<html><head></head><body><section data-pdf-bookmark="Chapter 11. Working with Dirty Data" data-type="chapter" epub:type="chapter"><div class="chapter" id="c-11">&#13;
<h1><span class="label">Chapter 11. </span>Working with Dirty Data</h1>&#13;
&#13;
<p>So far in this book, I’ve ignored the problem of badly formatted data by using generally well-formatted data sources, dropping data entirely if it deviated from what was expected. But, in web scraping, you often can’t be too picky about where you get your data, or what it looks like.</p>&#13;
&#13;
<p>Because of errant punctuation, inconsistent capitalization, line breaks, and misspellings, dirty data can be a big problem on the web. This chapter covers a few tools and techniques to help you prevent the problem at the source by changing the way you write code and cleaning the data after it’s in the database.</p>&#13;
&#13;
<p>This is the chapter where web scraping intersects with its close relative, data science. While the job title of “data scientist” might conjure mental images of cutting-edge programming techniques and advanced mathematics, the truth is that a lot of it is grunt work. Someone has to clean and normalize these millions of records before they can be used to build a machine learning model, and that person is the data <span class="keep-together">scientist.</span></p>&#13;
&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id622">&#13;
<h1>Extract, Transform, Load</h1>&#13;
&#13;
<p>Extract, Transform, Load (ETL) is a concept <a contenteditable="false" data-primary="ETL (extract, transform, and load)" data-type="indexterm" id="id623"/><a contenteditable="false" data-primary="data extraction, ETL (extract, transform, load)" data-type="indexterm" id="id624"/>used frequently in programming, particularly in industry. Many companies concern themselves with the business of moving data from one place to another place, transforming the data as they go. Data is extracted from a source, transformed through some business process, and loaded into another source.</p>&#13;
&#13;
<p>Most of this book is involved with the “E” of ETL. That is, it focuses on extracting data from sources around the web. <a data-type="xref" data-xrefstyle="chap-num-title" href="ch09.html#c-9">Chapter 9, “Storing Data”</a> covers the “L”—loading that data into databases.</p>&#13;
&#13;
<p>This chapter, along with <a data-type="xref" data-xrefstyle="chap-num-title" href="ch12.html#c-12">Chapter 12, “Reading and Writing Natural Languages”</a>, focuses on the “T,” or the transformation of data.</p>&#13;
&#13;
<p>Mentally breaking your data applications into the three stages, Extract, Transform, and Load, can help you organize your processes and tools to create clean software structures.</p>&#13;
</div></aside>&#13;
&#13;
<section data-pdf-bookmark="Cleaning Text" data-type="sect1"><div class="sect1" id="id67">&#13;
<h1>Cleaning Text</h1>&#13;
&#13;
<p>Python is a programming language that <a contenteditable="false" data-primary="cleaning text" data-type="indexterm" id="clntxt"/>lends itself very well to text processing. It’s easy to write clean, functional, modular code to do even complex text processing projects. With the <a contenteditable="false" data-primary="Python" data-secondary="Wikipedia article" data-type="indexterm" id="id625"/>following code, we can scrape text from the Wikipedia article on Python at <a href="http://en.wikipedia.org/wiki/Python_(programming_language)"><em>http://en.wikipedia.org/wiki/Python_(programming_language)</em></a>:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="kn">from</code> <code class="nn">urllib.request</code> <code class="kn">import</code> <code class="n">urlopen</code>&#13;
<code class="kn">from</code> <code class="nn">bs4</code> <code class="kn">import</code> <code class="n">BeautifulSoup</code>&#13;
&#13;
<code class="n">url</code> <code class="o">=</code> <code class="s1">'http://en.wikipedia.org/wiki/Python_(programming_language)'</code>&#13;
<code class="n">html</code> <code class="o">=</code> <code class="n">urlopen</code><code class="p">(</code><code class="n">url</code><code class="p">)</code>&#13;
<code class="n">bs</code> <code class="o">=</code> <code class="n">BeautifulSoup</code><code class="p">(</code><code class="n">html</code><code class="p">,</code> <code class="s1">'html.parser'</code><code class="p">)</code>&#13;
<code class="n">content</code> <code class="o">=</code> <code class="n">bs</code><code class="o">.</code><code class="n">find</code><code class="p">(</code><code class="s1">'div'</code><code class="p">,</code> <code class="p">{</code><code class="s1">'id'</code><code class="p">:</code><code class="s1">'mw-content-text'</code><code class="p">})</code><code class="o">.</code><code class="n">find_all</code><code class="p">(</code><code class="s1">'p'</code><code class="p">)</code>&#13;
<code class="n">content</code> <code class="o">=</code> <code class="p">[</code><code class="n">p</code><code class="o">.</code><code class="n">get_text</code><code class="p">()</code> <code class="k">for</code> <code class="n">p</code> <code class="ow">in</code> <code class="n">content</code><code class="p">]</code>&#13;
</pre>&#13;
&#13;
<p>This content begins:</p>&#13;
&#13;
<pre>&#13;
Python is a high-level, general-purpose programming language. Its &#13;
design philosophy emphasizes code readability with the use of &#13;
significant indentation via the off-side rule.[33]&#13;
</pre>&#13;
&#13;
<p>We will perform several actions on this text:</p>&#13;
&#13;
<ul>&#13;
	<li>Remove citations, of the form “[123]”</li>&#13;
	<li>Remove newline characters</li>&#13;
	<li>Split the text into sentences</li>&#13;
	<li>Remove any parenthesized text containing an aside in the middle of a sentence</li>&#13;
	<li>Remove descriptions of illustrations not included in the text</li>&#13;
	<li>Make text lowercase</li>&#13;
	<li>Remove all punctuation</li>&#13;
</ul>&#13;
&#13;
<p>It’s important to note that these functions must be applied in a particular order. For instance, removing punctuation (including square brackets) would make it difficult to identify and remove citations later on. Removing punctuation and making all text lowercase would also make it impossible to split the text into sentences.</p>&#13;
&#13;
<p>The functions for removing newline characters <a contenteditable="false" data-primary="text" data-secondary="newline characters" data-type="indexterm" id="id626"/><a contenteditable="false" data-primary="text" data-secondary="lowercase, converting to" data-type="indexterm" id="id627"/><a contenteditable="false" data-primary="newline characters" data-type="indexterm" id="id628"/> and making the text lowercase are fairly straightforward:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="k">def</code> <code class="nf">replace_newlines</code><code class="p">(</code><code class="n">text</code><code class="p">):</code>&#13;
    <code class="k">return</code> <code class="n">text</code><code class="o">.</code><code class="n">replace</code><code class="p">(</code><code class="s1">'</code><code class="se">\n</code><code class="s1">'</code><code class="p">,</code> <code class="s1">' '</code><code class="p">)</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">make_lowercase</code><code class="p">(</code><code class="n">text</code><code class="p">):</code>&#13;
    <code class="k">return</code> <code class="n">text</code><code class="o">.</code><code class="n">lower</code><code class="p">()</code>&#13;
</pre>&#13;
&#13;
<p>Here the newlines are replaced with a space character (“ ”) rather than removed altogether to avoid text like this:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">It</code> <code class="n">uses</code> <code class="n">dynamic</code> <code class="n">name</code> <code class="n">resolution</code> <code class="p">(</code><code class="n">late</code> <code class="n">binding</code><code class="p">),</code> <code class="n">which</code> <code class="n">binds</code> <code class="n">method</code> &#13;
<code class="ow">and</code> <code class="n">variable</code> <code class="n">names</code> <code class="n">during</code> <code class="n">program</code> <code class="n">execution</code><code class="o">.</code>&#13;
<code class="n">Its</code> <code class="n">design</code> <code class="n">offers</code> <code class="n">some</code> <code class="n">support</code> <code class="k">for</code> <code class="n">functional</code> <code class="n">programming</code> &#13;
<code class="ow">in</code> <code class="n">the</code> <code class="n">Lisp</code> <code class="n">tradition</code><code class="o">.</code></pre>&#13;
&#13;
<p>being turned into text like this:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">It</code> <code class="n">uses</code> <code class="n">dynamic</code> <code class="n">name</code> <code class="n">resolution</code> <code class="p">(</code><code class="n">late</code> <code class="n">binding</code><code class="p">),</code> <code class="n">which</code> <code class="n">binds</code> <code class="n">method</code>&#13;
<code class="ow">and</code> <code class="n">variable</code> <code class="n">names</code> <code class="n">during</code> <code class="n">program</code> <code class="n">execution</code><code class="o">.</code> <code class="n">Its</code> <code class="n">design</code> <code class="n">offers</code> <code class="n">some</code> &#13;
<code class="n">support</code> <code class="k">for</code> <code class="n">functional</code> <code class="n">programming</code> <code class="ow">in</code> <code class="n">the</code> <code class="n">Lisp</code> <code class="n">tradition</code><code class="o">.</code></pre>&#13;
&#13;
<p>Inserting the space ensures that all sentences still get a space between them.</p>&#13;
&#13;
<p>With this in mind, we can write the function for splitting sentences:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="k">def</code> <code class="nf">split_sentences</code><code class="p">(</code><code class="n">text</code><code class="p">):</code>&#13;
    <code class="k">return</code> <code class="p">[</code><code class="n">s</code><code class="o">.</code><code class="n">strip</code><code class="p">()</code> <code class="k">for</code> <code class="n">s</code> <code class="ow">in</code> <code class="n">text</code><code class="o">.</code><code class="n">split</code><code class="p">(</code><code class="s1">'. '</code><code class="p">)]</code></pre>&#13;
&#13;
<p>Rather than splitting simply on the period, we split on the period and a space. This prevents decimals, for instance in the ubiquitous “Python 2.5,” or code examples like:</p>&#13;
&#13;
<pre>&#13;
if (c = 1) { ...}</pre>&#13;
&#13;
<p>from being split erroneously into sentences. In addition, we want to make sure that any double-spaced or otherwise odd sentences are cleaned by stripping each leading or trailing whitespace using the <code>strip</code> function before returning.</p>&#13;
&#13;
<p>However, <code>split_sentences</code> can’t be called right away. Many sentences contain citations immediately after them:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">capable</code> <code class="n">of</code> <code class="n">exception</code> <code class="n">handling</code> <code class="ow">and</code> <code class="n">interfacing</code> <code class="k">with</code> <code class="n">the</code> <code class="n">Amoeba</code> &#13;
<code class="n">operating</code> <code class="n">system</code><code class="o">.</code><code class="p">[</code><code class="mi">13</code><code class="p">]</code> <code class="n">Its</code> <code class="n">implementation</code> <code class="n">began</code> <code class="ow">in</code> <code class="n">December</code> <code class="mf">1989.</code><code class="p">[</code><code class="mi">44</code><code class="p">]</code>&#13;
</pre>&#13;
&#13;
<p>The function for removing citations can be written like this:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="kn">import</code> <code class="nn">re</code>&#13;
&#13;
<code class="n">CITATION_REGEX</code> <code class="o">=</code> <code class="n">re</code><code class="o">.</code><code class="n">compile</code><code class="p">(</code><code class="s1">'\[[0-9]*\]'</code><code class="p">)</code>&#13;
<code class="k">def</code> <code class="nf">strip_citations</code><code class="p">(</code><code class="n">text</code><code class="p">):</code>&#13;
    <code class="k">return</code> <code class="n">re</code><code class="o">.</code><code class="n">sub</code><code class="p">(</code><code class="n">CITATION_REGEX</code><code class="p">,</code> <code class="s1">''</code><code class="p">,</code> <code class="n">text</code><code class="p">)</code>&#13;
</pre>&#13;
&#13;
<p>The variable name <code>CITATION_REGEX</code> is written in uppercase, indicating that it’s a constant, and pre-compiled outside of the function itself. The function could also be written as:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="k">def</code> <code class="nf">strip_citations</code><code class="p">(</code><code class="n">text</code><code class="p">):</code>&#13;
    <code class="k">return</code> <code class="n">re</code><code class="o">.</code><code class="n">sub</code><code class="p">(</code><code class="sa">r</code><code class="s1">'\[[0-9]*\]'</code><code class="p">,</code> <code class="s1">''</code><code class="p">,</code> <code class="n">text</code><code class="p">)</code></pre>&#13;
&#13;
<p>However, this forces Python to recompile this regular expression every time the function is run (which could be thousands or millions of times, depending on the project), rather than having it pre-compiled and ready to go. While the speed of the program is not necessarily a significant bottleneck in web scraping, pre-compiling regular expressions outside of functions is easy to do and allows you to document the code through an appropriate variable name for the regular expression.</p>&#13;
&#13;
<p>Removing parenthesized text, such as:</p>&#13;
&#13;
<pre>&#13;
all versions of Python (including 2.7[56]) had security issues</pre>&#13;
&#13;
<p>and:</p>&#13;
&#13;
<pre>&#13;
dynamic name resolution (late binding), which binds method</pre>&#13;
&#13;
<p>is a similar pattern to removing the citations. A good first approach might be:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">PARENS_REGEX</code> <code class="o">=</code> <code class="n">re</code><code class="o">.</code><code class="n">compile</code><code class="p">(</code><code class="s1">'\(.*\)'</code><code class="p">)</code>&#13;
<code class="k">def</code> <code class="nf">remove_parentheses</code><code class="p">(</code><code class="n">text</code><code class="p">):</code>&#13;
    <code class="k">return</code> <code class="n">re</code><code class="o">.</code><code class="n">sub</code><code class="p">(</code><code class="n">PARENS_REGEX</code><code class="p">,</code> <code class="s1">''</code><code class="p">,</code> <code class="n">text</code><code class="p">)</code></pre>&#13;
&#13;
<p>Indeed, this does remove parenthesized <a contenteditable="false" data-primary="text" data-secondary="parenthesized" data-type="indexterm" id="id629"/>text in the examples above, but it also removes anything in parentheses from sections like:</p>&#13;
&#13;
<pre>&#13;
This has the advantage of avoiding a classic C error of mistaking &#13;
an assignment operator = for an equality operator == in conditions:&#13;
if (c = 1) { ...} is syntactically valid</pre>&#13;
&#13;
<p>In addition, it presents a danger if there are unmatched parentheses in the text. An opening parenthesis may cause large sections of text to be removed the next time any sort of closing parenthesis is found.</p>&#13;
&#13;
<p>To solve this, we can examine the types of characters generally seen in parenthesized text, look only for them, and limit the length of that parenthesized text:</p>&#13;
&#13;
<pre>&#13;
PARENS_REGEX = re.compile('\([a-z A-Z \+\.,\-]{0,100}\)')&#13;
def remove_parentheses(text):&#13;
    return re.sub(PARENS_REGEX, '', text)</pre>&#13;
&#13;
<p>Occasionally, descriptions of illustrations not extracted in the text might be present. For example:</p>&#13;
&#13;
<pre>&#13;
Hello world program:</pre>&#13;
&#13;
<p>which precedes a block of code not extracted in text.</p>&#13;
&#13;
<p>These descriptions are generally short, start with a newline, contain only letters, and end with a colon. We can remove them with a regular expression:</p>&#13;
&#13;
<pre>&#13;
DESCRIPTION_REGEX = re.compile('\n[a-z A-Z]*:')&#13;
def remove_descriptions(text):&#13;
    return re.sub(DESCRIPTION_REGEX, '', text)</pre>&#13;
&#13;
<p>At this point, we can remove the punctuation. Because so many of the previous steps depend on punctuation to be present in order to identify what text to keep and what to remove, stripping the punctuation is generally one of the last steps of any text cleaning task.</p>&#13;
&#13;
<p><a href="https://docs.python.org/3/library/string.html">Python’s string module</a> contains many handy sets of characters, one of which is <code>string.punctuation</code>. This is a set of all the ASCII punctuation:</p>&#13;
&#13;
<pre>&#13;
&gt;&gt;&gt; import string&#13;
&gt;&gt;&gt; string.punctuation&#13;
'!"#$%&amp;\'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~'&#13;
</pre>&#13;
&#13;
<p>We can take this string containing all ASCII punctuation and turn it into a regular expression using <code>re.escape</code> (which escapes any reserved regular expression symbols) and joining everything with a <code>|</code> character:</p>&#13;
&#13;
<pre>&#13;
puncts = [re.escape(c) for c in string.punctuation]&#13;
PUNCTUATION_REGEX = re.compile('|'.join(puncts))&#13;
&#13;
def remove_punctuation(text):&#13;
    return re.sub(PUNCTUATION_REGEX, '', text)&#13;
</pre>&#13;
&#13;
<p>It’s common, with all this string manipulation, for unicode characters to become misrepresented in the string. Especially common is the unicode “nonbreaking space” which is represented by a <code>&amp;nbsp;</code> in HTML and can be found frequently in text on the web. This can be seen in our Wikipedia text printed out as <code>\xa0</code>:</p>&#13;
&#13;
<pre>&#13;
 python\xa020 was released...</pre>&#13;
&#13;
<p>Regardless of which strange characters you encounter, you can fix them with Python’s <code>unicodedata</code> <a contenteditable="false" data-primary="Python" data-secondary="unicodedata" data-type="indexterm" id="id630"/><a contenteditable="false" data-primary="unicodedata" data-type="indexterm" id="id631"/>package. Normalizing unicode characters will be the final step in cleaning the text:</p>&#13;
&#13;
<pre>&#13;
def normalize(text):&#13;
    return unicodedata.normalize('NFKD', text)</pre>&#13;
&#13;
<p>At this point, you have a set of short, well-organized functions that perform a variety of text cleaning operations. Because we might want to add, remove, or change the order that the functions are called in, we can add these functions to a list and call them in a general way on our text:</p>&#13;
&#13;
<pre>&#13;
text_operations = [&#13;
    strip_citations,&#13;
    remove_parentheses,&#13;
    remove_descriptions,&#13;
    replace_newlines,&#13;
    split_sentences,&#13;
    make_lowercase,&#13;
    remove_punctuation,&#13;
    normalize&#13;
]&#13;
&#13;
cleaned = content&#13;
for op in text_operations:&#13;
    if type(cleaned) == list:&#13;
        cleaned = [op(c) for c in cleaned]&#13;
    else:&#13;
        cleaned = op(cleaned)&#13;
        &#13;
print(cleaned)&#13;
</pre>&#13;
&#13;
<p>Although Python is not generally thought of as a functional language like JavaScript or—as a more extreme example—Haskell, it’s useful to remember that functions can be passed around as variables in <a contenteditable="false" data-primary="cleaning text" data-startref="clntxt" data-type="indexterm" id="id632"/>situations like this!</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Working with Normalized Text" data-type="sect1"><div class="sect1" id="id68">&#13;
<h1>Working with Normalized Text</h1>&#13;
&#13;
<p>Once you’ve cleaned the text, what do you do <a contenteditable="false" data-primary="text" data-secondary="normalized" data-type="indexterm" id="txtnmz"/><a contenteditable="false" data-primary="normalized text" data-type="indexterm" id="mnlzxt"/>with it? One common technique is to break it up into smaller pieces of text that can be more easily quantified and analyzed. Computational linguists call these <em>n-grams</em>, where n represents the number of words in each piece of text. In this example, we’ll be working specifically with 2-grams, or 2 word pieces of text.</p>&#13;
&#13;
<p>N-grams typically do not span sentences. So we can use the text obtained in the previous section, split into sentences, and create 2-grams with each sentence in the list.</p>&#13;
&#13;
<p>A Python function for breaking <a contenteditable="false" data-primary="text" data-secondary="n-grams" data-type="indexterm" id="id633"/><a contenteditable="false" data-primary="n-grams" data-type="indexterm" id="id634"/>text into n-grams can be written as:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="k">def</code> <code class="nf">getNgrams</code><code class="p">(</code><code class="n">text</code><code class="p">,</code> <code class="n">n</code><code class="p">):</code>&#13;
    <code class="n">text</code> <code class="o">=</code> <code class="n">text</code><code class="o">.</code><code class="n">split</code><code class="p">(</code><code class="s1">' '</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="p">[</code><code class="n">text</code><code class="p">[</code><code class="n">i</code><code class="p">:</code><code class="n">i</code><code class="o">+</code><code class="n">n</code><code class="p">]</code> <code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="n">text</code><code class="p">)</code><code class="o">-</code><code class="n">n</code><code class="o">+</code><code class="mi">1</code><code class="p">)]</code>&#13;
&#13;
<code class="n">getNgrams</code><code class="p">(</code><code class="s1">'web scraping with python'</code><code class="p">,</code> <code class="mi">2</code><code class="p">)</code>&#13;
</pre>&#13;
&#13;
<p>The output of this function on the text “web scraping with python” is:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="p">[[</code><code class="s1">'web'</code><code class="p">,</code> <code class="s1">'scraping'</code><code class="p">],</code> <code class="p">[</code><code class="s1">'scraping'</code><code class="p">,</code> <code class="s1">'with'</code><code class="p">],</code> <code class="p">[</code><code class="s1">'with'</code><code class="p">,</code> <code class="s1">'python'</code><code class="p">]]</code></pre>&#13;
&#13;
<p>One problem with this function is that it returns many duplicate 2-grams. Every 2-gram it encounters gets added to the list, with no record of its frequency. Not only is it interesting to record the frequency of these 2-grams, rather than just their existence, but it can be useful in charting the effects of changes to the cleaning and data normalization algorithms. If data is normalized successfully, the total number of unique n-grams will be reduced, while the total count of n-grams found (i.e., the number of unique or nonunique items identified as n-grams) will not be reduced. In other words, there will be fewer “buckets” for the same number of n-grams.</p>&#13;
&#13;
<p>You can do this by modifying the code that collects the n-grams to add them to a <code>Counter</code> object, rather than a list. Here, the <code>cleaned</code> variable is our list of cleaned sentences obtained in the previous section:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="kn">from</code> <code class="nn">collections</code> <code class="kn">import</code> <code class="n">Counter</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">getNgrams</code><code class="p">(</code><code class="n">text</code><code class="p">,</code> <code class="n">n</code><code class="p">):</code>&#13;
    <code class="n">text</code> <code class="o">=</code> <code class="n">text</code><code class="o">.</code><code class="n">split</code><code class="p">(</code><code class="s1">' '</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="p">[</code><code class="s1">' '</code><code class="o">.</code><code class="n">join</code><code class="p">(</code><code class="n">text</code><code class="p">[</code><code class="n">i</code><code class="p">:</code><code class="n">i</code><code class="o">+</code><code class="n">n</code><code class="p">])</code> <code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="n">text</code><code class="p">)</code><code class="o">-</code><code class="n">n</code><code class="o">+</code><code class="mi">1</code><code class="p">)]</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">countNGramsFromSentences</code><code class="p">(</code><code class="n">sentences</code><code class="p">,</code> <code class="n">n</code><code class="p">):</code>&#13;
    <code class="n">counts</code> <code class="o">=</code> <code class="n">Counter</code><code class="p">()</code>&#13;
    <code class="k">for</code> <code class="n">sentence</code> <code class="ow">in</code> <code class="n">sentences</code><code class="p">:</code>&#13;
        <code class="n">counts</code><code class="o">.</code><code class="n">update</code><code class="p">(</code><code class="n">getNgrams</code><code class="p">(</code><code class="n">sentence</code><code class="p">,</code> <code class="n">n</code><code class="p">))</code>&#13;
    <code class="k">return</code> <code class="n">counts</code>&#13;
&#13;
</pre>&#13;
&#13;
<p>There are many other ways to create counts of n-grams, such as adding them to a dictionary object in which the value of the list points at a count for the number of times it was seen. That has a disadvantage in that it requires a bit more management and makes sorting tricky.</p>&#13;
&#13;
<p>However, using a <code>Counter</code> object also has a disadvantage: it cannot store lists, because lists are unhashable. Converting these to tuples (which are hashable) would work well and make sense in this context, as would joining the lists to strings. In this case, I’ve chosen to convert them to strings by using a <code>' '.join(text[i:i+n])</code> inside the list comprehension for each n-gram.</p>&#13;
&#13;
<p>We can call the <code>countNGramsFromSentences</code> function with our cleaned text from the previous section and use the <code>most_common</code> function to get a list of 2-grams sorted by the most common ones first:</p>&#13;
&#13;
<pre data-code-language="text" data-type="programlisting">&#13;
counts = countNGramsFromSentences(cleaned, 2)&#13;
print(counts.most_common())</pre>&#13;
&#13;
<p>Here are the results:</p>&#13;
&#13;
<pre data-code-language="text" data-type="programlisting">&#13;
[('in the', 19), ('of the', 19), ('such as', 18), ('as a', 14),&#13;
('in python', 12), ('python is', 9), ('of python', 9),&#13;
('the python', 9)...&#13;
</pre>&#13;
&#13;
<p>As of this writing, there are 2,814 unique 2-grams, with the most popular ones containing word combinations that are very common in any English text, such as “such as.” Depending on your project, you may want to remove n-grams like this that do not have much relevance to the page’s actual subject matter. Doing this is a topic for <a data-type="xref" href="ch12.html#c-12">Chapter 12</a>.</p>&#13;
&#13;
<p>Beyond this, it’s usually good to stop and consider how much computing power you want to expend normalizing data. There are a number of situations in which different spellings of words are equivalent, but to resolve this equivalency, you need to run a check on every single word to see whether it matches any of your preprogrammed equivalencies.</p>&#13;
&#13;
<p>For example, “Python 1st” and “Python first” both appear in the list of 2-grams. However, to make a blanket rule that says, “All first, second, third, etc., will be resolved to 1st, 2nd, 3rd, etc. (or vice versa)” would result in an additional 10 or so checks per word.</p>&#13;
&#13;
<p>Similarly, the inconsistent use of hyphens (“co-ordinated” versus “coordinated”), misspellings, and other natural language incongruities will affect the groupings of <span class="keep-together">n-grams</span> and might muddy the results of the output if the incongruities are common enough.</p>&#13;
&#13;
<p>One solution, in the case of hyphenated words, might be to remove hyphens entirely and treat the word as a single string, which would require only a single operation. However, this would also mean that hyphenated phrases (an all-too-common occurrence) will be treated  as a single word. Going the other route and treating hyphens as spaces <a contenteditable="false" data-primary="text" data-secondary="normalized" data-startref="txtnmz" data-type="indexterm" id="id635"/><a contenteditable="false" data-primary="normalized text" data-startref="mnlzxt" data-type="indexterm" id="id636"/>might be a better option. Just be prepared for the occasional “co ordinated” and “ordinated attack” to slip in!</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Cleaning Data with Pandas" data-type="sect1"><div class="sect1" id="id69">&#13;
<h1>Cleaning Data with Pandas</h1>&#13;
&#13;
<p>This section is not about the endearing <a contenteditable="false" data-primary="cleaning data, pandas" data-type="indexterm" id="cldpda"/><a contenteditable="false" data-primary="pandas" data-type="indexterm" id="id637"/>bears native to China, but the Python data analysis package: <em>pandas</em>. If you’ve done any work with data science and machine learning, you’ve likely encountered it before, as it is ubiquitous in the field.</p>&#13;
&#13;
<p>Pandas was created as a solo project for work in 2008 by programmer Wes McKinney. In 2009, he made the project public and it quickly took off. The package filled a particular niche in data wrangling. It functioned much like a spreadsheet in some ways, with pretty printing and easy reshaping pivot functions. It also harnessed the power and flexibility of the underlying Python code and data science libraries that it was built on.</p>&#13;
&#13;
<p>Some might recommend the <a href="https://www.anaconda.com">Anaconda package management system</a> when installing data science libraries like numpy, pandas, and scikit-learn. Although there is excellent support for these packages with Anaconda, pandas is also straightforward to install with pip:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">pip</code> <code class="n">install</code> <code class="n">pandas</code></pre>&#13;
&#13;
<p>The package is, by <a contenteditable="false" data-primary="pandas" data-secondary="pip (package installer for python)" data-type="indexterm" id="id638"/><a contenteditable="false" data-primary="pandas" data-secondary="installing" data-type="indexterm" id="id639"/><a contenteditable="false" data-primary="pip (package installer for python)" data-secondary="pandas" data-type="indexterm" id="id640"/>convention, imported as <code>pd</code> rather than the full name <code>pandas</code>:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="kn">import</code> <code class="nn">pandas</code> <code class="k">as</code> <code class="nn">pd</code></pre>&#13;
&#13;
<div data-type="warning" epub:type="warning">&#13;
<h1>Don’t Import Individual Methods and Classes from Pandas</h1>&#13;
&#13;
<p>The pandas ecosystem is large, complex, <a contenteditable="false" data-primary="pandas" data-secondary="importing as pd" data-type="indexterm" id="id641"/>and often overlaps the namespace of built-in Python functions and packages. For this reason, pandas functions should almost always be referenced starting from <code>pd</code> rather than importing them directly, such as:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="kn">from</code> <code class="nn">pandas</code> <code class="kn">import</code> <code class="n">array</code>&#13;
<code class="kn">from</code> <code class="nn">pandas.DataFrame</code> <code class="kn">import</code> <code class="nb">min</code>&#13;
</pre>&#13;
&#13;
<p>In these cases, the above imports might cause confusion with the built-in Python <code>array</code> module and <code>min</code> function.</p>&#13;
&#13;
<p>One accepted exception may be for the DataFrame class, imported as:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="kn">from</code> <code class="nn">pandas</code> <code class="kn">import</code> <code class="n">DataFrame</code></pre>&#13;
&#13;
<p>In this case, <code>DataFrame</code> is not found in the Python standard library and is easily-recognized as <a contenteditable="false" data-primary="pandas" data-secondary="DataFrame" data-type="indexterm" id="pddfm"/><a contenteditable="false" data-primary="DataFrames, pandas and" data-type="indexterm" id="dfrpds"/>a pandas class. However, this is the one exception you are likely to see, and many still prefer to reference the DataFrame class as <code>pd.DataFrame</code>. Because the library is so-often referenced in code, this is one reason why the convention is to import pandas as <code>pd</code> rather than the full name!</p>&#13;
</div>&#13;
&#13;
<p>The object you will be working with most often in the pandas library is the DataFrame. These are similar to spreadsheets or tables, and can be constructed in a variety of ways. For example:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">df</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">DataFrame</code><code class="p">([[</code><code class="s1">'a'</code><code class="p">,</code> <code class="mi">1</code><code class="p">],</code> <code class="p">[</code><code class="s1">'b'</code><code class="p">,</code> <code class="mi">2</code><code class="p">],</code> <code class="p">[</code><code class="s1">'c'</code><code class="p">,</code> <code class="mi">3</code><code class="p">]])</code>&#13;
<code class="n">df</code><code class="o">.</code><code class="n">head</code><code class="p">()</code>&#13;
</pre>&#13;
&#13;
<p>The <code>head</code> method produces a pretty-printed DataFrame of the data and its columns and headers, as shown in <a data-type="xref" href="#fig1101">Figure 11-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig1101"><img class="iimageswswp_1101_replacementpng fse fs" src="assets/wsp3_1101.png"/>&#13;
<h6><span class="label">Figure 11-1. </span>A simple pandas DataFrame</h6>&#13;
</div></figure>&#13;
&#13;
<p>DataFrames are required to always have an index and column names. If those are not provided, as in this case, where only a simple matrix of data is supplied, they will be automatically generated. The DataFrame’s index (0, 1, 2) can be seen in bold to the left, and the column names (0, 1) are at the top in bold.</p>&#13;
&#13;
<p>Rather than working with raw Python lists and dictionaries, DataFrames provide an enormous variety convenient helper functions to sort, clean, manipulate, arrange, and display your data. If you are working with larger data sets, they also provide a speed and memory <a contenteditable="false" data-primary="pandas" data-secondary="DataFrame" data-startref="pddfm" data-type="indexterm" id="id642"/><a contenteditable="false" data-primary="DataFrames, pandas and" data-startref="dfrpds" data-type="indexterm" id="id643"/>advantage over lists and dictionaries.</p>&#13;
&#13;
<section data-pdf-bookmark="Cleaning" data-type="sect2"><div class="sect2" id="id152">&#13;
<h2>Cleaning</h2>&#13;
&#13;
<p>In the following examples, you’ll <a contenteditable="false" data-primary="pandas" data-secondary="cleaning data" data-type="indexterm" id="pdcgd"/>use data scraped from <a href="https://en.wikipedia.org/wiki/List_of_countries_with_McDonald%27s_restaurants">Wikipedia’s List of <span class="keep-together">Countries with </span> McDonald’s Restaurants</a>. We can use the <code>pd.read_csv</code> function to read data directly from a CSV file to a dataframe:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">df</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">read_csv</code><code class="p">(</code><code class="s1">'countries.csv'</code><code class="p">)</code>&#13;
<code class="n">df</code><code class="o">.</code><code class="n">head</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code></pre>&#13;
&#13;
<p>Optionally, an integer can be passed to the <code>head</code> method to print out a number of rows other than the default of 5. This gives a nice view of the CSV data scraped from earlier, as shown in <a data-type="xref" href="#1102">Figure 11-2</a>.</p>&#13;
&#13;
<figure><div class="figure" id="1102"><img class="iimageswswp_1102_replacementpng" src="assets/wsp3_1102.png"/>&#13;
<h6><span class="label">Figure 11-2. </span>Displaying a list of countries with lds </h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">The column names here are somewhat wordy and not well-formatted. We can rename them using the <code>rename</code> method:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">df</code><code class="o">.</code><code class="n">rename</code><code class="p">(</code><code class="n">columns</code><code class="o">=</code><code class="p">{</code>&#13;
    <code class="s1">'#'</code><code class="p">:</code> <code class="s1">'Order'</code><code class="p">,</code>&#13;
    <code class="s1">'Country/territory'</code><code class="p">:</code> <code class="s1">'Country'</code><code class="p">,</code>&#13;
    <code class="s1">'Date of first store'</code><code class="p">:</code> <code class="s1">'Date'</code><code class="p">,</code>&#13;
    <code class="s1">'First outlet location'</code><code class="p">:</code> <code class="s1">'Location'</code><code class="p">,</code>&#13;
    <code class="s1">'Max. no. ofoperatingoutlets'</code><code class="p">:</code> <code class="s1">'Outlets'</code>    &#13;
<code class="p">},</code> <code class="n">inplace</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code>&#13;
</pre>&#13;
&#13;
<p>Here, we pass in a dictionary to the <code>columns</code> keyword argument, where the keys are the original column names and the value is the new column name. The boolean argument <code>inplace</code> means that the columns are renamed in-place in the original DataFrame, rather than a new DataFrame being returned.</p>&#13;
&#13;
<p>Next, we can isolate only the columns that we want to work with by passing in a list of those column names to a sort of slicing syntax using <code>[]</code> brackets:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">df</code> <code class="o">=</code> <code class="n">df</code><code class="p">[[</code><code class="s1">'Order'</code><code class="p">,</code> <code class="s1">'Country'</code><code class="p">,</code> <code class="s1">'Date'</code><code class="p">,</code> <code class="s1">'Location'</code><code class="p">,</code> <code class="s1">'Outlets'</code><code class="p">]]</code></pre>&#13;
&#13;
<p>Now that we have the relabeled DataFrame columns we want, we can look at the data. There are a few things we will want to fix up. First, the dates in the “Date of first store” or “Date” column are usually well-formatted, but they also contain extra text or even other dates. As a simple strategy, we may decide to keep the first thing that matches the “date” format and discard the rest.</p>&#13;
&#13;
<p>Functions can be applied to an entire column in a DataFrame by first selecting that column using the same “slicing” syntax used above. A single selected column a pandas <code>Series</code> instance. The <code>Series</code> class has an <code>apply</code> method which applies a single function to each value in the Series:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="kn">import</code> <code class="nn">re</code>&#13;
&#13;
<code class="n">date_regex</code> <code class="o">=</code> <code class="n">re</code><code class="o">.</code><code class="n">compile</code><code class="p">(</code><code class="s1">'[A-Z][a-z]+ [0-9]{1,2}, [0-9]</code><code class="si">{4}</code><code class="s1">'</code><code class="p">)</code>&#13;
<code class="n">df</code><code class="p">[</code><code class="s1">'Date'</code><code class="p">]</code> <code class="o">=</code> <code class="n">df</code><code class="p">[</code><code class="s1">'Date'</code><code class="p">]</code><code class="o">.</code><code class="n">apply</code><code class="p">(</code><code class="k">lambda</code> <code class="n">d</code><code class="p">:</code> <code class="n">date_regex</code><code class="o">.</code><code class="n">findall</code><code class="p">(</code><code class="n">d</code><code class="p">)[</code><code class="mi">0</code><code class="p">])</code></pre>&#13;
&#13;
<p>Here, I am using a lambda operator to apply a function that <span class="keep-together">gets all</span> <code>date_regex</code> matches and returns the first one as the date.</p>&#13;
&#13;
<p>After cleaning, these dates can be converted to actual pandas datetime values using the <code>to_datetime</code> function:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">df</code><code class="p">[</code><code class="s1">'Date'</code><code class="p">]</code> <code class="o">=</code> <code class="n">pd</code><code class="o">.</code><code class="n">to_datetime</code><code class="p">(</code><code class="n">df</code><code class="p">[</code><code class="s1">'Date'</code><code class="p">])</code></pre>&#13;
&#13;
<p>Often, there is a delicate balance between the fast and efficient production of “clean” data, and the preservation of completely accurate and nuanced data. For instance, our date cleaning reduced the following text in the United Kingdom row:  "<em>England: November 13, 1974[21] Wales: December 3, 1984 Scotland: November 23, 1987[22] Northern Ireland: October 12, 1991</em>" into the single date: "<em>1974-11-13</em>“.</p>&#13;
&#13;
<p>Technically, this is correct. If the country of the United Kingdom as a whole is considered, then 1974-11-13 is the first date a McDonald’s appeared in it. However, it is simply happenstance that the dates were written in the cell in chronological order, and that we decided to take the first one, and also that the earliest date was the right one to choose. One might imagine many other circumstances where we might not be so lucky.</p>&#13;
&#13;
<p>In some cases, you may do a survey of the data and decide that your chosen cleaning method is good enough. Perhaps it is correct in most of the cases you look at. Perhaps it’s incorrect in one direction half the time, incorrect in the other direction the other half of the time, and things balance out for your purposes over large datasets. Or you may decide you need another method to clean or capture the data more accurately.</p>&#13;
&#13;
<p>The “Outlets” column of the dataset presents similar challenges. This column contains text such as "<em>13,515[10][failed verification][11]</em>" and "<em> (excl. seasonal restaurants) 43 (including seasonal and mobile restaurants)</em>" which are not the clean integers that we might like for further analysis. Again, we can use a simple approach to get the first integer available in the dataset:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">int_regex</code> <code class="o">=</code> <code class="n">re</code><code class="o">.</code><code class="n">compile</code><code class="p">(</code><code class="s1">'[0-9,]+'</code><code class="p">)</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">str_to_int</code><code class="p">(</code><code class="n">s</code><code class="p">):</code>&#13;
    <code class="n">s</code> <code class="o">=</code> <code class="n">int_regex</code><code class="o">.</code><code class="n">findall</code><code class="p">(</code><code class="n">s</code><code class="p">)[</code><code class="mi">0</code><code class="p">]</code>&#13;
    <code class="n">s</code> <code class="o">=</code> <code class="n">s</code><code class="o">.</code><code class="n">replace</code><code class="p">(</code><code class="s1">','</code><code class="p">,</code><code class="s1">''</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="nb">int</code><code class="p">(</code><code class="n">s</code><code class="p">)</code>&#13;
&#13;
<code class="n">df</code><code class="p">[</code><code class="s1">'Outlets'</code><code class="p">]</code> <code class="o">=</code> <code class="n">df</code><code class="p">[</code><code class="s1">'Outlets'</code><code class="p">]</code><code class="o">.</code><code class="n">apply</code><code class="p">(</code><code class="n">str_to_int</code><code class="p">)</code>&#13;
</pre>&#13;
&#13;
<p>Although this could also be written as a lambda function, you may consider breaking the logic out into a separate function if several steps are required. This also has the advantage of allowing you to easily print out any exceptions found during exploratory data processing, for further consideration:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="k">def</code> <code class="nf">str_to_int</code><code class="p">(</code><code class="n">s</code><code class="p">):</code>&#13;
    <code class="k">try</code><code class="p">:</code>&#13;
        <code class="n">s</code> <code class="o">=</code> <code class="n">int_regex</code><code class="o">.</code><code class="n">findall</code><code class="p">(</code><code class="n">s</code><code class="p">)[</code><code class="mi">0</code><code class="p">]</code>&#13;
        <code class="n">s</code> <code class="o">=</code> <code class="n">s</code><code class="o">.</code><code class="n">replace</code><code class="p">(</code><code class="s1">','</code><code class="p">,</code><code class="s1">''</code><code class="p">)</code>&#13;
    <code class="k">except</code><code class="p">:</code>&#13;
        <code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'Whoops: </code><code class="si">{</code><code class="n">s</code><code class="si">}</code><code class="s1">'</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="nb">int</code><code class="p">(</code><code class="n">s</code><code class="p">)</code></pre>&#13;
&#13;
<p>Finally, the DataFrame is cleaned and ready for further analysis, as shown in <a data-type="xref" href="#1103">Figure 11-3</a>.</p>&#13;
&#13;
<figure><div class="figure" id="1103"><img class="iimageswswp_1103_replacementpng" src="assets/wsp3_1103.png"/>&#13;
<h6><span class="label">Figure 11-3. </span>DataFrame with clean column headers, formatted dates, and integer data</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Indexing, Sorting, and Filtering" data-type="sect2"><div class="sect2" id="id70">&#13;
<h2 class="less_space">Indexing, Sorting, and Filtering</h2>&#13;
&#13;
<p>Remember from earlier that all DataFrames <a contenteditable="false" data-primary="indexing" data-type="indexterm" id="edxg"/><a contenteditable="false" data-primary="sorting" data-type="indexterm" id="strgn"/><a contenteditable="false" data-primary="filtering" data-type="indexterm" id="fltgr"/>have an index, whether you explicitly provide one or not. The McDonald’s data itself has a convenient index: the “Order” column, which signifies the chronological order in which the countries received their first McDonald’s restaurant. We can set the index using the <code>set_index</code> method:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">df</code><code class="o">.</code><code class="n">set_index</code><code class="p">([</code><code class="s1">'Order'</code><code class="p">],</code> <code class="n">inplace</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code>&#13;
<code class="n">df</code><code class="o">.</code><code class="n">head</code><code class="p">()</code></pre>&#13;
&#13;
<p>This discards the old index and moves the “Order” column into the index. Again, the <code>inplace</code> keyword argument means that this is done in-place on the original DataFrame, rather than have a copy of the DataFrame returned.</p>&#13;
&#13;
<p>The <code>sort_values</code> method can be used to sort data by one or many columns. The <code>inplace</code> keyword can be used in this method as well. However, because sorting is usually done for exploratory analysis and a permanent sort is not desired, it may be more useful to return the DataFrame for printing:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">df</code><code class="o">.</code><code class="n">sort_values</code><code class="p">(</code><code class="n">by</code><code class="o">=</code><code class="p">[</code><code class="s1">'Outlets'</code><code class="p">,</code> <code class="s1">'Date'</code><code class="p">],</code> <code class="n">ascending</code><code class="o">=</code><code class="kc">False</code><code class="p">)</code></pre>&#13;
&#13;
<p>This shows that the countries with the most McDonald’s are the United States, followed by China, and then Japan. France,  I’m sure it will be pleased to know, comes in fourth place, with the greatest number of McDonald’s of any European country!</p>&#13;
&#13;
<p> </p>&#13;
&#13;
<p>Filtering DataFrames is easy with the <code>query</code> method. It takes, as an argument, a query string:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">df</code><code class="o">.</code><code class="n">query</code><code class="p">(</code><code class="s1">'Outlets &lt; 100'</code><code class="p">)</code></pre>&#13;
&#13;
<p>This returns a DataFrame containing only records where the number of Outlets is less than 100. Most of the usual Python comparison <a contenteditable="false" data-primary="Python" data-secondary="comparison operators" data-type="indexterm" id="id644"/>operators work for DataFrame filtering using the query method, however this query language is not Python syntax. For instance, this will raise an Exception:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">df</code><code class="o">.</code><code class="n">query</code><code class="p">(</code><code class="s1">'Date is not None'</code><code class="p">)</code></pre>&#13;
&#13;
<p>If you want to test for the presence or absence of any empty values, the correct pandas way to do it is using the <code>isnull</code> and <code>notnull</code> query functions:</p>&#13;
&#13;
<pre class="pre" data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">df</code><code class="o">.</code><code class="n">query</code><code class="p">(</code><code class="s1">'Date.isnull()'</code><code class="p">)</code>&#13;
<code class="n">df</code><code class="o">.</code><code class="n">query</code><code class="p">(</code><code class="s1">'Date.notnull()'</code><code class="p">)</code>&#13;
</pre>&#13;
&#13;
<p>As you might guess, these statements capture both <code>None</code> values as well as <code>NaN</code> objects from the underlying numpy package that pandas is built on top of.</p>&#13;
&#13;
<p>If we want to add another logic clause, you can separate them by a single ampersand:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">df</code><code class="o">.</code><code class="n">query</code><code class="p">(</code><code class="s1">'Outlets &lt; 100 &amp; Date &lt; "01-06-1990"'</code><code class="p">)</code>&#13;
</pre>&#13;
&#13;
<p>An <code>or</code> statement is represented with a single pipe:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="n">df</code><code class="o">.</code><code class="n">query</code><code class="p">(</code><code class="s1">'Outlets &lt; 100 | Date &lt; "01-06-1990"'</code><code class="p">)</code></pre>&#13;
&#13;
<p>Note that the entire date (<code>"1990-01-01"</code>) is not required here, but will also work with just the year <code>"1990"</code>. Pandas is fairly forgiving about interpreting strings as dates, although you should always double-check that the data <a contenteditable="false" data-primary="indexing" data-startref="edxg" data-type="indexterm" id="id645"/><a contenteditable="false" data-primary="sorting" data-startref="strgn" data-type="indexterm" id="id646"/><a contenteditable="false" data-primary="filtering" data-startref="fltgr" data-type="indexterm" id="id647"/>coming back is what you expect it to be.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="More About Pandas" data-type="sect2"><div class="sect2" id="id71">&#13;
<h2>More About Pandas</h2>&#13;
&#13;
<p>I sincerely hope that your journey with pandas does not end here. We are fortunate that Wes McKinney, the creator and <a href="https://en.wikipedia.org/wiki/Benevolent_dictator_for_life">Benevolent Dictator for Life</a> of pandas, has also written a book about it: <a class="orm:hideurl" href="https://www.oreilly.com/library/view/python-for-data/9781098104023/"><em>Python for Data Analysis</em></a>.</p>&#13;
&#13;
<p>If you plan to do more with data science, or simply want a good tool to clean and analyze data occasionally in Python, I recommend <a contenteditable="false" data-primary="cleaning data, pandas" data-startref="cldpda" data-type="indexterm" id="id648"/><a contenteditable="false" data-primary="pandas" data-secondary="cleaning data" data-startref="pdcgd" data-type="indexterm" id="id649"/>that you check it out.</p>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section></body></html>