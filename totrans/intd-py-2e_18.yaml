- en: 'Chapter 16\. Data in a Box: Persistent Storage'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is a capital mistake to theorize before one has data.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Arthur Conan Doyle
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'An active program accesses data stored in Random Access Memory, or RAM. RAM
    is very fast, but it is expensive and requires a constant supply of power; if
    the power goes out, all the data in memory is lost. Disk drives are slower than
    RAM but have more capacity, cost less, and retain data even after someone trips
    over the power cord. Thus, a huge amount of effort in computer systems has been
    devoted to making the best trade-offs between storing data on disk and RAM. As
    programmers, we need *persistence*: storing and retrieving data using nonvolatile
    media such as disks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is all about the different flavors of data storage, each optimized
    for different purposes: flat files, structured files, and databases. File operations
    other than input and output are covered in [Chapter 14](ch14.html#ch_files).'
  prefs: []
  type: TYPE_NORMAL
- en: A *record* is a term for one chunk of related data, consisting of individual
    *fields*.
  prefs: []
  type: TYPE_NORMAL
- en: Flat Text Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest persistence is a plain old flat file. This works well if your data
    has a very simple structure and you exchange all of it between disk and memory.
    Plain text data might be suitable for this treatment.
  prefs: []
  type: TYPE_NORMAL
- en: Padded Text Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this format, each field in a record has a fixed width, and is padded (usually
    with space characters) to that width in the file, giving each line (record) the
    same width. A programmer can use `seek()` to jump around the file and only read
    and write the records and fields that are needed.
  prefs: []
  type: TYPE_NORMAL
- en: Tabular Text Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With simple text files, the only level of organization is the line. Sometimes,
    you want more structure than that. You might want to save data for your program
    to use later, or send data to another program.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many formats, and here’s how you can distinguish them:'
  prefs: []
  type: TYPE_NORMAL
- en: A *separator*, or *delimiter*, character like tab (`'\t'`), comma (`','`), or
    vertical bar (`'|'`). This is an example of the comma-separated values (CSV) format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''<''` and `''>''` around *tags*. Examples include XML and HTML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Punctuation. An example is JavaScript Object Notation (JSON).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indentation. An example is YAML (which is recursively defined as “YAML Ain’t
    Markup Language”).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Miscellaneous, such as configuration files for programs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these structured file formats can be read and written by at least one
    Python module.
  prefs: []
  type: TYPE_NORMAL
- en: CSV
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Delimited files are often used as an exchange format for spreadsheets and databases.
    You could read CSV files manually, a line at a time, splitting each line into
    fields at comma separators, and adding the results to data structures such as
    lists and dictionaries. But it’s better to use the standard `csv` module, because
    parsing these files can get more complicated than you think. Following are a few
    important characteristics to keep in mind when working with CSV:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some have alternate delimiters besides a comma: `''|''` and `''\t''` (tab)
    are common.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some have *escape sequences*. If the delimiter character can occur within a
    field, the entire field might be surrounded by quote characters or preceded by
    some escape character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files have different line-ending characters. Unix uses `'\n'`, Microsoft uses
    `'\r\n'`, and Apple used to use `'\r'` but now uses `'\n'`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first line may contain column names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, we see how to read and write a list of rows, each containing a list
    of columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates the file *villains* with these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we try to read it back in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We took advantage of the structure created by the `reader()` function. It created
    rows in the `cin` object that we could extract in a `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Using `reader()` and `writer()` with their default options, the columns are
    separated by commas and the rows by line feeds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data can be a list of dictionaries rather than a list of lists. Let’s read
    the *villains* file again, this time using the new `DictReader()` function and
    specifying the column names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: That `OrderedDict` is there for compatibility with versions of Python before
    3.6, when dictionaries kept their order by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s rewrite the CSV file by using the new `DictWriter()` function. We also
    call `writeheader()` to write an initial line of column names to the CSV file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: That creates a *villains.csv* file with a header line ([Example 16-1](#villains_csv)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-1\. villains.csv
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s read it back. By omitting the `fieldnames` argument in the `DictReader()`
    call, we tell it to use the values in the first line of the file (`first,last`)
    as column labels and matching dictionary keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Delimited files convey only two dimensions: rows (lines) and columns (fields
    within a line). If you want to exchange data structures among programs, you need
    a way to encode hierarchies, sequences, sets, and other structures as text.'
  prefs: []
  type: TYPE_NORMAL
- en: 'XML is a prominent *markup* format that does this. It uses *tags* to delimit
    data, as in this sample *menu.xml* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Following are a few important characteristics of XML:'
  prefs: []
  type: TYPE_NORMAL
- en: Tags begin with a `<` character. The tags in this sample were `menu`, `breakfast`,
    `lunch`, `dinner`, and `item`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whitespace is ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually a *start tag* such as `<menu>` is followed by other content and then
    a final matching *end tag* such as `</menu>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tags can *nest* within other tags to any level. In this example, `item` tags
    are children of the `breakfast`, `lunch`, and `dinner` tags; they, in turn, are
    children of `menu`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional *attributes* can occur within the start tag. In this example, `price`
    is an attribute of `item`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tags can contain *values*. In this example, each `item` has a value, such as
    `pancakes` for the second breakfast item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a tag named `thing` has no values or children, it can be expressed as the
    single tag by including a forward slash just before the closing angle bracket,
    such as `<thing/>`, rather than a start and end tag, like `<thing></thing>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The choice of where to put data—attributes, values, child tags—is somewhat arbitrary.
    For instance, we could have written the last `item` tag as `<item price="$8.00"
    food="spaghetti"/>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML is often used for data *feeds* and *messages* and has subformats like RSS
    and Atom. Some industries have many specialized XML formats, such as the [finance
    field](http://bit.ly/xml-finance).
  prefs: []
  type: TYPE_NORMAL
- en: XML’s über-flexibility has inspired multiple Python libraries that differ in
    approach and capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to parse XML in Python is by using the standard `ElementTree`
    module. Here’s a little program to parse the *menu.xml* file and print some tags
    and attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For each element in the nested lists, `tag` is the tag string and `attrib` is
    a dictionary of its attributes. `ElementTree` has many other ways of searching
    XML-derived data, modifying it, and even writing XML files. The `ElementTree`
    [documentation](http://bit.ly/elementtree) has the details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other standard Python XML libraries include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`xml.dom`'
  prefs: []
  type: TYPE_NORMAL
- en: The Document Object Model (DOM), familiar to JavaScript developers, represents
    web documents as hierarchical structures. This module loads the entire XML file
    into memory and lets you access all the pieces equally.
  prefs: []
  type: TYPE_NORMAL
- en: '`xml.sax`'
  prefs: []
  type: TYPE_NORMAL
- en: Simple API for XML, or SAX, parses XML on the fly, so it does not have to load
    everything into memory at once. Therefore, it can be a good choice if you need
    to process very large streams of XML.
  prefs: []
  type: TYPE_NORMAL
- en: An XML Security Note
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use all the formats described in this chapter to save objects to files
    and read them back again. It’s possible to exploit this process and cause security
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following XML snippet from the billion laughs Wikipedia page
    defines 10 nested entities, each expanding the lower level 10 times for a total
    expansion of one billion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The bad news: billion laughs would blow up all of the XML libraries mentioned
    in the previous sections. [Defused XML](https://bitbucket.org/tiran/defusedxml)
    lists this attack and others, along with the vulnerability of Python libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The link shows how to change the settings for many of the libraries to avoid
    these problems. Also, you can use the `defusedxml` library as a security frontend
    for the other libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The standard Python site also has its own page on [XML vulnerabilities](https://oreil.ly/Rnsiw).
  prefs: []
  type: TYPE_NORMAL
- en: HTML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gigagobs of data are saved as Hypertext Markup Language (HTML), the basic document
    format of the web. The problem is that much of it doesn’t follow the HTML rules,
    which can make it difficult to parse. HTML is a better display format than a data
    interchange format. Because this chapter is intended to describe fairly well-defined
    data formats, I’ve separated out the discussion about HTML to [Chapter 18](ch18.html#ch_web).
  prefs: []
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[JavaScript Object Notation (JSON)](http://www.json.org) has become a very
    popular data interchange format, beyond its JavaScript origins. The JSON format
    is a subset of JavaScript, and often legal Python syntax, as well. Its close fit
    to Python makes it a good choice for data interchange among programs. You’ll see
    many examples of JSON for web development in [Chapter 18](ch18.html#ch_web).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the variety of XML modules, there’s one main JSON module, with the unforgettable
    name `json`. This program encodes (dumps) data to a JSON string and decodes (loads)
    a JSON string back to data. In this next example, let’s build a Python data structure
    containing the data from the earlier XML example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, encode the data structure (`menu`) to a JSON string (`menu_json`) by
    using `dumps()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, let’s turn the JSON string `menu_json` back into a Python data structure
    (`menu2`) by using `loads()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`menu` and `menu2` are both dictionaries with the same keys and values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might get an exception while trying to encode or decode some objects, including
    objects such as `datetime` (covered in detail in [Chapter 13](ch13.html#ch_times)),
    as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This can happen because the JSON standard does not define date or time types;
    it expects you to define how to handle them. You could convert the `datetime`
    to something JSON understands, such as a string or an *epoch* value (see [Chapter 13](ch13.html#ch_times)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `datetime` value could occur in the middle of normally converted data
    types, it might be annoying to make these special conversions. You can modify
    how JSON is encoded by using inheritance, which is described in [Chapter 10](ch10.html#ch_objects).
    Python’s JSON [documentation](http://bit.ly/json-docs) gives an example of this
    for complex numbers, which also makes JSON play dead. Let’s modify it for `datetime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The new class `DTEncoder` is a subclass, or child class, of `JSONEncoder`. We
    need to override its only `default()` method to add `datetime` handling. Inheritance
    ensures that everything else will be handled by the parent class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `isinstance()` function checks whether the object `obj` is of the class
    `datetime.datetime`. Because everything in Python is an object, `isinstance()`
    works everywhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For JSON and other structured text formats, you can load from a file into data
    structures without knowing anything about the structures ahead of time. Then,
    you can walk through the structures by using `isinstance()` and type-appropriate
    methods to examine their values. For example, if one of the items is a dictionary,
    you can extract contents through `keys()`, `values()`, and `items()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After making you do it the hard way, it turns out that there’s an even easier
    way to convert `datetime` objects to JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: That `default=str` tells `json.dumps()` to apply the `str()` conversion function
    for data types that it doesn’t understand. This works because the definition of
    the `datetime.datetime` class includes a `__str__()` method.
  prefs: []
  type: TYPE_NORMAL
- en: YAML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to JSON, [YAML](http://www.yaml.org) has keys and values, but handles
    more data types such as dates and times. The standard Python library does not
    yet include YAML handling, so you need to install a third-party library named
    [`yaml`](http://pyyaml.org/wiki/PyYAML) to manipulate it. `((("dump() function")))((("load()
    function")))load()` converts a YAML string to Python data, whereas `dump()` does
    the opposite.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following YAML file, *mcintyre.yaml*, contains information on the Canadian
    poet James McIntyre, including two of his poems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Values such as `true`, `false`, `on`, and `off` are converted to Python booleans.
    Integers and strings are converted to their Python equivalents. Other syntax creates
    lists and dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The data structures that are created match those in the YAML file, which in
    this case are more than one level deep in places. You can get the title of the
    second poem with this dict/list/dict reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: PyYAML can load Python objects from strings, and this is dangerous. Use `safe_load()`
    instead of `load()` if you’re importing YAML that you don’t trust. Better yet,
    *always* use `safe_load()`. Read Ned Batchelder’s blog post [“War is Peace”](http://bit.ly/war-is-peace)
    for a description of how unprotected YAML loading compromised the Ruby on Rails
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: Tablib
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After reading all of the previous sections, there’s one third-party package
    that lets you import, export, and edit tabular data in CSV, JSON, *or* YAML format,^([1](ch16.html#idm45794977436440))
    as well as Microsoft Excel, Pandas DataFrame, and a few others. You install it
    with the familiar refrain (`pip install tablib`), and peek at the [docs](http://docs.python-tablib.org).
  prefs: []
  type: TYPE_NORMAL
- en: Pandas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is as good place as any to introduce [pandas](https://pandas.pydata.org)—a
    Python library for structured data. It’s an excellent tool for handling real-life
    data issues:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Read and write many text and binary file formats:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text, with fields separated by commas (CSV), tabs (TSV), or other characters
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed-width text
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Excel
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML tables
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: HDF5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: and [others](https://oreil.ly/EWlgS).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Group, split, merge, index, slice, sort, select, label
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change size or shape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle missing data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate random values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage time series
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The read functions return a [`DataFrame`](https://oreil.ly/zupYI) object, Pandas’
    standard representation for two-dimensional data (rows and columns). It’s similar
    in some ways to a spreadsheet or a relational database table. Its one-dimensional
    little brother is a [`Series`](https://oreil.ly/pISZT).
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 16-2](#pandas_csv_example) demonstrates a simple application that
    reads our *villains.csv* file from [Example 16-1](#villains_csv).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-2\. Read CSV with Pandas
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The variable `data` just shown is a `DataFrame`. which has many more tricks
    than a basic Python dictionary. It’s especially useful for heavy numeric work
    with NumPy, and data preparation for machine learning.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the [“Getting Started”](https://oreil.ly/VKSrZ) section of the documentation
    for Pandas’ features, and [“10 Minutes to Pandas”](https://oreil.ly/CLoVg) for
    working examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use Pandas for a little calendar example—make a list of the first day
    of the first three months in 2019:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You could write something that does this, using the time and date functions
    described in [Chapter 13](ch13.html#ch_times), but it would be a lot more work—especially
    debugging (dates and times are frustrating). Pandas also handles many special
    date/time [details](https://oreil.ly/vpeTP), like business months and years.
  prefs: []
  type: TYPE_NORMAL
- en: Pandas will appear again later when I talk about mapping ([“Geopandas”](ch21.html#geopandas))
    and scientific applications ([“Pandas”](ch22.html#sci_pandas)).
  prefs: []
  type: TYPE_NORMAL
- en: Configuration Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most programs offer various *options* or *settings*. Dynamic ones can be provided
    as program arguments, but long-lasting ones need to be kept somewhere. The temptation
    to define your own quick-and-dirty *config file* format is strong—but resist it.
    It often turns out to be dirty, but not so quick. You need to maintain both the
    writer program and the reader program (sometimes called a *parser*). There are
    good alternatives that you can just drop into your program, including those in
    the previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we’ll use the standard `configparser` module, which handles Windows-style
    *.ini* files. Such files have sections of *key* = *value* definitions. Here’s
    a minimal *settings.cfg* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the code to read it into Python data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Other options are available, including fancier interpolation. See the `configparser`
    [documentation](http://bit.ly/configparser). If you need deeper nesting than two
    levels, try YAML or JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Binary Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some file formats were designed to store particular data structures but are
    neither relational nor NoSQL databases. The sections that follow present some
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: Padded Binary Files and Memory Mapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These are similar to padded text files, but the contents may be binary, and
    the padding byte may be `\x00` instead of a space character. Each record has a
    fixed size, as does each field within a record. This makes it simpler to `seek()`
    throughout the file for the desired records and fields. Every operation on the
    data is manual, so this approach tends to be used only in very low-level (e.g.,
    close to the hardware) situations.
  prefs: []
  type: TYPE_NORMAL
- en: Data in this form can be *memory mapped* with the standard `mmap` library. See
    some [examples](https://pymotw.com/3/mmap), and the standard [documentation](https://oreil.ly/eI0mv).
  prefs: []
  type: TYPE_NORMAL
- en: Spreadsheets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Spreadsheets, notably Microsoft Excel, are widespread binary data formats. If
    you can save your spreadsheet to a CSV file, you can read it by using the standard
    `csv` module that was described earlier. This will work for a binary `xls` file,
    [`xlrd`](https://oreil.ly/---YE), or `tablib` (mentioned earlier at [“Tablib”](#tablib)).
  prefs: []
  type: TYPE_NORMAL
- en: HDF5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[HDF5](https://oreil.ly/QTT6x) is a binary data format for multidimensional
    or hierarchical numeric data. It’s used mainly in science, where fast random access
    to large datasets (gigabytes to terabytes) is a common requirement. Even though
    HDF5 could be a good alternative to databases in some cases, for some reason HDF5
    is almost unknown in the business world. It’s best suited to *WORM* (write once/read
    many) applications for which database protection against conflicting writes is
    not needed. Here are some modules that you might find useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '`h5py` is a full-featured low-level interface. Read the [documentation](http://www.h5py.org)
    and [code](https://github.com/h5py/h5py).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PyTables` is a bit higher-level, with database-like features. Read the [documentation](http://www.pytables.org)
    and [code](http://pytables.github.com).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both of these are discussed in terms of scientific applications of Python in
    [Chapter 22](ch22.html#ch_science). I’m mentioning HDF5 here in case you have
    a need to store and retrieve large amounts of data and are willing to consider
    something outside the box as well as the usual database solutions. A good example
    is the [Million Song dataset](http://millionsongdataset.com), which has downloadable
    song data in HDF5 and SQLite formats.
  prefs: []
  type: TYPE_NORMAL
- en: TileDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A recent successor to HDF5 for dense or spare array storage is [TileDB](https://tiledb.io).
    Install the [Python interface](https://github.com/TileDB-Inc/TileDB-Py) (which
    includes the TileDB library itself) by running `pip install tiledb`. This is aimed
    at scientific data and applications.
  prefs: []
  type: TYPE_NORMAL
- en: Relational Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Relational databases are only about 40 years old but are ubiquitous in the
    computing world. You’ll almost certainly have to deal with them at one time or
    another. When you do, you’ll appreciate what they provide:'
  prefs: []
  type: TYPE_NORMAL
- en: Access to data by multiple simultaneous users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protection from corruption by those users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficient methods to store and retrieve the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data defined by *schemas* and limited by *constraints*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Joins* to find relationships across diverse types of data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A declarative (rather than imperative) query language: *SQL* (Structured Query
    Language)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are called *relational* because they show relationships among different
    kinds of data in the form of rectangular *tables*. For instance, in our menu example
    earlier, there is a relationship between each item and its price.
  prefs: []
  type: TYPE_NORMAL
- en: A table is a rectangular grid of *columns* (data fields) and *rows* (individual
    data records), similar to a spreadsheet. The intersection of a row and column
    is a table *cell*. To create a table, name it and specify the order, names, and
    types of its columns. Each row has the same columns, although a column may be
    defined to allow missing data (called *nulls*) in cells. In the menu example,
    you could create a table with one row for each item being sold. Each item has
    the same columns, including one for the price.
  prefs: []
  type: TYPE_NORMAL
- en: A column or group of columns is usually the table’s *primary key*; its values
    must be unique in the table. This prevents adding the same data to the table more
    than once. This key is *indexed* for fast lookups during queries. An index works
    a little like a book index, making it fast to find a particular row.
  prefs: []
  type: TYPE_NORMAL
- en: Each table lives within a parent *database*, like a file within a directory.
    Two levels of hierarchy help keep things organized a little better.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Yes, the word *database* is used in multiple ways: as the server, the table
    container, and the data stored therein. If you’ll be referring to all of them
    at the same time, it might help to call them *database server*, *database*, and
    *data*.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to find rows by some nonkey column value, define a *secondary index*
    on that column. Otherwise, the database server must perform a *table scan*—a brute-force
    search of every row for matching column values.
  prefs: []
  type: TYPE_NORMAL
- en: Tables can be related to each other with *foreign keys*, and column values can
    be constrained to these keys.
  prefs: []
  type: TYPE_NORMAL
- en: SQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQL is not an API or a protocol, but a declarative *language*: you say *what*
    you want rather than *how* to do it. It’s the universal language of relational
    databases. SQL queries are text strings sent by a client to the database server,
    which in turn figures out what to do with them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There have been various SQL standard definitions, and all database vendors
    have added their own tweaks and extensions, resulting in many SQL *dialects*.
    If you store your data in a relational database, SQL gives you some portability.
    Still, dialect and operational differences can make it difficult to move your
    data to another type of database. There are two main categories of SQL statements:'
  prefs: []
  type: TYPE_NORMAL
- en: DDL (data definition language)
  prefs: []
  type: TYPE_NORMAL
- en: Handles creation, deletion, constraints, and permissions for tables, databases,
    and users.
  prefs: []
  type: TYPE_NORMAL
- en: DML (data manipulation language)
  prefs: []
  type: TYPE_NORMAL
- en: Handles data insertions, selects, updates, and deletions.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 16-1](#table_8-1) lists the basic SQL DDL commands.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 16-1\. Basic SQL DDL commands
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | SQL pattern | SQL example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create a database | `CREATE DATABASE` *dbname* | `CREATE DATABASE d` |'
  prefs: []
  type: TYPE_TB
- en: '| Select current database | `USE` *dbname* | `USE d` |'
  prefs: []
  type: TYPE_TB
- en: '| Delete a database and its tables | `DROP DATABASE` *dbname* | `DROP DATABASE
    d` |'
  prefs: []
  type: TYPE_TB
- en: '| Create a table | `CREATE TABLE` *tbname* `(` *coldefs* `)` | `CREATE TABLE
    t (id INT, count INT)` |'
  prefs: []
  type: TYPE_TB
- en: '| Delete a table | `DROP TABLE` *tbname* | `DROP TABLE t` |'
  prefs: []
  type: TYPE_TB
- en: '| Remove all rows from a table | `TRUNCATE TABLE` *tbname* | `TRUNCATE TABLE
    t` |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Why all the CAPITAL LETTERS? SQL is case-insensitive, but it’s a tradition (don’t
    ask me why) to SHOUT its keywords in code examples to distinguish them from column
    names.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main DML operations of a relational database are often known by the acronym
    CRUD:'
  prefs: []
  type: TYPE_NORMAL
- en: '*C*reate by using the SQL `INSERT` statement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*R*ead by using `SELECT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*U*pdate by using `UPDATE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*D*elete by using `DELETE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Table 16-2](#sql_dml) looks at the commands available for SQL DML.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 16-2\. Basic SQL DML commands
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | SQL pattern | SQL example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Add a row | `INSERT INTO` *tbname* `VALUES(` … `)` | `INSERT INTO t VALUES(7,
    40)` |'
  prefs: []
  type: TYPE_TB
- en: '| Select all rows and columns | `SELECT * FROM` *tbname* | `SELECT * FROM t`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Select all rows, some columns | `SELECT` *cols* `FROM` *tbname* | `SELECT
    id, count FROM t` |'
  prefs: []
  type: TYPE_TB
- en: '| Select some rows, some columns | `SELECT` *cols* `FROM` *tbname* `WHERE`
    *condition* | `SELECT id, count from t WHERE count > 5 AND id = 9` |'
  prefs: []
  type: TYPE_TB
- en: '| Change some rows in a column | `UPDATE` *tbname* `SET` *col* `=` *value*
    `WHERE` *condition* | `UPDATE t SET count=3 WHERE id=5` |'
  prefs: []
  type: TYPE_TB
- en: '| Delete some rows | `DELETE FROM` *tbname* `WHERE` *condition* | `DELETE FROM
    t WHERE count <= 10 OR id = 16` |'
  prefs: []
  type: TYPE_TB
- en: DB-API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An application programming interface (API) is a set of functions that you can
    call to get access to some service. [DB-API](http://bit.ly/db-api) is Python’s
    standard API for accessing relational databases. Using it, you can write a single
    program that works with multiple kinds of relational databases instead of writing
    a separate program for each one. It’s similar to Java’s JDBC or Perl’s dbi.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its main functions are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`connect()`'
  prefs: []
  type: TYPE_NORMAL
- en: Make a connection to the database; this can include arguments such as username,
    password, server address, and others.
  prefs: []
  type: TYPE_NORMAL
- en: '`cursor()`'
  prefs: []
  type: TYPE_NORMAL
- en: Create a *cursor* object to manage queries.
  prefs: []
  type: TYPE_NORMAL
- en: '`execute()` and `executemany()`'
  prefs: []
  type: TYPE_NORMAL
- en: Run one or more SQL commands against the database.
  prefs: []
  type: TYPE_NORMAL
- en: '`fetchone()`, `fetchmany()`, and `fetchall()`'
  prefs: []
  type: TYPE_NORMAL
- en: Get the results from `execute()`.
  prefs: []
  type: TYPE_NORMAL
- en: The Python database modules in the coming sections conform to DB-API, often
    with extensions and some differences in details.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[SQLite](http://www.sqlite.org) is a good, light, open source relational database.
    It’s implemented as a standard Python library, and stores databases in normal
    files. These files are portable across machines and operating systems, making
    SQLite a very portable solution for simple relational database applications. It
    isn’t as full featured as MySQL or PostgreSQL, but it does support SQL, and it
    manages multiple simultaneous users. Web browsers, smartphones, and other applications
    use SQLite as an embedded database.'
  prefs: []
  type: TYPE_NORMAL
- en: You begin with a `connect()` to the local SQLite database file that you want
    to use or create. This file is the equivalent of the directory-like *database*
    that parents tables in other servers. The special string `':memory:'` creates
    the database in memory only; this is fast and useful for testing but will lose
    data when your program terminates or if your computer goes down.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the next example, let’s make a database called `enterprise.db` and the
    table `zoo` to manage our thriving roadside petting zoo business. The table columns
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`critter`'
  prefs: []
  type: TYPE_NORMAL
- en: A variable length string, and our primary key.
  prefs: []
  type: TYPE_NORMAL
- en: '`count`'
  prefs: []
  type: TYPE_NORMAL
- en: An integer count of our current inventory for this animal.
  prefs: []
  type: TYPE_NORMAL
- en: '`damages`'
  prefs: []
  type: TYPE_NORMAL
- en: The dollar amount of our current losses from animal–human interactions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Python’s triple quotes are handy when creating long strings such as SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add some animals to the zoo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s a safer way to insert data, using a *placeholder*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This time, we used three question marks in the SQL to indicate that we plan
    to insert three values, and then pass those three values as a tuple to the `execute()`
    function. Placeholders handle tedious details such as quoting. They protect you
    against *SQL injection*, a kind of external attack that inserts malicious SQL
    commands into the system (and which is common on the web).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s see if we can get all our animals out again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s get them again, but ordered by their counts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Hey, we wanted them in descending order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Which type of animal is costing us the most?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You would have thought it was the bears. It’s always best to check the actual
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we leave SQLite, we need to clean up. If we opened a connection and
    a cursor, we need to close them when we’re done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: MySQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[MySQL](http://www.mysql.com) is a very popular open source relational database.
    Unlike SQLite, it’s an actual server, so clients can access it from different
    devices across the network.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 16-3](#mysql_drivers) lists the drivers you can use to access MySQL
    from Python. For more details on all Python MySQL drivers, see the *python.org*
    [wiki](https://wiki.python.org/moin/MySQL).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 16-3\. MySQL drivers
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Link | Pypi package | Import as | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| mysqlclient | [*https://https://mysqlclient.readthedocs.io*](https://mysqlclient.readthedocs.io/)
    | mysql-connector-python | `MySQLdb` |  |'
  prefs: []
  type: TYPE_TB
- en: '| MySQL Connector | [*http://bit.ly/mysql-cpdg*](http://bit.ly/mysql-cpdg)
    | mysql-connector-python | `mysql.connector` |  |'
  prefs: []
  type: TYPE_TB
- en: '| PYMySQL | [*https://github.com/petehunt/PyMySQL*](https://github.com/petehunt/PyMySQL/)
    | pymysql | `pymysql` |  |'
  prefs: []
  type: TYPE_TB
- en: '| oursql | [*http://pythonhosted.org/oursql*](http://pythonhosted.org/oursql/)
    | oursql | `oursql` | Requires the MySQL C client libraries |'
  prefs: []
  type: TYPE_TB
- en: PostgreSQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PostgreSQL](http://www.postgresql.org) is a full-featured open source relational
    database. Indeed in many ways, it’s more advanced than MySQL. [Table 16-4](#postgres_drivers)
    presents the Python drivers you can use to access it.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 16-4\. PostgreSQL drivers
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Link | Pypi package | Import as | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| psycopg2 | [*http://initd.org/psycopg*](http://initd.org/psycopg/) | psycopg2
    | psycopg2 | Needs `pg_config` from PostgreSQL client tools |'
  prefs: []
  type: TYPE_TB
- en: '| py-postgresql | [*https://pypi.org/project/py-postgresql*](https://pypi.org/project/py-postgresql/)
    | py-postgresql | postgresql |  |'
  prefs: []
  type: TYPE_TB
- en: The most popular driver is `psycopg2`, but its installation requires the PostgreSQL
    client libraries.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQL is not quite the same for all relational databases, and DB-API takes you
    only so far. Each database implements a particular *dialect* reflecting its features
    and philosophy. Many libraries try to bridge these differences in one way or another.
    The most popular cross-database Python library is [SQLAlchemy](http://www.sqlalchemy.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'It isn’t in the standard library, but it’s well known and used by many people.
    You can install it on your system by using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use SQLAlchemy on several levels:'
  prefs: []
  type: TYPE_NORMAL
- en: The lowest level manages database connection *pools*, executes SQL commands,
    and returns results. This is closest to the DB-API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next up is the *SQL expression language*, which lets you express queries in
    a more Python-oriented way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highest is the ORM (Object Relational Model) layer, which uses the SQL Expression
    Language and binds application code with relational data structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we go along, you’ll understand what the terms mean in those levels. SQLAlchemy
    works with the database drivers documented in the previous sections. You don’t
    need to import the driver; the initial connection string you provide to SQLAlchemy
    will determine it. That string looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The values you put in this string are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect`'
  prefs: []
  type: TYPE_NORMAL
- en: The database type
  prefs: []
  type: TYPE_NORMAL
- en: '`driver`'
  prefs: []
  type: TYPE_NORMAL
- en: The particular driver you want to use for that database
  prefs: []
  type: TYPE_NORMAL
- en: '`user` and `password`'
  prefs: []
  type: TYPE_NORMAL
- en: Your database authentication strings
  prefs: []
  type: TYPE_NORMAL
- en: '`host` and `port`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The database server’s location (`: port` is needed only if it’s not the standard
    one for this server)'
  prefs: []
  type: TYPE_NORMAL
- en: '`dbname`'
  prefs: []
  type: TYPE_NORMAL
- en: The database to initially connect to on the server
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 16-5](#sqlalchemy_dialects) lists the dialects and drivers.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 16-5\. SQLAlchemy connection
  prefs: []
  type: TYPE_NORMAL
- en: '| dialect | driver |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `sqlite` | `pysqlite` (or omit) |'
  prefs: []
  type: TYPE_TB
- en: '| `mysql` | `mysqlconnector` |'
  prefs: []
  type: TYPE_TB
- en: '| `mysql` | `pymysql` |'
  prefs: []
  type: TYPE_TB
- en: '| `mysql` | `oursql` |'
  prefs: []
  type: TYPE_TB
- en: '| `postgresql` | `psycopg2` |'
  prefs: []
  type: TYPE_TB
- en: '| `postgresql` | `pypostgresql` |'
  prefs: []
  type: TYPE_TB
- en: See also the SQLAlchemy details on dialects for [MySQL](https://oreil.ly/yVHy-),
    [SQLite](https://oreil.ly/okP9v), [PostgreSQL](https://oreil.ly/eDddn), and [other
    databases](https://oreil.ly/kp5WS).
  prefs: []
  type: TYPE_NORMAL
- en: The engine layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, let’s try the lowest level of SQLAlchemy, which does little more than
    the base DB-API functions.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try it with SQLite, which is already built in to Python. The connection
    string for SQLite skips the *`host`*, *`port`*, *`user`*, and *`password`*. The
    *`dbname`* tells SQLite what file to use to store your database. If you omit the
    *`dbname`*, SQLite builds a database in memory. If the *`dbname`* starts with
    a slash (/), it’s an absolute filename on your computer (as in Linux and macOS;
    for example, `C:\` on Windows). Otherwise, it’s relative to your current directory.
  prefs: []
  type: TYPE_NORMAL
- en: The following segments are all part of one program, separated here for explanation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, you need to import what we need. The following is an example of an
    *import alias*, which lets us use the string `sa` to refer to SQLAlchemy methods.
    I do this mainly because `sa` is a lot easier to type than `sqlalchemy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect to the database and create the storage for it in memory (the argument
    string `''sqlite:///:memory:''` also works):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a database table called `zoo` that comprises three columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Running `conn.execute()` returns a SQLAlchemy object called a `ResultProxy`.
    You’ll soon see what to do with it.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, if you’ve never made a database table before, congratulations. Check
    that one off your bucket list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, insert three sets of data into your new empty table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, ask the database for everything that we just put in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In SQLAlchemy, `rows` is not a list; it’s that special `ResultProxy` thing
    that we can’t print directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you can iterate over it like a list, so we can get a row at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: That was almost the same as the SQLite DB-API example that you saw earlier.
    The one advantage is that we didn’t need to import the database driver at the
    top; SQLAlchemy figured that out from the connection string. Just changing the
    connection string would make this code portable to another type of database. Another
    plus is SQLAlchemy’s *connection pooling*, which you can read about at its [documentation
    site](http://bit.ly/conn-pooling).
  prefs: []
  type: TYPE_NORMAL
- en: The SQL Expression Language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next level up is SQLAlchemy’s SQL Expression Language. It introduces functions
    to create the SQL for various operations. The Expression Language handles more
    of the SQL dialect differences than the lower-level engine layer does. It can
    be a handy middle-ground approach for relational database applications.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s how to create and populate the `zoo` table. Again, these are successive
    fragments of a single program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The import and connection are the same as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To define the `zoo` table, we begin using some of the Expression Language instead
    of SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Check out the parentheses in that multiline call in the preceding example. The
    structure of the `Table()` method matches the structure of the table. Just as
    our table contains three columns, there are three calls to `Column()` inside the
    parentheses of the `Table()` method call.
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, `zoo` is some magic object that bridges the SQL database world and
    the Python data structure world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert the data with more Expression Language functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the SELECT statement (`zoo.select()` selects everything from the
    table represented by the `zoo` object, such as `SELECT * FROM zoo` would do in
    plain SQL):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, get the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The Object-Relational Mapper (ORM)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, the `zoo` object was a mid-level connection between
    SQL and Python. At the top layer of SQLAlchemy, the Object-Relational Mapper (ORM)
    uses the SQL Expression Language but tries to make the actual database mechanisms
    invisible. You define classes, and the ORM handles how to get their data in and
    out of the database. The basic idea behind that complicated phrase, “object-relational
    mapper,” is that you can refer to objects in your code and thus stay close to
    the way Python likes to operate while still using a relational database.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll define a `Zoo` class and hook it into the ORM. This time, we make SQLite
    use the file *zoo.db* so that we can confirm that the ORM worked.
  prefs: []
  type: TYPE_NORMAL
- en: As in the previous two sections, the snippets that follow are actually one program
    separated by explanations. Don’t worry if you don’t understand some if it. The
    SQLAlchemy documentation has all the details—and this stuff can get complex. I
    just want you to get an idea of how much work it is to do this, so that you can
    decide which of the approaches discussed in this chapter suits you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial import is the same, but this time we need another something also:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we make the connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we get into SQLAlchemy’s ORM. We define the `Zoo` class and associate
    its attributes with table columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line magically creates the database and table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then insert data by creating Python objects. The ORM manages these
    internally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we get the ORM to take us to SQL land. We create a session to talk to
    the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the session, we write the three objects that we created to the database.
    The `add()` function adds one object, and `add_all()` adds a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to force everything to complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Did it work? Well, it created a *zoo.db* file in the current directory. You
    can use the command-line `sqlite3` program to check it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The purpose of this section was to show what an ORM is and how it works at
    a high level. The author of SQLAlchemy has written a full [tutorial](http://bit.ly/obj-rel-tutorial).
    After reading this, decide which of the following levels would best fit your needs:'
  prefs: []
  type: TYPE_NORMAL
- en: Plain DB-API, as in the earlier SQLite section
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SQLAlchemy engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SQLAlchemy Expression Language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SQLAlchemy ORM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It seems like a natural choice to use an ORM to avoid the complexities of SQL.
    Should you use one? Some people think ORMs should be [avoided](http://bit.ly/obj-rel-map),
    but others think the criticism is [overdone](http://bit.ly/fowler-orm). Whoever’s
    right, an ORM is an abstraction, and all abstractions are [leaky](http://bit.ly/leaky-law)
    and break down at some point. When your ORM doesn’t do what you want, you must
    figure out both how it works and how to fix it in SQL. To borrow an internet meme:'
  prefs: []
  type: TYPE_NORMAL
- en: Some people, when confronted with a problem, think, “I know, I’ll use an ORM.”
    Now they have two problems.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use ORMs for simple applications or applications that map data pretty directly
    to database tables. If the application is that simple, you may consider using
    straight SQL or the SQL Expression Language.
  prefs: []
  type: TYPE_NORMAL
- en: Other Database Access Packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’re looking for Python tools that will handle multiple databases, with
    more features than the bare db-api but less than SQLAlchemy, these are worth a
    look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`dataset`](https://dataset.readthedocs.org) claims the goal “databases for
    lazy people”. It’s built on SQLAlchemy and provides a simple ORM for SQL, JSON,
    and CSV storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`records`](https://pypi.org/project/records) bills itself as “SQL for Humans.”
    It supports only SQL queries, using SQLAlchemy internally to handle SQL dialect
    issues, connection pooling, and other details. Its integration with `tablib` (mentioned
    at [“Tablib”](#tablib)) lets you export data to CSV, JSON, and other formats.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NoSQL Data Stores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Relational tables are rectangular, but data come in many shapes and may be very
    difficult to fit without significant effort and contortion. It’s a square peg/round
    hole problem.
  prefs: []
  type: TYPE_NORMAL
- en: Some nonrelational databases have been written to allow more flexible data definitions
    as well as to process very large data sets or support custom data operations.
    They’ve been collectively labeled *NoSQL* (formerly meaning *no SQL*, now the
    less confrontational *not only SQL*).
  prefs: []
  type: TYPE_NORMAL
- en: The simplest type of NoSQL databases are *key-value stores*. One popularity
    [ranking](https://oreil.ly/_VCKq) shows some that I cover in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The dbm Family
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `dbm` formats were around long before the *NoSQL* label was coined. They’re
    simple key-value stores, often embedded in applications such as web browsers to
    maintain various settings. A dbm database is like a Python dictionary in the following
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: You can assign a value to a key, and it’s automatically saved to the database
    on disk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can query a key for its value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a quick example. The second argument to the following `open()`
    method is `''r''` to read, `''w''` to write, and `''c''` for both, creating the
    file if it doesn’t exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'To create key-value pairs, just assign a value to a key just as you would a
    dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s pause and check what we have so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now close, then reopen to see whether it actually saved what we gave it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Keys and values are stored as `bytes`. You cannot iterate over the database
    object `db`, but you can get the number of keys by using `len()`. `get()` and
    `setdefault()` work as they do for dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: Memcached
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`memcached`](http://memcached.org) is a fast in-memory key-value *cache* server.
    It’s often put in front of a database, or used to store web server session data.'
  prefs: []
  type: TYPE_NORMAL
- en: You can download versions for [Linux and macOS](https://memcached.org/downloads)
    as well as [Windows](http://bit.ly/memcache-win). If you want to try out this
    section, you’ll need a running memcached server and Python driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many Python drivers; one that works with Python 3 is [`python3-memcached`](https://oreil.ly/7FA3-),
    which you can install by using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'To use it, connect to a memcached server, after which you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Set and get values for keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increment or decrement a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete a key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data keys and values are *not* persistent, and data that you wrote earlier might
    disappear. This is inherent in memcached—it’s a cache server, not a database,
    and it avoids running out of memory by discarding old data.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can connect to multiple memcached servers at the same time. In this next
    example, we’re just talking to one on the same computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Redis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Redis](http://redis.io) is a *data structure server*. It handles keys and
    their values, but the values are richer than those in other key-value stores.
    Like memcached, all of the data in a Redis server should fit in memory. Unlike
    memcached, Redis can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Save data to disk for reliability and restarts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep old data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide more data structures than simple strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Redis data types are a close match to Python’s, and a Redis server can be
    a useful intermediary for one or more Python applications to share data. I’ve
    found it so useful that it’s worth a little extra coverage here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python driver `redis-py` has its source code and tests on [GitHub](https://oreil.ly/aZIbQ)
    as well as [documentation](http://bit.ly/redis-py-docs). You can install it by
    using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The [Redis server](http://redis.io) has good documentation. If you install and
    start the Redis server on your local computer (with the network nickname `localhost`),
    you can try the programs in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A key with a single value is a Redis *string*. Simple Python data types are
    automatically converted. Connect to a Redis server at some host (default is `localhost`)
    and port (default is `6379`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Connecting to `redis.Redis('localhost')` or `redis.Redis('localhost', 6379)`
    would have given the same result.
  prefs: []
  type: TYPE_NORMAL
- en: 'List all keys (none so far):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Set a simple string (key `''secret''`), integer (key `''carats''`), and float
    (key `''fever''`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the values back (as Python `byte` values) by key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `setnx()` method sets a value only if the key does not exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'It failed because we had already defined `''secret''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getset()` method returns the old value and sets it to a new one at the
    same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Let’s not get too far ahead of ourselves. Did it work?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, get a substring by using `getrange()` (as in Python, offset `0` means
    start, and `-1` means end):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace a substring by using `setrange()` (using a zero-based offset):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, set multiple keys at once by using `mset()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Get more than one value at once by using `mget()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete a key by using `delete()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Increment by using the `incr()` or `incrbyfloat()` commands, and decrement
    with `decr()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s no `decrbyfloat()`. Use a negative increment to reduce the fever:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Redis lists can contain only strings. The list is created when you do your
    first insertion. Insert at the beginning by using `lpush()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert more than one item at the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert before or after a value by using `linsert()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert at an offset by using `lset()` (the list must exist already):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert at the end by using `rpush()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the value at an offset by using `lindex()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the values in an offset range by using `lrange()` (0 to -1 for all):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Trim the list with `ltrim()`, keeping only those in a range of offsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Get a range of values (use `0` to `-1` for all) by using `lrange()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[Chapter 15](ch15.html#ch_systems) shows you how you can use Redis lists and
    *publish-subscribe* to implement job queues.'
  prefs: []
  type: TYPE_NORMAL
- en: Hashes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Redis *hashes* are similar to Python dictionaries but can contain only strings.
    Also, you can go only one level deep, not make deep-nested structures. Here are
    examples that create and play with a Redis hash called `song`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the fields `do` and `re` in hash `song` at once by using `hmset()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Set a single field value in a hash by using `hset()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Get one field’s value by using `hget()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Get multiple field values by using `hmget()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Get all field keys for the hash by using `hkeys()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Get all field values for the hash by using `hvals()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the number of fields in the hash by using `hlen()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Get all field keys and values in the hash by using `hgetall()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Set a field if its key doesn’t exist by using `hsetnx()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Redis sets are similar to Python sets, as you’ll see in the following examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add one or more values to a set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the number of values from the set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Get all of the set’s values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove a value from the set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s make a second set to show some set operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Intersect (get the common members of) the `zoo` and `better_zoo` sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the intersection of `zoo` and `better_zoo`, and store the result in the
    set `fowl_zoo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Who’s in there?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the union (all members) of `zoo` and `better_zoo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Store that union result in the set `fabulous_zoo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'What does `zoo` have that `better_zoo` doesn’t? Use `sdiff()` to get the set
    difference, and `sdiffstore()` to save it in the `zoo_sale` set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Sorted sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the most versatile Redis data types is the *sorted set*, or *zset*.
    It’s a set of unique values, but each value has an associated floating-point *score*.
    You can access each item by its value or score. Sorted sets have many uses:'
  prefs: []
  type: TYPE_NORMAL
- en: Leader boards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondary indexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timeseries, using timestamps as scores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We show the last use case, tracking user logins via timestamps. We’re using
    the Unix *epoch* value (more on this in [Chapter 15](ch15.html#ch_systems)) that’s
    returned by the Python `time()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s add our first guest, looking nervous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Five minutes later, another guest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Two hours later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'One day later, not hasty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: In what order did `bilbo` arrive?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: When was that?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see everyone in login order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'With their times, please:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Caches and expiration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All Redis keys have a time-to-live, or *expiration date*. By default, this
    is forever. We can use the `expire()` function to instruct Redis how long to keep
    the key. The value is a number of seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The `expireat()` command expires a key at a given epoch time. Key expiration
    is useful to keep caches fresh and to limit login sessions. An analogy: in the
    refrigerated room behind the milk racks at your grocery store, store employees
    yank those gallons as they reach their freshness dates.'
  prefs: []
  type: TYPE_NORMAL
- en: Document Databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *document database* is a NoSQL database that stores data with varying fields.
    Compared to a relational table (rectangular, with the same columns in every row)
    such data is “ragged,” with varying fields (columns) per row, and even nested
    fields. You could handle data like this in memory with Python dictionaries and
    lists, or store it as JSON files. To store such data in a relational database
    table, you would need to define every possible column and use nulls for missing
    data.
  prefs: []
  type: TYPE_NORMAL
- en: '*ODM* can stand for Object Data Manager or Object Document Mapper (at least
    they agree on the *O* part). An ODM is the document database counterpart of a
    relational database ORM. Some [popular](https://oreil.ly/5Zpxx) document databases
    and tools (drivers and ODMs) are listed in [Table 16-6](#document_db_table).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 16-6\. Document databases
  prefs: []
  type: TYPE_NORMAL
- en: '| Database | Python API |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [Mongo](https://www.mongodb.com) | [tools](https://api.mongodb.com/python/current/tools.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| [DynamoDB](https://aws.amazon.com/dynamodb) | [`boto3`](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GettingStarted.Python.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| [CouchDB](http://couchdb.apache.org) | [`couchdb`](https://couchdb-python.readthedocs.io/en/latest/index.html)
    |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'PostgreSQL can do some of the things that document databases do. Some of its
    extensions allow it to escape relational orthodoxy while keeping features like
    transactions, data validation, and foreign keys: 1) multidimensional [*arrays*](https://oreil.ly/MkfLY)—store
    more than one value in a table cell; 2) [*jsonb*](https://oreil.ly/K_VJg)—store
    JSON data in a cell, with full indexing and querying.'
  prefs: []
  type: TYPE_NORMAL
- en: Time Series Databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Time series* data may be collected at fixed intervals (such as computer performance
    metrics) or at random times, which has led to many storage methods. Among [many](https://oreil.ly/CkjC0)
    of [these](https://oreil.ly/IbOxQ), some with Python support are listed in [Table 16-7](#temporal_db_table).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 16-7\. Temporal databases
  prefs: []
  type: TYPE_NORMAL
- en: '| Database | Python API |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [InfluxDB](https://www.influxdata.com) | [`influx-client`](https://pypi.org/project/influx-client)
    |'
  prefs: []
  type: TYPE_TB
- en: '| [kdb+](https://kx.com) | [PyQ](https://code.kx.com/v2/interfaces/pyq/) |'
  prefs: []
  type: TYPE_TB
- en: '| [Prometheus](https://prometheus.io) | [`prometheus_client`](https://github.com/prometheus/client_python/blob/master/README.md)
    |'
  prefs: []
  type: TYPE_TB
- en: '| [TimescaleDB](https://www.timescale.com) | (PostgreSQL clients) |'
  prefs: []
  type: TYPE_TB
- en: '| [OpenTSDB](http://opentsdb.net) | [`potsdb`](https://pypi.org/project/potsdb)
    |'
  prefs: []
  type: TYPE_TB
- en: '| [PyStore](https://github.com/ranaroussi/pystore) | [`PyStore`](https://pypi.org/project/PyStore)
    |'
  prefs: []
  type: TYPE_TB
- en: Graph Databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For our last case of data that need its own database category, we have *graphs*:
    *nodes* (data) connected by *edges* or *vertices* (relationships). An individual
    Twitter *user* could be a node, with edges to other users like *following* and
    *followed*.'
  prefs: []
  type: TYPE_NORMAL
- en: Graph data has become more visible with the growth of social media, where the
    value is in the connections as much as the content. Some [popular](https://oreil.ly/MAwMQ)
    graph databases are outlined in [Table 16-8](#graph_db_table).
  prefs: []
  type: TYPE_NORMAL
- en: Table 16-8\. Graph databases
  prefs: []
  type: TYPE_NORMAL
- en: '| Database | Python API |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [Neo4J](https://neo4j.com) | [`py2neo`](https://py2neo.org/v3) |'
  prefs: []
  type: TYPE_TB
- en: '| [OrientDB](https://orientdb.com) | [`pyorient`](https://orientdb.com/docs/last/PyOrient.html)
    |'
  prefs: []
  type: TYPE_TB
- en: '| [ArangoDB](https://www.arangodb.com) | [`pyArango`](https://github.com/ArangoDB-Community/pyArango)
    |'
  prefs: []
  type: TYPE_TB
- en: Other NoSQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The NoSQL servers listed here handle data larger than memory, and many of them
    use multiple computers. [Table 16-9](#nosql_table) presents notable servers and
    their Python libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Table 16-9\. NoSQL databases
  prefs: []
  type: TYPE_NORMAL
- en: '| Database | Python API |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [Cassandra](http://cassandra.apache.org) | [`pycassa`](https://github.com/pycassa/pycassa)
    |'
  prefs: []
  type: TYPE_TB
- en: '| [CouchDB](http://couchdb.apache.org) | [`couchdb-python`](https://github.com/djc/couchdb-python)
    |'
  prefs: []
  type: TYPE_TB
- en: '| [HBase](http://hbase.apache.org) | [`happybase`](https://github.com/wbolster/happybase)
    |'
  prefs: []
  type: TYPE_TB
- en: '| [Kyoto Cabinet](http://fallabs.com/kyotocabinet) | [`kyotocabinet`](http://bit.ly/kyotocabinet)
    |'
  prefs: []
  type: TYPE_TB
- en: '| [MongoDB](http://www.mongodb.org) | [`mongodb`](http://api.mongodb.org/python/current)
    |'
  prefs: []
  type: TYPE_TB
- en: '| [Pilosa](https://www.pilosa.com) | [`python-pilosa`](https://github.com/pilosa/python-pilosa)
    |'
  prefs: []
  type: TYPE_TB
- en: '| [Riak](http://basho.com/riak) | [`riak-python-client`](https://github.com/basho/riak-python-client)
    |'
  prefs: []
  type: TYPE_TB
- en: Full-Text Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, there’s a special category of databases for *full-text* search. They
    index everything, so you can find that poem that talks about windmills and giant
    wheels of cheese. You can see some popular open source examples along with their
    Python APIs in [Table 16-10](#full_text_table).
  prefs: []
  type: TYPE_NORMAL
- en: Table 16-10\. Full-text databases
  prefs: []
  type: TYPE_NORMAL
- en: '| Site | Python API |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [Lucene](http://lucene.apache.org) | [`pylucene`](http://lucene.apache.org/pylucene)
    |'
  prefs: []
  type: TYPE_TB
- en: '| [Solr](http://lucene.apache.org/solr) | [`SolPython`](http://wiki.apache.org/solr/SolPython)
    |'
  prefs: []
  type: TYPE_TB
- en: '| [ElasticSearch](http://www.elasticsearch.org) | [`elasticsearch`](https://elasticsearch-py.readthedocs.io)
    |'
  prefs: []
  type: TYPE_TB
- en: '| [Sphinx](http://sphinxsearch.com) | [`sphinxapi`](http://bit.ly/sphinxapi)
    |'
  prefs: []
  type: TYPE_TB
- en: '| [Xapian](http://xapian.org) | [`xappy`](https://code.google.com/p/xappy)
    |'
  prefs: []
  type: TYPE_TB
- en: '| [Whoosh](http://bit.ly/mchaput-whoosh) | (written in Python, includes an
    API) |'
  prefs: []
  type: TYPE_TB
- en: Coming Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter was about interleaving code in time (*concurrency*). The
    next one is about moving data through space (*networking*), which can be used
    for concurrency and other reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Do
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '16.1 Save the following text lines to a file called *books.csv* (notice that
    if the fields are separated by commas, you need to surround a field with quotes
    if it contains a comma):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 16.2 Use the `csv` module and its `DictReader` method to read *books.csv* to
    the variable `books`. Print the values in `books`. Did `DictReader` handle the
    quotes and commas in the second book’s title?
  prefs: []
  type: TYPE_NORMAL
- en: '16.3 Create a CSV file called *books2.csv* by using these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '16.4 Use the `sqlite3` module to create a SQLite database called *books.db*
    and a table called `books` with these fields: `title` (text), `author` (text),
    and `year` (integer).'
  prefs: []
  type: TYPE_NORMAL
- en: 16.5 Read *books2.csv* and insert its data into the `book` table.
  prefs: []
  type: TYPE_NORMAL
- en: 16.6 Select and print the `title` column from the `book` table in alphabetical
    order.
  prefs: []
  type: TYPE_NORMAL
- en: 16.7 Select and print all columns from the `book` table in order of publication.
  prefs: []
  type: TYPE_NORMAL
- en: 16.8 Use the `sqlalchemy` module to connect to the sqlite3 database *books.db*
    that you just made in exercise 16.4. As in 16.6, select and print the `title`
    column from the `book` table in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: 16.9 Install the Redis server and the Python `redis` library (`pip install redis`)
    on your computer. Create a Redis hash called `test` with the fields `count` (`1`)
    and `name` (`'Fester Bestertester'`). Print all the fields for `test`.
  prefs: []
  type: TYPE_NORMAL
- en: 16.10 Increment the `count` field of `test` and print it.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch16.html#idm45794977436440-marker)) Alas, not XML yet.
  prefs: []
  type: TYPE_NORMAL
