- en: 5\. Conditionals and Recursion#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://allendowney.github.io/ThinkPython/chap05.html](https://allendowney.github.io/ThinkPython/chap05.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The main topic of this chapter is the `if` statement, which executes different
    code depending on the state of the program. And with the `if` statement we’ll
    be able to explore one of the most powerful ideas in computing, **recursion**.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we’ll start with three new features: the modulus operator, boolean expressions,
    and logical operators.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.1\. Integer division and modulus[#](#integer-division-and-modulus "Link to
    this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall that the integer division operator, `//`, divides two numbers and rounds
    down to an integer. For example, suppose the run time of a movie is 105 minutes.
    You might want to know how long that is in hours. Conventional division returns
    a floating-point number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'But we don’t normally write hours with decimal points. Integer division returns
    the integer number of hours, rounding down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the remainder, you could subtract off one hour in minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Or you could use the **modulus operator**, `%`, which divides two numbers and
    returns the remainder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The modulus operator is more useful than it might seem. For example, it can
    check whether one number is divisible by another – if `x % y` is zero, then `x`
    is divisible by `y`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it can extract the right-most digit or digits from a number. For example,
    `x % 10` yields the right-most digit of `x` (in base 10). Similarly, `x % 100`
    yields the last two digits.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the modulus operator can do “clock arithmetic”. For example, if an
    event starts at 11 AM and lasts three hours, we can use the modulus operator to
    figure out what time it ends.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The event would end at 2 PM.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2\. Boolean Expressions[#](#boolean-expressions "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **boolean expression** is an expression that is either true or false. For
    example, the following expressions use the equals operator, `==`, which compares
    two values and produces `True` if they are equal and `False` otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: A common error is to use a single equal sign (`=`) instead of a double equal
    sign (`==`). Remember that `=` assigns a value to a variable and `==` compares
    two values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`True` and `False` are special values that belong to the type `bool`; they
    are not strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `==` operator is one of the **relational operators**; the others are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 5.3\. Logical operators[#](#logical-operators "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To combine boolean values into expressions, we can use **logical operators**.
    The most common are `and`, `or`, and `not`. The meaning of these operators is
    similar to their meaning in English. For example, the value of the following expression
    is `True` only if `x` is greater than `0` *and* less than `10`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following expression is `True` if *either or both* of the conditions is
    true, that is, if the number is divisible by 2 *or* 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the `not` operator negates a boolean expression, so the following expression
    is `True` if `x > y` is `False`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Strictly speaking, the operands of a logical operator should be boolean expressions,
    but Python is not very strict. Any nonzero number is interpreted as `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This flexibility can be useful, but there are some subtleties to it that can
    be confusing. You might want to avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4\. if statements[#](#if-statements "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to write useful programs, we almost always need the ability to check
    conditions and change the behavior of the program accordingly. **Conditional statements**
    give us this ability. The simplest form is the `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`if` is a Python keyword. `if` statements have the same structure as function
    definitions: a header followed by an indented statement or sequence of statements
    called a **block**.'
  prefs: []
  type: TYPE_NORMAL
- en: The boolean expression after `if` is called the **condition**. If it is true,
    the statements in the indented block run. If not, they don’t.
  prefs: []
  type: TYPE_NORMAL
- en: There is no limit to the number of statements that can appear in the block,
    but there has to be at least one. Occasionally, it is useful to have a block that
    does nothing – usually as a place keeper for code you haven’t written yet. In
    that case, you can use the `pass` statement, which does nothing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The word `TODO` in a comment is a conventional reminder that there’s something
    you need to do later.
  prefs: []
  type: TYPE_NORMAL
- en: 5.5\. The `else` clause[#](#the-else-clause "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An `if` statement can have a second part, called an `else` clause. The syntax
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: If the condition is true, the first indented statement runs; otherwise, the
    second indented statement runs.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, if `x` is even, the remainder when `x` is divided by `2` is
    `0`, so the condition is true and the program displays `x is even`. If `x` is
    odd, the remainder is `1`, so the condition is false, and the program displays
    `x is odd`.
  prefs: []
  type: TYPE_NORMAL
- en: Since the condition must be true or false, exactly one of the alternatives will
    run. The alternatives are called **branches**.
  prefs: []
  type: TYPE_NORMAL
- en: 5.6\. Chained conditionals[#](#chained-conditionals "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes there are more than two possibilities and we need more than two branches.
    One way to express a computation like that is a **chained conditional**, which
    includes an `elif` clause.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`elif` is an abbreviation of “else if”. There is no limit on the number of
    `elif` clauses. If there is an `else` clause, it has to be at the end, but there
    doesn’t have to be one.'
  prefs: []
  type: TYPE_NORMAL
- en: Each condition is checked in order. If the first is false, the next is checked,
    and so on. If one of them is true, the corresponding branch runs and the `if`
    statement ends. Even if more than one condition is true, only the first true branch
    runs.
  prefs: []
  type: TYPE_NORMAL
- en: 5.7\. Nested Conditionals[#](#nested-conditionals "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One conditional can also be nested within another. We could have written the
    example in the previous section like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The outer `if` statement contains two branches. The first branch contains a
    simple statement. The second branch contains another `if` statement, which has
    two branches of its own. Those two branches are both simple statements, although
    they could have been conditional statements as well.
  prefs: []
  type: TYPE_NORMAL
- en: Although the indentation of the statements makes the structure apparent, **nested
    conditionals** can be difficult to read. I suggest you avoid them when you can.
  prefs: []
  type: TYPE_NORMAL
- en: Logical operators often provide a way to simplify nested conditional statements.
    Here’s an example with a nested conditional.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `print` statement runs only if we make it past both conditionals, so we
    get the same effect with the `and` operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'For this kind of condition, Python provides a more concise option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 5.8\. Recursion[#](#recursion "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is legal for a function to call itself. It may not be obvious why that is
    a good thing, but it turns out to be one of the most magical things a program
    can do. Here’s an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: If `n` is 0 or negative, `countdown` outputs the word, “Blastoff!” Otherwise,
    it outputs `n` and then calls itself, passing `n-1` as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s what happens when we call this function with the argument `3`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The execution of `countdown` begins with `n=3`, and since `n` is greater than
    `0`, it displays `3`, and then calls itself.…
  prefs: []
  type: TYPE_NORMAL
- en: The execution of `countdown` begins with `n=2`, and since `n` is greater than
    `0`, it displays `2`, and then calls itself.…
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The execution of `countdown` begins with `n=1`, and since `n` is greater than
    `0`, it displays `1`, and then calls itself.…
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: The execution of `countdown` begins with `n=0`, and since `n` is not greater
    than `0`, it displays “Blastoff!” and returns.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `countdown` that got `n=1` returns.
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `countdown` that got `n=2` returns.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `countdown` that got `n=3` returns.
  prefs: []
  type: TYPE_NORMAL
- en: A function that calls itself is **recursive**. As another example, we can write
    a function that prints a string `n` times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: If `n` is positive, `print_n_times` displays the value of `string` and then
    calls itself, passing along `string` and `n-1` as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: If `n` is `0` or negative, the condition is false and `print_n_times` does nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s how it works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: For simple examples like this, it is probably easier to use a `for` loop. But
    we will see examples later that are hard to write with a `for` loop and easy to
    write with recursion, so it is good to start early.
  prefs: []
  type: TYPE_NORMAL
- en: 5.9\. Stack diagrams for recursive functions[#](#stack-diagrams-for-recursive-functions
    "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s a stack diagram that shows the frames created when we called `countdown`
    with `n = 3`.
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/e6406e06456c8a30f02728ca9ab2416d72ded3e8d84449e77a93f601da23cedc.png](../Images/5dabd26c3a8ec6a56a8c98d2081490cb.png)'
  prefs: []
  type: TYPE_IMG
- en: The four `countdown` frames have different values for the parameter `n`. The
    bottom of the stack, where `n=0`, is called the **base case**. It does not make
    a recursive call, so there are no more frames.
  prefs: []
  type: TYPE_NORMAL
- en: 5.10\. Infinite recursion[#](#infinite-recursion "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a recursion never reaches a base case, it goes on making recursive calls
    forever, and the program never terminates. This is known as **infinite recursion**,
    and it is generally not a good idea. Here’s a minimal function with an infinite
    recursion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Every time `recurse` is called, it calls itself, which creates another frame.
    In Python, there is a limit to the number of frames that can be on the stack at
    the same time. If a program exceeds the limit, it causes a runtime error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The traceback indicates that there were almost 3000 frames on the stack when
    the error occurred.
  prefs: []
  type: TYPE_NORMAL
- en: If you encounter an infinite recursion by accident, review your function to
    confirm that there is a base case that does not make a recursive call. And if
    there is a base case, check whether you are guaranteed to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: 5.11\. Keyboard input[#](#keyboard-input "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The programs we have written so far accept no input from the user. They just
    do the same thing every time.
  prefs: []
  type: TYPE_NORMAL
- en: Python provides a built-in function called `input` that stops the program and
    waits for the user to type something. When the user presses *Return* or *Enter*,
    the program resumes and `input` returns what the user typed as a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Before getting input from the user, you might want to display a prompt telling
    the user what to type. `input` can take a prompt as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The sequence `\n` at the end of the prompt represents a **newline**, which is
    a special character that causes a line break – that way the user’s input appears
    below the prompt.
  prefs: []
  type: TYPE_NORMAL
- en: If you expect the user to type an integer, you can use the `int` function to
    convert the return value to `int`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: But if they type something that’s not an integer, you’ll get a runtime error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: We will see how to handle this kind of error later.
  prefs: []
  type: TYPE_NORMAL
- en: 5.12\. Debugging[#](#debugging "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a syntax or runtime error occurs, the error message contains a lot of
    information, but it can be overwhelming. The most useful parts are usually:'
  prefs: []
  type: TYPE_NORMAL
- en: What kind of error it was, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where it occurred.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syntax errors are usually easy to find, but there are a few gotchas. Errors
    related to spaces and tabs can be tricky because they are invisible and we are
    used to ignoring them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the problem is that the second line is indented by one space.
    But the error message points to `y`, which is misleading. Error messages indicate
    where the problem was discovered, but the actual error might be earlier in the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same is true of runtime errors. For example, suppose you are trying to
    convert a ratio to decibels, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The error message indicates line 5, but there is nothing wrong with that line.
    The problem is in line 4, which uses integer division instead of floating-point
    division – as a result, the value of `ratio` is `0`. When we call `math.log10`,
    we get a `ValueError` with the message `math domain error`, because `0` is not
    in the “domain” of valid arguments for `math.log10`, because the logarithm of
    `0` is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: In general, you should take the time to read error messages carefully, but don’t
    assume that everything they say is correct.
  prefs: []
  type: TYPE_NORMAL
- en: 5.13\. Glossary[#](#glossary "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**recursion:** The process of calling the function that is currently executing.'
  prefs: []
  type: TYPE_NORMAL
- en: '**modulus operator:** An operator, `%`, that works on integers and returns
    the remainder when one number is divided by another.'
  prefs: []
  type: TYPE_NORMAL
- en: '**boolean expression:** An expression whose value is either `True` or `False`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**relational operator:** One of the operators that compares its operands: `==`,
    `!=`, `>`, `<`, `>=`, and `<=`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**logical operator:** One of the operators that combines boolean expressions,
    including `and`, `or`, and `not`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**conditional statement:** A statement that controls the flow of execution
    depending on some condition.'
  prefs: []
  type: TYPE_NORMAL
- en: '**condition:** The boolean expression in a conditional statement that determines
    which branch runs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**block:** One or more statements indented to indicate they are part of another
    statement.'
  prefs: []
  type: TYPE_NORMAL
- en: '**branch:** One of the alternative sequences of statements in a conditional
    statement.'
  prefs: []
  type: TYPE_NORMAL
- en: '**chained conditional:** A conditional statement with a series of alternative
    branches.'
  prefs: []
  type: TYPE_NORMAL
- en: '**nested conditional:** A conditional statement that appears in one of the
    branches of another conditional statement.'
  prefs: []
  type: TYPE_NORMAL
- en: '**recursive:** A function that calls itself is recursive.'
  prefs: []
  type: TYPE_NORMAL
- en: '**base case:** A conditional branch in a recursive function that does not make
    a recursive call.'
  prefs: []
  type: TYPE_NORMAL
- en: '**infinite recursion:** A recursion that doesn’t have a base case, or never
    reaches it. Eventually, an infinite recursion causes a runtime error.'
  prefs: []
  type: TYPE_NORMAL
- en: '**newline:** A character that creates a line break between two parts of a string.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.14\. Exercises[#](#exercises "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 5.14.1\. Ask a virtual assistant[#](#ask-a-virtual-assistant "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ask a virtual assistant, “What are some uses of the modulus operator?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python provides operators to compute the logical operations `and`, `or`, and
    `not`, but it doesn’t have an operator that computes the exclusive `or` operation,
    usually written `xor`. Ask an assistant “What is the logical xor operation and
    how do I compute it in Python?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we saw two ways to write an `if` statement with three branches,
    using a chained conditional or a nested conditional. You can use a virtual assistant
    to convert from one to the other. For example, ask a VA, “Convert this statement
    to a chained conditional.”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Ask a VA, “Rewrite this statement with a single conditional.”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: See if a VA can simplify this unnecessary complexity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Here’s an attempt at a recursive function that counts down by two.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: It seems to work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: But it has an error. Ask a virtual assistant what’s wrong and how to fix it.
    Paste the solution it provides back here and test it.
  prefs: []
  type: TYPE_NORMAL
- en: 5.14.2\. Exercise[#](#exercise "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `time` module provides a function, also called `time`, that returns returns
    the number of seconds since the “Unix epoch”, which is January 1, 1970, 00:00:00
    UTC (Coordinated Universal Time).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Use integer division and the modulus operator to compute the number of days
    since January 1, 1970 and the current time of day in hours, minutes, and seconds.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about the `time` module at [https://docs.python.org/3/library/time.html](https://docs.python.org/3/library/time.html).
  prefs: []
  type: TYPE_NORMAL
- en: 5.14.3\. Exercise[#](#id1 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are given three sticks, you may or may not be able to arrange them in
    a triangle. For example, if one of the sticks is 12 inches long and the other
    two are one inch long, you will not be able to get the short sticks to meet in
    the middle. For any three lengths, there is a test to see if it is possible to
    form a triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: If any of the three lengths is greater than the sum of the other two, then you
    cannot form a triangle. Otherwise, you can. (If the sum of two lengths equals
    the third, they form what is called a “degenerate” triangle.)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Write a function named `is_triangle` that takes three integers as arguments,
    and that prints either “Yes” or “No”, depending on whether you can or cannot form
    a triangle from sticks with the given lengths. Hint: Use a chained conditional.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.14.4\. Exercise[#](#id2 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What is the output of the following program? Draw a stack diagram that shows
    the state of the program when it prints the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 5.14.5\. Exercise[#](#id3 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following exercises use the `jupyturtle` module, described in Chapter 4.
  prefs: []
  type: TYPE_NORMAL
- en: Read the following function and see if you can figure out what it does. Then
    run it and see if you got it right. Adjust the values of `length`, `angle` and
    `factor` and see what effect they have on the result. If you are not sure you
    understand how it works, try asking a virtual assistant.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 5.14.6\. Exercise[#](#id4 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ask a virtual assistant “What is the Koch curve?”
  prefs: []
  type: TYPE_NORMAL
- en: To draw a Koch curve with length `x`, all you have to do is
  prefs: []
  type: TYPE_NORMAL
- en: Draw a Koch curve with length `x/3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn left 60 degrees.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw a Koch curve with length `x/3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn right 120 degrees.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw a Koch curve with length `x/3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Turn left 60 degrees.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw a Koch curve with length `x/3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The exception is if `x` is less than `5` – in that case, you can just draw a
    straight line with length `x`.
  prefs: []
  type: TYPE_NORMAL
- en: Write a function called `koch` that takes `x` as an argument and draws a Koch
    curve with the given length.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 5.14.7\. Exercise[#](#id5 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Virtual assistants know about the functions in the `jupyturtle` module, but
    there are many versions of these functions, with different names, so a VA might
    not know which one you are talking about.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem, you can provide additional information before you ask
    a question. For example, you could start a prompt with “Here’s a program that
    uses the `jupyturtle` module,” and then paste in one of the examples from this
    chapter. After that, the VA should be able to generate code that uses this module.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, ask a VA for a program that draws a Sierpiński triangle. The
    code you get should be a good starting place, but you might have to do some debugging.
    If the first attempt doesn’t work, you can tell the VA what happened and ask for
    help – or you can debug it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s what the result might look like, although the version you get might be
    different.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[Think Python: 3rd Edition](https://allendowney.github.io/ThinkPython/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Copyright 2024 [Allen B. Downey](https://allendowney.com)
  prefs: []
  type: TYPE_NORMAL
- en: 'Code license: [MIT License](https://mit-license.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Text license: [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
  prefs: []
  type: TYPE_NORMAL
