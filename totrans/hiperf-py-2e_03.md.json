["```py\n>>> %%timeit l = list(range(10))\n ...: l[5]\n ...:\n30.1 ns ± 0.996 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)\n\n>>> %%timeit l = list(range(10_000_000))\n ...: l[100_000]\n ...:\n28.9 ns ± 0.894 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)\n```", "```py\ndef linear_search(needle, array):\n    for i, item in enumerate(array):\n        if item == needle:\n            return i\n    return -1\n```", "```py\ndef binary_search(needle, haystack):\n    imin, imax = 0, len(haystack)\n    while True:\n        if imin > imax:\n            return -1\n        midpoint = (imin + imax) // 2\n        if haystack[midpoint] > needle:\n            imax = midpoint\n        elif haystack[midpoint] < needle:\n            imin = midpoint+1\n        else:\n            return midpoint\n```", "```py\nimport bisect\nimport random\n\ndef find_closest(haystack, needle):\n    # bisect.bisect_left will return the first value in the haystack\n    # that is greater than the needle\n    i = bisect.bisect_left(haystack, needle)\n    if i == len(haystack):\n        return i - 1\n    elif haystack[i] == needle:\n        return i\n    elif i > 0:\n        j = i - 1\n        # since we know the value is larger than needle (and vice versa for the\n        # value at j), we don't need to use absolute values here\n        if haystack[i] - needle > needle - haystack[j]:\n            return j\n    return i\n\nimportant_numbers = []\nfor i in range(10):\n    new_number = random.randint(0, 1000)\n    bisect.insort(important_numbers, new_number)\n\n# important_numbers will already be in order because we inserted new elements\n# with bisect.insort\nprint(important_numbers)\n# > [14, 265, 496, 661, 683, 734, 881, 892, 973, 992]\n\nclosest_index = find_closest(important_numbers, -250)\nprint(f\"Closest value to -250: {important_numbers[closest_index]}\")\n# > Closest value to -250: 14\n\nclosest_index = find_closest(important_numbers, 500)\nprint(f\"Closest value to 500: {important_numbers[closest_index]}\")\n# > Closest value to 500: 496\n\nclosest_index = find_closest(important_numbers, 1100)\nprint(f\"Closest value to 1100: {important_numbers[closest_index]}\")\n# > Closest value to 1100: 992\n```", "```py\n>>> numbers = [5, 8, 1, 3, 2, 6]\n>>> numbers[2] = 2 * numbers[0]  ![1](Images/1.png)\n>>> numbers\n[5, 8, 10, 3, 2, 6]\n```", "```py\n>>> len(numbers)\n6\n>>> numbers.append(42)\n>>> numbers\n[5, 8, 10, 3, 2, 6, 42]\n>>> len(numbers)\n7\n```", "```py\nM = (N >> 3) + (3 if N < 9 else 6)\n```", "```py\nl = [1, 2]\nfor i in range(3, 7):\n    l.append(i)\n```", "```py\n>>> %memit [i*i for i in range(100_000)]\npeak memory: 70.50 MiB, increment: 3.02 MiB\n\n>>> %%memit l = []\n... for i in range(100_000):\n...     l.append(i * 2)\n...\npeak memory: 67.47 MiB, increment: 8.17 MiB\n\n>>> %timeit [i*i for i in range(100_000)]\n7.99 ms ± 219 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n\n>>> %%timeit l = []\n... for i in range(100_000):\n...     l.append(i * 2)\n...\n12.2 ms ± 184 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n```", "```py\n>>> t = (1, 2, 3, 4)\n>>> t[0] = 5\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: 'tuple' object does not support item assignment\n```", "```py\n>>> t1 = (1, 2, 3, 4)\n>>> t2 = (5, 6, 7, 8)\n>>> t1 + t2\n(1, 2, 3, 4, 5, 6, 7, 8)\n```", "```py\n>>> %timeit l = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n95 ns ± 1.87 ns per loop (mean ± std. dev. of 7 runs, 10000000 loops each)\n\n>>> %timeit t = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n12.5 ns ± 0.199 ns per loop (mean ± std. dev. of 7 runs, 100000000 loops each)\n```"]