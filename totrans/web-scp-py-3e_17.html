<html><head></head><body><section data-pdf-bookmark="Chapter 15. Crawling Through APIs" data-type="chapter" epub:type="chapter"><div class="chapter" id="c-15">&#13;
<h1><span class="label">Chapter 15. </span>Crawling Through APIs</h1>&#13;
&#13;
<p>JavaScript has traditionally been the bane of web crawlers everywhere. At one point in the ancient history of the internet, you could be guaranteed that a request for an HTML page made to the web server would represent the same HTML website you would see in a browser.</p>&#13;
&#13;
<p>As JavaScript and Ajax content generation and loading become more ubiquitous, that situation is becoming less common. In <a data-type="xref" href="ch14.html#c-14">Chapter 14</a>, you looked at one way of solving this: using Selenium to automate a browser and fetch the data. This is an easy thing to do. It works almost all of the time.</p>&#13;
&#13;
<p>The problem is that, when you have a “hammer” as powerful and effective as Selenium, every web scraping problem starts to look a lot like a nail.</p>&#13;
&#13;
<p>In this chapter, you’ll look at cutting through the JavaScript entirely (no need to execute it or even load it!) and getting straight to the source of the data: the APIs that generate it.</p>&#13;
&#13;
<section data-pdf-bookmark="A Brief Introduction to APIs" data-type="sect1"><div class="sect1" id="id95">&#13;
<h1>A Brief Introduction to APIs</h1>&#13;
&#13;
<p>Although countless books, talks, and guides have <a contenteditable="false" data-primary="APIs (application programming interfaces)" data-type="indexterm" id="id764"/><a contenteditable="false" data-primary="application programming interfaces (APIs)" data-see="APIs (application programming interfaces)" data-type="indexterm" id="id765"/>been written about the intricacies of REST, GraphQL, JSON, and XML APIs, at their core they are based on a simple concept. An <em>API</em>, or Application Programming Interface, defines a standardized syntax that allows one piece of software to communicate with another piece of software, even though they might be written in different languages or otherwise structured <span class="keep-together">differently.</span></p>&#13;
&#13;
<p class="pagebreak-before">This section focuses on web APIs (in particular, APIs that allow a web server to communicate to a browser) and uses the term <em>API</em> to refer specifically to that type. But you may want to keep in mind that, in other contexts, <em>API</em> is also a generic term that can be used to, say, allow a Java program to communicate with a Python program running on the same machine. An API does not always have to be “across the internet” and does not necessarily involve any web technologies.</p>&#13;
&#13;
<p>Web APIs are most often used by developers who are using a well-advertised and documented public service. For example, the US National Weather Service provides a <a href="https://www.weather.gov/documentation/services-web-api">weather API</a> that gives current weather data and forecasts for any location. Google has dozens of APIs in its <a href="https://console.developers.google.com">Developers section</a> for language translations, analytics, and geolocation.</p>&#13;
&#13;
<p>The documentation for these APIs typically <a contenteditable="false" data-primary="APIs (application programming interfaces)" data-secondary="endpoints" data-type="indexterm" id="id766"/><a contenteditable="false" data-primary="endpoints" data-type="indexterm" id="id767"/>describes routes or <em>endpoints</em>, as URLs that you can request, with variable parameters, either <a contenteditable="false" data-primary="APIs (application programming interfaces)" data-secondary="GET" data-type="indexterm" id="id768"/>in the path of the URL or as <code>GET</code> parameters.</p>&#13;
&#13;
<p>For example, the following provides <code>pathparam</code> as a parameter in the route path:</p>&#13;
&#13;
<pre data-code-language="text" data-type="programlisting">&#13;
http://example.com/the-api-route/pathparam&#13;
</pre>&#13;
&#13;
<p>And this provides <code>pathparam</code> as the value for the parameter <code>param1</code>:</p>&#13;
&#13;
<pre data-code-language="text" data-type="programlisting">&#13;
http://example.com/the-api-route?param1=pathparam&#13;
</pre>&#13;
&#13;
<p>Both methods of passing variable data to the API are frequently used, although, like many topics in computer <a contenteditable="false" data-primary="APIs (application programming interfaces)" data-secondary="variable data" data-type="indexterm" id="id769"/>science, philosophic debate has raged on when and where variables should be passed through the path or through the parameters.</p>&#13;
&#13;
<p>The response from the API is usually <a contenteditable="false" data-primary="APIs (application programming interfaces)" data-secondary="responses" data-type="indexterm" id="id770"/><a contenteditable="false" data-primary="JSON (JavaScript Object Notation)" data-secondary="API response" data-type="indexterm" id="id771"/>returned in a JSON or XML format. JSON is far more popular in modern times than XML, but you may still see some XML responses. Many APIs allow you to change the response type, using another parameter to define which type of response you would like.</p>&#13;
&#13;
<p>Here’s an example of a JSON-formatted API response:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting">&#13;
<code class="p">{</code><code class="nt">"user"</code><code class="p">:{</code><code class="nt">"id"</code><code class="p">:</code><code class="w"> </code><code class="mi">123</code><code class="p">,</code><code class="w"> </code><code class="nt">"name"</code><code class="p">:</code><code class="w"> </code><code class="s2">"Ryan Mitchell"</code><code class="p">,</code><code class="w"> </code><code class="nt">"city"</code><code class="p">:</code><code class="w"> </code><code class="s2">"Boston"</code><code class="p">}}</code><code class="w"/>&#13;
</pre>&#13;
&#13;
<p>Here’s an example of an XML-formatted API <a contenteditable="false" data-primary="XML (Extensible Markup Language)" data-secondary="API response" data-type="indexterm" id="id772"/>response:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting">&#13;
<code class="nt">&lt;user&gt;&lt;id&gt;</code>123<code class="nt">&lt;/id&gt;&lt;name&gt;</code>Ryan<code class="w"> </code>Mitchell<code class="nt">&lt;/name&gt;&lt;city&gt;</code>Boston<code class="nt">&lt;/city&gt;&lt;/user&gt;</code><code class="w"/></pre>&#13;
&#13;
<p><a href="http://ip-api.com">ip-api.com</a> provides an easy-to-use and simple API that translates IP addresses to actual physical addresses. You can try a simple API request by entering the following in your browser:<sup><a data-type="noteref" href="ch15.html#id773" id="id773-marker">1</a></sup></p>&#13;
&#13;
<pre data-code-language="text" data-type="programlisting">&#13;
http://ip-api.com/json/50.78.253.58</pre>&#13;
&#13;
<p>This should produce a response like the following:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting">&#13;
<code class="p">{</code><code class="nt">"as"</code><code class="p">:</code><code class="w"> </code><code class="s2">"AS7922 Comcast Cable Communications, LLC"</code><code class="p">,</code><code class="nt">"city"</code><code class="p">:</code><code class="w"> </code><code class="s2">"Boston"</code><code class="p">,</code><code class="w"/>&#13;
<code class="nt">"country"</code><code class="p">:</code><code class="w"> </code><code class="s2">"United States"</code><code class="p">,</code><code class="nt">"countryCode"</code><code class="p">:</code><code class="w"> </code><code class="s2">"US"</code><code class="p">,</code><code class="w"/>&#13;
<code class="nt">"isp"</code><code class="p">:</code><code class="w"> </code><code class="s2">"Comcast Cable Communications"</code><code class="p">,</code><code class="nt">"lat"</code><code class="p">:</code><code class="w"> </code><code class="mf">42.3584</code><code class="p">,</code><code class="nt">"lon"</code><code class="p">:</code><code class="w"> </code><code class="mf">-71.0598</code><code class="p">,</code><code class="w"/>&#13;
<code class="nt">"org"</code><code class="p">:</code><code class="w"> </code><code class="s2">"Boston Park Plaza Hotel"</code><code class="p">,</code><code class="nt">"query"</code><code class="p">:</code><code class="w"> </code><code class="s2">"50.78.253.58"</code><code class="p">,</code><code class="w"/>&#13;
<code class="nt">"region"</code><code class="p">:</code><code class="w"> </code><code class="s2">"MA"</code><code class="p">,</code><code class="nt">"regionName"</code><code class="p">:</code><code class="w"> </code><code class="s2">"Massachusetts"</code><code class="p">,</code><code class="nt">"status"</code><code class="p">:</code><code class="w"> </code><code class="s2">"success"</code><code class="p">,</code><code class="w"/>&#13;
<code class="nt">"timezone"</code><code class="p">:</code><code class="w"> </code><code class="s2">"America/New_York"</code><code class="p">,</code><code class="nt">"zip"</code><code class="p">:</code><code class="w"> </code><code class="s2">"02116"</code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Notice that the request contains the parameter <code>json</code> in the path. You can request an XML or CSV response by changing this parameter accordingly:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
http://ip-api.com/xml/50.78.253.58&#13;
http://ip-api.com/csv/50.78.253.58&#13;
</pre>&#13;
&#13;
<section data-pdf-bookmark="HTTP Methods and APIs" data-type="sect2"><div class="sect2" id="id160">&#13;
<h2>HTTP Methods and APIs</h2>&#13;
&#13;
<p>In the previous section, you <a contenteditable="false" data-primary="APIs (application programming interfaces)" data-secondary="HTTP methods" data-type="indexterm" id="appht"/><a contenteditable="false" data-primary="HTTP (HyperText Transfer Protocol)" data-secondary="APIs" data-type="indexterm" id="hyxpp"/>looked at APIs making a <code>GET</code> request to the server for information. There are four main ways (or <em>methods</em>) to request information from a web server via HTTP:</p>&#13;
&#13;
<ul>&#13;
	<li>&#13;
	<p><code><code>GET</code></code></p>&#13;
	</li>&#13;
	<li>&#13;
	<p><code><code>POST</code></code></p>&#13;
	</li>&#13;
	<li>&#13;
	<p><code><code>PUT</code></code></p>&#13;
	</li>&#13;
	<li>&#13;
	<p><code><code>DELETE</code></code></p>&#13;
	</li>&#13;
</ul>&#13;
&#13;
<p>Technically, more than these four exist (such as <code>HEAD</code>, <code>OPTIONS</code>, and <code>CONNECT</code>), but they are rarely used in APIs, and it is unlikely that you will ever see them. The vast majority of APIs limit themselves to these four methods or even a subset of these four methods. It is common to see APIs that use only <code>GET</code>, or use only <code>GET</code> and <code>POST</code>.</p>&#13;
&#13;
<p><code>GET</code> is what you use when you visit a website through the address bar in your browser. <code>GET</code> is the method you are using when you make a call to <a href="http://ip-api.com/json/50.78.253.58"><em>http://ip-api.com/json/50.78.253.58</em></a>. You can think of <code>GET</code> as saying, “Hey, web server, please retrieve/get me this information.”</p>&#13;
&#13;
<p>A <code>GET</code> request, by definition, makes no changes to the information in the server’s database. Nothing is stored; nothing is modified. Information is only read.</p>&#13;
&#13;
<p><code>POST</code> is what you <a contenteditable="false" data-primary="APIs (application programming interfaces)" data-secondary="POST" data-type="indexterm" id="id774"/>use when you fill out a form or submit information, presumably to a backend script on the server. Every time you log in to a website, you are making a <code>POST</code> request with your username and (hopefully) encrypted password. If you are making a <code>POST</code> request with an API, you are saying, “Please store this information in your database.”</p>&#13;
&#13;
<p class="pagebreak-before"><code>PUT</code> is less commonly used <a contenteditable="false" data-primary="APIs (application programming interfaces)" data-secondary="PUT" data-type="indexterm" id="id775"/>when interacting with websites but is used from time to time in APIs. A <code>PUT</code> request is used to update an object or information. An API might require a <code>POST</code> request to create a new user, for example, but it might need a <code>PUT</code> request if you want to update that user’s email address.<sup><a data-type="noteref" href="ch15.html#id776" id="id776-marker">2</a></sup></p>&#13;
&#13;
<p><code>DELETE</code> is used, as you <a contenteditable="false" data-primary="APIs (application programming interfaces)" data-secondary="DELETE" data-type="indexterm" id="id777"/>might imagine, to delete an object. For instance, if you send a <code>DELETE</code> request to <em>http://example.com/user/23</em>, it will delete the user with the ID 23. <code>DELETE</code> methods are not often encountered in public APIs, which are primarily created to disseminate information or allow users to create or post information, rather than allow users to remove that information from their databases.</p>&#13;
&#13;
<p>Unlike <code>GET</code> requests, <code>POST</code>, <code>PUT</code>, and <code>DELETE</code> requests allow you to send information in the body of a request, in addition to the URL or route from which you are requesting data.</p>&#13;
&#13;
<p>Just like the response that you receive from the web server, this data in the body is typically formatted as JSON or, less commonly, as XML, and the format of this data is defined by the syntax of the API. For example, if you are using an API that creates comments on blog posts, you might make a <code>PUT</code> request to:</p>&#13;
&#13;
<pre data-code-language="text" data-type="programlisting">&#13;
http://example.com/comments?post=123&#13;
</pre>&#13;
&#13;
<p>with the following request body:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting">&#13;
<code class="p">{</code><code class="nt">"title"</code><code class="p">:</code><code class="w"> </code><code class="s2">"Great post about APIs!"</code><code class="p">,</code><code class="w"> </code><code class="nt">"body"</code><code class="p">:</code><code class="w"> </code><code class="s2">"Very informative. Really helped me </code>&#13;
<code class="s2">out with a tricky technical challenge I was facing. Thanks for taking the time </code>&#13;
<code class="s2">to write such a detailed blog post about PUT requests!"</code><code class="p">,</code><code class="w"> </code><code class="nt">"author"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="nt">"name"</code><code class="p">:</code><code class="s2">"Ryan </code>&#13;
<code class="s2">Mitchell"</code><code class="p">,</code><code class="w"> </code><code class="nt">"website"</code><code class="p">:</code><code class="w"> </code><code class="s2">"http://pythonscraping.com"</code><code class="p">,</code><code class="w"> </code><code class="nt">"company"</code><code class="p">:</code><code class="w"> </code><code class="s2">"O'Reilly Media"</code><code class="p">}}</code><code class="w"/>&#13;
</pre>&#13;
&#13;
<p>Note that the ID of the blog post (<code>123</code>) is passed as a parameter in the URL, where the content for the new comment you are making is passed in the body of the request. Parameters and data may be passed in both the parameter and the body. Which parameters are required and where they are passed is determined, again, by the syntax <a contenteditable="false" data-primary="APIs (application programming interfaces)" data-secondary="HTTP methods" data-startref="appht" data-type="indexterm" id="id778"/><a contenteditable="false" data-primary="HTTP (HyperText Transfer Protocol)" data-secondary="APIs" data-startref="hyxpp" data-type="indexterm" id="id779"/>of the API.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="More About API Responses" data-type="sect2"><div class="sect2" id="id161">&#13;
<h2>More About API Responses</h2>&#13;
&#13;
<p>As you saw in the ip-api.com example <a contenteditable="false" data-primary="APIs (application programming interfaces)" data-secondary="XML (Extensible Markup Language) and" data-type="indexterm" id="pxxkp"/><a contenteditable="false" data-primary="XML (Extensible Markup Language)" data-secondary="API response" data-type="indexterm" id="xxpp"/><a contenteditable="false" data-primary="JSON (JavaScript Object Notation)" data-secondary="API response" data-type="indexterm" id="jsojr"/><a contenteditable="false" data-primary="APIs (application programming interfaces)" data-secondary="JSON response and" data-type="indexterm" id="ppjsn"/>at the beginning of the chapter, an important feature of APIs is that they have well-formatted responses. The most common types of response formatting are <em>eXtensible Markup Language</em> (XML) and <em>JavaScript Object Notation</em> (JSON).</p>&#13;
&#13;
<p>In recent years, JSON has become vastly more popular than XML for a couple of major reasons. First, JSON files are generally smaller than well-designed XML files. Compare, for example, the following XML data, which clocks in at 98 characters:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting">&#13;
<code class="nt">&lt;user&gt;&lt;firstname&gt;</code>Ryan<code class="nt">&lt;/firstname&gt;&lt;lastname&gt;</code>Mitchell<code class="nt">&lt;/lastname&gt;&lt;username&gt;</code>Kludgist<code class="w"/>&#13;
<code class="nt">&lt;/username&gt;&lt;/user&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>And now look at the same data in JSON:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting">&#13;
<code class="p">{</code><code class="nt">"user"</code><code class="p">:{</code><code class="nt">"firstname"</code><code class="p">:</code><code class="s2">"Ryan"</code><code class="p">,</code><code class="nt">"lastname"</code><code class="p">:</code><code class="s2">"Mitchell"</code><code class="p">,</code><code class="nt">"username"</code><code class="p">:</code><code class="s2">"Kludgist"</code><code class="p">}}</code><code class="w"/></pre>&#13;
&#13;
<p>This is only 73 characters, or a whopping 36% smaller than the equivalent XML.</p>&#13;
&#13;
<p>Of course, one could argue that the XML could be formatted like this:</p>&#13;
&#13;
<pre data-code-language="xml" data-executable="true" data-type="programlisting">&#13;
<code class="nt">&lt;user</code><code class="w"> </code><code class="na">firstname=</code><code class="s">"ryan"</code><code class="w"> </code><code class="na">lastname=</code><code class="s">"mitchell"</code><code class="w"> </code><code class="na">username=</code><code class="s">"Kludgist"</code><code class="nt">&gt;&lt;/user&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>But this is considered bad practice because it doesn’t support deep nesting of data. Regardless, it still requires 71 characters, about the same length as the equivalent JSON.</p>&#13;
&#13;
<p>Another reason JSON is quickly becoming more popular than XML is due to a shift in web technologies. In the past, it was more common for a server-side script such as PHP or .NET to be on the receiving end of an API. Nowadays, it is likely that a framework, such as Angular or Backbone, will be sending and receiving API calls. Server-side technologies are somewhat agnostic as to the form in which their data comes. But JavaScript libraries like Backbone find JSON easier to handle.</p>&#13;
&#13;
<p>Although APIs are typically thought of as having either an XML response or a JSON response, anything is possible. The response type of the API is limited only by the imagination of the programmer who created it. CSV is another typical response output (as seen in the ip-api.com example). Some APIs may even be designed to generate files. A request may be made to a server to generate an image with some particular text overlaid on it or to request a particular XLSX or PDF file.</p>&#13;
&#13;
<p>Some APIs return no response at all. For example, if you are making a request to a server to create a new blog post comment, it may return only an HTTP response code 200, meaning “I posted the comment; everything is great!” Others may return a minimal response like this:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting">&#13;
<code class="p">{</code><code class="nt">"success"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">}</code><code class="w"/>&#13;
</pre>&#13;
&#13;
<p>If an error occurs, you may get a response like this:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting">&#13;
<code class="p">{</code><code class="nt">"error"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="nt">"message"</code><code class="p">:</code><code class="w"> </code><code class="s2">"Something super bad happened"</code><code class="p">}}</code><code class="w"/>&#13;
</pre>&#13;
&#13;
<p>Or if the API is not particularly well configured, you may get a nonparsable stack trace or some plain English text. When making a request to an API, it’s usually wise to first check that the response you get is actually JSON (or XML, or CSV, or whatever format you’re <a contenteditable="false" data-primary="APIs (application programming interfaces)" data-secondary="XML (Extensible Markup Language) and" data-startref="pxxkp" data-type="indexterm" id="id780"/><a contenteditable="false" data-primary="XML (Extensible Markup Language)" data-secondary="API response" data-startref="xxpp" data-type="indexterm" id="id781"/><a contenteditable="false" data-primary="JSON (JavaScript Object Notation)" data-secondary="API response" data-startref="jsojr" data-type="indexterm" id="id782"/><a contenteditable="false" data-primary="APIs (application programming interfaces)" data-secondary="JSON response and" data-startref="ppjsn" data-type="indexterm" id="id783"/>expecting back).</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Parsing JSON" data-type="sect1"><div class="sect1" id="id96">&#13;
<h1>Parsing JSON</h1>&#13;
&#13;
<p>In this chapter, you’ve looked <a contenteditable="false" data-primary="JSON (JavaScript Object Notation)" data-secondary="parsing" data-type="indexterm" id="jsjbp"/><a contenteditable="false" data-primary="parsing JSON" data-type="indexterm" id="psgjs"/>at various types of APIs and how they function, and you’ve looked at sample JSON responses from these APIs. Now let’s look at how to parse and use this information.</p>&#13;
&#13;
<p>At the beginning of the chapter you saw the example of the ip-api.com  API, which resolves IP addresses to physical addresses:</p>&#13;
&#13;
<pre class="pre" data-code-language="text" data-type="programlisting">&#13;
http://ip-api.com/json/50.78.253.58</pre>&#13;
&#13;
<p>You can take the output of this request and use Python’s JSON-parsing functions to decode it:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="kn">import</code> <code class="nn">json</code>&#13;
<code class="kn">from</code> <code class="nn">urllib.request</code> <code class="kn">import</code> <code class="n">urlopen</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">getCountry</code><code class="p">(</code><code class="n">ipAddress</code><code class="p">):</code>&#13;
    <code class="n">response</code> <code class="o">=</code> <code class="n">urlopen</code><code class="p">(</code><code class="s1">'http://ip-api.com/json/'</code><code class="o">+</code><code class="n">ipAddress</code><code class="p">)</code><code class="o">.</code><code class="n">read</code><code class="p">()</code>&#13;
    <code class="err">​</code>    <code class="o">.</code><code class="n">decode</code><code class="p">(</code><code class="s1">'utf-8'</code><code class="p">)</code>&#13;
    <code class="n">responseJson</code> <code class="o">=</code> <code class="n">json</code><code class="o">.</code><code class="n">loads</code><code class="p">(</code><code class="n">response</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="n">responseJson</code><code class="o">.</code><code class="n">get</code><code class="p">(</code><code class="s1">'countryCode'</code><code class="p">)</code>&#13;
&#13;
<code class="nb">print</code><code class="p">(</code><code class="n">getCountry</code><code class="p">(</code><code class="s1">'50.78.253.58'</code><code class="p">))</code></pre>&#13;
&#13;
<p>This prints the country code for the IP address 50.78.253.58.</p>&#13;
&#13;
<p>The JSON parsing library used <a contenteditable="false" data-primary="Python" data-secondary="JSON parsing library" data-type="indexterm" id="id784"/><a contenteditable="false" data-primary="JSON (JavaScript Object Notation)" data-secondary="parsing library" data-type="indexterm" id="id785"/>is part of Python’s core library. Just type in <code>import json</code> at the top, and you’re all set! Unlike many languages that might parse JSON into a special JSON object or JSON node, Python uses a more flexible approach and turns JSON objects into dictionaries, JSON arrays into lists, JSON strings into strings, and so forth. In this way, it is extremely easy to access and manipulate values stored in JSON.</p>&#13;
&#13;
<p>The following gives a quick demonstration of how Python’s JSON library handles the values that might be encountered in a JSON string:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="kn">import</code> <code class="nn">json</code>&#13;
&#13;
<code class="n">jsonString</code> <code class="o">=</code> <code class="s1">'{"arrayOfNums":[{"number":0},{"number":1},{"number":2}],</code><code class="w"/>&#13;
               <code class="s2">"arrayOfFruits"</code><code class="p">:[{</code><code class="s2">"fruit"</code><code class="p">:</code><code class="s2">"apple"</code><code class="p">},{</code><code class="s2">"fruit"</code><code class="p">:</code><code class="s2">"banana"</code><code class="p">},</code>&#13;
                               <code class="p">{</code><code class="s2">"fruit"</code><code class="p">:</code><code class="s2">"pear"</code><code class="p">}]}</code><code class="s1">'</code><code class="w"/>&#13;
<code class="n">jsonObj</code> <code class="o">=</code> <code class="n">json</code><code class="o">.</code><code class="n">loads</code><code class="p">(</code><code class="n">jsonString</code><code class="p">)</code>&#13;
&#13;
<code class="nb">print</code><code class="p">(</code><code class="n">jsonObj</code><code class="o">.</code><code class="n">get</code><code class="p">(</code><code class="s1">'arrayOfNums'</code><code class="p">))</code>&#13;
<code class="nb">print</code><code class="p">(</code><code class="n">jsonObj</code><code class="o">.</code><code class="n">get</code><code class="p">(</code><code class="s1">'arrayOfNums'</code><code class="p">)[</code><code class="mi">1</code><code class="p">])</code>&#13;
<code class="nb">print</code><code class="p">(</code><code class="n">jsonObj</code><code class="o">.</code><code class="n">get</code><code class="p">(</code><code class="s1">'arrayOfNums'</code><code class="p">)[</code><code class="mi">1</code><code class="p">]</code><code class="o">.</code><code class="n">get</code><code class="p">(</code><code class="s1">'number'</code><code class="p">)</code> <code class="o">+</code>&#13;
      <code class="n">jsonObj</code><code class="o">.</code><code class="n">get</code><code class="p">(</code><code class="s1">'arrayOfNums'</code><code class="p">)[</code><code class="mi">2</code><code class="p">]</code><code class="o">.</code><code class="n">get</code><code class="p">(</code><code class="s1">'number'</code><code class="p">))</code>&#13;
<code class="nb">print</code><code class="p">(</code><code class="n">jsonObj</code><code class="o">.</code><code class="n">get</code><code class="p">(</code><code class="s1">'arrayOfFruits'</code><code class="p">)[</code><code class="mi">2</code><code class="p">]</code><code class="o">.</code><code class="n">get</code><code class="p">(</code><code class="s1">'fruit'</code><code class="p">))</code></pre>&#13;
&#13;
<p class="pagebreak-before">Here is the output:</p>&#13;
&#13;
<pre data-code-language="text" data-type="programlisting">&#13;
[{'number': 0}, {'number': 1}, {'number': 2}]&#13;
{'number': 1}&#13;
3&#13;
pear</pre>&#13;
&#13;
<p>Line 1 is a list of dictionary objects, line 2 is a dictionary object, line 3 is an integer (the sum of the integers accessed <a contenteditable="false" data-primary="JSON (JavaScript Object Notation)" data-secondary="parsing" data-startref="jsjbp" data-type="indexterm" id="id786"/><a contenteditable="false" data-primary="parsing JSON" data-startref="psgjs" data-type="indexterm" id="id787"/>in the dictionaries), and line 4 is a string.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Undocumented APIs" data-type="sect1"><div class="sect1" id="id162">&#13;
<h1>Undocumented APIs</h1>&#13;
&#13;
<p>So far in this chapter, we’ve discussed <a contenteditable="false" data-primary="APIs (application programming interfaces)" data-secondary="undocumented" data-type="indexterm" id="appmmud"/>only APIs that are documented. Their developers intend them to be used by the public, publish information about them, and assume that the APIs will be used by other developers. But the vast majority of APIs don’t have any published documentation at all.</p>&#13;
&#13;
<p>But why would you create an API without any public documentation? As mentioned in the beginning of this chapter, it all has to do with JavaScript.</p>&#13;
&#13;
<p>Traditionally, the web servers for dynamic websites had several tasks whenever a user requested a page:</p>&#13;
&#13;
<ul>&#13;
	<li>&#13;
	<p>Handle <code>GET</code> requests from users requesting a page of a website</p>&#13;
	</li>&#13;
	<li>&#13;
	<p>Retrieve the data from the database that appears on that page</p>&#13;
	</li>&#13;
	<li>&#13;
	<p>Format the data into the HTML template for the page</p>&#13;
	</li>&#13;
	<li>&#13;
	<p>Send that formatted HTML to the user</p>&#13;
	</li>&#13;
</ul>&#13;
&#13;
<p>As JavaScript frameworks became more ubiquitous, many of the HTML creation tasks handled by the server moved into the browser. The server might send a hardcoded HTML template to the user’s browser, but separate Ajax requests would be made to load the content and place it in the correct slots in that HTML template. All this would happen on the browser/client side.</p>&#13;
&#13;
<p>This was initially a problem for web scrapers. They were accustomed to making a request for an HTML page and getting back exactly that—an HTML page with all of the content already in place. Instead, they now got an HTML template without any content.</p>&#13;
&#13;
<p>Selenium was used to solve this problem. Now the programmer’s web scraper could become the browser, request the HTML template, execute any JavaScript, allow all the data to load in its place, and only <em>then</em> scrape the page for data. Because the HTML was all loaded, it was essentially reduced to a previously solved problem—the problem of parsing and formatting existing HTML.</p>&#13;
&#13;
<p class="pagebreak-before">However, because the entire content management system (that used to reside only in the web server) had essentially moved to the browser client, even the simplest websites could balloon into several megabytes of content and a dozen HTTP requests.</p>&#13;
&#13;
<p>In addition, when Selenium is used, all of the “extras” that the user doesn’t necessarily care about are loaded: calls to tracking programs, loading sidebar ads, calls to tracking programs for the sidebar ads. Images, CSS, third-party font data—all of it needs to be loaded. This may seem great when you’re using a browser to browse the web, but if you’re writing a web scraper that needs to move fast, collect specific data, and place the lowest possible load on the web server, you can be loading a hundred times more data than you need.</p>&#13;
&#13;
<p>But there’s a silver lining to all of this JavaScript, Ajax, and web modernization: because servers are no longer formatting the data into HTML, they often act as thin wrappers around the database itself. This thin wrapper simply extracts data from the database and returns it to the page via an API.</p>&#13;
&#13;
<p>Of course, these APIs aren’t meant to be used by anyone or anything besides the web page itself, and so developers leave them undocumented and assume (or hope) that no one will notice them. But they do exist.</p>&#13;
&#13;
<p>The American retail giant target.com, for example, loads all of its search results via JSON. You can search for a product on their site by visiting <a href="https://www.target.com/s?searchTerm=web%20scraping%20with%20python"><em>https://www.target.com/s?searchTerm=web%20scraping%20with%20python</em></a>.</p>&#13;
&#13;
<p>If you scrape this page using urllib or the Requests library, you won’t find any search results. These are loaded separately via an API call to the URL:</p>&#13;
&#13;
<pre data-code-language="text">&#13;
https://redsky.target.com/redsky_aggregations/v1/web/plp_search_v2</pre>&#13;
&#13;
<p>Because Target’s API requires a key for each request, and those API keys time out, I recommend that you try this out yourself and see the JSON results.</p>&#13;
&#13;
<p>You could, of course, use Selenium to load all the search results and parse the resulting HTML. However, you would be making about 260 requests and transferring megabytes of data with each search. Using the API directly, you make only one request and transfer <a contenteditable="false" data-primary="APIs (application programming interfaces)" data-secondary="undocumented" data-startref="appmmud" data-type="indexterm" id="id788"/>approximately only the 10 kb of nicely formatted data that you need.</p>&#13;
&#13;
<section data-pdf-bookmark="Finding Undocumented APIs" data-type="sect2"><div class="sect2" id="id249">&#13;
<h2>Finding Undocumented APIs</h2>&#13;
&#13;
<p>You’ve used the Chrome inspector in previous chapters to examine the contents of an HTML page, but now you’ll use it for a slightly different purpose: to examine the requests and responses of the calls that are used to construct that page.</p>&#13;
&#13;
<p>To do this, open the Chrome inspector window and click the Network tab, shown in <a data-type="xref" href="#chromeinspect">Figure 15-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="chromeinspect"><img alt="" class="iimagesnetworkinspectorpng" src="assets/wsp3_1501.png"/>&#13;
<h6><span class="label">Figure 15-1. </span>The Chrome network inspector tool provides a view into all calls your browser is making and receiving</h6>&#13;
</div></figure>&#13;
&#13;
<p>Note that you need to open this window before the page loads. It does not track network calls while it’s closed.</p>&#13;
&#13;
<p>While the page is loading, you’ll see a line appear in real time whenever your browser makes a call back to the web server for additional information to render the page. This may include an API call.</p>&#13;
&#13;
<p>Finding undocumented APIs can take a little detective work (to take the detective work out of this, see <a data-type="xref" href="#documenting_undocumented_apis">“Documenting Undocumented APIs”</a>), especially with larger sites with lots of network calls. Generally, though, you’ll know it when you see it.</p>&#13;
&#13;
<p>API calls tend to have several features that are useful for locating them in the list of network calls:</p>&#13;
&#13;
<ul>&#13;
	<li>&#13;
	<p>They often have JSON or XML in them. You can filter the list of requests by using the search/filter field.</p>&#13;
	</li>&#13;
	<li>&#13;
	<p>With <code>GET</code> requests, the URL will contain the parameter values passed to them. This will be useful if, for example, you’re looking for an API call that returns the results of a search or is loading data for a specific page. Simply filter the results with the search term you used, page ID, or other identifying information.</p>&#13;
	</li>&#13;
	<li>&#13;
	<p>They will usually be of the type XHR.</p>&#13;
	</li>&#13;
</ul>&#13;
&#13;
<p>APIs may not always be obvious, especially in large sites with lots of features that may make hundreds of calls while loading a single page. However, spotting the metaphorical needle in the haystack becomes much easier with a little practice.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Documenting Undocumented APIs" data-type="sect2"><div class="sect2" id="documenting_undocumented_apis">&#13;
<h2>Documenting Undocumented APIs</h2>&#13;
&#13;
<p>After you’ve found an API call being made, it’s <a contenteditable="false" data-primary="APIs (application programming interfaces)" data-secondary="undocumented" data-startref="appmmud" data-type="indexterm" id="id789"/>often useful to document it to some extent, especially if your scrapers will rely heavily on the call. You may want to load several pages on the website, filtering for the target API call in the inspector console Network tab. By doing this, you can see how the call changes from page to page and identify the fields that it accepts and returns.</p>&#13;
&#13;
<p>Every API call can be identified and documented by paying attention to the following fields:</p>&#13;
&#13;
<ul>&#13;
	<li>&#13;
	<p>HTTP method used</p>&#13;
	</li>&#13;
	<li>&#13;
	<p>Inputs</p>&#13;
&#13;
	<ul>&#13;
		<li>&#13;
		<p>Path parameters</p>&#13;
		</li>&#13;
		<li>&#13;
		<p>Headers (including cookies)</p>&#13;
		</li>&#13;
		<li>&#13;
		<p>Body content (for <code>PUT</code> and <code>POST</code> calls)</p>&#13;
		</li>&#13;
	</ul>&#13;
	</li>&#13;
	<li>&#13;
	<p>Outputs</p>&#13;
&#13;
	<ul>&#13;
		<li>&#13;
		<p>Response headers (including cookies set)</p>&#13;
		</li>&#13;
		<li>&#13;
		<p>Response body type</p>&#13;
		</li>&#13;
		<li>&#13;
		<p>Response body fields</p>&#13;
		</li>&#13;
	</ul>&#13;
	</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Combining APIs with Other Data Sources" data-type="sect1"><div class="sect1" id="id164">&#13;
<h1>Combining APIs with Other Data Sources</h1>&#13;
&#13;
<p>Although the raison d'être of many <a contenteditable="false" data-primary="APIs (application programming interfaces)" data-secondary="combining with data sources" data-type="indexterm" id="appgbds"/>modern web applications is to take existing data and format it in a more appealing way, I would argue that this isn’t an interesting thing to do in most instances. If you’re using an API as your only data source, the best you can do is merely copy someone else’s database that already exists and which is, essentially, already published. What can be far more interesting is to take two or more data sources and combine them in a novel way or use an API as a tool to look at scraped data from a new perspective.</p>&#13;
&#13;
<p>Let’s look at one example of how data from APIs can be used in conjunction with web scraping to see which parts of the world contribute the most to Wikipedia.</p>&#13;
&#13;
<p class="pagebreak-before">If you’ve spent much time on Wikipedia, you’ve likely come across an article’s revision history page, which displays a list of recent edits. If users are logged in to Wikipedia when they make the edit, their username is displayed. If they are not logged in, their IP address is recorded, as shown in <a data-type="xref" href="#wiki_history">Figure 15-2</a>.</p>&#13;
&#13;
<figure><div class="figure" id="wiki_history"><img alt="Alt Text" class="iimageswikipedia_historypagepng" src="assets/wsp3_1502.png"/>&#13;
<h6><span class="label">Figure 15-2. </span>The IP address of an anonymous editor on the revision history page for Wikipedia’s Python entry</h6>&#13;
</div></figure>&#13;
&#13;
<p>The IP address provided on the history page is 121.97.110.145. By using the ip-api.com API, that IP address is from Quezon, Philippines, as of this writing (IP addresses can occasionally shift geographically).</p>&#13;
&#13;
<p>This information isn’t all that interesting on its own, but what if you could gather many points of geographic data about Wikipedia edits and where they occur? A few years ago, I did just that and used <a href="https://developers.google.com/chart/interactive/docs/gallery/geochart">Google’s GeoChart library</a> to create an <a href="http://www.pythonscraping.com/pages/wikipedia.html">interesting chart</a> that shows the origins of edits to the English-language Wikipedia, as well as the Wikipedias written in other languages (<a data-type="xref" href="#geochart_library">Figure 15-3</a>).</p>&#13;
&#13;
<figure><div class="figure" id="geochart_library"><img alt="Alt Text" class="iwikipediaeditspng" src="assets/wsp3_1503.png"/>&#13;
<h6><span class="label">Figure 15-3. </span>Visualization of Wikipedia edits created using Google’s GeoChart library</h6>&#13;
</div></figure>&#13;
&#13;
<p>Creating a basic script that crawls Wikipedia, looks for revision history pages, and then looks for IP addresses on those revision history pages isn’t difficult. Using modified code from <a data-type="xref" href="ch06.html#c-6">Chapter 6</a>, the following script does just that:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="k">def</code> <code class="nf">getLinks</code><code class="p">(</code><code class="n">articleUrl</code><code class="p">):</code>&#13;
    <code class="n">html</code> <code class="o">=</code> <code class="n">urlopen</code><code class="p">(</code><code class="sa">f</code><code class="s1">'http://en.wikipedia.org</code><code class="si">{</code><code class="n">articleUrl</code><code class="si">}</code><code class="s1">'</code><code class="p">)</code>&#13;
    <code class="n">bs</code> <code class="o">=</code> <code class="n">BeautifulSoup</code><code class="p">(</code><code class="n">html</code><code class="p">,</code> <code class="s1">'html.parser'</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="n">bs</code><code class="o">.</code><code class="n">find</code><code class="p">(</code><code class="s1">'div'</code><code class="p">,</code> <code class="p">{</code><code class="s1">'id'</code><code class="p">:</code><code class="s1">'bodyContent'</code><code class="p">})</code><code class="o">.</code><code class="n">findAll</code><code class="p">(</code><code class="s1">'a'</code><code class="p">,</code> &#13;
        <code class="n">href</code><code class="o">=</code><code class="n">re</code><code class="o">.</code><code class="n">compile</code><code class="p">(</code><code class="s1">'^(/wiki/)((?!:).)*$'</code><code class="p">))</code>&#13;
&#13;
<code class="k">def</code> <code class="nf">getHistoryIPs</code><code class="p">(</code><code class="n">pageUrl</code><code class="p">):</code>&#13;
    <code class="c1">#Format of revision history pages is: </code>&#13;
    <code class="c1">#http://en.wikipedia.org/w/index.php?title=Title_in_URL&amp;action=history</code>&#13;
    <code class="n">pageUrl</code> <code class="o">=</code> <code class="n">pageUrl</code><code class="o">.</code><code class="n">replace</code><code class="p">(</code><code class="s1">'/wiki/'</code><code class="p">,</code> <code class="s1">''</code><code class="p">)</code>&#13;
    <code class="n">historyUrl</code> <code class="o">=</code> <code class="sa">f</code><code class="s1">'http://en.wikipedia.org/w/index.php?title=</code><code class="si">{</code><code class="n">pageUrl</code><code class="si">}</code><code class="se">\</code>&#13;
<code class="s1">    &amp;action=history'</code>&#13;
    <code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'history url is: </code><code class="si">{</code><code class="n">historyUrl</code><code class="si">}</code><code class="s1">'</code><code class="p">)</code>&#13;
    <code class="n">bs</code> <code class="o">=</code> <code class="n">BeautifulSoup</code><code class="p">(</code><code class="n">urlopen</code><code class="p">(</code><code class="n">historyUrl</code><code class="p">),</code> <code class="s1">'html.parser'</code><code class="p">)</code>&#13;
    <code class="c1">#finds only the links with class "mw-anonuserlink" which has IP addresses </code>&#13;
    <code class="c1">#instead of usernames</code>&#13;
    <code class="n">ipAddresses</code> <code class="o">=</code> <code class="n">bs</code><code class="o">.</code><code class="n">findAll</code><code class="p">(</code><code class="s1">'a'</code><code class="p">,</code> <code class="p">{</code><code class="s1">'class'</code><code class="p">:</code><code class="s1">'mw-anonuserlink'</code><code class="p">})</code>&#13;
    <code class="k">return</code> <code class="nb">set</code><code class="p">([</code><code class="n">ip</code><code class="o">.</code><code class="n">get_text</code><code class="p">()</code> <code class="k">for</code> <code class="n">ip</code> <code class="ow">in</code> <code class="n">ipAddresses</code><code class="p">])</code>&#13;
&#13;
<code class="n">links</code> <code class="o">=</code> <code class="n">getLinks</code><code class="p">(</code><code class="s1">'/wiki/Python_(programming_language)'</code><code class="p">)</code>&#13;
&#13;
<code class="k">while</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="n">links</code><code class="p">)</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">):</code>&#13;
    <code class="k">for</code> <code class="n">link</code> <code class="ow">in</code> <code class="n">links</code><code class="p">:</code>&#13;
        <code class="nb">print</code><code class="p">(</code><code class="s1">'-'</code><code class="o">*</code><code class="mi">20</code><code class="p">)</code> &#13;
        <code class="n">historyIPs</code> <code class="o">=</code> <code class="n">getHistoryIPs</code><code class="p">(</code><code class="n">link</code><code class="o">.</code><code class="n">attrs</code><code class="p">[</code><code class="s1">'href'</code><code class="p">])</code>&#13;
        <code class="k">for</code> <code class="n">historyIP</code> <code class="ow">in</code> <code class="n">historyIPs</code><code class="p">:</code>&#13;
            <code class="nb">print</code><code class="p">(</code><code class="n">historyIP</code><code class="p">)</code>&#13;
&#13;
    <code class="n">newLink</code> <code class="o">=</code> <code class="n">links</code><code class="p">[</code><code class="n">random</code><code class="o">.</code><code class="n">randint</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="nb">len</code><code class="p">(</code><code class="n">links</code><code class="p">)</code><code class="o">-</code><code class="mi">1</code><code class="p">)]</code><code class="o">.</code><code class="n">attrs</code><code class="p">[</code><code class="s1">'href'</code><code class="p">]</code>&#13;
    <code class="n">links</code> <code class="o">=</code> <code class="n">getLinks</code><code class="p">(</code><code class="n">newLink</code><code class="p">)</code>&#13;
</pre>&#13;
&#13;
<p>This program uses two main functions: <code>getLinks</code> (which was also used in <a data-type="xref" href="ch06.html#c-6">Chapter 6</a>), and the  new <code>getHistoryIPs</code>, which searches for the contents of all links with the class <code>mw-anonuserlink</code> (indicating an anonymous user with an IP address, rather than a username) and returns it as a set.</p>&#13;
&#13;
<p>This code also uses a somewhat arbitrary (yet effective for the purposes of this example) search pattern to look for articles from which to retrieve revision histories. It starts by retrieving the histories of all Wikipedia articles linked to by the starting page (in this case, the article on the Python programming language). Afterward, it randomly selects a new starting page and retrieves all revision history pages of articles linked to by that page. It will continue until it hits a page with no links.</p>&#13;
&#13;
<p>Now that you have code that retrieves IP addresses as a string, you can combine this with the <code>getCountry</code> function from the previous section to resolve these IP addresses to countries. You’ll modify <code>getCountry</code> slightly to account for invalid or malformed IP addresses that result in a 404 Not Found error:</p>&#13;
&#13;
<pre data-code-language="python" data-executable="true" data-type="programlisting">&#13;
<code class="k">def</code> <code class="nf">getCountry</code><code class="p">(</code><code class="n">ipAddress</code><code class="p">):</code>&#13;
    <code class="k">try</code><code class="p">:</code>&#13;
      <code class="n">response</code> <code class="o">=</code> <code class="n">urlopen</code><code class="p">(</code><code class="sa">f</code><code class="s1">'https://ipwho.is/</code><code class="si">{</code><code class="n">ipAddress</code><code class="si">}</code><code class="s1">'</code><code class="p">)</code><code class="o">.</code><code class="n">read</code><code class="p">()</code><code class="o">.</code><code class="n">decode</code><code class="p">(</code><code class="s1">'utf-8'</code><code class="p">)</code>&#13;
    <code class="k">except</code> <code class="n">HTTPError</code><code class="p">:</code>&#13;
      <code class="k">return</code> <code class="kc">None</code>&#13;
    <code class="n">responseJson</code> <code class="o">=</code> <code class="n">json</code><code class="o">.</code><code class="n">loads</code><code class="p">(</code><code class="n">response</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="n">responseJson</code><code class="o">.</code><code class="n">get</code><code class="p">(</code><code class="s1">'country_code'</code><code class="p">)</code>&#13;
    &#13;
<code class="n">links</code> <code class="o">=</code> <code class="n">getLinks</code><code class="p">(</code><code class="s1">'/wiki/Python_(programming_language)'</code><code class="p">)</code>&#13;
&#13;
<code class="k">while</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="n">links</code><code class="p">)</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">):</code>&#13;
    <code class="k">for</code> <code class="n">link</code> <code class="ow">in</code> <code class="n">links</code><code class="p">:</code>&#13;
      <code class="nb">print</code><code class="p">(</code><code class="s1">'-'</code><code class="o">*</code><code class="mi">20</code><code class="p">)</code> &#13;
      <code class="n">historyIPs</code> <code class="o">=</code> <code class="n">getHistoryIPs</code><code class="p">(</code><code class="n">link</code><code class="o">.</code><code class="n">attrs</code><code class="p">[</code><code class="s2">"href"</code><code class="p">])</code>&#13;
      <code class="k">for</code> <code class="n">historyIP</code> <code class="ow">in</code> <code class="n">historyIPs</code><code class="p">:</code>&#13;
          <code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="si">{</code><code class="n">historyIP</code><code class="si">}</code><code class="s1"> is from </code><code class="si">{</code><code class="n">getCountry</code><code class="p">(</code><code class="n">historyIP</code><code class="p">)</code><code class="si">}</code><code class="s1">'</code><code class="p">)</code>&#13;
&#13;
    <code class="n">newLink</code> <code class="o">=</code> <code class="n">links</code><code class="p">[</code><code class="n">random</code><code class="o">.</code><code class="n">randint</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="nb">len</code><code class="p">(</code><code class="n">links</code><code class="p">)</code><code class="o">-</code><code class="mi">1</code><code class="p">)]</code><code class="o">.</code><code class="n">attrs</code><code class="p">[</code><code class="s1">'href'</code><code class="p">]</code>&#13;
    <code class="n">links</code> <code class="o">=</code> <code class="n">getLinks</code><code class="p">(</code><code class="n">newLink</code><code class="p">)</code>&#13;
</pre>&#13;
&#13;
<p>Here’s the sample output:</p>&#13;
&#13;
<pre data-code-language="text" data-type="programlisting">&#13;
--------------------&#13;
history url is: http://en.wikipedia.org/w/index.php?title=Programming_paradigm&amp;a&#13;
ction=history&#13;
2405:201:2009:80b0:41bc:366f:a49c:52f2 is from IN&#13;
115.186.189.53 is from PK&#13;
103.252.145.68 is from IN&#13;
2405:201:400b:7058:b128:89fd:5248:f249 is from IN&#13;
172.115.220.47 is from US&#13;
2806:1016:d:54b6:8950:4501:c00b:507a is from MX&#13;
36.255.87.160 is from IN&#13;
2603:6011:1100:a1d0:31bd:8a11:a0c8:e4c3 is from US&#13;
2806:108e:d:bd2c:a577:db4f:2867:2b5c is from MX&#13;
2409:4042:e8f:8d39:b50c:f4ca:91b8:eb9d is from IN&#13;
107.190.108.84 is from CA&#13;
--------------------&#13;
history url is: http://en.wikipedia.org/w/index.php?title=Multi-paradigm_program&#13;
ming_language&amp;action=history&#13;
98.197.198.46 is from US&#13;
75.139.254.117 is from US&#13;
</pre>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="More About APIs" data-type="sect1"><div class="sect1" id="id97">&#13;
<h1>More About APIs</h1>&#13;
&#13;
<p>This chapter has shown a few ways <a contenteditable="false" data-primary="APIs (application programming interfaces)" data-secondary="combining with data sources" data-startref="appgbds" data-type="indexterm" id="id790"/>that modern APIs are commonly used to access data on the web, and how those APIs can be used to build faster and more powerful web scrapers. If you’re looking to build APIs instead of just using them, or if you want to learn more about the theory of their construction and syntax, I recommend <a class="orm:hideurl" href="http://bit.ly/RESTful-Web-APIs"><em>RESTful Web APIs</em></a> by Leonard Richardson, Mike Amundsen, and Sam Ruby (O’Reilly). This book provides a strong overview of the theory <a contenteditable="false" data-primary="RESTful Web APIs" data-type="indexterm" id="id791"/>and practice of using APIs on the web. In addition, Mike Amundsen has a fascinating video series, <a href="http://oreil.ly/1GOXNhE"><em>Designing APIs for the Web</em></a> (O’Reilly), that teaches you how to create your own APIs—a useful thing to know if you decide to make your scraped data available to the public in a convenient format.</p>&#13;
&#13;
<p>While some might bemoan the ubiquity of JavaScript and dynamic websites, making traditional “grab and parse the HTML page” practices outdated, I, for one, welcome our new robot overlords. As dynamic websites rely less on HTML pages for human consumption and more on strictly formatted JSON files for HTML consumption, this provides a boon for everyone trying to get clean, well-formatted data.</p>&#13;
&#13;
<p>The web is no longer a collection of HTML pages with occasional multimedia and CSS adornments. It’s a collection of hundreds of file types and data formats, whizzing hundreds at a time to form the pages that you consume through your browser. The real trick is often to look beyond the page in front of you and grab the data at its source.</p>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="id773"><sup><a href="ch15.html#id773-marker">1</a></sup> This API resolves IP addresses to geographic locations and is one you’ll be using later in the chapter as well.</p><p data-type="footnote" id="id776"><sup><a href="ch15.html#id776-marker">2</a></sup> In reality, many APIs use <code>POST</code> requests in lieu of <code>PUT</code> requests when updating information. Whether a new entity is created or an old one is merely updated is often left to how the API request itself is structured. However, it’s still good to know the difference, and you will often encounter <code>PUT</code> requests in commonly used APIs.</p></div></div></section></body></html>