["```py\n`class` *`Classname`*(*`base``-``classes`*, *, ***`kw`*):\n    statement(s)\n```", "```py\n`class` C1:\n    x = 23\nprint(C1.x)                      *`# prints:`* *`23`*\n```", "```py\n`class` C2:\n    `pass`\nC2.x = 23\nprint(C2.x)                      *`# prints:`* *`23`*\n```", "```py\nprint(C1.__name__, C1.__bases__) *`# prints:`* *`C1 (<class 'object'>,)`*\n```", "```py\n`class` C3:\n    x = 23\n    y = x + 22                   *`# must use just x`*, *`not`* *`C3.x`*\n```", "```py\n`class` C4:\n    x = 23\n    `def` amethod(self):\n        print(C4.x)              *`# must use C4.x or self.x`*, *`not`* *`just x!`*\n```", "```py\n`class` C5:\n    `def` hello(self):\n        print('Hello')\n```", "```py\n`class` Const:  *`# class with an overriding descriptor, see later`*\n    `def` __init__(self, value):\n        self.__dict__['value'] = value\n    `def` __set__(self, *_):  \n        # silently ignore any attempt at setting\n        # (a better design choice might be to raise AttributeError)\n        `pass`\n    `def` __get__(self, *_):\n        *`# always return the constant value`*\n        `return` self.__dict__['value']\n    `def` __delete__(self, *_): \n        *`# silently ignore any attempt at deleting`* \n        # (a better design choice might be to raise AttributeError)\n        `pass`\n\n`class` X:\n    c = Const(23)\n\nx = X()\nprint(x.c)  *`# prints:`* *`23`*\nx.c = 42    *`# silently ignored (unless you raise AttributeError)`*\nprint(x.c)  *`# prints:`* *`23`*\n`del` x.c *`# silently ignored again (ditto)`*\nprint(x.c)  *`# prints:`* *`23`*\n```", "```py\nan_instance = C5()\n```", "```py\n`class` C6:\n    `def` __init__(self, n):\n        self.x = n\n```", "```py\nanother_instance = C6(42)\n```", "```py\nan_instance.hello()                      *`# prints:`* *`Hello`*\nprint(another_instance.x)                *`# prints:`* *`42`*\n```", "```py\n`class` C7:\n    `pass`\nz = C7()\nz.x = 23\nprint(z.x)                               *`# prints:`* *`23`*\n```", "```py\nprint(z.__class__.__name__, z.__dict__)  *`# prints:`* *`C7 {'x':23}`*\n```", "```py\nz.y = 45\nz.__dict__['z'] = 67\nprint(z.x, z.y, z.z)                     *`# prints:`* *`23 45 67`*\n```", "```py\n`class` SpecialCase:\n    `def` amethod(self):\n        print('special')\n`class` NormalCase:\n    `def` amethod(self):\n        print('normal')\n`def` appropriate_case(isnormal=`True`):\n    `if` isnormal:\n        `return` NormalCase()\n    `else``:`\n `return` SpecialCase()\naninstance = appropriate_case(isnormal=`False`)\naninstance.amethod()                  *`# prints:`* *`special`*\n```", "```py\n*`x`* = *`C`*.__new__(*`C`*, 23)\n`if` isinstance(*`x`*, *`C`*):\n    type(*`x`*).__init__(*`x`*, 23)\n```", "```py\n`class` Singleton:\n    _singletons = {}\n    `def` __new__(cls, *args, **kwds):\n        `if` cls `not` `in` cls._singletons:\n            cls._singletons[cls] = obj = super().__new__(cls)\n            obj._initialized = False\n        `return` cls._singletons[cls]\n```", "```py\n`class` B:\n    a = 23\n    b = 45\n    `def` f(self):\n        print('method f in class B')\n    `def` g(self):\n        print('method g in class B')\n`class` C(B):\n    b = 67\n    c = 89\n    d = 123\n    `def` g(self):\n        print('method g in class C')\n    `def` h(self):\n        print('method h in class C')\nx = C()\nx.d = 77\nx.e = 88\n```", "```py\nprint(x.e, x.d, x.c, x.b, x.a)             *`# prints:`* *`88 77 89 67 23`*\n```", "```py\nprint(x.h, x.g, x.f, C.h, C.g, C.f)\n```", "```py\n<bound method C.h of <__main__.C object at 0x8156d5c>>\n```", "```py\n<function C.h at 0x102cabae8>\n```", "```py\nx.h()                   *`# prints:`* *`method h in class C`*\n```", "```py\n`def` f(a, b): ...              *`# a function f with two arguments`*\n\n`class` C:\n    name = f\nx = C()\n```", "```py\nx.__class__.__dict__['name'](x, *`arg`*)\n```", "```py\n`def` make_adder_as_closure(augend):\n    `def` add(addend, _augend=augend):\n        `return` addend + _augend\n    `return` add\n```", "```py\n`def` make_adder_as_bound_method(augend):\n    `class` Adder:\n        `def` __init__(self, augend):\n            self.augend = augend\n        `def` add(self, addend):\n            `return` addend+self.augend\n    `return` Adder(augend).add\n```", "```py\n`def` make_adder_as_callable_instance(augend):\n    `class` Adder:\n        `def` __init__(self, augend):\n            self.augend = augend\n        `def` __call__(self, addend):\n            `return` addend+self.augend\n    `return` Adder(augend)\n```", "```py\n`class` B:\n    a = 23\n    b = 45\n    `def` f(self):\n        print('method f in class B')\n    `def` g(self):\n        print('method g in class B')\n`class` C(B):\n    b = 67\n    c = 89\n    d = 123\n    `def` g(self):\n        print('method g in class C')\n    `def` h(self):\n        print('method h in class C')\n```", "```py\n`class` Base:\n    `def` greet(self, name):\n        print('Welcome', name)\n`class` Sub(Base):\n    `def` greet(self, name):\n        print('Well Met and', end=' ')\n        Base.greet(self, name)\nx = Sub()\nx.greet('Alex')\n```", "```py\n`class` Base:\n    `def` __init__(self):\n        self.anattribute = 23\n`class` Derived(Base):\n    `def` __init__(self):\n        Base.__init__(self)\n        self.anotherattribute = 45\n```", "```py\n`class` Derived(Base):\n    `def` __init__(self):\n        Base.__init__(self)\n```", "```py\n`class` Derived(Base):\n    `def` __init__(self):\n        super().__init__()\n        self.anotherattribute = 45\n```", "```py\n`class` A:\n    `def` met(self):\n        print('A.met')\n`class` B(A):\n    `def` met(self):\n        print('B.met')\n        A.met(self)\n`class` C(A):\n    `def` met(self):\n        print('C.met')\n        A.met(self)\n`class` D(B,C):\n    `def` met(self):\n        print('D.met')\n        B.met(self)\n        C.met(self)\n```", "```py\n`class` A:\n    `def` met(self):\n        print('A.met')\n`class` B(A):\n    `def` met(self):\n        print('B.met')\n        super().met()\n`class` C(A):\n    `def` met(self):\n        print('C.met')\n        super().met()\n`class` D(B,C):\n    `def` met(self):\n        print('D.met')\n        super().met()\n```", "```py\nNewClass = type(name, bases, class_attributes, **kwargs)\n```", "```py\nAmphibiousVehicle = type('AmphibiousVehicle', \n                         (LandVehicle, WaterVehicle), {})\n```", "```py\n`class` AmphibiousVehicle(LandVehicle, WaterVehicle): `pass`\n```", "```py\n`class` AClass:\n    `def` astatic():\n        print('a static method')\n    astatic = staticmethod(astatic)\n\nan_instance = AClass()\nprint(AClass.astatic())             *`# prints:`* *`a static method`*\nprint(an_instance.astatic())        *`# prints:`* *`a static method`*\n```", "```py\n`class` ABase:\n    `def` aclassmet(cls):\n        print('a class method for', cls.__name__)\n    aclassmet = classmethod(aclassmet)\n`class` `ADeriv`(ABase):\n    `pass`\n\nb_instance = ABase()\nd_instance = ADeriv()\nprint(ABase.aclassmet())        *`# prints:`* *`a class method for ABase`*\nprint(b_instance.aclassmet())   *`# prints:`* *`a class method for ABase`*\nprint(ADeriv.aclassmet())       *`# prints:`* *`a class method for ADeriv`*\nprint(d_instance.aclassmet())   *`# prints:`* *`a class method for ADeriv`*\n```", "```py\n`class` Rectangle:\n    `def` __init__(self, width, height):\n        self.width = width\n        self.height = height\n    `def` area(self):\n        `return` self.width * self.height\n    area = property(area, doc='area of the rectangle')\n```", "```py\n*`attrib`* = property(fget=`None`, fset=`None`, fdel=`None`, doc=`None`)\n```", "```py\n`class` Rectangle:\n    `def` __init__(self, width, height):\n        self.width = width\n        self.height = height\n    @property\n    `def` area(self):\n        *`\"\"\"area of the rectangle\"\"\"`*\n        `return` self.width * self.height\n```", "```py\n`import` math\n`class` Rectangle:\n    `def` __init__(self, width, height):\n        self.width = width\n        self.height = height\n    @property\n    `def` area(self):\n        *`\"\"\"area of the rectangle\"\"\"`*\n        `return` self.width * self.height\n    @area.setter\n    `def` area(self, value):\n        scale = math.sqrt(value/self.area)\n        self.width *= scale\n        self.height *= scale\n```", "```py\nsome_instance.widget_count += 1\n```", "```py\nsome_instance.set_widget_count(some_instance.get_widget_count() + 1)\n```", "```py\n`class` B:\n    `def` f(self):\n        `return` 23\n    g = property(f)\n`class` C(B):\n    `def` f(self):\n        `return` 42\n\nc = C()\nprint(c.g)                *`# prints:`* *`23`*, *`not`* *`42`*\n```", "```py\n`class` B:\n    `def` f(self):\n        `return` 23\n    `def` _f_getter(self):\n        `return` self.f()\n    g = property(_f_getter)\n`class` C(B):\n    `def` f(self):\n        `return` 42\n\nc = C()\nprint(c.g)                *`# prints:`* *`42`**`,`* *`as expected`*\n```", "```py\n`class` OptimizedRectangle(Rectangle):\n    __slots__ = 'width', 'height'\n```", "```py\n`class` OptimizedRectangle(Rectangle):\n    __slots__ = {'width': 'rectangle width in pixels',\n                 'height': 'rectangle height in pixels'}\n```", "```py\n`class` listNoAppend(list):\n    `def` __getattribute__(self, name):\n        `if` name == 'append':\n            `raise` AttributeError(name)\n        `return` list.__getattribute__(self, name)\n```", "```py\n`def` fake_get_item(idx):\n    `return` idx\n`class` MyClass:\n    `pass`\nn = MyClass()\nn.__getitem__ = fake_get_item\nprint(n[23])                      *`# results in:`*\n*`# Traceback (most recent call last):`*\n*`#   File \"<stdin>\", line 1, in ?`*\n*`# TypeError: unindexable object`*\n```", "```py\n`class` noway(dict, list):\n    `pass`\n```", "```py\n`def` __getitem__(self, index):\n    *`# Recursively special-case slicing`*\n    `if` isinstance(index, slice):\n        `return` self.__class__(self[x]\n                              `for` x `in` range(*index.indices(len(self))))\n    *`# Check index, and deal with a negative and/or out-of-bounds index`*\n    index = operator.index(index)\n    `if` index < 0:\n        index += len(self)\n    `if` `not` (0 <= index < len(self)):\n        `raise` `IndexError`\n    *`# Index is now a correct int, within range(len(self))`*\n *`# ...rest of __getitem__, dealing with single-item access...`*\n```", "```py\n`for` *`z`* `in` *`x`*:\n    `if` *`y`*==*`z`*:\n        `return` `True`\n`return` `False`\n```", "```py\n`def` f(cls, ...):\n *`# ...definition of f snipped...`*\nf = classmethod(f)\n```", "```py\n@classmethod\n`def` f(cls, ...):\n *`# ...definition of f snipped...`*\n```", "```py\n`def` showdoc(f):\n    `if` f.__doc__:\n        print(f'{f.__name__}: {f.__doc__}')\n    `else`:\n        print(f'{f.__name__}: No docstring!')\n    `return` f\n\n@showdoc\n`def` f1():\n    \"\"\"a docstring\"\"\"  *`# prints:`* *`f1: a docstring`*\n\n@showdoc\n`def` f2():\n    `pass`               *`# prints:`* *`f2: No docstring!`*\n```", "```py\nimport functools\n\n`def` announce(f):\n    @functools.wraps(f)\n    `def` wrap(*a, **k):\n        print(f'Calling {f.__name__}')\n        `return` f(*a, **k)\n    `return` wrap\n```", "```py\n>>> `class` C:\n...     `def` __init_subclass__(cls, foo=None, **kw):\n...         print(cls, kw)\n...         cls.say_foo = staticmethod(lambda: f'*{foo}*')\n...         super().__init_subclass__(**kw)\n... \n>>> `class` D(C, foo='bar'):\n...     `pass`\n...\n```", "```py\n<class '__main__.D'> {}\n```", "```py\n>>> D.say_foo()\n```", "```py\n'*bar*'\n```", "```py\n>>> `class` Attrib:\n...     `def` __set_name__(self, cls, name):\n...         print(f'Attribute {name!r} added to {cls}')\n... \n>>> `class` AClass:\n...     some_name = Attrib()\n...\n```", "```py\nAttribute 'some_name' added to <class '__main__.AClass'>\n```", "```py\n>>>\n```", "```py\n`class` M:\n    `def` __prepare__(classname, *classbases, **kwargs):\n        `return` {}\n *`# ...rest of M snipped...`*\n`class` X(onebase, another, metaclass=M, foo='bar'):\n *`# ...body of X snipped...`*\n```", "```py\n`class` MyMeta(type):\n    `def` __str__(cls):\n        `return` f'Beautiful class {cls.__name__!r}'\n`class` MyClass(metaclass=MyMeta):\n    `pass`\nx = MyClass()\nprint(type(x))      *`# prints:`* *`Beautiful class 'MyClass'`*\n```", "```py\n`class` Bunch:\n    `def` __init__(self, **fields):\n        self.__dict__ = fields\np = Bunch(x=2.3, y=4.5)\nprint(p)       *`# prints:`* *`<_main__.Bunch object at 0x00AE8B10>`*\n```", "```py\n`class` Point(Bunch):\n    *`\"\"\"A Point has x and y coordinates, defaulting to 0.0,`*\n       *`and a color, defaulting to 'gray'-and nothing more,`*\n       *`except what Python and the metaclass conspire to add,`*\n       *`such as __init__ and __repr__.`*\n    *`\"\"\"`*\n    x = 0.0\n    y = 0.0\n    color = 'gray'\n*`# example uses of class Point`*\nq = Point()\nprint(q)                    *`# prints:`* *`Point()`*\np = Point(x=1.2, y=3.4)\nprint(p)                    *`# prints:`* *`Point(x=1.2, y=3.4)`*\n```", "```py\n`import` warnings\n`class` MetaBunch(type):\n    *`\"\"\"`*\n    *`Metaclass for new and improved \"Bunch\": implicitly defines`*\n    *`__slots__, __init__, and __repr__ from variables bound in`*\n    *`class scope.`*\n    *`A class statement for an instance of MetaBunch (i.e., for a`*\n    *`class whose metaclass is MetaBunch) must define only`*\n    *`class-scope data attributes (and possibly special methods, but`*\n    *`NOT __init__ and __repr__). MetaBunch removes the data`*\n    *`attributes from class scope, snuggles them instead as items in`*\n    *`a class-scope dict named __dflts__, and puts in the class a`*\n    *`__slots__ with those attributes' names, an __init__ that takes`*\n    *`as optional named arguments each of them (using the values in`*\n    *`__dflts__ as defaults for missing ones), and a __repr__ that`*\n    *`shows the repr of each attribute that differs from its default`*\n    *`value (the output of __repr__ can be passed to __eval__ to make`*\n    *`an equal instance, as per usual convention in the matter, if`*\n    *`each non-default-valued attribute respects that convention too).`*\n    *`The order of data attributes remains the same as in the`* *`class body.`*\n    *`\"\"\"`*\n    `def` __new__(mcl, classname, bases, classdict):\n        *`\"\"\"Everything needs to be done in __new__, since`*\n           *`type.__new__ is where __slots__ are taken into account.`*\n        *`\"\"\"`*\n        *`# Define as local functions the __init__ and __repr__ that`*\n        *`# we'll use in the new class`*\n        `def` __init__(self, **kw):\n            *`\"\"\"__init__ is simple: first, set attributes without`*\n *`explicit values to their defaults; then, set`* *`those`*\n *`explicitly`* *`passed in kw.`*\n            *`\"\"\"`*\n            `for` k `in` self.__dflts__:\n                `if` `not` k `in` kw:\n                    setattr(self, k, self.__dflts__[k])\n            `for` k `in` kw:\n                setattr(self, k, kw[k])\n        `def` __repr__(self):\n            *`\"\"\"__repr__ is minimal: shows only attributes that`*\n               *`differ`* *`from default values, for compactness.`*\n            *`\"\"\"`*\n            rep = [f'{k}={getattr(self, k)!r}'\n                    `for` k `in` self.__dflts__\n                    `if` getattr(self, k) != self.__dflts__[k]\n                  ]\n            `return` f'{classname}({', '.join(rep)})'\n        *`# Build the newdict that we'll use as class dict for the`*\n        *`# new class`*\n        newdict = {'__slots__': [], '__dflts__': {},\n                   '__init__': __init__, '__repr__' :__repr__,}\n        `for` k `in` classdict:\n            `if` k.startswith('__') `and` k.endswith('__'):\n                *`# Dunder methods: copy to newdict, or warn`*\n                *`# about conflicts`*\n                `if` k `in` newdict:\n                    warnings.warn(f'Cannot set attr {k!r}'\n                                  f' in bunch-class {classname!r}')\n `else``:`\n                    newdict[k] = classdict[k]\n `else``:`\n                *`# Class variables: store name in __slots__, and`*\n                *`# name and value as an item in __dflts__`*\n                newdict['__slots__'].append(k)\n                newdict['__dflts__'][k] = classdict[k]\n        *`# Finally, delegate the rest of the work to type.__new__`*\n        `return` super().__new__(mcl, classname, bases, newdict)\n\n`class` Bunch(metaclass=MetaBunch):\n    *`\"\"\"For convenience: inheriting from Bunch can be used to get`*\n       *`the new metaclass (same as defining metaclass= yourself).`*\n    *`\"\"\"`*\n `pass`\n```", "```py\n`import` dataclasses\n`@`dataclasses.dataclass\n`class` Point:\n    x: float\n    y: float\n```", "```py\n>>> pt\n```", "```py\nPoint(x=0.5, y=0.5)\n```", "```py\n`def` __post_init__(self):\n    self.create_time = time.time()\n```", "```py\n>>> pt\n```", "```py\nPoint(x=0.5, y=0.5, create_time=1645122864.3553088)\n```", "```py\n`def` distance_from(self, other):\n    dx, dy = self.x - other.x, self.y - other.y\n    `return` math.hypot(dx, dy)\n\n@property\n`def` distance_from_origin(self):\n    `return` self.distance_from(Point(0, 0))\n```", "```py\n>>> pt.distance_from(Point(-1, -1))\n```", "```py\n2.1213203435596424\n```", "```py\n>>> pt.distance_from_origin\n```", "```py\n0.7071067811865476\n```", "```py\n*`# colors`*\nRED = 1\nGREEN = 2\nBLUE = 3\n\n*`# sizes`*\nXS = 1\nS = 2\nM = 3\nL = 4\nXL = 5\n```", "```py\n`from` enum `import` Enum, auto\n\n`class` Color(Enum):\n    RED = 1\n    GREEN = 2\n    BLUE = 3\n\n`class` Size(Enum):\n    XS = auto()\n    S = auto()\n    M = auto()\n    L = auto()\n    XL = auto()\n```", "```py\n`from` enum `import` Enum\nColor = Enum('Color', ('RED', 'GREEN', 'BLUE'))\nSize = Enum('Size', 'XS S M L XL')\n```", "```py\n`while` process_state `is` ProcessState.RUNNING:\n *`# running process code goes here`*\n    `if` processing_completed():\n        process_state = ProcessState.IDLE\n```", "```py\n`import` enum\n`import` stat\n\n`class` Permission(enum.Flag):\n    EXEC_OTH = stat.S_IXOTH\n    WRITE_OTH = stat.S_IWOTH\n    READ_OTH = stat.S_IROTH\n    EXEC_GRP = stat.S_IXGRP\n    WRITE_GRP = stat.S_IWGRP\n    READ_GRP = stat.S_IRGRP\n    EXEC_USR = stat.S_IXUSR\n    WRITE_USR = stat.S_IWUSR\n    READ_USR = stat.S_IRUSR\n\n    @classmethod\n    `def` from_stat(cls, stat_result):\n        `return` cls(stat_result.st_mode & 0o777)\n\n`from` pathlib `import` Path\n\ncur_dir = Path.cwd()\ndir_perm = Permission.from_stat(cur_dir.stat())\n`if` dir_perm & Permission.READ_OTH:\n    print(f'{cur_dir} is readable by users outside the owner group')\n\n*`# the following raises TypeError: Flag enums do not support order`* \n*`# comparisons`*\nprint(Permission.READ_USR > Permission.READ_OTH)\n```"]