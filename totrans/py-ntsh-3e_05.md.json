["```py\n*`identifier`*: *`type_specification`*\n```", "```py\n*`type_specifier`*[*`type_parameter`*, ...]\n```", "```py\n`import` typing\n\n*`# an int`*\ncount: int\n\n*`# a list of ints, with a default value`*\ncounts: list[int] = []\n\n*`# a dict with str keys, values are tuples containing 2 ints and a str`*\nemployee_data: dict[str, tuple[int, int, str]]\n\n*`# a callable taking a single str or bytes argument and returning a bool`*\nstr_predicate_function: typing.Callable[[str | bytes], bool]\n\n*`# a dict with str keys, whose values are functions that take and return`* \n*`# an int`*\nstr_function_map: dict[str, typing.Callable[[int], int]] = {\n    'square': `lambda` x: x * x,\n    'cube': `lambda` x: x * x * x,\n}\n```", "```py\n`def` identifier(argument, ...) -> type_specification :\n```", "```py\n*`identifier`*[: *`type_specification`*[ = *`default_value`*]]\n```", "```py\n`def` pad(a: list[str], min_len: int = 1, padstr: str = ' ') -> list[str]:\n    *`\"\"\"Given a list of strings and a minimum length, return a copy of`*\n *`the list extended with \"padding\" strings to be at least the`*\n *`minimum length.`*\n *`\"\"\"`*\n    `return` a + ([padstr] * (min_len - len(a)))\n```", "```py\n`class` A:\n    @classmethod\n    `def` factory_method(cls) -> A:\n        *`# ... method body goes here ...`*\n```", "```py\n`class` A:\n    @classmethod\n    `def` factory_method(cls) -> 'A':\n        *`# ... method body goes here ...`*\n```", "```py\n`class` RomanNumeral:\n    *`\"\"\"Class representing some Roman numerals and their int`* \n *`values.`*\n *`\"\"\"`*\n    int_values = {'I': 1, 'II': 2, 'III': 3, 'IV': 4, 'V': 5}\n\n    `def` __init__(self, label: str):\n        self.label = label\n\n    `def` __int__(self) -> int:\n        `return` RomanNumeral.int_values[self.label]\n```", "```py\n>>> movie_sequel = RomanNumeral('II')\n>>> print(int(movie_sequel))\n```", "```py\n2\n```", "```py\n>>> issubclass(RomanNumeral, typing.SupportsInt)\n```", "```py\nTrue\n```", "```py\n>>> isinstance(movie_sequel, typing.SupportsInt)\n```", "```py\nTrue\n```", "```py\n@typing.overload\n`def` fn(*, key: str, value: int):\n    `.``.``.`\n\n@typing.overload\n`def` fn(*, strict: bool):\n    `.``.``.`\n\n`def` fn(**kwargs):\n    *`# implementation goes here, including handling of differing`* \n    *`# named arguments`*\n    `pass`\n\n*`# valid calls`*\nfn(key='abc', value=100)\nfn(strict=True)\n\n*`# invalid calls`*\nfn(1)\nfn('abc')\nfn('abc', 100)\nfn(key='abc')\nfn(`True`)\nfn(strict=True, value=100)\n```", "```py\n`def` func(x: list[int] | list[str]):\n    `try`:\n        `return` sum(x)\n    `except` TypeError:\n        x = cast(list[str], x)\n        `return` ','.join(x)\n```", "```py\ncolor_lookup: dict[str, tuple[int, int, int]] = {}\n```", "```py\ncolor_lookup['red'] = (255, 0, 0)\ncolor_lookup['red'][2]\n```", "```py\ncolor_lookup[0]\n```", "```py\nerror: Invalid index type \"int\" for \"dict[str, tuple[int, int, int]]\";\nexpected type \"str\"\n```", "```py\ncolor_lookup['red'] = (255, 0, 0, 0)\n```", "```py\nerror: Incompatible types in assignment (expression has type\n\"tuple[int, int, int, int]\", target has type \"tuple[int, int, int]\")\n```", "```py\n`import` typing\nT = typing.TypeVar('T')\n```", "```py\n`class` Accumulator(typing.Generic[T]):\n    `def` __init__(self):\n        self._contents: list[T] = []\n```", "```py\n    `def` update(self, *args: T) -> `None`:\n        self._contents.extend(args)\n\n    `def` undo(self) -> `None`:\n        *`# remove last value added`*\n        `if` self._contents:\n            self._contents.pop()\n```", "```py\n    `def` __len__(self) -> int:\n        `return` len(self._contents)\n\n    `def` __iter__(self) -> typing.Iterator[T]:\n        `return` iter(self._contents)\n```", "```py\nacc: Accumulator[int] = Accumulator()\nacc.update(1, 2, 3)\nprint(sum(acc))  # prints 6\nacc.undo()\nprint(sum(acc))  # prints 3\n```", "```py\nacc.update('A')\n```", "```py\nerror: Argument 1 to \"update\" of \"Accumulator\" has incompatible type\n\"str\"; expected \"int\"\n```", "```py\nprint(''.join(acc))\n```", "```py\nerror: Argument 1 to \"join\" of \"str\" has incompatible type\n\"Accumulator[int]\"; expected \"Iterable[str]\"\n```", "```py\n*`# T must be one of the types listed (int, float, complex, or str)`*\nT = typing.TypeVar('T', int, float, complex, str)\n*`# T must be the class MyClass or a subclass of the class MyClass`*\nT = typing.TypeVar('T', bound=MyClass)\n*`# T must implement __len__ to be a valid subclass of the Sized protocol`*\nT = typing.TypeVar('T', bound=collections.abc.Sized)\n```", "```py\n`class` HouseListingTuple(typing.NamedTuple):\n    address: str\n    list_price: int\n    square_footage: int = 0\n    condition: str = 'Good'\n```", "```py\nlisting1 = HouseListingTuple(\n    address='123 Main',\n    list_price=100_000,\n    square_footage=2400,\n    condition='Good',\n)\n\nprint(listing1.address)  *`# prints: 123 Main`*\nprint(type(listing1))    *`# prints: <class 'HouseListingTuple'>`*\n```", "```py\nlisting2 = HouseListingTuple(\n    '123 Main',\n)\n*`# raises a runtime error: TypeError: HouseListingTuple.__new__()` \n`# missing 1 required positional argument: 'list_price'`*\n```", "```py\n`class` HouseListingDict(typing.TypedDict):\n    address: str\n    list_price: int\n    square_footage: int\n    condition: str\n```", "```py\nlisting1 = HouseListingDict(\n    address='123 Main',\n    list_price=100_000,\n    square_footage=2400,\n    condition='Good',\n)\n\nprint(listing1['address'])  # prints *`123 Main`*\nprint(type(listing1))  # prints *`<class 'dict'>`*\n\nlisting2 = HouseListingDict(\n    address='124 Main',\n    list_price=110_000,\n)\n```", "```py\nerror: Missing keys (\"square_footage\", \"condition\") for TypedDict\n\"HouseListing\"\n```", "```py\n`class` HouseListing(typing.TypedDict, total=False):\n    *`# ...`*\n```", "```py\n`class` HouseListing(typing.TypedDict):\n    address: typing.Required[str]\n    list_price: int\n    square_footage: typing.NotRequired[int]\n    condition: str\n```", "```py\nT = typing.TypeVar('T')\n\n`class` Node(typing.TypedDict, typing.Generic[T]):\n    label: T\n    neighbors: list[T]\n\nn = Node(label='Acme', neighbors=['anvil', 'magnet', 'bird seed'])\n```", "```py\nHouseListing = TypedDict('HouseListing',\n                         address=str, \n                         list_price=int, \n                         square_footage=int, \n                         condition=str)\n```", "```py\nHouseListing = TypedDict('HouseListing',\n                         {'address': str, \n                          'list_price': int, \n                          'square_footage': int,\n                          'condition': str})\n```", "```py\nn = Node(label='Acme', neighbors=['anvil', 'magnet', 'bird seed'])\nprint(type(n))           *`# prints: <class 'dict'>`*\nprint(type(n) is dict)   *`# prints: True`*\n```", "```py\nIdentifier = int\n```", "```py\nIdentifier: TypeAlias = int\n```", "```py\n*`# Python will treat this like a standard str assignment`*\nTBDType = 'ClassNotDefinedYet'\n\n*`# indicates that this is actually a forward reference to a class`*\nTBDType: TypeAlias = 'ClassNotDefinedYet'\n```", "```py\nemployee_department_map: dict[str, str] = {}\n```", "```py\nEmpId = typing.NewType('EmpId', str)\nDeptId = typing.NewType('DeptId', str)\nemployee_department_map: dict[EmpId, DeptId] = {}\n```", "```py\n`def` transfer_employee(empid: EmpId, to_dept: DeptId):\n *`# update department for employee`\n*     employee_department_map[to_dept] = empid\n```", "```py\nerror: Invalid index type \"DeptId\" for \"Dict[EmpId, DeptId]\"; expected\ntype \"EmpId\"\nerror: Incompatible types in assignment (expression has type \"EmpId\",\ntarget has type \"DeptId\")\n```", "```py\nZipCode = typing.NewType(\"ZipCode\", str)\n```", "```py\n>>> `def` f(a:list[str], b) -> int:\n...     `pass`\n...\n>>> f.__annotations__\n```", "```py\n{'a': list[str], 'return': <class 'int'>}\n```", "```py\n>>> `class` Customer:\n...     name: str\n...     reward_points: int = 0\n...\n>>> Customer.__annotations__\n```", "```py\n{'name': <class 'str'>, 'reward_points': <class 'int'>}\n```", "```py\nT = typing.TypeVar('T')\n\n@typing.runtime_checkable\n`class` SupportsUpdateUndo(typing.Protocol):\n    `def` update(self, *args: T) -> `None`:\n        ...\n    `def` undo(self) -> `None`:\n        ...\n```", "```py\n>>> issubclass(Accumulator, SupportsUpdateUndo)\n```", "```py\nTrue\n```", "```py\n>>> isinstance(acc, SupportsUpdateUndo)\n```", "```py\nTrue\n```"]