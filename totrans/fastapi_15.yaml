- en: Chapter 12\. Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A QA engineer walks into a bar. Orders a beer. Orders 0 beers. Orders 99999999999
    beers. Orders a lizard. Orders –1 beers. Orders a ueicbksjdhd.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: First real customer walks in and asks where the bathroom is. The bar bursts
    into flames, killing everyone.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Brenan Keller, Twitter
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Preview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter discusses the kinds of testing that you would perform on a FastAPI
    site: *unit*, *integration*, and *full*. It features *pytest* and automated test
    development.'
  prefs: []
  type: TYPE_NORMAL
- en: Web API Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You’ve already seen several manual API testing tools as endpoints have been
    added:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTPie
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTPX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And many more testing tools are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Curl](https://curl.se) is very well known, although in this book I’ve used
    HTTPie instead for its simpler syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Httpbin](http://httpbin.org), written by the author of Requests, is a free
    test server that provides many views into your HTTP request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Postman](https://www.postman.com) is a full API test platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chrome DevTools](https://oreil.ly/eUK_R) is a rich toolset, part of the Chrome
    browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These can all be used for full (end-to-end) tests, such as those you’ve seen
    in the previous chapters. Those manual tests have been useful for quickly verifying
    code just after it’s typed.
  prefs: []
  type: TYPE_NORMAL
- en: But what if a change that you make later breaks one of those earlier manual
    tests (a *regression*)? You don’t want to rerun dozens of tests after every code
    change. That’s when *automated* tests become important. The rest of this chapter
    focuses on these, and how to build them with pytest.
  prefs: []
  type: TYPE_NORMAL
- en: Where to Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I’ve mentioned the varieties of tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit
  prefs: []
  type: TYPE_NORMAL
- en: Within a layer, tests individual functions
  prefs: []
  type: TYPE_NORMAL
- en: Integration
  prefs: []
  type: TYPE_NORMAL
- en: Across layers, tests connectivity
  prefs: []
  type: TYPE_NORMAL
- en: Full
  prefs: []
  type: TYPE_NORMAL
- en: Tests the full API and stack beneath it
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes these are called a *test pyramid*, with the width indicating the relative
    number of tests that should be in each group ([Figure 12-1](#fig-pyramid)).
  prefs: []
  type: TYPE_NORMAL
- en: '![fapi 1201](assets/fapi_1201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-1\. Test pyramid
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: What to Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What should you test as you’re writing code? Basically, for a given input,
    confirm that you get the correct output. You might check the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Missing inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Duplicate inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorrect input types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorrect input order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invalid input values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Huge inputs or outputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Errors can happen anywhere:'
  prefs: []
  type: TYPE_NORMAL
- en: The Web layer
  prefs: []
  type: TYPE_NORMAL
- en: Pydantic will catch any mismatch with the model and return a `422` HTTP status
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The Data layer
  prefs: []
  type: TYPE_NORMAL
- en: The database will raise exceptions for missing or duplicate data, as well as
    SQL query syntax errors. Timeouts or memory exhaustion may occur when passing
    a huge data result in one piece, instead of in chunks with a generator or pagination.
  prefs: []
  type: TYPE_NORMAL
- en: Any layer
  prefs: []
  type: TYPE_NORMAL
- en: Plain old bugs and oversights can occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapters [8](ch08.html#ch08) through [10](ch10.html#ch10) contained some of
    these tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Full manual tests*, using tools like HTTPie'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Unit manual tests*, as Python fragments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Automated tests*, using pytest scripts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next few sections expand on pytest.
  prefs: []
  type: TYPE_NORMAL
- en: Pytest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has long had the standard package [unittest](https://oreil.ly/3u0M_).
    A later third-party package called [nose](https://nose.readthedocs.io) tried to
    improve on it. Most Python developers now prefer [pytest](https://docs.pytest.org),
    which does more than either of these and is easier to use. It isn’t built into
    Python, so you’ll need to run `pip install pytest` if you don’t already have it.
    Also, run `pip install pytest-mock` to get the automatic `mocker` fixture; you’ll
    see this later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'What does pytest offer? Nice automatic features include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Test discovery
  prefs: []
  type: TYPE_NORMAL
- en: A test prefix or test suffix in a Python filename will be run automatically.
    This filename matching goes down into subdirectories, executing as many tests
    as you have there.
  prefs: []
  type: TYPE_NORMAL
- en: Assertion failure details
  prefs: []
  type: TYPE_NORMAL
- en: A failing `assert` statement prints what was expected and what actually happened.
  prefs: []
  type: TYPE_NORMAL
- en: Fixtures
  prefs: []
  type: TYPE_NORMAL
- en: 'These functions can run once for the whole test script, or run for every test
    (its *scope*), providing test functions with parameters like standard test data
    or database initialization. Fixtures are a sort of dependency injection, like
    FastAPI offers for web path functions: specific data passed to a general test
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: Parameterization
  prefs: []
  type: TYPE_NORMAL
- en: This provides multiple test data to a test function.
  prefs: []
  type: TYPE_NORMAL
- en: Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Where should you put your tests? There doesn’t seem to be wide agreement, but
    here are two reasonable designs:'
  prefs: []
  type: TYPE_NORMAL
- en: A *test* directory at the top, with subdirectories for the code area being tested
    (like *web*, *service*, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *test* directory under each code directory (like *web*, *service*, etc.).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, within the specific subdirectory like *test/web*, should you make more
    directories for different test types (like *unit*, *integration*, and *full*)?
    In this book, I’m using this hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Individual test scripts live within the bottom directories. Those are in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Automated Unit Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A unit test should check one thing, within one layer. This usually means passing
    parameter(s) to a function and asserting what should be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests require *isolation* of the code being tested. If not, you’re also
    testing something else. So, how do you isolate code for unit tests?
  prefs: []
  type: TYPE_NORMAL
- en: Mocking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this book’s code stack, accessing a URL via a web API generally calls a function
    in the Web layer, which calls a function in the Service layer, which calls a function
    in the Data layer, which accesses a database. The results flow back up the chain,
    eventually back out of the Web layer to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit testing sounds simple. For each function in your codebase, pass in test
    arguments and confirm that it returns expected values. This works well for a *pure
    function*: one that takes input arguments and returns responses without referencing
    any external code. But most functions also call other functions, so how can you
    control what those other functions do? What about the data that comes from these
    external sources? The most common external factor to control is database access,
    but really it can be anything.'
  prefs: []
  type: TYPE_NORMAL
- en: One method is to *mock* each external function call. Because functions are first-class
    objects in Python, you can substitute one function for another. The unittest package
    has a mock module that does this.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers believe that mocking is the best way to isolate unit tests.
    I’ll first show examples of mocking here, along with the argument that often mocking
    requires too much knowledge of *how* your code works, rather than the results.
    You may hear the terms *structural testing* (as in mocks, where the tested code
    is quite visible) and *behavioral testing* (where the code internals are not needed).
  prefs: []
  type: TYPE_NORMAL
- en: Examples [12-1](#ex-12-1) and [12-2](#ex-12-2) define the modules *mod1.py*
    and *mod2.py*.
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-1\. Called module (mod1.py)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Example 12-2\. Calling module (mod2.py)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `summer()` function calculates the sum of its arguments, and returns a string
    with a preamble and the sum. [Example 12-3](#ex-12-3) is a minimal pytest script
    to verify `summer()`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-3\. Pytest script test_summer1.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 12-4](#ex-12-4) runs the test successfully.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-4\. Run the pytest script
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: (The `-q` runs the test quietly, without lots of extra printed details.) OK,
    it passed. But the `summer()` function got some text from the `preamble` function.
    What if we just want to test that the addition succeeded?
  prefs: []
  type: TYPE_NORMAL
- en: We could write a new function that just returns the stringified sum of two numbers,
    and then rewrite `summer()` to return this appended to the `preamble()` string.
  prefs: []
  type: TYPE_NORMAL
- en: Or, we could mock `preamble()` to remove its effect, as shown in multiple ways
    in [Example 12-5](#ex-12-5).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-5\. Pytest with a mock (test_summer2.py)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'These tests show that mocks can be created in more than one way. The function
    `test_caller_a()` uses `mock.patch()` as a Python *context manager* (the `with`
    statement). Its arguments are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"mod1.preamble"`'
  prefs: []
  type: TYPE_NORMAL
- en: The full string name of the `preamble()` function in module `mod1`.
  prefs: []
  type: TYPE_NORMAL
- en: '`return_value=""`'
  prefs: []
  type: TYPE_NORMAL
- en: Makes this mocked version return an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: The `test_caller_b()` function is almost the same, but adds `as mock_preamble`
    to use the mock object on the next line.
  prefs: []
  type: TYPE_NORMAL
- en: The `test_caller_c()` function defines the mock with a Python *decorator*. The
    mocked object is passed as an argument to `test_caller2()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `test_caller_d()` function is like `test_caller_b()`, setting the `return_value`
    in a separate call to `mock_preamble`.
  prefs: []
  type: TYPE_NORMAL
- en: In each case, the string name of the thing to be mocked must match the way it’s
    called in the code that’s being tested—in this case, `summer()`. The mock library
    converts this string name to a variable that will intercept any references to
    the original variable with that name. (Remember that in Python, variables are
    just references to the real objects.)
  prefs: []
  type: TYPE_NORMAL
- en: So, when [Example 12-6](#ex-12-6) is run, in all four `summer()` test functions,
    when `summer(5,6)` is called, the changeling mock `preamble()` is called instead
    of the real one. The mocked version drops that string, so the test can ensure
    that `summer()` returns a string version of the sum of its two arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-6\. Run mocked pytest
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: That was a contrived case, for simplicity. Mocking can be quite complex; see
    articles like [“Understanding the Python Mock Object Library” by Alex Ronquillo](https://oreil.ly/I0bkd)
    for clear examples, and the official [Python docs](https://oreil.ly/hN9lZ) for
    the harrowing details.
  prefs: []
  type: TYPE_NORMAL
- en: Test Doubles and Fakes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To perform that mock, you needed to know that the `summer()` function imported
    the function `preamble()` from the module `mod1`. This was a structural test,
    requiring knowledge of specific variable and module names.
  prefs: []
  type: TYPE_NORMAL
- en: Is there a way to perform a behavioral test that doesn’t need this?
  prefs: []
  type: TYPE_NORMAL
- en: 'One way is to define a *double*: separate code that does what we want in the
    test—in this case, make `preamble()` return an empty string. One way to do this
    is with imports. Apply this to this example first, before using it for unit tests
    in the layers of the next three sections.'
  prefs: []
  type: TYPE_NORMAL
- en: First, redefine *mod2.py* in [Example 12-7](#ex-12-7).
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-7\. Make mod2.py import a double if unit testing
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 12-8](#ex-12-8) defines that double module *fake_mod1.py*.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-8\. Double fake_mod1.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: And [Example 12-9](#ex-12-9) is the test.
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-9\. Test script test_summer_fake.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: …​.which [Example 12-10](#ex-12-10) runs.
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-10\. Run the new unit test
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This import-switching method does require adding a check for an environment
    variable, but avoids having to write specific mocks for function calls. You can
    be the judge of which you prefer. The next few sections will use the `import`
    method, which works nicely with the *fake* package that I’d been using as I defined
    the code layers.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, these examples replaced `preamble()` with a *mock* in a test script
    or imported a doppelgänger *double*. You can isolate the code being tested in
    other ways, but these work and are not as tricky as others that Google might find
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: Web
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This layer implements the site’s API. Ideally, each path function (endpoint)
    should have at least one test—maybe more, if the function could fail in more than
    one way. At the Web layer, you typically want to see if the endpoint exists, works
    with the correct parameters, and returns the right status code and data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: These are shallow API tests, testing solely within the Web layer. So, Service-layer
    calls (which would in turn call the Data layer and the database) need to be intercepted,
    along with any other calls that exit the Web layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `import` idea of the previous section, use the environment variable
    `CRYPTID_UNIT_TEST` to import the *fake* package as `service`, instead of the
    real `service`. This stops Web functions from calling Service functions, and instead
    short-circuits them to the *fake* (doubles) version. Then the lower Data layer
    and database aren’t involved, either. We get what we want: unit tests. [Example 12-11](#ex-12-11)
    has the modified *web/creature.py* file.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-11\. Modified web/creature.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 12-12](#ex-12-12) has tests, using two pytest fixtures:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sample()`'
  prefs: []
  type: TYPE_NORMAL
- en: A new `Creature` object
  prefs: []
  type: TYPE_NORMAL
- en: '`fakes()`'
  prefs: []
  type: TYPE_NORMAL
- en: A list of “existing” creatures
  prefs: []
  type: TYPE_NORMAL
- en: The fakes are obtained from a lower-level module. By setting the environment
    variable `CRYPTID_UNIT_TEST`, the Web module from [Example 12-11](#ex-12-11) imports
    the fake service version (providing fake data rather than calling the database)
    instead of the real one. This isolates the tests, which is the point.
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-12\. Web unit tests for creatures, using fixtures
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a way, the Service layer is the important one and could be connected to different
    Web and Data layers. [Example 12-13](#ex-12-13) is similar to [Example 12-11](#ex-12-11),
    differing mainly in the `import` and use of the lower-level data module. It also
    doesn’t catch any exceptions that might arise from the Data layer, leaving them
    to be handled by the Web layer.
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-13\. Modified service/creature.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 12-14](#ex-12-14) has the corresponding unit tests.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-14\. Service tests in test/unit/service/test_creature.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Data layer is simpler to test in isolation, because there’s no worry about
    accidentally calling a function in an even lower layer. Unit tests should cover
    both the functions in this layer and the specific database queries that they use.
    So far, SQLite has been the database “server” and SQL the query language. But
    as I mention in [Chapter 14](ch14.html#ch14), you may decide to work with a package
    like SQLAlchemy, and use its SQLAlchemy Expression Language or its ORM. Then these
    would need full tests. So far, I’ve kept to the lowest level: Python’s DB-API
    and vanilla SQL queries.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the Web and Service unit tests, this time we don’t need “fake” modules
    to replace the existing Data layer modules. Instead, set a different environment
    variable to get the Data layer to use a memory-only SQLite instance instead of
    a file-based one. This doesn’t require any changes to the existing Data modules,
    just a setting in [Example 12-15](#ex-12-15)’s test *before* importing any Data
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-15\. Data unit tests test/unit/data/test_creature.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Automated Integration Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integration tests show how well different code interacts *between* layers. But
    if you look for examples of this, you get many different answers. Should you test
    partial call trails like Web → Service, Web → Data, and so on?
  prefs: []
  type: TYPE_NORMAL
- en: 'To fully test every connection in an A → B → C pipeline, you’d need to test
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A → B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: B → C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A → C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And the arrows would fill a quiver if you have more than these three junctions.
  prefs: []
  type: TYPE_NORMAL
- en: Or should integration tests be essentially full tests, but with the very end
    piece—data storage on disk—mocked?
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, you’ve been using SQLite as the database, and you can use in-memory
    SQLite as a double (fake) for the on-disk SQLite database. If your queries are
    *very* standard SQL, SQLite-in-memory may be an adequate mock for other databases
    as well. If not, these modules are tailored to mock specific databases:'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL
  prefs: []
  type: TYPE_NORMAL
- en: '[pgmock](https://pgmock.readthedocs.io)'
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB
  prefs: []
  type: TYPE_NORMAL
- en: '[Mongomock](https://github.com/mongomock/mongomock)'
  prefs: []
  type: TYPE_NORMAL
- en: Many
  prefs: []
  type: TYPE_NORMAL
- en: '[Pytest Mock Resources](https://pytest-mock-resources.readthedocs.io) spins
    up various test databases in Docker containers, and is integrated with pytest.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you could just fire up a test database of the same kind as production.
    An environment variable could contain the specifics, much like the unit test/fake
    trick you’ve been using.
  prefs: []
  type: TYPE_NORMAL
- en: The Repository Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although I did not implement it for this book, the [Repository pattern](https://oreil.ly/3JMKH)
    is an interesting approach. A *repository* is a simple intermediate in-memory
    data store—like the fake Data layer that you’ve seen here so far. This then talks
    to pluggable backends for real databases. It’s accompanied by a [*Unit of Work*
    pattern](https://oreil.ly/jHGV8), which ensures that a group of operations in
    a single *session* is either committed or rolled back as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: So far, the database queries in this book have been atomic. For real-world database
    work, you may need multistep queries, and some kind of session handling. The Repository
    pattern also dovetails with [dependency injection](https://oreil.ly/0f0Q3), which
    you’ve seen elsewhere in this book and probably appreciate a little by now.
  prefs: []
  type: TYPE_NORMAL
- en: Automated Full Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Full tests exercise all the layers together, as close to production use as
    possible. Most of the tests that you’ve already seen in this book have been full:
    call the Web endpoint, run through Servicetown to downtown Dataville, and return
    with groceries. These are closed tests. Everything is live, and you don’t care
    how it does it, just that it does it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can fully test each endpoint in the overall API in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Over HTTP/HTTPS
  prefs: []
  type: TYPE_NORMAL
- en: Write individual Python test clients that access the server. Many examples in
    this book have done this, with standalone clients like HTTPie, or in scripts using
    Requests.
  prefs: []
  type: TYPE_NORMAL
- en: Using `TestClient`
  prefs: []
  type: TYPE_NORMAL
- en: Use this built-in FastAPI/Starlette object to access the server directly, without
    an overt TCP connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'But these approaches require writing one or more tests for each endpoint. This
    can become medieval, and we’re a few centuries past medieval now. A more recent
    approach is based on *property-based testing*. This takes advantage of FastAPI’s
    autogenerated documentation. An OpenAPI *schema* called *openapi.json* is created
    by FastAPI every time you change a path function or path decorator in the Web
    layer. This schema details everything about every endpoint: arguments, return
    values, and so on. That’s what OpenAPI is for, as described here by the [OpenAPI
    Initiative’s FAQ page](https://www.openapis.org/faq):'
  prefs: []
  type: TYPE_NORMAL
- en: The OAS defines a standard, programming language-agnostic interface description
    for REST APIs, which allows both humans and computers to discover and understand
    the capabilities of a service without requiring access to source code, additional
    documentation, or inspection of network traffic.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: OAS (OpenAPI Specification)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Two packages are needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Hypothesis](https://hypothesis.works)'
  prefs: []
  type: TYPE_NORMAL
- en: '`pip install hypothesis`'
  prefs: []
  type: TYPE_NORMAL
- en: '[Schemathesis](https://schemathesis.readthedocs.io)'
  prefs: []
  type: TYPE_NORMAL
- en: '`pip install schemathesis`'
  prefs: []
  type: TYPE_NORMAL
- en: Hypothesis is the base library, and Schemathesis applies it to the OpenAPI 3.0
    schema that FastAPI generates. Running Schemathesis reads this schema, generates
    gobs of tests with varying data (that you don’t need to come up with!), and works
    with pytest.
  prefs: []
  type: TYPE_NORMAL
- en: To keep this brief, [Example 12-16](#ex-12-16) first slims *main.py* down to
    its base creature and explorer endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-16\. Bare-bones main.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 12-17](#ex-12-17) runs the tests.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-17\. Run Schemathesis tests
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: I got two F’s, both in `PATCH` calls (`modify()` functions). How mortifying.
  prefs: []
  type: TYPE_NORMAL
- en: 'This output section is followed by one marked `FAILURES`, with detailed stack
    traces of any tests that failed. Those need to be fixed. The final section is
    marked `SUMMARY`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: That was fast, and multiple tests were not needed for each endpoint, imagining
    inputs that might break them. Property-based testing reads the types and constraints
    of the input arguments from the API schema, and generates a range of values to
    shoot at each endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is yet another unexpected benefit of type hints, which at first seemed
    to be just nice things:'
  prefs: []
  type: TYPE_NORMAL
- en: type hints → OpenAPI schema → generated documentation *and* tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security isn’t one thing, but everything. You need to defend against malice
    but also against plain old mistakes, and even events that you have no control
    over. Let’s defer scaling issues to the next section and deal mainly here with
    the analysis of potential threats.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 11](ch11.html#ch11) discussed authentication and authorization. These
    factors are always messy and error-prone. It’s tempting to use clever methods
    to counteract clever attacks, and it’s always a challenge to design protection
    that’s easy to understand and implement.'
  prefs: []
  type: TYPE_NORMAL
- en: But now that you know about Schemathesis, read its [documentation](https://oreil.ly/v_O-Q)
    on property-based testing for authentication. Just as it vastly simplified testing
    most of the API, it can automate much of the tests for endpoints that need authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Load Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Load tests show how your application handles heavy traffic:'
  prefs: []
  type: TYPE_NORMAL
- en: API calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database reads or writes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disk use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network latency and bandwidth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some can be *full* tests that simulate an army of users clamoring to use your
    service; you want to be ready before that day arrives. The content in this section
    overlaps with that in [“Performance”](ch13.html#performanceSect) and [“Troubleshooting”](ch13.html#troubleshooting).
  prefs: []
  type: TYPE_NORMAL
- en: Many good load testers out are there, but here I’ll recommend [Locust](https://locust.io).
    With Locust, you define all your tests with plain Python scripts. It can simulate
    hundreds of thousands of users, all pounding away at your site, or even multiple
    servers, at once.
  prefs: []
  type: TYPE_NORMAL
- en: Install it locally with `pip install locust`. Your first test may be how many
    concurrent visitors your site can handle. This is like testing how much extreme
    weather a building can withstand when faced with a hurricane/earthquake/blizzard
    or other home insurance event. So, you need some website structural tests. Follow
    the Locust [docs](https://docs.locust.io) for all the details.
  prefs: []
  type: TYPE_NORMAL
- en: But, as they say on TV, there’s more! Recently, [Grasshopper](https://github.com/alteryx/locust-grasshopper)
    extended Locust to do things like measuring time across multiple HTTP calls. To
    try this extension out, install with `pip install locust-grasshopper`.
  prefs: []
  type: TYPE_NORMAL
- en: Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter fleshed out the types of testing, with examples of pytest performing
    automated code testing at the unit, integration, and full levels. API tests can
    be automated with Schemathesis. This chapter also discussed how to expose security
    and performance problems before they strike.
  prefs: []
  type: TYPE_NORMAL
