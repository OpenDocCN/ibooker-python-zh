- en: Chapter 7\. Adopting Typechecking Practically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many developers dream of the days when they’ll finally work in a completely
    *green-field* project. A green-field project is one that is brand-new, where you
    have a blank slate with your code’s architecture, design, and modularity. However,
    most projects soon become *brown-field*, or legacy code. These projects have been
    around the block a bit; much of the architecture and design has been solidified.
    Making big, sweeping changes will impact real users. The term *brown-field* is
    often seen as derogatory, especially when it feels like you are slogging through
    a big ball of mud.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, not all brown-field projects are a punishment to work in. Michael
    Feathers, author of *Working Effectively With Legacy Code* (Pearson), has this
    to say:'
  prefs: []
  type: TYPE_NORMAL
- en: In a well-maintained system, it might take a while to figure out how to make
    a change, but once you do, the change is usually easy and you feel much more comfortable
    with the system. In a legacy system, it can take a long time to figure out what
    to do, and the change is difficult also.^([1](part0010_split_007.html#idm45644746117528))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Feathers defines legacy code as “code without tests.” I prefer an alternate
    definition: legacy code is simply code where you can no longer discuss the code
    with the developers who wrote it. In lieu of that communication, you rely on the
    codebase itself to describe its behavior. If the codebase clearly communicates
    its intentions, it is a well-maintained system that is easy to work in. It may
    take a little bit of time to understand it all, but once you do, you are able
    to add features and evolve the system. However, if that codebase is difficult
    to understand, you will face an uphill battle. That code becomes unmaintainable.
    This is why robustness is paramount. Writing robust code eases the transition
    from green-field to brown-field by making the code more maintainable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the type annotation strategies that I’ve shown in the first part of
    this book are easier to adopt when a project is new. Adopting these practices
    in a mature project is more challenging. It is not impossible, but the cost may
    be higher. This is the heart of engineering: making smart decisions about trade-offs.'
  prefs: []
  type: TYPE_NORMAL
- en: Trade-offs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every decision you make involves a trade-off. Lots of developers focus on the
    classic time versus space trade-off in algorithms. But there are plenty of other
    trade-offs, often involving intangible qualities. I’ve already covered the benefits
    of a typechecker quite extensively throughout this first part of the book:'
  prefs: []
  type: TYPE_NORMAL
- en: A typechecker increases communication and reduces the chances of bugs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A typechecker provides a safety net for making changes and increases the robustness
    of your codebase.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A typechecker allows you to deliver functionality faster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But what are the costs? Adopting type annotations is not free, and they only
    get worse the larger your codebase is. These costs include:'
  prefs: []
  type: TYPE_NORMAL
- en: The need for buy-in. Depending on culture, it might take some time convincing
    an organization to adopt typechecking.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have buy-in, there is an initial cost of adoption. Developers don’t
    start type annotating their code overnight, and it takes time before they grok
    it. They need to learn it and experiment before they are on board.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It takes time and effort to adopt tooling. You need centralized checking of
    some fashion, and developers need to familiarize themselves with running the tooling
    as part of their workflows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will take time to write type annotations in your codebase.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As type annotations are checked, developers will have to get used to the slowdown
    in fighting the typechecker. There is additional cognitive overload in thinking
    about types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Developer time is expensive, and it is easy to focus on what else those developers
    could be doing. Adopting type annotations is not free. Worse, with a large enough
    codebase, these costs can easily dwarf the initial benefit you get from typechecking.
    The problem is fundamentally a chicken-and-egg conundrum. You won’t see benefits
    for annotating types until you have written enough types in your codebase. However,
    it is tough to get buy-in for writing types when the benefit isn’t there early
    on. You can model your value as such:'
  prefs: []
  type: TYPE_NORMAL
- en: Value = (Total Benefits) − (Total Costs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your benefits and costs will follow a curve; they are not linear functions.
    I’ve outlined the basic shapes of the curves in [Figure 7-1](part0010_split_001.html#cost_benefit_curves).
  prefs: []
  type: TYPE_NORMAL
- en: '![Cost and benefit curves over time](../images/00012.gif)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. Cost and benefit curves over time
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I’ve purposely left off the range, because the scale will change depending on
    the size of your codebase, but the shapes remain the same. Your costs will start
    out high, but get easier as adoption increases. Your benefits will start off low,
    but as you annotate your codebase, you will see more value. You won’t see a return
    on investment until these two curves meet. To maximize value, you need to reach
    that intersection as early as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking Even Earlier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To maximize the benefits of type annotations, you need to either get value earlier
    or decrease your costs earlier. The intersection of these two curves is a break-even
    point; this is where the amount of effort that you’re expending is paid back by
    the value you are receiving. You want to reach this point as fast as sustainably
    possible so that your type annotations have a positive impact. Here are some strategies
    to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Find Your Pain Points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the best ways to produce value is to reduce the pain you are currently
    experiencing. Ask yourself: where do I currently lose time in my process? Where
    do I lose money? Take a look at your test failures and customer bugs. These error
    cases incur real costs; you should be doing root cause analysis. If you find that
    a common root cause can be fixed by type annotations, you have a solid case for
    type annotation adoption. Here are specific bug classes you need to keep an eye
    out for:'
  prefs: []
  type: TYPE_NORMAL
- en: Any error surrounding `None`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invalid attribute access, such as trying to access variables of functions on
    the wrong type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Errors surrounding type conversions such as integers versus strings, bytes versus
    strings, or lists versus tuples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, talk to the people who have to work in the codebase itself. Root out the
    areas that are a constant source of confusion. If developers have trouble with
    certain parts of the codebase today, it’s likely that future developers will struggle
    too.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget to talk to those who are invested in your codebase but maybe don’t
    directly work in it, such as your tech support, product management, and QA. They
    often have a unique perspective on painful areas of the codebase that might not
    be apparent when looking through the code. Try to put these costs into concrete
    terms, such as time or money. This will be invaluable in evaluating where type
    annotations will be of benefit.
  prefs: []
  type: TYPE_NORMAL
- en: Target Code Strategically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may want to focus on trying to receive value earlier. Type annotations do
    not appear overnight in a large codebase. Instead, you will need to identify specific
    and strategic areas of code to target for type annotations. The beauty of type
    annotations is that they are completely optional. By typechecking just these areas,
    you very quickly see benefits without a huge up-front investment. Here are some
    strategies that you might employ to selectively type annotate your code.
  prefs: []
  type: TYPE_NORMAL
- en: Type annotate new code only
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider leaving your current unannotated code the way it is and annotate code
    based on these two rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Annotate any new code that you write.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotate any old code that you change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout time, you’ll build out your type annotations in all code except code
    that hasn’t been changed in a long time. Code that hasn’t been changing is relatively
    stable, and is probably not read too often. Type annotating it is not likely to
    gain you much benefit.
  prefs: []
  type: TYPE_NORMAL
- en: Type annotate from the bottom up
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your codebase may depend on common areas of code. These are your core libraries
    and utilities that serve as a foundation upon which everything else is built.
    Type annotating these parts of your codebase makes your benefit less about depth
    and more about breadth. Because so many other pieces sit atop this foundation,
    they will all reap the benefits of typechecking. New code will quite often depend
    on these utilities as well, so your new code will have an extra layer of protection.
  prefs: []
  type: TYPE_NORMAL
- en: Type annotate your moneymakers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some codebases, there is a clear separation between the core business logic
    and all the rest of the code that supports your business logic. Your *business
    logic* is the area of your system that is most responsible for delivering value.
    It might be the core reservation system for a travel agency, an ordering system
    in a restaurant, or a recommendation system for media services. All of the rest
    of the code (such as logging, messaging, database drivers, and user interface)
    exists to support your business logic. By type annotating your business logic,
    you are protecting a core part of your codebase. This code is often long-lived,
    making it an easy win for long-lasting value.
  prefs: []
  type: TYPE_NORMAL
- en: Type annotate the churners
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some parts of your codebase change way more often than the others. Every time
    a piece of code changes, you run the risk of an incorrect assumption introducing
    a bug. The whole point of robust code is to lessen the chance of introducing errors,
    so what better place to protect than the code that changes the most often? Look
    for your code that has many different commits in version control, or analyze which
    files have the most lines of code changed over a time period. Also take a look
    at which files have the most committers; this is a great indication that this
    is an area where you can shore up type annotations for communication purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Type annotate the complex
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you come across some complex code, it will take some time to understand.
    After understanding that code, the best thing you can do is reduce the complexity
    for the next developer who reads the code. Refactoring the code, improving naming,
    and adding comments are all fantastic ways to improve comprehension, but consider
    also adding more type annotations. Type annotations will help developers understand
    what types are used, how to call functions, and how to deal with return values.
    Type annotations provide additional documentation for complex code.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion Topic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of these strategies would benefit your codebase the most? Why does that
    strategy work best for you? What would the cost be to implement that strategy?
  prefs: []
  type: TYPE_NORMAL
- en: Lean on Your Tooling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are things that computers do well, and there are things that humans do
    well. This section is about the former. When trying to adopt type annotations,
    there are some fantastic things that automated tooling can assist with. First,
    let’s talk about the most common typechecker out there: mypy.'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve covered the configuration of mypy quite extensively in [Chapter 6](part0009_split_000.html#typechecker),
    but there are a few more options I’d like to delve into that will help you adopt
    typechecking. One of the biggest problems you will run into is the sheer number
    of errors that mypy will report the first time you run it on a larger codebase.
    The biggest mistake you can make in this situation is to keep the hundreds (or
    thousands) of errors turned on and hope that developers whittle away at the errors
    over time.
  prefs: []
  type: TYPE_NORMAL
- en: These errors will not get fixed in any quick fashion. If these errors are always
    turned on, you will not see the benefits of a typechecker, because it will be
    nearly impossible to detect new errors. Any new issue will simply be lost in the
    noise of the multitude of other issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'With mypy, you can tell the typechecker to ignore certain classes of errors
    or modules through configuration. Here’s a sample mypy file, which globally warns
    if `Any` types are returned, and sets config options on a per-module basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Using this format, you can pick and choose which errors your typechecker tracks.
    You can mask all of your existing errors, while focusing on fixing new errors.
    Be as specific as possible in defining which errors get ignored; you don’t want
    to mask new errors that show up in unrelated parts of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be even more specific, mypy will ignore any line commented with `# type:
    ignore`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`# type: ignore` should not be an excuse to be lazy! When writing new code,
    don’t ignore type errors—fix them as you go.'
  prefs: []
  type: TYPE_NORMAL
- en: Your first goal for adopting type annotations is to get a completely clean run
    of your typechecker. If there are errors, you either need to fix them with annotations
    (recommended) or accept that not all errors can be fixed soon and ignore them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over time, make sure the number of ignored sections of code decreases. You
    can track the number of lines containing `# type : ignore` or the number of configuration
    file sections that you are using; no matter what, strive to ignore as few sections
    as you can (within reasonable limits, of course—there is a law of diminishing
    returns).'
  prefs: []
  type: TYPE_NORMAL
- en: I also recommend turning the `warn_unused_ignores` flag on in your mypy configuration,
    which will warn when an ignore directive is no longer required.
  prefs: []
  type: TYPE_NORMAL
- en: Now, none of this helps you get any closer to actually annotating your codebase;
    it just gives you a starting point. To help annotate your codebase with tooling,
    you will need something that can automatically insert annotations.
  prefs: []
  type: TYPE_NORMAL
- en: MonkeyType
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[MonkeyType](https://github.com/Instagram/MonkeyType) is a tool that will automatically
    annotate your Python code. This is a great way to typecheck a large amount of
    code without a lot of effort.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First install MonkeyType with `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose your codebase controls an automatic chef with robotic arms that is
    capable of cooking perfect food every time. You want to program the chef with
    my family’s favorite recipe, Pasta with Italian Sausage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](../images/00002.gif)](part0010_split_006.html#co_adopting_typechecking_practically_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Definition of all ingredients
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](../images/00005.gif)](part0010_split_006.html#co_adopting_typechecking_practically_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Function to make pasta with sausage
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](../images/00006.gif)](part0010_split_006.html#co_adopting_typechecking_practically_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Prepping instructions
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](../images/00007.gif)](part0010_split_006.html#co_adopting_typechecking_practically_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Cooking instructions
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](../images/00008.gif)](part0010_split_006.html#co_adopting_typechecking_practically_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Serving instructions
  prefs: []
  type: TYPE_NORMAL
- en: I’ve left out a lot of the helper functions to save space, but this gives you
    an idea of what I’m trying to achieve. You can see the full example in the [GitHub
    repo](https://github.com/pviafore/RobustPython) that accompanies this book.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the entire example, I have zero type annotations. I don’t want to
    write all the type annotations by hand, so I’ll use MonkeyType. To help, I can
    generate *stub files* to create type annotations. Stub files are files that just
    contain function signatures.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to generate the stub files, you have to run your code. This is an
    important detail; MonkeyType will only annotate code that you run first. You can
    run specific scripts like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will generate a `SQLite` database that stores all the function calls made
    throughout the execution of that program. You should try to run as many parts
    of your system as you can in order to populate this database. Unit tests, integration
    tests, and test programs all contribute to populating the database.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because MonkeyType works by instrumenting your code using `sys.setprofile`,
    other instrumentation such as code coverage and profiling will not work at the
    same time. Any tool that uses instrumentation will need to be run separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have run through as many paths of your code as you want, you can generate
    the stub files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the stub file for this specific module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It won’t annotate everything, but it will certainly give you more than enough
    of a head start in your codebase. Once you are comfortable with the suggestions,
    you can apply them with `monkeytype apply <module-name>`. Once these annotations
    have been generated, search through the codebase for any use of `Union`. A `Union`
    tells you that more than one type has been passed to that function as part of
    the execution of your code. This is a *code smell*, or something that looks a
    little funny, even if it’s not totally wrong (yet). In this case, the use of a
    `Union` may indicate unmaintainable code; your code is receiving different types
    and might not be equipped to handle them. If wrong types are passed as a parameter,
    that’s a likely sign that assumptions have been invalidated somewhere along the
    way.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, the stubs for my `recipe_maker` contain a `Union` in one of
    my function signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameter `heat_level` has taken a `HeatLevel` in some cases and an integer
    in other cases. Looking back at my recipe, I see the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Whether this is an error or not depends on the implementation of the function.
    In my case, I want to be consistent, so I would change the integer usage to `Enum`
    usage. For your codebase, you will need to determine what is acceptable and what
    is not.
  prefs: []
  type: TYPE_NORMAL
- en: Pytype
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the problems with MonkeyType is that it only annotates code it sees
    at runtime. If there are branches of your code that are costly or unable to be
    run, MonkeyType will not help you that much. Fortunately, a tool exists to fill
    in this gap: [Pytype](https://github.com/google/pytype), written by Google. Pytype
    adds type annotations through static analysis, which means it does not need to
    run your code to figure out types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To run Pytype, install it with `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run Pytype against your code folder (e.g., *code_examples/chapter7*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will generate a set of *.pyi* files in a *.pytype* folder. These are very
    similar to the stub files that MonkeyType created. They contain annotated function
    signatures and variables that you can then copy into your source files.
  prefs: []
  type: TYPE_NORMAL
- en: Pytype offers other intriguing benefits as well. Pytype is not just a type annotator;
    it is a full linter and typechecker. It has a different typechecking philosophy
    than other typecheckers such as mypy, Pyright, and Pyre.
  prefs: []
  type: TYPE_NORMAL
- en: Pytype will use inference to do its typechecking, which means it will typecheck
    your code even in the absence of type annotations. This is a great way to get
    the benefit of a typechecker without having to write types throughout your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pytype is also a little more lenient on types changing in the middle of their
    lifetime. This is a boon for those who fully embrace Python’s dynamically typed
    nature. As long as code will work at runtime, Pytype is happy. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this case, names will start off as a list of `Ingredients`. If water is not
    among the ingredients, I add the string “water” to the list. At this point, the
    list is heterogeneous; it contains both ingredients and strings. If you were to
    annotate names as a `list[Ingredient]`, mypy would error out in this case. I would
    typically throw a red flag here as well; heterogeneous collections are harder
    to reason about in the absence of good type annotations. However, the next line
    renders both mypy and my objections moot. Everything is getting converted to a
    string when returned, which fulfills the annotation of the expected return type.
    Pytype is intelligent enough to detect this and consider this code to have no
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: Pytype’s leniency and approach to typechecking make it very forgiving for adopting
    into existing codebases. You don’t need any type annotations in order to see the
    value. This means you get all the benefits of a typechecker with very minimal
    work. High value, but low cost? Yes, please.
  prefs: []
  type: TYPE_NORMAL
- en: However, Pytype is a double-edged sword in this case. Make sure you don’t use
    Pytype as a crutch; you should still be writing type annotations. It becomes incredibly
    easy with Pytype to think that you don’t need type annotations at all. However,
    you should still write them for two reasons. Firstly, type annotations provide
    a documentation benefit, which helps your code’s readability. Secondly, Pytype
    will be able to make even more intelligent decisions if type annotations are present.
  prefs: []
  type: TYPE_NORMAL
- en: Closing Thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Type annotations are incredibly useful, but there is no denying their cost.
    The larger the codebase, the higher the cost will be for practically adopting
    type annotations. Every codebase is different; you need to evaluate the value
    and cost of type annotations for your specific scenario. If type annotations are
    too costly to adopt, consider three strategies to get past that hurdle:'
  prefs: []
  type: TYPE_NORMAL
- en: Find pain points
  prefs: []
  type: TYPE_NORMAL
- en: If you can eliminate entire classes of pain points through type annotations,
    such as errors, broken tests, or unclear code, you will save time and money. You
    target the areas that hurt the most, and by lessening that pain you are making
    it easier for developers to deliver value over time (which is a sure sign of maintainable
    code).
  prefs: []
  type: TYPE_NORMAL
- en: Target code strategically
  prefs: []
  type: TYPE_NORMAL
- en: Pick your spots wisely. In a large codebase, it will be near impossible to annotate
    every meaningful part of your code. Instead, focus on smaller sections that would
    see a huge benefit.
  prefs: []
  type: TYPE_NORMAL
- en: Lean on your tooling
  prefs: []
  type: TYPE_NORMAL
- en: Use mypy to help you selectively ignore files (and make sure that you are ignoring
    fewer lines of code over time). Use type annotators such as MonkeyType and Pytype
    to quickly generate types throughout your code. Don’t discount Pytype as a typechecker
    either, as it can find bugs lurking in your code with minimal setup.
  prefs: []
  type: TYPE_NORMAL
- en: This wraps up [Part I](part0004.html#part_1) of the book. It has focused exclusively
    on type annotations and typechecking. Feel free to mix and match the strategies
    and tools I’ve discussed. You don’t need to type annotate absolutely everything,
    as type annotations can constrain expressiveness if too strictly applied. But
    you should strive to clarify code and make it harder for bugs to crop up. You
    will find the balance over time, but you need to start thinking about types in
    Python and how you can express them to other developers. Remember, the goal is
    a maintainable codebase. People need to understand as much of your intentions
    as they can from the code alone.
  prefs: []
  type: TYPE_NORMAL
- en: In [Part II](part0011.html#part_2), I’m going to focus on creating your own
    types. You’ve seen a little of this with building your own collection types, but
    you can go so much further. You’ll learn about enumerations, data classes, and
    classes, and learn why you should pick one over the other. You’ll learn how to
    craft an API and subclass types and model your data. You’ll continue to build
    a vocabulary that improves readability in your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: '^([1](part0010_split_000.html#idm45644746117528-marker)) Michael C. Feathers.
    *Working Effectively with Legacy Code*. Upper Saddle River, NJ: Pearson, 2013.'
  prefs: []
  type: TYPE_NORMAL
