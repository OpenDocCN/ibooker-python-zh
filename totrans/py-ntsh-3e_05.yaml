- en: Chapter 5\. Type Annotations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. 类型注释
- en: Annotating your Python code with type information is an optional step which
    can be very helpful during development and maintenance of a large project or a
    library. Static type checkers and lint tools help identify and locate data type
    mismatches in function arguments and return values. IDEs can use these *type annotations*
    (also called *type hints*) to improve autocompletion and to provide pop-up documentation.
    Third-party packages and frameworks can use type annotations to tailor runtime
    behavior, or to autogenerate code based on type annotations for methods and variables.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型信息对Python代码进行注释是一个可选步骤，在开发和维护大型项目或库时可能非常有用。静态类型检查器和lint工具可帮助识别和定位函数参数和返回值的数据类型不匹配。IDE可以使用这些*类型注释*（也称为*类型提示*）来改进自动完成，并提供弹出式文档。第三方软件包和框架可以使用类型注释来定制运行时行为，或者根据方法和变量的类型注释自动生成代码。
- en: Type annotations and checking in Python continue to evolve, and touch on many
    complicated issues. This chapter covers some of the most common use cases for
    type annotations; you can find more comprehensive material in the resources listed
    at the end of the chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的类型注释和检查仍在不断发展，并涉及许多复杂的问题。本章涵盖了类型注释的一些最常见用例；您可以在本章末尾列出的资源中找到更全面的资料。
- en: Type Annotation Support Varies by Python Version
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python版本的类型注释支持因版本而异
- en: Python’s features supporting type annotations have evolved from version to version,
    with some significant additions and deletions. The rest of this chapter will describe
    the type annotation support in the most recent versions of Python (3.10 and later),
    with notes to indicate features that might be present or absent in other versions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 支持类型注释的Python功能已经从一个版本发展到另一个版本，其中包括一些重大的增加和删除。本章的其余部分将描述Python最新版本（3.10及更高版本）中的类型注释支持，其中包含一些可能在其他版本中存在或不存在的功能的注释。
- en: History
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 历史
- en: Python is, fundamentally, a *dynamically typed* language. This lets you rapidly
    develop code by naming and using variables without having to declare them. Dynamic
    typing allows for flexible coding idioms, generic containers, and polymorphic
    data handling without requiring explicit definition of interface types or class
    hierarchies. The downside is that the language offers no help during development
    in flagging variables of incompatible types being passed to or returned from functions.
    In place of the development-time compile step that some languages utilize to detect
    and report data type issues, Python relies on developers to maintain comprehensive
    unit tests, especially (though far from exclusively!^([1](ch05.xhtml#ch01fn72)))
    to uncover data type errors by re-creating the runtime environment in a series
    of test cases.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Python本质上是一种*动态类型*语言。这使您能够通过命名和使用变量来快速开发代码，而无需声明它们。动态类型允许使用灵活的编码习惯、通用容器和多态数据处理，而无需显式定义接口类型或类层次结构。缺点是，在开发过程中，语言无法在传递给函数或从函数返回的不兼容类型的变量上提供帮助。Python不像一些语言那样利用开发时编译步骤来检测和报告数据类型问题，而是依靠开发人员通过一系列测试用例在运行时环境中重建来发现数据类型错误。
- en: Type Annotations Are Not Enforced
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型注释不是强制性的
- en: Type annotations are *not* enforced at runtime. Python does not perform any
    type validation or data conversion based on them; the executable Python code is
    still responsible for using variables and function arguments properly. However,
    type annotations must be syntactically correct. A late-imported or dynamically
    imported module containing an invalid type annotation raises a SyntaxError exception
    in your running Python program, just like any invalid Python statement.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 类型注释在运行时*不*被强制执行。Python不执行任何基于类型注释的类型验证或数据转换；可执行的Python代码仍然负责正确使用变量和函数参数。但是，类型注释必须在语法上是正确的。包含无效类型注释的延迟导入或动态导入模块会在运行中的Python程序中引发SyntaxError异常，就像任何无效的Python语句一样。
- en: Historically, the absence of any kind of type checking was often seen as a shortcoming
    of Python, with some programmers citing this as a reason for choosing other programming
    languages. However, the community wanted Python to maintain its runtime type freedom,
    so the logical approach was to add support for static type checks performed at
    development time by lint-like tools (described further in the following section)
    and IDEs. Some attempts were made at type checking based on parsing function signatures
    or docstrings. Guido van Rossum cited several cases on the [Python Developers
    mailing list](https://oreil.ly/GFMBC) showing that type annotations could be helpful;
    for example, when maintaining large legacy codebases. With an annotation syntax,
    development tools could perform static type checks to highlight variable and function
    usages that conflict with the intended types.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，Python缺乏任何类型检查被认为是其短板之一，一些程序员因此选择其他编程语言。然而，社区希望Python保持其运行时类型自由，因此逻辑上的做法是增加对由类似lint工具（在下一节进一步描述）和IDE执行的静态类型检查的支持。一些尝试是基于解析函数签名或文档字符串进行类型检查。Guido
    van Rossum在[Python开发者邮件列表](https://oreil.ly/GFMBC)上引用了几个案例，显示类型注解可以帮助，例如在维护大型遗留代码库时。使用注解语法，开发工具可以执行静态类型检查，以突出显示与预期类型冲突的变量和函数使用。
- en: The first official version of type annotations used specially formatted comments
    to indicate variable types and return codes, as defined in [PEP 484](https://oreil.ly/61GSZ),
    a provisional PEP for Python 3.5.^([2](ch05.xhtml#ch01fn73)) Using comments allowed
    for rapid implementation of, and experimentation with, the new typing syntax,
    without having to modify the Python compiler itself.^([3](ch05.xhtml#ch01fn74))
    The third-party package [mypy](http://mypy-lang.org) gained broad acceptance performing
    static type checking using these comments. With the adoption of [PEP 526](https://oreil.ly/S8kI3)
    in Python 3.6, type annotations were fully incorporated into the Python language
    itself, with a supporting typing module added to the standard library.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 类型注解的第一个官方版本使用特殊格式的注释来指示变量类型和返回代码，如[PEP 484](https://oreil.ly/61GSZ)所定义的，这是Python
    3.5的一项临时PEP。^([2](ch05.xhtml#ch01fn73)) 使用注释可以快速实现和尝试新的类型语法，而无需修改Python编译器本身。^([3](ch05.xhtml#ch01fn74))
    第三方包[mypy](http://mypy-lang.org)通过使用这些注释进行静态类型检查得到了广泛接受。随着Python 3.6采纳了[PEP 526](https://oreil.ly/S8kI3)，类型注解已完全整合到Python语言本身，并在标准库中添加了一个支持的typing模块。
- en: Type-Checking Utilities
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型检查工具
- en: As type annotations have become an established part of Python, type-checking
    utilities and IDE plug-ins have also become part of the Python ecosystem.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 随着类型注解成为Python的一个已确立部分，类型检查工具和IDE插件也成为Python生态系统的一部分。
- en: mypy
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: mypy
- en: The standalone [mypy](https://oreil.ly/6fMPM) utility continues to be a mainstay
    for static type checking, always up-to-date (give or take a Python version!) with
    evolving Python type annotation forms. mypy is also available as a plug-in for
    editors including Vim, Emacs, and SublimeText, and for the Atom, PyCharm, and
    VS Code IDEs. (PyCharm, VS Code, and Wing IDE also incorporate their own type-checking
    features separate from mypy.) The most common command for running mypy is simply
    **mypy my_python_script.py**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 独立的[mypy](https://oreil.ly/6fMPM)实用程序继续作为静态类型检查的主要工具，始终与Python类型注解形式的演变保持最新状态（只要考虑Python版本！）。mypy还作为插件提供给编辑器，包括Vim、Emacs和SublimeText，以及Atom、PyCharm和VS
    Code IDE。 （PyCharm、VS Code和Wing IDE还单独包含了自己的类型检查功能，与mypy分开）。运行mypy的最常见命令只是**mypy
    my_python_script.py**。
- en: You can find more detailed usage examples and command-line options in the [mypy
    online documentation](https://oreil.ly/rQPK0), as well as a [cheat sheet](https://oreil.ly/CT6FE)
    that serves as a handy reference. Code examples later in this section will include
    example mypy error messages to illustrate the kinds of Python errors that can
    be caught using type checking.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[mypy在线文档](https://oreil.ly/rQPK0)中找到更详细的用法示例和命令行选项，以及一个作为便捷参考的[速查表](https://oreil.ly/CT6FE)。本节后面的代码示例将包含mypy错误消息示例，以说明可以通过类型检查捕获的Python错误类型。
- en: Other Type Checkers
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他类型检查器
- en: 'Other type checkers to consider using include:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 其他考虑使用的类型检查器包括：
- en: MonkeyType
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: MonkeyType
- en: Instagram’s [MonkeyType](https://oreil.ly/RHqNo) uses the sys.setprofile hook
    to detect types dynamically at runtime; like pytype (see below), it can also generate
    a *.pyi* (stub) file instead of, or in addition to, inserting type annotations
    in the Python code file itself.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Instagram 的 [MonkeyType](https://oreil.ly/RHqNo) 使用 sys.setprofile 钩子在运行时动态检测类型；像
    pytype 一样（见下文），它也可以生成 *.pyi*（存根）文件，而不是或者除了在 Python 代码文件中插入类型注解。
- en: pydantic
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: pydantic
- en: '[pydantic](https://oreil.ly/-zNQj) also works at runtime, but it does not generate
    stubs or insert type annotations; rather, its primary goal is to parse inputs
    and ensure that Python code receives clean data. As described in the [online docs](https://oreil.ly/0Ucvm),
    it also allows you to extend its validation features for your own environment.
    See [“FastAPI”](ch20.xhtml#fastapi) for a simple example.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[pydantic](https://oreil.ly/-zNQj) 也可以在运行时工作，但不生成存根或插入类型注解；它的主要目标是解析输入并确保 Python
    代码获得干净的数据。正如[在线文档](https://oreil.ly/0Ucvm)中所述，它还允许您扩展其验证功能以适应自己的环境。参见[“FastAPI”](ch20.xhtml#fastapi)的简单示例。'
- en: Pylance
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Pylance
- en: '[Pylance](https://oreil.ly/uB5XN) is a type checking module primarily meant
    to embed Pyright (see below) into VS Code.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[Pylance](https://oreil.ly/uB5XN) 是一个类型检查模块，主要用于将 Pyright（见下文）嵌入到 VS Code 中。'
- en: Pyre
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Pyre
- en: Facebook’s [Pyre](https://oreil.ly/HJ-qQ) can also generate *.pyi* files. It
    currently does not run on Windows, unless you have the [Windows Subsystem for
    Linux (WSL)](https://oreil.ly/DwB82) installed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook 的 [Pyre](https://oreil.ly/HJ-qQ) 也可以生成 *.pyi* 文件。目前在 Windows 上无法运行，除非安装了
    [Windows Subsystem for Linux (WSL)](https://oreil.ly/DwB82)。
- en: Pyright
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Pyright
- en: '[Pyright](https://oreil.ly/wwuA8) is Microsoft’s static type checking tool,
    available as a command-line utility and a VS Code extension.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[Pyright](https://oreil.ly/wwuA8) 是微软的静态类型检查工具，作为命令行实用程序和 VS Code 扩展提供。'
- en: pytype
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: pytype
- en: '[pytype](https://oreil.ly/QuhCB) from Google is a static type checker that
    focuses on *type inferencin*g (and offers advice even in the absence of type hints)
    in addition to type annotations. Type inferencing offers a powerful capability
    for detecting type errors even in code without annotations. pytype can also generate
    *.pyi* files and merge stub files back into *.py* sources (the most recent versions
    of mypy are following suit on this). Currently, pytype does not run on Windows
    unless you first install [WSL](https://oreil.ly/7G_j-).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[pytype](https://oreil.ly/QuhCB) 是谷歌的静态类型检查器，专注于*类型推断*（即使在没有类型提示的情况下也能提供建议），除了类型注解。类型推断提供了强大的能力，即使在没有注解的代码中也能检测类型错误。pytype
    还可以生成 *.pyi* 文件，并将存根文件合并回 *.py* 源代码中（最新版本的 mypy 也在效仿）。目前，pytype 在 Windows 上无法运行，除非你首先安装
    [WSL](https://oreil.ly/7G_j-)。'
- en: The emergence of type-checking applications from multiple major software organizations
    is a testimonial to the widespread interest in the Python developer community
    in using type annotations.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 多个主要软件组织开发的类型检查应用的出现，证明了 Python 开发者社区在使用类型注解方面的广泛兴趣。
- en: Type Annotation Syntax
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型注解语法
- en: 'A *type annotation* is specified in Python using the form:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*类型注解* 在 Python 中使用以下形式指定：'
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*type_specification* can be any Python expression, but usually involves one
    or more built-in types (for example, just mentioning a Python type is a perfectly
    valid expression) and/or attributes imported from the typing module (discussed
    in the following section). The typical form is:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*type_specification* 可以是任何 Python 表达式，但通常涉及一个或多个内置类型（例如，仅提到 Python 类型就是一个完全有效的表达式）和/或从
    typing 模块导入的属性（在下一节中讨论）。典型的形式是：'
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here are some examples of type expressions used as type annotations for a variable:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些作为变量类型注解使用的类型表达式示例：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that **lambda**s do *not* accept type annotations.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，**lambda** 不接受类型注解。
- en: 'To annotate a function with a return type, use the form:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要为函数添加返回类型注解，请使用以下形式：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'where each *argument* takes the form:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 *参数* 的形式如下：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here’s an example of an annotated function:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个带有注解函数的示例：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that when an annotated parameter has a default value, PEP 8 recommends
    using spaces around the equals sign.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当带有默认值的注解参数时，PEP 8 建议在等号周围使用空格。
- en: Forward-Referencing Types That Are Not Yet Fully Defined
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还未完全定义的前向引用类型
- en: 'At times, a function or variable definition needs to reference a type that
    has not yet been defined. This is quite common in class methods, or methods that
    must define arguments or return values of the type of the current class. Those
    function signatures are parsed at compile time, and at that point the type is
    not yet defined. For example, this classmethod fails to compile:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，函数或变量定义需要引用尚未定义的类型。这在类方法或必须定义当前类类型的参数或返回值的方法中非常常见。这些函数签名在编译时解析，此时类型尚未定义。例如，此类方法无法编译通过：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Since class A has not yet been defined when Python compiles factory_method,
    the code raises NameError.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Python 编译 `factory_method` 时，类 A 尚未定义，因此代码会引发 NameError 错误。
- en: 'The problem can be resolved by enclosing the return type A in quotes:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 问题可以通过在类型 A 的返回类型中添加引号来解决：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A future version of Python may defer the evaluation of type annotations until
    runtime, making the enclosing quotes unnecessary (Python’s Steering Committee
    is evaluating various possibilities). You can preview this behavior using **from**
    __future__ **import** annotations.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 未来版本的 Python 可能会推迟对类型注解的评估，直到运行时，从而使封闭引号变得不必要（Python 的指导委员会正在评估各种可能性）。您可以使用
    **from** __future__ **import** annotations 预览此行为。
- en: The typing Module
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: typing 模块
- en: 'The typing module supports type hints. It contains definitions that are useful
    when creating type annotations, including:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: typing 模块支持类型提示。它包含在创建类型注释时有用的定义，包括：
- en: Classes and functions for defining types
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于定义类型的类和函数
- en: Classes and functions for modifying type expressions
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于修改类型表达式的类和函数
- en: Abstract base classes (ABCs)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象基类（ABCs）
- en: Protocols
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议
- en: Utilities and decorators
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实用程序和装饰器
- en: Classes for defining custom types
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于定义自定义类型的类
- en: Types
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型
- en: The initial implementations of the typing module included definitions of types
    corresponding to Python built-in containers and other types, as well as types
    from standard library modules. Many of these types have since been deprecated
    (see below), but some are still useful, since they do not correspond directly
    to any Python built-in type. [Table 5-1](#useful_definitions_in_the_typing_module)
    lists the typing types still useful in Python 3.9 and later.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: typing 模块最初的实现包括对应于 Python 内置容器和其他类型的类型定义，以及标准库模块中的类型。许多这些类型已被弃用（见下文），但某些仍然有用，因为它们不直接对应任何
    Python 内置类型。 [Table 5-1](#useful_definitions_in_the_typing_module) 列出了在 Python
    3.9 及更高版本中仍然有用的 typing 类型。
- en: Table 5-1\. Useful definitions in the typing module
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-1\. typing 模块中有用的定义
- en: '| Type | Description |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| Type | 描述 |'
- en: '| --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Any | Matches any type. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| Any | 匹配任何类型。 |'
- en: '| AnyStr | Equivalent to str &#124; bytes. AnyStr is meant to be used to annotate
    function arguments and return types where either string type is acceptable, but
    the types should not be mixed between multiple arguments, or arguments and return
    types. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| AnyStr | 等效于 str &#124; bytes。AnyStr 用于注释函数参数和返回类型，其中任一字符串类型都可以接受，但不应在多个参数之间混合使用，或者在参数和返回类型之间混合使用。
    |'
- en: '| BinaryIO | Matches streams with binary (bytes) content such as those returned
    from open with mode=''b'', or io.BytesIO. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| BinaryIO | 匹配具有二进制（bytes）内容的流，例如使用 mode=''b'' 打开的流或 io.BytesIO。 |'
- en: '| Callable | Callable[[*argument_type*, ...], *return_type*] Defines the type
    signature for a callable object. Takes a list of types corresponding to the arguments
    to the callable, and a type for the return value of the function. If the callable
    takes no arguments, indicate this with an empty list, []. If the callable has
    no return value, use **None** for *return_type*. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| Callable | Callable[[*argument_type*, ...], *return_type*] 定义可调用对象的类型签名。接受与可调用对象的参数对应的类型列表，以及函数返回值的类型。如果可调用对象不接受任何参数，请使用空列表
    []。如果可调用对象没有返回值，请使用 **None** 作为 *return_type*。 |'
- en: '| IO | Equivalent to BinaryIO &#124; TextIO. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| IO | 等效于 BinaryIO &#124; TextIO。 |'
- en: '| Lit⁠e⁠r⁠a⁠l​[*⁠e⁠x⁠p⁠ression*,...] | 3.8+ Specifies a list of valid values
    that the variable may take. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| Lit⁠e⁠r⁠a⁠l​[*⁠e⁠x⁠p⁠ression*,...] | 3.8+ 指定变量可能采用的有效值列表。 |'
- en: '| LiteralString | 3.11+ Specifies a str that must be implemented as a literal
    quoted value. Used to guard against leaving code open to injection attacks. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| LiteralString | 3.11+ 指定必须实现为文字引号值的 str。用于防止代码易受到注入攻击。 |'
- en: '| NoReturn | Use as the return type for functions that “run forever,” such
    as those that call http.serve_forever or event_loop.run_forever without returning.
    This is *not* intended for functions that simply return with no explicit value;
    for those use -> **None**. More discussion of return types can be found in [“Adding
    Type Annotations to Existing Code (Gradual Typing)”](#adding_type_annotations_to_existing_cod).
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| NoReturn | 用作“永久运行”函数的返回类型，比如调用 http.serve_forever 或 event_loop.run_forever
    而没有返回值的情况。这不适用于简单返回无明确值的函数；对于这种情况，请使用 -> **None**。更多有关返回类型的讨论详见[“为现有代码添加类型注解（逐步类型化）”](#adding_type_annotations_to_existing_cod)。
    |'
- en: '| Self | 3.11+ Use as the return type for instance functions that **return**
    self (and in a few other cases, as exemplified in [PEP 673](https://oreil.ly/NMMaw)).
    |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| Self | 3.11+ 用作实例函数返回类型，**返回** self（以及其他少数情况，详见[PEP 673](https://oreil.ly/NMMaw)）。
    |'
- en: '| TextIO | Matches streams with text (str) content, such as those returned
    from open with mode=''t'', or io.StringIO. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| TextIO | 匹配文本流（str 类型内容），比如使用 mode=''t'' 打开的文件或者 io.StringIO 返回的对象。 |'
- en: '-3.9 Prior to 3.9, the definitions in the typing module were used to create
    types representing built-in types, such as List[int] for a list of ints. From
    3.9 onward, these names are deprecated, as their corresponding built-in or standard
    library types now support the [] syntax: a list of ints is now simply typed using
    list[int]. [Table 5-2](#python_built_in_types_and_their_pre_thr) lists the definitions
    from the typing module that were necessary prior to Python 3.9 for type annotations
    using built-in types.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: -3.9 在 Python 3.9 之前，typing 模块的定义用于创建表示内置类型的类型，例如 List[int] 表示整数列表。从 Python
    3.9 开始，这些名称已弃用，因为其对应的内置或标准库类型现在支持 [] 语法：整数列表现在简单地使用 list[int] 类型声明。[Table 5-2](#python_built_in_types_and_their_pre_thr)
    列出了在 Python 3.9 之前使用 typing 模块进行类型注解时必要的定义。
- en: Table 5-2\. Python built-in types and their pre-3.9 definitions in the typing
    module
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Table 5-2\. Python 内置类型及其在 typing 模块中 3.9 之前的定义
- en: '| Built-in type | Pre-3.9 typing module equivalent |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 内置类型 | Python 3.9 前的 typing 模块等效类型 |'
- en: '| --- | --- |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| dict | Dict |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| dict | Dict |'
- en: '| frozenset | FrozenSet |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| frozenset | FrozenSet |'
- en: '| list | List |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| list | List |'
- en: '| set | Set |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| set | Set |'
- en: '| str | Text |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| str | Text |'
- en: '| tuple | Tuple |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| tuple | Tuple |'
- en: '| type | Type |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| type | Type |'
- en: '| collections.ChainMap | ChainMap |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| collections.ChainMap | ChainMap |'
- en: '| collections.Counter | Counter |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| collections.Counter | Counter |'
- en: '| collections.defaultdict | DefaultDict |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| collections.defaultdict | DefaultDict |'
- en: '| collections.deque | Deque |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| collections.deque | Deque |'
- en: '| collections.OrderedDict | OrderedDict |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| collections.OrderedDict | OrderedDict |'
- en: '| re.Match | Match |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| re.Match | Match |'
- en: '| re.Pattern | Pattern |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| re.Pattern | Pattern |'
- en: Type Expression Parameters
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Type Expression Parameters
- en: Some types defined in the typing module modify other type expressions. The types
    listed in [Table 5-3](#type_expression_parameters) provide additional typing information
    or constraints for the modified types in *type_expression*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 typing 模块中定义的某些类型修改其他类型表达式。[Table 5-3](#type_expression_parameters) 列出的类型提供了关于
    *type_expression* 修改类型的额外类型信息或约束。
- en: Table 5-3\. Type expression parameters
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Table 5-3\. 类型表达式参数
- en: '| Parameter | Usage and description |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| Parameter | 用法和描述 |'
- en: '| --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Annotated | Annotated[*type_expression, expression, ...*] 3.9+ Extends the
    *type_expression* with additional metadata. The extra metadata values for function
    *fn* can be retrieved at runtime using get_type_hints(*fn*, include_extras=**True**).
    |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| Annotated | Annotated[*type_expression, expression, ...*] 3.9+ 用额外的元数据扩展
    *type_expression*。函数 *fn* 的额外元数据可以在运行时使用 get_type_hints(*fn*, include_extras=**True**)
    获取。 |'
- en: '| ClassVar | ClassVar[*type_expression*] Indicates that the variable is a class
    variable, and should not be assigned as an instance variable. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| ClassVar | ClassVar[*type_expression*] 表示变量是类变量，不应该作为实例变量赋值。 |'
- en: '| Final | Final[*type_expression*] 3.8+ Indicates that the variable should
    not be written to or overridden in a subclass. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| Final | Final[*type_expression*] 3.8+ 表示变量不应该在子类中写入或重写。 |'
- en: '| Optional | Optional[*type_expression*] Equivalent to *type_expression* &#124;
    **None**. Often used for named arguments with a default value of **None**. (Optional
    does not automatically define **None** as the default value, so you must still
    follow it with =**None** in a function signature.) 3.10+ With the availability
    of the &#124; operator for specifying alternative type attributes, there is a
    growing consensus to prefer *type_expression* &#124; **None** over using Optional[*type_expression*].
    |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| Optional | Optional[*type_expression*] Equivalent to *type_expression* &#124;
    **None**. Often used for named arguments with a default value of **None**. (Optional
    does not automatically define **None** as the default value, so you must still
    follow it with =**None** in a function signature.) 3.10+ With the availability
    of the &#124; operator for specifying alternative type attributes, there is a
    growing consensus to prefer *type_expression* &#124; **None** over using Optional[*type_expression*].
    |'
- en: Abstract Base Classes
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象基类
- en: Just as for built-in types, the initial implementations of the typing module
    included definitions of types corresponding to abstract base classes in the collections.abc
    module. Many of these types have since been deprecated (see below), but two definitions
    have been retained as aliases to ABCs in collections.abc (see [Table 5-4](#abstract_base_class_aliases)).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与内置类型类似，typing 模块的初始实现包括了与 collections.abc 模块中的抽象基类对应的类型定义。许多这些类型后来已被弃用（见下文），但两个定义已保留为
    collections.abc 中 ABCs 的别名（见 [表格 5-4](#abstract_base_class_aliases)）。
- en: Table 5-4\. Abstract base class aliases
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 5-4\. 抽象基类别名
- en: '| Type | Method subclasses must implement |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| Type | Method subclasses must implement |'
- en: '| --- | --- |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Hashable | __hash__ |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| Hashable | __hash__ |'
- en: '| Sized | __len__ |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| Sized | __len__ |'
- en: '-3.9 Prior to Python 3.9, the following definitions in the typing module represented
    abstract base classes defined in the collections.abc module, such as Sequence[int]
    for a sequence of ints. From 3.9 onward, these names in the typing module are
    deprecated, as their corresponding types in collections.abc now support the []
    syntax:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: -3.9 在 Python 3.9 之前，typing 模块中的以下定义表示在 collections.abc 模块中定义的抽象基类，例如 Sequence[int]
    用于整数序列。从 3.9 开始，typing 模块中这些名称已被弃用，因为它们在 collections.abc 中对应的类型现在支持 [] 语法：
- en: '| AbstractSet | Container | Mapping |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| AbstractSet | Container | Mapping |'
- en: '| AsyncContextManager | ContextManager | MappingView |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| AsyncContextManager | ContextManager | MappingView |'
- en: '| AsyncGenerator | Coroutine | MutableMapping |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| AsyncGenerator | Coroutine | MutableMapping |'
- en: '| AsyncIterable | Generator | MutableSequence |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| AsyncIterable | Generator | MutableSequence |'
- en: '| AsyncIterator | ItemsView | MutableSet |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| AsyncIterator | ItemsView | MutableSet |'
- en: '| Awaitable | Iterable | Reversible |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| Awaitable | Iterable | Reversible |'
- en: '| ByteString | Iterator | Sequence |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| ByteString | Iterator | Sequence |'
- en: '| Collection | KeysView | ValuesView |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| Collection | KeysView | ValuesView |'
- en: Protocols
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议
- en: 'The typing module defines several *protocols*, which are similar to what some
    other languages call “interfaces.” Protocols are abstract base classes intended
    to concisely express constraints on a type, ensuring it contains certain methods.
    Each protocol currently defined in the typing module relates to a single special
    method, and its name starts with Supports followed by the name of the method (however,
    other libraries, such as those defined in [typeshed](https://oreil.ly/adB9Z),
    need not follow the same constraints). Protocols can be used as minimal abstract
    classes to determine a class’s support for that protocol’s capabilities: all that
    a class needs to do to comply with a protocol is to implement the protocol’s special
    method(s).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: typing 模块定义了几个*协议*，类似于其他一些语言称为“接口”的概念。协议是抽象基类，旨在简洁表达对类型的约束，确保其包含某些方法。typing
    模块中当前定义的每个协议都与单个特殊方法相关，其名称以 Supports 开头，后跟方法名（然而，如 [typeshed](https://oreil.ly/adB9Z)
    中定义的其他库可能不遵循相同的约束）。协议可用作确定类对该协议功能支持的最小抽象类：要遵守协议，类所需做的就是实现协议的特殊方法。
- en: '[Table 5-5](#protocols_in_the_typing_module_and_thei) lists the protocols defined
    in the typing module.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 5-5](#protocols_in_the_typing_module_and_thei) 列出了 typing 模块中定义的协议。'
- en: Table 5-5\. Protocols in the typing module and their required methods
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 5-5\. typing 模块中的协议及其必需方法
- en: '| Protocol | Has method |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| Protocol | Has method |'
- en: '| --- | --- |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| SupportsAbs | __abs__ |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| SupportsAbs | __abs__ |'
- en: '| SupportsBytes | __bytes__ |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| SupportsBytes | __bytes__ |'
- en: '| SupportsComplex | __complex__ |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| SupportsComplex | __complex__ |'
- en: '| SupportsFloat | __float__ |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| SupportsFloat | __float__ |'
- en: '| SupportsIndex 3.8+ | __index__ |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| SupportsIndex 3.8+ | __index__ |'
- en: '| SupportsInt | __int__ |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| SupportsInt | __int__ |'
- en: '| SupportsRound | __round__ |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| SupportsRound | __round__ |'
- en: 'A class does not have to explicitly inherit from a protocol in order to satisfy
    issubclass(*cls*, *protocol_type*), or for its instances to satisfy isinstance(*obj*,
    *protocol_type*). The class simply has to implement the method(s) defined in the
    protocol. Imagine, for example, a class implementing Roman numerals:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 类不必显式从协议继承以满足issubclass（*cls*，*protocol_type*），或使其实例满足isinstance（*obj*，*protocol_type*）。类只需实现协议中定义的方法即可。例如，想象一个实现罗马数字的类：
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To create an instance of this class (to, say, represent a sequel in a movie
    title) and get its value, you could use the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建此类的实例（例如，表示电影标题中的续集）并获取其值，您可以使用以下代码：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: RomanNumeral satisfies issubclass, and isinstance checks with SupportsInt because
    it implements __int__, even though it does not inherit explicitly from the protocol
    class SupportsInt:^([4](ch05.xhtml#ch01fn75))
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: RomanNumeral满足issubclass，并且由于实现了__int__，与SupportsInt进行isinstance检查，即使它不是显式从协议类SupportsInt继承:^([4](ch05.xhtml#ch01fn75))
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Utilities and Decorators
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实用程序和装饰器
- en: '[Table 5-6](#commonly_used_functions_and_decorators) lists commonly used functions
    and decorators defined in the typing module; it’s followed by a few examples.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[Table 5-6](#commonly_used_functions_and_decorators) 列出了在typing模块中定义的常用函数和装饰器；接下来是一些示例。'
- en: Table 5-6\. Commonly used functions and decorators defined in the typing module
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 表5-6.定义在typing模块中的常用函数和装饰器
- en: '| Function/decorator | Usage and description |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| Function/decorator | 用法和描述 |'
- en: '| --- | --- |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| cast | cast(*type*, *var*) Signals to the static type checker that *var*
    should be considered as type *type*. Returns *var*; at runtime there is no change,
    conversion, or validation of *var*. See the example after the table. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| cast | cast（*type*，*var*）向静态类型检查器发出信号，*var*应被视为*type*类型。返回*var*；在运行时，*var*没有更改、转换或验证。请参见表后的示例。'
- en: '| final | @final 3.8+ Used to decorate a method in a class definition, to warn
    if the method is overridden in a subclass. Can also be used as a class decorator,
    to warn if the class itself is being subclassed. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| final | @final 3.8+ 用于装饰类定义中的方法，如果该方法在子类中被重写则发出警告。也可以用作类装饰器，用于警告是否正在对类本身进行子类化。'
- en: '| get_args | get_args(*custom_type*) Returns the arguments used to construct
    a custom type. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| get_args | get_args（*custom_type*）返回用于构造自定义类型的参数。'
- en: '| get_origin | get_origin(*custom_type*) 3.8+ Returns the base type used to
    construct a custom type. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| get_origin | get_origin（*custom_type*）3.8+ 返回用于构造自定义类型的基础类型。'
- en: '| get_type_hints | get_type_hints(*obj*) Returns results as if accessing *obj*.__annotations__.
    Can be called with optional globalns and localns namespace arguments to resolve
    forward type references given as strings, and/or with optional Boolean include_extras
    argument to include any nontyping annotations added using Annotations. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| get_type_hints | get_type_hints（*obj*）返回结果，就像访问*obj*.__annotations__一样。可以使用可选的globalns和localns命名空间参数调用，以解析作为字符串给出的前向类型引用，和/或使用包含Annotations的任何非类型注释的可选Boolean
    include_extras参数。'
- en: '| NewType | NewType(*type_name*, *type*) Defines a custom type derived from
    *type*. *type_name* is a string that should match the local variable to which
    the NewType is being assigned. Useful for distinguishing different uses for common
    types, such as a str used for an employee name versus a str used for a department
    name. See [“NewType”](#newtype) for more on this function. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| NewType | NewType（*type_name*，*type*）定义了从*type*派生的自定义类型。*type_name*是一个字符串，应与分配NewType的局部变量匹配。用于区分常见类型的不同用途，例如用于员工姓名的str与用于部门名称的str。有关此函数的更多信息，请参见[“NewType”](#newtype)。'
- en: '| no_type_check | @no_type_check Used to indicate that annotations are not
    intended to be used as type information. Can be applied to a class or function.
    |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| no_type_check | @no_type_check 用于指示注释不打算用作类型信息。可应用于类或函数。'
- en: '| no_type_che⁠c⁠k⁠_​d⁠e⁠c⁠orator | @no_type_check_decorator Used to add no_type_check
    behavior to another decorator. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| no_type_che⁠c⁠k⁠_​d⁠e⁠c⁠orator | @no_type_check_decorator 用于向另一个装饰器添加no_type_check行为。'
- en: '| overload | @overload Used to allow defining multiple methods with the same
    name but differing types in their signatures. See the example after the table.
    |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| overload | @overload 用于允许定义多个方法，名称相同但签名类型不同。请参见表后的示例。'
- en: '| r⁠u⁠n⁠t⁠i⁠m⁠e⁠_​c⁠h⁠e⁠c⁠k⁠a⁠b⁠l⁠e | @runtime_checkable 3.8+ Used to add isinstance
    and issubclass support for custom protocol classes. See [“Using Type Annotations
    at Runtime”](#using_type_annotations_at_runtime) for more on this decorator. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| r⁠u⁠n⁠t⁠i⁠m⁠e⁠_​c⁠h⁠e⁠c⁠k⁠a⁠b⁠l⁠e | @runtime_checkable 3.8+ 用于为自定义协议类添加 isinstance
    和 issubclass 支持。有关此装饰器的更多信息，请参见 [“Using Type Annotations at Runtime”](#using_type_annotations_at_runtime)
    。'
- en: '| TypeAlias | *name*: TypeAlias = *type_expression* 3.10+ Used to distinguish
    the definition of a type alias from a simple assignment. Most useful in cases
    where *type_expression* is a simple class name or a string value referring to
    a class that is not yet defined, which might look like an assignment. TypeAlias
    may only be used at module scope. A common use is to make it easier to consistently
    reuse a lengthy type expression, e.g.: Number: TypeAlias = int &#124; float &#124;
    Fraction. See [“TypeAlias”](#typealias) for more on this annotation. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| TypeAlias | *name*: TypeAlias = *type_expression* 3.10+ 用于区分类型别名的定义和简单赋值。在
    *type_expression* 是简单类名或字符串值引用尚未定义的类的情况下最有用，这可能看起来像是一个赋值。TypeAlias 只能在模块范围内使用。一个常见用法是使得一致重用冗长的类型表达式变得更容易，例如：Number:
    TypeAlias = int &#124; float &#124; Fraction。更多关于此注解的信息，请参见 [“TypeAlias”](#typealias)
    。'
- en: '| type_check_only | @type_check_only Used to indicate that the class or function
    is only used at type-checking time and is not available at runtime. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| type_check_only | @type_check_only 用于指示类或函数仅在类型检查时使用，而在运行时不可用。'
- en: '| TYPE_CHECKING | A special constant that static type checkers evaluate as
    **True** but that is set to **False** at runtime. Use this to skip imports of
    large, slow-to-import modules used solely to support type checking (so that the
    import is not needed at runtime). |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| TYPE_CHECKING | 一个特殊的常量，静态类型检查器将其评估为 **True**，但在运行时设置为 **False**。使用它可以跳过导入用于支持类型检查的大型、导入缓慢的模块（以便在运行时不需要该导入）。'
- en: '| TypeVar | TypeVar(*type_name*, **types*) Defines a type expression element
    for use in complex generic types using Generic. *type_name* is a string that should
    match the local variable to which the TypeVar is being assigned. If *types* are
    not given, then the associated Generic will accept any type. If *types* are given,
    then the Generic will only accept instances of any of the provided types or their
    subclasses. Also accepts the named Boolean arguments covariant and contravariant
    (both defaulting to False), and the argument bound. These are described in more
    detail in [“Generics and TypeVars”](#generics_and_typevars) and in the [typing
    module docs](https://oreil.ly/069u4). |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| TypeVar | TypeVar(*type_name*, **types*) 定义用于复杂泛型类型中的类型表达式元素，使用 Generic。*type_name*
    是一个字符串，应与分配给 TypeVar 的局部变量匹配。如果未提供 *types*，则相关的 Generic 将接受任何类型的实例。如果提供了 *types*，则
    Generic 将仅接受提供的类型或其子类的实例。还接受名为协变和逆变（默认为 False）的布尔参数，以及 bound 参数。关于这些参数的详细信息，请参见
    [“Generics and TypeVars”](#generics_and_typevars) 和 [typing 模块文档](https://oreil.ly/069u4)
    。'
- en: 'Use overload at type-checking time to flag named arguments that must be used
    in particular combinations. In this case, fn must be called with either a str
    key and int value pair, or with a single bool value:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型检查时使用 overload 来标记必须以特定组合使用的命名参数。在这种情况下，fn 必须以 str 键和 int 值对或单个布尔值调用：
- en: '[PRE15]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that the overload decorator is used purely for static type checking. To
    actually dispatch to different methods based on a parameter type at runtime, use
    functools.singledispatch.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，overload 装饰器仅用于静态类型检查。要根据参数类型在运行时实际分派到不同方法，请使用 functools.singledispatch。
- en: 'Use the cast function to force a type checker to treat a variable as being
    of a particular type, within the scope of the cast:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 cast 函数可以强制类型检查器在 cast 的作用域内将变量视为特定类型：
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Use cast with Caution
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谨慎使用 cast
- en: cast is a way of overriding any inferences or prior annotations that may be
    present at a particular place in your code. It may hide actual type errors in
    your code, rendering the type-checking pass incomplete or inaccurate. The func
    in the preceding example raises no mypy warnings itself, but fails at runtime
    if passed a list of mixed ints and strs.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: cast 是一种覆盖代码中特定位置可能存在的所有推断或先前注释的方法。它可能隐藏代码中的实际类型错误，导致类型检查通行不完整或不准确。在前面的示例中，func
    本身不会引发任何 mypy 警告，但如果传递了混合整数和字符串的列表，则在运行时会失败。
- en: Defining Custom Types
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义自定义类型
- en: Just as Python’s **class** syntax permits the creation of new runtime types
    and behavior, the typing module constructs discussed in this section enable the
    creation of specialized type expressions for advanced type checking.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如Python的**class**语法允许创建新的运行时类型和行为一样，本节讨论的typing模块构造使得能够创建用于高级类型检查的专门类型表达式。
- en: The typing module includes three classes from which your classes can inherit
    to get type definitions and other default features, listed in [Table 5-7](#base_classes_for_defining_custom_types).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: typing模块包括三个类，你可以继承这些类来获取类型定义和其他默认特性，详见[表 5-7](#base_classes_for_defining_custom_types)。
- en: Table 5-7\. Base classes for defining custom types
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-7\. 定义自定义类型的基类
- en: '| Generic | Generic[*type_var*, ...] Defines a type-checking abstract base
    class for a class whose methods reference one or more TypeVar-defined types. Generics
    are described in more detail in the following subsection. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| Generic | Generic[*type_var*, ...] 定义了一个类型检查抽象基类，用于类的方法引用一个或多个TypeVar定义的类型。泛型将在以下小节详述。
    |'
- en: '| NamedTuple | NamedTuple A typed implementation of collections.namedtuple.
    See [“NamedTuple”](#namedtuple) for further details and examples. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| NamedTuple | NamedTuple 是collections.namedtuple的有类型实现。详见[“NamedTuple”](#namedtuple)获取更多详情和示例。
    |'
- en: '| TypedDict | TypedDict 3.8+ Defines a type-checking dict that has specific
    keys and value types for each key. See [“TypedDict”](#typeddict) for details.
    |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| TypedDict | TypedDict 3.8+ 定义了一个类型检查字典，其具有每个键的特定键和值类型。详见[“TypedDict”](#typeddict)了解详情。
    |'
- en: Generics and TypeVars
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 泛型和TypeVar
- en: '*Generics* are types that define a template for classes that can adapt the
    type annotations of their method signatures based on one or more type parameters.
    For instance, dict is a generic that takes two type parameters: the type for the
    dictionary keys and the type for the dictionary values. Here is how dict might
    be used to define a dictionary that maps color names to RGB triples:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*泛型* 是定义类模板的类型，这些类可以根据一个或多个类型参数调整其方法签名的类型注释。例如，dict是一个泛型，接受两个类型参数：字典键的类型和字典值的类型。以下是如何使用dict来定义一个将颜色名称映射到RGB三元组的字典：'
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The variable color_lookup will support statements like:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 变量color_lookup将支持如下语句：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'However, the following statements generate mypy errors, due to a mismatched
    key or value type:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以下语句由于键或值类型不匹配而生成了mypy错误：
- en: '[PRE19]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Generic typing permits the definition of behavior in a class that is independent
    of the specific types of the objects that class works with. Generics are often
    used for defining container types, such as dict, list, set, etc. By defining a
    generic type, we avoid the necessity of exhaustively defining types for DictOfStrInt,
    DictOfIntEmployee, and so on. Instead, a generic dict is defined as dict[*KT*,
    *VT*], where *KT* and *VT* are placeholders for the dict’s key type and value
    type, and the specific types for any particular dict can be defined when the dict
    is instantiated.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型允许在一个类中定义与该类所处理对象的具体类型无关的行为。泛型通常用于定义容器类型，如dict、list、set等。通过定义泛型类型，我们避免了对DictOfStrInt、DictOfIntEmployee等详细定义类型的必要性。相反，泛型dict被定义为dict[*KT*,
    *VT*]，其中*KT*和*VT*是字典的键类型和值类型的占位符，并且可以在实例化字典时定义任何特定类型。
- en: 'As an example, let’s define a hypothetical generic class: an accumulator that
    can be updated with values, but which also supports an undo method. Since the
    accumulator is a generic container, we declare a TypeVar to represent the type
    of the contained objects:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，让我们定义一个假想的泛型类：一个累加器，可以更新值，但也支持撤销方法。由于累加器是一个泛型容器，我们声明一个TypeVar来表示所包含对象的类型：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The Accumulator class is defined as a subclass of Generic, with T as a type
    parameter. Here is the class declaration and its __init__ method, which creates
    a contained list, initially empty, of objects of type T:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 累加器类被定义为泛型的子类，其中T作为类型参数。以下是类声明及其__init__方法，它创建了一个包含对象类型T的初始为空的列表：
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To add the update and undo methods, we define arguments that reference the
    contained objects as being of type T:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加update和undo方法，我们定义引用类型T的参数，表示所包含的对象类型：
- en: '[PRE25]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Lastly, we add __len__ and __iter__ methods so that Accumulator instances can
    be iterated over:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加__len__和__iter__方法，以便可以对累加器实例进行迭代：
- en: '[PRE26]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now this class can be used to write code using Accumulator[int] to collect
    a number of int values:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以使用Accumulator[int]编写代码来收集多个整数值：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Because acc is an Accumulator containing ints, the following statements generate
    mypy error messages:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 acc 是包含 ints 的 Accumulator，所以下面的语句会生成 mypy 错误消息：
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Restricting TypeVar to specific types
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制 TypeVar 为特定类型
- en: Nowhere in our Accumulator class do we ever invoke methods directly on the contained
    T objects themselves. For this example, the T TypeVar is purely untyped, so type
    checkers like mypy cannot infer the presence of any attributes or methods of the
    T objects. If the generic needs to access attributes of the T objects it contains,
    then T should be defined using a modified form of TypeVar.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Accumulator 类中，我们从未直接调用所包含的 T 对象的方法。对于这个示例，T TypeVar 是纯粹无类型的，因此像 mypy 这样的类型检查器无法推断出
    T 对象的任何属性或方法的存在。如果泛型需要访问其包含的 T 对象的属性，则应使用 TypeVar 的修改形式来定义 T。
- en: 'Here are some examples of TypeVar definitions:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些 TypeVar 定义的示例：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: These forms of T allow a generic defined on T to use methods from these types
    in T’s TypeVar definition.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这些形式的 T 允许在 T 的 TypeVar 定义中使用这些类型的方法。
- en: NamedTuple
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NamedTuple
- en: 'The collections.namedtuple function simplifies the definition of class-like
    tuple types that support named access to the tuple elements. NamedTuple provides
    a typed version of this feature, using a class with attributes-style syntax similar
    to dataclasses (covered in [“Data Classes”](ch04.xhtml#data_classes)). Here’s
    a NamedTuple with four elements, with names, types, and optional default values:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: collections.namedtuple 函数简化了支持对元组元素进行命名访问的类似类的元组类型的定义。NamedTuple 提供了此功能的类型化版本，使用类似于数据类（在[“数据类”](ch04.xhtml#data_classes)中介绍）的属性样式语法的类。下面是一个具有四个元素的
    NamedTuple，带有名称、类型和可选默认值：
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'NamedTuple classes generate a default constructor, accepting positional or
    named arguments for each named field:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: NamedTuple 类生成一个默认的构造函数，接受每个命名字段的位置参数或命名参数：
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Attempting to create a tuple with too few elements raises a runtime error:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试创建元组时如果元素数量过少会引发运行时错误：
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: TypedDict
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TypedDict
- en: '3.8+ Python dict variables are often difficult to decipher in legacy codebases,
    because dicts are used in two ways: as collections of key/value pairs (such as
    a mapping from user ID to username), and records mapping known field names to
    values. It is usually easy to see that a function argument is to be passed as
    a dict, but the actual keys and value types are dependent on the code that may
    call that function. Beyond simply defining that a dict may be a mapping of str
    values to int values, as in dict[str, int], a TypedDict defines the expected keys
    and the types of each corresponding value. The following example defines a TypedDict
    version of the previous house listing type (note that TypedDict definitions do
    not accept default value definitions):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 3.8+ Python 字典变量在旧代码库中经常难以理解，因为字典有两种用法：作为键/值对的集合（例如，从用户 ID 到用户名的映射），以及将已知字段名映射到值的记录。通常很容易看出函数参数将作为字典传递，但实际的键和值类型取决于可能调用该函数的代码。除了简单地定义字典可以是一个
    str 到 int 值的映射，例如 dict[str, int]，TypedDict 还定义了预期的键和每个相应值的类型。以下示例定义了之前房屋列表类型的
    TypedDict 版本（注意，TypedDict 定义不接受默认值定义）：
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'TypedDict classes generate a default constructor, accepting named arguments
    for each defined key:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: TypedDict 类生成一个默认的构造函数，为每个定义的键接受命名参数：
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Unlike the NamedTuple example, listing2 will not raise a runtime error, simply
    creating a dict with just the given keys. However, mypy will flag listing2 as
    a type error with the message:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 与 NamedTuple 示例不同，listing2 不会引发运行时错误，只是创建一个具有给定键的字典。但是，mypy 将使用消息标记 listing2
    为类型错误：
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To indicate to the type checker that some keys may be omitted (but to still
    validate those that are given), add total=False to the class declaration:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要向类型检查器指示某些键可能被省略（但仍然验证给定的键），请将 total=False 添加到类声明中：
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '3.11+ Individual fields can also use the Required or NotRequired type annotations
    to explicitly mark them as required or optional:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 3.11+ 个别字段还可以使用 Required 或 NotRequired 类型注释显式地标记它们为必需或可选：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'TypedDict can be used to define a generic type, too:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: TypedDict 也可以用来定义泛型类型：
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Do Not Use the Legacy TypedDict(name, **fields) Format
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要使用传统的 TypedDict(name, **fields) 格式
- en: 'To support backporting to older versions of Python, the initial release of
    TypedDict also let you use a syntax similar to that for namedtuple, such as:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持向较旧版本的 Python 进行回溯，TypedDict 的初始版本也允许您使用类似于 namedtuple 的语法，例如：
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'or:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 或：
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: These forms are deprecated in Python 3.11, and are planned to be removed in
    Python 3.13.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这些形式在 Python 3.11 中已被弃用，并计划在 Python 3.13 中移除。
- en: 'Note that TypedDict does not actually define a new type. Classes created by
    inheriting from TypedDict actually serve as dict factories, such that instances
    created from them *are* dicts. Reusing the previous code snippet defining the
    Node class, we can see this using the type built-in function:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，TypedDict 实际上不定义新类型。通过从 TypedDict 继承创建的类实际上充当字典工厂，从而创建的实例 *是* 字典。通过重新使用定义
    Node 类的先前代码片段，我们可以看到这一点，使用 type 内置函数：
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: There is no special runtime conversion or initialization when using TypedDict;
    the benefits of TypedDict are those of static type checking and self documentation,
    which naturally accrue from using type annotations.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TypedDict 时没有特殊的运行时转换或初始化；TypedDict 的好处来自静态类型检查和自我文档化，这些自然地通过使用类型注解积累。
- en: TypeAlias
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TypeAlias
- en: '3.10+ Defining a simple type alias can be misinterpreted as assigning a class
    to a variable. For instance, here we define a type for record identifiers in a
    database:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 3.10+ 定义简单类型别名可能会被误解为将类分配给变量。例如，在这里我们为数据库中的记录标识符定义了一个类型：
- en: '[PRE45]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To clarify that this statement is intended to define a custom type name for
    the purposes of type checking, use TypeAlias:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清这个声明是为了定义用于类型检查的自定义类型名称，请使用 TypeAlias：
- en: '[PRE46]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'TypeAlias is also useful when defining an alias for a type that is not yet
    defined, and so referenced as a string value:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: TypeAlias 在定义尚未定义的类型并以字符串值引用时非常有用：
- en: '[PRE47]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: TypeAlias types may only be defined at module scope. Custom types defined using
    TypeAlias are interchangeable with the target type. Contrast TypeAlias (which
    does not create a new type, just gives a new name for an existing one) with NewType,
    covered in the following section, which does create a new type.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: TypeAlias 类型只能在模块范围内定义。使用 TypeAlias 定义的自定义类型与目标类型可互换。与后续章节中涵盖的 NewType 相对比（NewType
    不创建新类型，仅为现有类型提供新名称），TypeAlias 仅为现有类型提供新名称。
- en: NewType
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NewType
- en: NewType allows you to define application-specific subtypes, to avoid confusion
    that might result from using the same type for different variables. If your program
    uses str values for different types of data, for example, it is easy to accidentally
    interchange values. Suppose you have a program that models employees in departments.
    The following type declaration is not sufficiently descriptive—which is the key
    and which is the value?
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: NewType 允许您定义特定于应用程序的子类型，以避免使用相同类型为不同变量可能导致的混淆。例如，如果您的程序使用 str 值来表示不同类型的数据，很容易意外地交换值。假设您有一个模拟员工和部门的程序。以下类型声明不够描述清楚——哪一个是关键，哪一个是值？
- en: '[PRE48]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Defining types for employee and department IDs makes this declaration clearer:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为员工和部门 ID 定义类型使得声明更清晰：
- en: '[PRE49]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'These type definitions will also allow type checkers to flag this incorrect
    usage:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型定义也将允许类型检查器标记此不正确的使用：
- en: '[PRE50]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Running mypy reports these errors for the line employee_department_map[to_dept]
    = empid:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 mypy 时会报告这些错误，如下所示：employee_department_map[to_dept] = empid。
- en: '[PRE51]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Using NewType often requires you to use typing.cast too; for example, to create
    an EmpId, you need to cast a str to the EmpId type.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NewType 通常需要您也使用 typing.cast；例如，要创建一个 EmpId，您需要将一个 str 强制转换为 EmpId 类型。
- en: 'You can also use NewType to indicate the desired implementation type for an
    application-specific type. For instance, the basic US postal zip code is five
    numeric digits. It is common to see this implemented using int, which becomes
    problematic with zip codes that have a leading 0. To indicate that zip codes should
    be implemented using str, your code can define this type-checking type:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 NewType 指示应用程序特定类型的所需实现类型。例如，基本的美国邮政编码是五位数字。通常会看到这种实现使用 int，这在具有前导 0
    的邮政编码时会出现问题。为了指示邮政编码应使用 str 实现，您的代码可以定义此类型检查类型：
- en: '[PRE52]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Annotating variables and function arguments using ZipCode will help flag incorrect
    uses of int for zip code values.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ZipCode 注释变量和函数参数将有助于标记错误的 int 用于邮政编码值的使用。
- en: Using Type Annotations at Runtime
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时使用类型注解
- en: 'Function and class variable annotations can be introspected by accessing the
    function or class’s __annotations__ attribute (although a [better practice](https://oreil.ly/r-YsZ)
    is to instead call inspect.get_annotations()):'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和类变量的注释可以通过访问函数或类的 __annotations__ 属性进行内省（尽管更好的做法是调用 inspect.get_annotations()）：
- en: '[PRE53]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This feature is used by third-party packages such as pydantic and FastAPI to
    provide extra code generation and validation capabilities.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能被 pydantic 和 FastAPI 等第三方包使用，以提供额外的代码生成和验证功能。
- en: 3.8+ To define your own custom protocol class that supports runtime checking
    with issubclass and isinstance, define that class as a subclass of typing.Protocol,
    with empty method definitions for the required protocol methods, and decorate
    the class with @runtime_checkable (covered in [Table 5-6](#commonly_used_functions_and_decorators)).
    If you *don’t* decorate it with @runtime_checkable, you’re still defining a Protocol
    that’s quite usable for static type checking, but it won’t be runtime-checkable
    with issubclass and isinstance.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 3.8+ 要定义自己的自定义协议类，以支持运行时检查的子类和isinstance，请将该类定义为typing.Protocol的子类，并对所需的协议方法进行空方法定义，并使用@runtime_checkable（在[表5-6](#commonly_used_functions_and_decorators)中介绍）。如果*不*使用@runtime_checkable装饰它，您仍然定义了一个非常适用于静态类型检查的协议，但它不会使用issubclass和isinstance进行运行时检查。
- en: 'For example, we could define a protocol that indicates that a class implements
    the update and undo methods as follows (the Python Ellipsis, ..., is a convenient
    syntax for indicating an empty method definition):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以定义一个协议，指示一个类实现了更新和撤销方法，如下所示（Python中的省略号`...`是指示空方法定义的便捷语法）：
- en: '[PRE57]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Without making any changes to the inheritance path of Accumulator (defined
    in [“Generics and TypeVars”](#generics_and_typevars)), it now satisfies runtime
    type checks with SupportsUpdateUndo:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在不对Accumulator的继承路径进行任何更改（在[“泛型和TypeVars”](#generics_and_typevars)中定义）的情况下，它现在满足了对SupportsUpdateUndo的运行时类型检查：
- en: '[PRE58]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In addition, any other class that implements update and undo methods will now
    qualify as a SupportsUpdateUndo “subclass.”
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，现在任何其他实现了更新和撤销方法的类都将被视为`SupportsUpdateUndo`的“子类”。
- en: How to Add Type Annotations to Your Code
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何为您的代码添加类型注解
- en: Having seen some of the features and capabilities provided by using type annotations,
    you may be wondering about the best way to get started. This section describes
    a few scenarios and approaches to adding type annotations.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 看到了使用类型注解提供的一些特性和功能，您可能想知道最佳的入门方式。本节描述了添加类型注解的几种情景和方法。
- en: Adding Type Annotations to New Code
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向新代码添加类型注解
- en: 'When you start writing a short Python script, adding type annotations may seem
    like an unnecessary extra burden. As a spinoff of the [Two Pizza Rule](https://oreil.ly/SWLnG),
    we suggest the Two Function Rule: as soon as your script contains two functions
    or methods, go back and add type annotations to the method signatures, and any
    shared variables or types as necessary. Use TypedDict to annotate any dict structures
    that are used in place of classes, so that dict keys get clearly defined up front
    or get documented as you go; use NamedTuples (or dataclasses: some of this book’s
    authors *strongly* prefer the latter option) to define the specific attributes
    needed for those data “bundles.”'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始编写一个简短的Python脚本时，添加类型注解可能会显得多余。作为[“两个披萨规则”](https://oreil.ly/SWLnG)的一个衍生，我们建议使用“两个函数规则”：一旦您的脚本包含两个函数或方法，就回头添加方法签名的类型注解，以及必要时添加任何共享变量或类型。使用TypedDict来注释任何在类的位置使用的dict结构，以便在一开始就清晰地定义dict键或在进行过程中进行文档化；使用NamedTuples（或数据类：本书的一些作者*强烈*倾向于后者）来定义所需的特定属性，以用于这些数据“捆”。
- en: 'If you are beginning a major project with many modules and classes, then you
    should definitely use type annotations from the beginning. They can easily make
    you more productive, as they help avoid common naming and typing mistakes and
    ensure you get more fully supported autocompletion while working in your IDE.
    This is even more important on projects with multiple developers: having documented
    types helps tell everyone on the team the expectations for types and values to
    be used across the project. Capturing these types in the code itself makes them
    immediately accessible and visible during development, much more so than separate
    documentation or specifications.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您开始一个具有许多模块和类的重大项目，那么您一定应该从一开始就使用类型注解。它们可以让您更加高效，因为它们有助于避免常见的命名和类型错误，并确保您在IDE中获得更全面的支持自动完成。在具有多个开发人员的项目中，这一点尤为重要：在代码中记录类型有助于告诉团队中的每个人对类型和值的期望。将这些类型捕获在代码中使它们在开发过程中立即可访问和可见，比单独的文档或规范要更加方便。
- en: If you are developing a library to be shared across projects, then you should
    also use type annotations from the very start, most likely paralleling the function
    signatures in your API design. Having type annotations in a library will make
    life easier for your client developers, as all modern IDEs include type annotation
    plug-ins to support static type checking and function autocompletion and documentation.
    They will also help you when writing your unit tests, since you will benefit from
    the same rich IDE support.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在开发一个要在多个项目中共享的库，那么最好从一开始就使用类型注解，很可能与你API设计中的函数签名并行。在库中添加类型注解将会为客户开发者简化生活，因为所有现代IDE都包含类型注解插件来支持静态类型检查、函数自动完成和文档编写。它们在编写单元测试时也会帮助你，因为你将受益于相同的丰富IDE支持。
- en: For any of these projects, add a type-checking utility to your pre-commit hooks,
    so that you stay ahead of any type infractions that might creep into your new
    codebase. This way you can fix them as they occur, instead of waiting until you
    do a large commit and finding that you have made some fundamental typing errors
    in multiple places.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何这些项目，将类型检查实用程序添加到你的预提交挂钩中，这样你可以及时解决任何可能潜入你新代码库中的类型违规。这样一来，你可以在出现问题时修复它们，而不是等到做大的提交后才发现在多个地方都出现了基本的类型错误。
- en: Adding Type Annotations to Existing Code (Gradual Typing)
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 给现有代码添加类型注解（渐进式类型）
- en: Several companies that have run projects to apply type annotations to large
    existing codebases recommend an incremental approach, referred to as *gradual
    typing*. With gradual typing, you can work through your codebase in a stepwise
    manner, adding and validating type annotations a few classes or modules at a time.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 有几家公司已经运行了将类型注解应用于大型现有代码库的项目，推荐采用渐进式的方法，称为*渐进式类型*。通过渐进式类型，你可以逐步地按步骤处理你的代码库，逐步添加和验证类型注解到几个类或模块。
- en: Some utilities, like mypy, will let you add type annotations function by function.
    mypy, by default, skips functions without typed signatures, so you can methodically
    go through your codebase a few functions at a time. This incremental process allows
    you to focus your efforts on individual parts of the code, as opposed to adding
    type annotations everywhere and then trying to sort out an avalanche of type-checker
    errors.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 有些工具，比如mypy，会让你逐个函数地添加类型注解。默认情况下，mypy会跳过没有类型签名的函数，因此你可以逐步地逐个函数地处理你的代码库。这种增量的过程允许你将精力集中在代码的各个部分，而不是一次性地在所有地方添加类型注解，然后试图解决一堆类型检查器错误。
- en: 'Some recommended approaches are:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐的一些方法包括：
- en: Identify your most heavily used modules, and begin adding types to them, a method
    at a time. (These could be core application class modules, or widely shared utility
    modules.)
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定你使用最频繁的模块，并逐步添加类型，逐个方法地进行。（这些可能是核心应用程序类模块，或广泛共享的实用程序模块。）
- en: Annotate a few methods at a time, so that type-checking issues get raised and
    resolved gradually.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐个方法地添加注解，以便逐步引发并解决类型检查问题。
- en: Use pytype or pyre inference to generate initial *.pyi* stub files (discussed
    in the following section). Then, steadily migrate types from the *.pyi* files,
    either manually or using automation such as pytype’s merge_pyi utility.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用pytype或pyre推断生成初始的 *.pyi* 桩文件（在下一节中讨论）。然后，逐步从 *.pyi* 文件中迁移类型，可以手动进行，也可以使用像pytype的merge_pyi工具这样的自动化工具。
- en: Begin using type checkers in a lenient default mode, so that most code is skipped
    and you can focus attention on specific files. As work progresses, shift to a
    stricter mode so that remaining items are made more prominent, and files that
    have been annotated do not regress by taking on new nonannotated code.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用类型检查器的宽松默认模式，这样大部分代码会被跳过，你可以将注意力集中在特定的文件上。随着工作的进行，逐渐转向更严格的模式，以突出剩余的项目，并且已经注释的文件不会因为接受新的非注释代码而退步。
- en: Using .pyi Stub Files
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 .pyi 桩文件
- en: Sometimes you don’t have access to Python type annotations. For example, you
    might be using a library that does not have type annotations, or using a module
    whose functions are implemented in C.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能无法访问Python的类型注解。例如，你可能正在使用一个没有类型注解的库，或者使用一个其函数是用C实现的模块。
- en: In these cases, you can use separate *.pyi* stub files containing just the related
    type annotations. Several of the type checkers mentioned at the beginning of this
    chapter can generate these stub files. You can download stub files for popular
    Python libraries, as well as the Python standard library itself, from the [typeshed
    repository](https://oreil.ly/jKhNR). You can maintain stub files from the Python
    source, or, using merging utilities available in some of the type checkers, integrate
    them back into the original Python source.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，可以使用单独的*.pyi*存根文件，其中只包含相关的类型注解。本章开头提到的多个类型检查器可以生成这些存根文件。您可以从[typeshed存储库](https://oreil.ly/jKhNR)下载流行的Python库以及Python标准库本身的存根文件。您可以从Python源文件中维护存根文件，或者使用某些类型检查器中可用的合并工具将其集成回原始Python源代码中。
- en: Summary
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Python has steadily risen to prominence as a powerful language and programming
    ecosystem, supporting important enterprise applications. What was once a utility
    language for scripting and task automation has become a platform for significant
    and complex applications affecting millions of users, used in mission-critical
    and even extraterrestrial systems.^([5](ch05.xhtml#ch01fn76)) Adding type annotations
    is a significant step in developing and maintaining these systems.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Python作为一个强大的语言和编程生态系统已经稳步崛起，支持重要的企业应用程序。曾经作为脚本和任务自动化的实用语言，现在已经成为影响数百万用户的重要和复杂应用程序平台，用于关键任务甚至是地外系统。^([5](ch05.xhtml#ch01fn76-marker))
    添加类型注解是开发和维护这些系统的重要一步。
- en: The [online documentation](https://oreil.ly/Zg_NX) for type annotations provides
    up-to-date descriptions, examples, and [best practices](https://oreil.ly/xhq5g)
    as the syntax and practices for annotating types continue to evolve. The authors
    also recommend [*Fluent Python*, 2nd edition](http://oreilly.com/library/view/fluent-python-2nd/9781492056348),
    by Luciano Ramalho (O’Reilly), especially Chapters 8 and 15, which deal specifically
    with Python type annotations.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Python的[类型注解在线文档](https://oreil.ly/Zg_NX)提供了最新的描述、示例和[最佳实践](https://oreil.ly/xhq5g)，因为类型注解的语法和实践不断演变。作者还特别推荐了[*流畅的Python*第二版](http://oreilly.com/library/view/fluent-python-2nd/9781492056348)，作者是Luciano
    Ramalho（O'Reilly），尤其是第8章和第15章，这些章节专门讲解了Python类型注解。
- en: ^([1](ch05.xhtml#ch01fn72-marker)) Strong, extensive unit tests will also guard
    against many business logic problems that no amount of type checking would ever
    catch for you—so, type hints are not to be used *instead of* unit tests, but *in
    addition* to them.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch05.xhtml#ch01fn72-marker)) 强大而广泛的单元测试也将防范许多商业逻辑问题，这是任何类型检查都无法捕捉的—所以，类型提示不应该*代替*单元测试，而应该*与*单元测试一起使用。
- en: ^([2](ch05.xhtml#ch01fn73-marker)) The *syntax* for type annotation was introduced
    in Python 3.0, but only later were its *semantics* specified.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch05.xhtml#ch01fn73-marker)) 类型注解的*语法*在Python 3.0中引入，但其*语义*则是后来才明确指定的。
- en: ^([3](ch05.xhtml#ch01fn74-marker)) This approach was also compatible with Python
    2.7 code, still in widespread use at the time.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch05.xhtml#ch01fn74-marker)) 这种方法也兼容Python 2.7代码，当时广泛使用。
- en: ^([4](ch05.xhtml#ch01fn75-marker)) And SupportsInt uses the runtime_checkable
    decorator.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch05.xhtml#ch01fn75-marker)) 并且SupportsInt使用了runtime_checkable装饰器。
- en: ^([5](ch05.xhtml#ch01fn76-marker)) NASA’s Jet Propulsion Lab used Python for
    the Persistence Mars Rover and the Ingenuity Mars Helicopter; the team responsible
    for the discovery of gravitational waves used Python both to coordinate the instrumentation
    and to analyze the resulting hoard of data.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch05.xhtml#ch01fn76-marker)) NASA的喷气推进实验室使用Python开发了坚韧号火星车和毅力号火星直升机；负责发现引力波的团队既用Python协调仪器，也用Python分析了得到的大量数据。
