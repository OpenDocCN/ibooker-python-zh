- en: Chapter 6\. Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python uses *exceptions* to indicate errors and anomalies. When Python detects
    an error, it *raises* an exception—that is, Python signals the occurrence of an
    anomalous condition by passing an exception object to the exception propagation
    mechanism. Your code can explicitly raise an exception by executing a **raise**
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: '*Handling* an exception means catching the exception object from the propagation
    mechanism and taking actions as needed to deal with the anomalous situation. If
    a program does not handle an exception, the program terminates with an error message
    and traceback message. However, a program can handle exceptions and keep running,
    despite errors or other anomalies, by using the **try** statement with **except**
    clauses.'
  prefs: []
  type: TYPE_NORMAL
- en: Python also uses exceptions to indicate some situations that are not errors,
    and not even abnormal. For example, as covered in [“Iterators”](ch03.xhtml#iterators),
    calling the next built-in function on an iterator raises StopIteration when the
    iterator has no more items. This is not an error; it is not even an anomaly, since
    most iterators run out of items eventually. The optimal strategies for checking
    and handling errors and other special situations in Python are therefore different
    from those in other languages; we cover them in [“Error-Checking Strategies”](#error_checking_strategies).
  prefs: []
  type: TYPE_NORMAL
- en: This chapter shows how to use exceptions for errors and special situations.
    It also covers the logging module of the standard library, in [“Logging Errors”](#logging_errors),
    and the **assert** statement, in [“The assert Statement”](#the_assert_statement).
  prefs: []
  type: TYPE_NORMAL
- en: The try Statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **try** statement is Python’s core exception handling mechanism. It’s a
    compound statement with three kinds of optional clauses:'
  prefs: []
  type: TYPE_NORMAL
- en: It may have zero or more **except** clauses, defining how to handle particular
    classes of exceptions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it has **except** clauses, then it may also have, right afterwards, one **else**
    clause, executed only if the **try** suite raised no exceptions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whether or not it has **except** clauses, it may have a single **finally** clause,
    unconditionally executed, with the behavior covered in [“try/except/finally”](#trysolidusexceptsolidusfinally).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Python’s syntax requires the presence of at least one **except** clause or a
    **finally** clause, both of which might also be present in the same statement;
    **else** is only valid following one or more **except**s.
  prefs: []
  type: TYPE_NORMAL
- en: try/except
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s the syntax for the **try**/**except** form of the **try** statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This form of the **try** statement has one or more **except** clauses, as well
    as an optional **else** clause (and an optional **finally** clause, whose meaning
    does not depend on whether **except** and **else** clauses are present: we cover
    this in the following section).'
  prefs: []
  type: TYPE_NORMAL
- en: The body of each **except** clause is known as an *exception handler*. The code
    executes when the *expression* in the **except** clause matches an exception object
    propagating from the **try** clause. *expression* is a class or tuple of classes,
    in parentheses, and matches any instance of one of those classes or their subclasses.
    The optional *target* is an identifier that names a variable that Python binds
    to the exception object just before the exception handler executes. A handler
    can also obtain the current exception object by calling the exc_info function
    (3.11+ or the exception function) of the module sys (covered in [Table 9-3](ch09.xhtml#alignment_indicators)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the try/except form of the try statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When an exception is raised, execution of the **try** suite immediately ceases.
    If a **try** statement has several **except** clauses, the exception propagation
    mechanism checks the **except** clauses in order; the first **except** clause
    whose expression matches the exception object executes as the handler, and the
    exception propagation mechanism checks no further **except** clauses after that.
  prefs: []
  type: TYPE_NORMAL
- en: Specific Before General
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Place handlers for specific cases before handlers for more general cases: when
    you place a general case first, the more specific **except** clauses that follow
    never execute.'
  prefs: []
  type: TYPE_NORMAL
- en: The last **except** clause need not specify an expression. An **except** clause
    without any expression handles any exception that reaches it during propagation.
    Such unconditional handling is rare, but it does occur, often in “wrapper” functions
    that must perform some extra task before re-raising an exception (see [“The raise
    Statement”](#the_raise_statement)).
  prefs: []
  type: TYPE_NORMAL
- en: Avoid a “Bare Except” That Doesn’t Re-Raise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Beware of using a “bare” **except** (an **except** clause without an expression)
    unless you’re re-raising the exception in it: such sloppy style can make bugs
    very hard to find, since the bare **except** is overly broad and can easily mask
    coding errors and other kinds of bugs by allowing execution to continue after
    an unanticipated exception.'
  prefs: []
  type: TYPE_NORMAL
- en: 'New programmers who are “just trying to get things to work” may even write
    code like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is a dangerous practice, since it catches important process-exiting exceptions
    such as KeyboardInterrupt or SystemExit—a loop with such an exception handler
    can’t be exited with Ctrl-C, and possibly not even terminated with a system **kill**
    command. At the very least, such code should use **except** Exception:, which
    is still overly broad but at least does not catch the process-exiting exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exception propagation terminates when it finds a handler whose expression matches
    the exception object. When a **try** statement is nested (lexically in the source
    code, or dynamically within function calls) in the **try** clause of another **try**
    statement, a handler established by the inner **try** is reached first on propagation,
    so it handles the exception when it matches it. This may not be what you want.
    Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, it does not matter that the handler established by the clause
    **except** ZeroDivisionError: in the outer **try** clause is more specific than
    the catch-all **except**: in the inner **try** clause. The outer **try** does
    not enter into the picture: the exception doesn’t propagate out of the inner **try**.
    For more on exception propagation, see [“Exception Propagation”](#exception_propagation).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The optional **else** clause of **try**/**except** executes only when the **try**
    clause terminates normally. In other words, the **else** clause does not execute
    when an exception propagates from the **try** clause, or when the **try** clause
    exits with a **break**, **continue**, or **return** statement. Handlers established
    by **try**/**except** cover only the **try** clause, not the **else** clause.
    The **else** clause is useful to avoid accidentally handling unexpected exceptions.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: try/finally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s the syntax for the **try**/**finally** form of the **try** statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This form has one **finally** clause, and no else clause (unless it also has
    one or more **except** clauses, as covered in the following section).
  prefs: []
  type: TYPE_NORMAL
- en: The **finally** clause establishes what is known as a *cleanup handler*. This
    code always executes after the **try** clause terminates in any way. When an exception
    propagates from the **try** clause, the **try** clause terminates, the cleanup
    handler executes, and the exception keeps propagating. When no exception occurs,
    the cleanup handler executes anyway, regardless of whether the **try** clause
    reaches its end or exits by executing a **break**, **continue**, or **return**
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cleanup handlers established with **try**/**finally** offer a robust and explicit
    way to specify finalization code that must always execute, no matter what, to
    ensure consistency of program state and/or external entities (e.g., files, databases,
    network connections). Such assured finalization is nowadays usually best expressed
    via a *context manager* used in a **with** statement (see [“The with Statement
    and Context Managers”](#the_with_statement_and_context_managers)). Here is an
    example of the **try**/**finally** form of the **try** statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'and here is the corresponding, more concise and readable, example of using
    **with** for exactly the same purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Avoid break and return Statements in a finally Clause
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **finally** clause may contain one or more of the statements **continue**,
    3.8+ **break**, or **return**. However, such usage may make your program less
    clear: exception propagation stops when such a statement executes, and most programmers
    would not expect propagation to be stopped within a **finally** clause. This usage
    may confuse people who are reading your code, so we recommend you avoid it.'
  prefs: []
  type: TYPE_NORMAL
- en: try/except/finally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **try**/**except**/**finally** statement, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'is equivalent to the nested statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A **try** statement can have multiple **except** clauses, and optionally an
    **else** clause, before a terminating **finally** clause. In all variations, the
    effect is always as just shown—that is, it’s just like nesting a **try**/**except**
    statement, with all the **except** clauses and the **else** clause, if any, into
    a containing **try**/**finally** statement.
  prefs: []
  type: TYPE_NORMAL
- en: The raise Statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use the **raise** statement to raise an exception explicitly. **raise**
    is a simple statement with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Only an exception handler (or a function that a handler calls, directly or indirectly)
    can use **raise** without any expression. A plain **raise** statement re-raises
    the same exception object that the handler received. The handler terminates, and
    the exception propagation mechanism keeps going up the call stack, searching for
    other applicable handlers. Using **raise** without any expression is useful when
    a handler discovers that it is unable to handle an exception it receives, or can
    handle the exception only partially, so the exception should keep propagating
    to allow handlers up the call stack to perform their own handling and cleanup.
  prefs: []
  type: TYPE_NORMAL
- en: When *expression* is present, it must be an instance of a class inheriting from
    the built-in class BaseException, and Python raises that instance.
  prefs: []
  type: TYPE_NORMAL
- en: When **from** *exception* is included (which can only occur in an **except**
    block that receives *exception*), Python raises the received expression “nested”
    in the newly raised exception expression. [“Exceptions “wrapping” other exceptions
    or tracebacks”](#exceptions_quotation_markwrappingquotat) describes this in more
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a typical use of the **raise** statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#comarker1)'
  prefs: []
  type: TYPE_NORMAL
- en: Some people consider raising a standard exception here to be inappropriate,
    and would prefer to raise an instance of a custom exception, as covered later
    in this chapter; this book’s authors disagree with this opinion.
  prefs: []
  type: TYPE_NORMAL
- en: This cross_product example function returns a list of all pairs with one item
    from each of its sequence arguments, but first, it tests both arguments. If either
    argument is empty, the function raises ValueError rather than just returning an
    empty list as the list comprehension would normally do.
  prefs: []
  type: TYPE_NORMAL
- en: Check Only What You Need To
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is no need for cross_product to check whether seq1 and seq2 are iterable:
    if either isn’t, the list comprehension itself raises the appropriate exception,
    presumably a TypeError.'
  prefs: []
  type: TYPE_NORMAL
- en: Once an exception is raised, by Python itself or with an explicit **raise**
    statement in your code, it is up to the caller to either handle it (with a suitable
    **try**/**except** statement) or let it propagate further up the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t Use raise for Redundant Error Checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use the raise statement only to raise additional exceptions for cases that would
    normally be OK but that your specification defines to be errors. Do not use raise
    to duplicate the same error checking that Python already (implicitly) does on
    your behalf.
  prefs: []
  type: TYPE_NORMAL
- en: The with Statement and Context Managers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **with** statement is a compound statement with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The semantics of **with** are equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: where _manager and _normal_exit are arbitrary internal names that are not used
    elsewhere in the current scope. If you omit the optional **as** *varname* part
    of the **with** clause, Python still calls _manager.__enter__, but doesn’t bind
    the result to any name, and still calls _manager.__exit__ at block termination.
    The object returned by the *expression*, with methods __enter__ and __exit__,
    is known as a *context manager*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **with** statement is the Python embodiment of the well-known C++ idiom
    [“resource acquisition is initialization” (RAII)](https://oreil.ly/vROml): you
    need only write context manager classes—that is, classes with two special methods,
    __enter__ and __exit__. __enter__ must be callable without arguments. __exit__
    must be callable with three arguments: all **None** when the body completes without
    propagating exceptions, and otherwise, the type, value, and traceback of the exception.
    This provides the same guaranteed finalization behavior as typical ctor/dtor pairs
    have for auto variables in C++ and **try**/**finally** statements have in Python
    or Java. In addition, they can finalize differently depending on what exception,
    if any, propagates, and optionally block a propagating exception by returning
    a true value from __exit__.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is a simple, purely illustrative way to ensure <name> and
    </name> tags are printed around some other output (note that context manager classes
    often have lowercase names, rather than following the normal title case convention
    for class names):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: A simpler way to build context managers is to use the contextmanager decorator
    in the contextlib module of the Python standard library. This decorator turns
    a generator function into a factory of context manager objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The contextlib way to implement the enclosing_tag context manager, having imported
    contextlib earlier, is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: contextlib supplies, among others, the class and functions listed in [Table 6-1](#commonly_used_classes_and_functions_in).
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-1\. Commonly used classes and functions in the contextlib module
  prefs: []
  type: TYPE_NORMAL
- en: '| AbstractContextManager | AbstractContextManager An abstract base class with
    two overridable methods: __enter__, which defaults to **return** self, and __exit__,
    which defaults to **return** None. |'
  prefs: []
  type: TYPE_TB
- en: '| chdir | chdir(*dir_path*) 3.11+ A context manager whose __enter__ method
    saves the current working directory path and performs os.chdir(*dir_path*), and
    whose __exit__ method performs os.chdir(*saved_path*). |'
  prefs: []
  type: TYPE_TB
- en: '| closing | closing(*something*) A context manager whose __enter__ method is
    **return** *something*, and whose __exit__ method calls *something*.close(). |'
  prefs: []
  type: TYPE_TB
- en: '| contextmanager | contextmanager A decorator that you apply to a generator
    to make it into a context manager. |'
  prefs: []
  type: TYPE_TB
- en: '| nullcontext | nullcontext(*something*) A context manager whose __enter__
    method is **return** *something*, and whose __exit__ method does nothing. |'
  prefs: []
  type: TYPE_TB
- en: '| redirect_stderr | redirect_stderr(*destination*) A context manager that temporarily
    redirects, within the body of the **with** statement, sys.stderr to the file or
    file-like object *destination*. |'
  prefs: []
  type: TYPE_TB
- en: '| redirect_stdout | redirect_stdout(*destination*) A context manager that temporarily
    redirects, within the body of the **with** statement, sys.stdout to the file or
    file-like object *destination*. |'
  prefs: []
  type: TYPE_TB
- en: '| suppress | suppress(**exception_classes*) A context manager that silently
    suppresses exceptions occurring in the body of the **with** statement of any of
    the classes listed in *exception_classes*. For instance, this function to delete
    a file ignores FileNotFoundError:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Use sparingly, since silently suppressing exceptions is often bad practice.
    |
  prefs: []
  type: TYPE_NORMAL
- en: For more details, examples, “recipes,” and even more (somewhat abstruse) classes,
    see Python’s [online docs](https://oreil.ly/Jwr_w).
  prefs: []
  type: TYPE_NORMAL
- en: Generators and Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To help generators cooperate with exceptions, **yield** statements are allowed
    inside **try**/**finally** statements. Moreover, generator objects have two other
    relevant methods, throw and close. Given a generator object *g* built by calling
    a generator function, the throw method’s signature is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When the generator’s caller calls *g*.throw, the effect is just as if a **raise**
    statement with the same argument executed at the spot of the **yield** at which
    generator *g* is suspended.
  prefs: []
  type: TYPE_NORMAL
- en: The generator method close has no arguments; when the generator’s caller calls
    *g*.close(), the effect is like calling *g*.throw(GeneratorExit()).^([1](ch06.xhtml#ch01fn78))
    GeneratorExit is a built-in exception class that inherits directly from BaseException.
    Generators also have a finalizer (the special method __del__) that implicitly
    calls close when the generator object is garbage-collected.
  prefs: []
  type: TYPE_NORMAL
- en: If a generator raises or propagates a StopIteration exception, Python turns
    the exception’s type into RuntimeError.
  prefs: []
  type: TYPE_NORMAL
- en: Exception Propagation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an exception is raised, the exception propagation mechanism takes control.
    The normal control flow of the program stops, and Python looks for a suitable
    exception handler. Python’s **try** statement establishes exception handlers via
    its **except** clauses. The handlers deal with exceptions raised in the body of
    the **try** clause, as well as exceptions propagating from functions called by
    that code, directly or indirectly. If an exception is raised within a **try**
    clause that has an applicable **except** handler, the **try** clause terminates
    and the handler executes. When the handler finishes, execution continues with
    the statement after the **try** statement (in the absence of any explicit change
    to the flow of control, such as a **raise** or **return** statement).
  prefs: []
  type: TYPE_NORMAL
- en: If the statement raising the exception is not within a **try** clause that has
    an applicable handler, the function containing the statement terminates, and the
    exception propagates “upward” along the stack of function calls to the statement
    that called the function. If the call to the terminated function is within a **try**
    clause that has an applicable handler, that **try** clause terminates, and the
    handler executes. Otherwise, the function containing the call terminates, and
    the propagation process repeats, *unwinding* the stack of function calls until
    an applicable handler is found.
  prefs: []
  type: TYPE_NORMAL
- en: If Python cannot find any applicable handler, by default the program prints
    an error message to the standard error stream (sys.stderr). The error message
    includes a traceback that gives details about functions terminated during propagation.
    You can change Python’s default error-reporting behavior by setting sys.excepthook
    (covered in [Table 8-3](ch08.xhtml#functions_and_attributes_of_the_sys_mod)).
    After error reporting, Python goes back to the interactive session, if any, or
    terminates if execution was not interactive. When the exception type is SystemExit,
    termination is silent and ends the interactive session, if any.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some functions to show exception propagation at work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling the h function prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: That is, none of the “after” print statements execute, since the flow of exception
    propagation cuts them off.
  prefs: []
  type: TYPE_NORMAL
- en: The function h establishes a **try** statement and calls the function g within
    the **try** clause. g, in turn, calls f, which performs a division by 0, raising
    an exception of type ZeroDivisionError. The exception propagates all the way back
    to the **except** clause in h. The functions f and g terminate during the exception
    propagation phase, which is why neither of their “after” messages is printed.
    The execution of h’s **try** clause also terminates during the exception propagation
    phase, so its “after” message isn’t printed either. Execution continues after
    the handler, at the end of h’s **try**/**except** block.
  prefs: []
  type: TYPE_NORMAL
- en: Exception Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exceptions are instances of BaseException (more specifically, instances of one
    of its subclasses). [Table 6-2](#attributes_and_methods_of_the_baseexcep) lists
    the attributes and methods of BaseException.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-2\. Attributes and methods of the BaseException class
  prefs: []
  type: TYPE_NORMAL
- en: '| __cause__ | *exc*.__cause__ Returns the parent exception of an exception
    raised using **raise** **from**. |'
  prefs: []
  type: TYPE_TB
- en: '| __notes__ | *exc*.__notes__ 3.11+ Returns a list of strs added to the exception
    using add_note. This attribute only exists if add_note has been called at least
    once, so the safe way to access this list is with getattr(*exc*, ''__notes__'',
    []). |'
  prefs: []
  type: TYPE_TB
- en: '| add_note | *exc*.add_note(*note*) 3.11+ Appends the str *note* to the notes
    on this exception. These notes are shown after the traceback when displaying the
    exception. |'
  prefs: []
  type: TYPE_TB
- en: '| args | *exc.*args Returns a tuple of the arguments used to construct the
    exception. This error-specific information is useful for diagnostic or recovery
    purposes. Some exception classes interpret args and set convenient named attributes
    on the classes’ instances. |'
  prefs: []
  type: TYPE_TB
- en: '| wi⁠t⁠h⁠_​t⁠r⁠a⁠ceback | *exc*.with_traceback(*tb*) Returns a new exception,
    replacing the original exception’s traceback with the new traceback *tb*, or with
    no traceback if *tb* is **None**. Can be used to trim the original traceback to
    remove internal library function call frames. |'
  prefs: []
  type: TYPE_TB
- en: The Hierarchy of Standard Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned previously, exceptions are instances of subclasses of BaseException.
    The inheritance structure of exception classes is important, as it determines
    which **except** clauses handle which exceptions. Most exception classes extend
    the class Exception; however, the classes KeyboardInterrupt, GeneratorExit, and
    SystemExit inherit directly from BaseException and are not subclasses of Exception.
    Thus, a handler clause **except** Exception **as** e does not catch KeyboardInterrupt,
    GeneratorExit, or SystemExit (we covered exception handlers in [“try/except”](#trysolidusexcept)
    and GeneratorExit in [“Generators and Exceptions”](#generators_and_exceptions)).
    Instances of SystemExit are normally raised via the exit function in the sys module
    (covered in [Table 8-3](ch08.xhtml#functions_and_attributes_of_the_sys_mod)).
    When the user hits Ctrl-C, Ctrl-Break, or other interrupting keys on their keyboard,
    that raises KeyboardInterrupt.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hierarchy of built-in exception classes is, roughly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: There are other exception subclasses (in particular, Warning and OSError have
    many, whose omission is indicated here with ellipses), but this is the gist. A
    complete list is available in Python’s [online docs](https://oreil.ly/pLihr).
  prefs: []
  type: TYPE_NORMAL
- en: The classes marked “(abstract)” are never instantiated directly; their purpose
    is to make it easier for you to specify **except** clauses that handle a range
    of related errors.
  prefs: []
  type: TYPE_NORMAL
- en: Standard Exception Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 6-3](#standard_exception_classes) lists exception classes raised by
    common runtime errors.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-3\. Standard exception classes
  prefs: []
  type: TYPE_NORMAL
- en: '| Exception class | Raised when |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| AssertionError | An **assert** statement failed. |'
  prefs: []
  type: TYPE_TB
- en: '| AttributeError | An attribute reference or assignment failed. |'
  prefs: []
  type: TYPE_TB
- en: '| ImportError | An **import** or **from**...**import** statement (covered in
    [“The import Statement”](ch07.xhtml#the_import_statement)) couldn’t find the module
    to import (in this case, what Python raises is actually an instance of ImportError’s
    subclass ModuleNotFoundError), or couldn’t find a name to be imported from the
    module. |'
  prefs: []
  type: TYPE_TB
- en: '| IndentationError | The parser encountered a syntax error due to incorrect
    indentation. Subclasses SyntaxError. |'
  prefs: []
  type: TYPE_TB
- en: '| IndexError | An integer used to index a sequence is out of range (using a
    noninteger as a sequence index raises TypeError). Subclasses LookupError. |'
  prefs: []
  type: TYPE_TB
- en: '| KeyboardInterrupt | The user pressed the interrupt key combination (Ctrl-C,
    Ctrl-Break, Delete, or others, depending on the platform’s handling of the keyboard).
    |'
  prefs: []
  type: TYPE_TB
- en: '| KeyError | A key used to index a mapping is not in the mapping. Subclasses
    LookupError. |'
  prefs: []
  type: TYPE_TB
- en: '| MemoryError | An operation ran out of memory. |'
  prefs: []
  type: TYPE_TB
- en: '| NameError | A name was referenced, but it was not bound to any variable in
    the current scope. |'
  prefs: []
  type: TYPE_TB
- en: '| N⁠o⁠t⁠I⁠m⁠p⁠l⁠e⁠m⁠e⁠n⁠t⁠e⁠d​E⁠r⁠r⁠o⁠r | Raised by abstract base classes to
    indicate that a concrete subclass must override a method. |'
  prefs: []
  type: TYPE_TB
- en: '| OSError | Raised by functions in the module os (covered in [“The os Module”](ch11.xhtml#the_os_module)
    and [“Running Other Programs with the os Module”](ch15.xhtml#running_other_programs_with_the_os_modu))
    to indicate platform-dependent errors. OSError has many subclasses, covered in
    the following subsection. |'
  prefs: []
  type: TYPE_TB
- en: '| RecursionError | Python detected that the recursion depth has been exceeded.
    Subclasses RuntimeError. |'
  prefs: []
  type: TYPE_TB
- en: '| RuntimeError | Raised for any error or anomaly not otherwise classified.
    |'
  prefs: []
  type: TYPE_TB
- en: '| SyntaxError | Python’s parser encountered a syntax error. |'
  prefs: []
  type: TYPE_TB
- en: '| SystemError | Python has detected an error in its own code, or in an extension
    module. Please report this to the maintainers of your Python version, or of the
    extension in question, including the error message, the exact Python version (sys.version),
    and, if possible, your program’s source code. |'
  prefs: []
  type: TYPE_TB
- en: '| TypeError | An operation or function was applied to an object of an inappropriate
    type. |'
  prefs: []
  type: TYPE_TB
- en: '| UnboundLocalError | A reference was made to a local variable, but no value
    is currently bound to that local variable. Subclasses NameError. |'
  prefs: []
  type: TYPE_TB
- en: '| UnicodeError | An error occurred while converting Unicode (i.e., a str) to
    a byte string, or vice versa. Subclasses ValueError. |'
  prefs: []
  type: TYPE_TB
- en: '| ValueError | An operation or function was applied to an object that has a
    correct type but an inappropriate value, and nothing more specific (e.g., KeyError)
    applies. |'
  prefs: []
  type: TYPE_TB
- en: '| ZeroDivisionError | A divisor (the righthand operand of a /, //, or % operator,
    or the second argument to the built-in function divmod) is 0. Subclasses ArithmeticError.
    |'
  prefs: []
  type: TYPE_TB
- en: OSError subclasses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OSError represents errors detected by the operating system. To handle such errors
    more elegantly, OSError has many subclasses, whose instances are what actually
    get raised; for a complete list, see Python’s [online docs](https://oreil.ly/3vJ3W).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider this task: try to read and return the contents of a certain
    file, return a default string if the file does not exist, and propagate any other
    exception that makes the file unreadable (except for the file not existing). Using
    an existing OSError subclass, you can accomplish the task quite simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The FileNotFoundError subclass of OSError makes this kind of common task simple
    and direct to express in code.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions “wrapping” other exceptions or tracebacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, you cause an exception while trying to handle another. To let you
    clearly diagnose this issue, each exception instance holds its own traceback object;
    you can make another exception instance with a different traceback with the with_traceback
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, Python automatically stores which exception it’s handling as the
    __context__ attribute of any further exception raised during the handling (unless
    you set the exception’s __suppress_context__ attribute to **True** with the **raise**...**from**
    statement, which we cover shortly). If the new exception propagates, Python’s
    error message uses that exception’s __context__ attribute to show details of the
    problem. For example, take the (deliberately!) broken code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The error displayed is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Thus, Python clearly displays both exceptions, the original and the intervening
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get more control over the error display, you can, if you wish, use the **raise**...**from**
    statement. When you execute **raise** *e* **from** *ex*, both *e* and *ex* are
    exception objects: *e* is the one that propagates, and *ex* is its “cause.” Python
    records *ex* as the value of *e.__cause__*, and sets *e.*__suppress_context__
    to true. (Alternatively, *ex* can be **None**: then, Python sets *e.__cause__*
    to **None**, but still sets *e.*__suppress_context__ to true, and thus leaves
    *e.*__context__ alone).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As another example, here’s a class implementing a mock filesystem directory
    using a Python dict, with the filenames as the keys and the file contents as the
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When read_file is called with a nonexistent filename, the access to the self._files
    dict raises KeyError. Since this code is intended to emulate a filesystem directory,
    read_file catches the KeyError and raises FileNotFoundError instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'As is, accessing a nonexistent file named ''data.txt'' will output an exception
    message similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This exception report shows both the KeyError and the FileNotFoundError. To
    suppress the internal KeyError exception (to hide implementation details of FileSystemDirectory),
    we change the **raise** statement in read_file to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the exception only shows the FileNotFoundError information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: For details and motivations regarding exception chaining and embedding, see
    [PEP 3134](https://oreil.ly/wE9rL).
  prefs: []
  type: TYPE_NORMAL
- en: Custom Exception Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can extend any of the standard exception classes in order to define your
    own exception class. Often, such a subclass adds nothing more than a docstring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: An Empty Class or Function Should Have a Docstring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As covered in [“The pass Statement”](ch03.xhtml#the_pass_statement), you don’t
    need a pass statement to make up the body of a class. The docstring (which you
    should always write, to document the class’s purpose if nothing else!) is enough
    to keep Python happy. Best practice for all “empty” classes (regardless of whether
    they are exception classes), just like for all “empty” functions, is usually to
    have a docstring and no **pass** statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the semantics of **try**/**except**, raising an instance of a custom
    exception class such as InvalidAttributeError is almost the same as raising an
    instance of its standard exception superclass, AttributeError, but with some advantages.
    Any **except** clause that can handle AttributeError can handle InvalidAttributeError
    just as well. In addition, client code that knows about your InvalidAttributeError
    custom exception class can handle it specifically, without having to handle all
    other cases of AttributeError when it is not prepared for those. For example,
    suppose you write code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, client code can, if it so chooses, be more selective in its handlers.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Use Custom Exception Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s an excellent idea to define, and raise, instances of custom exception classes
    in your modules, rather than plain standard exceptions. By using custom exception
    classes that extend standard ones, you make it easier for callers of your module’s
    code to handle exceptions that come from your module separately from others, if
    they choose to.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Exceptions and Multiple Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An effective approach to the use of custom exceptions is to multiply inherit
    exception classes from your module’s special custom exception class and a standard
    exception class, as in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, an instance of CustomAttributeError can only be raised explicitly and deliberately,
    showing an error related specifically to your code that *also* happens to be an
    AttributeError. When your code raises an instance of CustomAttributeError, that
    exception can be caught by calling code that’s designed to catch all cases of
    AttributeError as well as by code that’s designed to catch all exceptions raised
    only, specifically, by your module.
  prefs: []
  type: TYPE_NORMAL
- en: Use Multiple Inheritance for Custom Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever you must decide whether to raise an instance of a specific standard
    exception, such as AttributeError, or of a custom exception class you define in
    your module, consider this multiple inheritance approach, which, in this book’s
    authors’ opinion,^([2](ch06.xhtml#ch01fn79)) gives you the best of both worlds
    in such cases. Make sure you clearly document this aspect of your module, because
    the technique, although handy, is not widely used. Users of your module may not
    expect it unless you clearly and explicitly document what you are doing.
  prefs: []
  type: TYPE_NORMAL
- en: Other Exceptions Used in the Standard Library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many modules in Python’s standard library define their own exception classes,
    which are equivalent to the custom exception classes that your own modules can
    define. Typically, all functions in such standard library modules may raise exceptions
    of such classes, in addition to exceptions in the standard hierarchy covered in
    [“Standard Exception Classes”](#standard_exception_classe). We cover the main
    cases of such exception classes throughout the rest of this book, in chapters
    covering the standard library modules that supply and may raise them.
  prefs: []
  type: TYPE_NORMAL
- en: ExceptionGroup and except*
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3.11+ In some circumstances, such as when performing validation of some input
    data against multiple criteria, it is useful to be able to raise more than a single
    exception at once. Python 3.11 introduced a mechanism to raise multiple exceptions
    at once using an ExceptionGroup instance and to process more than one exception
    using an **except*** form in place of **except**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To raise ExceptionGroup, the validating code captures multiple Exceptions into
    a list and then raises an ExceptionGroup that is constructed using that list.
    Here is some code that searches for misspelled and invalid words, and raises an
    ExceptionGroup containing all of the found errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code validates a sample text string and lists out all the found
    errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'giving this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Unlike **except**, after it finds an initial match, **except*** continues to
    look for additional exception handlers matching exception types in the raised
    ExceptionGroup.
  prefs: []
  type: TYPE_NORMAL
- en: Error-Checking Strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most programming languages that support exceptions raise exceptions only in
    rare cases. Python’s emphasis is different. Python deems exceptions appropriate
    whenever they make a program simpler and more robust, even if that makes exceptions
    rather frequent.
  prefs: []
  type: TYPE_NORMAL
- en: LBYL Versus EAFP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common idiom in other languages, sometimes known as “look before you leap”
    (LBYL), is to check in advance, before attempting an operation, for anything that
    might make the operation invalid. This approach is not ideal, for several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The checks may diminish the readability and clarity of the common, mainstream
    cases where everything is OK.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The work needed for checking purposes may duplicate a substantial part of the
    work done in the operation itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The programmer might easily err by omitting a needed check.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The situation might change between the moment when you perform the checks and
    the moment when, later (even by a tiny fraction of a second!), you attempt the
    operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preferred idiom in Python is to attempt the operation in a **try** clause
    and handle the exceptions that may result in one or more **except** clauses. This
    idiom is known as [“It’s easier to ask forgiveness than permission” (EAFP)](https://oreil.ly/rGXC9),
    a frequently quoted motto widely credited to Rear Admiral Grace Murray Hopper,
    co-inventor of COBOL. EAFP shares none of the defects of LBYL. Here is a function
    using the LBYL idiom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: With LBYL, the checks come first, and the mainstream case is somewhat hidden
    at the end of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the equivalent function using the EAFP idiom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: With EAFP, the mainstream case is up front in a **try** clause, and the anomalies
    are handled in the following **except** clause, making the whole function easier
    to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'EAFP is a good error-handling strategy, but it is not a panacea. In particular,
    you must take care not to cast too wide a net, catching errors that you did not
    expect and therefore did not mean to catch. The following is a typical case of
    such a risk (we cover built-in function getattr in [Table 8-2](ch08.xhtml#pythonapostrophes_core_built_in_functio)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The intention of the trycalling function is to try calling a method named *attrib*
    on the object *obj*, but to return *default* if *obj* has no method thus named.
    However, the function as coded does not do *just* that: it also accidentally hides
    any error case where an AttributeError is raised inside the sought-after method,
    silently returning *default* in those cases. This could easily hide bugs in other
    code. To do exactly what’s intended, the function must take a little bit more
    care:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This implementation of trycalling separates the getattr call, placed in the
    **try** clause and therefore guarded by the handler in the **except** clause,
    from the call of the method, placed in the **else** clause and therefore free
    to propagate any exception. The proper approach to EAFP involves frequent use
    of the **else** clause in **try**/**except** statements (which is more explicit,
    and thus better Python style, than just placing the nonguarded code after the
    whole **try**/**except** statement).
  prefs: []
  type: TYPE_NORMAL
- en: Handling Errors in Large Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In large programs, it is especially easy to err by making your **try**/**except**
    statements too broad, particularly once you have convinced yourself of the power
    of EAFP as a general error-checking strategy. A **try**/**except** combination
    is too broad when it catches too many different errors, or an error that can occur
    in too many different places. The latter is a problem when you need to distinguish
    exactly what went wrong and where, and the information in the traceback is not
    sufficient to pinpoint such details (or you discard some or all of the information
    in the traceback). For effective error handling, you have to keep a clear distinction
    between errors and anomalies that you expect (and thus know how to handle) and
    unexpected errors and anomalies that may indicate a bug in your program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some errors and anomalies are not really erroneous, and perhaps not even all
    that anomalous: they are just special “edge” cases, perhaps somewhat rare but
    nevertheless quite expected, which you choose to handle via EAFP rather than via
    LBYL to avoid LBYL’s many intrinsic defects. In such cases, you should just handle
    the anomaly, often without even logging or reporting it.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep Your try/except Constructs Narrow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Be very careful to keep **try**/**except** constructs as narrow as feasible.
    Use a small **try** clause that contains a small amount of code that doesn’t call
    too many other functions, and use very specific exception class tuples in the
    **except** clauses. If need be, further analyze the details of the exception in
    your handler code, and **raise** again as soon as you know it’s not a case this
    handler can deal with.
  prefs: []
  type: TYPE_NORMAL
- en: Errors and anomalies that depend on user input or other external conditions
    not under your control are always expected, precisely because you have no control
    over their underlying causes. In such cases, you should concentrate your effort
    on handling the anomaly gracefully, reporting and logging its exact nature and
    details, and keeping your program running with undamaged internal and persistent
    state. Your **try**/**except** clauses should still be reasonably narrow, although
    this is not quite as crucial as when you use EAFP to structure your handling of
    not-really-erroneous special/edge cases.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, entirely unexpected errors and anomalies indicate bugs in your program’s
    design or coding. In most cases, the best strategy regarding such errors is to
    avoid **try**/**except** and just let the program terminate with error and traceback
    messages. (You might want to log such information and/or display it more suitably
    with an application-specific hook in sys.excepthook, as we’ll discuss shortly.)
    In the unlikely case that your program must keep running at all costs, even under
    dire circumstances, **try**/**except** statements that are quite wide may be appropriate,
    with the **try** clause guarding function calls that exercise vast swaths of program
    functionality, and broad **except** clauses.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a long-running program, make sure to log all details of the anomaly
    or error to some persistent place for later study (and also report to yourself
    some indication of the problem, so that you know such later study is necessary).
    The key is making sure that you can revert the program’s persistent state to some
    undamaged, internally consistent point. The techniques that enable long-running
    programs to survive some of their own bugs, as well as environmental adversities,
    are known as [checkpointing](https://oreil.ly/GX4hz) (basically, periodically
    saving program state, and writing the program so it can reload the saved state
    and continue from there) and [transaction processing](https://oreil.ly/0MaWS);
    we do not cover them further in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Logging Errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When Python propagates an exception all the way to the top of the stack without
    finding an applicable handler, the interpreter normally prints an error traceback
    to the standard error stream of the process (sys.stderr) before terminating the
    program. You can rebind sys.stderr to any file-like object usable for output in
    order to divert this information to a destination more suitable for your purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you want to change the amount and kind of information output on such occasions,
    rebinding sys.stderr is not sufficient. In such cases, you can assign your own
    function to sys.excepthook: Python calls it when terminating the program due to
    an unhandled exception. In your exception-reporting function, output whatever
    information will help you diagnose and debug the problem and direct that information
    to whatever destinations you please. For example, you might use the traceback
    module (covered in [“The traceback Module”](ch17.xhtml#the_traceback_module))
    to format stack traces. When your exception-reporting function terminates, so
    does your program.'
  prefs: []
  type: TYPE_NORMAL
- en: The logging module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Python standard library offers the rich and powerful logging module to let
    you organize the logging of messages from your applications in systematic, flexible
    ways. Pushing things to the limit, you might write a whole hierarchy of Logger
    classes and subclasses; you could couple the loggers with instances of Handler
    (and subclasses thereof), or insert instances of the class Filter to fine-tune
    criteria determining what messages get logged in which ways.
  prefs: []
  type: TYPE_NORMAL
- en: Messages are formatted by instances of the Formatter class—the messages themselves
    are instances of the LogRecord class. The logging module even includes a dynamic
    configuration facility, whereby you may dynamically set logging configuration
    files by reading them from disk files, or even by receiving them on a dedicated
    socket in a specialized thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the logging module sports a frighteningly complex and powerful architecture,
    suitable for implementing highly sophisticated logging strategies and policies
    that may be needed in vast and complicated software systems, in most applications
    you might get away with using a tiny subset of the package. First, **import**
    logging. Then, emit your message by passing it as a string to any of the module’s
    functions debug, info, warning, error, or critical, in increasing order of severity.
    If the string you pass contains format specifiers such as %s (as covered in [“Legacy
    String Formatting with %”](ch09.xhtml#legacy_string_formatting_with_percent)),
    then, after the string, pass as further arguments all the values to be formatted
    in that string. For example, don’t call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'which performs the formatting operation whether it’s needed or not; rather,
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'which performs formatting if and only if needed (i.e., if and only if calling
    debug is going to result in logging output, depending on the current threshold
    logging level). If foo is used only for logging and is especially compute- or
    I/O-intensive to create, you can use isEnabledFor to conditionalize the expensive
    code that creates foo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Configuring logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unfortunately, the logging module does not support the more readable formatting
    approaches covered in [“String Formatting”](ch09.xhtml#string_formatting), but
    only the legacy one mentioned in the previous subsection. Fortunately, it’s very
    rare to need any formatting specifiers beyond %s (which calls __str__) and %r
    (which calls __repr__).
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the threshold level is WARNING: any of the functions warning, error,
    or critical results in logging output, but the functions debug and info do not.
    To change the threshold level at any time, call logging.getLogger().setLevel,
    passing as the only argument one of the corresponding constants supplied by the
    logging module: DEBUG, INFO, WARNING, ERROR, or CRITICAL. For example, once you
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'all of the logging functions from debug to critical result in logging output
    until you change the level again. If later you call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: then only the functions error and critical result in logging output (debug,
    info, and warning won’t result in logging output); this condition, too, persists
    until you change the level again, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, logging output goes to your process’s standard error stream (sys.stderr,
    as covered in [Table 8-3](ch08.xhtml#functions_and_attributes_of_the_sys_mod))
    and uses a rather simplistic format (for example, it does not include a timestamp
    on each line it outputs). You can control these settings by instantiating an appropriate
    handler instance, with a suitable formatter instance, and creating and setting
    a new logger instance to hold it. In the simple, common case in which you just
    want to set these logging parameters once and for all, after which they persist
    throughout the run of your program, the simplest approach is to call the logging.basicConfig
    function, which lets you set things up quite simply via named parameters. Only
    the very first call to logging.basicConfig has any effect, and only if you call
    it before any of the logging functions (debug, info, and so on). Therefore, the
    most common use is to call logging.basicConfig at the very start of your program.
    For example, a common idiom at the start of a program is something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This setting writes logging messages to a file, nicely formatted with a precise
    human-readable timestamp, followed by the severity level right-aligned in an eight-character
    field, followed by the message proper.
  prefs: []
  type: TYPE_NORMAL
- en: For much, much more detailed information on the logging module and all the wonders
    you can perform with it, be sure to consult Python’s [rich online documentation](https://oreil.ly/AO1Xa)*.*
  prefs: []
  type: TYPE_NORMAL
- en: The assert Statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **assert** statement allows you to introduce “sanity checks” into a program.
    **assert** is a simple statement with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run Python with the optimize flag (**-O**, as covered in [“Command-Line
    Syntax and Options”](ch02.xhtml#command_line_syntax_and_options)), **assert**
    is a null operation: the compiler generates no code for it. Otherwise, **assert**
    evaluates *condition*. When *condition* is satisfied, **assert** does nothing.
    When *condition* is not satisfied, **assert** instantiates AssertionError with
    *expression* as the argument (or without arguments, if there is no *expression*)
    and raises the resulting instance.^([3](ch06.xhtml#ch01fn80))'
  prefs: []
  type: TYPE_NORMAL
- en: '**assert** statements can be an effective way to document your program. When
    you want to state that a significant, nonobvious condition *C* is known to hold
    at a certain point in a program’s execution (known as an *invariant* of your program),
    **assert** *C* is often better than a comment that just states that *C* holds.'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t Overuse assert
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Never use **assert** for other purposes besides sanity-checking program invariants.
    A serious but very common mistake is to use **assert** about the values of inputs
    or arguments. Checking for erroneous arguments or inputs is best done more explicitly,
    and in particular must not be done using **assert**, since it can be turned into
    a null operation by a Python command-line flag.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of **assert** is that, when *C* does *not* in fact hold, **assert**
    immediately alerts you to the problem by raising AssertionError, if the program
    is running without the **-O** flag. Once the code is thoroughly debugged, run
    it with **-O**, turning **assert** into a null operation and incurring no overhead
    (the **assert** remains in your source code to document the invariant).
  prefs: []
  type: TYPE_NORMAL
- en: The __debug__ Built-in Variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you run Python without the option **-O**, the __debug__ built-in variable
    is **True**. When you run Python with the option **-O**, __debug__ is **False**.
    Also, in the latter case the compiler generates no code for any **if** statement
    whose sole guard condition is __debug__.
  prefs: []
  type: TYPE_NORMAL
- en: To exploit this optimization, surround the definitions of functions that you
    call only in **assert** statements with **if** __debug__:. This technique makes
    compiled code smaller and faster when Python is run with **-O**, and enhances
    program clarity by showing that those functions exist only to perform sanity checks.
  prefs: []
  type: TYPE_NORMAL
- en: '^([1](ch06.xhtml#ch01fn78-marker)) Except that multiple calls to close are
    allowed and innocuous: all but the first one perform no operation.'
  prefs: []
  type: TYPE_NORMAL
- en: '^([2](ch06.xhtml#ch01fn79-marker)) This is somewhat controversial: while this
    book’s authors agree on this being “best practice,” some others strongly insist
    that one should always avoid multiple inheritance, including in this specific
    case.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch06.xhtml#ch01fn80-marker)) Some third-party frameworks, such as [pytest](http://docs.pytest.org/en/latest),
    materially improve the usefulness of the **assert** statement.
  prefs: []
  type: TYPE_NORMAL
