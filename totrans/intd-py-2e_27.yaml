- en: 'Appendix C. Something Completely Different: Async'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our first two appendixes were for beginning programmers, but this one is for
    those who are a bit advanced.
  prefs: []
  type: TYPE_NORMAL
- en: Like most programming languages, Python has been *synchronous*. It runs through
    code linearly, a line at a time, from top to bottom. When you call a function,
    Python jumps into its code, and the caller waits until the function returns before
    resuming what it was doing.
  prefs: []
  type: TYPE_NORMAL
- en: Your CPU can do only one thing at a time, so synchronous execution makes perfect
    sense. But it turns out that often a program is not actually running any code,
    but waiting for something, like data from a file or a network service. This is
    like us staring at a browser screen while waiting for a site to load. If we could
    avoid this “busy waiting,” we might shorten the total time of our programs. This
    is also called improving *throughput*.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 15](ch15.html#ch_systems), you saw that if you want some concurrency,
    your choices included threads, processes, or a third-party solution like `gevent`
    or `twisted`. But there are now a growing number of *asynchronous* answers, both
    built in to Python and third-party solutions. These coexist with the usual synchronous
    Python code, but, to borrow a Ghostbusters warning, you can’t cross the streams.
    I’ll show you how to avoid any ectoplasmic side effects.
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines and Event Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Python 3.4, Python added a standard *asynchronous* module called `asyncio`.
    Python 3.5 then added the keywords `async` and `await`. These implement some new
    concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Coroutines* are functions that pause at various points'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An *event loop* that schedules and runs coroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These let us write asynchronous code that looks something like the normal synchronous
    code that we’re used to. Otherwise, we’d need to use one of the methods mentioned
    in [Chapter 15](ch15.html#ch_systems) and [Chapter 17](ch17.html#ch_networks),
    and summarized later in [“Async Versus…”](#async_versus).
  prefs: []
  type: TYPE_NORMAL
- en: Normal multitasking is what your operating system does to your processes. It
    decides what’s fair, who’s being a CPU hog, when to open the I/O spigots, and
    so on. The event loop, however, provides *cooperative multitasking*, in which
    coroutines indicate when they’re able to start and stop. They run in a single
    thread, so you don’t have the potential issues that I mentioned in [“Threads”](ch15.html#threads).
  prefs: []
  type: TYPE_NORMAL
- en: 'You *define* a coroutine by putting `async` before its initial `def`. You *call*
    a coroutine by:'
  prefs: []
  type: TYPE_NORMAL
- en: Putting `await` before it, which quietly adds the coroutine to an existing event
    loop. You can do this only within another coroutine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or by using `asyncio.run()`, which explicitly starts an event loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or by using `asyncio.create_task()` or `asyncio.ensure_future()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This example uses the first two calling methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'These was a dramatic two-second wait in there that you can’t see on a printed
    page. To prove that we didn’t cheat (see [Chapter 19](ch19.html#ch_pythonista)
    for `timeit` details):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That `asyncio.sleep(2)` call was itself a coroutine, just an example here to
    fake something time consuming like an API call.
  prefs: []
  type: TYPE_NORMAL
- en: The line `asyncio.run(wicked())` is a way of running a coroutine from synchronous
    Python code (here, the top level of the program).
  prefs: []
  type: TYPE_NORMAL
- en: The difference from a standard synchronous counterpart (using `time.sleep()`)
    is that the caller of `wicked()` is not blocked for two seconds while it runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third way to run a coroutine is to create a *task* and `await` it. This
    example shows the task approach along with the previous two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you run this, you’ll see that there was no delay between the two lines printing
    this time. That’s because they were separate tasks. `task_1` paused two seconds
    after printing `Surrender`, but that didn’t affect `task_2`.
  prefs: []
  type: TYPE_NORMAL
- en: An `await` is similar to a `yield` in a generator, but rather than returning
    a value, it marks a spot where the event loop can pause it if needed.
  prefs: []
  type: TYPE_NORMAL
- en: There’s lots more where this came from in the [docs](https://oreil.ly/Cf_hd).
    Synchronous and asynchronous code can coexist in the same program. Just remember
    to put `async` before the `def` and `await` before the call of your asynchronous
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some more information:'
  prefs: []
  type: TYPE_NORMAL
- en: A [list](https://oreil.ly/Vj0yD) of `asyncio` links.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code for an `asyncio` [web crawler](https://oreil.ly/n4FVx).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asyncio Alternatives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although `asyncio` is a standard Python package, you can use `async` and `await`
    without it. Coroutines and the event loop are independent. The design of `asyncio`
    is sometimes [criticized](https://oreil.ly/n4FVx), and third-party alternatives
    have appeared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`curio`](https://curio.readthedocs.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`trio`](https://trio.readthedocs.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s show a real example using `trio` and [`asks`](https://asks.readthedocs.io)
    (an async web framework, modeled on the `requests` API). [Example C-1](#exC1)
    shows a concurrent web-crawling example using `trio` and `asks`, adapted from
    a stackoverflow [answer](https://oreil.ly/CbINS). To run this, first `pip install`
    both `trio` and `asks`.
  prefs: []
  type: TYPE_NORMAL
- en: Example C-1\. trio_asks_sites.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what I got:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You’ll notice that `trio` did not use `asyncio.run()`, but instead its own `trio.open_nursery()`.
    If you’re curious, you can read an [essay](https://oreil.ly/yp1-r) and [discussion](https://oreil.ly/P21Ra)
    of the design decisions behind `trio`.
  prefs: []
  type: TYPE_NORMAL
- en: A new package called [`AnyIO`](https://anyio.readthedocs.io/en/latest) provides
    a single interface to `asyncio`, `curio`, and `trio`.
  prefs: []
  type: TYPE_NORMAL
- en: In the future, you can expect more async approaches, both in standard Python
    and from third-party developers.
  prefs: []
  type: TYPE_NORMAL
- en: Async Versus…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you’ve seen in many places in this book, there are many techniques for concurrency.
    How does the async stuff compare with them?
  prefs: []
  type: TYPE_NORMAL
- en: Processes
  prefs: []
  type: TYPE_NORMAL
- en: This is a good solution if you want to use all the CPU cores on your machine,
    or multiple machines. But processes are heavy, take a while to start, and require
    serialization for interprocess communication.
  prefs: []
  type: TYPE_NORMAL
- en: Threads
  prefs: []
  type: TYPE_NORMAL
- en: Although threads were designed as a “lightweight” alternative to processes,
    each thread uses a good chunk of memory. Coroutines are much lighter than threads;
    you can create hundreds of thousands of coroutines on a machine that might only
    support a few thousand threads.
  prefs: []
  type: TYPE_NORMAL
- en: Green threads
  prefs: []
  type: TYPE_NORMAL
- en: Green threads like `gevent` work well and look like synchronous code, but they
    require *monkey-patching* standard Python functions, such as socket libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks
  prefs: []
  type: TYPE_NORMAL
- en: 'Libraries like `twisted` rely on *callbacks*: functions that are called when
    when certain events occur. This is familiar to GUI and JavaScript programmers.'
  prefs: []
  type: TYPE_NORMAL
- en: Queues—These tend to be a large-scale solution, when your data or processes
    really need more than one machine.
  prefs: []
  type: TYPE_NORMAL
- en: Async Frameworks and Servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The async additions to Python are recent, and it’s taking time for developers
    to create async versions of frameworks like Flask.
  prefs: []
  type: TYPE_NORMAL
- en: The [ASGI](https://asgi.readthedocs.io) standard is an async version of WSGI,
    discussed further [here](https://oreil.ly/BnEXT).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some ASGI web servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`hypercorn`](https://pgjones.gitlab.io/hypercorn)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`sanic`](https://sanic.readthedocs.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`uvicorn`](https://www.uvicorn.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And some async web frameworks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`aiohttp`](https://aiohttp.readthedocs.io)—Client *and* server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`api_hour`](https://pythonhosted.org/api_hour)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`asks`](https://asks.readthedocs.io)—Like `requests`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`blacksheep`](https://github.com/RobertoPrevato/BlackSheep)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`bocadillo`](https://github.com/bocadilloproject/bocadillo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`channels`](https://channels.readthedocs.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`fastapi`](https://fastapi.tiangolo.com)—Uses type annotations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`muffin`](https://muffin.readthedocs.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`quart`](https://gitlab.com/pgjones/quart)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`responder`](https://python-responder.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`sanic`](https://sanic.readthedocs.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`starlette`](https://www.starlette.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`tornado`](https://www.tornadoweb.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`vibora`](https://vibora.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, some async database interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`aiomysql`](https://aiomysql.readthedocs.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`aioredis`](https://aioredis.readthedocs.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`asyncpg`](https://github.com/magicstack/asyncpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
