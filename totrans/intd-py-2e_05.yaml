- en: Chapter 4\. Choose with if
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you can keep your head when all about you
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Are losing theirs and blaming it on you, …
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Rudyard Kipling, If—
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the previous chapters, you’ve seen many examples of data but haven’t done
    much with them. Most of the code examples used the interactive interpreter and
    were short. In this chapter, you learn how to structure Python *code*, not just
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Many computer languages use characters such as curly braces (`{` and `}`) or
    keywords such as `begin` and `end` to mark off sections of code. In those languages,
    it’s good practice to use consistent indentation to make your program more readable
    for yourself and others. There are even tools to make your code line up nicely.
  prefs: []
  type: TYPE_NORMAL
- en: When he was designing the language that became Python, Guido van Rossum decided
    that the indentation itself was enough to define a program’s structure, and avoided
    typing all those parentheses and curly braces. Python is unusual in this use of
    *white space* to define program structure. It’s one of the first aspects that
    newcomers notice, and it can seem odd to those who have experience with other
    languages. It turns out that after writing Python for a little while, it feels
    natural, and you stop noticing it. You even get used to doing more while typing
    less.
  prefs: []
  type: TYPE_NORMAL
- en: Our initial code examples have been one-liners. Let’s first see how to make
    comments and multiple-line commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Comment with #'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A *comment* is a piece of text in your program that is ignored by the Python
    interpreter. You might use comments to clarify nearby Python code, make notes
    to yourself to fix something someday, or for whatever purpose you like. You mark
    a comment by using the `#` character; everything from that point on to the end
    of the current line is part of the comment. You’ll usually see a comment on a
    line by itself, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, on the same line as the code it’s commenting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `#` character has many names: *hash*, *sharp*, *pound*, or the sinister-sounding
    *octothorpe*.^([1](ch04.html#idm45795038165928)) Whatever you call it,^([2](ch04.html#idm45795038164344))
    its effect lasts only to the end of the line on which it appears.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python does not have a multiline comment. You need to explicitly begin each
    comment line or section with a `#`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if it’s in a text string, the mighty octothorpe reverts back to its
    role as a plain old `#` character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Continue Lines with \
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Programs are more readable when lines are reasonably short. The recommended
    (not required) maximum line length is 80 characters. If you can’t say everything
    you want to say in that length, you can use the *continuation character*: `\`
    (backslash). Just put `\` at the end of a line, and Python will suddenly act as
    though you’re still on the same line.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if I wanted to add the first five digits, I could do it a line
    at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, I could do it in one step, using the continuation character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we skipped the backslash in the middle of an expression, we’d get an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a little trick—if you’re in the middle of paired parentheses (or square
    or curly brackets), Python doesn’t squawk about line endings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You’ll also see in [Chapter 5](ch05.html#ch_strings) that paired triple quotes
    let you make multiline strings.
  prefs: []
  type: TYPE_NORMAL
- en: Compare with if, elif, and else
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we finally take our first step into the *code structures* that weave data
    into programs. Our first example is this tiny Python program that checks the value
    of the boolean variable `disaster` and prints an appropriate comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `if` and `else` lines are Python *statements* that check whether a condition
    (here, the value of `disaster`) is a boolean `True` value, or can be evaluated
    as `True`. Remember, `print()` is Python’s built-in *function* to print things,
    normally to your screen.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you’ve programmed in other languages, note that you don’t need parentheses
    for the `if` test. For example, don’t say something such as `if (disaster == True)`
    (the equality operator `==` is described in a few paragraphs). You do need the
    colon (`:`) at the end. If, like me, you forget to type the colon at times, Python
    will display an error message.
  prefs: []
  type: TYPE_NORMAL
- en: Each `print()` line is indented under its test. I used four spaces to indent
    each subsection. Although you can use any indentation you like, Python expects
    you to be consistent with code within a section—the lines need to be indented
    the same amount, lined up on the left. The recommended style, called [*PEP-8*](http://bit.ly/pep-8),
    is to use four spaces. Don’t use tabs, or mix tabs and spaces; it messes up the
    indent count.
  prefs: []
  type: TYPE_NORMAL
- en: 'We did a number of things here, which I explain more fully as the chapter progresses:'
  prefs: []
  type: TYPE_NORMAL
- en: Assigned the boolean value `True` to the variable named `disaster`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performed a *conditional comparison* by using `if` and `else`, executing different
    code depending on the value of `disaster`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Called* the `print()` *function* to print some text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can have tests within tests, as many levels deep as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In Python, indentation determines how the `if` and `else` sections are paired.
    Our first test was to check `furry`. Because `furry` is `True`, Python goes to
    the indented `if large` test. Because we had set `large` to `True`, `if large`
    is evaluated as `True`, and the following `else` line is ignored. This makes Python
    run the line indented under `if large:` and print `It's a yeti.`
  prefs: []
  type: TYPE_NORMAL
- en: 'If there are more than two possibilities to test, use `if` for the first, `elif`
    (meaning *else if*) for the middle ones, and `else` for the last:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we tested for equality by using the `==` operator.
    Here are Python’s *comparison operators*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| equality | `==` |'
  prefs: []
  type: TYPE_TB
- en: '| inequality | `!=` |'
  prefs: []
  type: TYPE_TB
- en: '| less than | `<` |'
  prefs: []
  type: TYPE_TB
- en: '| less than or equal | `<=` |'
  prefs: []
  type: TYPE_TB
- en: '| greater than | `>` |'
  prefs: []
  type: TYPE_TB
- en: '| greater than or equal | `>=` |'
  prefs: []
  type: TYPE_TB
- en: 'These return the boolean values `True` or `False`. Let’s see how these all
    work, but first, assign a value to `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s try some tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that two equals signs (`==`) are used to *test equality*; remember, a single
    equals sign (`=`) is what you use to assign a value to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to make multiple comparisons at the same time, you use the *logical*
    (or *boolean*) *operators* `and`, `or`, and `not` to determine the final boolean
    result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Logical operators have lower *precedence* than the chunks of code that they’re
    comparing. This means that the chunks are calculated first, and then compared.
    In this example, because we set `x` to `7`, `5 < x` is calculated to be `True`
    and `x < 10` is also `True`, so we finally end up with `True and True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As [“Precedence”](ch03.html#precedence) points out, the easiest way to avoid
    confusion about precedence is to add parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some other tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re `and`-ing multiple comparisons with one variable, Python lets you
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s the same as `5 < x and x < 10`. You can also write longer comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: What Is True?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if the element we’re checking isn’t a boolean? What does Python consider
    `True` and `False`?
  prefs: []
  type: TYPE_NORMAL
- en: 'A `false` value doesn’t necessarily need to explicitly be a boolean `False`.
    For example, these are all considered `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| boolean | `False` |'
  prefs: []
  type: TYPE_TB
- en: '| null | `None` |'
  prefs: []
  type: TYPE_TB
- en: '| zero integer | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| zero float | `0.0` |'
  prefs: []
  type: TYPE_TB
- en: '| empty string | `''''` |'
  prefs: []
  type: TYPE_TB
- en: '| empty list | `[]` |'
  prefs: []
  type: TYPE_TB
- en: '| empty tuple | `()` |'
  prefs: []
  type: TYPE_TB
- en: '| empty dict | `{}` |'
  prefs: []
  type: TYPE_TB
- en: '| empty set | `set()` |'
  prefs: []
  type: TYPE_TB
- en: 'Anything else is considered `True`. Python programs use these definitions of
    “truthiness” and “falsiness” to check for empty data structures as well as `False`
    conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If what you’re testing is an expression rather than a simple variable, Python
    evaluates the expression and returns a boolean result. So, if you type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Python evaluates `color == "red"`. In our earlier example, we assigned the
    string `"mauve"` to `color`, so `color == "red"` is `False`, and Python moves
    on to the next test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Do Multiple Comparisons with in
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose that you have a letter and want to know whether it’s a vowel. One way
    would be to write a long `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever you need to make a lot of comparisons like that, separated by `or`,
    use Python’s *membership operator* `in`, instead. Here’s how to check vowel-ness
    more Pythonically, using `in` with a string made of vowel characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a preview of how to use `in` with some data types that you’ll read about
    in detail in the next few chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: For the dictionary, `in` looks at the keys (the lefthand side of the `:`) instead
    of their values.
  prefs: []
  type: TYPE_NORMAL
- en: 'New: I Am the Walrus'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arriving in Python 3.8 is the *walrus operator*, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: See the walrus? (Like a smiley, but tuskier.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, an assignment and test take two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With our new tusk power (aka [assignment expressions](https://oreil.ly/fHPtL))
    we can combine these into one step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The walrus also gets on swimmingly with `for` and `while`, which we look at
    in [Chapter 6](ch06.html#ch_for).
  prefs: []
  type: TYPE_NORMAL
- en: Coming Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Play with strings, and meet interesting characters.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Do
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 4.1 Choose a number between 1 and 10 and assign it to the variable `secret`.
    Then, select another number between 1 and 10 and assign it to the variable `guess`.
    Next, write the conditional tests (`if`, `else`, and `elif`) to print the string
    `'too low'` if `guess` is less than `secret`, `'too high'` if greater than `secret`,
    and `'just right'` if equal to `secret`.
  prefs: []
  type: TYPE_NORMAL
- en: '4.2 Assign `True` or `False` to the variables `small` and `green`. Write some
    `if`/`else` statements to print which of these matches those choices: cherry,
    pea, watermelon, pumpkin.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch04.html#idm45795038165928-marker)) Like that eight-legged green *thing*
    that’s *right behind you*!
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch04.html#idm45795038164344-marker)) Please don’t call it. It might come
    back.
  prefs: []
  type: TYPE_NORMAL
