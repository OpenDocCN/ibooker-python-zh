["```py\n`import` socket\n\nUDP_IP = 'localhost'\nUDP_PORT = 8883\nMESSAGE = \"\"\"\\ This is a bunch of lines, each\nof which will be sent in a single\nUDP datagram. No error detection\nor correction will occur.\nCrazy bananas! £€ should go through.\"\"\"\n\nserver = UDP_IP, UDP_PORT\nencoding = 'utf-8'\n`with` socket.socket(socket.AF_INET,    *`# IPv4`*\n                   socket.SOCK_DGRAM, *`# UDP`*\n                  ) `as` sock:\n `for` line `in` MESSAGE.splitlines():\n        data = line.encode(encoding)\n        bytes_sent = sock.sendto(data, server)\n        print(f'SENT {data!r} ({bytes_sent} of {len(data)})'\n\t\t      f' to {server}')\n        response, address = sock.recvfrom(1024)  *`# buffer size: 1024`*\n        print(f'RCVD {response.decode(encoding)!r}'\n              f' from {address}')\n\nprint('Disconnected from server')\n```", "```py\n`import` socket\n\nUDP_IP = 'localhost'\nUDP_PORT = 8883\nwith socket.socket(socket.AF_INET,    *`# IPv4`*\n                   socket.SOCK_DGRAM  *`# UDP`*\n                   ) as sock:\n    sock.bind((UDP_IP, UDP_PORT))\n    print(f'Serving at {UDP_IP}:{UDP_PORT}')\n `while` `True`:\n        data, sender_addr = sock.recvfrom(1024)  *`# 1024-byte buffer`*\n        print(f'RCVD {data!r}) from {sender_addr}')\n        bytes_sent = sock.sendto(data, sender_addr)\n        print(f'SENT {data!r} ({bytes_sent}/{len(data)})'\n              f' to {sender_addr}')\n```", "```py\n`import` socket\n\nIP_ADDR = 'localhost'\nIP_PORT = 8881\nMESSAGE = \"\"\"\\ A few lines of text\nincluding non-ASCII characters: €£\nto test the operation\nof both server\nand client.\"\"\"\n\nencoding = 'utf-8'\n`with` socket.socket(socket.AF_INET,     *`# IPv4`*\n                   socket.SOCK_STREAM  *`# TCP`*\n                   ) `as` sock:\n    sock.connect((IP_ADDR, IP_PORT))\n    print(f'Connected to server {IP_ADDR}:{IP_PORT}')\n    `for` line `in` MESSAGE.splitlines():\n        data = line.encode(encoding)\n        sock.sendall(data)\n        print(f'SENT {data!r} ({len(data)})')\n        response, address = sock.recvfrom(1024)  *`# buffer size: 1024`*\n        print(f'RCVD {response.decode(encoding)!r}'\n              f' ({len(response)}) from {address}')\n\nprint('Disconnected from server')\n```", "```py\n`import` concurrent\n`import` socket\n\nIP_ADDR = 'localhost'\nIP_PORT = 8881\n\n`def` handle(new_sock, address):\n    print('Connected from', address)\n    `with` new_sock:\n        `while` True:\n            received = new_sock.recv(1024)\n            `if` `not` received:\n                `break`\n            s = received.decode('utf-8', errors='replace')\n            print(f'Recv: {s!r}')\n            new_sock.sendall(received)\n            print(f'Echo: {s!r}')\n    print(f'Disconnected from {address}')\n\n`with` socket.socket(socket.AF_INET,     # IPv4 \n                   socket.SOCK_STREAM  # TCP\n                   ) `as` servsock:\n    servsock.bind((IP_ADDR, IP_PORT))\n    servsock.listen(5)\n    print(f'Serving at {servsock.getsockname()}')\n    `with` cconcurrent.futures.ThreadPoolExecutor(20) `as` e:\n        `while` True:\n            new_sock, address = servsock.accept()\n            e.submit(handle, new_sock, address)\n```", "```py\nctx = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\nctx.load_cert_chain(certfile='mycert.pem', keyfile='mykey.key')\n```", "```py\nsock = socket.socket(socket.AF_INET)\nsock = ctx.wrap_socket(sock, server_hostname='www.example.com')\nsock.connect(('www.example.com', 443))  \n*`# use 'sock' normally from here on`*\n```", "```py\nsock = socket.socket(socket.AF_INET)\nsock.bind(('www.example.com', 443))\nsock.listen(5)\n`while` `True``:`\n    newsock, fromaddr = sock.accept()\n    newsock = ctx.wrap_socket(newsock, server_side=`True`)\n    *`# deal with 'newsock' as usual; shut down, then close it, when done`*\n```"]