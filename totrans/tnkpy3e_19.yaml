- en: 17\. Inheritance#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17. 继承#
- en: 原文：[https://allendowney.github.io/ThinkPython/chap17.html](https://allendowney.github.io/ThinkPython/chap17.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://allendowney.github.io/ThinkPython/chap17.html](https://allendowney.github.io/ThinkPython/chap17.html)
- en: The language feature most often associated with object-oriented programming
    is **inheritance**. Inheritance is the ability to define a new class that is a
    modified version of an existing class. In this chapter I demonstrate inheritance
    using classes that represent playing cards, decks of cards, and poker hands. If
    you don’t play poker, don’t worry – I’ll tell you what you need to know.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与面向对象编程最常关联的语言特性是**继承**。继承是定义一个新的类，该类是现有类的修改版本的能力。在本章中，我将通过表示扑克牌、扑克牌组和扑克手牌的类来演示继承。如果你不玩扑克，不用担心——我会告诉你需要了解的内容。
- en: 17.1\. Representing cards[#](#representing-cards "Link to this heading")
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.1. 表示牌[#](#representing-cards "Link to this heading")
- en: There are 52 playing cards in a standard deck – each of them belongs to one
    of four suits and one of thirteen ranks. The suits are Spades, Hearts, Diamonds,
    and Clubs. The ranks are Ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, and King.
    Depending on which game you are playing, an Ace can be higher than King or lower
    than 2.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一副标准的扑克牌有 52 张——每一张牌属于四种花色之一和十三种点数之一。花色有黑桃、红桃、方块和梅花。点数有 Ace（王牌）、2、3、4、5、6、7、8、9、10、J（杰克）、Q（女王）和
    K（国王）。根据你玩的游戏规则，Ace 可以比 K 高，也可以比 2 低。
- en: 'If we want to define a new object to represent a playing card, it is obvious
    what the attributes should be: `rank` and `suit`. It is less obvious what type
    the attributes should be. One possibility is to use strings like `''Spade''` for
    suits and `''Queen''` for ranks. A problem with this implementation is that it
    would not be easy to compare cards to see which had a higher rank or suit.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想定义一个新的对象来表示一张扑克牌，属性应该是显而易见的：`rank` 和 `suit`。然而，属性应该是什么类型就不那么明显了。一个可能的选择是使用字符串，比如用
    `'Spade'` 表示花色，`'Queen'` 表示点数。这个实现的问题在于，比较牌的大小，看看哪张牌的点数或花色更高，将变得不那么容易。
- en: An alternative is to use integers to **encode** the ranks and suits. In this
    context, “encode” means that we are going to define a mapping between numbers
    and suits, or between numbers and ranks. This kind of encoding is not meant to
    be a secret (that would be “encryption”).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用整数来**编码**点数和花色。在这里，“编码”意味着我们将定义一个数字与花色之间，或者数字与点数之间的映射。这种编码并不意味着是保密的（那是“加密”）。
- en: 'For example, this table shows the suits and the corresponding integer codes:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个表格展示了花色和相应的整数代码：
- en: '| Suit | Code |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 花色 | 代码 |'
- en: '| --- | --- |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Spades | 3 |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| 黑桃 | 3 |'
- en: '| Hearts | 2 |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 红桃 | 2 |'
- en: '| Diamonds | 1 |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 方块 | 1 |'
- en: '| Clubs | 0 |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 梅花 | 0 |'
- en: With this encoding, we can compare suits by comparing their codes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种编码，我们可以通过比较它们的代码来比较花色。
- en: To encode the ranks, we’ll use the integer `2` to represent the rank `2`, `3`
    to represent `3`, and so on up to `10`. The following table shows the codes for
    the face cards.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编码点数，我们将使用整数 `2` 来表示点数 `2`，`3` 来表示 `3`，依此类推，一直到 `10`。下面的表格展示了面牌的代码。
- en: '| Rank | Code |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 点数 | 代码 |'
- en: '| --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Jack | 11 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 杰克 | 11 |'
- en: '| Queen | 12 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 女王 | 12 |'
- en: '| King | 13 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 国王 | 13 |'
- en: And we can use either `1` or `14` to represent an Ace, depending on whether
    we want it to be considered lower or higher than the other ranks.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `1` 或 `14` 来表示 Ace（王牌），具体取决于我们希望它被视为比其他点数低还是高。
- en: To represent these encodings, we will use two lists of strings, one with the
    names of the suits and the other with the names of the ranks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示这些编码，我们将使用两个字符串列表，一个包含花色的名称，另一个包含点数的名称。
- en: Here’s a definition for a class that represents a playing card, with these lists
    of strings as **class variables**, which are variables defined inside a class
    definition, but not inside a method.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个表示扑克牌的类的定义，使用这些字符串列表作为**类变量**，类变量是定义在类内部，但不在方法内部的变量。
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first element of `rank_names` is `None` because there is no card with rank
    zero. By including `None` as a place-keeper, we get a list with the nice property
    that the index `2` maps to the string `'2'`, and so on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`rank_names` 的第一个元素是 `None`，因为没有点数为零的牌。通过包括 `None` 作为占位符，我们得到了一个很好的属性：索引 `2`
    映射到字符串 `''2''`，以此类推。'
- en: Class variables are associated with the class, rather than an instance of the
    class, so we can access them like this.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 类变量与类相关联，而不是与类的实例相关联，因此我们可以像这样访问它们。
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can use `suit_names` to look up a suit and get the corresponding string.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `suit_names` 来查找花色并获取相应的字符串。
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And `rank_names` to look up a rank.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 并且可以使用 `rank_names` 来查找点数。
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 17.2\. Card attributes[#](#card-attributes "Link to this heading")
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.2\. 卡片属性[#](#card-attributes "跳转到此标题")
- en: Here’s an `__init__` method for the `Card` class – it takes `suit` and `rank`
    as parameters and assigns them to attributes with the same names.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Card`类的`__init__`方法——它接受`花色`和`点数`作为参数，并将它们分配给具有相同名称的属性。
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now we can create a `Card` object like this.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以这样创建一个`Card`对象。
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can use the new instance to access the attributes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用新的实例来访问属性。
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is also legal to use the instance to access the class variables.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用实例来访问类变量也是合法的。
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: But if you use the class, it is clearer that they are class variables, not attributes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果使用类来访问，能够更清楚地表明它们是类变量，而不是实例属性。
- en: 17.3\. Printing cards[#](#printing-cards "Link to this heading")
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.3\. 打印卡片[#](#printing-cards "跳转到此标题")
- en: Here’s a `__str__` method for `Card` objects.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`__str__`方法，用于`Card`对象。
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When we print a `Card`, Python calls the `__str__` method to get a human-readable
    representation of the card.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打印一个`Card`对象时，Python会调用`__str__`方法来获取该卡片的可读表示。
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The following is a diagram of the `Card` class object and the Card instance.
    `Card` is a class object, so its type is `type`. `queen` is an instance of `Card`,
    so its type is `Card`. To save space, I didn’t draw the contents of `suit_names`
    and `rank_names`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Card`类对象和卡片实例的示意图。`Card`是一个类对象，所以它的类型是`type`。`queen`是`Card`的实例，所以它的类型是`Card`。为了节省空间，我没有画出`suit_names`和`rank_names`的内容。
- en: '![_images/5f1d5a265aab792dbe104aaedafa1a65dded15806c5dff8a8854f2f3896703eb.png](../Images/cf84277cd6a15970041c403cff3b289f.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![_images/5f1d5a265aab792dbe104aaedafa1a65dded15806c5dff8a8854f2f3896703eb.png](../Images/cf84277cd6a15970041c403cff3b289f.png)'
- en: Every `Card` instance has its own `suit` and `rank` attributes, but there is
    only one `Card` class object, and only one copy of the class variables `suit_names`
    and `rank_names`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Card`实例都有自己的`suit`和`rank`属性，但只有一个`Card`类对象，并且类变量`suit_names`和`rank_names`只有一份副本。
- en: 17.4\. Comparing cards[#](#comparing-cards "Link to this heading")
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.4\. 比较卡片[#](#comparing-cards "跳转到此标题")
- en: Suppose we create a second `Card` object with the same suit and rank.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们创建了第二个具有相同花色和点数的`Card`对象。
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If we use the `==` operator to compare them, it checks whether `queen` and `queen2`
    refer to the same object.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`==`运算符来比较它们，它会检查`queen`和`queen2`是否指向同一个对象。
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: They don’t, so it returns `False`. We can change this behavior by defining the
    special method `__eq__`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 它们不相等，所以返回`False`。我们可以通过定义特殊方法`__eq__`来改变这种行为。
- en: '[PRE20]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`__eq__` takes two `Card` objects as parameters and returns `True` if they
    have the same suit and rank, even if they are not the same object. In other words,
    it checks whether they are equivalent, even if they are not identical.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`__eq__`接受两个`Card`对象作为参数，如果它们具有相同的花色和点数，即使它们不是同一个对象，也会返回`True`。换句话说，它会检查它们是否等价，即使它们不是同一个对象。'
- en: When we use the `==` operator with `Card` objects, Python calls the `__eq__`
    method.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`==`运算符比较`Card`对象时，Python会调用`__eq__`方法。
- en: '[PRE21]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As a second test, let’s create a card with the same suit and a different rank.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二个测试，让我们创建一张具有相同花色但不同点数的卡片。
- en: '[PRE23]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can confirm that `queen` and `six` are not equivalent.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以确认`queen`和`six`不是等价的。
- en: '[PRE25]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If we use the `!=` operator, Python invokes a special method called `__ne__`,
    if it exists. Otherwise it invokes`__eq__` and inverts the result – so if `__eq__`
    returns `True`, the result of the `!=` operator is `False`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`!=`运算符，Python会调用一个叫做`__ne__`的特殊方法（如果存在）。如果没有，它会调用`__eq__`并反转结果——也就是说，如果`__eq__`返回`True`，那么`!=`运算符的结果就是`False`。
- en: '[PRE27]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now suppose we want to compare two cards to see which is bigger. If we use one
    of the relational operators, we get a `TypeError`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想比较两张卡片，看看哪一张更大。如果我们使用关系运算符之一，将会出现`TypeError`。
- en: '[PRE31]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To change the behavior of the `<` operator, we can define a special method called
    `__lt__`, which is short for “less than”. For the sake of this example, let’s
    assume that suit is more important than rank – so all Spades outrank all Hearts,
    which outrank all Diamonds, and so on. If two cards have the same suit, the one
    with the higher rank wins.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变`<`运算符的行为，我们可以定义一个特殊的方法叫做`__lt__`，它是“less than”（小于）的缩写。为了简单起见，假设花色比点数更重要——所以所有黑桃的等级高于所有红心，红心又高于所有方块，依此类推。如果两张卡片的花色相同，那么点数较大的卡片获胜。
- en: To implement this logic, we’ll use the following method, which returns a tuple
    containing a card’s suit and rank, in that order.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个逻辑，我们将使用以下方法，它返回一个元组，包含卡片的花色和点数，按此顺序。
- en: '[PRE33]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We can use this method to write `__lt__`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个方法来编写`__lt__`。
- en: '[PRE34]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Tuple comparison compares the first elements from each tuple, which represent
    the suits. If they are the same, it compares the second elements, which represent
    the ranks.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 元组比较会比较每个元组的第一个元素，这些元素表示花色。如果它们相同，则比较第二个元素，这些元素表示点数。
- en: Now if we use the `<` operator, it invokes the `__lt__` method.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们使用`<`运算符，它会调用`__lt__`方法。
- en: '[PRE35]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If we use the `>` operator, it invokes a special method called `__gt__`, if
    it exists. Otherwise it invokes `__lt__` with the arguments in the opposite order.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`>`运算符，它会调用一个名为`__gt__`的特殊方法（如果存在）。否则，它会使用`__lt__`，并将参数顺序调换。
- en: '[PRE37]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Finally, if we use the `<=` operator, it invokes a special method called `__le__`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们使用`<=`运算符，它会调用一个名为`__le__`的特殊方法。
- en: '[PRE41]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: So we can check whether one card is less than or equal to another.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们可以检查一张牌是否小于或等于另一张牌。
- en: '[PRE42]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If we use the `>=` operator, it uses `__ge__` if it exists. Otherwise, it invokes
    `__le__` with the arguments in the opposite order.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`>=`运算符，它会使用`__ge__`（如果存在）。否则，它会使用`__le__`，并将参数顺序调换。
- en: '[PRE46]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As we have defined them, these methods are complete in the sense that we can
    compare any two `Card` objects, and consistent in the sense that results from
    different operators don’t contradict each other. With these two properties, we
    can say that `Card` objects are **totally ordered**. And that means, as we’ll
    see soon, that they can be sorted.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所定义的，这些方法是完整的，因为我们可以比较任何两个`Card`对象，而且是相容的，因为不同运算符的结果不互相矛盾。拥有这两个特性，我们可以说`Card`对象是**完全有序**的。这意味着，正如我们很快将看到的，它们可以被排序。
- en: 17.5\. Decks[#](#decks "Link to this heading")
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.5\. 牌组[#](#decks "跳转到此标题")
- en: Now that we have objects that represent cards, let’s define objects that represent
    decks. The following is a class definition for `Deck` with an `__init__` method
    takes a list of `Card` objects as a parameter and assigns it to an attribute called
    `cards`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了表示牌的对象，让我们定义表示牌组的对象。以下是`Deck`类的定义，其中`__init__`方法接收一个`Card`对象列表作为参数，并将其赋值给一个名为`cards`的属性。
- en: '[PRE48]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: To create a list that contains the 52 cards in a standard deck, we’ll use the
    following static method.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个包含标准牌组52张牌的列表，我们将使用以下静态方法。
- en: '[PRE49]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In `make_cards`, the outer loop enumerates the suits from `0` to `3`. The inner
    loop enumerates the ranks from `2` to `14` – where `14` represents an Ace that
    outranks a King. Each iteration creates a new `Card` with the current suit and
    rank, and appends it to `cards`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在`make_cards`中，外循环枚举从`0`到`3`的花色，内循环枚举从`2`到`14`的点数——其中`14`表示比国王还大的Ace。每次迭代都会用当前的花色和点数创建一张新的`Card`，并将其添加到`cards`列表中。
- en: Here’s how we make a list of cards and a `Deck` object that contains it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们如何制作一组牌并创建一个包含这些牌的`Deck`对象。
- en: '[PRE50]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: It contains 52 cards, as intended.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含52张牌，符合预期。
- en: '## 17.6\. Printing the deck[#](#printing-the-deck "Link to this heading")'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '## 17.6\. 打印牌组[#](#printing-the-deck "跳转到此标题")'
- en: Here is a `__str__` method for `Deck`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Deck`的`__str__`方法。
- en: '[PRE52]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This method demonstrates an efficient way to accumulate a large string – building
    a list of strings and then using the string method `join`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法展示了一种高效地积累大字符串的方式——先构建一个字符串列表，然后使用字符串方法`join`。
- en: We’ll test this method with a deck that only contains two cards.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用一副只包含两张牌的牌组来测试这个方法。
- en: '[PRE53]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If we call `str`, it invokes `__str__`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用`str`，它会调用`__str__`方法。
- en: '[PRE54]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: When Jupyter displays a string, it shows the “representational” form of the
    string, which represents a newline with the sequence `\n`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当Jupyter显示字符串时，它会显示字符串的“表示”形式，其中换行符用序列`\n`表示。
- en: However, if we print the result, Jupyter shows the “printable” form of the string,
    which prints the newline as whitespace.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们打印结果，Jupyter会显示字符串的“可打印”形式，其中换行符被显示为空格。
- en: '[PRE56]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: So the cards appear on separate lines.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这些牌会显示在不同的行上。
- en: 17.7\. Add, remove, shuffle and sort[#](#add-remove-shuffle-and-sort "Link to
    this heading")
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.7\. 添加、删除、洗牌和排序[#](#add-remove-shuffle-and-sort "跳转到此标题")
- en: To deal cards, we would like a method that removes a card from the deck and
    returns it. The list method `pop` provides a convenient way to do that.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要发牌，我们需要一个方法，它从牌组中移除一张牌并返回。列表方法`pop`提供了一个方便的方式来实现这一点。
- en: '[PRE58]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here’s how we use it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们如何使用它。
- en: '[PRE59]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We can confirm that there are `51` cards left in the deck.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以确认牌组中还剩下`51`张牌。
- en: '[PRE61]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: To add a card, we can use the list method `append`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一张牌，我们可以使用列表方法`append`。
- en: '[PRE63]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As an example, we can put back the card we just popped.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们可以把刚刚弹出的牌放回去。
- en: '[PRE64]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To shuffle the deck, we can use the `shuffle` function from the `random` module:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要洗牌，我们可以使用`random`模块中的`shuffle`函数：
- en: '[PRE66]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: If we shuffle the deck and print the first few cards, we can see that they are
    in no apparent order.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们洗牌并打印前几张卡片，我们会看到它们的顺序看似随机。
- en: '[PRE68]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: To sort the cards, we can use the list method `sort`, which sorts the elements
    “in place” – that is, it modifies the list rather than creating a new list.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要对卡片进行排序，我们可以使用列表方法`sort`，该方法会“就地”排序元素——也就是说，它修改原列表，而不是创建一个新的列表。
- en: '[PRE70]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: When we invoke `sort`, it uses the `__lt__` method to compare cards.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`sort`时，它会使用`__lt__`方法来比较卡片。
- en: '[PRE71]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: If we print the first few cards, we can confirm that they are in increasing
    order.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打印前几张卡片，可以确认它们是按升序排列的。
- en: '[PRE72]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In this example, `Deck.sort` doesn’t do anything other than invoke `list.sort`.
    Passing along responsibility like this is called **delegation**.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Deck.sort`除了调用`list.sort`之外并不会做其他事情。将责任传递给其他方法的做法称为**委托**。
- en: 17.8\. Parents and children[#](#parents-and-children "Link to this heading")
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.8\. 父类和子类[#](#parents-and-children "Link to this heading")
- en: Inheritance is the ability to define a new class that is a modified version
    of an existing class. As an example, let’s say we want a class to represent a
    “hand”, that is, the cards held by one player.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是定义一个新类的能力，这个新类是现有类的修改版。例如，假设我们想定义一个类来表示“手牌”，也就是一个玩家持有的卡片。
- en: A hand is similar to a deck – both are made up of a collection of cards, and
    both require operations like adding and removing cards.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hand`类似于`Deck`——两者都是由卡片集合组成，并且都需要执行像添加和移除卡片这样的操作。'
- en: A hand is also different from a deck – there are operations we want for hands
    that don’t make sense for a deck. For example, in poker we might compare two hands
    to see which one wins. In bridge, we might compute a score for a hand in order
    to make a bid.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hand`和`Deck`也有不同之处——我们希望对`Hand`进行的操作在`Deck`上没有意义。例如，在扑克中，我们可能会比较两副牌，看看哪一副胜出。在桥牌中，我们可能会计算一副牌的分数，以便进行叫牌。'
- en: This relationship between classes – where one is a specialized version of another
    – lends itself to inheritance.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类之间的关系——其中一个是另一个的专门化版本——非常适合继承。
- en: To define a new class that is based on an existing class, we put the name of
    the existing class in parentheses.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个基于现有类的新类，我们将现有类的名称放在括号中。
- en: '[PRE74]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This definition indicates that `Hand` inherits from `Deck`, which means that
    `Hand` objects can access methods defined in `Deck`, like `take_card` and `put_card`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义表明`Hand`继承自`Deck`，这意味着`Hand`对象可以访问`Deck`中定义的方法，如`take_card`和`put_card`。
- en: '`Hand` also inherits `__init__` from `Deck`, but if we define `__init__` in
    the `Hand` class, it overrides the one in the `Deck` class.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hand`也继承了`Deck`中的`__init__`方法，但如果我们在`Hand`类中定义了`__init__`，它将覆盖`Deck`类中的版本。'
- en: '[PRE75]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This version of `__init__` takes an optional string as a parameter, and always
    starts with an empty list of cards. When we create a `Hand`, Python invokes this
    method, not the one in `Deck` – which we can confirm by checking that the result
    has a `label` attribute.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的`__init__`方法接受一个可选的字符串作为参数，并且总是从一个空的卡片列表开始。当我们创建一个`Hand`对象时，Python会调用这个方法，而不是在`Deck`中的方法——我们可以通过检查结果是否包含`label`属性来确认这一点。
- en: '[PRE76]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: To deal a card, we can use `take_card` to remove a card from a `Deck`, and `put_card`
    to add the card to a `Hand`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要发一张卡片，我们可以使用`take_card`从`Deck`中移除一张卡片，并使用`put_card`将卡片添加到`Hand`中。
- en: '[PRE78]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Let’s encapsulate this code in a `Deck` method called `move_cards`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这段代码封装到一个名为`move_cards`的`Deck`方法中。
- en: '[PRE80]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This method is polymorphic – that is, it works with more than one type: `self`
    and `other` can be either a `Hand` or a `Deck`. So we can use this method to deal
    a card from `Deck` to a `Hand`, from one `Hand` to another, or from a `Hand` back
    to a `Deck`.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法是多态的——也就是说，它可以与多种类型一起工作：`self`和`other`可以是`Hand`或`Deck`。因此，我们可以使用这个方法将一张卡片从`Deck`发给`Hand`，从一副`Hand`发给另一副，或者从`Hand`发回`Deck`。
- en: 'When a new class inherits from an existing one, the existing one is called
    the **parent** and the new class is called the **child**. In general:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个新类继承自现有类时，现有类称为**父类**，新类称为**子类**。一般来说：
- en: Instances of the child class should have all of the attributes of the parent
    class, but they can have additional attributes.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类的实例应该拥有父类的所有属性，但它们可以有额外的属性。
- en: The child class should have all of the methods of the parent class, but it can
    have additional methods.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类应该拥有父类的所有方法，但它可以有额外的方法。
- en: If a child class overrides a method from the parent class, the new method should
    take the same parameters and return a compatible result.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果子类重写了父类的方法，则新方法应该采用相同的参数，并返回兼容的结果。
- en: This set of rules is called the “Liskov substitution principle” after computer
    scientist Barbara Liskov.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这一套规则被称为“李斯科夫替代原则”，以计算机科学家芭芭拉·李斯科夫的名字命名。
- en: If you follow these rules, any function or method designed to work with an instance
    of a parent class, like a `Deck`, will also work with instances of a child class,
    like `Hand`. If you violate these rules, your code will collapse like a house
    of cards (sorry).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循这些规则，任何设计用来处理父类实例的函数或方法，比如`Deck`，也可以用来处理子类实例，比如`Hand`。如果违反这些规则，你的代码将像纸牌屋一样崩塌（抱歉）。
- en: 17.9\. Specialization[#](#specialization "Link to this heading")
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.9\. 专门化[#](#specialization "Link to this heading")
- en: Let’s make a class called `BridgeHand` that represents a hand in bridge – a
    widely played card game. We’ll inherit from `Hand` and add a new method called
    `high_card_point_count` that evaluates a hand using a “high card point” method,
    which adds up points for the high cards in the hand.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`BridgeHand`的类，用来表示桥牌中的一手牌——这是一种广泛玩的纸牌游戏。我们将从`Hand`继承，并添加一个名为`high_card_point_count`的新方法，使用“高牌点数”方法来评估一手牌，该方法会为手中的高牌加总分数。
- en: Here’s a class definition that contains as a class variable a dictionary that
    maps from card names to their point values.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个类定义，其中包含一个类变量，映射了从卡片名称到其点数值的字典。
- en: '[PRE81]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Given the rank of a card, like `12`, we can use `Card.rank_names` to get the
    string representation of the rank, and then use `hcp_dict` to get its score.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一张卡片的等级，比如`12`，我们可以使用`Card.rank_names`获取该等级的字符串表示，然后使用`hcp_dict`获取它的分数。
- en: '[PRE82]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The following method loops through the cards in a `BridgeHand` and adds up their
    scores.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法遍历`BridgeHand`中的卡片，并加总它们的分数。
- en: '[PRE84]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: To test it, we’ll deal a hand with five cards – a bridge hand usually has thirteen,
    but it’s easier to test code with small examples.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行测试，我们将发一手五张牌——桥牌通常有十三张，但使用小例子更容易测试代码。
- en: '[PRE85]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: And here is the total score for the King and Queen.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是国王和皇后的总分。
- en: '[PRE87]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '`BridgeHand` inherits the variables and methods of `Hand` and adds a class
    variable and a method that are specific to bridge. This way of using inheritance
    is called **specialization** because it defines a new class that is specialized
    for a particular use, like playing bridge.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`BridgeHand`继承了`Hand`的变量和方法，并增加了一个类变量和一个特定于桥牌的方法。使用这种方式进行继承被称为**专门化**，因为它定义了一个针对特定用途（如打桥牌）而专门化的新类。'
- en: 17.10\. Debugging[#](#debugging "Link to this heading")
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.10\. 调试[#](#debugging "Link to this heading")
- en: Inheritance is a useful feature. Some programs that would be repetitive without
    inheritance can be written more concisely with it. Also, inheritance can facilitate
    code reuse, since you can customize the behavior of a parent class without having
    to modify it. In some cases, the inheritance structure reflects the natural structure
    of the problem, which makes the design easier to understand.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是一个有用的特性。一些如果没有继承就会重复的程序，可以用继承更简洁地编写。此外，继承有助于代码复用，因为你可以在不修改父类的情况下定制其行为。在某些情况下，继承结构反映了问题的自然结构，这使得设计更容易理解。
- en: On the other hand, inheritance can make programs difficult to read. When a method
    is invoked, it is sometimes not clear where to find its definition – the relevant
    code may be spread across several modules.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，继承可能会让程序变得难以阅读。当调用一个方法时，有时不清楚在哪里找到它的定义——相关代码可能分散在多个模块中。
- en: Any time you are unsure about the flow of execution through your program, the
    simplest solution is to add print statements at the beginning of the relevant
    methods. If `Deck.shuffle` prints a message that says something like `Running
    Deck.shuffle`, then as the program runs it traces the flow of execution.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你不确定程序的执行流程时，最简单的解决方法是，在相关方法的开始处添加打印语句。如果`Deck.shuffle`打印一条类似于`Running Deck.shuffle`的消息，那么程序运行时就能追踪执行流程。
- en: As an alternative, you could use the following function, which takes an object
    and a method name (as a string) and returns the class that provides the definition
    of the method.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代，你可以使用以下函数，它接受一个对象和一个方法名（作为字符串），并返回提供该方法定义的类。
- en: '[PRE89]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '`find_defining_class` uses the `mro` method to get the list of class objects
    (types) that will be searched for methods. “MRO” stands for “method resolution
    order”, which is the sequence of classes Python searches to “resolve” a method
    name – that is, to find the function object the name refers to.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`find_defining_class`使用`mro`方法获取类对象（类型）的列表，该列表将用于搜索方法。“MRO”代表“方法解析顺序”，即Python搜索的类的顺序，用于“解析”方法名——也就是说，找到该名称所引用的函数对象。'
- en: As an example, let’s instantiate a `BridgeHand` and then find the defining class
    of `shuffle`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们实例化一个 `BridgeHand`，然后找到 `shuffle` 的定义类。
- en: '[PRE90]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The `shuffle` method for the `BridgeHand` object is the one in `Deck`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`BridgeHand` 对象的 `shuffle` 方法是 `Deck` 中的那个。'
- en: 17.11\. Glossary[#](#glossary "Link to this heading")
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.11\. 词汇表[#](#glossary "跳转到此标题")
- en: '**inheritance:** The ability to define a new class that is a modified version
    of a previously defined class.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**继承：** 定义一个新类，该类是先前定义的类的修改版本。'
- en: '**encode:** To represent one set of values using another set of values by constructing
    a mapping between them.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**编码：** 使用另一组值来表示一组值，通过在它们之间构建映射。'
- en: '**class variable:** A variable defined inside a class definition, but not inside
    any method.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**类变量：** 在类定义内部定义的变量，但不在任何方法内部。'
- en: '**totally ordered:** A set of objects is totally ordered if we can compare
    any two elements and the results are consistent.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**完全有序：** 如果我们能比较任何两个元素并且比较结果是一致的，那么该集合就是完全有序的。'
- en: '**delegation:** When one method passes responsibility to another method to
    do most or all of the work.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**委托：** 当一个方法将责任传递给另一个方法来完成大部分或所有工作时。'
- en: '**parent class:** A class that is inherited from.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**父类：** 被继承的类。'
- en: '**child class:** A class that inherits from another class.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**子类：** 继承自另一个类的类。'
- en: '**specialization:** A way of using inheritance to create a new class that is
    a specialized version of an existing class.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**专门化：** 使用继承来创建一个新类，该类是现有类的专门化版本。'
- en: 17.12\. Exercises[#](#exercises "Link to this heading")
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 17.12\. 练习[#](#exercises "跳转到此标题")
- en: '[PRE92]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 17.12.1\. Ask a Virtual Assistant[#](#ask-a-virtual-assistant "Link to this
    heading")
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.12.1\. 请求虚拟助手[#](#ask-a-virtual-assistant "跳转到此标题")
- en: When it goes well, object-oriented programming can make programs more readable,
    testable, and reusable. But it can also make programs complicated and hard to
    maintain. As a result, OOP is a topic of controversy – some people love it, and
    some people don’t.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当它运行顺利时，面向对象编程可以使程序更易读、可测试和可重用。但它也可能使程序变得复杂，难以维护。因此，面向对象编程是一个有争议的话题——一些人喜欢它，而另一些人则不喜欢。
- en: 'To learn more about the topic, ask a virtual assistant:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于该主题的信息，请请求虚拟助手：
- en: What are some pros and cons of object-oriented programming?
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程有哪些优缺点？
- en: What does it mean when people say “favor composition over inheritance”?
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当人们说“偏好组合而非继承”时，这是什么意思？
- en: What is the Liskov substitution principle?
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 里氏替换原则是什么？
- en: Is Python an object-oriented language?
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 是面向对象的语言吗？
- en: What are the requirements for a set to be totally ordered?
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个集合要是完全有序的，需要满足哪些要求？
- en: And as always, consider using a virtual assistant to help with the following
    exercises.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，考虑使用虚拟助手来帮助完成以下练习。
- en: 17.12.2\. Exercise[#](#exercise "Link to this heading")
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.12.2\. 练习[#](#exercise "跳转到此标题")
- en: In contract bridge, a “trick” is a round of play in which each of four players
    plays one card. To represent those cards, we’ll define a class that inherits from
    `Deck`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在桥牌中，“trick” 是一轮比赛，其中四名玩家各出一张牌。为了表示这些牌，我们将定义一个继承自 `Deck` 的类。
- en: '[PRE94]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: As an example, consider this trick, where the first player leads with the 3
    of Diamonds, which means that Diamonds are the “led suit”. The second and third
    players “follow suit”, which means they play a card with the led suit. The fourth
    player plays a card of a different suit, which means they cannot win the trick.
    So the winner of this trick is the third player, because they played the highest
    card in the led suit.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，考虑这个技巧，第一位玩家以方块3出牌，这意味着方块是“领先花色”。第二位和第三位玩家“跟花色”，也就是出与领先花色相同的牌。第四位玩家出了一张不同花色的牌，这意味着他们不能赢得这一轮。所以这轮的赢家是第三位玩家，因为他们出了领先花色中的最大牌。
- en: '[PRE95]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Write a `Trick` method called `find_winner` that loops through the cards in
    the `Trick` and returns the index of the card that wins. In the previous example,
    the index of the winning card is `2`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 `Trick` 方法，名为 `find_winner`，它遍历 `Trick` 中的牌，并返回获胜牌的索引。在前面的示例中，获胜牌的索引是 `2`。
- en: 17.12.3\. Exercise[#](#id1 "Link to this heading")
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.12.3\. 练习[#](#id1 "跳转到此标题")
- en: The next few exercises ask to you write functions that classify poker hands.
    If you are not familiar with poker, I’ll explain what you need to know. We’ll
    use the following class to represent poker hands.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几个练习要求你编写函数来分类扑克牌型。如果你不熟悉扑克牌，我会解释你需要知道的内容。我们将使用以下类来表示扑克牌型。
- en: '[PRE97]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '`PokerHand` provides two methods that will help with the exercises.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`PokerHand` 提供了两个方法，帮助完成练习。'
- en: '`get_suit_counts` loops through the cards in the `PokerHand`, counts the number
    of cards in each suit, and returns a dictionary that maps from each suit code
    to the number of times it appears.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_suit_counts`循环遍历`PokerHand`中的牌，计算每种花色的牌数，并返回一个字典，将每个花色代码映射到它出现的次数。'
- en: '`get_rank_counts` does the same thing with the ranks of the cards, returning
    a dictionary that maps from each rank code to the number of times it appears.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_rank_counts`与牌的等级执行相同的操作，返回一个字典，将每个等级代码映射到它出现的次数。'
- en: All of the exercises that follow can be done using only the Python features
    we have learned so far, but some of them are more difficult than most of the previous
    exercises. I encourage you to ask a virtual assistant for help.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 所有接下来的练习都可以仅使用我们迄今学到的Python特性完成，但其中一些比以前的练习更难。我鼓励你寻求虚拟助手的帮助。
- en: For problems like this, it often works well to ask for general advice about
    strategies and algorithms. Then you can either write the code yourself or ask
    for code. If you ask for code, you might want to provide the relevant class definitions
    as part of the prompt.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样的问题，通常很好地寻求关于策略和算法的一般建议。然后你可以自己编写代码，或者请求代码。如果你请求代码，你可能需要在提示的一部分中提供相关的类定义。
- en: As a first exercise, we’ll write a method called `has_flush` that checks whether
    a hand has a “flush” – that is, whether it contains at least five cards of the
    same suit.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一练习，我们将编写一个名为`has_flush`的方法，检查一手牌是否有“同花” - 即是否包含至少五张同一花色的牌。
- en: In most varieties of poker, a hand contains either five or seven cards, but
    there are some exotic variations where a hand contains other numbers of cards.
    But regardless of how many cards there are in a hand, the only ones that count
    are the five that make the best hand.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数扑克牌的变体中，一手牌通常包含五张或七张牌，但也有一些异国情调的变体，一手牌包含其他数量的牌。但不管一手牌有多少张牌，只有五张牌才算在内，这五张牌可以组成最好的一手牌。
- en: 17.12.4\. Exercise[#](#id2 "Link to this heading")
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.12.4\. 练习[#](#id2 "Link to this heading")
- en: Write a method called `has_straight` that checks whether a hand contains a straight,
    which is a set of five cards with consecutive ranks. For example, if a hand contains
    ranks `5`, `6`, `7`, `8`, and `9`, it contains a straight.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为`has_straight`的方法，检查一手牌是否包含顺子，即五张具有连续等级的牌。例如，如果一手牌包含等级`5`、`6`、`7`、`8`和`9`，那么它就包含顺子。
- en: An Ace can come before a two or after a King, so `Ace`, `2`, `3`, `4`, `5` is
    a straight and so is `10`, `Jack`, `Queen`, `King`, `Ace`. But a straight cannot
    “wrap around”, so `King`, `Ace`, `2`, `3`, `4` is not a straight.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 一张A可以出现在2之前或K之后，所以`A`、`2`、`3`、`4`、`5`是顺子，`10`、`J`、`Q`、`K`、`A`也是顺子。但顺子不能“绕过”，所以`K`、`A`、`2`、`3`、`4`不是顺子。
- en: 17.12.5\. Exercise[#](#id3 "Link to this heading")
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.12.5\. 练习[#](#id3 "Link to this heading")
- en: A hand has a straight flush if it contains a set of five cards that are both
    a straight and a flush – that is, five cards of the same suit with consecutive
    ranks. Write a `PokerHand` method that checks whether a hand has a straight flush.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 一手牌有一个顺子同花顺，如果它包含五张既是顺子又是同一花色的牌 - 也就是说，五张具有连续等级的相同花色的牌。编写一个`PokerHand`方法，检查一手牌是否有顺子同花顺。
- en: 17.12.6\. Exercise[#](#id4 "Link to this heading")
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.12.6\. 练习[#](#id4 "Link to this heading")
- en: A poker hand has a pair if it contains two or more cards with the same rank.
    Write a `PokerHand` method that checks whether a hand contains a pair.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 一手扑克牌有一对，如果它包含两张或更多张同等级的牌。编写一个`PokerHand`方法，检查一手牌是否包含一对。
- en: To test your method, here’s a hand that has a pair.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试你的方法，这里有一个有一对的手牌。
- en: '[PRE98]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 17.12.7\. Exercise[#](#id5 "Link to this heading")
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.12.7\. 练习[#](#id5 "Link to this heading")
- en: A hand has a full house if it contains three cards of one rank and two cards
    of another rank. Write a `PokerHand` method that checks whether a hand has a full
    house.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一手牌有一个葫芦，如果它包含一组三张同一等级的牌和两张另一等级的牌。编写一个`PokerHand`方法，检查一手牌是否有葫芦。
- en: 17.12.8\. Exercise[#](#id6 "Link to this heading")
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 17.12.8\. 练习[#](#id6 "Link to this heading")
- en: This exercise is a cautionary tale about a common error that can be difficult
    to debug. Consider the following class definition.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习是一个关于一个常见错误的警示故事，这种错误往往很难调试。考虑以下的类定义。
- en: '[PRE106]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '`__init__` takes two parameters: `name` is required, but `contents` is optional
    – if it’s not provided, the default value is an empty list.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__`接受两个参数：`name`是必需的，但`contents`是可选的 - 如果没有提供，则默认值为空列表。'
- en: '`__str__` returns a string representation of the object that includes the name
    and the contents of the pouch.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`__str__`返回对象的字符串表示，包括袋子的名称和内容。'
- en: '`put_in_pouch` takes any object and appends it to `contents`.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`put_in_pouch`接受任何对象并将其附加到`contents`中。'
- en: Now let’s see how this class works. We’ll create two `Kangaroo` objects with
    the names `'Kanga'` and `'Roo'`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看这个类是如何工作的。我们将创建两个名为'Kanga'和'Roo'的`Kangaroo`对象。
- en: '[PRE107]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: To Kanga’s pouch we’ll add two strings and Roo.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向Kanga的袋子中添加两个字符串和Roo。
- en: '[PRE108]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: If we print `kanga`, it seems like everything worked.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打印`kanga`，似乎一切正常。
- en: '[PRE109]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: But what happens if we print `roo`?
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果我们打印`roo`会发生什么呢？
- en: '[PRE111]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Roo’s pouch contains the same contents as Kanga’s, including a reference to
    `roo`!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Roo的袋子里包含与Kanga的袋子相同的内容，包括对`roo`的引用！
- en: See if you can figure out what went wrong. Then ask a virtual assistant, “What’s
    wrong with the following program?” and paste in the definition of `Kangaroo`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你能否弄清楚哪里出了问题。然后问虚拟助手：“以下程序有什么问题？”并粘贴`Kangaroo`的定义。
- en: '[Think Python: 3rd Edition](https://allendowney.github.io/ThinkPython/index.html)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '[Think Python: 第3版](https://allendowney.github.io/ThinkPython/index.html)'
- en: Copyright 2024 [Allen B. Downey](https://allendowney.com)
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 版权所有 2024 [Allen B. Downey](https://allendowney.com)
- en: 'Code license: [MIT License](https://mit-license.org/)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 代码许可：[MIT 许可证](https://mit-license.org/)
- en: 'Text license: [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 文本许可：[创作共用 署名-非商业性使用-相同方式共享 4.0 国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/)
