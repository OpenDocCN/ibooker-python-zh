<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. Python Packages"><div class="chapter" id="chapter_packages">
<h1><span class="label">Chapter 3. </span>Python Packages</h1>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id262">
<h1>A Note for Early Release Readers</h1>
<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>

<p>This will be the third chapter of the final book. Please note that the GitHub repo will be made active later on.</p>

<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the author at <a href="mailto:mail@claudiojolowicz.com">mail@claudiojolowicz.com</a>.</p>
</div></aside>

<p>In this chapter you’ll learn how to package your Python projects for
distribution. A <em>package</em> is a single file containing an archive of your code
along with metadata that describes it, like the project name and version.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Python folks use the word <em>package</em> for two distinct concepts. <em>Import packages</em>
are modules that contain other modules. <em>Distribution packages</em> are archive
files for distributing Python software—​they’re the subject of this chapter.</p>
</div>

<p>You can install a package into a Python environment using a package installer
like pip. You can also upload it to a package repository for the benefit of
others. The Python Software Foundation (PSF) operates a package repository known
as the <a href="https://pypi.org/">Python Package Index</a> (PyPI). If your package is on
PyPI, anyone can install it by passing its project name to <code>pip install</code>.</p>

<p>Packaging your project makes it easy to share with others, but there’s another
benefit. When you install your package, it becomes a first-class citizen of a
Python environment:</p>

<ul>
<li>
<p>The interpreter imports your modules from the environment—​rather than an
arbitrary directory on your filesystem, which may or may not work depending on
how you invoke Python.</p>
</li>
<li>
<p>Installers use the package metadata to ensure the environment matches the
prerequisites of your package, such as the minimum Python version and any
third-party packages it depends on.</p>
</li>
<li>
<p>Installers can generate entry-point scripts that ensure your code always runs
on the interpreter in the environment. Compare this to hand-written Python
scripts, which may run on the wrong Python version, or without the required
third-party packages, or be unable to import their own modules.</p>
</li>
</ul>

<p>In this chapter, I’ll explain how you can package your Python projects and
introduce you to tools that help with packaging tasks. The chapter has three
parts:</p>

<ul>
<li>
<p>In the first part, I’ll talk about the life of a Python package. I’ll also
introduce an example application that you’ll use throughout this book. And
I’ll ask: why would you want to package your code at all?</p>
</li>
<li>
<p>In the second part, I’ll introduce Python’s package configuration file,
<em>pyproject.toml</em>, and tools for working with packages: <code>build</code>, <code>hatchling</code>,
and Twine. The tools pip, uv, and pipx also make a reappearance. Finally, I’ll
introduce Rye, a project manager that ties these packaging tools together into
a unified workflow. Along the way, you’ll learn about build frontends and
backends, wheels and sdists, editable installs, and the <em>src</em> layout.</p>
</li>
<li>
<p>In the third part, I’ll look at project metadata in detail—​the various fields
you can specify in <em>pyproject.toml</em> to define and describe your package, and
how to make efficient use of them.</p>
</li>
</ul>






<section data-type="sect1" data-pdf-bookmark="The Package Lifecycle"><div class="sect1" id="id93">
<h1>The Package Lifecycle</h1>

<p><a data-type="xref" href="#figure_packages_lifecycle">Figure 3-1</a> shows the typical lifecycle of a package.</p>

<figure><div id="figure_packages_lifecycle" class="figure">
<img src="assets/hmpt_0301.png" alt="The diagram shows how the author builds a project into a package and uploads it to a package index, while the user downloads and installs the package into an environment." width="2624" height="1003"/>
<h6><span class="label">Figure 3-1. </span>The package lifecycle: an author builds a project into a package and uploads it to a package index, and then a user downloads and installs the package into an environment.</h6>
</div></figure>
<dl class="calloutlist">
<dt><a class="co" href="#figure_packages_lifecycle"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd>
<p>Everything starts with a <em>project</em>: the source code of an application, library, or other piece of software.</p>
</dd>
<dt><a class="co" href="#figure_packages_lifecycle"><img src="assets/2.png" alt="2" width="12" height="12"/></a></dt>
<dd>
<p>As an author, your first step is to build a package from the project. The package is an installable artifact with a snapshot of your project at this point in time, identified by a unique name and version.</p>
</dd>
<dt><a class="co" href="#figure_packages_lifecycle"><img src="assets/3.png" alt="3" width="12" height="12"/></a></dt>
<dd>
<p>Next, you publish the package to a well-known repository such as PyPI.</p>
</dd>
<dt><a class="co" href="#figure_packages_lifecycle"><img src="assets/4.png" alt="4" width="12" height="12"/></a></dt>
<dd>
<p>A user can now fetch your package by specifying its name and version.</p>
</dd>
<dt><a class="co" href="#figure_packages_lifecycle"><img src="assets/5.png" alt="5" width="12" height="12"/></a></dt>
<dd>
<p>Finally, the user installs your package into their environment.</p>
</dd>
</dl>

<p>You can install a freshly built package directly into an environment, without
uploading it to a package repository first—​for example, when you’re testing
your package, or when you’re its only user.</p>

<p>In real life, tools often combine fetching and installing, building and
installing, and even building and publishing, into a single command.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="An Example Application"><div class="sect1" id="section_packages_example_application">
<h1>An Example Application</h1>

<p>Many applications start out as small, ad-hoc scripts.
<a data-type="xref" href="#example_packages_wikipedia">Example 3-1</a> fetches a random article from Wikipedia and
displays its title and summary in the console. The script restricts itself to
the standard library, so it runs in any Python 3 environment.</p>
<div id="example_packages_wikipedia" data-type="example">
<h5><span class="label">Example 3-1. </span>Displaying an extract from a random Wikipedia article</h5>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code><code> </code><code class="nn">json</code><code>
</code><code class="kn">import</code><code> </code><code class="nn">textwrap</code><code>
</code><code class="kn">import</code><code> </code><code class="nn">urllib</code><code class="nn">.</code><code class="nn">request</code><code>
</code><code>
</code><code class="n">API_URL</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">https://en.wikipedia.org/api/rest_v1/page/random/summary</code><code class="s2">"</code><code> </code><a class="co" id="co_python_packages_CO1-1" href="#callout_python_packages_CO1-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>
</code><code class="k">def</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="k">with</code><code> </code><code class="n">urllib</code><code class="o">.</code><code class="n">request</code><code class="o">.</code><code class="n">urlopen</code><code class="p">(</code><code class="n">API_URL</code><code class="p">)</code><code> </code><code class="k">as</code><code> </code><code class="n">response</code><code class="p">:</code><code> </code><a class="co" id="co_python_packages_CO1-2" href="#callout_python_packages_CO1-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a><code>
</code><code>        </code><code class="n">data</code><code> </code><code class="o">=</code><code> </code><code class="n">json</code><code class="o">.</code><code class="n">load</code><code class="p">(</code><code class="n">response</code><code class="p">)</code><code> </code><a class="co" id="co_python_packages_CO1-3" href="#callout_python_packages_CO1-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a><code>
</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="n">data</code><code class="p">[</code><code class="s2">"</code><code class="s2">title</code><code class="s2">"</code><code class="p">]</code><code class="p">,</code><code> </code><code class="n">end</code><code class="o">=</code><code class="s2">"</code><code class="se">\n</code><code class="se">\n</code><code class="s2">"</code><code class="p">)</code><code> </code><a class="co" id="co_python_packages_CO1-4" href="#callout_python_packages_CO1-4"><img src="assets/4.png" alt="4" width="12" height="12"/></a><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="n">textwrap</code><code class="o">.</code><code class="n">fill</code><code class="p">(</code><code class="n">data</code><code class="p">[</code><code class="s2">"</code><code class="s2">extract</code><code class="s2">"</code><code class="p">]</code><code class="p">)</code><code class="p">)</code><code> </code><a class="co" id="co_python_packages_CO1-5" href="#callout_python_packages_CO1-4"><img src="assets/4.png" alt="4" width="12" height="12"/></a><code>
</code><code>
</code><code class="k">if</code><code> </code><code class="vm">__name__</code><code> </code><code class="o">==</code><code> </code><code class="s2">"</code><code class="s2">__main__</code><code class="s2">"</code><code class="p">:</code><code>
</code><code>    </code><code class="n">main</code><code class="p">(</code><code class="p">)</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" id="callout_python_packages_CO1-1" href="#co_python_packages_CO1-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>The <code>API_URL</code> constant points to the REST API of the English Wikipedia—​or more specifically, its <code>/page/random/summary</code> endpoint.</p></dd>
<dt><a class="co" id="callout_python_packages_CO1-2" href="#co_python_packages_CO1-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>The <code>urllib.request.urlopen</code> invocation sends an HTTP GET request to the Wikipedia API. The <code>with</code> statement ensures that the connection is closed at the end of the block.</p></dd>
<dt><a class="co" id="callout_python_packages_CO1-3" href="#co_python_packages_CO1-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>The response body contains the resource data in JSON format. Conveniently, the response is a file-like object, so the <code>json</code> module can load it like a file from disk.</p></dd>
<dt><a class="co" id="callout_python_packages_CO1-4" href="#co_python_packages_CO1-4"><img src="assets/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>The <code>title</code> and <code>extract</code> keys hold the title of the Wikipedia page and a short plain text extract, respectively. The <code>textwrap.fill</code> function wraps the text so that every line is at most 70 characters long.</p></dd>
</dl>

<p>Store this script in a file called <em>random_wikipedia_article.py</em> and take
it for a spin. Here’s a sample run:</p>
<pre data-type="programlisting">&gt; <strong>py -m random_wikipedia_article</strong>
Jägersbleeker Teich

The Jägersbleeker Teich in the Harz Mountains of central Germany
is a storage pond near the town of Clausthal-Zellerfeld in the
county of Goslar in Lower Saxony. It is one of the Upper Harz Ponds
that were created for the mining industry.
</pre>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Why Packaging?"><div class="sect1" id="id95">
<h1>Why Packaging?</h1>

<p>Sharing a script like <a data-type="xref" href="#example_packages_wikipedia">Example 3-1</a> doesn’t require packaging.
You can publish it on a blog or a hosted repository, or send it to friends by
email or chat. Python’s ubiquity, the “batteries included” approach of its
standard library, and its nature as an interpreted language make this possible.</p>

<p>The ease of sharing modules with the world was a boon to Python’s adoption in
the early days. The Python programming language predates the advent of
language-specific package repositories—​PyPI didn’t come about for more than a
decade.<sup><a data-type="noteref" id="id263-marker" href="ch03.html#id263">1</a></sup></p>

<p>Distributing self-contained modules without packaging them seems like a great
idea at first: You keep your projects free of packaging cruft. They require no
separate artifacts, no intermediate steps like building, and no dedicated
tooling. But using modules as the unit of distribution comes with limitations:</p>
<dl>
<dt>Projects composed of multiple modules</dt>
<dd>
<p>When your project outgrows a single-file script, you should break it up—​but
installing a collection of files is cumbersome for your users. Packaging lets
you keep everything in a single file for distribution.</p>
</dd>
<dt>Projects with third-party dependencies</dt>
<dd>
<p>Python has a rich ecosystem of third-party packages, so you’re standing on the
shoulders of giants. But your users shouldn’t need to worry about installing
the correct version of every package you require. Packaging lets you declare
dependencies on other packages, which installers satisfy automatically.</p>
</dd>
<dt>Finding the project</dt>
<dd>
<p>What’s the repository URL of that useful module again? Or was it on a blog? If
you publish a package on PyPI, your users only need to know its name to
install the latest version. The situation is similar in a corporate
environment, where developers’ machines are configured to use a company-wide
package repository.</p>
</dd>
<dt>Installing the project</dt>
<dd>
<p>Downloading and double-clicking a script won’t work much of the time. You
shouldn’t need to place modules in arcane directories and perform a special
dance so your script executes on the correct interpreter. Packaging lets users
install your project with a single command, in a portable and safe way.</p>
</dd>
<dt>Updating the project</dt>
<dd>
<p>Users need to determine if the project is up-to-date and upgrade it to the
latest version if it isn’t. As an author, you need a way to let your users
benefit from new features, bug fixes, and improvements. Package repositories
let you publish a stream of releases for your project (a subset of the
development snapshots you’d get from its code repository.)</p>
</dd>
<dt>Running the project in the correct environment</dt>
<dd>
<p>Don’t leave it up to chance if your program runs on a supported Python
version, with the required third-party packages. Package installers check and,
where possible, satisfy your prerequisites. They also ensure that your code
runs in the environment intended for it.</p>
</dd>
<dt>Binary extensions</dt>
<dd>
<p>Python modules written in a compiled language like C or Rust require a build
step. Packaging lets you distribute pre-built binaries for common platforms.
Additionally, it lets you publish a source archive as a fallback; installers
run the build step on the end user’s machine.</p>
</dd>
<dt>Metadata</dt>
<dd>
<p>You can embed metadata inside a module, using attributes like <code>__author__</code>,
<code>__version__</code>, or <code>__license__</code>. But then tools have to execute the module to
read those attributes. Packages contain static metadata that any tool can read
without running Python.</p>
</dd>
</dl>

<p>As you’ve seen, packaging solves many problems, but what’s the overhead? In
short, you drop a declarative file named <em>pyproject.toml</em> into your project—​a
standard file that specifies the project metadata and its build system. In
return, you get commands to build, publish, and install your package.</p>

<p>In summary, Python packages come with many advantages:</p>

<ul>
<li>
<p>You can easily install and upgrade them</p>
</li>
<li>
<p>You can publish them in a package repository</p>
</li>
<li>
<p>They can depend on other packages</p>
</li>
<li>
<p>They run in an environment that satisfies their requirements</p>
</li>
<li>
<p>They can contain multiple modules</p>
</li>
<li>
<p>They can contain pre-built binary extensions</p>
</li>
<li>
<p>They can contain source distributions with automated build steps</p>
</li>
<li>
<p>They come with metadata that describes the package</p>
</li>
</ul>
</div></section>






<section data-type="sect1" data-pdf-bookmark="The pyproject.toml File"><div class="sect1" id="id96">
<h1>The pyproject.toml File</h1>

<p><a data-type="xref" href="#example_packages_pyproject_toml_small">Example 3-2</a> shows how to package the script from
<a data-type="xref" href="#example_packages_wikipedia">Example 3-1</a> with a bare minimum of metadata—​the project name
and version—​as well as an entry-point script. The project and the script use
hyphens (<code>random-wikipedia-article</code>), while the module uses underscores
(<code>random_wikipedia_article</code>). Place the module and the <em>pyproject.toml</em> file
side-by-side in an empty directory.</p>
<div id="example_packages_pyproject_toml_small" data-type="example">
<h5><span class="label">Example 3-2. </span>A minimal pyproject.toml file</h5>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project]</code><code class="w"/>
<code class="n">name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"random-wikipedia-article"</code><code class="w"/>
<code class="n">version</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"0.1"</code><code class="w"/>

<code class="k">[project.scripts]</code><code class="w"/>
<code class="n">random-wikipedia-article</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"random_wikipedia_article:main"</code><code class="w"/>

<code class="k">[build-system]</code><code class="w"/>
<code class="n">requires</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"hatchling"</code><code class="p">]</code><code class="w"/>
<code class="n">build-backend</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"hatchling.build"</code><code class="w"/></pre></div>
<div data-type="tip"><h6>Tip</h6>
<p>PyPI projects share a single namespace—​their names aren’t scoped by the users
or organizations owning the projects. Choose a unique name such as
<code>random-wikipedia-article-{your-name}</code>, and rename the Python module
accordingly.</p>
</div>

<p>At the top level, the <em>pyproject.toml</em> file can contain up to three sections—​or
<em>tables</em>, as the TOML standard calls them:</p>
<dl>
<dt><code>[project]</code></dt>
<dd>
<p>The <code>project</code> table holds the project metadata. The <code>name</code> and <code>version</code>
fields are mandatory. For real projects, you should provide additional
information, such as a description, the license, and the required Python
version (see <a data-type="xref" href="#section_packages_project_metadata">“Project Metadata”</a>). The <code>scripts</code> section
declares the name of the entry-point script and the function it should call.</p>
</dd>
<dt><code>[build-system]</code></dt>
<dd>
<p>The <code>build-system</code> table specifies how to build packages for the project (see
<a data-type="xref" href="#section_packages_build">“Building Packages with build”</a>)—specifically, which build tool your project uses.
I’ve opted for <code>hatchling</code> here, which comes with
<a href="https://hatch.pypa.io/">Hatch</a>, a modern and standards-compliant Python project
manager.</p>
</dd>
<dt><code>[tool]</code></dt>
<dd>
<p>The <code>tool</code> table stores configurations for each tool used by the project. For
example, the Ruff linter reads its configuration from the <code>[tool.ruff]</code> table,
while the type checker mypy uses <code>[tool.mypy]</code>.</p>
</dd>
</dl>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_packages_toml">
<h1>The TOML format</h1>
<p>Python’s project specification file uses <em>TOML</em> (Tom’s Obvious Minimal
Language), a cross-language format for configuration files that’s both
unambiguous and human-readable. The <a href="https://toml.io/">TOML website</a> has a good
introduction to the format.</p>

<p>Lists are termed <em>arrays</em> in TOML and use the same notation as Python:</p>

<pre data-type="programlisting" data-code-language="toml"><code class="n">requires</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"hatchling"</code><code class="p">,</code><code class="w"> </code><code class="s2">"hatch-vcs"</code><code class="p">]</code><code class="w"/></pre>

<p>Dictionaries are known as <em>tables</em> and come in several equivalent forms. You can
put the key/value pairs on separate lines, preceded by the table name in square
brackets:</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project]</code><code class="w"/>
<code class="n">name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"foo"</code><code class="w"/>
<code class="n">version</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"0.1"</code><code class="w"/></pre>

<p>Inline tables contain all key/value pairs on the same line:</p>

<pre data-type="programlisting" data-code-language="toml"><code class="n">project</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">name</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s2">"foo"</code><code class="p">,</code><code class="w"> </code><code class="n">version</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s2">"0.1"</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>

<p>You can also use dotted notation to create a table implicitly:</p>

<pre data-type="programlisting" data-code-language="toml"><code class="n">project</code><code class="p">.</code><code class="n">name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"foo"</code><code class="w"/>
<code class="n">project</code><code class="p">.</code><code class="n">version</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"0.1"</code><code class="w"/></pre>

<p>You can load a TOML file using the standard <code>tomllib</code> module:</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code><code> </code><code class="nn">tomllib</code><code>
</code><code>
</code><code class="k">with</code><code> </code><code class="nb">open</code><code class="p">(</code><code class="s2">"</code><code class="s2">pyproject.toml</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="n">mode</code><code class="o">=</code><code class="s2">"</code><code class="s2">rb</code><code class="s2">"</code><code class="p">)</code><code> </code><code class="k">as</code><code> </code><code class="n">io</code><code class="p">:</code><code> </code><a class="co" id="co_python_packages_CO2-1" href="#callout_python_packages_CO2-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>    </code><code class="n">data</code><code> </code><code class="o">=</code><code> </code><code class="n">tomllib</code><code class="o">.</code><code class="n">load</code><code class="p">(</code><code class="n">io</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_python_packages_CO2-1" href="#co_python_packages_CO2-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Always open the file in binary mode. TOML mandates UTF-8 character encoding;
on older platforms, opening the file in text mode can lead to garbled text (or
<em>mojibake</em>, as it’s affectionately known).</p></dd>
</dl>

<p>Python represents a TOML file as a dictionary, where keys are strings and values
can be strings, integers, floats, dates, times, lists, or dictionaries. Here’s
what a <em>pyproject.toml</em> file looks like in Python:</p>

<pre data-type="programlisting" data-code-language="python"><code class="p">{</code>
  <code class="s2">"project"</code><code class="p">:</code> <code class="p">{</code>
    <code class="s2">"name"</code><code class="p">:</code> <code class="s2">"random-wikipedia-article"</code><code class="p">,</code>
    <code class="s2">"version"</code><code class="p">:</code> <code class="s2">"0.1"</code><code class="p">,</code>
    <code class="s2">"scripts"</code><code class="p">:</code> <code class="p">{</code>
        <code class="s2">"random-wikipedia-article"</code><code class="p">:</code> <code class="s2">"random_wikipedia_article:main"</code>
    <code class="p">}</code>
  <code class="p">},</code>
  <code class="s2">"build-system"</code><code class="p">:</code> <code class="p">{</code>
    <code class="s2">"requires"</code><code class="p">:</code> <code class="p">[</code><code class="s2">"hatchling"</code><code class="p">],</code>
    <code class="s2">"build-backend"</code><code class="p">:</code> <code class="s2">"hatchling.build"</code>
  <code class="p">}</code>
<code class="p">}</code></pre>
</div></aside>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Building Packages with build"><div class="sect1" id="section_packages_build">
<h1>Building Packages with build</h1>

<p>Let’s create a package for your new project using <code>build</code>, a dedicated build
frontend maintained by the Python Packaging Authority (PyPA). The PyPA is a
group of volunteers that maintains a core set of software projects used in
Python packaging.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A <em>build frontend</em> is an application that orchestrates the build process for a
Python package. Build frontends don’t know how to assemble packaging artifacts
from source trees. The tool that does the actual building is known as the <em>build
backend</em>.</p>
</div>

<p>Open a terminal, change to the project directory, and invoke <code>build</code> with pipx:</p>
<pre data-type="programlisting">$ <strong>pipx run build</strong>
* Creating venv isolated environment...
* Installing packages in isolated environment... (hatchling)
* Getting build dependencies for sdist...
* Building sdist...
* Building wheel from sdist
* Creating venv isolated environment...
* Installing packages in isolated environment... (hatchling)
* Getting build dependencies for wheel...
* Building wheel...
Successfully built random_wikipedia_article-0.1.tar.gz
 and random_wikipedia_article-0.1-py2.py3-none-any.whl</pre>

<p>By default, <code>build</code> creates two kinds of packages for a project, an sdist and a
wheel (see <a data-type="xref" href="#section_packages_wheels_and_sdists">“Wheels and Sdists”</a>). You can find these files in
the <em>dist</em> directory of your project.</p>

<p>As you can see in the output above, <code>build</code> delegates the actual work to
<code>hatchling</code>, the build backend you designated in
<a data-type="xref" href="#example_packages_pyproject_toml_small">Example 3-2</a>. A build frontend uses the
<code>build-system</code> table to determine the build backend for the project
(<a data-type="xref" href="#table_packages_build_system">Table 3-1</a>).</p>
<table id="table_packages_build_system">
<caption><span class="label">Table 3-1. </span>The <code>build-system</code> table</caption>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>requires</code></p></td>
<td><p>array of strings</p></td>
<td><p>The list of packages required to build the project</p></td>
</tr>
<tr>
<td><p><code>build-backend</code></p></td>
<td><p>string</p></td>
<td><p>The import name of the build backend in the format <code>package.module:object</code></p></td>
</tr>
<tr>
<td><p><code>build-path</code></p></td>
<td><p>string</p></td>
<td><p>An entry for <code>sys.path</code> needed to import the build backend (optional)</p></td>
</tr>
</tbody>
</table>

<p><a data-type="xref" href="#figure_packages_build">Figure 3-2</a> shows how the build frontend and the build backend
collaborate to build a package.</p>

<figure><div id="figure_packages_build" class="figure">
<img src="assets/hmpt_0302.png" alt="The diagram shows how the build frontend orchestrates a package build, by creating a build environment as well as installing and running the build backend." width="2596" height="1232"/>
<h6><span class="label">Figure 3-2. </span>Build frontend and build backend</h6>
</div></figure>
<dl class="calloutlist">
<dt><a class="co" href="#figure_packages_build"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd>
<p>The build frontend creates a virtual environment, the <em>build environment</em>.</p>
</dd>
<dt><a class="co" href="#figure_packages_build"><img src="assets/2.png" alt="2" width="12" height="12"/></a></dt>
<dd>
<p>The build frontend installs the packages listed under <code>requires</code>: the build
backend itself as well as, optionally, plugins for that backend. These packages
are known as the <em>build dependencies</em>.</p>
</dd>
<dt><a class="co" href="#figure_packages_build"><img src="assets/3.png" alt="3" width="12" height="12"/></a></dt>
<dd>
<p>The build frontend triggers the actual package build, in two steps. First,
it imports the module or object declared in <code>build-backend</code>. Second, it invokes
well-known functions for creating packages and related tasks, known as <em>build
hooks</em>.</p>
</dd>
</dl>

<p>Here’s a simplified version of the commands the build frontend performs when you
build a wheel for your project:<sup><a data-type="noteref" id="id264-marker" href="ch03.html#id264">2</a></sup></p>
<pre data-type="programlisting">$ <strong>py -m venv buildenv</strong>
$ <strong>buildenv/bin/python -m pip install hatchling</strong>
$ <strong>buildenv/bin/python</strong>
&gt;&gt;&gt; <strong>import hatchling.build as backend</strong>
&gt;&gt;&gt; <strong>backend.get_requires_for_build_wheel()</strong>
[]  # no additional build dependencies requested
&gt;&gt;&gt; <strong>backend.build_wheel("dist")</strong>
'random_wikipedia_article-0.1-py2.py3-none-any.whl'
</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Some build frontends let you build in your current environment. If you disable
build isolation, the frontend only checks for build dependencies. If it
installed them, the build and runtime dependencies of different packages might
conflict.</p>
</div>

<p>Why separate the build frontend from the build backend? It means that tools can
trigger package builds without knowing the intricacies of the build process. For
example, package installers like pip and uv build packages on the fly when you
install from a source directory (see
<a data-type="xref" href="#section_packages_installing_from_source">“Installing Projects from Source”</a>).</p>

<p>Standardizing the contract between build frontends and build backends has
brought tremendous diversity and innovation to the packaging ecosystem. Build
frontends include <code>build</code>, pip, and uv, the backend-agnostic Python project
managers Rye, Hatch, and <a href="https://pdm-project.org/latest/">PDM</a>, and test
automation tools like <a href="https://tox.wiki/en/4.14.2/">tox</a>. Build backends include
those shipped with the project managers <a href="https://flit.pypa.io/">Flit</a>, Hatch, PDM,
and <a href="https://python-poetry.org/">Poetry</a>, the traditional build backend
<a href="https://setuptools.pypa.io/">setuptools</a>, as well as exotic builders like
<a href="https://www.maturin.rs/">Maturin</a>, a build backend for Python modules written in
the Rust programming language, and
<a href="https://sphinx-theme-builder.readthedocs.io/">Sphinx Theme Builder</a>, a build
backend for Sphinx documentation themes (<a data-type="xref" href="#table_packages_build_backends">Table 3-2</a>).</p>
<table id="table_packages_build_backends">
<caption><span class="label">Table 3-2. </span>Build backends</caption>
<thead>
<tr>
<th>Project</th>
<th><code>requires</code><sup><a data-type="noteref" id="id265-marker" href="ch03.html#id265">a</a></sup></th>
<th><code>build-backend</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Flit</p></td>
<td><p><code>flit-core</code></p></td>
<td><p><code>flit_core.buildapi</code></p></td>
</tr>
<tr>
<td><p>Hatch</p></td>
<td><p><code>hatchling</code></p></td>
<td><p><code>hatchling.build</code></p></td>
</tr>
<tr>
<td><p>Maturin</p></td>
<td><p><code>maturin</code></p></td>
<td><p><code>maturin</code></p></td>
</tr>
<tr>
<td><p>PDM</p></td>
<td><p><code>pdm-backend</code></p></td>
<td><p><code>pdm.backend</code></p></td>
</tr>
<tr>
<td><p>Poetry</p></td>
<td><p><code>poetry-core</code></p></td>
<td><p><code>poetry.core.masonry.api</code></p></td>
</tr>
<tr>
<td><p>Setuptools</p></td>
<td><p><code>setuptools</code></p></td>
<td><p><code>setuptools.build_meta</code></p></td>
</tr>
<tr>
<td><p>Sphinx Theme Builder</p></td>
<td><p><code>sphinx-theme-builder</code></p></td>
<td><p><code>sphinx_theme_builder</code></p></td>
</tr>
</tbody>
<tbody><tr class="footnotes"><td colspan="3"><p data-type="footnote" id="id265"><sup><a href="ch03.html#id265-marker">a</a></sup> See the official documentation of each tool for any recommended version bounds</p></td></tr></tbody></table>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Uploading Packages with Twine"><div class="sect1" id="section_packages_twine">
<h1>Uploading Packages with Twine</h1>

<p>It’s time to publish your package. In this section, you’ll use
<a href="https://test.pypi.org">TestPyPI</a>, a separate instance of the Python Package Index
intended for testing and experimentation. Just omit the <code>--repository</code> and
<code>--index-url</code> options below to use the real PyPI.</p>

<p>First, register an account using the link on the front page of TestPyPI. Second,
create an API token from your account page and copy the token to your preferred
password manager. You can now upload the packages in <em>dist</em> using Twine, the
official PyPI upload tool.</p>
<pre data-type="programlisting">$ <strong>pipx run twine upload --repository=testpypi dist/*</strong>
Uploading distributions to https://test.pypi.org/legacy/
Enter your API token: <strong>*********</strong>
Uploading random_wikipedia_article-0.1-py2.py3-none-any.whl
Uploading random_wikipedia_article-0.1.tar.gz

View at:
https://test.pypi.org/project/random-wikipedia-article/0.1/</pre>

<p>Congratulations, you have published your first Python package! Let’s install the
package from TestPyPI:</p>
<pre data-type="programlisting">$ <strong>pipx install --index-url=https://test.pypi.org/simple random-wikipedia-article</strong>
  installed package random-wikipedia-article 0.1, installed using Python 3.12.2
  These apps are now globally available
    - random-wikipedia-article
done!
</pre>

<p>You’re now able to invoke your application from anywhere:</p>
<pre data-type="programlisting">$ <strong>random-wikipedia-article</strong></pre>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Installing Projects from Source"><div class="sect1" id="section_packages_installing_from_source">
<h1>Installing Projects from Source</h1>

<p>If you distribute packages for your project, it’s a good idea to install these
packages locally for development and testing. Running tests against an installed
package rather than the source code means you’re testing your project the way
your users see it. And if you’re working on a service, it helps keep
development, staging, and production as similar as possible.</p>

<p>You <em>could</em> build a wheel with <code>build</code> and install it into a virtual
environment:</p>
<pre data-type="programlisting">$ <strong>pipx run build</strong>
$ <strong>uv venv</strong>
$ <strong>uv pip install dist/*.whl</strong></pre>

<p>There’s a shortcut for this, though. Both pip and uv can install your project
directly from a source directory, such as <code>.</code> for the current directory. Behind
the scenes, they use the project’s build backend to create a wheel for
installation—​they’re build frontends just like <code>build</code>:</p>
<pre data-type="programlisting">$ <strong>uv venv</strong>
$ <strong>uv pip install .</strong></pre>

<p>If your project comes with an entry-point script, you can also install it with
pipx:</p>
<pre data-type="programlisting">$ <strong>pipx install .</strong>
  installed package random-wikipedia-article 0.1, installed using Python 3.10.8
  These apps are now globally available
    - random-wikipedia-article</pre>








<section data-type="sect2" data-pdf-bookmark="Editable Installs"><div class="sect2" id="section_packages_editable_installs">
<h2>Editable Installs</h2>

<p>During development, it saves time to see code changes reflected in the
environment immediately, without repeatedly installing the project. You could
import your modules directly from the source tree—​but you’d lose all the
benefits of packaging your project.</p>

<p><em>Editable installs</em> achieve the best of both worlds by installing your package
in a special way that redirects imports to the source tree (see
<a data-type="xref" href="ch02.html#section_environments_site_packages">“Site Packages”</a>). You can think of this mechanism as a
kind of “hot reloading” for Python packages. The <code>--editable</code> option (<code>-e</code>)
works with uv, pip, and pipx:</p>
<pre data-type="programlisting">$ <strong>uv pip install --editable .</strong>
$ <strong>py -m pip install --editable .</strong>
$ <strong>pipx install --editable .</strong>
</pre>

<p>Once you’ve installed your package in this way, you won’t need to reinstall it
to see changes to the source code—​only when you edit <em>pyproject.toml</em> to change
the project metadata or add a third-party dependency.</p>

<p>Editable installs are modeled after the <em>development mode</em> feature from
setuptools, if you’ve been around long enough to be familiar with it. But unlike
<code>setup.py develop</code>, they rely on standard build hooks that any build backend can
provide.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Project Layout"><div class="sect1" id="section_packages_layout">
<h1>Project Layout</h1>

<p>Dropping a <em>pyproject.toml</em> next to a single-file module is an appealingly
simple approach. Unfortunately, this project layout comes with a serious
footgun, as you’ll see in this section. Let’s start by breaking something in the
project:</p>

<pre data-type="programlisting" data-code-language="python"><code class="k">def</code> <code class="nf">main</code><code class="p">():</code>
    <code class="k">raise</code> <code class="ne">Exception</code><code class="p">(</code><code class="s2">"Boom!"</code><code class="p">)</code></pre>

<p>Before publishing your package, run a last smoke test with a locally built
wheel:</p>
<pre data-type="programlisting">$ <strong>pipx run build</strong>
$ <strong>uv venv</strong>
$ <strong>uv pip install dist/*.whl</strong>
$ <strong>py -m random_wikipedia_article</strong>
Exception: Boom!
</pre>

<p>A bug found is a bug fixed. After removing the offending line, verify that the
program works as expected:</p>
<pre data-type="programlisting">$ <strong>py -m random_wikipedia_article</strong>
Cystiscus viaderi

Cystiscus viaderi is a species of very small sea snail, a marine
gastropod mollusk or micromollusk in the family Cystiscidae.</pre>

<p>All good, time to cut a release! First, push your fix and a Git tag for the new
version to your code repository. Next, use Twine to upload the wheel to PyPI:</p>
<pre data-type="programlisting">$ <strong>pipx run twine upload dist/*</strong></pre>

<p>But, oh no—​you never rebuilt the wheel. That bug is now in a public release!
How could that happen?</p>

<p>Running your application with <code>py -m</code> protects you from inadvertently running an
entry-point script from another installation (and it has the advantage of not
requiring an active environment on macOS and Linux). But it also adds the
current directory to the front of <code>sys.path</code> (see
<a data-type="xref" href="ch02.html#section_environments_site_packages">“Site Packages”</a>). All along, you’ve been testing the
module in your source tree, not the wheel you were going to publish!</p>

<p>You could set the <code>PYTHONSAFEPATH</code> environment variable and never think about
this again—​it’s an alias for <code>py -P</code> and omits the current directory from the
module path. But that would leave your contributors out in the cold—​and
yourself, whenever you’re working on another machine.</p>

<p>Instead, move your module out of the top-level directory so folks can’t import
it by mistake. By convention, Python source trees go into the <em>src</em>
directory—​which is why the arrangement is known as <em>src layout</em> in the Python
community.</p>

<p>At this point, it also makes sense to convert your single-file module into an
import package. Replace the <em>random_wikipedia_article.py</em> file by a
<em>random_wikipedia_article</em> directory with a <em>__init__.py</em> module.</p>

<p>Placing your code in an import package is mostly equivalent to having it in a
single-file module—​but there’s one difference: you can’t run the application
with <code>py -m random_wikipedia_article</code> unless you also add the special
<em>__main__.py</em> module to the package (<a data-type="xref" href="#example_packages_main">Example 3-3</a>).</p>
<div id="example_packages_main" data-type="example">
<h5><span class="label">Example 3-3. </span>The <em>__main__.py</em> module</h5>

<pre data-type="programlisting" data-code-language="python"><code class="kn">from</code> <code class="nn">random_wikipedia_article</code> <code class="kn">import</code> <code class="n">main</code>

<code class="n">main</code><code class="p">()</code></pre></div>

<p>The <em>__main__.py</em> module replaces the <code>if __name__ == "__main__"</code> block in
<em>__init__.py</em>. Remove that block from the module.</p>

<p>This leaves you with a classic initial project structure:</p>

<pre data-type="programlisting">random-wikipedia-article
├── pyproject.toml
└── src
    └── random_wikipedia_article
        ├── __init__.py
        └── __main__.py</pre>

<p>An import package makes it easier for your project to grow: you can move code
into separate modules and import it from there. For example, you could extract
the code that talks to the Wikipedia API into a function <code>fetch</code>. Next, you
might move the function to a module <em>fetch.py</em> in the package. Here’s how you’d
import the function from <em>__init__.py</em>:</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">from</code> <code class="nn">random_wikipedia_article.fetch</code> <code class="kn">import</code> <code class="n">fetch</code></pre>

<p>Eventually, <em>__init__.py</em> will only contain <code>import</code> statements for your
public API.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Managing Packages with Rye"><div class="sect1" id="section_packages_rye">
<h1>Managing Packages with Rye</h1>

<p>Many modern programming languages come with a single tool for building,
packaging, and other development tasks. You may wonder how the Python community
ended up with so many packaging tools with disjoint responsibilities.</p>

<p>The answer has to do with the nature and history of the Python project: Python
is a decentralized open source project driven by a community of thousands of
volunteers, with a history spanning more than three decades of organic growth.
This makes it hard for a single packaging tool to cater to all demands and
become firmly established.<sup><a data-type="noteref" id="id266-marker" href="ch03.html#id266">3</a></sup></p>

<p>Python’s strength lies in its rich ecosystem—​and interoperability standards
promote this diversity. As a Python developer, you have a choice of small
single-purpose tools that play well together. This approach ties in with the
Unix philosophy of “Do one thing, and do it well.”</p>

<p>But the Unix approach is no longer your only choice. <em>Python project managers</em>
provide a more integrated workflow. Among the first, Poetry (see
<a data-type="xref" href="ch05.html#chapter_poetry">Chapter 5</a>) has set itself the goal of reinventing Python packaging and
pioneered ideas such as static metadata and cross-platform lock files.</p>

<p><a href="https://rye-up.com/">Rye</a>, a Python project manager written in Rust, chooses a
different path. It provides a unified development experience on top of the
widely-used single-purpose tools you’ve already seen (and are about to see) in
this book. Started by Armin Ronacher as a private project and first released to
the public in 2023, it’s now under the stewardship of Astral, the company behind
Ruff and uv.</p>

<p>Please see Rye’s official documentation for installation instructions.</p>

<p>Your first step with Rye is initializing a new project with <code>rye init</code>. If you
don’t pass the project name, Rye uses the name of the current directory. Use the
<code>--script</code> option to include an entry-point script:</p>
<pre data-type="programlisting">$ <strong>rye init random-wikipedia-article --script</strong></pre>

<p>Rye initializes a Git repository in <em>random-wikipedia-article</em> and populates it
with a <em>pyproject.toml</em> file, an import package <code>random_wikipedia_article</code> in
the <em>src</em> directory, a <em>README.md</em> with the project description, a
<em>.python-version</em> file with the default Python version, and a virtual
environment in <em>.venv</em>. Rye supports various build backends, with <code>hatchling</code> as
the default choice.</p>

<pre data-type="programlisting">random-wikipedia-article
├── .git
├── .gitignore
├── .python-version
├── .venv
├── README.md
├── pyproject.toml
└── src
    └── random_wikipedia_article
        ├── __init__.py
        └── __main__.py</pre>

<p>Many of Rye’s commands are frontends to tools that have become a de-facto
standard in the Python world, or that promise to become one in the future. The
command <code>rye build</code> creates packages with <code>build</code>, the command <code>rye publish</code>
uploads them using Twine, and the command <code>rye sync</code> performs an editable
install using uv:</p>
<pre data-type="programlisting">$ <strong>rye build</strong>
$ <strong>rye publish --repository testpypi --repository-url https://test.pypi.org/legacy/</strong>
$ <strong>rye sync</strong></pre>

<p>There’s much more to <code>rye sync</code>, though. Rye manages private Python
installations using the Python Standalone Builds project (see
<a data-type="xref" href="ch01.html#section_python_brave">“A Brave New World: Installing with Hatch and Rye”</a>), and <code>rye sync</code> fetches each Python version on
first use. The command also generates a lock file for the project dependencies
and synchronizes the environment with that file (see <a data-type="xref" href="ch04.html#chapter_dependencies">Chapter 4</a>).</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Wheels and Sdists"><div class="sect1" id="section_packages_wheels_and_sdists">
<h1>Wheels and Sdists</h1>

<p>In <a data-type="xref" href="#section_packages_build">“Building Packages with build”</a>, <code>build</code> created two packages for your project:</p>

<ul>
<li>
<p><em>random_wikipedia_article-0.1.tar.gz</em></p>
</li>
<li>
<p><em>random_wikipedia_article-0.1-py2.py3-none-any.whl</em></p>
</li>
</ul>

<p>These artifacts are known as <em>wheels</em> and <em>sdists</em>. Wheels are ZIP archives with
a <em>.whl</em> extension, and they’re <em>built distributions</em>—for the most part,
installers extract them into the environment as-is. Sdists, by contrast, are
<em>source distributions</em>: they’re compressed archives of the source code with
packaging metadata. Sdists require an additional build step to produce an
installable wheel.</p>
<div data-type="tip"><h6>Tip</h6>
<p>The name “wheel” for a Python package is a reference to wheels of cheese. PyPI
was originally known as the <em>Cheese Shop</em>, after the Monty Python sketch about a
cheese shop with no cheese whatsoever. (These days, PyPI serves over a petabyte
of packages per day.)</p>
</div>

<p>The distinction between source distributions and built distributions may seem
strange for an interpreted language like Python. But you can also write Python
modules in a compiled language. In this situation, source distributions provide
a useful fallback when no pre-built wheels are available for a platform.</p>

<p>As a package author, you should build and publish both sdists and wheels for
your releases. This gives users a choice: They can fetch and install the wheel
if their environment is compatible (which is always the case for a pure Python
package)—or they can fetch the sdist and build a wheel from it locally (see
<a data-type="xref" href="#figure_packages_wheels_and_sdists">Figure 3-3</a>).</p>

<figure><div id="figure_packages_wheels_and_sdists" class="figure">
<img src="assets/hmpt_0303.png" alt="The diagram shows how the author builds and publishes an sdist and a wheel. Users either download and install the wheel, or they download the sdist and build and install a wheel from it." width="4353" height="2000"/>
<h6><span class="label">Figure 3-3. </span>Wheels and sdists</h6>
</div></figure>

<p>For consumers of packages, sdists come with a few caveats. First, the build step
involves arbitrary code execution, which can be a security
concern.<sup><a data-type="noteref" id="id267-marker" href="ch03.html#id267">4</a></sup> Second, installing wheels is much faster than
installing sdists, especially for legacy <em>setup.py</em>-based packages. Lastly,
users may encounter confusing build errors for extension modules if they don’t
have the required build toolchain on their system.</p>

<p>Generally, a pure Python package has a single sdist and a single wheel for a
given release. Binary extension modules, on the other hand, commonly come in
wheels for a range of platforms and environments.</p>
<div data-type="tip"><h6>Tip</h6>
<p>If you’re an author of extension modules, check out the <code>cibuildwheel</code> project:
it automates the building and testing of wheels across multiple platforms, with
support for GitHub Actions and various other continuous integration (CI)
systems.</p>
</div>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_packages_wheel_compatibility_tags">
<h1>Wheel Compatibility Tags</h1>
<p>Installers select the appropriate wheel for an environment using three so-called
<em>compatibility tags</em> that are embedded in the name of each wheel file:</p>
<dl>
<dt>Python tag</dt>
<dd>
<p>The target Python implementation</p>
</dd>
<dt>ABI tag</dt>
<dd>
<p>The target <em>application binary interface</em> (ABI) of Python, which defines the
set of symbols that binary extension modules can use to interact with the
interpreter</p>
</dd>
<dt>Platform tag</dt>
<dd>
<p>The target platform, including the processor architecture</p>
</dd>
</dl>

<p>Pure Python wheels are usually compatible with any Python implementation, do not
require a particular ABI, and are portable across platforms. Wheels express such
wide compatibility using the tags <code>py3-none-any</code>.</p>

<p>Wheels with binary extension modules, on the other hand, have more stringent
compatibility requirements. Take a look at the compatibility tags of these
wheels, for example:</p>
<dl>
<dt>numpy-1.24.0-cp311-cp311-macosx_10_9_x86_64.whl</dt>
<dd>
<p>NumPy is a fundamental library for scientific computing. Its wheel targets a
specific Python implementation and version (CPython 3.11), operating system
release (macOS 10.9 and above), and processor architecture (x86-64).</p>
</dd>
<dt>cryptography-38.0.4-cp36-abi3-manylinux_2_28_x86_64.whl</dt>
<dd>
<p>Cryptography is another fundamental library, with an interface to
cryptographic algorithms. Its wheel demonstrates two ways to reduce the build
matrix for binary distributions: The <em>stable ABI</em> is a restricted set of
symbols that are guaranteed to persist across Python feature versions
(<code>abi3</code>), and the <code>manylinux</code> tag advertises compatibility with a particular C
standard library implementation (glibc 2.28 and above) across a wide range of
Linux distributions.</p>
</dd>
</dl>
</div></aside>








<section data-type="sect2" data-pdf-bookmark="Core Metadata"><div class="sect2" id="id104">
<h2>Core Metadata</h2>

<p>If you’re curious, you can extract a wheel using the <code>unzip</code> utility to see the
files installers place in the <em>site-packages</em> directory. Execute the following
commands in a shell on Linux or macOS—​preferably inside an empty directory. If
you’re on Windows, you can follow along using the Windows Subsystem for Linux
(WSL).</p>
<pre data-type="programlisting">$ <strong>py -m pip download attrs</strong>
$ <strong>unzip *.whl</strong>
$ <strong>ls -1</strong>
attr
attrs
attrs-23.2.0.dist-info
attrs-23.2.0-py3-none-any.whl

$ <strong>head -n4 attrs-23.2.0.dist-info/METADATA</strong>
Metadata-Version: 2.1
Name: attrs
Version: 23.2.0
Summary: Classes Without Boilerplate
</pre>

<p>Besides the import packages (named <code>attr</code> and <code>attrs</code> in this case), the wheel
contains a <em>.dist-info</em> directory with administrative files. The <em>METADATA</em> file
in this directory contains the <em>core metadata</em> for the package, a standardized
set of attributes that describe the package for the benefit of installers and
other packaging tools. You can access the core metadata of installed packages at
runtime using the standard library:</p>
<pre data-type="programlisting">$ <strong>uv pip install attrs</strong>
$ <strong>py</strong>
&gt;&gt;&gt; <strong>from importlib.metadata import metadata</strong>
&gt;&gt;&gt; <strong>metadata("attrs")["Version"]</strong>
23.2.0
&gt;&gt;&gt; <strong>metadata("attrs")["Summary"]</strong>
Classes Without Boilerplate
</pre>

<p>In the next section, you’ll see how to embed core metadata in your own packages,
using the <code>project</code> table in <em>pyproject.toml</em>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The core metadata standards predate <em>pyproject.toml</em> by many years. Most project
metadata fields correspond to a core metadata field, but their names and syntax
differ slightly. As a package author, you can safely ignore this translation and
focus on the project metadata.</p>
</div>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Project Metadata"><div class="sect1" id="section_packages_project_metadata">
<h1>Project Metadata</h1>

<p>Build backends write out core metadata fields based on what you specify in the
<code>project</code> table of <em>pyproject.toml</em>. <a data-type="xref" href="#table_packages_project_metadata">Table 3-3</a>
provides an overview of all the fields you can use in the <code>project</code> table.</p>
<table id="table_packages_project_metadata">
<caption><span class="label">Table 3-3. </span>The <code>project</code> table</caption>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>name</code></p></td>
<td><p>string</p></td>
<td><p>The project name</p></td>
</tr>
<tr>
<td><p><code>version</code></p></td>
<td><p>string</p></td>
<td><p>The version of the project</p></td>
</tr>
<tr>
<td><p><code>description</code></p></td>
<td><p>string</p></td>
<td><p>A short description of the project</p></td>
</tr>
<tr>
<td><p><code>keywords</code></p></td>
<td><p>array of strings</p></td>
<td><p>A list of keywords for the project</p></td>
</tr>
<tr>
<td><p><code>readme</code></p></td>
<td><p>string or table</p></td>
<td><p>A file with a long description of the project</p></td>
</tr>
<tr>
<td><p><code>license</code></p></td>
<td><p>table</p></td>
<td><p>The license governing the use of this project</p></td>
</tr>
<tr>
<td><p><code>authors</code></p></td>
<td><p>array of tables</p></td>
<td><p>The list of authors</p></td>
</tr>
<tr>
<td><p><code>maintainers</code></p></td>
<td><p>array of tables</p></td>
<td><p>The list of maintainers</p></td>
</tr>
<tr>
<td><p><code>classifiers</code></p></td>
<td><p>array of strings</p></td>
<td><p>A list of classifiers describing the project</p></td>
</tr>
<tr>
<td><p><code>urls</code></p></td>
<td><p>table of strings</p></td>
<td><p>The project URLs</p></td>
</tr>
<tr>
<td><p><code>dependencies</code></p></td>
<td><p>array of strings</p></td>
<td><p>The list of required third-party packages</p></td>
</tr>
<tr>
<td><p><code>optional-dependencies</code></p></td>
<td><p>table of arrays of strings</p></td>
<td><p>Named lists of optional third-party packages (<em>extras</em>)</p></td>
</tr>
<tr>
<td><p><code>scripts</code></p></td>
<td><p>table of strings</p></td>
<td><p>Entry-point scripts</p></td>
</tr>
<tr>
<td><p><code>gui-scripts</code></p></td>
<td><p>table of strings</p></td>
<td><p>Entry-point scripts providing a graphical user interface</p></td>
</tr>
<tr>
<td><p><code>entry-points</code></p></td>
<td><p>table of tables of strings</p></td>
<td><p>Entry point groups</p></td>
</tr>
<tr>
<td><p><code>requires-python</code></p></td>
<td><p>string</p></td>
<td><p>The Python version required by this project</p></td>
</tr>
<tr>
<td><p><code>dynamic</code></p></td>
<td><p>array of strings</p></td>
<td><p>A list of dynamic fields</p></td>
</tr>
</tbody>
</table>

<p>Two fields are essential and mandatory for every package: <code>project.name</code> and
<code>project.version</code>. The project name uniquely identifies the project itself. The
project version identifies a <em>release</em>—a published snapshot of the project
during its lifetime. Besides the name and version, there are a number of
optional fields you can provide, such as the author and license, a short text
describing the project, or third-party packages used by the project (see
<a data-type="xref" href="#example_packages_pyproject_toml_large">Example 3-4</a>).</p>
<div id="example_packages_pyproject_toml_large" data-type="example">
<h5><span class="label">Example 3-4. </span>A pyproject.toml file with project metadata</h5>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project]</code><code class="w"/>
<code class="n">name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"random-wikipedia-article"</code><code class="w"/>
<code class="n">version</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"0.1"</code><code class="w"/>
<code class="n">description</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"Display extracts from random Wikipedia articles"</code><code class="w"/>
<code class="n">keywords</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"wikipedia"</code><code class="p">]</code><code class="w"/>
<code class="n">readme</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"README.md"</code><code class="w">  </code><code class="c1"># only if your project has a README.md file</code><code class="w"/>
<code class="n">license</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">text</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s2">"MIT"</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="n">authors</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[{</code><code class="w"> </code><code class="n">name</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s2">"Your Name"</code><code class="p">,</code><code class="w"> </code><code class="n">email</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s2">"you@example.com"</code><code class="w"> </code><code class="p">}]</code><code class="w"/>
<code class="n">classifiers</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"Topic :: Games/Entertainment :: Fortune Cookies"</code><code class="p">]</code><code class="w"/>
<code class="n">urls</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">Homepage</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s2">"https://yourname.dev/projects/random-wikipedia-article"</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="n">requires-python</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"&gt;=3.8"</code><code class="w"/>
<code class="n">dependencies</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"httpx&gt;=0.27.0"</code><code class="p">,</code><code class="w"> </code><code class="s2">"rich&gt;=13.7.1"</code><code class="p">]</code><code class="w"/></pre></div>

<p>In the following sections, I’ll take a closer look at the various project
metadata fields.</p>








<section data-type="sect2" data-pdf-bookmark="Naming Projects"><div class="sect2" id="id106">
<h2>Naming Projects</h2>

<p>The <code>project.name</code> field contains the official name of your project.</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project]</code><code class="w"/>
<code class="n">name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"random-wikipedia-article"</code><code class="w"/></pre>

<p>Your users specify this name to install the project with pip. This field also
determines your project’s URL on PyPI. You can use any ASCII letter or digit to
name your project, interspersed with periods, underscores, and hyphens.
Packaging tools normalize project names for comparison: all letters are
converted to lowercase, and punctuation runs are replaced by a single hyphen (or
underscore, in the case of package filenames). For example, <code>Awesome.Package</code>,
<code>awesome_package</code>, and <code>awesome-package</code> all refer to the same project.</p>

<p>Project names are distinct from <em>import names</em>, the names users specify to
import your code. Import names must be valid Python identifiers, so they can’t
have hyphens or periods and can’t start with a digit. They’re case-sensitive and
can contain any Unicode letter or digit. As a rule of thumb, you should have a
single import package per distribution package and use the same name for both
(or a straightforward translation, like <code>random-wikipedia-article</code> and
<code>random_wikipedia_article</code>).</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Versioning Projects"><div class="sect2" id="id107">
<h2>Versioning Projects</h2>

<p>The <code>project.version</code> field stores the version of your project at the time you
publish the release.</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project]</code><code class="w"/>
<code class="n">version</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"0.1"</code><code class="w"/></pre>

<p>The Python community has a specification for version numbers to ensure that
automated tools can make meaningful decisions, such as picking the latest
release of a project. At the core, versions are a dotted sequence of numbers.
These numbers may be zero, and trailing zeros can be omitted: <code>1</code>, <code>1.0</code>, and
<code>1.0.0</code> all refer to the same version. Additionally, you can append certain
kinds of suffixes to a version (<a data-type="xref" href="#table_packages_version_identifiers">Table 3-4</a>). The
most common ones identify prereleases: <code>1.0.0a2</code> is the second alpha release,
<code>1.0.0b3</code> is the third beta release, <code>1.0.0rc1</code> is the first release candidate.
Each of these precedes the next, and all of them precede the final release:
<code>1.0.0</code>. Python versions can use additional components as well as alternate
spellings; refer to <a href="https://peps.python.org/pep-0440/">PEP 440</a> for the full
specification.</p>
<table id="table_packages_version_identifiers">
<caption><span class="label">Table 3-4. </span>Version Identifiers</caption>
<thead>
<tr>
<th>Release Type</th>
<th>Description</th>
<th>Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Final release</p></td>
<td><p>A stable, public snapshot (default)</p></td>
<td><p><code>1.0.0</code>, <code>2017.5.25</code></p></td>
</tr>
<tr>
<td><p>Prerelease</p></td>
<td><p>Preview of a final release to support testing</p></td>
<td><p><code>1.0.0a1</code>, <code>1.0.0b1</code>, <code>1.0.0rc1</code></p></td>
</tr>
<tr>
<td><p>Developmental release</p></td>
<td><p>A regular internal snapshot, such as a nightly build</p></td>
<td><p><code>1.0.0.dev1</code></p></td>
</tr>
<tr>
<td><p>Post-release</p></td>
<td><p>Corrects a minor error outside of the code</p></td>
<td><p><code>1.0.0.post1</code></p></td>
</tr>
</tbody>
</table>

<p>The Python version specification is intentionally permissive. Two widely adopted
cross-language standards attach additional meaning to version numbers:
<a href="https://semver.org">Semantic Versioning</a> uses the scheme <code>major.minor.patch</code>,
where <code>patch</code> designates bugfix releases, <code>minor</code> designates compatible feature
releases, and <code>major</code> designates releases with breaking changes.
<a href="https://calver.org">Calendar Versioning</a> uses date-based versions of various
forms, such as <code>year.month.day</code>, <code>year.month.sequence</code>, or
<code>year.quarter.sequence</code>.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Dynamic Fields"><div class="sect2" id="id108">
<h2>Dynamic Fields</h2>

<p>The <em>pyproject.toml</em> standard encourages projects to define their metadata
statically, rather than rely on the build backend to compute the fields during
the package build. Static metadata benefits the packaging ecosystem, because it
makes the fields accessible to other tools. It also reduces cognitive overhead:
build backends use the same configuration format and populate the fields in a
straightforward and transparent way.</p>

<p>But sometimes it’s useful to let the build backend fill in a field dynamically.
For example, the next section shows how you can derive the package version from
a Python module or Git tag instead of duplicating it in <em>pyproject.toml</em>.</p>

<p>For this reason, the project metadata standard provides an escape hatch in the
form of <em>dynamic fields</em>. Projects are allowed to use a backend-specific
mechanism to compute a field on the fly if they list its name under the
<code>dynamic</code> key:</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project]</code><code class="w"/>
<code class="n">dynamic</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"version"</code><code class="p">,</code><code class="w"> </code><code class="s2">"readme"</code><code class="p">]</code><code class="w"/></pre>










<section data-type="sect3" data-pdf-bookmark="Single-sourcing the project version"><div class="sect3" id="section_packages_single_sourcing_the_version">
<h3>Single-sourcing the project version</h3>

<p>Many projects declare their version at the top of a Python module, like this:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">__version__</code> <code class="o">=</code> <code class="s2">"0.2"</code></pre>

<p>Updating a frequently changing item in several locations is tedious and
error-prone. Some build backends therefore allow you to extract the version
number from the code instead of repeating it in <code>project.version</code>. This
mechanism is specific to your build backend, so you configure it in the <code>tool</code>
table. <a data-type="xref" href="#example_packages_pyproject_toml_dynamic_version">Example 3-5</a> demonstrates how this
works with Hatch.</p>
<div id="example_packages_pyproject_toml_dynamic_version" data-type="example">
<h5><span class="label">Example 3-5. </span>Deriving the project version from a Python module</h5>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[</code><code class="k">project</code><code class="k">]</code><code class="w">
</code><code class="n">name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"</code><code class="s2">random-wikipedia-article</code><code class="s2">"</code><code class="w">
</code><code class="n">dynamic</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"</code><code class="s2">version</code><code class="s2">"</code><code class="p">]</code><code class="w"> </code><a class="co" id="co_python_packages_CO3-1" href="#callout_python_packages_CO3-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a><code class="w">

</code><code class="k">[</code><code class="k">tool</code><code class="k">.</code><code class="k">hatch</code><code class="k">.</code><code class="k">version</code><code class="k">]</code><code class="w">
</code><code class="n">path</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"</code><code class="s2">random_wikipedia_article.py</code><code class="s2">"</code><code class="w"> </code><a class="co" id="co_python_packages_CO3-2" href="#callout_python_packages_CO3-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a><code class="w">

</code><code class="k">[</code><code class="k">build-system</code><code class="k">]</code><code class="w">
</code><code class="n">requires</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"</code><code class="s2">hatchling</code><code class="s2">"</code><code class="p">]</code><code class="w">
</code><code class="n">build-backend</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"</code><code class="s2">hatchling.build</code><code class="s2">"</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" id="callout_python_packages_CO3-1" href="#co_python_packages_CO3-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Mark the version field as dynamic.</p></dd>
<dt><a class="co" id="callout_python_packages_CO3-2" href="#co_python_packages_CO3-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Tell Hatch where to look for the <code>__version__</code> attribute.</p></dd>
</dl>

<p>You can also avoid the duplication by going in the other direction: Declare the
version statically in <em>pyproject.toml</em> and read it from the installed metadata
at runtime, as shown in <a data-type="xref" href="#example_packages_importlib_metadata_version">Example 3-6</a>.</p>
<div id="example_packages_importlib_metadata_version" data-type="example">
<h5><span class="label">Example 3-6. </span>Reading the version from the installed metadata</h5>

<pre data-type="programlisting" data-code-language="python"><code class="kn">from</code> <code class="nn">importlib.metadata</code> <code class="kn">import</code> <code class="n">version</code>

<code class="n">__version__</code> <code class="o">=</code> <code class="n">version</code><code class="p">(</code><code class="s2">"random-wikipedia-article"</code><code class="p">)</code></pre></div>

<p>But don’t go and add this boilerplate to all your projects yet. Reading the
metadata from the environment isn’t something you want to do during program
startup. Third-party libraries like <code>click</code> perform the metadata lookup on
demand—​for example, when the user specifies a command-line option like
<code>--version</code>. You can read the version on demand by providing a <code>__getattr__</code>
function for your module
(<a data-type="xref" href="#example_packages_importlib_metadata_version_lazy">Example 3-7</a>).<sup><a data-type="noteref" id="id268-marker" href="ch03.html#id268">5</a></sup></p>
<div id="example_packages_importlib_metadata_version_lazy" data-type="example">
<h5><span class="label">Example 3-7. </span>Reading the version from the installed metadata on demand</h5>

<pre data-type="programlisting" data-code-language="python"><code class="k">def</code> <code class="fm">__getattr__</code><code class="p">(</code><code class="n">name</code><code class="p">):</code>
    <code class="k">if</code> <code class="n">name</code> <code class="o">!=</code> <code class="s2">"__version__"</code><code class="p">:</code>
        <code class="n">msg</code> <code class="o">=</code> <code class="sa">f</code><code class="s2">"module </code><code class="si">{</code><code class="vm">__name__</code><code class="si">}</code><code class="s2"> has no attribute </code><code class="si">{</code><code class="n">name</code><code class="si">}</code><code class="s2">"</code>
        <code class="k">raise</code> <code class="ne">AttributeError</code><code class="p">(</code><code class="n">msg</code><code class="p">)</code>

    <code class="kn">from</code> <code class="nn">importlib.metadata</code> <code class="kn">import</code> <code class="n">version</code>

    <code class="k">return</code> <code class="n">version</code><code class="p">(</code><code class="s2">"random-wikipedia-article"</code><code class="p">)</code></pre></div>

<p>Alas, you still haven’t truly single-sourced the version. Most likely, you also
tag releases in your version control system (VCS) using a command like <code>git tag
v1.0.0</code>. (If you don’t, you should—​if a release has a bug, the version tags
help you find the commit that introduced it.)</p>

<p>Luckily, a number of build backends come with plugins that extract the version
number from Git, Mercurial, and similar systems. This technique was pioneered by
the <code>setuptools-scm</code> plugin. For Hatch, you can use the <code>hatch-vcs</code> plugin,
which is a wrapper around <code>setuptools-scm</code>
(<a data-type="xref" href="#example_packages_pyproject_toml_hatch_vcs">Example 3-8</a>).</p>
<div id="example_packages_pyproject_toml_hatch_vcs" data-type="example">
<h5><span class="label">Example 3-8. </span>Deriving the project version from the version control system</h5>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project]</code><code class="w"/>
<code class="n">name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"random-wikipedia-article"</code><code class="w"/>
<code class="n">dynamic</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"version"</code><code class="p">]</code><code class="w"/>

<code class="k">[tool.hatch.version]</code><code class="w"/>
<code class="n">source</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"vcs"</code><code class="w"/>

<code class="k">[build-system]</code><code class="w"/>
<code class="n">requires</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"hatchling"</code><code class="p">,</code><code class="w"> </code><code class="s2">"hatch-vcs"</code><code class="p">]</code><code class="w"/>
<code class="n">build-backend</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"hatchling.build"</code><code class="w"/></pre></div>

<p>If you build this project from a repository and you’ve checked out the tag
<code>v1.0.0</code>, Hatch will use the version <code>1.0.0</code> for the metadata. If you’ve checked
out an untagged commit, Hatch will instead generate a developmental release like
<code>0.1.dev1+g6b80314</code>.<sup><a data-type="noteref" id="id269-marker" href="ch03.html#id269">6</a></sup> In other words, you read the
project version from Git during the package build, and from the package metadata
at runtime.</p>
</div></section>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Entry-point Scripts"><div class="sect2" id="section_packages_entrypoint_scripts">
<h2>Entry-point Scripts</h2>

<p><em>Entry-point scripts</em> are small executables that launch the interpreter from
their environment, import a module and invoke a function (see
<a data-type="xref" href="ch02.html#section_environments_scripts">“Entry-point scripts”</a>). Installers like pip generate them on the fly
when they install a package.</p>

<p>The <code>project.scripts</code> table lets you declare entry-point scripts. Specify the
name of the script as the key and the module and function that the script should
invoke as the value, using the format
<code><em>package</em>.<em>module</em>:<em>function</em></code>.</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project.scripts]</code><code class="w"/>
<code class="n">random-wikipedia-article</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"random_wikipedia_article:main"</code><code class="w"/></pre>

<p>This declaration allows users to invoke the program using its given name:</p>
<pre data-type="programlisting">$ <strong>random-wikipedia-article</strong></pre>

<p>The <code>project.gui-scripts</code> table uses the same format as the <code>project.scripts</code>
table—​use it if your application has a graphical user interface (GUI).</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project.gui-scripts]</code><code class="w"/>
<code class="n">random-wikipedia-article-gui</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"random_wikipedia_article:gui_main"</code><code class="w"/></pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Entry Points"><div class="sect2" id="section_packages_entrypoints">
<h2>Entry Points</h2>

<p>Entry-point scripts are a special case of a more general mechanism called <em>entry
points</em>. Entry points allow you to register a Python object in your package
under a public name. Python environments come with a registry of entry points,
and any package can query this registry to discover and import modules, using
the function <code>importlib.metadata.entry_points</code> from the standard library.
Applications commonly use this mechanism to support third-party plugins.</p>

<p>The <code>project.entry-points</code> table contains these generic entry points. They use
the same syntax as entry-point scripts, but are grouped in subtables known as
<em>entry point groups</em>. If you want to write a plugin for another application, you
register a module or object in its designated entry point group.</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project.entry-points.some_application]</code><code class="w"/>
<code class="n">my-plugin</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"my_plugin"</code><code class="w"/></pre>

<p>You can also register submodules using dotted notation, as well as objects
within modules, using the format
<code><em>module</em>:<em>object</em></code>:</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project.entry-points.some_application]</code><code class="w"/>
<code class="n">my-plugin</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"my_plugin.submodule:plugin"</code><code class="w"/></pre>

<p>Let’s look at an example to see how this works. Random Wikipedia articles make
for fun little fortune cookies, but they can also serve as <em>test
fixtures</em><sup><a data-type="noteref" id="id270-marker" href="ch03.html#id270">7</a></sup> for developers of Wikipedia viewers and
similar apps. Let’s turn the app into a plugin for the pytest testing framework.
(Don’t worry if you haven’t worked with pytest yet; I’ll cover testing in depth
in <a data-type="xref" href="ch06.html#chapter_testing">Chapter 6</a>.)</p>

<p>Pytest allows third-party plugins to extend its functionality with test fixtures
and other features. It defines an entry point group for such plugins named
<code>pytest11</code>. You can provide a plugin for pytest by registering a module in this
group. Let’s also add pytest to the project dependencies.</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project]</code><code class="w"/>
<code class="n">dependencies</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"pytest"</code><code class="p">]</code><code class="w"/>

<code class="k">[project.entry-points.pytest11]</code><code class="w"/>
<code class="n">random-wikipedia-article</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"random_wikipedia_article"</code><code class="w"/></pre>

<p>For simplicity, I’ve chosen the top-level module that hosted the <code>main</code> function
in <a data-type="xref" href="#example_packages_wikipedia">Example 3-1</a>. Next, extend pytest with a test fixture
returning a random Wikipedia article, as shown in
<a data-type="xref" href="#example_packages_wikipedia_pytest_fixture">Example 3-9</a>.</p>
<div id="example_packages_wikipedia_pytest_fixture" data-type="example">
<h5><span class="label">Example 3-9. </span>Test fixture with a random Wikipedia article</h5>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code> <code class="nn">json</code>
<code class="kn">import</code> <code class="nn">urllib.request</code>

<code class="kn">import</code> <code class="nn">pytest</code>

<code class="n">API_URL</code> <code class="o">=</code> <code class="s2">"https://en.wikipedia.org/api/rest_v1/page/random/summary"</code>

<code class="nd">@pytest</code><code class="o">.</code><code class="n">fixture</code>
<code class="k">def</code> <code class="nf">random_wikipedia_article</code><code class="p">():</code>
    <code class="k">with</code> <code class="n">urllib</code><code class="o">.</code><code class="n">request</code><code class="o">.</code><code class="n">urlopen</code><code class="p">(</code><code class="n">API_URL</code><code class="p">)</code> <code class="k">as</code> <code class="n">response</code><code class="p">:</code>
        <code class="k">return</code> <code class="n">json</code><code class="o">.</code><code class="n">load</code><code class="p">(</code><code class="n">response</code><code class="p">)</code></pre></div>

<p>A developer of a Wikipedia viewer can now install your plugin next to pytest.
Test functions use your test fixture by referencing it as a function argument
(see <a data-type="xref" href="#example_packages_wikipedia_pytest_test">Example 3-10</a>). Pytest recognizes that the
function argument is a test fixture and invokes the test function with the
return value of the fixture.</p>
<div id="example_packages_wikipedia_pytest_test" data-type="example">
<h5><span class="label">Example 3-10. </span>A test function that uses the random article fixture</h5>

<pre data-type="programlisting" data-code-language="python"><code class="c1"># test_wikipedia_viewer.py</code><code>
</code><code class="k">def</code><code> </code><code class="nf">test_wikipedia_viewer</code><code class="p">(</code><code class="n">random_wikipedia_article</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="n">random_wikipedia_article</code><code class="p">[</code><code class="s2">"</code><code class="s2">extract</code><code class="s2">"</code><code class="p">]</code><code class="p">)</code><code> </code><a class="co" id="co_python_packages_CO4-1" href="#callout_python_packages_CO4-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>    </code><code class="k">assert</code><code> </code><code class="kc">False</code><code> </code><a class="co" id="co_python_packages_CO4-2" href="#callout_python_packages_CO4-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a></pre></div>
<dl class="calloutlist">
<dt><a class="co" id="callout_python_packages_CO4-1" href="#co_python_packages_CO4-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>A real test would run the viewer instead of <code>print()</code>.</p></dd>
<dt><a class="co" id="callout_python_packages_CO4-2" href="#co_python_packages_CO4-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Fail the test so we get to see the full output.</p></dd>
</dl>

<p>You can try this out yourself in an active virtual environment in the project
directory:</p>
<pre data-type="programlisting">$ <strong>py -m pip install .</strong>
$ <strong>py -m pytest test_wikipedia_viewer.py</strong>
============================= test session starts ==============================
platform darwin -- Python 3.12.2, pytest-8.1.1, pluggy-1.4.0
rootdir: ...
plugins: random-wikipedia-article-0.1
collected 1 item

test_wikipedia_viewer.py F                                               [100%]

=================================== FAILURES ===================================
____________________________ test_wikipedia_viewer _____________________________

    def test_wikipedia_viewer(random_wikipedia_article):
        print(random_wikipedia_article["extract"])
&gt;       assert False
E       assert False

test_wikipedia_viewer.py:4: AssertionError
----------------------------- Captured stdout call -----------------------------
Halgerda stricklandi is a species of sea slug, a dorid nudibranch, a shell-less
marine gastropod mollusk in the family Discodorididae.
=========================== short test summary info ============================
FAILED test_wikipedia_viewer.py::test_wikipedia_viewer - assert False
============================== 1 failed in 1.10s ===============================
</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Authors and Maintainers"><div class="sect2" id="id112">
<h2>Authors and Maintainers</h2>

<p>The <code>project.authors</code> and <code>project.maintainers</code> fields contain the list of
authors and maintainers for the project. Each item in these lists is a table
with <code>name</code> and <code>email</code> keys—​you can specify either of these keys or both.</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project]</code><code class="w"/>
<code class="n">authors</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[{</code><code class="w"> </code><code class="n">name</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s2">"Your Name"</code><code class="p">,</code><code class="w"> </code><code class="n">email</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s2">"you@example.com"</code><code class="w"> </code><code class="p">}]</code><code class="w"/>
<code class="n">maintainers</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"> </code><code class="n">name</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s2">"Alice"</code><code class="p">,</code><code class="w"> </code><code class="n">email</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s2">"alice@example.com"</code><code class="w"> </code><code class="p">},</code><code class="w"/>
<code class="w">  </code><code class="p">{</code><code class="w"> </code><code class="n">name</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s2">"Bob"</code><code class="p">,</code><code class="w"> </code><code class="n">email</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s2">"bob@example.com"</code><code class="w"> </code><code class="p">},</code><code class="w"/>
<code class="p">]</code><code class="w"/></pre>

<p>The meaning of the fields is somewhat open to interpretation. If you start a new
project, I recommend including yourself under <code>authors</code> and omitting the
<code>maintainers</code> field. Long-lived open source projects typically list the original
author under <code>authors</code>, while the people in charge of ongoing project
maintenance appear as <code>maintainers</code>.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="The Description and README"><div class="sect2" id="id113">
<h2>The Description and README</h2>

<p>The <code>project.description</code> field contains a short description as a string. This
field will appear as the subtitle of your project page on PyPI. Some packaging
tools also use this field when displaying a compact list of packages with
human-readable descriptions.</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project]</code><code class="w"/>
<code class="n">description</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"Display extracts from random Wikipedia articles"</code><code class="w"/></pre>

<p>The <code>project.readme</code> field is typically a string with the relative path to the
file with the long description of your project. Common choices are <em>README.md</em>
for a description written in Markdown format and <em>README.rst</em> for the
reStructuredText format. The contents of this file appear on your project page
on PyPI.</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project]</code><code class="w"/>
<code class="n">readme</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"README.md"</code><code class="w"/></pre>

<p>Instead of a string, you can also specify a table with <code>file</code> and <code>content-type</code>
keys.</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project]</code><code class="w"/>
<code class="n">readme</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">file</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s2">"README"</code><code class="p">,</code><code class="w"> </code><code class="n">content-type</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s2">"text/plain"</code><code class="w"> </code><code class="p">}</code><code class="w"/></pre>

<p>You can even embed the long description in the <em>pyproject.toml</em> file using the
<code>text</code> key.</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project.readme]</code><code class="w"/>
<code class="n">content-type</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"text/markdown"</code><code class="w"/>
<code class="n">text</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"""</code>
<code class="s2"># random-wikipedia-article</code>

<code class="s2">Display extracts from random Wikipedia articles</code>
<code class="s2">"""</code><code class="w"/></pre>

<p>Writing a README that renders well is not trivial—​often, the project
description appears in disparate places, like PyPI, a repository hosting service
like GitHub, and inside official documentation on services like
<a href="https://readthedocs.org">Read the Docs</a>. If you need more flexibility, you can
declare the field dynamic and use a plugin like <code>hatch-fancy-pypi-readme</code> to
assemble the project description from multiple fragments.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Keywords and Classifiers"><div class="sect2" id="id114">
<h2>Keywords and Classifiers</h2>

<p>The <code>project.keywords</code> field contains a list of strings that people can use to
search for your project on PyPI.</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project]</code><code class="w"/>
<code class="n">keywords</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"wikipedia"</code><code class="p">]</code><code class="w"/></pre>

<p>The <code>project.classifiers</code> field contains a list of classifiers to categorize the
project in a standardized way.</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project]</code><code class="w"/>
<code class="n">classifiers</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="w"/>
<code class="w">    </code><code class="s2">"Development Status :: 3 - Alpha"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="s2">"Environment :: Console"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="s2">"Topic :: Games/Entertainment :: Fortune Cookies"</code><code class="p">,</code><code class="w"/>
<code class="p">]</code><code class="w"/></pre>

<p>PyPI maintains the <a href="https://pypi.org/classifiers">official registry</a> of
classifiers for Python projects. They’re known as <em>Trove classifiers</em> and
consist of hierarchically organized labels separated by double colons
(<a data-type="xref" href="#table_packages_trove_classifiers">Table 3-5</a>). The Trove project, initiated by Eric S.
Raymond, was an early design for an open source software repository.</p>
<table id="table_packages_trove_classifiers">
<caption><span class="label">Table 3-5. </span>Trove Classifiers</caption>
<thead>
<tr>
<th>Classifier Group</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Development Status</p></td>
<td><p>How mature this release is</p></td>
<td><p><code>Development Status :: 5 - Production/Stable</code></p></td>
</tr>
<tr>
<td><p>Environment</p></td>
<td><p>The environment in which the project runs</p></td>
<td><p><code>Environment :: No Input/Output (Daemon)</code></p></td>
</tr>
<tr>
<td><p>Operating System</p></td>
<td><p>The operating systems supported by the project</p></td>
<td><p><code>Operating System :: OS Independent</code></p></td>
</tr>
<tr>
<td><p>Framework</p></td>
<td><p>Any framework used by the project</p></td>
<td><p><code>Framework :: Flask</code></p></td>
</tr>
<tr>
<td><p>Audience</p></td>
<td><p>The kind of users served by the project</p></td>
<td><p><code>Intended Audience :: Developers</code></p></td>
</tr>
<tr>
<td><p>License</p></td>
<td><p>The license under which the project is distributed</p></td>
<td><p><code>License :: OSI Approved :: MIT License</code></p></td>
</tr>
<tr>
<td><p>Natural Language</p></td>
<td><p>The natural languages supported by the project</p></td>
<td><p><code>Natural Language :: English</code></p></td>
</tr>
<tr>
<td><p>Programming Language</p></td>
<td><p>The programming language the project is written in</p></td>
<td><p><code>Programming Language :: Python :: 3.12</code></p></td>
</tr>
<tr>
<td><p>Topic</p></td>
<td><p>Various topics related to the project</p></td>
<td><p><code>Topic :: Utilities</code></p></td>
</tr>
</tbody>
</table>

<p>Classifiers are entirely optional. I recommend indicating the development status
and the supported operating systems, which aren’t covered by other metadata
fields. If you’d like to include more classifiers, provide one from each
classifier group.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="The Project URLs"><div class="sect2" id="id115">
<h2>The Project URLs</h2>

<p>The <code>project.urls</code> table allows you to point users to your project homepage,
source code, documentation, issue tracker, and similar project-related URLs.
Your project page on PyPI links to these pages using the provided key as the
display text for each link. It also displays an appropriate icon for many common
names and URLs.</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project.urls]</code><code class="w"/>
<code class="n">Homepage</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"https://yourname.dev/projects/random-wikipedia-article"</code><code class="w"/>
<code class="n">Source</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"https://github.com/yourname/random-wikipedia-article"</code><code class="w"/>
<code class="n">Issues</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"https://github.com/yourname/random-wikipedia-article/issues"</code><code class="w"/>
<code class="n">Documentation</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"https://readthedocs.io/random-wikipedia-article"</code><code class="w"/></pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="The License"><div class="sect2" id="id116">
<h2>The License</h2>

<p>The <code>project.license</code> field is a table where you can specify your project
license under the <code>text</code> key or by reference to a file under the <code>file</code>
key. You may also want to add the corresponding Trove classifier for the
license.</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project]</code><code class="w"/>
<code class="n">license</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">text</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s2">"MIT"</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="n">classifiers</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"License :: OSI Approved :: MIT License"</code><code class="p">]</code><code class="w"/></pre>

<p>I recommend using the <code>text</code> key with a <a href="https://spdx.org/licenses/">SPDX license
identifier</a> such as “MIT” or “Apache-2.0”. The Software Package Data Exchange
(SPDX) is an open standard backed by the Linux Foundation for communicating
software bill of material information, including licenses.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>As of this writing, a Python Enhancement Proposal (PEP) is under discussion that
changes the <code>license</code> field to a string using SPDX syntax and adds a
<code>license-files</code> key for license files distributed with the package:
<a href="https://peps.python.org/pep-0639/">PEP 639</a>.</p>
</div>

<p>If you’re unsure which open source license to use for your project,
<a href="https://choosealicense.com/">choosealicense.com</a> provides some useful guidance.
For a proprietary project, it’s common to specify “proprietary”. You can also
add the special classifier <code>Private :: Do Not Upload</code> to prevent accidental
upload to PyPI.</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project]</code><code class="w"/>
<code class="n">license</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="n">text</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s2">"proprietary"</code><code class="w"> </code><code class="p">}</code><code class="w"/>
<code class="n">classifiers</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="w"/>
<code class="w">    </code><code class="s2">"License :: Other/Proprietary License"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="s2">"Private :: Do Not Upload"</code><code class="p">,</code><code class="w"/>
<code class="p">]</code><code class="w"/></pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="The Required Python Version"><div class="sect2" id="id117">
<h2>The Required Python Version</h2>

<p>Use the <code>project.requires-python</code> field to specify the versions of Python that
your project supports.<sup><a data-type="noteref" id="id271-marker" href="ch03.html#id271">8</a></sup></p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project]</code><code class="w"/>
<code class="n">requires-python</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"&gt;=3.8"</code><code class="w"/></pre>

<p>Most commonly, people specify the minimum Python version as a lower bound, using
a string with the format <code>&gt;=3.x</code>. The syntax of this field is more general and
follows the same rules as <em>version specifiers</em> for project dependencies (see
<a data-type="xref" href="ch04.html#chapter_dependencies">Chapter 4</a>).</p>

<p>Tools like Nox and tox make it easy to run checks across multiple Python
versions, helping you ensure that the field reflects reality. As a baseline, I
recommend requiring the oldest Python version that still receives security
updates. You can find the end-of-life dates for all current and past Python
versions on the <a href="https://devguide.python.org/versions/">Python Developer Guide</a>.</p>

<p>There are three main reasons to be more restrictive about the Python version.
First, your code may depend on newer language features—​for example, structural
pattern matching was introduced in Python 3.10. Second, your code may depend on
newer features in the standard library—​look out for the “Changed in version
3.x” notes in the official documentation. Third, it could depend on third-party
packages with more restrictive Python requirements.</p>

<p>Some packages declare upper bounds on the Python version, such as <code>&gt;=3.8,&lt;4</code>.
This practice is discouraged, but depending on such a package may force you to
declare the same upper bound for your own package. Dependency solvers can’t
downgrade the Python version in an environment; they will either fail or, worse,
downgrade the package to an old version with a looser Python constraint. A
future Python 4 is unlikely to introduce the kind of breaking changes that
people associate with the transition from Python 2 to 3.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Don’t specify an upper bound for the required Python version unless you <em>know</em>
that your package is not compatible with any higher version. Upper bounds cause
disruption in the ecosystem when a new version is released.</p>
</div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Dependencies and Optional Dependencies"><div class="sect2" id="id118">
<h2>Dependencies and Optional Dependencies</h2>

<p>The remaining two fields, <code>project.dependencies</code> and
<code>project.optional-dependencies</code>, list any third-party packages on which your
project depends. You’ll take a closer look at these fields—​and dependencies in
general—​in the next chapter.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="id119">
<h1>Summary</h1>

<p>Packaging allows you to publish releases of your Python projects, using source
distributions (<em>sdists</em>) and built distributions (<em>wheels</em>). These artifacts
contain your Python modules, together with project metadata, in an archive
format that end users can easily install into their environments. The standard
<em>pyproject.toml</em> file defines the build system for a Python project as well as
the project metadata. Build frontends like <code>build</code>, pip, and uv use the build
system information to install and run the build backend in an isolated
environment. The build backend assembles an sdist and wheel from the source tree
and embeds the project metadata. You can upload packages to the Python Package
Index (PyPI) or a private repository, using a tool like Twine. The Python
project manager Rye provides a more integrated workflow on top of these tools.</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="id263"><sup><a href="ch03.html#id263-marker">1</a></sup> Even the venerable Comprehensive Perl Archive Network (CPAN) didn’t exist in February 1991, when Guido van Rossum published the first release of Python on Usenet.</p><p data-type="footnote" id="id264"><sup><a href="ch03.html#id264-marker">2</a></sup> By default, the <code>build</code> tool builds the wheel from the sdist instead of the source tree, to ensure that the sdist is valid. Build backends can request additional build dependencies using the <code>get_requires_for_build_wheel</code> and <code>get_requires_for_build_sdist</code> build hooks.</p><p data-type="footnote" id="id266"><sup><a href="ch03.html#id266-marker">3</a></sup> Python’s packaging ecosystem is also a great demonstration of <em>Conway’s law</em>. In 1967, Melvin Conway—​an American computer scientist also known for developing the concept of coroutines—​observed that organizations will design systems that are copies of their communication structure.</p><p data-type="footnote" id="id267"><sup><a href="ch03.html#id267-marker">4</a></sup> This is especially true given the existence of <em>typosquatting</em>—where an attacker uploads a malicious package whose name is similar to a popular package—​and <em>dependency confusion attacks</em>—where a malicious package on a public server uses the same name as a package on a private company repository.</p><p data-type="footnote" id="id268"><sup><a href="ch03.html#id268-marker">5</a></sup> This nifty technique comes courtesy of my reviewer Hynek Schlawack.</p><p data-type="footnote" id="id269"><sup><a href="ch03.html#id269-marker">6</a></sup> In case you’re wondering, the <code>+g6b80314</code> suffix is a <em>local version identifier</em> that designates downstream changes, in this case using output from the command <code>git describe</code>.</p><p data-type="footnote" id="id270"><sup><a href="ch03.html#id270-marker">7</a></sup> <em>Test fixtures</em> set up objects that you need to run repeatable tests against your code.</p><p data-type="footnote" id="id271"><sup><a href="ch03.html#id271-marker">8</a></sup> You can also add Trove classifiers for each supported Python version. Some backends backfill classifiers for you—​Poetry does this out of the box for Python versions and project licenses.</p></div></div></section></div>
</div>
</body></html>