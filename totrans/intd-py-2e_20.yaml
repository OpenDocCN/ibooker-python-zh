- en: Chapter 18\. The Web, Untangled
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第18章。解开网络的秘密
- en: Oh, what a tangled web we weave…
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 哦，我们编织的网……
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Walter Scott, Marmion
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 沃尔特·斯科特，《马尔米翁》
- en: Straddling the French–Swiss border is CERN—a particle physics research institute
    that smashes atoms multiple times, just to make sure.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 横跨法国和瑞士边境的是CERN——一个粒子物理研究所，多次粉碎原子，以确保。
- en: 'All that smashing generates a mountain of data. In 1989, the English scientist
    Tim Berners-Lee first circulated a proposal within CERN to help disseminate information
    there and across the research community. He called it the *World Wide Web* and
    distilled its design into three simple ideas:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些粉碎产生了大量数据。1989年，英国科学家蒂姆·伯纳斯-李在CERN内部首次提出了一个提议，帮助在那里和研究界传播信息。他称之为*万维网*，并将其设计简化为三个简单的想法：
- en: HTTP (Hypertext Transfer Protocol)
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP（超文本传输协议）
- en: A protocol for web clients and servers to interchange requests and responses.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一种用于网络客户端和服务器交换请求和响应的协议。
- en: HTML (Hypertext Markup Language)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: HTML（超文本标记语言）
- en: A presentation format for results.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的演示格式。
- en: URL (Uniform Resource Locator)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: URL（统一资源定位符）
- en: A way to uniquely represent a server and a *resource* on that server.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 表示服务器和该服务器上的*资源*的唯一方式。
- en: In its simplest usage, a web client (I think Berners-Lee was the first to use
    the term *browser*) connected to a web server with HTTP, requested a URL, and
    received HTML.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的用法中，Web客户端（我认为伯纳斯-李是第一个使用术语*浏览器*的人）通过HTTP连接到Web服务器，请求URL，并接收HTML。
- en: This was all built on the networking base from the *internet*, which at the
    time was noncommercial, and known only to a few universities and research organizations.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切都建立在来自*互联网*的网络基础之上，当时互联网是非商业化的，并且仅为少数大学和研究组织所知。
- en: He wrote the first web browser and server on a NeXT^([1](ch18.html#idm45794970286888))
    computer. Web awareness really expanded in 1993, when a group of students at the
    University of Illinois released the Mosaic web browser (for Windows, the Macintosh,
    and Unix) and the NCSA *httpd* server. When I downloaded Mosaic that summer and
    started building sites, I had no idea that the web and the internet would soon
    become part of everyday life. The internet^([2](ch18.html#idm45794970285336))
    was still officially noncommercial then; there were about 500 known web servers
    [in the world](http://home.web.cern.ch/about/birth-web). By the end of 1994, the
    number of web servers had grown to 10,000. The internet was opened to commercial
    use, and the authors of Mosaic founded Netscape to write commercial web software.
    Netscape went public as part of the early internet frenzy, and the web’s explosive
    growth has never stopped.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 他在一台NeXT^([1](ch18.html#idm45794970286888))电脑上写了第一款网页浏览器和服务器。1993年，当伊利诺伊大学的一群学生发布了适用于Windows、Macintosh和Unix系统的Mosaic网页浏览器和NCSA
    *httpd*服务器时，网络意识真正扩展开来。那个夏天我下载了Mosaic并开始建站时，我完全没有想到网络和互联网很快会成为日常生活的一部分。当时互联网^([2](ch18.html#idm45794970285336))仍然正式非商业化；全球约有500台已知的网络服务器（[详见](http://home.web.cern.ch/about/birth-web)）。到1994年底，网络服务器数量已增长到10,000台。互联网开放商业化，Mosaic的作者们创立了Netscape公司，开发商业化的网络软件。Netscape随着早期互联网狂热而上市，网络的爆炸性增长从未停止。
- en: 'Almost every computer language has been used to write web clients and web servers.
    The dynamic languages Perl, PHP, and Ruby have been especially popular. In this
    chapter, I show why Python is a particularly good language for web work at every
    level:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每种计算机语言都被用来编写网络客户端和服务器。动态语言Perl、PHP和Ruby尤为流行。在本章中，我展示了为何Python是各个层次上进行网络工作的特别优秀语言：
- en: Clients, to access remote sites
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端，用于访问远程站点
- en: Servers, to provide data for websites and web APIs
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器，为网站和Web API提供数据
- en: Web APIs and services, to interchange data in other ways than viewable web pages
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web API和服务，以其他方式交换数据，而不仅仅是可视化的网页
- en: And while we’re at it, we’ll build an actual interactive website in the exercises
    at the end of this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，我们将在本章末尾的练习中构建一个实际的交互式网站。
- en: Web Clients
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络客户端
- en: The low-level network plumbing of the internet is called Transmission Control
    Protocol/Internet Protocol, or more commonly, simply TCP/IP ([“TCP/IP”](ch17.html#tcp_ip)
    goes into more detail about this). It moves bytes among computers, but doesn’t
    care about what those bytes mean. That’s the job of higher-level *protocols*—syntax
    definitions for specific purposes. HTTP is the standard protocol for web data
    interchange.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网的低级网络管道被称为传输控制协议/因特网协议，或更常见的TCP/IP（[“TCP/IP”](ch17.html#tcp_ip)详细介绍了这一点）。它在计算机之间传输字节，但不关心这些字节的含义。这是高级*协议*的工作——专门用于特定目的的语法定义。HTTP是网络数据交换的标准协议。
- en: 'The web is a client-server system. The client makes a *request* to a server:
    it opens a TCP/IP connection, sends the URL and other information via HTTP, and
    receives a *response*.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Web是一个客户端-服务器系统。客户端向服务器发送一个*请求*：它通过HTTP打开TCP/IP连接，发送URL和其他信息，并接收一个*响应*。
- en: The format of the response is also defined by HTTP. It includes the status of
    the request, and (if the request succeeded) the response’s data and format.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 响应的格式也由HTTP定义。它包括请求的状态，以及（如果请求成功）响应的数据和格式。
- en: The most well-known web client is a web *browser*. It can make HTTP requests
    in a number of ways. You might initiate a request manually by typing a URL into
    the location bar or clicking a link in a web page. Very often, the data returned
    is used to display a website —HTML documents, JavaScript files, CSS files, and
    images—but it can be any type of data, not just that intended for display.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名的Web客户端是Web *浏览器*。它可以以多种方式发出HTTP请求。您可以通过在位置栏中键入URL或单击Web页面中的链接手动发出请求。返回的数据通常用于显示网站——HTML文档、JavaScript文件、CSS文件和图像——但它可以是任何类型的数据，不仅仅是用于显示的数据。
- en: 'An important aspect of HTTP is that it’s *stateless*. Each HTTP connection
    that you make is independent of all the others. This simplifies basic web operations
    but complicates others. Here are just a few samples of the challenges:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP的一个重要特点是它是*无状态*的。您建立的每个HTTP连接都是彼此独立的。这简化了基本的Web操作，但也使其他操作变得复杂。这里只是一些挑战的样本：
- en: Caching
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存
- en: Remote content that doesn’t change should be saved by the web client and used
    to avoid downloading from the server again.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 不变的远程内容应该由Web客户端保存并使用，以避免再次从服务器下载。
- en: Sessions
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 会话
- en: A shopping website should remember the contents of your shopping cart.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 购物网站应该记住您购物车的内容。
- en: Authentication
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 认证
- en: Sites that require your username and password should remember them while you’re
    logged in.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 需要您的用户名和密码的网站在您登录时应该记住它们。
- en: Solutions to statelessness include *cookies*, in which the server sends the
    client enough specific information to be able to identify it uniquely when the
    client sends the cookie back.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 解决无状态性的方法包括*cookies*，服务器向客户端发送足够的特定信息，以便在客户端将cookie发送回来时能够唯一识别它。
- en: Test with telnet
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用telnet进行测试
- en: HTTP is a text-based protocol, so you can actually type it yourself for web
    testing. The ancient `telnet` program lets you connect to any server and port,
    and type commands to any service that’s running there. For secure (encrypted)
    connections to other machines, it’s been replaced by `ssh`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是基于文本的协议，因此您实际上可以自己输入以进行Web测试。古老的`telnet`程序允许您连接到任何运行服务的服务器和端口，并向任何正在运行的服务输入命令。对于与其他机器的安全（加密）连接，它已被`ssh`取代。
- en: 'Let’s ask everyone’s favorite test site, Google, some basic information about
    its home page. Type this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们询问每个人最喜欢的测试网站，Google，关于其主页的一些基本信息。输入以下内容：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If there is a web server on port 80 (this is where unencrypted `http` usually
    runs; encrypted `https` uses port 443) at *google.com* (I think that’s a safe
    bet), `telnet` will print some reassuring information, and then display a final
    blank line that’s your cue to type something else:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在80端口上有一个Web服务器（这是未加密的`http`通常运行的地方；加密的`https`使用443端口）在*google.com*上（我认为这是一个安全的赌注），`telnet`将打印一些令人放心的信息，然后显示一个最终的空行，这是您输入其他内容的信号：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, type an actual HTTP command for `telnet` to send to the Google web server.
    The most common HTTP command (the one your browser uses when you type a URL in
    its location bar) is `GET`. This retrieves the contents of the specified resource,
    such as an HTML file, and returns it to the client. For our first test, we’ll
    use the HTTP command `HEAD`, which just retrieves some basic information *about*
    the resource:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，键入一个实际的HTTP命令，让`telnet`发送给Google Web服务器。最常见的HTTP命令（当您在浏览器的位置栏中键入URL时使用的命令）是`GET`。这会检索指定资源的内容，例如HTML文件，并将其返回给客户端。对于我们的第一个测试，我们将使用HTTP命令`HEAD`，它只是检索资源的一些基本信息*关于*资源：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add an extra carriage return to send a blank line so the remote server knows
    you’re all done and want a response. That `HEAD /` sends the HTTP `HEAD` *verb*
    (command) to get information about the home page (`/`). You’ll receive a response
    such as this (I trimmed some of the long lines using … so they wouldn’t stick
    out of the book):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 添加额外的换行符以发送空行，以便远程服务器知道您已经完成并希望得到响应。该 `HEAD /` 发送 HTTP `HEAD` *动词*（命令）以获取关于首页（`/`）的信息。您将收到类似以下内容的响应（我使用...裁剪了一些长行，以防止其超出书籍）：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These are HTTP response headers and their values. Some, like `Date` and `Content-Type`,
    are required. Others, such as `Set-Cookie`, are used to track your activity across
    multiple visits (we talk about *state management* a little later in this chapter).
    When you make an HTTP `HEAD` request, you get back only headers. If you had used
    the HTTP `GET` or `POST` commands, you would also receive data from the home page
    (a mixture of HTML, CSS, JavaScript, and whatever else Google decided to throw
    into its home page).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 HTTP 响应头及其值。像 `Date` 和 `Content-Type` 这样的头是必需的。其他头，如 `Set-Cookie`，用于跟踪您在多次访问中的活动（我们稍后在本章讨论*状态管理*）。当您发出
    HTTP `HEAD` 请求时，您只会收到头信息。如果您使用了 HTTP `GET` 或 `POST` 命令，您还将从首页收到数据（其中包含 HTML、CSS、JavaScript
    和 Google 决定加入首页的其他内容）。
- en: 'I don’t want to leave you stranded in `telnet`. To close `telnet`, type the
    following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我不想让你陷在 `telnet` 中。要关闭 `telnet`，请键入以下内容：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Test with curl
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 curl 进行测试
- en: Using `telnet` is simple, but is a completely manual process. The [`curl`](https://curl.haxx.se)
    program is probably the most popular command-line web client. Documentation includes
    the book [*Everything Curl*](https://curl.haxx.se/book.html), in HTML, PDF, and
    ebook formats. A [table](https://oreil.ly/dLR8b) compares `curl` with similar
    tools. The [download](https://curl.haxx.se/download.html) page includes all the
    major platforms, and many obscure ones.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `telnet` 简单，但是这是一个完全手动的过程。[`curl`](https://curl.haxx.se) 程序可能是最流行的命令行 Web
    客户端。其文档包括书籍[*Everything Curl*](https://curl.haxx.se/book.html)，提供 HTML、PDF 和电子书格式。[一张表](https://oreil.ly/dLR8b)比较了
    `curl` 与类似工具。[下载](https://curl.haxx.se/download.html)页面包含了所有主要平台和许多不太常见的平台。
- en: 'The simplest use of `curl` does an implicit `GET` (output truncated here):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `curl` 的最简单方式执行隐式 `GET`（此处截断了输出）：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This uses `HEAD`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用 `HEAD`：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you’re passing arguments, you can include them in the command line or a
    data file. In these examples, I use the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要传递参数，您可以在命令行或数据文件中包含它们。在这些示例中，我使用以下内容：
- en: '*url* for any website'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*url* 适用于任何网站'
- en: '`data.txt` as a text data file with these contents: `a=1&b=2`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data.txt` 是一个文本数据文件，内容如下：`a=1&b=2`'
- en: '`data.json` as a JSON data file with these contents: `{"a":1, "b": 2}`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data.json` 作为 JSON 数据文件，其内容为：`{"a":1, "b": 2}`'
- en: '`a=1&b=2` as two data arguments'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a=1&b=2` 作为两个数据参数'
- en: 'Using default (*form-encoded*) arguments:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认的（*form-encoded*）参数：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For JSON-encoded arguments:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 JSON 编码的参数：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Test with httpie
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 httpie 进行测试
- en: A more Pythonic alternative to curl is [`httpie`](https://httpie.org).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 比 curl 更 Pythonic 的选择是[`httpie`](https://httpie.org)。
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To make a form-encoded POST, similar to the methods for `curl` above (`-f`
    is a synonym for `--form`):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行与上述 `curl` 方法类似的表单编码 POST，请使用 `-f` 作为 `--form` 的同义词：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The default encoding is JSON:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 默认编码是 JSON：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`httpie` also handles HTTP headers, cookies, file uploads, authentication,
    redirects, SSL, and so on. As usual, see the [docs](https://httpie.org/doc)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`httpie` 还处理 HTTP 头部、cookie、文件上传、身份验证、重定向、SSL 等等。如往常一样，请参阅[文档](https://httpie.org/doc)'
- en: Test with httpbin
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 httpbin 进行测试
- en: 'You can test your web queries against the site [`httpbin`](https://httpbin.org),
    or download and run the site in a local Docker image:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以针对网站[`httpbin`](https://httpbin.org)测试您的 Web 查询，或者在本地 Docker 映像中下载并运行该站点：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Python’s Standard Web Libraries
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 的标准 Web 库
- en: 'In Python 2, web client and server modules were a bit scattered. One of the
    Python 3 goals was to bundle these modules into two *packages* (remember from
    [Chapter 11](ch11.html#ch_modules) that a package is just a directory containing
    module files):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 2 中，Web 客户端和服务器模块有点分散。Python 3 的目标之一是将这些模块打包成两个*包*（请记住来自[第 11 章](ch11.html#ch_modules)的定义，包只是包含模块文件的目录）：
- en: '`http` manages all the client-server HTTP details:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http` 管理所有客户端-服务器 HTTP 细节：'
- en: '`client` does the client-side stuff'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`client` 处理客户端相关工作'
- en: '`server` helps you write Python web servers'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`server` 帮助你编写 Python Web 服务器'
- en: '`cookies` and `cookiejar` manage cookies, which save data between site visits'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cookies` 和 `cookiejar` 管理 cookie，用于在访问站点时保存数据'
- en: '`urllib` runs on top of `http`:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`urllib` 基于 `http` 运行：'
- en: '`request` handles the client request'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request` 处理客户端请求'
- en: '`response` handles the server response'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`response`处理服务器响应'
- en: '`parse` cracks the parts of a URL'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parse`解析URL的各个部分'
- en: Note
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you’re trying to write code that’s compatible with both Python 2 and Python
    3, keep in mind that `urllib` changed [a lot](https://oreil.ly/ww5_R) between
    the two versions. For a better alternative, refer to [“Beyond the Standard Library:
    requests”](#requests).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图编写同时兼容Python 2和Python 3的代码，请记住`urllib`在这两个版本之间有很大的变化。查看更好的替代方案，请参考[“超越标准库：requests”](#requests)。
- en: 'Let’s use the standard library to get something from a website. The URL in
    the following example returns information from a test website:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用标准库从网站获取一些内容。以下示例中的URL返回来自测试网站的信息：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This little chunk of Python opened a TCP/IP connection to the remote web server
    `www.example.com`, made an HTTP request, and received an HTTP response. The response
    contained more than just the page data. In [the official documentation](http://bit.ly/httpresponse-docs),
    we find that `conn` is an `HTTPResponse` object with a number of methods and attributes.
    One of the most important parts of the response is the HTTP *status code*:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这段小小的Python代码打开了一个到远程Web服务器`www.example.com`的TCP/IP连接，发送了一个HTTP请求，并接收到了一个HTTP响应。响应中包含的不仅仅是页面数据。在[官方文档](http://bit.ly/httpresponse-docs)中，我们发现`conn`是一个具有多个方法和属性的`HTTPResponse`对象。响应的一个重要部分是HTTP
    *状态码*：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A `200` means that everything was peachy. There are dozens of HTTP status codes,
    grouped into five ranges by their first (hundreds) digit:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`200`表示一切顺利。HTTP状态码分为五个范围，根据其第一个（百位）数字进行分组：'
- en: 1xx (information)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 1xx（信息）
- en: The server received the request but has some extra information for the client.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器已接收请求，但有一些额外的信息要传递给客户端。
- en: 2xx (success)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 2xx（成功）
- en: It worked; every success code other than 200 conveys extra details.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 成功；除了200之外的所有成功代码都携带额外的细节。
- en: 3xx (redirection)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 3xx（重定向）
- en: The resource moved, so the response returns the new URL to the client.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 资源已移动，所以响应将新的URL返回给客户端。
- en: 4xx (client error)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 4xx（客户端错误）
- en: Some problem from the client side, such as the well-known 404 (not found). 418
    (*I’m a teapot*) was an April Fool’s joke.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端出现了一些问题，比如众所周知的404（未找到）。418（*我是茶壶*）是愚人节玩笑。
- en: 5xx (server error)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 5xx（服务器错误）
- en: 500 is the generic whoops; you might see a 502 (bad gateway) if there’s some
    disconnect between a web server and a backend application server.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 500是通用的“哎呀”错误；如果Web服务器和后端应用程序服务器之间存在断开连接，则可能会看到502（坏网关）。
- en: 'To get the actual data contents from the web page, use the `read()` method
    of the `conn` variable. This returns a `bytes` value. Let’s get the data and print
    the first 50 bytes:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取网页的实际数据内容，请使用`conn`变量的`read()`方法。这将返回一个`bytes`值。让我们获取数据并打印前50个字节：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can convert these bytes to a string and print its first 50 characters:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些字节转换为字符串，并打印其前50个字符：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The rest is more HTML and CSS.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 其余是更多的HTML和CSS。
- en: Out of sheer curiosity, what HTTP headers were sent back to us?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 纯粹出于好奇，我们收到了哪些HTTP头部回复？
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Remember that `telnet` example a little earlier? Now, our Python library is
    parsing all those HTTP response headers and providing them in a dictionary. `Date`
    and `Server` seem straightforward; some of the others, less so. It’s helpful to
    know that HTTP has a set of standard headers such as `Content-Type`, and many
    optional ones.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得之前的`telnet`示例吗？现在，我们的Python库正在解析所有这些HTTP响应头，并将它们以字典形式提供。`Date`和`Server`似乎很直观；其他一些可能不那么直观。了解HTTP具有一组标准头部，如`Content-Type`和许多可选头部，这是很有帮助的。
- en: 'Beyond the Standard Library: requests'
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超越标准库：requests
- en: At the beginning of [Chapter 1](ch01.html#ch_intro), there was a program that
    accessed a Wayback Machine API by using the standard libraries `urllib.request`
    and `json`. Following that example is a version that uses the third-party module
    `requests`. The `requests` version is shorter and easier to understand.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html#ch_intro)的开头，有一个程序通过使用标准库`urllib.request`和`json`访问了Wayback
    Machine API。接下来是一个使用第三方模块`requests`的版本。`requests`版本更简短，更易于理解。
- en: For most purposes, I think web client development with `requests` is easier.
    You can browse the [documentation](https://oreil.ly/zF8cy) (which is pretty good)
    for full details. I’ll show the basics of `requests` in this section and use it
    throughout this book for web client tasks.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数情况，我认为使用`requests`进行Web客户端开发更容易。你可以浏览[文档](https://oreil.ly/zF8cy)（非常好），了解所有细节。我将在本节中展示`requests`的基础知识，并在整本书中用它来处理Web客户端任务。
- en: 'First, install the `requests` library:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装`requests`库：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let’s redo our example.com query with `requests`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用 `requests` 重新执行我们的 example.com 查询：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To show a JSON query, here’s a minimal version of a program that appears at
    the end of this chapter. You provide a string, and it uses an Internet Archive
    search API to look through the titles of billions of multimedia items saved there.
    Notice that in the `requests.get()` call shown in [Example 18-1](#ex1801), you
    only need to pass a `params` dictionary, and `requests` handles all the query
    construction and character escaping.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示一个JSON查询，这是一个本章末尾出现的程序的最小版本。你提供一个字符串，它使用互联网档案馆搜索API来搜索那里保存的数十亿多媒体项目的标题。请注意，在
    [示例18-1](#ex1801) 中显示的 `requests.get()` 调用中，你只需要传递一个 `params` 字典，`requests` 将处理所有的查询构造和字符转义。
- en: Example 18-1\. ia.py
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-1\. ia.py
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How’s their stock of wendigo items?
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 他们关于食人魔物品的库存如何？
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first column (the *identifier*) can be used to actually view the item at
    the *archive.org* site. You’ll see how to do this at the end of this chapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列（*标识符*）可以用来实际查看存档网站上的项目。你将在本章末尾看到如何做到这一点。
- en: Web Servers
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web服务器
- en: Web developers have found Python to be an excellent language for writing web
    servers and server-side programs. This has led to such a variety of Python-based
    web *frameworks* that it can be hard to navigate among them and make choices—not
    to mention deciding what deserves to go into a book.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Web开发人员发现Python是编写Web服务器和服务器端程序的优秀语言。这导致了许多基于Python的Web *框架* 的出现，以至于在它们中间和做选择时可能很难导航——更不用说决定哪些应该写进一本书了。
- en: A web framework provides features with which you can build websites, so it does
    more than a simple web (HTTP) server. You’ll see features such as routing (URL
    to server function), templates (HTML with dynamic inclusions), debugging, and
    more.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Web框架提供了一些功能，你可以用它来构建网站，所以它不仅仅是一个简单的Web（HTTP）服务器。你会看到一些功能，比如路由（将URL映射到服务器功能）、模板（包含动态内容的HTML）、调试等等。
- en: I’m not going to cover all of the frameworks here—just those that I’ve found
    to be relatively simple to use and suitable for real websites. I’ll also show
    how to run the dynamic parts of a website with Python and other parts with a traditional
    web server.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我不打算在这里涵盖所有的框架，只介绍那些我发现相对简单易用且适合真实网站的。我还会展示如何用Python运行网站的动态部分以及用传统Web服务器运行其他部分。
- en: The Simplest Python Web Server
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最简单的Python Web服务器
- en: 'You can run a simple web server by typing just one line of Python:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入一行Python来运行一个简单的Web服务器：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This implements a bare-bones Python HTTP server. If there are no problems,
    this will print an initial status message:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这实现了一个简单的Python HTTP服务器。如果没有问题，它将打印初始状态消息：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: That `0.0.0.0` means *any TCP address*, so web clients can access it no matter
    what address the server has. There’s more low-level details on TCP and other network
    plumbing for you to read about in [Chapter 17](ch17.html#ch_networks).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 那个 `0.0.0.0` 意味着 *任何TCP地址*，所以Web客户端无论服务器有什么地址都可以访问它。有关TCP和其他网络底层细节，你可以在[第17章](ch17.html#ch_networks)中进一步阅读。
- en: 'You can now request files, with paths relative to your current directory, and
    they will be returned. If you type `http://localhost:8000` in your web browser,
    you should see a directory listing there, and the server will print access log
    lines such as this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以请求文件，路径相对于你当前的目录，它们将被返回。如果在你的Web浏览器中输入 `http://localhost:8000`，你应该能看到那里的目录列表，并且服务器将打印类似这样的访问日志行：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`localhost` and `127.0.0.1` are TCP synonyms for *your local computer*, so
    this works regardless of whether you’re connected to the internet. You can interpret
    this line as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`localhost` 和 `127.0.0.1` 是 *你的本地计算机* 的TCP同义词，所以这在无论你是否连接互联网时都能工作。你可以这样解释这一行：'
- en: '`127.0.0.1` is the client’s IP address'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`127.0.0.1` 是客户端的IP地址'
- en: The first `-` is the remote username, if found
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个 `-` 是远程用户名（如果有的话）
- en: The second `-` is the login username, if required
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个 `-` 是登录用户名（如果需要的话）
- en: '`[20/Feb/2013 22:02:37]` is the access date and time'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[20/Feb/2013 22:02:37]` 是访问的日期和时间'
- en: '`"GET / HTTP/1.1"` is the command sent to the web server:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"GET / HTTP/1.1"` 是发送给Web服务器的命令：'
- en: The HTTP method (`GET`)
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP方法（`GET`）
- en: The resource requested (`/`, the top)
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所请求的资源（`/`，顶层）
- en: The HTTP version (`HTTP/1.1`)
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP版本（`HTTP/1.1`）
- en: The final `200` is the HTTP status code returned by the web server
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后的 `200` 是Web服务器返回的HTTP状态码
- en: 'Click any file. If your browser can recognize the format (HTML, PNG, GIF, JPEG,
    and so on) it should display it, and the server will log the request. For instance,
    if you have the file *oreilly.png* in your current directory, a request for *[*http://localhost:8000/oreilly.png*](http://localhost:8000/oreilly.png)*
    should return the image of the unsettling fellow in [Figure 20-2](ch20.html#tarsier_1),
    and the log should show something such as this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 点击任何文件。如果你的浏览器能够识别格式（HTML、PNG、GIF、JPEG 等），它应该会显示它，并且服务器将记录该请求。例如，如果你的当前目录中有
    *oreilly.png* 文件，请求 *[*http://localhost:8000/oreilly.png*](http://localhost:8000/oreilly.png)*
    应该返回 [图 20-2](ch20.html#tarsier_1) 中那个怪异家伙的图像，并且日志应该显示类似于这样的内容：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you have other files in the same directory on your computer, they should
    show up in a listing on your display, and you can click any one to download it.
    If your browser is configured to display that file’s format, you’ll see the results
    on your screen; otherwise, your browser will ask you if you want to download and
    save the file.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的电脑相同目录下还有其他文件，它们应该显示在你的显示器上，你可以点击任何一个来下载。如果你的浏览器配置了显示该文件的格式，你会在屏幕上看到结果；否则，你的浏览器会询问你是否要下载并保存该文件。
- en: 'The default port number used is 8000, but you can specify another:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 默认使用的端口号是 8000，但你可以指定其他端口号：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You should see this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到这个：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This Python-only server is best suited for quick tests. You can stop it by killing
    its process; in most terminals, press Ctrl+C.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个仅支持 Python 的服务器最适合进行快速测试。你可以通过结束其进程来停止它；在大多数终端中，按 Ctrl+C。
- en: You should not use this basic server for a busy production website. Traditional
    web servers such as Apache and NGINX are much faster for serving static files.
    In addition, this simple server has no way to handle dynamic content, which more
    extensive servers can do by accepting parameters.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该将这个基本服务器用于繁忙的生产网站。传统的 Web 服务器如 Apache 和 NGINX 对于提供静态文件要快得多。此外，这个简单的服务器无法处理动态内容，而更复杂的服务器可以通过接受参数来实现这一点。
- en: Web Server Gateway Interface (WSGI)
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web 服务器网关接口（WSGI）
- en: All too soon, the allure of serving simple files wears off, and we want a web
    server that can also run programs dynamically. In the early days of the web, the
    *Common Gateway Interface* (CGI) was designed for clients to make web servers
    run external programs and return the results. CGI also handled getting input arguments
    from the client through the server to the external programs. However, the programs
    were started anew for *each* client access. This could not scale well, because
    even small programs have appreciable startup time.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，只提供简单文件的吸引力就消失了，我们需要一个能够动态运行程序的 Web 服务器。在 Web 的早期，*通用网关接口*（CGI）是为客户端执行 Web
    服务器运行外部程序并返回结果设计的。CGI 也处理通过服务器从客户端获取输入参数传递到外部程序。然而，这些程序会为 *每个* 客户端访问重新启动。这种方式不能很好地扩展，因为即使是小型程序也有可观的启动时间。
- en: To avoid this startup delay, people began merging the language interpreter into
    the web server. Apache ran PHP within its `mod_php` module, Perl in `mod_perl`,
    and Python in `mod_python`. Then, code in these dynamic languages could be executed
    within the long-running Apache process itself rather than in external programs.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种启动延迟，人们开始将语言解释器合并到 Web 服务器中。Apache 在其 `mod_php` 模块中运行 PHP，Perl 在 `mod_perl`
    中，Python 在 `mod_python` 中。然后，这些动态语言中的代码可以在长时间运行的 Apache 进程中执行，而不是在外部程序中执行。
- en: An alternative method was to run the dynamic language within a separate long-running
    program and have it communicate with the web server. FastCGI and SCGI are examples.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是在单独的长期运行程序中运行动态语言，并让它与 Web 服务器通信。FastCGI 和 SCGI 就是其中的例子。
- en: Python web development made a leap with the definition of the *Web Server Gateway
    Interface* (WSGI), a universal API between Python web applications and web servers.
    All of the Python web frameworks and web servers in the rest of this chapter use
    WSGI. You don’t normally need to know how WSGI works (there really isn’t much
    to it), but it helps to know what some of the parts under the hood are called.
    This is a *synchronous* connection—one step follows another.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Python Web 开发通过定义 *Web 服务器网关接口*（WSGI）迈出了一大步，这是 Python Web 应用程序与 Web 服务器之间的通用
    API。本章剩余部分介绍的所有 Python Web 框架和 Web 服务器都使用 WSGI。通常情况下你不需要知道 WSGI 如何工作（其实它并不复杂），但了解一些底层组成部分的名称有助于你的理解。这是一个
    *同步* 连接，一步接着一步。
- en: ASGI
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ASGI
- en: In a few places so far, I’ve mentioned that Python has been introducing *asynchronous*
    language features like `async`, `await`, and `asyncio`. ASGI (Asynchronous Server
    Gateway Interface) is a counterpart of WSGI that uses these new features. In [Appendix C](app03.html#app_async),
    you’ll see more discussion, and examples of new web frameworks that use ASGI.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，在几个地方，我已经提到Python正在引入像`async`、`await`和`asyncio`这样的*异步*语言特性。ASGI（异步服务器网关接口）是WSGI的一个对应项，它使用这些新特性。在[附录 C](app03.html#app_async)中，您将看到更多讨论，并且会有使用ASGI的新Web框架示例。
- en: Apache
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Apache
- en: The [`apache`](http://httpd.apache.org) web server’s best WSGI module is [`mod_wsgi`](https://code.google.com/p/modwsgi).
    This can run Python code within the Apache process or in separate processes that
    communicate with Apache.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[apache](http://httpd.apache.org) Web服务器最好的WSGI模块是[mod_wsgi](https://code.google.com/p/modwsgi)。这可以在Apache进程内或与Apache通信的独立进程中运行Python代码。'
- en: You should already have `apache` if your system is Linux or macOS. For Windows,
    you’ll need to install [apache](http://bit.ly/apache-http).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统是Linux或macOS，您应该已经有`apache`。对于Windows，您需要安装[apache](http://bit.ly/apache-http)。
- en: Finally, install your preferred WSGI-based Python web framework. Let’s try `bottle`
    here. Almost all of the work involves configuring Apache, which can be a dark
    art.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，安装您喜欢的基于WSGI的Python Web框架。我们在这里尝试`bottle`。几乎所有的工作都涉及配置Apache，这可能是一门黑暗的艺术。
- en: Create the test file shown in [Example 18-2](#ch18_ex01) and save it as */var/www/test/home.wsgi*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 创建如[示例 18-2](#ch18_ex01)所示的测试文件，并将其保存为*/var/www/test/home.wsgi*。
- en: Example 18-2\. home.wsgi
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-2\. home.wsgi
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Do not call `run()` this time, because that starts the built-in Python web server.
    We need to assign to the variable `application` because that’s what `mod_wsgi`
    looks for to marry the web server and the Python code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这次不要调用`run()`，因为它会启动内置的Python Web服务器。我们需要将变量`application`赋值，因为这是`mod_wsgi`用来连接Web服务器和Python代码的地方。
- en: If `apache` and its `mod_wsgi` module are working correctly, we just need to
    connect them to our Python script. We want to add one line to the file that defines
    the default website for this `apache` server, but finding that file is a task
    itself. It could be */etc/apache2/httpd.conf*, or */etc/apache2/sites-available/default*,
    or the Latin name of someone’s pet salamander.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`apache`和其`mod_wsgi`模块正常工作，我们只需将它们连接到我们的Python脚本即可。我们希望在定义此`apache`服务器默认网站的文件中添加一行，但找到该文件本身就是一个任务。它可能是*/etc/apache2/httpd.conf*，也可能是*/etc/apache2/sites-available/default*，或者是某人宠物蝾螈的拉丁名。
- en: 'Let’s assume for now that you understand `apache` and found that file. Add
    this line inside the `<VirtualHost>` section that governs the default website:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设您已经理解了`apache`并找到了那个文件。在管理默认网站的<VirtualHost>部分内添加此行：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'That section might then look like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 那一节可能看起来像这样：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Start `apache`, or restart it if it was running to make it use this new configuration.
    If you then browse to [*http://localhost/*](http://localhost/), you should see:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 启动`apache`，或者如果它已经运行，则重新启动以使用这个新配置。然后，如果您浏览到[*http://localhost/*](http://localhost/)，您应该会看到：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This runs `mod_wsgi` in *embedded mode*, as part of `apache` itself.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在*嵌入模式*下运行`mod_wsgi`，作为`apache`本身的一部分。
- en: 'You can also run it in *daemon mode*, as one or more processes, separate from
    `apache`. To do this, add two new directive lines to your `apache` config file:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以将其以*守护程序模式*运行，作为一个或多个与`apache`分开的进程。为此，请在您的`apache`配置文件中添加两行新的指令行：
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the preceding example, *`user-name`* and *`group-name`* are the operating
    system user and group names, and the *`domain-name`* is the name of your internet
    domain. A minimal `apache` config might look like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，*`user-name`*和*`group-name`*是操作系统用户和组名，*`domain-name`*是您的互联网域名。一个最小的`apache`配置可能如下所示：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: NGINX
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NGINX
- en: The [`NGINX`](http://nginx.org) web server does not have an embedded Python
    module. Instead, it’s a frontend to a separate WSGI server such as uWSGI or gUnicorn.
    Together they make a very fast and configurable platform for Python web development.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[NGINX](http://nginx.org) Web服务器没有内置的Python模块。相反，它是一个前端，用于连接到诸如uWSGI或gUnicorn之类的独立WSGI服务器。它们共同构成了一个非常快速和可配置的Python
    Web开发平台。'
- en: You can install `nginx` from its [website](http://wiki.nginx.org/Install). For
    examples of setting up Flask with NGINX and a WSGI server, see [this](https://oreil.ly/7FTPa).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从其[网站](http://wiki.nginx.org/Install)安装`nginx`。有关使用NGINX和WSGI服务器设置Flask的示例，请参阅[此处](https://oreil.ly/7FTPa)。
- en: Other Python Web Servers
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他Python Web服务器
- en: 'Following are some of the independent Python-based WSGI servers that work like
    `apache` or `nginx`, using multiple processes and/or threads (see [“Concurrency”](ch15.html#concurrency))
    to handle simultaneous requests:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些独立的基于 Python 的 WSGI 服务器，类似于 `apache` 或 `nginx`，使用多进程和/或线程（见[“并发”](ch15.html#concurrency)）处理并发请求：
- en: '[`uwsgi`](http://projects.unbit.it/uwsgi)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`uwsgi`](http://projects.unbit.it/uwsgi)'
- en: '[`cherrypy`](http://www.cherrypy.org)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`cherrypy`](http://www.cherrypy.org)'
- en: '[`pylons`](http://www.pylonsproject.org)'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`pylons`](http://www.pylonsproject.org)'
- en: 'Here are some *event-based* servers, which use a single process but avoid blocking
    on any single request:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些*基于事件*的服务器，它们使用单一进程但避免在任何单个请求上阻塞：
- en: '[`tornado`](http://www.tornadoweb.org)'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`tornado`](http://www.tornadoweb.org)'
- en: '[`gevent`](http://gevent.org)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`gevent`](http://gevent.org)'
- en: '[`gunicorn`](http://gunicorn.org)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`gunicorn`](http://gunicorn.org)'
- en: I have more to say about events in the discussion about *concurrency* in [Chapter 15](ch15.html#ch_systems).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于[第 15 章](ch15.html#ch_systems)中关于*并发*的讨论中，我还有更多要说的。
- en: Web Server Frameworks
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web 服务器框架
- en: Web servers handle the HTTP and WSGI details, but you use web *frameworks* to
    actually write the Python code that powers the site. So, let’s talk about frameworks
    for a while and then get back to alternative ways of actually serving sites that
    use them.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Web 服务器处理 HTTP 和 WSGI 的细节，但是你使用 Web *框架*来实际编写驱动站点的 Python 代码。因此，让我们先谈谈框架，然后再回到实际使用它们的网站服务的替代方法。
- en: 'If you want to write a website in Python, there are many (some say too many)
    Python web frameworks. A web framework handles, at a minimum, client requests
    and server responses. Most major web frameworks include these tasks:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想用 Python 写一个网站，有许多（有人说太多）Python Web 框架。Web 框架至少处理客户端请求和服务器响应。大多数主要的 Web
    框架包括以下任务：
- en: HTTP protocol handling
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 协议处理
- en: Authentication (*authn*, or who are you?)
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证（*authn*，或者你是谁？）
- en: Authorization (*authz*, or what can you do?)
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证（*authz*，或者你可以做什么？）
- en: Establish a session
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立一个会话
- en: Get parameters
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取参数
- en: Validate parameters (required/optional, type, range)
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证参数（必需/可选、类型、范围）
- en: Handle HTTP verbs
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 HTTP 动词
- en: Route (functions/classes)
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由（函数/类）
- en: Serve static files (HTML, JS, CSS, images)
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供静态文件（HTML、JS、CSS、图像）
- en: Serve dynamic data (databases, services)
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供动态数据（数据库、服务）
- en: Return values and HTTP status
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值和 HTTP 状态
- en: 'Optional features include:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 可选功能包括：
- en: Backend templates
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后端模板
- en: Database connectivity, ORMs
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库连接、ORMs
- en: Rate limiting
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速率限制
- en: Asynchronous tasks
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步任务
- en: In the coming sections, we write example code for two frameworks (`bottle` and
    `flask`). These are *synchronous*. Later, I talk about alternatives, especially
    for database-backed websites. You can find a Python framework to power any site
    that you can think of.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将为两个框架（`bottle` 和 `flask`）编写示例代码。这些是*同步*的。稍后，我将讨论特别是用于数据库支持网站的替代方案。你可以找到一个
    Python 框架来支持你可以想到的任何网站。
- en: Bottle
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bottle
- en: 'Bottle consists of a single Python file, so it’s very easy to try out, and
    it’s easy to deploy later. Bottle isn’t part of standard Python, so to install
    it, type the following command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Bottle 由单个 Python 文件组成，因此非常容易尝试，并且稍后易于部署。Bottle 不是标准 Python 的一部分，因此要安装它，请键入以下命令：
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here’s code that will run a test web server and return a line of text when your
    browser accesses the URL *[*http://localhost:9999/*](http://localhost:9999/)*.
    Save it as *bottle1.py* ([Example 18-3](#ch18_ex02)).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个将运行一个测试 Web 服务器并在你的浏览器访问 URL [*http://localhost:9999/*](http://localhost:9999/)
    时返回一行文本的代码。将其保存为 *bottle1.py*（[示例 18-3](#ch18_ex02)）。
- en: Example 18-3\. bottle1.py
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-3\. bottle1.py
- en: '[PRE37]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Bottle uses the `route` decorator to associate a URL with the following function;
    in this case, `/` (the home page) is handled by the `home()` function. Make Python
    run this server script by typing this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Bottle 使用 `route` 装饰器将 URL 关联到以下函数；在这种情况下，`/`（主页）由 `home()` 函数处理。通过键入以下命令使 Python
    运行此服务器脚本：
- en: '[PRE38]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You should see this on your browser when you access *[*http://localhost:9999/*](http://localhost:9999/)*:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当你访问[*http://localhost:9999/*](http://localhost:9999/)时，你应该在你的浏览器上看到这个：
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `run()` function executes `bottle`’s built-in Python test web server. You
    don’t need to use this for `bottle` programs, but it’s useful for initial development
    and testing.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`run()` 函数执行 `bottle` 内置的 Python 测试 Web 服务器。对于 `bottle` 程序，你不需要使用它，但在初始开发和测试时很有用。'
- en: 'Now, instead of creating text for the home page in code, let’s make a separate
    HTML file called *index.html* that contains this line of text:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不再在代码中创建主页文本，让我们创建一个名为 *index.html* 的单独 HTML 文件，其中包含这行文本：
- en: '[PRE40]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Make `bottle` return the contents of this file when the home page is requested.
    Save this script as *bottle2.py* ([Example 18-4](#ch18_ex03)).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使`bottle`在请求主页时返回此文件的内容。将此脚本保存为*bottle2.py*([示例 18-4](#ch18_ex03))。
- en: Example 18-4\. bottle2.py
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-4\. bottle2.py
- en: '[PRE41]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the call to `static_file()`, we want the file `index.html` in the directory
    indicated by `root` (in this case, `''.''`, the current directory). If your previous
    server example code was still running, stop it. Now, run the new server:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`static_file()`时，我们想要的是`root`所指示的目录中的文件`index.html`（在本例中，为 `'.'`，即当前目录）。如果你之前的服务器示例代码仍在运行，请停止它。现在，运行新的服务器：
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'When you ask your browser to get *http:/localhost:9999/*, you should see this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当你请求浏览器获取*http:/localhost:9999/*时，你应该看到这个：
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Let’s add one last example that shows how to pass arguments to a URL and use
    them. Of course, this will be *bottle3.py*, which you can see in [Example 18-5](#ch18_ex04).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们最后添加一个示例，展示如何向 URL 传递参数并使用它们。当然，这将是*bottle3.py*，你可以在[示例 18-5](#ch18_ex04)中看到它。
- en: Example 18-5\. bottle3.py
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-5\. bottle3.py
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We have a new function called `echo()` and want to pass it a string argument
    in a URL. That’s what the line `@route(''/echo/<thing>'')` in the preceding example
    does. That `<thing>` in the route means that whatever was in the URL after `/echo/`
    is assigned to the string argument `thing`, which is then passed to the `echo`
    function. To see what happens, stop the old server if it’s still running and then
    start it with the new code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`echo()`的新函数，并希望在 URL 中传递一个字符串参数。这就是前面示例中的`@route('/echo/<thing>')`一行所做的事情。路由中的`<thing>`意味着在`/echo/`之后的
    URL 中的任何内容都将被分配给字符串参数`thing`，然后传递给`echo`函数。要查看发生了什么，请停止旧服务器（如果仍在运行）然后使用新代码启动它：
- en: '[PRE45]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, access *[*http://localhost:9999/echo/Mothra*](http://localhost:9999/echo/Mothra)*
    in your web browser. You should see the following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在你的网络浏览器中访问*[*http://localhost:9999/echo/Mothra*](http://localhost:9999/echo/Mothra)*。你应该看到以下内容：
- en: '[PRE46]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now, leave *bottle3.py* running for a minute so that we can try something else.
    You’ve been verifying that these examples work by typing URLs into your browser
    and looking at the displayed pages. You can also use client libraries such as
    `requests` to do your work for you. Save this as *bottle_test.py* ([Example 18-6](#ch18_ex05)).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让*bottle3.py*运行一分钟，这样我们可以尝试其他东西。你一直通过在浏览器中输入 URL 并查看显示的页面来验证这些示例是否有效。你也可以使用诸如`requests`之类的客户端库来为你完成工作。将此保存为*bottle_test.py*([示例 18-6](#ch18_ex05))。
- en: Example 18-6\. bottle_test.py
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-6\. bottle_test.py
- en: '[PRE47]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Great! Now, run it:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在，运行它：
- en: '[PRE48]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You should see this in your terminal:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在终端上看到这个：
- en: '[PRE49]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This is a little example of a *unit test*. [Chapter 19](ch19.html#ch_pythonista)
    provides more details on why tests are good and how to write them in Python.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个*单元测试*的小例子。[第 19 章](ch19.html#ch_pythonista)详细介绍了为什么测试很重要以及如何在 Python 中编写测试。
- en: 'There’s more to Bottle than I’ve shown here. In particular, you can try adding
    these arguments when you call `run()`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Bottle 还有更多功能，这里没有展示出来。特别是，你可以在调用`run()`时添加这些参数：
- en: '`debug=True` creates a debugging page if you get an HTTP error;'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug=True`如果出现 HTTP 错误，则会创建一个调试页面；'
- en: '`reloader=True` reloads the page in the browser if you change any of the Python
    code.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reloader=True`如果更改任何 Python 代码，它会在浏览器中重新加载页面。'
- en: It’s well documented at the [developer site](http://bottlepy.org/docs/dev).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这在[开发者网站](http://bottlepy.org/docs/dev)上有详细文档。
- en: Flask
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flask
- en: Bottle is a good initial web framework. If you need a few more cowbells and
    whistles, try Flask. It started in 2010 as an April Fools’ joke, but enthusiastic
    response encouraged the author, Armin Ronacher, to make it a real framework. He
    named the result Flask as a wordplay on Bottle.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Bottle 是一个不错的初始 Web 框架。如果你需要更多功能，可以尝试 Flask。它于 2010 年愚人节笑话开始，但是热烈的反响鼓励了作者阿尔明·罗纳赫将其制作成一个真正的框架。他将结果命名为
    Flask，这是对 Bottle 的一种文字游戏。
- en: Flask is about as simple to use as Bottle, but it supports many extensions that
    are useful in professional web development, such as Facebook authentication and
    database integration. It’s my personal favorite among Python web frameworks because
    it balances ease of use with a rich feature set.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 的使用方法与 Bottle 差不多，但它支持许多在专业 Web 开发中有用的扩展，比如 Facebook 认证和数据库集成。它是我个人在 Python
    Web 框架中的首选，因为它在易用性和丰富功能集之间取得了平衡。
- en: 'The `flask` package includes the `werkzeug` WSGI library and the `jinja2` template
    library. You can install it from a terminal:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`flask`包含`werkzeug` WSGI 库和`jinja2`模板库。你可以从终端安装它：'
- en: '[PRE50]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let’s replicate the final Bottle example code in Flask. First, though, we need
    to make a few changes:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Flask 中复制最终的 Bottle 示例代码。不过，在此之前，我们需要做一些更改：
- en: Flask’s default directory home for static files is `static`, and URLs for files
    there also begin with `/static`. We change the folder to `'.'` (current directory)
    and the URL prefix to `''` (empty) to allow the URL `/` to map to the file *index.html*.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flask的默认静态文件目录主目录是`static`，那里的文件URL也以`/static`开头。我们将文件夹更改为'.'（当前目录），URL前缀更改为''（空），以便将URL`/`映射到文件*index.html*。
- en: In the `run()` function, setting `debug=True` also activates the automatic reloader;
    `bottle` used separate arguments for debugging and reloading.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`run()`函数中，设置`debug=True`还会激活自动重新加载器；`bottle`为调试和重新加载使用了单独的参数。
- en: Save this file to *flask1.py* ([Example 18-7](#ch18_ex06)).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为*flask1.py*（[示例 18-7](#ch18_ex06)）。
- en: Example 18-7\. flask1.py
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-7\. flask1.py
- en: '[PRE51]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, run the server from a terminal or window:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在终端或窗口中运行服务器：
- en: '[PRE52]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Test the home page by typing this URL into your browser:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将此网址输入浏览器中来测试主页：
- en: '[PRE53]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You should see the following (as you did for `bottle`):'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下内容（就像对`bottle`一样）：
- en: '[PRE54]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Try the `/echo` endpoint:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试`/echo`端点：
- en: '[PRE55]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You should see this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到这个：
- en: '[PRE56]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: There’s another benefit to setting `debug` to `True` when calling `run`. If
    an exception occurs in the server code, Flask returns a specially formatted page
    with useful details about what went wrong, and where. Even better, you can type
    some commands to see the values of variables in the server program.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`run`时将`debug`设置为`True`还有另一个好处。如果服务器代码出现异常，Flask将返回一个格式特殊的页面，其中包含有关发生了什么错误以及在哪里的有用详细信息。更好的是，您可以输入一些命令来查看服务器程序中变量的值。
- en: Warning
  id: totrans-274
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Do not set `debug = True` in production web servers. It exposes too much information
    about your server to potential intruders.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在生产Web服务器中设置`debug = True`。这会向潜在入侵者暴露关于您服务器的过多信息。
- en: So far, the Flask example just replicates what we did with Bottle. What can
    Flask do that Bottle can’t? Flask includes `jinja2`, a more extensive templating
    system. Here’s a tiny example of how to use `jinja2` and Flask together.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Flask示例只是复制了我们在Bottle中所做的事情。Flask可以做到Bottle不能做到的是什么？Flask包含`jinja2`，一个更广泛的模板系统。这里是如何将`jinja2`和Flask结合使用的一个小例子。
- en: Create a directory called `templates` and a file within it called *flask2.html*
    ([Example 18-8](#ch18_ex07)).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`templates`的目录，并在其中创建一个名为*flask2.html*的文件（[示例 18-8](#ch18_ex07)）。
- en: Example 18-8\. flask2.html
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-8\. flask2.html
- en: '[PRE57]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Next, we write the server code to grab this template, fill in the value of *thing*
    that we passed it, and render it as HTML (I’m dropping the `home()` function here
    to save space). Save this as *flask2.py* ([Example 18-9](#ch18_ex08)).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写服务器代码来获取此模板，填充我们传递给它的*thing*的值，并将其呈现为HTML（我在这里省略了`home()`函数以节省空间）。将其保存为*flask2.py*（[示例 18-9](#ch18_ex08)）。
- en: Example 18-9\. flask2.py
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-9\. flask2.py
- en: '[PRE58]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: That `thing = thing` argument means to pass a variable named `thing` to the
    template, with the value of the string `thing`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 那个`thing = thing`参数意味着将一个名为`thing`的变量传递给模板，其值为字符串`thing`。
- en: 'Ensure that *flask1.py* isn’t still running and then start *flask2.py*:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 确保*flask1.py*没有在运行，并启动*flask2.py*：
- en: '[PRE59]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, type this URL:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输入此网址：
- en: '[PRE60]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You should see the following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下内容：
- en: '[PRE61]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let’s modify our template and save it in the *templates* directory as *flask3.html*:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的模板，并将其保存在*templates*目录中，文件名为*flask3.html*：
- en: '[PRE62]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: You can pass this second argument to the `echo` URL in many ways.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过多种方式将第二个参数传递给`echo`网址。
- en: Pass an argument as part of the URL path
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为URL路径的一部分传递一个参数
- en: Using this method, you simply extend the URL itself. Save the code shown in
    [Example 18-10](#ch18_ex10) as *flask3a.py*.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法，您只需扩展URL本身。将[示例 18-10](#ch18_ex10)中显示的代码保存为*flask3a.py*。
- en: Example 18-10\. flask3a.py
  id: totrans-295
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-10\. flask3a.py
- en: '[PRE63]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'As usual, stop the previous test server script if it’s still running and then
    try this new one:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，如果之前的测试服务器脚本仍在运行，请先停止它，然后尝试这个新的：
- en: '[PRE64]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The URL would look like this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: URL将如下所示：
- en: '[PRE65]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'And you should see the following:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 而且您应该看到以下内容：
- en: '[PRE66]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Or, you can provide the arguments as `GET` parameters, as shown in [Example 18-11](#ch18_ex11);
    save this as *flask3b.py*.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以按照[示例 18-11](#ch18_ex11)中显示的方式将参数作为`GET`参数提供；将其保存为*flask3b.py*。
- en: Example 18-11\. flask3b.py
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-11\. flask3b.py
- en: '[PRE67]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Run the new server script:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 运行新的服务器脚本：
- en: '[PRE68]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This time, use this URL:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，使用此网址：
- en: '[PRE69]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'You should get back what you see here:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到与这里看到的相同的结果：
- en: '[PRE70]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: When a `GET` command is used for a URL, any arguments are passed in the form
    ``&*`key1`*=*`val1`*&*`key2`*=*`val2`*&...``
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`GET`命令访问URL时，任何参数都以``&*`key1`*=*`val1`*&*`key2`*=*`val2`*&...``的形式传递。
- en: You can also use the dictionary `**` operator to pass multiple arguments to
    a template from a single dictionary (call this *flask3c.py*), as shown in [Example 18-12](#ch18_ex12).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用字典 `**` 运算符将多个参数从单个字典传递到模板（称为 *flask3c.py*），如 [示例 18-12](#ch18_ex12) 所示。
- en: Example 18-12\. flask3c.py
  id: totrans-314
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-12\. flask3c.py
- en: '[PRE71]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: That `**kwargs` acts like `thing=thing, place=place`. It saves some typing if
    there are a lot of input arguments.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`**kwargs` 就像 `thing=thing, place=place`。如果有很多输入参数，这样可以节省一些输入。'
- en: The `jinja2` templating language does a lot more than this. If you’ve programmed
    in PHP, you’ll see many similarities.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`jinja2` 模板语言比这个做的更多。如果你用过 PHP 编程，你会看到很多相似之处。'
- en: Django
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Django
- en: '[`Django`](https://www.djangoproject.com) is a very popular Python web framework,
    especially for large sites. It’s worth learning for many reasons, including frequent
    requests for `django` experience in Python job ads. It includes ORM code (we talked
    about ORMs in [“The Object-Relational Mapper (ORM)”](ch16.html#orms)) to create
    automatic web pages for the typical database *CRUD* functions (create, replace,
    update, delete) that we looked at in [Chapter 16](ch16.html#ch_databases). It
    also includes some automatic admin pages for these, but they’re designed for internal
    use by programmers rather than public web page use. You don’t have to use `Django`’s
    ORM if you prefer another, such as SQLAlchemy, or direct SQL queries.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Django`](https://www.djangoproject.com) 是一个非常流行的 Python web 框架，特别适用于大型网站。有很多理由值得学习它，包括
    Python 工作广告中对 `django` 经验的频繁需求。它包括 ORM 代码（我们在 [“对象关系映射器（ORM）”](ch16.html#orms)
    中讨论了 ORM）来为典型数据库的 *CRUD* 功能（创建、替换、更新、删除）自动生成网页，我们在 [第 16 章](ch16.html#ch_databases)
    中看过。它还包括一些自动管理页面，但这些页面设计用于程序员内部使用，而不是公共网页使用。如果你喜欢其他 ORM，比如 SQLAlchemy 或直接 SQL
    查询，你也不必使用 `Django` 的 ORM。'
- en: Other Frameworks
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他框架
- en: 'You can compare the frameworks by viewing this [online table](http://bit.ly/web-frames):'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查看这个 [在线表格](http://bit.ly/web-frames) 来比较这些框架：
- en: '[`fastapi`](https://fastapi.tiangelo.com) handles both synchronous (WSGI) and
    asynchronous (ASGI) calls, uses type hints, generates test pages, and is well
    documented. Recommended.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`fastapi`](https://fastapi.tiangelo.com) 处理同步（WSGI）和异步（ASGI）调用，使用类型提示，生成测试页面，文档齐全。推荐使用。'
- en: '[`web2py`](http://www.web2py.com) covers much the same ground as `django`,
    with a different style.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`web2py`](http://www.web2py.com) 覆盖了与 `django` 类似的大部分领域，但风格不同。'
- en: '[`pyramid`](https://trypyramid.com) grew from the earlier `pylons` project,
    and is similar to `django` in scope.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`pyramid`](https://trypyramid.com) 从早期的 `pylons` 项目发展而来，与 `django` 在范围上类似。'
- en: '[`turbogears`](http://turbogears.org) supports an ORM, many databases, and
    multiple template languages.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`turbogears`](http://turbogears.org) 支持 ORM、多个数据库和多个模板语言。'
- en: '[`wheezy.web`](http://pythonhosted.org/wheezy.web) is a newer framework optimized
    for performance. It was [faster](http://bit.ly/wheezyweb) than the others in a
    recent test.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`wheezy.web`](http://pythonhosted.org/wheezy.web) 是一个性能优化的较新框架。它在最近的测试中比其他框架都要
    [快](http://bit.ly/wheezyweb)。'
- en: '[`molten`](https://moltenframework.com) also uses type hints, but only supports
    WSGI.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`molten`](https://moltenframework.com) 也使用类型提示，但仅支持 WSGI。'
- en: '[`apistar`](https://docs.apistar.com) is similar to fastapi, but is more of
    an API validation tool than a web framework.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`apistar`](https://docs.apistar.com) 类似于 fastapi，但更像是 API 验证工具而不是 web 框架。'
- en: '[`masonite`](https://docs.masoniteproject.com) is a Python version of Ruby
    on Rails, or PHP’s Laravel.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`masonite`](https://docs.masoniteproject.com) 是 Python 版本的 Ruby on Rails 或
    PHP 的 Laravel。'
- en: Database Frameworks
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库框架
- en: 'The web and databases are the peanut butter and jelly of computing: where you
    find one, you’ll eventually find the other. In real-life Python applications,
    at some point you’ll probably need to provide a web interface (site and/or API)
    to a relational database.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算中，网络和数据库就像花生酱和果冻一样，一个地方会找到另一个地方。在现实生活中的 Python 应用程序中，你可能需要为关系数据库提供网页界面（网站和/或
    API）。
- en: 'You could build your own with:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用以下方法构建自己的：
- en: A web framework like Bottle or Flask
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像 Bottle 或 Flask 这样的 web 框架
- en: A database package, like db-api or SQLAlchemy
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数据库包，比如 db-api 或 SQLAlchemy
- en: A database driver, like pymysql
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库驱动，比如 pymysql
- en: 'Instead, you could use a web/database package like one of these:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可以使用像这些之一的 web/数据库包：
- en: '[connexion](https://connexion.readthedocs.io)'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[connexion](https://connexion.readthedocs.io)'
- en: '[datasette](https://datasette.readthedocs.io)'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[datasette](https://datasette.readthedocs.io)'
- en: '[sandman2](https://github.com/jeffknupp/sandman2)'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[sandman2](https://github.com/jeffknupp/sandman2)'
- en: '[flask-restless](https://flask-restless.readthedocs.io)'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[flask-restless](https://flask-restless.readthedocs.io)'
- en: Or, you could use a framework with built-in database support, like Django.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用一个具有内置数据库支持的框架，比如 Django。
- en: Your database may not be a relational one. If your data schema varies significantly—columns
    that differ markedly across rows—it might be worthwhile to consider a *schemaless*
    database, such as one of the *NoSQL* databases discussed in [Chapter 16](ch16.html#ch_databases).
    I once worked on a site that initially stored its data in a NoSQL database, switched
    to a relational one, on to another relational one, to a different NoSQL one, and
    then finally back to one of the relational ones.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 你的数据库可能不是关系型的。如果你的数据模式差异显著——不同行之间的列差异较大——考虑使用一个*无模式*数据库可能会更有价值，比如[第16章](ch16.html#ch_databases)中讨论的某些*NoSQL*数据库。我曾在一个网站工作过，最初将其数据存储在一个
    NoSQL 数据库中，然后切换到关系型数据库，再到另一个关系型数据库，然后再到另一个不同的 NoSQL 数据库，最后又回到一个关系型数据库。
- en: Web Services and Automation
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web Services and Automation
- en: We’ve just looked at traditional web client and server applications, consuming
    and generating HTML pages. Yet the web has turned out to be a powerful way to
    glue applications and data in many more formats than HTML.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看了传统的网络客户端和服务器应用程序，消费和生成 HTML 页面。然而，网络已经被证明是将应用程序和数据粘合在一起的强大方式，支持比 HTML
    更多格式的数据。
- en: webbrowser
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: webbrowser
- en: 'Let’s start begin a little surprise. Start a Python session in a terminal window
    and type the following:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始一个小小的惊喜。在终端窗口中启动一个 Python 会话，并输入以下内容：
- en: '[PRE72]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This secretly calls the standard library’s `webbrowser` module and directs your
    browser to an enlightening Python link.^([3](ch18.html#idm45794968721928))
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这会秘密调用标准库的 `webbrowser` 模块，并将你的浏览器导向一个启发性的 Python 链接。^([3](ch18.html#idm45794968721928))
- en: 'You can use this module directly. This program loads the main Python site’s
    page in your browser:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接使用这个模块。这个程序会在你的浏览器中加载主 Python 网站的页面：
- en: '[PRE73]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This opens it in a new window:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在一个新窗口中打开：
- en: '[PRE74]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'And this opens it in a new tab, if your browser supports tabs:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在一个新标签页中打开，如果你的浏览器支持标签页的话：
- en: '[PRE75]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The `webbrowser` makes your browser do all the work.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`webbrowser` 让你的浏览器做所有的工作。'
- en: webview
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: webview
- en: 'Rather than calling your browser as `webbrowser` does, `webview` displays the
    page in its own window, using your machine’s native GUI. To install on Linux or
    macOS:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`webview` 与 `webbrowser` 不同，它在自己的窗口中显示页面，使用您计算机的本地图形用户界面。要在 Linux 或 macOS 上安装：'
- en: '[PRE76]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'For Windows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows：
- en: '[PRE77]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: See the installation [notes](https://oreil.ly/NiYD7) if you have problems.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到问题，请查看安装[说明](https://oreil.ly/NiYD7)。
- en: 'Here’s an example in which I gave it the official US government current time
    site:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，我访问了美国政府官方当前时间的网站：
- en: '[PRE78]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[Figure 18-1](#fig1801) shows the result I got back.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '[图18-1](#fig1801) 显示了我得到的结果。'
- en: '![inp2 1801](assets/inp2_1801.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![inp2 1801](assets/inp2_1801.png)'
- en: Figure 18-1\. `webview` display window
  id: totrans-366
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图18-1\. `webview` 显示窗口
- en: To stop the program, kill the display window.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止程序，请关闭显示窗口。
- en: Web APIs and REST
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web API 和 REST
- en: Often, data is available only within web pages. If you want to access it, you
    need to access the pages through a web browser and read it. If the authors of
    the website made any changes since the last time you visited, the location and
    style of the data might have changed.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 数据通常仅在网页中可用。如果你想要访问这些数据，就需要通过网络浏览器访问页面并读取它。如果网站的作者自你上次访问以来进行了任何更改，数据的位置和样式可能已经改变。
- en: Instead of publishing web pages, you can provide data through a web *application
    programming interface* (API). Clients access your service by making requests to
    URLs and getting back responses containing status and data. Instead of HTML pages,
    the data is in formats that are easier for programs to consume, such as JSON or
    XML (refer to [Chapter 16](ch16.html#ch_databases) for more about these formats).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过网络*应用程序编程接口*（API）提供数据，而不是发布网页。客户端通过向 URL 发送请求并获取包含状态和数据的响应来访问你的服务。数据不是
    HTML 页面，而是更易于程序消费的格式，比如 JSON 或 XML（关于这些格式的更多信息请参考[第16章](ch16.html#ch_databases)）。
- en: '*Representational State Transfer* (REST) was defined by Roy Fielding in his
    doctoral thesis. Many products claim to have a *REST interface* or a *RESTful
    interface*. In practice, this often only means that they have a *web* interface—definitions
    of URLs to access a web service.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '*表述性状态转移*（REST）由罗伊·菲尔丁在他的博士论文中定义。许多产品声称拥有*REST接口*或*RESTful接口*。实际上，这通常意味着它们拥有一个*Web接口*——用于访问Web服务的URL定义。'
- en: 'A *RESTful* service uses the HTTP *verbs* in specific ways:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*RESTful*服务以特定方式使用HTTP *动词*：
- en: '`HEAD` gets information about the resource, but not its data.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HEAD` 获取资源的信息，但不获取其数据。'
- en: '`GET` retrieves the resource’s data from the server. This is the standard method
    used by your browser. `GET` should not be used to create, change, or delete data.'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` 从服务器检索资源的数据。这是你的浏览器使用的标准方法。`GET` 不应该用于创建、更改或删除数据。'
- en: '`POST` creates a new resource.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST` 创建一个新的资源。'
- en: '`PUT` replaces an existing resource, creating it if it doesn’t exist.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT` 替换现有资源，如果不存在则创建。'
- en: '`PATCH` partially updates a resource.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH` 部分更新资源。'
- en: '`DELETE` deletes. Truth in advertising!'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE` 删除。广告里面的真相！'
- en: A RESTful client can also request one or more content types from the server
    by using HTTP request headers. For example, a complex service with a REST interface
    might prefer its input and output to be JSON strings.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 RESTful 客户端也可以通过使用 HTTP 请求头从服务器请求一个或多个内容类型。例如，具有 REST 接口的复杂服务可能更喜欢其输入和输出为
    JSON 字符串。
- en: Crawl and Scrape
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 爬取和抓取
- en: Sometimes, you might want a little bit of information—a movie rating, stock
    price, or product availability—but what you need is available only in HTML pages,
    surrounded by ads and extraneous content.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能只想要一点信息——电影评分、股价或产品可用性，但你需要的信息只在由广告和无关内容环绕的 HTML 页面中。
- en: 'You could extract what you’re looking for manually by doing the following:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下步骤手动提取你要查找的信息：
- en: Type the URL into your browser.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 URL 输入到你的浏览器中。
- en: Wait for the remote page to load.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待远程页面加载。
- en: Look through the displayed page for the information you want.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在显示的页面中查找你想要的信息。
- en: Write it down somewhere.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 把它写在某个地方。
- en: Possibly repeat the process for related URLs.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能要重复处理相关的网址。
- en: However, it’s much more satisfying to automate some or all of these steps. An
    automated web fetcher is called a *crawler* or *spider*.^([4](ch18.html#idm45794968478664))
    After the contents have been retrieved from the remote web servers, a *scraper*
    parses it to find the needle in the haystack.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，自动化一些或所有这些步骤会更加令人满足。自动网络抓取器称为*爬虫*或*蜘蛛*。^([4](ch18.html#idm45794968478664))
    在从远程 Web 服务器检索内容后，*抓取器*会解析它以在海量信息中找到所需的信息。
- en: Scrapy
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scrapy
- en: 'If you need an industrial-strength combined crawler *and* scraper, [Scrapy](http://scrapy.org)
    is worth downloading:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个强大的联合爬虫*和*抓取器，[Scrapy](http://scrapy.org)值得下载：
- en: '[PRE79]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This installs the module and a standalone command-line `scrapy` program.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装模块和一个独立的命令行`scrapy`程序。
- en: Scrapy is a framework, not just a module such as `BeautifulSoup`. It does more,
    but it’s more complex to set up. To learn more about Scrapy, read [“Scrapy at
    a Glance”](https://oreil.ly/8IYoe) and the [tutorial](https://oreil.ly/4H_AW).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: Scrapy 是一个框架，不仅仅是一个模块，比如`BeautifulSoup`。它功能更强大，但设置更复杂。想了解更多关于 Scrapy 的信息，请阅读[“Scrapy
    简介”](https://oreil.ly/8IYoe)和[教程](https://oreil.ly/4H_AW)。
- en: BeautifulSoup
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BeautifulSoup
- en: 'If you already have the HTML data from a website and just want to extract data
    from it, [`BeautifulSoup`](https://oreil.ly/c43mV) is a good choice. HTML parsing
    is harder than it sounds. This is because much of the HTML on public web pages
    is technically invalid: unclosed tags, incorrect nesting, and other complications.
    If you try to write your own HTML parser by using regular expressions (discussed
    in [“Text Strings: Regular Expressions”](ch12.html#regex)) you’ll soon encounter
    these messes.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经从网站获得了 HTML 数据，只想从中提取数据，[`BeautifulSoup`](https://oreil.ly/c43mV)是一个不错的选择。HTML
    解析比听起来要难。这是因为公共网页上的大部分 HTML 在技术上都是无效的：未闭合的标签，不正确的嵌套以及其他复杂情况。如果你试图通过使用正则表达式（在[“文本字符串：正则表达式”](ch12.html#regex)中讨论）编写自己的
    HTML 解析器，很快就会遇到这些混乱。
- en: 'To install `BeautifulSoup`, type the following command (don’t forget the final
    `4`, or `pip` will try to install an older version and probably fail):'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`BeautifulSoup`，输入以下命令（不要忘记最后的`4`，否则`pip`会尝试安装旧版本并且可能失败）：
- en: '[PRE80]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Now, let’s use it to get all the links from a web page. The HTML `a` element
    represents a link, and `href` is its attribute representing the link destination.
    In [Example 18-13](#ch18_ex13), we’ll define the function `get_links()` to do
    the grunt work, and a main program to get one or more URLs as command-line arguments.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用它来获取网页上的所有链接。HTML `a` 元素表示一个链接，`href` 是表示链接目标的属性。在[例子 18-13](#ch18_ex13)中，我们将定义函数`get_links()`来完成这项繁重的工作，并且一个主程序来获取一个或多个
    URL 作为命令行参数。
- en: Example 18-13\. links.py
  id: totrans-399
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子 18-13\. links.py
- en: '[PRE81]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'I saved this program as *links.py* and then ran this command:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我把这个程序保存为*links.py*，然后运行这个命令：
- en: '[PRE82]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Here are the first few lines that it printed:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它打印的前几行：
- en: '[PRE83]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Requests-HTML
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Requests-HTML
- en: Kenneth Reitz, the author of the popular web client package `requests`, has
    written a new scraping library called [requests-html](http://html.python-requests.org)
    (for Python 3.6 and newer versions).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: Kenneth Reitz，流行的Web客户端包`requests`的作者，已经编写了一个名为[requests-html](http://html.python-requests.org)的新抓取库（适用于Python
    3.6及更新版本）。
- en: It gets a page and processes its elements, so you can find, for example, all
    of its links, or all the contents or attributes of any HTML element.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 它获取一个页面并处理其元素，因此你可以查找例如其所有链接或任何HTML元素的所有内容或属性。
- en: It has a clean design, similar to `requests` and other packages by the same
    author. Overall, it may be easier to use than `beautifulsoup` or Scrapy.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有干净的设计，类似于`requests`和其他同一作者的包。总体而言，它可能比`beautifulsoup`或Scrapy更容易使用。
- en: Let’s Watch a Movie
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们看电影
- en: Let’s build a full program.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个完整的程序。
- en: It searches for videos using an API at the Internet Archive.^([5](ch18.html#idm45794968341672))
    This is one of the few APIs that allows anonymous access *and* should still be
    around after this book is printed.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用Internet Archive的API搜索视频。^([5](ch18.html#idm45794968341672)) 这是为数不多允许匿名访问*且*在本书印刷后仍应存在的API之一。
- en: Note
  id: totrans-412
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Most web APIs require you to first get an *API key*, and provide it every time
    you access that API. Why? It’s the tragedy of the commons: free resources with
    anonymous access are often overused or abused. That’s why we can’t have nice things.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网络API要求你首先获取一个*API密钥*，并在每次访问该API时提供它。为什么？这是公地悲剧：匿名访问的免费资源经常被过度使用或滥用。这就是为什么我们不能有好东西。
- en: 'The following program shown in [Example 18-14](#ch18_ex14) does the following:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 18-14](#ch18_ex14)中显示的以下程序执行以下操作：
- en: Prompts you for part of a movie or video title
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示你输入电影或视频标题的一部分
- en: Searches for it at the Internet Archive
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Internet Archive搜索它
- en: Returns a list of identifiers, names, and descriptions
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回标识符、名称和描述的列表
- en: Lists them and asks you to select one
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出它们并要求你选择其中一个
- en: Displays that video in your web browser
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的Web浏览器中显示该视频
- en: Save this as *iamovies.py*.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 将此保存为*iamovies.py*。
- en: The `search()` function uses `requests` to access the URL, get the results,
    and convert them to JSON. The other functions handle everything else. You’ll see
    usage of list comprehensions, string slices, and other things that you’ve seen
    in previous chapters. (The line numbers are not part of the source; they’ll be
    used in the exercises to locate code pieces.)
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`search()`函数使用`requests`访问URL，获取结果并将其转换为JSON。其他函数处理其他所有事务。你会看到列表推导、字符串切片和你在之前章节中看到的其他内容。（行号不是源代码的一部分；它们将用于练习中定位代码片段。）'
- en: Example 18-14\. iamovies.py
  id: totrans-422
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 18-14\. iamovies.py
- en: '[PRE84]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Here’s what I got when I ran this program and searched for **`eegah`**:^([6](ch18.html#idm45794968318712))
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我运行此程序并搜索**`eegah`**时得到的结果：^([6](ch18.html#idm45794968318712))
- en: '[PRE85]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: It displayed the page in my browser, ready to run ([Figure 18-2](#fig1802)).
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 它在我的浏览器中显示了页面，准备运行（[图 18-2](#fig1802)）。
- en: '![inp2 1802](assets/inp2_1802.png)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![inp2 1802](assets/inp2_1802.png)'
- en: Figure 18-2\. Movie search result
  id: totrans-428
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 18-2\. 电影搜索结果
- en: Coming Up
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即将发生的事情
- en: The next chapter is an extremely practical one, covering the nuts and bolts
    of modern Python development. Learn how to become a steely-eyed, card-carrying
    Pythonista.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章是一个非常实用的章节，涵盖现代Python开发的方方面面。学习如何成为一个眼明手快、持有Python会员卡的Pythonista。
- en: Things to Do
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要做的事情
- en: 18.1 If you haven’t installed `flask` yet, do so now. This will also install
    `werkzeug`, `jinja2`, and possibly other packages.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 18.1 如果你还没有安装`flask`，请立即安装。这也会安装`werkzeug`、`jinja2`和可能的其他包。
- en: 18.2 Build a skeleton website, using Flask’s debug/reload development web server.
    Ensure that the server starts up for hostname `localhost` on default port `5000`.
    If your computer is already using port 5000 for something else, use another port
    number.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 18.2 使用Flask的调试/重新加载开发Web服务器构建一个骨架网站。确保服务器在默认端口`5000`上为主机名`localhost`启动。如果你的计算机已经在使用端口5000进行其他操作，请使用其他端口号。
- en: 18.3 Add a `home()` function to handle requests for the home page. Set it up
    to return the string `It's alive!`.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 18.3 添加一个`home()`函数来处理对主页的请求。设置它返回字符串`It's alive!`。
- en: '18.4 Create a Jinja2 template file called *home.html* with the following contents:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 18.4 创建一个名为*home.html*的Jinja2模板文件，内容如下：
- en: '[PRE86]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '18.5 Modify your server’s `home()` function to use the *home.html* template.
    Provide it with three `GET` parameters: `thing`, `height`, and `color`.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 18.5 修改你的服务器的`home()`函数，使用*home.html*模板。为其提供三个`GET`参数：`thing`、`height`和`color`。
- en: ^([1](ch18.html#idm45794970286888-marker)) A company founded by Steve Jobs during
    his exile from Apple.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch18.html#idm45794970286888-marker)) 史蒂夫·乔布斯在被迫离开苹果期间创立的一家公司。
- en: ^([2](ch18.html#idm45794970285336-marker)) Let’s kill a *zombie lie* here. Senator
    (and later, Vice President) Al Gore championed bipartisan legislation and cooperation
    that greatly advanced the early internet, including funding for the group that
    wrote Mosaic. He never claimed that he “invented the internet”; that phrase was
    falsely attributed to him by political rivals as he began running for president
    in 2000.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch18.html#idm45794970285336-marker)) 让我们在这里揭穿一个*僵尸谎言*。参议员（后来是副总统）阿尔·戈尔倡导了大力推动早期互联网发展的两党立法和合作，包括为编写Mosaic的团队提供资金。他从未声称自己“发明了互联网”；这个短语是在2000年他开始竞选总统时由政治对手错误地归因给他的。
- en: ^([3](ch18.html#idm45794968721928-marker)) If you don’t see it for some reason,
    visit [xkcd](http://xkcd.com/353).
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch18.html#idm45794968721928-marker)) 如果出现某种原因没有看到它，请访问[xkcd](http://xkcd.com/353)。
- en: ^([4](ch18.html#idm45794968478664-marker)) Unappealing terms to arachnophobes.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch18.html#idm45794968478664-marker)) 对恐蜘蛛症患者来说，这些术语可能不吸引人。
- en: ^([5](ch18.html#idm45794968341672-marker)) If you remember, I used another Archive
    API in the main example program we looked at in [Chapter 1](ch01.html#ch_intro).
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch18.html#idm45794968341672-marker)) 如果你还记得，在我们在[第一章](ch01.html#ch_intro)中看到的主要示例程序中，我使用了另一个档案
    API。
- en: ^([6](ch18.html#idm45794968318712-marker)) With Richard Kiel as the caveman,
    years before he was Jaws in a Bond movie.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch18.html#idm45794968318712-marker)) 由理查德·基尔饰演穴居人，这是他在邦德电影中扮演钢牙前的多年。
