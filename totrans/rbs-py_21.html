<html><head></head><body>
<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 18. Event-Driven Architecture" class="preface"><div class="preface" id="ch18">
<h1 class="calibre10" id="calibre_pb_0"><span class="calibre">Chapter 18. </span>Event-Driven Architecture</h1>


<p class="author1">Extensibility is important at every level of your codebase. At the code level, you employ extensibility to make your functions and classes flexible. <a data-type="indexterm" data-primary="event-driven architecture" id="ix_evnt" class="calibre5"/>At the abstract level, you utilize the same principles in your codebase’s architecture. <em class="calibre6">Architecture</em> is the set of high-level guidelines and constraints that shape how you design software. <a data-type="indexterm" data-primary="architecture, defined" id="idm45644730657144" class="calibre5"/>It is the vision that influences all developers, past, present, and future. This chapter, as well as the next one, are going to show two examples of how architectural examples improve maintability. Everything you’ve learned so far in this part of the book applies: good architecture promotes extensibility, manages dependencies well, and fosters composability.</p>

<p class="author1">In this chapter, you will learn about event-driven architecture. <em class="calibre6">Event-driven architecture</em> revolves around events, or notifications in your system. It is a fantastic way to decouple different parts of your codebase, as well as extend your system for new functionality or performance. Event-driven architectures allow you to introduce new changes easily with minimal impact. First, I want to talk about the flexibility that event-driven architectures provide. Then, I’ll cover two separate variations of event-driven architectures: simple events and streaming events. While they are similar, you will use them in slightly different scenarios.</p>






</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 18. Event-Driven Architecture" class="preface">
<div class="preface" id="ch18">
<section data-type="sect1" data-pdf-bookmark="How It Works" class="preface"><div class="preface" id="idm45644730654424">
<h1 class="calibre12" id="calibre_pb_1">How It Works</h1>

<p class="author1">When you focus on event-driven architectures, you are revolving around reactions to stimuli.<a data-type="indexterm" data-primary="event-driven architecture" data-secondary="how it works" id="idm45644730652392" class="calibre5"/> You deal with reactions to simuli all the time, whether it’s pulling a casserole out of the oven or picking up a delivery from your front door after a phone notification.<a data-type="indexterm" data-primary="producers–consumers of events" id="idm45644730651080" class="calibre5"/> In an event-driven architecture, you architect your code to represent this model. Your stimulus is some <em class="calibre6">producer</em> of events. <a data-type="indexterm" data-primary="consumers of events" data-seealso="producers–consumers of events" id="idm45644730649752" class="calibre5"/>A <em class="calibre6">consumer</em> of these events is the reaction to that stimulus. An event is just a transmission of information from a producer to a consumer. <a data-type="xref" href="part0023_split_001.html#producer_consumer_table" class="calibre5">Table 18-1</a> shows some common producer–consumer pairs.</p>
<table id="producer_consumer_table" class="calibre45">
<caption class="calibre46"><span class="calibre">Table 18-1. </span>Everyday events and their consumers</caption>
<thead class="calibre47">
<tr class="calibre48">
<th class="calibre49">Producer</th>
<th class="calibre49">Consumer</th>
</tr>
</thead>
<tbody class="calibre50">
<tr class="calibre48">
<td class="calibre51"><p class="author1">Kitchen timer going off</p></td>
<td class="calibre51"><p class="author1">Chef retrieves a casserole from the oven</p></td>
</tr>
<tr class="calibre53">
<td class="calibre51"><p class="author1">Cook ringing a bell when a dish is done</p></td>
<td class="calibre51"><p class="author1">Server picks it up and serves it</p></td>
</tr>
<tr class="calibre48">
<td class="calibre51"><p class="author1">Alarm clock going off</p></td>
<td class="calibre51"><p class="author1">Late sleeper wakes up</p></td>
</tr>
<tr class="calibre53">
<td class="calibre51"><p class="author1">A last call for boarding at an airport</p></td>
<td class="calibre51"><p class="author1">Rushing family rushes, trying to make their connection</p></td>
</tr>
</tbody>
</table>

<p class="author1">You actually deal with producers and consumers every time you program. Any function that returns a value is a producer, and any piece of code that uses that returned value is a consumer. Observe:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">complete_order</code><code class="calibre17">(</code><code class="n">order</code><code class="calibre17">:</code> <code class="n">Order</code><code class="calibre17">):</code>
    <code class="n">package_order</code><code class="calibre17">(</code><code class="n">order</code><code class="calibre17">)</code>
    <code class="n">notify_customer_that_order_is_done</code><code class="calibre17">(</code><code class="n">order</code><code class="calibre17">)</code>
    <code class="n">notify_restaurant_that_order_is_done</code><code class="calibre17">(</code><code class="n">order</code><code class="calibre17">)</code></pre>

<p class="author1">In this case, <code class="calibre17">complete_order</code> is <em class="calibre6">producing</em> information in the form of a completed order. Based on the function names, the customer and the restaurant are <em class="calibre6">consuming</em> the fact that an order is done. There is a direct linkage where the producer notifies the consumer. Event-driven architectures aim to sever this physical dependency.<a data-type="indexterm" data-primary="coupling" data-secondary="decoupling of producers and consumers of events" id="idm45644730415416" class="calibre5"/> The goal is to decouple producers and consumers. Producers do not know about the consumers, and consumers do not know about the producers. This is what drives the flexibility of an event-driven architecture.</p>

<p class="author1">With this decoupling, it becomes incredibly easy to add onto your system. If you need new consumers, you can add them without ever touching the producer. If you need different producers, you can add them without ever touching the consumers. This bidirectional extensibility allows you to substantially change multiple parts of your codebase in isolation.<a data-type="indexterm" data-primary="extensibility" data-secondary="bidirectional, of event-driven architectures" id="idm45644730413272" class="calibre5"/></p>

<p class="author1">What’s happening behind the scenes is quite ingenious. Instead of any dependencies <a data-type="indexterm" data-primary="transport mechanisms" id="idm45644730411880" class="calibre5"/>between producer and consumer, they both depend on a transport mechanism, as shown in <a data-type="xref" href="part0023_split_001.html#transport_mechanism" class="calibre5">Figure 18-1</a>. A <em class="calibre6">transport mechanism</em> is simply the way that two pieces of code pass data back and forth.</p>

<figure class="calibre36"><div id="transport_mechanism" class="figure">
<img src="../images/00033.gif" alt="ropy 1801" class="calibre40"/>
<h6 class="calibre37"><span class="calibre">Figure 18-1. </span>Producer–consumer relationship</h6>
</div></figure>








</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 18. Event-Driven Architecture" class="preface">
<div class="preface" id="ch18">
<section data-type="sect1" data-pdf-bookmark="How It Works" class="preface">
<div class="preface" id="idm45644730654424">
<section data-type="sect2" data-pdf-bookmark="Drawbacks" class="preface"><div class="preface" id="idm45644730402392">
<h2 class="calibre34" id="calibre_pb_2">Drawbacks</h2>

<p class="author1">Because the producer and consumer depend on a transport mechanism, they have to agree on the message format. <a data-type="indexterm" data-primary="event-driven architecture" data-secondary="drawbacks of" id="idm45644730400696" class="calibre5"/><a data-type="indexterm" data-primary="logical dependencies" data-secondary="producers and consumers of events" id="idm45644730399752" class="calibre5"/>In most event-driven architectures, both the producer and consumer agree on a common identifier and message format. This does create a <em class="calibre6">logical</em> dependency between the two but not a physical one. If either party changes the identifier or message format in an incompatible way, the scheme breaks down. And like most logical dependencies, it is difficult to link the dependencies together through inspection. Consult <a data-type="xref" href="part0021_split_000.html#dependencies" class="calibre5">Chapter 16</a> to learn more about how to mitigate these problems.</p>

<p class="author1">Because of this separation of code, your typechecker will not be much help when things go wrong. If a consumer starts depending on the wrong event type, the typechecker will not flag it. Be extra careful when changing the type of a producer or consumer, because you will have to update all the other producers–consumers to match.</p>

<p class="author1">Event-driven architectures can make debugging harder.<a data-type="indexterm" data-primary="debugging" data-secondary="of event-driven architectures" id="idm45644730395912" class="calibre5"/> When stepping through code in a debugger, you will get to the code that produces an event, but when you step into the transport mechanism, you often are stepping into third-party code.<a data-type="indexterm" data-primary="transport mechanisms" data-secondary="and debugging of event-driven architectures" id="idm45644730394584" class="calibre5"/> In the worst case, the code that actually transports your events may be running in a different process, or even on a different machine. You may need multiple debuggers active (one per process or system) to properly debug event-driven architectures.</p>

<p class="author1">Finally, error handling becomes a little more difficult when using event-driven architectures.<a data-type="indexterm" data-primary="errors" data-secondary="error handling in event-driven architectures" id="idm45644730392648" class="calibre5"/> Most producers are decoupled from their consumers; when a consumer throws an exception or returns an error, it’s not always easy to handle it from the producer side.</p>

<p class="author1">As a thought experiment, consider what would happen if a producer produced an event and five consumers consumed it. If the third consumer that was notified threw an exception, what should happen? Should the other consumers get the exception, or should the execution stop in its tracks? Should the producer know about any error conditions, or should the errors get swallowed up? If the producer receives an exception, what happens if different consumers produce different exceptions? There is no one right answer to all of these questions; consult the tools you’re using for event-driven architectures to better understand what happens in these cases.</p>

<p class="author1">Despite these drawbacks, event-driven architectures are worthwhile in situations where you need to give your system much-needed flexibility. Future maintainers can replace your producers or consumers with minimal impact. They can bring in new producers and consumers to create new functionality. They can quickly integrate with external systems, opening the door for new partnerships. And best of all, they are working with small, modular systems that are easy to test in isolation and easy to understand.</p>
</div></section>





</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 18. Event-Driven Architecture" class="preface">
<div class="preface" id="ch18">
<section data-type="sect1" data-pdf-bookmark="Simple Events" class="preface"><div class="preface" id="idm45644730653832">
<h1 class="calibre12" id="calibre_pb_3">Simple Events</h1>

<p class="author1">The simplest case for event-oriented <a data-type="indexterm" data-primary="event-driven architecture" data-secondary="dealing with simple events" id="idm45644730388024" class="calibre5"/><a data-type="indexterm" data-primary="simple events" id="idm45644730387064" class="calibre5"/>architectures is dealing with <em class="calibre6">simple events</em> such as acting or alerting you when certain conditions change. Your producer of information is the one sending the event, and your consumer receives and acts upon the event. There are two typical ways of implementing this: with or without a message broker.</p>








</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 18. Event-Driven Architecture" class="preface">
<div class="preface" id="ch18">
<section data-type="sect1" data-pdf-bookmark="Simple Events" class="preface">
<div class="preface" id="idm45644730653832">
<section data-type="sect2" data-pdf-bookmark="Using a Message Broker" class="preface"><div class="preface" id="idm45644730385480">
<h2 class="calibre34" id="calibre_pb_4">Using a Message Broker</h2>

<p class="author1">A message broker is <a data-type="indexterm" data-primary="event-driven architecture" data-secondary="dealing with simple events" data-tertiary="using a message broker" id="idm45644730365240" class="calibre5"/>a specific piece of code that acts as a transport of data.<a data-type="indexterm" data-primary="message brokers" id="idm45644730363880" class="calibre5"/><a data-type="indexterm" data-primary="producers–consumers of events" data-secondary="using message broker as transport mechanism" id="idm45644730363208" class="calibre5"/> Producers will publish data, known as a message, to a specific <em class="calibre6">topic</em> on the message broker.<a data-type="indexterm" data-primary="topics" id="idm45644730361704" class="calibre5"/> The topic is simply a unique identifier, such as a string. It could be something simple, like “orders,” or complex, like “sandwich order is finished.” It’s just a namespace that distinguishes one message channel from another. <a data-type="indexterm" data-primary="subscribing to a topic" id="idm45644730360584" class="calibre5"/>Consumers use the same identifier to <em class="calibre6">subscribe</em> to a topic. The message broker then sends the message to all consumers subscribed to the topic. <a data-type="indexterm" data-primary="publisher/subscriber (pub/sub) systems" id="idm45644730359288" class="calibre5"/>This type of system is also known as <em class="calibre6">publisher/subscriber</em>, or pub/sub for short. <a data-type="xref" href="part0023_split_004.html#message_broker" class="calibre5">Figure 18-2</a> shows a hypothetical pub/sub architecture.</p>

<figure class="calibre36"><div id="message_broker" class="figure">
<img src="../images/00034.gif" alt="ropy 1802" class="calibre40"/>
<h6 class="calibre37"><span class="calibre">Figure 18-2. </span>A hypothetical message broker–based architecture</h6>
</div></figure>

<p class="author1">For this chapter, I will design the notification system for an automated drone delivery service for restaurants. When a customer order is cooked, the drone system kicks into action, picks up the order, and delivers the meal to the correct address.<a data-type="indexterm" data-primary="producers–consumers of events" data-secondary="in automated drone delivery system example" data-secondary-sortas="automated" id="idm45644730354616" class="calibre5"/> There are five notifications that happen in this system, and I’ve broken them down into producer–consumer in <a data-type="xref" href="part0023_split_004.html#drone_notification_table" class="calibre5">Table 18-2</a>.</p>
<table id="drone_notification_table" class="calibre45">
<caption class="calibre46"><span class="calibre">Table 18-2. </span>Producers and consumers in the automated drone delivery system</caption>
<thead class="calibre47">
<tr class="calibre48">
<th class="calibre49">Producer</th>
<th class="calibre49">Consumer</th>
</tr>
</thead>
<tbody class="calibre50">
<tr class="calibre48">
<td class="calibre51"><p class="author1">Meal has finished cooking</p></td>
<td class="calibre51"><p class="author1">Drone is notified for pickup</p></td>
</tr>
<tr class="calibre53">
<td class="calibre51"><p class="author1">Meal has finished cooking</p></td>
<td class="calibre51"><p class="author1">Customer is notified that the meal is cooked</p></td>
</tr>
<tr class="calibre48">
<td class="calibre51"><p class="author1">Drone is en route</p></td>
<td class="calibre51"><p class="author1">Customer is notified about an ETA</p></td>
</tr>
<tr class="calibre53">
<td class="calibre51"><p class="author1">Drone has delivered meal</p></td>
<td class="calibre51"><p class="author1">Customer is notified about delivery</p></td>
</tr>
<tr class="calibre48">
<td class="calibre51"><p class="author1">Drone has delivered meal</p></td>
<td class="calibre51"><p class="author1">Restaurant is notified about delivery</p></td>
</tr>
</tbody>
</table>

<p class="author1">I don’t want any of these systems to directly know about one another, as the code handling customers, drones, and restaurants should remain independent (they are maintained by separate teams and I want to keep physical dependencies low).</p>

<p class="author1">First, I will define the topics that exist in the system: a meal has finished cooking, the drone is en route, and the order is delivered.<a data-type="indexterm" data-primary="topics" data-secondary="defining for automated drone delivery system" id="idm45644730339240" class="calibre5"/></p>

<p class="author1">For this example, I will use the Python library <a href="https://oreil.ly/8xLj7" class="calibre5">PyPubSub</a>, which is a publish-subscribe API used in single-process applications.<a data-type="indexterm" data-primary="PyPubSub library" id="idm45644730337064" class="calibre5"/> To use it, you need to set up code to subscribe to a topic and other code to publish to the topic. First, you need to install <code class="calibre17">pypubsub</code>:</p>

<pre data-type="programlisting" class="calibre35">pip install pypubsub</pre>

<p class="author1">Then, to <a data-type="indexterm" data-primary="publisher/subscriber (pub/sub) systems" data-secondary="subscribing and publishing to a topic" id="idm45644730334536" class="calibre5"/><a data-type="indexterm" data-primary="topics" data-secondary="subscribing and publishing to" id="idm45644730333496" class="calibre5"/>subscribe to the topic, you specify the topic and the function you want to be called:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">pubsub</code> <code class="k">import</code> <code class="n">pub</code>

<code class="k">def</code> <code class="nf">notify_customer_that_meal_is_done</code><code class="calibre17">(</code><code class="n">order</code><code class="calibre17">:</code> <code class="n">Order</code><code class="calibre17">):</code>
    <code class="c"># ... snip ...</code>

<code class="n">pub</code><code class="calibre17">.</code><code class="n">subscribe</code><code class="calibre17">(</code><code class="n">notify_customer_that_meal_is_done</code><code class="calibre17">,</code> <code class="s">"meal-done"</code><code class="calibre17">)</code></pre>

<p class="author1">Then to publish to this topic, you do the following:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">pubsub</code> <code class="k">import</code> <code class="n">pub</code>

<code class="k">def</code> <code class="nf">complete_order</code><code class="calibre17">(</code><code class="n">order</code><code class="calibre17">:</code> <code class="n">Order</code><code class="calibre17">):</code>
    <code class="n">packge_order</code><code class="calibre17">(</code><code class="n">order</code><code class="calibre17">)</code>
    <code class="n">pub</code><code class="calibre17">.</code><code class="n">publish</code><code class="calibre17">(</code><code class="s">"meal-done"</code><code class="calibre17">,</code> <code class="n">order</code><code class="calibre17">)</code></pre>
<div data-type="warning" epub:type="warning" class="calibre23"><h6 class="calibre24">Warning</h6>
<p class="author1">Subscribers operate in the same thread as the publisher, which means that any blocking I/O, such as waiting on a socket to be read, will block the publisher. This will affect all other subscribers and should be avoided.</p>
</div>

<p class="author1">These two pieces of code have no knowledge of each other; all they depend upon is the PyPubSub library as well as agreeing on the topic/message data. This makes it incredibly easy to add new subscribers:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">pubsub</code> <code class="k">import</code> <code class="n">pub</code>

<code class="k">def</code> <code class="nf">schedule_pick_up_for_meal</code><code class="calibre17">(</code><code class="n">order</code><code class="calibre17">:</code> <code class="n">Order</code><code class="calibre17">):</code>
    <code class="sd">'''Schedule a drone pick-up'''</code>
    <code class="c"># ... snip ...</code>

<code class="n">pub</code><code class="calibre17">.</code><code class="n">subscribe</code><code class="calibre17">(</code><code class="n">schedule_pick_up_for_meal</code><code class="calibre17">,</code> <code class="s">"meal-done"</code><code class="calibre17">)</code></pre>

<p class="author1">You can’t get much more extensible. By defining topics that exist within the system, you can create new producers or consumers with the utmost ease. As your system needs to grow, you extend it by interacting with the existing messaging system.</p>

<p class="author1">PyPubSub also comes with a few options to help with debugging.<a data-type="indexterm" data-primary="debugging" data-secondary="PyPubSub options for" id="idm45644730247848" class="calibre5"/><a data-type="indexterm" data-primary="PyPubSub library" data-secondary="debugging options" id="idm45644730210968" class="calibre5"/> You can add audit operations by adding your own functionality for things like new topics being created or a message being sent. You can add error handlers for any subscriber exception being thrown. You can also set up subscribers for <em class="calibre6">all</em> topics at once. If you would like to learn more about any of these features, or any other piece of functionality in PyPubSub, check out the <a href="https://pypubsub.readthedocs.io" class="calibre5">PyPubSub documentation</a>.</p>
<div data-type="note" epub:type="note" class="calibre21"><h6 class="calibre22">Note</h6>
<p class="author1">PyPubSub is meant for single-process applications; you cannot publish to code running in other processes or systems.<a data-type="indexterm" data-primary="PyPubSub library" data-secondary="use with single-process applications" id="idm45644730207048" class="calibre5"/> Other applications can be used to provide this functionality, such as <a href="https://kafka.apache.org" class="calibre5">Kafka</a>, <a href="https://redis.io" class="calibre5">Redis</a>, or <a href="https://www.rabbitmq.com" class="calibre5">RabbitMQ</a>. Check out each of these tool’s documentation to learn how to use them in Python.<a data-type="indexterm" data-primary="Redis" id="idm45644730203896" class="calibre5"/><a data-type="indexterm" data-primary="Kafka" id="idm45644730203192" class="calibre5"/><a data-type="indexterm" data-primary="RabbitMQ" id="idm45644730202520" class="calibre5"/></p>
</div>
</div></section>













</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 18. Event-Driven Architecture" class="preface">
<div class="preface" id="ch18">
<section data-type="sect1" data-pdf-bookmark="Simple Events" class="preface">
<div class="preface" id="idm45644730653832">
<section data-type="sect2" data-pdf-bookmark="The Observer Pattern" class="preface"><div class="preface" id="idm45644730384856">
<h2 class="calibre34" id="calibre_pb_5">The Observer Pattern</h2>

<p class="author1">If you don’t<a data-type="indexterm" data-primary="Observer Pattern" id="idm45644730199928" class="calibre5"/><a data-type="indexterm" data-primary="event-driven architecture" data-secondary="dealing with simple events" data-tertiary="implementing the Observer Pattern" id="idm45644730199192" class="calibre5"/> want to use a message broker, you can choose to implement the Observer Pattern.<sup class="calibre11"><a data-type="noteref" id="idm45644730197896-marker" href="part0023_split_008.html#idm45644730197896" class="calibre5">1</a></sup> With the Observer Pattern, your producer contains of a list of <em class="calibre6">observers</em>: the consumers in this scenario.<a data-type="indexterm" data-primary="observers" id="idm45644730196264" class="calibre5"/>  The Observer Pattern does not need a separate library to act as a message broker.<a data-type="indexterm" data-primary="design patterns" data-secondary="Observer Pattern" id="idm45644730195464" class="calibre5"/></p>

<p class="author1">To avoid directly linking producers and consumers, you need to keep the knowledge of observers <em class="calibre6">generic</em>. In other words, keep any specific knowledge about the observers abstracted away. I will do this by just using functions (type annotated as a <code class="calibre17">Callable</code>). Here is how I would rewrite the previous example to use an Observer Pattern:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">complete_order</code><code class="calibre17">(</code><code class="n">order</code><code class="calibre17">:</code> <code class="n">Order</code><code class="calibre17">,</code> <code class="n">observers</code><code class="calibre17">:</code> <code class="nb">list</code><code class="calibre17">[</code><code class="n">Callable</code><code class="calibre17">[</code><code class="n">Order</code><code class="calibre17">]]):</code>
    <code class="n">package_order</code><code class="calibre17">(</code><code class="n">order</code><code class="calibre17">)</code>
    <code class="k">for</code> <code class="n">observer_func</code> <code class="calibre19">in</code> <code class="n">observers</code><code class="calibre17">:</code>
        <code class="n">observer</code><code class="calibre17">(</code><code class="n">order</code><code class="calibre17">)</code></pre>

<p class="author1">In this case, the producer only knows about a list of functions to call to notify. To add new observers, you just need to add them to the list passed in as an argument. Furthermore, since this is just function calls, your typechecker will be able to detect when a producer or its observers change in an incompatible way, which is a huge benefit over the message broker paradigm. It is also easier to debug, as you don’t need to step through third-party message broker code in your debugger.</p>
<aside data-type="sidebar" epub:type="sidebar" class="calibre32"><div class="sidebar" id="idm45644730145752">
<h5 class="calibre33">Patterns Without Classes</h5>
<p class="author1">The example in this chapter is not the typical representation of the Observer Pattern. <a data-type="indexterm" data-primary="design patterns" data-secondary="object-oriented implementation of" id="idm45644730144376" class="calibre5"/><a data-type="indexterm" data-primary="patterns without classes" id="idm45644730143432" class="calibre5"/>The traditional implementation of this design pattern (as well as with many others) is represented in a very object-oriented fashion with classes, subclasses, inheritance, and interfaces. For example, the original <a data-type="indexterm" data-primary="Observer Pattern" data-secondary="object-oriented implementation of" id="idm45644730142440" class="calibre5"/>Observer Pattern might be expressed in this way in Python:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">typing</code> <code class="k">import</code> <code class="n">Any</code>
<code class="k">class</code> <code class="nc">Subscriber</code><code class="o">:</code>
    <code class="k">def</code> <code class="nf">notify</code><code class="o">(</code><code class="n">data</code><code class="o">:</code> <code class="n">Any</code><code class="o">):</code>
        <code class="k">raise</code> <code class="ne">NotImplementedError</code><code class="o">()</code>

<code class="k">class</code> <code class="nc">Publisher</code><code class="o">:</code>
    <code class="k">def</code> <code class="calibre17">__init__</code><code class="o">(</code><code class="nb">self</code><code class="o">):</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">subscribers</code> <code class="o">=</code> <code class="o">[]</code>

    <code class="k">def</code> <code class="nf">add_subscriber</code><code class="o">(</code><code class="nb">self</code><code class="o">,</code> <code class="n">sub</code><code class="o">:</code> <code class="n">Subscriber</code><code class="o">):</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">subscribers</code><code class="o">.</code><code class="n">append</code><code class="o">(</code><code class="n">sub</code><code class="o">)</code>

    <code class="k">def</code> <code class="nf">notify_subscribers</code><code class="o">(</code><code class="nb">self</code><code class="o">,</code> <code class="n">data</code><code class="o">:</code> <code class="n">Any</code><code class="o">):</code>
        <code class="k">for</code> <code class="n">subscriber</code> <code class="ow">in</code> <code class="n">subscribers</code><code class="o">:</code>
            <code class="n">subscriber</code><code class="o">.</code><code class="n">notify</code><code class="o">(</code><code class="n">data</code><code class="o">)</code></pre>

<p class="author1">Classes that needed to publish or subscribe would then inherit from the appropriate base class. This is useful from a reuse standpoint, but it can be cumbersome to introduce classes when the example with functions is much simpler.</p>

<p class="author1">As such, design patterns have earned some criticism around the number of boilerplate classes and interfaces needed to implement them. As the development community has evolved, public opinion has soured toward many patterns because of their association with class-/interface-heavy code that was described as “object-oriented” in the mid 1990s and 2000s.</p>

<p class="author1">However, do not throw away the concept of many design patterns because of how the example was originally presented. There have been many iterations on these patterns that simplify implementation. Most patterns don’t focus on the state management aspect of object-oriented code but on decoupling dependencies, and are still beneficial to larger system design.</p>
</div></aside>

<p class="author1">The Observer Pattern above does have some drawbacks.<a data-type="indexterm" data-primary="Observer Pattern" data-secondary="drawbacks of" id="idm45644730022984" class="calibre5"/><a data-type="indexterm" data-primary="exceptions" data-secondary="thrown by observers" id="idm45644730022072" class="calibre5"/> First, you are a bit more sensitive to errors that crop up. If the observer throws an exception, the producer needs to be able to handle that directly (or use a helper function or class to handle the notification wrapped in a <code class="calibre17">try…except</code>). Second, the linking of producer to observer is more direct than in the message broker paradigm.<a data-type="indexterm" data-primary="producers–consumers of events" data-secondary="linking of producer to observer" id="idm45644730020264" class="calibre5"/> In a message broker paradigm, the publisher and subscriber can become connected regardless of where they live in the codebase.</p>

<p class="author1">In contrast, the Observer Pattern requires the caller of the notification (in the previous case, this was <code class="calibre17">complete_order</code>) to know about the observers. If the caller doesn’t know directly about the observers, then its caller needs to pass in the observers. This can continue all the way up the call stack until you are in a piece of code that directly knows about the observers. This can pollute a lot your function calls with extra parameters if there is a large gap between what knows about the observers and the actual code issuing the notification. If you find yourself passing observers through multiple functions to get to a producer deep in the call stack, consider using a message broker instead.</p>

<p class="author1">If you would like to go more in-depth into event-driven architectures with simple events, I recommend the book <a href="https://oreil.ly/JPpdr" class="calibre5"><em class="calibre6">Architecture Patterns with Python</em></a> by Harry Percival and Bob Gregory (O’Reilly); its Part II is all about event-driven architecture.</p>
</div></section>





</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 18. Event-Driven Architecture" class="preface">
<div class="preface" id="ch18">
<section data-type="sect1" data-pdf-bookmark="Simple Events" class="preface">
<div class="preface" id="idm45644730653832">
<section data-type="sect2" data-pdf-bookmark="The Observer Pattern" class="preface">
<div class="preface" id="idm45644730384856">
<div data-type="note" epub:type="note" class="calibre21"><h1 class="calibre38" id="calibre_pb_6">Discussion Topic</h1>
<p class="author1">How would event-driven architecture improve the decoupling within your codebase? Would the Observer Pattern or a message broker be more suitable for your needs?</p>
</div>
</div></section>





</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 18. Event-Driven Architecture" class="preface">
<div class="preface" id="ch18">
<section data-type="sect1" data-pdf-bookmark="Streaming Events" class="preface"><div class="preface" id="idm45644730014376">
<h1 class="calibre12" id="calibre_pb_7">Streaming Events</h1>

<p class="author1">In the preceding section, simple events were each represented as a discrete event that happened when a certain condition was fulfilled.<a data-type="indexterm" data-primary="streaming events" id="ix_strmev" class="calibre5"/><a data-type="indexterm" data-primary="event-driven architecture" data-secondary="streaming events" id="ix_evntstrm" class="calibre5"/> Message brokers and the Observer Pattern are great ways to handle simple events. However, some systems deal with a never-ending series of events. The events flow into the system as a continuous series of data known as a stream. Think about the drone systems described in the last section. Consider all the data that comes from each drone. There might be location data, battery levels, current speed, wind data, weather data, and current weight carried. This data will be coming in at regular intervals, and you need a way to handle it.</p>

<p class="author1">In these sorts of use cases, you don’t want to build all the boilerplate of pub/sub or observers; you want an architecture that matches your use case. You need a programming model that centers on events and defines workflows for handling every single event. Enter reactive programming.<a data-type="indexterm" data-primary="reactive programming" id="idm45644730008648" class="calibre5"/></p>

<p class="author1"><em class="calibre6">Reactive programming</em> is an architectural style that revolves around streams of events. You define data sources as producers of these streams, and then link together multiple observers. Each observer is notified whenever there is a change in data and defines a series of operations for handling the data stream. The reactive programming style was popularized by <a href="http://reactivex.io" class="calibre5">ReactiveX</a>. In this section, I’ll use the Python implementation of ReactiveX: RxPY.<a data-type="indexterm" data-primary="RxPy" id="idm45644730006232" class="calibre5"/><a data-type="indexterm" data-primary="ReactiveX, RxPy implementation" id="idm45644730005528" class="calibre5"/></p>

<p class="author1">I will install RxPy with <code class="calibre17">pip</code>:</p>

<pre data-type="programlisting" class="calibre35">pip install rx</pre>

<p class="author1">From there, I need to define a stream of data.<a data-type="indexterm" data-primary="observables" id="idm45644730002648" class="calibre5"/> In RxPY parlance, this is known as an <em class="calibre6">observable</em>. <a data-type="indexterm" data-primary="RxPy" data-secondary="observables" id="idm45644730001384" class="calibre5"/>For example purposes, I’ll use a single hard-coded observable, but in practice, you will generate multiple observables from real data.</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">import</code> <code class="nn">rx</code>
<code class="c"># Each one of these is simulating an independent real-world event streaming in</code>
<code class="n">observable</code> <code class="calibre17">=</code> <code class="n">rx</code><code class="calibre17">.</code><code class="n">of</code><code class="calibre17">(</code>
    <code class="n">LocationData</code><code class="calibre17">(</code><code class="n">x</code><code class="calibre17">=</code><code class="mi">3</code><code class="calibre17">,</code> <code class="n">y</code><code class="calibre17">=</code><code class="mi">12</code><code class="calibre17">,</code> <code class="n">z</code><code class="calibre17">=</code><code class="mi">40</code><code class="calibre17">),</code>
    <code class="n">BatteryLevel</code><code class="calibre17">(</code><code class="n">percent</code><code class="calibre17">=</code><code class="mi">95</code><code class="calibre17">),</code>
    <code class="n">BatteryLevel</code><code class="calibre17">(</code><code class="n">percent</code><code class="calibre17">=</code><code class="mi">94</code><code class="calibre17">),</code>
    <code class="n">WindData</code><code class="calibre17">(</code><code class="n">speed</code><code class="calibre17">=</code><code class="mi">15</code><code class="calibre17">,</code> <code class="n">direction</code><code class="calibre17">=</code><code class="n">Direction</code><code class="calibre17">.</code><code class="n">NORTH</code><code class="calibre17">),</code>
    <code class="c"># ... snip 100s of events</code>
    <code class="n">BatteryLevel</code><code class="calibre17">(</code><code class="n">percent</code><code class="calibre17">=</code><code class="mi">72</code><code class="calibre17">),</code>
    <code class="n">CurrentWeight</code><code class="calibre17">(</code><code class="n">grams</code><code class="calibre17">=</code><code class="mi">300</code><code class="calibre17">)</code>
<code class="calibre17">)</code></pre>

<p class="author1">This observable is generated from a list of events of different types for the drone data.</p>

<p class="author1">I next need to define what to do to process each event.<a data-type="indexterm" data-primary="RxPy" data-secondary="observers subscribing to observables" id="idm45644729922648" class="calibre5"/> Once I have an observable, observers can subscribe to it, in a similar manner to the pub/sub mechanism:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">handle_drone_data</code><code class="calibre17">(</code><code class="n">value</code><code class="calibre17">):</code>
    <code class="c"># ... snip handle drone data ...</code>

<code class="n">observable</code><code class="calibre17">.</code><code class="n">subscribe</code><code class="calibre17">(</code><code class="n">handle_drone_data</code><code class="calibre17">)</code></pre>

<p class="author1">This doesn’t look too different from a normal pub/sub idiom.</p>

<p class="author1">The real magic comes with <em class="calibre6">pipable</em> operators.<a data-type="indexterm" data-primary="RxPy" data-secondary="pipable operators" id="idm45644729872136" class="calibre5"/><a data-type="indexterm" data-primary="pipable operators" id="idm45644729871224" class="calibre5"/> RxPY allows you to <em class="calibre6">pipe</em>, or chain, operations together to produce a pipeline of filters, transformations, and calculations.<a data-type="indexterm" data-primary="operators, piping or chaining in RxPy" id="idm45644729869896" class="calibre5"/> For instance, I can write an operator pipeline with <code class="calibre17">rx.pipe</code> to grab the average weight the drone has carried:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">import</code> <code class="nn">rx.operators</code>

<code class="n">get_average_weight</code> <code class="calibre17">=</code> <code class="n">observable</code><code class="calibre17">.</code><code class="n">pipe</code><code class="calibre17">(</code>
    <code class="n">rx</code><code class="calibre17">.</code><code class="n">operators</code><code class="calibre17">.</code><code class="n">filter</code><code class="calibre17">(</code><code class="k">lambda</code> <code class="n">data</code><code class="calibre17">:</code> <code class="nb">isinstance</code><code class="calibre17">(</code><code class="n">data</code><code class="calibre17">,</code> <code class="n">CurrentWeight</code><code class="calibre17">)),</code>
    <code class="n">rx</code><code class="calibre17">.</code><code class="n">operators</code><code class="calibre17">.</code><code class="n">map</code><code class="calibre17">(</code><code class="k">lambda</code> <code class="n">cw</code><code class="calibre17">:</code> <code class="n">cw</code><code class="calibre17">.</code><code class="n">grams</code><code class="calibre17">),</code>
    <code class="n">rx</code><code class="calibre17">.</code><code class="n">operators</code><code class="calibre17">.</code><code class="n">average</code><code class="calibre17">()</code>
<code class="calibre17">)</code>

<code class="c"># save_average_weight does something with the final data</code>
<code class="c"># (e.g. save to database, print to screen, etc.)</code>
<code class="n">get_average_weight</code><code class="calibre17">.</code><code class="n">subscribe</code><code class="calibre17">(</code><code class="n">save_average_weight</code><code class="calibre17">)</code></pre>

<p class="author1">Similarly, I could write a pipeline chain that tracks the drone’s maximum altitude once it’s left the restaurant:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">get_max_altitude</code> <code class="calibre17">=</code> <code class="n">observable</code><code class="calibre17">.</code><code class="n">pipe</code><code class="calibre17">(</code>
    <code class="n">rx</code><code class="calibre17">.</code><code class="n">operators</code><code class="calibre17">.</code><code class="n">skip_while</code><code class="calibre17">(</code><code class="n">is_close_to_restaurant</code><code class="calibre17">),</code>
    <code class="n">rx</code><code class="calibre17">.</code><code class="n">operators</code><code class="calibre17">.</code><code class="n">filter</code><code class="calibre17">(</code><code class="k">lambda</code> <code class="n">data</code><code class="calibre17">:</code> <code class="nb">isinstance</code><code class="calibre17">(</code><code class="n">data</code><code class="calibre17">,</code> <code class="n">LocationData</code><code class="calibre17">)),</code>
    <code class="n">rx</code><code class="calibre17">.</code><code class="n">operators</code><code class="calibre17">.</code><code class="n">map</code><code class="calibre17">(</code><code class="k">lambda</code> <code class="n">loc</code><code class="calibre17">:</code> <code class="n">loc</code><code class="calibre17">.</code><code class="n">z</code><code class="calibre17">),</code>
    <code class="n">rx</code><code class="calibre17">.</code><code class="n">operators</code><code class="calibre17">.</code><code class="n">max</code><code class="calibre17">()</code>
<code class="calibre17">)</code>

<code class="c"># save max altitude does something with the final data</code>
<code class="c"># (e.g. save to database, print to screen, etc)</code>
<code class="n">get_max_altitude</code><code class="calibre17">.</code><code class="n">subscribe</code><code class="calibre17">(</code><code class="n">save_max_altitude</code><code class="calibre17">)</code></pre>
<div data-type="note" epub:type="note" class="calibre21"><h6 class="calibre22">Note</h6>
<p class="author1">A <em class="calibre6">lambda function</em> is just an inline function without a name.<a data-type="indexterm" data-primary="lambda functions" id="idm45644729702440" class="calibre5"/> It is often used for functions that are only used once where you don’t want to place the definition of the function too far away from its use.</p>
</div>

<p class="author1">This is our old friend <em class="calibre6">composability</em> (as seen in <a data-type="xref" href="part0022_split_000.html#composability" class="calibre5">Chapter 17</a>) coming to our aid.<a data-type="indexterm" data-primary="composability" data-secondary="operators in RxPy" id="idm45644729699656" class="calibre5"/> I can compose different operators however I want to produce a datastream that matches my use case. RxPY has support for over one hundred built-in operators, as well as a framework for defining your own operators. You can even compose the results from one pipe into a new stream of events that other parts of the program can observe. This composability, paired with the decoupled nature of event subscription, gives you a large amount of flexibility in writing code.<a data-type="indexterm" data-primary="immutability" data-secondary="in reactive programming" data-secondary-sortas="reactive" id="idm45644729698072" class="calibre5"/> Furthermore, reactive programming encourages immutability, which greatly decreases the chance of bugs. You can hook up new pipes, compose operators together, handle data asynchronously, and more with a reactive framework like RxPY.</p>

<p class="author1">It also becomes easy to debug in isolation. While you can’t easily step through RxPY with a debugger (you’ll end up in a lot of complicated code related to operations and observables), you can instead step into the functions that you pass to operators. Testing is a breeze too. Since all the functions are meant to be immutable, you can test any of them on their own. You end up with a lot of small, single-purpose functions that are easy to understand.</p>

<p class="author1">This type of model excels in systems that revolve around streams of data, such as data pipelines and extract, transform, load (ETL) systems.<a data-type="indexterm" data-primary="reactive programming" data-secondary="use cases" id="idm45644729695032" class="calibre5"/> It is also incredibly useful in applications dominated by reactions to I/O events, such as server applications and GUI applications. If reactive programming fits your domain model, I encourage you to read the <a href="https://rxpy.readthedocs.io/en/latest" class="calibre5">RxPY documentation</a>. If you’d like more structured learning, I recommend the video course <a href="https://oreil.ly/Kr9At" class="calibre5"><em class="calibre6">Reactive Python for Data Science</em></a> or the book <a href="https://oreil.ly/JCuf6" class="calibre5"><em class="calibre6">Hands-On Reactive Programming with Python: Event-Driven Development Unraveled with RxPY</em></a> by Romain Picard (O’Reilly).</p>
</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 18. Event-Driven Architecture" class="preface">
<div class="preface" id="ch18">
<section data-type="sect1" data-pdf-bookmark="Closing Thoughts" class="preface"><div class="preface" id="idm45644730013432">
<h1 class="calibre12" id="calibre_pb_8">Closing Thoughts</h1>

<p class="author1">Event-driven architectures are incredibly powerful.<a data-type="indexterm" data-primary="event-driven architecture" data-secondary="streaming events" data-startref="ix_evntstrm" id="idm45644729690488" class="calibre5"/><a data-type="indexterm" data-primary="streaming events" data-startref="ix_strmev" id="idm45644729689224" class="calibre5"/> An event-driven architecture allows you to separate producers and consumers of information. By decoupling the two, you introduce flexibility into your system. You can replace functionality, test your code in isolation, or extend new functionality by introducing new producers or consumers.</p>

<p class="author1">There are many ways to architect an event-driven system. You can choose to stay with simple events and the Observer Pattern for lightweight events in your system. As you scale up, you may need to introduce a message broker, such as with PyPubSub. You may even need to use another library as a message broker if you want to scale across processes or systems. Finally, as you approach streams of events, you can consider a reactive programming framework, such as RxPY.</p>

<p class="author1">In the next chapter, I will cover a different type of architectural paradigm: plug-in architectures. Plug-in architectures offer similar flexibility, composability, and extensibility to event-driven architectures, but in a completely different way. Whereas event-driven architectures focus on events, plug-in architecture focuses on pluggable units of implementation. You’ll see how plug-in architectures can give you plenty of options to build a robust codebase that is easy to maintain.<a data-type="indexterm" data-primary="event-driven architecture" data-startref="ix_evnt" id="idm45644729686056" class="calibre5"/></p>
</div></section>







<div data-type="footnotes" class="calibre25"><p data-type="footnote" id="idm45644730197896" class="calibre26"><sup class="calibre27"><a href="part0023_split_005.html#idm45644730197896-marker" class="calibre5">1</a></sup> The Observer Pattern is first described in <em class="calibre6">Design Patterns: Elements of Reusable Object-Oriented Software</em> by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-Wesley Professional). This book is colloquially known as the “Gang of Four (GoF)” book.</p></div></div></section></body></html>