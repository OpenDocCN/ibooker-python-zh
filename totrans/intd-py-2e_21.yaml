- en: Chapter 19\. Be a Pythonista
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Always wanted to travel back in time to try fighting a younger version of yourself?
    Software development is the career for you!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Elliot Loh](http://bit.ly/loh-tweet)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This chapter is devoted to the art and science of Python development, with “best
    practice” recommendations. Absorb them, and you too can be a card-carrying Pythonista.
  prefs: []
  type: TYPE_NORMAL
- en: About Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, a few notes about programming, based on personal experience.
  prefs: []
  type: TYPE_NORMAL
- en: My original career path was science, and I taught myself programming to analyze
    and display experimental data. I expected computer programming to be like my impression
    of accounting—precise but dull. I was surprised to find that I enjoyed it. Part
    of the fun was its logical aspects—like solving puzzles—but part was creative.
    You had to write your program correctly to get the right results, but you had
    the freedom to write it any way you wanted. It was an unusual balance of right-brain
    and left-brain thinking.
  prefs: []
  type: TYPE_NORMAL
- en: After I wandered off into a career in programming, I also learned that the field
    had many niches, with very different tasks and types of people. You could delve
    into computer graphics, operating systems, business applications—even science.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re a programmer, you might have had a similar experience yourself. If
    you’re not, you might try programming a bit to see if it fits your personality,
    or at least helps you to get something done. As I may have mentioned much earlier
    in this book, math skills are not so important. It seems that the ability to think
    logically is most important and that an aptitude for languages seems to help.
    Finally, patience also helps, especially when you’re tracking down an elusive
    bug in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Find Python Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you need to develop some code, the fastest solution is to steal it…from
    a source that allows it.
  prefs: []
  type: TYPE_NORMAL
- en: The Python [standard library](http://docs.python.org/3/library) is wide, deep,
    and mostly clear. Dive in and look for those pearls.
  prefs: []
  type: TYPE_NORMAL
- en: Like the halls of fame for various sports, it takes time for a module to get
    into the standard library. New packages are appearing outside constantly, and
    throughout this book, I’ve highlighted some that either do something new or do
    something old better. Python is advertised as *batteries included*, but you might
    need a new kind of battery.
  prefs: []
  type: TYPE_NORMAL
- en: So where, outside the standard library, should you look for good Python code?
  prefs: []
  type: TYPE_NORMAL
- en: The first place to look is the [Python Package Index (PyPI)](https://pypi.org).
    Formerly named the *Cheese Shop* after a Monty Python skit, this site is constantly
    updated with Python packages—more than 113,000 as I write this. When you use `pip`
    (see the next section), it searches PyPI. The main PyPI page shows the most recently
    added packages. You can also conduct a direct search by typing something into
    the search box in the middle of the PyPI home page. For example, `genealogy` yields
    21 matches, and `movies` yields 528.
  prefs: []
  type: TYPE_NORMAL
- en: Another popular repository is GitHub. See what Python packages are currently
    [trending](https://github.com/trending?l=python).
  prefs: []
  type: TYPE_NORMAL
- en: '[Popular Python recipes](http://bit.ly/popular-recipes) has more than four
    thousand short Python programs, on every subject.'
  prefs: []
  type: TYPE_NORMAL
- en: Install Packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many ways to install Python packages:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `pip` if you can. It’s the most common method by far. You can install most
    of the Python packages you’re likely to encounter with `pip`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `pipenv`, which combines `pip` and `virtualenv`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, you can use a package manager for your operating system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `conda` if you do a lot of scientific work and want to use the Anaconda
    distribution of Python. See [“Install Anaconda”](app02.html#install_anaconda)
    for details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install from source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re interested in several packages in the same area, you might find a
    Python distribution that already includes them. For instance, in [Chapter 22](ch22.html#ch_science),
    you can try out a number of numeric and scientific programs that would be tedious
    to install individually but are included with distributions such as Anaconda.
  prefs: []
  type: TYPE_NORMAL
- en: Use pip
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python packaging has had some limitations. An earlier installation tool called
    `easy_install` has been replaced by one called `pip`, but neither had been in
    the standard Python installation. If you’re supposed to install things by using
    `pip`, from where did you get `pip`? Starting with Python 3.4, `pip` will finally
    be included with the rest of Python to avoid such existential crises. If you’re
    using an earlier version of Python 3 and don’t have `pip`, you can get it from
    [*http://www.pip-installer.org*](http://www.pip-installer.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest use of `pip` is to install the latest version of a single package
    by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see details on what it’s doing, just so you don’t think it’s goofing
    off: downloading, running *setup.py*, installing files on your disk, and other
    details.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also ask `pip` to install a specific version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, a minimum version (this is useful when some feature that you can’t live
    without turns up in a particular version):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, those single quotes prevent the `>` from being interpreted
    by the shell to redirect output to a file called `=0.9.0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to install more than one Python package, you can use a [requirements
    file](http://bit.ly/pip-require). Although it has many options, the simplest use
    is a list of packages, one per line, optionally with a specific or relative version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Your sample *requirements.txt* file might contain this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A few more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the latest version: `pip install --upgrade *package*`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Delete a package: `pip uninstall *package*`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use virtualenv
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The standard way of installing third-party Python packages is to use `pip` and
    `virtual``env`. I show how to install `virtualenv` in [“Install virtualenv”](app02.html#install_virtualenv).
  prefs: []
  type: TYPE_NORMAL
- en: A *virtual environment* is just a directory that contains the Python interpreter,
    some other programs like `pip`, and some packages. You *activate* it by running
    the shell script `activate` that’s in the `bin` directory of that virtual environment.
    This sets the environment variable `$PATH` that your shell uses to find programs.
    By activating a virtual enviroment, you put its `bin` directory ahead of the usual
    directories in your `$PATH`. The result is that when you type a command like `pip`
    or `python`, your shell first finds the one in your virtual environment, instead
    of system directories like `/bin`, `/usr/bin`, or `/usr/local/bin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You don’t want to install software into those system directories anyhow, because:'
  prefs: []
  type: TYPE_NORMAL
- en: You don’t have permission to write to them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even if you could, overwriting your system’s standard programs (like `python`)
    could cause problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use pipenv
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A recent package called [pipenv](http://docs.pipenv.org) combines our friends
    `pip` and `virtualenv`. It also addresses dependency issues that can arise when
    using `pip` in different environments (such as your local development machine,
    versus staging, versus production):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Its use is recommended by the [Python Packaging Authority](https://www.pypa.io)—a
    working group trying to improve Python’s packaging workflow. This is not the same
    as the group that defines core Python itself, so `pipenv` is not a part of the
    standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Use a Package Manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apple’s macOS includes the third-party packagers [homebrew](http://brew.sh)
    (`brew`) and [`ports`](http://www.macports.org). They work a little like `pip`,
    but aren’t restricted to Python packages.
  prefs: []
  type: TYPE_NORMAL
- en: Linux has a different manager for each distribution. The most popular are `apt-get`,
    `yum`, `dpkg`, and `zypper`.
  prefs: []
  type: TYPE_NORMAL
- en: Windows has the Windows Installer and package files with a *.msi* suffix. If
    you installed Python for Windows, it was probably in the MSI format.
  prefs: []
  type: TYPE_NORMAL
- en: Install from Source
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Occasionally, a Python package is new, or the author hasn’t managed to make
    it available with `pip`. To build the package, you generally do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract the files by using `zip`, `tar`, or another appropriate tool if they’re
    archived or compressed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run `python setup.py install` in the directory containing a *setup.py* file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As always, be careful what you download and install. It’s a little harder to
    hide malware in Python programs, which are readable text, but it has happened.
  prefs: []
  type: TYPE_NORMAL
- en: Integrated Development Environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’ve used a plain-text interface for programs in this book, but that doesn’t
    mean that you need to run everything in a console or text window. There are many
    free and commercial integrated development environments (IDEs), which are GUIs
    with support for such tools as text editors, debuggers, library searching, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: IDLE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[IDLE](http://bit.ly/py-idle) is the only Python IDE that’s included with the
    standard distribution. It’s based on tkinter, and its GUI is plain.'
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PyCharm](http://www.jetbrains.com/pycharm) is a recent graphic IDE with many
    features. The community edition is free, and you can get a free license for the
    professional edition to use in a classroom or an open source project. [Figure 19-1](#img_pycharm)
    shows its initial display.'
  prefs: []
  type: TYPE_NORMAL
- en: '![inp2 1901](assets/inp2_1901.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 19-1\. Startup screen for PyCharm
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: IPython
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[iPython](http://ipython.org) started as an enhanced terminal (text) Python
    IDE, but evolved a graphical interface with the metaphor of a *notebook*. It integrated
    many packages that are discussed in this book, including Matplotlib and NumPy,
    and became a popular tool in scientific computing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You install the basic text version with (you guessed it) `pip install ipython`.
    When you start it, you’ll see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you know, the standard Python interpreter uses the input prompts `>>>` and
    `...` to indicate where and when you should type code. IPython tracks everything
    you type in a list called `In`, and all your output in `Out`. Each input can be
    more than one line, so you submit it by holding the Shift key while pressing Enter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a one-line example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`In` and `Out` are automatically numbered lists, letting you access any of
    the inputs you typed or outputs you received.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you type `?` after a variable, IPython tells you its type, value, ways of
    making a variable of that type, and some explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Name lookup is a popular feature of IDEs such as IPython. If you press the
    Tab key right after some characters, IPython shows all variables, keywords, and
    functions that begin with those characters. Let’s define some variables and then
    find everything that begins with the letter `f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you type `fe` followed by the Tab key, it expands to the variable `fee`,
    which, in this program, is the only thing that starts with `fe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There’s much more to IPython. Take a look at its [tutorial](https://oreil.ly/PIvVK)
    to get a feel for its features.
  prefs: []
  type: TYPE_NORMAL
- en: Jupyter Notebook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Jupyter](https://jupyter.org) is an evolution of IPython. The name combines
    the languages Julia, Python, and R—all of which are popular in data science and
    scientific computing. Jupyter Notebooks are a modern way to develop and publish
    your code with documentation for any of these languages.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’d like to play with it first before installing anything on your computer,
    you can first [try it out](https://jupyter.org/try) in your web browser.
  prefs: []
  type: TYPE_NORMAL
- en: To install Jupyter Notebook locally, type `pip install jupyter`. Run it with
    `jupyter notebook`.
  prefs: []
  type: TYPE_NORMAL
- en: JupyterLab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JupyterLab is the next generation of Jupyter Notebook and will eventually replace
    it. As with the Notebook, you can first [try out](https://jupyter.org/try) JupyterLab
    in your browser. You install it locally with `pip install jupyterlab` and then
    run it with `jupyter lab`.
  prefs: []
  type: TYPE_NORMAL
- en: Name and Document
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You won’t remember what you wrote. Sometimes, I look at code that I wrote even
    recently and wonder where on earth it came from. That’s why it helps to document
    your code. Documentation can include comments and docstrings, but it can also
    incorporate informative naming of variables, functions, modules, and classes.
    Don’t be obsessive, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Instead, say *why* you assigned the value `10`. Point out why you called the
    variable `num`. If you were writing the venerable Fahrenheit-to-Celsius converter,
    you might name variables to explain what they do rather than a lump of magic code.
    And a little test code wouldn’t hurt ([Example 19-1](#ex1901)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-1\. ftoc1.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s run the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make (at least) two improvements:'
  prefs: []
  type: TYPE_NORMAL
- en: Python doesn’t have constants, but the PEP8 stylesheet [recommends](http://bit.ly/pep-constant)
    using capital letters and underscores (e.g., `ALL_CAPS`) when naming variables
    that should be considered constants. Let’s rename those constant-y variables in
    our example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because we precompute values based on constant values, let’s move them to the
    top level of the module. Then, they’ll be calculated only once rather than in
    every call to the `ftoc()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example 19-2](#ex1902) shows the result of our rework.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-2\. ftoc2.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Add Type Hints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static languages require you to define the types of your variables, and they
    can catch some errors at compile time. As you know, Python doesn’t do this, and
    you can encounter bugs only when the code is run. Python variables are names and
    only refer to actual objects. Objects have strict types, but names can point to
    any object at any time.
  prefs: []
  type: TYPE_NORMAL
- en: Yet in real code (in Python and other languages), a name tends to refer to a
    particular object. It would help, at least in documentation, if we could annotate
    things (variables, function returns, and so on) with the object types we expect
    them to be referencing. Then, developers would not need to look through as much
    code to see how a particular variable is supposed to act.
  prefs: []
  type: TYPE_NORMAL
- en: Python 3.x added *type hints* (or *type annotations*) to address this. It’s
    completely optional, and does not force types on variables. It helps developers
    who are used to static languages, where variable types *must* be declared.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hints for a function that converts a number to a string would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: These are only hints, and they don’t change how Python works. Their main use
    is for documentation, but people are finding more uses. For example, the [FastAPI](https://fastapi.tiangolo.com)
    web framework uses hints to generate web documentation with live forms for testing.
  prefs: []
  type: TYPE_NORMAL
- en: Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You probably already know this, but if not: even trivial code changes can break
    your program. Python lacks the type-checking of static languages, which makes
    some things easier but also lets undesirable results through the door. Testing
    is essential.'
  prefs: []
  type: TYPE_NORMAL
- en: The very simplest way to test Python programs is to add `print()` statements.
    The Python interactive interpreter’s Read-Evaluate-Print Loop (REPL) lets you
    edit and test changes quickly. However, you don’t want `print()` statements in
    production code, so you need to remember to remove them all.
  prefs: []
  type: TYPE_NORMAL
- en: Check with pylint, pyflakes, flake8, or pep8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step, before creating actual test programs, is to run a Python code
    checker. The most popular are [`pylint`](http://www.pylint.org) and [`pyflakes`](http://bit.ly/pyflakes).
    You can install either or both by using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: These check for actual code errors (such as referring to a variable before assigning
    it a value) and style faux pas (the code equivalent of wearing plaids and stripes).
    [Example 19-3](#ex1903) is a fairly meaningless program with a bug and style issue.
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-3\. style1.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the initial output of `pylint`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Much further down, under `Global evaluation`, is our score (10.0 is perfect):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Ouch. Let’s fix the bug first. That `pylint` output line starting with an `E`
    indicates an `Error`, which occurred because we didn’t assign a value to `c` before
    we printed it. Take a look at [Example 19-4](#ex1904) to see how we can fix that.
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-4\. style2.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Good, no more `E` lines. And our score jumped from -3.33 to 4.29:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`pylint` wants a docstring (a short text at the top of a module or function,
    describing the code), and it thinks short variable names such as `a`, `b`, and
    `c` are tacky. Let’s make `pylint` happier and improve *style2.py* to *style3.py*
    ([Example 19-5](#ex1905)).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-5\. style3.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Hey, no complaints. And our score?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: And there was much rejoicing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another style checker is [`pep8`](https://pypi.python.org/pypi/pep8), which
    you can install in your sleep by now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: What does it say about our style makeover?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: To be really stylish, it’s recommending that I add a blank line after the initial
    module docstring.
  prefs: []
  type: TYPE_NORMAL
- en: Test with unittest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve verified that we’re no longer insulting the style senses of the code gods,
    so let’s move on to actual tests of the logic in your program.
  prefs: []
  type: TYPE_NORMAL
- en: It’s a good practice to write independent test programs first, to ensure that
    they all pass before you commit your code to any source control system. Writing
    tests can seem tedious at first, but they really do help you find problems faster—especially
    *regressions* (breaking something that used to work). Painful experience teaches
    all developers that even the teeniest change, which they swear could not possibly
    affect anything else, actually does. If you look at well-written Python packages,
    they always include a test suite.
  prefs: []
  type: TYPE_NORMAL
- en: The standard library contains not one, but two test packages. Let’s start with
    [`unittest`](https://oreil.ly/ImFmE). We’ll write a module that capitalizes words.
    Our first version just uses the standard string function `capitalize()`, with
    some unexpected results as we’ll see. Save this as *cap.py* ([Example 19-6](#ex1906)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-6\. cap.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The basis of testing is to decide what outcome you want from a certain input
    (here, you want the capitalized version of whatever text you input), submit the
    input to the function you’re testing, and then check whether it returned the expected
    results. The expected result is called an *assertion*, so in `unittest` you check
    your results by using methods with names that begin with `assert`, like the `assertEqual`
    method shown in [Example 19-7](#ex1907).
  prefs: []
  type: TYPE_NORMAL
- en: Save this test script as *test_cap.py*.
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-7\. test_cap.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setUp()` method is called before each test method, and the `tearDown()`
    method is called after each. Their purpose is to allocate and free external resources
    needed by the tests, such as a database connection or some test data. In this
    case, our tests are self-contained, and we wouldn’t even need to define `setUp()`
    and `tearDown()`, but it doesn’t hurt to have empty versions there. At the heart
    of our test are the two functions named `test_one_word()` and `test_multiple_words()`.
    Each runs the `just_do_it()` function we defined with different input and checks
    whether we got back what we expect. Okay, let’s run it. This will call our two
    test methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: It liked the first test (`test_one_word`), but not the second (`test_multiple_words`).
    The up arrows (`^`) show where the strings actually differed.
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s special about multiple words? Reading the documentation for the `string`
    [`capitalize`](https://oreil.ly/x1IV8) function yields an important clue: it capitalizes
    only the first letter of the first word. Maybe we should have read that first.'
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, we need another function. Gazing down that page a bit, we find
    [`title()`](https://oreil.ly/CNKNl). So, let’s change *cap.py* to use `title()`
    instead of `capitalize()` ([Example 19-8](#ex1908)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-8\. cap.py, revised
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Rerun the tests, and let’s see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Everything is great. Well, actually, they’re not. We need to add at least one
    more method to *test_cap.py* ([Example 19-9](#ex1909)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-9\. test_cap.py, revised
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Go ahead and try it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Our function capitalized the `m` in `I'm`. A quick run back to the documentation
    for `title()` shows that it doesn’t handle apostrophes well. We *really* should
    have read the entire text first.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of the standard library’s `string` documentation is another candidate:
    a helper function called `capwords()`. Let’s use it in *cap.py* ([Example 19-10](#ex1910)).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-10\. cap.py, re-revised
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: At last, we’re finally done! Uh, no. We have one more test to add to *test_cap.py*
    ([Example 19-11](#ex1911)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-11\. test_cap.py, re-revised
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Did it work?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: It looks like that first double quote confused even `capwords`, our favorite
    capitalizer thus far. It tried to capitalize the `"`, and lowercased the rest
    (`You're`). We should have also tested that our capitalizer left the rest of the
    string untouched.
  prefs: []
  type: TYPE_NORMAL
- en: People who do testing for a living have a knack for spotting these edge cases,
    but developers often have blind spots when it comes to their own code.
  prefs: []
  type: TYPE_NORMAL
- en: '`unittest` provides a small but powerful set of assertions, letting you check
    values, confirm whether you have the class you want, determine whether an error
    was raised, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Test with doctest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The second test package in the standard library is [`doctest`](http://bit.ly/py-doctest).
    With this package, you can write tests within the docstring itself, also serving
    as documentation. It looks like the interactive interpreter: the characters `>>>`,
    followed by the call, and then the results on the following line. You can run
    some tests in the interactive interpreter and just paste the results into your
    test file. Let’s modify our old *cap.py* as *cap2.py* (without that troublesome
    last test with quotes), as shown in [Example 19-12](#ex1912).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-12\. cap2.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run it, it doesn’t print anything if all tests passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Give it the verbose (`-v`) option to see what actually happened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Test with nose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The third-party package called [`nose`](https://oreil.ly/gWK6r) is another
    alternative to `unittest`. Here’s the command to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: You don’t need to create a class that includes test methods, as we did with
    `unittest`. Any function with a name matching `test` somewhere in its name will
    be run. Let’s modify our last version of our `unittest` tester and save it as
    *test_cap_nose.py* ([Example 19-13](#ex1913)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-13\. test_cap_nose.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This is the same bug we found when we used `unittest` for testing; fortunately,
    there’s an exercise to fix it at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Other Test Frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For some reason, people like to write Python test frameworks. If you’re curious,
    you can check out some other popular ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`tox`](http://tox.readthedocs.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`py.test`](https://pytest.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`green`](https://github.com/CleanCut/green)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous Integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When your group is cranking out a lot of code daily, it helps to automate tests
    as soon as changes arrive. You can automate source control systems to run tests
    on all code as it’s checked in. This way, everyone knows whether someone *broke
    the build* and just disappeared for an early lunch—or a new job.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are big systems, and I’m not going into installation and usage details
    here. In case you need them someday, you’ll know where to find them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`buildbot`](http://buildbot.net)'
  prefs: []
  type: TYPE_NORMAL
- en: Written in Python, this source control system automates building, testing, and
    releasing.
  prefs: []
  type: TYPE_NORMAL
- en: '[`jenkins`](http://jenkins-ci.org)'
  prefs: []
  type: TYPE_NORMAL
- en: This is written in Java, and seems to be the preferred CI tool of the moment.
  prefs: []
  type: TYPE_NORMAL
- en: '[`travis-ci`](http://travis-ci.com)'
  prefs: []
  type: TYPE_NORMAL
- en: This automates projects hosted at GitHub, and is free for open source projects.
  prefs: []
  type: TYPE_NORMAL
- en: '[`circleci`](https://circleci.com)'
  prefs: []
  type: TYPE_NORMAL
- en: This one is commercial but free for open source and private projects.
  prefs: []
  type: TYPE_NORMAL
- en: Debug Python Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging is like being the detective in a crime movie where you are also the
    murderer.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Filipe Fortes
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Everyone knows that debugging is twice as hard as writing a program in the first
    place. So if you’re as clever as you can be when you write it, how will you ever
    debug it?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Brian Kernighan
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Test first. The better your tests are, the less you’ll have to fix later. Yet,
    bugs happen and need to be fixed when they’re found later.
  prefs: []
  type: TYPE_NORMAL
- en: When code breaks, it’s usually because of something you just did. So you typically
    debug “from the bottom up,” starting with your most recent changes.^([1](ch19.html#idm45794966587992))
  prefs: []
  type: TYPE_NORMAL
- en: But sometimes the cause is elsewhere, in something that you trusted and thought
    worked. You would think that if there were problems in something that many people
    use, someone would have noticed by now. That is not always what happens. The trickiest
    bugs that I’ve encountered, that each took more than a week to fix, had external
    causes. So after blaming the person in the mirror, question your assumptions.
    This is a “top-down” approach, and it takes longer.
  prefs: []
  type: TYPE_NORMAL
- en: The following are some debugging techniques, from quick and dirty to slower,
    but often just as dirty.
  prefs: []
  type: TYPE_NORMAL
- en: Use print()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest way to debug in Python is to print out strings. Some useful things
    to print include `vars()`, which extracts the values of your local variables,
    including function arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Other things that are often worth printing are `locals()` and `globals()`.
  prefs: []
  type: TYPE_NORMAL
- en: If your code also includes normal prints to standard output, you can write your
    debugging messages to standard error output with `print(*stuff*, file=sys.stderr)`.
  prefs: []
  type: TYPE_NORMAL
- en: Use Decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you read in [“Decorators”](ch09.html#decorators), a decorator can call code
    before or after a function without modifying the code within the function itself.
    This means that you can use a decorator to do something before or after any Python
    function, not just ones that you wrote. Let’s define the decorator `dump` to print
    the input arguments and output values of any function as it’s called (designers
    know that a dump often needs decorating), as shown in [Example 19-14](#ex1914).
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-14\. dump.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now the decoratee. This is a function called `double()` that expects numeric
    arguments, either named or unnamed, and returns them in a list with their values
    doubled ([Example 19-15](#ex1915)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-15\. test_dump.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a moment to run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Use pdb
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These techniques help, but sometimes there’s no substitute for a real debugger.
    Most IDEs include a debugger, with varying features and user interfaces. Here,
    I describe use of the standard Python debugger, [`pdb`](https://oreil.ly/IIN4y).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you run your program with the `-i` flag, Python will drop you into its interactive
    interpreter if the program fails.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a program with a bug that depends on data—the kind of bug that can be
    particularly hard to find. This is a real bug from the early days of computing,
    and it baffled programmers for quite a while.
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to read a file of countries and their capital cities, separated
    by a comma, and write them out as *capital*, *country*. They might be capitalized
    incorrectly, so we should fix that also when we print. Oh, and there might be
    extra spaces here and there, and you’ll want to get rid of those, too. Finally,
    although it would make sense for the program to just read to the end of the file,
    for some reason our manager told us to stop when we encounter the word `quit`
    (in any mixture of uppercase and lowercase characters). [Example 19-16](#ex1916)
    shows a sample data file.
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-16\. cities.csv
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s design our *algorithm* (method for solving the problem). This is *pseudocode*—it
    looks like a program, but is just a way to explain the logic in normal language
    before converting it to an actual program. One reason programmers like Python
    is because it *looks a lot like pseudocode*, so there’s less work involved when
    it’s time to convert it to a working program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We need to strip initial and trailing spaces from the names because that was
    a requirement. Likewise for the lowercase comparison with `quit` and converting
    the city and country names to title case. That being the case, let’s whip out
    *capitals.py*, which is sure to work perfectly ([Example 19-17](#ex1917)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-17\. capitals.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try it with that sample data file we made earlier. Ready, fire, aim:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Looks great! It passed one test, so let’s put it in production, processing capitals
    and countries from around the world—until it fails, but only for this data file
    ([Example 19-18](#ex1918)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-18\. cities2.csv
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The program ends after printing only 5 lines of the 15 in the data file, as
    demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: What happened? We can keep editing *capitals.py*, putting `print()` statements
    in likely places, but let’s see if the debugger can help us.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the debugger, import the `pdb` module from the command line by typing
    **`-m pdb`**, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This starts the program and places you at the first line. If you type **`c`**
    (*continue*), the program will run until it ends, either normally or with an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: It completed normally, just as it did when we ran it earlier outside of the
    debugger. Let’s try again, using some commands to narrow down where the problem
    lies. It seems to be a *logic error* rather than a syntax problem or exception
    (which would have printed error messages).
  prefs: []
  type: TYPE_NORMAL
- en: 'Type **`s`** (*step*) to single-step through Python lines. This steps through
    *all* Python code lines: yours, the standard library’s, and any other modules
    you might be using. When you use `s`, you also go into functions and single-step
    within them. Type **`n`** (*next*) to single-step but *not* to go inside functions;
    when you get to a function, a single `n` causes the entire function to execute
    and take you to the next line of your program. Thus, use `s` when you’re not sure
    where the problem is; use `n` when you’re sure that a particular function isn’t
    the cause, especially if it’s a long function. Often you’ll single-step through
    your own code and step over library code, which is presumably well tested. Let’s
    use `s` to step from the beginning of the program into the function `process_cities()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Type **`l`** (*list*) to see the next few lines of your program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The arrow (`->`) denotes the current line.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could continue using `s` or `n`, hoping to spot something, but let’s use
    one of the main features of a debugger: *breakpoints*. A breakpoint stops execution
    at the line you indicate. In our case, we want to know why `process_cities()`
    bails out before it’s read all of the input lines. Line 3 (`for line in file:`)
    will read every line in the input file, so that seems innocent. The only other
    place where we could return from the function before reading all of the data is
    at line 6 (`return`). Let’s set a breakpoint on line 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s continue the program until it either hits the breakpoint or reads
    all of the input lines and finishes normally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Aha! It stopped at our line 6 breakpoint. This indicates that the program wants
    to return early after reading the country after Colombia. Let’s print the value
    of `line` to see what we just read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: What’s so special about—oh, never mind.
  prefs: []
  type: TYPE_NORMAL
- en: Really? **`quit`**o? Our manager never expected the string `quit` to turn up
    inside normal data, so using it as a *sentinel* (end indicator) value like this
    was a boneheaded idea. You march right in there and tell him that—while I wait
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'If at this point you still have a job, you can see all your breakpoints by
    using a plain `b` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'An `l` will show your code lines, the current line (`->`), and any breakpoints
    (`B`). A plain `l` will start listing from the end of your previous call to `l`,
    so include the optional starting line (here, let’s start from line `1`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: OK, as shown in [Example 19-19](#ex1919), let’s fix that `quit` test to match
    only the full line, not within other characters.
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-19\. capitals2.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Once more, with feeling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: That was a skimpy overview of the debugger—just enough to show you what it can
    do and what commands you’d use most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: more tests, less debugging.'
  prefs: []
  type: TYPE_NORMAL
- en: Use breakpoint()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Python 3.7, there’s a new built-in function called `breakpoint()`. If you
    add it to your code, a debugger will automatically start up and pause at each
    location. Without this, you would need to fire up a debugger like `pdb` and set
    breakpoints manually, as you saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default debugger is the one you’ve just seen (`pdb`), but this can be changed
    by setting the environment variable `PYTHONBREAKPOINT`. For example, you could
    specify use of the web-based remote debugger [web-pdb](https://pypi.org/project/web-pdb):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The official documentation is a bit dry, but there are good overviews [here](https://oreil.ly/9Q9MZ)
    and [there](https://oreil.ly/2LJKy).
  prefs: []
  type: TYPE_NORMAL
- en: Log Error Messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point you might need to graduate from using `print()` statements to
    logging messages. A log is usually a system file that accumulates messages, often
    inserting useful information such as a timestamp or the name of the user who’s
    running the program. Often logs are *rotated* (renamed) daily and compressed;
    by doing so, they don’t fill up your disk and cause problems themselves. When
    something goes wrong with your program, you can look at the appropriate log file
    to see what happened. The contents of exceptions are especially useful in logs
    because they show you the actual line at which your program croaked, and why.
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard Python library module is [`logging`](http://bit.ly/py-logging).
    I’ve found most descriptions of it somewhat confusing. After a while it makes
    more sense, but it does seem overly complicated at first. The `logging` module
    includes these concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: The *message* that you want to save to the log
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ranked priority *levels* and matching functions: `debug()`, `info()`, `warn()`,
    `error()`, and `critical()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more *logger* objects as the main connection with the module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Handlers* that direct the message to your terminal, a file, a database, or
    somewhere else'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Formatters* that create the output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Filters* that make decisions based on the input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the simplest logging example, just import the module and use some of its
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Did you notice that `debug()` and `info()` didn’t do anything, and the other
    two printed *LEVEL*:`root`: before each message? So far, it’s like a `print()`
    statement with multiple personalities, some of them hostile.'
  prefs: []
  type: TYPE_NORMAL
- en: But it is useful. You can scan for a particular value of *LEVEL* in a log file
    to find particular messages, compare timestamps to see what happened before your
    server crashed, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'A lot of digging through the documentation answers the first mystery (we get
    to the second one in a page or two): the default priority *level* is `WARNING`,
    and that got locked in as soon as we called the first function (`logging.debug()`).
    We can set the default level by using `basicConfig()`. `DEBUG` is the lowest level,
    so this enables it and all the higher levels to flow through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'We did all that with the default `logging` functions without actually creating
    a *logger* object. Each logger has a name. Let’s make one called `bunyan`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: If the logger name contains any dot characters, they separate levels of a hierarchy
    of loggers, each with potentially different properties. This means that a logger
    named `quark` is higher than one named `quark.charmed`. The special *root logger*
    is at the top and is called `''`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we’ve just printed messages, which is not a great improvement over
    `print()`. We use *handlers* to direct the messages to different places. The most
    common is a *log file*, and here’s how you do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Aha! The lines aren’t on the screen anymore; instead, they’re in the file named
    *blue_ox.log*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Calling `basicConfig()` with a `filename` argument created a `FileHandler` for
    you and made it available to your logger. The `logging` module includes at least
    15 handlers to send messages to places such as email and web servers as well as
    the screen and files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can control the *format* of your logged messages. In our first
    example, our default gave us something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'If you provide a `format` string to `basicConfig()`, you can change to the
    format of your preference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: We let the logger send output to the screen again, but changed the format.
  prefs: []
  type: TYPE_NORMAL
- en: The `logging` module recognizes a number of variable names in the `fmt` format
    string. We used `asctime` (date and time as an ISO 8601 string), `levelname`,
    `lineno` (line number), and the `message` itself. There are other built-ins, and
    you can provide your own variables, as well.
  prefs: []
  type: TYPE_NORMAL
- en: There’s much more to `logging` than this little overview can provide. You can
    log to more than one place at the same time, with different priorities and formats.
    The package has a lot of flexibility but sometimes at the cost of simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: Optimize
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is usually fast enough—until it isn’t. In many cases, you can gain speed
    by using a better algorithm or data structure. The trick is knowing where to do
    this. Even experienced programmers guess wrong surprisingly often. You need to
    be like the careful quiltmaker and measure before you cut. And this leads us to
    *timers*.
  prefs: []
  type: TYPE_NORMAL
- en: Measure Timing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve seen that the `time()` function in the `time` module returns the current
    epoch time as a floating-point number of seconds. A quick way of timing something
    is to get the current time, do something, get the new time, and then subtract
    the original time from the new time. Let’s write this up, as presented in [Example 19-20](#ex1920),
    and call it (what else?) *time1.py*.
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-20\. time1.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we’re measuring the time it takes to assign the value `5`
    to the name `num` and multiply it by `2`. This is *not* a realistic benchmark,
    just an example of how to measure some arbitrary Python code. Try running it a
    few times, just to see how much it can vary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: That was about two or three millionths of a second. Let’s try something slower,
    such as `sleep()`.^([2](ch19.html#idm45794965496488)) If we sleep for a second,
    our timer should take a tiny bit more than a second. [Example 19-21](#ex1921)
    shows the code; save this as *time2.py*.
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-21\. time2.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s be certain of our results, so run it a few times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: As expected, it takes about a second to run. If it didn’t, either our timer
    or `sleep()` should be embarrassed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a handier way to measure code snippets like this: using the standard
    module [`timeit`](http://bit.ly/py-timeit). It has a function called (you guessed
    it) `timeit()`, which will do *count* runs of your test *code* and print some
    results. The syntax is: ``timeit.timeit(*`code`*``, ``number=*`count`*)``.'
  prefs: []
  type: TYPE_NORMAL
- en: In the examples in this section, the `code` needs to be within quotes so that
    it is not executed after you press the Return key but is executed inside `timeit()`.
    (In the next section, you’ll see how to time a function by passing its name to
    `timeit()`.) Let’s run our previous example just once and time it. Call this file
    *timeit1.py* ([Example 19-22](#ex1922)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-22\. timeit1.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it a few times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Again, these two code lines ran in about two millionths of a second. We can
    use the `repeat` argument of the `timeit` module’s `repeat()` function to run
    more sets. Save this as *timeit2.py* ([Example 19-23](#ex1923)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-23\. timeit2.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Try running it to see what transpires:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The first run took two millionths of a second, and the second and third runs
    were faster. Why? There could be many reasons. For one thing, we’re testing a
    very small piece of code, and its speed could depend on what else the computer
    was doing in those instants, how the Python system optimizes calculations, and
    many other things.
  prefs: []
  type: TYPE_NORMAL
- en: Using `timeit()` meant wrapping the code you’re trying to measure as a string.
    What if you have multiple lines of code? You could pass it a triple-quoted multiline
    string, but that might be hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s define a lazy `snooze()` function that nods off for a second, as we all
    do occasionally.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can wrap the `snooze()` function itself. We need to include the arguments
    `globals=globals()` (this helps Python to find `snooze`) and `number=1` (run it
    only once; the default is 1000000, and we don’t have that much time):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can use a decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way is to use a context manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: The `__exit()__` method takes three extra arguments that we don’t use here;
    we could have used `*args` in their place.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, we’ve seen many ways to do timing. Now, let’s time some code to compare
    the efficiency of different algorithms (program logic) and data structures (storage
    mechanisms).
  prefs: []
  type: TYPE_NORMAL
- en: Algorithms and Data Structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [Zen of Python](http://bit.ly/zen-py) declares that *There should be one—and
    preferably only one—obvious way to do it*. Unfortunately, sometimes it isn’t obvious,
    and you need to compare alternatives. For example, is it better to use a `for`
    loop or a list comprehension to build a list? And what do we mean by *better*?
    Is it faster, easier to understand, using less memory, or more “Pythonic”?
  prefs: []
  type: TYPE_NORMAL
- en: In this next exercise, we build a list in different ways, comparing speed, readability,
    and Python style. Here’s *time_lists.py* ([Example 19-24](#ex1924)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-24\. time_lists.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'In each function, we add 1,000 items to a list, and we call each function 1,000
    times. Notice that in this test we called `timeit()` with the function name as
    the first argument rather than code as a string. Let’s run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: The list comprehension is at least twice as fast as adding items to the list
    by using `append()`. In general, comprehensions are faster than manual construction.
  prefs: []
  type: TYPE_NORMAL
- en: Use these ideas to make your own code faster.
  prefs: []
  type: TYPE_NORMAL
- en: Cython, NumPy, and C Extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re pushing Python as hard as you can and still can’t get the performance
    you want, you have yet more options.
  prefs: []
  type: TYPE_NORMAL
- en: '[Cython](http://cython.org) is a hybrid of Python and C, designed to translate
    Python with some performance annotations to compiled C code. These annotations
    are fairly small, like declaring the types of some variables, function arguments,
    or function returns. For scientific-style loops of numeric calculations, adding
    these hints will make them much faster—as much as a thousand times faster. See
    [the Cython wiki](https://oreil.ly/MmW_v) for documentation and examples.'
  prefs: []
  type: TYPE_NORMAL
- en: You can read much more about NumPy in [Chapter 22](ch22.html#ch_science). It’s
    a Python math library, written in C for speed.
  prefs: []
  type: TYPE_NORMAL
- en: Many parts of Python and its standard library are written in C for speed and
    wrapped in Python for convenience. These hooks are available to you for your applications.
    If you know C and Python and really want to make your code fly, writing a C extension
    is harder, but the improvements can be worth the trouble.
  prefs: []
  type: TYPE_NORMAL
- en: PyPy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When Java first appeared about 20 years ago, it was as slow as an arthritic
    Schnauzer. When it started to mean real money to Sun and other companies, though,
    they put millions into optimizing the Java interpreter and the underlying Java
    virtual machine (JVM), borrowing techniques from earlier languages like Smalltalk
    and LISP. Microsoft likewise put great effort into optimizing its rival C# language
    and .NET VM.
  prefs: []
  type: TYPE_NORMAL
- en: No one owns Python, so no one has pushed that hard to make it faster. You’re
    probably using the standard Python implementation. It’s written in C, and often
    called CPython (not the same as Cython).
  prefs: []
  type: TYPE_NORMAL
- en: Like PHP, Perl, and even Java, Python is not compiled to machine language, but
    translated to an intermediate language (with names such as *bytecode* or p-code)
    which is then interpreted in a *virtual machine*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PyPy](http://pypy.org) is a new Python interpreter that applies some of the
    tricks that sped up Java. Its [benchmarks](http://speed.pypy.org) show that PyPy
    is faster than CPython in every test—more than six times faster on average, and
    up to 20 times faster in some cases. It works with Python 2 and 3. You can download
    it and use it instead of CPython. PyPy is constantly being improved, and it might
    even replace CPython some day. Read the latest release notes on the site to see
    whether it could work for your purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: Numba
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use [Numba](http://numba.pydata.org) to compile your Python code on
    the fly to machine code and speed it up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install with the usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s first time a normal Python function that calculates a hypotenuse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `@jit` decorator to speed up calls after the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `@jit(nopython=True)` to avoid the overhead of the normal Python interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Numba is especially useful with NumPy and other mathematically demanding packages.
  prefs: []
  type: TYPE_NORMAL
- en: Source Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you’re working on a small group of programs, you can usually keep track
    of your changes—until you make a boneheaded mistake and clobber a few days of
    work. Source control systems help protect your code from dangerous forces, like
    you. If you work with a group of developers, source control becomes a necessity.
    There are many commercial and open source packages in this area. The most popular
    in the open source world where Python lives are Mercurial and Git. Both are examples
    of *distributed* version control systems, which produce multiple copies of code
    repositories. Earlier systems such as Subversion run on a single server.
  prefs: []
  type: TYPE_NORMAL
- en: Mercurial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Mercurial](http://mercurial-scm.org) is written in Python. It’s fairly easy
    to learn, with a handful of subcommands to download code from a Mercurial repository,
    add files, check in changes, and merge changes from different sources. [bitbucket](https://bitbucket.org)
    and [other sites](http://bit.ly/merc-host) offer free or commercial hosting.'
  prefs: []
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Git](http://git-scm.com) was originally written for Linux kernel development,
    but now dominates open source in general. It’s similar to Mercurial, although
    some find it slightly trickier to master. [GitHub](http://github.com) is the largest
    git host, with more than a million repositories, but there are [many other hosts](http://bit.ly/githost-scm).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The standalone program examples in this book are available in a public Git
    repository at [GitHub](https://oreil.ly/U2Rmy). If you have the `git` program
    on your computer, you can download these programs by using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also download the code from the GitHub page:'
  prefs: []
  type: TYPE_NORMAL
- en: Click “Clone in Desktop” to open your computer’s version of `git`, if installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click “Download ZIP” to get a zipped archive of the programs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you don’t have `git` but would like to try it, read the [installation guide](http://bit.ly/git-install).
    I talk about the command-line version here, but you might be interested in sites
    such as GitHub that have extra services and might be easier to use in some cases;
    `git` has many features, but is not always intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take `git` for a test drive. We won’t go far, but the ride will show a
    few commands and their output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make a new directory and change to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a local Git repository in your current directory *newdir*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Create a Python file called *test.py*, shown in [Example 19-25](#ex1925), with
    these contents in *newdir*.
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-25\. test.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the file to the Git repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: What do you think of that, Mr. Git?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that *test.py* is part of the local repository but its changes have
    not yet been committed. Let’s *commit* it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: That `-m "my first commit"` was your *commit message*. If you omitted that,
    `git` would pop you into an editor and coax you to enter the message that way.
    This becomes a part of the `git` change history for that file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what our current status is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Okay, all current changes have been committed. This means that we can change
    things and not worry about losing the original version. Make an adjustment now
    to *test.py*—change `Oops` to `Ops!` and save the file ([Example 19-26](#ex1926)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-26\. test.py, revised
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s check to see what `git` thinks now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `git diff` to see what lines have changed since the last commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to commit this change now, `git` complains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'That `staged for commit` phrase means you need to `add` the file, which roughly
    translated means *hey git, look over here*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'You could have also typed `git add .` to add *all* changed files in the current
    directory; that’s handy when you actually have edited multiple files and want
    to ensure that you check in all their changes. Now we can commit the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’d like to see all the terrible things that you’ve done to *test.py*,
    most recent first, use `git log`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Distribute Your Programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You know that your Python files can be installed in files and directories, and
    you know that you can run a Python program file with the `python` interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: It’s less well known that the Python interpreter can also execute Python code
    packaged in ZIP files. It’s even less well known that special ZIP files known
    as [pex files](https://pex.readthedocs.io) can also be used.
  prefs: []
  type: TYPE_NORMAL
- en: Clone This Book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can get a copy of all the programs in this book. Visit the [Git repository](https://oreil.ly/FbFAE)
    and follow the directions to copy it to your local machine. If you have `git`,
    run the command `git clone https://github.com/madscheme/introducing-python` to
    make a Git repository on your computer. You can also download the files in ZIP
    format.
  prefs: []
  type: TYPE_NORMAL
- en: How You Can Learn More
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is an introduction. It almost certainly says too much about some things
    that you don’t care about and not enough about some things that you do. Let me
    recommend some Python resources that I’ve found helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Books
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I’ve found the books in the following list to be especially useful. These range
    from introductory to advanced, with mixtures of Python 2 and 3:'
  prefs: []
  type: TYPE_NORMAL
- en: Barry, Paul. *Head First Python (2nd Edition)* O’Reilly, 2016.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beazley, David M. *Python Essential Reference (5th Edition)*. Addison-Wesley,
    2019.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beazley, David M. and Brian K. Jones. *Python Cookbook (3rd Edition)*. O’Reilly,
    2013.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gorelick, Micha and Ian Ozsvald. *High Performance Python*. O’Reilly, 2014.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maxwell, Aaron. *Powerful Python*. Powerful Python Press, 2017.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'McKinney, Wes. *Python for Data Analysis: Data Wrangling with Pandas, NumPy,
    and IPython*. O’Reilly, 2012.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ramalho, Luciano. *Fluent Python*. O’Reilly, 2015.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reitz, Kenneth and Tanya Schlusser. *The Hitchhiker’s Guide to Python*. O’Reilly,
    2016.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slatkin, Brett. *Effective Python*. Addison-Wesley, 2015.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Summerfield, Mark. *Python in Practice: Create Better Programs Using Concurrency,
    Libraries, and Patterns*. Addison-Wesley, 2013.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, there are [many more](https://wiki.python.org/moin/PythonBooks).
  prefs: []
  type: TYPE_NORMAL
- en: Websites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some websites where you can find helpful tutorials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Python for You and Me](https://pymbook.readthedocs.io) is an introduction,
    with good Windows coverage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Real Python](http://realpython.com) by various authors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Learn Python the Hard Way](http://learnpythonthehardway.org/book) by Zed Shaw'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Dive into Python 3](https://oreil.ly/UJcGM) by Mark Pilgrim'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Mouse Vs. Python](http://www.blog.pythonlibrary.org) by Michael Driscoll'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you’re interested in keeping up with what’s going on in the Pythonic world,
    check out these news websites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[comp.lang.python](http://bit.ly/comp-lang-python)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[comp.lang.python.announce](http://bit.ly/comp-lang-py-announce)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[r/python subreddit](http://www.reddit.com/r/python)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Planet Python](http://planet.python.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, here are some good websites for finding and downloading packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Python Package Index](https://pypi.python.org/pypi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Awesome Python](https://awesome-python.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Stack Overflow Python questions](https://oreil.ly/S1vEL)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ActiveState Python recipes](http://code.activestate.com/recipes/langs/python)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Python packages trending on GitHub](https://github.com/trending?l=python)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Computing communities have varied personalities: enthusiastic, argumentative,
    dull, hipster, button-down, and many others across a broad range. The Python community
    is friendly and civil. You can find Python groups based on location—[meetups](http://python.meetup.com)
    and local user groups [around the world](https://wiki.python.org/moin/LocalUserGroups).
    Other groups are distributed and based on common interests. For instance, [PyLadies](http://www.pyladies.com)
    is a support network for women who are interested in Python and open source.'
  prefs: []
  type: TYPE_NORMAL
- en: Conferences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of the many [conferences](http://www.pycon.org) and workshops [around the world](https://www.python.org/community/workshops),
    the largest are held annually in [North America](https://us.pycon.org) and [Europe](https://europython.eu/en).
  prefs: []
  type: TYPE_NORMAL
- en: Getting a Python Job
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Useful search sites include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Indeed](https://www.indeed.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Stack Overflow](https://stackoverflow.com/jobs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ZipRecruiter](https://www.ziprecruiter.com/candidate/suggested-jobs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Simply Hired](https://www.simplyhired.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CareerBuilder](https://www.careerbuilder.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Google](https://www.google.com/search?q=jobs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[LinkedIn](https://www.linkedin.com/jobs/search)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For most of these sites, type `python` in the first box and your location in
    the other. Good local sites include the Craigslist ones, like this link for [Seattle](https://seattle.craigslist.org/search/jjj).
    Simply change the `seattle` part to `sfbay`, `boston`, `nyc`, or other craigslist
    site prefixes to search those areas. For remote (telecommuting, or “work from
    home”) Python jobs, special sites include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Indeed](https://oreil.ly/pFQwb)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Google](https://oreil.ly/LI529)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[LinkedIn](https://oreil.ly/nhV6s)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Stack Overflow](https://oreil.ly/R23Tx)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Remote Python](https://oreil.ly/bPW1I)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[We Work Remotely](https://oreil.ly/9c3sC)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ZipRecruiter](https://oreil.ly/ohwAY)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Glassdoor](https://oreil.ly/tK5f5)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Remotely Awesome Jobs](https://oreil.ly/MkMeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Working Nomads](https://oreil.ly/uHVE3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GitHub](https://oreil.ly/smmrZ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coming Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: But wait, there’s more! The next three chapters offer tours of Python in the
    arts, business, and science. You’ll find at least one package that you’ll want
    to explore. Bright and shiny objects abound on the net. Only you can tell which
    are costume jewelry and which are silver bullets. And even if you’re not currently
    pestered by werewolves, you might want some of those silver bullets in your pocket.
    Just in case.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have answers to those annoying end-of-chapter exercises, details
    on installation of Python and friends, and a few cheat sheets for things that
    I always need to look up. Your brain is almost certainly better tuned, but they’re
    there if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Do
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: (Pythonistas don’t have homework today.)
  prefs: []
  type: TYPE_NORMAL
- en: '^([1](ch19.html#idm45794966587992-marker)) You, as the detective: “I know I’m
    in there! And if I don’t come out with my hands up, I’m coming in after me!”'
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch19.html#idm45794965496488-marker)) Many computer books use Fibonacci
    number calculations in timing examples, but I’d rather sleep than calculate Fibonacci
    numbers.
  prefs: []
  type: TYPE_NORMAL
