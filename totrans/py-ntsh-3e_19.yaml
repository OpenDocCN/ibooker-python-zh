- en: Chapter 19\. Client-Side Network Protocol Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python’s standard library supplies several modules to simplify the use of internet
    protocols on both the client and server sides. These days, the [Python Package
    Index](https://oreil.ly/PGIim), best known as *PyPI*, offers many more such packages.
    Because many of the standard library modules date back to the previous century,
    you will find that nowadays third-party packages support a wider array of protocols,
    and several offer better APIs than the standard library’s equivalents. When you
    need to use a network protocol that’s missing from the standard library, or covered
    by the standard library in a way you think is not satisfactory, be sure to search
    PyPI—you’re likely to find better solutions there.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we cover some standard library packages that allow relatively
    simple uses of network protocols: these let you code without requiring third-party
    packages, making your application or library easier to install on other machines.
    You may therefore come across them when dealing with legacy code, and their simplicity
    also makes them interesting reading for the Python student. We also mention a
    few third-party packages covering important network protocols not included in
    the standard library, but we do not cover third-party packages using asynchronous
    programming.'
  prefs: []
  type: TYPE_NORMAL
- en: For the very frequent use case of HTTP clients and other network resources (such
    as anonymous FTP sites) best accessed via URLs, the third-party [requests package](https://oreil.ly/t4X8r)
    is even recommended in the Python documentation, so we cover that and recommend
    its use instead of standard library modules.
  prefs: []
  type: TYPE_NORMAL
- en: Email Protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most email today is *sent* via servers implementing the Simple Mail Transport
    Protocol (SMTP) and *received* via servers and clients using Post Office Protocol
    version 3 (POP3) and/or Internet Message Access Protocol version 4 (IMAP4).^([1](ch19.xhtml#ch01fn140))
    Clients for these protocols are supported by the Python standard library modules
    smtplib, poplib, and imaplib, respectively, the first two of which we cover in
    this book. When you need to handle *parsing* or *generating* email messages, use
    the email package, covered in [Chapter 21](ch21.xhtml#emailcomma_mimecomma_and_other_network).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to write a client that can connect via either POP3 or IMAP4, a
    standard recommendation would be to pick IMAP4, since it is more powerful and—according
    to Python’s own online docs—often more accurately implemented on the server side.
    Unfortunately, imaplib is very complex, and far too vast to cover in this book.
    If you do choose to go that route, use the [online docs](https://oreil.ly/3ncIi),
    inevitably complemented by the IMAP RFCs, and possibly other related RFCs, such
    as 5161 and 6855 for capabilities and 2342 for namespaces. Using the RFCs in addition
    to the online docs for the standard library module can’t be avoided: many of the
    arguments passed to imaplib functions and methods, and results from calling them,
    are strings with formats that are only documented in the RFCs, not in Python’s
    own docs. A highly recommended alternative is to use the simpler, higher-abstraction-level
    third-party package [IMAPClient](https://oreil.ly/xTc4T), available with a **pip
    install** and well documented [online](https://oreil.ly/SuiI_).'
  prefs: []
  type: TYPE_NORMAL
- en: The poplib Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The poplib module supplies a class, POP3, to access a POP mailbox.^([2](ch19.xhtml#ch01fn141))
    The constructor has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '| POP3 | **class** POP3(*host*, port=110) Returns an instance *p* of class
    POP3 connected to the specified *host* and port. The class POP3_SSL behaves just
    the same, but connects to the host (by default on port 995) over a secure TLS
    channel; it’s needed to connect to email servers that demand some minimum security,
    such as pop.gmail.com.^([a](ch19.xhtml#ch01fn142)) |'
  prefs: []
  type: TYPE_TB
- en: '| ^([a](ch19.xhtml#ch01fn142-marker)) To connect to a Gmail account, in particular,
    you need to configure that account to enable POP, “allow less secure apps,” and
    avoid two-step verification—things that in general we don’t recommend, as they
    weaken your email’s security. |'
  prefs: []
  type: TYPE_TB
- en: An instance *p* of the class POP3 supplies many methods; the most frequently
    used are listed in [Table 19-1](#methods_of_an_instance_p_of_popthree). In each
    case, *msgnum*, the identifying number of a message, can be a string containing
    an integer value or an int.
  prefs: []
  type: TYPE_NORMAL
- en: Table 19-1\. Methods of an instance p of POP3
  prefs: []
  type: TYPE_NORMAL
- en: '| dele | *p*.dele(*msgnum*) Marks message *msgnum* for deletion and returns
    the server response string. The server queues such deletion requests, and executes
    them only when you terminate this connection by calling *p*.quit.^([a](ch19.xhtml#ch01fn143))
    |'
  prefs: []
  type: TYPE_TB
- en: '| list | *p*.list(*msgnum*=**None**) Returns a three-item tuple (*response*,
    *messages*, *octets*), where *response* is the server response string; *messages*
    a list of bytestrings, each of two words b''*msgnum* *bytes*'', the message number
    and length, in bytes, of each message in the mailbox; and *octets* is the length,
    in bytes, of the total response. When *msgnum* is not **None**, list returns a
    string, the response for the given *msgnum*, not a tuple. |'
  prefs: []
  type: TYPE_TB
- en: '| pass_ | *p*.pass_(*password*) Sends the password to the server, and returns
    the server response string. Must be called after *p*.user. The trailing underscore
    in the name is needed because **pass** is a Python keyword. |'
  prefs: []
  type: TYPE_TB
- en: '| quit | *p*.quit() Ends the session and tells the server to perform deletions
    that were requested by calls to *p*.dele. Returns the server response string.
    |'
  prefs: []
  type: TYPE_TB
- en: '| retr | *p*.retr(*msgnum*) Returns a three-item tuple (*response*, *lines*,
    *bytes*), where *response* is the server response string, *lines* is the list
    of all lines in message *msgnum* as bytestrings, and *bytes* is the total number
    of bytes in the message. |'
  prefs: []
  type: TYPE_TB
- en: '| s⁠e⁠t⁠_​d⁠e⁠b⁠u⁠g⁠l⁠e⁠v⁠e⁠l | *p*.set_debuglevel(*debug_level*) Sets the
    debug level to *debug_level*, an int with value 0 (the default) for no debugging,
    1 for a modest amount of debugging output, or 2 or more for a complete output
    trace of all control information exchanged with the server. |'
  prefs: []
  type: TYPE_TB
- en: '| stat | *p*.stat() Returns a pair (*num_msgs*, *bytes*), where *num_msgs*
    is the number of messages in the mailbox and *bytes* is the total number of bytes.
    |'
  prefs: []
  type: TYPE_TB
- en: '| top | *p*.top(*msgnum*, *maxlines*) Like retr, but returns at most *maxlines*
    lines from the message’s body (in addition to all the lines from the headers).
    Can be useful for peeking at the start of long messages. |'
  prefs: []
  type: TYPE_TB
- en: '| user | *p*.user(*username*) Sends the server the username; invariably followed
    up by a call to *p*.pass_. |'
  prefs: []
  type: TYPE_TB
- en: '| ^([a](ch19.xhtml#ch01fn143-marker)) The standard states that if disconnection
    occurs before the quit call, the deletions should not be actioned. Despite this,
    some servers will perform the deletion after any disconnection, planned or unplanned.
    |'
  prefs: []
  type: TYPE_TB
- en: The smtplib Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The smtplib module supplies a class, SMTP, to send mail via an SMTP server.^([3](ch19.xhtml#ch01fn144))
    The constructor has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '| SMTP | class SMTP([*host*, port=25]) Returns an instance *s* of the class
    SMTP. When *host* (and optionally port) is given, implicitly calls *s*.connect(*host*,
    port). The class SMTP_SSL behaves just the same, but connects to the host (by
    default on port 465) over a secure TLS channel; it’s needed to connect to email
    servers that demand some minimum security, such as smtp.gmail.com. |'
  prefs: []
  type: TYPE_TB
- en: An instance *s* of the class SMTP supplies many methods. The most frequently
    used of these are listed in [Table 19-2](#methods_of_an_instance_s_of_smtp).
  prefs: []
  type: TYPE_NORMAL
- en: Table 19-2\. Methods of an instance s of SMTP
  prefs: []
  type: TYPE_NORMAL
- en: '| connect | *s*.connect(host=127.0.0.1, port=25) Connects to an SMTP server
    on the given host (by default, the local host) and port (port 25 is the default
    port for the SMTP service; 465 is the default port for the more secure “SMTP over
    TLS”). |'
  prefs: []
  type: TYPE_TB
- en: '| login | *s*.login(*user*, *password*) Logs in to the server with the given
    *user* and *password*. Needed only if the SMTP server requires authentication
    (as just about all do). |'
  prefs: []
  type: TYPE_TB
- en: '| quit | *s*.quit() Terminates the SMTP session. |'
  prefs: []
  type: TYPE_TB
- en: '| sendmail | *s*.sendmail(*from_addr*, *to_addrs*, *msg_string*) Sends mail
    message *msg_string* from the sender whose address is in string *from_addr* to
    each of the recipients in the list *to_addrs*.^([a](ch19.xhtml#ch01fn145)) *msg_string*
    must be a complete RFC 822 message in a single multiline bytestring: the headers,
    an empty line for separation, then the body. The mail transport mechanism uses
    only *from_addr* and *to_addrs* to determine routing, ignoring any headers in
    *msg_string*.^([b](ch19.xhtml#ch01fn146)) To prepare RFC 822–compliant messages,
    use the package email, covered in [“MIME and Email Format Handling”](ch21.xhtml#mime_and_email_format_handling).
    |'
  prefs: []
  type: TYPE_TB
- en: '| send_message | *s.*send_message(*msg,* from_addr=**None**, to_addrs=**None**)
    A convenience function taking an email.message.Message object as its first argument.
    If either or both of from_addr and to_addrs are **None**, they are extracted from
    the message instead. |'
  prefs: []
  type: TYPE_TB
- en: '| ^([a](ch19.xhtml#ch01fn145-marker)) While the standard places no limits on
    the number of recipients in *from_addr*, individual mail servers may well do so,
    often making it advisable to batch messages with a maximum number of recipients
    in each one.^([b](ch19.xhtml#ch01fn146-marker)) This allows email systems to implement
    Bcc (blind copy) emails, for example, as the routing does not depend on the message
    envelope. |'
  prefs: []
  type: TYPE_TB
- en: HTTP and URL Clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the time, your code uses the HTTP and FTP protocols through the higher-abstraction
    URL layer, supported by the modules and packages covered in the following sections.
    Python’s standard library also offers lower-level, protocol-specific modules that
    are less often used: for FTP clients, [ftplib](https://oreil.ly/O_XHc); for HTTP
    clients, http.client (we cover HTTP servers in [Chapter 20](ch20.xhtml#serving_http)).
    If you need to write an FTP server, look at the third-party module [pyftpdlib](https://oreil.ly/Qrvcn).
    Implementations of the newer [HTTP/2](https://http2.github.io) may not be fully
    mature, but your best bet as of this writing is the third-party module [HTTPX](https://www.python-httpx.org).
    We do not cover any of these lower-level modules in this book: we focus on higher-abstraction,
    URL-level access throughout the following sections.'
  prefs: []
  type: TYPE_NORMAL
- en: URL Access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A URL is a type of uniform resource identifier (URI). A URI is a string that
    *identifies* a resource (but does not necessarily *locate* it), while a URL *locates*
    a resource on the internet. A URL is a string composed of several parts (some
    optional), called *components*: the *scheme, location, path, query*, and *fragment.*
    (The second component is sometimes also known as a *net location*, or *netloc*
    for short.) A URL with all parts looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In *https://www.python.org/community/awards/psf-awards/#october-2016*, for
    example, the scheme is *http*, the location is *www.python.org*, the path is */community/awards/psf-awards/*,
    there is no query, and the fragment is *#october-2016.* (Most schemes default
    to a *well-known port* when the port is not explicitly specified; for example,
    80 is the well-known port for the HTTP scheme.) Some punctuation is part of one
    of the components it separates; other punctuation characters are just separators,
    not part of any component. Omitting punctuation implies missing components. For
    example, in *mailto:me@you.com*, the scheme is *mailto*, the path is *me@you.com*
    (*mailto:me@you.com*), and there is no location, query, or fragment. No // means
    the URI has no location, no ? means it has no query, and no # means it has no
    fragment.'
  prefs: []
  type: TYPE_NORMAL
- en: If the location ends with a colon followed by a number, this denotes a TCP port
    for the endpoint. Otherwise, the connection uses the well-known port associated
    with the scheme (e.g., port 80 for HTTP).
  prefs: []
  type: TYPE_NORMAL
- en: The urllib Package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The urllib package supplies several modules for parsing and utilizing URL strings
    and associated resources. In addition to the urllib.parse and urllib.request modules
    described here, these include the module urllib.robotparser (for the specific
    purpose of parsing a site’s *robots.txt* file as per [RFC 9309](https://oreil.ly/QI7CQ))
    and the module urllib.error, containing all exception types raised by other urllib
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: The urllib.parse module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The urllib.parse module supplies functions for analyzing and synthesizing URL
    strings, and is typically imported with **from** urllib **import** parse **as**
    urlparse. Its most frequently used functions are listed in [Table 19-3](#useful_functions_of_the_urllibdotparse).
  prefs: []
  type: TYPE_NORMAL
- en: Table 19-3\. Useful functions of the urllib.parse module
  prefs: []
  type: TYPE_NORMAL
- en: '| urljoin | urljoin(*base_url_string*, *relative_url_string*) Returns a URL
    string *u*, obtained by joining *relative_url_string*, which may be relative,
    with *base_url_string*. The joining procedure that urljoin performs to obtain
    its result may be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When either of the argument strings is empty, *u* is the other argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When *relative_url_string* explicitly specifies a scheme that is different from
    that of *base_url_string**,* *u* is *relative_url_string*. Otherwise, *u*’s scheme
    is that of *base_url_string*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the scheme does not allow relative URLs (e.g., mailto), or when *relative_url_string*
    explicitly specifies a location (even when it is the same as the location of *base_url_string*),
    all other components of *u* are those of *relative_url_string*. Otherwise, *u*’s
    location is that of *base_url_string*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*u*’s path is obtained by joining the paths of *base_url_string* and *relative_url_string*
    according to standard syntax for absolute and relative URL paths.^([a](ch19.xhtml#ch01fn147))
    For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| urlsplit | urlsplit(*url_string*, default_scheme='''', allow_fragments=**True**)
    Analyzes *url_string* and returns a tuple (actually an instance of SplitResult,
    which you can treat as a tuple or use with named attributes) with five string
    items: *scheme*, *netloc*, *path*, *query*, and *fragment**.* *default_scheme*
    is the first item when the *url_string* lacks an explicit scheme. When allow_fragments
    is **False**, the tuple’s last item is always '''', whether or not *url_string*
    has a fragment. Items corresponding to missing parts are also ''''. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| urlunsplit | urlunsplit(*url_tuple*) *url_tuple* is any iterable with exactly
    five items, all strings. Any return value from a urlsplit call is an acceptable
    argument for urlunsplit. urlunsplit returns a URL string with the given components
    and the needed separators, but with no redundant separators (e.g., there is no
    # in the result when the fragment, *url_tuple*’s last item, is '''' ). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'urlunsplit(urlsplit(*x*)) returns a normalized form of URL string *x*, which
    is not necessarily equal to *x* because *x* need not be normalized. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the normalization ensures that redundant separators, such as the
    trailing ? in the argument to urlsplit, are not present in the result. |
  prefs: []
  type: TYPE_NORMAL
- en: '| ^([a](ch19.xhtml#ch01fn147-marker)) Per [RFC 1808](https://oreil.ly/T9v1p).
    |'
  prefs: []
  type: TYPE_TB
- en: The urllib.request module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The urllib.request module supplies functions for accessing data resources over
    standard internet protocols, the most commonly used of which are listed in [Table 19-4](#useful_functions_of_the_urllibdotreques).
    (The examples in the table assume you’ve imported the module.)
  prefs: []
  type: TYPE_NORMAL
- en: Table 19-4\. Useful functions of the urllib.request module
  prefs: []
  type: TYPE_NORMAL
- en: '| urlopen | urlopen(*url*, data=**None***,* timeout*,* context=**None**) Returns
    a response object whose type depends on the scheme in *url*:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP and HTTPS URLs return an http.client.HTTPResponse object (with the msg
    attribute modified to contain the same data as the reason attribute; for details,
    see the [online docs](https://oreil.ly/gWFcH)). Your code can use this object
    like an iterable, and as a context manager in a **with** statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FTP, file, and data URLs return a urllib.response.addinfourl object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*url* is the string or urllib.request.Request object for the URL to open. *data*
    is an optional bytes object, file-like object, or iterable of bytes, encoding
    additional data to send to the URL following *application/x-www-form-urlencoded*
    format. *timeout* is an optional argument for specifying, in seconds, a timeout
    for blocking operations of the URL opening process, applicable only for HTTP,
    HTTPS, and FTP URLs. When *context* is given, it must contain an ssl.SSLContext
    object specifying SSL options; *context* replaces the deprecated *cafile*, *capath*,
    and *cadefault* arguments. The following example downloads a file from an HTTPS
    URL and extracts it into a local bytes object, unicode_db:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| u⁠r⁠l​r⁠e⁠t⁠r⁠i⁠e⁠v⁠e | urlretrieve(*url_string*, filename=**None**, report_hook=**None**,
    data=**None**) A compatibility function to support migration from Python 2 legacy
    code. *url_string* gives the URL of the resource to download. filename is an optional
    string naming the local file in which to store the data retrieved from the URL.
    report_hook is a callable to support progress reporting during downloading, called
    once as each block of data is retrieved. data is similar to the data argument
    for urlopen. In its simplest form, urlretrieve is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Since this function was developed for Python 2 compatibility, you may still
    see it in existing codebases. New code should use urlopen. |
  prefs: []
  type: TYPE_NORMAL
- en: For full coverage of urllib.request see the [online docs](https://oreil.ly/Vz9IV)
    and Michael Foord’s [HOWTO](https://oreil.ly/6Lrem), which includes examples on
    downloading files given a URL. There’s a short example using urllib.request in
    [“An HTML Parsing Example with BeautifulSoup”](ch22.xhtml#an_html_parsing_example_with_beautifuls).
  prefs: []
  type: TYPE_NORMAL
- en: The Third-Party requests Package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The third-party [requests package](https://oreil.ly/cOiit) (very well documented
    [online](https://oreil.ly/MiQ76)) is how we recommend you access HTTP URLs. As
    usual for third-party packages, it’s best installed with a simple **pip install
    requests**. In this section, we summarize how best to use it for reasonably simple
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: Natively, requests only supports the HTTP and HTTPS transport protocols; to
    access URLs using other protocols, you need to install other third-party packages
    (known as *protocol adapters*), such as [requests-ftp](https://oreil.ly/efT73)
    for FTP URLs, or others supplied as part of the rich [requests-toolbelt](https://oreil.ly/_6nQe)
    package of requests utilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The requests package’s functionality hinges mostly on three classes it supplies:
    Request, modeling an HTTP request to be sent to a server; Response, modeling a
    server’s HTTP response to a request; and Session, offering continuity across a
    sequence of requests, also known as a *session.* For the common use case of a
    single request/response interaction, you don’t need continuity, so you may often
    just ignore Session.'
  prefs: []
  type: TYPE_NORMAL
- en: Sending requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Typically, you don’t need to explicitly consider the Request class: rather,
    you call the utility function request, which internally prepares and sends the
    Request and returns the Response instance. request has two mandatory positional
    arguments, both strs: method, the HTTP method to use, and url, the URL to address.
    Then, many optional named parameters may follow (in the next section, we cover
    the most commonly used named parameters to the request function).'
  prefs: []
  type: TYPE_NORMAL
- en: For further convenience, the requests module also supplies functions whose names
    are those of the HTTP methods delete, get, head, options, patch, post, and put;
    each takes a single mandatory positional argument, url, then the same optional
    named arguments as the function request.
  prefs: []
  type: TYPE_NORMAL
- en: When you want some continuity across multiple requests, call Session to make
    an instance *s*, then use *s*’s methods request, get, post, and so on, which are
    just like the functions with the same names directly supplied by the requests
    module (however, *s*’s methods merge *s*’s settings with the optional named parameters
    to prepare each request to send to the given url).
  prefs: []
  type: TYPE_NORMAL
- en: request’s optional named parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The function request (just like the functions get, post, and so on, and methods
    with the same names on an instance *s* of class Session) accepts many optional
    named parameters. Refer to the requests package’s excellent [online docs](https://oreil.ly/0rIwn)
    for the full set if you need advanced functionality such as control over proxies,
    authentication, special treatment of redirection, streaming, cookies, and so on.
    [Table 19-5](#named_parameters_accepted_by_the_reques) lists the most frequently
    used named parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Table 19-5\. Named parameters accepted by the request function
  prefs: []
  type: TYPE_NORMAL
- en: '| data | A dict, a sequence of key/value pairs, a bytestring, or a file-like
    object to use as the body of the request |'
  prefs: []
  type: TYPE_TB
- en: '| files | A dict with names as keys and file-like objects or *file tuples*
    as values, used with the POST method to specify a multipart-encoding file upload
    (we cover the format of values for files in the next section) |'
  prefs: []
  type: TYPE_TB
- en: '| headers | A dict of HTTP headers to send in the request |'
  prefs: []
  type: TYPE_TB
- en: '| json | Python data (usually a dict) to encode as JSON as the body of the
    request |'
  prefs: []
  type: TYPE_TB
- en: '| params | A dict of (*name*, *value*) items, or a bytestring to send as the
    query string with the request |'
  prefs: []
  type: TYPE_TB
- en: '| timeout | A float number of seconds, the maximum time to wait for the response
    before raising an exception |'
  prefs: []
  type: TYPE_TB
- en: 'data, json, and files are mutually incompatible ways to specify a body for
    the request; you should normally use at most one of them, and only for HTTP methods
    that do use a body (namely PATCH, POST, and PUT). The one exception is that you
    can have both a data argument passing a dict and a files argument. That is very
    common usage: in this case, both the key/value pairs in the dict and the files
    form the body of the request as a single *multipart/form-data* whole.^([4](ch19.xhtml#ch01fn148))'
  prefs: []
  type: TYPE_NORMAL
- en: The files argument (and other ways to specify the request’s body)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you specify the request’s body with json or data (passing a bytestring
    or a file-like object, which must be open for reading, usually in binary mode),
    the resulting bytes are directly used as the request’s body. When you specify
    it with data (passing a dict or a sequence of key/value pairs), the body is built
    as a *form*, from the key/value pairs formatted in *application/x-www-form-urlencoded*
    format, according to the relevant [web standard](https://oreil.ly/hHKp4).
  prefs: []
  type: TYPE_NORMAL
- en: When you specify the request’s body with files, the body is also built as a
    form, in this case with the format set to *multipart/form-data* (the only way
    to upload files in a PATCH, POST, or PUT HTTP request). Each file you’re uploading
    is formatted into its own part of the form; if, in addition, you want the form
    to give to the server further nonfile parameters, then in addition to files, you
    need to pass a data argument with a dict value (or a sequence of key/value pairs)
    for the further parameters. Those parameters get encoded into a supplementary
    part of the multipart form.
  prefs: []
  type: TYPE_NORMAL
- en: For flexibility, the value of the files argument can be a dict (its items are
    taken as a sequence of (*name*, *value*) pairs), or a sequence of (*name*, *value*)
    pairs (order is maintained in the resulting request body).
  prefs: []
  type: TYPE_NORMAL
- en: Either way, each value in a (*name*, *value*) pair can be a str (or, better,^([5](ch19.xhtml#ch01fn149))
    a bytes or bytearray) to be used directly as the uploaded file’s contents, or
    a file-like object open for reading (then, requests calls .read() on it and uses
    the result as the uploaded file’s contents; we strongly urge that in such cases
    you open the file in binary mode to avoid any ambiguity regarding content length).
    When any of these conditions apply, requests uses the *name* part of the pair
    (e.g., the key into the dict) as the file’s name (unless it can improve on that
    because the open file object is able to reveal its underlying filename), takes
    its best guess at a content type, and uses minimal headers for the file’s form
    part.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, the value in each (*name*, *value*) pair can be a tuple with
    two to four items, (*fn*, *fp*[, *ft*[, *fh*]]) (using square brackets as metasyntax
    to indicate optional parts). In this case, *fn* is the file’s name, *fp* provides
    the contents (in just the same way as in the previous paragraph), optional *ft*
    provides the content type (if missing, requests guesses it, as in the previous
    paragraph), and the optional dict *fh* provides extra headers for the file’s form
    part.
  prefs: []
  type: TYPE_NORMAL
- en: How to interpret requests examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In practical applications, you don’t usually need to consider the internal
    instance *r* of the class requests.Request, which functions like requests.post
    is building, preparing, and then sending on your behalf. However, to understand
    exactly what requests is doing, working at a lower level of abstraction (building,
    preparing, and examining *r*—no need to send it!) is instructive. For example,
    after importing requests, passing data as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'prints out (splitting the *p*.headers dict’s printout for readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, when passing files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'this prints out (with several lines split for readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Happy interactive exploring!
  prefs: []
  type: TYPE_NORMAL
- en: The Response class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The one class from the requests module that you always have to consider is
    Response: every request, once sent to the server (typically, that’s done implicitly
    by methods such as get), returns an instance *r* of requests.Response.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you usually want to do is to check *r*.status_code, an int
    that tells you how the request went, in typical “HTTPese”: 200 means “everything’s
    fine,” 404 means “not found,” and so on. If you’d rather just get an exception
    for status codes indicating some kind of error, call *r*.raise_for_status; that
    does nothing if the request went fine, but raises requests.exceptions.HTTPError
    otherwise. (Other exceptions, not corresponding to any specific HTTP status code,
    can and do get raised without requiring any such explicit call: e.g., ConnectionError
    for any kind of network problem, or TimeoutError for a timeout.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you may want to check the response’s HTTP headers: for that, use *r*.headers,
    a dict (with the special feature of having case-insensitive string-only keys indicating
    the header names as listed, e.g., in [Wikipedia](https://oreil.ly/_nJRX), per
    the HTTP specs). Most headers can be safely ignored, but sometimes you’d rather
    check. For example, you can verify whether the response specifies which natural
    language its body is written in, via *r*.headers.get(''content-language''), to
    offer different presentation choices, such as the option to use some kind of language
    translation service to make the response more usable for the user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You don’t usually need to make specific status or header checks for redirects:
    by default, requests automatically follows redirects for all methods except HEAD
    (you can explicitly pass the allow_redirection named parameter in the request
    to alter that behavior). If you allow redirects, you may want to check *r*.history,
    a list of all Response instances accumulated along the way, oldest to newest,
    up to but excluding *r* itself (*r*.history is empty if there have been no redirects).'
  prefs: []
  type: TYPE_NORMAL
- en: Most often, maybe after checking status and headers, you want to use the response’s
    body. In simple cases, just access the response’s body as a bytestring, *r*.content,
    or decode it as JSON (once you’ve checked that’s how it’s encoded, e.g., via *r*.headers.get('content-type'))
    by calling *r*.json.
  prefs: []
  type: TYPE_NORMAL
- en: Often, you’d rather access the response’s body as (Unicode) text, with the property
    *r*.text. The latter gets decoded (from the octets that actually make up the response’s
    body) with the codec requests thinks is best, based on the Content-Type header
    and a cursory examination of the body itself. You can check what codec has been
    used (or is about to be used) via the attribute *r*.encoding; its value will be
    the name of a codec registered with the codecs module, covered in [“The codecs
    Module”](ch09.xhtml#the_codecs_module). You can even *override* the choice of
    codec to use by *assigning* to *r*.encoding the name of the codec you choose.
  prefs: []
  type: TYPE_NORMAL
- en: We do not cover other advanced issues, such as streaming, in this book; see
    the requests package’s [online docs](https://oreil.ly/4St1s) for further information.
  prefs: []
  type: TYPE_NORMAL
- en: Other Network Protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many, *many* other network protocols are in use—a few are best supported by
    Python’s standard library, but for most of them you’ll find better and more recent
    third-party modules on [PyPI](https://oreil.ly/PGIim).
  prefs: []
  type: TYPE_NORMAL
- en: To connect as if you were logging in to another machine (or a separate login
    session on your own node), you can use the [Secure Shell (SSH)](https://oreil.ly/HazNC)
    protocol, supported by the third-party module [paramiko](http://www.paramiko.org)
    or the higher abstraction layer wrapper around it, the third-party module [spur](https://oreil.ly/vdmrN).
    (You can also, with some likely security risks, still use classic [Telnet](https://oreil.ly/5fw-y),
    supported by the standard library module [telnetlib](https://oreil.ly/GYdGi).)
  prefs: []
  type: TYPE_NORMAL
- en: 'Other network protocols include, among many others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[NNTP](https://oreil.ly/zCBov), to access Usenet News servers, supported by
    the standard library module nntplib'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[XML-RPC](https://oreil.ly/7vRm0), for a rudimentary remote procedure call
    functionality, supported by [xmlrpc.client](https://oreil.ly/K3oDj)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[gRPC](http://www.grpc.io), for a more modern remote procedure functionality,
    supported by third-party module [grpcio](https://oreil.ly/KHQHs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NTP](http://www.ntp.org), to get precise time off the network, supported by
    third-party module [ntplib](https://oreil.ly/R5SDp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SNMP](https://oreil.ly/nlhqH), for network management, supported by third-party
    module [pysnmp](https://oreil.ly/syh0_)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'No single book (not even this one!) could possibly cover all these protocols
    and their supporting modules. Rather, our best suggestion in the matter is a strategic
    one: whenever you decide that your application needs to interact with some other
    system via a certain networking protocol, don’t rush to implement your own modules
    to support that protocol. Instead, search and ask around, and you’re likely to
    find excellent existing Python modules (third-party or standard-library ones)
    supporting that protocol.^([6](ch19.xhtml#ch01fn150))'
  prefs: []
  type: TYPE_NORMAL
- en: 'Should you find some bug or missing feature in such modules, open a bug or
    feature request (and, ideally, supply a patch or pull request that would fix the
    problem and satisfy your application’s needs). In other words, become an active
    member of the open source community, rather than just a passive user: you will
    be welcome there, scratch your own itch, and help many others in the process.
    “Give forward,” since you cannot “give back” to all the awesome people who contributed
    to give you most of the tools you’re using!'
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch19.xhtml#ch01fn140-marker)) IMAP4, per [RFC 1730](https://oreil.ly/fn5aH);
    or IMAP4rev1, per [RFC 2060](https://oreil.ly/C5N0w).
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch19.xhtml#ch01fn141-marker)) The specification of the POP protocol can
    be found in [RFC 1939](https://oreil.ly/NLl6b).
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch19.xhtml#ch01fn144-marker)) The specification of the SMTP protocol can
    be found in [RFC 2821](https://oreil.ly/J9aCH).
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch19.xhtml#ch01fn148-marker)) According to [RFC 2388](https://oreil.ly/7xsOe).
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch19.xhtml#ch01fn149-marker)) As it gives you complete, explicit control
    of exactly what octets are uploaded.
  prefs: []
  type: TYPE_NORMAL
- en: '^([6](ch19.xhtml#ch01fn150-marker)) Even more importantly, if you think you
    need to invent a brand-new protocol and implement it on top of sockets, think
    again, and search carefully: it’s far more likely that one or more of the huge
    number of existing internet protocols meets your needs just fine!'
  prefs: []
  type: TYPE_NORMAL
