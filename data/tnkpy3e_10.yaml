- en: 8\. Strings and Regular Expressions#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8\. 字符串和正则表达式#
- en: 原文：[https://allendowney.github.io/ThinkPython/chap08.html](https://allendowney.github.io/ThinkPython/chap08.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://allendowney.github.io/ThinkPython/chap08.html](https://allendowney.github.io/ThinkPython/chap08.html)
- en: Strings are not like integers, floats, and booleans. A string is a **sequence**,
    which means it contains multiple values in a particular order. In this chapter
    we’ll see how to access the values that make up a string, and we’ll use functions
    that process strings.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串不同于整数、浮点数和布尔值。字符串是一个**序列**，意味着它包含多个按特定顺序排列的值。在本章中，我们将学习如何访问组成字符串的值，并使用处理字符串的函数。
- en: We’ll also use regular expressions, which are a powerful tool for finding patterns
    in a string and performing operations like search and replace.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用正则表达式，它是查找字符串中模式并执行如搜索和替换等操作的强大工具。
- en: As an exercise, you’ll have a chance to apply these tools to a word game called
    Wordle.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，你将有机会将这些工具应用到一个叫做Wordle的单词游戏中。
- en: 8.1\. A string is a sequence[#](#a-string-is-a-sequence "Link to this heading")
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1\. 字符串是一个序列[#](#a-string-is-a-sequence "Link to this heading")
- en: A string is a sequence of characters. A **character** can be a letter (in almost
    any alphabet), a digit, a punctuation mark, or white space.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是字符的序列。**字符**可以是字母（几乎所有字母表中的字母）、数字、标点符号或空格。
- en: 'You can select a character from a string with the bracket operator. This example
    statement selects character number 1 from `fruit` and assigns it to `letter`:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用方括号操作符从字符串中选择一个字符。这个示例语句从`fruit`中选择第1个字符，并将其赋值给`letter`：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The expression in brackets is an **index**, so called because it *indicates*
    which character in the sequence to select. But the result might not be what you
    expect.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号中的表达式是一个**索引**，之所以这么叫，是因为它*指示*要选择序列中的哪个字符。但结果可能不是你预期的。
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The letter with index `1` is actually the second letter of the string. An index
    is an offset from the beginning of the string, so the offset of the first letter
    is `0`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 索引为`1`的字母实际上是字符串中的第二个字母。索引是从字符串开始位置的偏移量，所以第一个字母的偏移量是`0`。
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can think of `'b'` as the 0th letter of `'banana'` – pronounced “zero-eth”.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把`'b'`当作`'banana'`的第0个字母——读作“零个”。
- en: The index in brackets can be a variable.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号中的索引可以是一个变量。
- en: '[PRE5]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Or an expression that contains variables and operators.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 或者是包含变量和运算符的表达式。
- en: '[PRE7]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: But the value of the index has to be an integer – otherwise you get a `TypeError`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，索引的值必须是整数——否则你会遇到`TypeError`。
- en: '[PRE9]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we saw in Chapter 1, we can use the built-in function `len` to get the length
    of a string.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第一章中看到的，我们可以使用内置函数`len`来获取字符串的长度。
- en: '[PRE11]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To get the last letter of a string, you might be tempted to write this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取字符串中的最后一个字母，你可能会想写成这样：
- en: '[PRE13]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'But that causes an `IndexError` because there is no letter in `''banana''`
    with the index 6\. Because we started counting at `0`, the six letters are numbered
    `0` to `5`. To get the last character, you have to subtract `1` from `n`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但这会导致`IndexError`，因为在`'banana'`中没有索引为6的字母。因为我们从`0`开始计数，所以六个字母的编号是`0`到`5`。要获取最后一个字符，你需要从`n`中减去`1`：
- en: '[PRE15]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: But there’s an easier way. To get the last letter in a string, you can use a
    negative index, which counts backward from the end.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但有更简单的方法。要获取字符串中的最后一个字母，你可以使用负索引，它从字符串的末尾向后计数。
- en: '[PRE17]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The index `-1` selects the last letter, `-2` selects the second to last, and
    so on.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 索引`-1`选择最后一个字母，`-2`选择倒数第二个字母，以此类推。
- en: 8.2\. String slices[#](#string-slices "Link to this heading")
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2\. 字符串切片[#](#string-slices "Link to this heading")
- en: A segment of a string is called a **slice**. Selecting a slice is similar to
    selecting a character.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的一部分称为**切片**。选择切片类似于选择单个字符。
- en: '[PRE19]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The operator `[n:m]` returns the part of the string from the `n`th character
    to the `m`th character, including the first but excluding the second. This behavior
    is counterintuitive, but it might help to imagine the indices pointing *between*
    the characters, as in this figure:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符`[n:m]`返回字符串从第`n`个字符到第`m`个字符的部分，包括第一个字符但不包括第二个字符。这种行为是反直觉的，但可以通过想象索引指向*字符之间*的空间来帮助理解，如图所示：
- en: '![_images/8ee40ccdcbc16b8660dd062b1c73a25d49a42724ad6026a2fa3ebf191b4a9862.png](../Images/a09d0d29930012ae176692b0cb80c9df.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![_images/8ee40ccdcbc16b8660dd062b1c73a25d49a42724ad6026a2fa3ebf191b4a9862.png](../Images/a09d0d29930012ae176692b0cb80c9df.png)'
- en: For example, the slice `[3:6]` selects the letters `ana`, which means that `6`
    is legal as part of a slice, but not legal as an index.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，切片`[3:6]`选择了字母`ana`，这意味着`6`在作为切片的一部分时是合法的，但作为索引时是不合法的。
- en: If you omit the first index, the slice starts at the beginning of the string.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略第一个索引，切片将从字符串的开头开始。
- en: '[PRE21]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you omit the second index, the slice goes to the end of the string:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略第二个索引，切片将一直延伸到字符串的末尾：
- en: '[PRE23]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If the first index is greater than or equal to the second, the result is an
    **empty string**, represented by two quotation marks:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个索引大于或等于第二个索引，结果将是一个**空字符串**，由两个引号表示：
- en: '[PRE25]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: An empty string contains no characters and has length 0.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 空字符串不包含任何字符，长度为0。
- en: Continuing this example, what do you think `fruit[:]` means? Try it and see.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 继续这个例子，你认为`fruit[:]`意味着什么？试试看吧。
- en: 8.3\. Strings are immutable[#](#strings-are-immutable "Link to this heading")
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3\. 字符串是不可变的[#](#strings-are-immutable "链接到此标题")
- en: 'It is tempting to use the `[]` operator on the left side of an assignment,
    with the intention of changing a character in a string, like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易在赋值语句的左侧使用`[]`运算符，试图更改字符串中的字符，如下所示：
- en: '[PRE27]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The result is a `TypeError`. In the error message, the “object” is the string
    and the “item” is the character we tried to assign. For now, an **object** is
    the same thing as a value, but we will refine that definition later.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个`TypeError`。在错误信息中，“对象”是字符串，“项”是我们试图赋值的字符。目前，**对象**与值是相同的，但我们稍后会进一步细化这个定义。
- en: The reason for this error is that strings are **immutable**, which means you
    can’t change an existing string. The best you can do is create a new string that
    is a variation of the original.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 发生这个错误的原因是字符串是**不可变的**，这意味着你不能更改一个已有的字符串。你能做的最好的事是创建一个新的字符串，它是原始字符串的变体。
- en: '[PRE29]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This example concatenates a new first letter onto a slice of `greeting`. It
    has no effect on the original string.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将一个新的首字母连接到`greeting`的切片上。它不会对原始字符串产生影响。
- en: '[PRE31]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 8.4\. String comparison[#](#string-comparison "Link to this heading")
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4\. 字符串比较[#](#string-comparison "链接到此标题")
- en: The relational operators work on strings. To see if two strings are equal, we
    can use the `==` operator.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 关系运算符适用于字符串。要检查两个字符串是否相等，我们可以使用`==`运算符。
- en: '[PRE33]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Other relational operations are useful for putting words in alphabetical order:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 其他关系运算符对于将单词按字母顺序排列很有用：
- en: '[PRE35]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Python does not handle uppercase and lowercase letters the same way people
    do. All the uppercase letters come before all the lowercase letters, so:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Python处理大写字母和小写字母的方式不同于人类。所有大写字母都排在所有小写字母之前，所以：
- en: '[PRE38]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: To solve this problem, we can convert strings to a standard format, such as
    all lowercase, before performing the comparison. Keep that in mind if you have
    to defend yourself against a man armed with a Pineapple.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以在进行比较之前将字符串转换为标准格式，例如全小写。请记住，如果你需要防御一个手持菠萝的人时，这一点非常重要。
- en: 8.5\. String methods[#](#string-methods "Link to this heading")
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5\. 字符串方法[#](#string-methods "链接到此标题")
- en: Strings provide methods that perform a variety of useful operations. A method
    is similar to a function – it takes arguments and returns a value – but the syntax
    is different. For example, the method `upper` takes a string and returns a new
    string with all uppercase letters.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串提供了执行多种有用操作的方法。方法类似于函数——它接受参数并返回一个值——但语法有所不同。例如，`upper`方法接受一个字符串并返回一个新的字符串，其中所有字母都为大写。
- en: Instead of the function syntax `upper(word)`, it uses the method syntax `word.upper()`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用的方法语法是`word.upper()`，而不是函数语法`upper(word)`。
- en: '[PRE40]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This use of the dot operator specifies the name of the method, `upper`, and
    the name of the string to apply the method to, `word`. The empty parentheses indicate
    that this method takes no arguments.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这种使用点运算符的方式指定了方法的名称`upper`，以及要应用该方法的字符串名称`word`。空的括号表示此方法不接受任何参数。
- en: A method call is called an **invocation**; in this case, we would say that we
    are invoking `upper` on `word`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 方法调用称为**调用**；在这种情况下，我们可以说我们正在对`word`调用`upper`方法。
- en: '## 8.6\. Writing files[#](#writing-files "Link to this heading")'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '## 8.6\. 写入文件[#](#writing-files "链接到此标题")'
- en: String operators and methods are useful for reading and writing text files.
    As an example, we’ll work with the text of *Dracula*, a novel by Bram Stoker that
    is available from Project Gutenberg ([https://www.gutenberg.org/ebooks/345](https://www.gutenberg.org/ebooks/345)).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串运算符和方法对于读取和写入文本文件非常有用。举个例子，我们将处理*德古拉*的文本，这本由布拉姆·斯托克创作的小说可以从古腾堡计划获取（[https://www.gutenberg.org/ebooks/345](https://www.gutenberg.org/ebooks/345)）。
- en: 'I’ve downloaded the book in a plain text file called `pg345.txt`, which we
    can open for reading like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将这本书下载为名为`pg345.txt`的纯文本文件，我们可以像这样打开它进行阅读：
- en: '[PRE42]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In addition to the text of the book, this file contains a section at the beginning
    with information about the book and a section at the end with information about
    the license. Before we process the text, we can remove this extra material by
    finding the special lines at the beginning and end that begin with `'***'`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 除了书籍的文本外，这个文件在开头包含了一段关于书籍的信息，在结尾包含了一段关于许可证的信息。在处理文本之前，我们可以通过找到以 `'***'` 开头的特殊行来去除这些额外的内容。
- en: The following function takes a line and checks whether it is one of the special
    lines. It uses the `startswith` method, which checks whether a string starts with
    a given sequence of characters.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数接收一行并检查它是否是特殊行之一。它使用 `startswith` 方法，检查字符串是否以给定的字符序列开头。
- en: '[PRE43]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We can use this function to loop through the lines in the file and print only
    the special lines.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个函数来遍历文件中的行，并仅打印特殊行。
- en: '[PRE44]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now let’s create a new file, called `pg345_cleaned.txt`, that contains only
    the text of the book. In order to loop through the book again, we have to open
    it again for reading. And, to write a new file, we can open it for writing.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个新的文件，命名为 `pg345_cleaned.txt`，其中只包含书籍的文本。为了再次循环遍历书籍，我们必须重新打开它以进行读取。并且，为了写入新文件，我们可以以写入模式打开它。
- en: '[PRE46]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`open` takes an optional parameters that specifies the “mode” – in this example,
    `''w''` indicates that we’re opening the file for writing. If the file doesn’t
    exist, it will be created; if it already exists, the contents will be replaced.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`open` 接受一个可选参数，指定“模式”——在这个例子中，`''w''` 表示我们以写入模式打开文件。如果文件不存在，它将被创建；如果文件已经存在，内容将被替换。'
- en: As a first step, we’ll loop through the file until we find the first special
    line.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，我们将遍历文件，直到找到第一行特殊行。
- en: '[PRE47]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `break` statement “breaks” out of the loop – that is, it causes the loop
    to end immediately, before we get to the end of the file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`break` 语句“跳出”循环——也就是说，它会立即结束循环，而不等到文件末尾。'
- en: When the loop exits, `line` contains the special line that made the conditional
    true.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环退出时，`line` 包含了使条件为真的特殊行。
- en: '[PRE48]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Because `reader` keeps track of where it is in the file, we can use a second
    loop to pick up where we left off.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `reader` 会跟踪文件中的当前位置，我们可以使用第二个循环从我们离开的地方继续。
- en: The following loop reads the rest of the file, one line at a time. When it finds
    the special line that indicates the end of the text, it breaks out of the loop.
    Otherwise, it writes the line to the output file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下循环逐行读取文件的其余部分。当它找到表示文本结束的特殊行时，它会跳出循环。否则，它会将该行写入输出文件。
- en: '[PRE50]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When this loop exits, `line` contains the second special line.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个循环退出时，`line` 包含第二个特殊行。
- en: '[PRE51]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: At this point `reader` and `writer` are still open, which means we could keep
    reading lines from `reader` or writing lines to `writer`. To indicate that we’re
    done, we can close both files by invoking the `close` method.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`reader` 和 `writer` 仍然打开，这意味着我们可以继续从 `reader` 读取行或向 `writer` 写入行。为了表示我们完成了，我们可以通过调用
    `close` 方法关闭这两个文件。
- en: '[PRE53]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: To check whether this process was successful, we can read the first few lines
    from the new file we just created.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查这个过程是否成功，我们可以读取刚创建的新文件中的前几行。
- en: '[PRE54]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `endswith` method checks whether a string ends with a given sequence of
    characters.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`endswith` 方法检查字符串是否以给定的字符序列结尾。'
- en: 8.7\. Find and replace[#](#find-and-replace "Link to this heading")
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7\. 查找与替换[#](#find-and-replace "链接到此标题")
- en: In the Icelandic translation of *Dracula* from 1901, the name of one of the
    characters was changed from “Jonathan” to “Thomas”. To make this change in the
    English version, we can loop through the book, use the `replace` method to replace
    one name with another, and write the result to a new file.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1901 年的冰岛语版《德古拉》中，其中一个角色的名字从 “Jonathan” 改成了 “Thomas”。为了在英文版中进行这一更改，我们可以遍历整本书，使用
    `replace` 方法将一个名字替换成另一个，并将结果写入新文件。
- en: We’ll start by counting the lines in the cleaned version of the file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从计数文件清理版的行数开始。
- en: '[PRE56]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: To see whether a line contains “Jonathan”, we can use the `in` operator, which
    checks whether this sequence of characters appears anywhere in the line.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看一行是否包含“Jonathan”，我们可以使用 `in` 运算符，检查该字符序列是否出现在行中。
- en: '[PRE58]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: There are 199 lines that contain the name, but that’s not quite the total number
    of times it appears, because it can appear more than once in a line. To get the
    total, we can use the `count` method, which returns the number of times a sequence
    appears in a string.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有 199 行包含这个名字，但这还不是它出现的总次数，因为它可能在一行中出现多次。为了得到总数，我们可以使用 `count` 方法，它返回字符串中某个序列出现的次数。
- en: '[PRE60]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now we can replace `''Jonathan''` with `''Thomas''` like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以像这样将 `'Jonathan'` 替换为 `'Thomas'`：
- en: '[PRE62]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The result is a new file called `pg345_replaced.txt` that contains a version
    of *Dracula* where Jonathan Harker is called Thomas.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个新文件，名为 `pg345_replaced.txt`，其中包含了*德古拉*的一个版本，在这个版本中，Jonathan Harker 被称为
    Thomas。
- en: 8.8\. Regular expressions[#](#regular-expressions "Link to this heading")
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.8\. 正则表达式[#](#regular-expressions "Link to this heading")
- en: If we know exactly what sequence of characters we’re looking for, we can use
    the `in` operator to find it and the `replace` method to replace it. But there
    is another tool, called a **regular expression** that can also perform these operations
    – and a lot more.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确切知道要寻找的字符序列，可以使用 `in` 运算符来查找，并使用 `replace` 方法替换它。但还有一种工具，叫做**正则表达式**，也可以执行这些操作——而且功能更多。
- en: To demonstrate, I’ll start with a simple example and we’ll work our way up.
    Suppose, again, that we want to find all lines that contain a particular word.
    For a change, let’s look for references to the titular character of the book,
    Count Dracula. Here’s a line that mentions him.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我将从一个简单的例子开始，然后逐步增加难度。假设，我们再次想要找到所有包含特定单词的行。为了换个方式，我们来看一下书中提到主人公德古拉伯爵的地方。这里有一行提到他。
- en: '[PRE63]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: And here’s the **pattern** we’ll use to search.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将用于搜索的**模式**。
- en: '[PRE64]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: A module called `re` provides functions related to regular expressions. We can
    import it like this and use the `search` function to check whether the pattern
    appears in the text.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 `re` 的模块提供了与正则表达式相关的函数。我们可以像这样导入它，并使用 `search` 函数来检查模式是否出现在文本中。
- en: '[PRE65]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If the pattern appears in the text, `search` returns a `Match` object that contains
    the results of the search. Among other information, it has a variable named `string`
    that contains the text that was searched.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模式出现在文本中，`search` 将返回一个包含搜索结果的 `Match` 对象。除了其他信息外，它还包含一个名为 `string` 的变量，其中包含被搜索的文本。
- en: '[PRE67]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: It also provides a method called `group` that returns the part of the text that
    matched the pattern.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供了一个名为 `group` 的方法，可以返回匹配模式的文本部分。
- en: '[PRE69]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: And it provides a method called `span` that returns the index in the text where
    the pattern starts and ends.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供了一个名为 `span` 的方法，可以返回模式在文本中开始和结束的位置。
- en: '[PRE71]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: If the pattern doesn’t appear in the text, the return value from `search` is
    `None`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模式在文本中没有出现，`search` 的返回值是 `None`。
- en: '[PRE73]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: So we can check whether the search was successful by checking whether the result
    is `None`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过检查结果是否为 `None` 来判断搜索是否成功。
- en: '[PRE75]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Putting all that together, here’s a function that loops through the lines in
    the book until it finds one that matches the given pattern, and returns the `Match`
    object.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些都结合起来，这里有一个函数，它循环遍历书中的每一行，直到找到匹配给定模式的行，并返回 `Match` 对象。
- en: '[PRE77]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We can use it to find the first mention of a character.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用它来找到某个字符的首次出现。
- en: '[PRE78]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: For this example, we didn’t have to use regular expressions – we could have
    done the same thing more easily with the `in` operator. But regular expressions
    can do things the `in` operator cannot.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们并不需要使用正则表达式——我们可以用 `in` 运算符更轻松地完成相同的事情。但正则表达式可以做一些 `in` 运算符无法做到的事情。
- en: For example, if the pattern includes the vertical bar character, `'|'`, it can
    match either the sequence on the left or the sequence on the right. Suppose we
    want to find the first mention of Mina Murray in the book, but we are not sure
    whether she is referred to by first name or last. We can use the following pattern,
    which matches either name.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果模式中包括竖线字符，`'|'`，它可以匹配左边或右边的序列。假设我们想要在书中找到 Mina Murray 的首次提及，但我们不确定她是用名字还是姓氏来称呼的。我们可以使用以下模式，它可以匹配这两个名字。
- en: '[PRE80]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: We can use a pattern like this to see how many times a character is mentioned
    by either name. Here’s a function that loops through the book and counts the number
    of lines that match the given pattern.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这样的模式来查看某个字符通过名字提到的次数。这里有一个函数，它会遍历书中的每一行，并统计与给定模式匹配的行数。
- en: '[PRE82]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Now let’s see how many times Mina is mentioned.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看 Mina 被提到多少次。
- en: '[PRE83]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The special character `'^'` matches the beginning of a string, so we can find
    a line that starts with a given pattern.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊字符`'^'`匹配字符串的开始，因此我们可以找到以给定模式开头的行。
- en: '[PRE85]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: And the special character `'$'` matches the end of a string, so we can find
    a line that ends with a given pattern (ignoring the newline at the end).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊字符`'$'`匹配字符串的结尾，因此我们可以找到以给定模式结尾的行（忽略行尾的换行符）。
- en: '[PRE87]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 8.9\. String substitution[#](#string-substitution "Link to this heading")
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.9\. 字符串替换[#](#string-substitution "链接到此标题")
- en: Bram Stoker was born in Ireland, and when *Dracula* was published in 1897, he
    was living in England. So we would expect him to use the British spelling of words
    like “centre” and “colour”. To check, we can use the following pattern, which
    matches either “centre” or the American spelling “center”.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 布拉姆·斯托克出生在爱尔兰，*而《德古拉》*于1897年出版时，他正居住在英格兰。因此，我们可以预期他会使用英国拼写方式，例如“centre”和“colour”。为了验证这一点，我们可以使用以下模式，这个模式可以匹配“centre”或者美国拼写“center”。
- en: '[PRE89]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: In this pattern, the parentheses enclose the part of the pattern the vertical
    bar applies to. So this pattern matches a sequence that starts with `'cent'` and
    ends with either `'er'` or `'re'`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模式中，括号包围的是竖线（`|`）所应用的模式部分。所以这个模式匹配的是一个以`'cent'`开头并且以`'er'`或`'re'`结尾的序列。
- en: '[PRE90]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: As expected, he used the British spelling.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，他使用了英国拼写。
- en: We can also check whether he used the British spelling of “colour”. The following
    pattern uses the special character `'?'`, which means that the previous character
    is optional.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以检查他是否使用了“colour”的英国拼写。以下模式使用了特殊字符`'?'`，表示前一个字符是可选的。
- en: '[PRE92]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This pattern matches either “colour” with the `'u'` or “color” without it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式可以匹配带有`'u'`的“colour”或没有`'u'`的“color”。
- en: '[PRE93]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Again, as expected, he used the British spelling.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，正如预期的那样，他使用了英国拼写。
- en: Now suppose we want to produce an edition of the book with American spellings.
    We can use the `sub` function in the `re` module, which does **string substitution**.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想制作一本使用美国拼写的书籍版本。我们可以使用`re`模块中的`sub`函数，它执行**字符串替换**。
- en: '[PRE95]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The first argument is the pattern we want to find and replace, the second is
    what we want to replace it with, and the third is the string we want to search.
    In the result, you can see that “colour” has been replaced with “color”.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是我们想要查找并替换的模式，第二个是我们想用来替换的内容，第三个是我们要搜索的字符串。在结果中，你可以看到“colour”已被替换为“color”。
- en: 8.10\. Debugging[#](#debugging "Link to this heading")
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.10\. 调试[#](#debugging "链接到此标题")
- en: 'When you are reading and writing files, debugging can be tricky. If you are
    working in a Jupyter notebook, you can use **shell commands** to help. For example,
    to display the first few lines of a file, you can use the command `!head`, like
    this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在读取和写入文件时，调试可能会很棘手。如果你在使用Jupyter笔记本，可以使用**shell命令**来帮助。例如，要显示文件的前几行，可以使用命令`!head`，像这样：
- en: '[PRE97]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The initial exclamation point, `!`, indicates that this is a shell command,
    which is not part of Python. To display the last few lines, you can use `!tail`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的感叹号`!`表示这是一个shell命令，而不是Python的一部分。要显示最后几行，可以使用`!tail`。
- en: '[PRE98]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: When you are working with large files, debugging can be difficult because there
    might be too much output to check by hand. A good debugging strategy is to start
    with just part of the file, get the program working, and then run it with the
    whole file.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理大文件时，调试可能会变得困难，因为输出可能过多，无法手动检查。一个好的调试策略是从文件的一部分开始，先让程序正常工作，然后再用完整的文件运行它。
- en: To make a small file that contains part of a larger file, we can use `!head`
    again with the redirect operator, `>`, which indicates that the results should
    be written to a file rather than displayed.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制作一个包含大文件部分内容的小文件，我们可以再次使用`!head`并配合重定向符号`>`，表示结果应该写入文件而不是显示在屏幕上。
- en: '[PRE99]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: By default, `!head` reads the first 10 lines, but it takes an optional argument
    that indicates the number of lines to read.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`!head`读取前10行，但它也接受一个可选参数，用于指示要读取的行数。
- en: '[PRE100]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: This shell command reads the first 100 lines from `pg345_cleaned.txt` and writes
    them to a file called `pg345_cleaned_100_lines.txt`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个shell命令读取`pg345_cleaned.txt`的前100行，并将它们写入名为`pg345_cleaned_100_lines.txt`的文件。
- en: 'Note: The shell commands `!head` and `!tail` are not available on all operating
    systems. If they don’t work for you, we can write similar functions in Python.
    See the first exercise at the end of this chapter for suggestions.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：shell命令`!head`和`!tail`并非在所有操作系统上都可用。如果它们在你这里无法使用，我们可以用Python编写类似的函数。请参考本章最后的第一个练习获取建议。
- en: 8.11\. Glossary[#](#glossary "Link to this heading")
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.11\. 术语表[#](#glossary "链接到此标题")
- en: '**sequence:** An ordered collection of values where each value is identified
    by an integer index.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**sequence（序列）：** 一种有序的值集合，每个值由一个整数索引标识。'
- en: '**character:** An element of a string, including letters, numbers, and symbols.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**character（字符）：** 字符串中的一个元素，包括字母、数字和符号。'
- en: '**index:** An integer value used to select an item in a sequence, such as a
    character in a string. In Python indices start from `0`.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**index（索引）：** 用于选择序列中项的整数值，例如字符串中的字符。在 Python 中，索引从`0`开始。'
- en: '**slice:** A part of a string specified by a range of indices.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**slice（切片）：** 由一系列索引范围指定的字符串的一部分。'
- en: '**empty string:** A string that contains no characters and has length `0`.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**empty string（空字符串）：** 一个不包含任何字符且长度为`0`的字符串。'
- en: '**object:** Something a variable can refer to. An object has a type and a value.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**object（对象）：** 一个变量可以引用的事物。对象有类型和数值。'
- en: '**immutable:** If the elements of an object cannot be changed, the object is
    immutable.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**immutable（不可变）：** 如果一个对象的元素不能被改变，则该对象是不可变的。'
- en: '**invocation:** An expression – or part of an expression – that calls a method.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**invocation（调用）：** 一个表达式——或表达式的一部分——用于调用方法。'
- en: '**regular expression:** A sequence of characters that defines a search pattern.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**regular expression（正则表达式）：** 定义搜索模式的字符序列。'
- en: '**pattern:** A rule that specifies the requirements a string has to meet to
    constitute a match.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**pattern（模式）：** 规定一个字符串必须满足的要求，以便构成匹配。'
- en: '**string substitution:** Replacement of a string, or part of a string, with
    another string.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**string substitution（字符串替换）：** 用另一个字符串替换字符串的部分内容。'
- en: '**shell command:** A statement in a shell language, which is a language used
    to interact with an operating system.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**shell command（shell 命令）：** 用于与操作系统交互的 shell 语言中的语句。'
- en: 8.12\. Exercises[#](#exercises "Link to this heading")
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.12\. 练习[#](#exercises "链接到此标题")
- en: '[PRE101]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 8.12.1\. Ask a virtual assistant[#](#ask-a-virtual-assistant "Link to this heading")
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.12.1\. 向虚拟助手提问[#](#ask-a-virtual-assistant "链接到此标题")
- en: In this chapter, we only scratched the surface of what regular expressions can
    do. To get an idea of what’s possible, ask a virtual assistant, “What are the
    most common special characters used in Python regular expressions?”
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们仅触及了正则表达式能做的事情的表面。为了了解正则表达式的可能性，可以问虚拟助手：“Python 正则表达式中最常用的特殊字符有哪些？”
- en: 'You can also ask for a pattern that matches particular kinds of strings. For
    example, try asking:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以请求匹配特定类型字符串的模式。例如，尝试询问：
- en: Write a Python regular expression that matches a 10-digit phone number with
    hyphens.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个匹配带有连字符的 10 位电话号码的 Python 正则表达式。
- en: Write a Python regular expression that matches a street address with a number
    and a street name, followed by `ST` or `AVE`.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个匹配带有数字和街道名称的街道地址的 Python 正则表达式，地址后跟`ST`或`AVE`。
- en: Write a Python regular expression that matches a full name with any common title
    like `Mr` or `Mrs` followed by any number of names beginning with capital letters,
    possibly with hyphens between some names.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个匹配完整姓名的 Python 正则表达式，该姓名可能包含常见的称谓，如`Mr`或`Mrs`，后跟一个或多个以大写字母开头的名字，名字之间可能有连字符。
- en: And if you want to see something more complicated, try asking for a regular
    expression that matches any legal URL.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看一些更复杂的内容，可以尝试询问正则表达式，它匹配任何合法的 URL。
- en: A regular expression often has the letter `r` before the quotation mark, which
    indicates that it is a “raw string”. For more information, ask a virtual assistant,
    “What is a raw string in Python?”
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式通常在引号前面加上字母`r`，表示这是一个“原始字符串”。欲了解更多信息，可以问虚拟助手：“Python 中的原始字符串是什么？”
- en: 8.12.2\. Exercise[#](#exercise "Link to this heading")
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.12.2\. 练习[#](#exercise "链接到此标题")
- en: See if you can write a function that does the same thing as the shell command
    `!head`. It should take as arguments the name of a file to read, the number of
    lines to read, and the name of the file to write the lines into. If the third
    parameter is `None`, it should display the lines rather than write them to a file.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你能否编写一个函数，实现与 shell 命令`!head`相同的功能。它应该接受三个参数：要读取的文件名、要读取的行数以及要将这些行写入的文件名。如果第三个参数是`None`，它应该显示这些行，而不是将它们写入文件。
- en: Consider asking a virtual assistant for help, but if you do, tell it not to
    use a `with` statement or a `try` statement.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑请虚拟助手帮忙，但如果这样做，请告诉它不要使用`with`语句或`try`语句。
- en: 8.12.3\. Exercise[#](#id1 "Link to this heading")
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.12.3\. 练习[#](#id1 "链接到此标题")
- en: “Wordle” is an online word game where the objective is to guess a five-letter
    word in six or fewer attempts. Each attempt has to be recognized as a word, not
    including proper nouns. After each attempt, you get information about which of
    the letters you guessed appear in the target word, and which ones are in the correct
    position.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: “Wordle”是一个在线字谜游戏，目标是在六次或更少的尝试中猜出一个五个字母的单词。每次尝试必须被识别为一个单词，不包括专有名词。每次尝试后，你会得到有关你猜测的字母哪些出现在目标单词中，哪些在正确位置的信息。
- en: For example, suppose the target word is `MOWER` and you guess `TRIED`. You would
    learn that `E` is in the word and in the correct position, `R` is in the word
    but not in the correct position, and `T`, `I`, and `D` are not in the word.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设目标单词是`MOWER`，你猜测了`TRIED`。你会得知`E`在单词中并且位置正确，`R`在单词中但位置不正确，`T`、`I`和`D`不在单词中。
- en: As a different example, suppose you have guessed the words `SPADE` and `CLERK`,
    and you’ve learned that `E` is in the word, but not in either of those positions,
    and none of the other letters appear in the word. Of the words in the word list,
    how many could be the target word? Write a function called `check_word` that takes
    a five-letter word and checks whether it could be the target word, given these
    guesses.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个不同的例子，假设你已经猜测了单词`SPADE`和`CLERK`，并且你得知`E`在这个单词中，但不在这两个位置上，且其他字母都没有出现在单词中。在单词列表中的单词中，有多少个可能是目标单词？编写一个名为`check_word`的函数，接收一个五个字母的单词并检查它是否可能是目标单词，基于这些猜测。
- en: You can use any of the functions from the previous chapter, like `uses_any`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用上一章中的任何函数，如`uses_any`。
- en: 8.12.4\. Exercise[#](#id2 "Link to this heading")
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.12.4\. 练习[#](#id2 "链接到此标题")
- en: Continuing the previous exercise, suppose you guess the work `TOTEM` and learn
    that the `E` is *still* not in the right place, but the `M` is. How many words
    are left?
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 继续上一个练习，假设你猜测了单词`TOTEM`，并得知`E`*仍然*不在正确的位置，但`M`在正确的位置。剩下多少个单词？
- en: 8.12.5\. Exercise[#](#id3 "Link to this heading")
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.12.5\. 练习[#](#id3 "链接到此标题")
- en: '*The Count of Monte Cristo* is a novel by Alexandre Dumas that is considered
    a classic. Nevertheless, in the introduction of an English translation of the
    book, the writer Umberto Eco confesses that he found the book to be “one of the
    most badly written novels of all time”.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*基督山伯爵*是亚历山大·仲马的小说，被认为是经典。然而，在这本书的英文版序言中，作家翁贝托·埃科承认他发现这本书是“有史以来写得最糟糕的小说之一”。'
- en: In particular, he says it is “shameless in its repetition of the same adjective,”
    and mentions in particular the number of times “its characters either shudder
    or turn pale.”
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，他说它在“重复使用相同的形容词”方面是“厚颜无耻的”，并特别提到“它的角色要么颤抖，要么变得苍白”的次数。
- en: To see whether his objection is valid, let’s count the number number of lines
    that contain the word `pale` in any form, including `pale`, `pales`, `paled`,
    and `paleness`, as well as the related word `pallor`. Use a single regular expression
    that matches any of these words. As an additional challenge, make sure that it
    doesn’t match any other words, like `impale` – you might want to ask a virtual
    assistant for help.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证他的意见是否有效，让我们统计包含单词`pale`的所有行，无论是`pale`、`pales`、`paled`、`paleness`，还是相关的单词`pallor`。使用一个正则表达式匹配这些单词。作为额外的挑战，确保它不会匹配其他单词，比如`impale`——你可能需要向虚拟助手寻求帮助。
- en: '[Think Python: 3rd Edition](https://allendowney.github.io/ThinkPython/index.html)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[Think Python: 第三版](https://allendowney.github.io/ThinkPython/index.html)'
- en: Copyright 2024 [Allen B. Downey](https://allendowney.com)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 版权所有 2024 [Allen B. Downey](https://allendowney.com)
- en: 'Code license: [MIT License](https://mit-license.org/)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 代码许可：[MIT 许可证](https://mit-license.org/)
- en: 'Text license: [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 文本许可：[创作共用 署名-非商业性使用-相同方式共享 4.0 国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/)
