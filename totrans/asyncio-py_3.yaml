- en: Chapter 3\. Asyncio Walk-Through
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 Asyncio演练
- en: Asyncio provides another tool for concurrent programming in Python, that is
    more lightweight than threads or multiprocessing. In a very simple sense it does
    this by having an event loop execute a collection of tasks, with a key difference
    being that each task chooses when to yield control back to the event loop.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Asyncio为Python提供了另一种轻量级的并发编程工具，比线程或多进程更轻量级。简单来说，它通过一个事件循环执行一系列任务来实现这一点，其中的一个关键区别是每个任务可以选择何时将控制权返回给事件循环。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Philip Jones, [“Understanding Asyncio”](http://bit.ly/2EPys9Q)
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Philip Jones，[“理解Asyncio”](http://bit.ly/2EPys9Q)
- en: The `asyncio` API in Python is complex because it aims to solve different problems
    for different groups of people. Unfortunately, very little guidance is available
    to help you figure out which parts of `asyncio` are important for the group *you’re*
    in.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的`asyncio` API之所以复杂，是因为它旨在解决不同群体的不同问题。不幸的是，很少有指导可以帮助你找出`asyncio`的哪些部分对*你*而言是重要的。
- en: 'My goal is to help you figure that out. There are two main target audiences
    for the async features in Python:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我的目标是帮助你理清楚这一点。Python中async功能的两个主要目标受众如下：
- en: End-user developers
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最终用户开发者
- en: These want to make applications using `asyncio`. I am going to assume that you’re
    in this group.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这些人想要使用`asyncio`来开发应用程序。我假设你是这一群体中的一员。
- en: Framework developers
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 框架开发者
- en: These want to make frameworks and libraries that end-user developers can use
    in their applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这些人想要创建最终用户开发者可以在其应用程序中使用的框架和库。
- en: Much of the confusion around `asyncio` in the community today is due to lack
    of understanding of this difference. For instance, the official Python documentation
    for `asyncio` is more appropriate for framework developers than end users. This
    means that end-user developers reading those docs quickly become shell-shocked
    by the apparent complexity. You’re somewhat forced to take it all in before being
    able to do anything with it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当今社区对`asyncio`存在很多困惑，主要是因为缺乏对这种差异的理解。例如，官方Python文档中关于`asyncio`的内容更适合框架开发者而不是最终用户。这意味着阅读这些文档的最终用户开发者很快就会被表面上的复杂性震惊到。在能够实际操作之前，你被迫先完全理解这些内容。
- en: It is my hope that this book can help you distinguish between the features of
    Asyncio that are important for end-user developers and those important for framework
    developers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这本书能够帮助你区分出对最终用户开发者重要的Asyncio特性和对框架开发者重要的特性。
- en: Tip
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you’re interested in the lower-level details around how concurrency frameworks
    like Asyncio are built internally, I highly recommend a wonderful talk by Dave
    Beazley, [“Python Concurrency from the Ground Up: LIVE!”](https://oreil.ly/_68Rm),
    in which he demonstrates putting together a simpler version of an async framework
    like Asyncio.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对像Asyncio这样的并发框架在内部是如何构建的低级细节感兴趣，我强烈推荐Dave Beazley的一场精彩演讲，[“从头开始的Python并发：LIVE！”](https://oreil.ly/_68Rm)，在这场演讲中，他演示了如何组装一个类似Asyncio的简化版本的异步框架。
- en: My goal is to give you only the most basic understanding of the building blocks
    of Asyncio—enough that you should be able to write simple programs with it, and
    certainly enough that you will be able to dive into more complete references.^([1](ch03.html#idm46363038714696))
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我的目标只是让你对Asyncio的基本构建块有最基本的理解，足以让你能够编写简单的程序，当然也足以让你深入参考更完整的资料。^([1](ch03.html#idm46363038714696))
- en: First up, we have a “quickstart” section that introduces the most important
    building blocks for Asyncio applications.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有一个“快速入门”部分，介绍了Asyncio应用程序中最重要的构建块。
- en: Quickstart
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速入门
- en: You only need to know about seven functions to use Asyncio [for everyday use].
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你只需要了解七个函数就可以使用Asyncio进行[日常使用]。
- en: ''
  id: totrans-18
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Yury Selivanov, author of PEP 492, which added the `async` and `await` keywords
    to Python
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Yury Selivanov，PEP 492的作者，该提案为Python添加了`async`和`await`关键字
- en: It’s pretty scary diving into the [official documentation](https://oreil.ly/4Y_Pd)
    for Asyncio. There are many sections with new, enigmatic words and concepts that
    will be unfamiliar to even experienced Python programmers, as Asyncio is a very
    new thing in Python. I’m going to break all that down and explain how to approach
    the `asyncio` module documentation later, but for now you need to know that the
    actual surface area you have to worry about with the `asyncio` library is much
    smaller than it seems.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 深入阅读Asyncio的[官方文档](https://oreil.ly/4Y_Pd)可能会让人望而却步。有许多章节涉及新的、神秘的术语和概念，即使是经验丰富的Python程序员也会感到陌生，因为Asyncio在Python中是一个非常新的东西。稍后我将详细解释如何解读`asyncio`模块文档，但现在您需要知道，您需要关注的实际表面领域要比看上去的`asyncio`库小得多。
- en: 'Yury Selivanov, the author of [PEP 492](https://oreil.ly/I3K7H) and all-round
    major contributor to async Python, explained in his PyCon 2016 talk [“async/await
    in Python 3.5 and Why It Is Awesome,”](https://oreil.ly/ImGca) that many of the
    APIs in the `asyncio` module are really intended for framework designers, not
    end-user developers. In that talk, he emphasized the main features that end users
    should care about. These are a small subset of the whole `asyncio` API and can
    be summarized as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Yury Selivanov，[PEP 492](https://oreil.ly/I3K7H)的作者及异步Python的全面主要贡献者，在他的PyCon
    2016演讲“async/await in Python 3.5 and Why It Is Awesome”中解释了`asyncio`模块中的许多API实际上是为框架设计者而不是终端用户开发者设计的。在那次演讲中，他强调了终端用户应该关注的主要特性。这些特性是`asyncio`API的一个小子集，可以总结如下：
- en: Starting the `asyncio` event loop
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动`asyncio`事件循环
- en: Calling `async`/`await` functions
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`async`/`await`函数
- en: Creating a *task* to be run on the loop
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个*任务*以在循环中运行
- en: Waiting for multiple tasks to complete
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待多个任务完成
- en: Closing the loop after all concurrent tasks have completed
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有并发任务完成后关闭循环
- en: In this section, we’re going to look at those core features and see how to hit
    the ground looping with event-based programming in Python.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看这些核心特性，并了解如何在Python中使用基于事件的编程迅速入门。
- en: The “Hello World” of Asyncio in Python looks like [Example 3-1](#helloworld00).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，Asyncio的“Hello World”看起来像[示例 3-1](#helloworld00)。
- en: Example 3-1\. The “Hello World” of Asyncio
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-1\. Asyncio的“Hello World”
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO1-1)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO1-1)'
- en: '`asyncio` provides a `run()` function to execute an `async def` function and
    all other coroutines called from there, like `sleep()` in the `main()` function.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio`提供了一个`run()`函数来执行`async def`函数以及从那里调用的所有其他协程，比如在`main()`函数中的`sleep()`。'
- en: 'Here’s the output from running [Example 3-1](#helloworld00):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行[示例 3-1](#helloworld00)的输出：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In practice, most of your Asyncio-based code will use the `run()` function shown
    here, but it’s important to understand a little more about what that function
    is doing for you. This understanding is important because it will influence how
    you design larger applications.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，基于Asyncio的大部分代码将使用这里显示的`run()`函数，但理解更多关于该函数为您做了什么是很重要的。这种理解很重要，因为它将影响您如何设计更大的应用程序。
- en: '[Example 3-2](#helloworld) is what I’ll call a “Hello-ish World” example. It
    isn’t exactly the same as what `run()` does, but it’s close enough to introduce
    the ideas that we’ll build on throughout the rest of the book. You’ll need a basic
    knowledge of coroutines (discussed in depth later in this chapter), but try to
    follow along anyway and focus on the high-level concepts for now.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-2](#helloworld)是我将称之为“Hello-ish World”的示例。它与`run()`的功能不完全相同，但足以介绍我们在本书其余部分将构建的思想。您需要基本的协程知识（本章后面会深入讨论），但现在试着跟上并专注于高级概念。'
- en: Example 3-2\. The “Hello-ish World” of Asyncio
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-2\. Asyncio的“Hello-ish World”
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO2-1)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO2-1)'
- en: '`loop` = *`asyncio.get_event_loop()`*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop` = *`asyncio.get_event_loop()`*'
- en: You need a loop instance before you can run any coroutines, and this is how
    you get one. In fact, anywhere you call it, `get_event_loop()` will give you the
    same `loop` instance each time, as long as you’re using only a single thread.^([2](ch03.html#idm46363038459208))
    If you’re inside an `async def` function, you should call `asyncio.get_running_loop()`
    instead, which always gives you what you expect. This is covered in much more
    detail later in the book.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行任何协程之前，你需要一个循环实例，这是你获取它的方式。事实上，无论你在哪里调用它，只要你只使用单个线程，`get_event_loop()`每次都会给你相同的`loop`实例。^([2](ch03.html#idm46363038459208))
    如果你在`async def`函数内部，应该使用`asyncio.get_running_loop()`，它总是给你预期的内容。这些内容在本书的后面部分将详细介绍。
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO2-2)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO2-2)'
- en: '`task` = *`loop.create_task(coro)`*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`task` = *`loop.create_task(coro)`*'
- en: In this case, the specific call is `loop.create_task(main())`. Your coroutine
    function will not be executed until you do this. We say that `create_task()` *schedules*
    your coroutine to be run on the loop.^([3](ch03.html#idm46363038400376)) The returned
    `task` object can be used to monitor the status of the task (for example, whether
    it is still running or has completed), and can also be used to obtain a result
    value from your completed coroutine. You can cancel the task with `task.cancel()`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，具体的调用是`loop.create_task(main())`。你的协程函数在你执行此操作之前不会被执行。我们说`create_task()`
    *调度* 你的协程在循环上运行。^([3](ch03.html#idm46363038400376)) 返回的`task`对象可以用于监视任务的状态（例如，它是仍在运行还是已经完成），并且还可以用于从已完成的协程中获取结果值。你可以用`task.cancel()`取消任务。
- en: '[![3](assets/3.png)](#co_asyncio_walk_through_CO2-3)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asyncio_walk_through_CO2-3)'
- en: '*`loop.run_until_complete(coro)`*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*`loop.run_until_complete(coro)`*'
- en: This call will *block* the current thread, which will usually be the main thread.
    Note that `run_until_complete()` will keep the loop running only until the given
    *`coro`* completes—but all *other* tasks scheduled on the loop will also run while
    the loop is running. Internally, `asyncio.run()` calls `run_until_complete()`
    for you and therefore blocks the main thread in the same way.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用会*阻塞*当前线程，通常是主线程。注意，`run_until_complete()`只会在给定的*`coro`*完成之前保持循环运行，但是在循环运行时，所有*其他*安排在循环上的任务也会运行。在内部，`asyncio.run()`为你调用`run_until_complete()`，因此以相同的方式阻塞主线程。
- en: '[![4](assets/4.png)](#co_asyncio_walk_through_CO2-4)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asyncio_walk_through_CO2-4)'
- en: '`group` = *`asyncio.gather(task1, task2, task3)`*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`group` = *`asyncio.gather(task1, task2, task3)`*'
- en: When the “main” part of the program unblocks, either due to a [process signal](https://oreil.ly/KfOmB)
    being received or the loop being stopped by some code calling `loop.stop()`, the
    code after `run_until_complete()` will run. The standard idiom as shown here is
    to gather the still-pending tasks, cancel them, and then use `loop.run_until_complete()`
    again until those tasks are done. `gather()` is the method for doing the gathering.
    Note that `asyncio.run()` will do all of the cancelling, gathering, and waiting
    for pending tasks to finish up.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序的“主”部分因接收到[进程信号](https://oreil.ly/KfOmB)或某些代码调用`loop.stop()`而解除阻塞时，`run_until_complete()`之后的代码将运行。如本例所示的标准习语是收集仍未完成的任务，取消它们，然后再次使用`loop.run_until_complete()`直到这些任务完成。`gather()`是执行收集的方法。注意，`asyncio.run()`将执行取消、收集和等待挂起任务完成的所有操作。
- en: '[![5](assets/5.png)](#co_asyncio_walk_through_CO2-6)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asyncio_walk_through_CO2-6)'
- en: '*`loop.close()`*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*`loop.close()`*'
- en: '`loop.close()` is usually the final action: it must be called on a stopped
    loop, and it will clear all queues and shut down the executor. A *stopped* loop
    can be restarted, but a *closed* loop is gone for good. Internally, `asyncio.run()`
    will close the loop before returning. This is fine because `run()` creates a new
    event loop every time you call it.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`loop.close()`通常是最后的操作：它必须在停止的循环上调用，并且它将清除所有队列并关闭执行器。*停止*的循环可以重新启动，但是*关闭*的循环则永远消失。在返回之前，`asyncio.run()`会关闭循环。这是可以接受的，因为每次调用`run()`时都会创建一个新的事件循环。'
- en: '[Example 3-1](#helloworld00) shows that if you use `asyncio.run()`, none of
    these steps are necessary: they are all done for you. However, it is important
    to understand these steps because more complex situations will come up in practice,
    and you’ll need the extra knowledge to deal with them. Several of these are covered
    in detail later in the book.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-1](#helloworld00) 表明，如果使用`asyncio.run()`，这些步骤都是不必要的：它们都为你完成了。然而，理解这些步骤很重要，因为在实践中会遇到更复杂的情况，你需要额外的知识来处理它们。这本书的后面部分将详细涵盖其中的几个。'
- en: Caution
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding example is still too simplistic to be useful in a practical setting.
    More information around correct shutdown handling is required. The goal of the
    example is merely to introduce the most important functions and methods in `asyncio`.
    More practical information for shutdown handling is presented in [“Starting Up
    and Shutting Down (Gracefully!)”](#shutdown).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例仍然过于简单，不足以在实际环境中使用。需要更多关于正确关闭处理的信息。示例的目标仅是介绍 `asyncio` 中最重要的函数和方法。有关正确关闭处理的更实用信息在
    [“启动和关闭（优雅地！）”](#shutdown) 中呈现。
- en: '`asyncio` in Python exposes a great deal of the underlying machinery around
    the event loop—and requires you to be aware of aspects like lifecycle management.
    This is different from Node.js, for example, which also contains an event loop
    but keeps it somewhat hidden away. However, once you’ve worked with `asyncio`
    for bit, you’ll begin to notice that the pattern for starting up and shutting
    down the event loop doesn’t stray terribly far from the code presented here. We’ll
    examine some of the nuances of managing the loop life cycle in more detail later
    in the book.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio` 在 Python 中公开了与事件循环相关的大量底层机制，并且需要你意识到像生命周期管理这样的方面。例如，这与 Node.js 不同，Node.js
    也包含一个事件循环，但它将其隐藏得相对较深。然而，一旦你使用了 `asyncio` 一段时间，你会开始注意到启动和关闭事件循环的模式与此处呈现的代码并没有太大的不同。我们将在本书后面更详细地探讨管理循环生命周期的一些细微差别。'
- en: I left something out in the preceding example. The last item of basic functionality
    you’ll need to know about is how to run *blocking* functions. The thing about
    cooperative multitasking is that you need all I/O-bound functions to…well, cooperate,
    and that means allowing a context switch back to the loop using the keyword `await`.
    Most of the Python code available in the wild today does not do this, and instead
    relies on you to run such functions in threads. Until there is more widespread
    support for `async def` functions, you’re going to find that using such blocking
    libraries is unavoidable.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我在上一个示例中遗漏了一些内容。你需要了解的最后一个基本功能是如何运行 *阻塞* 函数。关于协作式多任务的事情是，你需要所有 I/O 绑定函数……嗯，协作，并且这意味着允许使用关键字
    `await` 切换回循环。今天大部分的 Python 代码并没有这样做，而是依赖于你在线程中运行这些函数。在广泛支持 `async def` 函数之前，你会发现使用这些阻塞库是不可避免的。
- en: For this, `asyncio` provides an API that is very similar to the API in the `concurrent.futures`
    package. This package provides a `ThreadPoolExecutor` and a `ProcessPoolExecutor`.
    The default is thread-based, but either thread-based or pool-based executors can
    be used. I omitted executor considerations from the previous example because they
    would have obscured the description of how the fundamental parts fit together.
    Now that those have been covered, we can look at the executor directly.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，`asyncio` 提供了一个 API，该 API 与 `concurrent.futures` 包中的 API 非常相似。该包提供了一个 `ThreadPoolExecutor`
    和一个 `ProcessPoolExecutor`。默认情况下是基于线程的，但可以使用基于线程或基于池的执行器。我在前面的示例中省略了执行器的考虑，因为它们可能会使基本部分的描述变得模糊。现在这些已经涵盖了，我们可以直接看看执行器了。
- en: There are a couple of quirks to be aware of. Let’s have a look at the code sample
    in [Example 3-3](#quickstart-executor).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些需要注意的怪癖。让我们看看 [示例 3-3](#quickstart-executor) 中的代码样本。
- en: Example 3-3\. The basic executor interface
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-3\. 基本执行器接口
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO3-1)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO3-1)'
- en: '`blocking()` calls the traditional `time.sleep()` internally, which *would
    have* blocked the main thread and prevented your event loop from running. This
    means that you must not make this function a coroutine—indeed, you cannot even
    call this function from *anywhere* in the main thread, which is where the `asyncio`
    loop is running. We solve this problem by running this function in an *executor*.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`blocking()` 在内部调用传统的 `time.sleep()`，这本质上会阻塞主线程并阻止你的事件循环运行。这意味着你不能将此函数作为协程—事实上，你甚至不能从主线程中的
    *任何地方* 调用此函数，因为 `asyncio` 循环正是在那里运行的。我们通过在 *执行器* 中运行此函数来解决这个问题。'
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO3-2)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO3-2)'
- en: 'Unrelated to this section, but something to keep in mind for later in the book:
    note that the blocking sleep time (0.5 seconds) is shorter than the nonblocking
    sleep time (1 second) in the `main()` coroutine. This makes the code sample neat
    and tidy. In [“Waiting for the Executor During Shutdown”](#waitforexe) we’ll explore
    what happens if executor functions outlive their async counterparts during the
    shutdown sequence.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 与本节无关，但稍后在本书中需要牢记的一点是，阻塞的睡眠时间（0.5 秒）比非阻塞的睡眠时间（1 秒）短。这使得代码示例看起来整洁而整齐。在 [“等待执行器关闭期间”](#waitforexe)
    中，我们将探讨在关闭序列期间执行器函数超过其异步对应物时会发生什么情况。
- en: '[![3](assets/3.png)](#co_asyncio_walk_through_CO3-3)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asyncio_walk_through_CO3-3)'
- en: '`await loop.run_in_executor(None, func)`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`await loop.run_in_executor(None, func)`'
- en: 'This is the last of our list of essential, must-know features of `asyncio`.
    Sometimes you need to run things in a separate thread or even a separate process:
    this method is used for exactly that. Here we pass our blocking function to be
    run in the default executor.^([4](ch03.html#idm46363038125400)) Note that `run_in_executor()`
    does *not* block the main thread: it only schedules the executor task to run (it
    returns a `Future`, which means you can `await` it if the method is called within
    another coroutine function). The executor task will begin executing only after
    `run_until_complete()` is called, which allows the event loop to start processing
    events.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们 `asyncio` 必须掌握的关键功能列表的最后一项。有时您需要在单独的线程甚至单独的进程中运行事物：这种方法正是用于此目的。在此，我们将我们的阻塞函数传递到默认执行器中运行。^([4](ch03.html#idm46363038125400))
    注意，`run_in_executor()` 不会阻塞主线程：它只是调度执行器任务以运行（它返回一个 `Future`，这意味着如果该方法在另一个协程函数中调用，您可以
    `await` 它）。执行器任务将仅在调用 `run_until_complete()` 后开始执行，这允许事件循环开始处理事件。
- en: '[![4](assets/4.png)](#co_asyncio_walk_through_CO3-4)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asyncio_walk_through_CO3-4)'
- en: 'Further to the note in callout 2: the set of tasks in `pending` does *not*
    include an entry for the call to `blocking()` made in `run_in_executor()`. This
    will be true of any call that returns a `Future` rather than a `Task`. The documentation
    is quite good at specifying return types, so you’ll see the return type there;
    just remember that `all_tasks()` really does return only `Task`s, not `Future`s.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步参考第 2 处提示：`pending` 中的任务集合不包括在 `run_in_executor()` 中调用的 `blocking()`。对于返回
    `Future` 而不是 `Task` 的任何调用，情况都是如此。文档在指定返回类型方面做得非常好，因此你会在那里看到返回类型；只需记住 `all_tasks()`
    确实只返回 `Task`，而不是 `Future`。
- en: 'Here’s the output of running this script:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行此脚本的输出：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that you’ve seen the most essential parts of `asyncio` for end-user developer
    needs, it’s time to expand our scope and arrange the `asyncio` API into a kind
    of hierarchy. This will make it easier to digest and understand how to take what
    you need from the documentation, and no more.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了 `asyncio` 对于最终用户开发者需求的最重要部分，是时候扩展我们的范围并将 `asyncio` API 排列成一种层次结构了。这将使得从文档中获取所需内容并了解如何获取更加容易。
- en: The Tower of Asyncio
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: asyncio 之塔
- en: As you saw in the preceding section, there are only a handful of commands that
    you need to know to be able to use `asyncio` as an end-user developer. Unfortunately,
    the documentation for `asyncio` presents a huge number of APIs, and it does so
    in a very “flat” format that makes it hard to tell which things are intended for
    common use and which are facilities being provided to framework designers.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的部分中看到的，要使用 `asyncio` 作为最终用户开发者，您只需了解少数几个命令即可。不幸的是，`asyncio` 的文档提供了大量的
    API，并且以非常“扁平”的格式呈现，这使得很难分辨哪些是用于常规使用的东西，哪些是提供给框架设计者的设施。
- en: When framework designers look at the same documentation, they look for *hook
    points* to which they can connect up their new frameworks or third-party libraries.
    In this section, we’ll look at `asyncio` through the eyes of a framework designer
    to get a sense of how they might approach building a new async-compatible library.
    Hopefully, this will help to further delineate the features that you need to care
    about in your own work.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当框架设计者查看同样的文档时，他们寻找*钩点*，以便将其新框架或第三方库连接起来。在本节中，我们将通过框架设计者的眼光来看 `asyncio`，以了解他们可能如何构建一个新的异步兼容库。希望这将有助于进一步界定您在自己工作中需要关注的功能。
- en: From this perspective, it is much more useful to think about the `asyncio` module
    as being arranged in a hierarchy (rather than a flat list), in which each level
    is built on top of the specification of the previous level. It isn’t quite as
    neat as that, unfortunately, and I’ve taken liberties with the arrangement in
    [Table 3-1](#features_of_asyncio_arranged_in_a_hierarchy), but hopefully this
    will give you an alternative view of the `asyncio` API.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个角度来看，把`asyncio`模块视为一个层次结构会更有用（而不是一个平面列表），每个级别都建立在前一个级别的规范之上。不幸的是，情况并非如此简洁，我在
    [表格 3-1](#features_of_asyncio_arranged_in_a_hierarchy) 中对排列进行了一些改动，但希望这能给你提供`asyncio`
    API的另一种视角。
- en: Warning
  id: totrans-79
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: '[Table 3-1](#features_of_asyncio_arranged_in_a_hierarchy), and the names and
    numbering of the “tiers” given here, is entirely my own invention, intended to
    add a little structure to help explain the `asyncio` API. The expert reader might
    arrange things in a different order, and that’s OK!'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 3-1](#features_of_asyncio_arranged_in_a_hierarchy)，以及这里给出的“级别”的名称和编号，完全是我自己创造的，旨在增加一些结构以帮助解释`asyncio`
    API。专业读者可能会以不同的顺序排列这些内容，这也没关系！'
- en: Table 3-1\. Features of asyncio arranged in a hierarchy; for end-user developers,
    the most important tiers are highlighted in bold
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-1\. `asyncio` 的特性按层次结构排列；对于最终用户开发者而言，最重要的级别已经用粗体标出。
- en: '| Level | Concept | Implementation |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 级别 | 概念 | 实现 |'
- en: '| --- | --- | --- |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Tier 9** | **Network: streams** | `StreamReader`, `StreamWriter`, `asyncio.open_connection()`,
    `asyncio.start_server()` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| **第 9 级** | **网络：流** | `StreamReader`, `StreamWriter`, `asyncio.open_connection()`,
    `asyncio.start_server()` |'
- en: '| Tier 8 | Network: TCP & UDP | `Protocol` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 第 8 级 | 网络：TCP & UDP | `Protocol` |'
- en: '| Tier 7 | Network: transports | `BaseTransport` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 第 7 级 | 网络：传输 | `BaseTransport` |'
- en: '| **Tier 6** | **Tools** | `asyncio.Queue` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **第 6 级** | **工具** | `asyncio.Queue` |'
- en: '| **Tier 5** | **Subprocesses & threads** | `run_in_executor()`, `asyncio.subprocess`
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **第 5 级** | **子进程和线程** | `run_in_executor()`, `asyncio.subprocess` |'
- en: '| Tier 4 | Tasks | `asyncio.Task`, `asyncio.create_task()` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 第 4 级 | 任务 | `asyncio.Task`, `asyncio.create_task()` |'
- en: '| Tier 3 | Futures | `asyncio.Future` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 第 3 级 | Futures | `asyncio.Future` |'
- en: '| **Tier 2** | **Event loop** | `asyncio.run()`, `BaseEventLoop` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **第 2 级** | **事件循环** | `asyncio.run()`, `BaseEventLoop` |'
- en: '| **Tier 1 (Base)** | **Coroutines** | `async def`, `async with`, `async for`,
    `await` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **第 1 级 (基础)** | **协程** | `async def`, `async with`, `async for`, `await`
    |'
- en: 'At the most fundamental level, Tier 1, we have the coroutines that you’ve already
    seen earlier in this book. This is the lowest level at which one can begin to
    think about designing a third-party framework, and surprisingly, this turns out
    to be somewhat popular with not one, but *two*, async frameworks currently available
    in the wild: [Curio](https://oreil.ly/Zu0lP) and [Trio](https://oreil.ly/z2lZY).
    Both of these rely *only* on native coroutines in Python, and nothing whatsoever
    from the `asyncio` library module.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基础的第 1 级，我们有你在本书早些时候已经看到的协程。这是可以开始考虑设计第三方框架的最低级别，令人惊讶的是，这种方法在当前有两个异步框架中相当受欢迎：[Curio](https://oreil.ly/Zu0lP)
    和 [Trio](https://oreil.ly/z2lZY)。这两者仅依赖于 Python 中的原生协程，完全不依赖于`asyncio`库模块中的任何东西。
- en: 'The next level is the event loop. Coroutines are not useful by themselves:
    they won’t do anything without a loop on which to run them (therefore, necessarily,
    Curio and Trio implement their own event loops). `asyncio` provides both a loop
    *specification*, `AbstractEventLoop`, and an *implementation*, `BaseEventLoop`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个级别是事件循环。协程本身并不实用：如果没有一个循环来运行它们，它们什么也做不了（因此，必然地，Curio 和 Trio 实现了它们自己的事件循环）。`asyncio`
    提供了循环的*规范*，`AbstractEventLoop`，以及*实现*，`BaseEventLoop`。
- en: The clear separation between specification and implementation makes it possible
    for third-party developers to make alternative implementations of the event loop,
    and this has already happened with the [uvloop](https://oreil.ly/2itn_) project,
    which provides a much faster loop implementation than the one in the `asyncio`
    standard library module. Importantly, uvloop simply “plugs into” the hierarchy
    and replaces *only* the loop part of the stack. The ability to make these kinds
    of choices is exactly why the `asyncio` API has been designed like this, with
    clear separation between the moving parts.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 规范与实现之间的明确分离使得第三方开发者能够创建事件循环的替代实现，这在 [uvloop](https://oreil.ly/2itn_) 项目中已经实现，该项目提供比`asyncio`标准库模块中更快的循环实现。重要的是，uvloop只是简单地“插入”到层次结构中，并且仅仅替换堆栈中的循环部分。能够做出这些选择的能力正是为什么`asyncio`
    API被设计成这样，各个部分之间有着明确的分离。
- en: 'Tiers 3 and 4 bring us futures and tasks, which are very closely related; they’re
    separated only because `Task` is a subclass of `Future`, but they could easily
    be considered to be in the same tier. A `Future` instance represents some sort
    of ongoing action that will return a result via *notification* on the event loop,
    while a `Task` represents a coroutine running on the event loop. The short version
    is: a future is “loop-aware,” while a task is both “loop-aware” *and* “coroutine-aware.”
    As an end-user developer, you will be working with tasks much more than futures,
    but for a framework designer, the proportion might be the other way around, depending
    on the details.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 层级 3 和 4 带来了未来和任务，它们非常密切相关；它们之间的分离只是因为`Task`是`Future`的子类，但可以轻易地被视为同一层级。`Future`实例代表着某种正在进行的操作，将通过事件循环上的通知返回结果，而`Task`则代表在事件循环上运行的协程。简而言之：未来是“循环感知”的，而任务既是“循环感知”又是“协程感知”的。作为最终用户开发者，你将更多地使用任务而不是未来，但对于框架设计者而言，比例可能相反，这取决于具体细节。
- en: Tier 5 represents the facilities for launching, and awaiting on work that must
    be run in a separate thread, or even in a separate process.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Tier 5 代表着启动和等待必须在单独线程或甚至单独进程中运行的工作的设施。
- en: Tier 6 represents additional async-aware tools such as `asyncio.Queue`. I could
    have placed this tier after the network tiers, but I think it’s neater to get
    all of the coroutine-aware APIs out of the way first, before we look at the I/O
    layers. The `Queue` provided by `asyncio` has a very similar API to the thread-safe
    `Queue` in the `queue` module, except that the `asyncio` version requires the
    `await` keyword on `get()` and `put()`. You cannot use `queue.Queue` directly
    inside coroutines because its `get()` will block the main thread.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Tier 6 代表额外的异步感知工具，例如`asyncio.Queue`。我本可以将这个层级放在网络层级之后，但我认为在我们查看I/O层之前，先把所有的协程感知API处理掉更整洁。`asyncio`提供的`Queue`与`queue`模块中的线程安全`Queue`有非常相似的API，只是`asyncio`版本在`get()`和`put()`上需要使用`await`关键字。你不能直接在协程内使用`queue.Queue`，因为它的`get()`会阻塞主线程。
- en: Finally, we have the network I/O tiers, 7 through 9\. As an end-user developer,
    the most convenient API to work with is the streams API at Tier 9\. I have positioned
    the streams API at the highest level of abstraction in the tower. The protocols
    API, immediately below that (Tier 8), is a more fine-grained API; you *can* use
    the protocols tier in all instances where you might use the streams tier, but
    using streams will be simpler. The final network I/O tier is the transport tier
    (Tier 7). It is unlikely you will ever have to work with this tier directly, unless
    you’re creating a framework for others to use and you need to customize how the
    transports are set up.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有网络I/O层级 7 到 9。作为最终用户开发者，最方便的API是位于层级 9 的流API。我将流API放置在塔的最高抽象层级。直接在流层级下面的是协议API（层级
    8），这是一个更细粒度的API；你*可以*在所有可以使用流层级的情况下使用协议层级，但使用流会更简单。最终的网络I/O层级是传输层级（层级 7）。除非你正在创建一个供他人使用并需要定制传输设置的框架，否则你不太可能直接使用这个层级。
- en: In [“Quickstart”](#quickstart-section), we looked at the absolute bare minimum
    that one would need to know to get started with the `asyncio` library. Now that
    we’ve had a look at how the entire `asyncio` library API is put together, I’d
    like to revisit that short list of features and reemphasize which parts you are
    likely to need to learn.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“快速入门”](#quickstart-section)中，我们仅仅涉及了使用`asyncio`库所需的绝对最低限度。现在我们已经全面了解了整个`asyncio`库的API是如何组织的，我想重新审视那个功能列表，并强调你可能需要学习哪些部分。
- en: 'These are the tiers that are most important to focus on when learning how to
    use the `asyncio` library module for writing network applications:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当学习如何使用`asyncio`库模块来编写网络应用程序时，这些层级是最重要关注的：
- en: Tier 1
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Tier 1
- en: Understanding how to write `async def` functions and use `await` to call and
    execute other coroutines is essential.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 理解如何编写`async def`函数并使用`await`调用和执行其他协程是至关重要的。
- en: Tier 2
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Tier 2
- en: Understanding how to start up, shut down, and interact with the event loop is
    essential.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 理解如何启动、关闭和与事件循环交互是至关重要的。
- en: Tier 5
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Tier 5
- en: Executors are necessary to use blocking code in your async application, and
    the reality is that most third-party libraries are not yet `asyncio`-compatible.
    A good example of this is the SQLAlchemy database ORM library, for which no feature-comparable
    alternative is available right now for `asyncio`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 执行器在您的异步应用程序中使用阻塞代码是必要的，而现实是大多数第三方库还不兼容`asyncio`。一个很好的例子是SQLAlchemy数据库ORM库，目前还没有功能相当的`asyncio`兼容替代品。
- en: Tier 6
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 等级 6
- en: If you need to feed data to one or more long-running coroutines, the best way
    to do that is with `asyncio.Queue`. This is exactly the same strategy as using
    `queue.Queue` for distributing data between threads. The Asyncio version of `Queue`
    uses the same API as the standard library queue module, but uses coroutines instead
    of the blocking methods like `get()`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要向一个或多个长时间运行的协程提供数据，最好的方法是使用 `asyncio.Queue`。这与使用 `queue.Queue` 在线程之间分发数据的策略完全相同。Asyncio
    版本的 `Queue` 使用与标准库队列模块相同的 API，但使用协程而不是像 `get()` 这样的阻塞方法。
- en: Tier 9
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 等级 9
- en: The streams API gives you the simplest way to handle socket communication over
    a network, and it is here that you should begin prototyping ideas for network
    applications. You may find that more fine-grained control is needed, and then
    you could switch to the protocols API, but in most projects it’s usually best
    to keep things simple until you know exactly what problem you’re trying to solve.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 流API为您提供了处理网络套接字通信的最简单方法，这是您应该开始原型化网络应用程序想法的地方。您可能会发现需要更细粒度的控制，那么您可以切换到协议API，但在大多数项目中，保持简单通常是最好的，直到您完全了解您要解决的问题。
- en: Of course, if you’re using an `asyncio`-compatible third-party library that
    handles all the socket communication for you, like `aiohttp`, you won’t need to
    directly work with the `asyncio` network tiers at all. In this case, you must
    rely heavily on the documentation provided with the library.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果您使用的是像 `aiohttp` 这样直接处理所有套接字通信的`asyncio`兼容的第三方库，您将不需要直接使用`asyncio`网络层。在这种情况下，您必须大量依赖提供的库文档。
- en: The `asyncio` library tries to provide sufficient features for both end-user
    developers and framework designers. Unfortunately, this means that the `asyncio`
    API can appear somewhat sprawling. I hope that this section has provided enough
    of a road map to help you pick out the parts you need.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio` 库试图为终端用户开发人员和框架设计者提供足够的功能。不幸的是，这意味着`asyncio` API可能显得有些冗长。我希望本节已经提供了足够的路线图，帮助您找出您需要的部分。'
- en: In the next sections, we’re going to look at the component parts of the preceding
    list in more detail.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将更详细地查看前面列表中的组成部分。
- en: Tip
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The [pysheeet](http://bit.ly/2toWDL1) site provides an in-depth summary (or
    “cheat sheet”) of large chunks of the `asyncio` API; each concept is presented
    with a short code snippet. The presentation is dense, so I wouldn’t recommend
    it for beginners, but if you have experience with Python and you’re the kind of
    person who “gets it” only when new programming info is presented in code, this
    is sure to be a useful resource.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[pysheeet](http://bit.ly/2toWDL1) 网站提供了`asyncio` API的深入摘要（或“速查表”）；每个概念都附带一个简短的代码片段。内容非常密集，所以我不建议初学者使用，但如果您有Python经验，并且只有在以代码形式呈现新的编程信息时才“get到”，这肯定是一个有用的资源。'
- en: Coroutines
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程
- en: 'Let’s begin at the very beginning: what is a coroutine?'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从非常基础的开始：什么是协程？
- en: My goal in this section is to help you understand the specific meaning behind
    terms like *coroutine object* and *asynchronous function*. The examples that follow
    will show low-level interactions not normally required in most programs; however,
    the examples will help give you a clearer understanding of the fundamental parts
    of Asyncio, and will make later sections much easier to grasp.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这一节的目标是帮助您理解诸如*协程对象*和*异步函数*之类术语背后的具体含义。接下来的示例将展示通常情况下大多数程序不需要的低级交互；然而，这些示例将帮助您更清晰地理解Asyncio的基本部分，并且会使后续章节更容易理解。
- en: The following examples can all be reproduced in a Python 3.8 interpreter in
    interactive mode, and I urge you to work through them on your own by typing them
    yourself, observing the output, and perhaps experimenting with different ways
    of interacting with `async` and `await`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例可以在Python 3.8交互模式中重现，并且我建议您通过自己输入它们、观察输出并可能尝试不同的与`async`和`await`交互方式来自己完成它们。
- en: Caution
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`asyncio` was first added to Python 3.4, but the new syntax for coroutines
    using `async def` and `await` was only added in Python 3.5\. How did people do
    anything with `asyncio` in 3.4? They used *generators* in very special ways to
    act as if they were coroutines. In some older codebases, you’ll see generator
    functions decorated with `@asyncio.coroutine` and containing `yield from` statements.
    Coroutines created with the newer `async def` are now referred to as *native coroutines*
    because they are built into the language as coroutines and nothing else. This
    book ignores the older generator-based coroutines entirely.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio` 首次添加到 Python 3.4 中，但使用 `async def` 和 `await` 的新协程语法仅在 Python 3.5
    中添加。人们在 3.4 中如何使用 `asyncio`？他们以非常特殊的方式使用 *生成器* 来模拟协程。在一些旧代码库中，您会看到带有 `@asyncio.coroutine`
    装饰器并包含 `yield from` 语句的生成器函数。使用新的 `async def` 创建的协程现在被称为 *本地协程*，因为它们作为协程内置到语言中。本书完全忽略了基于生成器的旧协程。'
- en: The New async def Keywords
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的 async def 关键字
- en: Let us begin with the simplest possible thing, shown in [Example 3-4](#firstsurprise).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的事情开始，如 [示例 3-4](#firstsurprise) 所示。
- en: Example 3-4\. Async functions are functions, not coroutines
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-4\. 异步函数是函数，而不是协程
- en: '[PRE5]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO4-1)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO4-1)'
- en: 'This is the simplest possible declaration of a coroutine: it looks like a regular
    function, except that it begins with the keywords `async def`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的协程声明：它看起来像一个普通函数，但是以关键字 `async def` 开始。
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO4-2)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO4-2)'
- en: 'Surprise! The precise type of `f` is *not* “coroutine”; it’s just an ordinary
    function. While it is common to refer to `async def` functions as coroutines,
    strictly speaking they are considered by Python to be *coroutine functions*. This
    behavior is identical to the way generator functions work in Python:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 惊喜！`f` 的确切类型并不是“协程”，它只是一个普通函数。虽然通常将 `async def` 函数称为协程，严格来说它们被 Python 视为 *协程函数*。这种行为与
    Python 中生成器函数的工作方式相同：
- en: '[PRE6]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Even though `g` is sometimes incorrectly referred to as a “generator,” it remains
    a function, and it is only when this function is *evaluated* that the generator
    is returned. Coroutine functions work in exactly the same way: you need to *call*
    the `async def` function to obtain the coroutine object.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 `g` 有时被错误地称为“生成器”，它仍然是一个函数，只有在 *评估* 此函数时才会返回生成器。协程函数的工作方式完全相同：您需要 *调用* `async
    def` 函数才能获取协程对象。
- en: '[![3](assets/3.png)](#co_asyncio_walk_through_CO4-3)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asyncio_walk_through_CO4-3)'
- en: The `inspect` module in the standard library can provide much better introspective
    capabilities than the `type()` built-in function.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的 `inspect` 模块可以提供比 `type()` 内置函数更好的反射能力。
- en: '[![4](assets/4.png)](#co_asyncio_walk_through_CO4-4)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asyncio_walk_through_CO4-4)'
- en: There is an `iscoroutinefunction()` function that lets you distinguish between
    an ordinary function and a coroutine function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个 `iscoroutinefunction()` 函数可以让你区分普通函数和协程函数。
- en: Returning to our `async def f()`, [Example 3-5](#adefretcoro) reveals what happens
    when we call it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的 `async def f()`，[示例 3-5](#adefretcoro) 展示了我们调用它时会发生什么。
- en: Example 3-5\. An async def function returns a coroutine object
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-5\. async def 函数返回一个协程对象
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This brings us back to our original question: what exactly is a coroutine?
    A *coroutine* is an *object* that encapsulates the ability to resume an underlying
    function that has been suspended before completion. If that sounds familiar, it’s
    because coroutines are very similar to generators. Indeed, before the introduction
    of *native* coroutines with the `async def` and `await` keywords in Python 3.5,
    it was already possible to use the `asyncio` library in Python 3.4 by using normal
    generators with special decorators.^([5](ch03.html#idm46363037762200)) It isn’t
    surprising that the new `async def` functions (and the coroutines they return)
    behave in a similar way to generators.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们回到了最初的问题：协程究竟是什么？*协程* 是一个 *对象*，它封装了在完成之前已被挂起的底层函数的能力。如果这听起来耳熟，那是因为协程与生成器非常相似。事实上，在
    Python 3.5 引入 *本地* 协程之前，使用 Python 3.4 的 `asyncio` 库已经可以通过使用带有特殊装饰器的普通生成器来使用。^([5](ch03.html#idm46363037762200))
    新的 `async def` 函数（及其返回的协程）行为类似于生成器是一件并不奇怪的事。
- en: We can play with coroutine objects a bit more to see how Python makes use of
    them. Most importantly, we want to see how Python is able to “switch” execution
    between coroutines. Let’s first look at how the return value can be obtained.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步玩弄协程对象，看看Python如何利用它们。最重要的是，我们想看看Python如何能够在协程之间“切换”执行。首先让我们看看如何获取返回值。
- en: When a coroutine *returns*, what really happens is that a `StopIteration` exception
    is raised. [Example 3-6](#corointernals), which continues in the same session
    as the previous examples, makes that clear.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当协程*返回*时，实际上是引发了一个`StopIteration`异常。[示例 3-6](#corointernals) 在同一会话中延续了前面示例的内容，阐明了这一点。
- en: 'Example 3-6\. Coroutine internals: using send() and StopIteration'
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-6\. 协程内部：使用 send() 和 StopIteration
- en: '[PRE8]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO5-1)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO5-1)'
- en: A coroutine is *initiated* by “sending” it a `None`. Internally, this is what
    the *event loop* is going to be doing to your precious coroutines; you will never
    have to do this manually. All the coroutines you make will be executed either
    with `loop.create_task(*coro*)` or `await *coro*`. It’s the `loop` that does the
    `.send(None)` behind the scenes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 协程通过“发送”`None`来*启动*。在内部，这就是*事件循环*将要对你的宝贵协程做的事情；你永远不需要手动执行这个过程。你创建的所有协程都会通过`loop.create_task(*coro*)`或`await
    *coro*`来执行。是`loop`在幕后执行`.send(None)`。
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO5-2)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO5-2)'
- en: 'When the coroutine *returns*, a special kind of exception is raised, called
    `StopIteration`. Note that we can access the return value of the coroutine via
    the `value` attribute of the exception itself. Again, you don’t need to know that
    it works like this: from your point of view, `async def` functions will simply
    return a value with the `return` statement, just like normal functions.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当协程*返回*时，会引发一种特殊的异常，称为`StopIteration`。注意，我们可以通过异常本身的`value`属性访问协程的返回值。再次强调，你无需知道它是如何工作的：从你的角度来看，`async
    def`函数将简单地使用`return`语句返回一个值，就像普通函数一样。
- en: 'These two points, the `send()` and the `StopIteration`, define the start and
    end of the executing coroutine, respectively. So far this just seems like a really
    convoluted way to run a function, but that’s OK: the *event loop* will be responsible
    for driving coroutines with these low-level internals. From your point of view,
    you will simply schedule coroutines for execution on the loop, and they will get
    executed top-down, almost like normal functions.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这两点，`send()`和`StopIteration`，分别定义了执行协程的开始和结束。到目前为止，这似乎只是运行函数的一种非常复杂的方式，但没关系：*事件循环*将负责使用这些低级别的内部驱动协程。从你的角度来看，你只需将协程安排到循环中执行，它们将按顺序自上而下执行，几乎像普通函数一样。
- en: The next step is to see how the execution of the coroutine can be suspended.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是看看如何暂停协程的执行。
- en: The New await Keyword
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的 await 关键字
- en: 'This new keyword [`await`](https://oreil.ly/uk4H3) always takes a parameter
    and will accept *only* a thing called an *awaitable*, which is defined as one
    of these (exclusively!):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新关键字[`await`](https://oreil.ly/uk4H3)始终接受一个参数，并且仅接受称为*可等待对象*的东西，其定义如下（仅此而已！）：
- en: A coroutine (i.e., the *result* of a called `async def` function).^([6](ch03.html#idm46363033404616))
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个协程（即调用了`async def`函数的*结果*）。^([6](ch03.html#idm46363033404616))
- en: Any object implementing the `__await__()` special method. That special method
    *must* return an iterator.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何实现了`__await__()`特殊方法的对象。这个特殊方法*必须*返回一个迭代器。
- en: The second kind of awaitable is out of scope for this book (you’ll never need
    it in day-to-day `asyncio` programming), but the first use case is pretty straightforward,
    as [Example 3-7](#firstawait) shows.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种可等待对象超出了本书的范围（你在日常`asyncio`编程中永远不会需要它），但第一个用例相当简单，如[示例 3-7](#firstawait)所示。
- en: Example 3-7\. Using await on a coroutine
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-7\. 在协程上使用 await
- en: '[PRE9]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO6-1)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO6-1)'
- en: Calling `f()` produces a coroutine; this means we are allowed to `await` it.
    The value of the `result` variable will be `123` when `f()` completes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`f()`会产生一个协程；这意味着我们可以对其使用`await`。当`f()`完成时，`result`变量的值将为`123`。
- en: 'Before we close out this section and move on to the event loop, it is useful
    to look at how coroutines may be fed exceptions. This is most commonly used for
    cancellation: when you call `task.cancel()`, the event loop will internally use
    `coro.throw()` to raise `asyncio.CancelledError` *inside* your coroutine ([Example 3-8](#injectexcept)).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本节并继续进行事件循环之前，查看一下如何将异常传递给协程会很有用。 这通常用于取消：当您调用 `task.cancel()` 时，事件循环将内部使用
    `coro.throw()` 来在您的协程内部引发 `asyncio.CancelledError`（[示例 3-8](#injectexcept)）。
- en: Example 3-8\. Using coro.throw() to inject exceptions into a coroutine
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-8\. 使用 coro.throw() 将异常注入到协程中
- en: '[PRE10]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO7-1)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO7-1)'
- en: As before, a new coroutine is created from the coroutine function `f()`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，从协程函数 `f()` 创建了一个新的协程。
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO7-2)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO7-2)'
- en: Instead of doing another `send()`, we call `throw()` and provide an exception
    class and a value. This raises an exception *inside* our coroutine, at the `await`
    point.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再执行另一个 `send()`，而是调用 `throw()` 并提供一个异常类和一个值。 这会在我们的协程内部，在 `await` 点引发异常。
- en: The `throw()` method is used (internally in `asyncio`) for *task cancellation*,
    which we can also demonstrate quite easily. We’re even going to go ahead in [Example 3-9](#corocancel)
    and handle the cancellation inside a new coroutine.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`throw()` 方法（在 `asyncio` 内部）用于 *任务取消*，我们也可以非常容易地演示。 我们甚至将继续在 [示例 3-9](#corocancel)
    中处理取消，这次在一个新的协程中。'
- en: Example 3-9\. Coroutine cancellation with CancelledError
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-9\. 使用 CancelledError 进行协程取消
- en: '[PRE11]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO8-1)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO8-1)'
- en: 'Our coroutine function now handles an exception. In fact, it handles the *specific*
    exception type used throughout the `asyncio` library for task cancellation: `asyncio.CancelledError`.
    Note that the exception is being injected into the coroutine from outside; i.e.,
    by the event loop, which we’re still simulating with manual `send()` and `throw()`
    commands. In real code, which you’ll see later, `CancelledError` is raised inside
    the task-wrapped coroutine when tasks are cancelled.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的协程函数处理了一个异常。 事实上，它处理了在整个 `asyncio` 库中用于任务取消的 *特定* 异常类型：`asyncio.CancelledError`。
    请注意，异常是从外部注入到协程中的； 即，由事件循环，我们仍然使用手动的 `send()` 和 `throw()` 命令进行模拟。 在真实代码中，您将在稍后看到，当任务被取消时，`CancelledError`
    会在任务封装的协程内部引发。
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO8-2)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO8-2)'
- en: A simple message to say that the task got cancelled. Note that by handling the
    exception, we ensure it will no longer propagate and our coroutine will `return`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的消息，表明任务被取消了。 请注意，通过处理异常，我们确保它不再传播，并且我们的协程将会 `return`。
- en: '[![3](assets/3.png)](#co_asyncio_walk_through_CO8-3)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asyncio_walk_through_CO8-3)'
- en: Here we `throw()` the `CancelledError` exception.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们抛出 `CancelledError` 异常。
- en: '[![4](assets/4.png)](#co_asyncio_walk_through_CO8-4)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asyncio_walk_through_CO8-4)'
- en: As expected, we see our cancellation message being printed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 不出所料，我们看到取消消息被打印出来了。
- en: '[![5](assets/5.png)](#co_asyncio_walk_through_CO8-5)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asyncio_walk_through_CO8-5)'
- en: Our coroutine exits normally. (Recall that the `StopIteration` exception is
    the normal way that coroutines exit.)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的协程正常退出。（回想一下，`StopIteration` 异常是协程正常退出的方式。）
- en: Just to drive home the point about how task cancellation is nothing more than
    regular exception raising (and handling), let’s look at [Example 3-10](#absorbcancel),
    where we absorb cancellation and move on to a different coroutine.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强调任务取消只是常规异常抛出（和处理）的要点，让我们看看 [示例 3-10](#absorbcancel)，在那里我们吸收取消并转移到另一个协程。
- en: Example 3-10\. For educational purposes only—don’t do this!
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-10\. 仅供教育目的使用——不要这样做！
- en: '[PRE12]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO9-1)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO9-1)'
- en: Instead of printing a message, what happens if after cancellation, we just go
    right back to awaiting another awaitable?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在取消之后，我们只是立即回到等待另一个可等待对象，会发生什么？
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO9-2)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO9-2)'
- en: Unsurprisingly, our outer coroutine continues to live, and it immediately suspends
    again inside the *new* coroutine.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 不足为奇的是，我们的外部协程继续存在，并且立即在 *新* 协程内部再次暂停。
- en: '[![3](assets/3.png)](#co_asyncio_walk_through_CO9-3)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asyncio_walk_through_CO9-3)'
- en: Everything proceeds normally, and our coroutine continues to suspend and resume
    as expected.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都按预期进行，我们的协程继续按预期暂停和恢复。
- en: Of course, it should go without saying that you should never actually do this!
    If your coroutine receives a cancellation signal, that is a clear directive to
    do only whatever cleanup is necessary and exit. Don’t just ignore it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，不言而喻的是，您绝不能真的这样做！如果您的协程收到取消信号，那就是明确的指令只做必要的清理工作并退出。不要简单地忽略它。
- en: By this point, it’s getting pretty tiring *pretending* to be an event loop by
    manually doing all the `.send(None)` calls, so in [Example 3-11](#finallyloop)
    we’ll bring in the loop provided by `asyncio` and clean up the preceding example
    accordingly.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 到了这一步，通过手动执行所有`.send(None)`调用来假装成事件循环已经相当疲劳了，因此在[示例 3-11](#finallyloop)中，我们将引入`asyncio`提供的循环，并相应地清理前面的示例。
- en: Example 3-11\. Using the event loop to execute coroutines
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-11\. 使用事件循环执行协程
- en: '[PRE13]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO10-1)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO10-1)'
- en: Obtain a loop.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 获取一个循环。
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO10-2)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO10-2)'
- en: Run the coroutine to completion. Internally, this is doing all those `.send(None)`
    method calls for us, and it detects completion of our coroutine with the `StopIteration`
    exception, which also contains our return value.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将协程运行到完成。在内部，这为我们做了所有那些`.send(None)`方法调用，并通过`StopIteration`异常检测我们协程的完成，该异常还包含了我们的返回值。
- en: Event Loop
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件循环
- en: The preceding section showed how the `send()` and `throw()` methods can interact
    with a coroutine, but that was just to help you understand how coroutines themselves
    are structured. The event loop in `asyncio` handles all of the switching between
    coroutines, as well as catching those `StopIteration` exceptions—and much more,
    such as listening to sockets and file descriptors for events.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节展示了`send()`和`throw()`方法如何与协程交互，但这仅是为了帮助您理解协程本身的结构。`asyncio`中的事件循环处理所有协程之间的切换，以及捕获`StopIteration`异常——以及更多内容，如监听套接字和文件描述符的事件。
- en: 'You can get by without ever needing to work with the event loop directly: your
    `asyncio` code can be written entirely using `await` calls, initiated by an `asyncio.run(*coro*)`
    call. However, at times some degree of interaction with the event loop itself
    might be necessary, and here we’ll discuss how to obtain it.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以完全不需要直接使用事件循环来编写您的`asyncio`代码，可以完全使用`await`调用，通过`asyncio.run(*coro*)`调用来启动。然而，有时可能需要与事件循环进行某种程度的交互，在这里我们将讨论如何获取它。
- en: 'There are two ways:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法：
- en: '*Recommended*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*推荐*'
- en: '`asyncio.get_running_loop()`, callable from inside the context of a coroutine'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio.get_running_loop()`，可在协程上下文内部调用'
- en: '*Discouraged*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*不建议使用*'
- en: '`asyncio.get_event_loop()`, callable from anywhere'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio.get_event_loop()`，可在任何地方调用'
- en: You’re going to see the discouraged function in much existing code, because
    the newer function, `get_running_loop()`, was introduced much later, in Python
    3.8. Thus, it will be useful in practice to have a basic idea of how the older
    method works, so we’ll look at both. Let’s start with [Example 3-12](#sameloop).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您会在许多现有代码中看到不建议使用的函数，因为较新的函数`get_running_loop()`是在Python 3.8中引入的。因此，了解旧方法的基本工作原理在实践中将非常有用，因此我们将同时查看两者。让我们从[示例 3-12](#sameloop)开始。
- en: Example 3-12\. Always getting the same event loop
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-12\. 始终获取相同的事件循环
- en: '[PRE14]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO11-1)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO11-1)'
- en: Both identifiers, `loop` and `loop2`, refer to the same instance.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符`loop`和`loop2`均指向同一实例。
- en: This means that if you’re inside a coroutine function and you need access to
    the loop instance, it’s fine to call `get_event_loop()` or `get_running_loop()`
    to obtain it. You *do not* need to pass an explicit `loop` parameter through all
    your functions.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果您在协程函数内部需要访问循环实例，调用`get_event_loop()`或`get_running_loop()`来获取它是可以的。您*不需要*通过所有函数显式传递`loop`参数。
- en: 'The situation is different if you’re a framework designer: it would be better
    to design your functions to accept a `loop` parameter, just in case your users
    are doing something unusual with [event loop policies](https://oreil.ly/oMe9w).
    Policies are out of scope for this book, and we’ll say no more about them.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是框架设计者，情况就不同了：最好设计您的函数接受一个`loop`参数，以防您的用户正在与[事件循环策略](https://oreil.ly/oMe9w)进行一些不寻常的操作。本书不涉及策略，我们将不再多说。
- en: So if `get_event_loop()` and `get_running_loop()` work the same, why do they
    both exist? The `get_event_loop()` method works only within the *same thread*.
    In fact, `get_event_loop()` will fail if called inside a new thread unless you
    specifically create a new loop with `new_event_loop()`, *and* set that new instance
    to be *the* loop for that thread by calling `set_event_loop()`. Most of us will
    only ever need (and want!) a single loop instance running in a single thread.
    This is nearly the entire point of async programming in the first place.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果 `get_event_loop()` 和 `get_running_loop()` 的功能相同，为什么它们都存在呢？`get_event_loop()`
    方法仅在*同一线程*内工作。事实上，如果在新线程中调用 `get_event_loop()`，除非您使用 `new_event_loop()` 明确创建一个新的循环，并通过调用
    `set_event_loop()` 将该新实例设置为该线程的*唯一*循环，否则它将失败。大多数情况下，我们只需要（并希望！）在单线程中运行一个单独的循环实例。这几乎是异步编程的整个初衷。
- en: 'In contrast, `get_running_loop()` (the recommended method) will always do what
    you expect: because it can be called only within the context of a coroutine, a
    task, or a function called from one of those, it always provides the *current*
    running event loop, which is almost always what you want.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`get_running_loop()`（推荐的方法）将始终按预期运行：因为它只能在协程、任务或从这些中调用的函数的上下文中调用，它总是提供*当前*正在运行的事件循环，这几乎总是您想要的。
- en: The introduction of `get_running_loop()` has also simplified the spawning of
    background tasks. Consider [Example 3-13](#creatingtasks), a coroutine function
    inside which additional tasks are created and *not* awaited.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 `get_running_loop()` 还简化了后台任务的生成。考虑 [示例 3-13](#creatingtasks)，在其中创建了额外的任务且*未*等待。
- en: Example 3-13\. Creating tasks
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-13\. 创建任务
- en: '[PRE15]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, the intention is to launch completely new tasks inside the
    coroutine. By not awaiting them, we ensure they will run independently of the
    execution context inside coroutine function `f()`. In fact, `f()` will exit before
    the tasks that it launched have completed.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，意图是在协程内部启动全新的任务。通过不等待它们，我们确保它们将独立于协程函数 `f()` 内部的执行上下文而运行。实际上，在由它启动的任务完成之前，`f()`
    将会退出。
- en: Before Python 3.7, it was necessary to first obtain the `loop` instance to schedule
    a task, but with the introduction of `get_running_loop()` came other `asyncio`
    functions that use it, like `asyncio.create_task()`. From Python 3.7 on, the code
    to spawn an async task now looks like [Example 3-14](#newcreatetask).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3.7 之前，必须首先获取 `loop` 实例以安排任务，但引入 `get_running_loop()` 后，出现了其他使用它的 `asyncio`
    函数，比如 `asyncio.create_task()`。从 Python 3.7 开始，生成异步任务的代码现在看起来像是 [示例 3-14](#newcreatetask)。
- en: Example 3-14\. Creating tasks the modern way
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-14\. 以现代方式创建任务
- en: '[PRE16]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It is also possible to use another low-level function called `asyncio.ensure_future()`
    to spawn tasks in the same way as `create_task()`, and you will likely still see
    calls to `ensure_future()` in older `asyncio` code. I considered avoiding the
    distraction of discussing `ensure_future()`, but it is a perfect case study of
    an `asyncio` API that was intended only for framework designers, but made the
    original adoption of `asyncio` much more difficult to understand for application
    developers. The difference between `asyncio.create_task()` and `asyncio.ensure_future()`
    is subtle and confusing for many newcomers. We explore these differences in the
    next section.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用另一个名为 `asyncio.ensure_future()` 的低级函数以与 `create_task()` 相同的方式生成任务，您可能仍然会在旧的
    `asyncio` 代码中看到对 `ensure_future()` 的调用。我考虑避免讨论 `ensure_future()`，但它是一个关于仅供框架设计者使用的
    `asyncio` API 的完美案例，但这使得应用程序开发人员最初理解 `asyncio` 变得更加困难。`asyncio.create_task()`
    与 `asyncio.ensure_future()` 之间的区别对于许多新手来说是微妙且令人困惑的。我们将在下一节探讨这些区别。
- en: Tasks and Futures
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务和未来
- en: Earlier we covered coroutines, and how they need to be run on a loop to be useful.
    Now I want to talk briefly about the `Task` and `Future` APIs. The one you will
    work with the most is `Task`, as most of your work will involve running coroutines
    with the `create_task()` function, exactly as set out in [“Quickstart”](#quickstart-section).
    The `Future` class is actually a superclass of `Task`, and it provides all of
    the functionality for interaction with the loop.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们讨论了协程及其在循环中运行以便有用的方式。现在我想简要讨论 `Task` 和 `Future` API。您将与之最多打交道的是 `Task`，因为大部分工作将涉及使用
    `create_task()` 函数运行协程，就像在[“快速入门”](#quickstart-section)中描述的那样。`Future` 类实际上是 `Task`
    的超类，并为与循环的交互提供所有功能。
- en: 'A simple way to think of it is like this: a `Future` represents a future completion
    state of some activity and is managed by the loop. A `Task` is exactly the same,
    but the specific “activity” is a coroutine— probably one of yours that you created
    with an `async def` function plus `create_task()`.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的思路是这样的：`Future` 表示某个活动的未来完成状态，并由循环管理。`Task` 完全相同，但特定的“活动”是一个协程——可能是您使用
    `async def` 函数和 `create_task()` 创建的协程之一。
- en: The `Future` class represents a *state* of something that is interacting with
    a loop. That description is too fuzzy to be useful, so you can instead think of
    a `Future` instance as a toggle for completion status. When a `Future` instance
    is created, the toggle is set to “not yet completed,” but at some later time it
    will be “completed.” In fact, a `Future` instance has a method called `done()`
    that allows you to check the status, as shown in [Example 3-15](#futdone).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future` 类代表与循环交互的*状态*。这种描述太模糊了，因此您可以将 `Future` 实例视为完成状态的切换器，而不是一个有用的东西。当创建
    `Future` 实例时，切换器设置为“尚未完成”，但稍后将“完成”。实际上，`Future` 实例有一个称为 `done()` 的方法，允许您检查状态，如
    [Example 3-15](#futdone) 中所示。'
- en: Example 3-15\. Checking completion status with done()
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-15\. 使用 `done()` 检查完成状态
- en: '[PRE17]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A `Future` instance may also do the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future` 实例还可以执行以下操作：'
- en: Have a “result” value set (use `.set_result(*value*)` to set it and `.result()`
    to obtain it)
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置“结果”值（使用 `.set_result(*value*)` 设置，使用 `.result()` 获取）
- en: Be cancelled with `.cancel()` (and check for cancellation with `.cancelled()`)
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `.cancel()` 取消（并使用 `.cancelled()` 检查取消）
- en: Have additional callback functions added that will be run when the future completes
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加额外的回调函数，在 future 完成时运行
- en: 'Even though `Task`s are more common, you can’t avoid `Future`s entirely: for
    instance, running a function on an executor will return a `Future` instance, *not*
    a `Task`. Let’s take a quick look at [Example 3-16](#futmanip) to get a feel for
    what it is like to work with a `Future` instance directly.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `Task` 更常见，但无法完全避免 `Future`：例如，在执行器上运行函数将返回一个 `Future` 实例，*而不是* `Task`。让我们快速浏览一下
    [Example 3-16](#futmanip)，感受直接使用 `Future` 实例的情况。
- en: Example 3-16\. Interaction with a Future instance
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-16\. 与 `Future` 实例交互
- en: '[PRE18]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO12-1)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO12-1)'
- en: Create a simple `main` function. We can run this, wait for a bit, and then set
    a result on this `Future`, `f`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个简单的 `main` 函数。我们可以运行它，等待一会儿，然后在这个 `Future` `f` 上设置一个结果。
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO12-2)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO12-2)'
- en: Set the result.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 设置结果。
- en: '[![3](assets/3.png)](#co_asyncio_walk_through_CO12-3)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asyncio_walk_through_CO12-3)'
- en: Manually create a `Future` instance. Note that this instance is (by default)
    tied to our `loop`, but it is not and will not be attached to any coroutine (that’s
    what `Task`s are for).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 手动创建一个 `Future` 实例。请注意，此实例（默认情况下）与我们的 `loop` 绑定，但不会附加到任何协程上（这就是 `Task` 的用途）。
- en: '[![4](assets/4.png)](#co_asyncio_walk_through_CO12-4)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asyncio_walk_through_CO12-4)'
- en: Before doing anything, verify that the future is not done yet.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行任何操作之前，请验证 future 是否尚未完成。
- en: '[![5](assets/5.png)](#co_asyncio_walk_through_CO12-5)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asyncio_walk_through_CO12-5)'
- en: '*Schedule* the `main()` coroutine, passing the future. Remember, all the `main()`
    coroutine does is sleep and then toggle the `Future` instance. (Note that the
    `main()` coroutine will not start running yet: coroutines run only when the loop
    is running.)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*Schedule* `main()` 协程，传递 future。记住，`main()` 协程只是睡眠然后切换 `Future` 实例的状态。（注意，`main()`
    协程还未开始运行：协程只在循环运行时运行。）'
- en: '[![6](assets/6.png)](#co_asyncio_walk_through_CO12-6)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_asyncio_walk_through_CO12-6)'
- en: Here we use `run_until_complete()` on a `Future` instance, rather than a `Task`
    instance.^([7](ch03.html#idm46363032184744)) This is different from what you’ve
    seen before. Now that the loop is running, the `main()` coroutine will begin executing.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们在 `Future` 实例上使用 `run_until_complete()`，而不是 `Task` 实例。^([7](ch03.html#idm46363032184744))
    这与您之前看到的不同。现在循环正在运行，`main()` 协程将开始执行。
- en: '[![7](assets/7.png)](#co_asyncio_walk_through_CO12-7)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_asyncio_walk_through_CO12-7)'
- en: Eventually, the future completes when its result is set. After completion, the
    result can be accessed.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，当 future 的结果设置时，它会完成。完成后，可以访问结果。
- en: Of course, it is unlikely that you will work with `Future` directly in the way
    shown here; the code sample is for education purposes only. Most of your contact
    with `asyncio` will be through `Task` instances.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不太可能直接按照这里所示的方式与`Future`直接交互；代码示例仅供教育目的。你与`asyncio`的大多数接触将通过`Task`实例完成。
- en: You might wonder what happens if you call `set_result()` on a `Task` instance.
    It was possible to do this before Python 3.8, but it is no longer allowed. `Task`
    instances are wrappers for coroutine objects, and their result values can be set
    only internally as the result of the underlying coroutine function, as shown in
    [Example 3-17](#taskmanip).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，如果在`Task`实例上调用`set_result()`会发生什么。在Python 3.8之前可以这样做，但现在不再允许。`Task`实例是协程对象的包装器，它们的结果值只能在底层协程函数的内部设置，如[示例 3-17](#taskmanip)中所示。
- en: Example 3-17\. Calling set_result() on a Task
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例3-17。在Task上调用set_result()
- en: '[PRE19]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO13-3)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO13-3)'
- en: The only difference is that we create a `Task` instance instead of a `Future`.
    Of course, the `Task` API requires us to provide a coroutine; we just use `sleep()`
    because it’s convenient.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别在于我们创建了一个`Task`实例而不是`Future`。当然，`Task` API要求我们提供一个协程；我们只是使用`sleep()`因为它很方便。
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO13-1)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO13-1)'
- en: 'A `Task` instance is being passed in. It satisfies the type signature of the
    function (because `Task` is a subclass of `Future`), but since Python 3.8, we’re
    no longer allowed to call `set_result()` on a `Task`: an attempt will raise `RuntimeError`.
    The idea is that a `Task` represents a running coroutine, so the result should
    always come only from that.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此处引用的一个臭名昭著的解释指出，正在传递一个`Task`实例。它满足函数的类型签名（因为`Task`是`Future`的子类），但自Python 3.8以来，我们不再允许在`Task`上调用`set_result()`：尝试这样做将引发`RuntimeError`。其思想是，`Task`代表正在运行的协程，因此结果应始终仅来自于那里。
- en: '[![3](assets/3.png)](#co_asyncio_walk_through_CO13-2)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asyncio_walk_through_CO13-2)'
- en: We can, however, still `cancel()` a task, which will raise `CancelledError`
    inside the underlying coroutine.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然可以`cancel()`一个任务，这将在底层协程中引发`CancelledError`。
- en: Create a Task? Ensure a Future? Make Up Your Mind!
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个Task？确保一个Future？下定决心吧！
- en: 'In [“Quickstart”](#quickstart-section), I said that the way to run coroutines
    was to use `asyncio.create_task()`. Before that function was introduced, it was
    necessary to obtain a `loop` instance and use `loop.create_task()` to do the same
    thing. This can, in fact, also be achieved with a different module-level function:
    `asyncio.ensure_future()`. Some developers recommended `create_task()`, while
    others recommended `ensure_future()`.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“快速入门”](#quickstart-section)中，我说过运行协程的方法是使用`asyncio.create_task()`。在引入该函数之前，需要获取一个`loop`实例，并使用`loop.create_task()`来完成相同的操作。实际上，还可以使用另一个模块级函数来实现这一点：`asyncio.ensure_future()`。一些开发者推荐使用`create_task()`，而另一些则推荐使用`ensure_future()`。
- en: During my research for this book, I became convinced that the API method `asyncio.ensure_future()`
    is responsible for much of the widespread misunderstanding about the `asyncio`
    library. Much of the API is really quite clear, but there are a few bad stumbling
    blocks to learning, and this is one of them. When you come across `ensure_future()`,
    your brain works very hard to integrate it into your mental model of how `asyncio`
    should be used—and likely fails!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书期间的研究中，我深信API方法`asyncio.ensure_future()`对于广泛误解`asyncio`库负有很大责任。大多数API确实非常清晰，但学习中存在一些障碍，这就是其中之一。当你遇到`ensure_future()`时，你的大脑会非常努力地将其整合到你对`asyncio`如何使用的心理模型中，并可能失败！
- en: 'The problem with `ensure_future()` is highlighted by this now-infamous explanation
    in the [Python 3.6 `asyncio` documentation](https://oreil.ly/fnjCs):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 对`ensure_future()`的问题在[Python 3.6 `asyncio`文档](https://oreil.ly/fnjCs)中有详细说明。
- en: '`asyncio.ensure_future`(*`coro_or_future`*, *, _`loop=None`)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio.ensure_future`(*`coro_or_future`*, *, _`loop=None`)'
- en: 'Schedule the execution of a *coroutine object*: wrap it in a future. Return
    a *Task* object.'
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 调度执行一个*协程对象*：将其包装在一个future中。返回一个*Task*对象。
- en: ''
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the argument is a *Future*, it is returned directly.
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果参数是一个*Future*，它将直接返回。
- en: 'What!? When I first read this, it was very confusing. Here is a (hopefully)
    clearer description of `ensure_future()`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 什么！？当我第一次读到这个时，它非常令人困惑。这里有一个（希望）更清晰的`ensure_future()`描述：
- en: If you pass in a coroutine, it will produce a `Task` instance (and your coroutine
    will be scheduled to run on the event loop). This is identical to calling `asyncio.create_task()`
    (or `loop.create_task()`) and returning the new `Task` instance.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果传入一个协程，它将产生一个`Task`实例（并且您的协程将被安排在事件循环上运行）。这与调用`asyncio.create_task()`（或`loop.create_task()`）并返回新的`Task`实例完全相同。
- en: If you pass in a `Future` instance (or a `Task` instance, because `Task` is
    a subclass of `Future`), you get that very same thing returned, *unchanged*. Yes,
    really!
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果传入一个`Future`实例（或`Task`实例，因为`Task`是`Future`的子类），您将获得相同的东西，*没有改变*。是的，真的！
- en: This function is a great example of the difference between the `asyncio` API
    that is aimed at *end-user developers* (the high-level API) and the `asyncio`
    API aimed at *framework designers* (the low-level API). Let’s have a closer look
    at how it works, in [Example 3-18](#eflook).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是`asyncio` API的一个很好的例子，它展示了面向*终端用户开发者*（高级API）和面向*框架设计者*（低级API）之间的差异。让我们更详细地看看它是如何工作的，在[示例 3-18](#eflook)中。
- en: Example 3-18\. A closer look at what ensure_future() is doing
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-18\. 详细了解ensure_future()的操作
- en: '[PRE20]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO14-1)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO14-1)'
- en: A simple do-nothing coroutine function. We just need something that can make
    a coroutine.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的无操作协程函数。我们只需要一个能生成协程的东西。
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO14-2)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO14-2)'
- en: We make the coroutine object by calling the function directly. Your code will
    rarely do this, but I want to be explicit here (a few lines down) that we’re passing
    a coroutine object into each of `create_task()` and `ensure_future()`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过直接调用函数来创建协程对象。您的代码很少会这样做，但我想在这里明确指出（几行以下）我们将协程对象传递给`create_task()`和`ensure_future()`。
- en: '[![3](assets/3.png)](#co_asyncio_walk_through_CO14-3)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asyncio_walk_through_CO14-3)'
- en: Obtain the loop.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 获取循环。
- en: '[![4](assets/4.png)](#co_asyncio_walk_through_CO14-4)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asyncio_walk_through_CO14-4)'
- en: First off, we use `loop.create_task()` to schedule our coroutine on the loop,
    and we get a new `Task` instance back.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`loop.create_task()`在循环上安排我们的协程，并获得一个新的`Task`实例。
- en: '[![5](assets/5.png)](#co_asyncio_walk_through_CO14-5)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asyncio_walk_through_CO14-5)'
- en: We verify the type. So far, nothing interesting.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们验证类型。到目前为止，没有什么有趣的。
- en: '[![6](assets/6.png)](#co_asyncio_walk_through_CO14-6)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_asyncio_walk_through_CO14-6)'
- en: 'We show that `asyncio.ensure_future()` can be used to perform the same act
    as `create_task()`: we passed in a coroutine and we got back a `Task` instance
    (and the coroutine has been scheduled to run on the loop)! If you’re passing in
    a coroutine, there is no difference between `loop.create_task()` and `asyncio.ensure_future()`.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了`asyncio.ensure_future()`可以用来执行与`create_task()`相同的操作：我们传入了一个协程，然后得到了一个`Task`实例（并且协程已被安排在循环上运行）！如果您传入一个协程，`loop.create_task()`和`asyncio.ensure_future()`之间没有任何区别。
- en: '[![7](assets/7.png)](#co_asyncio_walk_through_CO14-7)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_asyncio_walk_through_CO14-7)'
- en: But what happens if we pass a `Task` instance to `ensure_future()`? Note that
    we’re passing in a `Task` instance that was already created by `loop.create_task()`
    in step 4.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们将一个`Task`实例传递给`ensure_future()`会发生什么？请注意，在步骤4中已经通过`loop.create_task()`创建了一个`Task`实例。
- en: '[![8](assets/8.png)](#co_asyncio_walk_through_CO14-8)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_asyncio_walk_through_CO14-8)'
- en: 'We get back *exactly* the same `Task` instance as we passed in: it passes through
    unchanged.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确切地得到了*与传入相同*的`Task`实例：它没有任何变化地传递了下来。
- en: 'What’s the point of passing `Future` instances straight through? And why do
    two different things with the same function? The answer is that `ensure_future()`
    is intended to be used *by framework authors* to provide APIs *to end-user developers*
    that can handle both kinds of parameters. Don’t believe me? Here it is from the
    ex-BDFL himself:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 直接传递`Future`实例有什么意义？为什么用同一个函数做两件不同的事情？答案是`ensure_future()`旨在被*框架作者*使用，为*终端用户开发者*提供可以处理两种类型参数的API。不相信？这是来自前BDFL本人的解释：
- en: The point of `ensure_future()` is if you have something that could either be
    a coroutine or a `Future` (the latter includes a `Task` because that’s a subclass
    of `Future`), and you want to be able to call a method on it that is only defined
    on `Future` (probably about the only useful example being `cancel()`). When it
    is already a `Future` (or `Task`), this does nothing; when it is a coroutine,
    it wraps it in a `Task`.
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ensure_future()`的用途在于，如果你有一个可能是协程或`Future`（后者包括`Task`，因为它是`Future`的子类）的东西，并且你想要能够调用一个仅在`Future`上定义的方法（可能唯一有用的例子是`cancel()`）。当它已经是`Future`（或`Task`）时，这不会做任何操作；当它是一个协程时，它会将其包装在一个`Task`中。'
- en: ''
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you know that you have a coroutine and you want it to be scheduled, the correct
    API to use is `create_task()`. The only time when you should be calling `ensure_future()`
    is when you are providing an API (like most of asyncio’s own APIs) that accepts
    either a coroutine or a `Future` and you need to do something to it that requires
    you to have a `Future`.
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你知道你有一个协程并且想要调度它，正确的 API 是`create_task()`。唯一需要调用`ensure_future()`的时候是在你提供一个
    API（像大多数 asyncio 的 API 一样）接受协程或`Future`，并且你需要对它做一些需要你有一个`Future`的操作的时候。
- en: ''
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Guido van Rossum, [commenting](https://oreil.ly/cSOFB) on [issue #477](https://oreil.ly/ydRpR)'
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Guido van Rossum，在[issue #477](https://oreil.ly/ydRpR)上[评论](https://oreil.ly/cSOFB)'
- en: In sum, `asyncio.ensure_future()` is a helper function intended for framework
    designers. This is easiest to explain by analogy to a much more common kind of
    function, so let’s do that. If you have a few years’ programming experience behind
    you, you may have seen functions similar to the `listify()` function in [Example 3-19](#listify).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，`asyncio.ensure_future()`是一个专为框架设计者设计的辅助函数。这最容易通过类似函数的类比来解释，所以让我们这样做。如果你有几年的编程经验，你可能见过类似于`listify()`函数的函数，在[Example
    3-19](#listify)中有所提及。
- en: Example 3-19\. A utility function for coercing input into a list
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-19\. 一个将输入强制转换为列表的实用函数
- en: '[PRE21]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This function tries to convert the argument into a list, no matter what comes
    in. These kinds of functions are often used in APIs and frameworks to coerce inputs
    into a known type, which simplifies subsequent code—in this case, you know that
    the parameter (output from `listify()`) will always be a list.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数尝试将参数无论如何转换为一个列表。这些类型的函数经常在 API 和框架中用于将输入强制转换为已知类型，这简化了后续的代码—在这种情况下，你知道参数（从`listify()`输出）将始终是一个列表。
- en: 'If I rename the `listify()` function to `ensure_list()`, then you should begin
    to see the parallel with `asyncio.ensure_future()`: it tries to always coerce
    the argument into a `Future` (or subclass) type. This is a utility function to
    make life easier for *framework developers*, not end-user developers like you
    and I.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我将`listify()`函数重命名为`ensure_list()`，那么你应该开始看到与`asyncio.ensure_future()`的类比：它总是试图强制将参数转换为`Future`（或其子类）类型。这是一个实用函数，旨在使*框架开发者*的生活更轻松，而不是像你和我这样的最终用户开发者。
- en: 'Indeed, the `asyncio` standard library module itself uses `ensure_future()`
    for exactly this reason. When next you look over the API, everywhere you see a
    function parameter described as “awaitable objects,” it is likely that internally
    `ensure_future()` is being used to coerce the parameter. For example, the `asyncio.gather()`
    function has the following signature:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`asyncio`标准库模块本身正是出于这个原因使用`ensure_future()`。当你下次查看 API 时，无论你在哪里看到一个被描述为“可等待对象”的函数参数，很可能内部正在使用`ensure_future()`来强制转换参数。例如，`asyncio.gather()`函数有以下签名：
- en: '[PRE22]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The *`aws`* parameter means “awaitable objects,” which includes coroutines,
    tasks, and futures. Internally, `gather()` is using `ensure_future()` for type
    coercion: tasks and futures are left untouched, while tasks are created for coroutines.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '*`aws`*参数意味着“可等待对象”，其中包括协程、任务和 future。在内部，`gather()`使用`ensure_future()`进行类型强制转换：任务和
    future 保持不变，而为协程创建任务。'
- en: The key point here is that as an end-user application developer, you should
    never need to use `asyncio.ensure_future()`. It’s more a tool for framework designers.
    If you need to schedule a coroutine on the event loop, just do that directly with
    `asyncio.create_task()`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键点是，作为最终用户应用开发者，你永远不应该需要使用`asyncio.ensure_future()`。这更多是框架设计者的工具。如果你需要在事件循环中安排一个协程，直接使用`asyncio.create_task()`即可。
- en: In the next few sections, we’ll go back to language-level features, starting
    with asynchronous context managers.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将回到语言级别的特性，从异步上下文管理器开始。
- en: 'Async Context Managers: async with'
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步上下文管理器：async with
- en: Support for coroutines in context managers turns out to be exceptionally convenient.
    This makes sense, because many situations require network resources—say, connections—to
    be opened and closed within a well-defined scope.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在上下文管理器中支持协程的能力非常方便。这是有道理的，因为许多情况需要在定义良好的范围内打开和关闭网络资源，比如连接。
- en: 'The key to understanding `async with` is to realize that the operation of a
    context manager is driven by *method calls*, and then consider: what if those
    methods were coroutine functions? Indeed, this is exactly how it works, as shown
    in [Example 3-20](#asyncctx).'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 理解`async with`的关键在于意识到上下文管理器的操作是通过*方法调用*驱动的，然后考虑：如果这些方法是协程函数会怎样？事实上，这正是它的工作原理，就像在[示例 3-20](#asyncctx)中展示的那样。
- en: Example 3-20\. Async context manager
  id: totrans-308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-20\. 异步上下文管理器
- en: '[PRE23]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO15-1)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO15-1)'
- en: Instead of the `__enter__()` special method for synchronous context managers,
    the new `__aenter__()` special method is used. This special method must be an
    `async def` method.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 对于同步上下文管理器，不再使用`__enter__()`特殊方法，而是使用新的`__aenter__()`特殊方法。这个特殊方法必须是`async def`方法。
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO15-2)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO15-2)'
- en: Likewise, instead of `__exit__()`, use `__aexit__()`. The parameters are identical
    to those for `__exit__()` and are populated if an exception was raised in the
    body of the context manager.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，使用`__aexit__()`代替`__exit__()`。参数与`__exit__()`相同，并在上下文管理器主体中引发异常时被填充。
- en: Caution
  id: totrans-314
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Just because you’re using `asyncio` in your program, that doesn’t mean that
    all your context managers must be async ones like these. They’re useful only if
    you need to `await` something inside the *enter* and *exit* methods. If there
    is no blocking I/O code, just use regular context managers.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅因为你在程序中使用了`asyncio`并不意味着你所有的上下文管理器都必须像这些那样是异步的。只有在*enter*和*exit*方法中需要`await`某些内容时才有用。如果没有阻塞I/O代码，只需使用常规的上下文管理器即可。
- en: Now—between you and me—I don’t much like using this explicit style of context
    manager when the wonderful `@contextmanager` decorator exists in the `contextlib`
    module of the standard library. As you might guess, an asynchronous version, `@asynccontextmanager`,
    also exists and makes it much easier to create simple async context managers.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在——就你我之间而言——我不太喜欢使用这种显式的上下文管理器风格，因为标准库的`contextlib`模块中存在着令人惊叹的`@contextmanager`装饰器。正如你所料，还有一个异步版本`@asynccontextmanager`，使得创建简单的异步上下文管理器变得更加容易。
- en: The contextlib Way
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: contextlib的方式
- en: This approach is analogous to the `@contextmanager` decorator in the `contextlib`
    standard library. To recap, [Example 3-21](#blockway) takes a look at the blocking
    way first.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法类似于标准库中的`@contextmanager`装饰器。简而言之，[示例 3-21](#blockway) 首先看了阻塞方式。
- en: Example 3-21\. The blocking way
  id: totrans-319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-21\. 阻塞方式
- en: '[PRE24]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO16-1)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO16-1)'
- en: The `@contextmanager` decorator transforms a generator function into a context
    manager.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`@contextmanager`装饰器将生成器函数转换为上下文管理器。'
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO16-2)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO16-2)'
- en: This function call (which I made up for this example) looks suspiciously like
    the sort of thing that will want to use a network interface, which is many orders
    of magnitude slower than “normal” CPU-bound code. This context manager *must*
    be used in a dedicated thread; otherwise, the whole program will be paused while
    waiting for data.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数调用（我为这个示例编造的）看起来非常像需要使用网络接口的东西，这比“正常”的CPU密集型代码慢了几个数量级。这个上下文管理器*必须*在专用线程中使用；否则，整个程序将在等待数据时暂停。
- en: '[![3](assets/3.png)](#co_asyncio_walk_through_CO16-3)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asyncio_walk_through_CO16-3)'
- en: Imagine that we update some statistics every time we process data from a URL,
    such as the number of times the URL has been downloaded. From a concurrency perspective,
    we would need to know whether this function involves I/O internally, such as writing
    to a database over a network. If so, `update_stats()` is also a blocking call.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，每次从URL处理数据时我们更新一些统计信息，比如URL被下载的次数。从并发的角度来看，我们需要知道这个函数是否涉及内部I/O，比如通过网络写入数据库。如果是这样，`update_stats()`也是一个阻塞调用。
- en: '[![4](assets/4.png)](#co_asyncio_walk_through_CO16-4)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asyncio_walk_through_CO16-4)'
- en: Our context manager is being used. Note specifically how the network call (to
    `download_webpage()`) is hidden inside the construction of the context manager.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用我们的上下文管理器。特别注意网络调用（`download_webpage()`）如何隐藏在上下文管理器的构建中。
- en: '[![5](assets/5.png)](#co_asyncio_walk_through_CO16-5)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asyncio_walk_through_CO16-5)'
- en: 'This function call, `process()`, might also be blocking. We’d have to look
    at what the function does, because the distinction between what is blocking or
    nonblocking is not clear-cut. It might be:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数调用，`process()`，也可能是阻塞的。我们需要查看函数的操作，因为阻塞或非阻塞的区别不太明显。它可能是：
- en: Innocuous and nonblocking (fast and CPU-bound)
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无害且非阻塞（快速且CPU绑定）
- en: Mildly blocking (fast and I/O-bound, perhaps something like fast disk access
    instead of network I/O)
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻微阻塞（快速且I/O绑定，可能是像快速磁盘访问这样的东西而不是网络I/O）
- en: Blocking (slow and I/O-bound)
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻塞的（慢且I/O绑定）
- en: Diabolical (slow and CPU-bound)
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邪恶的（慢且CPU绑定）
- en: For the sake of simplicity in this example, let’s presume that the call to `process()`
    is a fast, CPU-bound operation and therefore nonblocking.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，在这个例子中，假设调用`process()`是一个快速的、CPU绑定的操作，因此是非阻塞的。
- en: '[Example 3-22](#nonblockway) is exactly the same example, but using the new
    async-aware helper that was introduced in Python 3.7.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 3-22](#nonblockway) 正是相同的例子，但使用了在Python 3.7中引入的新的async-aware helper。'
- en: Example 3-22\. The nonblocking way
  id: totrans-337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-22\. 非阻塞方式
- en: '[PRE25]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO17-1)'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO17-1)'
- en: The new `@asynccontextmanager` decorator is used in exactly the same way.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`@asynccontextmanager`装饰器的使用方式完全相同。
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO17-2)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO17-2)'
- en: It does, however, require that the decorated generator function be declared
    with `async def`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，它确实要求修饰的生成器函数使用`async def`声明。
- en: '[![3](assets/3.png)](#co_asyncio_walk_through_CO17-3)'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asyncio_walk_through_CO17-3)'
- en: As before, we fetch the data from the URL before making it available to the
    body of the context manager. I have added the `await` keyword, which tells us
    that this coroutine will allow the event loop to run other tasks while we wait
    for the network call to complete.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，在将数据提供给上下文管理器的主体之前，我们从URL中获取数据。我添加了`await`关键字，它告诉我们，这个协程将允许事件循环在我们等待网络调用完成时运行其他任务。
- en: Note that we *cannot* simply tack on the `await` keyword to anything. This change
    presupposes that we were also able to *modify* the `download_webpage()` function
    itself, and convert it into a coroutine that is compatible with the `await` keyword.
    For the times when it is not possible to modify the function, a different approach
    is needed; we’ll discuss that in the next example.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们*不能*简单地将`await`关键字附加到任何内容上。这一变化预设了我们还能够*修改*`download_webpage()`函数本身，并将其转换为与`await`关键字兼容的协程。对于无法修改函数的情况，需要采取不同的方法；我们将在下一个示例中讨论这一点。
- en: '[![4](assets/4.png)](#co_asyncio_walk_through_CO17-4)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asyncio_walk_through_CO17-4)'
- en: As before, the data is made available to the body of the context manager. I’m
    trying to keep the code simple, so I’ve omitted the usual `try/finally` handler
    that you should normally write to deal with exceptions raised in the body of caller.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，数据被提供给上下文管理器的主体。我试图保持代码简洁，因此省略了您通常应该编写的处理调用者主体中引发的异常的常规`try/finally`处理程序。
- en: 'Note that the presence of `yield` is what changes a function into a *generator
    function*; the additional presence of the `async def` keywords in point 1 makes
    this an *asynchronous generator function*. When called, it will return an *asynchronous
    generator*. The `inspect` module has two functions that can test for these: `isasyncgenfunction()`
    and `isasyncgen()`, respectively.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`yield`的存在改变了函数成为*生成器函数*；在第1点中的额外存在`async def`关键字使其成为*异步生成器函数*。当调用时，它将返回一个*异步生成器*。`inspect`模块有两个函数可以测试这些：`isasyncgenfunction()`和`isasyncgen()`。
- en: '[![5](assets/5.png)](#co_asyncio_walk_through_CO17-5)'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asyncio_walk_through_CO17-5)'
- en: Here, assume that we’ve also converted the code inside the `update_stats()`
    function to allow it to produce coroutines. We can then use the `await` keyword,
    which allows a context switch to the event loop while we wait for the I/O-bound
    work to complete.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，假设我们已经将`update_stats()`函数内的代码转换为允许其生成协程。然后我们可以使用`await`关键字，在等待I/O绑定工作完成时进行上下文切换到事件循环。
- en: '[![6](assets/6.png)](#co_asyncio_walk_through_CO17-6)'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_asyncio_walk_through_CO17-6)'
- en: 'Another change was required in the usage of the context manager itself: we
    needed to use `async with` instead of a plain `with`.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用上下文管理器本身时，还需要进行另一个更改：我们需要使用`async with`而不是普通的`with`。
- en: Hopefully, this example shows that the new `@asynccontextmanager` is perfectly
    analogous to the `@contextmanager` decorator.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这个例子显示了新的`@asynccontextmanager`与`@contextmanager`装饰器非常类似。
- en: In callouts 3 and 5, I said it was necessary to modify some functions to return
    coroutines; these were `download_webpage()` and `update_stats()`. This is usually
    not that easy to do, since async support needs to be added down at the socket
    level. The focus of the preceding examples was simply to show off the new `@asynccontextmanager`
    decorator, not to show how to convert blocking functions into nonblocking ones.
    The more common situation is when you want to use a blocking function in your
    program, but it’s not possible to modify the code in that function.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 3 和 5 中，我说需要修改一些函数以返回协程；这些函数是`download_webpage()`和`update_stats()`。通常情况下，这并不容易做到，因为需要在套接字级别添加异步支持。前面的示例的重点仅是展示新的`@asynccontextmanager`装饰器，而不是展示如何将阻塞函数转换为非阻塞函数。更常见的情况是，当您希望在程序中使用阻塞函数时，但无法修改该函数中的代码。
- en: This situation will usually happen with third-party libraries, and a great example
    is the `requests` library, which uses blocking calls throughout.^([8](ch03.html#idm46363031039256))
    If you can’t change the code being called, there is another way. This is a convenient
    place to show you how an *executor* can be used to do exactly that, as illustrated
    in [Example 3-23](#ctxdec).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况通常会发生在第三方库中，一个很好的例子是`requests`库，它在整个过程中使用阻塞调用。^([8](ch03.html#idm46363031039256))
    如果无法更改被调用的代码，还有另一种方法。这是一个便利的地方，可以展示如何使用*执行器*来做到这一点，如[示例 3-23](#ctxdec)所示。
- en: Example 3-23\. The nonblocking-with-a-little-help-from-my-friends way
  id: totrans-356
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-23\. 非阻塞的“有点帮助于我的朋友”方法
- en: '[PRE26]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO18-1)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO18-1)'
- en: For this example, assume that we are *unable* to modify the code for our two
    blocking calls, `download_webpage()` and `update_stats()`; i.e., we can’t alter
    them to be coroutine functions. That’s bad, because the most grave sin of event-based
    programming is breaking the rule that you must never, under any circumstances,
    prevent the event loop from processing events.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本例，假设我们*无法*修改我们两个阻塞调用`download_webpage()`和`update_stats()`的代码；即我们不能将它们修改为协程函数。这很糟糕，因为基于事件的编程最严重的罪行之一是违反了绝对不能阻止事件循环处理事件的规则。
- en: To get around the problem, we will use an *executor* to run the blocking calls
    in a separate thread. The executor is made available to us as an attribute of
    the event loop itself.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决问题，我们将使用一个*执行器*在单独的线程中运行阻塞调用。执行器作为事件循环本身的属性向我们提供。
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO18-2)'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO18-2)'
- en: We call the executor. The signature is `AbstractEventLoop.run_in_executor`(*`executor`*,
    *`func`*, *`*args`*). If you want to use the default executor (which is a `ThreadPoolExecutor`),
    you must pass `None` as the value for the *`executor`* argument.^([9](ch03.html#idm46363030900744))
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用执行器。签名是`AbstractEventLoop.run_in_executor`（*`executor`*，*`func`*，*`*args`*）。如果要使用默认执行器（即`ThreadPoolExecutor`），必须将*`executor`*参数的值传递为`None`。^([9](ch03.html#idm46363030900744))
- en: '[![3](assets/3.png)](#co_asyncio_walk_through_CO18-3)'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asyncio_walk_through_CO18-3)'
- en: As with the call to `download_webpage()`, we also run the other blocking call
    to `update_stats()` in an executor. Note that you *must* use the `await` keyword
    in front. If you forget, the execution of the asynchronous generator (i.e., your
    async context manager) will not wait for the call to complete before proceeding.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 与调用`download_webpage()`一样，我们还在执行器中运行另一个阻塞调用`update_stats()`。请注意，你*必须*在前面使用`await`关键字。如果忘记了，异步生成器（即您的异步上下文管理器）在继续执行之前不会等待调用完成。
- en: It’s likely that async context managers are going to be heavily used in many
    `asyncio`-based codebases, so it’s pretty important to have a good understanding
    of them. You can read more about the new `@asynccontextmanager` decorator in the
    [Python 3.7 documentation](http://bit.ly/2FoWl9f).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会在许多基于`asyncio`的代码库中广泛使用异步上下文管理器，因此对它们有一个很好的理解是非常重要的。您可以在[Python 3.7文档](http://bit.ly/2FoWl9f)中阅读有关新的`@asynccontextmanager`装饰器的更多信息。
- en: 'Async Iterators: async for'
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步迭代器：async for
- en: Next up is the async version of the `for` loop. It is easiest to understand
    how this works if you first recognize that ordinary iteration—just like so many
    other language features—is implemented through the use of *special methods*, recognizable
    by the double underscores in their names.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `for` 循环的异步版本。如果您首先意识到普通迭代——就像许多其他语言特性一样——是通过使用*特殊方法*来实现的，这将最容易理解它是如何工作的。
- en: For reference, [Example 3-24](#normaliter) shows how a standard (nonasync) iterator
    is defined through the use of the `__iter__()` and `__next__()` methods.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考，[示例 3-24](#normaliter) 展示了通过使用 `__iter__()` 和 `__next__()` 方法定义标准（非异步）迭代器的方式。
- en: Example 3-24\. A traditional, nonasync iterator
  id: totrans-369
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-24\. 传统的非异步迭代器
- en: '[PRE27]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO19-1)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO19-1)'
- en: An *iterator* must implement the `__iter__()` special method.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '*迭代器*必须实现 `__iter__()` 特殊方法。'
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO19-2)'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO19-2)'
- en: Initialize some state to the “starting” state.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 将一些状态初始化为“起始”状态。
- en: '[![3](assets/3.png)](#co_asyncio_walk_through_CO19-3)'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asyncio_walk_through_CO19-3)'
- en: The `__iter__()` special method must return an *iterable*; i.e., an object that
    implements the `__next__()` special method. In this case, it’s the same instance,
    because `A` itself also implements the `__next__()` special method.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`__iter__()` 特殊方法必须返回一个*可迭代*对象；即，一个实现了 `__next__()` 特殊方法的对象。在这种情况下，它是同一个实例，因为
    `A` 本身也实现了 `__next__()` 特殊方法。'
- en: '[![4](assets/4.png)](#co_asyncio_walk_through_CO19-4)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asyncio_walk_through_CO19-4)'
- en: The `__next__()` method is defined. This will be called for every step in the
    iteration sequence until…
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了 `__next__()` 方法。这将在迭代序列的每一步中调用，直到……
- en: '[![5](assets/5.png)](#co_asyncio_walk_through_CO19-5)'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asyncio_walk_through_CO19-5)'
- en: …`StopIteration` is raised.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: …抛出 `StopIteration`。
- en: '[![6](assets/6.png)](#co_asyncio_walk_through_CO19-6)'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_asyncio_walk_through_CO19-6)'
- en: The *returned values* for each iteration are generated.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 每次迭代的*返回值*都是生成的。
- en: 'Now you ask: what happens if you declare the `__next__()` special method as
    an `async def` coroutine function? That will allow it to `await` some kind of
    I/O-bound operation—and this is pretty much exactly how `async for` works, except
    for some small details around naming. The specification (in PEP 492) shows that
    to use `async for` on an async iterator, several things are required in the async
    iterator itself:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能会问：如果将 `__next__()` 特殊方法声明为 `async def` 协程函数会发生什么？那将允许它`await`某种 I/O 绑定操作——这几乎正是
    `async for` 的工作方式，除了一些围绕命名的小细节。规范（在 PEP 492 中）显示，要在异步迭代器上使用 `async for`，异步迭代器本身需要满足几个条件：
- en: 'You must implement `def __aiter__()`. (Note: *not* with `async def`!)'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你必须实现 `def __aiter__()`。（注意：*不是* 使用 `async def`！）
- en: '`__aiter__()` must return an object that implements `async def __anext__()`.'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`__aiter__()` 必须返回一个实现了 `async def __anext__()` 的对象。'
- en: '`__anext__()` must return a value for each iteration and raise `Stop​AsyncIteration`
    when finished.'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`__anext__()` 必须为每次迭代返回一个值，并在完成时引发 `Stop​AsyncIteration`。'
- en: Let’s take a quick look at how that might work. Imagine that we have a bunch
    of keys in a [Redis](https://redis.io/) database, and we want to iterate over
    their data, but we fetch the data only on demand. An asynchronous iterator for
    that might look like [Example 3-25](#iter_redis).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下它可能如何工作。想象我们在一个 [Redis](https://redis.io/) 数据库中有一堆键，我们想迭代它们的数据，但我们仅在需要时获取数据。这样的异步迭代器可能看起来像
    [示例 3-25](#iter_redis)。
- en: Example 3-25\. Async iterator for fetching data from Redis
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-25\. 从 Redis 获取数据的异步迭代器
- en: '[PRE28]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO20-1)'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO20-1)'
- en: 'The `main()` function: we run it using `asyncio.run()` toward the bottom of
    the code sample.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数：我们在代码示例底部使用 `asyncio.run()` 运行它。'
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO20-2)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO20-2)'
- en: We use the high-level interface in `aioredis` to get a connection.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `aioredis` 中的高级接口来获取连接。
- en: '[![3](assets/3.png)](#co_asyncio_walk_through_CO20-3)'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asyncio_walk_through_CO20-3)'
- en: Imagine that each of the values associated with these keys is quite large and
    stored in the Redis instance.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，与这些键关联的每个值都相当大，并存储在 Redis 实例中。
- en: '[![4](assets/4.png)](#co_asyncio_walk_through_CO20-4)'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asyncio_walk_through_CO20-4)'
- en: 'We’re using `async for`: the point is that *iteration* *is able to suspend
    itself* while waiting for the next datum to arrive.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用 `async for`：关键是*迭代* *能够暂停自身*，同时等待下一个数据到达。
- en: '[![5](assets/5.png)](#co_asyncio_walk_through_CO20-5)'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asyncio_walk_through_CO20-5)'
- en: For completeness, imagine that we also perform some I/O-bound activity on the
    fetched value—perhaps a simple data transformation—and then it gets sent on to
    another destination.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，假设我们还对提取的值执行了一些I/O绑定活动——也许是一个简单的数据转换——然后将其发送到另一个目标。
- en: '[![6](assets/6.png)](#co_asyncio_walk_through_CO20-6)'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_asyncio_walk_through_CO20-6)'
- en: 'The initializer of this class is quite ordinary: we store the Redis connection
    instance and the list of keys to iterate over.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 此类的初始化器非常普通：我们存储Redis连接实例和要迭代的键列表。
- en: '[![7](assets/7.png)](#co_asyncio_walk_through_CO20-7)'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_asyncio_walk_through_CO20-7)'
- en: Just as in the previous code example with `__iter__()`, we use `__aiter__()`
    to set things up for iteration. We create a normal iterator over the keys, `self.ikeys`,
    and `return self` because `OneAtATime` also implements the `__anext__()` coroutine
    method.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 就像前面的代码示例中使用`__iter__()`一样，我们使用`__aiter__()`来为迭代设置事物。我们在键`self.ikeys`上创建一个普通迭代器，并`return
    self`，因为`OneAtATime`还实现了`__anext__()`协程方法。
- en: '[![8](assets/8.png)](#co_asyncio_walk_through_CO20-8)'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_asyncio_walk_through_CO20-8)'
- en: Note that the `__anext__()` method is declared with `async def`, while the `__aiter__()`
    method is declared only with `def`.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`__anext__()`方法使用`async def`声明，而`__aiter__()`方法仅使用`def`声明。
- en: '[![9](assets/9.png)](#co_asyncio_walk_through_CO20-9)'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_asyncio_walk_through_CO20-9)'
- en: 'For each key, we fetch the value from Redis: `self.ikeys` is a regular iterator
    over the keys, so we use `next()` to move over them.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个键，我们从Redis获取值：`self.ikeys`是键的常规迭代器，因此我们使用`next()`来移动它们。
- en: '[![10](assets/10.png)](#co_asyncio_walk_through_CO20-10)'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](assets/10.png)](#co_asyncio_walk_through_CO20-10)'
- en: When `self.ikeys` is exhausted, we handle the `StopIteration` and simply turn
    it into a `StopAsyncIteration`! This is how you signal stop from inside an async
    iterator.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 当`self.ikeys`耗尽时，我们处理`StopIteration`并简单地将其转换为`StopAsyncIteration`！这就是您如何在异步迭代器内部发出停止信号。
- en: '[![11](assets/11.png)](#co_asyncio_walk_through_CO20-11)'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '[![11](assets/11.png)](#co_asyncio_walk_through_CO20-11)'
- en: Finally—the entire point of this example—we can get the data from Redis associated
    with this key. We can `await` the data, which means that other code can run on
    the event loop while we wait on network I/O.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 最后——这个示例的整个重点——我们可以获取与此键关联的Redis数据。我们可以`await`数据，这意味着在等待网络I/O时可以运行其他代码。
- en: 'Hopefully, this example is clear: `async for` provides the ability to retain
    the convenience of a simple `for` loop, even when iterating over data where the
    iteration itself is performing I/O. The benefit is that you can process enormous
    amounts of data with a single loop, because you have to deal with each chunk only
    in tiny batches.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这个示例很清楚：`async for`提供了在迭代本身执行I/O的数据时保留简单`for`循环便利性的能力。好处是您可以通过单个循环处理大量数据，因为您只需处理每个数据块的微小批次。
- en: Simpler Code with Async Generators
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用异步生成器简化代码
- en: '*Async generators* are `async def` functions that have `yield` keywords inside
    them. Async generators result in simpler code.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '*异步生成器*是`async def`函数，其中包含`yield`关键字。异步生成器使代码更简单。'
- en: However, the idea of them might be confusing if you have some experience with
    using generators *as if* they were coroutines, such as with the Twisted framework,
    or the Tornado framework, or even with `yield from` in Python 3.4’s `asyncio`.
    Therefore, before we continue, it will be best if you can convince yourself that
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您有使用生成器 *仿佛* 它们是协程的经验，比如使用Twisted框架、Tornado框架或者Python 3.4的`asyncio`中的`yield
    from`，那么对它们的理解可能会有些困惑。因此，在继续之前，最好您能确信
- en: Coroutines and generators are completely different concepts.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程和生成器是完全不同的概念。
- en: Async generators behave much like ordinary generators.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步生成器的行为与普通生成器非常相似。
- en: For iteration, you use `async for` for async generators, instead of the ordinary
    `for` used for ordinary generators.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于迭代，您使用`async for`来处理异步生成器，而不是用于普通生成器的普通`for`。
- en: The example used in the previous section to demonstrate an async iterator for
    interaction with Redis turns out to be much simpler if we set it up as an async
    generator, shown in [Example 3-26](#asyncgenredis).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中用于演示与Redis交互的异步迭代器的示例，如果我们将其设置为异步生成器，将会变得简单得多，如[示例 3-26](#asyncgenredis)所示。
- en: Example 3-26\. Easier with an async generator
  id: totrans-420
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-26\. 使用异步生成器更容易
- en: '[PRE29]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO21-1)'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO21-1)'
- en: The `main()` function is identical to the version in [Example 3-25](#iter_redis).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数与[Example 3-25](#iter_redis)中的版本相同。'
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO21-2)'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO21-2)'
- en: 'Well, almost identical: I changed the name from *`CamelCase`* to *`snake_case`*.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，几乎一样：我将名称从*`CamelCase`*改为*`snake_case`*。
- en: '[![3](assets/3.png)](#co_asyncio_walk_through_CO21-3)'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asyncio_walk_through_CO21-3)'
- en: Our function is now declared with `async def`, making it a *coroutine function*,
    and since this function also contains the `yield` keyword, we refer to it as an
    *asynchronous generator function*.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数现在声明为`async def`，使其成为*协程函数*，由于这个函数也包含`yield`关键字，我们将其称为*异步生成器函数*。
- en: '[![4](assets/4.png)](#co_asyncio_walk_through_CO21-4)'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asyncio_walk_through_CO21-4)'
- en: 'We don’t have to do the convoluted things necessary in the previous example
    with `self.ikeys`: here, we just loop over the keys directly and obtain the value…'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必像之前的示例中那样做繁琐的事情，比如使用`self.ikeys`：在这里，我们直接循环遍历键并获取值…
- en: '[![5](assets/5.png)](#co_asyncio_walk_through_CO21-5)'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asyncio_walk_through_CO21-5)'
- en: …and then yield it to the caller, just like a normal generator.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: …然后将其 yield 给调用者，就像一个普通的生成器一样。
- en: 'It might seem complex if this is new to you, but I urge you to play around
    with this yourself on a few toy examples. It starts to feel natural pretty quickly.
    Async generators are likely to become popular in `asyncio`-based codebases because
    they bring all the same benefits as normal generators: making code shorter and
    simpler.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这对你来说是新的，它可能看起来很复杂，但我建议你在几个玩具示例上自己试试。它很快就会感觉自然起来。异步生成器很可能会在基于`asyncio`的代码库中变得流行，因为它们带来了与普通生成器相同的所有好处：使代码更短，更简单。
- en: Async Comprehensions
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步推导式
- en: Now that we’ve seen how Python supports asynchronous iteration, the next natural
    question to ask is whether it also works for list comprehensions—and the answer
    is *yes*. This support was introduced in [PEP 530](https://oreil.ly/4qNoH), and
    I recommend you take a look at the PEP yourself; it is short and readable. [Example 3-27](#asynccomps)
    shows how typical async comprehensions are laid out.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到 Python 如何支持异步迭代，下一个自然的问题是它是否也适用于列表推导式——答案是*是*。这种支持是在[PEP 530](https://oreil.ly/4qNoH)中引入的，我建议你自己阅读一下这个PEP；它很简短，易读。[Example 3-27](#asynccomps)展示了典型异步推导式的布局。
- en: Example 3-27\. Async list, dict, and set comprehensions
  id: totrans-435
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-27。异步列表、字典和集合推导式
- en: '[PRE30]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO22-1)'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO22-1)'
- en: '`doubler()` is a very simple async generator: given an upper value, it’ll iterate
    over a simple range, yielding a tuple of the value and its double.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '`doubler()`是一个非常简单的异步生成器：给定一个上限值，它将迭代一个简单的范围，产生值及其两倍的元组。'
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO22-2)'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO22-2)'
- en: Sleep a little, just to emphasize that this is really an async function.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 睡一会儿，只是为了强调这确实是一个异步函数。
- en: '[![3](assets/3.png)](#co_asyncio_walk_through_CO22-3)'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asyncio_walk_through_CO22-3)'
- en: 'An async list comprehension: note how `async for` is used instead of the usual
    `for`. This difference is the same as that shown in the examples in [“Async Iterators:
    async for”](#asynciter).'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 异步列表推导式：请注意如何使用`async for`而不是通常的`for`。这个差异与[“异步迭代器：async for”](#asynciter)中的示例所示的相同。
- en: '[![4](assets/4.png)](#co_asyncio_walk_through_CO22-4)'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asyncio_walk_through_CO22-4)'
- en: An async dict comprehension; all the usual tricks work, such as unpacking the
    tuple into `x` and `y` so that they can feed the dict comprehension syntax.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 异步字典推导式；所有通常的技巧都有效，比如将元组解包成`x`和`y`，以便它们可以提供给字典推导式语法。
- en: '[![5](assets/5.png)](#co_asyncio_walk_through_CO22-5)'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asyncio_walk_through_CO22-5)'
- en: The async set comprehension works exactly as you would expect.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 异步集合推导式的工作方式与你期望的完全相同。
- en: You can also use `await` inside comprehensions, as outlined in PEP 530\. This
    shouldn’t be a surprise; `await` *`coro`* is a normal expression and can be used
    in most places you would expect.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在推导式中使用`await`，如PEP 530所述。这不应该让人感到意外；`await``coro`是一个正常的表达式，可以在大多数你期望的地方使用。
- en: It’s the `async for` that makes a comprehension an *async comprehension*, not
    the presence of `await`. All that’s needed for `await` to be legal (inside a comprehension)
    is for it to be used inside the body of a coroutine function—i.e., a function
    declared with `async def`. Using `await` and `async for` inside the same list
    comprehension is really combining two separate concepts, but we’ll do this anyway
    in [Example 3-28](#awaitcomp) to make sure you’re comfortable with async language
    syntax.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 是`async for`使理解成为*异步理解*，而不是`await`的存在。`await`要在理解内部合法（或者说，在协程函数体内使用）只需其在异步函数`async
    def`中使用即可。在同一列表理解中结合使用`await`和`async for`实际上是结合了两个独立的概念，但我们会在[示例 3-28](#awaitcomp)中这样做，以确保你对异步语言语法感到舒适。
- en: Example 3-28\. Putting it all together
  id: totrans-449
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-28\. 将所有内容整合在一起
- en: '[PRE31]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO23-1)'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO23-1)'
- en: 'A simple coroutine function: sleep for a bit; then return the parameter plus
    100.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的协程函数：暂停一会儿；然后返回参数加上100。
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO23-2)'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO23-2)'
- en: This is an *async generator*, which we will call inside an async list comprehension
    a bit farther down, using `async for` to drive the iteration.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个*异步生成器*，我们稍后将在异步列表理解中调用它，使用`async for`来驱动迭代。
- en: '[![3](assets/3.png)](#co_asyncio_walk_through_CO23-3)'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asyncio_walk_through_CO23-3)'
- en: The async generator will yield a tuple of `f` and the iteration var `x`. The
    `f` return value is a *coroutine function*, not yet a coroutine.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 异步生成器将产生一个`f`和迭代变量`x`的元组。`f`的返回值是一个*协程函数*，而不是一个协程。
- en: '[![4](assets/4.png)](#co_asyncio_walk_through_CO23-4)'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asyncio_walk_through_CO23-4)'
- en: Finally, the async comprehension. This example has been contrived to demonstrate
    a comprehension that includes *both* `async for` and `await`. Let’s break down
    what’s happening inside the comprehension. First, the `factory(3)` call returns
    an async generator, which must be driven by iteration. Because it’s an *async*
    generator, you can’t just use `for`; you must use `async for`.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是异步理解。这个示例被构造出来演示同时包含`async for`和`await`的理解。让我们分解一下理解内部发生了什么。首先，`factory(3)`调用返回一个异步生成器，必须通过迭代来驱动它。因为它是一个*异步*生成器，你不能简单地使用`for`；你必须使用`async
    for`。
- en: The values produced by the async generator are a tuple of a coroutine function
    `f` and an `int`. Calling the coroutine function `f()` produces a coroutine, which
    must be evaluated with `await`.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 异步生成器生成的值是一个由协程函数`f`和一个`int`组成的元组。调用协程函数`f()`会产生一个协程，必须使用`await`来评估它。
- en: 'Note that inside the comprehension, the use of `await` has nothing at all to
    do with the use of `async for`: they are doing completely different things and
    acting on different objects entirely.'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在理解中，使用`await`与使用`async for`毫不相关：它们完全执行不同的任务，并作用于完全不同的对象。
- en: Starting Up and Shutting Down (Gracefully!)
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动和关闭（优雅地！）
- en: Most async-based programs are going to be long-running, network-based applications.
    This domain holds a surprising amount of complexity in dealing with how to start
    up and shut down correctly.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数基于异步的程序将会是长时间运行的、基于网络的应用程序。这个领域在正确处理启动和关闭的复杂性方面包含了惊人的多样性。
- en: Of the two, startup is simpler. The standard way of starting up an `asyncio`
    application is to have a `main()` coroutine function and call it with `asyncio.run()`,
    as shown in [Example 3-2](#helloworld) at the beginning of this chapter.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两者中，启动更为简单。启动`asyncio`应用程序的标准方式是拥有一个`main()`协程函数，并使用`asyncio.run()`调用它，就像在本章开头的[示例 3-2](#helloworld)中展示的那样。
- en: Generally, startup will be fairly straightforward; for the server case described
    earlier, you can read more about it [in the docs](http://bit.ly/2FrKaIV). We’ll
    also briefly look at a demonstration of server startup in an upcoming code example.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，启动过程会相对直接；对于前面描述的服务器情况，你可以在[文档](http://bit.ly/2FrKaIV)中进一步了解。接下来，我们还会简要看一下服务器启动的示例代码。
- en: 'Shutdown is much more intricate. For shutdown, I previously covered the dance
    that happens inside `asyncio.run()`. When the `async def main()` function exits,
    the following actions are taken:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭过程要复杂得多。对于关闭，我之前讲过发生在`asyncio.run()`内部的流程。当`async def main()`函数退出时，将执行以下操作：
- en: Collect all the still-pending task objects (if any).
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集所有仍未完成的任务对象（如果有）。
- en: Cancel these tasks (this raises `CancelledError` inside each running coroutine,
    which you may choose to handle in a `try/except` within the body of the coroutine
    function).
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消这些任务（这会在每个正在运行的协程内部引发`CancelledError`，您可以选择在协程函数的`try/except`中处理它）。
- en: Gather all these tasks into a *group* task.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有这些任务聚合成一个*组*任务。
- en: Use `run_until_complete()` on the group task to wait for them to finish—i.e.,
    let the `CancelledError` exception be raised and dealt with.
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组任务上使用`run_until_complete()`等待它们完成——也就是说，让`CancelledError`异常被引发并处理。
- en: '`asyncio.run()` performs these actions for you, but in spite of this assistance,
    a rite of passage in building your first few nontrivial `asyncio` apps is going
    to be trying to get rid of error messages like “Task was destroyed but it is pending!”
    during shutdown. This happens because your application was not expecting one or
    more of the preceding steps. [Example 3-29](#destroytasks) is an example of a
    script that raises this annoying error.'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio.run()`为您执行这些操作，但是尽管有这些帮助，构建您的前几个非平凡`asyncio`应用程序的过程中，您可能会试图消除诸如“任务已被销毁但仍处于挂起状态！”之类的错误消息。这是因为您的应用程序未预期某个或多个前面的步骤。[示例 3-29](#destroytasks)
    是一个引发此烦人错误的脚本的示例。'
- en: Example 3-29\. Destroyer of pending tasks
  id: totrans-471
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-29\. 待处理任务的销毁者
- en: '[PRE32]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO24-1)'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO24-1)'
- en: Task 1 will run for 1 second.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 任务 1 将运行 1 秒钟。
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO24-2)'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO24-2)'
- en: Task 2 will run for 2 seconds.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 任务 2 将运行 2 秒钟。
- en: '[![3](assets/3.png)](#co_asyncio_walk_through_CO24-3)'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asyncio_walk_through_CO24-3)'
- en: Run only until task 1 is complete.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 仅运行直到任务 1 完成。
- en: 'Running it produces the following output:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它会产生以下输出：
- en: '[PRE33]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This error is telling you that some tasks had not yet been completed when the
    loop was closed. We want to avoid this, and that is why the idiomatic shutdown
    procedure is to collect all unfinished tasks, cancel them, and then let them all
    finish *before* closing the loop. `asyncio.run()` does all of these steps for
    you, but it is important to understand the process in detail so that you will
    be able to handle more complex situations.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 此错误告诉您，在关闭循环时，一些任务尚未完成。我们希望避免这种情况，这就是为什么习惯性的关闭过程是收集所有未完成的任务，取消它们，然后让它们全部完成*之后*再关闭循环。`asyncio.run()`为您执行所有这些步骤，但是重要的是详细了解这个过程，这样您就能处理更复杂的情况。
- en: Let’s look at a more detailed code sample that illustrates all these phases.
    [Example 3-30](#telnetdemo) is a mini case study with a Telnet-based echo server.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个更详细的代码示例，展示所有这些阶段。[示例 3-30](#telnetdemo) 是一个基于 Telnet 的回显服务器的迷你案例研究。
- en: Example 3-30\. Asyncio application life cycle (based on the TCP echo server
    in the Python documentation)
  id: totrans-483
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-30\. Asyncio 应用生命周期（基于 Python 文档中的 TCP 回显服务器）
- en: '[PRE34]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO25-1)'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO25-1)'
- en: This `echo()` coroutine function will be used (by the server) to create a coroutine
    for each connection made. The function is using the streams API for networking
    with `asyncio`.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 此`echo()`协程函数将被（服务器）用于为每个建立的连接创建一个协程。该函数正在使用`asyncio`的流 API 进行网络操作。
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO25-2)'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO25-2)'
- en: To keep the connection alive, we’ll have an infinite loop to wait for messages.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持连接活跃，我们将使用一个无限循环来等待消息。
- en: '[![3](assets/3.png)](#co_asyncio_walk_through_CO25-3)'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asyncio_walk_through_CO25-3)'
- en: Return the data back to the sender, but in ALL CAPS.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据返回给发送者，但使用全部大写字母。
- en: '[![4](assets/4.png)](#co_asyncio_walk_through_CO25-4)'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asyncio_walk_through_CO25-4)'
- en: If this task is *cancelled*, we’ll print a message.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此任务被*取消*，我们将打印一条消息。
- en: '[![5](assets/5.png)](#co_asyncio_walk_through_CO25-5)'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asyncio_walk_through_CO25-5)'
- en: This code for starting a TCP server is taken directly from the Python 3.8 documentation.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 此 TCP 服务器启动代码直接来自于 Python 3.8 文档。
- en: 'After starting the echo server, you can telnet to and interact with it:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 启动回显服务器后，可以使用 telnet 进行交互：
- en: '[PRE35]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The server output for that session looks like this (the server keeps running
    until we hit Ctrl-C):'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 该会话的服务器输出如下（服务器会一直运行，直到我们按下 Ctrl-C）：
- en: '[PRE36]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the Telnet session just shown, the client (i.e., Telnet) closed the connection
    before the server was stopped, but let’s see what happens if we shut down our
    server while a connection is active. We’ll see the following output from the server
    process:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在刚才展示的 Telnet 会话中，客户端（即 Telnet）在服务器停止之前关闭了连接，但是让我们看看如果在连接活动时关闭服务器会发生什么。我们将从服务器进程看到以下输出：
- en: '[PRE37]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here you can see that the exception handler for `CancelledError` was triggered.
    Now let’s imagine that this is a real-world production application, and we want
    to send all events about dropped connections to a monitoring service. The code
    sample might be modified to look like [Example 3-31](#taskaftercancel).
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到 `CancelledError` 的异常处理程序被触发。 现在让我们假设这是一个真实的生产应用程序，并且我们希望将所有关于断开连接的事件发送到监控服务。
    代码示例可能会修改为如下形式 [示例 3-31](#taskaftercancel)。
- en: Example 3-31\. Creating a task inside a cancellation handler
  id: totrans-502
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-31\. 在取消处理程序内创建任务
- en: '[PRE38]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO26-1)'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO26-1)'
- en: Pretend that this coroutine actually contacts an external server to submit event
    notifications.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 假装这个协程实际上联系外部服务器以提交事件通知。
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO26-2)'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO26-2)'
- en: Because the event notifier involves network access, it is common for such calls
    to be made in a separate async task; that’s why we’re using the `create_task()`
    function here.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 因为事件通知器涉及网络访问，因此通常会在单独的异步任务中进行这类调用； 这就是我们在这里使用 `create_task()` 函数的原因。
- en: 'This code has a bug, however. It becomes obvious if we rerun the example, and
    make sure to stop the server (with Ctrl-C) while a connection is active:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这段代码有一个 bug。 如果我们重新运行示例，并确保在连接活动时停止服务器（使用 Ctrl-C）：
- en: '[PRE39]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: To understand why this is happening, we must go back to the sequence of cleanup
    events that `asyncio.run()` does during the shutdown phase; in particular, the
    important part is that when we press Ctrl-C, all the currently active tasks are
    collected and cancelled. At this point, *only those tasks* are then awaited, and
    `asyncio.run()` returns immediately after that. The bug in our modified code is
    that we created a *new* task inside the cancellation handler of our existing “echo”
    task. This new task was created only after `asyncio.run()` had collected and cancelled
    all the tasks in the process.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么会发生这种情况，我们必须回到 `asyncio.run()` 在关闭阶段执行的清理事件序列； 特别是重要的部分是，当我们按下 Ctrl-C
    时，所有当前活动的任务都被收集并取消。 此时，*仅这些任务* 然后被等待，而 `asyncio.run()` 在此之后立即返回。 我们修改后的代码中的 bug
    是，在现有“echo”任务的取消处理程序内创建了一个*新*任务。 这个新任务是在 `asyncio.run()` 收集和取消了过程中所有任务之后才创建的。
- en: This is why it is important to be aware of how `asyncio.run()` works.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么了解 `asyncio.run()` 如何工作非常重要。
- en: Tip
  id: totrans-512
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: As a general rule of thumb, try to avoid creating new tasks inside `CancelledError`
    exception handlers. If you must, be sure to also `await` the new task or future
    inside the scope of the same function.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个基本的经验法则，尽量避免在 `CancelledError` 异常处理程序内创建新任务。 如果必须这样做，请确保在同一函数范围内也要 `await`
    新任务或 future。
- en: 'And finally: if you’re using a library or framework, make sure to follow its
    documentation on how you should perform startup and shutdown. Third-party frameworks
    usually provide their own functions for startup and shutdown, and they’ll provide
    event hooks for customization. You can see an example of these hooks with the
    Sanic framework in [“Case Study: Cache Invalidation”](ch04.html#asyncpg_cs).'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 最后：如果您正在使用库或框架，请确保遵循其关于如何执行启动和关闭的文档。 第三方框架通常提供其自己的启动和关闭功能，并提供事件钩子进行定制。 您可以在
    Sanic 框架中查看这些钩子的示例 [“案例研究：缓存失效”](ch04.html#asyncpg_cs)。
- en: What Is the return_exceptions=True for in gather()?
  id: totrans-515
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`gather()` 中的 `return_exceptions=True` 是什么意思？'
- en: You may have noticed the keyword argument `return_exceptions=True` in the call
    to `gather()` in Examples [3-3](#quickstart-executor) and [3-1](#features_of_asyncio_arranged_in_a_hierarchy)
    during the shutdown sequence, but I very sneakily said nothing about it at the
    time. `asyncio.run()` also uses `gather()` and `return_exceptions=True` internally,
    and the time has come for further discussion.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到在关闭序列期间的 `gather()` 调用中的关键字参数 `return_exceptions=True`，但在当时我非常狡猾地没有提到它。
    `asyncio.run()` 也在内部使用 `gather()` 和 `return_exceptions=True`，现在是进一步讨论的时候了。
- en: 'Unfortunately, the default is `gather(..., return_exceptions=False`). This
    default is problematic for most situations, including the shutdown process, and
    this is why `asyncio.run()` sets the parameter to `True`. It’s a little complicated
    to explain directly; instead, let’s step through a sequence of observations that’ll
    make it much easier to understand:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，默认设置为`gather(..., return_exceptions=False)`。 这个默认设置在大多数情况下都有问题，包括关闭过程，这就是为什么`asyncio.run()`将参数设置为`True`。
    直接解释起来有点复杂； 相反，让我们逐步观察一系列观察，这将使理解变得更加容易：
- en: '`run_until_complete()` operates on a future; during shutdown, it’s the future
    returned by `gather()`.'
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`run_until_complete()`作用于一个future；在关闭期间，它是由`gather()`返回的future。'
- en: If that future raises an exception, the exception will *also* be raised out
    of `run_until_complete()`, which means that the loop will stop.
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果该future引发异常，该异常也将从`run_until_complete()`中抛出，这意味着循环将停止。
- en: If `run_until_complete()` is being used on a group future, any exception raised
    inside *any of the subtasks* will also be raised in the “group” future if it isn’t
    handled in the subtask. Note this includes `CancelledError`.
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`run_until_complete()`用于一个组合future，任何子任务中引发的异常也会在“组”future中引发，如果在子任务中没有处理的话。注意，这包括`CancelledError`。
- en: If only some tasks handle `CancelledError` and others don’t, the ones that don’t
    will cause the loop to stop. This means that the loop will be stopped *before*
    all the tasks are done.
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果只有一些任务处理`CancelledError`而其他任务没有处理，那么没有处理的任务将导致循环停止。这意味着循环会在所有任务完成*之前*停止。
- en: For shutdown, we really don’t want this behavior. We want `run_until_complete()`
    to finish only when all the tasks in the group have finished, regardless of whether
    some of the tasks raise exceptions.
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于关闭，我们确实不希望出现这种行为。我们希望`run_until_complete()`仅在组中的所有任务都完成时才结束，无论某些任务是否引发异常。
- en: 'Hence we have `gather(*, return_exceptions=True)`: that setting makes the “group”
    future treat exceptions from the subtasks as *returned values*, so that they don’t
    bubble out and interfere with `run_until_complete()`.'
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此我们有`gather(*, return_exceptions=True)`：该设置使得“组”future将子任务中的异常视为*返回值*，因此它们不会冒出来干扰`run_until_complete()`。
- en: 'And there you have it: the relationship between `return_exceptions=True` and
    `run_until_complete()`. An undesirable consequence of capturing exceptions in
    this way is that some errors may escape your attention because they’re now (effectively)
    being handled inside the group task. If this is a concern, you can obtain the
    output list from `run_until_complete()` and scan it for any subclasses of `Exception`,
    and then write log messages appropriate for your situation. [Example 3-32](#allcomplete)
    demonstrates this approach.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样：`return_exceptions=True`和`run_until_complete()`之间的关系。以这种方式捕获异常的一个不良后果是，一些错误可能会逃脱您的注意，因为它们现在（实际上）正在组任务内部处理。如果这是一个问题，您可以从`run_until_complete()`获取输出列表，并扫描其中任何`Exception`的子类，然后根据您的情况编写适当的日志消息。[示例 3-32](#allcomplete)演示了这种方法。
- en: Example 3-32\. All the tasks will complete
  id: totrans-525
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-32\. 所有任务都将完成
- en: '[PRE40]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO27-1)'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO27-1)'
- en: It would be awful if someone were to pass in a zero…
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人传入零的话，那就糟糕了...
- en: 'Here’s the output:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE41]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Without `return_exceptions=True`, the `ZeroDivisionError` would be raised from
    `run_until_complete()`, stopping the loop and thus preventing the other tasks
    from finishing.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 没有`return_exceptions=True`，在`run_until_complete()`中会引发`ZeroDivisionError`，导致循环停止，从而阻止其他任务完成。
- en: In the next section, we look at handling signals (beyond KeyboardInterrupt),
    but before we get there, it’s worth keeping in mind that graceful shutdown is
    one of the more difficult aspects of network programming, and this remains true
    for `asyncio`. The information in this section is merely a start. I encourage
    you to have specific tests for clean shutdown in your own automated test suites.
    Different applications often require different strategies.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论处理信号（除了KeyboardInterrupt之外），但在此之前，值得注意的是，优雅关闭是网络编程中更为困难的方面之一，对于`asyncio`也是如此。本节中的信息仅为一个起点。我建议您在自己的自动化测试套件中为干净的关闭设置具体的测试。不同的应用通常需要不同的策略。
- en: Tip
  id: totrans-533
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: I’ve published a tiny package on the Python package index (PyPI) called [`aiorun`](https://oreil.ly/kQDt8),
    primarily for my own experiments and education in dealing with `asyncio` shutdown,
    that incorporates many ideas from this section. It may also be useful for you
    to tinker with the code and experiment with your own ideas around `asyncio` shutdown
    scenarios.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 我在Python包索引（PyPI）上发布了一个小包[`aiorun`](https://oreil.ly/kQDt8)，主要用于我在处理`asyncio`关闭时的实验和教育，其中包含了本节许多想法。也许对您来说，调试代码并在自己的`asyncio`关闭场景中尝试新想法也很有用。
- en: Signals
  id: totrans-535
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号
- en: Previous examples showed how the event loop is stopped with a `KeyboardInterrupt`;
    i.e., pressing Ctrl-C. Internally within `asyncio.run()`, the raised `KeyboardInterrupt`
    effectively unblocks a `loop.run_until_complete()` call and allows the subsequent
    shutdown sequence to happen.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例展示了如何通过按下Ctrl-C停止事件循环。在`asyncio.run()`内部，引发的`KeyboardInterrupt`有效地解除了`loop.run_until_complete()`调用，并允许随后的关闭序列发生。
- en: '`KeyboardInterrupt` corresponds to the `SIGINT` signal. In network services,
    the more common signal for process termination is actually `SIGTERM`, and this
    is also the default signal when you use the `kill` command in a Unix shell.'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyboardInterrupt`对应于`SIGINT`信号。在网络服务中，更常见的进程终止信号实际上是`SIGTERM`，这也是在Unix shell中使用`kill`命令时的默认信号。'
- en: Tip
  id: totrans-538
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'The `kill` command on Unix systems is deceptively named: all it does it send
    signals to a process. Without arguments, `kill` *`<PID>`* will send a `TERM` signal:
    your process can receive the signal and do a graceful shutdown, or simply ignore
    it! That’s a bad idea, though, because if your process doesn’t stop eventually,
    the next thing the would-be killer usually does is `kill -s KILL` *`<PID>`*, which
    sends the `KILL` signal. This will shut you down, and there’s nothing your program
    can do about it. Receiving the `TERM` (or `INT`) signal is your opportunity to
    shut down in a controlled way.'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: Unix系统上的`kill`命令具有迷惑性的名称：它只是向进程发送信号。如果没有参数，`kill` *`<PID>`*将发送一个`TERM`信号：您的进程可以接收该信号并以优雅的方式关闭或者简单地忽略它！但这是个坏主意，因为如果您的进程最终不停止，那么想要杀死进程的下一步通常是执行`kill
    -s KILL` *`<PID>`*，这将发送`KILL`信号。这会强制关闭您的程序，而您的程序无能为力。接收`TERM`（或`INT`）信号是您控制方式关闭的机会。
- en: '`asyncio` has built-in support for handling process signals, but there’s a
    surprising degree of complexity around signal handling in general (not specific
    to `asyncio`). We cannot cover everything here, but we can have a look at some
    of the more basic considerations that need to be made. [Example 3-33](#shutsig01)
    will produce the following output:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio`内置支持处理进程信号，但是信号处理通常存在一定的复杂性（与`asyncio`无关）。我们无法在这里覆盖所有内容，但我们可以看一些需要考虑的基本情况。[示例 3-33](#shutsig01)将产生以下输出：'
- en: '[PRE42]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: I pressed Ctrl-C to stop the program, as shown on the last line. [Example 3-33](#shutsig01)
    intentionally avoids using the convenient `asyncio.run()` function because I want
    to warn you about specific traps in handling the two most common signals, `SIGTERM`
    and `SIGINT`, during your shutdown sequence. After we discuss these, I will show
    a final example of signal handling using the more convenient `asyncio.run()` function.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 我按下Ctrl-C来停止程序，如最后一行所示。[示例 3-33](#shutsig01)有意避免使用便捷的`asyncio.run()`函数，因为我想警告您在处理两个最常见的信号`SIGTERM`和`SIGINT`时要注意特定的陷阱。在讨论这些之后，我将展示一个使用更方便的`asyncio.run()`函数的最终示例。
- en: Example 3-33\. Refresher for using KeyboardInterrupt as a SIGINT handler
  id: totrans-543
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-33\. 使用`KeyboardInterrupt`作为SIGINT处理程序的复习
- en: '[PRE43]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO28-1)'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO28-1)'
- en: This is the main part of our application. To keep things simple, we’re just
    going to sleep in an infinite loop.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们应用程序的主要部分。为了保持简单，我们将在一个无限循环中休眠。
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO28-2)'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO28-2)'
- en: This startup and shutdown sequence will be familiar to you from the previous
    section. We schedule `main()`, call `run_forever()`, and wait for something to
    stop the loop.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 此启动和关闭序列将与您在前一节中熟悉的内容相同。我们安排`main()`，调用`run_forever()`，并等待某些事件停止循环。
- en: '[![3](assets/3.png)](#co_asyncio_walk_through_CO28-3)'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asyncio_walk_through_CO28-3)'
- en: In this case, only Ctrl-C will stop the loop. Then we handle `KeyboardInterrupt`
    and do all the necessary cleanup bits, as covered in the previous sections.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，只有Ctrl-C才能停止循环。然后我们处理`KeyboardInterrupt`并执行所有必要的清理工作，正如前几节所述。
- en: 'So far, that’s pretty straightforward. Now I’m going to complicate things.
    Suppose that:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这相当简单明了。现在我要复杂化事情了。假设：
- en: One of your colleagues asks that you please handle `SIGTERM` in addition to
    `SIGINT` as a shutdown signal.
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的一位同事要求您除了处理`SIGINT`信号外，还请处理`SIGTERM`信号作为关闭信号。
- en: In your real application, you need to do cleanup inside your `main()` coroutine;
    you will need to handle `CancelledError`, and the cleanup code inside the exception
    handler will take several seconds to finish (imagine that you have to communicate
    with network peers and close a bunch of socket connections).
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的实际应用程序中，您需要在 `main()` 协程内部进行清理；您将需要处理 `CancelledError`，并且异常处理程序内部的清理代码将需要几秒钟来完成（想象一下，您必须与网络对等方通信并关闭一堆套接字连接）。
- en: Your app must not do weird things if you’re sent signals multiple times (such
    as rerunning any shutdown steps); after you receive the first shutdown signal,
    you want to simply ignore any new signals until exit.
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的应用程序接收到多次信号（例如重新运行任何关闭步骤），则不应该做奇怪的事情；在接收到第一个关闭信号后，您希望简单地忽略任何新信号直到退出。
- en: '`asyncio` provides enough granularity in the API to handle all these situations.
    [Example 3-34](#bothsig) modifies the previous simple code example to include
    these new features.'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio` 提供了足够的 API 粒度来处理所有这些情况。[示例 3-34](#bothsig) 修改了之前的简单代码示例，包含了这些新特性。'
- en: Example 3-34\. Handle both SIGINT and SIGTERM, but stop the loop only once
  id: totrans-556
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-34\. 处理 SIGINT 和 SIGTERM，但只停止循环一次
- en: '[PRE44]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO29-1)'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO29-1)'
- en: Import the signal values from the standard library `signal` module.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 从标准库 `signal` 模块导入信号值。
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO29-2)'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO29-2)'
- en: This time, our `main()` coroutine is going to do some cleanup internally. When
    the cancellation signal is received (initiated by cancelling each of the tasks),
    there will be a period of 3 seconds where `main()` will continue running during
    the `run_until_complete()` phase of the shutdown process. It’ll print, “Your app
    is shutting down…”.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们的 `main()` 协程将在内部进行一些清理。当接收到取消信号（通过取消每个任务来启动）时，将在关闭过程的 `run_until_complete()`
    阶段继续运行 3 秒钟。它会打印，“Your app is shutting down…”。
- en: '[![3](assets/3.png)](#co_asyncio_walk_through_CO29-3)'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asyncio_walk_through_CO29-3)'
- en: This is a callback handler for when we receive a signal. It is configured on
    the loop via the call to `add_signal_handler()` a bit farther down.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当我们接收信号时的回调处理程序。它通过稍后的 `add_signal_handler()` 调用配置在循环上。
- en: '[![4](assets/4.png)](#co_asyncio_walk_through_CO29-4)'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asyncio_walk_through_CO29-4)'
- en: 'The primary purpose of the handler is to stop the loop: this will unblock the
    `loop.run_forever()` call and allow pending task collection and cancellation,
    and the `run_complete()` for shutdown.'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序的主要目的是停止循环：这将解除 `loop.run_forever()` 调用的阻塞，并允许挂起任务的收集和取消，并且 `run_complete()`
    用于关闭。
- en: '[![5](assets/5.png)](#co_asyncio_walk_through_CO29-5)'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asyncio_walk_through_CO29-5)'
- en: 'Since we are now in shutdown mode, we *don’t want* another `SIGINT` or `SIGTERM`
    to trigger this handler again: that would call `loop.stop()` during the `run_until_complete()`
    phase, which would interfere with our shutdown process. Therefore, we *remove*
    the signal handler for `SIGTERM` from the loop.'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在处于关闭模式，我们*不希望*再次触发 `SIGINT` 或 `SIGTERM` 这个处理程序：在 `run_until_complete()`
    阶段调用 `loop.stop()` 将干扰我们的关闭过程。因此，我们从循环中*移除*了 `SIGTERM` 的信号处理程序。
- en: '[![6](assets/6.png)](#co_asyncio_walk_through_CO29-6)'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_asyncio_walk_through_CO29-6)'
- en: 'This is a “gotcha”: we can’t simply remove the handler for `SIGINT`, because
    if we did that, `KeyboardInterrupt` would again become the handler for `SIGINT`,
    the same as it was before we added our own handlers. Instead, we set an empty
    `lambda` function as the handler. This means that `KeyboardInterrupt` stays away,
    and `SIGINT` (and Ctrl-C) has no effect.^([10](ch03.html#idm46363028180248))'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个“坑”：我们不能简单地删除 `SIGINT` 的处理程序，因为如果这样做，`KeyboardInterrupt` 将再次成为 `SIGINT`
    的处理程序，就像我们在添加自己的处理程序之前一样。相反，我们将空的 `lambda` 函数设置为处理程序。这意味着 `KeyboardInterrupt`
    保持远离，而 `SIGINT`（和 Ctrl-C）则没有效果。^([10](ch03.html#idm46363028180248))
- en: '[![7](assets/7.png)](#co_asyncio_walk_through_CO29-7)'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_asyncio_walk_through_CO29-7)'
- en: Here the signal handlers are attached to the loop. Note that, as discussed previously,
    setting a handler on `SIGINT` means a `KeyboardInterrupt` will no longer be raised
    on `SIGINT`. The raising of a `KeyboardInterrupt` is the “default” handler for
    `SIGINT` and is preconfigured in Python until you do something to change the handler,
    as we’re doing here.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 这里将信号处理程序附加到循环中。请注意，正如之前讨论的那样，设置在 `SIGINT` 上的处理程序意味着 `KeyboardInterrupt` 将不再在
    `SIGINT` 上引发。在 Python 中，引发 `KeyboardInterrupt` 是 `SIGINT` 的“默认”处理程序，直到您做某些更改来改变处理程序，正如我们在这里所做的。
- en: '[![8](assets/8.png)](#co_asyncio_walk_through_CO29-8)'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_asyncio_walk_through_CO29-8)'
- en: As usual, execution blocks on `run_forever()` until something stops the loop.
    In this case, the loop will be stopped inside `handler()` if either `SIGINT` or
    `SIGTERM` is sent to our process. The remainder of the code is the same as before.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，执行会在`run_forever()`上阻塞，直到某些东西停止循环。在这种情况下，如果将`SIGINT`或`SIGTERM`发送到我们的进程，循环将在`handler()`内部停止。其余代码与以前完全相同。
- en: 'Here’s the output:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出：
- en: '[PRE45]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[![1](assets/1.png)](#comarker1)'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#comarker1)'
- en: I hit Ctrl-C a bunch of times during the shutdown phase, but as expected, nothing
    happened until the `main()` coroutine eventually completed.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 在关闭阶段，我按了很多次Ctrl-C，但正如预期的那样，在`main()`协程最终完成之前什么也没发生。
- en: In these examples, I’ve controlled the life cycle of the event loop the hard
    way, but this was necessary to explain the components of the shutdown procedure.
    In practice, we would much prefer to use the more convenient `asyncio.run()` function.
    [Example 3-35](#bothsigrun) retains the features of the preceding signal-handling
    design, but also takes advantage of the convenience of `asyncio.run()`.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，我以较困难的方式控制了事件循环的生命周期，但这是必要的，以解释关闭过程的各个组成部分。在实践中，我们更愿意使用更方便的`asyncio.run()`函数。[示例 3-35](#bothsigrun)保留了前述信号处理设计的特性，同时还利用了`asyncio.run()`的便利性。
- en: Example 3-35\. Signal handling when using asyncio.run()
  id: totrans-579
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-35\. 使用asyncio.run()时的信号处理
- en: '[PRE46]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO30-1)'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO30-1)'
- en: Because `asyncio.run()` takes control of the event loop startup, our first opportunity
    to change signal handling behavior will be in the `main()` function.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`asyncio.run()`控制了事件循环的启动，我们在`main()`函数中第一次更改信号处理行为的机会就来了。
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO30-2)'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO30-2)'
- en: Inside the signal handler, we can’t stop the loop as in previous examples, because
    we’ll get warnings about how the loop was stopped before the task created for
    `main()` was completed. Instead, we can initiate task cancellation here, which
    will ultimately result in the `main()` task exiting; when that happens, the cleanup
    handling inside `asyncio.run()` will take over.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 在信号处理程序中，我们不能像前面的示例那样停止循环，因为我们会收到有关在`main()`任务完成之前停止循环的警告。相反，我们可以在这里启动任务取消，这最终会导致`main()`任务退出；当这发生时，`asyncio.run()`内部的清理处理将接管。
- en: Waiting for the Executor During Shutdown
  id: totrans-585
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等待执行者在关闭期间
- en: '[“Quickstart”](#quickstart-section) introduced the basic executor interface
    with [Example 3-3](#quickstart-executor), where I pointed out that the blocking
    `time.sleep()` call was conveniently shorter than the `asyncio.sleep()` call—luckily
    for us, because it means the executor task completes sooner than the `main()`
    coroutine, and as a result the program shuts down correctly.'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '[“快速入门”](#quickstart-section)介绍了基本的执行者接口，使用了[示例 3-3](#quickstart-executor)，在那里我指出阻塞的`time.sleep()`调用比`asyncio.sleep()`调用方便，幸运的是对我们来说，这意味着执行者任务比`main()`协程更早完成，因此程序可以正确关闭。'
- en: 'This section examines what happens during shutdown when executor jobs take
    longer to finish than all the pending `Task` instances. The short answer is: without
    intervention, you’re going to get errors like those produced by the code in [Example 3-36](#exetoolong).'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将探讨在执行者作业需要较长时间完成而所有待处理的`Task`实例都完成时发生的关闭情况。简短的答案是：没有干预的话，你会得到类似于[示例 3-36](#exetoolong)代码产生的错误。
- en: Example 3-36\. The executor takes too long to finish
  id: totrans-588
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-36\. 执行者需要太长时间才能完成
- en: '[PRE47]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO31-1)'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO31-1)'
- en: This code sample is exactly the same as the one in [Example 3-3](#quickstart-executor),
    *except* that the sleep time in the blocking function is now longer than in the
    async one.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码示例与[示例 3-3](#quickstart-executor)完全相同，*唯一*的区别是阻塞函数中的休眠时间现在比异步函数长。
- en: 'Running this code produces the following output:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会产生以下输出：
- en: '[PRE48]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'What’s happening here is that behind the scenes, `run_in_executor()` does *not*
    create a `Task` instance: it returns a `Future`. That means it isn’t included
    in the set of “active tasks” that get cancelled inside `asyncio.run()`, and therefore
    `run_until_complete()` (called inside `asyncio.run()`) does *not* wait for the
    executor task to finish. The `RuntimeError` is being raised from the internal
    `loop.close()` call made inside `asyncio.run()`.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的是，在幕后，`run_in_executor()`并*不*创建一个`Task`实例：它返回一个`Future`。这意味着它不包括在“活动任务”集合中，这些任务会在`asyncio.run()`内部被取消，因此`run_until_complete()`（在`asyncio.run()`内部调用）不会等待执行器任务完成。`RuntimeError`是由`asyncio.run()`内部的`loop.close()`调用引发的。
- en: 'At the time of writing, `loop.close()` in Python 3.8 does not wait for all
    executor jobs to finish, and this is why the `Future` returned from `run_in_executor()`
    complains: by the time it resolves, the loop has already been closed. There are
    discussions about how to improve this in the core Python dev team, but until a
    solution has been settled on, you’re going to need a strategy for handling these
    errors.'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写时，Python 3.8中的`loop.close()`不会等待所有执行器作业完成，这就是为什么`run_in_executor()`返回的`Future`抱怨的原因：在它解析完成时，循环已经关闭了。关于如何改进这一点，Python核心开发团队正在讨论，但在找到解决方案之前，你需要一种处理这些错误的策略。
- en: Tip
  id: totrans-596
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: In Python 3.9, the `asyncio.run()` function [has been improved](https://oreil.ly/ZrpRb)
    to correctly wait for executor shutdown, but at the time of writing, this has
    not yet been backported to Python 3.8.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3.9中，`asyncio.run()`函数已经[得到改进](https://oreil.ly/ZrpRb)，正确等待执行器关闭，但在编写时，这个改进尚未回溯到Python
    3.8。
- en: Several ideas for fixing this spring to mind, all with different trade-offs,
    and we’re going to look at a few of them. My real goal for this exercise is to
    help you think about the event loop life cycle from different points of view,
    considering the lifetime management of all the coroutines, threads, and subprocesses
    that might be interoperating in a nontrivial program.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个修复这个问题的想法，每个都有不同的权衡，我们将看一些。我在这个练习中真正的目标是帮助你从不同的角度考虑事件循环的生命周期，考虑所有可能在非平凡程序中相互操作的协程、线程和子进程的生命周期管理。
- en: The first idea—and the easiest to implement, as shown in [Example 3-37](#wrapexecoro)—
    is to always `await` an executor task from inside a coroutine.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个想法——也是最容易实现的，如[示例 3-37](#wrapexecoro)所示——是总是在协程内部`await`执行器任务。
- en: 'Example 3-37\. Option A: wrap the executor call inside a coroutine'
  id: totrans-600
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-37\. 选项 A：将执行器调用包装在协程内部
- en: '[PRE49]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO32-1)'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO32-1)'
- en: The idea aims at fixing the shortcoming that `run_in_executor()` returns only
    a `Future` instance and not a task. We can’t capture the job in `all_tasks()`
    (used within `asyncio.run()`), but we *can* use `await` on the future. The first
    part of the plan is to create a future inside the `main()` function.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法旨在解决`run_in_executor()`仅返回`Future`实例而不是任务的缺陷。我们无法在`all_tasks()`中捕获这个作业（在`asyncio.run()`内使用），但我们可以在future上使用`await`。计划的第一部分是在`main()`函数内创建一个future。
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO32-2)'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO32-2)'
- en: We can use the `try/finally` structure to ensure that we wait for the future
    to be finished before the `main()` function returns.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`try/finally`结构确保在`main()`函数返回之前等待future完成。
- en: 'The code works, but it places a heavy limitation on lifetime management of
    the executor function: it implies that you must use a `try/finally` within every
    single scope where an executor job is created. We would prefer to spawn executor
    jobs in the same way that we create async tasks, and still have the shutdown handling
    inside `asyncio.run()` perform a graceful exit.'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 代码能够正常运行，但它对执行器函数的生命周期管理施加了严重限制：这意味着你必须在每一个创建执行器作业的作用域内使用`try/finally`。我们更希望像创建异步任务一样生成执行器作业，并且仍然可以在`asyncio.run()`内部进行优雅的退出处理。
- en: The next idea, shown in [Example 3-38](#addfuturealltasks), is a little more
    cunning. Since our problem is that an executor creates a future instead of a task,
    and the shutdown handling inside `asyncio.run()` deals with tasks, our next plan
    is to wrap the future (produced by the executor) inside a new task object.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个想法，如[示例 3-38](#addfuturealltasks)所示，更加狡猾一些。由于我们的问题在于执行器创建了一个future而不是任务，并且`asyncio.run()`内部的关闭处理处理的是任务，我们的下一个计划是将执行器产生的future包装在一个新的任务对象中。
- en: 'Example 3-38\. Option B: add the executor future to the gathered tasks'
  id: totrans-608
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-38\. 选项 B：将执行器future添加到收集的任务中
- en: '[PRE50]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO33-2)'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO33-2)'
- en: We take the future returned from the `run_in_executor()` call and pass it into
    a new utility function, `make_coro()`. The important point here is that we’re
    using `create_task()`, which means that this task *will* appear in the list of
    `all_tasks()` within the shutdown handling of `asyncio.run()`, and will receive
    a cancellation during the shutdown process.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取从`run_in_executor()`调用返回的未来，并将其传递给一个新的实用函数`make_coro()`。这里的重要点在于我们使用了`create_task()`，这意味着该任务将出现在`asyncio.run()`的关闭处理中的`all_tasks()`列表中，并且在关闭过程中将收到取消。
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO33-1)'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO33-1)'
- en: This utility function `make_coro()` simply waits for the future to complete—but
    crucially, it *continues to wait* for the future even inside the exception handler
    for `CancelledError`.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实用函数`make_coro()`简单地等待未来完成——但关键是，它*继续等待*未来，即使在处理`CancelledError`的异常处理程序中也是如此。
- en: This solution is better behaved during shutdown, and I encourage you to run
    the example and hit Ctrl-C immediately after “Hello!” is printed. The shutdown
    process will still wait for `make_coro()` to exit, which means that it also waits
    for our executor job to exit. However, this code is very clumsy because you have
    to wrap every executor `Future` instance inside a `make_coro()` call.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案在关闭过程中表现更加良好，我鼓励您运行示例并在打印“Hello！”后立即按Ctrl-C。关闭过程仍将等待`make_coro()`退出，这意味着它也等待我们的执行器作业退出。然而，这段代码非常笨拙，因为您必须在`make_coro()`调用中将每个执行器`Future`实例包装起来。
- en: If we’re willing to give up the convenience of the `asyncio.run()` function
    (until Python 3.9 is available), we can do better with custom loop handling, shown
    in [Example 3-39](#customexewait).
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意放弃`asyncio.run()`函数的便利性（直到Python 3.9可用），我们可以通过自定义循环处理做得更好，如[示例 3-39](#customexewait)所示。
- en: 'Example 3-39\. Option C: just like camping, bring your own loop and your own
    executor'
  id: totrans-616
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例3-39\. 选项C：就像露营一样，带上自己的循环和执行器
- en: '[PRE51]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[![1](assets/1.png)](#co_asyncio_walk_through_CO34-1)'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asyncio_walk_through_CO34-1)'
- en: This time, we create our own executor instance.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们创建了我们自己的执行器实例。
- en: '[![2](assets/2.png)](#co_asyncio_walk_through_CO34-2)'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asyncio_walk_through_CO34-2)'
- en: We have to set our custom executor as the default one for the loop. This means
    that anywhere the code calls `run_in_executor()`, it’ll be using our custom instance.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将我们的自定义执行器设置为循环的默认执行器。这意味着无论代码在何处调用`run_in_executor()`，都将使用我们的自定义实例。
- en: '[![3](assets/3.png)](#co_asyncio_walk_through_CO34-3)'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asyncio_walk_through_CO34-3)'
- en: As before, we run the blocking function.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 就像以前一样，我们运行阻塞函数。
- en: '[![4](assets/4.png)](#co_asyncio_walk_through_CO34-4)'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asyncio_walk_through_CO34-4)'
- en: Finally, we can explicitly wait for all the executor jobs to finish before closing
    the loop. This will avoid the “Event loop is closed” messages that we saw before.
    We can do this because we have access to the executor object; the default executor
    is not exposed in the `asyncio` API, which is why we cannot call `shutdown()`
    on it and were forced to create our own executor instance.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在关闭循环之前，我们可以显式等待所有执行器作业完成。这样可以避免之前看到的“事件循环已关闭”消息。我们之所以能够这样做，是因为我们可以访问执行器对象；默认执行器在`asyncio`
    API中未公开，这就是为什么我们无法对其调用`shutdown()`并被迫创建自己的执行器实例的原因。
- en: 'Finally, we have a strategy with general applicability: you can call `run_in_executor()`
    anywhere, and your program will still shut down cleanly, even if executor jobs
    are still running after all the async tasks have completed.'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一种普遍适用的策略：无论何时调用`run_in_executor()`，您的程序仍将进行干净关闭，即使在所有异步任务完成后仍有执行器作业在运行。
- en: I strongly urge you to experiment with the code examples shown here and try
    different strategies to create tasks and executor jobs, staggering them in time
    and trying to shut down cleanly. I expect that a future version of Python will
    allow the `asyncio.run()` function to wait (internally) for executor jobs to finish,
    but I hope that the discussion in this section is still useful for you to develop
    your thinking around clean shutdown handling.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议您尝试这里显示的代码示例，并尝试使用不同的策略创建任务和执行器作业，分时执行并尝试清洁关闭。我期待Python的未来版本将允许`asyncio.run()`函数内部等待执行器作业完成，但我希望本节中的讨论仍对您开发围绕清洁关闭处理的思路有所帮助。
- en: ^([1](ch03.html#idm46363038714696-marker)) When they become available! At the
    time of writing, the only available references for Asyncio were the API specification
    in the official Python documentation and a collection of blog posts, several of
    which have been linked to in this book.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.html#idm46363038714696-marker)) 当它们可用时！撰写本文时，Asyncio 的唯一可用参考资料是官方
    Python 文档中的 API 规范和一系列博客文章，其中本书中链接了几篇。
- en: ^([2](ch03.html#idm46363038459208-marker)) The `asyncio` API lets you do lots
    of wild things with multiple loop instances and threads, but this is not the right
    book to get into that. 99% of the time you’re going to use only a single, main
    thread for your app, as shown here.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch03.html#idm46363038459208-marker)) `asyncio` API 允许你用多个循环实例和线程做很多疯狂的事情，但这不是一个讨论这些内容的合适的书籍。99%的情况下，你只会为你的应用程序使用一个单一的主线程，就像这里展示的那样。
- en: ^([3](ch03.html#idm46363038400376-marker)) Using the parameter name *`coro`*
    is a common convention in the API documentation. It refers to a *coroutine*; i.e.,
    strictly speaking, the *result* of calling an `async def` function, and *not*
    the function itself.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch03.html#idm46363038400376-marker)) 在 API 文档中，使用参数名*`coro`*是一种常见的约定。它指的是一个*协程*；也就是说，严格来说，是调用`async
    def`函数的*结果*，而*不是*函数本身。
- en: ^([4](ch03.html#idm46363038125400-marker)) Unfortunately, the first parameter
    of `run_in_executor()` is the `Executor` instance to use, and you *must* pass
    `None` in order to use the default. Every time I use this, it feels like the “executor”
    parameter is crying out to be a kwarg with a default value of `None`.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch03.html#idm46363038125400-marker)) 不幸的是，`run_in_executor()`的第一个参数是要使用的`Executor`实例，而你*必须*传递`None`才能使用默认值。每次我使用这个时，感觉“executor”参数都在呼唤着要成为一个带有默认值为`None`的关键字参数。
- en: ^([5](ch03.html#idm46363037762200-marker)) And furthermore, this is how other
    open source libraries such as Twisted and Tornado have exposed async support in
    the past.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch03.html#idm46363037762200-marker)) 而且，其他开源库（如 Twisted 和 Tornado）过去是这样暴露异步支持的。
- en: ^([6](ch03.html#idm46363033404616-marker)) Also acceptable is a legacy, generator-based
    coroutine, which is a generator function that is decorated with `@types.coroutine`
    and uses the `yield from` keyword internally to suspend. We are going to completely
    ignore legacy coroutines in this book. Erase them from your mind!
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch03.html#idm46363033404616-marker)) 还可以接受的是基于生成器的旧版协程，它是一个被`@types.coroutine`装饰并在内部使用`yield
    from`关键字挂起的生成器函数。在本书中，我们将完全忽略旧版协程。请把它们从你的脑海中抹去！
- en: '^([7](ch03.html#idm46363032184744-marker)) The documentation is inconsistent
    here: the signature is given as `AbstractEventLoop.run_until_complete`(*`future`*),
    but it really should be `AbstractEventLoop.run_until_complete`(*`coro_or_future`*)
    as the same rules apply.'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch03.html#idm46363032184744-marker)) 这里的文档不一致：签名给出的是 `AbstractEventLoop.run_until_complete`(*`future`*)，但实际上应该是
    `AbstractEventLoop.run_until_complete`(*`coro_or_future`*)，因为相同的规则适用。
- en: ^([8](ch03.html#idm46363031039256-marker)) Async support can be quite difficult
    to add to an existing framework after the fact since large structural changes
    to the codebase might be needed. This was discussed in a [GitHub issue for `requests`](https://oreil.ly/we5cZ).
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch03.html#idm46363031039256-marker)) 在事后给现有框架添加异步支持可能会非常困难，因为可能需要对代码库进行大规模的结构性更改。这在一个[用于
    `requests` 的 GitHub 问题](https://oreil.ly/we5cZ)中有所讨论。
- en: ^([9](ch03.html#idm46363030900744-marker)) Yes, this is super annoying. Every
    time I use this call, I can’t help wondering why the more common idiom of using
    `executor=None` as a keyword argument was not preferred.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch03.html#idm46363030900744-marker)) 是的，这真的很烦人。每次我使用这个调用时，我都不禁想知道为什么更常见的习惯用法，即将`executor=None`作为关键字参数，不被优先选择。
- en: ^([10](ch03.html#idm46363028180248-marker)) `add_signal_handler()` should probably
    be named `set_signal_handler()`, since you can have only one handler per signal
    type; calling `add_signal_handler()` a second time for the same signal will replace
    the existing handler for that signal.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch03.html#idm46363028180248-marker)) `add_signal_handler()`可能应该被命名为`set_signal_handler()`，因为你每个信号类型只能有一个处理程序；对于同一个信号再次调用`add_signal_handler()`将替换该信号的现有处理程序。
