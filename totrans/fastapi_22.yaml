- en: Chapter 18\. Games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Preview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Games cover a lot of ground, from simple text to multiplayer 3D extravaganzas.
    This chapter will demonstrate a simple game and how the web endpoint can interact
    with the user across multiple steps. This process is different from the familiar
    one-shot request-response web endpoints that you’ve seen so far.
  prefs: []
  type: TYPE_NORMAL
- en: Python Game Packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you really want to get into Python for games, here are some useful tools:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Text:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Adventurelib](https://adventurelib.readthedocs.io)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Graphic:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PyGame](https://www.pygame.org), [primer](https://realpython.com/pygame-a-primer)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[pyglet](https://pyglet.org)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Python Arcade](https://api.arcade.academy)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[HARFANG](https://www.harfang3d.com)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Panda3D](https://docs.panda3d.org)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'But I’m not going to use any of these in this chapter. The example code can
    get so large and complex that it overshadows the goal of this book: creating websites—APIs
    and traditional content—with FastAPI, as simply as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: Splitting Game Logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are so many ways to write a game. Who does what, and who keeps what where—the
    client or the server? The web is stateless, so each time the client calls the
    server, the server is a total amnesiac and swears it’s never seen this client
    before. So we need to keep *state* somewhere: data retained across game steps
    to thread them all together.'
  prefs: []
  type: TYPE_NORMAL
- en: We could write a game completely in JavaScript on the client side, and keep
    all the state there. If you know JavaScript well, that’s a good solution, but
    if you don’t (a possibility, because you’re reading a Python book), let’s give
    Python something to do too.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the other extreme, we could write a server-heavy application: generate some
    distinct id for this particular game on an initial web call, and pass that id
    with other data to the server in subsequent game steps, and maintain all that
    changing state in some server-side data store, like a database.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we could structure the game as a sequence of client-server web endpoint
    calls, in a so-called single-page application (SPA). Writing an SPA would typically
    have JavaScript making Ajax calls to a server, and targeting the web responses
    to refresh parts of the page instead of the whole display. The client JavaScript
    and HTML do some of the work, and the server handles some of the logic and data.
  prefs: []
  type: TYPE_NORMAL
- en: Game Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, what’s the game? We’ll build a simple [Wordle-like game](https://oreil.ly/PuD-Y),
    but using only the names of the creatures from the *cryptid.db* database. This
    makes it quite a bit easier than Wordle, especially if you cheat and look at [Appendix B](app02.html#app02).
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use the final, balanced, design approach above:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use vanilla JavaScript in the client instead of well-known JavaScript
    libraries like React, Angular, or even jQuery.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new FastAPI endpoint, GET `/game`, initializes the game. It gets a random
    creature’s name from our cryptid database, and returns that, embedded as a hidden
    value in a Jinja template file of HTML, CSS, and JavaScript.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the client, the newly returned HTML and JavaScript display a Wordle-type
    interface. A sequence of boxes appears, one for each letter in the hidden creature
    name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The player types a letter into each box, then submits this guess and the hidden
    true name to the server. This is in an AJAX call, using the JavaScript `fetch()`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A second new FastAPI endpoint, POST `/game`, takes this guess and actual secret
    name and scores the guess against that name. It returns the guess and score to
    the client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The client displays the guess and score with appropriate CSS colors in a newly
    generated table row: green for a letter in the correct place, yellow for a letter
    in the name but another position, and gray for a letter not occurring in the hidden
    name. The score is a string of single characters, which are used as CSS class
    names to display the correct colors for the guess’s letters.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all the letters are green, then celebrate accordingly. Otherwise, the client
    displays a new sequence of text input boxes for the next guess, and repeats the
    steps 4 and later until the name is guessed or you give up. Most of the cryptid
    names are not household words, so check [Appendix B](app02.html#app02) as needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These rules are slightly different from official Wordle, which allows only five-letter
    dictionary words and a limit of six steps.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t get your hopes up. Like most of the examples in this book, the game logic
    and design are minimal—just enough to get the pieces to work together. You can
    impart much more style and grace, given a working base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Web Part One: Game Initialization'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want two new web endpoints. We’re using creature names, so we might think
    of naming endpoints like GET `/creature/game` and POST `/creature/game`. But that
    won’t work, because we already have similar endpoints GET `/creature/{name}` and
    POST `/creature/{name}`, and FastAPI will match those first. So let’s make a new
    top-level routing namespace `/game`, and place both new endpoints under it.
  prefs: []
  type: TYPE_NORMAL
- en: The first endpoint in [Example 18-1](#ex1801) initializes the game. It needs
    to get a random creature name from the database, and return this with all the
    client code to implement the multistep game logic. For this, we’ll use a Jinja
    template (which you saw in [Chapter 16](ch16.html#ch16)) that contains HTML, CSS,
    and JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-1\. Web game initialization (web/game.py)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: FastAPI requires the `game_start()` path function to have a `request` parameter,
    and to pass it to the template as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in [Example 18-2](#ex1802), hook this `/game` subrouter into the main
    module that has been overseeing the `/explorer` and `/creature` routes.
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-2\. Add /game subroute (web/main.py)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Web Part Two: Game Steps'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The largest component of the client side template (HTML, CSS, and JavaScript)
    can be seen in [Example 18-3](#ex1803).
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-3\. Working Jinja template file (template/game.html)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Service Part One: Initialization'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Example 18-4](#ex1804) shows the Service code to connect the Web layer’s game
    start function to the Data layer’s provision of a random creature name.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-4\. Calculate score (service/game.py)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Service Part Two: Scoring'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add the code from [Example 18-5](#ex1805) (next) to that of [Example 18-4](#ex1804).
    The score is a string of single characters that indicate whether the guessed letter
    matched in the correct position, matched in another position, or was a miss. The
    guess and word are both converted to lowercase to make matching case-insensitive.
    If the guess is not the same length as the hidden word, an empty string score
    is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-5\. Calculate score (service/game.py)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Test!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Example 18-6](#ex1806) contains some pytest exercises for the service score
    calculation. It uses pytest’s `parametrize` feature to pass in a sequence of tests,
    rather than writing a loop inside the test function itself. Remember from [Example 18-5](#ex1805)
    that `H` is a direct hit, `C` is close (wrong position), and `M` is a miss.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-6\. Test score calculation (test/unit/service/test_game.py)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Data: Initialization'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We only need one function in the new *data/game.py* module, shown in [Example 18-7](#ex1807).
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-7\. Get random creature name (data/game.py)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let’s Play Cryptonamicon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: (Someone, please come up with a better name.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In your browser, go to `http://localhost:8000/game`. You should see an initial
    display like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![fapi 18in01](assets/fapi_18in01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s type a few letters and submit them as a guess to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![fapi 18in02](assets/fapi_18in02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The letters *b*, *f*, and *g* are yellow (if you’re not viewing this in color,
    you’ll have to take my word for it!), meaning they’re in the hidden name but in
    the wrong position:'
  prefs: []
  type: TYPE_NORMAL
- en: '![fapi 18in03](assets/fapi_18in03.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s take a stab at the name, but flub the last letter. We see lots of green
    on the second line. Oh, so close!
  prefs: []
  type: TYPE_NORMAL
- en: '![fapi 18in04](assets/fapi_18in04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s fix that last letter, and just for fun, capitalize some of the letters
    to ensure that we get case-insensitive matching. Submit that one now, and golly
    gee:'
  prefs: []
  type: TYPE_NORMAL
- en: '![fapi 18in05](assets/fapi_18in05.png)'
  prefs: []
  type: TYPE_IMG
- en: Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used HTML, JavaScript, CSS, and FastAPI to build a (very!) simple interactive
    Wordle-style game. This chapter demonstrated how to manage multiple threaded conversations
    between a web client and server, using JSON and Ajax.
  prefs: []
  type: TYPE_NORMAL
