- en: Chapter 2\. Extending Our Functional Test Using the unittest Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s adapt our test, which currently checks for the default Django “it worked”
    page, and check instead for some of the things we want to see on the real front
    page of our site.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to reveal what kind of web app we’re building: a to-do lists site! I know,
    I know, every other web dev tutorial online is also a to-do lists app, or maybe
    a blog or a polls app. I’m very much following fashion.'
  prefs: []
  type: TYPE_NORMAL
- en: The reason is that a to-do list is a really nice example. At its most basic
    it is very simple indeed—​just a list of text strings—​so it’s easy to get a “minimum
    viable” list app up and running. But it can be extended in all sorts of ways—​different
    persistence models, adding deadlines, reminders, sharing with other users, and
    improving the client-side UI. There’s no reason to be limited to just “to-do”
    lists either; they could be any kind of lists. But the point is that it should
    allow me to demonstrate all of the main aspects of web programming, and how you
    apply TDD to them.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Functional Test to Scope Out a Minimum Viable App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tests that use Selenium let us drive a real web browser, so they really let
    us see how the application *functions* from the user’s point of view. That’s why
    they’re called *functional tests*.
  prefs: []
  type: TYPE_NORMAL
- en: This means that an FT can be a sort of specification for your application. It
    tends to track what you might call a *User Story*, and follows how the user might
    work with a particular feature and how the app should respond to them.
  prefs: []
  type: TYPE_NORMAL
- en: FTs should have a human-readable story that we can follow. We make it explicit
    using comments that accompany the test code. When creating a new FT, we can write
    the comments first, to capture the key points of the User Story. Being human-readable,
    you could even share them with nonprogrammers, as a way of discussing the requirements
    and features of your app.
  prefs: []
  type: TYPE_NORMAL
- en: TDD and agile or lean software development methodologies often go together,
    and one of the things we often talk about is the minimum viable app; what is the
    simplest thing we can build that is still useful? Let’s start by building that,
    so that we can test the water as quickly as possible.
  prefs: []
  type: TYPE_NORMAL
- en: A minimum viable to-do list really only needs to let the user enter some to-do
    items, and remember them for their next visit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up *functional_tests.py* and write a story a bit like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: functional_tests.py (ch02l001)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You’ll notice that, apart from writing the test out as comments, I’ve updated
    the `assert` to look for the word “To-Do” instead of Django’s “Congratulations”.
    That means we expect the test to fail now. Let’s try running it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, start up the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, in another terminal, run the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: That’s what we call an *expected fail*, which is actually good news—​not quite
    as good as a test that passes, but at least it’s failing for the right reason;
    we can have some confidence we’ve written the test correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The Python Standard Library’s unittest Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a couple of little annoyances we should probably deal with. Firstly,
    the message “AssertionError” isn’t very helpful—​it would be nice if the test
    told us what it actually found as the browser title. Also, it’s left a Firefox
    window hanging around the desktop, so it would be nice if that got cleared up
    for us automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option would be to use the second parameter of the `assert` keyword, something
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: And we could also use a `try/finally` to clean up the old Firefox window.
  prefs: []
  type: TYPE_NORMAL
- en: 'But these sorts of problems are quite common in testing, and there are some
    ready-made solutions for us in the standard library’s `unittest` module. Let’s
    use that! In *functional_tests.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: functional_tests.py (ch02l003)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll probably notice a few things here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_extending_our_functional_test_using___span_class__keep_together__the_unittest_module__span__CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Tests are organised into classes, which inherit from `unittest.TestCase`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_extending_our_functional_test_using___span_class__keep_together__the_unittest_module__span__CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The main body of the test is in a method called `test_can_start_a_todo_list`.
    Any method whose name starts with `test_` is a test method, and will be run by
    the test runner. You can have more than one `test_` method per class. Nice descriptive
    names for our test methods are a good idea too.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_extending_our_functional_test_using___span_class__keep_together__the_unittest_module__span__CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`setUp` and `tearDown` are special methods which get run before and after each
    test. I’m using them to start and stop our browser. They’re a bit like a `try/finally`,
    in that `tearDown` will run even if there’s an error during the test itself.^([1](ch02.xhtml#id222))
    No more Firefox windows left lying around!'
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_extending_our_functional_test_using___span_class__keep_together__the_unittest_module__span__CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '`browser`, which was previously a global variable, becomes `self.browser`,
    an attribute of the test class. This lets us pass it between `setUp`, `tearDown`,
    and the test method itself.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_extending_our_functional_test_using___span_class__keep_together__the_unittest_module__span__CO1-7)'
  prefs: []
  type: TYPE_NORMAL
- en: We use `self.assertIn` instead of just `assert` to make our test assertions.
    `unittest` provides lots of helper functions like this to make test assertions,
    like `assertEqual`, `assertTrue`, `assertFalse`, and so on. You can find more
    in the [`unittest` documentation](http://docs.python.org/3/library/unittest.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_extending_our_functional_test_using___span_class__keep_together__the_unittest_module__span__CO1-8)'
  prefs: []
  type: TYPE_NORMAL
- en: '`self.fail` just fails no matter what, producing the error message given. I’m
    using it as a reminder to finish the test.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_extending_our_functional_test_using___span_class__keep_together__the_unittest_module__span__CO1-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have the `if __name__ == '__main__'` clause (if you’ve not seen
    it before, that’s how a Python script checks if it’s been executed from the command
    line, rather than just imported by another script). We call `unittest.main()`,
    which launches the `unittest` test runner, which will automatically find test
    classes and methods in the file and run them.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you’ve read the Django testing documentation, you might have seen something
    called `LiveServerTestCase`, and are wondering whether we should use it now. Full
    points to you for reading the friendly manual! `LiveServerTestCase` is a bit too
    complicated for now, but I promise I’ll use it in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s try out our new and improved FT!^([2](ch02.xhtml#id223))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: That’s a bit nicer, isn’t it? It tidied up our Firefox window, it gives us a
    nicely formatted report of how many tests were run and how many failed, and the
    `assertIn` has given us a helpful error message with useful debugging info. Bonzer!
  prefs: []
  type: TYPE_NORMAL
- en: Commit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a good point to do a commit; it’s a nicely self-contained change. We’ve
    expanded our functional test to include comments that describe the task we’re
    setting ourselves, our minimum viable to-do list. We’ve also rewritten it to use
    the Python `unittest` module and its various testing helper functions.
  prefs: []
  type: TYPE_NORMAL
- en: Do a **`git status`**—that should assure you that the only file that has changed
    is *functional_tests.py*. Then do a **`git diff -w`**, which shows you the difference
    between the last commit and what’s currently on disk, with the `-w` saying “ignore
    whitespace changes”.
  prefs: []
  type: TYPE_NORMAL
- en: 'That should tell you that *functional_tests.py* has changed quite substantially:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s do a:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `-a` means “automatically add any changes to tracked files” (i.e., any files
    that we’ve committed before). It won’t add any brand new files (you have to explicitly
    `git add` them yourself), but often, as in this case, there aren’t any new files,
    so it’s a useful shortcut.
  prefs: []
  type: TYPE_NORMAL
- en: When the editor pops up, add a descriptive commit message, like “First FT specced
    out in comments, and now uses unittest.”
  prefs: []
  type: TYPE_NORMAL
- en: Now that our FT uses a real test framework, and that we’ve got placeholder comments
    for what we want it to do, we’re in an excellent position to start writing some
    real code for our lists app. Read on!
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch02.xhtml#id222-marker)) The only exception is if you have an exception
    inside `setUp`, then `tearDown` doesn’t run.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch02.xhtml#id223-marker)) Are you unable to move on because you’re wondering
    what those *ch02l00x* things are, next to some of the code listings? They refer
    to specific [commits](https://github.com/hjwp/book-example/commits/chapter_02_unittest)
    in the book’s example repo. It’s all to do with my book’s own [tests](https://github.com/hjwp/Book-TDD-Web-Dev-Python/tree/master/tests).
    You know, the tests for the tests in the book about testing. They have tests of
    their own, naturally.
  prefs: []
  type: TYPE_NORMAL
