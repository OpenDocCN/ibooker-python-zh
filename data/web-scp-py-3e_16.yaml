- en: Chapter 14\. Scraping JavaScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章。JavaScript抓取
- en: Client-side scripting languages are languages that are run in the browser itself,
    rather than on a web server. The success of a client-side language depends on
    your browser’s ability to interpret and execute the language correctly.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端脚本语言是在浏览器内部而不是在Web服务器上运行的语言。客户端语言的成功取决于浏览器正确解释和执行语言的能力。
- en: 'While there are hundreds of server-side programming languages, there’s only
    one client-side programming language. This is because of the difficulty of getting
    every browser manufacturer to agree on a standard. This is a good thing when it
    comes to web scraping: the fewer languages there are to deal with, the better.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有数百种服务器端编程语言，但只有一种客户端编程语言。这是因为让每个浏览器制造商达成标准协议的难度很大。在进行网页抓取时，语言种类越少越好。
- en: Other Client-Side Programming Languages
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他客户端编程语言
- en: 'Some readers may take issue with the sentence: “There’s only one client-side
    programming language.” Technically, languages such as ActionScript and VBScript
    exist. However, these are no longer supported and, in the case of VBScript, was
    only ever supported by a single browser. For this reason, they are very rarely
    seen.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有些读者可能会对这句话提出异议：“只有一种客户端编程语言。”技术上存在ActionScript和VBScript等语言。然而，这些语言已不再受支持，并且在VBScript的情况下，仅被单个浏览器支持过。因此，它们很少被看到。
- en: If you want to be pedantic about it, absolutely anyone can make a new client-side
    programming language! There are likely many of them out there! The only issue
    is getting widespread support by browsers to make that language effective and
    put it into use by others.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想对此挑剔，任何人都可以创建新的客户端编程语言！可能有很多这样的语言存在！唯一的问题是得到浏览器的广泛支持，使该语言有效并被其他人使用。
- en: 'Some have also argued that CSS and HTML are programming languages in themselves.
    I agree with this in theory. Lara Schenck has an excellent and entertaining blog
    post on the subject: [*https://notlaura.com/is-css-turing-complete/*](https://notlaura.com/is-css-turing-complete/).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人还争论说CSS和HTML本身就是编程语言。在理论上我同意这一点。Lara Schenck在这个主题上有一篇出色而有趣的博客文章：[*https://notlaura.com/is-css-turing-complete/*](https://notlaura.com/is-css-turing-complete/)。
- en: However, in practice, CSS and HTML are generally treated as markup languages
    separate from “programming languages” and, besides, are covered extensively in
    this book.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实际操作中，CSS和HTML通常被视为与“编程语言”分开的标记语言，并且本书对它们有广泛的覆盖。
- en: 'JavaScript is, by far, the most common and most well-supported client-side
    scripting language on the web today. It can be used to collect information for
    user tracking, submit forms without reloading the page, embed multimedia, and
    even power entire online games. Even deceptively simple-looking pages often contain
    multiple pieces of JavaScript. You can find it embedded between `script` tags
    in the page’s source code:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是迄今为止在Web上最常见和最受支持的客户端脚本语言。它可以用于收集用户跟踪信息，无需重新加载页面即可提交表单，嵌入多媒体，甚至支持整个在线游戏。即使看似简单的页面通常也包含多个JavaScript片段。你可以在页面的源代码中的`script`标签之间找到它：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A Brief Introduction to JavaScript
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript简介
- en: Having at least some idea of what is going on in the code you are scraping can
    be immensely helpful. With that in mind, it’s a good idea to familiarize yourself
    with JavaScript.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您正在抓取的代码至少有一些了解是非常有帮助的。考虑到这一点，熟悉JavaScript是个好主意。
- en: '*JavaScript* is a weakly typed language, with a syntax that is often compared
    to C++ and Java. Although certain elements of the syntax, such as operators, loops,
    and arrays, might be similar, the weak typing and scriptlike nature of the language
    can make it a difficult beast for some programmers to deal with.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*JavaScript* 是一种弱类型语言，其语法经常与C++和Java进行比较。尽管语法的某些元素，如操作符、循环和数组，可能类似，但语言的弱类型和脚本化特性可能使它对某些程序员来说成为难以应付的“野兽”。'
- en: 'For example, the following recursively calculates values in the Fibonacci sequence
    up to 100 and prints them to the browser’s developer console:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下递归计算斐波那契数列的值，直到100，并将它们打印到浏览器的开发者控制台：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that all variables are identified by preceding them with `var`. This
    is similar to the `$` sign in PHP or the type declaration (`int`, `String`, `List`, etc.)
    in Java or C++. Python is unusual in that it doesn’t have this sort of explicit
    variable declaration.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有变量都是通过在其前面加上 `var` 来标识的。这类似于 PHP 中的 `$` 符号或 Java 或 C++ 中的类型声明（`int`、`String`、`List`
    等）。Python 不同之处在于它没有这种明确的变量声明。
- en: 'JavaScript is also good at passing functions around:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 也擅长传递函数：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This might seem daunting at first, but it becomes simple if you think in terms
    of lambda expressions (covered in [Chapter 5](ch05.html#c-5)). The variable `fibonacci` is
    defined as a function. The value of its function returns a function that prints
    increasingly large values in the Fibonacci sequence. Each time it is called, it
    returns the Fibonacci-calculating function, which executes again and increases
    the values in the function.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 起初可能会感到艰难，但如果你从 lambda 表达式的角度来思考（在 [第5章](ch05.html#c-5) 中介绍），问题就会变得简单起来。变量 `fibonacci`
    被定义为一个函数。它的函数值返回一个函数，该函数打印出 Fibonacci 序列中逐渐增大的值。每次调用它时，它返回计算 Fibonacci 的函数，并再次执行并增加函数中的值。
- en: 'You might also see functions like these written in the arrow syntax introduced
    in JavaScript ES6 (ECMAScript 6, introduced in 2015):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可能会看到像这样用 JavaScript ES6 引入的箭头语法编写的函数：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, I’m using the JavaScript keyword `const` to indicate a constant variable
    that will not be reassigned later. You might also see the keyword `let`, indicating
    a variable that may be reassigned. These were also introduced in ES6.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用 JavaScript 关键字 `const` 表示一个常量变量，它以后不会被重新分配。你可能还会看到关键字 `let`，表示可以重新分配的变量。这些关键字也是在
    ES6 中引入的。
- en: Passing around functions as variables is also extremely useful when it comes
    to handling user actions and callbacks, and it is worth getting comfortable with
    this style of programming when it comes to reading JavaScript.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数作为变量传递也在处理用户操作和回调时非常有用，当涉及阅读 JavaScript 时，习惯这种编程风格是值得的。
- en: Common JavaScript Libraries
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见的 JavaScript 库
- en: Although the core JavaScript language is important to know, you can’t get far
    on the modern web without using at least one of the language’s many third-party
    libraries. You might see one or more of these commonly used libraries when looking
    at page source code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管核心 JavaScript 语言很重要，但在现代网络上，如果不使用该语言的众多第三方库之一，你无法走得太远。查看页面源代码时，你可能会看到一种或多种常用的库。
- en: Executing JavaScript by using Python can be extremely time-consuming and processor
    intensive, especially if you’re doing it on a large scale. Knowing your way around
    JavaScript and being able to parse it directly (without needing to execute it
    to acquire the information) can be extremely useful and save you a lot of headaches.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Python 执行 JavaScript 可能会非常耗时和处理器密集，特别是在大规模执行时。熟悉 JavaScript 并能够直接解析它（而无需执行以获取信息）可能非常有用，并且能节省你大量麻烦。
- en: jQuery
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: jQuery
- en: '*jQuery* is an extremely common library, used by more than 70% of all websites.^([1](ch14.html#id730)).
    A site using jQuery is readily identifiable because it will contain an import
    to jQuery somewhere in its code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*jQuery* 是一种极为常见的库，被超过 70% 的网站使用^([1](ch14.html#id730))。使用 jQuery 的网站很容易识别，因为它的代码中某处会包含对
    jQuery 的导入：'
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If jQuery is found on a site, you must be careful when scraping it. jQuery is
    adept at dynamically creating HTML content that appears only after the JavaScript
    is executed. If you scrape the page’s content by using traditional methods, you
    will retrieve only the preloaded page that appears before the JavaScript has created
    the content (this scraping problem is covered in more detail in [“Ajax and Dynamic
    HTML”](#ajax_dynamic_html)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在网站上找到了 jQuery，你在进行抓取时必须小心。jQuery 擅长动态创建 HTML 内容，这些内容仅在执行 JavaScript 后才出现。如果使用传统方法抓取页面内容，你只能获取到在
    JavaScript 创建内容之前预加载的页面（这个抓取问题在 [“Ajax 和动态 HTML”](#ajax_dynamic_html) 中有更详细的讨论）。
- en: In addition, these pages are more likely to contain animations, interactive
    content, and embedded media that might make scraping challenging.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这些页面更有可能包含动画、交互内容和嵌入媒体，这可能会使抓取变得更具挑战性。
- en: Google Analytics
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Google Analytics
- en: '*Google Analytics* is used by about 50% of all websites,^([2](ch14.html#id733))
    making it perhaps the most common JavaScript library and the most popular user
    tracking tool on the internet. Both [*http://pythonscraping.com*](http://pythonscraping.com)
    and [*http://www.oreilly.com/*](http://www.oreilly.com/) use Google Analytics.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*Google Analytics* 被大约 50% 的所有网站使用^([2](ch14.html#id733))，使其成为可能是互联网上最常见的 JavaScript
    库和最受欢迎的用户跟踪工具。[*http://pythonscraping.com*](http://pythonscraping.com) 和 [*http://www.oreilly.com/*](http://www.oreilly.com/)
    均使用 Google Analytics。'
- en: 'Determining whether a page is using Google Analytics is easy. It will have
    JavaScript at the bottom, similar to the following (taken from the O’Reilly Media
    site):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 确定页面是否使用 Google Analytics 很容易。它将在底部具有类似以下内容的 JavaScript（摘自 O’Reilly Media 网站）：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This script handles Google Analytics-specific cookies used to track your visit
    from page to page. This can sometimes be a problem for web scrapers that are designed
    to execute JavaScript and handle cookies (such as those that use Selenium, discussed
    later in this chapter).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本处理了用于跟踪您从页面到页面访问的 Google Analytics 特定 cookie。对于那些设计为执行 JavaScript 和处理 cookie（例如稍后在本章中讨论的
    Selenium 使用的那些）的网络爬虫，这有时可能会成为一个问题。
- en: If a site uses Google Analytics or a similar web analytics system, and you do
    not want the site to know that it’s being crawled or scraped, make sure to discard
    any cookies used for analytics or discard cookies altogether.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网站使用 Google Analytics 或类似的 Web 分析系统，而您不希望该网站知道它正在被爬取或抓取，则确保丢弃任何用于分析的 cookie
    或完全丢弃 cookie。
- en: Google Maps
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Google 地图
- en: If you’ve spent any time on the internet, you’ve almost certainly seen *Google
    Maps* embedded in a website. Its API makes it extremely easy to embed maps with
    custom information on any site.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在互联网上花费了一些时间，几乎可以肯定地看到嵌入到网站中的 *Google 地图*。其 API 使得在任何网站上轻松嵌入具有自定义信息的地图成为可能。
- en: If you’re scraping any sort of location data, understanding how Google Maps
    works makes it easy to obtain well-formatted latitude/longitude coordinates and
    even addresses. One of the most common ways to denote a location in Google Maps
    is through a *marker* (also known as a *pin*).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在抓取任何类型的位置数据，了解 Google 地图的工作原理将使您能够轻松获取格式良好的纬度/经度坐标，甚至地址。在 Google 地图中表示位置的最常见方式之一是通过
    *标记*（也称为 *图钉*）。
- en: 'Markers can be inserted into any Google Map by using code such as:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 标记可以通过以下代码插入到任何 Google 地图中：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Python makes it easy to extract all instances of coordinates that occur between
    `google.maps.LatLng(` and `)` to obtain a list of latitude/longitude coordinates.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Python 使得可以轻松提取在 `google.maps.LatLng(` 和 `)` 之间发生的所有坐标实例，以获取纬度/经度坐标列表。
- en: Using [Google’s Reverse Geocoding API](https://developers.google.com/maps/documentation/javascript/examples/geocoding-reverse),
    you can resolve these coordinate pairs to addresses that are well formatted for
    storage and analysis.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [Google 逆地理编码 API](https://developers.google.com/maps/documentation/javascript/examples/geocoding-reverse)，您可以将这些坐标对解析为适合存储和分析的地址。
- en: Ajax and Dynamic HTML
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ajax 和动态 HTML
- en: Until now, the only way we’ve had of communicating with a web server is to send
    it some sort of HTTP request via the retrieval of a new page. If you’ve ever submitted
    a form or retrieved information from a server without reloading the page, you’ve
    likely used a website that uses Ajax.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们与 web 服务器通信的唯一方法是通过检索新页面发送某种 HTTP 请求。如果您曾经提交过表单或在不重新加载页面的情况下从服务器检索信息，那么您可能使用过使用
    Ajax 的网站。
- en: Contrary to what some believe, Ajax is not a language but a group of technologies
    used to accomplish a certain task (much like web scraping, come to think of it). *Ajax*
    stands for *Asynchronous JavaScript and XML* and is used to send information to
    and receive it from a web server without making a separate page request.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与一些人的观点相反，Ajax 不是一种语言，而是一组用于完成特定任务的技术（与网页抓取类似）。*Ajax* 代表 *异步 JavaScript 和 XML*，用于向
    web 服务器发送信息并接收信息，而无需发出单独的页面请求。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You should never say, “This website will be written in Ajax.” It would be correct
    to say, “This website will use Ajax to communicate with the web server.”
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您不应该说，“这个网站将用 Ajax 编写。”而应该说，“这个网站将使用 Ajax 与 web 服务器通信。”
- en: Like Ajax, *dynamic HTML* (DHTML) is a collection of technologies used for a
    common purpose. DHTML is HTML code, CSS language, or both that changes as client-side
    scripts change HTML elements on the page. A button might appear only after the
    user moves the cursor, a background color might change on a click, or an Ajax
    request might trigger a new block of content to load.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Ajax 一样，*动态 HTML*（DHTML）是用于共同目的的一组技术。DHTML 是 HTML 代码、CSS 语言或两者的组合，它随着客户端脚本在页面上改变
    HTML 元素而改变。例如，当用户移动鼠标时，可能会出现一个按钮，点击时可能会改变背景颜色，或者 Ajax 请求可能会触发加载一个新的内容块。
- en: Note that although the word “dynamic” is generally associated with words like
    “moving,” or “changing” the presence of interactive HTML components, moving images,
    or embedded media does not necessarily make a page DHTML, even though it might
    look dynamic. In addition, some of the most boring, static-looking pages on the
    internet can have DHTML processes running behind the scenes that depend on the
    use of JavaScript to manipulate the HTML and CSS.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管“动态”一词通常与“移动”或“变化”等词语相关联，交互式 HTML 组件的存在、移动图像或嵌入式媒体并不一定使页面成为 DHTML 页面，尽管它可能看起来很动态。此外，互联网上一些看起来最无聊、最静态的页面背后可能运行着依赖于
    JavaScript 来操作 HTML 和 CSS 的 DHTML 进程。
- en: If you scrape many websites, you will soon run into a situation in which the
    content you are viewing in your browser does not match the content you see in
    the source code you’re retrieving from the site. You might view the output of
    your scraper and scratch your head, trying to figure out where everything you’re
    seeing on the exact same page in your browser has disappeared to.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你经常爬取多个网站，很快你就会遇到这样一种情况：你在浏览器中看到的内容与你从网站源代码中检索到的内容不匹配。当你查看爬虫的输出时，可能会摸不着头脑，试图弄清楚为什么你在浏览器上看到的内容在网页源代码中竟然找不到。
- en: The web page might also have a loading page that appears to redirect you to
    another page of results, but you’ll notice that the page’s URL never changes when
    this redirect happens.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 该网页还可能有一个加载页面，看起来似乎会将您重定向到另一个结果页面，但您会注意到，当此重定向发生时，页面的 URL 没有发生变化。
- en: Both of these are caused by a failure of your scraper to execute the JavaScript
    that is making the magic happen on the page. Without the JavaScript, the HTML
    just sort of sits there, and the site might look very different from what it looks
    like in your web browser, which executes the JavaScript without problem.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种情况都是由于你的爬虫未能执行页面上发生魔法的 JavaScript 导致的。没有 JavaScript，HTML 就只是呆呆地呈现在那里，而网站可能看起来与在你的网页浏览器中看到的完全不同。
- en: 'There are several giveaways that a page might be using Ajax or DHTML to change
    or load the content, but in situations like this, there are only two solutions:
    scrape the content directly from the JavaScript; or use Python packages capable
    of executing the JavaScript itself and scrape the website as you view it in your
    browser.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 页面可能有几个迹象表明它可能在使用 Ajax 或 DHTML 来更改或加载内容，但在这种情况下，只有两种解决方案：直接从 JavaScript 中获取内容；或使用能够执行
    JavaScript 并在浏览器中查看网站的 Python 包来爬取网站。
- en: Executing JavaScript in Python with Selenium
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Python 中执行 Selenium 中的 JavaScript
- en: '[Selenium](http://www.seleniumhq.org) is a powerful web scraping tool developed
    originally for website testing. These days, it’s also used when the accurate portrayal
    of websites—as they appear in a browser—is required. Selenium works by automating
    browsers to load the website, retrieve the required data, and even take screenshots
    or assert that certain actions happen on the website.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[Selenium](http://www.seleniumhq.org) 是一个强大的网页抓取工具，最初用于网站测试。如今，当需要准确地呈现网页在浏览器中的外观时，也会使用
    Selenium。Selenium 通过自动化浏览器加载网页，获取所需数据，甚至拍摄屏幕截图或验证网站上发生的某些动作来工作。'
- en: Selenium does not contain its own web browser; it requires integration with
    third-party browsers in order to run. If you were to run Selenium with Firefox,
    for example, you would see a Firefox instance open up on your screen, navigate
    to the website, and perform the actions you had specified in the code. Although
    this might be neat to watch, I prefer my scripts to run quietly in the background
    and often use Chrome’s *headless* mode to do that.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium 不包含自己的网络浏览器；它需要与第三方浏览器集成才能运行。例如，如果你用 Firefox 运行 Selenium，你会看到一个 Firefox
    实例在你的屏幕上打开，导航到网站，并执行你在代码中指定的操作。尽管这可能很有趣，我更喜欢我的脚本在后台静静地运行，并经常使用 Chrome 的*无头*模式来做到这一点。
- en: A *headless browser* loads websites into memory and executes JavaScript on the
    page, but does it without any graphic rendering of the website to the user. By
    combining Selenium with headless Chrome, you can run an extremely powerful web
    scraper that handles cookies, JavaScript, headers, and everything else you need
    with ease, as if you were using a rendered browser.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*无头浏览器*将网站加载到内存中，并在页面上执行 JavaScript，但不会向用户显示网站的图形渲染。通过将 Selenium 与无头 Chrome
    结合使用，你可以运行一个非常强大的网页抓取器，轻松处理 cookies、JavaScript、标头以及其他所有你需要的东西，就像使用渲染浏览器一样。
- en: Installing and Running Selenium
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和运行 Selenium
- en: You can download the Selenium library from [its website](https://pypi.python.org/pypi/selenium) or
    use a third-party installer such as pip to install it from the command line.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从[其网站](https://pypi.python.org/pypi/selenium)下载 Selenium 库，或者使用像 pip 这样的第三方安装程序从命令行安装它。
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Previous versions of Selenium required that you also manually download a webdriver
    file that would allow it to interface with your web browser. This webdriver is
    called such because it is a software *driver* for the web browser. Much like a
    software driver for a hardware device, it allows the Python Selenium package to
    interface with and control your browser.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的 Selenium 版本要求你手动下载一个 webdriver 文件，以便它与你的网络浏览器进行交互。这个 webdriver 之所以被称为这样，是因为它是网页浏览器的软件*驱动程序*。就像硬件设备的软件驱动程序一样，它允许
    Python Selenium 包与你的浏览器进行接口和控制。
- en: Unfortunately, because new versions of browsers are released frequently, and
    are much more frequently updated thanks to automatic updates, this meant that
    Selenium drivers also had to be frequently updated. Navigating to the browser
    driver’s website (such as [*http://chromedriver.chromium.org/downloads*](http://chromedriver.chromium.org/downloads)),
    downloading the new file, and replacing the old file was a frequent chore. In
    Selenium 4, released in October 2021, this entire process was replaced by the
    webdriver manager Python package.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，由于浏览器的新版本频繁发布，并且多亏了自动更新，这意味着 Selenium 驱动程序也必须经常更新。导航到浏览器驱动程序的网站（例如[*http://chromedriver.chromium.org/downloads*](http://chromedriver.chromium.org/downloads)），下载新文件，并替换旧文件是一个频繁的烦恼。在
    2021 年十月发布的 Selenium 4 中，这整个过程被 webdriver 管理器 Python 包替代。
- en: 'The webdriver manager can be installed with pip:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: webdriver 管理器可以通过 pip 安装：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When called, the webdriver manager downloads the latest driver:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 调用时，webdriver 管理器会下载最新的驱动程序：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Of course, if this script is being run frequently, it’s inefficient to install
    a new driver file each time just in case the Chrome browser was updated since
    the last time it ran. The output of the driver manager installation is simply
    the path in your `driver` directory where the driver is located:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果这个脚本经常运行，每次运行时都安装一个新的驱动文件以防止 Chrome 浏览器自上次运行以来被更新是低效的。驱动程序管理器安装的输出只是驱动程序位于你的`driver`目录中的路径：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you still enjoy downloading files by hand, you can do that by passing your
    own path into the `Service` object:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然喜欢手动下载文件，你可以通过将自己的路径传递给`Service`对象来实现：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Although plenty of pages use Ajax to load data, I’ve created a sample page at
    [*http://pythonscraping.com/pages/javascript/ajaxDemo.html*](http://pythonscraping.com/pages/javascript/ajaxDemo.html) to
    run your scrapers against. This page contains some sample text, hardcoded into
    the page’s HTML, that is replaced by Ajax-generated content after a two-second
    delay. If you were to scrape this page’s data by using traditional methods, you’d
    get only the loading page, without getting the data that you want.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多页面使用 Ajax 加载数据，我已经创建了一个样例页面[*http://pythonscraping.com/pages/javascript/ajaxDemo.html*](http://pythonscraping.com/pages/javascript/ajaxDemo.html)供你对抗抓取器。这个页面包含一些样例文本，硬编码到页面的
    HTML 中，在两秒延迟后被 Ajax 生成的内容替换。如果你使用传统方法来抓取这个页面的数据，你只会得到加载页面，而无法获取你想要的数据。
- en: The Selenium library is an API called on the object [`webdriver`](https://selenium-python.readthedocs.io/api.html).
    Note that this is a Python object representing or acting as an interface to the
    webdriver application you downloaded. While the same terms “driver” and “webdriver”
    are often used interchangeably for both things (the Python object and the application
    itself) it’s important to distinguish them conceptually.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium 库是调用[`webdriver`](https://selenium-python.readthedocs.io/api.html)对象的
    API。请注意，这是一个代表或充当你下载的 webdriver 应用程序的 Python 对象。虽然“driver”和“webdriver”这两个术语通常可以互换使用来指代这两个东西（Python
    对象和应用程序本身），但在概念上区分它们是很重要的。
- en: The `webdriver` object is a bit like a browser in that it can load websites,
    but it can also be used like a `BeautifulSoup` object to find page elements, interact
    with elements on the page (send text, click, etc.), and do other actions to drive
    the web scrapers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`webdriver`对象有点像浏览器，它可以加载网站，但也可以像`BeautifulSoup`对象一样用于查找页面元素，与页面上的元素交互（发送文本，单击等），并执行其他操作以驱动网络爬虫。'
- en: 'The following code retrieves text behind an Ajax “wall” on the test page:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码检索测试页面上Ajax“墙”后面的文本：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This creates a new Selenium webdriver, using the Chrome library, which tells
    the webdriver to load a page and then pauses execution for three seconds before
    looking at the page to retrieve the (hopefully loaded) content.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用Chrome库创建一个新的Selenium webdriver，告诉webdriver加载页面，然后在查看页面以检索（希望加载的）内容之前暂停执行三秒钟。
- en: 'When you instantiate a new Chrome webdriver in Python, you can pass it a variety
    of options through the `Options` object. In this case, we’re using the `--headless`
    option to make the webdriver run in the background:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在Python中实例化一个新的Chrome webdriver时，可以通过`Options`对象传递各种选项。在这种情况下，我们使用`--headless`选项使webdriver在后台运行：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Whether you used the driver manager package to install a driver or downloaded
    it yourself, you must pass this path into the `Service` object, as well as pass
    in your options, to create a new webdriver:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是使用驱动程序管理程序包安装驱动程序还是自行下载驱动程序，都必须将此路径传递给`Service`对象，并传递您的选项，以创建新的webdriver：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If everything is configured correctly, the script should take a few seconds
    to run and then result in the following text:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切配置正确，脚本应该在几秒钟内运行，然后结果如下所示：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Selenium Selectors
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Selenium选择器
- en: 'In previous chapters, you’ve selected page elements using `BeautifulSoup` selectors,
    such as `find` and `find_all`. Selenium uses a very similar set of methods to
    select elements: `find_element` and `find_elements`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的章节中，您已使用`BeautifulSoup`选择器（如`find`和`find_all`）选择页面元素。 Selenium使用非常相似的一组方法来选择元素：`find_element`和`find_elements`。
- en: 'There are so many ways to find and select elements from HTML, you might think
    that Selenium would use a wide variety of arguments and keyword arguments for
    these methods. However, for both `find_element` and `find_elements` there are
    only two arguments for both of these functions: the `By` object and the string
    selector.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从HTML中找到和选择元素的方法有很多，您可能会认为Selenium会使用各种参数和关键字参数来执行这些方法。但是，对于`find_element`和`find_elements`，这两个函数都只有两个参数：`By`对象和字符串选择器。
- en: 'The `By` object specifies how the selector string should be interpreted, with
    the following list of options:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`By`对象指定选择器字符串应如何解释，有以下选项列表：'
- en: '`By.ID`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`By.ID`'
- en: Used in the example; finds elements by their HTML `id` attribute.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中使用；通过它们的HTML `id`属性查找元素。
- en: '`By.NAME`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`By.NAME`'
- en: Finds HTML tags by their `name` attribute. This is handy for HTML forms.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过它们的`name`属性查找HTML标记。这对于HTML表单很方便。
- en: '`By.XPATH`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`By.XPATH`'
- en: Uses an `XPath` expression to select matching elements. The XPath syntax will
    be covered in more detail later in this chapter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用XPath表达式选择匹配的元素。XPath语法将在本章的后面更详细地介绍。
- en: '`By.LINK_TEXT`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`By.LINK_TEXT`'
- en: Finds HTML `<a>` tags by the text they contain. For example, a link labeled
    “Next” can be selected using `(By.LINK_TEXT, 'Next')`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过它们包含的文本查找HTML `<a>`标签。例如，可以使用`(By.LINK_TEXT，'Next')`选择标记为“Next”的链接。
- en: '`By.PARTIAL_LINK_TEXT`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`By.PARTIAL_LINK_TEXT`'
- en: Similar to `LINK_TEXT` but matches on a partial string.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`LINK_TEXT`，但匹配部分字符串。
- en: '`By.TAG_NAME`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`By.TAG_NAME`'
- en: Finds HTML tags by their tag name.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过标记名称查找HTML标记。
- en: '`By.CLASS_NAME`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`By.CLASS_NAME`'
- en: Used to find elements by their HTML `class` attribute. Why is this function `CLASS_NAME` and
    not simply `CLASS`? Using the form `object.CLASS` would create problems for Selenium’s
    Java library, where `.class` is a reserved method. To keep the Selenium syntax
    consistent between languages, `CLASS_NAME` is used instead.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 用于通过它们的HTML `class`属性查找元素。为什么这个函数是`CLASS_NAME`而不仅仅是`CLASS`？使用形式`object.CLASS`会为Selenium的Java库创建问题，其中`.class`是保留方法。为了保持各种语言之间的Selenium语法一致，使用了`CLASS_NAME`。
- en: '`By.CSS_SELECTOR`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`By.CSS_SELECTOR`'
- en: Finds elements by their `class`, `id`, or `tag` name, using the `#idName`, `.className`, `tagName` convention.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`class`、`id`或`tag`名称查找元素，使用`#idName`、`.className`、`tagName`约定。
- en: 'In the previous example, you used the selector `driver.find_element(By.ID,
    ''content'')`, although the following selectors would have worked as well:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，您使用了选择器`driver.find_element(By.ID，'content')`，虽然以下选择器也可以使用：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Of course, if you want to select multiple elements on the page, most of these
    element selectors can return a Python list of elements by using `elements` (i.e.,
    make it plural):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果要在页面上选择多个元素，大多数这些元素选择器都可以通过使用`elements`（即，使其复数化）返回一个Python元素列表：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you still want to use BeautifulSoup to parse this content, you can, by using
    webdriver’s `page_source` function, which returns the page’s source, as viewed
    by the DOM at that current time, as a string:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仍然希望使用 BeautifulSoup 解析此内容，则可以通过使用 webdriver 的 `page_source` 函数来实现，该函数将页面的源代码作为字符串返回，正如在当前时间由DOM查看的那样：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Waiting to Load
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等待加载
- en: Note that although the page itself contains an HTML button, Selenium’s `.text` function
    retrieves the text value of the button in the same way that it retrieves all other
    content on the page.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管页面本身包含一个 HTML 按钮，但 Selenium 的 `.text` 函数以与检索页面上所有其他内容相同的方式检索按钮的文本值。
- en: 'If the `time.sleep` pause is changed to one second instead of three, the text
    returned changes to the original:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`time.sleep`暂停时间更改为一秒而不是三秒，则返回的文本将变为原始文本：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Although this solution works, it is somewhat inefficient, and implementing it
    could cause problems on a large scale. Page-load times are inconsistent, depending
    on the server load at any particular millisecond, and natural variations occur
    in connection speed. Although this page load should take just over two seconds,
    you’re giving it an entire three seconds to make sure that it loads completely.
    A more efficient solution would repeatedly check for the existence of a particular
    element on a fully loaded page and return only when that element exists.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管此解决方案有效，但效率略低，并且实施它可能在大规模上造成问题。页面加载时间不一致，取决于任何特定毫秒的服务器负载，并且连接速度会自然变化。尽管此页面加载应仅需超过两秒，但您将其整整三秒时间来确保其完全加载。更高效的解决方案将重复检查完全加载页面上特定元素的存在，并仅在该元素存在时返回。
- en: 'The following program uses the presence of the button with the ID `loadedButton` to
    declare that the page has been fully loaded:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序使用带有 ID `loadedButton` 的按钮的出现来声明页面已完全加载：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This script has several new imports, most notably `WebDriverWait` and `expected​_con⁠ditions`,
    both of which are combined here to form what Selenium calls an* implicit wait*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本引入了几个新的导入项，特别是`WebDriverWait`和`expected_conditions`，两者在此处组合以形成 Selenium 称之为的*隐式等待*。
- en: 'An implicit wait differs from an explicit wait in that it waits for a certain
    state in the DOM to occur before continuing, while an explicit wait defines a
    hardcoded time as in the previous example, which has a wait of three seconds.
    In an implicit wait, the triggering DOM state is defined by `expected_condition` (note
    that the import is cast to `EC` here, a common convention used for brevity). Expected
    conditions can be many things in the Selenium library, including:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式等待与显式等待不同，它在继续之前等待DOM中的某种状态发生，而显式等待则定义了一个硬编码时间，例如前面示例中的三秒等待时间。在隐式等待中，触发DOM状态由`expected_condition`定义（请注意，此处导入被转换为`EC`，这是一种常用的简洁约定）。在
    Selenium 库中，预期条件可以是许多事物，包括：
- en: An alert box pops up.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹出警报框。
- en: An element (such as a text box) is put into a *selected* state.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素（例如文本框）处于*选定*状态。
- en: The page’s title changes, or text is now displayed on the page or in a specific
    element.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面标题更改，或现在在页面上或特定元素中显示文本。
- en: An element is now visible to the DOM, or an element disappears from the DOM.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，一个元素对DOM可见，或者一个元素从DOM中消失。
- en: Most of these expected conditions require that you specify an element to watch
    for in the first place. Elements are specified using locators. Note that locators
    are not the same as selectors (see [“Selenium Selectors”](#selenium_sidebar) for
    more on selectors). A *locator* is an abstract query language, using the `By` object,
    which can be used in a variety of ways, including to make selectors.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些预期条件要求您首先指定要监视的元素。元素使用定位器指定。请注意，定位器与选择器不同（有关选择器的更多信息，请参见[“Selenium Selectors”](#selenium_sidebar)）。*定位器*是一种抽象查询语言，使用`By`对象，可以以多种方式使用，包括制作选择器。
- en: 'In the following code, a locator is used to find elements with the ID `loadedButton`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，使用定位器查找具有 ID `loadedButton` 的元素：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Locators also can be used to create selectors, using the `find_element` webdriver
    function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 定位器还可以用来创建选择器，使用`find_element` webdriver 函数：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you do not need to use a locator, don’t; it will save you an import. However,
    this handy tool is used for a variety of applications and has a great degree of
    flexibility.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不需要使用定位器，请不要使用；这将节省您的导入。然而，这个方便的工具用于各种应用，并具有极大的灵活性。
- en: XPath
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XPath
- en: '*XPath* (short for *XML Path*) is a query language used for navigating and
    selecting portions of an XML document. Founded by the W3C in 1999, it is occasionally
    used in languages such as Python, Java, and C# when dealing with XML documents.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*XPath*（即*XML Path*）是用于导航和选择XML文档部分的查询语言。1999年由W3C创立，偶尔在Python、Java和C#等语言中处理XML文档时使用。'
- en: Although BeautifulSoup does not support XPath, many of the other libraries in
    this book, such as Scrapy and Selenium, do. It often can be used in the same way
    as CSS selectors (such as `mytag#idname`), although it is designed to work with
    more generalized XML documents rather than HTML documents in particular.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然BeautifulSoup不支持XPath，但本书中的许多其他库（如Scrapy和Selenium）支持。它通常可以像CSS选择器（例如`mytag#idname`）一样使用，尽管它设计用于与更广义的XML文档一起工作，而不是特定的HTML文档。
- en: 'The XPath syntax has four major concepts:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: XPath语法有四个主要概念：
- en: Root nodes versus nonroot nodes
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 根节点与非根节点
- en: '`/div` will select the div node only if it is at the root of the document.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`/div` 仅在文档根部选择div节点。'
- en: '`//div` selects all divs anywhere in the document.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`//div` 在文档中选择所有的div。'
- en: Attribute selection
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 属性选择
- en: '`//@href` selects any nodes with the attribute `href`.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`//@href` 选择具有属性`href`的任何节点。'
- en: '`//a[@href=''http://google.com'']` selects all links in the document that point
    to Google.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`//a[@href=''http://google.com'']` 选择文档中指向Google的所有链接。'
- en: Selection of nodes by position
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过位置选择节点
- en: '`//a[3]` selects the third link in the document.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`//a[3]` 选择文档中的第三个链接。'
- en: '`//table[last()]` selects the last table in the document.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`//table[last()]` 选择文档中的最后一个表格。'
- en: '`//a[position() < 3]` selects the first two links in the document.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`//a[position() < 3]` 选择文档中的前两个链接。'
- en: Asterisks (*) match any set of characters or nodes and can be used in a variety
    of situations
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 星号（*）匹配任何字符或节点，并可在各种情况下使用。
- en: '`//table/tr/*` selects all children of `tr` tags in all tables (this is good
    for selecting cells using both `th` and `td` tags).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`//table/tr/*` 选择所有表格中`tr`标签的子节点（这对使用`th`和`td`标签选择单元格很有用）。'
- en: '`//div[@*]` selects all `div` tags that have any attributes.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`//div[@*]` 选择所有带有任何属性的`div`标签。'
- en: XPath syntax also has many advanced features. Over the years, it has developed
    into a relatively complicated query language, with boolean logic, functions (such
    as `position()`), and a variety of operators not discussed here.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: XPath语法还具有许多高级功能。多年来，它发展成为一个相对复杂的查询语言，具有布尔逻辑、函数（如`position()`）和各种此处未讨论的运算符。
- en: If you have an HTML or XML selection problem that cannot be addressed by the
    functions shown here, see [Microsoft’s XPath Syntax page](https://msdn.microsoft.com/en-us/enus/library/ms256471).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有无法通过此处显示的功能解决的HTML或XML选择问题，请参阅[Microsoft的XPath语法页面](https://msdn.microsoft.com/en-us/enus/library/ms256471)。
- en: Additional Selenium WebDrivers
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他Selenium WebDrivers
- en: 'In the previous section, the Chrome WebDriver (ChromeDriver) was used with
    Selenium. In most cases, there is little reason to have a browser pop up on the
    screen and start scraping the web, so running this in headless mode can be convenient.
    However, running in nonheadless mode, and/or using different browser drivers can
    be good practice for a number of reasons:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，Chrome WebDriver（ChromeDriver）与Selenium一起使用。大多数情况下，不需要浏览器弹出屏幕并开始网页抓取，因此在无头模式下运行会很方便。然而，以非无头模式运行，并/或使用不同的浏览器驱动程序，可以出于多种原因进行良好的实践：
- en: Troubleshooting. If your code is running in headless mode and fails, the failure
    may be difficult to diagnose without seeing the page in front of you.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障排除。如果您的代码在无头模式下运行失败，可能很难在没有看到页面的情况下诊断失败原因。
- en: You can also pause the code execution and interact with the web page or use
    the inspector tools while your scraper is running in order to diagnose problems.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以暂停代码执行并与网页交互，或在您的抓取器运行时使用检查工具来诊断问题。
- en: Tests may depend on a specific browser in order to run. A failure in one browser
    but not in another may point at a browser-specific problem.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试可能依赖于特定的浏览器才能运行。一个浏览器中的失败而另一个浏览器中没有可能指向特定于浏览器的问题。
- en: 'In most cases it is preferable to use the webdriver manager to get your browser
    drivers. For instance, you can use the webdriver manager for Firefox and Microsoft
    Edge:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，最好使用webdriver管理器获取您的浏览器驱动程序。例如，您可以使用webdriver管理器来获取Firefox和Microsoft
    Edge的驱动程序：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: However, if you need a deprecated browser version or a browser not available
    through the webdriver manager (such as Safari) you may still need to manually
    download the driver files.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您需要一个已弃用的浏览器版本或者通过webdriver管理器无法获取的浏览器（例如Safari），您可能仍然需要手动下载驱动程序文件。
- en: Many groups, both official and unofficial, are involved in the creation and
    maintenance of Selenium webdrivers for every major browser today. The Selenium
    group curates a [collection of these webdrivers](http://www.seleniumhq.org/download/) for
    easy reference.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的每个主要浏览器都有许多官方和非官方团体参与创建和维护Selenium Web驱动程序。Selenium团队整理了一个用于参考的[这些Web驱动程序的集合](http://www.seleniumhq.org/download/)。
- en: Handling Redirects
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理重定向
- en: Client-side redirects are page redirects that are executed in your browser by
    JavaScript, rather than a redirect performed on the server, before the page content
    is sent. It can sometimes be tricky to tell the difference when visiting a page
    in your web browser. The redirect might happen so fast that you don’t notice any
    delay in loading time and assume that a client-side redirect is actually a server-side
    redirect.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端重定向是由JavaScript在您的浏览器中执行的页面重定向，而不是在服务器上执行的重定向，在发送页面内容之前。当您访问网页时，有时很难区分两者的区别。重定向可能发生得如此之快，以至于您没有注意到加载时间的任何延迟，并假定客户端重定向实际上是服务器端重定向。
- en: However, when scraping the web, the difference is obvious. A server-side redirect,
    depending on how it is handled, can be traversed easily by Python’s urllib library
    without any help from Selenium (for more information on doing this, see [Chapter 6](ch06.html#c-6)).
    Client-side redirects won’t be handled at all unless something is executing the
    JavaScript.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在网页抓取时，差异是显而易见的。一个服务器端的重定向，根据它是如何处理的，可以通过Python的urllib库轻松地遍历，而无需Selenium的帮助（有关如何执行此操作的更多信息，请参见[第6章](ch06.html#c-6)）。客户端重定向除非执行JavaScript，否则根本不会处理。
- en: Selenium is capable of handling these JavaScript redirects in the same way that
    it handles other JavaScript execution; however, the primary issue with these redirects
    is when to stop page execution—that is, how to tell when a page is done redirecting. A
    demo page at [*http://pythonscraping.com/pages/javascript/redirectDemo1.html*](http://pythonscraping.com/pages/javascript/redirectDemo1.html) gives
    an example of this type of redirect, with a two-second pause.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium能够以处理其他JavaScript执行的方式处理这些JavaScript重定向；然而，这些重定向的主要问题在于何时停止页面执行，即如何判断页面何时完成重定向。一个演示页面在[*http://pythonscraping.com/pages/javascript/redirectDemo1.html*](http://pythonscraping.com/pages/javascript/redirectDemo1.html)上展示了这种类型的重定向，带有两秒的暂停。
- en: 'You can detect that redirect in a clever way by “watching” an element in the
    DOM when the page initially loads, and then repeatedly calling that element until
    Selenium throws a `StaleElementReferenceException`; the element is no longer attached
    to the page’s DOM and the site has redirected:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过“观察”页面初始加载时的DOM中的一个元素来巧妙地检测重定向，然后重复调用该元素，直到Selenium抛出`StaleElementReferenceException`；元素不再附加到页面的DOM中，网站已重定向：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This script checks the page every half second, with a timeout of 10 seconds,
    although the times used for the checking time and timeout can be easily adjusted
    up or down, as needed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本每隔半秒检查一次页面，超时时间为10秒，尽管检查时间和超时时间可以根据需要轻松调整。
- en: Alternatively, you can write a similar loop checking the current URL of the
    page until the URL changes or it matches a specific URL that you’re looking for.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以编写一个类似的循环来检查页面当前的URL，直到URL发生变化或者匹配您正在寻找的特定URL为止。
- en: 'Waiting for elements to appear and disappear is a common task in Selenium,
    and you can also use the same `WebDriverWait` function used in the previous button
    loading example. Here you’re providing it a timeout of 15 seconds and an XPath
    selector that looks for the page body content to accomplish the same task:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在Selenium中等待元素出现和消失是一个常见任务，您也可以像上一个按钮加载示例中使用的`WebDriverWait`函数一样使用相同的方法。在这里，您提供了一个15秒的超时时间和一个XPath选择器，用于查找页面主体内容来完成相同的任务：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A Final Note on JavaScript
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript的最后一点说明
- en: Most sites today on the internet use JavaScript.^([3](ch14.html#id763)) Fortunately
    for us, in many cases this use of JavaScript will not affect how you scrape the
    page. The JavaScript may be limited to powering a site’s tracking tools, controlling
    a small section of the site, or manipulating a drop-down menu, for example. In
    cases where it does impact how you scrape the site, the JavaScript can be executed
    with tools like Selenium to produce the simple HTML page you’ve been learning
    to scrape in the first part of this book.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当今大多数互联网上的网站都在使用JavaScript。^([3](ch14.html#id763)) 幸运的是，对我们来说，在许多情况下，这种JavaScript的使用不会影响你对页面的抓取。JavaScript可能仅限于为站点的跟踪工具提供动力，控制站点的一小部分或操作下拉菜单，例如。在它影响到你抓取网站的方式时，可以使用像Selenium这样的工具来执行JavaScript，以生成你在本书第一部分学习抓取的简单HTML页面。
- en: 'Remember: just because a site uses JavaScript does not mean that all the traditional
    web scraping tools go out the window. The purpose of JavaScript is ultimately
    to produce HTML and CSS code that can be rendered by the browser, or to communicate
    with the server dynamically, through HTTP requests and responses. Once Selenium
    is used, the HTML and CSS on the page can be read and parsed as you would with
    any other website code, and HTTP requests and responses can be sent and handled
    by your code via the techniques in earlier chapters, even without using Selenium.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：仅因为一个网站使用JavaScript并不意味着所有传统的网络爬取工具都不再适用。JavaScript的目的最终是生成可以由浏览器渲染的HTML和CSS代码，或通过HTTP请求和响应与服务器动态通信。一旦使用Selenium，页面上的HTML和CSS可以像处理其他任何网站代码一样读取和解析，通过本书前几章的技术可以发送和处理HTTP请求和响应，即使不使用Selenium也可以。
- en: In addition, JavaScript can even be a benefit to web scrapers, because its use
    as a “browser-side content management system” may expose useful APIs to the outside
    world, letting you obtain the data more directly. For more information on this,
    see [Chapter 15](ch15.html#c-15).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，JavaScript甚至可以成为网络爬虫的一个好处，因为它作为“浏览器端内容管理系统”的使用可能向外界公开有用的API，使您可以更直接地获取数据。有关更多信息，请参见[第15章](ch15.html#c-15)。
- en: If you are still having difficulty with a particularly hairy JavaScript situation,
    you can find information on Selenium and interacting directly with dynamic websites,
    including drag-and-drop interfaces, in [Chapter 17](ch17.html#c-17).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在处理某个棘手的JavaScript情况时仍然遇到困难，你可以在[第17章](ch17.html#c-17)中找到关于Selenium和直接与动态网站交互的信息，包括拖放界面等。
- en: ^([1](ch14.html#id730-marker)) See Web Technology Surveys analysis at [*https://w3techs.com/technologies/details/js-jquery*](https://w3techs.com/technologies/details/js-jquery)
    W3Techs uses web crawlers to monitor trends in technology usage over time.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch14.html#id730-marker)) 查看Web Technology Surveys分析，网址为[*https://w3techs.com/technologies/details/js-jquery*](https://w3techs.com/technologies/details/js-jquery)，W3Techs使用网络爬虫随时间监测技术使用趋势。
- en: ^([2](ch14.html#id733-marker)) W3Techs, [“Usage Statistics and Market Share
    of Google Analytics for Websites”](http://w3techs.com/technologies/details/ta-googleanalytics/all/all).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch14.html#id733-marker)) W3Techs，《Google Analytics网站使用统计和市场份额》。
- en: ^([3](ch14.html#id763-marker)) W3Techs, [“Usage Statistics of JavaScript as
    Client-Side Programming Language on Websites”](http://w3techs.com/technologies/details/cp-javascript/all/all).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch14.html#id763-marker)) W3Techs，《网站上作为客户端编程语言使用的JavaScript的使用统计》。
