<html><head></head><body>
<div id="sbo-rt-content"><section data-nutshell-tab="Object-Oriented Python" data-pdf-bookmark="Chapter 4. Object-Oriented Python" data-type="chapter" epub:type="chapter"><div class="chapter" id="object_oriented_python">
<h1><span class="label">Chapter 4. </span>Object-Oriented Python</h1>
<p>Python is an object-oriented (OO) programming language. Unlike some other object-oriented languages, however, Python doesn’t force you to use the object-oriented paradigm exclusively: it also supports<a contenteditable="false" data-primary="procedural programming" data-type="indexterm" id="idm44924571781776"/> procedural programming, with modules and functions, so that you can select the best paradigm for each part of your program. The<a contenteditable="false" data-primary="object-oriented Python" data-secondary="benefits of" data-type="indexterm" id="idm44924571751568"/> object-oriented paradigm helps you group state (data) and behavior (code) together in handy packets of functionality. Moreover, it offers some useful specialized mechanisms covered in this chapter, like <em>inheritance</em> and <em>special methods</em>. The simpler procedural approach, based on modules and functions, may be more suitable when you don’t need the pluses<sup><a data-type="noteref" href="ch04.xhtml#ch01fn48" id="ch01fn48-marker">1</a></sup> of object-oriented programming. With Python, you can mix and match paradigms.</p>
<p>In addition to core OO concepts, this chapter covers <em>abstract base classes</em>, <em>decorators</em>, and <em>metaclasses</em>.</p>
<section data-pdf-bookmark="Classes and Instances" data-type="sect1"><div class="sect1" id="classes_and_instances">
<h1>Classes and Instances</h1>
<p>If<a contenteditable="false" data-primary="object-oriented Python" data-secondary="classes and instances" data-type="indexterm" id="OOPclasinst04"/><a contenteditable="false" data-primary="classes" data-type="indexterm" id="classes04"/> you’re familiar with object-oriented programming in other OO languages such as C++ or Java, you probably have a good grasp of classes and instances: a <em>class</em> is a user-defined type, which you <em>instantiate</em> to build <em>instances</em>, i.e., objects of that type. Python supports this through its class and instance objects.</p>
<section data-pdf-bookmark="Python Classes" data-type="sect2"><div class="sect2" id="python_classes">
<h2>Python Classes</h2>
<p>A <em>class</em> is a Python object with the following characteristics:</p>
<ul>
<li>
<p>You can call a class object just like you’d call a function. The call, known<a contenteditable="false" data-primary="instantiation" data-type="indexterm" id="idm44924571735792"/> as <em>instantiation</em>, returns an object known as an <em>instance</em> of the class; the class is also known as the<a contenteditable="false" data-primary="type, definition of term" data-type="indexterm" id="idm44924571733696"/> instance’s <em>type</em>.</p>
</li>
<li>
<p>A class has arbitrarily named attributes that you can bind and reference.</p>
</li>
<li>
<p>The values of class attributes can be<a contenteditable="false" data-primary="descriptors" data-type="indexterm" id="idm44924571730416"/> <em>descriptors</em> (including functions), covered in <a data-type="xref" href="#descriptors">“Descriptors”</a>, or ordinary data objects.</p>
</li>
<li>
<p>Class attributes bound to functions are also known as<a contenteditable="false" data-primary="methods" data-secondary="basics of" data-type="indexterm" id="idm44924571726912"/> <em>methods</em> of the class.</p>
</li>
<li>
<p>A method can have any one of many Python-defined names with<a contenteditable="false" data-primary="__ (double underscore)" data-type="indexterm" id="idm44924571724064"/><a contenteditable="false" data-primary="underscore (_)" data-secondary="double (__ dunder)" data-type="indexterm" id="idm44924571722960"/> two leading and two trailing underscores (known as<a contenteditable="false" data-primary="dunder (double underscore)" data-secondary="definition of term" data-type="indexterm" id="idm44924571721456"/> <em>dunder names</em>, short for “double-underscore names”—the name <span class="code">__init__</span>, for example, is pronounced “dunder init”). Python implicitly calls such special methods, when a class supplies them, when various kinds of operations occur on that class or its instances.</p>
</li>
<li>
<p>A<a contenteditable="false" data-primary="inheritance" data-secondary="basics of" data-type="indexterm" id="idm44924571717936"/> class can <em>inherit</em> from one or more classes, meaning it delegates to other class objects the lookup of some attributes (including regular and<a contenteditable="false" data-primary="dunder (double underscore)" data-secondary="inheritance and" data-type="indexterm" id="idm44924571715952"/> dunder methods) that are not in the class itself.</p>
</li>
</ul>
<p>An<a contenteditable="false" data-primary="instances" data-secondary="basics of" data-type="indexterm" id="idm44924571713888"/> instance of a class is a Python object with arbitrarily named attributes that you can bind and reference. Every instance object delegates attribute lookup to its class for any attribute not found in the instance itself. The class, in turn, may delegate the lookup to classes from which it inherits, if any.</p>
<p>In Python, classes are objects (values), handled just like other objects. You can pass a class as an argument in a call to a function, and a function can return a class as the result of a call. You can bind a class to a variable, an item in a container, or an attribute of an object. Classes can also be keys into a dictionary. Since classes are perfectly ordinary objects in Python, we often say that classes are <em>first-class</em> objects.</p>
</div></section>
<section data-pdf-bookmark="The class Statement" data-type="sect2"><div class="sect2" id="the_class_statement">
<h2>The class Statement</h2>
<p>The<a contenteditable="false" data-primary="classes" data-secondary="class statements" data-type="indexterm" id="idm44924571709520"/><a contenteditable="false" data-primary="class statements" data-type="indexterm" id="idm44924571708112"/> <span class="code"><strong>class</strong></span> statement is the most usual way you create a class object. <span class="code"><strong>class</strong></span> is a single-clause compound statement with the following syntax:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><em><code class="nc">Classname</code></em><code class="p">(</code><em><code class="n">base</code><code class="o">-</code><code class="n">classes</code></em><code class="p">,</code><code> </code><code class="o">*</code><code class="p">,</code><code> </code><code class="o">*</code><code class="o">*</code><em><code class="n">kw</code></em><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">statement</code><code class="p">(</code><code class="n">s</code><code class="p">)</code></pre>
<p><span class="code"><em>Classname</em></span> is an identifier: a variable that the class statement, when finished, binds (or rebinds) to the just-created class object. Python naming <a href="https://oreil.ly/orJJ1">conventions</a> advise using title case for class names, such as <span class="code">Item</span>, <span class="code">PrivilegedUser</span>, <span class="code">MultiUseFacility</span>, etc.</p>
<p><span class="code"><em>base-classes<a contenteditable="false" data-primary="base-classes" data-type="indexterm" id="idm44924571676528"> </a></em></span> <a contenteditable="false" data-primary="superclasses" data-type="indexterm" id="idm44924571675264"/><a contenteditable="false" data-primary="parents" data-type="indexterm" id="idm44924571674192"/>is a comma-delimited series of expressions whose values are class objects. Various programming languages use different names for these class objects: you can call them the <em>bases, superclasses</em>, or <em>parents</em> of the class. You can say the class created <em>inherits</em> from, <em>derives</em> from, <em>extends</em>, or <em>subclasses</em> its base classes; in this book, we generally use <em>extend</em>. This class is a<a contenteditable="false" data-primary="direct subclasses" data-type="indexterm" id="idm44924571650544"/> <em>direct subclass</em> or<a contenteditable="false" data-primary="descendants" data-type="indexterm" id="idm44924571648832"/> <em>descendant</em> of its base classes. <span class="code">**</span><span class="code"><em>kw</em></span> can<a contenteditable="false" data-primary="** (double star) operator" data-secondary="metaclass arguments" data-type="indexterm" id="idm44924571645680"/><a contenteditable="false" data-primary="double star (**) operator" data-secondary="metaclass arguments" data-type="indexterm" id="idm44924571644336"/> include a named argument <span class="code">metaclass=</span> to establish the class’s <em>metaclass</em>,<sup><a data-type="noteref" href="ch04.xhtml#ch01fn49" id="ch01fn49-marker">2</a></sup> as covered in <a data-type="xref" href="#how_python_determines_a_classapostrophe">“How Python Determines a Class’s Metaclass”</a>.</p>
<p>Syntactically, including <span class="code"><em>base-classes</em></span> is optional: to indicate that you’re creating a class without bases, just omit <span class="code"><em>base-classes</em></span> (and, optionally, also omit the parentheses around it, placing the colon right after the class name). Every class inherits from <span class="code">object</span>, whether you specify explicit bases or not.</p>
<p>The subclass relationship between classes is transitive: if <span class="code"><em>C1</em></span> extends <span class="code"><em>C2</em></span>, and <span class="code"><em>C2</em></span> extends <span class="code"><em>C3</em></span>, then <span class="code"><em>C1</em></span> extends <span class="code"><em>C3</em></span>. The built-in function <span class="code">issubclass(<em>C1</em></span>, <span class="code"><em>C2</em>)</span> accepts two class objects: it returns <span class="code"><strong>True</strong></span> when <span class="code"><em>C1</em></span> extends <span class="code"><em>C2</em></span>, and otherwise it returns <span class="code"><strong>False</strong></span>. Any class is a subclass of itself; therefore, <span class="code">issubclass(<em>C</em></span>, <span class="code"><em>C</em>)</span> returns <span class="code"><strong>True</strong></span> for any class <span class="code"><em>C</em></span>. We cover how base classes affect a class’s functionality in <a data-type="xref" href="#inheritance">“Inheritance”</a>.</p>
<p>The nonempty sequence of indented statements that follows the <span class="code"><strong>class</strong></span> statement is the <em>class body</em>. A class body executes immediately as part of the <span class="code"><strong>class</strong></span> statement’s execution. Until the body finishes executing, the new class object does not yet exist, and the <span class="code"><em>Classname</em></span> identifier is not yet bound (or rebound). <a data-type="xref" href="#how_a_metaclass_creates_a_class">“How a Metaclass Creates a Class”</a> provides more details about what happens when a <span class="code"><strong>class</strong></span> statement executes. Note that the <span class="code"><strong>class</strong></span> statement does not immediately create any instance of the new class, but rather defines the set of attributes shared by all instances when you later create instances by calling the class.</p>
</div></section>
<section data-pdf-bookmark="The Class Body" data-type="sect2"><div class="sect2" id="the_class_body">
<h2>The Class Body</h2>
<p>The<a contenteditable="false" data-primary="classes" data-secondary="class body" data-type="indexterm" id="idm44924571613376"/> body of a class is where you normally specify class attributes; these attributes can be descriptor objects (including functions) or ordinary data objects of any type. An attribute of a class can be another class—so, for example, you can have a <span class="code"><strong>class</strong></span> statement “nested” inside another <span class="code"><strong>class</strong></span> statement.</p>
<section data-pdf-bookmark="Attributes of class objects" data-type="sect3"><div class="sect3" id="attributes_of_class_objects">
<h3>Attributes of class objects</h3>
<p>You<a contenteditable="false" data-primary="attributes" data-secondary="specifying" data-type="indexterm" id="idm44924571608016"/> usually specify an attribute of a class object by binding a value to an identifier within the class body. For example:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">C1</code><code class="p">:</code><code>
</code><code>    </code><code class="n">x</code><code> </code><code class="o">=</code><code> </code><code class="mi">23</code><code>
</code><code class="nb">print</code><code class="p">(</code><code class="n">C1</code><code class="o">.</code><code class="n">x</code><code class="p">)</code><code>                      </code><em><code class="c1"># prints:</code></em><code class="c1"> </code><em><code class="c1">23</code></em></pre>
<p>Here, the class object <span class="code">C1</span> has an attribute named <span class="code">x</span>, bound to the value <span class="code">23</span>, and <span class="code">C1.x</span> refers to that attribute. Such attributes may also be accessed via instances: <span class="code">c = C1(); print(c.x)</span>. However, this isn’t always reliable in practice. For example, when the class instance <span class="code">c</span> has an <span class="code">x</span> attribute, that’s what <span class="code">c.x</span> accesses, not the class-level one. So, to access a class-level attribute from an instance, using, say, <span class="code">print(c.__class__.x)</span> may be best.</p>
<p>You can also bind or unbind class attributes outside the class body. For example:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">C2</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">pass</code></strong><code>
</code><code class="n">C2</code><code class="o">.</code><code class="n">x</code><code> </code><code class="o">=</code><code> </code><code class="mi">23</code><code>
</code><code class="nb">print</code><code class="p">(</code><code class="n">C2</code><code class="o">.</code><code class="n">x</code><code class="p">)</code><code>                      </code><em><code class="c1"># prints:</code></em><code class="c1"> </code><em><code class="c1">23</code></em></pre>
<p>Your program is usually more readable if you bind class attributes only with statements inside the class body. However, rebinding them elsewhere may be necessary if you want to carry state information at a class, rather than instance, level; Python lets you do that, if you wish. There is no difference between a class attribute bound in the class body and one bound or rebound outside the body by assigning to an attribute.</p>
<p>As we’ll discuss shortly, all class instances share all of the class’s attributes.</p>
<p>The <span class="code"><strong>class</strong></span> statement implicitly sets some class attributes. The attribute <span class="code">__name__</span> is the <span class="code"><em>Classname</em></span> identifier string used in the <span class="code"><strong>class</strong></span> statement. The attribute <span class="code">__bases__</span> is the tuple of class objects given (or implied) as the base classes in the <span class="code"><strong>class</strong></span> statement. For example, using the class <span class="code">C1</span> we just created:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="nb">print</code><code class="p">(</code><code class="n">C1</code><code class="o">.</code><code class="vm">__name__</code><code class="p">,</code><code> </code><code class="n">C1</code><code class="o">.</code><code class="vm">__bases__</code><code class="p">)</code><code> </code><em><code class="c1"># prints:</code></em><code class="c1"> </code><em><code class="c1">C1 (&lt;class 'object'&gt;,)</code></em></pre>
<p>A class also has an attribute called <span class="code">__dict__</span>, which is the read-only mapping that the class uses to hold other attributes (also known, informally, as the class’s <em>namespace</em>).</p>
<p>In statements directly in a class’s body, references to class attributes must use a simple name, not a fully qualified name. For example:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">C3</code><code class="p">:</code><code>
</code><code>    </code><code class="n">x</code><code> </code><code class="o">=</code><code> </code><code class="mi">23</code><code>
</code><code>    </code><code class="n">y</code><code> </code><code class="o">=</code><code> </code><code class="n">x</code><code> </code><code class="o">+</code><code> </code><code class="mi">22</code><code>                   </code><em><code class="c1"># must use just x</code></em><code class="c1">, </code><em><code class="c1">not</code></em><code class="c1"> </code><em><code class="c1">C3.x</code></em></pre>
<p>However, in statements within <em>methods</em> defined in a class body, references to class attributes must use a fully qualified name, not a simple name. For example:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">C4</code><code class="p">:</code><code>
</code><code>    </code><code class="n">x</code><code> </code><code class="o">=</code><code> </code><code class="mi">23</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">amethod</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="n">C4</code><code class="o">.</code><code class="n">x</code><code class="p">)</code><code>              </code><em><code class="c1"># must use C4.x or self.x</code></em><code class="c1">, </code><em><code class="c1">not</code></em><code class="c1"> </code><em><code class="c1">just x!</code></em></pre>
<p>Attribute references (i.e., expressions like <span class="code"><em>C.x</em></span>) have semantics richer than attribute bindings. We cover such references in detail in <a data-type="xref" href="#attribute_reference_basics">“Attribute Reference Basics”</a>.</p>
</div></section>
<section data-pdf-bookmark="Function definitions in a class body" data-type="sect3"><div class="sect3" id="function_definitions_in_a_class_body">
<h3>Function definitions in a class body</h3>
<p>Most<a contenteditable="false" data-primary="functions" data-secondary="function definitions in class bodies" data-type="indexterm" id="idm44924571396624"/> class bodies include some<a contenteditable="false" data-primary="def statement" data-type="indexterm" id="idm44924571394736"/> <span class="code"><strong>def</strong></span> statements, since functions (known as <em>methods<a contenteditable="false" data-primary="methods" data-secondary="function definitions in class bodies" data-type="indexterm" id="idm44924571392368"/></em> in this context) are important attributes for most class instances. A <span class="code"><strong>def</strong></span> statement in a class body obeys the rules covered in <a data-type="xref" href="ch03.xhtml#function">“Functions”</a>. In addition, a method defined in a class body has a mandatory first parameter, conventionally always named<a contenteditable="false" data-primary="self parameter" data-type="indexterm" id="idm44924571364368"/> <span class="code">self</span>, that refers to the instance on which you call the method. The <span class="code">self</span> parameter plays a special role in method calls, as covered in <a data-type="xref" href="#bound_and_unbound_methods">“Bound and Unbound Methods”</a>.</p>
<p>Here’s an example of a class that includes a method definition:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">C5</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">hello</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">Hello</code><code class="s1">'</code><code class="p">)</code></pre>
<p>A class can define a variety of special dunder methods relating to specific operations on its instances. We discuss these methods in detail in <a data-type="xref" href="#special_methods">“Special Methods”</a>.</p>
</div></section>
<section data-pdf-bookmark="Class-private variables" data-type="sect3"><div class="sect3" id="class_private_variables">
<h3>Class-private variables</h3>
<p>When<a contenteditable="false" data-primary="class-private variables" data-type="indexterm" id="idm44924581980144"/><a contenteditable="false" data-primary="variables and other references" data-secondary="class-private variables" data-type="indexterm" id="idm44924581979008"/> a statement in a class body (or in a method in the body) uses an identifier starting (but not ending) with<a contenteditable="false" data-primary="__ (double underscore)" data-type="indexterm" id="idm44924581977408"/><a contenteditable="false" data-primary="dunder (double underscore)" data-secondary="availability of" data-type="indexterm" id="idm44924581976304"/><a contenteditable="false" data-primary="underscore (_)" data-secondary="double (__ dunder)" data-type="indexterm" id="idm44924581956992"/> two underscores, such as<a contenteditable="false" data-primary=" __ident" data-type="indexterm" id="idm44924581955488"/> <span class="code"><em>__ident</em></span>, Python implicitly changes the identifier to <span class="code"><em>_Classname__ident</em></span>, where <span class="code"><em>Classname</em></span> is the name of the class. This implicit change lets a class use “private” names for attributes, methods, global variables, and other purposes, reducing the risk of accidentally duplicating names used elsewhere (particularly in subclasses).</p>
<p>By convention, identifiers starting with a<a contenteditable="false" data-primary="_ (underscore)" data-secondary="in identifiers" data-secondary-sortas="identifiers" data-type="indexterm" id="idm44924581951456"/><a contenteditable="false" data-primary="underscore (_)" data-secondary="in identifiers" data-secondary-sortas="identifiers" data-type="indexterm" id="idm44924581949808"/> <em>single</em> underscore are private to the scope that binds them, whether that scope is or isn’t a class. The Python compiler does not enforce this privacy convention: it is up to programmers to respect it.</p>
</div></section>
<section data-pdf-bookmark="Class documentation strings" data-type="sect3"><div class="sect3" id="class_documentation_strings">
<h3>Class documentation strings</h3>
<p>If the first statement in the class body is a string literal, the compiler binds that string as the<a contenteditable="false" data-primary="documentation strings (docstrings)" data-type="indexterm" id="idm44924581945408"/><a contenteditable="false" data-primary="docstrings (documentation strings)" data-type="indexterm" id="idm44924581944288"/> <em>documentation string</em> (or <em>docstring</em>) for the class. The docstring for the class is available in the<a contenteditable="false" data-primary="__doc__ attribute" data-type="indexterm" id="idm44924581942144"/> <span class="code">__doc__</span> attribute; if the first statement in the class body is <em>not</em> a string literal, its value is <span class="code"><strong>None</strong></span>. See <a data-type="xref" href="ch03.xhtml#docstrings">“Docstrings”</a> for more information on documentation strings.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Descriptors" data-type="sect2"><div class="sect2" id="descriptors">
<h2>Descriptors</h2>
<p>A<a contenteditable="false" data-primary="classes" data-secondary="descriptors" data-type="indexterm" id="idm44924581935776"/><a contenteditable="false" data-primary="descriptors" data-type="indexterm" id="idm44924581934368"/> <em>descriptor</em> is an object whose class supplies one or more special methods<a contenteditable="false" data-primary="__delete__ (descriptor method)" data-type="indexterm" id="idm44924581932688"/><a contenteditable="false" data-primary="__set__ (descriptor method)" data-type="indexterm" id="idm44924581931616"/><a contenteditable="false" data-primary="__get__ (descriptor method)" data-type="indexterm" id="idm44924581930544"/> named <span class="code">__get__</span>, <span class="code">__set__</span>, or <span class="code">__delete__</span>. Descriptors that are class attributes control the semantics of accessing and setting attributes on instances of that class. Roughly speaking, when you access an instance attribute, Python gets the attribute’s value by calling <span class="code">__get__</span> on the corresponding descriptor, if any. For example:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">Const</code><code class="p">:</code><code>  </code><em><code class="c1"># class with an overriding descriptor, see later</code></em><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">value</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="bp">self</code><code class="o">.</code><code class="vm">__dict__</code><code class="p">[</code><code class="s1">'</code><code class="s1">value</code><code class="s1">'</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="n">value</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__set__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="o">*</code><code class="n">_</code><code class="p">)</code><code class="p">:</code><code>  </code><code>
</code><code>        </code><code class="c1"># silently ignore any attempt at setting</code><code>
</code><code>        </code><code class="c1"># (a better design choice might be to raise AttributeError)</code><code>
</code><code>        </code><strong><code class="k">pass</code></strong><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__get__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="o">*</code><code class="n">_</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><em><code class="c1"># always return the constant value</code></em><code>
</code><code>        </code><strong><code class="k">return</code></strong><code> </code><code class="bp">self</code><code class="o">.</code><code class="vm">__dict__</code><code class="p">[</code><code class="s1">'</code><code class="s1">value</code><code class="s1">'</code><code class="p">]</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__delete__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="o">*</code><code class="n">_</code><code class="p">)</code><code class="p">:</code><code> </code><code>
</code><code>        </code><em><code class="c1"># silently ignore any attempt at deleting</code></em><code class="c1"> </code><code>
</code><code>        </code><code class="c1"># (a better design choice might be to raise AttributeError)</code><code>
</code><code>        </code><strong><code class="k">pass</code></strong><code>
</code><code>
</code><strong><code class="k">class</code></strong><code> </code><code class="nc">X</code><code class="p">:</code><code>
</code><code>    </code><code class="n">c</code><code> </code><code class="o">=</code><code> </code><code class="n">Const</code><code class="p">(</code><code class="mi">23</code><code class="p">)</code><code>
</code><code>
</code><code class="n">x</code><code> </code><code class="o">=</code><code> </code><code class="n">X</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="nb">print</code><code class="p">(</code><code class="n">x</code><code class="o">.</code><code class="n">c</code><code class="p">)</code><code>  </code><em><code class="c1"># prints:</code></em><code class="c1"> </code><em><code class="c1">23</code></em><code>
</code><code class="n">x</code><code class="o">.</code><code class="n">c</code><code> </code><code class="o">=</code><code> </code><code class="mi">42</code><code>    </code><em><code class="c1"># silently ignored (unless you raise AttributeError)</code></em><code>
</code><code class="nb">print</code><code class="p">(</code><code class="n">x</code><code class="o">.</code><code class="n">c</code><code class="p">)</code><code>  </code><em><code class="c1"># prints:</code></em><code class="c1"> </code><em><code class="c1">23</code></em><code>
</code><strong><code class="k">del</code></strong><code> </code><code class="n">x</code><code class="o">.</code><code class="n">c</code><em><code>     </code><code class="c1"># silently ignored again (ditto)</code></em><code>
</code><code class="nb">print</code><code class="p">(</code><code class="n">x</code><code class="o">.</code><code class="n">c</code><code class="p">)</code><code>  </code><em><code class="c1"># prints:</code></em><code class="c1"> </code><em><code class="c1">23</code></em></pre>
<p>For more details, see <a data-type="xref" href="#attribute_reference_basics">“Attribute Reference Basics”</a>.</p>
<section data-pdf-bookmark="Overriding and nonoverriding descriptors" data-type="sect3"><div class="sect3" id="overriding_and_nonoverriding_descriptor">
<h3>Overriding and nonoverriding descriptors</h3>
<p>When a descriptor’s class supplies a special method named <span class="code">__set__</span>, the descriptor is known as an<a contenteditable="false" data-primary=" overriding descriptors" data-type="indexterm" id="idm44924581760912"/> <em>overriding descriptor</em> (or, using the older, confusing terminology, a<a contenteditable="false" data-primary="data descriptors" data-type="indexterm" id="idm44924581782080"/> <em>data descriptor</em>); when the descriptor’s class supplies <span class="code">__get__</span> and not <span class="code">__set__</span>, the descriptor is known as a<a contenteditable="false" data-primary="nonoverriding descriptors" data-type="indexterm" id="idm44924581778992"/> <em>nonoverriding descriptor</em>.</p>
<p>For example, the class of function objects supplies <span class="code">__get__</span>, but not <span class="code">__set__</span>; therefore, function objects are nonoverriding descriptors. Roughly speaking, when you assign a value to an instance attribute with a corresponding descriptor that is overriding, Python sets the attribute value by calling <span class="code">__set__</span> on the descriptor. For more details, see <a data-type="xref" href="#attributes_of_instance_objects">“Attributes of instance objects”</a>.</p>
<p>The<a contenteditable="false" data-primary="dunder (double underscore)" data-secondary="overriding and nonoverriding descriptors" data-type="indexterm" id="idm44924581723344"/> third dunder method of the descriptor protocol is <span class="code">__delete__</span>, called when the <span class="code"><strong>del</strong></span> statement is used on the descriptor instance. If <span class="code"><strong>del</strong></span> is not supported, it is still a good idea to implement <span class="code">__delete__</span>, raising a proper <span class="code">AttributeError</span> exception; otherwise, the caller will get a mysterious <span class="code">AttributeError: __delete__</span> exception.</p>
<p>The <a href="https://oreil.ly/0yGz3">online docs</a> include many more examples of descriptors and their related methods.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Instances" data-type="sect2"><div class="sect2" id="instances">
<h2>Instances</h2>
<p>To<a contenteditable="false" data-primary="instances" data-secondary="details of" data-type="indexterm" id="instances04"/><a contenteditable="false" data-primary="classes" data-secondary="instances" data-type="indexterm" id="idm44924581712768"/> create an instance of a class, call the class object as if it were a function. Each call returns a new instance whose type is that class:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">an_instance</code> <code class="o">=</code> <code class="n">C5</code><code class="p">()</code></pre>
<p>The<a contenteditable="false" data-primary="isinstance (built-in function)" data-type="indexterm" id="idm44924581707696"/> built-in function <span class="code">isinstance(<em>i</em>,</span> <span class="code"><em>C</em></span><span class="code">)</span>, with a class as argument <span class="code"><em>C</em></span>, returns <span class="code"><strong>True</strong></span> when <span class="code"><em>i</em></span> is an instance of class <span class="code"><em>C</em></span> or any subclass of <span class="code"><em>C</em></span>. Otherwise, <span class="code">isinstance</span> returns <span class="code"><strong>False</strong></span>. If <span class="code"><em>C</em></span> is a tuple of types (<span class="version">3.10+</span> or multiple types joined using the <span class="code">|</span> operator), <span class="code">isinstance</span> returns <span class="code"><strong>True</strong></span> if <span class="code"><em>i</em></span> is an instance or subclass instance of any of the given types, and <span class="code"><strong>False</strong></span> otherwise.</p>
<section data-pdf-bookmark="__init__" data-type="sect3"><div class="sect3" id="init_">
<h3>__init__</h3>
<p>When<a contenteditable="false" data-primary="__init__ (special method)" data-type="indexterm" id="idm44924581669712"/> a class defines or inherits a method named <span class="code">__init__</span>, calling the class object executes <span class="code">__init__</span> on the new instance to perform per instance initialization. Arguments passed in the call must correspond to <span class="code">__init__</span>’s parameters, except for the parameter <span class="code">self</span>. For example, consider the following class definition:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">C6</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">n</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="bp">self</code><code class="o">.</code><code class="n">x</code><code> </code><code class="o">=</code><code> </code><code class="n">n</code></pre>
<p>Here’s how you can create an instance of the <span class="code">C6</span> class:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">another_instance</code> <code class="o">=</code> <code class="n">C6</code><code class="p">(</code><code class="mi">42</code><code class="p">)</code></pre>
<p>As shown in the <span class="code">C6</span> class definition, the <span class="code">__init__</span> method typically contains statements that bind instance attributes. An <span class="code">__init__</span> method must not return a value other than <span class="code"><strong>None</strong></span>; if it does, Python raises a <span class="code">TypeError</span> exception.</p>
<p>The main purpose of <span class="code">__init__</span> is to bind, and thus create, the attributes of a newly created instance. You may also bind, rebind, or unbind instance attributes outside <span class="code">__init__</span>. However, your code is more readable when you initially bind all class instance attributes in the <span class="code">__init__</span> method.</p>
<p>When <span class="code">__init__</span> is absent (and not inherited from any base class), you must call the class without arguments, and the new instance has no instance-specific attributes.</p>
</div></section>
<section data-pdf-bookmark="Attributes of instance objects" data-type="sect3"><div class="sect3" id="attributes_of_instance_objects">
<h3>Attributes of instance objects</h3>
<p>Once<a contenteditable="false" data-primary="attributes" data-secondary="of instance objects" data-secondary-sortas="instance objects" data-type="indexterm" id="idm44924581603360"/> you have created an instance, you can access its attributes (data and methods) using the dot (<span class="code">.</span>) operator. For example:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">an_instance</code><code class="o">.</code><code class="n">hello</code><code class="p">(</code><code class="p">)</code><code>                      </code><em><code class="c1"># prints:</code></em><code class="c1"> </code><em><code class="c1">Hello</code></em><code>
</code><code class="nb">print</code><code class="p">(</code><code class="n">another_instance</code><code class="o">.</code><code class="n">x</code><code class="p">)</code><code>                </code><em><code class="c1"># prints:</code></em><code class="c1"> </code><em><code class="c1">42</code></em></pre>
<p>Attribute references such as these have fairly rich semantics in Python; we cover them in detail in <a data-type="xref" href="#attribute_reference_basics">“Attribute Reference Basics”</a>.</p>
<p>You can give an instance object an attribute by binding a value to an attribute reference. For example:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">C7</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">pass</code></strong><code>
</code><code class="n">z</code><code> </code><code class="o">=</code><code> </code><code class="n">C7</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="n">z</code><code class="o">.</code><code class="n">x</code><code> </code><code class="o">=</code><code> </code><code class="mi">23</code><code>
</code><code class="nb">print</code><code class="p">(</code><code class="n">z</code><code class="o">.</code><code class="n">x</code><code class="p">)</code><code>                               </code><em><code class="c1"># prints:</code></em><code class="c1"> </code><em><code class="c1">23</code></em></pre>
<p>Instance object <span class="code">z</span> now has an attribute named <span class="code">x</span>, bound to the value <span class="code">23</span>, and <span class="code">z.x</span> refers to that attribute. The <span class="code">__setattr__</span> special method, if present, intercepts every attempt to bind an attribute. (We cover <span class="code">__setattr__</span> in <a data-type="xref" href="#general_purpose_special_methods">Table 4-1</a>.)</p>
<p>When you attempt to bind to an instance attribute whose name corresponds to an overriding descriptor in the class, the descriptor’s <span class="code">__set__</span> method intercepts the attempt: if <span class="code">C7.x</span> were an overriding descriptor, <span class="code">z.x=23</span> would execute <span class="code">type(z).x.__set__(z,</span> <span class="code">23)</span>.</p>
<p>Creating an instance sets two instance attributes. For any instance <span class="code"><em>z</em></span>, <span class="code"><em>z.</em></span><span class="code">__class__</span> is the class object to which <span class="code"><em>z</em></span> belongs, and <span class="code"><em>z.</em></span><span class="code">__dict__</span> is the mapping <span class="code"><em>z</em></span> uses to hold its other attributes. For example, for the instance <span class="code">z</span> we just created:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="nb">print</code><code class="p">(</code><code class="n">z</code><code class="o">.</code><code class="vm">__class__</code><code class="o">.</code><code class="vm">__name__</code><code class="p">,</code><code> </code><code class="n">z</code><code class="o">.</code><code class="vm">__dict__</code><code class="p">)</code><code>  </code><em><code class="c1"># prints:</code></em><code class="c1"> </code><em><code class="c1">C7 {'x':23}</code></em></pre>
<p>You may rebind (but not unbind) either or both of these attributes, but this is rarely necessary.</p>
<p>For any instance <span class="code"><em>z</em></span>, any object <span class="code"><em>x</em></span>, and any identifier <span class="code"><em>S</em></span> (except <span class="code">__class__</span> and <span class="code">__dict__</span>), <span class="code"><em>z.S</em></span><span class="code">=<em>x</em></span> is equivalent to <span class="code"><em>z</em></span>.<span class="code">__dict__['</span><span class="code"><em>S</em>']=</span><span class="code"><em>x</em></span> (unless a <span class="code">__setattr__</span> special method, or an overriding descriptor’s <span class="code">__set__</span> special method, intercepts the binding attempt). For example, again referring to the <span class="code">z</span> we just created:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">z</code><code class="o">.</code><code class="n">y</code><code> </code><code class="o">=</code><code> </code><code class="mi">45</code><code>
</code><code class="n">z</code><code class="o">.</code><code class="vm">__dict__</code><code class="p">[</code><code class="s1">'</code><code class="s1">z</code><code class="s1">'</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="mi">67</code><code>
</code><code class="nb">print</code><code class="p">(</code><code class="n">z</code><code class="o">.</code><code class="n">x</code><code class="p">,</code><code> </code><code class="n">z</code><code class="o">.</code><code class="n">y</code><code class="p">,</code><code> </code><code class="n">z</code><code class="o">.</code><code class="n">z</code><code class="p">)</code><code>                     </code><em><code class="c1"># prints:</code></em><code class="c1"> </code><em><code class="c1">23 45 67</code></em></pre>
<p>There is no difference between instance attributes created by assigning to attributes and those created by explicitly binding an entry in <span class="code"><em>z</em></span><span class="code">.__dict__</span>.</p>
</div></section>
<section data-pdf-bookmark="The factory function idiom" data-type="sect3"><div class="sect3" id="the_factory_function_idiom">
<h3>The factory function idiom</h3>
<p>It’s often necessary to create instances of different classes depending on some condition, or avoid creating a new instance if an existing one is available for reuse. A common misconception is that such needs might be met by having <span class="code">__init__</span> return a particular object. However, this approach is infeasible: Python raises an exception if <span class="code">__init__</span> returns any value other than <span class="code"><strong>None</strong></span>. The best way to implement flexible object creation is to use a function rather than calling the class object directly. A function used this way is known as a <em>factory function</em>.</p>
<p>Calling a factory function is a flexible approach: a function may return an existing reusable instance or create a new instance by calling whatever class is appropriate. Say you have two almost interchangeable classes, <span class="code">SpecialCase</span> and <span class="code">NormalCase</span>, and want to flexibly generate instances of either one of them, depending on an argument. The following <span class="code">appropriate_case</span> factory function, as a “toy” example, allows you to do just that (we’ll talk more about the<a contenteditable="false" data-primary="self parameter" data-type="indexterm" id="idm44924581604608"/> <span class="code">self</span> parameter in <a data-type="xref" href="#bound_and_unbound_methods">“Bound and Unbound Methods”</a>):</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">SpecialCase</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">amethod</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">special</code><code class="s1">'</code><code class="p">)</code><code>
</code><strong><code class="k">class</code></strong><code> </code><code class="nc">NormalCase</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">amethod</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">normal</code><code class="s1">'</code><code class="p">)</code><code>
</code><strong><code class="k">def</code></strong><code> </code><code class="nf">appropriate_case</code><code class="p">(</code><code class="n">isnormal</code><code class="o">=</code><strong><code class="kc">True</code></strong><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">if</code></strong><code> </code><code class="n">isnormal</code><code class="p">:</code><code>
</code><code>        </code><strong><code class="k">return</code></strong><code> </code><code class="n">NormalCase</code><code class="p">(</code><code class="p">)</code><code>
</code><code>    </code><strong><code class="k">else</code><code class="p">:</code></strong><code>
</code><strong><code>        </code><code class="k">return</code></strong><code> </code><code class="n">SpecialCase</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="n">aninstance</code><code> </code><code class="o">=</code><code> </code><code class="n">appropriate_case</code><code class="p">(</code><code class="n">isnormal</code><code class="o">=</code><strong><code class="kc">False</code></strong><code class="p">)</code><code>
</code><code class="n">aninstance</code><code class="o">.</code><code class="n">amethod</code><code class="p">(</code><code class="p">)</code><code>                  </code><em><code class="c1"># prints:</code></em><code class="c1"> </code><em><code class="c1">special</code></em></pre>
</div></section>
<section data-pdf-bookmark="__new__" data-type="sect3"><div class="sect3" id="new_">
<h3>__new__</h3>
<p>Every class has (or inherits) a class method named <span class="code">__new__</span> (we cover class methods in <a data-type="xref" href="#class_methods">“Class methods”</a>). When you call <span class="code"><em>C</em></span><span class="code">(*<em>args</em>, **<em>kwds</em>)</span> to create a new instance of class <span class="code"><em>C</em></span>, Python first calls <span class="code"><em>C.</em></span><span class="code">__new__(<em>C</em>, *<em>args</em>, **<em>kwds</em>)</span>, and uses <span class="code">__new__</span>’s return value <span class="code"><em>x</em></span> as the newly created instance. Then Python calls <span class="code"><em>C.</em></span><span class="code">__init__(<em>x</em>, *<em>args</em>, **<em>kwds</em>)</span>, but only when <span class="code"><em>x</em></span> is indeed an instance of <span class="code"><em>C</em></span> or any of its subclasses (otherwise, <span class="code"><em>x</em></span>’s state remains as <span class="code">__new__</span> had left it). Thus, for example, the statement <span class="code"><em>x</em></span><span class="code">=<em>C</em>(23)</span> is equivalent to:</p>
<pre data-code-language="python" data-type="programlisting">
<em><code class="n">x</code></em><code> </code><code class="o">=</code><code> </code><em><code class="n">C</code></em><code class="o">.</code><code class="fm">__new__</code><code class="p">(</code><em><code class="n">C</code></em><code class="p">,</code><code> </code><code class="mi">23</code><code class="p">)</code><code>
</code><strong><code class="k">if</code></strong><code> </code><code class="nb">isinstance</code><code class="p">(</code><em><code class="n">x</code></em><code class="p">,</code><code> </code><em><code class="n">C</code></em><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="nb">type</code><code class="p">(</code><em><code class="n">x</code></em><code class="p">)</code><code class="o">.</code><code class="fm">__init__</code><code class="p">(</code><em><code class="n">x</code></em><code class="p">,</code><code> </code><code class="mi">23</code><code class="p">)</code></pre>
<p><span class="code">object.__new__</span> creates a new, uninitialized instance of the class it receives as its first argument. It ignores other arguments when that class has an <span class="code">__init__</span> method, but it raises an exception when it receives other arguments beyond the first, and the class that’s the first argument does not have an <span class="code">__init__</span> method. When you override <span class="code">__new__</span> within a class body, you do not need to add <span class="code">__new__=classmethod(__new__)</span>, nor use an <span class="code">@classmethod</span> decorator, as you normally would: Python recognizes the name <span class="code">__new__</span> and treats it as special in this context. In those sporadic cases in which you rebind <span class="code"><em>C</em></span><span class="code">.__new__</span> later, outside the body of class <span class="code"><em>C</em></span>, you do need to use <span class="code"><em>C</em></span><span class="code">.__new__=classmethod(<em>whatever</em>)</span>.</p>
<p><span class="code">__new__</span> has most of the flexibility of a factory function, as covered in the previous section. <span class="code">__new__</span> may choose to return an existing instance or make a new one, as appropriate. When <span class="code">__new__</span> does create a new instance, it usually delegates creation to <span class="code">object.__new__</span> or the <span class="code">__new__</span> method of another superclass of <span class="code"><em>C</em></span>.</p>
<p>The following example shows how to override the class method <span class="code">__new__</span> in order to implement a version of the Singleton design pattern:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">Singleton</code><code class="p">:</code><code>
</code><code>    </code><code class="n">_singletons</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code class="p">}</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__new__</code><code class="p">(</code><code class="bp">cls</code><code class="p">,</code><code> </code><code class="o">*</code><code class="n">args</code><code class="p">,</code><code> </code><code class="o">*</code><code class="o">*</code><code class="n">kwds</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><strong><code class="k">if</code></strong><code> </code><code class="bp">cls</code><code> </code><strong><code class="ow">not</code><code> </code><code class="ow">in</code></strong><code> </code><code class="bp">cls</code><code class="o">.</code><code class="n">_singletons</code><code class="p">:</code><code>
</code><code>            </code><code class="bp">cls</code><code class="o">.</code><code class="n">_singletons</code><code class="p">[</code><code class="bp">cls</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="n">obj</code><code> </code><code class="o">=</code><code> </code><code class="nb">super</code><code class="p">(</code><code class="p">)</code><code class="o">.</code><code class="fm">__new__</code><code class="p">(</code><code class="bp">cls</code><code class="p">)</code><code>
</code><code>            </code><code class="n">obj</code><code class="o">.</code><code class="n">_initialized</code><code> </code><code class="o">=</code><code> </code><code class="kc">False</code><code>
</code><code>        </code><strong><code class="k">return</code></strong><code> </code><code class="bp">cls</code><code class="o">.</code><code class="n">_singletons</code><code class="p">[</code><code class="bp">cls</code><code class="p">]</code></pre>
<p>(We cover the built-in <span class="code">super</span> in <a data-type="xref" href="#cooperative_superclass_method_calling">“Cooperative superclass method calling”</a>.)</p>
<p>Any subclass of <span class="code">Singleton</span> (that does not further override <span class="code">__new__</span>) has exactly one instance. When the subclass defines <span class="code">__init__</span>, it must ensure <span class="code">__init__</span> is safe to call repeatedly (at each call of the subclass) on the subclass’s only instance.<sup><a data-type="noteref" href="ch04.xhtml#ch01fn50" id="ch01fn50-marker">3</a></sup> In this example, we insert the <span class="code">_initialized</span> attribute, set to <span class="code"><strong>False</strong></span>, when <span class="code">__new__</span> actually creates a new instance. Subclasses’ <span class="code">__init__</span> methods can test if <span class="code">self._initialized</span> is <span class="code"><strong>False</strong></span> and, if so, set it to <span class="code"><strong>True</strong></span> and continue with the rest of the <span class="code">__init__</span> method. When subsequent “creates” of the singleton instance call <span class="code">__init__</span> again, <span class="code">self._initialized</span> will be <span class="code"><strong>True</strong></span>, indicating the instance is already initialized, and <span class="code">__init__</span> can typically just return, avoiding some repetitive work.<a contenteditable="false" data-primary="" data-startref="instances04" data-type="indexterm" id="idm44924581035648"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Attribute Reference Basics" data-type="sect2"><div class="sect2" id="attribute_reference_basics">
<h2>Attribute Reference Basics</h2>
<p>An<a contenteditable="false" data-primary="classes" data-secondary="attribute reference basics" data-type="indexterm" id="idm44924581032400"/><a contenteditable="false" data-primary="attributes" data-secondary="attribute reference basics" data-type="indexterm" id="ATrefbas04"/> <em>attribute reference</em> is an expression of the form <span class="code"><em>x.name</em></span>, where <span class="code"><em>x</em></span> is any expression and <span class="code"><em>name</em></span> is an identifier called the <em>attribute name</em>. Many Python objects have attributes, but an attribute reference has special, rich semantics when <span class="code"><em>x</em></span> refers to a class or instance. Methods are attributes, too, so everything we say about attributes in general also applies to callable attributes (i.e., methods).</p>
<p>Say that <span class="code"><em>x</em></span> is an instance of class <span class="code">C</span>, which inherits from base class <span class="code">B</span>. Both classes and the instance have several attributes (data and methods), as follows:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">B</code><code class="p">:</code><code>
</code><code>    </code><code class="n">a</code><code> </code><code class="o">=</code><code> </code><code class="mi">23</code><code>
</code><code>    </code><code class="n">b</code><code> </code><code class="o">=</code><code> </code><code class="mi">45</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">f</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">method f in class B</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">g</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">method g in class B</code><code class="s1">'</code><code class="p">)</code><code>
</code><strong><code class="k">class</code></strong><code> </code><code class="nc">C</code><code class="p">(</code><code class="n">B</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">b</code><code> </code><code class="o">=</code><code> </code><code class="mi">67</code><code>
</code><code>    </code><code class="n">c</code><code> </code><code class="o">=</code><code> </code><code class="mi">89</code><code>
</code><code>    </code><code class="n">d</code><code> </code><code class="o">=</code><code> </code><code class="mi">123</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">g</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">method g in class C</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">h</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">method h in class C</code><code class="s1">'</code><code class="p">)</code><code>
</code><code class="n">x</code><code> </code><code class="o">=</code><code> </code><code class="n">C</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="n">x</code><code class="o">.</code><code class="n">d</code><code> </code><code class="o">=</code><code> </code><code class="mi">77</code><code>
</code><code class="n">x</code><code class="o">.</code><code class="n">e</code><code> </code><code class="o">=</code><code> </code><code class="mi">88</code></pre>
<p>A<a contenteditable="false" data-primary="dunder (double underscore)" data-secondary="attribute references" data-type="indexterm" id="idm44924584581008"/> few attribute dunder names are special. <span class="code"><em>C</em></span><span class="code">.__name__</span> is the string <span class="code">'<em>C</em>'</span>, the class’s name. <span class="code"><em>C</em></span><span class="code">.__bases__</span> is the tuple <span class="code">(<em>B</em>,)</span>, the tuple of <span class="code"><em>C</em></span>’s base classes. <span class="code"><em>x</em></span><span class="code">.__class__</span> is the class <span class="code"><em>C</em></span> to which <span class="code"><em>x</em></span> belongs. When you refer to an attribute with one of these special names, the attribute reference looks directly into a dedicated slot in the class or instance object and fetches the value it finds there. You cannot unbind these attributes. You may rebind them on the fly, changing the name or base classes of a class or the class of an instance, but this advanced technique is rarely necessary.</p>
<p>Class <span class="code"><em>C</em></span> and instance <span class="code"><em>x</em></span> each have one other special attribute: a mapping named <span class="code">__dict__</span> (typically mutable for <span class="code"><em>x</em></span>, but not for <span class="code"><em>C</em></span>). All other attributes of a class or instance,<sup><a data-type="noteref" href="ch04.xhtml#ch01fn51" id="ch01fn51-marker">4</a></sup> except the few special ones, are held as items in the <span class="code">__dict__</span> attribute of the class or instance.</p>
<section data-pdf-bookmark="Getting an attribute from a class" data-type="sect3"><div class="sect3" id="getting_an_attribute_from_a_class">
<h3>Getting an attribute from a class</h3>
<p>When you use the syntax <span class="code"><em>C.name</em></span> to refer to an attribute on a class object <span class="code"><em>C</em></span>, lookup proceeds in two steps:</p>
<ol>
<li>
<p>When <span class="code">'<em>name</em>'</span> is a key in <span class="code"><em>C.</em></span><span class="code">__dict__</span>, <span class="code"><em>C.name</em></span> fetches the value <span class="code"><em>v</em></span> from <span class="code"><em>C.</em></span><span class="code">__dict__['<em>name</em>']</span>. Then, when <span class="code"><em>v</em></span> is a descriptor (i.e., <span class="code">type(<em>v</em>)</span> supplies a method named <span class="code">__get__</span>), the value of <span class="code"><em>C.name</em></span> is the result of calling <span class="code">type(<em>v</em>).__get__(<em>v</em>, None,</span> <span class="code"><em>C</em></span><span class="code">)</span>. When <span class="code"><em>v</em></span> is not a descriptor, the value of <span class="code"><em>C.name</em></span> is <span class="code"><em>v</em></span>.</p>
</li>
<li>
<p>When <span class="code">'<em>name</em>'</span> is <em>not</em> a key in <span class="code"><em>C</em></span>.<span class="code">__dict__</span>, <span class="code"><em>C.name</em></span> delegates the lookup to <span class="code"><em>C</em></span>’s base classes, meaning it loops on <span class="code"><em>C</em></span>’s ancestor classes and tries the <span class="code"><em>name</em></span> lookup on each (in <em>method resolution order</em>, as covered in <a data-type="xref" href="#inheritance">“Inheritance”</a>).</p>
</li>
</ol>
</div></section>
<section data-pdf-bookmark="Getting an attribute from an instance" data-type="sect3"><div class="sect3" id="getting_an_attribute_from_an_instance">
<h3>Getting an attribute from an instance</h3>
<p>When you use the syntax <span class="code"><em>x.name</em></span> to refer to an attribute of instance <span class="code"><em>x</em></span> of class <span class="code"><em>C</em></span>, lookup proceeds in three steps:</p>
<ol>
<li>
<p>When <span class="code">'<em>name</em>'</span> is in <span class="code"><em>C</em></span> (or in one of <span class="code"><em>C</em></span>’s ancestor classes) as the name of an overriding descriptor <span class="code"><em>v</em></span> (i.e., <span class="code">type(<em>v</em>)</span> supplies methods <span class="code">__get__</span> and <span class="code">__set__</span>), the value of <span class="code"><em>x.name</em></span> is the result of <span class="code">type(<em>v</em>).__get__(<em>v, x, C</em>)</span>.</p>
</li>
<li>
<p>Otherwise, when <span class="code">'<em>name</em>'</span> is a key in <span class="code"><em>x</em></span><span class="code">.__dict__</span>, <span class="code"><em>x.name</em></span> fetches and returns the value at <span class="code"><em>x</em></span><span class="code">.__dict__['<em>name</em>']</span>.</p>
</li>
<li>
<p>Otherwise, <span class="code"><em>x.name</em></span> delegates the lookup to <span class="code"><em>x</em></span>’s class (according to the same two-step lookup process used for <span class="code"><em>C.name</em></span>, as just detailed):</p>
<ul>
<li>
<p>When this finds a descriptor <span class="code"><em>v</em></span>, the overall result of the attribute lookup is, again, <span class="code">type(<em>v</em>).__get__(<em>v, x, C</em>)</span>.</p>
</li>
<li>
<p>When this finds a nondescriptor value <span class="code"><em>v</em></span>, the overall result of the attribute lookup is just <span class="code"><em>v</em></span>.</p>
</li>
</ul>
</li>
</ol>
<p>When these lookup steps do not find an attribute, Python raises an <span class="code">AttributeError</span> exception. However, for lookups of <span class="code"><em>x.name</em></span>, when <span class="code"><em>C</em></span> defines or inherits the special method <span class="code">__getattr__</span>, Python calls <span class="code"><em>C</em></span><span class="code">.__getattr__(<em>x,</em></span> <span class="code">'</span><span class="code"><em>name</em>')</span> rather than raising the exception. It’s then up to <span class="code">__getattr__</span> to return a suitable value or raise the appropriate exception, normally <span class="code">AttributeError</span>.</p>
<p>Consider the following attribute references, defined previously:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="nb">print</code><code class="p">(</code><code class="n">x</code><code class="o">.</code><code class="n">e</code><code class="p">,</code><code> </code><code class="n">x</code><code class="o">.</code><code class="n">d</code><code class="p">,</code><code> </code><code class="n">x</code><code class="o">.</code><code class="n">c</code><code class="p">,</code><code> </code><code class="n">x</code><code class="o">.</code><code class="n">b</code><code class="p">,</code><code> </code><code class="n">x</code><code class="o">.</code><code class="n">a</code><code class="p">)</code><code>             </code><em><code class="c1"># prints:</code></em><code class="c1"> </code><em><code class="c1">88 77 89 67 23</code></em></pre>
<p><span class="code">x.e</span> and <span class="code">x.d</span> succeed in step 2 of the instance lookup process, since no descriptors are involved and <span class="code">'e'</span> and <span class="code">'d'</span> are both keys in <span class="code">x.__dict__</span>. Therefore, the lookups go no further but rather return <span class="code">88</span> and <span class="code">77</span>. The other three references must proceed to step 3 of the instance lookup process and look in <span class="code">x.__class__</span> (i.e., <span class="code">C</span>). <span class="code">x.c</span> and <span class="code">x.b</span> succeed in step 1 of the class lookup process, since <span class="code">'c'</span> and <span class="code">'b'</span> are both keys in <span class="code">C.__dict__</span>. Therefore, the lookups go no further but rather return <span class="code">89</span> and <span class="code">67</span>. <span class="code">x.a</span> gets all the way to step 2 of the class lookup process, looking in <span class="code">C<em>.</em>__bases__[0]</span> (i.e., <span class="code">B</span>). <span class="code">'a'</span> is a key in <span class="code">B<em>.</em>__dict__</span>; therefore, <span class="code">x.a</span> finally succeeds and returns <span class="code">23</span>.</p>
</div></section>
<section data-pdf-bookmark="Setting an attribute" data-type="sect3"><div class="sect3" id="setting_an_attribute">
<h3>Setting an attribute</h3>
<p>Note that the attribute lookup steps happen as just described only when you <em>refer</em> to an attribute, not when you <em>bind</em> an attribute. When you bind to a class or instance attribute whose name is not special (unless a <span class="code">__setattr__</span> method, or the <span class="code">__set__</span> method of an overriding descriptor, intercepts the binding of an instance attribute), you affect only the <span class="code">__dict__</span> entry for the attribute (in the class or instance, respectively). In other words, for attribute binding, there is no lookup procedure involved, except for the check for overriding descriptors.<a contenteditable="false" data-primary="" data-startref="ATrefbas04" data-type="indexterm" id="idm44924584400144"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Bound and Unbound Methods" data-type="sect2"><div class="sect2" id="bound_and_unbound_methods">
<h2>Bound and Unbound Methods</h2>
<p>The<a contenteditable="false" data-primary="classes" data-secondary="bound and unbound methods" data-type="indexterm" id="idm44924584396592"/><a contenteditable="false" data-primary="bound methods" data-type="indexterm" id="bmeth04"/><a contenteditable="false" data-primary="unbound methods" data-type="indexterm" id="ubmeth04"/><a contenteditable="false" data-primary="methods" data-secondary="bound and unbound methods" data-type="indexterm" id="Mbandumeth04"/> method <span class="code">__get__</span> of a function object can return the function object itself, or a <em>bound method object</em> that wraps the function; a bound method is associated with the specific instance it’s obtained from.</p>
<p>In the code in the previous section, the attributes <span class="code">f</span>, <span class="code">g</span>, and <span class="code">h</span> are functions; therefore, an attribute reference to any one of them returns a method object that wraps the respective function. Consider the following:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="nb">print</code><code class="p">(</code><code class="n">x</code><code class="o">.</code><code class="n">h</code><code class="p">,</code> <code class="n">x</code><code class="o">.</code><code class="n">g</code><code class="p">,</code> <code class="n">x</code><code class="o">.</code><code class="n">f</code><code class="p">,</code> <code class="n">C</code><code class="o">.</code><code class="n">h</code><code class="p">,</code> <code class="n">C</code><code class="o">.</code><code class="n">g</code><code class="p">,</code> <code class="n">C</code><code class="o">.</code><code class="n">f</code><code class="p">)</code></pre>
<p>This statement outputs three bound methods, represented by strings like:</p>
<pre data-type="programlisting">
<strong>&lt;bound method C.h of &lt;__main__.C object at 0x8156d5c&gt;&gt;</strong></pre>
<p>and then three function objects, represented by strings like:</p>
<pre data-type="programlisting">
<strong>&lt;function C.h at 0x102cabae8&gt;</strong></pre>
<div data-type="note" epub:type="note">
<h1>Bound Methods Versus Function Objects</h1>
<p>We get bound methods when the attribute reference is on instance <span class="code"><em>x</em></span>, and function objects when the attribute reference is on class <span class="code"><em>C</em></span>.</p>
</div>
<p>Because a bound method is already associated with a specific instance, you can call the method as follows:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">x</code><code class="o">.</code><code class="n">h</code><code class="p">(</code><code class="p">)</code><code>                   </code><em><code class="c1"># prints:</code></em><code class="c1"> </code><em><code class="c1">method h in class C</code></em></pre>
<p>The key thing to notice here is that you don’t pass the method’s first argument, <span class="code">self</span>, by the usual argument-passing syntax. Rather, a bound method of instance <span class="code"><em>x</em></span> implicitly binds the<a contenteditable="false" data-primary="self parameter" data-type="indexterm" id="idm44924584314176"/> <span class="code">self</span> parameter to object <span class="code"><em>x</em></span>. Thus, the method’s body can access the instance’s attributes as attributes of <span class="code">self</span>, even though we don’t pass an explicit argument to the method.</p>
<p>Let’s take a closer look at bound methods. When an attribute reference on an instance, in the course of the lookup, finds a function object that’s an attribute in the instance’s class, the lookup calls the function’s <span class="code">__get__</span> method to get the attribute’s value. The call, in this case, creates and returns a <em>bound method</em> that wraps the function.</p>
<p>Note that when the attribute reference’s lookup finds a function object directly in <span class="code"><em>x</em></span><span class="code">.__dict__</span>, the attribute reference operation does <em>not</em> create a bound method. In such cases, Python does not treat the function as a descriptor and does not call the function’s <span class="code">__get__</span> method; rather, the function object itself is the attribute’s value. Similarly, Python creates no bound methods for callables that are not ordinary functions, such as built-in (as opposed to Python-coded) functions, since such callables are not descriptors.</p>
<p>A bound method has three read-only attributes in addition to those of the function object it wraps: <span class="code">im_class</span> is the class object that supplies the method, <span class="code">im_func</span> is the wrapped function, and <span class="code">im_self</span> refers to <span class="code"><em>x</em></span>, the instance from which you got the method.</p>
<p>You use a bound method just like its <span class="code">im_func</span> function, but calls to a bound method do not explicitly supply an argument corresponding to the first parameter (conventionally named <span class="code">self</span>). When you call a bound method, the bound method passes <span class="code">im_self</span> as the first argument to <span class="code">im_func</span> before other arguments (if any) given at the point of call.</p>
<p>Let’s follow, in excruciatingly low-level detail, the conceptual steps involved in a method call with the normal syntax <span class="code"><em>x.name</em></span><span class="code">(<em>arg</em>)</span>. In the following context:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">def</code></strong><code> </code><code class="nf">f</code><code class="p">(</code><code class="n">a</code><code class="p">,</code><code> </code><code class="n">b</code><code class="p">)</code><code class="p">:</code><code> </code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>              </code><em><code class="c1"># a function f with two arguments</code></em><code>
</code><code>
</code><strong><code class="k">class</code></strong><code> </code><code class="nc">C</code><code class="p">:</code><code>
</code><code>    </code><code class="n">name</code><code> </code><code class="o">=</code><code> </code><code class="n">f</code><code>
</code><code class="n">x</code><code> </code><code class="o">=</code><code> </code><code class="n">C</code><code class="p">(</code><code class="p">)</code></pre>
<p><span class="code">x</span> is an instance object of class <span class="code">C</span>, <span class="code">name</span> is an identifier that names a method of <span class="code">x</span>’s (an attribute of <span class="code">C</span> whose value is a function, in this case function <span class="code">f</span>), and <span class="code"><em>arg</em></span> is any expression. Python first checks if <span class="code">'name'</span> is the attribute name in <span class="code">C</span> of an overriding descriptor, but it isn’t—functions are descriptors, because their type defines the method <span class="code">__get__</span>, but <em>not</em> overriding ones, because their type does not define the method <span class="code">__set__</span>. Python next checks if <span class="code">'name'</span> is a key in <span class="code">x._dict__</span>, but it isn’t. So, Python finds <span class="code">name</span> in <span class="code">C</span> (everything would work just the same if <span class="code">name</span> were found, by inheritance, in one of <span class="code">C</span>’s <span class="code">__bases__</span>). Python notices that the attribute’s value, function object <span class="code">f</span>, is a descriptor. Therefore, Python calls <span class="code">f.__get__(x, C)</span>, which returns a bound method object with <span class="code">im_func</span> set to <span class="code">f</span>, <span class="code">im_class</span> set to <span class="code">C</span>, and <span class="code">im_self</span> set to <span class="code">x</span>. Then Python calls this bound method object, with <span class="code"><em>arg</em></span> as the only argument. The bound method inserts <span class="code">im_self</span> (i.e., <span class="code">x</span>) as the first argument, and <span class="code"><em>arg</em></span> becomes the second one in a call to the bound method’s <span class="code">im_func</span> (i.e., function <span class="code">f</span>). The overall effect is just like calling:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">x</code><code class="o">.</code><code class="vm">__class__</code><code class="o">.</code><code class="vm">__dict__</code><code class="p">[</code><code class="s1">'</code><code class="s1">name</code><code class="s1">'</code><code class="p">]</code><code class="p">(</code><code class="n">x</code><code class="p">,</code><code> </code><em><code class="n">arg</code></em><code class="p">)</code></pre>
<p>When a bound method’s function body executes, it has no special namespace relationship to either its <span class="code">self</span> object or any class. Variables referenced are local or global, just like any other function, as covered in <a data-type="xref" href="ch03.xhtml#namespaces">“Namespaces”</a>. Variables do not implicitly indicate attributes in <span class="code">self</span>, nor do they indicate attributes in any class object. When the method needs to refer to, bind, or unbind an attribute of its <span class="code">self</span> object, it does so by standard attribute reference syntax (e.g., <span class="code">self.</span><span class="code"><em>name</em></span>).<sup><a data-type="noteref" href="ch04.xhtml#ch01fn52" id="ch01fn52-marker">5</a></sup> The lack of implicit scoping may take some getting used to (simply because Python differs in this respect from many, though far from all, other object-oriented languages), but it results in clarity, simplicity, and the removal of potential ambiguities.</p>
<p>Bound method objects are first-class objects: you can use them wherever you can use a callable object. Since a bound method holds references to both the function it wraps and the <span class="code">self</span> object on which it executes, it’s a powerful and flexible alternative to a closure (covered in <a data-type="xref" href="ch03.xhtml#nested_functions_and_nested_scopes">“Nested functions and nested scopes”</a>). An instance object whose class supplies the special method <span class="code">__call__</span> (covered in <a data-type="xref" href="#general_purpose_special_methods">Table 4-1</a>) offers another viable alternative. These constructs let you bundle some behavior (code) and some state (data) into a single callable object. Closures are simplest, but they are somewhat limited in their applicability. Here’s the closure from the section on nested functions and nested scopes:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">def</code></strong><code> </code><code class="nf">make_adder_as_closure</code><code class="p">(</code><code class="n">augend</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">add</code><code class="p">(</code><code class="n">addend</code><code class="p">,</code><code> </code><code class="n">_augend</code><code class="o">=</code><code class="n">augend</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><strong><code class="k">return</code></strong><code> </code><code class="n">addend</code><code> </code><code class="o">+</code><code> </code><code class="n">_augend</code><code>
</code><code>    </code><strong><code class="k">return</code></strong><code> </code><code class="n">add</code></pre>
<p>Bound methods and callable instances are richer and more flexible than closures. Here’s how to implement the same functionality with a bound method:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">def</code></strong><code> </code><code class="nf">make_adder_as_bound_method</code><code class="p">(</code><code class="n">augend</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">class</code></strong><code> </code><code class="nc">Adder</code><code class="p">:</code><code>
</code><code>        </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">augend</code><code class="p">)</code><code class="p">:</code><code>
</code><code>            </code><code class="bp">self</code><code class="o">.</code><code class="n">augend</code><code> </code><code class="o">=</code><code> </code><code class="n">augend</code><code>
</code><code>        </code><strong><code class="k">def</code></strong><code> </code><code class="nf">add</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">addend</code><code class="p">)</code><code class="p">:</code><code>
</code><code>            </code><strong><code class="k">return</code></strong><code> </code><code class="n">addend</code><code class="o">+</code><code class="bp">self</code><code class="o">.</code><code class="n">augend</code><code>
</code><code>    </code><strong><code class="k">return</code></strong><code> </code><code class="n">Adder</code><code class="p">(</code><code class="n">augend</code><code class="p">)</code><code class="o">.</code><code class="n">add</code></pre>
<p>And here’s how to implement it with a callable instance (an instance whose class supplies the special method <span class="code">__call__</span>):</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">def</code></strong><code> </code><code class="nf">make_adder_as_callable_instance</code><code class="p">(</code><code class="n">augend</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">class</code></strong><code> </code><code class="nc">Adder</code><code class="p">:</code><code>
</code><code>        </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">augend</code><code class="p">)</code><code class="p">:</code><code>
</code><code>            </code><code class="bp">self</code><code class="o">.</code><code class="n">augend</code><code> </code><code class="o">=</code><code> </code><code class="n">augend</code><code>
</code><code>        </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__call__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">addend</code><code class="p">)</code><code class="p">:</code><code>
</code><code>            </code><strong><code class="k">return</code></strong><code> </code><code class="n">addend</code><code class="o">+</code><code class="bp">self</code><code class="o">.</code><code class="n">augend</code><code>
</code><code>    </code><strong><code class="k">return</code></strong><code> </code><code class="n">Adder</code><code class="p">(</code><code class="n">augend</code><code class="p">)</code></pre>
<p>From the viewpoint of the code that calls the functions, all of these factory functions are interchangeable, since all of them return callable objects that are polymorphic (i.e., usable in the same ways). In terms of implementation, the closure is simplest; the object-oriented approaches—i.e., the bound method and the callable instance—use more flexible, general, and powerful mechanisms, but there is no need for that extra power in this simple example (since no other state is required beyond the <span class="code">augend</span>, which is just as easily carried in the closure as in either of the object-oriented approaches).<a contenteditable="false" data-primary="" data-startref="Mbandumeth04" data-type="indexterm" id="idm44924583965696"/><a contenteditable="false" data-primary="" data-startref="ubmeth04" data-type="indexterm" id="idm44924583977008"/><a contenteditable="false" data-primary="" data-startref="bmeth04" data-type="indexterm" id="idm44924583975632"/></p>
</div></section>
<section data-pdf-bookmark="Inheritance" data-type="sect2"><div class="sect2" id="inheritance">
<h2>Inheritance</h2>
<p>When<a contenteditable="false" data-primary="classes" data-secondary="inheritance" data-type="indexterm" id="idm44924583972800"/><a contenteditable="false" data-primary="inheritance" data-secondary="details of" data-type="indexterm" id="inherit04"/> you use an attribute reference <span class="code"><em>C.name</em></span> on a class object <span class="code"><em>C</em></span>, and <span class="code">'<em>name</em>'</span> is not a key in <span class="code"><em>C</em></span><span class="code">.__dict__</span>, the lookup implicitly proceeds on each class object that is in <span class="code"><em>C</em></span><span class="code">.__bases__</span> in a specific order (which for historical reasons is known as the <em>method resolution order</em>, or MRO, but in fact applies to all attributes, not just methods). <span class="code"><em>C</em></span>’s base classes may in turn have their own bases. The lookup checks direct and indirect ancestors, one by one, in MRO, stopping when <span class="code">'<em>name</em>'</span> is found.</p>
<section data-pdf-bookmark="Method resolution order" data-type="sect3"><div class="sect3" id="method_resolution_order">
<h3>Method resolution order</h3>
<p>The lookup of an attribute name in a class essentially occurs by visiting ancestor classes in left-to-right, depth-first order. However, in the presence of multiple inheritance (which makes the inheritance graph a general <em>directed acyclic graph</em>, or DAG, rather than specifically a tree), this simple approach might lead to some ancestor classes being visited twice. In such cases, the resolution order leaves in the lookup sequence only the <em>rightmost</em> occurrence of any given class.</p>
<p>Each class and built-in type has a special read-only class attribute called <span class="code">__mro__</span>, which is the tuple of types used for method resolution, in order. You can reference <span class="code">__mro__</span> only on classes, not on instances, and, since <span class="code">__mro__</span> is a read-only attribute, you cannot rebind or unbind it. For a detailed and highly technical explanation of all aspects of Python’s MRO, you may want to study Michele Simionato’s essay <a href="https://oreil.ly/pf6RF">“The Python 2.3 Method Resolution Order”</a><sup><a data-type="noteref" href="ch04.xhtml#ch01fn53" id="ch01fn53-marker">6</a></sup> and Guido van Rossum’s article on <a href="https://oreil.ly/hetjd">“The History of Python”</a>. In particular, note that it <em>is</em> quite possible that Python cannot determine <em>any</em> unambiguous MRO for a certain class: in this case, Python raises a <span class="code">TypeError</span> exception when it executes that <span class="code"><strong>class</strong></span> statement.</p>
</div></section>
<section data-pdf-bookmark="Overriding attributes" data-type="sect3"><div class="sect3" id="overriding_attributes">
<h3>Overriding attributes</h3>
<p>As we’ve just seen, the search for an attribute proceeds along the MRO (typically, up the inheritance tree) and stops as soon as the attribute is found. Descendant classes are always examined before their ancestors, so that when a subclass defines an attribute with the same name as one in a superclass, the search finds the definition in the subclass and stops there. This is known as the subclass <em>overriding</em> the definition in the superclass. Consider the following code:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">B</code><code class="p">:</code><code>
</code><code>    </code><code class="n">a</code><code> </code><code class="o">=</code><code> </code><code class="mi">23</code><code>
</code><code>    </code><code class="n">b</code><code> </code><code class="o">=</code><code> </code><code class="mi">45</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">f</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">method f in class B</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">g</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">method g in class B</code><code class="s1">'</code><code class="p">)</code><code>
</code><strong><code class="k">class</code></strong><code> </code><code class="nc">C</code><code class="p">(</code><code class="n">B</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">b</code><code> </code><code class="o">=</code><code> </code><code class="mi">67</code><code>
</code><code>    </code><code class="n">c</code><code> </code><code class="o">=</code><code> </code><code class="mi">89</code><code>
</code><code>    </code><code class="n">d</code><code> </code><code class="o">=</code><code> </code><code class="mi">123</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">g</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">method g in class C</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">h</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">method h in class C</code><code class="s1">'</code><code class="p">)</code></pre>
<p>Here, class <span class="code">C</span> overrides attributes <span class="code">b</span> and <span class="code">g</span> of its superclass <span class="code">B</span>. Note that, unlike in some other languages, in Python you may override data attributes just as easily as callable attributes (methods).</p>
</div></section>
<section data-pdf-bookmark="Delegating to superclass methods" data-type="sect3"><div class="sect3" id="delegating_to_superclass_methods">
<h3>Delegating to superclass methods</h3>
<p>When subclass <span class="code"><em>C</em></span> overrides a method <span class="code"><em>f</em></span> of its superclass <span class="code"><em>B</em></span>, the body of <span class="code"><em>C</em></span><span class="code">.</span><span class="code"><em>f</em></span> often wants to delegate some part of its operation to the superclass’s implementation of the method. This can sometimes be done using a function object, as follows:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">Base</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">greet</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">name</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">Welcome</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">name</code><code class="p">)</code><code>
</code><strong><code class="k">class</code></strong><code> </code><code class="nc">Sub</code><code class="p">(</code><code class="n">Base</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">greet</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">name</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">Well Met and</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">end</code><code class="o">=</code><code class="s1">'</code><code class="s1"> </code><code class="s1">'</code><code class="p">)</code><code>
</code><code>        </code><code class="n">Base</code><code class="o">.</code><code class="n">greet</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">name</code><code class="p">)</code><code>
</code><code class="n">x</code><code> </code><code class="o">=</code><code> </code><code class="n">Sub</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="n">x</code><code class="o">.</code><code class="n">greet</code><code class="p">(</code><code class="s1">'</code><code class="s1">Alex</code><code class="s1">'</code><code class="p">)</code></pre>
<p>The delegation to the superclass, in the body of <span class="code">Sub.greet</span>, uses a function object obtained by attribute reference <span class="code">Base.greet</span> on the superclass, and therefore passes all arguments normally, including <span class="code">self</span>. (If it seems a bit ugly explicitly using the base class, bear with us; you’ll see a better way to do this shortly, in this very section). Delegating to a superclass implementation is a frequent use of such function objects.</p>
<p>One common use of delegation occurs with the special method <span class="code">__init__</span>. When Python creates an instance, it does not automatically call the <span class="code">__init__</span> methods of any base classes, unlike some other object-oriented languages. It is up to a subclass to initialize its superclasses, using delegation as necessary. For example:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">Base</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="bp">self</code><code class="o">.</code><code class="n">anattribute</code><code> </code><code class="o">=</code><code> </code><code class="mi">23</code><code>
</code><strong><code class="k">class</code></strong><code> </code><code class="nc">Derived</code><code class="p">(</code><code class="n">Base</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="n">Base</code><code class="o">.</code><code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code>
</code><code>        </code><code class="bp">self</code><code class="o">.</code><code class="n">anotherattribute</code><code> </code><code class="o">=</code><code> </code><code class="mi">45</code></pre>
<p>If the <span class="code">__init__</span> method of class <span class="code">Derived</span> didn’t explicitly call that of class <span class="code">Base</span>, instances of <span class="code">Derived</span> would miss that portion of their initialization. Thus, such instances would violate the <a href="https://oreil.ly/0jxrp">Liskov substitution principle (LSP)</a>, since they’d lack the attribute <span class="code">anattribute</span>. This issue does <em>not</em> arise if a subclass does not define <span class="code">__init__</span>, since in that case it inherits it from the superclass. So, there is <em>never</em> any reason to code:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">Derived</code><code class="p">(</code><code class="n">Base</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="n">Base</code><code class="o">.</code><code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code></pre>
<div data-type="tip">
<h1>Never Code a Method That Just Delegates to the Superclass</h1>
<p>You should never define a semantically empty <span class="code">__init__</span> (i.e., one that just delegates to the superclass). Instead, inherit <span class="code">__init__</span> from the superclass. This advice applies to <em>all</em> methods, special or not, but for some reason the bad habit of coding such semantically empty methods seems to show up most often for <span class="code">__init__</span>.</p>
</div>
<p>The preceding code illustrates the concept of delegation to an object’s superclass, but it is actually a poor practice, in today’s Python, to code these superclasses explicitly by name. If the base class is renamed, all the call sites to it must be updated. Or, worse, if refactoring the class hierarchy introduces a new layer between the <span class="code">Derived</span> and <span class="code">Base</span> class, the newly inserted class’s method will be silently skipped.</p>
<p>The recommended approach is to call methods defined in a superclass using the <span class="code">super</span> built-in type. To invoke methods up the inheritance chain, just call <span class="code">super()</span>, without arguments:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">Derived</code><code class="p">(</code><code class="n">Base</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">super</code><code class="p">(</code><code class="p">)</code><code class="o">.</code><code class="fm">__init__</code><code class="p">(</code><code class="p">)</code><code>
</code><code>        </code><code class="bp">self</code><code class="o">.</code><code class="n">anotherattribute</code><code> </code><code class="o">=</code><code> </code><code class="mi">45</code></pre>
</div></section>
<section data-pdf-bookmark="Cooperative superclass method calling" data-type="sect3"><div class="sect3" id="cooperative_superclass_method_calling">
<h3>Cooperative superclass method calling</h3>
<p>Explicitly calling the superclass’s version of a method using the superclass’s name is also quite problematic in cases of multiple inheritance with so-called “diamond-shaped” graphs. Consider the following code:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">A</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">met</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">A.met</code><code class="s1">'</code><code class="p">)</code><code>
</code><strong><code class="k">class</code></strong><code> </code><code class="nc">B</code><code class="p">(</code><code class="n">A</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">met</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">B.met</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>        </code><code class="n">A</code><code class="o">.</code><code class="n">met</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code>
</code><strong><code class="k">class</code></strong><code> </code><code class="nc">C</code><code class="p">(</code><code class="n">A</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">met</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">C.met</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>        </code><code class="n">A</code><code class="o">.</code><code class="n">met</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code>
</code><strong><code class="k">class</code></strong><code> </code><code class="nc">D</code><code class="p">(</code><code class="n">B</code><code class="p">,</code><code class="n">C</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">met</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">D.met</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>        </code><code class="n">B</code><code class="o">.</code><code class="n">met</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code>
</code><code>        </code><code class="n">C</code><code class="o">.</code><code class="n">met</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code></pre>
<p>When we call <span class="code">D().met()</span>, <span class="code">A.met</span> ends up being called twice. How can we ensure that each ancestor’s implementation of the method is called once and only once? The solution is to use <span class="code">super</span>:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">A</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">met</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">A.met</code><code class="s1">'</code><code class="p">)</code><code>
</code><strong><code class="k">class</code></strong><code> </code><code class="nc">B</code><code class="p">(</code><code class="n">A</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">met</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">B.met</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>        </code><code class="nb">super</code><code class="p">(</code><code class="p">)</code><code class="o">.</code><code class="n">met</code><code class="p">(</code><code class="p">)</code><code>
</code><strong><code class="k">class</code></strong><code> </code><code class="nc">C</code><code class="p">(</code><code class="n">A</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">met</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">C.met</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>        </code><code class="nb">super</code><code class="p">(</code><code class="p">)</code><code class="o">.</code><code class="n">met</code><code class="p">(</code><code class="p">)</code><code>
</code><strong><code class="k">class</code></strong><code> </code><code class="nc">D</code><code class="p">(</code><code class="n">B</code><code class="p">,</code><code class="n">C</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">met</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">D.met</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>        </code><code class="nb">super</code><code class="p">(</code><code class="p">)</code><code class="o">.</code><code class="n">met</code><code class="p">(</code><code class="p">)</code></pre>
<p>Now, <span class="code">D().met()</span> results in exactly one call to each class’s version of <span class="code">met</span>. If you get into the good habit of always coding superclass calls with <span class="code">super</span>, your classes will fit smoothly even in complicated inheritance structures—and there will be no ill effects if the inheritance structure instead turns out to be simple.</p>
<p>The only situation in which you may prefer to use the rougher approach of calling superclass methods through the explicit syntax is when various classes have different and incompatible signatures for the same method. This is an unpleasant situation in many respects; if you do have to deal with it, the explicit syntax may sometimes be the least of the evils. Proper use of multiple inheritance is seriously hampered; but then, even the most fundamental properties of OOP, such as polymorphism between base and subclass instances, are impaired when you give methods of the same name different signatures in a superclass and its subclass.</p>
</div></section>
<section data-pdf-bookmark="Dynamic class definition using the type built-in function" data-type="sect3"><div class="sect3" id="dynamic_class_definition_using_the_type">
<h3>Dynamic class definition using the type built-in function</h3>
<p>In<a contenteditable="false" data-primary="type (built-in type)" data-type="indexterm" id="idm44924579298176"/> addition to the <span class="code">type(<em>obj</em>)</span> use, you can also call <span class="code">type</span> with three arguments to define a new class:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">NewClass</code> <code class="o">=</code> <code class="nb">type</code><code class="p">(</code><code class="n">name</code><code class="p">,</code> <code class="n">bases</code><code class="p">,</code> <code class="n">class_attributes</code><code class="p">,</code> <code class="o">**</code><code class="n">kwargs</code><code class="p">)</code></pre>
<p>where <span class="code"><em>name</em></span> is the name of the new class (which should match the target variable), <span class="code"><em>bases</em></span> is a tuple of immediate superclasses, <span class="code"><em>class_attributes</em></span> is a <span class="code">dict</span> of class-level methods and attributes to define in the new class, and <span class="code">**<em>kwargs</em></span> are optional named arguments to pass to the<a contenteditable="false" data-primary="** (double star) operator" data-secondary="metaclass arguments" data-type="indexterm" id="idm44924579226176"/><a contenteditable="false" data-primary="double star (**) operator" data-secondary="metaclass arguments" data-type="indexterm" id="idm44924579224864"/> metaclass of one of the base classes.</p>
<p>For example, with a simple hierarchy of <span class="code">Vehicle</span> classes (such as <span class="code">LandVehicle</span>, <span class="code">WaterVehicle</span>, <span class="code">AirVehicle</span>, <span class="code">SpaceVehicle</span>, etc.), you can dynamically create hybrid classes at runtime, such as:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">AmphibiousVehicle</code> <code class="o">=</code> <code class="nb">type</code><code class="p">(</code><code class="s1">'AmphibiousVehicle'</code><code class="p">,</code> 
                         <code class="p">(</code><code class="n">LandVehicle</code><code class="p">,</code> <code class="n">WaterVehicle</code><code class="p">),</code> <code class="p">{})</code></pre>
<p>This would be equivalent to defining a multiply inherited class:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">AmphibiousVehicle</code><code class="p">(</code><code class="n">LandVehicle</code><code class="p">,</code><code> </code><code class="n">WaterVehicle</code><code class="p">)</code><code class="p">:</code><code> </code><strong><code class="k">pass</code></strong></pre>
<p>When you call type to create classes at runtime, you do not need to manually define the combinatorial expansion of all combinations of <span class="code">Vehicle</span> subclasses, and adding new subclasses does not require massive extension of defined mixed classes.<sup><a data-type="noteref" href="ch04.xhtml#ch01fn54" id="ch01fn54-marker">7</a></sup> For more notes and examples, see the <a href="https://oreil.ly/aNrSu">online documentation</a>.</p>
</div></section>
<section data-pdf-bookmark="“Deleting” class attributes" data-type="sect3"><div class="sect3" id="quotation_markdeletingquotation_mark_cl">
<h3>“Deleting” class attributes</h3>
<p>Inheritance and overriding provide a simple and effective way to add or modify (override) class attributes (such as methods) noninvasively—i.e., without modifying the base class defining the attributes—by adding or overriding the attributes in subclasses. However, inheritance does not offer a way to delete (hide) base classes’ attributes noninvasively. If the subclass simply fails to define (override) an attribute, Python finds the base class’s definition. If you need to perform such deletion, possibilities include the following:</p>
<ul>
<li>
<p>Override the method and raise an exception in the method’s body.</p>
</li>
<li>
<p>Eschew inheritance, hold the attributes elsewhere than in the subclass’s <span class="code">__dict__</span>, and define <span class="code">__getattr__</span> for selective delegation.</p>
</li>
<li>
<p>Override <span class="code">__getattribute__</span> to similar effect.</p>
</li>
</ul>
<p>The last of these techniques is demonstrated in <a data-type="xref" href="#getattribute_">“__getattribute__”</a>.</p>
<div data-type="tip">
<h1>Consider Using Aggregation Instead of Inheritance</h1>
<p>An alternative to inheritance is to use <em>aggregation</em>: instead of inheriting from a base class, hold an instance of that base class as a private attribute. You then get complete control over the attribute’s life cycle and public interface by providing public methods in the containing class that delegate to the contained attribute (i.e., by calling equivalent methods on the attribute). This way, the containing class has more control over the creation and deletion of the attribute; also, for any unwanted methods that the attribute’s class provides, you simply don’t write delegating methods in the containing class.<a contenteditable="false" data-primary="" data-startref="inherit04" data-type="indexterm" id="idm44924579129568"/></p>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="The Built-in object Type" data-type="sect2"><div class="sect2" id="the_built_in_object_type">
<h2>The Built-in object Type</h2>
<p>The built-in <span class="code">object</span> type is the ancestor of all built-in types and classes. The <span class="code">object</span> type defines some special methods (documented in <a data-type="xref" href="#special_methods">“Special Methods”</a>) that implement the default semantics of objects:</p>
<dl>
<dt class="plain"><span class="code">__new__</span>, <span class="code">__init__</span></dt>
<dd>You can create a direct instance of <span class="code">object</span> by calling <span class="code">object()</span> without any arguments. The call uses <span class="code">object.__new__</span> and <span class="code">object.__init__</span> to make and return an instance object without attributes (and without even a <span class="code">__dict__</span> in which to hold attributes). Such instance objects may be useful as “sentinels,” guaranteed to compare unequal to any other distinct object.</dd>
<dt class="plain"><span class="code">__delattr__</span>, <span class="code">__getattr__</span>, <span class="code">__getattribute__</span>, <span class="code">__setattr__</span></dt>
<dd>By default, any object handles attribute references (as covered in <a data-type="xref" href="#attribute_reference_basics">“Attribute Reference Basics”</a>) using these methods of <span class="code">object</span>.</dd>
<dt class="plain"><span class="code">__hash__</span>, <span class="code">__repr__</span>, <span class="code">__str__</span></dt>
<dd>Passing an object to <span class="code">hash</span>, <span class="code">repr</span>, or <span class="code">str</span> calls the object’s corresponding<a contenteditable="false" data-primary="dunder (double underscore)" data-secondary="object type" data-type="indexterm" id="idm44924579106720"/> dunder method.</dd>
</dl>
<p>A subclass of <span class="code">object</span> (i.e., any class) may—and often will!—override any of these methods and/or add others.</p>
</div></section>
<section data-pdf-bookmark="Class-Level Methods" data-type="sect2"><div class="sect2" id="class_level_methods">
<h2>Class-Level Methods</h2>
<p>Python<a contenteditable="false" data-primary="classes" data-secondary="class-level methods" data-type="indexterm" id="idm44924579102064"/><a contenteditable="false" data-primary="methods" data-secondary="class-level methods" data-type="indexterm" id="idm44924579100656"/> supplies two built-in nonoverriding descriptor types, which give a class two distinct kinds of “class-level methods”: <em>static methods</em> and <em>class methods</em>.</p>
<section data-pdf-bookmark="Static methods" data-type="sect3"><div class="sect3" id="static_methods">
<h3>Static methods</h3>
<p>A <em>static method</em> is a method that you can call on a class, or on any instance of the class, without the special behavior and constraints of ordinary methods regarding the first parameter. A static method may have any signature; it may have no parameters, and the first parameter, if any, plays no special role. You can think of a static method as an ordinary function that you’re able to call normally, despite the fact that it happens to be bound to a class attribute.</p>
<p>While it is never <em>necessary</em> to define static methods (you can always choose to instead define a normal function, outside the class), some programmers consider them to be an elegant syntax alternative when a function’s purpose is tightly bound to some specific class.</p>
<p>To build a static method, call the built-in type <span class="code">staticmethod</span> and bind its result to a class attribute. Like all binding of class attributes, this is normally done in the body of the class, but you may also choose to perform it elsewhere. The only argument to <span class="code">staticmethod</span> is the function to call when Python calls the static method. The following example shows one way to define and call a static method:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">AClass</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">astatic</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">a static method</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>    </code><code class="n">astatic</code><code> </code><code class="o">=</code><code> </code><code class="nb">staticmethod</code><code class="p">(</code><code class="n">astatic</code><code class="p">)</code><code>
</code><code>
</code><code class="n">an_instance</code><code> </code><code class="o">=</code><code> </code><code class="n">AClass</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="nb">print</code><code class="p">(</code><code class="n">AClass</code><code class="o">.</code><code class="n">astatic</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>             </code><em><code class="c1"># prints:</code></em><code class="c1"> </code><em><code class="c1">a static method</code></em><code>
</code><code class="nb">print</code><code class="p">(</code><code class="n">an_instance</code><code class="o">.</code><code class="n">astatic</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>        </code><em><code class="c1"># prints:</code></em><code class="c1"> </code><em><code class="c1">a static method</code></em></pre>
<p>This example uses the same name for the function passed to <span class="code">staticmethod</span> and for the attribute bound to <span class="code">staticmethod</span>’s result. This naming convention is not mandatory, but it’s a good idea, and we recommend you always use it. Python offers a special, simplified syntax to support this style, covered in <a data-type="xref" href="#decorators">“Decorators”</a>.</p>
</div></section>
<section data-pdf-bookmark="Class methods" data-type="sect3"><div class="sect3" id="class_methods">
<h3>Class methods</h3>
<p>A <em>class method</em> is a method you can call on a class or on any instance of the class. Python binds the method’s first parameter to the class on which you call the method, or the class of the instance on which you call the method; it does not bind it to the instance, as for normal<a contenteditable="false" data-primary="bound methods" data-type="indexterm" id="idm44924589495456"/> bound methods. The first parameter of a class method is conventionally named <span class="code">cls</span>.</p>
<p>As with static methods, while it is never <em>necessary</em> to define class methods (you can always choose to define a normal function, outside the class, that takes the class object as its first parameter), class methods are an elegant alternative to such functions (particularly since they can usefully be overridden in subclasses, when that is necessary).</p>
<p>To build a class method, call the built-in type <span class="code">classmethod</span> and bind its result to a class attribute. Like all binding of class attributes, this is normally done in the body of the class, but you may choose to perform it elsewhere. The only argument to <span class="code">classmethod</span> is the function to call when Python calls the class method. Here’s one way you can define and call a class method:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">ABase</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">aclassmet</code><code class="p">(</code><code class="bp">cls</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">a class method for</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="bp">cls</code><code class="o">.</code><code class="vm">__name__</code><code class="p">)</code><code>
</code><code>    </code><code class="n">aclassmet</code><code> </code><code class="o">=</code><code> </code><code class="nb">classmethod</code><code class="p">(</code><code class="n">aclassmet</code><code class="p">)</code><code>
</code><strong><code class="k">class</code><code> </code><code class="nc">ADeriv</code></strong><code class="p">(</code><code class="n">ABase</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">pass</code></strong><code>
</code><code>
</code><code class="n">b_instance</code><code> </code><code class="o">=</code><code> </code><code class="n">ABase</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="n">d_instance</code><code> </code><code class="o">=</code><code> </code><code class="n">ADeriv</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="nb">print</code><code class="p">(</code><code class="n">ABase</code><code class="o">.</code><code class="n">aclassmet</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>        </code><em><code class="c1"># prints:</code></em><code class="c1"> </code><em><code class="c1">a class method for ABase</code></em><code>
</code><code class="nb">print</code><code class="p">(</code><code class="n">b_instance</code><code class="o">.</code><code class="n">aclassmet</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>   </code><em><code class="c1"># prints:</code></em><code class="c1"> </code><em><code class="c1">a class method for ABase</code></em><code>
</code><code class="nb">print</code><code class="p">(</code><code class="n">ADeriv</code><code class="o">.</code><code class="n">aclassmet</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>       </code><em><code class="c1"># prints:</code></em><code class="c1"> </code><em><code class="c1">a class method for ADeriv</code></em><code>
</code><code class="nb">print</code><code class="p">(</code><code class="n">d_instance</code><code class="o">.</code><code class="n">aclassmet</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>   </code><em><code class="c1"># prints:</code></em><code class="c1"> </code><em><code class="c1">a class method for ADeriv</code></em></pre>
<p>This example uses the same name for the function passed to <span class="code">classmethod</span> and for the attribute bound to <span class="code">classmethod</span>’s result. Again, this naming convention is not mandatory, but it’s a good idea, and we recommend that you always use it. Python’s simplified syntax to support this style is covered in <a data-type="xref" href="#decorators">“Decorators”</a>.</p>
</div></section>
</div></section>
<section data-pdf-bookmark="Properties" data-type="sect2"><div class="sect2" id="properties">
<h2>Properties</h2>
<p>Python<a contenteditable="false" data-primary="classes" data-secondary="properties" data-type="indexterm" id="idm44924579029056"/><a contenteditable="false" data-primary="properties" data-type="indexterm" id="prop04"/> supplies a built-in overriding descriptor type, usable to give a class’s instances <em>properties</em>. A property is an instance attribute with special functionality. You reference, bind, or unbind the attribute with the normal syntax (e.g., <span class="code">print(<em>x.prop</em>),</span> <span class="code"><em>x</em></span><span class="code">.<em>prop</em>=23,</span> <span class="code"><strong>del</strong></span> <span class="code"><em>x.prop</em></span><span class="code">)</span>. However, rather than following the usual semantics for attribute reference, binding, and unbinding, these accesses call on instance <span class="code"><em>x</em></span> the methods that you specify as arguments to the built-in type <span class="code">property</span>. Here’s one way to define a read-only property:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">Rectangle</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">width</code><code class="p">,</code><code> </code><code class="n">height</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="bp">self</code><code class="o">.</code><code class="n">width</code><code> </code><code class="o">=</code><code> </code><code class="n">width</code><code>
</code><code>        </code><code class="bp">self</code><code class="o">.</code><code class="n">height</code><code> </code><code class="o">=</code><code> </code><code class="n">height</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">area</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><strong><code class="k">return</code></strong><code> </code><code class="bp">self</code><code class="o">.</code><code class="n">width</code><code> </code><code class="o">*</code><code> </code><code class="bp">self</code><code class="o">.</code><code class="n">height</code><code>
</code><code>    </code><code class="n">area</code><code> </code><code class="o">=</code><code> </code><code class="nb">property</code><code class="p">(</code><code class="n">area</code><code class="p">,</code><code> </code><code class="n">doc</code><code class="o">=</code><code class="s1">'</code><code class="s1">area of the rectangle</code><code class="s1">'</code><code class="p">)</code></pre>
<p>Each instance <span class="code"><em>r</em></span> of class <span class="code">Rectangle</span> has a synthetic read-only attribute <span class="code"><em>r</em></span><span class="code">.area</span>, which the method <span class="code"><em>r</em></span><span class="code">.area()</span> computes on the fly by multiplying the sides. The docstring <span class="code">Rectangle.area.__doc__</span> is <span class="code">'area of the rectangle'</span>. The <span class="code"><em>r</em></span><span class="code">.area</span> attribute is read-only (attempts to rebind or unbind it fail) because we specify only a <span class="code">get</span> method in the call to <span class="code">property</span>, and no <span class="code">set</span> or <span class="code">del</span> methods.</p>
<p>Properties perform tasks similar to those of the special methods <span class="code">__getattr__</span>, <span class="code">__setattr__</span>, and <span class="code">__delattr__</span> (covered in <a data-type="xref" href="#general_purpose_special_method">“General-Purpose Special Methods”</a>), but properties are faster and simpler. To build a property, call the built-in type <span class="code">property</span> and bind its result to a class attribute. Like all binding of class attributes, this is normally done in the body of the class, but you may choose to do it elsewhere. Within the body of a class <span class="code"><em>C</em></span>, you can use the following syntax:</p>
<pre data-code-language="python" data-type="programlisting">
<em><code class="n">attrib</code></em><code> </code><code class="o">=</code><code> </code><code class="nb">property</code><code class="p">(</code><code class="n">fget</code><code class="o">=</code><strong><code class="kc">None</code></strong><code class="p">,</code><code> </code><code class="n">fset</code><code class="o">=</code><strong><code class="kc">None</code></strong><code class="p">,</code><code> </code><code class="n">fdel</code><code class="o">=</code><strong><code class="kc">None</code></strong><code class="p">,</code><code> </code><code class="n">doc</code><code class="o">=</code><strong><code class="kc">None</code></strong><code class="p">)</code></pre>
<p>When <span class="code"><em>x</em></span> is an instance of <span class="code"><em>C</em></span> and you reference <span class="code"><em>x</em></span><span class="code">.<em>attrib</em></span>, Python calls on <span class="code"><em>x</em></span> the method you passed as argument <span class="code">fget</span> to the property constructor, without arguments. When you assign <span class="code"><em>x</em>.<em>attrib</em></span> <span class="code">=</span> <span class="code"><em>value</em></span>, Python calls the method you passed as argument <span class="code">fset</span>, with <span class="code"><em>value</em></span> as the only argument. When you execute <span class="code"><strong>del</strong></span> <span class="code"><em>x</em>.</span><span class="code"><em>attrib</em></span>, Python calls the method you passed as argument <span class="code">fdel</span>, without arguments. Python uses the argument you passed as <span class="code">doc</span> as the docstring of the attribute. All parameters to <span class="code">property</span> are optional. When an argument is missing, Python raises an exception when some code attempts that operation. For example, in the <span class="code">Rectangle</span> example, we made the property <span class="code">area</span> read-only because we passed an argument only for the parameter <span class="code">fget</span>, and not for the parameters <span class="code">fset</span> and <span class="code">fdel</span>.</p>
<p>An elegant syntax to create properties in a class is to use <span class="code">property</span> as a <em>decorator</em> (see <a data-type="xref" href="#decorators">“Decorators”</a>):</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">Rectangle</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">width</code><code class="p">,</code><code> </code><code class="n">height</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="bp">self</code><code class="o">.</code><code class="n">width</code><code> </code><code class="o">=</code><code> </code><code class="n">width</code><code>
</code><code>        </code><code class="bp">self</code><code class="o">.</code><code class="n">height</code><code> </code><code class="o">=</code><code> </code><code class="n">height</code><code>
</code><code>    </code><code class="nd">@property</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">area</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><em><code class="sd">"""area of the rectangle"""</code></em><code>
</code><code>        </code><strong><code class="k">return</code></strong><code> </code><code class="bp">self</code><code class="o">.</code><code class="n">width</code><code> </code><code class="o">*</code><code> </code><code class="bp">self</code><code class="o">.</code><code class="n">height</code></pre>
<p>To use this syntax, you <em>must</em> give the getter method the same name as you want the property to have; the method’s docstring becomes the docstring of the property. If you want to add a setter and/or a deleter as well, use decorators named (in this example) <span class="code">area.setter</span> and <span class="code">area.deleter</span>, and name the methods thus decorated the same as the property, too. For example:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">math</code><code>
</code><strong><code class="k">class</code></strong><code> </code><code class="nc">Rectangle</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">width</code><code class="p">,</code><code> </code><code class="n">height</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="bp">self</code><code class="o">.</code><code class="n">width</code><code> </code><code class="o">=</code><code> </code><code class="n">width</code><code>
</code><code>        </code><code class="bp">self</code><code class="o">.</code><code class="n">height</code><code> </code><code class="o">=</code><code> </code><code class="n">height</code><code>
</code><code>    </code><code class="nd">@property</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">area</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><em><code class="sd">"""area of the rectangle"""</code></em><code>
</code><code>        </code><strong><code class="k">return</code></strong><code> </code><code class="bp">self</code><code class="o">.</code><code class="n">width</code><code> </code><code class="o">*</code><code> </code><code class="bp">self</code><code class="o">.</code><code class="n">height</code><code>
</code><code>    </code><code class="nd">@area</code><code class="o">.</code><code class="n">setter</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">area</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">value</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="n">scale</code><code> </code><code class="o">=</code><code> </code><code class="n">math</code><code class="o">.</code><code class="n">sqrt</code><code class="p">(</code><code class="n">value</code><code class="o">/</code><code class="bp">self</code><code class="o">.</code><code class="n">area</code><code class="p">)</code><code>
</code><code>        </code><code class="bp">self</code><code class="o">.</code><code class="n">width</code><code> </code><code class="o">*</code><code class="o">=</code><code> </code><code class="n">scale</code><code>
</code><code>        </code><code class="bp">self</code><code class="o">.</code><code class="n">height</code><code> </code><code class="o">*</code><code class="o">=</code><code> </code><code class="n">scale</code></pre>
<section data-pdf-bookmark="Why properties are important" data-type="sect3"><div class="sect3" id="why_properties_are_important">
<h3>Why properties are important</h3>
<p>The crucial importance of properties is that their existence makes it perfectly safe (and indeed advisable) for you to expose public data attributes as part of your class’s public interface. Should it ever become necessary, in future versions of your class or other classes that need to be polymorphic to it, to have some code execute when the attribute is referenced, rebound, or unbound, you will be able to change the plain attribute into a property and get the desired effect without any impact on any code that uses your class (aka “client code”). This lets you avoid goofy idioms, such as <em>accessor</em> and <em>mutator</em> methods, required by OO languages lacking properties. For example, client code can use natural idioms like this:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">some_instance</code><code class="o">.</code><code class="n">widget_count</code> <code class="o">+=</code> <code class="mi">1</code></pre>
<p>rather than being forced into contorted nests of accessors and mutators like this:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">some_instance</code><code class="o">.</code><code class="n">set_widget_count</code><code class="p">(</code><code class="n">some_instance</code><code class="o">.</code><code class="n">get_widget_count</code><code class="p">()</code> <code class="o">+</code> <code class="mi">1</code><code class="p">)</code></pre>
<p>If you’re ever tempted to code methods whose natural names are something like <span class="code">get_</span><span class="code"><em>this</em></span> or <span class="code">set_</span><span class="code"><em>that</em></span>, wrap those methods into properties instead, for clarity.</p>
</div></section>
<section data-pdf-bookmark="Properties and inheritance" data-type="sect3"><div class="sect3" id="properties_and_inheritance">
<h3>Properties and inheritance</h3>
<p>Inheritance of properties works just like for any other attribute. However, there’s a little trap for the unwary: <em>the methods called upon to access a property are those defined in the class in which the property itself is defined</em>, without intrinsic use of further overriding that may happen in subclasses. Consider this example:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">B</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">f</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><strong><code class="k">return</code></strong><code> </code><code class="mi">23</code><code>
</code><code>    </code><code class="n">g</code><code> </code><code class="o">=</code><code> </code><code class="nb">property</code><code class="p">(</code><code class="n">f</code><code class="p">)</code><code>
</code><strong><code class="k">class</code></strong><code> </code><code class="nc">C</code><code class="p">(</code><code class="n">B</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">f</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><strong><code class="k">return</code></strong><code> </code><code class="mi">42</code><code>
</code><code>
</code><code class="n">c</code><code> </code><code class="o">=</code><code> </code><code class="n">C</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="nb">print</code><code class="p">(</code><code class="n">c</code><code class="o">.</code><code class="n">g</code><code class="p">)</code><code>                </code><em><code class="c1"># prints:</code></em><code class="c1"> </code><em><code class="c1">23</code></em><code class="c1">, </code><em><code class="c1">not</code></em><code class="c1"> </code><em><code class="c1">42</code></em></pre>
<p>Accessing the property <span class="code">c.g</span> calls <span class="code">B.f</span>, not <span class="code">C.f</span>, as you might expect. The reason is quite simple: the property constructor receives (directly or via the decorator syntax) the <em>function object</em> <span class="code">f</span> (and that happens at the time the <span class="code"><strong>class</strong></span> statement for <span class="code">B</span> executes, so the function object in question is the one also known as <span class="code">B.f</span>). The fact that the subclass <span class="code">C</span> later redefines the name <span class="code">f</span> is therefore irrelevant, since the property performs no lookup for that name, but rather uses the function object it received at creation time. If you need to work around this issue, you can do it by adding the extra level of lookup indirection yourself:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">B</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">f</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><strong><code class="k">return</code></strong><code> </code><code class="mi">23</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">_f_getter</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><strong><code class="k">return</code></strong><code> </code><code class="bp">self</code><code class="o">.</code><code class="n">f</code><code class="p">(</code><code class="p">)</code><code>
</code><code>    </code><code class="n">g</code><code> </code><code class="o">=</code><code> </code><code class="nb">property</code><code class="p">(</code><code class="n">_f_getter</code><code class="p">)</code><code>
</code><strong><code class="k">class</code></strong><code> </code><code class="nc">C</code><code class="p">(</code><code class="n">B</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">f</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><strong><code class="k">return</code></strong><code> </code><code class="mi">42</code><code>
</code><code>
</code><code class="n">c</code><code> </code><code class="o">=</code><code> </code><code class="n">C</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="nb">print</code><code class="p">(</code><code class="n">c</code><code class="o">.</code><code class="n">g</code><code class="p">)</code><code>                </code><em><code class="c1"># prints:</code></em><code class="c1"> </code><em><code class="c1">42</code></em><em><code class="c1">,</code></em><code class="c1"> </code><em><code class="c1">as expected</code></em></pre>
<p>Here, the function object held by the property is <span class="code">B._f_getter</span>, which in turn does perform a lookup for the name <span class="code">f</span> (since it calls <span class="code">self.f()</span>); therefore, the overriding of <span class="code">f</span> has the expected effect. As David Wheeler famously put it, “All problems in computer science can be solved by<a contenteditable="false" data-primary="" data-startref="prop04" data-type="indexterm" id="idm44924580939616"/> another level of indirection.”<sup><a data-type="noteref" href="ch04.xhtml#ch01fn55" id="ch01fn55-marker">8</a></sup></p>
</div></section>
</div></section>
<section data-pdf-bookmark="__slots__" data-type="sect2"><div class="sect2" id="slots_">
<h2>__slots__</h2>
<p>Normally, each<a contenteditable="false" data-primary="classes" data-secondary="__slots__ attribute" data-type="indexterm" id="idm44924580935472"/><a contenteditable="false" data-primary="__slots__ attribute" data-type="indexterm" id="idm44924580933680"/> instance object <span class="code"><em>x</em></span> of any class <span class="code"><em>C</em></span> has a dictionary <span class="code"><em>x.</em></span><span class="code">__dict__</span> that Python uses to let you bind arbitrary attributes on <span class="code"><em>x</em></span>. To save a little memory (at the cost of letting <span class="code"><em>x</em></span> have only a predefined set of attribute names), you can define in class <span class="code"><em>C</em></span> a class attribute named <span class="code">__slots__</span>, a sequence (normally a tuple) of strings (normally identifiers). When class <span class="code"><em>C</em></span> has <span class="code">__slots__</span>, instance <span class="code"><em>x</em></span> of class <span class="code"><em>C</em></span> has no <span class="code">__dict__</span>: trying to bind on <span class="code"><em>x</em></span> an attribute whose name is not in <span class="code"><em>C.</em></span><span class="code">__slots__</span> raises an exception.</p>
<p>Using <span class="code">__slots__</span> lets you reduce memory consumption for small instance objects that can do without the powerful and convenient ability to have arbitrarily named attributes. <span class="code">__slots__</span> is worth adding only to classes that can have so many instances that saving a few tens of bytes per instance is important—typically classes that could have millions, not mere thousands, of instances alive at the same time. Unlike most other class attributes, however, <span class="code">__slots__</span> works as we’ve just described only if an assignment in the class body binds it as a class attribute. Any later alteration, rebinding, or unbinding of <span class="code">__slots__</span> has no effect, nor does inheriting <span class="code">__slots__</span> from a base class. Here’s how to add <span class="code">__slots__</span> to the <span class="code">Rectangle</span> class defined earlier to get smaller (though less flexible) instances:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">OptimizedRectangle</code><code class="p">(</code><code class="n">Rectangle</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="vm">__slots__</code><code> </code><code class="o">=</code><code> </code><code class="s1">'</code><code class="s1">width</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">height</code><code class="s1">'</code></pre>
<p>There’s no need to define a slot for the <span class="code">area</span> property: <span class="code">__slots__</span> does not constrain properties, only ordinary instance attributes, which would reside in the instance’s <span class="code">__dict__</span> if <span class="code">__slots__</span> wasn’t defined.</p>
<p><span class="version">3.8+</span> <span class="code">__slots__</span> attributes can also be defined using a <span class="code">dict</span> with attribute names for the keys and docstrings for the values. <span class="code">OptimizedRectangle</span> could be declared more fully as:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">OptimizedRectangle</code><code class="p">(</code><code class="n">Rectangle</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="vm">__slots__</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code class="s1">'</code><code class="s1">width</code><code class="s1">'</code><code class="p">:</code><code> </code><code class="s1">'</code><code class="s1">rectangle width in pixels</code><code class="s1">'</code><code class="p">,</code><code>
</code><code>                 </code><code class="s1">'</code><code class="s1">height</code><code class="s1">'</code><code class="p">:</code><code> </code><code class="s1">'</code><code class="s1">rectangle height in pixels</code><code class="s1">'</code><code class="p">}</code></pre>
</div></section>
<section data-pdf-bookmark="__getattribute__" data-type="sect2"><div class="sect2" id="getattribute_">
<h2>__getattribute__</h2>
<p>All<a contenteditable="false" data-primary="classes" data-secondary="__getattribute__ (special method)" data-type="indexterm" id="idm44924580803024"/><a contenteditable="false" data-primary="__getattribute__ (special method)" data-type="indexterm" id="idm44924580801648"/> references to instance attributes go through the special method <span class="code">__getattribute__</span>. This method comes from <span class="code">object</span>, where it implements attribute reference semantics (as documented in <a data-type="xref" href="#attribute_reference_basics">“Attribute Reference Basics”</a>). You may override <span class="code">__getattribute__</span> for purposes such as hiding inherited class attributes for a subclass’s instances. For instance, the following example shows one way to implement a list without <span class="code">append</span>:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">listNoAppend</code><code class="p">(</code><code class="nb">list</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__getattribute__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">name</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><strong><code class="k">if</code></strong><code> </code><code class="n">name</code><code> </code><code class="o">==</code><code> </code><code class="s1">'</code><code class="s1">append</code><code class="s1">'</code><code class="p">:</code><code>
</code><code>            </code><strong><code class="k">raise</code></strong><code> </code><code class="ne">AttributeError</code><code class="p">(</code><code class="n">name</code><code class="p">)</code><code>
</code><code>        </code><strong><code class="k">return</code></strong><code> </code><code class="nb">list</code><code class="o">.</code><code class="fm">__getattribute__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">name</code><code class="p">)</code></pre>
<p>An instance <span class="code"><em>x</em></span> of class <span class="code">listNoAppend</span> is almost indistinguishable from a built-in list object, except that its runtime performance is substantially worse, and any reference to <span class="code"><em>x</em></span><span class="code">.append</span> raises an exception.</p>
<p>Implementing <span class="code">__getattribute__</span> can be tricky; it is often easier to use the built-in functions <span class="code">getattr</span> and <span class="code">setattr</span> and the instance’s <span class="code">__dict__</span> (if any), or to reimplement <span class="code">__getattr__</span> and <span class="code">__setattr__</span>. Of course, in some cases (such as the preceding example), there is no alternative.</p>
</div></section>
<section data-pdf-bookmark="Per Instance Methods" data-type="sect2"><div class="sect2" id="per_instance_methods">
<h2>Per Instance Methods</h2>
<p>An<a contenteditable="false" data-primary="classes" data-secondary="per instance methods" data-type="indexterm" id="idm44924580698128"/><a contenteditable="false" data-primary="per instance methods" data-type="indexterm" id="idm44924580696720"/><a contenteditable="false" data-primary="methods" data-secondary="per instance methods" data-type="indexterm" id="idm44924580695616"/><a contenteditable="false" data-primary="instances" data-secondary="per instance methods" data-type="indexterm" id="idm44924580694240"/> instance can have instance-specific bindings for all attributes, including callable attributes (methods). For a method, just like for any other attribute (except those bound to overriding descriptors), an instance-specific binding hides a class-level binding: attribute lookup does not consider the class when it finds a binding directly in the instance. An instance-specific binding for a callable attribute does not perform any of the transformations detailed in <a data-type="xref" href="#bound_and_unbound_methods">“Bound and Unbound Methods”</a>: the attribute reference returns exactly the same callable object that was earlier bound directly to the instance attribute.</p>
<p class="pagebreak-before">However, this does not work as you might expect for per instance bindings of the special methods that Python calls implicitly as a result of various operations, as covered in <a data-type="xref" href="#special_methods">“Special Methods”</a>. Such implicit uses of special methods always rely on the <em>class-level</em> binding of the special method, if any. For example:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">def</code></strong><code> </code><code class="nf">fake_get_item</code><code class="p">(</code><code class="n">idx</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">return</code></strong><code> </code><code class="n">idx</code><code>
</code><strong><code class="k">class</code></strong><code> </code><code class="nc">MyClass</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">pass</code></strong><code>
</code><code class="n">n</code><code> </code><code class="o">=</code><code> </code><code class="n">MyClass</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="n">n</code><code class="o">.</code><code class="fm">__getitem__</code><code> </code><code class="o">=</code><code> </code><code class="n">fake_get_item</code><code>
</code><code class="nb">print</code><code class="p">(</code><code class="n">n</code><code class="p">[</code><code class="mi">23</code><code class="p">]</code><code class="p">)</code><code>                      </code><em><code class="c1"># results in:</code></em><code>
</code><em><code class="c1"># Traceback (most recent call last):</code></em><code>
</code><em><code class="c1">#   File "&lt;stdin&gt;", line 1, in ?</code></em><code>
</code><em><code class="c1"># TypeError: unindexable object</code></em></pre>
</div></section>
<section data-pdf-bookmark="Inheritance from Built-in Types" data-type="sect2"><div class="sect2" id="inheritance_from_built_in_types">
<h2>Inheritance from Built-in Types</h2>
<p>A<a contenteditable="false" data-primary="classes" data-secondary="inheritance from built-in types" data-type="indexterm" id="idm44924580644256"/><a contenteditable="false" data-primary="inheritance" data-secondary="from built-in types" data-secondary-sortas="built-in types" data-type="indexterm" id="idm44924580643152"/><a contenteditable="false" data-primary="built-ins" data-secondary="inheritance from types" data-type="indexterm" id="idm44924580641536"/> class can inherit from a built-in type. However, a class may directly or indirectly extend multiple built-in types only if those types are specifically designed to allow this level of mutual compatibility. Python does not support unconstrained inheritance from multiple arbitrary built-in types. Normally, a new-style class only extends at most one substantial built-in type. For example, this:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">noway</code><code class="p">(</code><code class="nb">dict</code><code class="p">,</code><code> </code><code class="nb">list</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">pass</code></strong></pre>
<p>raises a <span class="code">TypeError</span> exception, with a detailed explanation of “multiple bases have instance lay-out conflict.” When you see such error messages, it means that you’re trying to inherit, directly or indirectly, from multiple built-in types that are not specifically designed to cooperate at such a deep level.<a contenteditable="false" data-primary="" data-startref="classes04" data-type="indexterm" id="idm44924580600608"/><a contenteditable="false" data-primary="" data-startref="OOPclasinst04" data-type="indexterm" id="idm44924580599328"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Special Methods" data-type="sect1"><div class="sect1" id="special_methods">
<h1>Special Methods</h1>
<p>A<a contenteditable="false" data-primary="object-oriented Python" data-secondary="special methods" data-type="indexterm" id="OOPspmeth04"/><a contenteditable="false" data-primary="special methods" data-type="indexterm" id="spmeth04"/><a contenteditable="false" data-primary="special methods" data-secondary="basics of" data-type="indexterm" id="idm44924580575584"/> class may define or inherit special methods, often referred to as<a contenteditable="false" data-primary="__ (double underscore)" data-type="indexterm" id="idm44924580574080"/><a contenteditable="false" data-primary="dunder (double underscore)" data-secondary="definition of term" data-type="indexterm" id="idm44924580572976"/><a contenteditable="false" data-primary="underscore (_)" data-secondary="double (__ dunder)" data-type="indexterm" id="idm44924580571632"/> “dunder” methods because, as described earlier, their names have leading and trailing double underscores. Each special method relates to a specific operation. Python implicitly calls a special method whenever you perform the related operation on an instance object. In most cases, the method’s return value is the operation’s result, and attempting an operation when its related method is not present raises an exception.</p>
<p>Throughout this section, we point out the cases in which these general rules do not apply. In the following discussion, <span class="code"><em>x</em></span> is the instance of class <span class="code"><em>C</em></span> on which you perform the operation, and <span class="code"><em>y</em></span> is the other operand, if any. The parameter <span class="code">self</span> of each method also refers to the instance object <span class="code"><em>x</em></span>. Whenever we mention calls to <span class="code"><em>x.</em></span><span class="code">__<em>whatever</em>__(...)</span>, keep in mind that the exact call happening is rather, pedantically speaking, <span class="code"><em>x.</em></span><span class="code">__class__.__<em>whatever</em>__(</span><span class="code"><em>x</em></span>, <span class="code">...)</span>.</p>
<section data-pdf-bookmark="General-Purpose Special Methods" data-type="sect2"><div class="sect2" id="general_purpose_special_method">
<h2>General-Purpose Special Methods</h2>
<p>Some<a contenteditable="false" data-primary="special methods" data-secondary="general-purpose" data-type="indexterm" id="idm44924580558576"/><a contenteditable="false" data-primary="dunder (double underscore)" data-secondary="general-purpose special methods" data-type="indexterm" id="idm44924580557168"/> dunder methods relate to general-purpose operations. A class that defines or inherits these methods allows its instances to control such operations. These operations can be divided into categories:</p>
<dl>
<dt>Initialization and finalization</dt>
<dd>A<a contenteditable="false" data-primary="initialization" data-type="indexterm" id="idm44924580553824"/><a contenteditable="false" data-primary="finalization" data-type="indexterm" id="idm44924580552688"/><a contenteditable="false" data-primary=" __new__ (special method)" data-type="indexterm" id="idm44924580551584"/><a contenteditable="false" data-primary=" __init__ (special method)" data-type="indexterm" id="idm44924580550512"/><a contenteditable="false" data-primary=" __del__ (special method)" data-type="indexterm" id="idm44924580549392"/> class can control its instances’ initialization (a very common requirement) via special methods <span class="code">__new__</span> and <span class="code">__init__</span>, and/or their finalization (a rare requirement) via <span class="code">__del__</span>.</dd>
<dt>String representation</dt>
<dd>A<a contenteditable="false" data-primary="strings" data-secondary="special methods for string representation" data-type="indexterm" id="idm44924580544944"/><a contenteditable="false" data-primary="__str__ (special method)" data-type="indexterm" id="idm44924580543568"/><a contenteditable="false" data-primary="__format__ (special method)" data-type="indexterm" id="idm44924580542496"/><a contenteditable="false" data-primary="__bytes__ (special method)" data-type="indexterm" id="idm44924580541424"/> class can control how Python renders its instances as strings via special methods <span class="code">__repr__</span>, <span class="code">__str__</span>, <span class="code">__format__</span>, and <span class="code">__bytes__</span>.</dd>
<dt>Comparison, hashing, and use in a Boolean context</dt>
<dd>A<a contenteditable="false" data-primary="comparison" data-secondary="special methods for" data-type="indexterm" id="idm44924580536592"/><a contenteditable="false" data-primary="hashing" data-secondary="special methods for" data-type="indexterm" id="idm44924580534800"/><a contenteditable="false" data-primary="Boolean values" data-type="indexterm" id="idm44924580533424"/> class can control how its instances compare with other objects (via special methods<a contenteditable="false" data-primary="__lt__ (special method)" data-type="indexterm" id="idm44924580532192"/><a contenteditable="false" data-primary="__ne__ (special method)" data-type="indexterm" id="idm44924580531088"/><a contenteditable="false" data-primary="__eq__ (special method)" data-type="indexterm" id="idm44924580529984"/><a contenteditable="false" data-primary="__ge__ (special method)" data-type="indexterm" id="idm44924580528880"/><a contenteditable="false" data-primary="__gt__ (special method)" data-type="indexterm" id="idm44924580527776"/><a contenteditable="false" data-primary="__le__ (special method)" data-type="indexterm" id="idm44924580526672"/> <span class="code">__lt__</span>, <span class="code">__le__</span>, <span class="code">__gt__</span>, <span class="code">__ge__</span>, <span class="code">__eq__</span>, and <span class="code">__ne__</span>), how dictionaries use them as keys and sets use them as members (via<a contenteditable="false" data-primary="__hash__ (special method)" data-type="indexterm" id="idm44924580521120"/> <span class="code">__hash__</span>), and whether they evaluate as<a contenteditable="false" data-primary="True" data-type="indexterm" id="idm44924580519200"/><a contenteditable="false" data-primary="falsy" data-secondary="evaluation in Boolean contexts" data-type="indexterm" id="idm44924580518096"/> truthy or falsy in Boolean contexts ( via<span class="code">__bool__</span>).</dd>
<dt>Attribute reference, binding, and unbinding</dt>
<dd>A<a contenteditable="false" data-primary="attributes" data-secondary="attribute reference special methods" data-type="indexterm" id="idm44924580515088"/><a contenteditable="false" data-primary="binding" data-secondary="attributes" data-type="indexterm" id="idm44924580513712"/><a contenteditable="false" data-primary="unbinding" data-type="indexterm" id="idm44924580512336"/> class can control access to its instances’ attributes (reference, binding, unbinding) via special methods<a contenteditable="false" data-primary="__getattribute__ (special method)" data-type="indexterm" id="idm44924580510976"/><a contenteditable="false" data-primary="__delattr__ (special method)" data-type="indexterm" id="idm44924580509904"/><a contenteditable="false" data-primary="__setattr__ (special method)" data-type="indexterm" id="idm44924580508784"/><a contenteditable="false" data-primary="__getattr__ (special method)" data-type="indexterm" id="idm44924580507664"/> <span class="code">__getattribute__</span>, <span class="code">__getattr__</span>, <span class="code">__setattr__</span>, and <span class="code">__delattr__</span>.</dd>
<dt>Callable instances</dt>
<dd>A<a contenteditable="false" data-primary="callable instances" data-type="indexterm" id="idm44924580502768"/> class can make its instances callable, just like function objects, via special method<a contenteditable="false" data-primary="__call__ (special method)" data-type="indexterm" id="idm44924580501504"/> <span class="code">__call__</span>.</dd>
</dl>
<p><a data-type="xref" href="#general_purpose_special_methods">Table 4-1</a> documents the general-purpose special methods.</p>
<table class="border" id="general_purpose_special_methods">
<caption><span class="label">Table 4-1. </span>General-purpose special methods</caption>
<tbody>
<tr>
<td class="width-25"><span class="code">__bool__</span></td>
<td><span class="code">__bool__(self)</span><br/>
			When<a contenteditable="false" data-primary="__bool__ (special method)" data-type="indexterm" id="idm44924580493152"/> evaluating <span class="code"><em>x</em></span> as true or false (see <a data-type="xref" href="ch03.xhtml#boolean_values">“Boolean Values”</a>)—for example, on a call to <span class="code">bool(<em>x</em>)</span>—Python calls <span class="code"><em>x</em></span><span class="code">.__bool__()</span>, which should return <span class="code"><strong>True</strong></span> or <span class="code"><strong>False</strong></span>. When <span class="code">__bool__</span> is not present, Python calls <span class="code">__len__</span>, and takes <span class="code"><em>x</em></span> as falsy when <span class="code"><em>x</em></span><span class="code">.__len__()</span> returns <span class="code">0</span> (to check that a container is nonempty, avoid coding <span class="code"><strong>if</strong></span> <span class="code">len(<em>container</em>)&gt;0:</span>; use <span class="code"><strong>if</strong></span> <span class="code"><em>container</em></span>: instead). When neither <span class="code">__bool__</span> nor <span class="code">__len__</span> is present, Python considers <span class="code"><em>x</em></span> truthy.</td>
</tr>
<tr>
<td><span class="code">__bytes__</span></td>
<td><span class="code">__bytes__(self)</span><br/>
			Calling <span class="code">bytes(<em>x</em>)</span> calls <span class="code"><em>x</em></span><span class="code">.__bytes__()</span>, if present. If a class supplies both special methods <span class="code">__bytes__</span> and <span class="code">__str__</span>, they should return “equivalent” strings, respectively, of <span class="code">bytes</span> and <span class="code">str</span> type.</td>
</tr>
<tr>
<td><span class="code">__call__</span></td>
<td><span class="code">__call__(self[,</span> <span class="code"><em>args</em></span><span class="code">...])</span><br/>
			When<a contenteditable="false" data-primary="__call__ (special method)" data-type="indexterm" id="idm44924580463968"/> you call <span class="code"><em>x</em></span><span class="code">([<em>args</em>...])</span>, Python translates the operation into a call to <span class="code"><em>x</em></span><span class="code">.__call__([<em>args</em>...])</span>. The arguments for the call operation correspond to the parameters for the <span class="code">__call__</span> method, minus the first one. The first parameter, conventionally called <span class="code">self</span>, refers to <span class="code"><em>x</em></span>: Python supplies it implicitly, just as in any other call to a<a contenteditable="false" data-primary="bound methods" data-type="indexterm" id="idm44924580456832"/> bound method.</td>
</tr>
<tr>
<td><span class="code">__del__</span></td>
<td><span class="code">__del__(self)</span><br/>
			Just<a contenteditable="false" data-primary="__del__ (special method)" data-type="indexterm" id="idm44924580452896"/> before <span class="code"><em>x</em></span> disappears via garbage collection, Python calls <span class="code"><em>x</em></span><span class="code">.__del__()</span> to let <span class="code"><em>x</em></span> finalize itself. If <span class="code">__del__</span> is absent, Python does no special finalization on garbage-collecting <span class="code"><em>x</em></span> (this is the most common case: very few classes need to define <span class="code">__del__</span>). Python ignores the return value of <span class="code">__del__</span> and doesn’t implicitly call <span class="code">__del__</span> methods of class <span class="code"><em>C</em></span>’s superclasses. <span class="code"><em>C</em></span>.<span class="code">__del__</span> must explicitly perform any needed finalization, including, if need be, by delegation. When class <span class="code"><em>C</em></span> has base classes to finalize, <span class="code"><em>C</em></span>.<span class="code">__del__</span> must call <span class="code">super().__del__()</span>.<br/>
			The <span class="code">__del__</span> method has no specific connection with the <span class="code"><strong>del</strong></span> statement, covered in <a data-type="xref" href="ch03.xhtml#del_statements">“del Statements”</a>.<br/>
<span class="code">__del__</span> is generally not the best approach when you need timely and guaranteed finalization. For such needs, use the <span class="code"><strong>try</strong></span><span class="code">/</span><span class="code"><strong>finally</strong></span> statement covered in <a data-type="xref" href="ch06.xhtml#trysolidusfinally">“try/finally”</a> (or, even better, the <span class="code"><strong>with</strong></span> statement, covered in <a data-type="xref" href="ch03.xhtml#the_with_statement">“The with Statement”</a>). Instances of classes defining <span class="code">__del__</span> don’t participate in cyclic garbage collection, covered in <a data-type="xref" href="ch14.xhtml#garbage_collection">“Garbage Collection”</a>. Be careful to avoid reference loops involving such instances: define <span class="code">__del__</span> only when there is no feasible alternative.</td>
</tr>
<tr>
<td><span class="code">__delattr__</span></td>
<td><span class="code">__delattr__(self,</span> <span class="code"><em>name</em></span><span class="code">)</span><br/>
			At<a contenteditable="false" data-primary="__delattr__ (special method)" data-type="indexterm" id="idm44924580424544"/> every request to unbind attribute <span class="code"><em>x.y</em></span> (typically, <span class="code"><strong>del</strong></span> <span class="code"><em>x.y</em></span>), Python calls <span class="code"><em>x</em></span><span class="code">.__delattr__('<em>y</em>')</span>. All the considerations discussed later for <span class="code">__setattr__</span> also apply to <span class="code">__delattr__</span>. Python ignores the return value of <span class="code">__delattr__</span>. Absent <span class="code">__delattr__</span>, Python turns <span class="code"><strong>del</strong></span> <span class="code"><em>x.y</em></span> into <span class="code"><strong>del</strong></span> <span class="code"><em>x</em></span><span class="code">.__dict__['<em>y</em>']</span>.</td>
</tr>
<tr>
<td><span class="code">__dir__</span></td>
<td><span class="code">__dir__(self)</span><br/>
			When<a contenteditable="false" data-primary="__dir__ (special method)" data-type="indexterm" id="idm44924580409536"/> you call <span class="code">dir(<em>x</em>)</span>, Python translates the operation into a call to <span class="code"><em>x</em></span><span class="code">.__dir__()</span>, which must return a sorted list of <span class="code"><em>x</em></span>’s attributes. When <span class="code"><em>x</em></span>’s class has no <span class="code">__dir__</span>, <span class="code">dir(<em>x</em>)</span> performs introspection to return a sorted list of <span class="code"><em>x</em></span>’s attributes, striving to produce relevant, rather than complete, information.</td>
</tr>
<tr>
<td><span class="code">__eq__</span>, <span class="code">__ge__</span>,<br/>
<span class="code">__gt__</span>, <span class="code">__le__</span>,<br/>
<span class="code">__lt__</span>, <span class="code">__ne__</span></td>
<td><span class="code">__eq__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>, <span class="code">__ge__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>,<br/>
<span class="code">__gt__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>, <span class="code">__le__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>,<br/>
<span class="code">__lt__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>, <span class="code">__ne__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span><br/>
			The<a contenteditable="false" data-primary="__eq__ (special method)" data-type="indexterm" id="idm44924580380864"/><a contenteditable="false" data-primary="__ge__ (special method)" data-type="indexterm" id="idm44924580379760"/><a contenteditable="false" data-primary="__gt__ (special method)" data-type="indexterm" id="idm44924580378656"/><a contenteditable="false" data-primary="__le__ (special method)" data-type="indexterm" id="idm44924580377552"/><a contenteditable="false" data-primary="__lt__ (special method)" data-type="indexterm" id="idm44924580376448"/><a contenteditable="false" data-primary="__ne__ (special method)" data-type="indexterm" id="idm44924580375344"/> comparisons <span class="code"><em>x</em></span> <span class="code">==</span> <span class="code"><em>y</em></span>, <span class="code"><em>x</em></span> <span class="code">&gt;=</span> <span class="code"><em>y</em></span>, <span class="code"><em>x</em></span> <span class="code">&gt;</span> <span class="code"><em>y</em></span>, <span class="code"><em>x</em></span> <span class="code">&lt;=</span> <span class="code"><em>y</em></span>, <span class="code"><em>x</em></span> <span class="code">&lt;</span> <span class="code"><em>y</em></span>, and <span class="code"><em>x</em></span> <span class="code">!=</span> <span class="code"><em>y</em></span>, respectively, call the special methods listed here, which should return <span class="code"><strong>False</strong></span> or <span class="code"><strong>True</strong></span>. Each method may return<a contenteditable="false" data-primary="NotImplemented" data-type="indexterm" id="idm44924580357920"/> <span class="code">NotImplemented</span> to tell Python to handle the comparison in alternative ways (e.g., Python may then try <span class="code"><em>y</em></span> <span class="code">&gt;</span> <span class="code"><em>x</em></span> in lieu of <span class="code"><em>x</em></span> <span class="code">&lt;</span> <span class="code"><em>y</em></span>).<br/>
			Best practice is to define only one inequality comparison method (normally <span class="code">__lt__</span>) plus <span class="code">__eq__</span>, and decorate the class with <span class="code">functools.total_ordering</span> (covered in <a data-type="xref" href="ch08.xhtml#functions_and_attributes_of_the_functoo">Table 8-7</a>), to avoid boilerplate and any risk of logical contradictions in your comparisons.</td>
</tr>
<tr>
<td><span class="code">__format__</span></td>
<td><span class="code">__format__(self, format_string='')</span><br/>
			Calling<a contenteditable="false" data-primary="__format__ (special method)" data-type="indexterm" id="idm44924580346256"/> <span class="code">format(<em>x</em>)</span> calls <span class="code"><em>x</em></span><span class="code">.__format__('')</span>, and calling <span class="code">format(<em>x, format_string</em>)</span> calls <span class="code"><em>x</em></span><span class="code">.__format__(<em>format_string</em>)</span>. The class is responsible for interpreting the format string (each class may define its own small “language” of format specifications, inspired by those implemented by built-in types, as covered in <a data-type="xref" href="ch09.xhtml#string_formatting">“String Formatting”</a>). When <span class="code">__format__</span> is inherited from <span class="code">object</span>, it delegates to <span class="code">__str__</span> and does not accept a nonempty format string.</td>
</tr>
<tr>
<td><span class="code">__getattr__</span></td>
<td><span class="code">__getattr__(self,</span> <span class="code"><em>name</em></span><span class="code">)</span><br/>
			When<a contenteditable="false" data-primary="__getattr__ (special method)" data-type="indexterm" id="idm44924580332448"/> <span class="code"><em>x.y</em></span> can’t be found by the usual steps (i.e., when an <span class="code">AttributeError</span> would usually be raised), Python calls <span class="code"><em>x</em></span><span class="code">.__getattr__('<em>y</em>')</span>. Python does not call <span class="code">__getattr__</span> for attributes found by normal means (as keys in <span class="code"><em>x</em></span><span class="code">.__dict__</span>, or via <span class="code"><em>x</em></span><span class="code">.__class__</span>). If you want Python to call <span class="code">__getattr__</span> for <em>every</em> attribute, keep the attributes elsewhere (e.g., in another <span class="code">dict</span> referenced by an attribute with a private name), or override <span class="code">__getattribute__</span> instead. <span class="code">__getattr__</span> should raise <span class="code">AttributeError</span> if it can’t find <span class="code"><em>y</em></span>.</td>
</tr>
<tr>
<td><span class="code">__getattribute__</span></td>
<td><span class="code">__getattribute_(self,</span> <span class="code"><em>name</em></span><span class="code">)</span><br/>
			At<a contenteditable="false" data-primary="__getattribute__ (special method)" data-type="indexterm" id="idm44924580315360"/> every request to access attribute <span class="code"><em>x</em></span>.<span class="code"><em>y</em></span>, Python calls <span class="code"><em>x</em></span><span class="code">.__getattribute__('<em>y</em>')</span>, which must get and return the attribute value or else raise <span class="code">AttributeError</span>. The usual semantics of attribute access (<span class="code"><em>x</em></span><span class="code">.__dict__</span>, <span class="code"><em>C.</em></span><span class="code">__slots__</span>, <span class="code"><em>C</em></span>’s class attributes, <span class="code"><em>x</em></span><span class="code">.__getattr__</span>) are all due to <span class="code">object.__getattribute__</span>.<br/>
			When class <span class="code"><em>C</em></span> overrides <span class="code">__getattribute__</span>, it must implement all of the attribute semantics it wants to offer. The typical way to implement attribute access is by delegating (e.g., call <span class="code">object.__getattribute__(self, ...)</span> as part of the operation of your override of <span class="code">__getattribute__</span>).
			<div data-type="warning" epub:type="warning">
<h1>Overriding __getattribute__ Slows Attribute Access</h1>
<p>When a class overrides <span class="code">__getattribute__</span>, all attribute accesses on instances of the class become slow, as the overriding code executes on every attribute access.</p>
</div>
</td>
</tr>
<tr>
<td><span class="code">__hash__</span></td>
<td><span class="code">__hash__(self)</span><br/>
			Calling<a contenteditable="false" data-primary="__hash__ (special method)" data-type="indexterm" id="idm44924580296656"/> <span class="code">hash(<em>x</em>)</span> calls <span class="code"><em>x</em></span><span class="code">.__hash__()</span> (and so do other contexts that need to know <span class="code"><em>x</em></span>’s hash value, namely using <span class="code"><em>x</em></span> as a dictionary key, such as <span class="code"><em>D</em></span><span class="code">[<em>x</em>]</span> where <span class="code"><em>D</em></span> is a dictionary, or using <span class="code"><em>x</em></span> as a set member). <span class="code">__hash__</span> must return an <span class="code">int</span> such that <span class="code"><em>x</em></span><span class="code">==<em>y</em></span> implies <span class="code">hash(</span><span class="code"><em>x</em>)==hash(<em>y</em>)</span>, and must always return the same value for a given object.<br/>
			When <span class="code">__hash__</span> is absent, calling <span class="code">hash(<em>x</em>)</span> calls <span class="code">id(<em>x</em>)</span> instead, as long as <span class="code">__eq__</span> is also absent. Other contexts that need to know <span class="code"><em>x</em></span>’s hash value behave the same way.<br/>
			Any <span class="code"><em>x</em></span> such that <span class="code">hash(<em>x</em>)</span> returns a result, rather than raising an exception, is known as a <em>hashable object</em>. When <span class="code">__hash__</span> is absent, but <span class="code">__eq__</span> is present, calling <span class="code">hash(<em>x</em>)</span> raises an exception (and so do other contexts that need to know <span class="code"><em>x</em></span>’s hash value). In this case, <span class="code"><em>x</em></span> is not hashable and therefore cannot be a dictionary key or set member.<br/>
			You normally define <span class="code">__hash__</span> only for immutable objects that also define <span class="code">__eq__</span>. Note that if there exists any <span class="code"><em>y</em></span> such that <span class="code"><em>x</em></span><span class="code">==<em>y</em></span>, even if <span class="code"><em>y</em></span> is of a different type, and both <span class="code"><em>x</em></span> and <span class="code"><em>y</em></span> are hashable, you <em>must</em> ensure that <span class="code">hash(</span><span class="code"><em>x</em>)==hash(<em>y</em>)</span>. (There are few cases, among Python built-ins, where <span class="code"><em>x</em></span><span class="code">==</span><span class="code"><em>y</em></span> can hold between objects of different types. The most important ones are equality between different number types: an <span class="code">int</span> can equal a <span class="code">bool</span>, a <span class="code">float</span>, a <span class="code">fractions.Fraction</span> instance, or a <span class="code">decimal.Decimal</span> instance.)</td>
</tr>
<tr>
<td><span class="code">__init__</span></td>
<td><span class="code">__init__(self[,</span> <span class="code"><em>args</em></span><span class="code">...])</span><br/>
			When<a contenteditable="false" data-primary="__init__ (special method)" data-type="indexterm" id="idm44924580250832"/> a call <span class="code"><em>C</em></span><span class="code">([<em>args...</em>])</span> creates instance <span class="code"><em>x</em></span> of class <span class="code"><em>C</em></span>, Python calls <span class="code"><em>x</em></span><span class="code">.__init__([<em>args</em>...])</span> to let <span class="code"><em>x</em></span> initialize itself. If <span class="code">__init__</span> is absent (i.e., it’s inherited from <span class="code">object</span>), you must call <span class="code"><em>C</em></span> without arguments, <span class="code"><em>C</em></span><span class="code">()</span>, and <span class="code"><em>x</em></span> has no instance-specific attributes on creation. Python performs no implicit call to <span class="code">__init__</span> methods of class <span class="code"><em>C</em></span>’s superclasses. <span class="code"><em>C</em></span><span class="code">.__init__</span> must explicitly perform any initialization, including, if need be, by delegation. For example, when class <span class="code"><em>C</em></span> has a base class <span class="code"><em>B</em></span> to initialize without arguments, the code in <span class="code"><em>C</em></span>.<span class="code">__init__</span> must explicitly call <span class="code">super().__init__()</span>. <span class="code">__init__</span>’s inheritance works just like for any other method or attribute: if <span class="code"><em>C</em></span> itself does not override <span class="code">__init__</span>, it inherits it from the first superclass in its <span class="code">__mro__</span> to override <span class="code">__init__</span>, like every other attribute.<br/>
<span class="code">__init__</span> must return <span class="code">None</span>; otherwise, calling the class raises <span class="code">TypeError</span>.</td>
</tr>
<tr>
<td><span class="code">__new__</span></td>
<td><span class="code">__new__(cls[,</span> <span class="code"><em>args</em></span><span class="code">...])</span><br/>
			When you call <span class="code"><em>C</em></span><span class="code">([<em>args</em>...])</span>, Python gets the new instance <span class="code"><em>x</em></span> that you are creating by invoking <span class="code"><em>C.</em></span><span class="code">__new__(<em>C</em>[,</span> <span class="code"><em>args</em></span><span class="code">...])</span>. Every class has the class method <span class="code">__new__</span> (usually, it just inherits it from <span class="code">object</span>), which can return any value <span class="code"><em>x</em></span>. In other words, <span class="code">__new__</span> need not return a new instance of <span class="code"><em>C</em></span>, although it’s expected to do so. If the value <span class="code"><em>x</em></span> that <span class="code">__new__</span> returns is an instance of <span class="code"><em>C</em></span> or of any subclass of <span class="code"><em>C</em></span> (whether a new or a previously existing one), Python then calls <span class="code">__init__</span> on <span class="code"><em>x</em></span> (with the same <span class="code">[<em>args</em>...]</span> originally passed to <span class="code">__new__</span>).
			<div data-type="tip">
<h1>Initialize Immutables in __new__, All Others in __init__</h1>
<p>You<a contenteditable="false" data-primary="__new__ (special method)" data-type="indexterm" id="idm44924580203696"/> can perform most kinds of initialization of new instances in either <span class="code">__init__</span> or <span class="code">__new__</span>, so you may wonder where it’s best to place them. Best practice is to put the initialization in <span class="code">__init__</span> only, unless you have a specific reason to put it in <span class="code">__new__</span>. (When a type is immutable, <span class="code">__init__</span> cannot change its instances: in this case, <span class="code">__new__</span> has to perform all initialization.)</p>
</div>
</td>
</tr>
<tr>
<td><span class="code">__repr__</span></td>
<td><span class="code">__repr__(self)</span><br/>
			Calling<a contenteditable="false" data-primary="__repr__ (special method)" data-type="indexterm" id="idm44924580195712"/> <span class="code">repr(<em>x</em>)</span> (which happens implicitly in the interactive interpreter when <span class="code"><em>x</em></span> is the result of an expression statement) calls <span class="code"><em>x</em></span><span class="code">.__repr__()</span> to get and return a complete string representation of <span class="code"><em>x</em></span>. If <span class="code">__repr__</span> is absent, Python uses a default string representation. <span class="code">__repr__</span> should return a string with unambiguous information on <span class="code"><em>x</em></span>. When feasible, try to make <span class="code">eval(repr(<em>x</em>))==</span><span class="code"><em>x</em></span> (but, don’t go crazy to achieve this goal!).</td>
</tr>
<tr>
<td><span class="code">__setattr__</span></td>
<td><span class="code">__setattr__(self,</span> <span class="code"><em>name</em></span><span class="code">,</span> <span class="code"><em>value</em></span><span class="code">)</span><br/>
			At<a contenteditable="false" data-primary="__setattr__ (special method)" data-type="indexterm" id="idm44924580180416"/> any request to bind attribute <span class="code"><em>x.y</em></span> (usually, an assignment statement <span class="code"><em>x.y=value</em></span>, but also, e.g., <span class="code">setattr(<em>x</em>, '<em>y</em>',</span> <span class="code"><em>value</em></span><span class="code">))</span>, Python calls <span class="code"><em>x</em></span><span class="code">.__setattr__('<em>y</em>',</span> <span class="code"><em>value</em></span><span class="code">)</span>. Python always calls <span class="code">__setattr__</span> for <em>any</em> attribute binding on <span class="code"><em>x</em></span>—a major difference from <span class="code">__getattr__</span> (in this respect, <span class="code">__setattr__</span> is closer to <span class="code">__getattribute__</span>). To avoid recursion, when <span class="code"><em>x</em></span><span class="code">.__setattr__</span> binds <span class="code"><em>x</em></span>’s attributes, it must modify <span class="code"><em>x</em></span><span class="code">.__dict__</span> directly (e.g., via <span class="code"><em>x</em></span><span class="code">.__dict__[<em>name</em>]=<em>value</em></span>); or better, <span class="code">__setattr__</span> can delegate to the superclass (call <span class="code">super().__setattr__('</span><span class="code"><em>y</em>',</span> <span class="code"><em>value</em></span><span class="code">)</span>). Python ignores the return value of <span class="code">__setattr__</span>. If <span class="code">__setattr__</span> is absent (i.e., inherited from object), and <span class="code"><em>C.y</em></span> is not an overriding descriptor, Python usually translates <span class="code"><em>x.y=z</em></span> into <span class="code"><em>x</em></span><span class="code">.__dict__['<em>y</em>']=</span><span class="code"><em>z</em></span> (however, <span class="code">__setattr__</span> also works fine with <span class="code">__slots__</span>).</td>
</tr>
<tr>
<td><span class="code">__str__</span></td>
<td><span class="code">__str__(self)</span><br/>
			Like<a contenteditable="false" data-primary="__str__ (special method)" data-type="indexterm" id="idm44924580148144"/> print(<em>x</em>), <span class="code">str(<em>x</em>)</span> calls <span class="code"><em>x</em></span><span class="code">.__str__()</span> to get an informal, concise string representation of <span class="code"><em>x</em></span>. If <span class="code">__str__</span> is absent, Python calls <span class="code"><em>x</em></span><span class="code">.__repr__</span>. <span class="code">__str__</span> should return a convenient human-readable string, even when that entails some approximation.</td>
</tr>
</tbody>
</table>
</div></section>
<section data-pdf-bookmark="Special Methods for Containers" data-type="sect2"><div class="sect2" id="special_methods_for_containers">
<h2>Special Methods for Containers</h2>
<p>An<a contenteditable="false" data-primary="special methods" data-secondary="for containers" data-secondary-sortas="containers" data-type="indexterm" id="idm44924580138352"/><a contenteditable="false" data-primary="containers" data-secondary="special methods for" data-type="indexterm" id="Cspecial04"/> instance can be a <em>container</em> (a sequence, mapping, or set—mutually exclusive concepts<sup><a data-type="noteref" href="ch04.xhtml#ch01fn56" id="ch01fn56-marker">9</a></sup>). For maximum usefulness, containers should provide special methods <span class="code">__getitem__</span>, <span class="code">__contains__</span>, and <span class="code">__iter__</span> (and, if mutable, also <span class="code">__setitem__</span> and <span class="code">__delitem__</span>), plus nonspecial methods discussed in the following sections. In many cases, you can obtain suitable implementations of the nonspecial methods by extending the appropriate abstract base class from the <span class="code">collections.abc</span> module, such as <span class="code">Sequence</span>, <span class="code">MutableSequence</span>, and so on, as covered in <a data-type="xref" href="#abstract_base_classe">“Abstract Base Classes”</a>.</p>
<section data-pdf-bookmark="Sequences" data-type="sect3"><div class="sect3" id="sequences">
<h3>Sequences</h3>
<p>In<a contenteditable="false" data-primary="sequence operations" data-secondary="special methods for containers" data-type="indexterm" id="idm44924580124720"/><a contenteditable="false" data-primary="sequence operations" data-type="indexterm" id="idm44924580122624"/> each item-access special method, a sequence that has <span class="code"><em>L</em></span> items should accept any integer <span class="code"><em>key</em></span> such that <span class="code"><em>-L</em></span><span class="code">&lt;=<em>key</em>&lt;<em>L</em></span>.<sup><a data-type="noteref" href="ch04.xhtml#ch01fn57" id="ch01fn57-marker">10</a></sup> For compatibility with built-in sequences, a negative index <span class="code"><em>key</em></span>, <span class="code">0&gt;</span><span class="code"><em>key</em>&gt;=-<em>L</em></span>, should be equivalent to <span class="code"><em>key</em>+</span><span class="code"><em>L</em></span>. When <span class="code"><em>key</em></span> has an invalid type, indexing should raise a <span class="code">TypeError</span> exception. When <span class="code"><em>key</em></span> is a value of a valid type but out of range, indexing should raise an <span class="code">IndexError</span> exception. For sequence classes that do not define <span class="code">__iter__</span>, the <span class="code"><strong>for</strong></span> statement relies on these requirements, as do built-in functions that take iterable arguments. Every item-access special method of a sequence should also, if at all practical, accept as its index argument an instance of the built-in type <span class="code">slice</span> whose <span class="code">start</span>, <span class="code">step</span>, and <span class="code">stop</span> attributes are <span class="code">int</span>s or <span class="code">None</span>; the <em>slicing</em> syntax relies on this requirement, as covered in <a data-type="xref" href="#container_slicing">“Container slicing”</a>.</p>
<p>A sequence should also allow concatenation (with another sequence of the same type) by <span class="code">+</span>, and repetition by <span class="code">*</span> (multiplication by an integer). A sequence should therefore have special methods<a contenteditable="false" data-primary="__add__ (numeric special method)" data-type="indexterm" id="idm44924580100256"/><a contenteditable="false" data-primary="__mul__ (numeric special method)" data-type="indexterm" id="idm44924580099136"/> <span class="code">__add__</span>, <span class="code">__mul__</span>, <span class="code">__radd__</span>, and <span class="code">__rmul__</span>, covered in <a data-type="xref" href="#special_methods_for_numeric_object">“Special Methods for Numeric Objects”</a>; in addition, <em>mutable</em> sequences should have equivalent in-place methods <span class="code">__iadd__</span> and <span class="code">__imul__</span>. A sequence should be meaningfully comparable to another sequence of the same type, implementing<a contenteditable="false" data-primary="comparison" data-secondary="lexicographic comparison" data-type="indexterm" id="idm44924580092000"/><a contenteditable="false" data-primary="lexicographic comparison" data-type="indexterm" id="idm44924580090560"/> <a href="https://oreil.ly/byfuT"><em>lexicographic</em> comparison</a>, like lists and tuples do. (Inheriting from the <span class="code">Sequence</span> or <span class="code">MutableSequence</span> abstract base class does not suffice to fulfill all of these requirements; inheriting from <span class="code">MutableSequence</span>, at most, only supplies <span class="code">__iadd__</span>.)</p>
<p>Every<a contenteditable="false" data-primary="count method" data-secondary="sequence type" data-type="indexterm" id="idm44924580085184"/> sequence should have the nonspecial methods covered in <a data-type="xref" href="ch03.xhtml#list_methods">“List methods”</a>: <span class="code">count</span> and <span class="code">index</span> in any case, and, if mutable, then also <span class="code">append</span>, <span class="code">insert</span>,<a contenteditable="false" data-primary="extend method" data-secondary="sequence type" data-type="indexterm" id="idm44924580079424"/> <span class="code">extend</span>, <span class="code">pop</span>, <span class="code">remove</span>, <span class="code">reverse</span>, and <span class="code">sort</span>, with the same signatures and semantics as the corresponding methods of lists. (Inheriting from the <span class="code">Sequence</span> or <span class="code">MutableSequence</span> abstract base class does suffice to fulfill these requirements, except for <span class="code">sort</span>.)</p>
<p>An immutable sequence should be hashable if, and only if, all of its items are. A sequence type may constrain its items in some ways (for example, accepting only string items), but that is not mandatory.</p>
</div></section>
<section data-pdf-bookmark="Mappings" data-type="sect3"><div class="sect3" id="mappings">
<h3>Mappings</h3>
<p>A<a contenteditable="false" data-primary="mappings" data-secondary="special methods for containers" data-type="indexterm" id="idm44924580070192"/> mapping’s item-access special methods should raise a <span class="code">KeyError</span> exception, rather than <span class="code">IndexError</span>, when they receive an invalid <span class="code"><em>key</em></span> argument value of a valid type. Any mapping should define the nonspecial methods covered in <a data-type="xref" href="ch03.xhtml#dictionary_methods">“Dictionary Methods”</a>: <span class="code">copy</span>, <span class="code">get</span>, <span class="code">items</span>, <span class="code">keys</span>, and <span class="code">values</span>. A mutable mapping should also define the methods <span class="code">clear</span>, <span class="code">pop</span>, <span class="code">popitem</span>, <span class="code">setdefault</span>, and <span class="code">update</span>. (Inheriting from the <span class="code">Mapping</span> or <span class="code">MutableMapping</span> abstract base class fulfills these requirements, except for <span class="code">copy</span>.)</p>
<p>An immutable mapping should be hashable if all of its items are. A mapping type may constrain its keys in some ways—for example, accepting only hashable keys, or (even more specifically) accepting, say, only string keys—but that is not mandatory. Any mapping should be meaningfully comparable to another mapping of the same type (at least for equality and inequality, although not necessarily for ordering comparisons).</p>
</div></section>
<section data-pdf-bookmark="Sets" data-type="sect3"><div class="sect3" id="set">
<h3>Sets</h3>
<p>Sets<a contenteditable="false" data-primary="set operations" data-secondary="special methods for containers" data-type="indexterm" id="idm44924580053696"/> are a peculiar kind of container: they are neither sequences nor mappings and cannot be indexed, but they do have a length (number of elements) and are iterable. Sets also support many operators (<span class="code">&amp;</span>, <span class="code">|</span>, <span class="code">^</span>, and <span class="code">-</span>, as well as membership tests and comparisons) and equivalent nonspecial methods (<span class="code">intersection</span>, <span class="code">union</span>, and so on). If you implement a set-like container, it should be polymorphic to Python built-in sets, covered in <a data-type="xref" href="ch03.xhtml#sets">“Sets”</a>. (Inheriting from the <span class="code">Set</span> or <span class="code">MutableSet</span> abstract base class fulfills these requirements.)</p>
<p>An immutable set-like type should be hashable if all of its elements are. A set-like type may constrain its elements in some ways—for example, accepting only hashable elements, or (more specifically) accepting, say, only integer elements—but that is not mandatory.</p>
</div></section>
<section data-pdf-bookmark="Container slicing" data-type="sect3"><div class="sect3" id="container_slicing">
<h3>Container slicing</h3>
<p>When<a contenteditable="false" data-primary="slicing" data-secondary="special methods for containers" data-type="indexterm" id="idm44924580042864"/> you reference, bind, or unbind a slicing such as <span class="code"><em>x</em></span><span class="code">[<em>i</em>:<em>j</em>]</span> or <span class="code"><em>x</em></span><span class="code">[<em>i</em>:<em>j</em>:<em>k</em>]</span> on a container <span class="code"><em>x</em></span> (in practice, this is only used with sequences), Python calls <span class="code"><em>x</em></span>’s applicable item-access special method, passing as <span class="code"><em>key</em></span> an object of a built-in type called a <em>slice object</em>. A slice object has the attributes <span class="code">start</span>, <span class="code">stop</span>, and <span class="code">step</span>. Each attribute is <span class="code"><strong>None</strong></span> if you omit the corresponding value in the slice syntax. For example, <span class="code"><strong>del</strong></span> <span class="code"><em>x</em></span><span class="code">[:3]</span> calls <span class="code"><em>x</em></span><span class="code">.__delitem__(<em>y</em>)</span>, where <span class="code"><em>y</em></span> is a slice object such that <span class="code"><em>y</em></span><span class="code">.stop</span> is <span class="code">3</span>, <span class="code"><em>y</em></span><span class="code">.start</span> is <span class="code"><strong>None</strong></span>, and <span class="code"><em>y</em></span><span class="code">.step</span> is <span class="code"><strong>None</strong></span>. It is up to container object <span class="code"><em>x</em></span> to appropriately interpret slice object arguments passed to <span class="code"><em>x</em></span>’s special methods. The method <span class="code">indices</span> of slice objects can help: call it with your container’s length as its only argument, and it returns a tuple of three nonnegative indices suitable as <span class="code">start</span>, <span class="code">stop</span>, and <span class="code">step</span> for a loop indexing each item in the slice. For example, a common idiom in a sequence class’s <span class="code">__getitem__</span> special method to fully support slicing is:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">def</code></strong><code> </code><code class="fm">__getitem__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">index</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><em><code class="c1"># Recursively special-case slicing</code></em><code>
</code><code>    </code><strong><code class="k">if</code></strong><code> </code><code class="nb">isinstance</code><code class="p">(</code><code class="n">index</code><code class="p">,</code><code> </code><code class="nb">slice</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><strong><code class="k">return</code></strong><code> </code><code class="bp">self</code><code class="o">.</code><code class="vm">__class__</code><code class="p">(</code><code class="bp">self</code><code class="p">[</code><code class="n">x</code><code class="p">]</code><code>
</code><code>                              </code><strong><code class="k">for</code></strong><code> </code><code class="n">x</code><code> </code><strong><code class="ow">in</code></strong><code> </code><code class="nb">range</code><code class="p">(</code><code class="o">*</code><code class="n">index</code><code class="o">.</code><code class="n">indices</code><code class="p">(</code><code class="nb">len</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">)</code><code class="p">)</code><code class="p">)</code><code>
</code><code>    </code><em><code class="c1"># Check index, and deal with a negative and/or out-of-bounds index</code></em><code>
</code><code>    </code><code class="n">index</code><code> </code><code class="o">=</code><code> </code><code class="n">operator</code><code class="o">.</code><code class="n">index</code><code class="p">(</code><code class="n">index</code><code class="p">)</code><code>
</code><code>    </code><strong><code class="k">if</code></strong><code> </code><code class="n">index</code><code> </code><code class="o">&lt;</code><code> </code><code class="mi">0</code><code class="p">:</code><code>
</code><code>        </code><code class="n">index</code><code> </code><code class="o">+</code><code class="o">=</code><code> </code><code class="nb">len</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code>
</code><code>    </code><strong><code class="k">if</code><code> </code><code class="ow">not</code></strong><code> </code><code class="p">(</code><code class="mi">0</code><code> </code><code class="o">&lt;</code><code class="o">=</code><code> </code><code class="n">index</code><code> </code><code class="o">&lt;</code><code> </code><code class="nb">len</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><strong><code class="k">raise</code><code> </code><code class="ne">IndexError</code></strong><code>
</code><code>    </code><em><code class="c1"># Index is now a correct int, within range(len(self))</code></em><code>
</code><em><code>    </code><code class="c1"># ...rest of __getitem__, dealing with single-item access...</code></em></pre>
<p>This idiom uses generator expression (genexp) syntax and assumes that your class’s <span class="code">__init__</span> method can be called with an iterable argument to create a suitable new instance of the class.</p>
</div></section>
<section data-pdf-bookmark="Container methods" data-type="sect3"><div class="sect3" id="container_method">
<h3>Container methods</h3>
<p>The special methods <span class="code">__getitem__</span>, <span class="code">__setitem__</span>, <span class="code">__delitem__</span>, <span class="code">__iter__</span>, <span class="code">__len__</span>, and <span class="code">__contains__</span> expose container functionality (see <a data-type="xref" href="#container_methods">Table 4-2</a>).</p>
<table class="border" id="container_methods">
<caption><span class="label">Table 4-2. </span>Container methods</caption>
<tbody>
<tr>
<td class="width-17"><span class="code">__contains__</span></td>
<td><span class="code">__contains__(self,</span> <span class="code"><em>item</em></span><span class="code">)</span><br/>
			The<a contenteditable="false" data-primary="__contains__ (container method)" data-type="indexterm" id="idm44924579859024"/> Boolean test <span class="code"><em>y</em></span> <span class="code"><strong>in</strong></span> <span class="code"><em>x</em></span> calls <span class="code"><em>x</em></span><span class="code">.__contains__(<em>y</em>)</span>. When <span class="code"><em>x</em></span> is a sequence, or set-like, <span class="code">__contains__</span> should return <span class="code"><strong>True</strong></span> when <span class="code"><em>y</em></span> equals the value of an item in <span class="code"><em>x</em></span>. When <span class="code"><em>x</em></span> is a mapping, <span class="code">__contains__</span> should return <span class="code"><strong>True</strong></span> when <span class="code"><em>y</em></span> equals the value of a key in <span class="code"><em>x</em></span>. Otherwise, <span class="code">__contains__</span> should return <span class="code"><strong>False</strong></span>. When <span class="code">__contains__</span> is absent and <span class="code"><em>x</em></span> is iterable, Python performs <span class="code"><em>y</em></span> <span class="code"><strong>in</strong></span> <span class="code"><em>x</em></span> as follows, taking time proportional to <span class="code">len(<em>x</em>)</span>:
			<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">for</code></strong><code> </code><em><code class="n">z</code></em><code> </code><strong><code class="ow">in</code></strong><code> </code><em><code class="n">x</code></em><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">if</code></strong><code> </code><em><code class="n">y</code></em><code class="o">==</code><em><code class="n">z</code></em><code class="p">:</code><code>
</code><code>        </code><strong><code class="k">return</code><code> </code><code class="kc">True</code></strong><code>
</code><strong><code class="k">return</code><code> </code><code class="kc">False</code></strong></pre>
</td>
</tr>
<tr>
<td><span class="code">__delitem__</span></td>
<td><span class="code">__delitem__(self,</span> <span class="code"><em>key</em></span><span class="code">)</span><br/>
			For<a contenteditable="false" data-primary="__delitem__ (container method)" data-type="indexterm" id="idm44924579810048"/> a request to unbind an item or slice of <span class="code"><em>x</em></span> (typically <span class="code"><strong>del</strong></span> <span class="code"><em>x</em></span><span class="code">[<em>key</em>]</span>), Python calls <span class="code"><em>x</em></span><span class="code">.__delitem__(<em>key</em>)</span>. A container <span class="code"><em>x</em></span> should have <span class="code">__delitem__</span> if <span class="code"><em>x</em></span> is mutable and items (and possibly slices) can be removed.</td>
</tr>
<tr>
<td><span class="code">__getitem__</span></td>
<td><span class="code">__getitem__(self,</span> <span class="code"><em>key</em></span><span class="code">)</span><br/>
			When<a contenteditable="false" data-primary="__getitem__ (container method)" data-type="indexterm" id="idm44924579779984"/> you access <span class="code"><em>x</em></span><span class="code">[<em>key</em>]</span> (i.e., when you index or slice container <span class="code"><em>x</em></span>), Python calls <span class="code"><em>x</em></span><span class="code">.__getitem__(<em>key</em>)</span>. All (non-set-like) containers should have <span class="code">__getitem__</span>.</td>
</tr>
<tr>
<td><span class="code">__iter__</span></td>
<td><span class="code">__iter__(self)</span><br/>
			For<a contenteditable="false" data-primary="__iter__ (container method)" data-type="indexterm" id="idm44924579770480"/> a request to loop on all items of <span class="code"><em>x</em></span> (typically <span class="code"><strong>for</strong></span> <span class="code"><em>item</em></span> <span class="code"><strong>in</strong></span> <span class="code"><em>x</em></span>), Python calls <span class="code"><em>x</em></span><span class="code">.__iter__()</span> to get an iterator on <span class="code"><em>x</em></span>. The built-in function <span class="code">iter(<em>x</em>)</span> also calls <span class="code"><em>x</em></span><span class="code">.__iter__()</span>. When <span class="code">__iter__</span> is absent, <span class="code">iter(<em>x</em>)</span> synthesizes and returns an iterator object that wraps <span class="code"><em>x</em></span> and yields <span class="code"><em>x</em></span><span class="code">[0]</span>, <span class="code"><em>x</em></span><span class="code">[1]</span>, and so on, until one of these indexings raises an <span class="code">IndexError</span> exception to indicate the end of the container. However, it is best to ensure that all of the container classes you code have <span class="code">__iter__</span>.</td>
</tr>
<tr>
<td><span class="code">__len__</span></td>
<td><span class="code">__len__(self)</span><br/>
			Calling<a contenteditable="false" data-primary="__len__ (container method)" data-type="indexterm" id="idm44924579751216"/> <span class="code">len(<em>x</em>)</span> calls <span class="code"><em>x</em></span><span class="code">.__len__()</span> (and so do other built-in functions that need to know how many items are in container <span class="code"><em>x</em></span>). <span class="code">__len__</span> should return an <span class="code">int</span>, the number of items in <span class="code"><em>x</em></span>. Python also calls <span class="code"><em>x</em></span><span class="code">._len__()</span> to evaluate <span class="code"><em>x</em></span> in a Boolean context, when <span class="code">__bool__</span> is absent; in this case, a container is falsy if and only if the container is empty (i.e., the container’s length is <span class="code">0</span>). All containers should have <span class="code">__len__</span>, unless it’s just too expensive for the container to determine how many items it contains.</td>
</tr>
<tr>
<td><span class="code">__setitem__</span></td>
<td><span class="code">__setitem__(self,</span> <span class="code"><em>key, value</em></span><span class="code">)</span><br/>
			For<a contenteditable="false" data-primary="__setitem__ (container method)" data-type="indexterm" id="idm44924578093392"/> a request to bind an item or slice of <span class="code"><em>x</em></span> (typically an assignment <span class="code"><em>x</em></span><span class="code">[<em>key</em>]=<em>value</em></span>), Python calls <span class="code"><em>x</em>.__setitem__(<em>key, value</em>)</span>. A container <span class="code"><em>x</em></span> should have <span class="code">__setitem__</span> if <span class="code"><em>x</em></span> is mutable, so items, and maybe slices, can be added or rebound.<a contenteditable="false" data-primary="" data-startref="Cspecial04" data-type="indexterm" id="idm44924578085312"/></td>
</tr>
</tbody>
</table>
</div></section>
</div></section>
<section data-pdf-bookmark="Abstract Base Classes" data-type="sect2"><div class="sect2" id="abstract_base_classe">
<h2>Abstract Base Classes</h2>
<p>Abstract base classes (ABCs)<a contenteditable="false" data-primary="special methods" data-secondary="abstract base classes (ABCs)" data-type="indexterm" id="idm44924578082000"/><a contenteditable="false" data-primary="abstract base classes (ABCs)" data-type="indexterm" id="abc04"/> are an important pattern in object-oriented design: they’re classes that cannot be directly instantiated, but exist to be extended by concrete classes (the more usual kind of classes, ones that <em>can</em> be instantiated).</p>
<p>One recommended approach to OO design (attributed to Arthur J. Riel) is to never extend a<a contenteditable="false" data-primary="concrete classes" data-type="indexterm" id="idm44924578078112"/> concrete class.<sup><a data-type="noteref" href="ch04.xhtml#ch01fn58" id="ch01fn58-marker">11</a></sup> If two concrete classes have enough in common to tempt you to have one of them inherit from the other, proceed instead by making an <em>abstract</em> base class that subsumes all they have in common, and have each concrete class extend that ABC. This approach avoids many of the subtle traps and pitfalls of inheritance.</p>
<p>Python offers rich support for ABCs—enough to make them a first-class part of Python’s object model.<sup><a data-type="noteref" href="ch04.xhtml#ch01fn59" id="ch01fn59-marker">12</a></sup></p>
<section data-pdf-bookmark="The abc module" data-type="sect3"><div class="sect3" id="the_abc_module">
<h3>The abc module</h3>
<p>The<a contenteditable="false" data-primary="abc module" data-type="indexterm" id="idm44924578069536"/><a contenteditable="false" data-primary="standard library modules" data-secondary="abc" data-type="indexterm" id="idm44924578068400"/> standard library module <span class="code">abc</span> supplies metaclass <span class="code">ABCMeta</span> and class <span class="code">ABC</span> (subclassing <span class="code">abc.ABC</span> makes <span class="code">abc.ABCMeta</span> the metaclass, and has no other effect).</p>
<p>When you use <span class="code">abc.ABCMeta</span> as the metaclass for any class <span class="code"><em>C</em></span>, this makes <span class="code"><em>C</em></span> an ABC and supplies the class method <span class="code"><em>C</em></span><span class="code">.register</span>, callable with a single argument: that single argument can be any existing class (or built-in type) <span class="code"><em>X</em></span>.</p>
<p>Calling <span class="code"><em>C</em></span><span class="code">.register(<em>X</em>)</span> makes <span class="code"><em>X</em></span> a<a contenteditable="false" data-primary="virtual subclasses" data-type="indexterm" id="idm44924578054672"/> <em>virtual</em> subclass of <span class="code"><em>C</em></span>, meaning that <span class="code">issubclass(<em>X,</em></span> <span class="code"><em>C</em>)</span> returns <span class="code"><strong>True</strong></span>, but <span class="code"><em>C</em></span> does not appear in <span class="code"><em>X</em></span><span class="code">.__mro__</span>, nor does <span class="code"><em>X</em></span> inherit any of <span class="code"><em>C</em></span>’s methods or other attributes.</p>
<p>Of course, it’s also possible to have a new class <span class="code"><em>Y</em></span> inherit from <span class="code"><em>C</em></span> in the normal way, in which case <span class="code"><em>C</em></span> does appear in <span class="code"><em>Y</em></span>.<span class="code">__mro__</span>, and <span class="code"><em>Y</em></span> inherits all of <span class="code"><em>C</em></span>’s methods, as usual in subclassing.</p>
<p>An ABC <span class="code"><em>C</em></span> can also optionally override class method <span class="code">__subclasshook__</span>, which <span class="code">issubclass(<em>X, C</em>)</span> calls with the single argument <span class="code"><em>X</em></span> (<span class="code"><em>X</em></span> being any class or type). When <span class="code"><em>C</em></span><span class="code">.__subclasshook__(<em>X</em>)</span> returns <span class="code"><strong>True</strong></span>, then so does <span class="code">issubclass(<em>X, C</em>)</span>; when <span class="code"><em>C</em></span><span class="code">.__subclasshook__(<em>X</em>)</span> returns <span class="code"><strong>False</strong></span>, then so does <span class="code">issubclass(<em>X, C</em>)</span>. When <span class="code"><em>C</em></span><span class="code">.__subclasshook__(<em>X</em>)</span> returns<a contenteditable="false" data-primary="NotImplemented" data-type="indexterm" id="idm44924578024592"/> <span class="code">NotImplemented</span>, then <span class="code">issubclass(<em>X, C</em>)</span> proceeds in the usual way.</p>
<p>The <span class="code">abc</span> module also supplies the decorator <span class="code">abstractmethod</span> to designate methods that must be implemented in inheriting classes. You can define a property as abstract by using both the <span class="code">property</span> and <span class="code">abstractmethod</span> decorators, in that order.<sup><a data-type="noteref" href="ch04.xhtml#ch01fn60" id="ch01fn60-marker">13</a></sup> Abstract methods and properties can have implementations (available to subclasses via the <span class="code">super</span> built-in), but the point of making methods and properties abstract is that you can instantiate a nonvirtual subclass <span class="code"><em>X</em></span> of an ABC <span class="code"><em>C</em></span> only if <span class="code"><em>X</em></span> overrides every abstract property and method of <span class="code"><em>C</em></span>.</p>
</div></section>
<section data-pdf-bookmark="ABCs in the collections module" data-type="sect3"><div class="sect3" id="abcs_in_the_collections_module">
<h3>ABCs in the collections module</h3>
<p><span class="code">collections</span><a contenteditable="false" data-primary="collections module" data-type="indexterm" id="idm44924578008240"/> supplies many ABCs, in <span class="code">collections.abc</span>.<sup><a data-type="noteref" href="ch04.xhtml#ch01fn61" id="ch01fn61-marker">14</a></sup> Some of these ABCs accept as a virtual subclass any class defining or inheriting a specific abstract method, as<a contenteditable="false" data-primary="__call__ (special method)" data-type="indexterm" id="idm44924578003680"/><a contenteditable="false" data-primary="__contains__ (container method)" data-type="indexterm" id="idm44924578002512"/><a contenteditable="false" data-primary="__hash__ (special method)" data-type="indexterm" id="idm44924578001392"/><a contenteditable="false" data-primary="__iter__ (container method)" data-type="indexterm" id="idm44924578000272"/><a contenteditable="false" data-primary="__len__ (container method)" data-type="indexterm" id="idm44924577999152"/> listed in <a data-type="xref" href="#single_method_abcs">Table 4-3</a>.</p>
<table class="border" id="single_method_abcs">
<caption class="width-full"><span class="label">Table 4-3. </span>Single-method ABCs</caption>
<thead>
<tr>
<th>ABC</th>
<th>Abstract methods</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="code">Callable</span></td>
<td><span class="code">__call__</span></td>
</tr>
<tr>
<td><span class="code">Container</span></td>
<td><span class="code">__contains__</span></td>
</tr>
<tr>
<td><span class="code">Hashable</span></td>
<td><span class="code">__hash__</span></td>
</tr>
<tr>
<td><span class="code">Iterable</span></td>
<td><span class="code">__iter__</span></td>
</tr>
<tr>
<td><span class="code">Sized</span></td>
<td><span class="code">__len__</span></td>
</tr>
</tbody>
</table>
<p>The other ABCs in <span class="code">collections.abc</span> extend one or more of these, adding more abstract methods and/or<a contenteditable="false" data-primary="mixin methods" data-type="indexterm" id="idm44924577981104"/><a contenteditable="false" data-primary="methods" data-secondary="mixin methods" data-type="indexterm" id="idm44924577980000"/> <em>mixin</em> methods implemented in terms of the abstract methods. (When you extend any ABC in a concrete class, you <em>must</em> override the abstract methods; you can also override some or all of the mixin methods, when that helps improve performance, but you don’t have to—you can just inherit them, when this results in performance that’s sufficient for your purposes.)</p>
<p><a data-type="xref" href="#abcs_with_additional_methods">Table 4-4</a> details the ABCs in <span class="code">collections.abc</span> that<a contenteditable="false" data-primary="extension modules" data-secondary="in collections.abc" data-secondary-sortas="collections.abc" data-type="indexterm" id="idm44924577975600"/> directly extend the preceding ones.</p>
<table class="border" id="abcs_with_additional_methods">
<caption><span class="label">Table 4-4. </span>ABCs with additional methods</caption>
<thead>
<tr>
<th>ABC</th>
<th>Extends</th>
<th>Abstract methods</th>
<th>Mixin methods</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="code">Iterator</span></td>
<td><span class="code">Iterable</span></td>
<td><span class="code">__next__</span></td>
<td><span class="code">__iter__</span></td>
</tr>
<tr>
<td><span class="code">Mapping</span></td>
<td><span class="code">Container</span><br/>
<span class="code">Iterable</span><br/>
<span class="code">Sized</span></td>
<td><span class="code">__getitem__</span><br/>
<span class="code">__iter__</span><br/>
<span class="code">__len__</span></td>
<td><span class="code">__contains__</span><br/>
<span class="code">__eq__</span><br/>
<span class="code">__ne__</span><br/>
<span class="code">getitems</span><br/>
<span class="code">keys</span><br/>
<span class="code">values</span></td>
</tr>
<tr>
<td><span class="code">MappingView</span></td>
<td><span class="code">Sized</span></td>
<td> </td>
<td><span class="code">__len__</span></td>
</tr>
<tr>
<td><span class="code">Sequence</span></td>
<td><span class="code">Container</span><br/>
<span class="code">Iterable</span><br/>
<span class="code">Sized</span></td>
<td><span class="code">__getitem__</span><br/>
<span class="code">__len__</span></td>
<td><span class="code">__contains__</span><br/>
<span class="code">__iter__</span><br/>
<span class="code">__reversed__</span><br/>
<span class="code">count</span><br/>
<span class="code">index</span></td>
</tr>
<tr>
<td><span class="code">Set</span></td>
<td><span class="code">Container</span><br/>
<span class="code">Iterable</span><br/>
<span class="code">Sized</span></td>
<td><span class="code">__contains__</span><br/>
<span class="code">__iter</span><br/>
<span class="code">__len__</span></td>
<td><span class="code">__and__</span><sup><a data-type="noteref" href="ch04.xhtml#ch01fn62" id="ch01fn62-marker">a</a></sup><br/>
<span class="code">__eq__</span><br/>
<span class="code">__ge__</span><sup><a data-type="noteref" href="ch04.xhtml#ch01fn63" id="ch01fn63-marker">b</a></sup><br/>
<span class="code">__gt__</span><br/>
<span class="code">__le__</span><br/>
<span class="code">__lt__</span><br/>
<span class="code">__ne__</span><br/>
<span class="code">__or__</span><br/>
<span class="code">__sub__</span><br/>
<span class="code">__xor__</span><br/>
<span class="code">isdisjoint</span></td>
</tr>
</tbody>
<tbody><tr class="footnotes"><td colspan="4"><p data-type="footnote" id="ch01fn62"><sup><a href="ch04.xhtml#ch01fn62-marker">a</a></sup> For sets and mutable sets, many dunder methods are equivalent to nonspecial methods in the concrete class <span class="code">set</span>; e.g., <span class="code">__add__</span> is like <span class="code">intersection</span> and <span class="code">__iadd__</span> is like <span class="code">intersection_update</span>.</p><p data-type="footnote" id="ch01fn63"><sup><a href="ch04.xhtml#ch01fn63-marker">b</a></sup> For sets, the ordering methods reflect the concept of <em>subset</em>: <span class="code"><em>s1</em></span> <span class="code">&lt;=</span> <span class="code"><em>s2</em></span> means “<span class="code"><em>s1</em></span> is a subset of or equal to <span class="code"><em>s2</em></span>.”</p></td></tr></tbody></table>
<p><a data-type="xref" href="#the_remaining_abcs_in_collectionsdotabc">Table 4-5</a> details the ABCs in this module that further extend the previous ones.</p>
<table class="border" id="the_remaining_abcs_in_collectionsdotabc">
<caption><span class="label">Table 4-5. </span>The remaining ABCs in <span class="code">collections.abc</span></caption>
<thead>
<tr>
<th>ABC</th>
<th>Extends</th>
<th>Abstract methods</th>
<th>Mixin methods</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="code">ItemsView</span></td>
<td><span class="code">MappingView</span><br/>
<span class="code">Set</span></td>
<td> </td>
<td><span class="code">__contains__</span><br/>
<span class="code">__iter__</span></td>
</tr>
<tr>
<td><span class="code">KeysView</span></td>
<td><span class="code">MappingView</span><br/>
<span class="code">Set</span></td>
<td> </td>
<td><span class="code">__contains__</span><br/>
<span class="code">__iter__</span></td>
</tr>
<tr>
<td><span class="code">MutableMapping</span></td>
<td><span class="code">Mapping</span></td>
<td><span class="code">__delitem__</span><br/>
<span class="code">__getitem__</span><br/>
<span class="code">__iter__</span><br/>
<span class="code">__len_</span><br/>
<span class="code">__setitem__</span></td>
<td><span class="code">Mapping</span>’s methods, plus:<br/>
<span class="code">clear</span><br/>
<span class="code">pop</span><br/>
<span class="code">popitem</span><br/>
<span class="code">setdefault</span><br/>
<span class="code">update</span></td>
</tr>
<tr>
<td><span class="code">MutableSequence</span></td>
<td><span class="code">Sequence</span></td>
<td><span class="code">__delitem__</span><br/>
<span class="code">__getitem__</span><br/>
<span class="code">__len__</span><br/>
<span class="code">__setitem__</span><br/>
<span class="code">insert</span></td>
<td><span class="code">Sequence</span>’s methods, plus:<br/>
<span class="code">__iadd__</span><br/>
<span class="code">append</span><br/>
<span class="code">extend</span><a contenteditable="false" data-primary="extend method" data-secondary="MutableSequence" data-type="indexterm" id="idm44924577876000"/><br/>
<span class="code">pop</span><br/>
<span class="code">remove</span><br/>
<span class="code">reverse</span></td>
</tr>
<tr>
<td><span class="code">MutableSet</span></td>
<td><span class="code">Set</span></td>
<td><span class="code">__contains__</span><br/>
<span class="code">__iter</span><br/>
<span class="code">__len__</span><br/>
<span class="code">add</span><br/>
<span class="code">discard</span></td>
<td><span class="code">Set</span>’s methods, plus:<br/>
<span class="code">__iand__</span><br/>
<span class="code">__ior__</span><br/>
<span class="code">__isub__</span><br/>
<span class="code">__ixor__</span><br/>
<span class="code">clear</span><br/>
<span class="code">pop</span><br/>
<span class="code">remove</span></td>
</tr>
<tr>
<td><span class="code">ValuesView</span></td>
<td><span class="code">MappingView</span></td>
<td> </td>
<td><span class="code">__contains__</span><br/>
<span class="code">__iter__</span></td>
</tr>
</tbody>
</table>
<p>See the <a href="https://oreil.ly/AVoUU">online docs</a> for further details and usage examples.</p>
</div></section>
<section data-pdf-bookmark="ABCs in the numbers module" data-type="sect3"><div class="sect3" id="abcs_in_the_numbers_module">
<h3>ABCs in the numbers module</h3>
<p><span class="code">numbers</span> supplies<a contenteditable="false" data-primary="numbers module" data-type="indexterm" id="idm44924577850992"/><a contenteditable="false" data-primary="standard library modules" data-secondary="numbers" data-type="indexterm" id="idm44924577849856"/> a hierarchy (also known as a <em>tower</em>) of ABCs representing various kinds of numbers. <a data-type="xref" href="#abcs_supplied_by_the_numbers_module">Table 4-6</a> lists the ABCs in the <span class="code">numbers</span> module.</p>
<table class="border" id="abcs_supplied_by_the_numbers_module">
<caption><span class="label">Table 4-6. </span>ABCs supplied by the <span class="code">numbers</span> module</caption>
<thead>
<tr>
<th>ABC</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="code">Number</span></td>
<td>The root of the hierarchy. Includes numbers of <em>any</em> kind; need not support any given operation.</td>
</tr>
<tr>
<td><span class="code">Complex</span></td>
<td>Extends <span class="code">Number</span>. Must support (via special methods) conversions to <span class="code">complex</span> and <span class="code">bool</span>, <span class="code">+</span>, <span class="code">-</span>, <span class="code">*</span>, <span class="code">/</span>, <span class="code">==</span>, <span class="code">!=</span>, and <span class="code">abs</span>, and, directly, the method <span class="code">conjugate</span> and properties <span class="code">real</span> and <span class="code">imag</span>.</td>
</tr>
<tr>
<td><span class="code">Real</span></td>
<td>Extends <span class="code">Complex</span>.<sup><a data-type="noteref" href="ch04.xhtml#ch01fn64" id="ch01fn64-marker">a</a></sup> Additionally, must support (via special methods) conversion to <span class="code">float</span>, <span class="code">math.trunc</span>, <span class="code">round</span>, <span class="code">math.floor</span>, <span class="code">math.ceil</span>, <span class="code">divmod</span>, <span class="code">//</span>, <span class="code">%</span>, <span class="code">&lt;</span>, <span class="code">&lt;=</span>, <span class="code">&gt;</span>, and <span class="code">&gt;=</span>.</td>
</tr>
<tr>
<td><span class="code">Rational</span></td>
<td>Extends <span class="code">Real</span>. Additionally, must support the properties <span class="code">numerator</span> and <span class="code">denominator</span>.</td>
</tr>
<tr>
<td><span class="code">Integral</span></td>
<td>Extends <span class="code">Rational</span>.<sup><a data-type="noteref" href="ch04.xhtml#ch01fn65" id="ch01fn65-marker">b</a></sup> Additionally, must support (via special methods) conversion to <span class="code">int</span>, <span class="code">**</span>, and bitwise operations <span class="code">&lt;&lt;</span>, <span class="code">&gt;&gt;</span>, <span class="code">&amp;</span>, <span class="code">^</span>, <span class="code">|</span>, and <span class="code">~</span>.</td>
</tr>
</tbody>
<tbody><tr class="footnotes"><td colspan="2"><p data-type="footnote" id="ch01fn64"><sup><a href="ch04.xhtml#ch01fn64-marker">a</a></sup> So, every <span class="code">int</span> or <span class="code">float</span> has a property <span class="code">real</span> equal to its value, and a property <span class="code">imag</span> equal to <span class="code">0</span>.</p><p data-type="footnote" id="ch01fn65"><sup><a href="ch04.xhtml#ch01fn65-marker">b</a></sup> So, every <span class="code">int</span> has a property <span class="code">numerator</span> equal to its value, and a property <span class="code">denominator</span> equal to <span class="code">1</span>.</p></td></tr></tbody></table>
<p>See the <a href="https://oreil.ly/ViRw9">online docs</a> for notes on implementing your own numeric types.<a contenteditable="false" data-primary="" data-startref="abc04" data-type="indexterm" id="idm44924577796000"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Special Methods for Numeric Objects" data-type="sect2"><div class="sect2" id="special_methods_for_numeric_object">
<h2>Special Methods for Numeric Objects</h2>
<p>An<a contenteditable="false" data-primary="special methods" data-secondary="for numeric objects" data-secondary-sortas="numeric objects" data-type="indexterm" id="idm44924577792960"/><a contenteditable="false" data-primary="numeric objects, special methods for" data-type="indexterm" id="numobspec04"/> instance may support numeric operations by means of many special methods. Some classes that are not numbers also support some of the special methods in <a data-type="xref" href="#special_methods_for_numeric_objects">Table 4-7</a> in order to overload operators such as <span class="code">+</span> and <span class="code">*</span>. In particular, sequences should have special methods <span class="code">__add__</span>, <span class="code">__mul__</span>, <span class="code">__radd__</span>, and <span class="code">__rmul__</span>, as mentioned in <a data-type="xref" href="ch03.xhtml#sequence">“Sequences”</a>. When one of the binary methods (such as <span class="code">__add__</span>, <span class="code">__sub__</span>, etc.) is called with an operand of an unsupported type for that method, the method should return the<a contenteditable="false" data-primary="NotImplemented" data-type="indexterm" id="idm44924577781568"/> built-in singleton <span class="code">NotImplemented</span>.</p>
<table class="border" id="special_methods_for_numeric_objects">
<caption><span class="label">Table 4-7. </span>Special methods for numeric objects</caption>
<tbody>
<tr>
<td><span class="code">__abs__</span>,<br/>
<span class="code">__invert__</span>,<br/>
<span class="code">__neg__</span>,<br/>
<span class="code">__pos__</span></td>
<td><span class="code">__abs_(self)</span>, <a contenteditable="false" data-primary="__invert__ (numeric special method)" data-type="indexterm" id="idm44924577772160"/><span class="code"> __invert__(self)</span>, <span class="code"> __neg__(self)</span>, <span class="code"> __pos__(self)</span><br/>
			The<a contenteditable="false" data-primary="__abs__ (numeric special method)" data-type="indexterm" id="idm44924577768768"/><a contenteditable="false" data-primary="__pos__ (numeric special method)" data-type="indexterm" id="idm44924577767696"/><a contenteditable="false" data-primary="__neg__ (numeric special method)" data-type="indexterm" id="idm44924577766624"/> unary operators <span class="code">abs(<em>x</em>)</span>, <span class="code">~</span><span class="code"><em>x</em></span>, <span class="code">-</span><span class="code"><em>x</em></span>, and <span class="code">+</span><span class="code"><em>x</em></span>, respectively, call these methods.</td>
</tr>
<tr>
<td><span class="code">__add__</span>,<br/>
<span class="code">__mod__</span>,<br/>
<span class="code">__mul__</span>,<br/>
<span class="code">__sub__</span></td>
<td><span class="code">__add__ (self,</span> <span class="code"><em>other</em></span><span class="code">)</span>,<br/>
<span class="code">__mod__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>,<br/>
<span class="code">__mul__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>,<br/>
<span class="code">__sub__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span><br/>
			The<a contenteditable="false" data-primary="__add__ (numeric special method)" data-type="indexterm" id="idm44924577745472"/><a contenteditable="false" data-primary="__sub__ (numeric special method)" data-type="indexterm" id="idm44924577744400"/><a contenteditable="false" data-primary="__mul__ (numeric special method)" data-type="indexterm" id="idm44924577743280"/><a contenteditable="false" data-primary="__mod__ (numeric special method)" data-type="indexterm" id="idm44924577742160"/> operators <span class="code"><em>x +</em></span> <span class="code"><em>y</em></span>, <span class="code"><em>x %</em></span> <span class="code"><em>y</em></span>, <span class="code"><em>x *</em></span> <span class="code"><em>y</em></span>, and <span class="code"><em>x -</em></span> <span class="code"><em>y</em></span>, respectively, call these methods, usually for arithmetic computations.</td>
</tr>
<tr>
<td><span class="code">__and__</span>,<br/>
<span class="code">__lshift__</span>,<br/>
<span class="code">__or__</span>,<br/>
<span class="code">__rshift__</span>,<br/>
<span class="code">__xor__</span></td>
<td><span class="code">__and__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>,<span class="code"> __lshift__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>,<br/>
<span class="code">__or__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>,<span class="code"> __rshift_(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>,<br/>
<span class="code">__xor__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span><br/>
			The<a contenteditable="false" data-primary="__rshift__ (numeric special method)" data-type="indexterm" id="idm44924577717024"/><a contenteditable="false" data-primary="__and__ (numeric special method)" data-type="indexterm" id="idm44924577715952"/><a contenteditable="false" data-primary="__xor__ (numeric special method)" data-type="indexterm" id="idm44924577714880"/><a contenteditable="false" data-primary="__or__ (numeric special method)" data-type="indexterm" id="idm44924577713808"/><a contenteditable="false" data-primary="__lshift__ (numeric special method)" data-type="indexterm" id="idm44924577712688"/> operators <span class="code"><em>x &amp;</em></span> <span class="code"><em>y</em></span>, <span class="code"><em>x &lt;&lt;</em></span> <span class="code"><em>y</em></span>, <span class="code"><em>x |</em></span> <span class="code"><em>y</em></span>, <span class="code"><em>x &gt;&gt;</em></span> <span class="code"><em>y</em></span>, and <span class="code"><em>x ^</em></span> <span class="code"><em>y</em></span>, respectively, call these methods, usually for bitwise operations.</td>
</tr>
<tr>
<td><span class="code">__complex__</span>,<br/>
<span class="code">__float__</span>,<br/>
<span class="code">__int__</span></td>
<td><span class="code">__complex__(self)</span>, <span class="code"> __float__(self)</span>, <span class="code"> __int__(self)</span><br/>
			The<a contenteditable="false" data-primary="__int__ (numeric special method)" data-type="indexterm" id="idm44924577697552"/><a contenteditable="false" data-primary="__complex__ (numeric special method)" data-type="indexterm" id="idm44924577696480"/><a contenteditable="false" data-primary="__float__ (numeric special method)" data-type="indexterm" id="idm44924577695408"/> built-in types <span class="code">complex(<em>x</em>)</span>, <span class="code">float(<em>x</em>)</span>, and <span class="code">int(<em>x</em>)</span>, respectively, call these methods.</td>
</tr>
<tr>
<td><span class="code">__divmod__</span></td>
<td><span class="code">__divmod__(self, o<em>ther</em>)</span><br/>
			The<a contenteditable="false" data-primary="__divmod__ (numeric special method)" data-type="indexterm" id="idm44924577687504"/> built-in function <span class="code">divmod(<em>x, y</em>)</span> calls <span class="code"><em>x</em></span><span class="code">.__divmod__(<em>y</em>)</span>. <span class="code">__divmod__</span> should return a pair <span class="code">(<em>quotient, remainder</em>)</span> equal to <span class="code">(<em>x</em></span> <span class="code">//</span> <span class="code"><em>y, x</em></span> <span class="code">%</span> <span class="code"><em>y</em>)</span>.</td>
</tr>
<tr>
<td><span class="code">__floordiv__</span>,<br/>
<span class="code">__truediv__</span></td>
<td><span class="code">__floordiv__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>,<br/>
<span class="code">__truediv__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span><br/>
			The<a contenteditable="false" data-primary="__floordiv__ (numeric special method)" data-type="indexterm" id="idm44924577669760"/><a contenteditable="false" data-primary="__truediv__ (numeric special method)" data-type="indexterm" id="idm44924577668688"/> operators <span class="code"><em>x</em></span> <span class="code">//</span> <span class="code"><em>y</em></span> and <span class="code"><em>x</em></span> <span class="code">/</span> <span class="code"><em>y</em></span>, respectively, call these methods, usually for arithmetic division.</td>
</tr>
<tr>
<td><span class="code">__iadd__</span>,<br/>
<span class="code">__ifloordiv__</span>,<br/>
<span class="code">__imod__</span>,<br/>
<span class="code">__imul__</span>,<br/>
<span class="code">__isub__</span>,<br/>
<span class="code">__itruediv__</span>,<br/>
<span class="code">__imatmul__</span></td>
<td><span class="code">__iadd__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>,<br/>
<span class="code">__ifloordiv__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>,<br/>
<span class="code">__imod__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>,<br/>
<span class="code">__imul__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>,<br/>
<span class="code">__isub__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>,<br/>
<span class="code">__itruediv__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>,<br/>
<span class="code">__imatmul__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span><br/>
			The augmented assignments <span class="code"><em>x</em></span> <span class="code">+=</span> <span class="code"><em>y</em></span>, <span class="code"><em>x</em></span> <span class="code">//=</span> <span class="code"><em>y</em></span>, <span class="code"><em>x</em></span> <span class="code">%=</span> <span class="code"><em>y</em></span>, <span class="code"><em>x</em></span> <span class="code">*=</span> <span class="code"><em>y</em></span>, <span class="code"><em>x</em></span> <span class="code">-=</span> <span class="code"><em>y</em></span>, <span class="code"><em>x</em></span> <span class="code">/=</span> <span class="code"><em>y</em></span>, and <span class="code"><em>x</em></span> <span class="code">@=</span> <span class="code"><em>y</em></span>, respectively, call these methods. Each method should modify <span class="code"><em>x</em></span> in place and return <span class="code">self</span>. Define these methods when <span class="code"><em>x</em></span> is mutable (i.e., when <span class="code"><em>x</em></span> <em>can</em> change in place).</td>
</tr>
<tr>
<td><span class="code">__iand__</span>,<br/>
<span class="code">__ilshift__</span>,<br/>
<span class="code">__ior__</span>,<br/>
<span class="code">__irshift__</span>,<br/>
<span class="code">__ixor__</span></td>
<td><span class="code">__iand_(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>,<br/>
<span class="code">__ilshift_(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>,<br/>
<span class="code">__ior__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>,<br/>
<span class="code">__irshift__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>,<br/>
<span class="code">__ixor__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span><br/>
			The augmented assignments <span class="code"><em>x</em></span> <span class="code">&amp;=</span> <span class="code"><em>y</em></span>, <span class="code"><em>x</em></span> <span class="code">&lt;&lt;=</span> <span class="code"><em>y</em></span>, <span class="code"><em>x</em></span> <span class="code">\=</span> <span class="code"><em>y</em></span>, <span class="code"><em>x</em></span> <span class="code">&gt;&gt;=</span> <span class="code"><em>y</em></span>, and <span class="code"><em>x</em></span> <span class="code">^=</span> <span class="code"><em>y</em></span>, respectively, call these methods. Each method should modify <span class="code"><em>x</em></span> in place and return <span class="code">self</span>. Define these methods when <span class="code"><em>x</em></span> is mutable (i.e., when <span class="code"><em>x</em></span> <em>can</em> change in place).</td>
</tr>
<tr>
<td><span class="code">__index__</span></td>
<td><span class="code">__index__(self)</span><br/>
			Like<a contenteditable="false" data-primary="__index__ (numeric special method)" data-type="indexterm" id="idm44924577582096"/> <span class="code">__int__</span>, but meant to be supplied only by types that are alternative implementations of integers (in other words, all of the type’s instances can be exactly mapped into integers). For example, out of all the built-in types, only <span class="code">int</span> supplies <span class="code">__index__</span>; <span class="code">float</span> and <span class="code">str</span> don’t, although they do supply <span class="code">__int__</span>. Sequence indexing and slicing internally use <span class="code">__index__</span> to get the needed integer indices.</td>
</tr>
<tr>
<td><span class="code">__ipow__</span></td>
<td><span class="code">__ipow__(self,<em>other</em>)</span><br/>
			The augmented assignment <span class="code"><em>x</em></span> <span class="code">**=</span> <span class="code"><em>y</em></span> calls <span class="code"><em>x</em></span><span class="code">.__ipow__(<em>y</em>)</span>. <span class="code">__ipow__</span> should modify <span class="code"><em>x</em></span> in place and return <span class="code">self</span>.</td>
</tr>
<tr>
<td><span class="code">__matmul__</span></td>
<td><span class="code">__matmul__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span><br/>
			The<a contenteditable="false" data-primary="__matmul__ (numeric special method)" data-type="indexterm" id="idm44924577562464"/> operator <span class="code"><em>x</em></span> <span class="code">@</span> <span class="code"><em>y</em></span> calls this method, usually for matrix multiplication.</td>
</tr>
<tr>
<td><span class="code">__pow__</span></td>
<td><span class="code">__pow__(self,<em>other</em>[,</span> <span class="code"><em>modulo</em></span><span class="code">])</span><br/>
<span class="code"><em>x</em></span> <span class="code">**</span> <span class="code"><em>y</em></span> and <span class="code">pow(<em>x, y</em>)</span> both call <span class="code"><em>x</em></span><span class="code">.__pow__(<em>y</em>)</span>, while<a contenteditable="false" data-primary="__pow__ (numeric special method)" data-type="indexterm" id="idm44924577548816"/> <span class="code">pow(<em>x, y, z</em>)</span> calls <span class="code"><em>x</em></span><span class="code">.__pow__(<em>y</em>,</span> <span class="code"><em>z</em></span><span class="code">)</span>. <span class="code"><em>x</em></span><span class="code">.__pow__(<em>y, z</em>)</span> should return a value equal to the expression <span class="code"><em>x</em></span><span class="code">.__pow__(<em>y</em>) %</span> <span class="code"><em>z</em></span>.</td>
</tr>
<tr>
<td><span class="code">__radd__</span>,<br/>
<span class="code">__rmod__</span>,<br/>
<span class="code">__rmul__</span>,<br/>
<span class="code">__rsub__</span>,<br/>
<span class="code">__rmatmul__</span></td>
<td><span class="code">__radd__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>,<br/>
<span class="code">__rmod__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>,<br/>
<span class="code">__rmul__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>,<br/>
<span class="code">__rsub__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>,<br/>
<span class="code">__rmatmul__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span><br/>
			The operators <span class="code"><em>y</em></span> <span class="code">+</span> <span class="code"><em>x</em></span>, <span class="code"><em>y</em></span> <span class="code">/</span> <span class="code"><em>x</em></span>, <span class="code"><em>y</em></span> <span class="code">%</span> <span class="code"><em>x</em></span>, <span class="code"><em>y</em></span> <span class="code">*</span> <span class="code"><em>x</em></span>, <span class="code"><em>y - x</em></span>, and <span class="code"><em>y</em></span> <span class="code">@</span> <span class="code"><em>x</em></span>, respectively, call these methods on <span class="code"><em>x</em></span> when <span class="code"><em>y</em></span> doesn’t have the needed method <span class="code">__add__</span>, <span class="code">__truediv__</span>, and so on, or when that method returns<a contenteditable="false" data-primary="NotImplemented" data-type="indexterm" id="idm44924577504432"/> <span class="code">NotImplemented</span>.</td>
</tr>
<tr>
<td><span class="code">__rand__</span>,<br/>
<span class="code">__rlshift__</span>,<br/>
<span class="code">__ror__</span>,<br/>
<span class="code">__rrshift__</span>,<br/>
<span class="code">__rxor__</span></td>
<td><span class="code">__rand__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>,<br/>
<span class="code">__rlshift__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>,<br/>
<span class="code">__ror__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>,<br/>
<span class="code">__rrshift__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span>,<br/>
<span class="code">__rxor__(self,</span> <span class="code"><em>other</em></span><span class="code">)</span><br/>
			The operators <span class="code"><em>y</em></span> <span class="code">&amp;</span> <span class="code"><em>x</em></span>, <span class="code"><em>y</em></span> <span class="code">&lt;&lt;</span> <span class="code"><em>x</em></span>, <span class="code"><em>y</em></span> <span class="code">|</span> <span class="code"><em>x</em></span>, <span class="code"><em>y</em></span> <span class="code">&gt;&gt;</span> <span class="code"><em>x</em></span>, and <span class="code"><em>x</em></span> <span class="code">^</span> <span class="code"><em>y</em></span>, respectively, call these methods on <span class="code"><em>x</em></span> when <span class="code"><em>y</em></span> doesn’t have the needed method <span class="code">__and__</span>, <span class="code">__lshift__</span>, and so on, or when that method returns <span class="code">NotImplemented</span>.</td>
</tr>
<tr>
<td><span class="code">__rdivmod__</span></td>
<td><span class="code">__rdivmod_(self,</span> <span class="code"><em>other</em></span><span class="code">)</span><br/>
			The built-in function <span class="code">divmod(<em>y</em>,</span> <span class="code"><em>x</em></span><span class="code">)</span> calls <span class="code"><em>x</em></span><span class="code">.__rdivmod__(<em>y</em>)</span> when <span class="code"><em>y</em></span> doesn’t have <span class="code">__divmod__</span>, or when that method returns <span class="code">NotImplemented</span>. <span class="code">__rdivmod__</span> should return a pair <span class="code">(<em>remainder</em>,</span> <span class="code"><em>quotient</em></span><span class="code">)</span>.</td>
</tr>
<tr>
<td><span class="code">__rpow__</span></td>
<td><span class="code">__rpow__(self</span>,<span class="code"><em>other</em></span><span class="code">)</span><br/>
<span class="code"><em>y</em></span> <span class="code">**</span> <span class="code"><em>x</em></span> and <span class="code">pow(<em>y</em>,</span> <span class="code"><em>x</em></span><span class="code">)</span> call <span class="code"><em>x</em></span><span class="code">.__rpow__(<em>y</em>)</span> when <span class="code"><em>y</em></span> doesn’t have <span class="code">__pow__</span>, or when that method returns <span class="code">NotImplemented</span>. There is no three-argument form in this case.<a contenteditable="false" data-primary="" data-startref="spmeth04" data-type="indexterm" id="idm44924577442544"/><a contenteditable="false" data-primary="" data-startref="OOPspmeth04" data-type="indexterm" id="idm44924577441168"/><a contenteditable="false" data-primary="" data-startref="numobspec04" data-type="indexterm" id="idm44924577439792"/></td>
</tr>
</tbody>
</table>
</div></section>
</div></section>
<section data-pdf-bookmark="Decorators" data-type="sect1"><div class="sect1" id="decorators">
<h1>Decorators</h1>
<p>In<a contenteditable="false" data-primary="object-oriented Python" data-secondary="decorators" data-type="indexterm" id="OOPdecor04"/><a contenteditable="false" data-primary="decorators" data-type="indexterm" id="decor04"/><a contenteditable="false" data-primary="higher-order functions" data-type="indexterm" id="idm44924577432976"/><a contenteditable="false" data-primary="functions" data-secondary="higher-order functions" data-type="indexterm" id="idm44924577431872"/> Python, you often use <em>higher-order functions</em>: callables that accept a function as an argument and return a function as their result. For example, descriptor types such as <span class="code">staticmethod</span> and <span class="code">classmethod</span>, covered in <a data-type="xref" href="#class_level_methods">“Class-Level Methods”</a>, can be used, within class bodies, as follows:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">def</code></strong><code> </code><code class="nf">f</code><code class="p">(</code><code class="bp">cls</code><code class="p">,</code><code> </code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code class="p">)</code><code class="p">:</code><code>
</code><em><code>    </code><code class="c1"># ...definition of f snipped...</code></em><code>
</code><code class="n">f</code><code> </code><code class="o">=</code><code> </code><code class="nb">classmethod</code><code class="p">(</code><code class="n">f</code><code class="p">)</code></pre>
<p>However, having the call to <span class="code">classmethod</span> textually <em>after</em> the <span class="code"><strong>def</strong></span> statement hurts code readability: while reading <span class="code"><em>f</em></span>’s definition, the reader of the code is not yet aware that <span class="code"><em>f</em></span> is going to become a class method rather than an instance method. The<a contenteditable="false" data-primary="at sign (@)" data-secondary="decorators" data-type="indexterm" id="ASdec04"/><a contenteditable="false" data-primary="@ (commercial at sign)" data-secondary="decorators" data-type="indexterm" id="CASdecorat04"/> code is more readable if the mention of <span class="code">classmethod</span> comes <em>before</em> the <span class="code">def</span>. For this purpose, use the syntax form known as <em>decoration</em>:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="nd">@classmethod</code><code>
</code><strong><code class="k">def</code></strong><code> </code><code class="nf">f</code><code class="p">(</code><code class="bp">cls</code><code class="p">,</code><code> </code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code class="p">)</code><code class="p">:</code><code>
</code><em><code>    </code><code class="c1"># ...definition of f snipped...</code></em></pre>
<p>The decorator, here <span class="code">@classmethod</span>, must be immediately followed by a <span class="code"><strong>def</strong></span> statement and means that <span class="code"><em>f</em></span> <span class="code">=</span> <span class="code"><em>classmethod</em></span><span class="code">(<em>f</em>)</span> executes right after the <span class="code"><strong>def</strong></span> statement (for whatever name <span class="code"><em>f</em></span> the <span class="code"><strong>def</strong></span> defines). More generally, <span class="code">@<em>expression</em></span> evaluates the expression (which must be a name, possibly qualified, or a call) and binds the result to an internal temporary name (say, <span class="code"><em>__aux</em></span>); any decorator must be immediately followed by a <span class="code"><strong>def</strong></span> (or <span class="code"><strong>class</strong></span>) statement, and means that <span class="code"><em>f</em></span> <span class="code">= __</span><span class="code"><em>aux</em>(<em>f</em>)</span> executes right after the <span class="code"><strong>def</strong></span> or <span class="code"><strong>class</strong></span> statement (for whatever name <span class="code"><em>f</em></span> the <span class="code"><strong>def</strong></span> or <span class="code"><strong>class</strong></span> defines). The object bound to <span class="code">__</span><span class="code"><em>aux</em></span> is known as a <em>decorator</em>, and it’s said to <em>decorate</em> function or class <span class="code"><em>f</em></span>.</p>
<p>Decorators are a handy shorthand for some higher-order functions. You can apply decorators to any <span class="code"><strong>def</strong></span> or <span class="code"><strong>class</strong></span> statement, not just in class bodies. You may code custom decorators, which are just higher-order functions accepting a function or class object as an argument and returning a function or class object as the result. For example, here is a simple example decorator that does not modify the function it decorates, but rather prints the function’s docstring to standard output at function definition time:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">def</code></strong><code> </code><code class="nf">showdoc</code><code class="p">(</code><code class="n">f</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">if</code></strong><code> </code><code class="n">f</code><code class="o">.</code><code class="vm">__doc__</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="si">{</code><code class="n">f</code><code class="o">.</code><code class="vm">__name__</code><code class="si">}</code><code class="s1">: </code><code class="si">{</code><code class="n">f</code><code class="o">.</code><code class="vm">__doc__</code><code class="si">}</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>    </code><strong><code class="k">else</code></strong><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="si">{</code><code class="n">f</code><code class="o">.</code><code class="vm">__name__</code><code class="si">}</code><code class="s1">: No docstring!</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>    </code><strong><code class="k">return</code></strong><code> </code><code class="n">f</code><code>
</code><code>
</code><code class="nd">@showdoc</code><code>
</code><strong><code class="k">def</code></strong><code> </code><code class="nf">f1</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="sd">"""a docstring"""</code><code>  </code><em><code class="c1"># prints:</code></em><code class="c1"> </code><em><code class="c1">f1: a docstring</code></em><code>
</code><code>
</code><code class="nd">@showdoc</code><code>
</code><strong><code class="k">def</code></strong><code> </code><code class="nf">f2</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">pass</code><code>              </code></strong><code> </code><em><code class="c1"># prints:</code></em><code class="c1"> </code><em><code class="c1">f2: No docstring!</code></em></pre>
<p>The standard library module <span class="code">functools</span> offers a handy decorator, <span class="code">wraps</span>, to enhance decorators built by the common “wrapping” idiom:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="kn">import</code><code> </code><code class="nn">functools</code><code>
</code><code>
</code><strong><code class="k">def</code></strong><code> </code><code class="nf">announce</code><code class="p">(</code><code class="n">f</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="nd">@functools</code><code class="o">.</code><code class="n">wraps</code><code class="p">(</code><code class="n">f</code><code class="p">)</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">wrap</code><code class="p">(</code><code class="o">*</code><code class="n">a</code><code class="p">,</code><code> </code><code class="o">*</code><code class="o">*</code><code class="n">k</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="s1">Calling </code><code class="si">{</code><code class="n">f</code><code class="o">.</code><code class="vm">__name__</code><code class="si">}</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>        </code><strong><code class="k">return</code></strong><code> </code><code class="n">f</code><code class="p">(</code><code class="o">*</code><code class="n">a</code><code class="p">,</code><code> </code><code class="o">*</code><code class="o">*</code><code class="n">k</code><code class="p">)</code><code>
</code><code>    </code><strong><code class="k">return</code></strong><code> </code><code class="n">wrap</code></pre>
<p>Decorating a function <span class="code"><em>f</em></span> with <span class="code">@announce</span> causes a line announcing the call to be printed before each call to <span class="code"><em>f</em></span>. Thanks to the <span class="code">functools.wraps(<em>f</em>)</span> decorator, the wrapper adopts the name and docstring of the wrappee: this is useful, for example, when calling the built-in <span class="code">help</span> on such a decorated function.<a contenteditable="false" data-primary="" data-startref="decor04" data-type="indexterm" id="idm44924577151392"/><a contenteditable="false" data-primary="" data-startref="OOPdecor04" data-type="indexterm" id="idm44924577150016"/><a contenteditable="false" data-primary="" data-startref="CASdecorat04" data-type="indexterm" id="idm44924577148640"/><a contenteditable="false" data-primary="" data-startref="ASdec04" data-type="indexterm" id="idm44924577147264"/></p>
</div></section>
<section data-pdf-bookmark="Metaclasses" data-type="sect1"><div class="sect1" id="metaclasses">
<h1>Metaclasses</h1>
<p>Any <a contenteditable="false" data-primary="object-oriented Python" data-secondary="metaclasses" data-type="indexterm" id="OOPmeta04"/><a contenteditable="false" data-primary="metaclasses" data-type="indexterm" id="meta04"/>object, even a class object, has a type. In Python, types and classes are also first-class objects. The<a contenteditable="false" data-primary="metaclasses" data-secondary="definition of term" data-type="indexterm" id="idm44924577108528"/> type of a class object is also known as the class’s <em>metaclass</em>.<sup><a data-type="noteref" href="ch04.xhtml#ch01fn66" id="ch01fn66-marker">15</a></sup> An object’s behavior is mostly determined by the type of the object. This also holds for classes: a class’s behavior is mostly determined by the class’s metaclass. Metaclasses are an advanced subject, and you may want to skip the rest of this section. However, fully grasping metaclasses can lead you to a deeper understanding of Python; very occasionally, it can be useful to define your own custom metaclasses.</p>
<section data-pdf-bookmark="Alternatives to Custom Metaclasses for Simple Class Customization" data-type="sect2"><div class="sect2" id="alternatives_to_custom_metaclasses_for">
<h2>Alternatives to Custom Metaclasses for Simple Class Customization</h2>
<p>While<a contenteditable="false" data-primary="metaclasses" data-secondary="alternatives to" data-type="indexterm" id="idm44924577100640"/> a custom metaclass lets you tweak classes’ behaviors in pretty much any way you want, it’s often possible to achieve some customizations more simply than by coding a custom metaclass.</p>
<p>When a class <span class="code"><em>C</em></span> has or inherits a class method <span class="code">__init_subclass__</span>, Python calls that method whenever you subclass <span class="code"><em>C</em></span>, passing the newly built subclass as the only positional argument. <span class="code">__init_subclass__</span> can also have named parameters, in which case Python passes corresponding named arguments found in the class statement that performs the subclassing. As a purely illustrative example:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><strong><code class="k">class</code></strong><code> </code><code class="nc">C</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><strong><code class="k">def</code></strong><code> </code><code class="nf">__init_subclass__</code><code class="p">(</code><code class="bp">cls</code><code class="p">,</code><code> </code><code class="n">foo</code><code class="o">=</code><code class="kc">None</code><code class="p">,</code><code> </code><code class="o">*</code><code class="o">*</code><code class="n">kw</code><code class="p">)</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>         </code><code class="nb">print</code><code class="p">(</code><code class="bp">cls</code><code class="p">,</code><code> </code><code class="n">kw</code><code class="p">)</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>         </code><code class="bp">cls</code><code class="o">.</code><code class="n">say_foo</code><code> </code><code class="o">=</code><code> </code><code class="nb">staticmethod</code><code class="p">(</code><code class="k">lambda</code><code class="p">:</code><code> </code><code class="sa">f</code><code class="s1">'</code><code class="s1">*</code><code class="si">{</code><code class="n">foo</code><code class="si">}</code><code class="s1">*</code><code class="s1">'</code><code class="p">)</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>         </code><code class="nb">super</code><code class="p">(</code><code class="p">)</code><code class="o">.</code><code class="n">__init_subclass__</code><code class="p">(</code><code class="o">*</code><code class="o">*</code><code class="n">kw</code><code class="p">)</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code> </code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><strong><code class="k">class</code></strong><code> </code><code class="nc">D</code><code class="p">(</code><code class="n">C</code><code class="p">,</code><code> </code><code class="n">foo</code><code class="o">=</code><code class="s1">'</code><code class="s1">bar</code><code class="s1">'</code><code class="p">)</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><strong><code class="k">pass</code></strong><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code></pre>
<pre data-type="programlisting">
<strong>&lt;class '__main__.D'&gt; {}</strong></pre>
<pre data-code-language="python" data-type="programlisting">
<code class="o">&gt;&gt;&gt;</code> <code class="n">D</code><code class="o">.</code><code class="n">say_foo</code><code class="p">()</code></pre>
<pre data-type="programlisting">
<strong>'*bar*'</strong></pre>
<p>The code in <span class="code">__init_subclass__</span> can alter <span class="code">cls</span> in any applicable, post-class-creation way; essentially, it works like a class decorator that Python automatically applies to any subclass of <span class="code">C</span>.</p>
<p>Another special method used for customization is <span class="code">__set_name__</span>, which lets you ensure that instances of descriptors added as class attributes know what class you’re adding them to, and under which names. At the end of the <span class="code"><strong>class</strong></span> statement that adds <span class="code"><em>ca</em></span> to class <span class="code"><em>C</em></span> with name <span class="code"><em>n</em></span>, when the type of <span class="code"><em>ca</em></span> has the method <span class="code">__set_name__</span>, Python calls <span class="code"><em>ca.</em></span><span class="code">__set_name__(<em>C,</em></span> <span class="code"><em>n</em>)</span>. For example:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><strong><code class="k">class</code></strong><code> </code><code class="nc">Attrib</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><strong><code class="k">def</code></strong><code> </code><code class="nf">__set_name__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="bp">cls</code><code class="p">,</code><code> </code><code class="n">name</code><code class="p">)</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>         </code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="s1">Attribute </code><code class="si">{</code><code class="n">name</code><code class="si">!r}</code><code class="s1"> added to </code><code class="si">{</code><code class="bp">cls</code><code class="si">}</code><code class="s1">'</code><code class="p">)</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code> </code><code>
</code><code class="o">&gt;&gt;</code><code class="o">&gt;</code><code> </code><strong><code class="k">class</code></strong><code> </code><code class="nc">AClass</code><code class="p">:</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>     </code><code class="n">some_name</code><code> </code><code class="o">=</code><code> </code><code class="n">Attrib</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code></pre>
<pre data-type="programlisting">
<strong>Attribute 'some_name' added to &lt;class '__main__.AClass'&gt;</strong></pre>
<pre data-code-language="python" data-type="programlisting">
<code class="o">&gt;&gt;&gt;</code></pre>
</div></section>
<section data-pdf-bookmark="How Python Determines a Class’s Metaclass" data-type="sect2"><div class="sect2" id="how_python_determines_a_classapostrophe">
<h2>How Python Determines a Class’s Metaclass</h2>
<p>The <span class="code"><strong>class</strong></span> statement accepts optional named arguments (after the bases, if any). The most important named argument is <span class="code">metaclass</span>, which, if present, identifies the new class’s metaclass. Other named arguments are allowed only if a non-<span class="code">type</span> metaclass is present, in which case they are passed on to the optional <span class="code">__prepare__</span> method of the metaclass (it’s entirely up to the <span class="code">__prepare__</span> method to make use of such named arguments).<sup><a data-type="noteref" href="ch04.xhtml#ch01fn67" id="ch01fn67-marker">16</a></sup> When the named argument <span class="code">metaclass</span> is absent, Python determines the metaclass by inheritance; for classes with no explicitly specified bases, the metaclass defaults to <span class="code">type</span>.</p>
<p>Python calls the <span class="code">__prepare__</span> method, if present, as soon as it determines the metaclass, as follows:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">M</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__prepare__</code><code class="p">(</code><code class="n">classname</code><code class="p">,</code><code> </code><code class="o">*</code><code class="n">classbases</code><code class="p">,</code><code> </code><code class="o">*</code><code class="o">*</code><code class="n">kwargs</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><strong><code class="k">return</code></strong><code> </code><code class="p">{</code><code class="p">}</code><code>
</code><em><code>    </code><code class="c1"># ...rest of M snipped...</code></em><code>
</code><strong><code class="k">class</code></strong><code> </code><code class="nc">X</code><code class="p">(</code><code class="n">onebase</code><code class="p">,</code><code> </code><code class="n">another</code><code class="p">,</code><code> </code><code class="n">metaclass</code><code class="o">=</code><code class="n">M</code><code class="p">,</code><code> </code><code class="n">foo</code><code class="o">=</code><code class="s1">'</code><code class="s1">bar</code><code class="s1">'</code><code class="p">)</code><code class="p">:</code><code>
</code><em><code>    </code><code class="c1"># ...body of X snipped...</code></em></pre>
<p>Here, the call is equivalent to <span class="code">M.__prepare__('X'</span>, <span class="code">onebase</span>, <span class="code">another</span>, <span class="code">foo='bar'</span>). <span class="code">__prepare__</span>, if present, must return a mapping (usually just a dictionary), which Python uses as the <span class="code"><em>d</em></span> mapping in which it executes the class body. If <span class="code">__prepare__</span> is absent, Python uses a new, initially empty <span class="code">dict</span> as <span class="code"><em>d</em></span>.</p>
</div></section>
<section data-pdf-bookmark="How a Metaclass Creates a Class" data-type="sect2"><div class="sect2" id="how_a_metaclass_creates_a_class">
<h2>How a Metaclass Creates a Class</h2>
<p>Having<a contenteditable="false" data-primary="metaclasses" data-secondary="class creation by" data-type="indexterm" id="idm44924566702544"/> determined the metaclass <span class="code"><em>M</em></span>, Python calls <span class="code"><em>M</em></span> with three arguments: the class name (a <span class="code">str</span>), the tuple of base classes <span class="code"><em>t</em></span>, and the dictionary (or other mapping resulting from <span class="code">__prepare__</span>) <span class="code"><em>d</em></span> in which the class body just finished executing.<sup><a data-type="noteref" href="ch04.xhtml#ch01fn68" id="ch01fn68-marker">17</a></sup> The call returns the class object <span class="code"><em>C</em></span>, which Python then binds to the class name, completing the execution of the <span class="code"><strong>class</strong></span> statement. Note that this is in fact an instantiation of type <span class="code"><em>M</em></span>, so the call to <span class="code"><em>M</em></span> executes <span class="code"><em>M.</em></span><span class="code">__init__(<em>C</em>,</span> <span class="code"><em>namestring</em></span><span class="code">,</span> <span class="code"><em>t</em></span><span class="code">,</span> <span class="code"><em>d</em></span><span class="code">)</span>, where <span class="code"><em>C</em></span> is the return value of <span class="code"><em>M.</em></span><span class="code">__new__(<em>M, namestring, t, d</em>)</span>, just as in any other instantiation.</p>
<p>After Python creates the class object <span class="code"><em>C</em></span>, the relationship between class <span class="code"><em>C</em></span> and its type (<span class="code">type(<em>C</em>)</span>, normally <span class="code"><em>M</em></span>) is the same as that between any object and its type. For example, when you call the class object <span class="code"><em>C</em></span> (to create an instance of <span class="code"><em>C</em></span>), <span class="code"><em>M.</em></span><span class="code">__call__</span> executes, with class object <span class="code"><em>C</em></span> as the first argument.</p>
<p>Note the benefit, in this context, of the approach described in <a data-type="xref" href="#per_instance_methods">“Per Instance Methods”</a>, whereby special methods are looked up only on the class, not on the instance. Calling <span class="code"><em>C</em></span> to instantiate it must execute the metaclass’s <span class="code"><em>M.</em></span><span class="code">__call__</span>, whether or not <span class="code"><em>C</em></span> has a per instance attribute (method) <span class="code">__call__</span> (i.e., independently of whether <em>instances</em> of <span class="code"><em>C</em></span> are or aren’t callable). This way, the Python object model avoids having to make the relationship between a class and its metaclass an ad hoc special case. Avoiding ad hoc special cases is a key to Python’s power: Python has few, simple, general rules, and applies them consistently.</p>
<section data-pdf-bookmark="Defining and using your own metaclasses" data-type="sect3"><div class="sect3" id="defining_and_using_your_own_metaclasses">
<h3>Defining and using your own metaclasses</h3>
<p>It’s<a contenteditable="false" data-primary="metaclasses" data-secondary="defining and using your own" data-type="indexterm" id="idm44924566634704"/> easy to define custom metaclasses: inherit from <span class="code">type</span> and override some of its methods. You can also perform most of the tasks for which you might consider creating a metaclass with <span class="code">__new__</span>, <span class="code">__init__</span>, <span class="code">__getattribute__</span>, and so on, without involving metaclasses. However, a custom metaclass can be faster, since special processing is done only at class creation time, which is a rare operation. A custom metaclass lets you define a whole category of classes in a framework that magically acquire whatever interesting behavior you’ve coded, quite independently of what special methods the classes themselves may choose to define.</p>
<p>To alter a specific class in an explicit way, a good alternative is often to use a class decorator, as mentioned in <a data-type="xref" href="#decorators">“Decorators”</a>. However, decorators are not inherited, so the decorator must be explicitly applied to each class of interest.<sup><a data-type="noteref" href="ch04.xhtml#ch01fn69" id="ch01fn69-marker">18</a></sup> Metaclasses, on the other hand, <em>are</em> inherited; in fact, when you define a custom metaclass <span class="code"><em>M</em></span>, it’s usual to also define an otherwise empty class <span class="code"><em>C</em></span> with metaclass <span class="code"><em>M</em></span>, so that other classes requiring <span class="code"><em>M</em></span> can just inherit from <span class="code"><em>C</em></span>.</p>
<p>Some behavior of class objects can be customized only in metaclasses. The following example shows how to use a metaclass to change the string format of class objects:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">MyMeta</code><code class="p">(</code><code class="nb">type</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__str__</code><code class="p">(</code><code class="bp">cls</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><strong><code class="k">return</code></strong><code> </code><code class="sa">f</code><code class="s1">'</code><code class="s1">Beautiful class </code><code class="si">{</code><code class="bp">cls</code><code class="o">.</code><code class="vm">__name__</code><code class="si">!r}</code><code class="s1">'</code><code>
</code><strong><code class="k">class</code></strong><code> </code><code class="nc">MyClass</code><code class="p">(</code><code class="n">metaclass</code><code class="o">=</code><code class="n">MyMeta</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">pass</code></strong><code>
</code><code class="n">x</code><code> </code><code class="o">=</code><code> </code><code class="n">MyClass</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="nb">print</code><code class="p">(</code><code class="nb">type</code><code class="p">(</code><code class="n">x</code><code class="p">)</code><code class="p">)</code><code>      </code><em><code class="c1"># prints:</code></em><code class="c1"> </code><em><code class="c1">Beautiful class 'MyClass'</code></em></pre>
</div></section>
<section data-pdf-bookmark="A substantial custom metaclass example" data-type="sect3"><div class="sect3" id="a_substantial_custom_metaclass_example">
<h3>A substantial custom metaclass example</h3>
<p>Suppose<a contenteditable="false" data-primary="metaclasses" data-secondary="custom metaclass example" data-type="indexterm" id="idm44924566558640"/> that, programming in Python, we miss C’s <span class="code">struct</span> type: an object that is just a bunch of data attributes, in order, with fixed names (data classes, covered in the following section, fully address this requirement, which makes this example a purely illustrative one). Python lets us easily define a generic <span class="code">Bunch</span> class that is similar, apart from the fixed order and names:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">Bunch</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="o">*</code><code class="o">*</code><code class="n">fields</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="bp">self</code><code class="o">.</code><code class="vm">__dict__</code><code> </code><code class="o">=</code><code> </code><code class="n">fields</code><code>
</code><code class="n">p</code><code> </code><code class="o">=</code><code> </code><code class="n">Bunch</code><code class="p">(</code><code class="n">x</code><code class="o">=</code><code class="mf">2.3</code><code class="p">,</code><code> </code><code class="n">y</code><code class="o">=</code><code class="mf">4.5</code><code class="p">)</code><code>
</code><code class="nb">print</code><code class="p">(</code><code class="n">p</code><code class="p">)</code><code>       </code><em><code class="c1"># prints:</code></em><code class="c1"> </code><em><code class="c1">&lt;_main__.Bunch object at 0x00AE8B10&gt;</code></em></pre>
<p>A custom metaclass can exploit the fact that attribute names are fixed at class creation time. The code shown in <a data-type="xref" href="#example_four_onedot_the_metabunch_metac">Example 4-1</a> defines a metaclass, <span class="code">MetaBunch</span>, and a class, <span class="code">Bunch</span>, to let us write code like:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">class</code></strong><code> </code><code class="nc">Point</code><code class="p">(</code><code class="n">Bunch</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><em><code class="sd">"""A Point has x and y coordinates, defaulting to 0.0,</code></em><code class="sd">
       </code><em><code class="sd">and a color, defaulting to 'gray'-and nothing more,</code></em><code class="sd">
       </code><em><code class="sd">except what Python and the metaclass conspire to add,</code></em><code class="sd">
       </code><em><code class="sd">such as __init__ and __repr__.</code></em><code class="sd">
    </code><em><code class="sd">"""</code></em><code>
</code><code>    </code><code class="n">x</code><code> </code><code class="o">=</code><code> </code><code class="mf">0.0</code><code>
</code><code>    </code><code class="n">y</code><code> </code><code class="o">=</code><code> </code><code class="mf">0.0</code><code>
</code><code>    </code><code class="n">color</code><code> </code><code class="o">=</code><code> </code><code class="s1">'</code><code class="s1">gray</code><code class="s1">'</code><code>
</code><em><code class="c1"># example uses of class Point</code></em><code>
</code><code class="n">q</code><code> </code><code class="o">=</code><code> </code><code class="n">Point</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="nb">print</code><code class="p">(</code><code class="n">q</code><code class="p">)</code><code>                    </code><em><code class="c1"># prints:</code></em><code class="c1"> </code><em><code class="c1">Point()</code></em><code>
</code><code class="n">p</code><code> </code><code class="o">=</code><code> </code><code class="n">Point</code><code class="p">(</code><code class="n">x</code><code class="o">=</code><code class="mf">1.2</code><code class="p">,</code><code> </code><code class="n">y</code><code class="o">=</code><code class="mf">3.4</code><code class="p">)</code><code>
</code><code class="nb">print</code><code class="p">(</code><code class="n">p</code><code class="p">)</code><code>                    </code><em><code class="c1"># prints:</code></em><code class="c1"> </code><em><code class="c1">Point(x=1.2, y=3.4)</code></em></pre>
<p>In this code, the <span class="code">print</span> calls emit readable string representations of our <span class="code">Point</span> instances. <span class="code">Point</span> instances are quite memory lean, and their performance is basically the same as for instances of the simple class <span class="code">Bunch</span> in the previous example (there is no extra overhead due to implicit calls to special methods). <a data-type="xref" href="#example_four_onedot_the_metabunch_metac">Example 4-1</a> is quite substantial, and following all its details requires a grasp of aspects of Python discussed later in this book, such as strings (covered in <a data-type="xref" href="ch09.xhtml#strings_and_things">Chapter 9</a>) and module warnings (covered in <a data-type="xref" href="ch17.xhtml#the_warnings_module">“The warnings Module”</a>). The identifier <span class="code">mcl</span> used in <a data-type="xref" href="#example_four_onedot_the_metabunch_metac">Example 4-1</a> stands for “metaclass,” clearer in this special advanced case than the habitual case of <span class="code">cls</span> standing for “class.”</p>
<div data-type="example" id="example_four_onedot_the_metabunch_metac">
<h5><span class="label">Example 4-1. </span>The <span class="code">MetaBunch</span> metaclass</h5>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">warnings</code><code>
</code><strong><code class="k">class</code></strong><code> </code><code class="nc">MetaBunch</code><code class="p">(</code><code class="nb">type</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><em><code class="sd">"""</code></em><code class="sd">
    </code><em><code class="sd">Metaclass for new and improved "Bunch": implicitly defines</code></em><code class="sd">
    </code><em><code class="sd">__slots__, __init__, and __repr__ from variables bound in</code></em><code class="sd">
    </code><em><code class="sd">class scope.</code></em><code class="sd">
    </code><em><code class="sd">A class statement for an instance of MetaBunch (i.e., for a</code></em><code class="sd">
    </code><em><code class="sd">class whose metaclass is MetaBunch) must define only</code></em><code class="sd">
    </code><em><code class="sd">class-scope data attributes (and possibly special methods, but</code></em><code class="sd">
    </code><em><code class="sd">NOT __init__ and __repr__). MetaBunch removes the data</code></em><code class="sd">
    </code><em><code class="sd">attributes from class scope, snuggles them instead as items in</code></em><code class="sd">
    </code><em><code class="sd">a class-scope dict named __dflts__, and puts in the class a</code></em><code class="sd">
    </code><em><code class="sd">__slots__ with those attributes' names, an __init__ that takes</code></em><code class="sd">
    </code><em><code class="sd">as optional named arguments each of them (using the values in</code></em><code class="sd">
    </code><em><code class="sd">__dflts__ as defaults for missing ones), and a __repr__ that</code></em><code class="sd">
    </code><em><code class="sd">shows the repr of each attribute that differs from its default</code></em><code class="sd">
    </code><em><code class="sd">value (the output of __repr__ can be passed to __eval__ to make</code></em><code class="sd">
    </code><em><code class="sd">an equal instance, as per usual convention in the matter, if</code></em><code class="sd">
    </code><em><code class="sd">each non-default-valued attribute respects that convention too).</code></em><code class="sd">
    </code><em><code class="sd">The order of data attributes remains the same as in the</code></em><code class="sd"> </code><em><code class="sd">class body.</code></em><code class="sd">
    </code><em><code class="sd">"""</code></em><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__new__</code><code class="p">(</code><code class="n">mcl</code><code class="p">,</code><code> </code><code class="n">classname</code><code class="p">,</code><code> </code><code class="n">bases</code><code class="p">,</code><code> </code><code class="n">classdict</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><em><code class="sd">"""Everything needs to be done in __new__, since</code></em><code class="sd">
           </code><em><code class="sd">type.__new__ is where __slots__ are taken into account.</code></em><code class="sd">
        </code><em><code class="sd">"""</code></em><code>
</code><code>        </code><em><code class="c1"># Define as local functions the __init__ and __repr__ that</code></em><code>
</code><code>        </code><em><code class="c1"># we'll use in the new class</code></em><code>
</code><code>        </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="o">*</code><code class="o">*</code><code class="n">kw</code><code class="p">)</code><code class="p">:</code><code>
</code><code>            </code><em><code class="sd">"""__init__ is simple: first, set attributes without</code></em><code class="sd">
</code><em><code class="sd">               explicit values to their defaults; then, set</code></em><code class="sd"> </code><em><code class="sd">those</code></em><code class="sd">
</code><em><code class="sd">               explicitly</code></em><code class="sd"> </code><em><code class="sd">passed in kw.</code></em><code class="sd">
            </code><em><code class="sd">"""</code></em><code>
</code><code>            </code><strong><code class="k">for</code></strong><code> </code><code class="n">k</code><code> </code><strong><code class="ow">in</code></strong><code> </code><code class="bp">self</code><code class="o">.</code><code class="n">__dflts__</code><code class="p">:</code><code>
</code><code>                </code><strong><code class="k">if</code></strong><code> </code><strong><code class="ow">not</code></strong><code> </code><code class="n">k</code><code> </code><strong><code class="ow">in</code></strong><code> </code><code class="n">kw</code><code class="p">:</code><code>
</code><code>                    </code><code class="nb">setattr</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">k</code><code class="p">,</code><code> </code><code class="bp">self</code><code class="o">.</code><code class="n">__dflts__</code><code class="p">[</code><code class="n">k</code><code class="p">]</code><code class="p">)</code><code>
</code><code>            </code><strong><code class="k">for</code></strong><code> </code><code class="n">k</code><code> </code><strong><code class="ow">in</code></strong><code> </code><code class="n">kw</code><code class="p">:</code><code>
</code><code>                </code><code class="nb">setattr</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">k</code><code class="p">,</code><code> </code><code class="n">kw</code><code class="p">[</code><code class="n">k</code><code class="p">]</code><code class="p">)</code><code>
</code><code>        </code><strong><code class="k">def</code></strong><code> </code><code class="fm">__repr__</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>            </code><em><code class="sd">"""__repr__ is minimal: shows only attributes that</code></em><code class="sd">
               </code><em><code class="sd">differ</code></em><code class="sd"> </code><em><code class="sd">from default values, for compactness.</code></em><code class="sd">
            </code><em><code class="sd">"""</code></em><code>
</code><code>            </code><code class="n">rep</code><code> </code><code class="o">=</code><code> </code><code class="p">[</code><code class="sa">f</code><code class="s1">'</code><code class="si">{</code><code class="n">k</code><code class="si">}</code><code class="s1">=</code><code class="si">{</code><code class="nb">getattr</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">k</code><code class="p">)</code><code class="si">!r}</code><code class="s1">'</code><code>
</code><code>                    </code><strong><code class="k">for</code></strong><code> </code><code class="n">k</code><code> </code><strong><code class="ow">in</code></strong><code> </code><code class="bp">self</code><code class="o">.</code><code class="n">__dflts__</code><code>
</code><code>                    </code><strong><code class="k">if</code></strong><code> </code><code class="nb">getattr</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">k</code><code class="p">)</code><code> </code><code class="o">!=</code><code> </code><code class="bp">self</code><code class="o">.</code><code class="n">__dflts__</code><code class="p">[</code><code class="n">k</code><code class="p">]</code><code>
</code><code>                  </code><code class="p">]</code><code>
</code><code>            </code><strong><code class="k">return</code></strong><code> </code><code class="sa">f</code><code class="s1">'</code><code class="si">{</code><code class="n">classname</code><code class="si">}</code><code class="s1">(</code><code class="si">{</code><code class="s1">'</code><code class="s1">, </code><code class="s1">'</code><code class="o">.</code><code class="n">join</code><code class="p">(</code><code class="n">rep</code><code class="p">)</code><code class="si">}</code><code class="s1">)</code><code class="s1">'</code><code>
</code><code>        </code><em><code class="c1"># Build the newdict that we'll use as class dict for the</code></em><code>
</code><code>        </code><em><code class="c1"># new class</code></em><code>
</code><code>        </code><code class="n">newdict</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code class="s1">'</code><code class="s1">__slots__</code><code class="s1">'</code><code class="p">:</code><code> </code><code class="p">[</code><code class="p">]</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">__dflts__</code><code class="s1">'</code><code class="p">:</code><code> </code><code class="p">{</code><code class="p">}</code><code class="p">,</code><code>
</code><code>                   </code><code class="s1">'</code><code class="s1">__init__</code><code class="s1">'</code><code class="p">:</code><code> </code><code class="fm">__init__</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">__repr__</code><code class="s1">'</code><code> </code><code class="p">:</code><code class="fm">__repr__</code><code class="p">,</code><code class="p">}</code><code>
</code><code>        </code><strong><code class="k">for</code></strong><code> </code><code class="n">k</code><code> </code><strong><code class="ow">in</code></strong><code> </code><code class="n">classdict</code><code class="p">:</code><code>
</code><code>            </code><strong><code class="k">if</code></strong><code> </code><code class="n">k</code><code class="o">.</code><code class="n">startswith</code><code class="p">(</code><code class="s1">'</code><code class="s1">__</code><code class="s1">'</code><code class="p">)</code><code> </code><strong><code class="ow">and</code></strong><code> </code><code class="n">k</code><code class="o">.</code><code class="n">endswith</code><code class="p">(</code><code class="s1">'</code><code class="s1">__</code><code class="s1">'</code><code class="p">)</code><code class="p">:</code><code>
</code><code>                </code><em><code class="c1"># Dunder methods: copy to newdict, or warn</code></em><code>
</code><code>                </code><em><code class="c1"># about conflicts</code></em><code>
</code><code>                </code><strong><code class="k">if</code></strong><code> </code><code class="n">k</code><code> </code><strong><code class="ow">in</code></strong><code> </code><code class="n">newdict</code><code class="p">:</code><code>
</code><code>                    </code><code class="n">warnings</code><code class="o">.</code><code class="n">warn</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="s1">Cannot set attr </code><code class="si">{</code><code class="n">k</code><code class="si">!r}</code><code class="s1">'</code><code>
</code><code>                                  </code><code class="sa">f</code><code class="s1">'</code><code class="s1"> in bunch-class </code><code class="si">{</code><code class="n">classname</code><code class="si">!r}</code><code class="s1">'</code><code class="p">)</code><code>
</code><strong><code>               </code></strong><code> </code><strong><code class="k">else</code></strong><strong><code class="p">:</code></strong><code>
</code><code>                    </code><code class="n">newdict</code><code class="p">[</code><code class="n">k</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="n">classdict</code><code class="p">[</code><code class="n">k</code><code class="p">]</code><code>
</code><strong><code>           </code></strong><code> </code><strong><code class="k">else</code></strong><strong><code class="p">:</code></strong><code>
</code><code>                </code><em><code class="c1"># Class variables: store name in __slots__, and</code></em><code>
</code><code>                </code><em><code class="c1"># name and value as an item in __dflts__</code></em><code>
</code><code>                </code><code class="n">newdict</code><code class="p">[</code><code class="s1">'</code><code class="s1">__slots__</code><code class="s1">'</code><code class="p">]</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">k</code><code class="p">)</code><code>
</code><code>                </code><code class="n">newdict</code><code class="p">[</code><code class="s1">'</code><code class="s1">__dflts__</code><code class="s1">'</code><code class="p">]</code><code class="p">[</code><code class="n">k</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="n">classdict</code><code class="p">[</code><code class="n">k</code><code class="p">]</code><code>
</code><code>        </code><em><code class="c1"># Finally, delegate the rest of the work to type.__new__</code></em><code>
</code><code>        </code><strong><code class="k">return</code></strong><code> </code><code class="nb">super</code><code class="p">(</code><code class="p">)</code><code class="o">.</code><code class="fm">__new__</code><code class="p">(</code><code class="n">mcl</code><code class="p">,</code><code> </code><code class="n">classname</code><code class="p">,</code><code> </code><code class="n">bases</code><code class="p">,</code><code> </code><code class="n">newdict</code><code class="p">)</code><code>
</code><code>
</code><strong><code class="k">class</code></strong><code> </code><code class="nc">Bunch</code><code class="p">(</code><code class="n">metaclass</code><code class="o">=</code><code class="n">MetaBunch</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><em><code class="sd">"""For convenience: inheriting from Bunch can be used to get</code></em><code class="sd">
       </code><em><code class="sd">the new metaclass (same as defining metaclass= yourself).</code></em><code class="sd">
    </code><em><code class="sd">"""</code></em><code>
</code><strong><code>   </code></strong><code> </code><strong><code class="k">pass</code></strong></pre>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="Data Classes" data-type="sect2"><div class="sect2" id="data_classes">
<h2>Data Classes</h2>
<p>As<a contenteditable="false" data-primary="standard library modules" data-secondary="data classes" data-type="indexterm" id="idm44924565900816"/><a contenteditable="false" data-primary="metaclasses" data-secondary="data classes" data-type="indexterm" id="idm44924565899600"/><a contenteditable="false" data-primary="dataclasses module" data-type="indexterm" id="idm44924565898384"/> the previous <span class="code">Bunch</span> class exemplified, a class whose instances are just a bunch of named data items is a great convenience. Python’s standard library covers that with the <span class="code">dataclasses</span> module.</p>
<p>The main feature of the <span class="code">dataclasses</span> module you’ll be using is the <span class="code">dataclass</span> function: a decorator you apply to any class whose instances you want to be just such a bunch of named data items. As a typical example, consider the following code:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">dataclasses</code><code>
</code><strong><code class="nd">@</code></strong><code class="nd">dataclasses</code><code class="o">.</code><code class="n">dataclass</code><code>
</code><strong><code class="k">class</code></strong><code> </code><code class="nc">Point</code><code class="p">:</code><code>
</code><code>    </code><code class="n">x</code><code class="p">:</code><code> </code><code class="nb">float</code><code>
</code><code>    </code><code class="n">y</code><code class="p">:</code><code> </code><code class="nb">float</code></pre>
<p>Now you can call, say, <span class="code">pt = Point(0.5, 0.5)</span> and get a variable with attributes <span class="code">pt.x</span> and <span class="code">pt.y</span>, each equal to <span class="code">0.5</span>. By default, the <span class="code">dataclass</span> decorator has imbued the class <span class="code">Point</span> with an <span class="code">__init__</span> method accepting initial floating-point values for attributes <span class="code">x</span> and <span class="code">y</span>, and a <span class="code">__repr__</span> method ready to appropriately display any instance of the class:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="o">&gt;&gt;&gt;</code> <code class="n">pt</code></pre>
<pre data-type="programlisting">
<strong>Point(x=0.5, y=0.5)</strong></pre>
<p>The <span class="code">dataclass</span> function takes many optional named parameters to let you tweak details of the class it decorates. The parameters you may be explicitly using most often are listed in <a data-type="xref" href="#commonly_used_parameters_of_the_datacla">Table 4-8</a>.</p>
<table class="border" id="commonly_used_parameters_of_the_datacla">
<caption><span class="label">Table 4-8. </span>Commonly used <span class="code">dataclass</span> function parameters</caption>
<thead>
<tr>
<th>Parameter name</th>
<th>Default value and resulting behavior</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="code">eq</span></td>
<td><span class="code"><strong>True</strong></span><br/>
			When <span class="code"><strong>True</strong></span>, generates an <span class="code">__eq__</span> method (unless the class defines one)</td>
</tr>
<tr>
<td><span class="code">frozen</span></td>
<td><span class="code"><strong>False</strong></span><br/>
			When <span class="code"><strong>True</strong></span>, makes each instance of the class read-only (not allowing rebinding or deletion of attributes)</td>
</tr>
<tr>
<td><span class="code">init</span></td>
<td><span class="code"><strong>True</strong></span><br/>
			When <span class="code"><strong>True</strong></span>, generates an <span class="code">__init__</span> method (unless the class defines one)</td>
</tr>
<tr>
<td><span class="code">kw_only</span></td>
<td><span class="code"><strong>False</strong></span><br/>
<span class="version">3.10+</span> When <span class="code"><strong>True</strong></span>, forces arguments to <span class="code">__init__</span> to be named, not positional</td>
</tr>
<tr>
<td><span class="code">order</span></td>
<td><span class="code"><strong>False</strong></span><br/>
			When <span class="code"><strong>True</strong></span>, generates order-comparison special methods (<span class="code">__le__</span>, <span class="code">__lt__</span>, and so on) unless the class defines them</td>
</tr>
<tr>
<td><span class="code">repr</span></td>
<td><span class="code"><strong>True</strong></span><br/>
			When <span class="code"><strong>True</strong></span>, generates a <span class="code">__repr__</span> method (unless the class defines one)</td>
</tr>
<tr>
<td><span class="code">slots</span></td>
<td><span class="code"><strong>False</strong></span><br/>
<span class="version">3.10+</span> When <span class="code"><strong>True</strong></span>, adds the appropriate <span class="code">__slots__</span> attribute to the class (saving some amount of memory for each instance, but disallowing the addition of other, arbitrary attributes to class instances)</td>
</tr>
</tbody>
</table>
<p>The decorator also adds to the class a <span class="code">__hash__</span> method (allowing instances to be keys in a dictionary and members of a set) when that is safe (typically, when you set <span class="code">frozen</span> to <span class="code"><strong>True</strong></span>). You may force the addition of <span class="code">__hash__</span> even when that’s not necessarily safe, but we earnestly recommend that you don’t; if you insist, check the <a href="https://oreil.ly/rOJTW">online docs</a> for details on how to do so.</p>
<p>If you need to tweak each instance of a <span class="code">dataclass</span> after the automatically generated <span class="code">__init__</span> method has done the core work of assigning each instance attribute, define a method called <span class="code">__post_init__</span>, and the decorator will ensure it is called right after <span class="code">__init__</span> is done.</p>
<p>Say you wish to add an attribute to <span class="code">Point</span> to capture the time when the point was created. This could be added as an attribute assigned in <span class="code">__post_init__</span>. Add the attribute <span class="code">create_time</span> to the members defined for <span class="code">Point</span>, as type <span class="code">float</span> with a default value of <span class="code">0</span>, and then add an implementation for <span class="code">__post_init__</span>:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">def</code></strong><code> </code><code class="nf">__post_init__</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="bp">self</code><code class="o">.</code><code class="n">create_time</code><code> </code><code class="o">=</code><code> </code><code class="n">time</code><code class="o">.</code><code class="n">time</code><code class="p">(</code><code class="p">)</code></pre>
<p>Now if you create the variable <span class="code">pt = Point(0.5, 0.5)</span>, printing it out will display the creation timestamp, similar to the following:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="o">&gt;&gt;&gt;</code> <code class="n">pt</code></pre>
<pre data-type="programlisting">
<strong>Point(x=0.5, y=0.5, create_time=1645122864.3553088)</strong></pre>
<p>Like regular classes, <span class="code">dataclass</span>es can also support additional methods and properties, such as this method that computes the distance between two <span class="code">Point</span>s and this property that returns the distance from a <span class="code">Point</span> at the origin:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">def</code></strong><code> </code><code class="nf">distance_from</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code><code> </code><code class="n">other</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">dx</code><code class="p">,</code><code> </code><code class="n">dy</code><code> </code><code class="o">=</code><code> </code><code class="bp">self</code><code class="o">.</code><code class="n">x</code><code> </code><code class="o">-</code><code> </code><code class="n">other</code><code class="o">.</code><code class="n">x</code><code class="p">,</code><code> </code><code class="bp">self</code><code class="o">.</code><code class="n">y</code><code> </code><code class="o">-</code><code> </code><code class="n">other</code><code class="o">.</code><code class="n">y</code><code>
</code><code>    </code><strong><code class="k">return</code></strong><code> </code><code class="n">math</code><code class="o">.</code><code class="n">hypot</code><code class="p">(</code><code class="n">dx</code><code class="p">,</code><code> </code><code class="n">dy</code><code class="p">)</code><code>
</code><code>
</code><code class="nd">@property</code><code>
</code><strong><code class="k">def</code></strong><code> </code><code class="nf">distance_from_origin</code><code class="p">(</code><code class="bp">self</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">return</code></strong><code> </code><code class="bp">self</code><code class="o">.</code><code class="n">distance_from</code><code class="p">(</code><code class="n">Point</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code> </code><code class="mi">0</code><code class="p">)</code><code class="p">)</code></pre>
<p>For example:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="o">&gt;&gt;&gt;</code> <code class="n">pt</code><code class="o">.</code><code class="n">distance_from</code><code class="p">(</code><code class="n">Point</code><code class="p">(</code><code class="o">-</code><code class="mi">1</code><code class="p">,</code> <code class="o">-</code><code class="mi">1</code><code class="p">))</code></pre>
<pre data-type="programlisting">
<strong>2.1213203435596424</strong></pre>
<pre data-code-language="python" data-type="programlisting">
<code class="o">&gt;&gt;&gt;</code> <code class="n">pt</code><code class="o">.</code><code class="n">distance_from_origin</code></pre>
<pre data-type="programlisting">
<strong>0.7071067811865476</strong></pre>
<p>The <span class="code">dataclasses</span> module also supplies <span class="code">asdict</span> and <span class="code">astuple</span> functions, each taking a <span class="code">dataclass</span> instance as the first argument and returning, respectively, a <span class="code">dict</span> and a <span class="code">tuple</span> with the class’s fields. Furthermore, the module supplies a <span class="code">field</span> function that you may use to customize the treatment of some of a <span class="code">dataclass</span>’s fields (i.e., instance attributes), and several other specialized functions and classes needed only for very advanced, esoteric purposes; to learn all about them, check out the <a href="https://oreil.ly/rOJTW">online docs</a>.</p>
</div></section>
<section data-pdf-bookmark="Enumerated Types (Enums)" data-type="sect2"><div class="sect2" id="enumerated_types_left_parenthesisenumsr">
<h2>Enumerated Types (Enums)</h2>
<p>When<a contenteditable="false" data-primary="enumerated types (enums)" data-type="indexterm" id="enum04"/> programming, you’ll often want to create a set of related values that catalog or <em>enumerate</em> the possible values for a particular property or program setting,<sup><a data-type="noteref" href="ch04.xhtml#ch01fn70" id="ch01fn70-marker">19</a></sup> whatever they might be: terminal colors, logging levels, process states, playing card suits, clothing sizes, or just about anything else you can think of. An <em>enumerated type</em> (<em>enum</em>) is a type that defines a group of such values, with symbolic names that you can use as typed global constants. Python provides the <span class="code">Enum</span> class and related subclasses in the<a contenteditable="false" data-primary="enum module" data-type="indexterm" id="idm44924565488144"/><a contenteditable="false" data-primary="standard library modules" data-secondary="enum" data-type="indexterm" id="idm44924565487040"/> <span class="code">enum</span> module for defining enums.</p>
<p>Defining an enum gives your code a set of symbolic constants that represent the values in the enumeration. In the absence of enums, constants might be defined as <span class="code">int</span>s, as in this code:</p>
<pre data-code-language="python" data-type="programlisting">
<em><code class="c1"># colors</code></em><code>
</code><code class="n">RED</code><code> </code><code class="o">=</code><code> </code><code class="mi">1</code><code>
</code><code class="n">GREEN</code><code> </code><code class="o">=</code><code> </code><code class="mi">2</code><code>
</code><code class="n">BLUE</code><code> </code><code class="o">=</code><code> </code><code class="mi">3</code><code>
</code><code>
</code><em><code class="c1"># sizes</code></em><code>
</code><code class="n">XS</code><code> </code><code class="o">=</code><code> </code><code class="mi">1</code><code>
</code><code class="n">S</code><code> </code><code class="o">=</code><code> </code><code class="mi">2</code><code>
</code><code class="n">M</code><code> </code><code class="o">=</code><code> </code><code class="mi">3</code><code>
</code><code class="n">L</code><code> </code><code class="o">=</code><code> </code><code class="mi">4</code><code>
</code><code class="n">XL</code><code> </code><code class="o">=</code><code> </code><code class="mi">5</code></pre>
<p>However, in this design, there is no mechanism to warn against nonsense expressions like <span class="code">RED &gt; XL</span> or <span class="code">L * BLUE</span>, since they are all just <span class="code">int</span>s. There is also no logical grouping of the colors or sizes.</p>
<p>Instead, you can use an <span class="code">Enum</span> subclass to define these values:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">from</code></strong><code> </code><code class="nn">enum</code><code> </code><strong><code class="kn">import</code></strong><code> </code><code class="n">Enum</code><code class="p">,</code><code> </code><code class="n">auto</code><code>
</code><code>
</code><strong><code class="k">class</code></strong><code> </code><code class="nc">Color</code><code class="p">(</code><code class="n">Enum</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">RED</code><code> </code><code class="o">=</code><code> </code><code class="mi">1</code><code>
</code><code>    </code><code class="n">GREEN</code><code> </code><code class="o">=</code><code> </code><code class="mi">2</code><code>
</code><code>    </code><code class="n">BLUE</code><code> </code><code class="o">=</code><code> </code><code class="mi">3</code><code>
</code><code>    </code><code>
</code><strong><code class="k">class</code></strong><code> </code><code class="nc">Size</code><code class="p">(</code><code class="n">Enum</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">XS</code><code> </code><code class="o">=</code><code> </code><code class="n">auto</code><code class="p">(</code><code class="p">)</code><code>
</code><code>    </code><code class="n">S</code><code> </code><code class="o">=</code><code> </code><code class="n">auto</code><code class="p">(</code><code class="p">)</code><code>
</code><code>    </code><code class="n">M</code><code> </code><code class="o">=</code><code> </code><code class="n">auto</code><code class="p">(</code><code class="p">)</code><code>
</code><code>    </code><code class="n">L</code><code> </code><code class="o">=</code><code> </code><code class="n">auto</code><code class="p">(</code><code class="p">)</code><code>
</code><code>    </code><code class="n">XL</code><code> </code><code class="o">=</code><code> </code><code class="n">auto</code><code class="p">(</code><code class="p">)</code></pre>
<p>Now, code like <span class="code">Color.RED &gt; Size.S</span> stands out visually as incorrect, and at runtime raises a Python <span class="code">TypeError</span>. Using <span class="code">auto()</span> automatically assigns incrementing <span class="code">int</span> values beginning with <span class="code">1</span> (in most cases, the actual values assigned to enum members are not meaningful).</p>
<div data-type="note" epub:type="note">
<h1>Calling Enum Creates a Class, Not an Instance</h1>
<p>Surprisingly, when you call <span class="code">enum.Enum()</span>, it doesn’t return a newly built <em>instance</em>, but rather a newly built <em>subclass</em>. So, the preceding snippet is equivalent to:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">from</code></strong><code> </code><code class="nn">enum</code><code> </code><strong><code class="kn">import</code></strong><code> </code><code class="n">Enum</code><code>
</code><code class="n">Color</code><code> </code><code class="o">=</code><code> </code><code class="n">Enum</code><code class="p">(</code><code class="s1">'</code><code class="s1">Color</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="p">(</code><code class="s1">'</code><code class="s1">RED</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">GREEN</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">BLUE</code><code class="s1">'</code><code class="p">)</code><code class="p">)</code><code>
</code><code class="n">Size</code><code> </code><code class="o">=</code><code> </code><code class="n">Enum</code><code class="p">(</code><code class="s1">'</code><code class="s1">Size</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">XS S M L XL</code><code class="s1">'</code><code class="p">)</code></pre>
<p>When you <em>call</em> <span class="code">Enum</span> (rather than explicitly subclassing it in a class statement), the first argument is the name of the subclass you’re building; the second argument gives all the names of that subclass’s members, either as a sequence of strings or as a single whitespace-separated (or comma-separated) string.</p>
<p>We recommend that you define <span class="code">Enum</span> subclasses using class inheritance syntax, instead of this abbreviated form. The <span class="code"><strong>class</strong></span> form is more visually explicit, so it is easier to see if a member is missing, misspelled, or added later.</p>
</div>
<p>The values within an enum are called its <em>members</em>. It is conventional to use all uppercase characters to name enum members, treating them much as though they were manifest constants. Typical uses of the members of an enum are assignment and identity checking:</p>
<pre class="pagebreak-before" data-code-language="python" data-type="programlisting">
<strong><code class="k">while</code></strong><code> </code><code class="n">process_state</code><code> </code><strong><code class="ow">is</code></strong><code> </code><code class="n">ProcessState</code><code class="o">.</code><code class="n">RUNNING</code><code class="p">:</code><code>
</code><em><code>    </code><code class="c1"># running process code goes here</code></em><code>
</code><code>    </code><strong><code class="k">if</code></strong><code> </code><code class="n">processing_completed</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="n">process_state</code><code> </code><code class="o">=</code><code> </code><code class="n">ProcessState</code><code class="o">.</code><code class="n">IDLE</code></pre>
<p>You can obtain all members of an <span class="code">Enum</span> by iterating over the <span class="code">Enum</span> class itself, or from the class’s <span class="code">__members__</span> attribute. <span class="code">Enum</span> members are all global singletons, so comparison<a contenteditable="false" data-primary="is keyword" data-type="indexterm" id="idm44924594427888"/> with <span class="code"><strong>is</strong></span> and<a contenteditable="false" data-primary="not" data-type="indexterm" id="idm44924594425776"/> <span class="code"><strong>is not</strong></span> is preferred over <span class="code">==</span> or <span class="code">!=</span>.</p>
<p>The <span class="code">enum</span> module contains several classes<sup><a data-type="noteref" href="ch04.xhtml#ch01fn71" id="ch01fn71-marker">20</a></sup> to support different forms of enums, listed in <a data-type="xref" href="#enum_classes">Table 4-9</a>.</p>
<table class="border" id="enum_classes">
<caption><span class="label">Table 4-9. </span><span class="code">enum</span> classes</caption>
<thead>
<tr>
<th>Class</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="code">Enum</span></td>
<td>Basic enumeration class; member values can be any Python object, typically <span class="code">int</span>s or <span class="code">str</span>s, but do not support <span class="code">int</span> or <span class="code">str</span> methods. Useful for defining enumerated types whose members are an unordered group.</td>
</tr>
<tr>
<td><span class="code">Flag</span></td>
<td>Used to define enums that you can combine with operators <span class="code">|</span>, <span class="code">&amp;</span>, <span class="code">^</span>, and <span class="code">~</span>; member values must be defined as <span class="code">int</span>s to support these bitwise operations (Python, however, assumes no ordering among them). <span class="code">Flag</span> members with a <span class="code">0</span> value are falsy; other members are truthy. Useful when you create or check values with bitwise operations (e.g., file permissions). To support bitwise operations, you generally use powers of 2 (1, 2, 4, 8, etc.) as member values.</td>
</tr>
<tr>
<td><span class="code">IntEnum</span></td>
<td>Equivalent to <span class="code"><strong>class</strong></span> <span class="code">IntEnum(<em>int</em>,</span> <span class="code"><em>Enum</em></span><span class="code">)</span>; member values are <span class="code">int</span>s and support all <span class="code">int</span> operations, including ordering. Useful when order among values is significant, such as when defining logging levels.</td>
</tr>
<tr>
<td><span class="code">IntFlag</span></td>
<td>Equivalent to <span class="code"><strong>class</strong></span> <span class="code">IntFlag(<em>int</em>,</span> <span class="code"><em>Flag</em></span><span class="code">)</span>; member values are <span class="code">int</span>s (usually, powers of 2) supporting all <span class="code">int</span> operations, including comparisons.</td>
</tr>
<tr>
<td><span class="code">StrEnum</span></td>
<td><span class="version">3.11+</span> Equivalent to <span class="code"><strong>class</strong></span> <span class="code">StrEnum(<em>str</em>,</span> <span class="code"><em>Enum</em></span><span class="code">)</span>; member values are <span class="code">str</span>s and support all <span class="code">str</span> operations.</td>
</tr>
</tbody>
</table>
<p>The <span class="code">enum</span> module also defines some support functions, listed in <a data-type="xref" href="#enum_support_functions">Table 4-10</a>.</p>
<table class="border" id="enum_support_functions">
<caption><span class="label">Table 4-10. </span><span class="code">enum</span> support functions</caption>
<thead>
<tr>
<th>Support function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="code">auto</span></td>
<td>Autoincrements member values as you define them. Values typically start at <span class="code">1</span> and increment by 1; for <span class="code">Flag</span>, increments are in powers of 2.</td>
</tr>
<tr>
<td><span class="code">unique</span></td>
<td>Class decorator to ensure that members’ values differ from each other.</td>
</tr>
</tbody>
</table>
<p>The following example shows how to define a <span class="code">Flag</span> subclass to work with the file permissions in the <span class="code">st_mode</span> attribute returned from calling <span class="code">os.stat</span> or <span class="code">Path.stat</span> (for a description of the <span class="code">stat</span> functions, see <a data-type="xref" href="ch11.xhtml#file_and_text_operations">Chapter 11</a>):</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">enum</code><code>
</code><strong><code class="kn">import</code></strong><code> </code><code class="nn">stat</code><code>
</code><code>
</code><strong><code class="k">class</code></strong><code> </code><code class="nc">Permission</code><code class="p">(</code><code class="n">enum</code><code class="o">.</code><code class="n">Flag</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">EXEC_OTH</code><code> </code><code class="o">=</code><code> </code><code class="n">stat</code><code class="o">.</code><code class="n">S_IXOTH</code><code>
</code><code>    </code><code class="n">WRITE_OTH</code><code> </code><code class="o">=</code><code> </code><code class="n">stat</code><code class="o">.</code><code class="n">S_IWOTH</code><code>
</code><code>    </code><code class="n">READ_OTH</code><code> </code><code class="o">=</code><code> </code><code class="n">stat</code><code class="o">.</code><code class="n">S_IROTH</code><code>
</code><code>    </code><code class="n">EXEC_GRP</code><code> </code><code class="o">=</code><code> </code><code class="n">stat</code><code class="o">.</code><code class="n">S_IXGRP</code><code>
</code><code>    </code><code class="n">WRITE_GRP</code><code> </code><code class="o">=</code><code> </code><code class="n">stat</code><code class="o">.</code><code class="n">S_IWGRP</code><code>
</code><code>    </code><code class="n">READ_GRP</code><code> </code><code class="o">=</code><code> </code><code class="n">stat</code><code class="o">.</code><code class="n">S_IRGRP</code><code>
</code><code>    </code><code class="n">EXEC_USR</code><code> </code><code class="o">=</code><code> </code><code class="n">stat</code><code class="o">.</code><code class="n">S_IXUSR</code><code>
</code><code>    </code><code class="n">WRITE_USR</code><code> </code><code class="o">=</code><code> </code><code class="n">stat</code><code class="o">.</code><code class="n">S_IWUSR</code><code>
</code><code>    </code><code class="n">READ_USR</code><code> </code><code class="o">=</code><code> </code><code class="n">stat</code><code class="o">.</code><code class="n">S_IRUSR</code><code>
</code><code>
</code><code>    </code><code class="nd">@classmethod</code><code>
</code><code>    </code><strong><code class="k">def</code></strong><code> </code><code class="nf">from_stat</code><code class="p">(</code><code class="bp">cls</code><code class="p">,</code><code> </code><code class="n">stat_result</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><strong><code class="k">return</code></strong><code> </code><code class="bp">cls</code><code class="p">(</code><code class="n">stat_result</code><code class="o">.</code><code class="n">st_mode</code><code> </code><code class="o">&amp;</code><code> </code><code class="mo">0o777</code><code class="p">)</code><code>
</code><code>
</code><strong><code class="kn">from</code></strong><code> </code><code class="nn">pathlib</code><code> </code><strong><code class="kn">import</code></strong><code> </code><code class="n">Path</code><code>
</code><code>
</code><code class="n">cur_dir</code><code> </code><code class="o">=</code><code> </code><code class="n">Path</code><code class="o">.</code><code class="n">cwd</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="n">dir_perm</code><code> </code><code class="o">=</code><code> </code><code class="n">Permission</code><code class="o">.</code><code class="n">from_stat</code><code class="p">(</code><code class="n">cur_dir</code><code class="o">.</code><code class="n">stat</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>
</code><strong><code class="k">if</code></strong><code> </code><code class="n">dir_perm</code><code> </code><code class="o">&amp;</code><code> </code><code class="n">Permission</code><code class="o">.</code><code class="n">READ_OTH</code><code class="p">:</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="si">{</code><code class="n">cur_dir</code><code class="si">}</code><code class="s1"> is readable by users outside the owner group</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>
</code><em><code class="c1"># the following raises TypeError: Flag enums do not support order</code></em><code class="c1"> </code><code>
</code><em><code class="c1"># comparisons</code></em><code>
</code><code class="nb">print</code><code class="p">(</code><code class="n">Permission</code><code class="o">.</code><code class="n">READ_USR</code><code> </code><code class="o">&gt;</code><code> </code><code class="n">Permission</code><code class="o">.</code><code class="n">READ_OTH</code><code class="p">)</code></pre>
<p>Using enums in place of arbitrary <span class="code">int</span>s or <span class="code">str</span>s can add readability and type integrity to your code. You can find more details on the classes and methods of the <span class="code">enum</span> module in the Python <a href="https://oreil.ly/d57vE">docs</a>.<a contenteditable="false" data-primary="" data-startref="meta04" data-type="indexterm" id="idm44924594152352"/><a contenteditable="false" data-primary="" data-startref="OOPmeta04" data-type="indexterm" id="idm44924594150944"/><a contenteditable="false" data-primary="" data-startref="enum04" data-type="indexterm" id="idm44924594174768"/></p>
</div></section>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="ch01fn48"><sup><a href="ch04.xhtml#ch01fn48-marker">1</a></sup> Or “drawbacks,” according to one reviewer. One developer’s meat is another developer’s poison.</p><p data-type="footnote" id="ch01fn49"><sup><a href="ch04.xhtml#ch01fn49-marker">2</a></sup> When that’s the case, it’s also OK to have other named arguments after <span class="code">metaclass=</span>. Such arguments, if any, are passed on to the metaclass.</p><p data-type="footnote" id="ch01fn50"><sup><a href="ch04.xhtml#ch01fn50-marker">3</a></sup> That need arises because <span class="code">__</span><span class="code">init</span><span class="code">__</span>, on any subclass of <span class="code">Singleton</span> that defines this special method, repeatedly executes, each time you instantiate the subclass, on the only instance that exists for each subclass of <span class="code">Singleton</span>.</p><p data-type="footnote" id="ch01fn51"><sup><a href="ch04.xhtml#ch01fn51-marker">4</a></sup> Except for instances of a class defining <span class="code">__slots__</span>, covered in <a data-type="xref" href="#slots_">“__slots__”</a>.</p><p data-type="footnote" id="ch01fn52"><sup><a href="ch04.xhtml#ch01fn52-marker">5</a></sup> Some other OO languages, like <a href="https://en.wikipedia.org/wiki/Modula-3">Modula-3</a>, similarly require explicit use of <span class="code">self</span>.</p><p data-type="footnote" id="ch01fn53"><sup><a href="ch04.xhtml#ch01fn53-marker">6</a></sup> Many Python releases later, Michele’s essay still applies!</p><p data-type="footnote" id="ch01fn54"><sup><a href="ch04.xhtml#ch01fn54-marker">7</a></sup> One of the authors has used this technique to dynamically combine small mixin test classes to create complex test case classes to test multiple independent product features.</p><p data-type="footnote" id="ch01fn55"><sup><a href="ch04.xhtml#ch01fn55-marker">8</a></sup> To complete the usually truncated famous quote: “except of course for the problem of too many indirections.”</p><p data-type="footnote" id="ch01fn56"><sup><a href="ch04.xhtml#ch01fn56-marker">9</a></sup> Third-party extensions can also define types of containers that are not sequences, not mappings, and not sets.</p><p data-type="footnote" id="ch01fn57"><sup><a href="ch04.xhtml#ch01fn57-marker">10</a></sup> Lower bound included, upper bound excluded—as always, the norm for Python.</p><p data-type="footnote" id="ch01fn58"><sup><a href="ch04.xhtml#ch01fn58-marker">11</a></sup> See, for example, <a href="https://oreil.ly/5B4nm">“Avoid Extending Classes”</a> by Bill Harlan.</p><p data-type="footnote" id="ch01fn59"><sup><a href="ch04.xhtml#ch01fn59-marker">12</a></sup> For a related concept focused on type checking, see <span class="code">typing.Protocols</span>, covered in <a data-type="xref" href="ch05.xhtml#protocols">“Protocols”</a>.</p><p data-type="footnote" id="ch01fn60"><sup><a href="ch04.xhtml#ch01fn60-marker">13</a></sup> The <span class="code">abc</span> module does include the <span class="code">abstractproperty</span> decorator, which combines these two, but <span class="code">abstractproperty</span> is deprecated, and new code should use the two decorators as described.</p><p data-type="footnote" id="ch01fn61"><sup><a href="ch04.xhtml#ch01fn61-marker">14</a></sup> For backward compatibility these ABCs were also accessible in the <span class="code">collections</span> module until Python 3.9, but the compatibility imports were removed in Python 3.10. New code should import these ABCs from <span class="code">collections.abc</span>.</p><p data-type="footnote" id="ch01fn66"><sup><a href="ch04.xhtml#ch01fn66-marker">15</a></sup> Strictly speaking, the type of a class <em><span class="code">C</span></em> could be said to be the metaclass only of <em>instances</em> of <span class="code"><em>C</em></span> rather than of <span class="code"><em>C</em></span> itself, but this subtle semantic distinction is rarely, if ever, observed in practice.</p><p data-type="footnote" id="ch01fn67"><sup><a href="ch04.xhtml#ch01fn67-marker">16</a></sup> Or when a base class has <span class="code">__init_subclass__</span>, in which case the named arguments are passed to that method, as covered in <a data-type="xref" href="#alternatives_to_custom_metaclasses_for">“Alternatives to Custom Metaclasses for Simple Class Customization”</a>.</p><p data-type="footnote" id="ch01fn68"><sup><a href="ch04.xhtml#ch01fn68-marker">17</a></sup> This is similar to calling <span class="code">type</span> with three arguments, as described in <a data-type="xref" href="#dynamic_class_definition_using_the_type">“Dynamic class definition using the type built-in function”</a>.</p><p data-type="footnote" id="ch01fn69"><sup><a href="ch04.xhtml#ch01fn69-marker">18</a></sup> <span class="code">__init_subclass__</span>, covered in <a data-type="xref" href="#alternatives_to_custom_metaclasses_for">“Alternatives to Custom Metaclasses for Simple Class Customization”</a>, works much like an “inherited decorator,” so it’s often an alternative to a custom metaclass.</p><p data-type="footnote" id="ch01fn70"><sup><a href="ch04.xhtml#ch01fn70-marker">19</a></sup> Don’t confuse this concept with the unrelated <span class="code">enumerate</span> built-in function, covered in <a data-type="xref" href="ch08.xhtml#core_built_ins_and_standard_library_mod">Chapter 8</a>, which generates <span class="code">(<em>number</em>,</span> <span class="code"><em>item</em></span><span class="code">)</span> pairs from an iterable.</p><p data-type="footnote" id="ch01fn71"><sup><a href="ch04.xhtml#ch01fn71-marker">20</a></sup> <span class="code">enum</span>’s specialized metaclass behaves so differently from the usual <span class="code">type</span> metaclass that it’s worth pointing out all the differences between <span class="code">enum.Enum</span> and ordinary classes. You can read about this in the <a href="https://oreil.ly/xpp5N">“How are Enums different?” section</a> of Python’s online <span class="keep-together">documentation</span>.</p></div></div></section></div></body></html>