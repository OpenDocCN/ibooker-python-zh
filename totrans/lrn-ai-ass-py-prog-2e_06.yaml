- en: 7 Problem decomposition
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 问题分解
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章内容涵盖
- en: Understanding problem decomposition and why we need to do it
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解问题分解以及我们为什么需要这样做
- en: Using top-down design to carry out problem decomposition and write programs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自顶向下设计来进行问题分解并编写程序
- en: Writing a spelling suggestions program using top-down design
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自顶向下设计编写拼写建议程序
- en: In chapter 3, we talked about why we shouldn’t ask Copilot to solve big problems.
    Imagine what could happen if we asked Copilot to “Design a two-player strategy
    game.”
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，我们讨论了为什么不应该让Copilot解决大问题。试想一下，如果我们让Copilot“设计一个双人策略游戏”，会发生什么情况。
- en: In the worst case, Copilot wouldn’t do anything useful. We observe this sometimes
    when Copilot gives us comments again and again but never provides us with real
    code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在最坏的情况下，Copilot可能什么有用的事都做不了。我们有时会看到这种情况，Copilot反复给我们评论，却从不提供真正的代码。
- en: In the best case, we’d get a canned program with all the decisions made for
    us. That program may not match what we wanted. Part of the power of being a programmer
    is customizing what we’re creating. Even if we didn’t want to customize anything,
    what would we do if the program from Copilot had flaws? It would be difficult
    for us to fix a large program that we don’t understand.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在最佳情况下，我们会得到一个现成的程序，所有决策都已经为我们做出。这个程序可能与我们想要的并不完全匹配。作为程序员的一个强大之处在于定制我们所创建的内容。即使我们不想定制任何东西，如果Copilot给出的程序有缺陷，我们该怎么办呢？如果程序来自Copilot并且我们不理解它，修复一个大程序将会非常困难。
- en: For us to get a program that does what we want, we need to feed small subproblems
    to Copilot and assemble those solutions into our own program. The focus of this
    chapter is learning how to break large problems into smaller subproblems, which
    is essential to being able to solve the large problems we want to solve.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们得到一个符合要求的程序，我们需要将小的子问题交给Copilot，并将这些解决方案组合成我们自己的程序。本章的重点是学习如何将大问题分解成更小的子问题，这对于解决我们想解决的大问题至关重要。
- en: 7.1 Problem decomposition
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 问题分解
- en: Problem decomposition involves starting with a large problem that may not be
    fully specified and breaking it down into subproblems, each of which is well-defined
    and useful for solving our overall problem. Our goal is then to write a function
    to solve each of those subproblems. We may be able to do this for some subproblems
    with a reasonable amount of code, but other subproblems may still be too big for
    us to capture in a function of reasonable size. (In chapter 3, we mentioned that
    we want to keep functions short—something like 12–20 lines—to give us the best
    chance of getting good code from Copilot, testing that code, and fixing bugs in
    that code if necessary.) If a subproblem is still too large to be implemented
    in a single function, then we further divide that subproblem into sub-subproblems
    of their own. Hopefully, each of those sub-subproblems will be small enough now,
    but if not, we’ll continue dividing those too! The key reason we do this is to
    manage complexity. Each function should be simple enough so that we can understand
    its purpose and so that Copilot can solve it well. If something does go wrong,
    we won’t have too much code to trawl through to find the problem. When we write
    code that is extremely complex, we’re likely to make mistakes. The same goes for
    Copilot! And, when we have mistakes in long, complex code, they aren’t easy to
    find and fix. It’s hard to overstate the importance of problem decomposition for
    quality code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 问题分解包括从一个可能没有完全指定的大问题开始，并将其分解为子问题，每个子问题都被明确定义并有助于解决我们的整体问题。我们的目标是为每个子问题编写一个函数来解决。对于某些子问题，我们可能能够通过适量的代码来解决，但其他子问题可能仍然太大，无法在合理大小的函数中捕获。（在第3章中，我们提到我们希望保持函数简短——大约12到20行——这样才能有最佳的机会从Copilot获得优质的代码，测试这些代码，并在必要时修复代码中的错误。）如果某个子问题仍然太大，无法在一个函数中实现，那么我们会进一步将该子问题分解成自己的子子问题。希望这些子子问题现在已经足够小，但如果没有，我们会继续分解它们！我们这么做的关键原因是为了管理复杂性。每个函数应该足够简单，以便我们能理解它的目的，并且Copilot能够很好地解决它。如果出现问题，我们也不会有太多的代码需要翻找来找到问题。当我们编写极其复杂的代码时，我们很可能会犯错误。Copilot也是如此！而且，当我们在冗长复杂的代码中出现错误时，问题并不容易找到和修复。问题分解对于高质量代码的重要性无法过分强调。
- en: The process of starting with a large problem and breaking it down is called
    *problem decomposition*. The way we’re doing this here is synonymous with the
    software engineering technique known as *top-down design*. It’s called top-down
    design because we’re starting with the large task we want to complete and breaking
    it down into smaller tasks. Once we’ve completed the top-down design, we can implement
    the resulting functions in code. We’ll have one function for our overall problem,
    which will call the functions for each of our subproblems. Each of those subproblem
    functions will further call their own functions, as needed, to solve any of their
    sub-subproblems, and so on.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个大问题开始，并将其分解成更小的任务的过程叫做*问题分解*。我们在这里采用的这种方式与软件工程技术中的*自顶向下设计*是同义的。之所以称之为自顶向下设计，是因为我们从想要完成的大任务开始，然后将其分解为更小的任务。完成自顶向下设计后，我们可以在代码中实现这些函数。我们将有一个针对整体问题的函数，它将调用针对每个子问题的函数。每个子问题函数会根据需要进一步调用它们自己的函数，以解决任何子子问题，依此类推。
- en: As we discussed in chapter 3, we’re looking to end up with functions that each
    have a small role to play in our overall program and whose behavior is clearly
    defined. We need those functions so that we can call them to reduce the complexity
    of functions that would otherwise be too complex. To improve clarity and ease
    of understanding, we seek to design functions that have a small number of parameters
    and return a small amount of highly useful information.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第三章中讨论的那样，我们希望最终得到的函数在我们的整体程序中扮演一个小角色，并且其行为是明确定义的。我们需要这些函数，以便可以调用它们来减少本来会过于复杂的函数的复杂性。为了提高清晰度和易理解性，我们寻求设计具有少量参数并返回少量高效有用信息的函数。
- en: 7.2 Small examples of top-down design
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 自顶向下设计的小示例
- en: 'We’ll soon jump into a more authentic example of how top-down design works,
    but we’d first like to set the stage using a couple of our earlier examples. Let’s
    think about the design of a function we previously wrote in chapter 3: `get_strong_password`.
    It repeatedly prompts the user for a password until they enter a strong password.
    Don’t go back and look at that code—we want to start fresh here.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会深入探讨一个更真实的自顶向下设计如何工作的例子，但我们首先想用我们之前的一些例子来铺垫。让我们回顾一下我们在第三章中写的一个函数的设计：`get_strong_password`。这个函数会反复提示用户输入密码，直到他们输入一个强密码为止。不要去回头看那段代码——我们希望从头开始。
- en: Suppose that we want to use a top-down design to solve this task. If it were
    one small, well-defined task, we could implement it directly as a single function.
    However, for this task, we do see a subtask; namely, what’s a strong password?
    What are the rules around that? To us, this sounds like a subtask that we can
    try to carve out of this function to make it simpler. Indeed, in chapter 3, when
    we wrote this function, we did call our earlier `is_strong_password` function,
    which makes the True/False decision about what it means for a password to be strong.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想用自顶向下设计来解决这个任务。如果这是一个小而明确的任务，我们可以直接实现为一个单一的函数。然而，对于这个任务，我们确实看到有一个子任务；即，什么是强密码？关于强密码有什么规则？对我们来说，这听起来像是一个可以从这个函数中拆分出来的子任务，从而简化它。事实上，在第三章当我们写这个函数时，我们确实调用了我们之前写的`is_strong_password`函数，该函数负责判断一个密码是否强大。
- en: We can depict this top-down design as shown in figure 7.1\. For ease of displaying
    what will ultimately be large figures later in the chapter, we’re going to consistently
    show the design from left to right rather than top to bottom, but the same fundamental
    principles still apply.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如图7.1所示描绘这种自顶向下的设计。为了便于展示本章后面会变得很大的图形，我们将始终从左到右展示设计，而不是从上到下，但相同的基本原理依然适用。
- en: '![figure](../Images/7-1.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/7-1.png)'
- en: Figure 7.1 Functions diagram for the `get_strong_password` function. `get_strong_password`
    calls `is_strong_password`.
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.1 `get_strong_password`函数的函数图。`get_strong_password`调用`is_strong_password`。
- en: This figure indicates that it’s our goal to have `get_strong_password` call
    `is_strong_ password` to do some of its work.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图表明我们的目标是让`get_strong_password`调用`is_strong_password`来完成它的一部分工作。
- en: Now, for our second example, recall from chapter 3 that we also wrote a `best_word`
    function that takes a list of words as its parameter and returns the one worth
    the most points. Again, don’t go back and look at that code—we want to figure
    it out again here. Let’s think about what the code for this task might look like.
    It will probably use a loop to consider each word, and in that loop, it will need
    to keep track of the best word we’ve seen so far. For each word, we need to figure
    out how many points it’s worth by adding up the number of points for each of its
    letters. Remember that *a* is worth 1 point, *b* is worth 3 points, *c* is worth
    3 points, *d* is worth 2 points, *e* is worth 1 point, and so on.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到我们的第二个示例，回想一下第3章，我们也写了一个`best_word`函数，它接受一个单词列表作为参数，并返回得分最高的单词。同样，别回去看那段代码——我们想在这里重新想一想它的实现。让我们思考一下这个任务的代码可能是什么样子的。它可能会使用一个循环来考虑每个单词，在这个循环中，它需要跟踪到目前为止我们看到的最好单词。对于每个单词，我们需要通过加总每个字母的分数来计算它的得分。记住，*a*值1分，*b*值3分，*c*值3分，*d*值2分，*e*值1分，依此类推。
- en: 'Whoa there! We’re really going in-depth on this “How many points each letter
    is worth” thing. This sounds like a subtask to us. If we had a function that we
    could call to tell us the number of points each word is worth, we wouldn’t need
    to worry about this points business in our `best_word` function. In chapter 3,
    we wrote a function called `num_points` that carries out exactly this subtask:
    take a word as a parameter and return its total point value. We can call `num_points`
    from `best_word`, as depicted in figure 7.2\. Again, this makes the task of `best_word`
    easier for us.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，慢点！我们真的在深入探讨这个“每个字母值多少分”的问题。这听起来像是一个子任务。如果我们有一个函数，可以告诉我们每个单词值多少分，那么在`best_word`函数中就不需要担心这个分数问题了。在第3章中，我们写了一个叫`num_points`的函数，正好完成这个子任务：接受一个单词作为参数并返回它的总得分。我们可以从`best_word`中调用`num_points`，如图7.2所示。这样，`best_word`的任务就变得更容易了。
- en: '![figure](../Images/7-2.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/7-2.png)'
- en: Figure 7.2 Functions diagram for `best_word`
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.2 `best_word`的函数图
- en: In chapter 3, we happened to write these functions from subtask to task, from
    the leaf function to the parent function. We’ll continue to do that in this chapter,
    but we’ll do the top-down design first to figure out which functions we’ll need.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，我们恰好是从子任务写到任务，从叶子函数写到父函数。本章我们会继续这样做，但我们会先进行自顶向下的设计，以弄清楚我们需要哪些函数。
- en: These two examples from chapter 3 we just talked about are small, and you may
    indeed be able to get their code written by powering ahead with a single function.
    But with large examples, problem decomposition is the only way to keep the complexity
    under control.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才谈到的这两个来自第3章的示例比较小，实际上你可能能通过一个函数快速写出它们的代码。但对于更大的示例，问题分解是唯一能控制复杂度的办法。
- en: We’ll next dive into a larger example of top-down design. The key skill that
    we want you to take from this chapter is how to break a large problem down into
    smaller subproblems. We encourage you to read through the upcoming example multiple
    times. On your first read, aim for a high-level view of how the pieces fit together
    to solve the overall problem. On your second read, feel free to dive deeper into
    how each function works on its own.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将深入探讨一个更大的自顶向下设计示例。我们希望你从这一章中学到的关键技能是如何将一个大问题拆解成更小的子问题。我们鼓励你多次阅读接下来的示例。第一次阅读时，目标是从高层次理解各个部分如何结合起来解决整体问题。第二次阅读时，可以更深入地了解每个函数如何单独工作。
- en: 7.3 Spelling suggestions
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 拼写建议
- en: For the rest of the chapter, we’re going to solve a problem from beginning to
    end using top-down design. We want you to be sucessful when you use this approach
    on your own to solve your own problems, so you’ll see top-down design reappear
    throughout the remainder of the book.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章剩下的部分，我们将从头到尾使用自顶向下的设计解决一个问题。我们希望你在自己使用这种方法解决问题时能够成功，所以你会在本书的其余部分看到自顶向下设计的身影。
- en: Oops—did we have a typo there? *Sucessful*? That was supposed to be *successful*.
    English words can be tricky to spell sometimes! You’ve probably run into many
    such words. Is it thorough or thourough? Acceptable or acceptible? Receive or
    recieve? We’re going to write a program that takes a word that’s potentially misspelled
    and offers possible corrections to that misspelling. It’s a basic spell-checker
    for individual words!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀——我们这里有个拼写错误吗？*Sucessful*？应该是*successful*。英语单词有时真的很难拼写！你可能已经遇到过许多这样的单词。是*thorough*还是*thourough*？是*acceptable*还是*acceptible*？是*receive*还是*recieve*？我们要编写一个程序，接受一个可能拼错的单词，并提供可能的修正建议。这是一个基本的单词拼写检查程序！
- en: How are we supposed to come up with these possible corrections? Well, let’s
    look at the pairs of words we just provided and discuss the types of mistakes
    they exemplify.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们该如何提出这些可能的修正建议呢？好吧，让我们看看刚才提供的单词对，并讨论它们所示范的错误类型。
- en: The mistake we made with the word *sucessful* is that we left out one letter—we
    need to add a *c* in there to get the correct word *successful*. So, in general,
    it seems like a good idea to consider adding a letter to a misspelled word because
    that might be exactly what’s needed to fix it. We’re going to consider adding
    any possible letter in any possible position, not just adding a copy of a letter
    that’s already there. This will help us fix misspelled words such as *acknowlege*
    (which is missing a *d*).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*sucessful*这个单词中的错误是漏掉了一个字母——我们需要在其中添加一个*c*，才能得到正确的单词*successful*。因此，通常来说，考虑向拼错的单词中添加字母似乎是一个好主意，因为这可能正是修正它所需要的。我们将考虑在任何可能的位置添加任何可能的字母，而不仅仅是重复已有的字母。这将帮助我们修正诸如*acknowlege*（缺少*d*）这样的拼写错误。
- en: There are other types of mistakes we’ll want to consider too. For example, the
    mistake in *thourough* isn’t that we’re missing a letter, but that we have an
    extra letter—we need to delete the first *u* to get *thorough*. We’re therefore
    going to consider removing any single letter from a misspelled word to see if
    that fixes it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他类型的错误我们也需要考虑。例如，*thourough*中的错误不是缺少一个字母，而是我们多了一个字母——我们需要删除第一个*u*，变成*thorough*。因此，我们将考虑从拼错的单词中删除任何单个字母，看看是否能修正它。
- en: 'What other mistakes can we fix? Well, there’s that misspelled word *acceptible*.
    That’s a new type of mistake: there’s no missing or extra letter, but there is
    a letter that should be changed to another letter. That is, if we change the *i*
    to an *a*, we arrive at the correctly spelled word *acceptable*. To that end,
    we can try changing each letter to each other letter in the alphabet to see if
    that fixes the misspelling.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还能修正什么其他的错误呢？比如那个拼错的单词*acceptible*。那是一种新的错误类型：没有缺失字母，也没有多余的字母，但有一个字母需要改为另一个字母。也就是说，如果我们将*i*改为*a*，就能得到正确拼写的单词*acceptable*。为此，我们可以尝试将每个字母替换为字母表中的另一个字母，看看是否能修正拼写错误。
- en: There are many ways to fix misspelled words beyond the three that we just gave.
    But we’ll stop here because we think that fixing three types of mistakes is sufficient
    for our purposes of demonstrating top-down design. This means that our program
    will fail to correct the misspelled word *recieve* to *receive*, because we won’t
    be fixing the mistake of having two letters in the wrong order. We’ll also fail
    to correct the misspelled word *camoflague* to camouflage, because we’ll be fixing
    only one mistake in a misspelled word (*camoflague* has two different errors,
    one missing *u* and one added *u*). Once you finish the chapter, we encourage
    you to continue to improve your program and learn more about correcting misspelled
    words if you’d like to go further.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们刚才提到的三种方法，还有很多修正拼写错误的方式。但是我们在这里停下来，因为我们认为修正这三种错误已经足够展示自顶向下设计的目的。这意味着我们的程序将无法修正拼错的单词*recieve*为*receive*，因为我们不会修正两个字母顺序错误的问题。我们也无法修正拼错的单词*camoflague*为camouflage，因为我们只会修正一个拼写错误（*camoflague*有两个不同的错误，一个字母缺失*u*，另一个字母多了*u*）。当你完成这一章后，如果你希望深入学习，我们鼓励你继续改进你的程序，了解更多关于修正拼写错误的方法。
- en: 7.4 Spelling suggestions using top-down design
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 使用自顶向下设计进行拼写建议
- en: Our task is to “write a program that takes a word that’s potentially misspelled
    and offers possible corrections to that misspelling.” That’s a big task that we
    definitely don’t want to try to jam into a single function.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是“编写一个程序，接受一个可能拼写错误的单词，并提供可能的纠正建议。”这是一个很大的任务，我们肯定不希望将其塞入一个单一的函数中。
- en: 'Many programs—whether they analyze data, provide spelling suggestions, or guess
    the author of an unknown text—have three distinct tasks to perform. First, there’s
    the input task: we need to acquire the data on which our program will run. Second,
    there’s the process task, where the program does whatever it’s supposed to do
    with that data. Now, processing the data is all well and good, but it’s useless
    if our users don’t know what our programs discovered through that processing.
    That’s where the third step, the output step, comes in, and it’s where we communicate
    something to the user. Table 7.1 summarizes this process.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序——无论是分析数据、提供拼写建议，还是猜测未知文本的作者——都有三个不同的任务要执行。首先是输入任务：我们需要获取程序运行所需的数据。其次是处理任务，程序对数据执行其应做的操作。现在，处理数据是好事，但如果用户不知道程序通过处理得出的结果，那它就没什么用。这就是第三步，输出步骤的作用，它是我们与用户沟通的地方。表7.1总结了这个过程。
- en: Table 7.1 A summary of the input, process data, and output tasks
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 7.1 输入、处理数据和输出任务的总结
- en: '| Phase | Role | Spelling Suggestions Example |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 阶段 | 角色 | 拼写建议示例 |'
- en: '| --- | --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Input  | Take, as input, the information needed for the function.  | Provide
    the misspelled word *sucessful* and a collection of real words (properly spelled
    words).  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 输入 | 获取函数所需的输入信息。 | 提供拼写错误的单词*sucessful*和一组正确拼写的单词。 |'
- en: '| Process data  | Perform the operation specified by the function on that data.  |
    Consider changes to that word that might result in a correctly spelled word, for
    example, adding a letter *c* either before or after the *c* in *sucessful* would
    produce the real word *successful*. Many other incorrect words (i.e., *scucessful*
    obtained by adding the letter *c* before the *u*) may also be attempted, but only
    real words should be in the result.  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 处理数据 | 对这些数据执行函数指定的操作。 | 考虑对该单词进行更改，可能会得到正确拼写的单词，例如，在*sucessful*的*su*后面或前面添加字母*c*，将得到正确的单词*successful*。许多其他错误单词（例如，通过在*u*前添加字母*c*而得到的*scucessful*）也可能被尝试，但结果中应仅包含真实单词。
    |'
- en: '| Output  | Return the result of that data processing.  | Return the suggestion
    “successful”.  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 输出 | 返回数据处理的结果。 | 返回建议“successful”。 |'
- en: You can see this input-process-output model at work back in our data processing
    example from chapter 2\. We needed to read the data from the CSV file (that’s
    the input step), determine the number of passing yards for each quarterback (that’s
    the process step), and then output the quarterbacks and their passing yards (that’s
    the output step).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在第二章的数据处理示例中看到这个输入-处理-输出模型的应用。我们需要从CSV文件中读取数据（那是输入步骤），确定每个四分卫的传球码数（那是处理步骤），然后输出四分卫及其传球码数（那是输出步骤）。
- en: 'We can think about our Spelling Suggestions problem in a similar way. What’s
    amazing here is that the input-process-output model gives us exactly the three
    subproblems that we’ll want to solve in our top-down design. Here’s what we mean
    (also see the example in table 7.1):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用类似的方式来思考我们的拼写建议问题。这里的神奇之处在于，输入-处理-输出模型恰好为我们提供了在自顶向下设计中需要解决的三个子问题。我们所说的意思是（也参见表7.1中的示例）：
- en: For the input step, we need to ask the user for the word for which they want
    to obtain spelling suggestions.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于输入步骤，我们需要询问用户他们希望获取拼写建议的单词。
- en: For the process step, we need to figure out all the possible suggestions for
    the user’s word.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于处理步骤，我们需要弄清楚用户单词的所有可能建议。
- en: For the output step, we need to tell the user about all the spelling suggestions
    that we found during the process step.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于输出步骤，我们需要告诉用户在处理步骤中找到的所有拼写建议。
- en: Notice that we started with one large problem to solve (the overall Spelling
    Suggestions problem), and now we have three smaller problems to solve. Our main
    or top-level function will end up calling any functions that result from this
    problem decomposition. We’ll name this main function `spell_check`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们从一个大问题开始解决（总体拼写建议问题），现在我们有了三个更小的问题需要解决。我们的主函数或顶级函数最终会调用从这个问题分解中得到的任何函数。我们将把这个主函数命名为`spell_check`。
- en: It’s often but not always the case that we need a separate function for each
    of the subproblems we identify. Take a look at the input step again. We need to
    ask the user for a word. While we could split off a separate function for this
    subtask, that would be overkill. Why? This is because Python already has a built-in
    function for asking the user for input! The function is called `input`, and we
    saw it at work in chapter 3, section 3.3.7, when we were asking the user to enter
    passwords.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，但并非总是如此，我们需要为每个识别出的子问题拆分出一个单独的函数。再看看输入步骤。我们需要让用户输入一个单词。虽然我们可以为这个子任务拆分出一个单独的函数，但那样就过头了。为什么？因为
    Python 已经有一个内置的函数用来向用户请求输入！这个函数叫做 `input`，我们在第三章的第3.3.7节中使用过它，那个时候我们让用户输入密码。
- en: Do we need to split off a separate function for the output step? No again! The
    output step is just outputting stuff to the user. We know that we can do that
    with Python’s already-existing print function. Again, it wouldn’t be a mistake
    to split off a function for this, and you may have done so if you were doing this
    problem decomposition on your own. What you’d notice, though, is that the function
    would be very short, consisting of not much more than a call of `print`—and at
    that point you might think again about whether you want it as a separate function
    or not.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为输出步骤拆分一个单独的函数吗？再次不需要！输出步骤只是将内容输出给用户。我们知道可以使用 Python 已有的 `print` 函数来做到这一点。同样，拆分出一个函数来处理这个步骤并不会是错误的，如果你自己进行问题分解时可能会这么做。但你会注意到，这个函数会非常简短，几乎只包含对
    `print` 的调用——到那时你可能会再次考虑是否真的需要将其拆分为单独的函数。
- en: The process step, by comparison, is going to involve a lot more work. There’s
    quite a bit that goes into figuring out all the possible spelling suggestions!
    We have to support deleting a letter, inserting a letter, changing one letter
    to another, and so on, which is way too much to keep all in our main `spell_check`
    function. We need a separate function for the process step. This is what we need
    to work on next.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，处理步骤将涉及更多的工作。找出所有可能的拼写建议需要做大量的工作！我们需要支持删除一个字母、插入一个字母、将一个字母更改为另一个字母等等，这些都太复杂，无法全部放在我们的主
    `spell_check` 函数中。我们需要为处理步骤单独拆分一个函数。接下来我们就要开始着手处理这个问题。
- en: 7.5 Breaking down the process subproblem
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 分解处理子问题
- en: We need a name for our function that implements the process step. We’ll call
    it `get_spelling_suggestions` because it will be responsible for returning the
    spelling suggestions for what the user typed. It certainly needs to take the user’s
    misspelled word as an argument, or it wouldn’t have access to it!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为实现处理步骤的函数起个名字。我们将其命名为 `get_spelling_suggestions`，因为它将负责返回用户输入的拼写建议。它肯定需要将用户拼写错误的单词作为参数传入，否则就无法访问它！
- en: 'Pause here for a second, though: Do you think this function needs any additional
    parameters? Answer: it does! Somehow the function needs to know which strings
    are real words in English. For example, it has to know about the words *successful*,
    *thorough*, *acceptable*, and thousands of other English words. We could do that
    in a couple of ways: we could pass a list or (Python) dictionary of real words
    as a parameter, or we could pass the name of a file that contains all the real
    words as a parameter. When you’re designing your functions, you’ll need to make
    similar decisions, focused on the inputs that the function needs to do its work
    and the return value that we need when it’s done.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这里稍作停顿：你认为这个函数需要任何额外的参数吗？答案是：需要！以某种方式，这个函数需要知道哪些字符串是真正的英文单词。例如，它必须知道单词 *successful*、*thorough*、*acceptable*
    和成千上万的其他英文单词。我们可以通过几种方式来实现这一点：我们可以将一个包含所有真实单词的列表或（Python）字典作为参数传递，或者我们可以将包含所有真实单词的文件名作为参数传递。当你设计函数时，你需要做出类似的决策，专注于函数需要的输入以及完成任务后需要的返回值。
- en: In addition to the misspelled word, we’re going to have our function take a
    parameter giving the name of a file that contains the list of valid words. There
    will be one valid word per line of this file. In the resources for this book,
    we’ve included one sample word list file called wordlist.txt that you can use.
    (We found a list of free dictionary words online with a simple internet search.)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除了拼写错误的单词外，我们还将让函数接受一个参数，传入包含有效单词列表的文件名。这个文件中的每一行包含一个有效单词。在本书的资源中，我们包含了一个名为
    wordlist.txt 的示例单词列表文件，供你使用。（我们通过简单的互联网搜索找到了一份免费的词典单词列表。）
- en: 'What do we need to do for this process step? We can think of four subtasks.
    This is more problem decomposition! Those subtasks are as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个过程步骤中需要做什么？我们可以考虑四个子任务。这就是更多的问提分解！这些子任务如下：
- en: '*Get a list of words from the word list file.* A file of words is a good start,
    but it’s more convenient to have the words inside a Python list. That way, we
    can easily determine if a string is a valid word. We’ll name this function `create_word_list`.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从单词列表文件中获取单词列表*。单词文件是一个不错的起点，但将单词放在 Python 列表中会更加方便。这样，我们就可以轻松地判断一个字符串是否是有效单词。我们将这个函数命名为`create_word_list`。'
- en: '*Generate a list of all possible words from the user’s string.* We need to
    delete a letter, insert a letter, or change one letter to another letter. This
    is going to generate many strings, some of which are real words and others that
    aren’t real words. For example, from the string `sucessful`, it would generate
    the real word *successful*, but also the strings `xsuccesful`, `sucxcesful`, and
    `succesfrl`, which are clearly not real words. But that’s OK. For now, we just
    want to generate every possible word so that we don’t miss any. We’ll name this
    function `all_possible_words`.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从用户的字符串生成所有可能的单词列表*。我们需要删除一个字母、插入一个字母，或者将一个字母更换成另一个字母。这将生成许多字符串，其中一些是实际的单词，而另一些则不是。例如，从字符串`sucessful`中，我们会生成实际单词*successful*，但也会生成`xsuccesful`、`sucxcesful`和`succesfrl`等字符串，这些显然不是实际单词。但没关系。现在我们只是想生成每一个可能的单词，以免错过任何一个。我们将这个函数命名为`all_possible_words`。'
- en: '*Using the list of all possible words, generate a list of only the real words.*
    This is the step where we prune our full list of potential words down to those
    words that actually exist in English. We’ll name this function `all_real_words`.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用所有可能单词的列表，生成仅包含实际单词的列表*。这是我们将潜在单词的完整列表筛选为那些实际存在的英语单词的步骤。我们将这个函数命名为`all_real_words`。'
- en: '*Return a list of the unique words.* Why unique? We don’t want to return the
    same spelling suggestion twice, even though there may be two or more ways to arrive
    at that spelling suggestion from the user’s string. For example, to fix the word
    *sucessful*, there are two ways to do it: we can add the missing *c* before the
    *c* that’s already there, or we can add the *c* before the *e*. Both result in
    the correctly spelled word *successful*, but we only want to maintain that word
    once.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*返回唯一单词的列表*。为什么是唯一的？我们不希望返回相同的拼写建议两次，尽管可能有两种或更多方法从用户的字符串得出该拼写建议。例如，要修正单词*sucessful*，有两种方法：我们可以在已经存在的*c*前面再加一个*c*，或者我们可以在*e*前面加上*c*。这两种方法都会得到正确拼写的单词*successful*，但我们只希望保留一个。'
- en: If we were to split out that final subtask—obtaining a list of unique words—into
    its own function, we’d call it something like `unique_words` or `only_unique_words`.
    While we could split out that subtask, and you’d be justified in doing so, we’ve
    decided to keep it as part of the `get_spelling_suggestions` function. The reason
    is that in Python, it ends up being just one line of code to remove duplicates
    from a list. For expediency, we’re telling you this now, but again, this would
    be a perfectly good subtask if you were doing this top-down design on your own.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将最终的子任务——获取唯一单词的列表——分解成一个独立的函数，我们可能会将其命名为`unique_words`或`only_unique_words`。虽然我们可以将这个子任务分解开，你也完全有理由这么做，但我们决定将其保留在`get_spelling_suggestions`函数中。原因是，在
    Python 中，从列表中去除重复项实际上只需要一行代码。为了方便起见，我们现在告诉你这一点，但如果你自己进行自顶向下设计，这也是一个完全合理的子任务。
- en: Multiple ways to break down problems
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 多种方式分解问题
- en: There’s no single correct way to do a top-down design and no single correct
    way to decompose problems into subproblems. For example, you may have been surprised
    that we decided to first generate all possible words (including fake ones that
    aren’t actually English words), and then prune that to the list of actual English
    words. Why not just check each possible word first, and only add it to our list
    if it’s a real word? We certainly could have done it that way too! If you had
    this alternate decomposition in mind, or we’ve piqued your curiosity, we encourage
    you to try this alternate design on your own after you’ve finished with the chapter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 进行自顶向下设计没有唯一正确的方式，问题分解成子问题也没有唯一正确的方式。例如，你可能会对我们首先生成所有可能的单词（包括那些并非真正英语单词的伪单词）并在此基础上筛选出实际的英语单词感到惊讶。为什么不先检查每个可能的单词，只有在它是真正的单词时才将其添加到列表中呢？我们当然也可以这样做！如果你有这种替代的分解方式，或者我们激发了你的好奇心，我们鼓励你在完成本章内容后，自己尝试这种替代设计。
- en: There’s also no shame in trying a top-down design and then abandoning it if
    the design isn’t working out. What might it mean for the design to not work out?
    Well, maybe you’re finding it difficult to break up large functions into distinct
    subproblems. Or maybe you’re getting dozens of tiny functions and starting to
    worry that your functions are too specific and not solving general problems. Or
    maybe you’re having to pass around many parameters, perhaps some of which are
    only there to be passed further and further until finally a function needs them.
    Or maybe you just want to play out an alternate top-down design to see how it
    goes!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试自上而下的设计，然后在设计无法奏效时放弃，这并不丢人。那么，设计无法奏效是什么意思呢？嗯，也许你发现很难将大型函数拆分为明确的子问题。或者，也许你得到了几十个小函数，开始担心这些函数是否过于具体，不能解决一般问题。或者，也许你需要传递很多参数，其中一些参数可能只是为了继续传递下去，直到最终一个函数需要它们。或者，也许你只是想试试另一种自上而下的设计，看看效果如何！
- en: We encourage experimentation at the design phase before you settle on a final
    design for the code. In this experimentation, you’d try different possible functions
    and different inputs/outputs for functions. For example, earlier we debated whether
    the `get_spelling_suggestions` function should take a name of a file containing
    real words or a list (or dictionary) containing real words. Both options would
    be worth considering during your design phase.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励在设计阶段进行实验，在最终确定代码的设计之前尝试不同的函数和不同的输入/输出。例如，之前我们讨论过`get_spelling_suggestions`函数应该接受一个包含真实单词的文件名，还是一个包含真实单词的列表（或字典）。在设计阶段，考虑这两种选择都是值得的。
- en: That leaves us with three subtasks we need to solve. We’re going to do our top-down
    design on these shortly. But first, let’s take stock of where we are right now
    (see figure 7.3).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这就剩下我们需要解决的三个子任务了。我们将在稍后对这些进行自上而下设计。但首先，让我们看看目前的进展如何（见图7.3）。
- en: '![figure](../Images/7-3.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/7-3.png)'
- en: Figure 7.3 Functions diagram showing the three subtasks of `get_spelling_suggestions`
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.3 函数图，展示了`get_spelling_suggestions`的三个子任务
- en: 7.5.1 Getting the list of words from the word list file
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.1 从词汇表文件中获取单词列表
- en: The function for this task is `create_word_list`. It will take one parameter,
    which is the name of the word list file, and will return the list of words from
    that file.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务的函数是`create_word_list`。它将接受一个参数，即词汇表文件的名称，并返回该文件中的单词列表。
- en: Do we need any further top-down design on this function? Let’s imagine we thought
    the answer was yes. What subtasks could we split out? We could imagine the tasks
    of opening the file, reading its contents, and closing the file. But opening the
    file, as we learned in chapter 5, section 5.1.4, is done by just calling Python’s
    `open` function. Similarly, closing the file is done by just calling Python’s
    `close` function. What about reading the words from the file? That doesn’t sound
    much different from reading the lines of the CSV file in chapter 5, section 5.1.4\.
    So we feel justified in leaving this function alone, without any further subtask
    splitting.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否需要对这个函数进行进一步的自上而下设计？让我们假设我们认为答案是肯定的。我们可以拆分出哪些子任务？我们可以考虑打开文件、读取内容和关闭文件的任务。但是，正如我们在第5章第5.1.4节学到的，打开文件只是通过调用Python的`open`函数来完成的。同样，关闭文件也是通过调用Python的`close`函数来完成的。那么，如何从文件中读取单词呢？这听起来和第5章第5.1.4节中读取CSV文件的行没有太大区别。所以我们认为没有必要进一步拆分这个函数的子任务。
- en: 7.5.2 Generating the list of all possible words
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.2 生成所有可能单词的列表
- en: The function for this task is `all_possible_words`, which will take one parameter
    giving us the string for which we want to provide spelling suggestions. It will
    return the list of all possible words that can be obtained by adding one letter,
    deleting one letter, or changing one letter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务的函数是`all_possible_words`，它将接受一个参数，给出我们希望提供拼写建议的字符串。它将返回所有可能的单词列表，这些单词可以通过添加一个字母、删除一个字母或更改一个字母得到。
- en: 'Adding one letter, deleting one letter, and changing one letter are three distinct
    types of tasks. Moreover, they don’t strike us as particularly simple tasks: they’re
    going to involve some sort of loop over the letters in the user’s string. Aha!
    Looks like we have some further top-down design to do on this one. In particular,
    we’re going to split three subtasks out of this function:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个字母、删除一个字母和更改一个字母是三种不同类型的任务。而且，它们看起来并不是特别简单的任务：它们需要在用户的字符串中的字母上进行某种循环。啊哈！看来我们需要对这个进行进一步的自上而下设计。特别地，我们将从这个函数中拆分出三个子任务：
- en: '`add_letter`—This function will take a string parameter and return a list of
    all strings that can be obtained by adding one letter anywhere in the word.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add_letter`—此函数将接受一个字符串参数，并返回一个通过在单词中任意位置添加一个字母可以得到的所有字符串列表。'
- en: '`delete_letter`—This function will take a string parameter and return a list
    of all strings that can be obtained by deleting one letter.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete_letter`—此函数将接受一个字符串参数，并返回一个通过删除一个字母可以得到的所有字符串列表。'
- en: '`change_letter`—This function will take a string parameter and return a list
    of all strings that can be obtained by changing one letter.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`change_letter`—此函数将接受一个字符串参数，并返回一个通过更改一个字母可以得到的所有字符串列表。'
- en: Table 7.2 provides what we expect each function will return for two different
    input strings. For both add_letter and change_letter, a large number of strings
    are returned because they will consider adding or changing every letter in English
    in every location in the input string.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.2 提供了我们期望每个函数对于两个不同输入字符串的返回结果。对于 `add_letter` 和 `change_letter`，返回了大量字符串，因为它们会考虑在输入字符串中的每个位置添加或更改每个字母。
- en: Table 7.2 Examples of the `add_letter`, `delete_letter`, and `change_letter`
    function
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 7.2 `add_letter`、`delete_letter` 和 `change_letter` 函数示例
- en: '| Input String | Strings Returned by `add_letter` | Strings Returned by `delete_letter`
    | Strings Returned by `change_letter` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 输入字符串 | `add_letter` 返回的字符串 | `delete_letter` 返回的字符串 | `change_letter` 返回的字符串
    |'
- en: '| --- | --- | --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `cu`  | `acu, bcu, ccu, …, zcu cau, cbu, ccu, …, czu cua, cub, cuc, …, cuz`  |
    `u, c`  | `au, bu, du, …, zu, ca, cb, cc, …, cz`  |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `cu`  | `acu, bcu, ccu, …, zcu cau, cbu, ccu, …, czu cua, cub, cuc, …, cuz`  |
    `u, c`  | `au, bu, du, …, zu, ca, cb, cc, …, cz`  |'
- en: '| `cad`  | `acad, bcad, ccad, …, zcad caad, cbad, ccad, …, czad caad, cabd,
    cacd, …, cazd cada, cadb, cadc, …, cadz`  | `ad, cd, ca`  | `aad, bad, dad, …,
    za cbd, ccd, cdd, …, czd caa, cab, cac, …, caz`  |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `cad`  | `acad, bcad, ccad, …, zcad caad, cbad, ccad, …, czad caad, cabd,
    cacd, …, cazd cada, cadb, cadc, …, cadz`  | `ad, cd, ca`  | `aad, bad, dad, …,
    za cbd, ccd, cdd, …, czd caa, cab, cac, …, caz`  |'
- en: As usual, it’s important to think through whether we need to split out further
    subtasks from these three functions. However, given that the pattern we expect
    to see is just a loop through the letters, we’d be comfortable pushing forward
    here and revisiting our top-down design if our assumption proves to be incorrect.
    For now, we can tell you that we’ll be just fine without any further splitting.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，重要的是要思考是否需要将这三个函数进一步拆分为子任务。然而，考虑到我们期望看到的模式只是对字母的循环遍历，我们会觉得可以继续推进，如果假设不正确，我们可以重新审视自顶向下的设计。现在我们可以告诉你，我们在没有进一步拆分的情况下也能做到。
- en: Knowing when to stop dividing into subtasks
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 知道何时停止将任务划分为子任务
- en: In general, knowing when to stop breaking a task into smaller subtasks is more
    art than science. It takes practice designing programs to get intuition about
    where to stop. Many experienced developers often pause for each subtask and consider
    how complex it is to program and sketch the steps of the function out in their
    mind. If the solution isn’t straightforward, they often choose to divide it into
    more steps. But we don’t expect you to be able to do this yet. Some companies
    put out guidelines to encourage simple functions by suggesting limits on the number
    of lines permitted (e.g., no more than 12 lines), but many feel the limit should
    be on the complexity moreso than the length, although length and complexity are
    certainly related.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，知道何时停止将任务分解为更小的子任务，更像是一种艺术而非科学。设计程序时，需要通过实践来获得直觉，判断何时停止。许多经验丰富的开发人员通常会为每个子任务停下来，考虑编程的复杂性，并在脑海中勾画出函数的步骤。如果解决方案不直接，他们通常会选择将其分解为更多步骤。但我们不期望你现在就能做到这一点。一些公司发布了指导方针，通过建议函数行数的限制（例如，不超过12行）来鼓励简化函数，但许多人认为限制应该更多地基于复杂性，而不是长度，尽管长度和复杂性是相关的。
- en: When you’re just getting started, a decent proxy then is to limit the number
    of lines per function to something like 12–20\. If you later find that a function
    ends up being just a single line, it’s still a subtask, but may not deserve its
    own function. (Sometimes, it’s okay to keep a short function though if it’s called
    many times by different functions or helps simplify the calling function.)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你刚开始时，一个合适的代理是将每个函数的行数限制在12到20行之间。如果你后来发现某个函数最终只有一行，它仍然是一个子任务，但可能不需要自己的函数。（有时，如果一个短函数被不同的函数多次调用，或者有助于简化调用函数，保留它也是可以的。）
- en: It’s okay to get this wrong when you’re first practicing; we certainly have.
    Sometimes a subtask seems like it’ll make a simple function, only to end up being
    much more difficult than expected. In cases like that, you know to just subdivide
    it more. Likewise, we’ve had functions that were a single line and if they were
    used commonly or made the calling function simpler to understand, we just kept
    that line as a function.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在刚开始练习时，犯错是正常的；我们肯定也犯过。有时一个子任务看起来只需要实现一个简单的函数，结果却比预期的要困难得多。在这种情况下，你知道只需要再将它拆分得更小。同样，我们也遇到过一些函数只有一行，如果它们经常被使用或者让调用函数更易理解，我们就将那一行保持为一个函数。
- en: 7.5.3 Generating the list of all real words
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.3 生成所有真实单词的列表
- en: 'The function for this task is `all_real_words`. It will take two parameters:
    the list of real words, and the list of all possible words. It will return a list
    consisting of only the real words from the full list of possible words. The code
    for this function would involve going through the list of possible words and checking
    whether each one shows up in the list of real words. As this task is a small,
    well-defined task that won’t yield a lot of code, we’re comfortable leaving this
    function alone without any further splitting.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务的函数是`all_real_words`。它将接受两个参数：真实单词的列表和所有可能单词的列表。它将返回一个仅包含真实单词的列表，从所有可能单词的列表中筛选出来。这个函数的代码将遍历所有可能的单词列表，检查每个单词是否出现在真实单词的列表中。由于这是一个小而明确的任务，不会生成很多代码，所以我们可以直接将这个函数保留，而不需要进一步拆分。
- en: 7.6 Summary of our top-down design
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 自顶向下设计总结
- en: We’ve reached the end of our top-down design process. You can see our final
    top-down design in figure 7.4.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了自顶向下设计的过程。你可以在图7.4中看到我们的最终设计。
- en: '![figure](../Images/7-4.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/7-4.png)'
- en: Figure 7.4 Functions diagram with the three subtasks of `all_possible_words`
    added
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.4 添加了`all_possible_words`三个子任务的函数图
- en: 'Let’s not lose the forest for the trees here. If we zoom out, what we’ve done
    is break down our original big problem into several smaller problems, each of
    which we’re going to implement as a function. Our original `spell_check` problem
    may have felt overwhelming. That’s OK, though, because we broke it down into one
    primary subtask of `get_spelling_suggestions`. The `get_spelling_suggestions`
    function is still a big problem in its own right, but we were able to solve that
    through the same process: we split it into three subtasks. Two of those subtasks,
    `create_word_list` and `all_real_words`, felt as though they could be solved in
    a single function, but the other task, `all_possible_words`, was complex enough
    that we felt it needed three more additional subtasks (`add_letter`, `delete_letter`,
    and `change_letter`). The important thing we want you to take away from this is
    that we used the same technique of problem decomposition at every step to turn
    an initially daunting task into just a collection of solvable subtasks that will
    become functions.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不要只看到树木，忽略了森林。如果我们放眼全局，我们所做的是将最初的一个大问题拆解为几个更小的问题，每个问题我们都会实现为一个函数。最初的`spell_check`问题可能让人觉得很有压力，但没关系，因为我们将它拆解为一个主要子任务`get_spelling_suggestions`。`get_spelling_suggestions`函数本身仍然是一个大问题，但我们通过相同的过程解决了它：我们将其拆解为三个子任务。两个子任务，`create_word_list`和`all_real_words`，看起来可以用一个函数来解决，但另一个任务，`all_possible_words`，则足够复杂，我们觉得需要三个额外的子任务（`add_letter`、`delete_letter`和`change_letter`）。我们希望你从中学到的一个重要点是，我们在每一步都使用了相同的分解问题的方法，把最初看起来令人生畏的任务，变成了一系列可以解决的小任务，而这些小任务将变成函数。
- en: Our next step is to move from design to implementation. We know which functions
    we need now to solve our problem. It’s time for the code!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是从设计转向实现。现在我们知道了解决问题所需的函数。是时候写代码了！
- en: 7.7 Implementing our functions
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7 实现我们的函数
- en: When you’re doing a top-down design, as we just did, you start with your overall
    problem and break it into subproblems. That’s why we started with `spell_check`
    (our overall problem) and eventually reached functions such as `add_letter`, which
    didn’t need any further splitting. But when we ask Copilot to implement these
    functions, we’re not going to work in the same order. Rather, we’re going to work
    in the *opposite* order, doing the smallest subproblems first, then moving onto
    the functions that depend on those subproblems. This corresponds to moving from
    right to left in a figure such as figure 7.4, starting with leaf functions and
    continuing to nonleaf functions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进行自上而下设计时，正如我们刚刚做的那样，你从整体问题开始，并将其拆解成子问题。这就是为什么我们从`spell_check`（我们的整体问题）开始，最终到了像`add_letter`这样的函数，它不需要进一步拆分。但当我们要求
    Copilot 实现这些函数时，我们并不会按照相同的顺序工作。相反，我们将按*相反*的顺序工作，先做最小的子问题，然后再做依赖于这些子问题的函数。这对应于从图
    7.4 中的右到左移动，从叶子函数开始，继续到非叶子函数。
- en: We implement functions in the opposite order like this so that Copilot knows
    about the smaller functions by the time we want to implement larger functions.
    That way, Copilot will be more likely to call our subtask functions as desired.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以相反的顺序实现函数，这样当我们想实现更大的函数时，Copilot 已经知道了较小的函数。这样，Copilot 就更有可能按照我们的预期调用子任务函数。
- en: We want to stay squarely focused on problem decomposition here, and we’ve made
    some decisions toward that end. First, while we’ll include some tests in our docstrings,
    we won’t be pursuing full testing in this example as we would have done in chapter
    6\. We encourage you to use doctest to run the tests that we do provide as well
    as add your own tests for further confidence in the code. Second, we haven’t dwelled
    much on our prompt engineering, instead focusing on the prompts that yielded good
    results. In the next chapter, we’ll focus on debugging, and that’s where we’ll
    return to prompt engineering. Third, we’re not focusing on reading and understanding
    the code in full detail. That said, we’ve included some annotations to explain
    what the code is doing and how it works.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在这里专注于问题分解，并且已朝着这个目标做出了一些决策。首先，虽然我们会在文档字符串中包含一些测试，但我们不会像第六章那样进行完整的测试。我们鼓励你使用
    doctest 运行我们提供的测试，并添加你自己的测试，以进一步验证代码。其次，我们没有过多关注提示工程，而是专注于那些产生良好结果的提示。在下一章，我们将专注于调试，那时我们会回到提示工程的内容。第三，我们不专注于全面阅读和理解代码。话虽如此，我们已包括一些注释来解释代码的作用和工作原理。
- en: 7.7.1 create_word_list
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.1 create_word_list
- en: We’ll start with our `create_word_list` function. As in chapter 3, we write
    the function header (the `def` line) and the docstring, and Copilot fills in the
    code. This is how we’ll have Copilot write the code for all the functions in this
    chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从我们的`create_word_list`函数开始。和第三章一样，我们先写函数头（`def` 行）和文档字符串，然后 Copilot 会填写代码。这就是我们让
    Copilot 为本章所有函数编写代码的方式。
- en: 'We already know what our `create_word_list` function is supposed to do: read
    the words from the word list file and return them as a Python list of words. We
    carefully write what we want in the docstring, as shown in listing 7.1.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道我们的`create_word_list`函数应该做什么：从单词列表文件中读取单词，并将它们作为一个 Python 单词列表返回。我们小心地在文档字符串中写下我们想要的内容，如列表
    7.1 所示。
- en: Listing 7.1 Function to read the list of words
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.1 读取单词列表的函数
- en: '[PRE0]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '#1 The header we wrote ourselves'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们自己写的标题'
- en: '#2 The docstring we wrote ourselves'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 我们自己写的文档字符串'
- en: '#3 Opens the file'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 打开文件'
- en: '#4 Loops through each line of the file'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 遍历文件的每一行'
- en: '#5 Adds each word to our list of words'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 将每个单词添加到我们的单词列表中'
- en: We’ve used a descriptive parameter name, `filename`, which gives a good clue
    to the purpose of the parameter. We’ve also been careful to use this parameter
    name in the docstring. Our docstring also makes it explicit that we want to *return*
    the list (rather than, say, print it).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个描述性的参数名 `filename`，它清楚地表明了参数的用途。我们也小心地在文档字符串中使用了这个参数名。我们的文档字符串还明确表示我们想要*返回*列表（而不是，例如，打印它）。
- en: We haven’t included a test in the docstring for this function, and that’s because
    we didn’t want to distract from the overall goal of implementing each of our functions.
    If you wanted to, though, you know how! Specifically, we did this in chapter 6
    where we created a small file for purposes of testing. Here, you could create
    a small file with one word per line but with only a few English words, and then
    test that the list of words we read from the file matches the words that we put
    in the file. We’re finished with our `create_word_list` function, so we can mark
    it as complete as in figure 7.5.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个函数的文档字符串中没有包含测试，因为我们不想分散实现每个函数的整体目标。但如果你想的话，你知道怎么做！具体来说，我们在第六章中做了这个，我们创建了一个小文件用于测试目的。在这里，你可以创建一个每行一个单词的小文件，但只包含少数几个英语单词，然后测试我们从文件中读取的单词列表是否与我们放入文件中的单词相匹配。我们已经完成了`create_word_list`函数，因此我们可以将其标记为完成，如图7.5所示。
- en: '![figure](../Images/7-5.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/7-5.png)'
- en: Figure 7.5 Full functions diagram with `create_word_list` finished
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.5 完整的函数图，`create_word_list`已完成
- en: To save space, we won’t show the updated figure after we implement each function,
    but we’ll show it occasionally.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，我们不会在每次实现完一个函数后展示更新的图示，但我们会偶尔展示它。
- en: 7.7.2 add_letter
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.2 add_letter
- en: Now we’ll work on the functions that `all_possible_words` needs, starting with
    `add_letter`. The `add_letter` function takes a string as a parameter and returns
    the list of potential words that can be formed by adding one letter to that string.
    Let’s think briefly about what to expect from this function with a quick example.
    If we gave the function the string `cu` (as in table 7.2) it’s going to generate
    a list of words with every letter added to each possible position. This means
    it should include strings that have an `a` added before `cu` to make `acu`, a
    `b` added before `cu` to make `bcu`, and so forth for the character before `cu`
    stopping with `zcu`. The function should also include every letter in between
    `c` and `u` to form `cau`, `cbu`, `ccu`… . , `czu`. Lastly (as there are three
    possible positions to add a letter), we’d expect the function to add every possible
    letter after `cu` to form `cua`, `cub`, `cuc`,… . , `cuz`. Our prompt to Copilot
    and the code generated by Copilot is shown in listing 7.2.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将开始处理`all_possible_words`所需的函数，从`add_letter`开始。`add_letter`函数以一个字符串作为参数，并返回通过向该字符串添加一个字母可以形成的所有可能单词列表。让我们简要地考虑一下使用这个函数时预期的结果，通过一个快速的例子。如果我们给函数传递字符串`cu`（如表7.2所示），它将会生成一个单词列表，其中每个字母都添加到每个可能的位置。这意味着它应该包括在`cu`之前添加`a`得到`acu`，在`cu`之前添加`b`得到`bcu`，以此类推，直到添加`z`得到`zcu`。该函数还应该包括介于`c`和`u`之间的每个字母，形成`cau`、`cbu`、`ccu`...、`czu`。最后（因为有三个可以添加字母的位置），我们预期该函数将添加`cu`后面的每个可能字母，形成`cua`、`cub`、`cuc`...、`cuz`。我们的提示词和由Copilot生成的代码如列表7.2所示。
- en: Listing 7.2 Function to add any possible letter
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.2 添加任何可能字母的函数
- en: '[PRE1]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '#1 Loops through each index, from 0 to just past the final character'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 遍历每个索引，从0到刚好超过最后一个字符'
- en: '#2 Loops through each lowercase letter'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 遍历每个小写字母'
- en: '#3 Forms a new word by placing character c at index i'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 通过将字符c放置在索引i处来形成一个新单词'
- en: '#4 Adds this new word to our list of words'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 将这个新单词添加到我们的单词列表中'
- en: The code here is quite subtle and deserves careful testing. For example, notice
    that the outer loop uses `len(word) + 1`, rather than the more standard `len(word)`.
    Without the `+ 1`, we would add characters at each existing index of the word
    string. But that would actually miss the fact that we also want to be able to
    add letters *past* the existing letters! The `+ 1` adds one extra iteration where
    we add a character to the end of the string.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码相当微妙，需要仔细测试。例如，请注意外层循环使用的是`len(word) + 1`，而不是更标准的`len(word)`。如果没有`+ 1`，我们将会在单词字符串的每个现有索引处添加字符。但这样实际上会忽略掉我们还希望能够在现有字母之后添加字母的事实！`+
    1`增加了一个额外的迭代，我们可以在字符串的末尾添加一个字符。
- en: For each index of the outer loop, we consider each possible lowercase letter
    in the inner loop. The line `new_word = word[:i] + c + word[i:]` uses string slicing,
    the technique of extracting letters out of a string using two indices, to add
    the current inner-loop character to the current outer-loop position.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于外层循环的每个索引，我们在内层循环中考虑每个可能的小写字母。`new_word = word[:i] + c + word[i:]`这行代码使用了字符串切片技术，这是一种通过两个索引从字符串中提取字母的技术，用于将当前内层循环的字符添加到当前外层循环的位置。
- en: Although we aren’t spending much time on testing in this chapter because the
    focus is problem decomposition, you would want to test this function by giving
    it a single misspelled word (i.e., *cu*) and then printing the returned words
    and ensuring it includes strings such as `acu` (add at the start), `cau` (add
    in the middle), and `cua` (add at the end), as well as possible real words such
    as *cup* and *cut*.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在本章中我们不会花太多时间在测试上，因为重点是问题分解，但你会希望通过给它一个拼写错误的单词（例如*cu*）来测试此函数，然后打印返回的单词并确保它包括如`acu`（添加到开头）、`cau`（添加到中间）和`cua`（添加到末尾）等字符串，以及可能的真实单词，如*cup*和*cut*。
- en: 'Note that we wouldn’t want to include exact tests in the docstring because
    the lists returned by this function are huge! For example, try typing this at
    the Python prompt:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不希望在文档字符串中包括确切的测试，因为这个函数返回的列表非常庞大！例如，尝试在Python提示符下键入：
- en: '[PRE2]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You’ll get a list with 78 strings in it! And that’s for our tiny `'cu'` string.
    The number of strings returned in the list grows significantly as we increase
    the number of characters in the parameter string.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到一个包含78个字符串的列表！这只是针对我们小小的`'cu'`字符串。随着参数字符串中字符数量的增加，返回列表中的字符串数量显著增加。
- en: 7.7.3 delete_letter
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.3 delete_letter
- en: Like `add_letter`, `delete_letter` takes a string as a parameter and returns
    a list of potential words. The difference is that rather than adding a letter,
    `delete_letter` deletes each possible letter from the string to arrive at new
    possible words. Let’s think about what we expect this function to do. If we give
    it the string “carf”, it should try deleting each letter to produce the strings
    “arf” by deleting “c”, “crf” by deleting “a”, “caf” by deleting “r”, and “car”
    by deleting “f”. Again, we gave the prompt to Copilot for this function, as shown
    in listing 7.3.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与`add_letter`类似，`delete_letter`将一个字符串作为参数并返回一个潜在单词的列表。不同之处在于，`delete_letter`不是添加字母，而是删除字符串中的每个可能字母，从而得到新的潜在单词。让我们思考一下我们期望这个函数执行的操作。如果我们给它字符串“carf”，它应该尝试删除每个字母来生成字符串“arf”（删除“c”）、“crf”（删除“a”）、“caf”（删除“r”）和“car”（删除“f”）。同样，我们为这个函数给了Copilot提示，如清单7.3所示。
- en: Listing 7.3 Function to delete any letter
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单7.3 删除任何字母的函数
- en: '[PRE3]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '#1 Loops through each index, from 0 to the final character'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 遍历每个索引，从0到最后一个字符'
- en: '#2 Forms a new word by deleting character at index i'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 通过删除索引i处的字符来形成一个新单词'
- en: '#3 Adds this new word to our list of words'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 将这个新单词添加到我们的单词列表中'
- en: This code is similar to our code for `add_letter`. One difference is that we
    have only one loop this time, not two. The reason is that we don’t need an inner
    loop to loop through the letters *a*, *b*, *c*, *d*, and so on. That’s because
    we’re deleting letters that already exist in the word, rather than figuring out
    which letter to add.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码类似于我们的`add_letter`代码。不同之处在于这次只有一个循环，而不是两个。原因是我们不需要一个内部循环来遍历字母*a*、*b*、*c*、*d*等。因为我们删除的是已经存在于单词中的字母，而不是找出要添加哪个字母。
- en: 7.7.4 change_letter
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.4 change_letter
- en: 'Now, it’s time for our third and final subtask of `all_possible_words: change_letter`!
    This function is responsible for generating words where one letter in the string
    is changed to some other letter. In thinking about what we’d like to see happen
    here, let’s consider the string `cu` again (as in table 7.2). We want this function
    to replace the letter *c* with all possible letters to create the strings `au`,
    `bu`, `du`… . , `zu` and to replace the letter *u* with all possible letters to
    create the strings `ca`, `cb`, `cc`… . , `cz`. (Note that we omit trying `cu`
    as that’s the initial string, we only consider changes to letters.) See listing
    7.4 for our prompt and the code from Copilot.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候处理`all_possible_words`的第三个也是最后一个子任务`change_letter`了！这个函数负责生成通过将字符串中的一个字母替换为其他字母而得到的单词。考虑到我们希望在这里看到的效果，让我们再考虑一下字符串`cu`（如表7.2所示）。我们希望这个函数将字母*c*替换为所有可能的字母，以生成字符串`au`、`bu`、`du`……，`zu`，并将字母*u*替换为所有可能的字母，以生成字符串`ca`、`cb`、`cc`……，`cz`。（请注意，我们省略了尝试`cu`，因为它是初始字符串，我们只考虑字母的变化。）请参见清单7.4，查看我们为此函数提供的提示和Copilot的代码。
- en: Listing 7.4 Function to change any letter
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 清单7.4 更改任何字母的函数
- en: '[PRE4]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '#1 Loops through each index, from 0 to the final character'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 遍历每个索引，从0到最后一个字符'
- en: '#2 Loops through each lowercase letter'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 遍历每个小写字母'
- en: '#3 If c is a different letter from the letter at index i'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 如果c与索引i处的字母不同'
- en: '#4 Forms a new word by changing the character at index i to character c'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 通过将索引i处的字符替换为字符c来形成一个新单词'
- en: '#5 Adds this new word to our list of words'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 将这个新单词添加到我们的单词列表中'
- en: This code is quite similar to our `add_letter` code! The main difference is
    that we use string slicing not to add a new character but to change an existing
    character.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们的`add_letter`代码非常相似！主要区别在于我们使用字符串切片来改变一个已有的字符，而不是添加一个新字符。
- en: At this point, we’ve completed the three functions we need to implement `all_possible_words`.
    Check out figure 7.6, where we’ve marked off the substantial progress that we’ve
    made! We’ll next tackle `all_possible_words`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了实现`all_possible_words`所需的三个函数。查看图 7.6，我们标出了已取得的重要进展！接下来，我们将处理`all_possible_words`。
- en: '![figure](../Images/7-6.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/7-6.png)'
- en: Figure 7.6 Full functions diagram with `all_possible_words` helper functions
    finished
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.6 完整的函数图，其中`all_possible_words`的辅助函数已完成
- en: 7.7.5 all_possible_words
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.5 all_possible_words
- en: The reason we can now implement `all_possible_words` is that we’ve already implemented
    the three subtask functions that `all_possible_words` needs to do its job. When
    we ask Copilot to write this code, we’re expecting to see calls of `add_letter`,
    `delete_letter`, and `change_letter`. Take a look at listing 7.5, and you’ll see
    Copilot doing exactly this with the prompt we’ve given it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在能够实现`all_possible_words`的原因是，我们已经实现了`all_possible_words`所需的三个子任务函数。当我们要求
    Copilot 编写这段代码时，我们期待看到`add_letter`、`delete_letter`和`change_letter`的调用。查看列表 7.5，你会看到
    Copilot 正是这样做的，并且是根据我们提供的提示。
- en: Listing 7.5 Function to generate all possible words
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.5 生成所有可能单词的函数
- en: '[PRE5]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '#1 Calls helper functions to add a letter and delete a letter'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 调用辅助函数添加一个字母并删除一个字母'
- en: '#2 Calls helper function to change a letter'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 调用辅助函数更改一个字母'
- en: 'Generating all possible words is no easy feat. Yet, we’ve managed to do it
    with a single line of Python code here! It just calls to three helper functions
    and that’s it. This is exactly why we’re doing top-down design: to make complex
    functions much easier to implement by offloading much of their complexity to helper
    functions.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 生成所有可能的单词可不简单。然而，我们通过一行 Python 代码就成功实现了！它仅调用了三个辅助函数，仅此而已。这正是我们进行自顶向下设计的原因：通过将大部分复杂性转移到辅助函数中，使得复杂的函数变得更容易实现。
- en: 7.7.6 all_real_words
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.6 all_real_words
- en: We’re close to being able to implement `get_spelling_suggestions`, but not quite,
    because we first need to implement its subtask function `all_real_words`. The
    `all_ real_words` function takes two parameters. The first parameter is the English
    word list (this will come from an English word list file). The second parameter
    is the list of possible words (this will come from `all_possible_words`). The
    function returns the list of possible words that are real words. Let’s do this!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们离实现`get_spelling_suggestions`已经不远了，但还没有完全完成，因为我们首先需要实现它的子任务函数`all_real_words`。`all_real_words`函数接受两个参数。第一个参数是英文单词列表（来自英文单词列表文件）。第二个参数是可能的单词列表（来自`all_possible_words`）。该函数返回的是那些在`possible_words`中且是实际单词的单词列表。让我们开始吧！
- en: Listing 7.6 Function to generate all real words
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.6 生成所有真实单词的函数
- en: '[PRE6]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '#1 Loops through the possible words'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 遍历可能的单词'
- en: '#2 Is this word a real word?'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 这个词是一个真实单词吗？'
- en: '#3 Yes: add the word to the list of real words that we’ll return'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 是的：将这个单词添加到我们将返回的真实单词列表中'
- en: The test in the docstring is a good example of how this function works. It’s
    using the `english_words` list for the first parameter and the `possible_words`
    list as the second parameter. The function will return those words from `possible_words`
    that are also in `english_words`. We’re using this very small test case, rather
    than using thousands of English words, because this makes it much easier for us
    to determine by hand what the correct return value should be!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串中的测试是这个函数如何工作的一个好例子。它使用`english_words`列表作为第一个参数，`possible_words`列表作为第二个参数。该函数将返回那些既在`possible_words`中又在`english_words`中的单词。我们使用这个非常小的测试案例，而不是使用成千上万的英文单词，是因为这样更容易手动确定正确的返回值！
- en: Let’s check how well we’re progressing in figure 7.7\. We’re getting close—just
    two functions to go!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看图 7.7 中我们的进展如何。我们已经接近完成了——只差两个函数！
- en: '![figure](../Images/7-7.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../Images/7-7.png)'
- en: Figure 7.7 Full functions diagram with `all_possible_words` and `all_real_words`
    finished
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.7 完整的函数图，其中`all_possible_words`和`all_real_words`已完成
- en: 7.7.7 get_spelling_suggestions
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.7 get_spelling_suggestions
- en: We’ve implemented `create_word_list`, `all_possible_words`, and `all_real_words`,
    and those are the only three subtask functions that `get_spelling_suggestions`
    needs. That means it’s time for us to implement `get_spelling_suggestions`!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了`create_word_list`、`all_possible_words`和`all_real_words`，这三个子任务函数正是`get_spelling_suggestions`所需要的。那就意味着，是时候实现`get_spelling_suggestions`了！
- en: 'This function takes two parameters: the name of a file that contains real words
    (one word per line) and the string that we want to provide suggestions for. It
    returns the list of the unique suggestions. As always, when scrutinizing Copilot
    code for a nonleaf function, you want to check that it’s calling the helper functions
    that you expect it to be calling, as shown in listing 7.7\. Before you move on,
    convince yourself that it’s calling all the helper functions that it should be
    calling.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受两个参数：一个包含真实单词（每行一个单词）文件的名称和我们希望提供拼写建议的字符串。它返回唯一拼写建议的列表。像往常一样，在检查Copilot代码中的非叶函数时，你需要确认它正在调用你预期的辅助函数，正如在列表7.7中所示。在继续之前，确保它调用了所有应该调用的辅助函数。
- en: Listing 7.7 Function to return spelling suggestions
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.7 返回拼写建议的函数
- en: '[PRE7]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '#1 Gets the list of English words'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 获取英语单词列表'
- en: '#2 Gets the list of possible words'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 获取可能的单词列表'
- en: '#3 Figures out which possible words are spelling suggestions'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 确定哪些可能的单词是拼写建议'
- en: '#4 Returns the unique list of spelling suggestions'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 返回唯一的拼写建议列表'
- en: 'That last line there is tricky. Apparently, it’s ensuring that we return only
    unique words—but how? Let’s ask Copilot to explain! Here’s the explanation that
    we got when we used the `/explain` command to Copilot:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行很棘手。显然，它确保我们只返回唯一的单词——但怎么做到呢？让我们请Copilot来解释一下！以下是我们在使用`/explain`命令向Copilot请求时得到的解释：
- en: '![chatGpt](../Images/chatGpt.png)Copilot This line of Python code is performing
    two operations:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)Copilot 这行Python代码执行了两个操作：'
- en: '`set(real_words)`: This is creating a set from the `real_words` list. A set
    in Python is an unordered collection of unique elements. So, this operation is
    removing any duplicate elements from the `real_words` list.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`set(real_words)`：这段代码是从`real_words`列表创建一个集合。在Python中，集合是一个无序的唯一元素集合。所以，这个操作会去除`real_words`列表中的任何重复元素。'
- en: '`list(set(real_words))`: This is converting the set back into a list. The result
    is a list where all elements are unique.'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`list(set(real_words))`：这段代码是将集合转换回列表。结果是一个所有元素都是唯一的列表。'
- en: So, in summary, this line of code is removing any duplicate words from the `real_
    words` list.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，这行代码的作用是从`real_words`列表中去除任何重复的单词。
- en: 7.7.8 spell_check
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.8 拼写检查
- en: 'We’ve made it to our final function, `spell_check`! It takes one parameter:
    a string indicating the name of a word list file. It asks the user to type a string,
    and then shows the user all spelling corrections for that string.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到了最后一个函数`spell_check`！它接受一个参数：一个表示单词列表文件名的字符串。它要求用户输入一个字符串，然后向用户展示该字符串的所有拼写更正。
- en: Listing 7.8 Our main function that interacts with the user
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.8 我们的主函数，和用户交互
- en: '[PRE8]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '#1 Asks the user to type a string'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 让用户输入一个字符串'
- en: '#2 Gets the spelling suggestions for the user'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 为用户获取拼写建议'
- en: '#3 Loops through the spelling suggestions'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 遍历拼写建议'
- en: '#4 Prints each spelling suggestion on its own line'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 将每个拼写建议单独打印在一行上'
- en: Consult figure 7.8 to see that we have indeed implemented all of our functions!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅图7.8，确认我们确实已经实现了所有的函数！
- en: '![figure](../Images/7-8.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/7-8.png)'
- en: Figure 7.8 Full functions diagram with all functions complete!
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.8 完整的函数图，所有函数都已完成！
- en: 'You need to add one line of code at the bottom of your Python program to actually
    call this function. Otherwise, your program won’t do anything because no function
    is being called! So, add this line at the bottom:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在Python程序的底部添加一行代码，来实际调用这个函数。否则，你的程序什么也不做，因为没有函数被调用！所以，在底部添加这一行：
- en: '[PRE9]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, assuming that you have the wordlist.txt file in your directory along with
    your Python program, you can run it! It will ask you to type a word. Try typing
    the misspelled word *sucessful* (the word that started it all!), and you should
    see the program provide the spelling suggestion of *successful*, like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你的目录中有`wordlist.txt`文件以及Python程序，你可以运行它！它会让你输入一个单词。试着输入拼写错误的单词*sucessful*（就是那个一开始出问题的单词！），然后你应该会看到程序提供拼写建议*successful*，像这样：
- en: '[PRE10]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Try other misspelled words too, such as *thourough* and *acceptible*. With these
    misspelled words so far, our program is replying with only a single spelling suggestion
    because there is only one real word a single edit away from the words we’re trying.
    We encourage you to try entering the word *carf* to see that our program can provide
    many possible spelling suggestions.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 也尝试其他拼写错误的词，例如*thourough*和*acceptible*。目前为止，程序只给出了一个拼写建议，因为只有一个真正的单词与我们尝试的词只有一次编辑的差距。我们鼓励你尝试输入*carf*，看看程序能否提供多个拼写建议。
- en: Congratulations! You’ve completed your first real-world top-down design. Your
    program provides spelling suggestions for a word, much as a spellchecker does.
    We made the problem considerably easier to implement by doing some up-front design
    work to break down the original problem into smaller subproblems.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你！你已经完成了第一个现实世界的自上而下设计。你的程序为一个单词提供拼写建议，就像拼写检查器一样。通过进行一些前期设计工作，将原始问题分解成更小的子问题，我们使得问题的实现变得更加容易。
- en: 'Many computer scientists view problem decomposition as *the* most critical
    skill needed to write good software [1]. We saw the value of problem decomposition
    in this chapter: it made a large problem solvable by breaking it into smaller
    steps until each step was easier to solve. We applied this skill in this chapter
    using top-down design (start with the large task and break it into smaller tasks)
    to put it in practice. This skill remains critical when working with tools such
    as Copilot and ChatGPT because they perform better when solving small, well-defined
    problems compared to large problems. As mentioned at the beginning of the chapter,
    problem decomposition is more of an art than a science, and it takes practice
    to get it right. We’ll do more problem decomposition in our upcoming chapters
    to help give you more intuition into how to approach it yourself.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 许多计算机科学家认为问题分解是编写优秀软件所需的*最*关键技能[1]。我们在本章中看到了问题分解的价值：通过将一个大问题分解成更小的步骤，直到每个步骤都更容易解决，它使得一个大问题变得可解。我们在本章中通过自上而下的设计（从大任务开始，将其分解成小任务）来实践这一技能。使用像Copilot和ChatGPT这样的工具时，这项技能仍然至关重要，因为它们在解决小而明确的问题时表现更好，而不是解决大问题。如本章开头所提到的，问题分解更多的是一种艺术而非科学，需要通过实践才能掌握。我们将在接下来的章节中做更多问题分解的练习，帮助你更直观地理解如何自己去做。
- en: 7.8 Exercises
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.8 练习
- en: 'Using the examples of `get_strong_password` and `best_word` discussed previously,
    let’s apply the top-down design approach to a new problem. Suppose we want to
    write a function called `find_highest_scoring_word` that takes a list of sentences
    as its parameter and returns the word with the highest score from all the sentences.
    Each word’s score is calculated the same way as in the `best_word` function:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用之前讨论过的`get_strong_password`和`best_word`的示例，采用自上而下的设计方法来解决一个新问题。假设我们要编写一个名为`find_highest_scoring_word`的函数，它接受一个包含多个句子的列表作为参数，并返回所有句子中得分最高的单词。每个单词的得分计算方法与`best_word`函数中的计算方法相同：
- en: Identify the subtasks needed to solve this problem. What are the individual
    functions you would design to break down the task into smaller, manageable pieces?
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定解决此问题所需的子任务。你会设计哪些单独的函数，将任务分解成更小、更易管理的部分？
- en: Draw a function diagram similar to figures 7.1 and 7.2, depicting how these
    functions would call each other to solve the overall problem.
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制一个类似于图7.1和7.2的函数图，描述这些函数如何相互调用来解决整体问题。
- en: We talked about how sometimes a task is simple enough to be kept as it is, that
    is, not broken down into smaller tasks. Given the following tasks, decide if you
    would divide them into smaller subtasks. If so, list the subtasks and explain
    why. If not, explain why the task is simple enough to remain a single function.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们谈到了有时任务足够简单，不需要将其分解成更小的任务。对于以下任务，决定是否将其分解成更小的子任务。如果是，请列出子任务并解释为什么。如果不是，请解释为什么任务足够简单，能够保持为单一函数。
- en: Reading a file and printing its contents
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取一个文件并打印其内容
- en: Calculating the average grade for a class of students from a list of scores
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据学生成绩列表计算班级的平均分
- en: Finding the maximum value in a list of numbers
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个数字列表中查找最大值
- en: Processing an order for an online store, which includes verifying the order,
    calculating the total price, applying discounts, and generating an invoice
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理在线商店订单，包括验证订单、计算总价、应用折扣和生成发票
- en: Why did we choose to create the `create_word_list` function as a separate function?
    Could this task be kept as part of a larger function? Explain your reasoning.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们选择将`create_word_list`函数作为一个单独的函数来创建？这个任务可以作为一个更大函数的一部分吗？请解释你的理由。
- en: Imagine you need to change the way the spell-checker works. Specifically, you
    want to modify the `add_letter` function to exclude certain letters (e.g., *q*,
    *x*, *z*) from being added. How would you modify the program we’ve written?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你需要更改拼写检查器的工作方式。具体来说，你想修改`add_letter`函数，排除某些字母（例如，*q*、*x*、*z*）不被添加。你将如何修改我们写的程序？
- en: The following function processes a list of orders, calculates the total price
    with tax, applies a discount if applicable, and generates a summary report.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下函数处理一个订单列表，计算含税总价，若适用则应用折扣，并生成汇总报告。
- en: '[PRE11]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Refactor (redesign) the `process_orders` function by breaking it down into smaller
    subproblems. Implement each subproblem as a separate function, and ensure the
    overall behavior remains the same.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`process_orders`函数重构（重新设计），将其分解为更小的子问题。将每个子问题实现为一个单独的函数，并确保整体行为保持不变。
- en: '6\. In this exercise, you’re given a code snippet already broken down into
    two functions: a main function and a helper function. When we call the function
    with Test Case 2 in the following code, we get a `ZeroDivisionError`. Your task
    is to identify and fix the error based on the provided error message.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 6\. 在这个练习中，给定了一个已经分解成两个函数的代码片段：一个主函数和一个辅助函数。当我们使用以下代码中的测试用例2调用该函数时，会出现`ZeroDivisionError`。你的任务是根据提供的错误信息识别并修复这个错误。
- en: '[PRE12]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: We need to divide a big programming problem into smaller subproblems before
    we can effectively implement it. This is known as problem decomposition.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们有效实现一个大的编程问题之前，需要将其分解为更小的子问题。这被称为问题分解。
- en: Top-down design is a systematic technique for breaking a problem down into small
    subtask functions.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自顶向下设计是一种将问题分解为小的子任务函数的系统化技术。
- en: In top-down design, we seek small functions that solve well-defined tasks and
    that can be used by one or more other functions.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在自顶向下设计中，我们寻求能够解决明确任务的小函数，这些函数可以被一个或多个其他函数使用。
- en: When we’re ready to implement our functions that arose from top-down design,
    we implement them from the bottom up; that is, we implement the leaf functions
    first, then functions that depend on those leaf functions, and so on until we
    implement the topmost function.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们准备实现从自顶向下设计中产生的函数时，我们是从自底向上实现的；也就是说，我们首先实现叶子函数，然后是依赖于这些叶子函数的函数，依此类推，直到我们实现最顶层的函数。
