- en: Chapter 2\. Automating Files and the Filesystem
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 自动化文件和文件系统
- en: One of Python’s most powerful features is its ability to manipulate text and
    files. In the DevOps world, you are continually parsing, searching, and changing
    the text in files, whether you’re searching application logs or propagating configuration
    files. Files are a means of persisting the state of your data, code, and configuration;
    they are how you look back at what happened in logs and how you control what happens
    with configuration. With Python, you can create, read, and change files and text
    in the code that you can use repeatedly. Automating these tasks is indeed one
    aspect of modern DevOps that separates it from traditional system administration.
    Rather than keeping a set of instructions that you have to follow manually, you
    can write code. This diminishes your chances of missing steps or doing them out
    of order. If you are confident that your system uses the same steps every time
    you run it, you can have greater understanding and confidence in the process.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python 最强大的功能之一是其处理文本和文件的能力。在 DevOps 的世界中，您不断地解析、搜索和更改文件中的文本，无论是搜索应用程序日志还是传播配置文件。文件是持久化数据、代码和配置状态的手段；它们是您查看日志发生的情况和控制配置发生的方式。使用
    Python，您可以在代码中创建、读取和更改文件和文本，以便重复使用。自动化这些任务确实是现代 DevOps 的一个方面，它使其与传统系统管理有所区别。与手动跟随一套指令不同，您可以编写代码。这样可以减少错过步骤或按顺序执行它们的机会。如果您确信每次运行系统时都使用相同的步骤，那么您对过程的理解和信心将会更高。
- en: Reading and Writing Files
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和写入文件
- en: 'You can use the `open` function to create a file object that can read and write
    files. It takes two arguments, the path of the file and the mode (mode optionally
    defaults to reading). You use the mode to indicate, among other things, if you
    want to read or write a file and if it is text or binary data. You can open a
    text file using the mode *r* to read its contents. The file object has a `read`
    method that returns the contents of the file as a string:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`open`函数可以创建一个文件对象，该对象可以读取和写入文件。它接受两个参数，文件路径和模式（模式默认为读取）。您可以使用模式指示是否要读取或写入文件，以及文件是文本还是二进制数据等。您可以使用模式
    *r* 打开文本文件以读取其内容。文件对象具有一个`read`方法，该方法将文件内容作为字符串返回：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-5
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It is a good practice to close a file when you finish with it. Python closes
    a file when it is out of scope, but until then the file consumes resources and
    may prevent other processes from opening it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成文件操作时关闭文件是一个良好的实践。Python 在文件超出范围时会关闭文件，但在此之前文件会消耗资源，并可能阻止其他进程打开它。
- en: 'You can also read a file using the `readlines` method. This method reads the
    file and splits its contents on newline characters. It returns a list of strings.
    Each string is one line of the original text:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `readlines` 方法读取文件。此方法读取文件并根据换行符拆分其内容。它返回一个字符串列表。每个字符串都是原始文本的一行：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A handy way of opening files is to use `with` statements. You do not need to
    close a file explicitly in this case. Python closes it and releases the file resource
    at the end of the indented block:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `with` 语句打开文件的一个便捷方法。在这种情况下，您不需要显式关闭文件。Python 在缩进块结束时关闭文件并释放文件资源：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Different operating systems use different escaped characters to represent line
    endings. Unix systems use `\n` and Windows systems use `\r\n`. Python converts
    these to `\n` when you open a file as text. If you are opening a binary file,
    such as a *.jpeg* image, you are likely to corrupt the data by this conversion
    if you open it as text. You can, however, read binary files by appending a *b*
    to mode:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的操作系统使用不同的转义字符表示换行符。Unix 系统使用 `\n`，而 Windows 系统使用 `\r\n`。Python 在将文件作为文本打开时会将这些转换为
    `\n`。如果您以文本方式打开二进制文件，例如 *.jpeg* 图像，则可能会通过此转换损坏数据。但是，您可以通过在模式后附加 *b* 来读取二进制文件：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Adding this opens the file without any line-ending conversion.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此项将不对行结束进行任何转换。
- en: 'To write to a file, use the write mode, represented as the argument `w`. The
    tool `direnv` is used to automatically set up some development environments. You
    can define environment variables and application runtimes in a file named *.envrc*;
    `direnv` uses it to set these things up when you enter the directory with the
    file. You can set the environment variable `STAGE` to `PROD` and `TABLE_ID` to
    `token-storage-1234` in such a file in Python by using `open` with the `write`
    flag:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要写入文件，使用写入模式，表示为参数`w`。工具`direnv`用于自动设置一些开发环境。您可以在名为*.envrc*的文件中定义环境变量和应用程序运行时；`direnv`在进入带有该文件的目录时使用它来设置这些内容。您可以在Python中使用带有写入标志的`open`来将环境变量`STAGE`设置为`PROD`，`TABLE_ID`设置为`token-storage-1234`：
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Warning
  id: totrans-16
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Be warned that `pathlib`’s `write` method will overwrite a file if it already
    exists.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 警告，如果文件已经存在，`pathlib`的`write`方法将覆盖该文件。
- en: The `open` function creates a file if it does not already exist and overwrites
    if it does. If you want to keep existing contents and only append the file, use
    the append flag `a`. This flag appends new text to the end of the file while keeping
    the original content. If you are writing nontext content, such as the contents
    of a *.jpeg* file, you are likely to corrupt it if you use either the `w` or `a`
    flag. This corruption is likely as Python converts line endings to platform-specific
    ones when it writes text data. To write binary data, you can safely use `wb` or
    `ab`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`open`函数如果文件不存在将创建文件，并且如果存在则覆盖它。如果您想保留现有内容并仅追加文件，请使用追加标志`a`。此标志将新文本追加到文件末尾，同时保留原始内容。如果您正在写入非文本内容，例如*.jpeg*文件的内容，如果使用`w`或`a`标志，可能会导致其损坏。当Python写入文本数据时，它会将行结束符转换为特定于平台的结束符。要写入二进制数据，您可以安全地使用`wb`或`ab`。'
- en: '[Chapter 3](ch03.html#working_with_the_command_line) covers `pathlib` in depth.
    Two useful features are convenience functions for reading and writing files. `pathlib`
    handles the file object behind the scenes. The following allows you to read text
    from a file:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[第三章](ch03.html#working_with_the_command_line)深入介绍了`pathlib`。两个有用的功能是便捷函数用于读取和写入文件。`pathlib`在幕后处理文件对象。以下示例允许您从文件中读取文本：'
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To read binary data, use the `path.read_bytes` method.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取二进制数据，请使用`path.read_bytes`方法。
- en: 'When you want to overwrite a file or write a new file, there are methods for
    writing text and for writing binary data:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要覆盖文件或写入新文件时，有写入文本和写入二进制数据的方法：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Reading and writing using the file object’s `read` and `write` functions is
    usually adequate for unstructured text, but what if you are dealing with more
    complex data? The Javascript Object Notation (JSON) format is widely used to store
    simple structured data in modern web services. It uses two data structures: a
    mapping of key-value pairs similar to a Python `dict` and a list of items somewhat
    similar to a Python `list`. It defines data types for numbers, strings, *booleans*
    (which hold true/false values), and *nulls* (empty values). The AWS Identity and
    Access Management (IAM) web service allows you to control access to AWS resources.
    It uses JSON files to define access policies, as in this sample file:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文件对象的`read`和`write`函数进行读写通常对于非结构化文本已经足够，但是如果你要处理更复杂的数据怎么办？JavaScript对象表示法（JSON）格式被广泛用于在现代Web服务中存储简单的结构化数据。它使用两种数据结构：类似于Python
    `dict`的键-值对映射和类似于Python `list`的项目列表。它定义了数字、字符串、*布尔*（保存true/false值）和*nulls*（空值）的数据类型。AWS身份和访问管理（IAM）Web服务允许您控制对AWS资源的访问。它使用JSON文件来定义访问策略，例如以下示例文件：
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You could use the standard file object `read` or `readlines` methods to get
    the data from such a file:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用标准文件对象的`read`或`readlines`方法从此类文件中获取数据：
- en: '[PRE8]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The result would not be immediately usable, as it would be a single string
    or list of strings, depending on your chosen read method:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可能不能立即使用，因为它将是一个字符串或字符串列表，具体取决于您选择的读取方法：
- en: '[PRE9]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You would then need to parse this string (or strings) into data structures
    and types that match the original, which may be a great deal of work. A far better
    way is to use the `json` module:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要将此字符串（或字符串）解析为与原始数据结构和类型匹配的数据。这可能是一项相当大的工作。更好的方法是使用`json`模块：
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This module parses the JSON format for you, returning the data in appropriate
    Python data structures:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块会为您解析JSON格式，将数据返回为适当的Python数据结构：
- en: '[PRE11]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `pprint` module automatically formats Python objects for printing. Its output
    is often more easily read and is a handy way of looking at nested data structures.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`pprint`模块会自动格式化Python对象以便打印。其输出通常更易读，是查看嵌套数据结构的便捷方式。'
- en: 'Now you can use the data with the original file structure. For example, here
    is how you would change the resource whose access this policy controls to `S3`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用原始文件结构中的数据。例如，这里是如何将该策略控制访问的资源更改为 `S3`：
- en: '[PRE12]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can write a Python dictionary as a JSON file by using the `json.dump` method.
    This is how you would update the policy file you just modified:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `json.dump` 方法将 Python 字典写入 JSON 文件。这就是你更新刚修改的策略文件的方式：
- en: '[PRE13]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Another language commonly used in configuration files is *YAML* (“YAML Ain’t
    Markup Language”). It is a superset of JSON, but has a more compact format, using
    whitespace similar to how Python uses it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常用于配置文件的语言是 *YAML*（“YAML Ain’t Markup Language”）。它是 JSON 的超集，但有更紧凑的格式，使用与
    Python 类似的空白。
- en: 'Ansible is a tool used to automate software configuration, management, and
    deployment. Ansible uses files, referred to as *playbooks*, to define actions
    you want to automate. These playbooks use the YAML format:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 是一个用于自动化软件配置、管理和部署的工具。Ansible 使用称为 *playbooks* 的文件来定义你想要自动化的操作。这些 playbooks
    使用 YAML 格式：
- en: '[PRE14]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The most commonly used library for parsing YAML files in Python is PyYAML.
    It is not in the Python Standard Library, but you can install it using `pip`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Python中最常用的解析YAML文件的库是Py   在 Python 中解析 YAML 文件最常用的库是 PyYAML。它不在 Python 标准库中，但你可以使用
    `pip` 安装它：
- en: '[PRE15]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once installed, you can use PyYAML to import and export YAML data much as you
    did with JSON:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以像处理 JSON 数据那样使用 PyYAML 导入和导出 YAML 数据：
- en: '[PRE16]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The data loads as familiar Python data structures (a `list` containing a `dict`):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 数据加载为熟悉的 Python 数据结构（一个包含 `dict` 的 `list`）：
- en: '[PRE17]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can also save Python data to a file in YAML format:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将 Python 数据保存到 YAML 格式的文件中：
- en: '[PRE18]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Another language widely used for representing structured data is Extensible
    Markup Language (XML). It consists of hierarchical documents of tagged elements.
    Historically, many web systems used XML to transport data. One such use is for
    Real Simple Syndication (RSS) feeds. RSS feeds are used to track and notify users
    of updates to websites and have been used to track the publication of articles
    from various sources. RSS feeds use XML-formatted pages. Python offers the `xml`
    library for dealing with XML documents. It maps the XML documents’ hierarchical
    structure to a tree-like data structure. The nodes of the tree are elements, and
    a parent-child relationship is used to model the hierarchy. The top parent node
    is referred to as the root element. To parse an RSS XML document and get its root:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种广泛用于表示结构化数据的语言是可扩展标记语言（XML）。它由带标签的元素的层次文档组成。历史上，许多 web 系统使用 XML 传输数据。其中一种用途是用于实时简单聚合（RSS）订阅源。RSS
    订阅源用于跟踪和通知用户网站更新，并已被用于跟踪来自各种来源的文章的发布。RSS 订阅源使用 XML 格式的页面。Python 提供了 `xml` 库来处理
    XML 文档。它将 XML 文档的层次结构映射到类似树状的数据结构。树的节点是元素，使用父子关系来建模层次结构。最顶层的父节点称为根元素。要解析一个 RSS
    XML 文档并获取其根节点：
- en: '[PRE19]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can walk down the tree by iterating over the child nodes:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过迭代子节点来遍历树：
- en: '[PRE20]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'XML allows for *namespacing* (using tags to group data). XML prepends tags
    with namespaces enclosed in brackets. If you know the structure of the hierarchy,
    you can search for elements by using their paths. You can supply a dictionary
    that defines namespaces as a convenience:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: XML 允许进行 *命名空间*（使用标签分组数据）。XML 在标签前加上用括号括起来的命名空间。如果你知道层次结构的结构，可以使用路径搜索元素。你可以提供一个定义命名空间的字典，方便使用：
- en: '[PRE21]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You may find yourself dealing with data stored as comma-separated values (CSV).
    This format is common for spreadsheet data. You can use the Python `csv` module
    to read these easily:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到需要处理逗号分隔值（CSV）格式的数据。这个格式常用于电子表格数据。你可以使用 Python 的 `csv` 模块轻松读取这些数据：
- en: '[PRE22]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `csv` reader object iterates through the *.csv* file one line at a time,
    allowing you to process the data one row at a time. Processing a file this way
    is especially useful for large *.csv* files that you do not want to read into
    memory all at once. Of course, if you need to do multiple row calculations across
    columns and the file is not overly large, you should load it all at once.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`csv` 读取器对象逐行遍历 *.csv* 文件，让你可以逐行处理数据。以这种方式处理文件对于不希望一次性读取到内存的大 *.csv* 文件特别有用。当然，如果你需要进行跨列的多行计算且文件不太大，你应该一次性加载所有数据。'
- en: 'The Pandas package is a mainstay in the data science world. It includes a data
    structure, the `pandas.DataFrame`, which acts like a data table, similar to a
    very powerful spreadsheet. If you have table-like data on which you want to do
    statistical analysis or that you want to manipulate by rows and columns, DataFrames
    is the tool for you. It is a third-party library, so you need to install it with
    `pip`. You can use a variety of methods to load data into the DataFrames; one
    of the most common is from a *.csv* file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas包是数据科学界的主要工具。它包括一个数据结构，`pandas.DataFrame`，它的作用类似于非常强大的电子表格。如果您有类似表格的数据，想要进行统计分析或者按行和列进行操作，DataFrame是您的工具。它是一个第三方库，因此您需要使用`pip`安装它。您可以使用各种方法将数据加载到DataFrame中；其中最常见的方法之一是从*.csv*文件中加载：
- en: '[PRE23]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can take a look at the top rows of your DataFrame using the `head` method:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`head`方法查看DataFrame的前几行：
- en: '[PRE24]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can get a statistical insight using the `describe` method:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`describe`方法获得统计洞见：
- en: '[PRE25]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Alternatively, you can view a single column of data by using its name in square
    brackets:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用方括号中的名称查看单列数据：
- en: '[PRE26]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Pandas has many more methods for analyzing and manipulating table-like data,
    and there are many books on its use. It is a tool you should be aware of if you
    have the need to do data analysis.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas有更多用于分析和操作类似表格的数据的方法，也有许多关于其使用的书籍。如果您需要进行数据分析，那么这是您应该了解的工具。
- en: Using Regular Expressions to Search Text
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式搜索文本
- en: 'The Apache HTTP server is an open source web server widely used to serve web
    content. The web server can be configured to save log files in different formats.
    One widely used format is the Common Log Format (CLF). A variety of log analysis
    tools can understand this format. Below is the layout of this format:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Apache HTTP服务器是一个广泛用于提供Web内容的开源Web服务器。Web服务器可以配置为以不同的格式保存日志文件。一个广泛使用的格式是通用日志格式（CLF）。各种日志分析工具都能理解这种格式。以下是此格式的布局：
- en: '[PRE27]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'What follows is an example line from a log in this format:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这种格式的日志的示例行：
- en: '[PRE28]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[Chapter 1](ch01.html#python_essentials_for_devops) introduced you to regular
    expressions and the Python `re` module, so let’s use it to pull information from
    a log in the common log format. One trick to constructing regular expressions
    is to do it in sections. Doing so enables you to get each subexpression working
    without the complication of debugging the whole expression. You can create a regular
    expression using named groups to pull out the IP address from a line:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[第一章](ch01.html#python_essentials_for_devops)向您介绍了正则表达式和Python的`re`模块，所以让我们使用它从常见日志格式中提取信息。构建正则表达式的一个技巧是分段进行。这样做可以使您让每个子表达式都能正常工作，而不必调试整个表达式。您可以使用命名组创建正则表达式来从一行中提取IP地址：'
- en: '[PRE29]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can also create a regular expression to get the time:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建一个正则表达式来获取时间：
- en: '[PRE30]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can grab multiple elements, as has been done here: the IP, user, time,
    and request:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像这样获取多个元素：IP、用户、时间和请求：
- en: '[PRE31]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Parsing a single line of a log is interesting but not terribly useful. However,
    you can use this regular expression as a basis for designing one to pull information
    from the whole log. Let’s say you want to pull all of the IP addresses for `GET`
    requests that happened on November 8, 2019\. Using the preceding expression, you
    make modifications based on the specifics of your request:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 解析日志的单行很有趣，但不是非常有用。但是，您可以使用这个正则表达式作为从整个日志中提取信息的基础。假设您想要提取2019年11月8日发生的所有`GET`请求的所有IP地址。使用前面的表达式，根据您请求的具体情况进行修改：
- en: '[PRE32]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Use the `finditer` method to process the log, printing the IP addresses of
    the matching lines:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`finditer`方法处理日志，打印匹配行的IP地址：
- en: '[PRE33]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There is a lot that you can do with regular expressions and texts of all sorts.
    If they do not daunt you, you will find them one of the most powerful tools in
    dealing with text.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多可以用正则表达式和各种文本做的事情。如果它们不使你畏惧，你会发现它们是处理文本最强大的工具之一。
- en: Dealing with Large Files
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理大文件
- en: There are times that you need to process very large files. If the files contain
    data that can be processed one line at a time, the task is easy with Python. Rather
    than loading the whole file into memory as you have done up until now, you can
    read one line at a time, process the line, and then move to the next. The lines
    are removed from memory automatically by Python’s garbage collector, freeing up
    memory.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要处理非常大的文件。如果文件包含可以一次处理一行的数据，则使用Python很容易。与其像您到目前为止所做的那样将整个文件加载到内存中，您可以一次读取一行，处理该行，然后继续下一个。Python的垃圾收集器会自动从内存中删除这些行，释放内存。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Python automatically allocates and frees memory. Garbage collection is one means
    of doing this. The Python garbage collector can be controlled using the `gc` package,
    though this is rarely needed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Python会自动分配和释放内存。垃圾收集是一种方法。Python的垃圾收集器可以使用`gc`包进行控制，尽管这很少需要。
- en: 'The fact that operating systems use alternate line endings can be a hassle
    when reading a file created on a different OS. Windows-created files have `\r`
    characters in addition to `\n`. These show up as part of the text on a Linux-based
    system. If you have a large file and you want to correct the line endings to fit
    your current OS, you can open the file, read one line at a time, and save it to
    a new file. Python handles the line-ending translation for you:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统使用替代行结束符时，读取在不同操作系统上创建的文件可能会很麻烦。Windows创建的文件除了`\n`外还有`\r`字符。这些字符在Linux系统中显示为文本的一部分。如果您有一个大文件，并且希望校正行结束符以适应当前操作系统，您可以打开文件，一次读取一行，并将其保存到新文件中。Python会为您处理行结束符的转换：
- en: '[PRE34]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Notice that you can nest the `with` statements to open two files at once and
    loop through the source file object one line at a time. You can define a generator
    function to handle this, especially if you need to parse multiple files a single
    line at a time:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您可以嵌套`with`语句以同时打开两个文件，并逐行处理源文件对象。如果需要一次处理多个文件的单行，可以定义生成器函数来处理：
- en: '[PRE35]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you do not or cannot use line endings as a means of breaking up your data,
    as in the case of a large binary file, you can read your data in chunks. You pass
    the number of bytes read in each chunk to the file objects `read` method. When
    there is nothing left to read, the expression returns an empty string:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不使用行结束符来分隔数据，如大型二进制文件的情况，则可以按块读取数据。您将每个块中读取的字节数传递给文件对象的`read`方法。当没有剩余内容可读时，表达式将返回空字符串：
- en: '[PRE36]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Encrypting Text
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密文本
- en: There are many times you need to encrypt text to ensure security. In addition
    to Python’s built-in package `hashlib`, there is a widely used third-party package
    called `cryptography`. Let’s take a look at both.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您有许多时候需要加密文本以确保安全性。除了Python的内置包`hashlib`外，还有一个广泛使用的第三方包称为`cryptography`。让我们来看看它们。
- en: Hashing with Hashlib
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Hashlib进行哈希处理
- en: 'To be secure, user passwords must be stored encrypted. A common way to handle
    this is to use a one-way function to encrypt the password into a bit string, which
    is very hard to reverse engineer. Functions that do this are called *hash functions*.
    In addition to obscuring passwords, hash functions ensure that documents sent
    over the web are unchanged during transmission. You run the hash function on the
    document and send the result along with the document. The recipient can then confirm
    that the value is the same when they hash the document. The `hashlib` includes
    secure algorithms for doing this, including *SHA1*, *SHA224*, *SHA384*, *SHA512*,
    and RSA’s *MD5*. This is how you would hash a password using the MD5 algorithm:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，用户密码必须加密存储。处理这一常见方法是使用单向函数将密码加密成位串，这样很难进行逆向工程。执行此操作的函数称为*哈希函数*。除了遮蔽密码外，哈希函数还确保在传输过程中未更改的文档。您对文档运行哈希函数并将结果与文档一起发送。接收者可以通过对文档进行哈希验证值是否相同。`hashlib`包括用于执行此操作的安全算法，包括*SHA1*、*SHA224*、*SHA384*、*SHA512*和RSA的*MD5*。这是使用MD5算法对密码进行哈希的方法：
- en: '[PRE37]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Notice that if your password or document is a string, you need to turn it into
    a binary string by using the `encode` method.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果您的密码或文档是字符串，则需要使用`encode`方法将其转换为二进制字符串。
- en: Encryption with Cryptography
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用密码学进行加密
- en: 'The `cryptography` library is a popular choice for handling encryption problems
    in Python. It is a third-party package, so you must install it with `pip`. *Symmetric
    key encryption* is a group of encryption algorithms based on shared keys. These
    algorithms include Advanced Encryption Algorithm (AES), Blowfish, Data Encryption
    Standard (DES), Serpent, and Twofish. A shared key is similar to a password that
    is used to both encrypt and decrypt text. The fact that both the creator and the
    reader of an encrypted file need to share the key is a drawback when compared
    to *asymmetric key encryption*, which we will touch on later. However, symmetric
    key encryption is faster and more straightforward, and so is appropriate for encrypting
    large files. Fernet is an implementation of the popular AES algorithm. You first
    need to generate a key:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`cryptography`库是Python中处理加密问题的热门选择。它是一个第三方包，所以你必须使用`pip`安装它。*对称密钥加密*是一组基于共享密钥的加密算法。这些算法包括高级加密标准（AES）、Blowfish、数据加密标准（DES）、Serpent和Twofish。共享密钥类似于用于加密和解密文本的密码。与稍后我们将讨论的*非对称密钥加密*相比，创建者和读者都需要共享密钥这一事实是其缺点。然而，对称密钥加密更快更简单，因此适合加密大文件。Fernet是流行AES算法的实现。你首先需要生成一个密钥：'
- en: '[PRE38]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You need to store this key securely, as you need it to decrypt. Keep in mind
    that anyone who has access to it is also able to decrypt your files. If you choose
    to save the key to a file, use the binary data type. The next step is to encrypt
    the data using the `Fernet` object:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要安全存储这个密钥，因为你需要它来解密。请记住，任何有权访问它的人也能解密你的文件。如果选择将密钥保存到文件中，请使用二进制数据类型。下一步是使用`Fernet`对象加密数据：
- en: '[PRE39]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can decrypt the data using a `Fernet` object created with the same key:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用使用相同密钥创建的`Fernet`对象解密数据：
- en: '[PRE40]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Asymmetric key encryption uses a pair of keys, one public and one private.
    The public key is designed to be widely shared, while a single user holds the
    private one. The only way you can decrypt messages that have been encrypted using
    your public key is by using your private key. This style of encryption is widely
    used to pass information confidentially both on local networks and across the
    internet. One very popular asymmetric key algorithm is Rivest-Shamir-Adleman (RSA),
    which is widely used for communication across networks. The cryptography library
    offers the ability to create public/private key pairs:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称加密使用一对密钥，一个是公钥，一个是私钥。公钥设计为广泛共享，而单个用户持有私钥。只有使用私钥才能解密使用你的公钥加密的消息。这种加密方式被广泛用于在本地网络和互联网上保密传递信息。一个非常流行的非对称密钥算法是Rivest-Shamir-Adleman（RSA），它被广泛用于网络通信。加密库提供了创建公钥/私钥对的能力：
- en: '[PRE41]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can then use the public key to encrypt:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以使用公钥进行加密：
- en: '[PRE42]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can use the private key to decrypt messages:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用私钥解密消息：
- en: '[PRE43]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The os Module
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: os模块
- en: The `os` module is one of the most used modules in Python. This module handles
    many low-level operating system calls and attempts to offer a consistent interface
    across multiple operating systems, which is important if you think your application
    might run on both Windows and Unix-based systems. It does offer some operating-specific
    features (`os.O_TEXT` for Windows and `os.O_CLOEXEC` on Linux) that are not available
    across platforms. Use these only if you are confident that your application does
    not need to be portable across operating systems. [Example 2-1](#Example-2-1)
    shows some of the most useful additional methods of the `os` module.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`os`模块是Python中最常用的模块之一。这个模块处理许多低级操作系统调用，并尝试在多个操作系统之间提供一致的接口，如果你的应用程序可能在Windows和Unix-based系统上运行，这点非常重要。它确实提供了一些特定于操作系统的特性（在Windows上为`os.O_TEXT`，在Linux上为`os.O_CLOEXEC`），这些特性跨平台不可用。只有在确信你的应用程序不需要在操作系统之间可移植时才使用这些特性。[示例
    2-1](#Example-2-1)展示了`os`模块中一些最有用的附加方法。'
- en: Example 2-1\. More os methods
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-1. 更多os方法
- en: '[PRE44]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[![1](assets/1.png)](#co_automating_files_and_the_filesystem_CO1-1)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_automating_files_and_the_filesystem_CO1-1)'
- en: List the contents of a directory.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列出目录的内容。
- en: '[![2](assets/2.png)](#co_automating_files_and_the_filesystem_CO1-2)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_automating_files_and_the_filesystem_CO1-2)'
- en: Rename a file or directory.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 重命名文件或目录。
- en: '[![3](assets/3.png)](#co_automating_files_and_the_filesystem_CO1-3)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_automating_files_and_the_filesystem_CO1-3)'
- en: Change the permission settings of a file or directory.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 更改文件或目录的权限设置。
- en: '[![4](assets/4.png)](#co_automating_files_and_the_filesystem_CO1-4)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_automating_files_and_the_filesystem_CO1-4)'
- en: Create a directory.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个目录。
- en: '[![5](assets/5.png)](#co_automating_files_and_the_filesystem_CO1-5)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_automating_files_and_the_filesystem_CO1-5)'
- en: Recursively create a directory path.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 递归创建目录路径。
- en: '[![6](assets/6.png)](#co_automating_files_and_the_filesystem_CO1-6)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_automating_files_and_the_filesystem_CO1-6)'
- en: Delete a file.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 删除文件。
- en: '[![7](assets/7.png)](#co_automating_files_and_the_filesystem_CO1-7)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_automating_files_and_the_filesystem_CO1-7)'
- en: Delete a single directory.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 删除单个目录。
- en: '[![8](assets/8.png)](#co_automating_files_and_the_filesystem_CO1-8)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_automating_files_and_the_filesystem_CO1-8)'
- en: Delete a tree of directories, starting with the leaf directory and working up
    the tree. The operation stops with the first nonempty directory.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 删除一棵目录树，从叶子目录开始向上遍历树。该操作会在遇到第一个非空目录时停止。
- en: '[![9](assets/9.png)](#co_automating_files_and_the_filesystem_CO1-9)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_automating_files_and_the_filesystem_CO1-9)'
- en: Get stats about the file or directory. These stats include `st_mode`, the file
    type and permissions, and `st_atime`, the time the item was last accessed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 获取文件或目录的统计信息。这些统计信息包括 `st_mode`，文件类型和权限，以及 `st_atime`，项目上次访问的时间。
- en: Managing Files and Directories Using os.path
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `os.path` 管理文件和目录
- en: 'In Python, you can use strings (binary or otherwise) to represent paths. The
    `os.path` module offers a plethora of path-related methods for creating and manipulating
    paths as strings. As previously mentioned, the `os` module tries to offer cross-platform
    behaviors, and the `os.path` submodule is no exception. This module interprets
    paths based on the current operating system, using forward slashes to separate
    directories in Unix-like systems and backward slashes in Windows. Your program
    can construct paths on the fly that work on the current system, whichever it is.
    The ability to easily split and join paths is probably the most used functionality
    of `os.path`. The three methods used to split paths are `split`, `basename`, and
    `dirname`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，您可以使用字符串（无论是二进制还是其他）来表示路径。`os.path` 模块提供了大量用于创建和操作路径的方法。如前所述，`os`
    模块尝试提供跨平台行为，`os.path` 子模块也不例外。该模块根据当前操作系统解释路径，Unix-like 系统中使用斜杠分隔目录，Windows 中使用反斜杠。您的程序可以动态构造适合当前系统的路径。轻松拆分和连接路径可能是
    `os.path` 最常用的功能之一。用于拆分路径的三个方法是 `split`，`basename` 和 `dirname`：
- en: '[PRE45]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[![1](assets/1.png)](#co_automating_files_and_the_filesystem_CO2-1)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_automating_files_and_the_filesystem_CO2-1)'
- en: Get the current working directory.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 获取当前工作目录。
- en: '[![2](assets/2.png)](#co_automating_files_and_the_filesystem_CO2-2)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_automating_files_and_the_filesystem_CO2-2)'
- en: '`os.path.split` splits the leaf level of the path from the parent path.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.path.split` 将路径的叶级与父路径分开。'
- en: '[![3](assets/3.png)](#co_automating_files_and_the_filesystem_CO2-3)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_automating_files_and_the_filesystem_CO2-3)'
- en: '`os.path.dirname` returns the parent path.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.path.dirname` 返回父路径。'
- en: '[![4](assets/4.png)](#co_automating_files_and_the_filesystem_CO2-4)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_automating_files_and_the_filesystem_CO2-4)'
- en: '`os.path.basename` returns the leaf name.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.path.basename` 返回叶子名称。'
- en: 'You can easily use `os.path.dirname` to walk up a directory tree:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以轻松使用 `os.path.dirname` 来向上遍历目录树：
- en: '[PRE46]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Using files to configure an application at runtime is a common practice; files
    in Unix-like systems are named by convention as dotfiles ending with *rc*. Vim’s
    *.vimrc* file and the Bash shell’s *.bashrc* are two common examples. You can
    store these files in different locations. Often programs will define a hierarchy
    of locations to check. For example, your tool might look first for an environment
    variable that defines which *rc* file to use, and in its absence, check the working
    directory, and then the user’s home directory. In [Example 2-2](#Example-2-2)
    we try to locate an *rc* file in these locations. We use the `*file*` variable
    that Python automatically sets when Python code runs from a file. This variable
    is populated with a path relative to the current working directory, not an absolute
    or full path. Python does not automatically expand paths, as is common in Unix-like
    systems, so we must expand this path before we use it to construct the path to
    check our *rc* file. Similarly, Python does not automatically expand environment
    variables in paths, so we must expand these explicitly.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时使用文件配置应用程序是常见的做法；Unix-like系统中的文件通常按照以*rc*结尾的约定命名。Vim的*.vimrc*文件和Bash shell的*.bashrc*是两个常见的示例。您可以将这些文件存储在不同的位置。通常，程序会定义一个层次结构来检查这些位置。例如，您的工具可能首先查找一个定义了要使用的*rc*文件的环境变量，如果没有找到，则检查工作目录，然后是用户主目录。在[示例 2-2](#Example-2-2)中，我们尝试在这些位置中找到一个*rc*文件。我们使用Python自动设置的`*file*`变量，该变量是相对于当前工作目录的路径，而不是绝对路径或完整路径。Python不会自动展开路径，这在类Unix系统中很常见，因此在使用它构建要检查的*rc*文件路径之前，我们必须将此路径展开。同样，Python不会自动展开路径中的环境变量，因此我们必须显式展开这些变量。
- en: Example 2-2\. find_rc method
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-2\. find_rc 方法
- en: '[PRE47]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[![1](assets/1.png)](#co_automating_files_and_the_filesystem_CO3-1)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_automating_files_and_the_filesystem_CO3-1)'
- en: Check whether the environment variable exists in the current environment.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 检查当前环境中是否存在环境变量。
- en: '[![2](assets/2.png)](#co_automating_files_and_the_filesystem_CO3-2)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_automating_files_and_the_filesystem_CO3-2)'
- en: Use `join` to construct a path with the environment variable name. This will
    look something like `$EXAMPLERC_DIR/.examplerc`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`join`结合环境变量名构建路径。这将看起来像是`$EXAMPLERC_DIR/.examplerc`。
- en: '[![3](assets/3.png)](#co_automating_files_and_the_filesystem_CO3-3)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_automating_files_and_the_filesystem_CO3-3)'
- en: Expand the environment variable to insert its value into the path.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 展开环境变量以将其值插入路径中。
- en: '[![4](assets/4.png)](#co_automating_files_and_the_filesystem_CO3-4)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_automating_files_and_the_filesystem_CO3-4)'
- en: Check to see if the file exists.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 检查文件是否存在。
- en: '[![5](assets/5.png)](#co_automating_files_and_the_filesystem_CO3-5)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_automating_files_and_the_filesystem_CO3-5)'
- en: Construct a path using the current working directory.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用当前工作目录构建路径。
- en: '[![6](assets/6.png)](#co_automating_files_and_the_filesystem_CO3-6)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_automating_files_and_the_filesystem_CO3-6)'
- en: Use the `expanduser` function to get the path to the user’s home directory.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`expanduser`函数获取用户主目录的路径。
- en: '[![7](assets/7.png)](#co_automating_files_and_the_filesystem_CO3-7)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_automating_files_and_the_filesystem_CO3-7)'
- en: Expand the relative path stored in `*file*` to an absolute path.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 将存储在`*file*`中的相对路径扩展为绝对路径。
- en: '[![8](assets/8.png)](#co_automating_files_and_the_filesystem_CO3-8)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_automating_files_and_the_filesystem_CO3-8)'
- en: Use `dirname` to get the path to the directory holding the current file.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dirname`获取当前文件所在目录的路径。
- en: The `path` submodule also offers ways to interrogate stats about a path. You
    can determine if a path is a file, a directory, a link, or a mount. You can get
    stats such as it’s size or time of last access or modification. In [Example 2-3](#Example-2-3)
    we use `path` to walk down a directory tree and report on the size and last access
    time of all files therein.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`path`子模块还提供了查询路径统计信息的方法。您可以确定路径是文件、目录、链接还是挂载点。您可以获取大小、最后访问时间或修改时间等统计信息。在[示例 2-3](#Example-2-3)中，我们使用`path`遍历目录树，并报告其中所有文件的大小和最后访问时间。'
- en: Example 2-3\. os_path_walk.py
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-3\. os_path_walk.py
- en: '[PRE48]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[![1](assets/1.png)](#co_automating_files_and_the_filesystem_CO4-1)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_automating_files_and_the_filesystem_CO4-1)'
- en: '`os.listdir` returns the contents of a directory.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.listdir`返回目录的内容。'
- en: '[![2](assets/2.png)](#co_automating_files_and_the_filesystem_CO4-2)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_automating_files_and_the_filesystem_CO4-2)'
- en: Construct the full path of an item in the parent directory.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 构建父目录中项目的完整路径。
- en: '[![3](assets/3.png)](#co_automating_files_and_the_filesystem_CO4-3)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_automating_files_and_the_filesystem_CO4-3)'
- en: Check to see if the path represents a file.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 检查路径是否表示一个文件。
- en: '[![4](assets/4.png)](#co_automating_files_and_the_filesystem_CO4-4)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_automating_files_and_the_filesystem_CO4-4)'
- en: Get the last time the file was accessed.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 获取文件上次访问的时间。
- en: '[![5](assets/5.png)](#co_automating_files_and_the_filesystem_CO4-5)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_automating_files_and_the_filesystem_CO4-5)'
- en: Get the size of the file.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 获取文件的大小。
- en: '[![6](assets/6.png)](#co_automating_files_and_the_filesystem_CO4-6)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_automating_files_and_the_filesystem_CO4-6)'
- en: Check if the path represents a directory.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 检查路径是否表示目录。
- en: '[![7](assets/7.png)](#co_automating_files_and_the_filesystem_CO4-7)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_automating_files_and_the_filesystem_CO4-7)'
- en: Check the tree from this directory down.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 从此目录向下检查树。
- en: You could use a script like this to identify large files or files that have
    not been accessed and then report, move, or delete them.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用类似于此的脚本来识别大文件或未访问的文件，然后报告、移动或删除它们。
- en: Walking Directory Trees Using os.walk
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 os.walk 遍历目录树
- en: The `os` module offers a convenience function for walking directory trees called
    `os.walk`. This function returns a generator that in turn returns a tuple for
    each iteration. The tuple consists of the current path, a list of directories,
    and a list of files. In [Example 2-4](#Example-2-4) we rewrite our `walk_path`
    function from [Example 2-3](#Example-2-3) to use `os.walk`. As you can see in
    this example, with `os.walk` you don’t need to test which paths are files or recall
    the function with every subdirectory.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`os` 模块提供了一个便捷的函数用于遍历目录树，称为 `os.walk`。该函数返回一个生成器，依次返回每个迭代的元组。该元组包括当前路径、目录列表和文件列表。在
    [示例 2-4](#Example-2-4) 中，我们重新编写了来自 [示例 2-3](#Example-2-3) 的 `walk_path` 函数，以使用
    `os.walk`。正如您在此示例中看到的那样，使用 `os.walk`，您无需测试哪些路径是文件，也无需在每个子目录中重新调用函数。'
- en: Example 2-4\. Rewrite walk_path
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-4\. 重写 walk_path
- en: '[PRE49]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Paths as Objects with Pathlib
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Pathlib 作为对象的路径
- en: The `pathlib` library represents paths as objects rather than strings. In [Example 2-5](#Example-2-5)
    we rewrite [Example 2-2](#Example-2-2) using `pathlib` rather than `os.path`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`pathlib` 库将路径表示为对象而不是字符串。在 [示例 2-5](#Example-2-5) 中，我们使用 `pathlib` 而不是 `os.path`
    重写了 [示例 2-2](#Example-2-2)。'
- en: Example 2-5\. rewrite find_rc
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-5\. 重写 find_rc
- en: '[PRE50]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[![1](assets/1.png)](#co_automating_files_and_the_filesystem_CO5-1)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_automating_files_and_the_filesystem_CO5-1)'
- en: As of this writing, `pathlib` does not expand environment variables. Instead
    you grab the value of the variable from `os.environ`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，`pathlib` 不会展开环境变量。相反，您可以从 `os.environ` 中获取变量的值。
- en: '[![2](assets/2.png)](#co_automating_files_and_the_filesystem_CO5-2)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_automating_files_and_the_filesystem_CO5-2)'
- en: This creates a `pathlib.Path` object appropriate for the currently running operating
    system.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建适用于当前运行操作系统的 `pathlib.Path` 对象。
- en: '[![3](assets/3.png)](#co_automating_files_and_the_filesystem_CO5-3)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_automating_files_and_the_filesystem_CO5-3)'
- en: You can construct new `pathlib.Path` objects by following a parent path with
    forward slashes and strings.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在父路径后跟正斜杠和字符串来构建新的 `pathlib.Path` 对象。
- en: '[![4](assets/4.png)](#co_automating_files_and_the_filesystem_CO5-4)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_automating_files_and_the_filesystem_CO5-4)'
- en: The `pathlib.Path` object itself has an `exists` method.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`pathlib.Path` 对象本身具有 `exists` 方法。'
- en: '[![5](assets/5.png)](#co_automating_files_and_the_filesystem_CO5-5)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_automating_files_and_the_filesystem_CO5-5)'
- en: Call `as_postix` to return the path as a string. Depending on your use case,
    you can return the `pathlib.Path` object itself.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `as_postix` 以将路径作为字符串返回。根据您的用例，您可以返回 `pathlib.Path` 对象本身。
- en: '[![6](assets/6.png)](#co_automating_files_and_the_filesystem_CO5-6)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_automating_files_and_the_filesystem_CO5-6)'
- en: The class method `pathlib.Path.cwd` returns a `pathlib.Path` object for the
    current working directory. This object is used immediately here to create the
    `config_path` by joining it with the string `rc_name`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法 `pathlib.Path.cwd` 返回当前工作目录的 `pathlib.Path` 对象。此对象在此处立即用于通过与字符串 `rc_name`
    连接来创建 `config_path`。
- en: '[![7](assets/7.png)](#co_automating_files_and_the_filesystem_CO5-7)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_automating_files_and_the_filesystem_CO5-7)'
- en: The class method `pathlib.Path.home` returns a `pathlib.Path` object for the
    current user’s home directory.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法 `pathlib.Path.home` 返回当前用户的主目录的 `pathlib.Path` 对象。
- en: '[![8](assets/8.png)](#co_automating_files_and_the_filesystem_CO5-8)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_automating_files_and_the_filesystem_CO5-8)'
- en: Create a `pathlib.Path` object using the relative path stored in `*file*` and
    then call its `resolve` method to get the absolute path.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用存储在 `*file*` 中的相对路径创建 `pathlib.Path` 对象，然后调用其 `resolve` 方法以获取绝对路径。
- en: '[![9](assets/9.png)](#co_automating_files_and_the_filesystem_CO5-9)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_automating_files_and_the_filesystem_CO5-9)'
- en: This returns a parent `pathlib.Path` object directly from the object itself.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这将直接从对象本身返回一个父级`pathlib.Path`对象。
