- en: 'Chapter 2\. Data: Types, Values, Variables, and Names'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good name is rather to be chosen than great riches.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Proverbs 22:1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Under the hood, everything in your computer is just a sequence of *bits* (see
    [Appendix A](app01.html#app_computers)). One of the insights of computing is that
    we can interpret those bits any way we want—as data of various sizes and types
    (numbers, text characters) or even as computer code itself. We use Python to define
    chunks of these bits for different purposes, and to get them to and from the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: We begin with Python’s data *types* and the *values* that they can contain.
    Then we see how to represent data as *literal* values and *variables*.
  prefs: []
  type: TYPE_NORMAL
- en: Python Data Are Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can visualize your computer’s memory as a long series of shelves. Each slot
    on one of those memory shelves is one byte wide (eight bits), and slots are numbered
    from 0 (the first) to the end. Modern computers have billions of bytes of memory
    (gigabytes), so the shelves would fill a huge imaginary warehouse.
  prefs: []
  type: TYPE_NORMAL
- en: A Python program is given access to some of your computer’s memory by your operating
    system. That memory is used for the code of the program itself, and the data that
    it uses. The operating system ensures that the program cannot read or write other
    memory locations without somehow getting permission.
  prefs: []
  type: TYPE_NORMAL
- en: Programs keep track of *where* (memory location) their bits are, and *what*
    (data type) they are. To your computer, it’s all just bits. The same bits mean
    different things, depending on what type we say they are. The same bit pattern
    might stand for the integer `65` or the text character `A`.
  prefs: []
  type: TYPE_NORMAL
- en: Different types may use different numbers of bits. When you read about a “64-bit
    machine,” this means that an integer uses 64 bits (8 bytes).
  prefs: []
  type: TYPE_NORMAL
- en: Some languages plunk and pluck these raw values in memory, keeping track of
    their sizes and types. Instead of handling such raw data values directly, Python
    wraps each data value—booleans, integers, floats, strings, even large data structures,
    functions, and programs—in memory as an *object*. There’s a whole chapter ([Chapter 10](ch10.html#ch_objects))
    on how to define your own objects in Python. For now, we’re just talking about
    objects that handle the basic built-in data types.
  prefs: []
  type: TYPE_NORMAL
- en: Using the memory shelves analogy, you can think of objects as variable-sized
    boxes occupying spaces on those shelves, as shown in [Figure 2-1](#fig_box). Python
    makes these object boxes, puts them in empty spaces on the shelves, and removes
    them when they’re no longer used.
  prefs: []
  type: TYPE_NORMAL
- en: '![inp2 0201](assets/inp2_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. An object is like a box; this one is an integer with value `7`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In Python, an object is a chunk of data that contains at least the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A *type* that defines what it can do (see the next section)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unique *id* to distinguish it from other objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *value* consistent with its type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *reference count* that tracks how often this object is used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its *id* is like its location on the shelf, a unique identifier. Its *type*
    is like a factory stamp on the box, saying what it can do. If a Python object
    is an integer, it has the type `int`, and could (among other things, which you’ll
    see in [Chapter 3](ch03.html#ch_numbers)) be added to another `int`. If we picture
    the box as being made of clear plastic, we can see the *value* inside. You’ll
    learn the use of the *reference count* a few sections from now, when we talk about
    variables and names.
  prefs: []
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Table 2-1](#table0201) shows the basic data types in Python. The second column
    (Type) contains the Python name of that type. The third column (Mutable?) indicates
    whether the value can be changed after creation, which I explain more in the next
    section. Examples shows one or more literal examples of that type. And the final
    column (Chapter) points you to the chapter in this book with the most details
    on this type.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-1\. Python’s basic data types
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Type | Mutable? | Examples | Chapter |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Boolean | `bool` | no | `True`, `False` | [Chapter 3](ch03.html#ch_numbers)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Integer | `int` | no | `47`, `25000`, `25_000` | [Chapter 3](ch03.html#ch_numbers)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Floating point | `float` | no | `3.14`, `2.7e5` | [Chapter 3](ch03.html#ch_numbers)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Complex | `complex` | no | `3j`, `5 + 9j` | [Chapter 22](ch22.html#ch_science)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Text string | `str` | no | `''alas''`, `"alack"`, `''''''a verse attack''''''`
    | [Chapter 5](ch05.html#ch_strings) |'
  prefs: []
  type: TYPE_TB
- en: '| List | `list` | yes | `[''Winken'', ''Blinken'', ''Nod'']` | [Chapter 7](ch07.html#ch_lists)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Tuple | `tuple` | no | `(2, 4, 8)` | [Chapter 7](ch07.html#ch_lists) |'
  prefs: []
  type: TYPE_TB
- en: '| Bytes | `bytes` | no | `b''ab\xff''` | [Chapter 12](ch12.html#ch_munging)
    |'
  prefs: []
  type: TYPE_TB
- en: '| ByteArray | `bytearray` | yes | `bytearray(...)` | [Chapter 12](ch12.html#ch_munging)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Set | `set` | yes | `set([3, 5, 7])` | [Chapter 8](ch08.html#ch_dicts) |'
  prefs: []
  type: TYPE_TB
- en: '| Frozen set | `frozenset` | no | `frozenset([''Elsa'', ''Otto''])` | [Chapter 8](ch08.html#ch_dicts)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Dictionary | `dict` | yes | `{''game'': ''bingo'', ''dog'': ''dingo'', ''drummer'':
    ''Ringo''}` | [Chapter 8](ch08.html#ch_dicts) |'
  prefs: []
  type: TYPE_TB
- en: After the chapters on these basic data types, you’ll see how to make new types
    in [Chapter 10](ch10.html#ch_objects).
  prefs: []
  type: TYPE_NORMAL
- en: Mutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nought may endure but Mutability.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Percy Shelley
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The type also determines whether the data *value* contained by the box can
    be changed (*mutable*) or is constant (*immutable*). Think of an immutable object
    as a sealed box, but with clear sides, like [Figure 2-1](#fig_box); you can see
    the value but you can’t change it. By the same analogy, a mutable object is like
    a box with a lid: not only can you see the value inside, you can also change it;
    however, you can’t change its type.'
  prefs: []
  type: TYPE_NORMAL
- en: Python is *strongly typed*, which means that the type of an object does not
    change, even if its value is mutable ([Figure 2-2](#fig_strong_typing)).
  prefs: []
  type: TYPE_NORMAL
- en: '![inp2 0202](assets/inp2_0202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. *Strong typing* does not mean push the keys harder
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Literal Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways of specifying data values in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Literal*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Variable*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In coming chapters, you’ll see the details on how to specify literal values
    for different data types—integers are a sequence of digits, floats contain a decimal
    point, text strings are surrounded by quotes, and so on. But, for the rest of
    this chapter, to avoid calloused fingertips, our examples will use only short
    decimal integers and a Python list or two. Decimal integers are just like integers
    in math: a sequence of digits from `0` to `9`. There are a few extra integer details
    (like signs and nondecimal bases) that we look at in [Chapter 3](ch03.html#ch_numbers).'
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we’ve arrived at a key concept in computing languages.
  prefs: []
  type: TYPE_NORMAL
- en: Python, like most computer languages, lets you define *variables*—names for
    values in your computer’s memory that you want to use in a program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python variable names have some rules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'They can contain only these characters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lowercase letters (`a` through `z`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Uppercase letters (`A` through `Z`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Digits (`0` through `9`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Underscore (`_`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'They are *case-sensitive*: `thing`, `Thing`, and `THING` are different names.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They must begin with a letter or an underscore, not a digit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Names that begin with an underscore are treated specially (which you can read
    about in [Chapter 9](ch09.html#ch_functions)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They cannot be one of Python’s *reserved words* (also known as *keywords*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The reserved words^([1](ch02.html#idm45795033434568)) are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Within a Python program, you can find the reserved words with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'These are valid names:'
  prefs: []
  type: TYPE_NORMAL
- en: '`a`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a_b_c___95`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_abc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_1a`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These names, however, are not valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '`1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1a`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1_`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name!`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`another-name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Python, you use `=` to *assign* a value to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We all learned in grade school arithmetic that `=` means *equal to*. So why
    do many computer languages, including Python, use `=` for assignment? One reason
    is that standard keyboards lack logical alternatives such as a left arrow key,
    and `=` didn’t seem too confusing. Also, in computer programs you use assignment
    much more than you test for equality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Programs are *not* like algebra. When you learned math in school, you saw equations
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You would solve the equation by “plugging in” a value for `x`. If you gave `x`
    the value `5`, `5 + 12` is `17`, so the value of `y` would be `17`. Plug in `6`
    for `x` to get `18` for `y`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Computer program lines may look like equations, but their meaning is different.
    In Python and other computer languages, `x` and `y` are *variables*. Python knows
    that a bare sequence of digits like `12` or `5` is a literal integer. So here’s
    a tiny Python program that mimics this equation, printing the resulting value
    of `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the big difference between math and programs: in math, `=` means *equality*
    of both sides, but in programs it means *assignment*: *assign the value on the
    right side to the variable on the left side*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also in programs, everything on the right side needs to have a value (this
    is called being *initialized*). The right side can be a literal value, or a variable
    that has already been assigned a value, or a combination. Python knows that `5`
    and `12` are literal integers. The first line assigns the integer value `5` to
    the variable `x`. Now we can use the variable `x` in the next line. When Python
    reads `y = x + 12`, it does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Sees the `=` in the middle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knows that this is an assignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculates the right side (gets the value of the object referred to by `x` and
    adds it to `12`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigns the result to the left-side variable, `y`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then typing the name of the variable `y` (in the interactive interpreter) will
    print its new value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you started your program with the line `y = x + 12`, Python would generate
    an *exception* (an error), because the variable `x` doesn’t have a value yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You’ll get the full rundown on exceptions in [Chapter 9](ch09.html#ch_functions).
    In computerese, we’d say that this `x` was *uninitialized*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In algebra, you can work backward, and assign a value to `y` to calculate `x`.
    To do this in Python, you’d need to get the literal values and initialized variables
    on the right side before assigning to `x` on the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Variables Are Names, Not Places
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now it’s time to make a crucial point about variables in Python: *variables
    are just names*. This is different from many other computer languages, and a key
    thing to know about Python, especially when we get to *mutable* objects like lists.
    Assignment *does not copy* a value; it just *attaches a name* to the object that
    contains the data. The name is a *reference* to a thing rather than the thing
    itself. Visualize a name as a tag with a string attached to the object box somewhere
    else in the computer’s memory ([Figure 2-3](#fig_sticky)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![inp2 0203](assets/inp2_0203.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-3\. Names point to objects (variable `a` points to an integer object
    with value `7`)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In other languages, the variable itself has a type, and binds to a memory location.
    You can change the value at that location, but it needs to be of the same type.
    This is why *static* languages make you declare the types of variables. Python
    doesn’t, because a name can refer to anything, and we get the value and type by
    “following the string” to the data object itself. This saves time, but there are
    some downsides:'
  prefs: []
  type: TYPE_NORMAL
- en: You may misspell a variable and get an exception because it doesn’t refer to
    anything, and Python doesn’t automatically check this as static languages do.
    [Chapter 19](ch19.html#ch_pythonista) shows ways of checking your variables ahead
    of time to avoid this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python’s raw speed is slower than a language like C. It makes the computer do
    more work so you don’t have to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Try this with the interactive interpreter (visualized in [Figure 2-4](#fig_sticky_2)):'
  prefs: []
  type: TYPE_NORMAL
- en: As before, assign the value `7` to the name `a`. This creates an object box
    containing the integer value `7`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the value of `a`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign `a` to `b`, making `b` also point to the object box containing `7`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Print the value of `b`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![inp2 0204](assets/inp2_0204.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-4\. Copying a name (now variable `b` also points to the same integer
    object)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In Python, if you want to know the type of anything (a variable or a literal
    value), you can use ``type(*`thing`*)``. `type()` is one of Python’s built-in
    functions. If you want to check whether a variable points to an object of a specific
    type, use ``isinstance(*`type`*)``:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When I mention a function, I’ll put parentheses (`()`) after it to emphasize
    that it’s a function rather than a variable name or something else.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try it with more literal values (`58`, `99.9`, `''abc''`) and variables
    (`a`, `b`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A *class* is the definition of an object; [Chapter 10](ch10.html#ch_objects)
    covers classes in greater detail. In Python, “class” and “type” mean pretty much
    the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve seen, when you use a variable in Python, it looks up the object that
    it refers to. Behind the scenes, Python is busy, often creating temporary objects
    that will be discarded a line or two later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s repeat an earlier example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code snippet, Python did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Created an integer object with the value `5`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Made a variable `y` point to that `5` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incremented the reference count of the object with value `5`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Created another integer object with the value `12`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subtracted the value of the object that `y` points to (`5`) from the value `12`
    in the (anonymous) object with that value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigned this value (`7`) to a new (so far, unnamed) integer object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Made the variable `x` point to this new object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incremented the reference count of this new object that `x` points to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looked up the value of the object that `x` points to (`7`) and printed it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an object’s reference count reaches zero, no names are pointing to it,
    so it doesn’t need to stick around. Python has a charmingly named *garbage collector*
    that reuses the memory of things that are no longer needed. Picture someone behind
    those memory shelves, yanking obsolete boxes for recycling.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we no longer need the objects with the values `5`, `12`, or `7`,
    or the variables `x` and `y`. The Python garbage collector may choose to send
    them to object heaven,^([2](ch02.html#idm45795033021464)) or keep some around
    for performance reasons given that small integers tend to be used a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning to Multiple Names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can assign a value to more than one variable name at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Reassigning a Name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because names point to objects, changing the value assigned to a name just makes
    the name point to a new object. The reference count of the old object is decremented,
    and the new one’s is incremented.
  prefs: []
  type: TYPE_NORMAL
- en: Copying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you saw in [Figure 2-4](#fig_sticky_2), assigning an existing variable `a`
    to a new variable named `b` just makes `b` point to the same object that `a` does.
    If you pick up either the `a` or `b` tag and follow their strings, you’ll get
    to the same object.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the object is immutable (like an integer), its value can’t be changed, so
    both names are essentially read-only. Try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When we assigned `x` to `y`, that made the name `y` point to the integer object
    with value `5` that `x` was also pointing to. Changing `x` made it point to a
    new integer object with value `29`. It did not change the one containing `5`,
    which `y` still points to.
  prefs: []
  type: TYPE_NORMAL
- en: But if both names point to a *mutable* object, you can change the object’s value
    via either name, and you’ll see the changed value when you use either name. If
    you didn’t know this first, it could surprise you.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *list* is a mutable array of values, and [Chapter 7](ch07.html#ch_lists)
    covers them in gruesome detail. For this example, `a` and `b` each point to a
    list with three integer members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: These list members (`a[0]`, `a[1]`, and `a[2]`) are themselves like names, pointing
    to integer objects with the values `2`, `4`, and `6`. The list object keeps its
    members in order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now change the first list element, through the name `a`, and see that `b` also
    changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When the first list element is changed, it no longer points to the object with
    value `2`, but a new object with value `99`. The list is still of type `list`,
    but its value (the list elements and their order) is mutable.
  prefs: []
  type: TYPE_NORMAL
- en: Choose Good Variable Names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: He said true things, but called them by wrong names.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Elizabeth Barrett Browning
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It’s surprising how important it is to choose good names for your variables.
    In many of the code examples so far, I’ve been using throwaway names like `a`
    and `x`. In real programs, you’ll have many more variables to keep track of at
    once, and you’ll need to balance brevity and clarity. For example, it’s faster
    to type `num_loons` rather than `number``_of_loons` or `gaviidae_inventory`, but
    it’s more explanatory than `n`.
  prefs: []
  type: TYPE_NORMAL
- en: Coming Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Numbers! They’re as exciting as you expect. Well, maybe not that bad.^([3](ch02.html#idm45795032772440))
    You’ll see how to use Python as a calculator and how a cat founded a digital system.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Do
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2.1 Assign the integer value `99` to the variable `prince`, and print it.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 What type is the value `5`?
  prefs: []
  type: TYPE_NORMAL
- en: 2.3 What type is the value `2.0`?
  prefs: []
  type: TYPE_NORMAL
- en: 2.4 What type is the expression `5 + 2.0`?
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch02.html#idm45795033434568-marker)) `async` and `await` are new in Python
    3.7.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch02.html#idm45795033021464-marker)) Or the Island of Misfit Objects.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch02.html#idm45795032772440-marker)) `8` looks like a snowman!
  prefs: []
  type: TYPE_NORMAL
