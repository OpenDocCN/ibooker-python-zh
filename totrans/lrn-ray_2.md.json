["```py\nimport random\n\nclass Discrete:\n    def __init__(self, num_actions: int):\n        \"\"\" Discrete action space for num_actions.\n        Discrete(4) can be used as encoding moving in one of the cardinal directions.\n        \"\"\"\n        self.n = num_actions\n\n    def sample(self):\n        return random.randint(0, self.n - 1)  ![1](assets/1.png)\n\nspace = Discrete(4)\nprint(space.sample())  ![2](assets/2.png)\n```", "```py\nimport os\n\nclass Environment:\n\n    seeker, goal = (0, 0), (4, 4)  ![1](assets/1.png)\n    info = {'seeker': seeker, 'goal': goal}\n\n    def __init__(self,  *args, **kwargs):\n        self.action_space = Discrete(4)  ![2](assets/2.png)\n        self.observation_space = Discrete(5*5)  ![3](assets/3.png)\n```", "```py\n    def reset(self):  ![1](assets/1.png)\n        \"\"\"Reset seeker and goal positions, return observations.\"\"\"\n        self.seeker = (0, 0)\n        self.goal = (4, 4)\n\n        return self.get_observation()\n\n    def get_observation(self):\n        \"\"\"Encode the seeker position as integer\"\"\"\n        return 5 * self.seeker[0] + self.seeker[1]  ![2](assets/2.png)\n\n    def get_reward(self):\n        \"\"\"Reward finding the goal\"\"\"\n        return 1 if self.seeker == self.goal else 0  ![3](assets/3.png)\n\n    def is_done(self):\n        \"\"\"We're done if we found the goal\"\"\"\n        return self.seeker == self.goal  ![4](assets/4.png)\n```", "```py\n    def step(self, action):\n        \"\"\"Take a step in a direction and return all available information.\"\"\"\n        if action == 0:  # move down\n            self.seeker = (min(self.seeker[0] + 1, 4), self.seeker[1])\n        elif action == 1:  # move left\n            self.seeker = (self.seeker[0], max(self.seeker[1] - 1, 0))\n        elif action == 2:  # move up\n            self.seeker = (max(self.seeker[0] - 1, 0), self.seeker[1])\n        elif action == 3:  # move right\n            self.seeker = (self.seeker[0], min(self.seeker[1] + 1, 4))\n        else:\n            raise ValueError(\"Invalid action\")\n\n        return self.get_observation(), self.get_reward(), self.is_done(), self.info  ![1](assets/1.png)\n```", "```py\n    def render(self, *args, **kwargs):\n        \"\"\"Render the environment, e.g. by printing its representation.\"\"\"\n        os.system('cls' if os.name == 'nt' else 'clear')  ![1](assets/1.png)\n        grid = [['| ' for _ in range(5)] + [\"|\\n\"] for _ in range(5)]\n        grid[self.goal[0]][self.goal[1]] = '|G'\n        grid[self.seeker[0]][self.seeker[1]] = '|S'  ![2](assets/2.png)\n        print(''.join([''.join(grid_row) for grid_row in grid]))  ![3](assets/3.png)\n```", "```py\nimport time\n\nenvironment = Environment()\n\nwhile not environment.is_done():\n    random_action = environment.action_space.sample()  ![1](assets/1.png)\n    environment.step(random_action)\n    time.sleep(0.1)\n    environment.render()  ![2](assets/2.png)\n```", "```py\nclass Policy:\n\n    def __init__(self, env):\n        \"\"\"A Policy suggests actions based on the current state.\n        We do this by tracking the value of each state-action pair.\n        \"\"\"\n        self.state_action_table = [\n            [0 for _ in range(env.action_space.n)]for _ in range(env.observation_space.n)  ![1](assets/1.png)\n        ]\n        self.action_space = env.action_space\n\n    def get_action(self, state, explore=True, epsilon=0.1):  ![2](assets/2.png)\n        \"\"\"Explore randomly or exploit the best value currently available.\"\"\"\n        if explore and random.uniform(0, 1) < epsilon:  ![3](assets/3.png)\n            return self.action_space.sample()\n        return np.argmax(self.state_action_table[state])\n```", "```py\nclass Simulation(object):\n    def __init__(self, env):\n        \"\"\"Simulates rollouts of an environment, given a policy to follow.\"\"\"\n        self.env = env\n\n    def rollout(self, policy, render=False, explore=True, epsilon=0.1):  ![1](assets/1.png)\n        \"\"\"Returns experiences for a policy rollout.\"\"\"\n        experiences = []\n        state = self.env.reset()  ![2](assets/2.png)\n        done = False\n        while not done:\n            action = policy.get_action(state, explore, epsilon)  ![3](assets/3.png)\n            next_state, reward, done, info = self.env.step(action)  ![4](assets/4.png)\n            experiences.append([state, action, reward, next_state])  ![5](assets/5.png)\n            state = next_state\n            if render:  ![6](assets/6.png)\n                time.sleep(0.05)\n                self.env.render()\n\n        return experiences\n```", "```py\nuntrained_policy = Policy(environment)\nsim = Simulation(environment)\n\nexp = sim.rollout(untrained_policy, render=True, epsilon=1.0)  ![1](assets/1.png)\nfor row in untrained_policy.state_action_table:\n    print(row)  ![2](assets/2.png)\n```", "```py\nnext_max = np.max(policy.state_action_table[next_state])\n```", "```py\nnew_value = 0.9 * value + 0.1 * (reward + 0.9 * next_max)\n```", "```py\nimport numpy as np\n\ndef update_policy(policy, experiences, weight=0.1, discount_factor=0.9):\n    \"\"\"Updates a given policy with a list of (state, action, reward, state)\n    experiences.\"\"\"\n    for state, action, reward, next_state in experiences:  ![1](assets/1.png)\n        next_max = np.max(policy.state_action_table[next_state])  ![2](assets/2.png)\n        value = policy.state_action_table[state][action]  ![3](assets/3.png)\n        new_value = (1 - weight) * value + weight * (reward + discount_factor * next_max)  ![4](assets/4.png)\n        policy.state_action_table[state][action] = new_value  ![5](assets/5.png)\n```", "```py\ndef train_policy(env, num_episodes=10000, weight=0.1, discount_factor=0.9):\n    \"\"\"Training a policy by updating it with rollout experiences.\"\"\"\n    policy = Policy(env)\n    sim = Simulation(env)\n    for _ in range(num_episodes):\n        experiences = sim.rollout(policy)  ![1](assets/1.png)\n        update_policy(policy, experiences, weight, discount_factor)  ![2](assets/2.png)\n\n    return policy\n\ntrained_policy = train_policy(environment)  ![3](assets/3.png)\n```", "```py\ndef evaluate_policy(env, policy, num_episodes=10):\n    \"\"\"Evaluate a trained policy through rollouts.\"\"\"\n    simulation = Simulation(env)\n    steps = 0\n\n    for _ in range(num_episodes):\n        experiences = simulation.rollout(policy, render=True, explore=False)  ![1](assets/1.png)\n        steps += len(experiences)  ![2](assets/2.png)\n\n    print(f\"{steps / num_episodes} steps on average \"\n          f\"for a total of {num_episodes} episodes.\")\n\n    return steps / num_episodes\n\nevaluate_policy(environment, trained_policy)\n```", "```py\n8.0 steps on average for a total of 10 episodes.\n```", "```py\nimport ray\n\nray.init()\nenvironment = Environment()\nenv_ref = ray.put(environment)  ![1](assets/1.png)\n\n@ray.remote\ndef create_policy():\n    env = ray.get(env_ref)\n    return Policy(env)  ![2](assets/2.png)\n\n@ray.remote\nclass SimulationActor(Simulation):  ![3](assets/3.png)\n    \"\"\"Ray actor for a Simulation.\"\"\"\n    def __init__(self):\n        env = ray.get(env_ref)\n        super().__init__(env)\n```", "```py\n@ray.remote\ndef update_policy_task(policy_ref, experiences_list):\n    \"\"\"Remote Ray task for updating a policy with experiences in parallel.\"\"\"\n    [update_policy(policy_ref, ray.get(xp)) for xp in experiences_list]  ![1](assets/1.png)\n    return policy_ref\n\ndef train_policy_parallel(num_episodes=1000, num_simulations=4):\n    \"\"\"Parallel policy training function.\"\"\"\n    policy = create_policy.remote()  ![2](assets/2.png)\n    simulations = [SimulationActor.remote() for _ in range(num_simulations)]  ![3](assets/3.png)\n\n    for _ in range(num_episodes):\n        experiences = [sim.rollout.remote(policy) for sim in simulations]  ![4](assets/4.png)\n        policy = update_policy_task.remote(policy, experiences)  ![5](assets/5.png)\n\n    return ray.get(policy)  ![6](assets/6.png)\n```", "```py\nparallel_policy = train_policy_parallel()\nevaluate_policy(environment, parallel_policy)\n```"]