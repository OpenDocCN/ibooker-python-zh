- en: Chapter 18\. Networking Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第18章 网络基础
- en: '*Connection-oriented* protocols work like making a telephone call. You request
    a connection to a particular *network endpoint* (equivalent to dialing somebody’s
    phone number), and your party either answers or doesn’t. If they do, you can talk
    to them and hear them talking back (simultaneously, if necessary), and you know
    that nothing is getting lost. At the end of the conversation you both say goodbye
    and hang up, so it’s obvious something has gone wrong if that closing event doesn’t
    occur (for example, if you just suddenly stop hearing the other party). The Transmission
    Control Protocol (TCP) is the main connection-oriented transport protocol of the
    internet, used by web browsers, secure shells, email, and many other applications.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*面向连接*协议的工作方式类似于打电话。您请求与特定的*网络端点*建立连接（类似于拨打某人的电话号码），您的对方要么接听要么不接听。如果接听，您可以与他们交谈并听到他们的回答（如果需要可以同时进行），并且您知道没有任何信息丢失。在对话结束时，您都会说再见并挂断电话，因此如果没有发生这种关闭事件，就明显表明出了问题（例如，如果突然听不到对方的声音）。传输控制协议（TCP）是互联网的主要面向连接传输协议，被Web浏览器、安全外壳、电子邮件和许多其他应用程序使用。'
- en: '*Connectionless* or *datagram* protocols work more like communicating by sending
    postcards. Mostly, the messages get through, but if anything goes wrong you have
    to be prepared to cope with the consequences—the protocol doesn’t notify you whether
    your messages have been received, and messages can arrive out of order. For exchanging
    short messages and getting answers, datagram protocols have less overhead than
    connection-oriented ones, as long as the overall service can cope with occasional
    disruptions. For example, a Domain Name Service (DNS) server may fail to respond:
    most DNS communication was until recently connectionless. The User Datagram Protocol
    (UDP) is the main connectionless transport protocol for internet communications.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*无连接*或者*数据报*协议更像是通过发送明信片进行通信。大多数情况下，消息可以传递，但是如果出了问题，你必须准备好应对后果——协议不会通知你消息是否已接收，而且消息可能会无序到达。对于交换短消息并获取答案，数据报协议的开销比面向连接的协议小，前提是整体服务能够处理偶发的中断。例如，域名服务（DNS）服务器可能无法响应：直到最近，大多数DNS通信都是无连接的。用户数据报协议（UDP）是互联网通信的主要无连接传输协议。'
- en: 'Nowadays, security is increasingly important: understanding the underlying
    basis of secure communications helps you ensure that your communications are as
    secure as they need to be. If this summary dissuades you from trying to implement
    such technology yourself without a thorough understanding of the issues and risks,
    it will have served a worthwhile purpose.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，安全性变得越来越重要：理解安全通信的基础知识有助于确保您的通信达到所需的安全水平。如果这个摘要让您在没有充分了解问题和风险的情况下尝试实现这样的技术，那么它将发挥出有价值的作用。
- en: All communications across network interfaces exchange strings of bytes. To communicate
    text, or indeed most other information, the sender must encode it as bytes, which
    the receiver must decode. We limit our discussion in this chapter to the case
    of a single sender and a single receiver.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 所有网络接口之间的通信都是通过字节串交换的。要传输文本或者其他大多数信息，发送方必须将其编码为字节，接收方必须解码。在本章中，我们将讨论单个发送方和单个接收方的情况。
- en: The Berkeley Socket Interface
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伯克利套接字接口
- en: Most networking nowadays uses *sockets.* Sockets give access to pipelines between
    independent endpoints, using a *transport layer protocol* to move information
    between those endpoints. The socket concept is general enough that the endpoints
    can be on the same computer, or on different computers networked together, either
    locally or via a wide area network.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如今大多数网络使用*套接字*。套接字提供了独立端点之间的管道访问，使用*传输层协议*在这些端点之间传输信息。套接字的概念足够通用，使得端点可以位于同一台计算机上，也可以位于联网的不同计算机上，无论是在本地还是通过广域网连接。
- en: The most frequently used transport layers today are UDP (for connectionless
    networking) and TCP (for connection-oriented networking); each is carried over
    a common Internet Protocol (IP) network layer. This stack of protocols, along
    with the many application protocols that run over them, is collectively known
    as *TCP/IP.* A good introduction is Gordon McMillan’s (dated but still perfectly
    valid) [*Socket Programming HOWTO*](https://oreil.ly/9Y5pc).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如今最常用的传输层是UDP（用于无连接的网络）和TCP（用于面向连接的网络）；每种传输层在通用Internet协议（IP）网络层上运行。这些协议堆栈以及运行在其上的许多应用协议总称为*TCP/IP*。Gordon
    McMillan的（有些陈旧但仍然有效的）[*Socket编程指南*](https://oreil.ly/9Y5pc)提供了很好的介绍。
- en: The two most common socket families are *internet sockets* based on TCP/IP communications
    (available in two flavors, to accommodate the modern IPv6 and the more traditional
    IPv4) and *Unix sockets*, though other families are also available. Internet sockets
    allow communication between any two computers that can exchange IP datagrams;
    Unix sockets can only communicate between processes on the same Unix machine.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 两种最常见的套接字家族是基于TCP/IP通信的*互联网套接字*（提供现代IPv6和更传统的IPv4两种版本）和*Unix套接字*，尽管还有其他家族可用。互联网套接字允许任何两台可以交换IP数据报的计算机进行通信；Unix套接字只能在同一Unix机器上的进程之间通信。
- en: To support many concurrent internet sockets, the TCP/IP protocol stack uses
    endpoints identified by an IP address, a *port number*, and a protocol. The port
    numbers allow protocol handling software to distinguish between different endpoints
    at the same IP address using the same protocol. A connected socket is also associated
    with a *remote endpoint*, the counterparty socket to which it is connected and
    with which it can communicate.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持许多并发的互联网套接字，TCP/IP协议栈使用由IP地址、*端口号*和协议标识的端点。端口号允许协议处理软件在相同IP地址上使用相同协议时区分不同的端点。连接的套接字还与一个*远程端点*关联，即连接并能够通信的对方套接字。
- en: Most Unix sockets have names in the Unix filesystem. On Linux platforms, sockets
    whose names begin with a zero byte live in a name pool maintained by the kernel.
    These are useful for communicating with a [chroot-jail process](https://oreil.ly/qvgaC),
    for example, where no filesystem is shared between two processes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Unix套接字在Unix文件系统中具有名称。在Linux平台上，以零字节开头的套接字存在于内核维护的名称池中。例如，这些对于与[chroot-jail进程](https://oreil.ly/qvgaC)通信非常有用，例如，两个进程之间没有共享文件系统。
- en: Both internet and Unix sockets support connectionless and connection-oriented
    networking, so if you write your programs carefully, they can work over either
    socket family. It is beyond the scope of this book to discuss other socket families,
    though we should mention that *raw sockets*, a subtype of the internet socket
    family, let you send and receive link layer packets (for example, Ethernet packets)
    directly. This is useful for some experimental applications and for [packet sniffing](https://oreil.ly/bmYSI).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网套接字和Unix套接字均支持无连接和面向连接的网络，因此如果您仔细编写程序，它们可以在任何套接字家族上工作。本书不讨论其他套接字家族的范围，尽管我们应该提到*原始套接字*，它是互联网套接字家族的一个子类型，允许直接发送和接收链路层数据包（例如以太网数据包）。这对于一些实验性应用和[数据包嗅探](https://oreil.ly/bmYSI)很有用。
- en: After creating an internet socket, you can associate (*bind*) a specific port
    number with the socket (as long as that port number is not in use by some other
    socket). This is the strategy many servers use, offering service on so-called
    [*well-known port numbers*](https://oreil.ly/Y2XeE) defined by internet standards
    as being in the range 1–1,023\. On Unix systems, *root* privileges are required
    to gain access to these ports. A typical client is unconcerned with the port number
    it uses, and so it typically requests an *ephemeral port*, assigned by the protocol
    driver and guaranteed to be unique on that host. There is no need to bind client
    ports.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 创建互联网套接字后，您可以将特定的端口号与套接字关联（只要该端口号没有被其他套接字使用）。这是许多服务器使用的策略，提供所谓的[*众所周知的端口号*](https://oreil.ly/Y2XeE)，由互联网标准定义为1-1,023范围内的端口号。在Unix系统上，需要*root*权限才能访问这些端口。典型的客户端不关心使用的端口号，因此通常请求由协议驱动程序分配并保证在主机上唯一的*临时端口*。无需绑定客户端端口。
- en: Consider two processes on the same computer, each acting as a client to the
    same remote server. The full association for their sockets has five components,
    (local_IP_address, local_port_number, protocol, remote_IP_address, remote_port_number).
    When packets arrive at the remote server, the destination, source IP address,
    destination port number, and protocol are the same for both clients. The guarantee
    of uniqueness for ephemeral port numbers lets the server distinguish between traffic
    from the two clients. This is how TCP/IP handles multiple conversations between
    the same two IP addresses.^([1](ch18.xhtml#ch01fn136))
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑同一台计算机上的两个进程，每个进程都作为同一个远程服务器的客户端。它们套接字的完整关联具有五个组成部分，（本地 IP 地址、本地端口号、协议、远程
    IP 地址、远程端口号）。当数据包到达远程服务器时，目标 IP 地址、源 IP 地址、目标端口号和协议对两个客户端来说是相同的。短暂端口号的唯一性保证了服务器能区分来自两个客户端的流量。这就是
    TCP/IP 处理同一对 IP 地址之间的多个会话的方式。^([1](ch18.xhtml#ch01fn136))
- en: Socket Addresses
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 套接字地址
- en: 'The different types of sockets use different address formats:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 不同类型的套接字使用不同的地址格式：
- en: Unix socket addresses are strings naming a node in the filesystem (on Linux
    platforms, bytestrings starting with b'\0' and corresponding to names in a kernel
    table).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unix 套接字地址是命名文件系统中节点的字符串（在 Linux 平台上，是以 b'\0' 开头的字节串，并对应内核表中的名称）。
- en: IPv4 socket addresses are (*address*, *port*) pairs. The first item is an IPv4
    address, the second a port number in the range 1–65,535.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPv4 套接字地址是 (*地址*, *端口*) 对。第一项是 IPv4 地址，第二项是范围在 1 到 65,535 的端口号。
- en: IPv6 socket addresses are four-item (*address*, *port*, *flowinfo*, *scopeid*)
    tuples. When providing an address as an argument, the *flowinfo* and *scopeid*
    items can generally be omitted, as long as the [address scope](https://oreil.ly/RcIfb)
    is unimportant.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPv6 套接字地址是四项 (*地址*, *端口*, *流信息*, *作用域 ID*) 元组。在提供地址作为参数时，通常可以省略 *流信息* 和 *作用域
    ID*，只要 [地址作用域](https://oreil.ly/RcIfb) 不重要即可。
- en: Client/Server Computing
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端/服务器计算
- en: The pattern we discuss hereafter is usually referred to as *client/server* networking,
    where a *server* listens for traffic on a specific endpoint from *clients* requiring
    the service. We do not cover *peer-to-peer* networking, which, lacking any central
    server, has to include the ability for peers to discover each other.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来讨论的模式通常称为 *客户端/服务器* 网络，其中 *服务器* 在特定端点上监听来自需要服务的 *客户端* 的流量。我们不涵盖 *点对点* 网络，因为缺少任何中央服务器，必须包含对等方发现的能力。
- en: Most, though by no means all, network communication is performed using client/server
    techniques. The server listens for incoming traffic at a predetermined or advertised
    network endpoint. In the absence of such input, it does nothing, simply sitting
    there waiting for input from clients. Communication is somewhat different between
    connectionless and connection-oriented endpoints.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数（虽然并非全部）网络通信是通过客户端/服务器技术进行的。服务器在预定或公布的网络端点处监听传入的流量。在缺少此类输入时，它不做任何操作，只是坐在那里等待来自客户端的输入。连接在面向无连接和面向连接的端点之间的通信有所不同。
- en: 'In connectionless networking, such as via UDP, requests arrive at a server
    randomly and are dealt with immediately: a response is dispatched to the requester
    without delay. Each request is handled on its own, usually without reference to
    any communications that may previously have occurred between the two parties.
    Connectionless networking is well suited to short-term, stateless interactions
    such as those required by DNS or network booting.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向无连接的网络中（例如通过 UDP），请求随机到达服务器并立即处理：响应立即发送给请求者。每个请求单独处理，通常不参考先前在两方之间可能发生的任何通信。面向无连接的网络非常适合短期无状态交互，例如
    DNS 或网络引导所需的交互。
- en: 'In connection-oriented networking, the client engages in an initial exchange
    with the server that effectively establishes a connection across a network pipeline
    between two processes (sometimes referred to as a [*virtual circuit*](https://oreil.ly/ePVQo)),
    across which the processes can communicate until both indicate their willingness
    to end the connection. In this case, serving needs to use parallelism (via a concurrency
    mechanism such as threads, processes, or asynchronicity: see [Chapter 15](ch15.xhtml#concurrency_threads_and_processes))
    to handle each incoming connection asynchronously or simultaneously. Without parallelism,
    the server would be unable to handle new incoming connections before earlier ones
    have terminated, since calls to socket methods normally *block* (meaning they
    pause the thread calling them until they terminate or time out). Connections are
    the best way to handle lengthy interactions such as mail exchanges, command-line
    shell interactions, or the transmission of web content, and offer automatic error
    detection and correction when they use TCP.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向连接的网络中，客户端与服务器进行初始交换，有效地在两个进程之间建立了网络管道上的连接（有时称为[*虚拟电路*](https://oreil.ly/ePVQo)），在这些进程可以进行通信，直到两者表示愿意结束连接。在这种情况下，服务需要使用并行处理（通过线程、进程或异步机制：参见[第15章](ch15.xhtml#concurrency_threads_and_processes)）来异步或同时处理每个传入的连接。如果没有并行处理，服务器将无法在早期的连接终止之前处理新的传入连接，因为对套接字方法的调用通常会*阻塞*（即它们会暂停调用它们的线程，直到它们终止或超时）。连接是处理诸如邮件交换、命令行交互或传输Web内容等长时间交互的最佳方法，并在使用TCP时提供自动错误检测和纠正。
- en: Connectionless client and server structures
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无连接的客户端和服务器结构。
- en: 'The broad logic flow of a connectionless server proceeds as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 无连接服务器的整体逻辑流程如下：
- en: Create a socket of type socket.SOCK_DGRAM by calling socket.socket.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用socket.socket创建类型为socket.SOCK_DGRAM的套接字。
- en: Associate the socket with the service endpoint by calling the socket’s bind
    method.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用套接字的bind方法将套接字与服务端点关联。
- en: 'Repeat the following steps *ad infinitum*:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复以下步骤*无限期*：
- en: Request an incoming datagram from a client by calling the socket’s recvfrom
    method; this call blocks until a datagram is received.
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用套接字的recvfrom方法请求来自客户端的传入数据报；此调用会阻塞，直到接收到数据报。
- en: Compute or look up the result.
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算或查找结果。
- en: Send the result back to the client by calling the socket’s sendto method.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用套接字的sendto方法将结果发送回客户端。
- en: The server spends most of its time in step 3a, awaiting input from clients.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器大部分时间都在步骤3a中等待来自客户端的输入。
- en: 'A connectionless client’s interaction with the server proceeds as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 无连接客户端与服务器的交互如下：
- en: Create a socket of type socket.SOCK_DGRAM by calling socket.socket.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用socket.socket创建类型为socket.SOCK_DGRAM的套接字。
- en: Optionally, associate the socket with a specific endpoint by calling the socket’s
    bind method.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，通过调用套接字的bind方法将套接字与特定端点关联。
- en: Send a request to the server’s endpoint by calling the socket’s sendto method.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用套接字的sendto方法向服务器端点发送请求。
- en: 'Await the server reply by calling the socket’s recvfrom method; this call blocks
    until the response is received. It’s necessary to apply a *timeout* to this call,
    to handle the case where a datagram goes missing and the program must either retry
    or abort the attempt: connectionless sockets don’t guarantee delivery.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用套接字的recvfrom方法等待服务器的回复；此调用会阻塞，直到收到响应。必须对此调用应用*超时*，以处理数据报丢失的情况，程序必须重试或中止尝试：无连接套接字不保证传递。
- en: Use the result in the remainder of the client program’s logic.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端程序的剩余逻辑中使用结果。
- en: 'A single client program can perform several interactions with the same or multiple
    servers, depending on the services it needs to use. Many such interactions are
    hidden from the application programmer inside library code. A typical example
    is the resolution of a hostname to the appropriate network address, which commonly
    uses the gethostbyname library function (implemented in Python’s socket module,
    discussed shortly). Connectionless interactions normally involve sending a single
    packet to the server and receiving a single packet in response. The main exceptions
    involve *streaming* protocols such as the Real-time Transport Protocol (RTP),^([2](ch18.xhtml#ch01fn137))
    which are typically layered on top of UDP to minimize latency and delays: in streaming,
    many datagrams are sent and received.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 单个客户端程序可以与同一个或多个服务器执行多次交互，具体取决于需要使用的服务。许多这样的交互对应用程序员来说是隐藏在库代码中的。一个典型的例子是将主机名解析为适当的网络地址，通常使用
    `gethostbyname` 库函数（在Python的 `socket` 模块中实现，稍后讨论）。无连接的交互通常涉及向服务器发送一个数据包并接收一个响应数据包。主要的例外情况涉及*流*协议，如实时传输协议（RTP），^([2](ch18.xhtml#ch01fn137))
    这些协议通常构建在UDP之上，以最小化延迟和延迟：在流式传输中，发送和接收许多数据报。
- en: Connection-oriented client and server structures
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接导向客户端和服务器结构
- en: 'The broad flow of logic of a connection-oriented server is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 连接导向服务器的逻辑流程如下：
- en: Create a socket of type socket.SOCK_STREAM by calling socket.socket.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `socket.socket` 创建 `socket.SOCK_STREAM` 类型的套接字。
- en: Associate the socket with the appropriate server endpoint by calling the socket’s
    bind method.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用套接字的 `bind` 方法将套接字与适当的服务器端点关联起来。
- en: Start the endpoint listening for connection requests by calling the socket’s
    listen method.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用套接字的 `listen` 方法开始端点监听连接请求。
- en: 'Repeat the following steps *ad infinitum*:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无限重复以下步骤*ad infinitum*：
- en: Await an incoming client connection by calling the socket’s accept method; the
    server process blocks until an incoming connection request is received. When such
    a request arrives, a new socket object is created whose other endpoint is the
    client program.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用套接字的 `accept` 方法等待传入的客户端连接；服务器进程会阻塞，直到收到传入的连接请求。当这样的请求到达时，会创建一个新的套接字对象，其另一个端点是客户端程序。
- en: Create a new control thread or process to handle this specific connection, passing
    it the newly created socket; the main thread of control then continues by looping
    back to step 4a.
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制线程或进程来处理这个特定的连接，将新创建的套接字传递给它；主控线程然后通过回到步骤 4a 来继续。
- en: In the new control thread, interact with the client using the new socket’s recv
    and send methods, respectively, to read data from the client and send data to
    it. The recv method blocks until data is available from the client (or the client
    indicates it wishes to close the connection, in which case recv returns an empty
    result). The send method only blocks when the network software has so much data
    buffered that communication has to pause until the transport layer has emptied
    some of its buffer memory. When the server wishes to close the connection, it
    can do so by calling the socket’s close method, optionally calling its shutdown
    method first.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的控制线程中，使用新套接字的 `recv` 和 `send` 方法与客户端进行交互，分别用于从客户端读取数据和向其发送数据。`recv` 方法会阻塞，直到从客户端接收到数据（或客户端指示希望关闭连接，在这种情况下
    `recv` 返回空结果）。当服务器希望关闭连接时，可以通过调用套接字的 `close` 方法来实现，可选择先调用其 `shutdown` 方法。
- en: The server spends most of its time in step 4a, awaiting connection requests
    from clients.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器大部分时间都在步骤 4a 中等待来自客户端的连接请求。
- en: 'A connection-oriented client’s overall logic is as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 连接导向客户端的总体逻辑如下：
- en: Create a socket of type socket.SOCK_STREAM by calling socket.socket.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `socket.socket` 创建 `socket.SOCK_STREAM` 类型的套接字。
- en: Optionally, associate the socket with a specific endpoint by calling the socket’s
    bind method.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，通过调用套接字的 `bind` 方法将套接字与特定端点关联。
- en: Establish a connection to the server by calling the socket’s connect method.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用套接字的 `connect` 方法建立与服务器的连接。
- en: Interact with the server using the socket’s recv and send methods, respectively,
    to read data from the server and send data to it. The recv method blocks until
    data is available from the server (or the server indicates it wishes to close
    the connection, in which case the recv call returns an empty result). The send
    method only blocks when the network software has so much data buffered that communications
    have to pause until the transport layer has emptied some of its buffer memory.
    When the client wishes to close the connection, it can do so by calling the socket’s
    close method, optionally calling its shutdown method first.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用套接字的 recv 和 send 方法与服务器进行交互，分别用于从服务器读取数据和向其发送数据。recv 方法会阻塞，直到从服务器接收到数据（或者服务器指示希望关闭连接，在这种情况下，recv
    调用会返回空结果）。send 方法仅在网络软件缓冲区有大量数据时才会阻塞，导致通信暂停，直到传输层释放部分缓冲内存。当客户端希望关闭连接时，可以调用套接字的
    close 方法，可选地先调用其 shutdown 方法。
- en: Connection-oriented interactions tend to be more complex than connectionless
    ones. Specifically, determining when to read and write data is more complicated,
    because inputs must be parsed to determine when a transmission from the other
    end of the socket is complete. The higher-layer protocols used in connection-oriented
    networking accommodate this determination; sometimes this is done by indicating
    the data length as a part of the content, sometimes by more sophisticated methods.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 面向连接的交互通常比无连接的更复杂。具体来说，确定何时读取和写入数据更加复杂，因为必须解析输入以确定何时传输完毕。在面向连接的网络中使用的更高层协议适应了这种确定性；有时通过在内容中指示数据长度来实现，有时则采用更复杂的方法。
- en: The socket Module
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: socket 模块
- en: Python’s socket module handles networking with the socket interface. There are
    minor differences between platforms, but the module hides most of them, making
    it relatively easy to write portable networking applications.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 socket 模块通过 socket 接口处理网络。虽然各平台间有些许差异，但该模块隐藏了大部分差异，使得编写可移植的网络应用相对容易。
- en: The module defines three exception classes, all subclasses of the built-in exception
    class OSError (see [Table 18-1](#socket_module_exception_classes)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块定义了三个异常类，均为内置异常类 OSError 的子类（见 [Table 18-1](#socket_module_exception_classes)）。
- en: Table 18-1\. socket module exception classes
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Table 18-1\. socket 模块异常类
- en: '| herror | Identifies hostname resolution errors: e.g., socket.gethostbyname
    cannot convert a name to a network address, or socket.gethostbyaddr can find no
    hostname for a network address. The accompanying value is a two-element tuple
    (*h_errno*, *string*), where *h_errno* is the integer error number from the operating
    system, and *string* is a description of the error. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| herror | 用于识别主机名解析错误：例如，socket.gethostbyname 无法将名称转换为网络地址，或者 socket.gethostbyaddr
    找不到网络地址对应的主机名。相关的值是一个两元组（*h_errno*，*string*），其中 *h_errno* 是来自操作系统的整数错误号，*string*
    是错误的描述。 |'
- en: '| gaierror | Identifies addressing errors encountered in socket.getaddrinfo
    or socket.getnameinfo. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| gaierror | 用于识别在 socket.getaddrinfo 或 socket.getnameinfo 中遇到的地址解析错误。 |'
- en: '| timeout | Raised when an operation takes longer than the timeout limit (as
    per socket.setdefaulttimeout, overridable on a per-socket basis). |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| timeout | 当操作超过超时限制时（依据 socket.setdefaulttimeout，可以在每个套接字上覆盖），引发此异常。 |'
- en: 'The module defines many constants. The most important of these are the address
    families (AF_*) and the socket types (SOCK_*) listed in [Table 18-2](#important_constants_defined_in_the_sock),
    members of IntEnum collections. The module also defines many other constants used
    to set socket options, but the documentation does not define them fully: to use
    them you must be familiar with documentation for the C sockets library and system
    calls.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块定义了许多常量。其中最重要的是地址家族（AF_*）和套接字类型（SOCK_*），列在 [Table 18-2](#important_constants_defined_in_the_sock)
    中，作为 IntEnum 集合的成员。此外，该模块还定义了许多其他用于设置套接字选项的常量，但文档未对其进行详细定义：要使用它们，您必须熟悉 C 套接字库和系统调用的文档。
- en: Table 18-2\. Important constants defined in the socket module
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Table 18-2\. socket 模块中定义的重要常量
- en: '| AF_BLUETOOTH | Used to create sockets of the Bluetooth address family, used
    in mobile and Personal Area Network (PAN) applications. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| AF_BLUETOOTH | 用于创建蓝牙地址家族的套接字，用于移动和个人区域网络（PAN）应用中。 |'
- en: '| AF_CAN | Used to create sockets for the Controller Area Network (CAN) address
    family, widely used in automation, automotive, and embedded device applications.
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| AF_CAN | 用于创建 Controller Area Network (CAN) 地址家族的套接字，在自动化、汽车和嵌入式设备应用中广泛使用。
    |'
- en: '| AF_INET | Used to create sockets of the IPv4 address family. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| AF_INET | 用于创建 IPv4 地址族的套接字。 |'
- en: '| AF_INET6 | Used to create sockets of the IPv6 address family. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| AF_INET6 | 用于创建 IPv6 地址族的套接字。 |'
- en: '| AF_UNIX | Used to create sockets of the Unix address family. This constant
    is only defined on platforms that make Unix sockets available. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| AF_UNIX | 用于创建 Unix 地址族的套接字。此常量仅在支持 Unix 套接字的平台上定义。 |'
- en: '| SOCK_DGRAM | Used to create connectionless sockets, which provide best-effort
    message delivery without connection capabilities or error detection. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| SOCK_DGRAM | 用于创建无连接套接字，提供尽力而为的消息传递，无连接能力或错误检测。 |'
- en: '| SOCK_RAW | Used to create sockets that give direct access to the link layer
    drivers; typically used to implement lower-level network features. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| SOCK_RAW | 用于创建直接访问链路层驱动程序的套接字；通常用于实现较低级别的网络功能。 |'
- en: '| SOCK_RDM | Used to create reliable connectionless message sockets used in
    the Transparent Inter Process Communication (TIPC) protocol. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| SOCK_RDM | 用于创建在透明进程间通信（TIPC）协议中使用的可靠连接的无连接消息套接字。 |'
- en: '| SOCK_SEQPACKET | Used to create reliable connection-oriented message sockets
    used in the TIPC protocol. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| SOCK_SEQPACKET | 用于创建在 TIPC 协议中使用的可靠连接的面向连接的消息套接字。 |'
- en: '| SOCK_STREAM | Used to create connection-oriented sockets, which provide full
    error detection and correction facilities. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| SOCK_STREAM | 用于创建面向连接的套接字，提供完整的错误检测和修正功能。 |'
- en: The module defines many functions to create sockets, manipulate address information,
    and assist with standard representations of data. We do not cover all of them
    in this book, as the socket module’s [documentation](https://oreil.ly/LU9FI) is
    fairly comprehensive; we deal only with those that are essential in writing networked
    applications.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块定义了许多函数来创建套接字、操作地址信息，并辅助标准数据的表示。本书未涵盖所有函数，因为套接字模块的[文档](https://oreil.ly/LU9FI)非常全面；我们只处理编写网络应用程序中必需的部分。
- en: The socket module contains many functions, most of which are only used in specific
    situations. For example, when communication takes place between network endpoints,
    the computers at either end might have architectural differences and represent
    the same data in different ways, so there are functions to handle translation
    of a limited number of data types to and from a network-neutral form. [Table 18-3](#useful_functions_of_the_socket_module)
    lists a few of the more generally applicable functions this module provides.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字模块包含许多函数，其中大多数仅在特定情况下使用。例如，当网络端点之间进行通信时，端点可能存在架构差异，并以不同方式表示相同的数据，因此存在处理有限数据类型转换的函数，以及从网络中立形式转换的函数。[Table 18-3](#useful_functions_of_the_socket_module)列出了此模块提供的一些更普遍适用的函数。
- en: Table 18-3\. Useful functions of the socket module
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Table 18-3\. 套接字模块的有用函数
- en: '| getaddrinfo | socket.getaddrinfo(*host*, *port*, family=0, type=0, proto=0,
    flags=0) Takes a *host* and *port* and returns a list of five-item tuples of the
    form (family, type, proto, *canonical_name, socket*) usable to create a socket
    connection to a specific service. *canonical_name* is an empty string unless the
    socket.AI_CANONNAME bit is set in the flags argument. When you pass a hostname
    rather than an IP address, getaddrinfo returns a list of tuples, one per IP address
    associated with the name. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| getaddrinfo | socket.getaddrinfo(*host*, *port*, family=0, type=0, proto=0,
    flags=0) 接受*host*和*port*，返回形如(family, type, proto, *canonical_name, socket*)的五元组列表，可用于创建到特定服务的套接字连接。当您传递主机名而不是IP地址时，getaddrinfo返回一个元组列表，每个IP地址与名称关联。
    |'
- en: '| getdefa⁠u⁠l⁠t​t⁠i⁠m⁠eout | socket.getdefaulttimeout() Returns the default
    timeout value in seconds for socket operations, or **None** if no value has been
    set. Some functions let you specify explicit timeouts. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| getdefa⁠u⁠l⁠t​t⁠i⁠m⁠eout | socket.getdefaulttimeout() 返回套接字操作的默认超时值（以秒为单位），如果未设置值则返回**None**。某些函数允许您指定显式超时。
    |'
- en: '| getfqdn | socket.getfqdn([*host*]) Returns the fully qualified domain name
    associated with a hostname or network address (by default, that of the computer
    on which you call it). |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| getfqdn | socket.getfqdn([*host*]) 返回与主机名或网络地址关联的完全限定域名（默认情况下是调用它的计算机的域名）。
    |'
- en: '| gethostbyaddr | socket.gethostbyaddr(*ip_address*) Takes a string containing
    an IPv4 or IPv6 address and returns a three-item tuple of the form (*hostname*,
    *aliaslist*, *ipaddrlist*). *hostname* is the canonical name for the IP address,
    *aliaslist* is a list of alternative names, and *ipaddrlist* is a list of IPv4
    and IPv6 addresses. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| gethostbyaddr | socket.gethostbyaddr(*ip_address*) 接受包含 IPv4 或 IPv6 地址的字符串，并返回一个形如
    (*hostname*, *aliaslist*, *ipaddrlist*) 的三元组。 *hostname* 是 IP 地址的规范名称，*aliaslist*
    是一个替代名称列表，*ipaddrlist* 是一个 IPv4 和 IPv6 地址列表。 |'
- en: '| gethostbyname | socket.gethostbyname(hostname) Returns a string containing
    the IPv4 address associated with the given hostname. If called with an IP address,
    returns that address. This function does not support IPv6: use getaddrinfo for
    IPv6. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| gethostbyname | socket.gethostbyname(hostname) 返回一个包含与给定主机名关联的 IPv4 地址的字符串。如果使用
    IP 地址调用，则返回该地址。此函数不支持 IPv6：请使用 getaddrinfo 获取 IPv6。 |'
- en: '| getnameinfo | socket.getnameinfo(*sock_addr*, flags=0) Takes a socket address
    and returns a (*host*, *port*) pair. Without flags*,* *host* is an IP address
    and *port* is an int. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| getnameinfo | socket.getnameinfo(*sock_addr*, flags=0) 接受套接字地址并返回一个 (*host*,
    *port*) 对。没有标志*，* *host* 是一个 IP 地址，*port* 是一个整数。 |'
- en: '| setdefa⁠u⁠l⁠t​t⁠i⁠m⁠eout | socket.setdefaulttimeout(*timeout*) Sets sockets’
    default timeout as a value in floating-point seconds. Newly created sockets operate
    in the mode determined by the *timeout* value, as discussed in the next section.
    Pass *timeout* as **None** to cancel the implicit use of timeouts on subsequently
    created sockets. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| setdefaulttimeout | socket.setdefaulttimeout(*timeout*) 将套接字的默认超时设置为浮点秒值。新创建的套接字按照
    *timeout* 值确定的模式运行，如下一节所述。将 *timeout* 作为 **None** 传递以取消随后创建的套接字上的隐式超时使用。 |'
- en: Socket Objects
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Socket 对象
- en: The socket object is the primary means of network communication in Python. A
    new socket is also created when a SOCK_STREAM socket accepts a connection, each
    such socket being used to communicate with the relevant client.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: socket 对象是 Python 中网络通信的主要手段。当 SOCK_STREAM 套接字接受连接时，也会创建一个新的套接字，每个这样的套接字都用于与相应的客户端通信。
- en: Socket Objects and with Statements
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Socket 对象和 with 语句
- en: 'Every socket object is a context manager: you can use any socket object in
    a **with** statement to ensure proper termination of the socket at exit from the
    statement’s body. For further details, see [“The with Statement and Context Managers”](ch06.xhtml#the_with_statement_and_context_managers).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 socket 对象都是上下文管理器：您可以在 **with** 语句中使用任何 socket 对象，以确保在退出语句体时正确终止套接字。有关详细信息，请参见[“with
    语句和上下文管理器”](ch06.xhtml#the_with_statement_and_context_managers)。
- en: 'There are several ways to create a socket, as detailed in the next section.
    Sockets can operate in three different modes, shown in [Table 18-4](#timeout_values_and_their_associated_mod),
    according to the timeout value, which can be set in different ways:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种创建 socket 的方式，如下一节所述。根据超时值，套接字可以在三种不同的模式下运行，如[表18-4](#timeout_values_and_their_associated_mod)所示，可以通过不同的方式设置超时值：
- en: By providing the timeout value as an argument on socket creation
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在创建 socket 时提供超时值作为参数
- en: By calling the socket object’s settimeout method
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用 socket 对象的 settimeout 方法
- en: According to the socket module’s default timeout value as returned by the socket.getdefaulttimeout
    function
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据 socket 模块的默认超时值，由 socket.getdefaulttimeout 函数返回
- en: The timeout values to establish each possible mode are listed in [Table 18-4](#timeout_values_and_their_associated_mod).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 建立每种可能模式的超时值列在 [表18-4](#timeout_values_and_their_associated_mod) 中。
- en: Table 18-4\. Timeout values and their associated modes
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 表18-4\. 超时值及其关联模式
- en: '| **None** | Sets *blocking* mode. Each operation suspends the thread (*blocks*)
    until the operation completes, unless the operating system raises an exception.
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **None** | 设置 *阻塞* 模式。每个操作都会暂停线程（*阻塞*），直到操作完成，除非操作系统引发异常。 |'
- en: '| 0 | Sets *nonblocking* mode. Each operation raises an exception when it cannot
    be completed immediately, or when an error occurs. Use the [selectors module](https://oreil.ly/UBypi)
    to find out whether an operation can be completed immediately. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 设置 *非阻塞* 模式。每个操作在无法立即完成或发生错误时引发异常。使用 [selectors 模块](https://oreil.ly/UBypi)
    查找操作是否可以立即完成。 |'
- en: '| >0.0 | Sets *timeout* mode. Each operation blocks until complete, or the
    timeout elapses (in which case it raises a socket.timeout exception), or an error
    occurs. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| >0.0 | 设置 *超时* 模式。每个操作都会阻塞，直到完成，或超时（在这种情况下会引发 socket.timeout 异常），或发生错误。 |'
- en: Socket objects represent network endpoints. The socket module supplies several
    functions to create a socket (see [Table 18-5](#socket_creation_functions)).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字对象表示网络端点。socket 模块提供了多个函数来创建套接字（参见 [表 18-5](#socket_creation_functions)）。
- en: Table 18-5\. Socket creation functions
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 表 18-5\. 套接字创建函数
- en: '| cre⁠a⁠t⁠e⁠_​c⁠o⁠n⁠n⁠e⁠c⁠t⁠i⁠o⁠n | create_connection([*address*[, *timeout*[,
    *source_address*]]]) Creates a socket connected to a TCP endpoint at an address
    (a (*host*, *port*) pair). *host* can either be a numeric network address or a
    DNS hostname; in the latter case, name resolution is attempted for both AF_INET
    and AF_INET6 (in unspecified order), then a connection is attempted to each returned
    address in turn—a convenient way to create client programs able to use either
    IPv6 or IPv4.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '| cre⁠a⁠t⁠e⁠_​c⁠o⁠n⁠n⁠e⁠c⁠t⁠i⁠o⁠n | create_connection([*address*[, *timeout*[,
    *source_address*]]]) 创建一个连接到地址（一个（*host*, *port*）对）的 TCP 端点的套接字。*host* 可以是数字网络地址或
    DNS 主机名；在后一种情况下，将尝试为 AF_INET 和 AF_INET6（顺序不确定）进行名称解析，然后依次尝试连接返回的每个地址——这是创建既能使用
    IPv6 又能使用 IPv4 的客户端程序的便捷方式。'
- en: The *timeout* argument, if given, specifies the connection timeout in seconds
    and thereby sets the socket’s mode (see [Table 18-4](#timeout_values_and_their_associated_mod));
    when not present, the socket.getdefaulttimeout function is called to determine
    the value. The *source_address* argument, if given, must also be a (*host, port*)
    pair that the remote socket gets passed as the connecting endpoint. When *host*
    is '' or *port* is 0, the default OS behavior is used. |
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*timeout* 参数（如果提供）指定连接超时时间（单位为秒），从而设置套接字的模式（参见[表 18-4](#timeout_values_and_their_associated_mod)）；当参数不存在时，将调用
    socket.getdefaulttimeout 函数来确定该值。如果提供 *source_address* 参数，那么它也必须是一个（*host, port*）对，远程套接字将其作为连接端点传递。当
    *host* 为 '''' 或 *port* 为 0 时，将使用默认的操作系统行为。'
- en: '| socket | socket(family=AF_INET, type=SOCK_STREAM, proto=0, fileno=**None**)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '| socket | socket(family=AF_INET, type=SOCK_STREAM, proto=0, fileno=**None**)'
- en: 'Creates and returns a socket of the appropriate address family and type (by
    default, a TCP socket on IPv4). Child processes do not inherit the socket thus
    created. The protocol number proto is only used with CAN sockets. When you pass
    the fileno argument, other arguments are ignored: the function returns the socket
    already associated with the given file descriptor. |'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并返回适当地址族和类型的套接字（默认为 IPv4 上的 TCP 套接字）。子进程不会继承创建的套接字。协议编号 proto 仅在 CAN 套接字中使用。当传递
    fileno 参数时，将忽略其他参数：函数返回已关联给定文件描述符的套接字。
- en: '| socketpair | socketpair([*family*[, *type*[, *proto*]]]) Returns a connected
    pair of sockets of the given address family, socket type, and (for CAN sockets
    only) protocol. When *family* is not specified, the sockets are of family AF_UNIX
    on platforms where the family is available; otherwise, they are of family AF_INET.
    When *type* is not specified, it defaults to SOCK_STREAM. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| socketpair | socketpair([*family*[, *type*[, *proto*]]]) 返回给定地址族、套接字类型和（仅对于
    CAN 套接字）协议的连接对套接字。当未指定 *family* 时，在支持该族的平台上，套接字为 AF_UNIX；否则，它们为 AF_INET。当未指定 *type*
    时，默认为 SOCK_STREAM。'
- en: A socket object *s* provides the methods listed in [Table 18-6](#methods_of_an_instance_s_of_socket).
    Those dealing with connections or requiring connected sockets work only for SOCK_STREAM
    sockets, while the others work with both SOCK_STREAM and SOCK_DGRAM sockets. For
    methods that take a *flags* argument, the exact set of flags available depends
    on your specific platform (the values available are documented on the Unix manual
    pages for [recv(2)](https://oreil.ly/boM-c) and [send(2)](https://oreil.ly/JAaNO)
    and in the [Windows docs](https://oreil.ly/90h4R)); if omitted, *flags* defaults
    to 0.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字对象 *s* 提供了 [表 18-6](#methods_of_an_instance_s_of_socket) 中列出的方法。那些涉及连接或需要已连接套接字的方法仅适用于
    SOCK_STREAM 套接字，而其他方法适用于 SOCK_STREAM 和 SOCK_DGRAM 套接字。对于带有 *flags* 参数的方法，可用的确切标志集取决于您的特定平台（可用值在
    Unix 手册页面的 [recv(2)](https://oreil.ly/boM-c) 和 [send(2)](https://oreil.ly/JAaNO)
    中以及 [Windows 文档](https://oreil.ly/90h4R) 中有记录）；如果省略，*flags* 默认为 0。
- en: Table 18-6\. Methods of an instance s of socket
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 表 18-6\. 套接字实例 *s* 的方法
- en: '| accept | accept() Blocks until a client establishes a connection to *s*,
    which must have been bound to an address (with a call to *s*.bind) and set to
    listening (with a call to *s*.listen). Returns a *new* socket object, which can
    be used to communicate with the other endpoint of the connection. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| accept | accept() 阻塞直到客户端与 *s* 建立连接（*s* 必须已绑定到一个地址（通过调用 *s*.bind）并设置为侦听状态（通过调用
    *s*.listen））。返回一个*新*套接字对象，可用于与连接的另一端点通信。'
- en: '| bind | bind(*address*) Binds *s* to a specific address. The form of the *address*
    argument depends on the socket’s address family (see [“Socket Addresses”](#socket_addresses)).
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| bind | bind(*address*) 将 *s* 绑定到特定地址。*address* 参数的形式取决于套接字的地址族（参见[“套接字地址”](#socket_addresses)）。
    |'
- en: '| close | close() Marks the socket as closed. Calling *s*.close does not necessarily
    close the connection immediately, depending on whether other references to the
    socket exist. If immediate closure is required, call the *s*.shutdown method first.
    The simplest way to ensure a socket is closed in a timely fashion is to use it
    in a **with** statement, since sockets are context managers. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| close | close() 标记套接字为关闭状态。调用 *s*.close 并不一定会立即关闭连接，这取决于是否还有对套接字的其他引用。如果需要立即关闭连接，首先调用
    *s*.shutdown 方法。确保套接字及时关闭的最简单方法是在 **with** 语句中使用它，因为套接字是上下文管理器。 |'
- en: '| connect | connect(*address*) Connects to a remote socket at *address*. The
    form of the *address* argument depends on the address family (see [“Socket Addresses”](#socket_addresses)).
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| connect | connect(*address*) 连接到地址为 *address* 的远程套接字。*address* 参数的形式取决于地址族（参见[“套接字地址”](#socket_addresses)）。
    |'
- en: '| detach | detach() Puts the socket into closed mode, but allows the socket
    object to be reused for further connections (by calling connect again). |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| detach | detach() 将套接字置于关闭模式，但允许套接字对象用于进一步的连接（通过再次调用 connect）。 |'
- en: '| dup | dup() Returns a duplicate of the socket, not inheritable by child processes.
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| dup | dup() 返回套接字的副本，不能被子进程继承。 |'
- en: '| fileno | fileno() Returns the socket’s file descriptor. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| fileno | fileno() 返回套接字的文件描述符。 |'
- en: '| getblocking | getblocking() Returns **True** if the socket is set to be blocking,
    either with a call to *s*.setblocking(**True**) or *s*.settimeout(**None**). Otherwise,
    returns **False**. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| getblocking | getblocking() 如果套接字被设置为阻塞模式，则返回**True**，可以通过调用 *s*.setblocking(**True**)
    或 *s*.settimeout(**None**) 进行设置。否则，返回**False**。 |'
- en: '| g⁠e⁠t⁠_​i⁠n⁠h⁠e⁠r⁠i⁠t⁠a⁠b⁠l⁠e | get_inheritable() Returns **True** when the
    socket is able to be inherited by child processes. Otherwise, returns **False**.
    |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| g⁠e⁠t⁠_​i⁠n⁠h⁠e⁠r⁠i⁠t⁠a⁠b⁠l⁠e | get_inheritable() 当套接字能够被子进程继承时返回**True**。否则，返回**False**。
    |'
- en: '| getpeername | getpeername() Returns the address of the remote endpoint to
    which this socket is connected. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| getpeername | getpeername() 返回此套接字连接的远程端点的地址。 |'
- en: '| getsockname | getsockname() Returns the address being used by this socket.
    |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| getsockname | getsockname() 返回此套接字正在使用的地址。 |'
- en: '| gettimeout | gettimeout() Returns the timeout associated with this socket.
    |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| gettimeout | gettimeout() 返回与此套接字关联的超时时间。 |'
- en: '| listen | listen([*backlog*]) Starts the socket listening for traffic on its
    associated endpoint. If given, the integer *backlog* argument determines how many
    unaccepted connections the operating system allows to queue up before starting
    to refuse connections. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| listen | listen([*backlog*]) 开始监听套接字的关联端点上的流量。如果给定，整数参数 *backlog* 确定操作系统在开始拒绝连接之前允许排队的未接受连接数量。
    |'
- en: '| makefile | makefile(*mode*, buffering=**None**, *, encoding=**None**, newline=**None**)
    Returns a file object allowing the socket to be used with file-like operations
    such as read and write. The arguments are like those for the built-in open function
    (see [“Creating a File Object with open”](ch11.xhtml#creating_a_file_object_with_open)).
    *mode* can be ''r'' or ''w''; ''b'' can be added for binary transmission. The
    socket must be in blocking mode; if a timeout value is set, unexpected results
    may be observed if a timeout occurs. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| makefile | makefile(*mode*, buffering=**None**, *, encoding=**None**, newline=**None**)
    返回一个文件对象，允许套接字用于类似文件的操作，如读和写。参数类似于内置的 open 函数（参见[“使用 open 创建文件对象”](ch11.xhtml#creating_a_file_object_with_open)）。*mode*
    可以是 ''r'' 或 ''w''；对于二进制传输，可以添加 ''b''。套接字必须处于阻塞模式；如果设置了超时值，当超时发生时可能会观察到意外的结果。 |'
- en: '| recv | recv(*bufsiz*[, *flags*]) Receives and returns a maximum of *bufsiz*
    bytes of data from the socket *s*. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| recv | recv(*bufsiz*[, *flags*]) 接收并返回来自套接字 *s* 的最多 *bufsiz* 字节数据。 |'
- en: '| recvfrom | recvfrom(*bufsiz*[, *flags*]) Receives a maximum of *bufsiz* bytes
    of data from *s*. Returns a pair (*bytes*, *address*): *bytes* is the received
    data, *address* the address of the counterparty socket that sent the data. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| recvfrom | recvfrom(*bufsiz*[, *flags*]) 从 *s* 接收最多 *bufsiz* 字节的数据。返回一对（*bytes*，*address*）：*bytes*
    是接收到的数据，*address* 是发送数据的对方套接字的地址。 |'
- en: '| recvfrom_into | recvfrom_into(*buffer*[, *nbytes*[, *flags*]]) Receives a
    maximum of *nbytes* bytes of data from *s*, writing it into the given *buffer*
    object. If *nbytes* is omitted or 0, len(*buffer*) is used. Returns a pair (*nbytes*,
    *address*): *nbytes* is the number of bytes received, *address* the address of
    the counterparty socket that sent the data (**_into* functions can be faster than
    “plain” ones allocating new buffers). |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| recvfrom_into | recvfrom_into(*buffer*[, *nbytes*[, *flags*]]) 从 *s* 接收最多
    *nbytes* 字节的数据，并将其写入给定的 *buffer* 对象中。如果省略 *nbytes* 或为 0，则使用 len(*buffer*)。返回一个二元组
    (*nbytes*, *address*)：*nbytes* 是接收的字节数，*address* 是发送数据的对方套接字的地址（**_into* 函数比分配新缓冲区的“普通”函数更快）。
    |'
- en: '| recv_into | recv_into(*buffer*[, *nbytes*[, *flags*]]) Receives a maximum
    of *nbytes* bytes of data from *s*, writing it into the given *buffer* object.
    If *nbytes* is omitted or 0, len(*buffer*) is used. Returns the number of bytes
    received. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| recv_into | recv_into(*buffer*[, *nbytes*[, *flags*]]) 从 *s* 接收最多 *nbytes*
    字节的数据，并将其写入给定的 *buffer* 对象中。如果省略 *nbytes* 或为 0，则使用 len(*buffer*)。返回接收的字节数。 |'
- en: '| recvmsg | recvmsg(*bufsiz*[, *ancbufsiz*[, *flags*]]) Receives a maximum
    of *bufsiz* bytes of data on the socket and a maximum of *ancbufsiz* bytes of
    ancillary (“out-of-band”) data. Returns a four-item tuple (*data*, *ancdata*,
    *msg_flags*, *address*), where *bytes* is the received data, *ancdata* is a list
    of three-item (*cmsg_level*, *cmsg_type*, *cmsg_data*) tuples representing the
    received ancillary data, *msg_flags* holds any flags received with the message
    (documented on the Unix manual page for the [recv(2)](https://oreil.ly/boM-c)
    system call or in the [Windows docs](https://oreil.ly/90h4R)), and *address* is
    the address of the counterparty socket that sent the data (if the socket is connected,
    this value is undefined, but the sender can be determined from the socket). |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| recvmsg | recvmsg(*bufsiz*[, *ancbufsiz*[, *flags*]]) 在套接字上接收最多 *bufsiz*
    字节的数据和最多 *ancbufsiz* 字节的辅助（“带外”）数据。返回一个四元组 (*data*, *ancdata*, *msg_flags*, *address*)，其中
    *data* 是接收的数据，*ancdata* 是表示接收的辅助数据的三元组 (*cmsg_level*, *cmsg_type*, *cmsg_data*)
    列表，*msg_flags* 包含与消息一起接收的任何标志（在 Unix 手册页中记录了 [recv(2)](https://oreil.ly/boM-c)
    系统调用或 [Windows 文档](https://oreil.ly/90h4R)中有详细说明），*address* 是发送数据的对方套接字的地址（如果套接字已连接，则此值未定义，但可以从套接字中确定发送方）。
    |'
- en: '| send | send(*bytes*[, *flags*]) Sends the given data *bytes* over the socket,
    which must already be connected to a remote endpoint. Returns the number of bytes
    sent, which you should check: the call may not transmit all data, in which case
    transmission of the remainder will have to be separately requested. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| send | send(*bytes*[, *flags*]) 将给定的数据 *bytes* 发送到已连接到远程端点的套接字上。返回发送的字节数，应检查：调用可能不会传输所有数据，此时必须单独请求剩余部分的传输。
    |'
- en: '| sendall | sendall(*bytes*[, *flags*]) Sends all the given data *bytes* over
    the socket, which must already be connected to a remote endpoint. The socket’s
    timeout value applies to the transmission of all the data, even if multiple transmissions
    are needed. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| sendall | sendall(*bytes*[, *flags*]) 将所有给定的数据 *bytes* 发送到已连接到远程端点的套接字上。套接字的超时值适用于所有数据的传输，即使需要多次传输也是如此。
    |'
- en: '| sendfile | sendfile(*file,* offset=0, count=**None**) Send the contents of
    file object *file* (which must be open in binary mode) to the connected endpoint.
    On platforms where os.sendfile is available, it’s used; otherwise, the send call
    is used. offset, if any, determines the starting byte position in the file from
    which transmission begins; count sets the maximum number of bytes to transmit.
    Returns the total number of bytes transmitted. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| sendfile | sendfile(*file,* offset=0, count=**None**) 将文件对象 *file* 的内容（必须以二进制模式打开）发送到连接的端点。在支持
    os.sendfile 的平台上，使用该函数；否则，使用 send 调用。如果指定了 offset，则确定从文件中哪个字节位置开始传输；count 设置要传输的最大字节数。返回传输的总字节数。
    |'
- en: '| sendmsg | sendmsg(*buffers*[, *ancdata*[, *flags*[, *address*]]]) Sends normal
    and ancillary (out-of-band) data to the connected endpoint. *buffers* should be
    an iterable of bytes-like objects. The *ancdata* argument should be an iterable
    of (*data, ancdata, msg_flags, address*) tuples representing the ancillary data.
    *msg_flags* are flags documented on the Unix manual page for the send(2) system
    call or in the [Windows docs](https://oreil.ly/90h4R). *address* should only be
    provided for an unconnected socket, and determines the endpoint to which the data
    is sent. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| sendmsg | sendmsg(*buffers*[, *ancdata*[, *flags*[, *address*]]]) 向连接的端点发送普通和辅助（带外）数据。
    *buffers* 应该是类字节对象的可迭代对象。 *ancdata* 参数应该是 (*data, ancdata, msg_flags, address*)
    元组的可迭代对象，表示辅助数据。 *msg_flags* 是在 Unix 手册页上的 send(2) 系统调用或在 [Windows 文档](https://oreil.ly/90h4R)
    中记录的标志位。 *address* 应仅在未连接的套接字中提供，并确定要发送数据的端点。 |'
- en: '| sendto | sendto(*bytes*,[*flags*,]*address*) Transmits the *bytes* (*s* must
    not be connected) to the given socket address, and returns the number of bytes
    sent. The optional *flags* argument has the same meaning as for recv. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| sendto | sendto(*bytes*,[*flags*,]*address*) 将 *bytes*（*s* 不能连接）传输到给定的套接字地址，并返回发送的字节数。
    可选的 *flags* 参数与 recv 中的含义相同。 |'
- en: '| setblocking | setblocking(*flag*) Determines whether *s* operates in blocking
    mode (see [“Socket Objects”](#socket_objects)), according to the truth value of
    *flag**.* *s*.setblocking(**True**) works like *s*.settimeout(**None**); *s*.set_blocking(**False**)
    works like *s*.settimeout(0.0). |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| setblocking | setblocking(*flag*) 根据 *flag* 的真值确定 *s* 是否以阻塞模式运行（见 [“套接字对象”](#socket_objects)）。
    *s*.setblocking(**True**) 的作用类似于 *s*.settimeout(**None**)； *s*.set_blocking(**False**)
    的作用类似于 *s*.settimeout(0.0)。 |'
- en: '| s⁠e⁠t⁠_​i⁠n⁠h⁠e⁠r⁠i⁠t⁠a⁠b⁠l⁠e | set_inheritable(*flag*) Determines whether
    the socket gets inherited by child processes, according to the truth value of
    *flag*. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| set_inheritable | set_inheritable(*flag*) 根据 *flag* 的真值确定套接字是否由子进程继承。 |'
- en: '| settimeout | settimeout(*timeout*) Establishes the mode of *s* (see [“Socket
    Objects”](#socket_objects)) according to the value of *timeout*. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| settimeout | settimeout(*timeout*) 根据 *timeout* 的值（见 [“套接字对象”](#socket_objects)）建立
    *s* 的模式。 |'
- en: '| shutdown | shutdown(*how*) Shuts down one or both halves of a socket connection
    according to the value of the *how* argument, as detailed here:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '| shutdown | shutdown(*how*) 根据 *how* 参数的值关闭套接字连接的一个或两个部分，如此处详细说明：'
- en: socket.SHUT_RD
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket.SHUT_RD`'
- en: No further receive operations can be performed on *s*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*s* 上不能再执行更多的接收操作。'
- en: socket.SHUT_RDWR
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket.SHUT_RDWR`'
- en: No further receive or send operations can be performed on *s*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*s* 上不能再执行更多的接收或发送操作。'
- en: socket.SHUT_WR
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket.SHUT_WR`'
- en: No further send operations can be performed on *s*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*s* 上不能再执行更多的发送操作。'
- en: '|'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: A socket object *s* also has the attributes family (*s*’s socket family) and
    type (*s*’s socket type).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字对象 *s* 还具有属性 family（*s* 的套接字家族）和 type（*s* 的套接字类型）。
- en: A Connectionless Socket Client
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无连接套接字客户端
- en: 'Consider a simplistic packet-echo service, where a client sends text encoded
    in UTF-8 to a server, which sends the same information back to the client. In
    a connectionless service, all the client has to do is send each chunk of data
    to the defined server endpoint:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个简单的数据包回显服务，在这个服务中，客户端将使用 UTF-8 编码的文本发送到服务器，服务器将相同的信息返回给客户端。 在无连接服务中，客户端只需将每个数据块发送到定义的服务器端点：
- en: '[PRE0]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that the server only performs a bytes-oriented echo function. The client,
    therefore, encodes its Unicode data into bytestrings, and decodes the bytestring
    responses received from the server back into Unicode text using the same encoding.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，服务器仅执行基于字节的回显功能。 因此，客户端将其 Unicode 数据编码为字节串，并使用相同的编码将从服务器接收的字节串响应解码为 Unicode
    文本。
- en: A Connectionless Socket Server
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无连接套接字服务器
- en: A server for the packet-echo service described in the previous section is also
    quite simple. It binds to its endpoint, receives packets (datagrams) at that endpoint,
    and returns to the client sending each datagram a packet with exactly the same
    data. The server treats all clients equally and does not need to use any kind
    of concurrency (though this last handy characteristic might not hold for a service
    where request handling takes more time).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节描述的数据包回显服务的服务器也非常简单。 它绑定到其端点，在该端点接收数据包（数据报），并向客户端返回每个数据报具有完全相同数据的数据包。 服务器平等地对待所有客户端，不需要使用任何类型的并发（尽管这种最后一个方便的特性可能不适用于处理请求时间更长的服务）。
- en: 'The following server works, but offers no way to terminate the service other
    than by interrupting it (typically from the keyboard, with Ctrl-C or Ctrl-Break):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下服务器工作，但除了通过中断（通常从键盘上的Ctrl-C或Ctrl-Break）无其他终止服务的方法：
- en: '[PRE1]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Neither is there any mechanism to handle dropped packets and similar network
    problems; this is often acceptable in simple services.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 同样没有任何机制来处理丢包和类似的网络问题；这在简单服务中通常是可以接受的。
- en: 'You can run the same programs using IPv6: simply replace the socket type AF_INET
    with AF_INET6.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用IPv6运行相同的程序：只需将套接字类型AF_INET替换为AF_INET6。
- en: A Connection-Oriented Socket Client
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向连接的套接字客户端
- en: 'Now consider a simplistic connection-oriented “echo-like” protocol: a server
    lets clients connect to its listening socket, receives arbitrary bytes from them,
    and sends back to each client the same bytes that client sent to the server, until
    the client closes the connection. Here’s an example of an elementary test client:^([3](ch18.xhtml#ch01fn138))'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一个简单的面向连接的“回显式”协议：服务器允许客户端连接到其监听套接字，从客户端接收任意字节，并将服务器接收到的相同字节发送回每个客户端，直到客户端关闭连接。以下是一个基本测试客户端的示例：^([3](ch18.xhtml#ch01fn138))
- en: '[PRE2]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note that the data is text, so it must be encoded with a suitable representation.
    We chose the usual suspect, UTF-8\. The server works in terms of bytes (since
    it is bytes, aka octets, that travel on the network); the received bytes object
    gets decoded with UTF-8 back into Unicode text before printing. Any other suitable
    codec could be used instead: the key point is that text must be encoded before
    transmission and decoded after reception. The server, working in terms of bytes,
    does not even need to know which encoding is being used, except maybe for logging
    purposes.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意数据是文本，因此必须用适当的表示方法进行编码。我们选择了常见的UTF-8编码。服务器以字节为单位工作（因为是字节（也称为八位字节）在网络上传输）；接收到的字节对象在打印之前会用UTF-8解码为Unicode文本。也可以选择其他合适的编解码器：关键是在传输之前对文本进行编码，在接收后进行解码。服务器在字节方面工作，甚至不需要知道使用的是哪种编码，除了可能用于日志记录之类的目的。
- en: A Connection-Oriented Socket Server
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向连接的套接字服务器
- en: 'Here is a simplistic server corresponding to the testing client shown in the
    previous section, using multithreading via concurrent.futures (covered in [“The
    concurrent.futures Module”](ch15.xhtml#the_concurrentdotfutures_module)):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的服务器，对应于前一节中显示的测试客户端，使用并发.future进行多线程处理（详见[“concurrent.futures模块”](ch15.xhtml#the_concurrentdotfutures_module)）：
- en: '[PRE3]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This server has its limits. In particular, it runs only 20 threads, so it cannot
    simultaneously serve more than 20 clients; any further client trying to connect
    while 20 others are already being served waits in servsock’s listening queue.
    Should that queue fill up with five clients waiting to be accepted, further clients
    attempting connection get rejected outright. This server is intended just as an
    elementary example for demonstration purposes, not as a solid, scalable, or secure
    system.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务器有其局限性。特别是，它仅运行20个线程，因此无法同时为超过20个客户端提供服务；当20个其他客户端正在接受服务时，试图连接的进一步客户端将等待在servsock的监听队列中。如果队列填满了等待接受的五个客户端，试图连接的进一步客户端将被直接拒绝。此服务器仅作为演示示例而非坚固、可扩展或安全系统。
- en: As before, the same programs can be run using IPv6 by replacing the socket type
    AF_INET with AF_INET6.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，可以通过将套接字类型AF_INET替换为AF_INET6来使用IPv6运行相同的程序。
- en: Transport Layer Security
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传输层安全性
- en: Transport Layer Security (TLS), the successor of Secure Sockets Layer (SSL),
    provides privacy and data integrity over TCP/IP, helping you defend against server
    impersonation, eavesdropping on the bytes being exchanged, and malicious alteration
    of those bytes. For an introduction to TLS, we recommend the extensive [Wikipedia
    entry](https://oreil.ly/EzLWt).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 传输层安全性（TLS）是安全套接字层（SSL）的后继者，提供TCP/IP上的隐私和数据完整性，帮助防止服务器冒充、窃听交换的字节以及恶意修改这些字节。对于TLS的介绍，我们推荐阅读广泛的[Wikipedia条目](https://oreil.ly/EzLWt)。
- en: In Python, you can use TLS via the ssl module of the standard library. To use
    ssl well, you need a good grasp of its rich [online docs](https://oreil.ly/2EGr0),
    as well as a deep and broad understanding of TLS itself (the Wikipedia article,
    excellent and vast as it is, can only begin to cover this large, difficult subject).
    In particular, you must study and thoroughly understand the [security considerations
    section of the online docs](https://oreil.ly/ohqtT), as well as all the materials
    found at the many links helpfully offered in that section.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，您可以通过标准库的ssl模块使用TLS。要很好地使用ssl，您需要深入理解其丰富的[在线文档](https://oreil.ly/2EGr0)，以及TLS本身的深入广泛理解（尽管作为一个庞大而复杂的主题，维基百科的文章只是开始涵盖这个话题）。特别是，您必须研究并彻底理解[在线文档安全考虑部分](https://oreil.ly/ohqtT)，以及该部分提供的众多有用链接中的所有材料。
- en: 'If these warnings make it sound as though a perfect implementation of security
    precautions is a daunting task, that’s because it *is.* In security, you’re pitting
    your wits and skills against those of sophisticated attackers who may be more
    familiar with the nooks and crannies of the problems involved: they specialize
    in finding workarounds and breaking in, while (usually) your focus is not exclusively
    on such issues—rather, you’re trying to provide some useful services in your code.
    It’s risky to see security as an afterthought or a secondary point—it *has* to
    be front and center throughout, to win said battle of skills and wits.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些警告使您觉得完美实施安全预防措施是一项艰巨的任务，那是因为它确实如此。在安全领域，您需要将智慧和技能与那些可能更熟悉所涉问题细节的高级攻击者的智慧和技能相比较：他们专注于发现漏洞和入侵方法，而您的焦点通常不仅限于此类问题——相反，您试图在代码中提供一些有用的服务。将安全视为事后或次要问题是有风险的——它必须始终处于核心位置，以赢得技术和智慧之战。
- en: That said, we strongly recommend that all readers undertake the study of TLS
    mentioned above—the better all developers understand security considerations,
    the better off we all are (except, we guess, the security-breaker wannabes!).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们强烈建议所有读者进行上述TLS学习——开发者对安全考虑的理解越深入，我们就越安全（除了那些渴望破解安全系统的人）。
- en: Unless you have acquired a really deep and broad understanding of TLS and Python’s
    ssl module (in which case, you’ll know what exactly to do—better than we possibly
    could!), we recommend using an SSLContext instance to hold all the details of
    your use of TLS. Build that instance with the ssl.create_default_context function,
    add your certificate if needed (it *is* needed if you’re writing a secure server),
    then use the instance’s wrap_socket method to wrap (almost^([4](ch18.xhtml#ch01fn139)))
    every socket.socket instance you make into an instance of ssl.SSLSocket—behaving
    almost identically to the socket object it wraps, but nearly transparently adding
    security checks and validation “on the side.”
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您已经深入广泛地了解了TLS和Python的ssl模块（在这种情况下，您会知道应该做什么——比我们可能的建议更好！），我们建议使用SSLContext实例来保存TLS使用的所有细节。使用ssl.create_default_context函数构建该实例，如果需要，添加您的证书（如果您正在编写安全服务器，则需要这样做），然后使用实例的wrap_socket方法将您创建的每个socket.socket实例包装成ssl.SSLSocket实例——它的行为几乎与包装的socket对象相同，但几乎透明地添加了安全检查和验证“在一侧”。
- en: The default TLS contexts strike a good compromise between security and broad
    usability, and we recommend you stick with them (unless you’re knowledgeable enough
    to fine-tune and tighten security for special needs). If you need to support outdated
    counterparts that are unable to use the most recent, most secure implementations
    of TLS, you may feel tempted to learn just enough to relax your security demands.
    Do that at your own risk—we most definitely *don’t* recommend wandering into such
    territory!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的TLS上下文在安全性和广泛适用性之间取得了良好的折衷，我们建议您坚持使用它们（除非您足够了解以便为特殊需求调整和加强安全性）。如果您需要支持无法使用最新、最安全的TLS实现的过时对应方案，您可能会有种放松安全要求的冲动。但请自行承担风险——我们绝对不建议冒险进入这样的领域！
- en: In the following sections, we cover the minimal subset of ssl you need to be
    familiar with if you just want to follow our recommendations. But even if that
    is the case, *please* also read up on TLS and ssl, just to gain some background
    knowledge about the intricate issues involved. It may stand you in good stead
    one day!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍您在仅想遵循我们建议时需要熟悉的ssl的最小子集。但即使是这种情况，也请*务必*阅读有关TLS和ssl的内容，以便对所涉及的复杂问题有所了解。这可能在某一天对您大有裨益！
- en: SSLContext
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SSLContext
- en: The ssl module supplies an ssl.SSLContext class, whose instances hold information
    about TLS configuration (including certificates and private keys) and offer many
    methods to set, change, check, and use that information. If you know exactly what
    you’re doing, you can manually instantiate, set up, and use your own SSLContext
    instances for your own specialized purposes.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ssl 模块提供了 ssl.SSLContext 类，其实例保存关于 TLS 配置的信息（包括证书和私钥），并提供许多方法来设置、更改、检查和使用这些信息。如果你确切知道自己在做什么，你可以手动实例化、设置和使用自己专门目的的
    SSLContext 实例。
- en: 'However, we recommend instead that you instantiate an SSLContext using the
    well-tuned function ssl.create_default_context, with a single argument: ssl.Purpose.CLIENT_AUTH
    if your code is a server (and thus may need to authenticate clients), or ssl.Purpose.SERVER_AUTH
    if your code is a client (and thus definitely needs to authenticate servers).
    If your code is both a client to some servers and a server to other clients (as,
    for example, some internet proxies are), then you’ll need two instances of SSLContext,
    one for each purpose.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们建议你使用经过良好调整的函数 ssl.create_default_context 实例化 SSLContext，只需一个参数：ssl.Purpose.CLIENT_AUTH
    如果你的代码是服务器（因此可能需要对客户端进行认证），或者 ssl.Purpose.SERVER_AUTH 如果你的代码是客户端（因此绝对需要对服务器进行认证）。如果你的代码既是某些服务器的客户端又是其他客户端的服务器（例如一些互联网代理），那么你将需要两个
    SSLContext 实例，每个目的一个。
- en: 'For most client-side uses, your SSLContext is ready. If you’re coding a server,
    or a client for one of the rare servers that require TLS authentication of the
    clients, you need to have a certificate file and a key file (see the [online docs](https://oreil.ly/mBPJ0)
    to learn how to obtain these files). Add them to the SSLContext instance (so that
    counterparties can verify your identity) by passing the paths to the certificate
    and key files to the load_cert_chain method with code like the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数客户端使用场景，你的 SSLContext 已经准备好了。如果你在编写服务器端或者一个少数需要对客户端进行 TLS 认证的服务器的客户端，你需要有一个证书文件和一个密钥文件（参见[在线文档](https://oreil.ly/mBPJ0)了解如何获取这些文件）。通过将证书和密钥文件的路径传递给
    load_cert_chain 方法，将它们添加到 SSLContext 实例中（以便对方可以验证你的身份），例如：
- en: '[PRE4]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once your context instance *ctx* is ready, if you’re coding a client, just
    call *ctx*.wrap_socket to wrap any socket you’re about to connect to a server,
    and use the wrapped result (an instance of ssl.SSLSocket) instead of the socket
    you just wrapped. For example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的上下文实例 *ctx* 准备好了，如果你在编写客户端，只需调用 *ctx*.wrap_socket 来包装你即将连接到服务器的任何套接字，并使用包装后的结果（一个
    ssl.SSLSocket 实例）而不是刚刚包装的套接字。例如：
- en: '[PRE5]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that, in the client case, you should also pass wrap_socket a server_hostname
    argument corresponding to the server you’re about to connect to; this way, the
    connection can verify that the identity of the server you end up connecting to
    is indeed correct, an absolutely crucial security step.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在客户端的情况下，你还应该传递一个 server_hostname 参数给 wrap_socket，该参数对应你即将连接的服务器；这样，连接可以验证你最终连接到的服务器的身份是否确实正确，这是绝对关键的安全步骤。
- en: 'Server-side, *don’t* wrap the socket that you are binding to an address, listening
    on, or accepting connections on; just wrap the new socket that accept returns.
    For example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，*不要* 包装绑定到地址、监听或接受连接的套接字；只需包装 accept 返回的新套接字。例如：
- en: '[PRE6]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this case, you need to pass wrap_socket the argument server_side=**True**
    so it knows that you’re on the server side of things.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你需要向 wrap_socket 传递参数 server_side=**True**，以便它知道你是服务器端的操作。
- en: Again, we recommend consulting the online docs—particularly the [examples](https://oreil.ly/r6hQ7)—for
    better understanding, even if you stick to just this simple subset of ssl operations.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强烈建议查阅在线文档，尤其是[示例](https://oreil.ly/r6hQ7)，以便更好地理解，即使你仅仅使用 SSL 操作的这个简单子集。
- en: ^([1](ch18.xhtml#ch01fn136-marker)) When you code an application program, you
    normally use sockets through higher-abstraction layers, such as those covered
    in [Chapter 19](ch19.xhtml#client_side_network_protocol_modules).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch18.xhtml#ch01fn136-marker)) 当你编写应用程序时，通常会通过更高级别的抽象层（如第 19 章中涵盖的那些）来使用套接字。
- en: ^([2](ch18.xhtml#ch01fn137-marker)) And the relatively newfangled multiplexed
    connections transport protocol [QUIC](https://oreil.ly/1XwoM), supported in Python
    by third-party [aioquic](https://oreil.ly/uh_1O).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch18.xhtml#ch01fn137-marker)) 还有相对较新的多路复用连接传输协议 [QUIC](https://oreil.ly/1XwoM)，在
    Python 中由第三方 [aioquic](https://oreil.ly/uh_1O) 支持。
- en: ^([3](ch18.xhtml#ch01fn138-marker)) This client example isn’t secure; see [“Transport
    Layer Security”](#transport_layer_security) for an introduction to making it secure.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch18.xhtml#ch01fn138-marker)) 这个客户端示例并不安全；参见[“传输层安全性”](#transport_layer_security)了解如何使其安全。
- en: ^([4](ch18.xhtml#ch01fn139-marker)) We say “almost” because, when you code a
    server, you don’t wrap the socket you bind, listen on, and accept connections
    from.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch18.xhtml#ch01fn139-marker)) 我们说“几乎”是因为，当你编写服务器时，你不会包装你绑定、监听和接受连接的套接字。
