<html><head></head><body><section data-pdf-bookmark="Chapter 5. Package Management" data-type="chapter" epub:type="chapter"><div class="chapter" id="package_management">&#13;
<h1><span class="label">Chapter 5. </span>Package Management</h1>&#13;
&#13;
&#13;
<p><a data-primary="package management" data-type="indexterm" id="ix_ch05-asciidoc0"/>Often<a data-primary="package management" data-secondary="about" data-type="indexterm" id="idm46691332363176"/>, small scripts grow in usefulness and importance, which creates a need to share and distribute their contents. Python libraries, as well as other code projects, require packaging.  Without packaging, distributing code becomes problematic and brittle.</p>&#13;
&#13;
<p>Once past the proof of concept stage, it is helpful to keep track of changes, advertise the type of change (for example, when introducing a backward-incompatible update), and provide a way for users to depend on a specific version. Even in the most straightforward use cases, it is beneficial to follow a few (packaging) guidelines. This, at the very least, should mean keeping track of a changelog and determining a <span class="keep-together">version.</span></p>&#13;
&#13;
<p>There are several strategies to follow for package management, and knowing a few of the ones most commonly used allows you to adopt the best option to solve a problem. For example, it might be easier to distribute a Python library through the <a data-primary="PyPI (Python Package Index)" data-type="indexterm" id="idm46691332359752"/><a data-primary="Python Package Index (PyPI)" data-type="indexterm" id="idm46691332359080"/>Python Package Index (PyPI) instead of making it a system package like Debian and RPM. If a Python script needs to run at specific intervals or if it is a long-running process, then system packaging working together with <code>systemd</code> might work better.</p>&#13;
&#13;
<p>Although <code>systemd</code> is not a packaging tool, it does play well on systems that depend on it to manage processes and the server startup sequence.  Learning how to handle processes with a few <code>systemd</code> configuration settings and some packaging is a great way to increase the capabilities of a Python project further.</p>&#13;
&#13;
<p>The native Python packaging tools have a public hosting instance for packages (PyPI). However, for Debian and RPM packages, it requires some effort to provide a local repository. This chapter covers a few tools that make it easier to create and manage a package repository, including a local alternative to PyPI.</p>&#13;
&#13;
<p>Having a good understanding of the different packaging strategies, and healthy practices like proper versioning and keeping a changelog, provide a stable, consistent experience when distributing software.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Why Is Packaging Important?" data-type="sect1"><div class="sect1" id="idm46691332354536">&#13;
<h1>Why Is Packaging Important?</h1>&#13;
&#13;
<p><a data-primary="package management" data-secondary="importance of" data-type="indexterm" id="idm46691332353192"/>Several factors make packaging software an essential feature of a project (regardless of size!). Keeping track of versions and changes (via a changelog) is an excellent way to provide some insight into new features and bug fixes. Versioning allows others to determine better what might work within a project.</p>&#13;
&#13;
<p>When trying to identify issues and bugs, a changelog with an accurate description of changes is an invaluable tool to help identify potential causes of system breakage.</p>&#13;
&#13;
<p>It takes discipline and hard work to version a project, describe changes in a changelog, and provide a way for others to install and use a project. However, the benefits when distributing, debugging, upgrading, or even uninstalling are significant.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="When Packaging Might Not Be Needed" data-type="sect2"><div class="sect2" id="idm46691332350376">&#13;
<h2>When Packaging Might Not Be Needed</h2>&#13;
&#13;
<p><a data-primary="package management" data-secondary="when packaging might not be needed" data-type="indexterm" id="idm46691332349032"/>Sometimes you don’t need to distribute a project to other systems at all. Ansible playbooks are usually run from one server to manage other systems in the network. In cases like Ansible, it might be enough to follow versioning and keep a changelog.</p>&#13;
&#13;
<p>Version control systems like Git make this easy with the use of tags. Tagging in <a data-primary="Git" data-secondary="tagging in" data-type="indexterm" id="idm46691332347208"/>Git would still be useful if a project does need to get packaged, since most tooling can consume the tag (as long as a tag represents a version) to produce a package.</p>&#13;
&#13;
<p>Recently, there was a long debug session to determine why an installer for a large software project had stopped working. Suddenly, all the functional tests for a small Python tool that depended on the installer completing its deployment were failing. The installer did have versions and kept those versions synchronized with version control, but there was no changelog whatsoever that would have explained that recent changes were going to break an existing API. To find the issue, we had to go through all the recent commits to determine what could be the problem.</p>&#13;
&#13;
<p>Going through a few commits shouldn’t be difficult, but try doing so on a project with more than four thousand commits! After finding the cause, two tickets were opened: one that explained the bug and another one to ask for a changelog.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Packaging Guidelines" data-type="sect1"><div class="sect1" id="idm46691332344168">&#13;
<h1>Packaging Guidelines</h1>&#13;
&#13;
<p><a data-primary="package management" data-secondary="guidelines" data-type="indexterm" id="ix_ch05-asciidoc1"/>Before packaging, a few things are worth considering so that the process is as smooth as possible. Even when you don’t plan to package a product, these guidelines help to improve a project overall.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Projects in version control are always ready to be packaged.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Descriptive Versioning" data-type="sect2"><div class="sect2" id="idm46691332339976">&#13;
<h2>Descriptive Versioning</h2>&#13;
&#13;
<p><a data-primary="descriptive versioning" data-type="indexterm" id="idm46691332338360"/><a data-primary="package management" data-secondary="descriptive versioning" data-type="indexterm" id="idm46691332337656"/><a data-primary="versioning, descriptive" data-type="indexterm" id="idm46691332336712"/>There are many ways to version software, but it is a good idea to follow a well-known schema. The Python developer’s guide <a href="https://oreil.ly/C3YKO">has a clear definition</a> for acceptable forms of versioning.</p>&#13;
&#13;
<p>The versioning schema is meant to be extremely flexible, while keeping an eye on consistency so that installer tooling can make sense and prioritize accordingly (for example, a stable version over a beta one). In its purest form, and most commonly in Python packages, the following two variants are used: <a data-primary="major.minor" data-type="indexterm" id="idm46691332334376"/><code>major.minor</code> or <a data-primary="major.minor.micro" data-type="indexterm" id="idm46691332333288"/><code>major.minor.micro</code>.</p>&#13;
&#13;
<p>Valid versions would then look like:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>0.0.1</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>1.0</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>2.1.1</code></p>&#13;
</li>&#13;
</ul>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Although there are many variations described by the excellent Python developer’s guide, concentrate on the simpler forms (listed above). They are good enough to produce packages, while adhering to most guidelines for both system and native Python packages.</p>&#13;
</div>&#13;
&#13;
<p>A commonly accepted format for releases is <code>major.minor.micro</code> (and also used by the <a href="https://semver.org">Semantic Versioning scheme</a>):</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>major</code> for backward-incompatible changes</p>&#13;
</li>&#13;
<li>&#13;
<p><code>minor</code> adds features that are also backward compatible</p>&#13;
</li>&#13;
<li>&#13;
<p><code>micro</code> adds backward-compatible bug fixes</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Following the listed versions above, you can deduce that a dependency on an application with version <code>1.0.0</code> might break with version <code>2.0.0</code>.</p>&#13;
&#13;
<p>Once the decision for a release occurs, then it is easy to determine the version number. Assuming the current released version of the project under development is <code>1.0.0</code>, it means the following outcomes are possible:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>If the release has backward-incompatible changes, the version is: <code>2.0.0</code></p>&#13;
</li>&#13;
<li>&#13;
<p>If the release has added features that do not break compatibility, the version is <code>1.1.0</code></p>&#13;
</li>&#13;
<li>&#13;
<p>If the release is to fix issues that also do not break compatibility, the version is <code>1.0.1</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Once a schema is being followed, then a release process is immediately descriptive. Although it would be nice for all software to follow a similar pattern, some projects have a completely different schema of their own. For example, the <a href="https://ceph.com">Ceph</a> project uses the following: <code>major.[0|1|2].minor</code></p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>major</code> indicates a major release, while not necessarily breaking backward-compatibility.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>0</code>, <code>1</code>, or <code>2</code> mean (in order) development release, release candidate, or stable <span class="keep-together">version.</span></p>&#13;
</li>&#13;
<li>&#13;
<p><code>minor</code> is used only for bug fixes and never for features.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>That schema would mean that <code>14.0.0</code> is a development release, while <code>14.2.1</code> is a bug fix release for the stable version of the major release (<code>14</code> in this case).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The changelog" data-type="sect2"><div class="sect2" id="idm46691332339272">&#13;
<h2>The changelog</h2>&#13;
&#13;
<p><a data-primary="changelog" data-secondary="package management" data-type="indexterm" id="idm46691332303912"/><a data-primary="package management" data-secondary="changelog" data-type="indexterm" id="idm46691332302936"/>As we have mentioned already, it is important to keep track of releases and what they mean in the context of a version number. Keeping a changelog is not that difficult, once a versioning schema is chosen. Although it can be a single file, large projects tend to break it down into smaller files in a directory. Best practice is using a simple format that is descriptive and easy to maintain.</p>&#13;
&#13;
<p>The following example is an actual portion of a <em>changelog</em> file in a production Python tool:</p>&#13;
&#13;
<pre data-code-language="restructuredtext" data-type="programlisting"><code class="gh">1.1.3</code>&#13;
<code class="gh">^^^^^</code>&#13;
22-Mar-2019&#13;
&#13;
<code class="m">*</code> No code changes - adding packaging files for Debian&#13;
&#13;
<code class="gh">1.1.2</code>&#13;
<code class="gh">^^^^^</code>&#13;
13-Mar-2019&#13;
&#13;
<code class="m">*</code> Try a few different executables (not only <code class="s">``python``</code>) to check for a working&#13;
  one, in order of preference, starting with <code class="s">``python3``</code> and ultimately falling&#13;
  back to the connection interpreter</pre>&#13;
&#13;
<p>The example provides four essential pieces of information:</p>&#13;
<ol>&#13;
<li>&#13;
<p>The latest version number released</p>&#13;
</li>&#13;
<li>&#13;
<p>Whether the latest release is backward compatible</p>&#13;
</li>&#13;
<li>&#13;
<p>The release date of the last version</p>&#13;
</li>&#13;
<li>&#13;
<p>Changes included in the release</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>The file doesn’t need to be of a specific format, as long as it is consistent and informative. A proper changelog can provide several pieces of information with little effort. It is tempting to try and automate the task of writing a changelog with every release, but we would advise against a fully automated process: nothing beats a well-written, thoughtful entry about a bug fix or a feature added.</p>&#13;
&#13;
<p>A poorly automated changelog is one that uses all the version control commits included in the release. This is not a good practice, since you can get the same information by listing the commits.<a data-startref="ix_ch05-asciidoc1" data-type="indexterm" id="idm46691332280808"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Choosing a Strategy" data-type="sect1"><div class="sect1" id="idm46691332293432">&#13;
<h1>Choosing a Strategy</h1>&#13;
&#13;
<p><a data-primary="package management" data-secondary="strategies" data-type="indexterm" id="idm46691332292024"/>Understanding the type of distribution needed and what infrastructure services are available helps determine what type of packaging to use. Pure Python libraries that extend functionality for other Python projects are suitable as a native Python package, hosted on the Python Package Index (PyPI) or a local index.</p>&#13;
&#13;
<p>Standalone scripts and long-running processes are good candidates for system packages like RPM or Debian, but ultimately, it depends on what type of systems are available and if it is at all possible to host (and manage) a repository. In the case of long-running processes, the packaging can have rules to configure a <a data-primary="systemd" data-type="indexterm" id="idm46691332289864"/><code>systemd</code> unit that makes it available as a controllable process. <code>systemd</code> allows for the graceful handling of start, stop, or restart operations. These are things that aren’t possible with native Python packaging.</p>&#13;
&#13;
<p>In general, the more a script or process needs to interact with a system, the better it is suited to a system package or a container. When writing a Python-only script, conventional Python packaging is the right choice.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>There aren’t hard requirements on what strategy to choose. It depends!  Pick the best environment available for distribution (RPM if the servers are CentOS, for example). Different types of packaging are not mutually exclusive; one project can offer multiple packaging formats at the same time.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Packaging Solutions" data-type="sect1"><div class="sect1" id="idm46691332238664">&#13;
<h1>Packaging Solutions</h1>&#13;
&#13;
<p><a data-primary="package management" data-secondary="solutions" data-type="indexterm" id="ix_ch05-asciidoc2"/>In this section, the details on how to create a package and host it are covered.</p>&#13;
&#13;
<p>To simplify the code examples, assume a small Python project called <code>hello-world</code> with the following structure:</p>&#13;
&#13;
<pre data-type="programlisting">hello-world&#13;
└── hello_world&#13;
    ├── __init__.py&#13;
    └── main.py&#13;
&#13;
1 directory, 2 files</pre>&#13;
&#13;
<p>The project has a top-level directory called <code>hello-world</code> and a subdirectory (<code>hello_world</code>) with two files in it. Depending on the packaging choice, different files are needed to create a package.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Native Python Packaging" data-type="sect2"><div class="sect2" id="idm46691332232808">&#13;
<h2>Native Python Packaging</h2>&#13;
&#13;
<p><a data-primary="native Python packaging" data-type="indexterm" id="ix_ch05-asciidoc3"/><a data-primary="package management" data-secondary="native Python packaging" data-type="indexterm" id="ix_ch05-asciidoc4"/>By far the simplest solution is using the native Python packaging tooling and hosting (via PyPI). Like the rest of the other packaging strategies, the project requires some files used by <code>setuptools</code>.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>One easy way to source a virtual environment is to create a <code>bash</code> or <code>zsh</code> alias that both cd’s into the directory and sources the environment, like this: <code>alias sugar="source ~/.sugar/bin/activate &amp;&amp; cd ~/src/sugar"</code></p>&#13;
</div>&#13;
&#13;
<p>To continue, create a new virtual environment and then activate:</p>&#13;
&#13;
<pre data-type="programlisting">$ python3 -m venv /tmp/packaging&#13;
$ source /tmp/packaging/bin/activate</pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><code>setuptools</code> is a requirement to produce a native Python package. It is a collection of tools and helpers to create and distribute Python packages.</p>&#13;
</div>&#13;
&#13;
<p>Once the virtual environment is active,  the following dependencies exist:</p>&#13;
<dl>&#13;
<dt><code>setuptools</code></dt>&#13;
<dd>&#13;
<p>A set of utilities for packaging</p>&#13;
</dd>&#13;
<dt><code>twine</code></dt>&#13;
<dd>&#13;
<p>A tool for registering and uploading packages</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Install them by running the following command:</p>&#13;
&#13;
<pre data-type="programlisting">$ pip install setuptools twine</pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>A very easy way to figure out what is installed is to use <code>IPython</code> and this snippet to list all of the Python packages as a <code>JSON</code> data <span class="keep-together">structure:</span></p>&#13;
&#13;
<pre data-code-language="python3" data-type="programlisting"><code class="n">In</code> <code class="p">[</code><code class="mi">1</code><code class="p">]:</code> <code class="err">!</code><code class="n">pip</code> <code class="nb">list</code> <code class="o">--</code><code class="nb">format</code><code class="o">=</code><code class="n">json</code>&#13;
&#13;
<code class="p">[{</code><code class="s2">"name"</code><code class="p">:</code> <code class="s2">"appnope"</code><code class="p">,</code> <code class="s2">"version"</code><code class="p">:</code> <code class="s2">"0.1.0"</code><code class="p">},</code>&#13;
 <code class="p">{</code><code class="s2">"name"</code><code class="p">:</code> <code class="s2">"astroid"</code><code class="p">,</code> <code class="s2">"version"</code><code class="p">:</code> <code class="s2">"2.2.5"</code><code class="p">},</code>&#13;
 <code class="p">{</code><code class="s2">"name"</code><code class="p">:</code> <code class="s2">"atomicwrites"</code><code class="p">,</code> <code class="s2">"version"</code><code class="p">:</code> <code class="s2">"1.3.0"</code><code class="p">},</code>&#13;
 <code class="p">{</code><code class="s2">"name"</code><code class="p">:</code> <code class="s2">"attrs"</code><code class="p">,</code> <code class="s2">"version"</code><code class="p">:</code> <code class="s2">"19.1.0"</code><code class="p">}]</code></pre>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Package files" data-type="sect3"><div class="sect3" id="idm46691332200904">&#13;
<h3>Package files</h3>&#13;
&#13;
<p><a data-primary="native Python packaging" data-secondary="package files" data-type="indexterm" id="ix_ch05-asciidoc5"/><a data-primary="package files" data-secondary="for native Python packaging" data-type="indexterm" id="ix_ch05-asciidoc6"/>To produce the native Python package, we have to add a few files. To keep things simple, focus on the minimum amount of files needed to produce the package. The file that describes the package to <code>setuptools</code> is named <em>setup.py</em>. It exists at the top-level directory. For the example project, this is how that file looks:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="kn">from</code> <code class="nn">setuptools</code> <code class="kn">import</code> <code class="n">setup</code><code class="p">,</code> <code class="n">find_packages</code>&#13;
&#13;
<code class="n">setup</code><code class="p">(</code>&#13;
    <code class="n">name</code><code class="o">=</code><code class="s2">"hello-world"</code><code class="p">,</code>&#13;
    <code class="n">version</code><code class="o">=</code><code class="s2">"0.0.1"</code><code class="p">,</code>&#13;
    <code class="n">author</code><code class="o">=</code><code class="s2">"Example Author"</code><code class="p">,</code>&#13;
    <code class="n">author_email</code><code class="o">=</code><code class="s2">"author@example.com"</code><code class="p">,</code>&#13;
    <code class="n">url</code><code class="o">=</code><code class="s2">"example.com"</code><code class="p">,</code>&#13;
    <code class="n">description</code><code class="o">=</code><code class="s2">"A hello-world example package"</code><code class="p">,</code>&#13;
    <code class="n">packages</code><code class="o">=</code><code class="n">find_packages</code><code class="p">(),</code>&#13;
    <code class="n">classifiers</code><code class="o">=</code><code class="p">[</code>&#13;
        <code class="s2">"Programming Language :: Python :: 3"</code><code class="p">,</code>&#13;
        <code class="s2">"License :: OSI Approved :: MIT License"</code><code class="p">,</code>&#13;
        <code class="s2">"Operating System :: OS Independent"</code><code class="p">,</code>&#13;
    <code class="p">],</code>&#13;
<code class="p">)</code></pre>&#13;
&#13;
<p>The <em>setup.py</em> file will import two helpers from the <code>setuptools</code> module: <code>setup</code> and <code>find_packages</code>. The <a data-primary="setup() function" data-type="indexterm" id="idm46691332069352"/><code>setup</code> function is what requires the rich description about the package. The <a data-primary="find_packages() function" data-type="indexterm" id="idm46691332068344"/><code>find_packages</code> function is a utility to automatically detect where the Python files are. Additionally, the file imports <code>classifiers</code> that describe certain aspects of the package, such as the license, operating systems supported, and Python versions. These <em>classifiers</em> are called <em>trove classifiers</em>, and the <a href="https://pypi.org/classifiers">Python Package Index</a> has a detailed description of other classifiers available. Detailed descriptions make a package get discovered when uploaded to PyPI.</p>&#13;
&#13;
<p class="pagebreak-before">With just the addition of this one file, we can already produce a package, in this case, a <em>source distribution</em> package. Without a <em>README</em> file, a warning appears when running the commands. To prevent this, add an empty one in the top-level directory with the command: <a data-primary="touch README command" data-type="indexterm" id="idm46691332063240"/><code>touch README</code>.</p>&#13;
&#13;
<p>The contents of the project directory should look like this:</p>&#13;
&#13;
<pre data-type="programlisting">hello-world&#13;
├── hello_world&#13;
│   ├── __init__.py&#13;
│   └── main.py&#13;
└── README&#13;
└── setup.py&#13;
&#13;
1 directory, 4 files</pre>&#13;
&#13;
<p>To produce the <em>source distribution</em> from it, run the following command:</p>&#13;
&#13;
<pre data-type="programlisting">python3 setup sdist</pre>&#13;
&#13;
<p>The output should look similar to the following:</p>&#13;
&#13;
<pre data-type="programlisting">$ python3 setup.py sdist&#13;
running sdist&#13;
running egg_info&#13;
writing hello_world.egg-info/PKG-INFO&#13;
writing top-level names to hello_world.egg-info/top_level.txt&#13;
writing dependency_links to hello_world.egg-info/dependency_links.txt&#13;
reading manifest file 'hello_world.egg-info/SOURCES.txt'&#13;
writing manifest file 'hello_world.egg-info/SOURCES.txt'&#13;
running check&#13;
creating hello-world-0.0.1&#13;
creating hello-world-0.0.1/hello_world&#13;
creating hello-world-0.0.1/hello_world.egg-info&#13;
copying files to hello-world-0.0.1...&#13;
copying README -&gt; hello-world-0.0.1&#13;
copying setup.py -&gt; hello-world-0.0.1&#13;
copying hello_world/__init__.py -&gt; hello-world-0.0.1/hello_world&#13;
copying hello_world/main.py -&gt; hello-world-0.0.1/hello_world&#13;
Writing hello-world-0.0.1/setup.cfg&#13;
Creating tar archive&#13;
removing 'hello-world-0.0.1' (and everything under it)</pre>&#13;
&#13;
<p>At the top-level directory of the project, a new directory called <em>dist</em> is there; it contains the <em>source distribution</em>: a file <em>hello-world-0.0.1.tar.gz</em>. If we check the contents of the directory, it has changed once again:</p>&#13;
&#13;
<pre data-type="programlisting">hello-world&#13;
├── dist&#13;
│   └── hello-world-0.0.1.tar.gz&#13;
├── hello_world&#13;
│   ├── __init__.py&#13;
│   └── main.py&#13;
├── hello_world.egg-info&#13;
│   ├── dependency_links.txt&#13;
│   ├── PKG-INFO&#13;
│   ├── SOURCES.txt&#13;
│   └── top_level.txt&#13;
├── README&#13;
└── setup.py&#13;
&#13;
3 directories, 9 files</pre>&#13;
&#13;
<p>The newly created <em>tar.gz</em> file is an installable package! This package can now be uploaded to PyPI for others to install directly from it. By following the version schema, it allows installers to ask for a specific version (<code>0.0.1</code> in this case), and the extra metadata passed into the <code>setup()</code> function enables other tools to discover it and show information about it, such as the author, description, and version.</p>&#13;
&#13;
<p>The Python installer tool <code>pip</code> can be used to install the <em>tar.gz</em> file directly. To try it out, use the path to the file as an argument:<a data-startref="ix_ch05-asciidoc6" data-type="indexterm" id="idm46691332051048"/><a data-startref="ix_ch05-asciidoc5" data-type="indexterm" id="idm46691332050344"/></p>&#13;
&#13;
<pre data-type="programlisting">$ pip install dist/hello-world-0.0.1.tar.gz&#13;
Processing ./dist/hello-world-0.0.1.tar.gz&#13;
Building wheels for collected packages: hello-world&#13;
  Building wheel for hello-world (setup.py) ... done&#13;
Successfully built hello-world&#13;
Installing collected packages: hello-world&#13;
Successfully installed hello-world-0.0.1</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Python Package Index" data-type="sect3"><div class="sect3" id="idm46691332154872">&#13;
<h3>The Python Package Index</h3>&#13;
&#13;
<p><a data-primary="native Python packaging" data-secondary="PyPI" data-type="indexterm" id="idm46691332047160"/><a data-primary="PyPI (Python Package Index)" data-type="indexterm" id="idm46691332046184"/><a data-primary="Python Package Index (PyPI)" data-type="indexterm" id="idm46691332045448"/>The Python Package Index (PyPI) is a repository of Python software that allows users to host Python packages and also install from it. It is maintained by and for the community with the help of sponsors and donations as part of the <a href="https://www.python.org/psf">Python Software Foundation</a>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>This section requires registration for the <em>test instance</em> of PyPI. Make sure you have an account already or <a href="https://oreil.ly/lyVVx">register online</a>.  You need your username and password for the account to upload packages.</p>&#13;
</div>&#13;
&#13;
<p>In the sample <em>setup.py</em> file, an example email address contains a placeholder. If the package is going to get published to the index, this needs to be updated to reflect the same email address that owns the project at PyPI. Update any other fields, like the <code>author</code>, <code>url</code>, and <code>description</code>, to more accurately reflect the project being built.</p>&#13;
&#13;
<p>To make sure things work correctly, and to avoid <em>pushing to production</em>, the package is tested by uploading it to the test instance of PyPI. This test instance behaves the same as production and verifies that a package works correctly.</p>&#13;
&#13;
<p>The <code>setuptools</code> and the <em>setup.py</em> file is the traditional method of  uploading a package to PyPI. A new approach, called <code>twine</code>, can simplify things.</p>&#13;
&#13;
<p>At the beginning of this section, <code>twine</code> got installed in the virtual environment.  Next, it can be used to upload the package to the test instance of PyPI. The following command uploads the <em>tar.gz</em> file and prompts for the username and password:</p>&#13;
&#13;
<pre data-type="programlisting">$ twine upload --repository-url https://test.pypi.org/legacy/ \&#13;
  dist/hello-world-0.0.1.tar.gz&#13;
Uploading distributions to https://test.pypi.org/legacy/&#13;
Enter your username:&#13;
Enter your password:</pre>&#13;
&#13;
<p>To test out whether the package made it, we can try and install it with <code>pip</code>:</p>&#13;
&#13;
<pre data-type="programlisting">$ python3 -m pip install --index-url https://test.pypi.org/simple/ hello-world</pre>&#13;
&#13;
<p>The command looks like it has a space in the PyPI URL, but the index URL ends in <span class="keep-together"><code>/simple/</code></span>, and <code>hello-world</code> is another argument that indicates the name of the Python package to be installed.</p>&#13;
&#13;
<p>For an actual production release, an account would need to exist or be <a href="https://pypi.org/account/register">created</a>. The same steps that are taken to upload to the test instance, including the validation, would also work for the <em>real</em> PyPI.</p>&#13;
&#13;
<p>Older Python packaging guides may reference commands such as:</p>&#13;
&#13;
<pre data-type="programlisting"> $ python setup.py register&#13;
 $ python setup.py upload</pre>&#13;
&#13;
<p>These may still work and are part of the <code>setuptools</code> set of utilities to package and upload projects to a package index. However, <code>twine</code> offers secure authentication over HTTPS, and allows signing with <code>gpg</code>. Twine works regardless if <code>python setup.py upload</code> doesn’t, and finally, it provides a way to test a package before uploading to the index.</p>&#13;
&#13;
<p>A final item to point out is that it may be helpful to create a <code>Makefile</code> and put a <code>make</code> command in it that automatically deploys your project and builds the documentation for you. Here is an example of how that could work:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">deploy-pypi:&#13;
  pandoc --from<code class="o">=</code>markdown --to<code class="o">=</code>rst README.md -o README.rst&#13;
  python setup.py check --restructuredtext --strict --metadata&#13;
  rm -rf dist&#13;
  python setup.py sdist&#13;
  twine upload dist/*&#13;
  rm -f README.rst</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Hosting an internal package index" data-type="sect3"><div class="sect3" id="idm46691332048104">&#13;
<h3>Hosting an internal package index</h3>&#13;
&#13;
<p><a data-primary="internal package index" data-type="indexterm" id="ix_ch05-asciidoc7"/><a data-primary="native Python packaging" data-secondary="hosting internal package index" data-type="indexterm" id="ix_ch05-asciidoc8"/>In some situations, it might be preferable to host an internal PyPI.</p>&#13;
&#13;
<p>A company where Alfredo used to work had private libraries that were not supposed to be public at all, so it was a requirement to host an instance of PyPI. Hosting has its caveats, though. All dependencies and versions of those dependencies have to exist in the instance; otherwise, installs can fail. An installer can’t fetch dependencies from different sources at the same time! On more than one occasion, a new version had a missing component, so that package had to be uploaded for the install to complete correctly.</p>&#13;
&#13;
<p>If package <em>A</em> is hosted internally and has requirements on packages <em>B</em> and <em>C</em>, all three need to exist (along with their required versions) in the same instance.</p>&#13;
&#13;
<p>An internal PyPI makes installations go faster, can keep packages private, and at its core, isn’t challenging to accomplish.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>A highly recommended full-featured tool for hosting an internal PyPI is <code>devpi</code>. It has features like mirroring, staging, replication, and Jenkins integration. The <a href="http://doc.devpi.net">project documentation</a> has great examples and detailed information.</p>&#13;
</div>&#13;
&#13;
<p>First, create a new directory called <code>pypi</code> so that you can create a proper structure for hosting packages, and then create a subdirectory with the name of our example package (<code>hello-world</code>). The names of subdirectories are the names of the packages <span class="keep-together">themselves:</span></p>&#13;
&#13;
<pre data-type="programlisting">$ mkdir -p pypi/hello-world&#13;
$ tree pypi&#13;
pypi&#13;
└── hello-world&#13;
&#13;
1 directory, 0 files</pre>&#13;
&#13;
<p>Now copy the <em>tar.gz</em> file into the <em>hello-world</em> directory. The final version of this directory structure should look like this:</p>&#13;
&#13;
<pre data-type="programlisting">$ tree pypi&#13;
pypi&#13;
└── hello-world&#13;
    └── hello-world-0.0.1.tar.gz&#13;
&#13;
1 directory, 1 file</pre>&#13;
&#13;
<p>The next step is to create a web server with auto indexing enabled. Python comes with a built-in web server that is good enough to try this out, and it even has the auto indexing enabled by default! Change directories to the <em>pypi</em> directory containing the <code>hello-world</code> package and start the built-in web server:</p>&#13;
&#13;
<pre data-type="programlisting">$ python3 -m http.server&#13;
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</pre>&#13;
&#13;
<p>In a new terminal session, create a temporary virtual environment to try out installing the <code>hello-world</code> package from the local PyPI instance. Activate it, and finally, try installing it by pointing <code>pip</code> to the custom local URL:</p>&#13;
&#13;
<pre data-type="programlisting">$ python3 -m venv /tmp/local-pypi&#13;
$ source /tmp/local-pypi/bin/activate&#13;
(local-pypi) $ pip install -i http://localhost:8000/ hello-world&#13;
Looking in indexes: http://localhost:8000/&#13;
Collecting hello-world&#13;
  Downloading http://localhost:8000/hello-world/hello-world-0.0.1.tar.gz&#13;
Building wheels for collected packages: hello-world&#13;
  Building wheel for hello-world (setup.py) ... done&#13;
Successfully built hello-world&#13;
Installing collected packages: hello-world&#13;
Successfully installed hello-world-0.0.1</pre>&#13;
&#13;
<p>In the session where the <code>http.server</code> module is running, there should be some logs demonstrating all the requests the installer made to retrieve the <code>hello-world</code> <span class="keep-together">package:</span></p>&#13;
&#13;
<pre data-type="programlisting">Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...&#13;
127.0.0.1 [09:58:37] "GET / HTTP/1.1" 200 -&#13;
127.0.0.1 [09:59:39] "GET /hello-world/ HTTP/1.1" 200 -&#13;
127.0.0.1 [09:59:39] "GET /hello-world/hello-world-0.0.1.tar.gz HTTP/1.1" 200</pre>&#13;
&#13;
<p>A production environment needs a better-performing web server. The <code>http.server</code> module is used in this example for simplicity, but it isn’t meant to handle simultaneous multiple requests or scaling out.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>When building a local index without a tool like <code>devpi</code>, there is a defined specification that includes descriptions of normalized names for the directory structure. This specification can be found in <a href="https://oreil.ly/sRcAe">PEP 503</a><a data-startref="ix_ch05-asciidoc8" data-type="indexterm" id="idm46691331941912"/><a data-startref="ix_ch05-asciidoc7" data-type="indexterm" id="idm46691331941208"/>.<a data-startref="ix_ch05-asciidoc4" data-type="indexterm" id="idm46691331940408"/><a data-startref="ix_ch05-asciidoc3" data-type="indexterm" id="idm46691331939704"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Debian Packaging" data-type="sect2"><div class="sect2" id="idm46691332232312">&#13;
<h2>Debian Packaging</h2>&#13;
&#13;
<p><a data-primary="Debian packaging" data-type="indexterm" id="ix_ch05-asciidoc9"/><a data-primary="package management" data-secondary="Debian packaging" data-type="indexterm" id="ix_ch05-asciidoc10"/>If targetting Debian (or a Debian-based distribution such as Ubuntu) for distributing a project, additional files are required. Understanding what these files are and how the Debian packaging tools use them improves the process of producing an installable <code>.deb</code> package and troubleshooting issues.</p>&#13;
&#13;
<p>Some of these plain-text files require a <em>very</em> strict formatting, and if the format is even slightly incorrect, the packaging cannot install.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>This section assumes the packaging is in a Debian or Debian-based distro, so that it is easier to install and use the required packaging tools.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Package files" data-type="sect3"><div class="sect3" id="idm46691331932392">&#13;
<h3>Package files</h3>&#13;
&#13;
<p><a data-primary="Debian packaging" data-secondary="package files" data-type="indexterm" id="idm46691331931016"/><a data-primary="package files" data-secondary="for Debian packaging" data-type="indexterm" id="idm46691331930040"/>Debian packaging needs a <em>debian</em> directory with a few files in it. To narrow the scope of what is needed to produce a package, most of the available options are skipped, such as running a test suite before completing a build or declaring multiple Python versions.</p>&#13;
&#13;
<p>Create the <em>debian</em> directory where all required files exist. In the end, the <code>hello-world</code> project structure should look like this:</p>&#13;
&#13;
<pre data-type="programlisting">$ tree&#13;
.&#13;
├── debian&#13;
├── hello_world&#13;
│   ├── __init__.py&#13;
│   └── main.py&#13;
├── README&#13;
└── setup.py&#13;
&#13;
2 directories, 4 files</pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Note that the directory includes the <em>setup.py</em> and <em>README</em> file from the native Python packaging section. It is required because Debian tooling uses these to produce the <code>.deb</code> package.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The changelog file" data-type="sect4"><div class="sect4" id="idm46691331923416">&#13;
<h4>The changelog file</h4>&#13;
&#13;
<p><a data-primary="changelog" data-secondary="Debian packaging" data-type="indexterm" id="idm46691331921848"/><a data-primary="Debian packaging" data-secondary="changelog file" data-type="indexterm" id="idm46691331920872"/>This file can be complicated to get right if done by hand. The errors produced when this file is not formatted correctly are not easy to debug. Most Debian packaging workflows rely on the <code>dch</code> tool to enhance debuggability.</p>&#13;
&#13;
<p>I’ve ignored my advice before and have tried to manually create this file. In the end I wasted time because error reporting is not very good, and spotting issues is very difficult. Below is an example of an entry in the <em>changelog</em> file that caused a problem:</p>&#13;
&#13;
<pre data-type="programlisting">--Alfredo Deza &lt;alfredo@example.com&gt; Sat, 11 May 2013 2:12:00 -0800</pre>&#13;
&#13;
<p>That entry produced the following error:</p>&#13;
&#13;
<pre data-type="programlisting">parsechangelog/debian: warning: debian/changelog(l7): found start of entry where&#13;
  expected more change data or trailer</pre>&#13;
&#13;
<p>Can you spot the fix?</p>&#13;
&#13;
<pre data-type="programlisting">-- Alfredo Deza &lt;alfredo@example.com&gt; Sat, 11 May 2013 2:12:00 -0800</pre>&#13;
&#13;
<p>A <em>space</em> between the dashes and my name was the cause. Save yourself the heartache and use <code>dch</code>. The tool is part of the <code>devscripts</code> package:</p>&#13;
&#13;
<pre data-type="programlisting">$ sudo apt-get install devscripts</pre>&#13;
&#13;
<p>The <code>dch</code> command-line tool has many options, and it is useful to go through its documentation (the main page is comprehensive). We are going to run it to create the changelog for the first time (this requires the one-time use of the <code>--create</code> flag). Before running it, export your full name and email so that they get into the generated file:</p>&#13;
&#13;
<pre data-type="programlisting">$ export DEBEMAIL="alfredo@example.com"&#13;
$ export DEBFULLNAME="Alfredo Deza"</pre>&#13;
&#13;
<p>Now run <code>dch</code> to produce the changelog:</p>&#13;
&#13;
<pre data-type="programlisting">$ dch --package "hello-world" --create -v "0.0.1" \&#13;
  -D stable "New upstream release"</pre>&#13;
&#13;
<p>The newly created file should look similar to this:</p>&#13;
&#13;
<pre data-type="programlisting">hello-world (0.0.1) stable; urgency=medium&#13;
&#13;
  * New upstream release&#13;
&#13;
 -- Alfredo Deza &lt;alfredo@example.com&gt;  Thu, 11 Apr 2019 20:28:08 -0400</pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The Debian changelog is specific to Debian packaging. It is fine to have a separate changelog for the project when the format doesn’t fit or if other information needs updating. Lots of projects keep the Debian <em>changelog</em> file as a separate Debian-only file.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The control file" data-type="sect4"><div class="sect4" id="idm46691331922760">&#13;
<h4>The control file</h4>&#13;
&#13;
<p><a data-primary="control file" data-type="indexterm" id="idm46691331903800"/><a data-primary="Debian packaging" data-secondary="control file" data-type="indexterm" id="idm46691331903096"/>This is the file that defines the package name, its description, and any dependencies needed for building and running the project. It also has a strict format, but it doesn’t need to change much (unlike the <em>changelog</em>). The file ensures that Python 3 is required and that it follows Debian’s Python naming guidelines.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In the transition from Python 2 to Python 3, most distributions settled on using the following schema for Python 3 packages: <code>python3-{package name}</code>.</p>&#13;
</div>&#13;
&#13;
<p>After adding the dependencies, naming conventions, and a short description, this is how the file should look:</p>&#13;
&#13;
<pre data-type="programlisting">Source: hello-world&#13;
Maintainer: Alfredo Deza &lt;alfredo@example.com&gt;&#13;
Section: python&#13;
Priority: optional&#13;
Build-Depends:&#13;
 debhelper (&gt;= 11~),&#13;
 dh-python,&#13;
 python3-all&#13;
 python3-setuptools&#13;
Standards-Version: 4.3.0&#13;
&#13;
Package: python3-hello-world&#13;
Architecture: all&#13;
Depends: ${misc:Depends}, ${python3:Depends}&#13;
Description: An example hello-world package built with Python 3</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Other required files" data-type="sect4"><div class="sect4" id="idm46691331897832">&#13;
<h4>Other required files</h4>&#13;
&#13;
<p><a data-primary="Debian packaging" data-secondary="required files" data-type="indexterm" id="idm46691331896296"/>There are a few other files needed to produce a Debian package. Most of them are just a couple of lines long and change infrequently.</p>&#13;
&#13;
<p>The <em>rules</em> file is an executable file that tells Debian what to run to produce the package; in this case it should look like the following:</p>&#13;
&#13;
<pre data-code-language="make" data-type="programlisting"><code class="c">#!/usr/bin/make -f</code>&#13;
&#13;
<code class="k">export </code><code class="nv">DH_VERBOSE</code><code class="o">=</code>1&#13;
&#13;
<code class="k">export </code><code class="nv">PYBUILD_NAME</code><code class="o">=</code>remoto&#13;
&#13;
<code class="nf">%</code><code class="o">:</code>&#13;
    dh <code class="k">$@</code> --with python3 --buildsystem=pybuild</pre>&#13;
&#13;
<p>The <em>compat</em> file sets the corresponding <code>debhelper</code> (another packaging tool) compatibility, recommended to be set to <code>10</code> here. You might check to see whether a higher value is required if an error message complains about it:</p>&#13;
&#13;
<pre data-type="programlisting">$ cat compat&#13;
10</pre>&#13;
&#13;
<p>Without a license, the build process might not work, and it is a good idea to state the license explicitly. This particular example uses the MIT license, and this is how it should look in <em>debian/copyright</em>:</p>&#13;
&#13;
<pre data-type="programlisting">Format: http://www.debian.org/doc/packaging-manuals/copyright-format/1.0&#13;
Upstream-Name: hello-world&#13;
Source: https://example.com/hello-world&#13;
&#13;
Files: *&#13;
Copyright: 2019 Alfredo Deza&#13;
License: Expat&#13;
&#13;
License: Expat&#13;
  Permission is hereby granted, free of charge, to any person obtaining a&#13;
  copy of this software and associated documentation files (the "Software"),&#13;
  to deal in the Software without restriction, including without limitation&#13;
  the rights to use, copy, modify, merge, publish, distribute, sublicense,&#13;
  and/or sell copies of the Software, and to permit persons to whom the&#13;
  Software is furnished to do so, subject to the following conditions:&#13;
  .&#13;
  The above copyright notice and this permission notice shall be included in&#13;
  all copies or substantial portions of the Software.&#13;
  .&#13;
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&#13;
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&#13;
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL&#13;
  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER&#13;
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING&#13;
  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER&#13;
  DEALINGS IN THE SOFTWARE.</pre>&#13;
&#13;
<p>Finally, after adding all these new files to the <code>debian</code> directory, the <code>hello-world</code> project looks like this:</p>&#13;
&#13;
<pre data-type="programlisting">.&#13;
├── debian&#13;
│   ├── changelog&#13;
│   ├── compat&#13;
│   ├── control&#13;
│   ├── copyright&#13;
│   └── rules&#13;
├── hello_world&#13;
│   ├── __init__.py&#13;
│   └── main.py&#13;
├── README&#13;
└── setup.py&#13;
&#13;
2 directories, 9 files</pre>&#13;
</div></section>&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Producing the binary" data-type="sect3"><div class="sect3" id="idm46691331897240">&#13;
<h3>Producing the binary</h3>&#13;
&#13;
<p><a data-primary="binaries" data-secondary="Debian" data-type="indexterm" id="idm46691331889272"/><a data-primary="Debian packaging" data-secondary="producing the binary" data-type="indexterm" id="idm46691331853128"/>To produce the binary, use the <a data-primary="debuild command-line tool" data-type="indexterm" id="idm46691331852056"/><code>debuild</code> command-line tool. For this example project, the package remains unsigned (the signing process requires a GPG key), and the <code>debuild</code> documentation uses an example that allows skipping the signing.  The script is run from inside the source tree to build only the binary package.  This command works for the <code>hello-world</code> project (truncated version shown here):</p>&#13;
&#13;
<pre data-type="programlisting">$ debuild -i -us -uc -b&#13;
...&#13;
dpkg-deb: building package 'python3-hello-world'&#13;
in '../python3-hello-world_0.0.1_all.deb'.&#13;
...&#13;
 dpkg-genbuildinfo --build=binary&#13;
 dpkg-genchanges --build=binary &gt;../hello-world_0.0.1_amd64.changes&#13;
dpkg-genchanges: info: binary-only upload (no source code included)&#13;
 dpkg-source -i --after-build hello-world-debian&#13;
dpkg-buildpackage: info: binary-only upload (no source included)&#13;
Now running lintian hello-world_0.0.1_amd64.changes ...&#13;
E: hello-world changes: bad-distribution-in-changes-file stable&#13;
Finished running lintian.</pre>&#13;
&#13;
<p>A <em>python3-hello-world_0.0.1_all.deb</em> should now exist in the upper directory.  The lintian call (a Debian packaging linter) complains at the very end that the <em>changelog</em> file has an invalid distribution, which is fine because we aren’t targeting a single distribution in particular (for example, Debian Buster). Rather, we are building a package that will most likely install in any Debian-base distro that complies with the dependencies (only Python 3, in this case).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Debian repositories" data-type="sect3"><div class="sect3" id="idm46691331887272">&#13;
<h3>Debian repositories</h3>&#13;
&#13;
<p><a data-primary="Debian packaging" data-secondary="Debian repositories" data-type="indexterm" id="idm46691331885352"/><a data-primary="Debian repositories" data-type="indexterm" id="idm46691331884376"/>There are many tools to automate Debian repositories, but it is useful to understand how to go about creating one (Alfredo even helped <a href="https://oreil.ly/hJMgY">develop one</a> for both RPM and Debian!). To continue, ensure that the binary package created previously is available at a known location:</p>&#13;
&#13;
<pre data-type="programlisting">$ mkdir /opt/binaries&#13;
$ cp python3-hello-world_0.0.1_all.deb /opt/binaries/</pre>&#13;
&#13;
<p>For this section, the <code>reprepro</code> tool needs to be installed:</p>&#13;
&#13;
<pre data-type="programlisting">$ sudo apt-get install reprepro</pre>&#13;
&#13;
<p>Create a new directory somewhere in the system to hold packages. This example uses <em>/opt/repo</em>. The basic configuration for a repository needs a file, called <code>distributions</code>, that describes the contents and looks like this:</p>&#13;
&#13;
<pre data-type="programlisting">Codename: sid&#13;
Origin: example.com&#13;
Label: example.com&#13;
Architectures: amd64 source&#13;
DscIndices: Sources Release .gz .bz2&#13;
DebIndices: Packages Release . .gz .bz2&#13;
Components: main&#13;
Suite: stable&#13;
Description: example repo for hello-world package&#13;
Contents: .gz .bz2</pre>&#13;
&#13;
<p>Save this file at <em>/opt/repo/conf/distributions</em>. Create another directory to hold the actual repo:</p>&#13;
&#13;
<pre data-type="programlisting">$ mkdir /opt/repo/debian/sid</pre>&#13;
&#13;
<p>To create the repository, instruct <code>reprepro</code> to use the <em>distributions</em> file created, and that the base directory is <em>/opt/repo/debian/sid</em>. Finally, add the binary previously created as a target for the Debian sid distribution:</p>&#13;
&#13;
<pre data-type="programlisting">$ reprepro --confdir /opt/repo/conf/distributions -b /opt/repo/debian/sid \&#13;
  -C main includedeb sid /opt/binaries/python3-hello-world_0.0.1_all.deb&#13;
Exporting indices...</pre>&#13;
&#13;
<p>This command creates the repo for the Debian sid distribution! This command can be adapted for a different Debian-based distribution such as Ubuntu Bionic, for example. To do so would only require replacing <code>sid</code> with <code>bionic</code>.</p>&#13;
&#13;
<p>Now that the repo exists, the next step is to ensure that it works as expected. For a production environment, a robust web server like Apache or Nginx would be a good choice, but to test this, use Python’s <code>http.server</code> module. Change directories to the directory containing the repository, and start the server:</p>&#13;
&#13;
<pre data-type="programlisting">$ cd /opt/repo/debian/sid&#13;
$ python3 -m http.server&#13;
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</pre>&#13;
&#13;
<p>Aptitude (or <code>apt</code>, the Debian package manager) needs some configuration to be aware of this new location for packages. This configuration is a simple file with a single line in it pointing to the URL and components of our repo. Create a file at <em>/etc/apt/sources.lists.d/hello-world.list</em>. It should look like this:</p>&#13;
&#13;
<pre data-type="programlisting">$ cat /etc/apt/sources.list.d/hello-world.list&#13;
deb [trusted=yes] http://localhost:8000/ sid main</pre>&#13;
&#13;
<p>The <code>[trusted=yes]</code> configuration tells <code>apt</code> not to enforce signed packages. On repositories that are properly signed, this step is not necessary.</p>&#13;
&#13;
<p>After adding the file, update <code>apt</code> so that it recognizes the new location, and look for (and install) the <code>hello-world</code> package:</p>&#13;
&#13;
<pre data-type="programlisting">$ sudo apt-get update&#13;
Ign:1 http://localhost:8000 sid InRelease&#13;
Get:2 http://localhost:8000 sid Release [2,699 B]&#13;
Ign:3 http://localhost:8000 sid Release.gpg&#13;
Get:4 http://localhost:8000 sid/main amd64 Packages [381 B]&#13;
Get:5 http://localhost:8000 sid/main amd64 Contents (deb) [265 B]&#13;
Fetched 3,345 B in 1s (6,382 B/s)&#13;
Reading package lists... Done</pre>&#13;
&#13;
<p>Searching for the <code>python3-hello-world</code> package provides the description added in the <em>distributions</em> file when configuring <code>reprepro</code>:</p>&#13;
&#13;
<pre data-type="programlisting">$ apt-cache search python3-hello-world&#13;
python3-hello-world - An example hello-world package built with Python 3</pre>&#13;
&#13;
<p>Installing and removing the package should work without a problem:<a data-startref="ix_ch05-asciidoc10" data-type="indexterm" id="idm46691332241432"/><a data-startref="ix_ch05-asciidoc9" data-type="indexterm" id="idm46691331819384"/></p>&#13;
&#13;
<pre data-type="programlisting">$ sudo apt-get install python3-hello-world&#13;
Reading package lists... Done&#13;
Building dependency tree&#13;
Reading state information... Done&#13;
The following NEW packages will be installed:&#13;
  python3-hello-world&#13;
0 upgraded, 1 newly installed, 0 to remove and 48 not upgraded.&#13;
Need to get 2,796 B of archives.&#13;
Fetched 2,796 B in 0s (129 kB/s)&#13;
Selecting previously unselected package python3-hello-world.&#13;
(Reading database ... 242590 files and directories currently installed.)&#13;
Preparing to unpack .../python3-hello-world_0.0.1_all.deb ...&#13;
Unpacking python3-hello-world (0.0.1) ...&#13;
Setting up python3-hello-world (0.0.1) ...&#13;
$ sudo apt-get remove --purge python3-hello-world&#13;
Reading package lists... Done&#13;
Building dependency tree&#13;
Reading state information... Done&#13;
The following packages will be REMOVED:&#13;
  python3-hello-world*&#13;
0 upgraded, 0 newly installed, 1 to remove and 48 not upgraded.&#13;
After this operation, 19.5 kB disk space will be freed.&#13;
Do you want to continue? [Y/n] Y&#13;
(Reading database ... 242599 files and directories currently installed.)&#13;
Removing python3-hello-world (0.0.1) ...</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="RPM Packaging" data-type="sect2"><div class="sect2" id="idm46691331886328">&#13;
<h2>RPM Packaging</h2>&#13;
&#13;
<p><a data-primary="package management" data-secondary="RPM packaging" data-type="indexterm" id="ix_ch05-asciidoc11"/><a data-primary="RPM packaging" data-type="indexterm" id="ix_ch05-asciidoc12"/>Just as with Debian packaging, when working in RPM, it is necessary to have the native Python packaging done already. It should be possible to produce a Python package with a <em>setup.py</em> file. However, very unlike Debian, in which many files are needed, RPM packaging can work with just one: the <em>spec</em> file. If targeting a distribution like CentOS or Fedora, the RPM Package Manager (formerly known as Red Hat Package Manager) is the way to go.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The spec file" data-type="sect3"><div class="sect3" id="idm46691331812568">&#13;
<h3>The spec file</h3>&#13;
&#13;
<p><a data-primary="RPM packaging" data-secondary="spec file" data-type="indexterm" id="idm46691331811192"/><a data-primary="spec file" data-type="indexterm" id="idm46691331810216"/>In its simplest form, the <em>spec</em> file (named <em>hello-world.spec</em> for this example) is not difficult to understand, and most sections are self-explanatory. It can even be generated by using <code>setuptools</code>:</p>&#13;
&#13;
<pre data-type="programlisting">$ python3 setup.py bdist_rpm --spec-only&#13;
running bdist_rpm&#13;
running egg_info&#13;
writing hello_world.egg-info/PKG-INFO&#13;
writing dependency_links to hello_world.egg-info/dependency_links.txt&#13;
writing top-level names to hello_world.egg-info/top_level.txt&#13;
reading manifest file 'hello_world.egg-info/SOURCES.txt'&#13;
writing manifest file 'hello_world.egg-info/SOURCES.txt'&#13;
writing 'dist/hello-world.spec'</pre>&#13;
&#13;
<p>The output file in <em>dist/hello-world.spec</em> should look similar to this:</p>&#13;
&#13;
<pre data-type="programlisting">%define name hello-world&#13;
%define version 0.0.1&#13;
%define unmangled_version 0.0.1&#13;
%define release 1&#13;
&#13;
Summary: A hello-world example pacakge&#13;
Name: %{name}&#13;
Version: %{version}&#13;
Release: %{release}&#13;
Source0: %{name}-%{unmangled_version}.tar.gz&#13;
License: MIT&#13;
Group: Development/Libraries&#13;
BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-buildroot&#13;
Prefix: %{_prefix}&#13;
BuildArch: noarch&#13;
Vendor: Example Author &lt;author@example.com&gt;&#13;
Url: example.com&#13;
&#13;
%description&#13;
A Python3 hello-world package&#13;
&#13;
%prep&#13;
%setup -n %{name}-%{unmangled_version} -n %{name}-%{unmangled_version}&#13;
&#13;
%build&#13;
python3 setup.py build&#13;
&#13;
%install&#13;
python3 setup.py install --single-version-externally-managed -O1 \&#13;
--root=$RPM_BUILD_ROOT --record=INSTALLED_FILES&#13;
&#13;
%clean&#13;
rm -rf $RPM_BUILD_ROOT&#13;
&#13;
%files -f INSTALLED_FILES&#13;
%defattr(-,root,root)</pre>&#13;
&#13;
<p>Although it looks simple, it is already creating a potential issue: the version is input and requires updating every time. This process is similar to Debian’s <em>changelog</em> file, which needs to have the version <em>bumped</em> on each release.</p>&#13;
&#13;
<p>The <a data-primary="setuptools" data-type="indexterm" id="idm46691331802664"/><code>setuptools</code> integration is advantageous, allows further modification to this file if needed, and copies to the root directory of the project for a permanent location. Some projects use a base template that gets populated to generate the spec file as part of the build process. This process is useful if following a rigorous release workflow. In the case of the <a href="https://ceph.com">Ceph project</a>, the release is tagged via version control (Git), and the release scripts use that tag to apply it to the template via a <code>Makefile</code>.  It is worth noting that additional methods exist to automate this process further.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Generating a <em>spec</em> file is not always useful, because certain sections might need to be hardcoded to follow some distribution rule or a specific dependency that is not part of the generated file. In such cases, it is best to generate it once and configure it further to finally save it and make the <em>spec</em> file a formal part of the project.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Producing the binary" data-type="sect3"><div class="sect3" id="idm46691331797256">&#13;
<h3>Producing the binary</h3>&#13;
&#13;
<p><a data-primary="binaries" data-secondary="RPM" data-type="indexterm" id="idm46691331795720"/><a data-primary="RPM packaging" data-secondary="producing the binary" data-type="indexterm" id="idm46691331794744"/>There are a few different tools to produce RPM binaries; one in particular is the <code>rpmbuild</code> command-line tool:</p>&#13;
&#13;
<pre data-type="programlisting">$ sudo yum install rpm-build</pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The command-line tool is <a data-primary="rpmbuild command-line tool" data-type="indexterm" id="idm46691331791512"/><code>rpmbuild</code> but the package is called <code>rpm-build</code>, so make sure that <code>rpmbuild</code> (the command-line tool) is available in the terminal.</p>&#13;
</div>&#13;
&#13;
<p>A directory structure is required by <code>rpmbuild</code> to create the binary. After the directories are created, the <em>source</em> file (the <em>tar.gz</em> file generated by <code>setuptools</code>) needs to be present in the <em>SOURCES</em> directory. This is how the structure should be created and how it will look once it is done:</p>&#13;
&#13;
<pre data-type="programlisting">$ mkdir -p /opt/repo/centos/{SOURCES,SRPMS,SPECS,RPMS,BUILD}&#13;
$ cp dist/hello-world-0.0.1.tar.gz /opt/repo/centos/SOURCES/&#13;
$ tree /opt/repo/centos&#13;
/opt/repo/centos&#13;
├── BUILD&#13;
├── BUILDROOT&#13;
├── RPMS&#13;
├── SOURCES&#13;
│   └── hello-world-0.0.1.tar.gz&#13;
├── SPECS&#13;
└── SRPMS&#13;
&#13;
6 directories, 1 file</pre>&#13;
&#13;
<p>The directory structure is always needed, and by default, <code>rpmbuild</code> requires it in the home directory. To keep things isolated, a different location (in <em>/opt/repo/centos</em>) is used. This process means configure <code>rpmbuild</code> uses this directory instead. This process produces both a binary and a <em>source</em> package with the <code>-ba</code> flag (output is <span class="keep-together">abbreviated):</span></p>&#13;
&#13;
<pre data-type="programlisting">$ rpmbuild -ba --define "_topdir /opt/repo/centos"  dist/hello-world.spec&#13;
...&#13;
Executing(%build): /bin/sh -e /var/tmp/rpm-tmp.CmGOdp&#13;
running build&#13;
running build_py&#13;
creating build&#13;
creating build/lib&#13;
creating build/lib/hello_world&#13;
copying hello_world/main.py -&gt; build/lib/hello_world&#13;
copying hello_world/__init__.py -&gt; build/lib/hello_world&#13;
Executing(%install): /bin/sh -e /var/tmp/rpm-tmp.CQgOKD&#13;
+ python3 setup.py install --single-version-externally-managed \&#13;
-O1 --root=/opt/repo/centos/BUILDROOT/hello-world-0.0.1-1.x86_64&#13;
running install&#13;
writing hello_world.egg-info/PKG-INFO&#13;
writing dependency_links to hello_world.egg-info/dependency_links.txt&#13;
writing top-level names to hello_world.egg-info/top_level.txt&#13;
reading manifest file 'hello_world.egg-info/SOURCES.txt'&#13;
writing manifest file 'hello_world.egg-info/SOURCES.txt'&#13;
running install_scripts&#13;
writing list of installed files to 'INSTALLED_FILES'&#13;
Processing files: hello-world-0.0.1-1.noarch&#13;
Provides: hello-world = 0.0.1-1&#13;
Wrote: /opt/repo/centos/SRPMS/hello-world-0.0.1-1.src.rpm&#13;
Wrote: /opt/repo/centos/RPMS/noarch/hello-world-0.0.1-1.noarch.rpm&#13;
Executing(%clean): /bin/sh -e /var/tmp/rpm-tmp.gcIJgT&#13;
+ umask 022&#13;
+ cd /opt/repo/centos//BUILD&#13;
+ cd hello-world-0.0.1&#13;
+ rm -rf /opt/repo/centos/BUILDROOT/hello-world-0.0.1-1.x86_64&#13;
+ exit 0</pre>&#13;
&#13;
<p>The directory structure at <em>/opt/repo/centos</em> will have lots of new files, but we are only interested in the one that has the <code>noarch</code> RPM:</p>&#13;
&#13;
<pre data-type="programlisting">$ tree /opt/repo/centos/RPMS&#13;
/opt/repo/centos/RPMS&#13;
└── noarch&#13;
    └── hello-world-0.0.1-1.noarch.rpm&#13;
&#13;
1 directory, 1 file</pre>&#13;
&#13;
<p>The <code>noarch</code> RPM is an installable RPM package! The tool produced other useful packages that can be published as well (look at <em>/opt/repo/centos/SRPMS</em>, for example).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="RPM repositories" data-type="sect3"><div class="sect3" id="idm46691331796664">&#13;
<h3>RPM repositories</h3>&#13;
&#13;
<p><a data-primary="RPM packaging" data-secondary="repositories" data-type="indexterm" id="ix_ch05-asciidoc13"/>To create an RPM repository,  use the <a data-primary="createrepo" data-type="indexterm" id="idm46691331772968"/><code>createrepo</code> command-line tool. It handles the creation of the repository metadata (XML-based RPM metadata) from the binaries it finds in a given directory. In this section, create (and host) the <code>noarch</code> binary:</p>&#13;
&#13;
<pre data-type="programlisting">$ sudo yum install createrepo</pre>&#13;
&#13;
<p>You can create the repository in the same location used to produce the <code>noarch</code> package, or use a new (clean) directory. Create new binaries if needed. Once that is completed, the package copies:</p>&#13;
&#13;
<pre data-type="programlisting">$ mkdir -p /var/www/repos/centos&#13;
$ cp -r /opt/repo/centos/RPMS/noarch /var/www/repos/centos</pre>&#13;
&#13;
<p>To create the metadata, run the <code>createrepo</code> tool:</p>&#13;
&#13;
<pre data-type="programlisting">$ createrepo -v /var/www/repos/centos/noarch&#13;
Spawning worker 0 with 1 pkgs&#13;
Worker 0: reading hello-world-0.0.1-1.noarch.rpm&#13;
Workers Finished&#13;
Saving Primary metadata&#13;
Saving file lists metadata&#13;
Saving other metadata&#13;
Generating sqlite DBs&#13;
Starting other db creation: Thu Apr 18 09:13:35 2019&#13;
Ending other db creation: Thu Apr 18 09:13:35 2019&#13;
Starting filelists db creation: Thu Apr 18 09:13:35 2019&#13;
Ending filelists db creation: Thu Apr 18 09:13:35 2019&#13;
Starting primary db creation: Thu Apr 18 09:13:35 2019&#13;
Ending primary db creation: Thu Apr 18 09:13:35 2019&#13;
Sqlite DBs complete</pre>&#13;
&#13;
<p>Although an <code>x86_64</code> package does not exist, repeat the <code>createrepo</code> call for this new directory so that <code>yum</code> doesn’t complain about it later:</p>&#13;
&#13;
<pre data-type="programlisting">$ mkdir /var/www/repos/centos/x86_64&#13;
$ createrepo -v /var/www/repos/centos/x86_64</pre>&#13;
&#13;
<p>We are going to use the <code>http.server</code> module to serve this directory over HTTP:</p>&#13;
&#13;
<pre data-type="programlisting">$ python3 -m http.server&#13;
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</pre>&#13;
&#13;
<p>To access this repository, <code>yum</code> needs to be configured with a <em>repo file</em>. Create one at <em>/etc/yum.repos.d/hello-world.repo</em>. It should look like this:</p>&#13;
&#13;
<pre data-code-language="ini" data-type="programlisting"><code class="k">[hello-world]</code>&#13;
<code class="na">name</code><code class="o">=</code><code class="s">hello-world example repo for noarch packages</code>&#13;
<code class="na">baseurl</code><code class="o">=</code><code class="s">http://0.0.0.0:8000/$basearch</code>&#13;
<code class="na">enabled</code><code class="o">=</code><code class="s">1</code>&#13;
<code class="na">gpgcheck</code><code class="o">=</code><code class="s">0</code>&#13;
<code class="na">type</code><code class="o">=</code><code class="s">rpm-md</code>&#13;
<code class="na">priority</code><code class="o">=</code><code class="s">1</code>&#13;
&#13;
<code class="k">[hello-world-noarch]</code>&#13;
<code class="na">name</code><code class="o">=</code><code class="s">hello-world example repo for noarch packages</code>&#13;
<code class="na">baseurl</code><code class="o">=</code><code class="s">http://0.0.0.0:8000/noarch</code>&#13;
<code class="na">enabled</code><code class="o">=</code><code class="s">1</code>&#13;
<code class="na">gpgcheck</code><code class="o">=</code><code class="s">0</code>&#13;
<code class="na">type</code><code class="o">=</code><code class="s">rpm-md</code>&#13;
<code class="na">priority</code><code class="o">=</code><code class="s">1</code></pre>&#13;
&#13;
<p>Note how the <code>gpgcheck</code> value is <code>0</code>. This means we haven’t signed any packages and <code>yum</code> should not try to verify a signature, preventing a failure in this example. Searching for the package should now be possible, giving us the description as part of the output:</p>&#13;
&#13;
<pre data-type="programlisting">$ yum --enablerepo=hello-world search hello-world&#13;
Loaded plugins: fastestmirror, priorities&#13;
Loading mirror speeds from cached hostfile&#13;
 * base: reflector.westga.edu&#13;
 * epel: mirror.vcu.edu&#13;
 * extras: mirror.steadfastnet.com&#13;
 * updates: mirror.mobap.edu&#13;
base                                                                   | 3.6 kB&#13;
extras                                                                 | 3.4 kB&#13;
hello- world                                                           | 2.9 kB&#13;
hello-world-noarch                                                     | 2.9 kB&#13;
updates                                                                | 3.4 kB&#13;
8 packages excluded due to repository priority protections&#13;
===============================================================================&#13;
matched: hello-world&#13;
===============================================================================&#13;
hello-world.noarch : A hello-world example pacakge</pre>&#13;
&#13;
<p>The search function works correctly; installing the package should work as well:</p>&#13;
&#13;
<pre data-type="programlisting">$ yum --enablerepo=hello-world install hello-world&#13;
Loaded plugins: fastestmirror, priorities&#13;
Loading mirror speeds from cached hostfile&#13;
 * base: reflector.westga.edu&#13;
 * epel: mirror.vcu.edu&#13;
 * extras: mirror.steadfastnet.com&#13;
 * updates: mirror.mobap.edu&#13;
8 packages excluded due to repository priority protections&#13;
Resolving Dependencies&#13;
--&gt; Running transaction check&#13;
---&gt; Package hello-world.noarch 0:0.0.1-1 will be installed&#13;
--&gt; Finished Dependency Resolution&#13;
&#13;
Dependencies Resolved&#13;
Installing:&#13;
 hello-world          noarch          0.0.1-1            hello-world-noarch&#13;
&#13;
Transaction Summary&#13;
Install  1 Package&#13;
&#13;
Total download size: 8.1 k&#13;
Installed size: 1.3 k&#13;
Downloading packages:&#13;
hello-world-0.0.1-1.noarch.rpm                                         | 8.1 kB&#13;
Running transaction check&#13;
Running transaction test&#13;
Transaction test succeeded&#13;
Running transaction&#13;
  Installing : hello-world-0.0.1-1.noarch&#13;
  Verifying  : hello-world-0.0.1-1.noarch&#13;
&#13;
Installed:&#13;
  hello-world.noarch 0:0.0.1-1&#13;
&#13;
Complete!</pre>&#13;
&#13;
<p>Removing has to work as well:</p>&#13;
&#13;
<pre data-type="programlisting">$ yum remove hello-world&#13;
Loaded plugins: fastestmirror, priorities&#13;
Resolving Dependencies&#13;
--&gt; Running transaction check&#13;
---&gt; Package hello-world.noarch 0:0.0.1-1 will be erased&#13;
--&gt; Finished Dependency Resolution&#13;
&#13;
Dependencies Resolved&#13;
Removing:&#13;
 hello-world          noarch          0.0.1-1           @hello-world-noarch&#13;
&#13;
Transaction Summary&#13;
Remove  1 Package&#13;
&#13;
Installed size: 1.3 k&#13;
Is this ok [y/N]: y&#13;
Downloading packages:&#13;
Running transaction check&#13;
Running transaction test&#13;
Transaction test succeeded&#13;
Running transaction&#13;
  Erasing    : hello-world-0.0.1-1.noarch&#13;
  Verifying  : hello-world-0.0.1-1.noarch&#13;
Removed:&#13;
  hello-world.noarch 0:0.0.1-1&#13;
Complete!</pre>&#13;
&#13;
<p>The <code>http.server</code> module should display some activity, demonstrating that <code>yum</code> was reaching out to get the <code>hello-world</code> <a data-startref="ix_ch05-asciidoc13" data-type="indexterm" id="idm46691331713336"/>package<a data-startref="ix_ch05-asciidoc12" data-type="indexterm" id="idm46691331712472"/><a data-startref="ix_ch05-asciidoc11" data-type="indexterm" id="idm46691331711768"/>:<a data-startref="ix_ch05-asciidoc2" data-type="indexterm" id="idm46691331710968"/></p>&#13;
&#13;
<pre data-type="programlisting">[18/Apr/2019 03:37:24] "GET /x86_64/repodata/repomd.xml HTTP/1.1"&#13;
[18/Apr/2019 03:37:24] "GET /noarch/repodata/repomd.xml HTTP/1.1"&#13;
[18/Apr/2019 03:37:25] "GET /x86_64/repodata/primary.sqlite.bz2 HTTP/1.1"&#13;
[18/Apr/2019 03:37:25] "GET /noarch/repodata/primary.sqlite.bz2 HTTP/1.1"&#13;
[18/Apr/2019 03:56:49] "GET /noarch/hello-world-0.0.1-1.noarch.rpm HTTP/1.1"</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Management with systemd" data-type="sect1"><div class="sect1" id="idm46691331775288">&#13;
<h1>Management with systemd</h1>&#13;
&#13;
<p><a data-primary="package management" data-secondary="systemd for" data-type="indexterm" id="ix_ch05-asciidoc14"/><a data-primary="systemd" data-type="indexterm" id="ix_ch05-asciidoc15"/><code>systemd</code> is a <em>system and service manager</em> for Linux (also known as <em>init system</em>). It is the default init system for many distributions, such as Debian and Red Hat. Here are some of the many features <code>systemd</code> provides:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Easy parallelization</p>&#13;
</li>&#13;
<li>&#13;
<p>Hooks and triggers for on-demand behavior</p>&#13;
</li>&#13;
<li>&#13;
<p>Logging integration</p>&#13;
</li>&#13;
<li>&#13;
<p>Ability to depend on other units for orchestrating complicated startups</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>There are plenty of other exciting aspects of <code>systemd</code>, such as network, DNS, and even mounting for devices.  The idea of handling processes with ease in Python has always been challenging; at one point there were a few <em>init-like</em> projects in Python to choose from, all with their configuration and handling APIs. Using <code>systemd</code> allows portability and makes it easy to collaborate with others since it is widely available.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Two well-known process handlers in Python are<a data-primary="circus" data-type="indexterm" id="idm46691331696920"/><a data-primary="supervisord" data-type="indexterm" id="idm46691331696216"/> <a href="http://supervisord.org"><code>supervisord</code></a> and <a href="https://oreil.ly/adGEj"><code>circus</code></a>.</p>&#13;
</div>&#13;
&#13;
<p>Not long ago, Alfredo wrote a small Python HTTP API that needed to go into production. The project had transitioned from <code>supervisord</code> to <code>circus</code>, and things were working fine.  Unfortunately, production constraints meant the integration of <code>systemd</code> with the OS. The transition was rough because <code>systemd</code> was reasonably new, but once things were in place, we benefited from having the same production-like handling for development and catching integration issues earlier in the development cycle. When the API went into the release, we already felt comfortable with <code>systemd</code> to troubleshoot problems and even fine-tune the configuration to cope with external issues. (Have you ever seen an <code>init</code> script fail because the network was not operational?)</p>&#13;
&#13;
<p>In this section we build a small HTTP service that needs to be available when the system boots and can restart at any moment. The unit configuration handles logging and ensures that specific system resources are available before attempting to start.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Long-Running Processes" data-type="sect2"><div class="sect2" id="idm46691331688952">&#13;
<h2>Long-Running Processes</h2>&#13;
&#13;
<p><a data-primary="systemd" data-secondary="long-running processes" data-type="indexterm" id="idm46691331687752"/>Processes that are meant to be running all the time are excellent candidates to be handled with <code>systemd</code>. Consider how a DNS or mail server works; these are <em>always on</em> programs, and they need some handling to capture logging or restart when configuration changes.</p>&#13;
&#13;
<p>We are going to use a small HTTP API server, based on the <a href="https://www.pecanpy.org">Pecan web framework</a>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>There is nothing specific in this section as to how Pecan works, so that the examples can be used for other frameworks or long-running services.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Setting It Up" data-type="sect2"><div class="sect2" id="idm46691331682872">&#13;
<h2>Setting It Up</h2>&#13;
&#13;
<p><a data-primary="systemd" data-secondary="setup" data-type="indexterm" id="ix_ch05-asciidoc16"/>Pick a permanent location for the project to create a directory at <em>/opt/http</em>, and then create a new virtual environment and install the Pecan framework:</p>&#13;
&#13;
<pre data-type="programlisting">$ mkdir -p /opt/http&#13;
$ cd /opt/http&#13;
$ python3 -m venv .&#13;
$ source bin/activate&#13;
(http) $ pip install "pecan==1.3.3"</pre>&#13;
&#13;
<p>Pecan has some built-in helpers that can create the necessary files and directories for an example project. Pecan can be used to create a basic “vanilla” HTTP API project that hooks up to <code>systemd</code>. Version <code>1.3.3</code> has two options: the <code>base</code> and the <code>rest-api</code> flavors:</p>&#13;
&#13;
<pre data-type="programlisting">$ pecan create api rest-api&#13;
Creating /opt/http/api&#13;
Recursing into +package+&#13;
  Creating /opt/http/api/api&#13;
...&#13;
Copying scaffolds/rest-api/config.py_tmpl to /opt/http/api/config.py&#13;
Copying scaffolds/rest-api/setup.cfg_tmpl to /opt/http/api/setup.cfg&#13;
Copying scaffolds/rest-api/setup.py_tmpl to /opt/http/api/setup.py</pre>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>It is important to use a consistent path, because it is used later when configuring the service with <code>systemd</code>.</p>&#13;
</div>&#13;
&#13;
<p>By including the project scaffolding, we now have a fully functional project with no effort. It even has a <em>setup.py</em> file with everything in it, ready to become a native Python package! Let’s install the project so that we can run it:</p>&#13;
&#13;
<pre data-type="programlisting">(http) $ python setup.py install&#13;
running install&#13;
running bdist_egg&#13;
running egg_info&#13;
creating api.egg-info&#13;
...&#13;
creating dist&#13;
creating 'dist/api-0.1-py3.6.egg' and adding 'build/bdist.linux-x86_64/egg'&#13;
removing 'build/bdist.linux-x86_64/egg' (and everything under it)&#13;
Processing api-0.1-py3.6.egg&#13;
creating /opt/http/lib/python3.6/site-packages/api-0.1-py3.6.egg&#13;
Extracting api-0.1-py3.6.egg to /opt/http/lib/python3.6/site-packages&#13;
...&#13;
Installed /opt/http/lib/python3.6/site-packages/api-0.1-py3.6.egg&#13;
Processing dependencies for api==0.1&#13;
Finished processing dependencies for api==0.1</pre>&#13;
&#13;
<p>The<a data-primary="pecan command-line tool" data-type="indexterm" id="idm46691331640248"/> <code>pecan</code> command-line tool requires a configuration file. The configuration file has already been created for you by the scaffolding, and it lives in the top directory. Start the server with the <em>config.py</em> file:</p>&#13;
&#13;
<pre data-type="programlisting">(http) $ pecan serve config.py&#13;
Starting server in PID 17517&#13;
serving on 0.0.0.0:8080, view at http://127.0.0.1:8080</pre>&#13;
&#13;
<p>Testing it out on the browser should produce a plain-text message. This is how it shows with the <code>curl</code> command:</p>&#13;
&#13;
<pre data-type="programlisting">(http) $ curl localhost:8080&#13;
Hello, World!</pre>&#13;
&#13;
<p>A long-running process starts with <code>pecan serve config.py</code>. The only way to stop this process is to send a <code>KeyboardInterrupt</code> with <code>Control-C</code>. Starting it again requires the virtual environment to be activated, and the same <code>pecan serve</code> command runs again.<a data-startref="ix_ch05-asciidoc16" data-type="indexterm" id="idm46691331633592"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The systemd Unit File" data-type="sect2"><div class="sect2" id="idm46691331682248">&#13;
<h2>The systemd Unit File</h2>&#13;
&#13;
<p><a data-primary="systemd" data-secondary="unit file" data-type="indexterm" id="idm46691331631576"/>Unlike older init systems that work with executable scripts, <code>systemd</code>  works with plain text files. The final version of the unit file looks like this:</p>&#13;
&#13;
<pre data-code-language="ini" data-type="programlisting"><code class="k">[Unit]</code>&#13;
<code class="na">Description</code><code class="o">=</code><code class="s">hello world pecan service</code>&#13;
<code class="na">After</code><code class="o">=</code><code class="s">network.target</code>&#13;
&#13;
<code class="k">[Service]</code>&#13;
<code class="na">Type</code><code class="o">=</code><code class="s">simple</code>&#13;
<code class="na">ExecStart</code><code class="o">=</code><code class="s">/opt/http/bin/pecan serve /opt/http/api/config.py</code>&#13;
<code class="na">WorkingDirectory</code><code class="o">=</code><code class="s">/opt/http/api</code>&#13;
<code class="na">StandardOutput</code><code class="o">=</code><code class="s">journal</code>&#13;
<code class="na">StandardError</code><code class="o">=</code><code class="s">journal</code>&#13;
&#13;
<code class="k">[Install]</code>&#13;
<code class="na">WantedBy</code><code class="o">=</code><code class="s">multi-user.target</code></pre>&#13;
&#13;
<p>Save this file as <code>hello-world.service</code>. It will be copied into its final destination later in this section.</p>&#13;
&#13;
<p>It is essential to get all the section names and the configuration directives correct, as all are case-sensitive. If names don’t match exactly, things won’t work. Let’s go into detail for each section of the HTTP service:</p>&#13;
<dl>&#13;
<dt>Unit</dt>&#13;
<dd>&#13;
<p>Provides a description and includes an <code>After</code> directive that tells <code>systemd</code> that this service unit needs to have an operational network environment before being started. Other units may have more complex requirements, not only to start the service but even <em>after</em> it starts! <code>Condition</code> and <code>Wants</code> are other directives that are very useful.</p>&#13;
</dd>&#13;
<dt>Service</dt>&#13;
<dd>&#13;
<p>This section is only needed when configuring a <em>service</em> unit. It defaults to <code>Type=simple</code>. Services of this type should not fork—they have to stay in the foreground so that <code>systemd</code> can handle their operation. The <code>ExecStart</code> line explains what the command should run to start the service. It is <em>crucial</em> to use absolute paths to avoid problems finding the right files.</p>&#13;
&#13;
<p>Although not required, I’ve included the <code>WorkingDirectory</code> directive to ensure that the process is in the same directory where the application lives. If anything updates later, it might benefit from already being in a position relative to the application.</p>&#13;
&#13;
<p>Both the <code>StandardOutput</code> and <code>StandardError</code> directives are great to work with, and show how much <code>systemd</code> has to offer here. It will handle all the logging emitted via <code>stdout</code> and <code>stderr</code> through <code>systemd</code> machinery. We will demonstrate this further when explaining how to interact with the service.</p>&#13;
</dd>&#13;
<dt>Install</dt>&#13;
<dd>&#13;
<p>The <code>WantedBy</code> directive explains how this unit handles once it is enabled. The <code>multi-user.target</code>  is equivalent to <code>runlevel 3</code> (the normal run level for a server that boots into a terminal). This type of configuration allows the system to determine how it behaves once enabled. Once enabled, a symlink is created in the <em>multi-user.target.wants</em> directory.<a data-startref="ix_ch05-asciidoc15" data-type="indexterm" id="idm46691331591704"/><a data-startref="ix_ch05-asciidoc14" data-type="indexterm" id="idm46691331590968"/></p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Installing the Unit" data-type="sect1"><div class="sect1" id="idm46691331709112">&#13;
<h1>Installing the Unit</h1>&#13;
&#13;
<p><a data-primary="package management" data-secondary="unit installation" data-type="indexterm" id="idm46691331588728"/>The configuration file itself has to go to a specific location so that <code>systemd</code> can pick it up and <em>load it</em>. Various locations are supported, but <em>/etc/systemd/system</em> is for units that are created or managed by an administrator.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>It is useful to make sure that the <code>ExecStart</code> directive works with those paths. Using absolute paths increases the chance of introducing a typo. To verify, run the whole line in the terminal and look for output similar to this:</p>&#13;
&#13;
<pre data-type="programlisting">$ /opt/http/bin/pecan serve /opt/http/api/config.py&#13;
Starting server in PID 20621&#13;
serving on 0.0.0.0:8080, view at http://127.0.0.1:8080</pre>&#13;
</div>&#13;
&#13;
<p>After verifying that the command works, copy the unit file into this directory using <code>hello-world.service</code> as the name:</p>&#13;
&#13;
<pre data-type="programlisting">$ cp hello-world.service /etc/systemd/system/</pre>&#13;
&#13;
<p class="pagebreak-before">Once in place, <code>systemd</code> needs to be reloaded to make it aware of this new unit:</p>&#13;
&#13;
<pre data-type="programlisting">$ systemctl daemon-reload</pre>&#13;
&#13;
<p>The service is now fully functional and can be started and stopped. This process is verified by using the <code>status</code> subcommand. Let’s go through the different commands you can use to interact with the service. First, let’s see if <code>systemd</code> recognizes it. This is how it should behave and what the output looks like:</p>&#13;
&#13;
<pre data-type="programlisting">$ systemctl status hello-world&#13;
● hello-world.service - hello world pecan service&#13;
   Loaded: loaded (/etc/systemd/system/hello-world.service; disabled; )&#13;
   Active: inactive (dead)</pre>&#13;
&#13;
<p>Since the service is not running, it is not surprising to see it reported as <code>dead</code>. Start the service next and check the status once again (<code>curl</code> should report nothing is running on port <code>8080</code>):</p>&#13;
&#13;
<pre data-type="programlisting">$ curl localhost:8080&#13;
curl: (7) Failed to connect to localhost port 8080: Connection refused&#13;
$ systemctl start hello-world&#13;
$ systemctl status hello-world&#13;
● hello-world.service - hello world pecan service&#13;
   Loaded: loaded (/etc/systemd/system/hello-world.service; disabled; )&#13;
   Active: active (running) since Tue 2019-04-23 13:44:20 EDT; 5s ago&#13;
 Main PID: 23980 (pecan)&#13;
    Tasks: 1 (limit: 4915)&#13;
   Memory: 20.1M&#13;
   CGroup: /system.slice/hello-world.service&#13;
           └─23980 /opt/http/bin/python /opt/http/bin/pecan serve config.py&#13;
&#13;
Apr 23 13:44:20 huando systemd[1]: Started hello world pecan service.</pre>&#13;
&#13;
<p>The service is running and fully operational. Verify it once again on port <code>8080</code> to make sure that the framework is up and running and responding to requests:</p>&#13;
&#13;
<pre data-type="programlisting">$ curl localhost:8080&#13;
Hello, World!</pre>&#13;
&#13;
<p>If you stop the service with <code>systemctl stop hello-world</code>, the <code>curl</code> command will report a connection failure once again.</p>&#13;
&#13;
<p>So far, we have created and installed the unit, verified it works by starting and stopping the service, and checked if the Pecan framework is responding to requests on its default port. You want this service up and running if the server reboots at any time, and this is where the <code>Install</code> section helps. Let’s <code>enable</code> the service:</p>&#13;
&#13;
<pre data-type="programlisting">$ systemctl enable hello-world&#13;
Created symlink hello-world.service → /etc/systemd/system/hello-world.service.</pre>&#13;
&#13;
<p>When the server restarts, the small HTTP API service is up and running.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Log Handling" data-type="sect2"><div class="sect2" id="idm46691331536248">&#13;
<h2>Log Handling</h2>&#13;
&#13;
<p><a data-primary="log handling" data-type="indexterm" id="idm46691331534632"/><a data-primary="package management" data-secondary="log handling" data-type="indexterm" id="idm46691331533704"/>Since this is a configured service with logging configuration (all <code>stdout</code> and <code>stderr</code> is going directly into <code>systemd</code>), the handling works <em>for free</em>. No need to configure file-based logging, rotation, or even expiration. There are a few interesting and very nice features provided by <code>systemd</code> that allow you to interact with logs, such as limiting the time range and filtering by unit or process ID.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The command to interact with logs from a unit is done through the <code>journalctl</code> command-line tool. This process might be a surprise if expecting another subcommand from <code>systemd</code> to provide&#13;
the logging helpers.</p>&#13;
</div>&#13;
&#13;
<p>Since we started the service and sent some requests to it via <code>curl</code> in the previous section, let’s see what the logs say:</p>&#13;
&#13;
<pre data-type="programlisting">$ journalctl -u hello-world&#13;
-- Logs begin at Mon 2019-04-15 09:05:11 EDT, end at Tue 2019-04-23&#13;
Apr 23 13:44:20 srv1 systemd[1]: Started hello world pecan service.&#13;
Apr 23 13:44:44 srv1 pecan[23980] [INFO    ] [pecan.commands.serve] GET / 200&#13;
Apr 23 13:44:55 srv1 systemd[1]: Stopping hello world pecan service...&#13;
Apr 23 13:44:55 srv1 systemd[1]: hello-world.service: Main process exited&#13;
Apr 23 13:44:55 srv1 systemd[1]: hello-world.service: Succeeded.&#13;
Apr 23 13:44:55 srv1 systemd[1]: Stopped hello world pecan service.</pre>&#13;
&#13;
<p>The <code>-u</code> flag specifies the <em>unit</em>, which in this case is <code>hello-world</code>, but you can also use a pattern or even specify multiple units.</p>&#13;
&#13;
<p>A common way to <em>follow</em> a log as it produces entries is to use the <code>tail</code> command. Specifically, this looks like:</p>&#13;
&#13;
<pre data-type="programlisting">$ tail -f pecan-access.log</pre>&#13;
&#13;
<p>The command to accomplish the same thing with <code>journalctl</code> looks slightly different, but it <em>works in the same way</em>:</p>&#13;
&#13;
<pre data-type="programlisting">$ journalctl -fu hello-world&#13;
Apr 23 13:44:44 srv1 pecan[23980][INFO][pecan.commands.serve] GET / 200&#13;
Apr 23 13:44:44 srv1 pecan[23980][INFO][pecan.commands.serve] GET / 200&#13;
Apr 23 13:44:44 srv1 pecan[23980][INFO][pecan.commands.serve] GET / 200</pre>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>If the <code>systemd</code> package is available with the <code>pcre2</code> engine, it allows you to use <code>--grep</code>. This further filters out log entries based on a pattern.</p>&#13;
</div>&#13;
&#13;
<p>The <code>-f</code> flag means to <em>follow</em> the log, and it starts from the most recent entries and continues to show the entries as they happen, just like <code>tail -f</code> would. In production, the number of logs may be too many, and errors might have been showing up <em>today</em>. In those cases, you can use a combination of <code>--since</code>  and <code>--until</code>. Both these flags accept a few different types of parameters:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>today</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>yesterday</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>"3 hours ago"</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>-1h</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>-15min</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>-1h35min</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>In our small example, <code>journalctl</code> is unable to find anything for the last 15 minutes. At the beginning of the output, it informs us of the range and produces the entries, if any:</p>&#13;
&#13;
<pre data-type="programlisting">$  journalctl -u hello-world --since "-15min"&#13;
-- Logs begin at Mon 2019-04-15 09:05:11 EDT, end at Tue 2019-04-23&#13;
-- No entries --</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exercises" data-type="sect1"><div class="sect1" id="idm46691331589832">&#13;
<h1>Exercises</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Use three different commands to get log output from <code>systemd</code> using <code>journalctl</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Explain what the <code>WorkinDirectory</code> configuration option is for <code>systemd</code> units.</p>&#13;
</li>&#13;
<li>&#13;
<p>Why is a changelog important?</p>&#13;
</li>&#13;
<li>&#13;
<p>What is a <em>setup.py</em> file for?</p>&#13;
</li>&#13;
<li>&#13;
<p>Name three differences between Debian and RPM packages.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Case Study Question" data-type="sect1"><div class="sect1" id="idm46691331496776">&#13;
<h1>Case Study Question</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Create a local instance of PyPI using <code>devpi</code>, upload a Python package, and then try to install that Python package from the local <code>devpi</code> instance.<a data-startref="ix_ch05-asciidoc0" data-type="indexterm" id="idm46691331493784"/></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>