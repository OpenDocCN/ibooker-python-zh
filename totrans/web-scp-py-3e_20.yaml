- en: Chapter 18\. Testing Your Website with Scrapers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with web projects that have a large development stack, it’s often
    only the “back” of the stack that ever gets tested regularly. Most programming
    languages today (including Python) have some type of test framework, but website
    frontends are often left out of these automated tests, although they might be
    the only customer-facing part of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Part of the problem is that websites are often a mishmash of many markup languages
    and programming languages. You can write unit tests for sections of your JavaScript,
    but it’s useless if the HTML it’s interacting with has changed in such a way that
    the JavaScript doesn’t have the intended action on the page, even if it’s working
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The problem of frontend website testing has often been left as an afterthought
    or delegated to lower-level programmers armed with, at most, a checklist and a
    bug tracker. However, with just a little more up-front effort, you can replace
    this checklist with a series of unit tests and replace human eyes with a web scraper.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine: test-driven development for web development. Daily tests to make sure
    all parts of the web interface are functioning as expected. A suite of tests run
    every time someone adds a new website feature or changes the position of an element.
    This chapter covers the basics of testing and how to test all sorts of websites,
    from simple to complicated, with Python-based web scrapers.'
  prefs: []
  type: TYPE_NORMAL
- en: An Introduction to Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’ve never written tests for your code before, there’s no better time to
    start than now. Having a suite of tests that can be run to ensure that your code
    performs as expected (at least, as far as you’ve written tests for) saves you
    time and worry and makes releasing new updates easy.
  prefs: []
  type: TYPE_NORMAL
- en: What Are Unit Tests?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The words *test* and *unit test* are often used interchangeably. Often, when
    programmers refer to “writing tests,” what they really mean is “writing unit tests.”
    On the other hand, when some programmers refer to writing unit tests, they’re
    really writing some other kind of test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although definitions and practices tend to vary from company to company, a
    unit test generally has the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Each unit test tests one aspect of the functionality of a component. For example,
    it might ensure that the appropriate error message is thrown if a negative number
    of dollars is withdrawn from a bank account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often, unit tests are grouped together in the same class, based on the component
    they are testing. You might have the test for a negative dollar value being withdrawn
    from a bank account, followed by a unit test for the behavior of an overdrawn
    bank account.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Each unit test can be run completely independently, and any setup or teardown
    required for the unit test must be handled by the unit test itself. Similarly,
    unit tests must not interfere with the success or failure of other tests, and
    they must be able to run successfully in any order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each unit test usually contains at least one *assertion.* For example, a unit
    test might assert that the answer to 2 + 2 is 4\. Occasionally, a unit test might
    contain only a failure state. For example, it might fail if an exception is thrown
    but pass by default if everything goes smoothly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests are separated from the bulk of the code. Although they necessarily
    need to import and use the code they are testing, they are generally kept in separate
    classes and directories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although many other types of tests can be written—integration tests and validation
    tests, for example—this chapter primarily focuses on unit testing. Not only have
    unit tests become extremely popular with recent pushes toward test-driven development,
    but their length and flexibility make them easy to work with as examples, and
    Python has some built-in unit testing capabilities, as you’ll see in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Python unittest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python’s unit-testing module, `unittest`, comes packaged with all standard
    Python installations. Just import and extend `unittest.TestCase`, and it will:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide `setUp` and `tearDown` functions that run before and after each unit
    test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide several types of “assert” statements to allow tests to pass or fail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run all functions that begin with `test_` as unit tests and ignore functions
    that are not prepended as tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following provides a simple unit test for ensuring that 2 + 2 = 4, according
    to Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Although `setUp` and `tearDown` don’t provide any useful functionality here,
    they are included for illustration purposes. Note that these functions are run
    before and after each individual test, not before and after all the tests in the
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the test function, when run from the command line, should look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This indicates that the test ran successfully, and 2 + 2 does indeed equal 4.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Wikipedia
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Testing the frontend of your website (excluding JavaScript, which we’ll cover
    next) is as simple as combining the Python `unittest` library with a web scraper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two tests this time: the first tests whether the title of the page
    is the expected “Monty Python,” and the second makes sure that the page has a
    content `div`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the content of the page is loaded only once, and that the global object
    `bs` is shared between tests. This is accomplished by using the `unittest`-specified
    function `setUpClass`, which is run only once at the start of the class (unlike
    `setUp`, which is run before every individual test). Using `setUpClass` instead
    of `setUp` saves unnecessary page loads; you can grab the content once and run
    multiple tests on it.
  prefs: []
  type: TYPE_NORMAL
- en: One major architectural difference between `setUpClass` and `setUp`, besides
    just when and how often they’re run, is that `setUpClass` is a static method that
    “belongs” to the class itself and has global class variables, whereas `setUp`
    is an instance function that belongs to a particular instance of the class. This
    is why `setUp` can set attributes on `self`—the particular instance of that class—while
    `setUpClass` can access only static class attributes on the class `TestWikipedia`.
  prefs: []
  type: TYPE_NORMAL
- en: Although testing a single page at a time might not seem all that powerful or
    interesting, as you may recall from [Chapter 6](ch06.html#c-6), it is relatively
    easy to build web crawlers that can iteratively move through all pages of a website.
    What happens when you combine a web crawler with a unit test that makes an assertion
    about each page?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to run a test repeatedly, but you must be careful to load
    each page only once for each set of tests you want to run on the page, and you
    must also avoid holding large amounts of information in memory at once. The following
    setup does just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There are a few things to notice. First, there is only one actual test in this
    class. The other functions are technically only helper functions, even though
    they’re doing the bulk of the computational work to determine whether a test passes.
    Because the test function performs the assertion statements, the results of the
    test are passed back to the test function where the assertions happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, while `contentExists` returns a boolean, `titleMatchesURL` returns the
    values themselves for evaluation. To see why you would want to pass values back
    rather than just a boolean, compare the results of a boolean assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'with the results of an `assertEquals` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Which one is easier to debug? (In this case, the error is occurring because
    of a redirect, when the article *http://wikipedia.org/wiki/u-2%20spy%20plane*
    redirects to an article titled “Lockheed U-2.”)
  prefs: []
  type: TYPE_NORMAL
- en: Testing with Selenium
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with Ajax scraping in [Chapter 14](ch14.html#c-14), JavaScript presents particular
    challenges when doing website testing. Fortunately, Selenium has an excellent
    framework in place for handling particularly complicated websites; in fact, the
    library was originally designed for website testing!
  prefs: []
  type: TYPE_NORMAL
- en: 'Although obviously written in the same language, the syntaxes of Python unit
    tests and Selenium unit tests have surprisingly little in common. Selenium does
    not require that its unit tests be contained as functions within classes; its
    `assert` statements do not require parentheses; and tests pass silently, producing
    some kind of message only on a failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When run, this test should produce no output.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, Selenium tests can be written more casually than Python unit tests,
    and `assert` statements can even be integrated into regular code, where it is
    desirable for code execution to terminate if some condition is not met.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the Site
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recently, I wanted to contact a local small business through its website’s contact
    form but found that the HTML form was broken; nothing happened when I clicked
    the Submit button. After a little investigation, I saw they were using a simple
    mailto form that was designed to send them an email with the form’s contents.
    Fortunately, I was able to use this information to send them an email, explain
    the problem with their form, and hire them, despite the technical issue.
  prefs: []
  type: TYPE_NORMAL
- en: If I were to write a traditional scraper that used or tested this form, my scraper
    would likely just copy the layout of the form and send an email directly—bypassing
    the form altogether. How could I test the functionality of the form and ensure
    that it was working perfectly through a browser?
  prefs: []
  type: TYPE_NORMAL
- en: Although previous chapters have discussed navigating links, submitting forms,
    and other types of interaction-like activity, at its core everything we’ve done
    is designed to *bypass* the browser interface, not use it. Selenium, on the other
    hand, can literally enter text, click buttons, and do everything through the browser
    (in this case, the headless Chrome browser), and detect things like broken forms,
    badly coded JavaScript, HTML typos, and other issues that might stymie actual
    customers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key to this sort of testing is the concept of Selenium elements. This object
    was briefly encountered in [Chapter 14](ch14.html#c-14), and is returned by calls
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as there are numerous actions you can take on various elements of a website
    in your browser, there are many actions Selenium can perform on any given element.
    Among these are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In addition to performing a one-time action on an element, strings of actions
    can be combined into *action chains*, which can be stored and executed once or
    multiple times in a program. Action chains are useful in that they can be a convenient
    way to string long sets of multiple actions, but they are functionally identical
    to calling the action explicitly on the element, as in the preceding examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this difference, take a look at the form page at [*http://pythonscraping.com/pages/files/form.html*](http://pythonscraping.com/pages/files/form.html)
    (which was previously used as an example in [Chapter 13](ch13.html#c-13)). We
    can fill out the form and submit it in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Method 1 calls `send_keys` on the two fields and then clicks the Submit button.
    Method 2 uses a single action chain to click and enter text in each field, which
    happens in a sequence after the `perform` method is called. This script operates
    in the same way, whether the first method or the second method is used, and prints
    this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'There is another variation in the two methods, in addition to the objects they
    use to handle the commands: notice that the first method clicks the Submit button,
    while the second uses the Return keystroke to submit the form while the text box
    is submitted. Because there are many ways to think about the sequence of events
    that complete the same action, there are many ways to complete the same action
    using Selenium.'
  prefs: []
  type: TYPE_NORMAL
- en: Drag and drop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Clicking buttons and entering text is one thing, but where Selenium really shines
    is in its ability to deal with relatively novel forms of web interaction. Selenium
    allows for the manipulation of drag-and-drop interfaces with ease. Using its drag-and-drop
    function requires you to specify a *source* element (the element to be dragged)
    and either an offset to drag it across, or a target element to drag it to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The demo page located at [*http://pythonscraping.com/pages/javascript/draggableDemo.html*](http://pythonscraping.com/pages/javascript/draggableDemo.html)
    presents an example of this type of interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Two messages are printed out from the `message div` on the demo page. The first
    says:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, quickly, after the task is completed, the content is printed out again,
    which now reads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As the demo page suggests, dragging elements to prove you’re not a bot is a
    common theme in many CAPTCHAs. Although bots have been able to drag objects around
    for a long time (it’s just a matter of clicking, holding, and moving), somehow
    the idea of using “drag this” as a verification of humanity just won’t die.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, these draggable CAPTCHA libraries rarely use any difficult-for-bots
    tasks, like “drag the picture of the kitten onto the picture of the cow” (which
    requires you to identify the pictures as “a kitten” and “a cow,” while parsing
    instructions); instead, they often involve number ordering or some other fairly
    trivial task like the one in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, their strength lies in the fact that there are so many variations,
    and they are so infrequently used; no one will likely bother making a bot that
    can defeat all of them. At any rate, this example should be enough to illustrate
    why you should never use this technique for large-scale websites.
  prefs: []
  type: TYPE_NORMAL
- en: Taking screenshots
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to the usual testing capabilities, Selenium has an interesting
    trick up its sleeve that might make your testing (or impressing your boss) a little
    easier: screenshots. Yes, photographic evidence can be created from unit tests
    run without the need for actually pressing the PrtScn key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This script navigates to [*http://pythonscraping.com*](http://pythonscraping.com)
    and then stores a screenshot of the home page in the local *tmp* folder (the folder
    must already exist for this to store correctly). Screenshots can be saved as a
    variety of image formats.
  prefs: []
  type: TYPE_NORMAL
