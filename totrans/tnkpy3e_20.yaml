- en: 18\. Python Extras#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://allendowney.github.io/ThinkPython/chap18.html](https://allendowney.github.io/ThinkPython/chap18.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: One of my goals for this book has been to teach you as little Python as possible.
    When there were two ways to do something, I picked one and avoided mentioning
    the other. Or sometimes I put the second one into an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Now I want to go back for some of the good bits that got left behind. Python
    provides a number of features that are not really necessary – you can write good
    code without them – but with them you can write code that’s more concise, readable,
    or efficient, and sometimes all three.
  prefs: []
  type: TYPE_NORMAL
- en: 18.1\. Sets[#](#sets "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python provides a class called `set` that represents a collection of unique
    elements. To create an empty set, we can use the class object like a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We can use the `add` method to add elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Or we can pass any kind of sequence to `set`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: An element can only appear once in a `set`. If you add an element that’s already
    there, it has no effect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Or if you create a set with a sequence that contains duplicates, the result
    contains only unique elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Some of the exercises in this book can be done concisely and efficiently with
    sets. For example, here is a solution to an exercise in Chapter 11 that uses a
    dictionary to check whether there are any duplicate elements in a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This version adds the element of `t` as keys in a dictionary, and then checks
    whether there are fewer keys than elements. Using sets, we can write the same
    function like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: An element can only appear in a set once, so if an element in `t` appears more
    than once, the set will be smaller than `t`. If there are no duplicates, the set
    will be the same size as `t`.
  prefs: []
  type: TYPE_NORMAL
- en: '`set` objects provide methods that perform set operations. For example, `union`
    computes the union of two sets, which is a new set that contains all elements
    that appear in either set.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Some arithmetic operators work with sets. For example, the `-` operator performs
    set subtraction – the result is a new set that contains all elements from the
    first set that are *not* in the second set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In [Chapter 12](chap12.html#section-dictionary-subtraction) we used dictionaries
    to find the words that appear in a document but not in a word list. We used the
    following function, which takes two dictionaries and returns a new dictionary
    that contains only the keys from the first that don’t appear in the second.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With sets, we don’t have to write this function ourselves. If `word_counter`
    is a dictionary that contains the unique words in the document and `word_list`
    is a list of valid words, we can compute the set difference like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The result is a set that contains the words in the document that don’t appear
    in the word list.
  prefs: []
  type: TYPE_NORMAL
- en: The relational operators work with sets. For example, `<=` checks whether one
    set is a subset of another, including the possibility that they are equal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With these operators, we can use sets to do some of the exercises in Chapter 7.
    For example, here’s a version of `uses_only` that uses a loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`uses_only` checks whether all letters in `word` are in `available`. With sets,
    we can rewrite it like this.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If the letters in `word` are a subset of the letters in `available`, that means
    that `word` uses only letters in `available`.
  prefs: []
  type: TYPE_NORMAL
- en: 18.2\. Counters[#](#counters "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `Counter` is like a set, except that if an element appears more than once,
    the `Counter` keeps track of how many times it appears. If you are familiar with
    the mathematical idea of a “multiset”, a `Counter` is a natural way to represent
    a multiset.
  prefs: []
  type: TYPE_NORMAL
- en: The `Counter` class is defined in a module called `collections`, so you have
    to import it. Then you can use the class object as a function and pass as an argument
    a string, list, or any other kind of sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: A `Counter` object is like a dictionary that maps from each key to the number
    of times it appears. As in dictionaries, the keys have to be hashable.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike dictionaries, `Counter` objects don’t raise an exception if you access
    an element that doesn’t appear. Instead, they return `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We can use `Counter` objects to solve one of the exercises from Chapter 10,
    which asks for a function that takes two words and checks whether they are anagrams
    – that is, whether the letters from one can be rearranged to spell the other.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a solution using `Counter` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If two words are anagrams, they contain the same letters with the same counts,
    so their `Counter` objects are equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '`Counter` provides a method called `most_common` that returns a list of value-frequency
    pairs, sorted from most common to least.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: They also provide methods and operators to perform set-like operations, including
    addition, subtraction, union and intersection. For example, the `+` operator combines
    two `Counter` objects and creates a new `Counter` that contains the keys from
    both and the sums of the counts.
  prefs: []
  type: TYPE_NORMAL
- en: We can test it by making a `Counter` with the letters from `'bans'` and adding
    it to the letters from `'banana'`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You’ll have a chance to explore other `Counter` operations in the exercises
    at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 18.3\. defaultdict[#](#defaultdict "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `collections` module also provides `defaultdict`, which is like a dictionary
    except that if you access a key that doesn’t exist, it generates a new value automatically.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a `defaultdict`, you provide a function that’s used to create
    new values. A function that create objects is sometimes called a **factory**.
    The built-in functions that create lists, sets, and other types can be used as
    factories.
  prefs: []
  type: TYPE_NORMAL
- en: For example, here’s a `defaultdict` that creates a new `list` when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the argument is `list`, which is a class object, not `list()`, which
    is a function call that creates a new list. The factory function doesn’t get called
    unless we access a key that doesn’t exist.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The new list, which we’re calling `t`, is also added to the dictionary. So
    if we modify `t`, the change appears in `d`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If you are making a dictionary of lists, you can often write simpler code using
    `defaultdict`.
  prefs: []
  type: TYPE_NORMAL
- en: In one of the exercises in [Chapter 11](chap11.html#chapter-tuples), I made
    a dictionary that maps from a sorted string of letters to the list of words that
    can be spelled with those letters. For example, the string `'opst'` maps to the
    list `['opts', 'post', 'pots', 'spot', 'stop', 'tops']`. Here’s the original code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: And here’s a simpler version using a `defaultdict`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the exercises at the end of the chapter, you’ll have a chance to practice
    using `defaultdict` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 18.4\. Conditional expressions[#](#conditional-expressions "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Conditional statements are often used to choose one of two values, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This statement checks whether `x` is positive. If so, it computes its logarithm.
    If not, `math.log` would raise a ValueError. To avoid stopping the program, we
    generate a `NaN`, which is a special floating-point value that represents “Not
    a Number”.
  prefs: []
  type: TYPE_NORMAL
- en: We can write this statement more concisely using a **conditional expression**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You can almost read this line like English: “`y` gets log-`x` if `x` is greater
    than 0; otherwise it gets `NaN`”.'
  prefs: []
  type: TYPE_NORMAL
- en: Recursive functions can sometimes be written concisely using conditional expressions.
    For example, here is a version of `factorial` with a conditional *statement*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: And here’s a version with a conditional *expression*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Another use of conditional expressions is handling optional arguments. For example,
    here is class definition with an `__init__` method that uses a conditional statement
    to check a parameter with a default value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Here’s a version that uses a conditional expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In general, you can replace a conditional statement with a conditional expression
    if both branches contain a single expression and no statements.
  prefs: []
  type: TYPE_NORMAL
- en: 18.5\. List comprehensions[#](#list-comprehensions "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In previous chapters, we’ve seen a few examples where we start with an empty
    list and add elements, one at a time, using the `append` method. For example,
    suppose we have a string that contains the title of a movie, and we want to capitalize
    all of the words.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We can split it into a list of strings, loop through the strings, capitalize
    them, and append them to a list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do the same thing more concisely using a **list comprehension**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The bracket operators indicate that we are constructing a new list. The expression
    inside the brackets specifies the elements of the list, and the `for` clause indicates
    what sequence we are looping through.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of a list comprehension might seem strange, because the loop variable
    – `word` in this example – appears in the expression before we get to its definition.
    But you get used to it.
  prefs: []
  type: TYPE_NORMAL
- en: As another example, in [Chapter 9](chap09.html#section-word-list) we used this
    loop to read words from a file and append them to a list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Here’s how we can write that as a list comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: A list comprehension can also have an `if` clause that determines which elements
    are included in the list. For example, here’s a `for` loop we used in [Chapter
    10](chap10.html#section-palindrome-list) to make a list of only the words in `word_list`
    that are palindromes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Here’s how we can do the same thing with an list comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: When a list comprehension is used as an argument to a function, we can often
    omit the brackets. For example, suppose we want to add up \(1 / 2^n\) for values
    of \(n\) from 0 to 9. We can use a list comprehension like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Or we can leave out the brackets like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the argument is technically a **generator expression**, not
    a list comprehension, and it never actually makes a list. But other than that,
    the behavior is the same.
  prefs: []
  type: TYPE_NORMAL
- en: List comprehensions and generator expressions are concise and easy to read,
    at least for simple expressions. And they are usually faster than the equivalent
    for loops, sometimes much faster. So if you are mad at me for not mentioning them
    earlier, I understand.
  prefs: []
  type: TYPE_NORMAL
- en: But, in my defense, list comprehensions are harder to debug because you can’t
    put a print statement inside the loop. I suggest you use them only if the computation
    is simple enough that you are likely to get it right the first time. Or consider
    writing and debugging a `for` loop and then converting it to a list comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: 18.6\. `any` and `all`[#](#any-and-all "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python provides a built-in function, `any`, that takes a sequence of boolean
    values and returns `True` if any of the values are `True`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '`any` is often used with generator expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: That example isn’t very useful because it does the same thing as the `in` operator.
    But we could use `any` to write concise solutions to some of the exercises in
    [Chapter 7](chap07.html#chapter-search). For example, we can write `uses_none`
    like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This function loops through the letters in `word` and checks whether any of
    them are in `forbidden`. Using `any` with a generator expression is efficient
    because it stops immediately if it finds a `True` value, so it doesn’t have to
    loop through the whole sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Python provides another built-in function, `all`, that returns `True` if every
    element of the sequence is `True`. We can use it to write a concise version of
    `uses_all`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Expressions using `any` and `all` can be concise, efficient, and easy to read.
  prefs: []
  type: TYPE_NORMAL
- en: 18.7\. Named tuples[#](#named-tuples "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `collections` module provides a function called `namedtuple` that can be
    used to create simple classes. For example, the `Point` object in [Chapter 16](chap16.html#section-create-point)
    has only two attributes, `x` and `y`. Here’s how we defined it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: That’s a lot of code to convey a small amount of information. `namedtuple` provides
    a more concise way to define classes like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The first argument is the name of the class you want to create. The second is
    a list of the attributes `Point` objects should have. The result is a class object,
    which is why it is assigned to a capitalized variable name.
  prefs: []
  type: TYPE_NORMAL
- en: A class created with `namedtuple` provides an `__init__` method that assigns
    values to the attributes and a `__str__` that displays the object in a readable
    form. So we can create and display a `Point` object like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '`Point` also provides an `__eq__` method that checks whether two `Point` objects
    are equivalent – that is, whether their attributes are the same.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: You can access the elements of a named tuple by name or by index.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: You can also treat a named tuple as a tuple, as in this assignment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: But `namedtuple` objects are immutable. After the attributes are initialized,
    they can’t be changed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '`namedtuple` provides a quick way to define simple classes. The drawback is
    that simple classes don’t always stay simple. You might decide later that you
    want to add methods to a named tuple. In that case, you can define a new class
    that inherits from the named tuple.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Or at that point you could switch to a conventional class definition.
  prefs: []
  type: TYPE_NORMAL
- en: 18.8\. Packing keyword arguments[#](#packing-keyword-arguments "Link to this
    heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 11](chap11.html#section-argument-pack), we wrote a function that
    packs its arguments into a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: You can call this function with any number of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: But the `*` operator doesn’t pack keyword arguments. So calling this function
    with a keyword argument causes an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'To pack keyword arguments, we can use the `**` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The keyword-packing parameter can have any name, but `kwargs` is a common choice.
    The result is a dictionary that maps from keywords to values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the value of `kwargs` is printed, but otherwise is has no effect.
  prefs: []
  type: TYPE_NORMAL
- en: But the `**` operator can also be used in an argument list to unpack a dictionary.
    For example, here’s a version of `mean` that packs any keyword arguments it gets
    and then unpacks them as keyword arguments for `sum`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Now if we call `mean` with `start` as a keyword argument, it gets passed along
    to sum, which uses it as the starting point of the summation. In the following
    example `start=3` adds `3` to the sum before computing the mean, so the sum is
    `6` and the result is `3`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: As another example, if we have a dictionary with keys `x` and `y`, we can use
    it with the unpack operator to create a `Point` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Without the unpack operator, `d` is treated as a single positional argument,
    so it gets assigned to `x`, and we get a `TypeError` because there’s no second
    argument to assign to `y`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: When you are working with functions that have a large number of keyword arguments,
    it is often useful to create and pass around dictionaries that specify frequently
    used options.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 18.9\. Debugging[#](#debugging "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In previous chapters, we used `doctest` to test functions. For example, here’s
    a function called `add` that takes two numbers and returns their sum. In includes
    a doctest that checks whether `2 + 2` is `4`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: This function takes a function object and runs its doctests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: So we can test `add` like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: There’s no output, which means all tests passed.
  prefs: []
  type: TYPE_NORMAL
- en: Python provides another tool for running automated tests, called `unittest`.
    It is a little more complicated to use, but here’s an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: First we import `TestCase`, which is a class in the `unittest` module. To use
    it, we have to define a new class that inherits from `TestCase` and provides at
    least one test method. The name of the test method must begin with `test` and
    should indicate which function it tests.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, `test_add` tests the `add` function by calling it, saving the
    result, and invoking `assertEqual`, which is inherited from `TestCase`. `assertEqual`
    takes two arguments and checks whether they are equal.
  prefs: []
  type: TYPE_NORMAL
- en: In order to run this test method, we have to run a function in `unittest` called
    `main` and provide several keyword arguments. The following function shows the
    details – if you are curious, you can ask a virtual assistant to explain how it
    works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '`run_unittest` does not take `TestExample` as an argument – instead, it searches
    for classes that inherit from `TestCase`. Then it searches for methods that begin
    with `test` and runs them. This process is called **test discovery**.'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s what happens when we call `run_unittest`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '`unittest.main` reports the number of tests it ran and the results. In this
    case `OK` indicates that the tests passed.'
  prefs: []
  type: TYPE_NORMAL
- en: To see what happens when a test fails, we’ll add an incorrect test method to
    `TestExample`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Here’s what happens when we run the tests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: The report includes the test method that failed and an error message showing
    where. The summary indicates that two tests ran and one failed.
  prefs: []
  type: TYPE_NORMAL
- en: In the exercises below, I’ll suggest some prompts you can use to ask a virtual
    assistant for more information about `unittest`.
  prefs: []
  type: TYPE_NORMAL
- en: 18.10\. Glossary[#](#glossary "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**factory:** A function used to create objects, often passed as a parameter
    to a function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**conditional expression:** An expression that uses a conditional to select
    one of two values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**list comprehension:** A concise way to loop through a sequence and create
    a list.'
  prefs: []
  type: TYPE_NORMAL
- en: '**generator expression:** Similar to a list comprehension except that it does
    not create a list.'
  prefs: []
  type: TYPE_NORMAL
- en: '**test discovery:** A process used to find and run tests.'
  prefs: []
  type: TYPE_NORMAL
- en: 18.11\. Exercises[#](#exercises "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 18.11.1\. Ask a virtual assistant[#](#ask-a-virtual-assistant "Link to this
    heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a few topics in this chapter you might want to learn about.
  prefs: []
  type: TYPE_NORMAL
- en: “What are the methods and operators of Python’s set class?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “What are the methods and operators of Python’s Counter class?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “What is the difference between a Python list comprehension and a generator
    expression?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “When should I use Python’s `namedtuple` rather than define a new class?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “What are some uses of packing and unpacking keyword arguments?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “How does `unittest` do test discovery?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Along with `assertEqual`, what are the most commonly used methods in `unittest.TestCase`?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “What are the pros and cons of `doctest` and `unittest`?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the following exercises, consider asking a virtual assistant for help, but
    as always, remember to test the results.
  prefs: []
  type: TYPE_NORMAL
- en: 18.11.2\. Exercise[#](#exercise "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the exercises in Chapter 7 asks for a function called `uses_none` that
    takes a word and a string of forbidden letters, and returns `True` if the word
    does not use any of the letters. Here’s a solution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a version of this function that uses `set` operations instead of a `for`
    loop. Hint: ask a VA, “How do I compute the intersection of Python sets?”'
  prefs: []
  type: TYPE_NORMAL
- en: 18.11.3\. Exercise[#](#id1 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Scrabble is a board game where the objective is to use letter tiles to spell
    words. For example, if we have tiles with the letters `T`, `A`, `B`, `L`, `E`,
    we can spell `BELT` and `LATE` using a subset of the tiles – but we can’t spell
    `BEET` because we don’t have two `E`s.
  prefs: []
  type: TYPE_NORMAL
- en: Write a function that takes a string of letters and a word, and checks whether
    the letters can spell the word, taking into account how many times each letter
    appears.
  prefs: []
  type: TYPE_NORMAL
- en: 18.11.4\. Exercise[#](#id2 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In one of the exercises from [Chapter 17](chap17.html#chapter-inheritance),
    my solution to `has_straightflush` uses the following method, which partitions
    a `PokerHand` into a list of four hands, where each hand contains cards of the
    same suit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Write a simplified version of this function using a `defaultdict`.
  prefs: []
  type: TYPE_NORMAL
- en: 18.11.5\. Exercise[#](#id3 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here’s the function from Chapter 11 that computes Fibonacci numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Write a version of this function with a single return statement that use two
    conditional expressions, one nested inside the other.
  prefs: []
  type: TYPE_NORMAL
- en: 18.11.6\. Exercise[#](#id4 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following is a function that computes the binomial coefficient recursively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Rewrite the body of the function using nested conditional expressions.
  prefs: []
  type: TYPE_NORMAL
- en: This function is not very efficient because it ends up computing the same values
    over and over. Make it more efficient by memoizing it, as described in [Chapter
    10](chap10.html#section-memos).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 18.11.7\. Exercise[#](#id5 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here’s the `__str__` method from the `Deck` class in [Chapter 17](chap17.html#section-print-deck).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Write a more concise version of this method with a list comprehension or generator
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[Think Python: 3rd Edition](https://allendowney.github.io/ThinkPython/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Copyright 2024 [Allen B. Downey](https://allendowney.com)
  prefs: []
  type: TYPE_NORMAL
- en: 'Code license: [MIT License](https://mit-license.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Text license: [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
  prefs: []
  type: TYPE_NORMAL
