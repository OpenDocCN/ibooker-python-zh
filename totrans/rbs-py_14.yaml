- en: Chapter 12\. Subtyping
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 12 章。子类型
- en: Most of [Part II](part0011.html#part_2) has focused on creating your own types
    and defining interfaces. These types do not exist in isolation; types are often
    related to one another. So far, you’ve seen *composition*, where types use other
    types as members. In this chapter, you’ll learn about *subtyping*, or creating
    types based on other types.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Part II 的大部分内容集中在创建自己的类型和定义接口上。这些类型不是孤立存在的；类型通常彼此相关联。到目前为止，您已经看到了 *组合*，其中类型使用其他类型作为成员。在本章中，您将了解
    *子类型*，即基于其他类型创建类型。
- en: When applied correctly, subtyping makes it incredibly easy to extend your codebase.
    You can introduce new behaviors without ever worrying about breaking the rest
    of your codebase. However, you must be dilligent when creating a subtyping relationship;
    if you do it poorly, you can decrease the robustness of your codebase in unexpected
    ways.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确应用时，子类型使得扩展代码库变得非常容易。您可以引入新的行为，而无需担心破坏代码库的其他部分。但是，在创建子类型关系时必须非常小心；如果处理不当，可能会以意想不到的方式降低代码库的健壮性。
- en: 'I’ll start with one of the most common subtype relationships: inheritance.
    Inheritance is seen as a traditional pillar of object-oriented programming (OOP).^([1](part0016_split_007.html#idm45644737734424))
    Inheritance can be tricky if not applied correctly. I’ll then move on to other
    forms of subtyping present in the Python programming language. You’ll also learn
    about one of the more fundamental SOLID design principles, the Liskov Substitution
    Principle. This chapter will help you make sense of when and where subtyping is
    appropriate and where it is not.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从最常见的子类型关系之一开始：继承。继承被视为面向对象编程（OOP）的传统支柱之一。^([1](part0016_split_007.html#idm45644737734424))
    如果不正确应用，继承可能会很棘手。然后，我将进一步介绍 Python 编程语言中存在的其他形式的子类型。您还将了解到基本的SOLID设计原则之一，即里斯科夫替换原则。本章将帮助您理解何时以及何地适合使用子类型，以及何时不适合。
- en: Inheritance
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: Most developers immediately think of inheritance when they talk about subtyping.
    *Inheritance* is a way of creating a new type from another type, copying all the
    behaviors into the new type. This new type is known as a *child class*, *derived
    class*, or *subclass*. In contrast, the type being inherited from is known as
    a *parent class*, *base class*, or *superclass*. When talking about types in this
    way, we say that the relationship is an *is-a* relationship. Any object of a derived
    class is also an instance of a base class.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当大多数开发者谈论子类型时，他们立即想到继承。*继承* 是一种从另一个类型创建新类型的方式，将所有行为复制到新类型中。这种新类型称为*子类*、*派生类*或*衍生类*。相反，被继承的类型称为*父类*、*基类*或*超类*。在这种类型的讨论中，我们说这种关系是一种
    *is-a* 关系。派生类的任何对象也是基类的实例。
- en: 'To illustrate this, you are going to design an app that helps owners of restaurants
    organize operations (tracking finances, customizing menus, etc.). For this scenario,
    a restaurant has the following behaviors:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，你将设计一个帮助餐厅业主组织运营的应用程序（跟踪财务、定制菜单等）。对于这种情况，餐厅具有以下行为：
- en: 'A restaurant has the following attributes: a name, a location, a list of employees
    and their schedules, inventory, a menu, and current finances. All of these attributes
    are mutable; even a restaurant can be renamed or change locations. When a restaurant
    changes locations, its location attribute reflects its final destination.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个餐厅具有以下属性：名称、位置、员工及其排班表、库存、菜单和当前财务状况。所有这些属性都是可变的；甚至餐厅的名称或位置也可以更改。当餐厅更改位置时，其位置属性将反映其最终目的地。
- en: An owner can own multiple restaurants.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个所有者可以拥有多个餐厅。
- en: Employees can be moved from one restaurant to another, but they cannot work
    at two restaurants at the same time.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 员工可以从一个餐厅调动到另一个餐厅，但不能同时在两个餐厅工作。
- en: When a dish is ordered, the ingredients used are removed from the inventory.
    When a specific item is depleted in the inventory, any dish requiring the ingredient
    is no longer available through the menu.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当点菜时，使用的成分将从库存中移除。当库存中的特定项目用尽时，需要该成分的任何菜品将不再通过菜单提供。
- en: Whenever a menu item is sold, the restaurant’s funds increase. Whenever new
    inventory is purchased, the restaurant’s funds decrease. For every hour that an
    employee works at that restaurant, the restaurant’s funds decrease according to
    the employee’s salary and/or wage.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当销售一个菜单项目时，餐厅的资金增加。每当购买新的库存时，餐厅的资金减少。每个员工在餐厅工作的每个小时，餐厅的资金都会根据员工的工资和/或时薪减少。
- en: Restaurant owners will use this app to view all their restaurants, manage their
    inventory, and track profits in real time.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 餐馆业主将使用此应用程序查看他们所有的餐馆，管理库存，并实时跟踪利润。
- en: 'Since there are specific invariants about the restaurant, I’ll use a class
    to represent a restaurant:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于餐馆有特定的不变量，我将使用一个类来代表一个餐馆：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In addition to a “standard” restaurant, as described above, there are a few
    “specialized” restaurants: a food truck and a pop-up stall.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述描述的“标准”餐馆外，还有几家“专业化”的餐馆：食品车和流动小吃摊。
- en: 'Food trucks are mobile: they drive around to different spots and change their
    menu based on the occasion. Pop-up stalls are transient; they appear for a limited
    time with a limited menu (typically for some sort of event like a festival or
    fair). While slightly different in how they operate, both a food truck and pop-up
    stall are still restaurants. This is what I mean when I say an *is-a* relationship—a
    food truck *is a* restaurant and a pop-up stall *is a* restaurant. Because this
    is an *is-a* relationship, inheritance is an appropriate construct to use.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 食品车是移动的：它们到不同的地点行驶，并根据场合更改菜单。流动小吃摊是短暂的；它们出现在有限的时间内，并提供有限的菜单（通常是某种事件，如节日或集市）。尽管它们在运作方式上略有不同，但食品车和流动小吃摊仍然是餐馆。这就是我所说的“is-a”关系的含义——食品车“是一个”餐馆，流动小吃摊“是一个”餐馆。因为这是一个“is-a”关系，继承是一个适当的构造来使用。
- en: 'You denote inheritance by specifying the base class when you define your derived
    class:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义派生类时，通过指定基类来表示继承：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[Figure 12-1](part0016_split_001.html#inheritance_uml) shows how this relationship
    is typically drawn.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-1](part0016_split_001.html#inheritance_uml) 展示了这种关系通常如何绘制。'
- en: '![Inheritance tree of restaurants](../images/00016.gif)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![餐馆的继承树](../images/00016.gif)'
- en: Figure 12-1\. Inheritance tree of restaurants
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-1\. 餐馆的继承树
- en: By defining inheritance in this fashion, you ensure that the derived classes
    will inherit all the methods and attributes from the base class, without needing
    to redefine them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以这种方式定义继承，确保派生类将继承基类的所有方法和属性，而无需重新定义它们。
- en: This means that if you were to instantiate one of the derived classes, such
    as `FoodTruck`, you would be able to use all the same methods as if you were interacting
    with a `Restaurant`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果您实例化其中一个派生类，比如 `FoodTruck`，您将能够使用与与 `Restaurant` 交互时相同的所有方法。
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'What’s really nice about this is that a derived class can be passed to a function
    expecting a base class and the typechecker will not complain one bit:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的优点在于，派生类可以传递给期望基类的函数，类型检查器不会抱怨一点：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By default, the derived class operates exactly like the base class. If you’d
    like the derived class to do something different, you can override methods or
    redefine the methods in the derived class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，派生类的行为与基类完全相同。如果希望派生类执行不同的操作，可以重写方法或在派生类中重新定义方法。
- en: 'Suppose I want my food truck to automatically drive to the next location when
    the location changes. For this use case, however, when asking for restaurant data,
    I only want the final location, not the location while the food truck is en route.
    Developers can call a separate method to show the current location (for use in
    a separate food truck–only map). I’ll set up a GPS locator in the `FoodTruck`’s
    constructor, and override `move_location` to start the automatic driving:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我希望我的食品车在位置更改时自动驶向下一个位置。但对于这种用例，当请求餐馆数据时，我只想要最终的位置，而不是食品车在路上的位置。开发人员可以调用一个单独的方法来显示当前位置（用于单独的食品车地图）。我将在
    `FoodTruck` 的构造函数中设置 GPS 定位器，并重写 `move_location` 来启动自动驾驶：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: I am using a special function, `super()`, to access the base class. When I call
    `super().__init__()`, I am actually calling `Restaurant`’s constructor. When I
    call `super().move_location`, I am calling `Restaurant`’s `move_location`, not
    `FoodTruck`’s `move_location`. This way, the code can behave exactly like the
    base class.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在使用一个特殊的函数，`super()`，来访问基类。当我调用 `super().__init__()` 时，实际上是在调用 `Restaurant`
    的构造函数。当我调用 `super().move_location` 时，我在调用 `Restaurant` 的 `move_location`，而不是 `FoodTruck`
    的 `move_location`。这样，代码可以完全像基类一样运行。
- en: Take a moment and reflect on the implications of extending code through subclassing.
    You can insert new behaviors into existing code without ever modifying that existing
    code. If you avoid modifying existing code, you drastically reduce the chance
    of introducing new bugs; you won’t inadvertently break consumers’ assumptions
    if you aren’t changing the code they depend on. A well-designed inheritance structure
    can greatly improve maintainability. Unfortunately, the inverse is true as well;
    design your inheritance poorly, and maintainability suffers. When working with
    inheritance, you always need to be thinking about how easy it is to substitute
    your code.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请花一点时间思考通过子类扩展代码的影响。您可以向现有代码中插入新的行为，而无需修改该现有代码。如果避免修改现有代码，则大大减少引入新错误的机会；如果不更改消费者依赖的代码，您也不会无意中打破他们的假设。良好设计的继承结构可以极大提高可维护性。不幸的是，反之亦然；设计不良的继承会导致可维护性下降。在使用继承时，您始终需要考虑代码替代的简易性。
- en: Substitutability
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可替代性
- en: As described earlier, inheritance is all about modeling an *is-a* relationship.
    Describing something with an *is-a* relationship may sound simple, but you’d be
    surprised just how wrong things can go. To model *is-a* relationships properly,
    you need to understand substitutability.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所述，继承关系涉及建模*是一个*关系。描述具有*是一个*关系的事物可能听起来很简单，但实际上可能出现很多意外情况。要正确建模*是一个*关系，您需要理解可替代性。
- en: '*Substitutability* states that when you derive from a base class, you should
    be able to use that derived class in every instance that you use a base class.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*可替代性*表明，当您从基类派生时，您应该能够在每个使用基类的实例中使用该派生类。'
- en: 'If I were to create a function that could display relevant restaurant data:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我创建一个可以显示相关餐厅数据的函数：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I should be able to pass a `Restaurant`, a `FoodTruck`, or a `PopUpStall`, and
    this function should be none the wiser. Again, this sounds simple; what’s the
    catch?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该能够传递一个`Restaurant`、一个`FoodTruck`或一个`PopUpStall`，而这个函数不应该感知到任何不同。这再次听起来很简单；有什么难点吗？
- en: 'There is indeed a catch. To show you, I’d like to step away from the food concept
    for a second, and go back to a fundamental question that any first grader should
    be able to answer: is a square a rectangle?'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 的确有一个难点。为了向您展示，我想暂时摆脱食品概念，回到任何一年级学生都应该能回答的基本问题：一个正方形是矩形吗？
- en: From your early days of school, you probably know the answer as “yes, a square
    is a rectangle.” A rectangle is a polygon that has four sides, and each intersection
    of two sides is a 90-degree angle. A square is the same, with the extra requirement
    that each side must be the exact same length.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从您上学的早期，您可能知道答案是“是的，正方形是矩形”。矩形是一个有四条边的多边形，两条边的交点是90度角。正方形也是如此，但额外要求每条边的长度必须完全相同。
- en: 'If I were to model this with inheritance, I might do so as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我用继承来建模这个问题，可能会这样做：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So yes, from a geometry perspective a square is indeed a rectangle. But this
    assumption when mapped to *is-a* relationships is flawed. Take a few moments and
    see if you can catch where my assumptions break down.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所以是的，从几何学的角度来看，正方形确实是矩形。但是，将这种假设映射到*是一个*关系时是有缺陷的。花几分钟时间看看我的假设在哪里崩溃。
- en: 'Still don’t see it? Here’s a hint: what if I asked you if a `Square` is *substitutable*
    for a `Rectangle` for every use case? Can you construct a use case for a rectangle
    that a square would not be substitutable for?'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 还看不出来？这里有个提示：如果我问你正方形是否可以在所有用例中替代矩形，你能构造一个正方形无法替代矩形的用例吗？
- en: 'Suppose the user of the app selects squares and rectangles on a map of restaurants
    to gauge market size. A user can draw a shape on the map, and then expand it as
    needed. One of the functions to handle this is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 假设应用程序的用户在餐厅地图上选择正方形和矩形以评估市场规模。用户可以在地图上绘制一个形状，然后根据需要扩展它。处理此功能之一如下：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With this code, what would happen if I were to pass a `Square` as the argument?
    All of a sudden, a previously passing assertion would start to fail, since the
    height of a square changes when the length changes. This is catastrophic; the
    whole intention of inheritance is to extend functionality without breaking existing
    code. In this case, by passing in a `Square` (since it’s also a `Rectangle`, the
    type checker won’t complain), I have introduced a bug just waiting to happen.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，如果我将一个`Square`作为参数传递会发生什么？突然间，之前通过的断言将开始失败，因为当长度改变时，正方形的高度也会改变。这是灾难性的；继承的整个意图是在不破坏现有代码的情况下扩展功能。在这种情况下，通过传递一个`Square`（因为它也是一个`Rectangle`，类型检查器不会抱怨），我引入了一个等待发生的错误。
- en: 'This sort of mistake impacts the derived class as well. The error above stems
    from overriding `set_width` in `Square` so that the height is changed as well.
    What if `set_width` were not overridden and the `Rectangle`’s `set_width function`
    were invoked? Well, if this were the case, and you passed a `Square` into the
    function, the assertion would not fail. Instead, something far less obvious but
    much more detrimental happens: the function succeeds. No longer do you receive
    an `AssertionError` with a stack trace that leads you to the bug. Now, you create
    a square that is no longer a square; the width is changed, but the height has
    not. You have committed a cardinal sin and have broken the invariants of that
    class.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种错误也会影响派生类。上述错误源于在`Square`中重写`set_width`，以便同时更改高度。如果没有重写`set_width`，而是调用了`Rectangle`的`set_width
    function`，会发生什么？如果是这样的话，并且你把一个`Square`传递给函数，断言将不会失败。相反，会发生一些不那么明显但更为有害的事情：函数成功执行。你不再收到带有堆栈跟踪导致错误的`AssertionError`。现在，你创建了一个不再是正方形的正方形；宽度已经改变，但高度没有变。你犯了一个基本错误，并且破坏了该类的不变量。
- en: What makes this so sinister is that the goal of inheritance is to decouple,
    or remove dependencies from, existing code and new code. Implementers and consumers
    of the base class have no view into different derived classes at runtime. It might
    be that the derived class definitions live in a completely different codebase,
    owned by a different organization. With this error case, you make it so that every
    time a derived class changes, you need to look at every invocation and use of
    the base class and assess whether or not your changes will break code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使得这种错误如此阴险的是继承的目标是为了解耦或者说移除现有代码和新代码之间的依赖关系。基类的实现者和使用者在运行时看不到不同的派生类。也许派生类的定义存在于完全不同的代码库中，由不同的组织拥有。在这种错误情况下，你会使得每次派生类发生变化时，都需要查看基类的每个调用和使用，并评估你的更改是否会破坏代码。
- en: In order to solve this, you have a few options available to you. First, you
    can not inherit `Square` from `Rectangle` in the first place and avoid the whole
    problem. Second, you can restrict the methods of `Rectangle` so that the `Square`
    does not contradict it (such as making the fields immutable). Last, you can abolish
    the class hierarchy altogether and provide an `is_square` method in the `Rectangle`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你有几个可选的方法。首先，你可以根本不让`Square`从`Rectangle`继承，避免整个问题。其次，你可以限制`Rectangle`的方法，使得`Square`不会与其矛盾（比如使字段不可变）。最后，你可以完全取消类的层次结构，并在`Rectangle`中提供一个`is_square`方法。
- en: These sorts of errors can break your codebase in subtle ways. Consider the use
    case where I want to franchise my restaurants; franchisees are allowed to create
    their own menu, but must always have a common set of dishes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些错误可能会以微妙的方式破坏你的代码库。考虑这样一个使用案例：我想要给我的餐馆加盟; 加盟商可以创建自己的菜单，但必须始终具有一组共同的菜肴。
- en: 'Here’s a potential implementation:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个潜在的实现方式：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, the function returns early if any of the restricted items aren’t
    in the new menu. What seems sensible in isolation completely falls apart when
    put in an inheritance hierarchy. Put yourself in another developer’s shoes, one
    who wants to implement the UI for changing menus in the app. They see a `Restaurant`
    class, and code against that interface. When a `RestrictedMenuRestaurant` inevitably
    gets used in place of a `Restaurant`, the UI will try to change a menu and have
    no indication that the update didn’t actually occur. The only way this bug could
    have been caught earlier would be for a developer to trawl through the codebase
    looking for derived classes that broke invariants. And if there’s any theme to
    this book, it’s that any time a developer has to go searching through a codebase
    to understand one piece of code, it’s a sure sign of fragility.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果新菜单中缺少任何限制项，函数会提前返回。一个看似合理的单独行为放在继承层次结构中完全会出现问题。请设身处地地换位思考，想象一下另一位开发人员，他想要实现应用程序中更改菜单的UI。他看到了一个`Restaurant`类，并根据这个接口编写代码。当一个`RestrictedMenuRestaurant`不可避免地被用作`Restaurant`的替代品时，UI将尝试更改菜单，但没有任何迹象表明更新实际上没有发生。唯一能更早发现这个错误的方法是开发人员搜索代码库，寻找破坏不变量的派生类。如果这本书有一个主题，那就是每当开发人员不得不搜索代码库以理解其中一部分代码时，这都是代码脆弱性的明显迹象。
- en: What if I wrote the code to throw an exception instead of just returning? Unfortunately,
    this doesn’t solve any problems either. Now, when users change the menu of a `Restaurant`,
    they are liable to receive an exception. If they look at the `Restaurant` class’s
    code, there is no indication that they would ever need to think about an exception.
    Nor should they be paranoid and wrap every call in a `try...except` block, worried
    that a derived class somewhere might throw an exception.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我写的代码抛出异常而不是简单返回会怎么样呢？不幸的是，这也解决不了任何问题。现在，当用户更改`Restaurant`的菜单时，他们可能会收到一个异常。如果他们查看`Restaurant`类的代码，就看不到他们需要考虑异常的迹象。他们也不应该偏执地每次调用都包装在`try...except`块中，担心某个地方的派生类可能会抛出异常。
- en: 'In both of these cases, subtle errors are introduced when a class inherits
    from a base class but does not behave exactly as that base class does. These errors
    require a specific combination of conditions to occur: code must execute methods
    on the base class, it must depend on specific behavior of that base class, and
    a derived class breaking that behavior has to be substituted as a base class.
    The tricky thing is that any of these conditions can be introduced long after
    the original code was written. This is why substitutability is so important. As
    a matter of fact, the importance of substitutability is embodied in a very important
    principle: the Liskov Substitution Principle.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，当一个类继承自一个基类但其行为并不完全与基类一致时，就会引入微妙的错误。这些错误需要特定的条件组合才会发生：代码必须在基类上执行方法，必须依赖于基类的特定行为，并且一个破坏该行为的派生类被用作基类的替代。棘手的是，这些条件中的任何一个都可能在原始代码编写后的很长时间内引入。这就是为什么可替换性如此重要。实际上，可替换性的重要性体现在一个非常重要的原则中：里斯科夫替换原则。
- en: The Liskov Substitution Principle (LSP), named after Barbara Liskov, states
    the following:^([2](part0016_split_007.html#idm45644736586104))
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[里斯科夫替换原则（Liskov Substitution Principle）](https://wiki.example.org/liskov_substitution_principle)，以芭芭拉·里斯科夫命名，陈述如下:^([2](part0016_split_007.html#idm45644736586104))'
- en: '*Subtype Requirement*: Let `Φ(X)` be a property provable about objects `X`
    of type `T`. Then `Φ(Y)` should be true for objects `Y` of type `S` where `S`
    is a subtype of `T`.'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*子类型要求*：让`Φ(X)`是对类型`T`的对象`X`可证明的一个属性。那么对于类型`S`的对象`Y`（其中`S`是`T`的一个子类型），`Φ(Y)`也应该为真。'
- en: 'Don’t let the formal notation scare you. The LSP is quite simple: in order
    for a subtype to exist, it must adhere to all the same properties (behaviors)
    as the supertype. It all comes back to substitutability. You should keep the LSP
    in mind whenever you think about properties of supertypes and what they mean for
    subtypes. When designing with inheritance, think through the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 不要让正式的符号表达吓到你。LSP（Liskov Substitution Principle）其实非常简单：为了存在一个子类型，它必须遵循与超类型相同的所有属性（行为）。这一切都归结为可替换性。每当你考虑超类型的属性及其对子类型意味着什么时，你都应该牢记LSP。在使用继承设计时，请考虑以下几点：
- en: Invariants
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 不变量
- en: '[Chapter 10](part0014_split_000.html#classes) focused mostly on invariants
    (truths about your types that must not be violated). When you’re subtyping from
    other types, the subtypes *must* preserve all invariants. When I subtyped `Square`
    from `Rectangle`, I disregarded the invariant that heights and widths can be set
    independent of one another.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[第10章](part0014_split_000.html#classes) 主要关注不变性（关于类型的真理，不得违反）。当您从其他类型进行子类型化时，子类型必须*保持*所有不变性。当我从`Rectangle`中的`Square`进行子类型化时，我忽略了高度和宽度可以独立设置的不变性。'
- en: Preconditions
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 前置条件
- en: A precondition is anything that must be true before interacting with a type’s
    property (such as calling a function). If the supertype defines preconditions
    that happen, the subtype *must not* be more restrictive. This is what happened
    when I subtyped `RestrictedMenuRestaurant` from `Restaurant`. I added an extra
    precondition that certain ingredients were mandatory when changing the menu. By
    throwing an exception, I’ve made it so that previously good data would now fail.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 前置条件是在与类型属性交互之前必须为真的任何条件（如调用函数）。如果超类型定义了发生的前置条件，则子类型*不得*更为严格。这就是当我从`Restaurant`中的`RestrictedMenuRestaurant`进行子类型化时发生的情况。我添加了一个额外的前置条件，即在更改菜单时某些成分是强制性的。通过抛出异常，我使先前的良好数据现在失败了。
- en: Postcondition
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 后置条件
- en: A postcondition is anything that must be true after interacting with a type’s
    property. If a supertype defines postconditions, the subtype must not *weaken*
    those postconditions. A postcondition is weakened if any of its guarantees are
    not met. When I subtyped `RestrictedMenuRestaurant` from `Restaurant` and returned
    early instead of changing the menu, I violated a postcondition. The base class
    guaranteed a postcondition that the menu would be updated, regardless of the menu
    contents. When subtyped like I did, I could no longer guarantee that postcondition.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 后置条件是与类型属性交互后必须为真的任何条件。如果超类型定义了后置条件，则子类型不得*削弱*这些后置条件。如果任何保证未满足，则后置条件被削弱。当我从`Restaurant`中的`RestrictedMenuRestaurant`中派生出来并且返回早期而不是更改菜单时，我违反了后置条件。基类保证了一个后置条件，即菜单将被更新，而不管菜单内容如何。当我像我做的那样派生子类时，我再也不能保证这个后置条件。
- en: 'If at any time you break an invariant, precondition, or postcondition in an
    overridden function, you are begging for an error to show up. Here are some red
    flags that I look for in the derived class’s overridden functions when evaluating
    inheritance relationships:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在重写函数中的任何时候违反不变性、前置条件或后置条件，您将会引发错误。以下是我在评估继承关系时在派生类的重写函数中寻找的一些警告信号：
- en: Conditionally checking arguments
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 条件检查参数
- en: A good way to know if a precondition is more restrictive is to see if there
    are any `if` statements at the beginning of the function checking the arguments
    being passed in. If there are, there’s a good chance they are different from the
    base class’s checks, typically meaning that the derived class is restricting the
    arguments further.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 确定前置条件是否更为严格的一个好方法是查看函数开始处是否有任何检查传入参数的`if`语句。如果有，那么它们很可能与基类的检查不同，通常意味着派生类正在进一步限制参数。
- en: Early return statements
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 早期返回语句
- en: If a subtype’s function returns early (in the middle of the function block),
    this indicates that the latter part of the function is not going to execute. Check
    that latter part for any postcondition guarantees; you don’t want to omit those
    by returning early.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子类型的函数在中间返回（在函数块的中部），这表示后续部分不会执行。检查后续部分是否有任何后置条件保证；您不希望通过早期返回而省略它们。
- en: Throwing an exception
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出异常
- en: Subtypes should only throw exceptions that match what the supertype throws (either
    exactly or a derived exception type). If any exceptions are different, callers
    are not going to expect them, let alone write code to catch them. It’s even worse
    if you throw an exception when the base class doesn’t indicate any possibility
    of an exception at all. The most flagrant violation of this that I’ve seen is
    throwing `NotImplementedError` exceptions (or similar).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 子类型应该只抛出与超类型完全匹配或派生异常类型的异常。如果有任何不同的异常，调用者将不会预期它们，更不用说写代码来捕获它们。如果在基类根本不指示可能发生异常的情况下抛出异常，则情况更糟。我见过的最严重的违反是抛出`NotImplementedError`异常（或类似异常）。
- en: Not calling `super()`
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 没有调用`super()`
- en: By definition of substitutability, the subtype must offer the same behavior
    as the supertype. If you aren’t calling `super()` as part of your subtype’s overridden
    functions, your subtype has no defined relationship to that behavior in code.
    Even if you were to copy-paste the supertype’s code into your subtype, there’s
    no guarantee that these will stay synchronized; a developer could make an innocuous
    change to the supertype’s function and not even realize that there is a subtype
    that needs to change as well.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 根据可替换性的定义，子类型必须提供与超类型相同的行为。如果您的子类型在重写的函数中没有调用`super()`，那么您的子类型与代码中该行为没有定义关系。即使您将超类型的代码复制粘贴到您的子类型中，也不能保证这些代码保持同步；开发者可能对超类型的函数进行无害的更改，甚至没有意识到需要同时更改的子类型。
- en: You need to be extra careful when modeling types with inheritance. Any mistake
    can introduce subtle bugs that could have catastrophic effects. When designing
    with inheritance, tread with utmost caution.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在建模具有继承性的类型时，您需要格外小心。任何错误都可能引入微妙的错误，可能会产生灾难性的影响。在设计继承时，务必格外谨慎。
- en: Discussion Topic
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论主题
- en: Have you encountered any of the red flags in your codebase? Has it led to surprising
    behavior when inheriting from other classes? Discuss why these break assumptions
    and what errors can happen in those cases.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否在代码库中遇到过任何红旗？在从其他类继承时，是否导致意外行为？讨论为何这些打破了假设，并在这些情况下可能发生的错误。
- en: Design Considerations
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计考虑
- en: 'Take precautions whenever you are writing classes intended to be derived from.
    Your goal is to make it as easy as possible for other developers to write derived
    classes. Here are a few guidelines for writing base classes (I’ll cover guidelines
    for derived classes afterward):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每当编写打算派生的类时，请采取预防措施。您的目标是尽可能地使其他开发者编写派生类变得容易。以下是编写基类的几条指导原则（稍后我将讨论派生类的指导原则）。
- en: Don’t change invariants
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 不要更改不变量
- en: Normally, changing invariants is a bad idea in the first place. Countless pieces
    of code can depend on your types, and changing an invariant will break assumptions
    made on your code. Unfortunately, derived classes can break if a base class changes
    invariants as well. If you have to change your base class, try to only add new
    functionality, not modify existing functionality.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，改变不变量本身就是一个不好的想法。无数的代码片段可能依赖于您的类型，改变不变量将打破对您代码的假设。不幸的是，如果基类更改了不变量，派生类也可能会受到影响。如果必须更改基类，请尽量仅添加新功能，而不是修改现有功能。
- en: Be cautious tying invariants to protected fields
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当将不变量与受保护字段绑定时需要特别小心。
- en: Protected fields are inherently meant to be interacted with by derived classes.
    If you tie invariants to these fields, you are fundamentally restricting what
    operations should be invoked. This creates a tension that other developers may
    not be aware of. It’s better to keep invariants to private data and force derived
    classes to interact with public or protected methods in order to interact with
    that private data.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护字段本质上是供派生类交互的。如果将不变量与这些字段绑定，您基本上在限制应调用哪些操作。这会造成其他开发者可能意识不到的紧张局势。最好将不变量保留在私有数据中，并强制派生类通过公共或受保护的方法与该私有数据进行交互。
- en: Document your invariants
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 记录您的不变量
- en: This is the number one most important thing you can do to help your other developers.
    While some invariants are representable in code (as you saw in [Chapter 10](part0014_split_000.html#classes)),
    there are simply some invariants that cannot be mathematically proven by a computer,
    such as guarantees around exceptions being thrown or not. You must document these
    invariants when you design your base class, and make it easy for derived classes
    to discover them, such as in a docstring.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是帮助其他开发者的最重要的事情之一。虽然有些不变量可以在代码中表示（如[第10章](part0014_split_000.html#classes)所示），但有些不变量无法通过计算机进行数学证明，比如关于异常是否抛出的保证。在设计基类时，您必须记录这些不变量，并且要确保派生类可以轻松发现它们，比如在文档字符串中。
- en: 'Ultimately, it is the derived class’s responsibility to adhere to the base
    class’s invariants. If you are writing a derived class, heed the following guidelines:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，派生类有责任遵守基类的不变量。如果您正在编写一个派生类，请遵循以下准则：
- en: Know the base class invariants
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉基类的不变量
- en: You can’t write a derived class properly without knowing the invariants. It
    is your job to understand all the base class’s invariants in order to preserve
    them. Look through code, documentation, and anything else related to the class
    to understand what you should and should not be doing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 没有了解不变性，就不能正确地编写派生类。你的工作是了解所有基类的不变性以保持它们。查看代码、文档和与类相关的所有内容，以了解你应该做什么和不应该做什么。
- en: Extend functionality in the base class
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展基类中的功能
- en: If you need to write code that doesn’t jive with your current invariants, you
    may want to put that functionality in the base class instead. Take the example
    of not supporting an overridable method. Rather than throw a `NotImplementedError`,
    you could create a Boolean flag indicating functionality support in the base class
    instead. If you do this, take note of all the guidelines earlier in this chapter
    for modifying the base class.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要编写与当前不变性不一致的代码，你可能需要将该功能放在基类中。举个例子，不支持可重写方法的情况。你可以在基类中创建一个布尔标志，指示基类中是否支持该功能，而不是抛出`NotImplementedError`。如果这样做，注意本章前面所有修改基类的准则。
- en: Every overridden method should contain `super()`
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每个重写的方法应该包含`super()`
- en: If you don’t call `super()` in an overridden method, you have no guarantee that
    your subclass is behaving exactly like the base class, especially if the base
    class changes at all in the future. If you are going to override a method, make
    sure you call `super()`. The only time you can get away with this is when the
    base method is empty (such as an abstract base class) and you are sure it will
    remain empty for the remainder of the codebase’s life cycle.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在重写的方法中不调用`super()`，那么你不能保证你的子类行为与基类完全一致，特别是如果将来基类发生任何变化。如果你要重写一个方法，请确保调用`super()`。唯一可以不这样做的时候是基类方法是空的（比如一个抽象基类），并且你确信它会在代码库的余生中保持空白。
- en: Composition
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合
- en: It’s also important to know when not to use inheritance. One of the biggest
    mistakes I’ve seen is using inheritance solely for the purpose of code reuse.
    Don’t get me wrong, inheritance is a great way to reuse code, but the primary
    reason for inheritance is modeling a relationship where subtypes are used in place
    of the supertype. If you never interact with the subtype in the code that assumes
    the supertype, you aren’t modeling an *is-a* relationship.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 了解何时不使用继承也很重要。我见过的最大错误之一是仅仅为了代码复用而使用继承。不要误会，继承是重用代码的好方法，但继承的主要目的是建模一个子类型可以替代超类型的关系。如果你在代码中从不与子类型交互，那么你并没有建模一个
    *is-a* 关系。
- en: 'In such cases, you want to use composition, also known as a *has-a* relationship.
    *Composition* is when you put member variables inside a type. I have primarily
    used composition to group types together. For instance, the restaurant from earlier:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你希望使用组合，也被称为 *has-a* 关系。*组合* 是将成员变量放在类型内部的情况。我主要使用组合来组合类型在一起。例如，之前提到的餐馆：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Discussion Topic
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论主题
- en: Where in your codebase have you overused inheritance? Are you using it anywhere
    as a conduit for reuse only? Discuss how to transform this to use composition
    instead.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码库中，你是否过度使用了继承？你是否仅仅因为重用而使用它？讨论如何转换为使用组合而不是继承。
- en: Each of the member fields set in the constructor is an example of composition.
    It doesn’t make sense for a `Restaurant` to be substitutable for a `Menu` (*is-a*
    relationship), but it does make sense for a restaurant to be composed of a menu
    (*has-a* relationship), among other things. You should prefer composition to inheritance
    anytime you need to reuse code but aren’t going to substitute types for one another.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数中设置的每个成员字段都是组合的一个示例。一个`Restaurant`可以替代一个`Menu`（*is-a* 关系）是没有意义的，但一个餐馆包含一个菜单（*has-a*
    关系）是有意义的，以及其他一些东西。每当你需要重用代码但不会替代类型时，你应该更倾向于使用组合而不是继承。
- en: Composition is preferable to inheritance as a reuse mechanism because it is
    a weaker form of *coupling*, which is another term for dependencies between entities.
    All other things being equal, you want weaker forms of coupling, as it makes it
    easier to reorganize classes and refactor functionality. If classes have high
    coupling between them, changes in one more directly affect the behavior of the
    other.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种重用机制，组合优于继承，因为它是一种更弱的 *耦合* 形式，耦合是实体之间的依赖关系的另一个术语。其他一切相等时，你希望有更弱的耦合形式，因为这样更容易重新组织类和重构功能。如果类之间的耦合度高，其中一个的变化会直接影响另一个的行为。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Mixins are the exception to preferring composition over inheritance, as they
    are classes explicitly meant to be inherited to provide additions to a type’s
    interface.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Mixins 是一个例外，不推荐组合优于继承，因为它们是专门设计为被继承以提供对类型接口的补充。
- en: 'With inheritance, a derived class is beholden to the base class’s changes.
    A developer must be cognizant of not only the public interface changing, but also
    changes to invariants and protected members. By contrast, when another class has
    an instance of your class, that class is only affected by a subset of changes:
    those impacting the public methods and invariants it depends on. By limiting the
    impact of changes, you lessen the chance of broken assumptions, decreasing fragility.
    To write robust code, use inheritance judiciously.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在继承中，派生类受制于基类的更改。开发人员必须注意不仅公共接口的变化，还有不变量和受保护成员的变化。相比之下，当另一个类拥有你的类的实例时，该类仅受到一部分变化的影响：那些影响其依赖的公共方法和不变量的变化。通过限制变化的影响，你减少了破坏性假设的机会，降低了代码的脆弱性。要编写健壮的代码，请谨慎使用继承。
- en: Closing Thoughts
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结思考
- en: Subtyped relationships are a very powerful concept in programming. You can use
    them to extend existing functionality without modifying it. However, inheritance
    is often overused, or used improperly. Subtypes should only be used if they are
    directly substitutable for their supertype. If this isn’t the case, reach for
    composition instead.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 子类型化关系在编程中是一个非常强大的概念。你可以利用它们扩展现有功能而不修改它。然而，继承往往被滥用或者使用不当。只有当子类型能够直接替代其超类型时才应使用子类型。如果情况不是这样，请考虑使用组合。
- en: Special care should be taken when introducing supertypes or subtypes. It may
    not be easy for developers to know of all the subtypes associated with a single
    supertype; some subtypes may even live in other codebases. Supertypes and subtypes
    are very closely coupled, so be cautious whenever you make changes. With the proper
    diligence, you can reap all the benefits of subtyping without introducing a slew
    of headaches.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 引入超类型或子类型时需要特别小心。开发人员可能不容易知道与单个超类型相关联的所有子类型；有些子类型甚至可能存在于其他代码库中。超类型和子类型非常紧密地耦合在一起，因此在进行任何更改时都要谨慎。通过适当的勤勉性，你可以在不引入一大堆问题的情况下享受子类型化带来的所有好处。
- en: 'In the next chapter, I’m going to focus on a specific application of subtyping
    known as protocols. These are the missing link between the typechecker and duck
    typing. Protocols bridge the gap in an important way: they help your typechecker
    catch some of the errors introduced in a supertype/subtype relationship. Any time
    you catch more errors, especially through a typechecker, you are contributing
    to the robustness of your codebase.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将专注于子类型化的一个特定应用，即协议。这些协议是类型检查器和鸭子类型之间的缺失连接。协议以重要的方式弥合了这一差距：它们帮助你的类型检查器捕捉到在超类型/子类型关系中引入的一些错误。任何时候你通过类型检查器捕获更多的错误，尤其是这些错误，都有助于代码库的稳健性。
- en: ^([1](part0016_split_000.html#idm45644737734424-marker)) Object-oriented programming
    is a programming paradigm where you organize your code around encapsulated data
    and their behaviors. If you’d like an introduction to OOP, I suggest [*Head First
    Object-Oriented Analysis and Design*](https://oreil.ly/6djy9) by Brett McLaughlin,
    Gary Pollice, and Dave West (O’Reilly).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](part0016_split_000.html#idm45644737734424-marker)) 面向对象编程是一种编程范式，它围绕封装的数据及其行为组织代码。如果你想了解面向对象编程，我建议阅读
    [*Head First Object-Oriented Analysis and Design*](https://oreil.ly/6djy9)，作者是布雷特·麦克劳林、加里·波利斯和戴夫·韦斯特（O'Reilly）。
- en: ^([2](part0016_split_002.html#idm45644736586104-marker)) Barbara H. Liskov and
    Jeannette M. Wing. “A Behavioral Notion of Subtyping.” *ACM Trans. Program. Lang.
    Syst.* 16, 6 (Nov. 1994), 1811–41\. [*https://doi.org/10.1145/197320.197383*](https://doi.org/10.1145/197320.197383).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](part0016_split_002.html#idm45644736586104-marker)) Barbara H. Liskov 和
    Jeannette M. Wing。《子类型化的行为概念》。*ACM Trans. Program. Lang. Syst.* 16, 6（1994年11月），1811–41\.
    [*https://doi.org/10.1145/197320.197383*](https://doi.org/10.1145/197320.197383)。
