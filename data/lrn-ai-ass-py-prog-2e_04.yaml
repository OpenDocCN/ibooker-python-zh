- en: '5 Reading Python code: Part 2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 阅读 Python 代码：第二部分
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章内容
- en: Repeating code the required number of times using loops
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用循环按需要的次数重复代码
- en: Using indentation to tell Python which code goes together
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缩进来告诉 Python 哪些代码属于同一组
- en: Building dictionaries to store pairs of associated values
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建字典以存储关联的值对
- en: Setting up files to read and process data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置文件以读取和处理数据
- en: Using modules to work in new domains
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块在新领域中工作
- en: 'In chapter 4, we explored five Python features that you’re going to see all
    the time as you continue in your programming journey: functions, variables, conditionals
    (`if` statements), strings, and lists. You need to know those features to read
    code, and we explained why being able to read code is important whether or not
    we’re using Copilot.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 4 章中，我们探讨了五个 Python 特性，这些特性会在你继续编程时经常遇到：函数、变量、条件语句（`if` 语句）、字符串和列表。你需要了解这些特性才能阅读代码，我们也解释了无论是否使用
    Copilot，能读懂代码都是非常重要的。
- en: We’ll continue in this chapter with five more Python features, which will round
    out our top 10\. As in chapter 4, we’ll do this through a combination of our own
    explanations, explanations from Copilot, and experimenting at the Python prompt.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续介绍另外五个 Python 特性，完成我们的前 10 大特性。如同第 4 章一样，我们将通过结合自己的解释、Copilot 的解释以及在
    Python 提示符下的实验来进行讲解。
- en: '5.1 Top 10 programming features you need to know: Part 2'
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 你需要了解的 10 大编程特性：第二部分
- en: 'This section details the next five of the top 10 programming features you need
    to know. Let’s continue where we left off in the previous chapter with feature
    number 6: loops.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本节详细介绍了你需要了解的 10 大编程特性中的下五个。让我们从上一章的第 6 个特性：循环开始继续讲解。
- en: '5.1.1 #6\. Loops'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '5.1.1 #6\. 循环'
- en: 'A loop allows the computer to repeat the same block of code as many times as
    needed. If a single one of our top 10 programming features exemplifies why computers
    are so useful for helping us get work done, it’s this one. Without the ability
    to loop, our programs would generally execute in order, line by line. Sure, they
    could still call functions and use `if` statements to make decisions, but the
    amount of work a program does would be proportional to the amount of code we write.
    Not so with loops: a single loop can process thousands or millions of values with
    ease.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 循环使计算机能够根据需要重复执行相同的代码块。如果我们需要的 10 大编程特性中有一个能够展示计算机为何如此有用，它就是这个特性。没有循环功能，我们的程序通常会按顺序逐行执行。当然，它们仍然可以调用函数并使用
    `if` 语句做出决策，但程序的工作量将与我们编写的代码量成正比。循环不同：一个简单的循环就能轻松处理数千或数百万个值。
- en: 'There are two types of loops: `for` loops and `while` loops. Generally speaking,
    we use a `for` loop whenever we know how many times we need the loop to run, and
    we use a `while` loop when we don’t. For example, in chapter 3, our `best_word`
    function (reproduced as listing 5.1) used a `for` loop because we know how many
    times we want the loop to run: once for each word in `word_list`! But in `get_strong_password`,
    which we’ll see again in listing 5.4, we used a `while` loop, because we have
    no idea how many bad passwords the user is going to type before they type a strong
    one. We’ll start with `for` loops and then move on to `while` loops.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 循环有两种类型：`for` 循环和 `while` 循环。一般来说，当我们知道循环需要执行多少次时，我们使用 `for` 循环；而当我们不知道时，我们使用
    `while` 循环。例如，在第 3 章中，我们的 `best_word` 函数（在列表 5.1 中重现）使用了 `for` 循环，因为我们知道需要循环多少次：即对
    `word_list` 中的每个单词执行一次！但在 `get_strong_password` 函数中，我们使用了 `while` 循环，因为我们无法预知用户输入多少次不安全密码后才会输入一个强密码。我们将从
    `for` 循环开始，然后再介绍 `while` 循环。
- en: Listing 5.1 `best_word` function from chapter 3
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.1 第 3 章中的 `best_word` 函数
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**#1 This is an example of a for loop.**  **A `for` loop allows us to access
    each value in a string or list. Let’s try it with a string first:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**#1 这是一个 for 循环的示例。** **`for` 循环允许我们访问字符串或列表中的每个值。我们首先用字符串来试试：**'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '#1 This repeats the indented code one time for each character of string s.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这段代码会对字符串 s 中的每个字符执行一次缩进代码。'
- en: '#2 Because “vacation” has eight letters, this code will run eight times.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 因为“vacation”有八个字母，所以这段代码将运行八次。'
- en: Notice that we don’t need an assignment statement for `char`. That’s because
    it’s a special variable called a loop variable that’s automatically managed by
    the `for` loop. `char` stands for character, and it’s an extremely popular name
    that people use for the loop variable. The `char` variable automatically gets
    assigned each character of the string. When talking about a loop, we often use
    the word *iteration* to refer to the code that executes each time through the
    loop. Here, for example, we would say that on the first iteration,`char` refers
    to `v`; on the second iteration, it refers to `a`; and so on. Notice also, just
    like for functions and `if` statements, we have indentation for the code that
    makes up the loop. We have only one line of code in the body of this loop, but
    just like for functions and `if` statements, we could have more.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们不需要为`char`赋值语句。那是因为它是一个特殊的变量，叫做循环变量，它由`for`循环自动管理。`char`代表字符，它是人们常用的循环变量的名字。`char`变量会自动赋值为字符串的每个字符。谈到循环时，我们常用*迭代*一词来指代每次通过循环时执行的代码。这里，比如我们可以说在第一次迭代时，`char`代表`v`；在第二次迭代时，`char`代表`a`；依此类推。还要注意，就像函数和`if`语句一样，循环内部的代码也有缩进。虽然这里循环体内只有一行代码，但就像函数和`if`语句一样，我们可以有更多的代码行。
- en: Let’s see an example of a `for` loop on a list this time (listing 5.2), demonstrating
    that we can process each value of a list like we process each value of a string.
    We’ll also throw two lines of code into the loop instead of just one, to demonstrate
    how that works too.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下这个`for`循环在列表上的示例（列表5.2），展示我们如何像处理字符串的每个值一样处理列表中的每个值。我们还会在循环中添加两行代码，而不仅仅是一个，以展示它是如何工作的。
- en: Listing 5.2 Example using a `for` loop
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.2 使用`for`循环的示例
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**#1 1st is a list, so this is a for loop on a list.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**#1 第一个是列表，所以这是一个在列表上的`for`循环。'
- en: '#2 This code runs on each iteration.**  **The code in listing 5.2 is just one
    way to loop through a list. The approach of `for` `animal` `in` `lst` assigns
    the variable `animal` to the next value in the list each time through the loop.
    Alternatively, you could use an index to access each element of the list. To do
    that, we need to learn about the built-in `range` function.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 这段代码在每次迭代时执行。**列表5.2中的代码只是通过列表循环的其中一种方式。`for` `animal` `in` `lst` 的写法会在每次循环时将变量`animal`赋值为列表中的下一个值。或者，你也可以使用索引来访问列表中的每个元素。要做到这一点，我们需要了解内置的`range`函数。'
- en: 'The `range` function gives you numbers within a range. We can provide a starting
    number and an ending number, and it will produce the range that goes from the
    starting number up to, but not including, the ending number. To see the numbers
    that `range` produces, we need to put the `list` function around it. Here’s an
    example of using `range`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`range`函数会给你一个范围内的数字。我们可以提供一个起始数字和一个结束数字，它会生成从起始数字到结束数字之间的范围，但不包括结束数字。为了查看`range`生成的数字，我们需要将`list`函数放在它周围。以下是使用`range`的示例：'
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '#1 Produces the range from 3 to 8 (not 3 to 9!)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 生成从3到8的范围（不是从3到9！）'
- en: Notice that it starts with the value `3` and includes all values between `3`
    and `8`. That is, it includes all numbers from the starting value `3` up to, but
    not including, the ending value `9`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，它从`3`开始，包含了从`3`到`8`之间的所有值。也就是说，它包含了从起始值`3`到结束值`9`之间的所有数字，但不包括结束值`9`。
- en: 'Now, how is `range` going to help us write a loop? Well, rather than hard-coding
    numbers like 3 and 9 in the range, we can include the length of a string or list,
    like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`range`如何帮助我们写循环呢？好吧，和直接在范围中硬编码数字像3和9不同，我们可以包括一个字符串或列表的长度，像这样：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '#1 Start at 0 and go up to, but not including, the length of 1st.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 从0开始，直到（但不包括）第一个列表的长度。'
- en: Notice that the range values here are 0, 1, 2, 3, which are the valid indices
    of our `lst` list! We can therefore use `range` to control a `for` loop, and that
    will give us access to each valid index from the string or list.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里的范围值是0、1、2、3，它们是我们`lst`列表的有效索引！因此，我们可以使用`range`来控制`for`循环，这样就可以访问字符串或列表中的每个有效索引。
- en: We can use `range` to perform the same task in listing 5.2\. See listing 5.3
    for the new code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`range`来执行列表5.2中的相同任务。请参阅列表5.3中的新代码。
- en: Listing 5.3 Loop example using for `loop` and `range`
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.3 使用`for`循环和`range`的循环示例
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**#1 for loop using the range function'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**#1 使用`range`函数的`for`循环'
- en: '#2 Indexing into the list using the index variable**  **We’ve used a variable
    named `index` here, but you’ll also often see people use just `i` for simplicity.
    That variable will be given the value `0` for the first iteration of the loop,
    `1` for the second, `2` for the third, and `3` for the last iteration. It stops
    at `3` because the length of the list is 4, and `range` stops one before that.
    Using indexing into the list, the code grabs the first element, then the second,
    then the third, and then the fourth, using the increasing indices. We could have
    also written the `for` loop without the `0`; `range` will assume we want the values
    between `0` and the value provided, like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 使用索引变量对列表进行索引**  **我们这里使用了一个名为`index`的变量，但你也常常会看到人们为了简便起见使用`i`。该变量在第一次迭代时赋值为`0`，在第二次迭代时为`1`，在第三次迭代时为`2`，最后一次迭代时为`3`。它在`3`时停止，因为列表的长度是4，而`range`在这个值之前停止。通过对列表进行索引，代码依次获取第一个元素、第二个元素、第三个元素，然后是第四个元素，使用递增的索引值。我们也可以不使用`0`来编写`for`循环；`range`将假设我们想要`0`和给定值之间的值，如下所示：'
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '#1 With one argument, range assumes that we want to start at 0.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 使用一个参数时，`range`假设我们想从0开始。'
- en: 'We’ll stop here with `for` loops. But we’re not done with loops yet because
    there’s another type of loop that we need to talk about: the `while` loop.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里结束关于`for`循环的讨论。但我们还没有结束循环的部分，因为有另一种类型的循环我们需要讨论：`while`循环。
- en: We use a `while` loop when we don’t know how many times to loop. A nice example
    of this situation is in our `get_strong_password` function from chapter 3\. We’ve
    reproduced that code here as listing 5.4.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`while`循环当我们不知道循环要执行多少次时。一个典型的例子就是在我们第3章的`get_strong_password`函数中。我们在这里重现了那段代码，见列表5.4。
- en: Listing 5.4 `get_strong_password` function from chapter 3
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.4 第3章的`get_strong_password`函数
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '#1 Keeps looping while the password isn’t strong'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 当密码不强时持续循环'
- en: 'We have no idea how many passwords the user is going to type until they type
    a strong one. Will it be on the 1st try, 2nd try, or 50th try? Who knows. That’s
    why we need a `while` loop: it ensures that the user is asked again and again
    until they provide a strong password.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不知道用户要输入多少次密码，直到他们输入一个强密码。可能是第一次尝试，第二次尝试，还是第50次尝试？谁知道呢。这就是我们需要使用`while`循环的原因：它确保用户不断被询问，直到他们提供一个强密码。
- en: To write a `while` loop, we follow `while` with a Boolean condition. If it’s
    `True`, Python runs one iteration of the loop. If, after that iteration, that
    Boolean condition is still `True`, then it runs another iteration. It keeps doing
    that until the condition is `False`, at which point the loop terminates.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写`while`循环，我们需要在`while`后面跟一个布尔条件。如果条件为`True`，Python将执行一次循环迭代。如果该布尔条件在迭代后仍然为`True`，那么它会执行下一次迭代。它会一直这样做，直到条件为`False`，此时循环结束。
- en: Now, we have enough information to make sense of the code for our `get_strong_`
    `password` function. By looking at the code, we can see that it begins by using
    the `input` function to ask the user for a password. Then, there’s a `while` loop.
    This loop continues as long as the password isn’t a strong password. The Boolean
    condition `not` `is_strong_password(password)` is equivalent to writing it as
    `is_strong_password` `(password)` `==` `False`. To avoid an infinite loop and
    to ask the user to try again, we have another use of `input` inside of the loop.
    We need the call of `input` above the loop to get the first try from the user.
    Without that, the `password` variable wouldn’t exist, and the `while` loop line
    would give an error because it wouldn’t have a `password` value to pass to the
    `is_strong_password` function.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经有足够的信息来理解我们的`get_strong_` `password`函数的代码。通过查看代码，我们可以看到它首先使用`input`函数请求用户输入密码。然后，接下来是一个`while`循环。这个循环会一直执行，直到密码是一个强密码。布尔条件`not`
    `is_strong_password(password)`等价于写成`is_strong_password` `(password)` `==` `False`。为了避免无限循环并提示用户再次尝试，我们在循环内又使用了一次`input`。我们需要在循环之前调用`input`来获取用户的第一次尝试。如果没有那样做，`password`变量将不存在，`while`循环那一行将会报错，因为它没有`password`值可以传递给`is_strong_password`函数。
- en: 'Don’t forget that we can ask Copilot for an explanation of this code, using
    what we learned in chapter 4, section 4.2\. This is useful whenever you’re feeling
    that you aren’t quite understanding what the code is doing or how it works. Here’s
    the explanation we received from Copilot:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了，我们可以使用在第4章第4.2节学到的内容，请Copilot解释这段代码。这在你感觉自己不太理解代码的作用或如何工作时非常有用。以下是我们从Copilot得到的解释：
- en: This Python code defines a function named `get_strong_password`. The purpose
    of this function is to interactively prompt the user to enter a password and keep
    asking until the user provides a password that is considered strong. The criteria
    for what constitutes a strong password is not defined in this function but is
    determined by another function named `is_strong_password`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这段Python代码定义了一个名为`get_strong_password`的函数。该函数的目的是与用户互动，提示用户输入密码，并持续询问直到用户提供一个被认为是强密码的密码。强密码的标准在此函数中没有定义，而是由另一个名为`is_strong_password`的函数来确定。
- en: The function begins by asking the user to enter a password using Python’s built-in
    `input` function. The entered password is then stored in the variable `password`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数首先通过Python内置的`input`函数请求用户输入密码。输入的密码随后存储在`password`变量中。
- en: Next, the function enters a `while` loop. The condition for this loop is `not`
    `is_strong_` `password(password)`. This means that the loop will continue to execute
    as long as the `is_strong_password` function returns `False` when called with
    the current password. In other words, the loop will keep running until the user
    enters a password that is considered strong.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，函数进入一个`while`循环。该循环的条件是`not is_strong_password(password)`。这意味着只要`is_strong_password`函数在调用当前密码时返回`False`，循环就会继续执行。换句话说，循环将一直运行，直到用户输入一个被认为是强密码的密码。
- en: Inside the loop, the function again prompts the user to enter a password. The
    new password replaces the previous one stored in the `password` variable. If this
    new password is still not strong, the loop will continue to prompt the user.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，函数再次提示用户输入密码。新的密码会替换之前存储在`password`变量中的密码。如果新的密码仍然不强，循环将继续提示用户。
- en: Once the user enters a password that is considered strong (i.e., `is_strong_password`
    `(password)` returns `True`), the `while` loop condition becomes `False` and the
    loop ends. The function then returns the strong password entered by the user.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户输入了一个被认为是强密码的密码（即`is_strong_password(password)`返回`True`），`while`循环条件变为`False`，循环结束。函数随后返回用户输入的强密码。
- en: This function is a good example of using a `while` loop to repeatedly prompt
    the user for input until the input meets certain criteria. However, the actual
    criteria for a strong password are not defined in this function and would need
    to be implemented in the `is_strong_password` function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是使用`while`循环反复提示用户输入，直到输入符合某些标准的一个很好的示例。然而，强密码的实际标准并未在此函数中定义，需要在`is_strong_password`函数中实现。
- en: This explanation is a very good description of the function and matches the
    description that we just gave! It contains useful general Python information as
    well, including a reminder in the final paragraph of why exactly we’re using a
    `while` loop. The explanation also mentions that we need the `is_strong_password`
    function to tell us whether a password is strong or not; we didn’t highlight that
    function, which is why Copilot is telling us that we need to implement it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解释很好地描述了该函数，并且与我们刚才提供的描述相符！它还包含了一些有用的Python常识，包括最后一段关于我们为何使用`while`循环的提醒。解释中还提到我们需要`is_strong_password`函数来判断密码是否强大；我们并未特别强调这个函数，这就是为什么Copilot提示我们需要实现它。
- en: Copilot explanations can be wrong
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Copilot的解释可能是错误的
- en: We chose the previous Copilot explanation because it was the best answer from
    Copilot after we asked it to explain the code three times. One of the answers
    it gave us sounded quite plausible, until it started talking about functions that
    didn’t exist. We believe the explanations can be helpful as a learning aid if
    you run it multiple times and look for common ideas, but a principal goal of this
    chapter is to give you the tools you need to understand when it makes mistakes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择了前一个Copilot的解释，因为它是在我们要求Copilot解释代码三次后得到的最佳答案。它给出的其中一个答案听起来相当合理，直到开始提到一些不存在的函数。我们认为这些解释可以作为学习的辅助工具，如果你多次运行并寻找共同的思路，它们是有帮助的，但本章的主要目标是给你提供理解它犯错时的工具。
- en: We encourage you to use Copilot explanations going forward and, if you’re interested,
    ask Copilot to explain any code from prior chapters that you’re still curious
    about. Again, these explanations can be wrong, so you should ask Copilot for several
    explanations to limit your reliance on a single erroneous explanation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励你以后使用Copilot的解释，并且如果你有兴趣，可以让Copilot解释任何你仍然好奇的之前章节中的代码。同样，这些解释可能是错误的，因此你应该向Copilot请求多个解释，以避免只依赖一个可能有误的解释。
- en: As with anything related to AI coding assistants right now, they’re going to
    mess up. But we’ve given the explanation here because we see this Copilot feature
    as a potentially powerful teaching resource now and that will become even more
    true as Copilot improves.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如目前与AI编程助手相关的一切一样，它们会犯错。但我们在这里给出解释，因为我们认为这个Copilot功能现在是一个潜在的强大教学资源，随着Copilot的不断改进，这一功能将变得更加有用。
- en: We’re supposed to use a `while` loop in these kinds of situations where we don’t
    know how many iterations there will be. But we *can* use a`while` loop even when
    we know how many iterations there are. For example, we can use a `while` loop
    to process the characters in a string or the values in a list. We sometimes see
    Copilot do this in the code that it generates, even though a `for` loop would
    have been a better choice. For example, we can use a `while` loop to process the
    animals in our earlier `animals` list, as in the following listing. It’s more
    work, though!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们应该使用`while`循环，因为我们不知道迭代次数。但即使我们知道迭代次数，*仍然*可以使用`while`循环。例如，我们可以使用`while`循环处理字符串中的字符或列表中的值。我们有时会看到Copilot在生成的代码中这样做，尽管使用`for`循环会是更好的选择。例如，我们可以使用`while`循环处理我们之前的`animals`列表中的动物，如以下列表所示。不过，这需要更多的工作！
- en: Listing 5.5 Loop example using a `while` loop
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.5 使用`while`循环的示例
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '#1 len tells us the length of the string and is the number of iterations we
    want.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 `len`告诉我们字符串的长度，也就是我们想要的迭代次数。'
- en: '#2 It’s a common human error to leave this out!'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 这是常见的人为错误，容易遗漏！'
- en: Without the `index` `+=` `1`, we would never increase the index through the
    string, and we’d print out the information for the first value over and over.
    That’s called an *infinite loop*. If you think back to how we wrote `for` loops,
    you’ll find that we didn’t have to manually increase any index variables. For
    such reasons, many programmers prefer to use `for` loops when they can. We don’t
    have to manually keep track of any index in a `for` loop, so we automatically
    avoid certain kinds of indexing problems and infinite loops.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有`index` `+=` `1`，我们将无法在字符串中增加索引，打印出的信息将一直是第一个值。这被称为*无限循环*。如果回想一下我们写的`for`循环，你会发现我们并不需要手动增加任何索引变量。出于这种原因，许多程序员在可以使用时更倾向于使用`for`循环。我们不需要在`for`循环中手动追踪任何索引，因此自动避免了某些索引问题和无限循环。
- en: '5.1.2 #7\. Indentation'
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '5.1.2 #7\. 缩进'
- en: 'Indentation is critical in Python code, because Python uses it to determine
    which lines of code go together. That’s why, for example, we always indent all
    the lines of code inside a function, the various portions of an `if` statement,
    and the code for a `for` or `while` loop. It’s not just nice formatting: if we
    get the indentation wrong, then we get the code wrong. For example, let’s say
    that we want to ask the user for the current hour and then output some text based
    on whether it’s morning, afternoon, or evening:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进在Python代码中至关重要，因为Python通过它来确定哪些代码行是一起执行的。例如，我们总是缩进函数内部的所有代码行，`if`语句的各个部分，以及`for`或`while`循环的代码。这不仅仅是格式问题：如果我们缩进错误，代码就会出错。例如，假设我们想询问用户当前的小时数，然后根据早晨、下午或晚上的时间输出一些文本：
- en: If it’s morning, we want to output “Good morning!” and “Have a nice day.”
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是早晨，我们想输出“Good morning!”和“Have a nice day.”
- en: If it’s afternoon, we want to output “Good afternoon!”
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是下午，我们想输出“Good afternoon!”
- en: If it’s evening, we want to output “Good evening!” and “Have a good night.”
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是晚上，我们想输出“Good evening!”和“Have a good night.”
- en: 'Take a look at the following code we’ve written and try to spot the problem
    with the indentation:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下我们编写的以下代码，尝试找出缩进的问题：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '#1 This line is not indented.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这一行没有缩进。'
- en: 'The problem is the last line: it’s not indented, but it should be! Because
    it’s not indented, we’ll output `Have` `a` `good` `night.` regardless of which
    hour the user types in. We need to indent it so that it’s part of the `else` portion
    of the `if` statement, ensuring that it only executes when it’s evening.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出在最后一行：它没有缩进，但应该有！由于没有缩进，无论用户输入什么小时，我们都会输出`Have` `a` `good` `night.`。我们需要缩进它，使其成为`if`语句的`else`部分，确保它只有在晚上时才会执行。
- en: Whenever we write code, we need to use multiple levels of indentation to express
    which pieces of code are associated with functions, `if` statements, loops, and
    so on. For example, when we write a function header, we need to indent all the
    code associated with that function below the function header. Some languages use
    brackets (e.g., {}) to show this, but Python just indents. If you’re already in
    the body of a function (one indent) and write a loop, then you’ll have to indent
    again (two indents) for the body of the loop, and so forth.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们编写代码时，我们需要使用多个缩进级别来表示哪些代码块与函数、`if` 语句、循环等相关联。例如，当我们写一个函数头时，我们需要缩进所有与该函数相关的代码。如果你已经处于函数体内（一层缩进），并且写了一个循环，那么你就需要再缩进一次（二层缩进）来表示循环体，依此类推。
- en: Looking back at our functions from chapter 3, we can see this in action. For
    example, in our `larger` function (reprinted as listing 5.6), the whole body of
    the function is indented, but there’s further indentation on the `if` portion
    and the `else` portion of the `if` statement.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们第 3 章的函数，可以看到这一点的应用。例如，在我们的 `larger` 函数中（作为列表 5.6 复印），整个函数体都有缩进，但 `if` 部分和
    `else` 部分的 `if` 语句有进一步的缩进。
- en: Listing 5.6 Function to determine the larger of two values
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.6 用于确定两个值较大的函数
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '#1 This shows a single indent for the body of the function.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这里展示了函数主体的单个缩进。'
- en: '#2 This shows a double indent for the body of the function and the body of
    the if statement.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 这里展示了函数体和 `if` 语句体的双重缩进。'
- en: '#3 This shows a single indent for the body of the function.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 这里展示了函数主体的单个缩进。'
- en: '#4 This shows a double indent for the body of the function and the body of
    the else statement.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 这里展示了函数体和 `else` 语句体的双重缩进。'
- en: 'Next, consider our `get_strong_password` function that we looked at in listing
    5.4 earlier: as usual, everything in the function is indented, but there’s further
    indentation for the body of the `while` loop.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，考虑我们之前在列表 5.4 中看到的 `get_strong_password` 函数：像往常一样，函数中的所有内容都有缩进，但 `while`
    循环的主体部分有进一步的缩进。
- en: There are even more levels of indentation in the first version of our `num_points`
    function (reproduced here from chapter 3 as listing 5.7). That’s because, inside
    of the `for` loop through each character of the word, we have an `if` statement.
    Each piece of the `if` statement, as we’ve learned, needs to be indented, leading
    to the extra level of indentation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `num_points` 函数的第一个版本（从第 3 章作为列表 5.7 复现）有更多的缩进层次。这是因为，在对单词的每个字符进行 `for`
    循环时，我们有一个 `if` 语句。正如我们所学，每个 `if` 语句的部分都需要缩进，这导致了额外的缩进层次。
- en: Listing 5.7 `num_points` function
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.7 `num_points` 函数
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '#1 This is indented to be inside the function.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这里进行了缩进，以便在函数内部。'
- en: '#2 This is indented again to be inside the for loop.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 这里再次进行了缩进，以便在 `for` 循环内部。'
- en: '#3 This is indented yet again to be inside the if statement.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 这里再次进行了缩进，以便在 if 语句内部。'
- en: There’s additional indentation in `is_strong_password` too (reproduced from
    chapter 3 as listing 5.8), but that’s only to spread out one super-long line of
    code across multiple lines. Notice that the lines end with `\`, which is the character
    that allows us to continue a line of code on the next line.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_strong_password` 中也有额外的缩进（从第 3 章作为列表 5.8 复现），但那只是为了将一行超长代码分布到多行中。注意，这些行的末尾有
    `\`，这是允许我们将一行代码延续到下一行的字符。'
- en: Listing 5.8 `is_strong_password` function
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.8 `is_strong_password` 函数
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '#1 The line ends with a backslash to continue the statement.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 该行以反斜杠结束，以继续语句。'
- en: '#2 The indent isn’t required but is useful for visually laying out the single
    return statement.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 这个缩进不是必须的，但对视觉上布局单个返回语句很有帮助。'
- en: Similarly, there’s some further indentation in our second version of `num_points`
    (reproduced from chapter 3 as listing 5.9), but that’s just to spread the dictionary
    out over multiple lines to make it more readable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们的 `num_points` 第二版本（从第 3 章作为列表 5.9 复现）也有进一步的缩进，但那只是为了将字典分布到多行中，以提高可读性。
- en: Listing 5.9 `num_points` alternative solution
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.9 `num_points` 替代解决方案
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '#1 We’re allowed to write a dictionary value over multiple lines.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们可以将字典值写成多行。'
- en: '#2 The indent isn’t required but is useful for visually laying out the dictionary.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 这个缩进不是必须的，但对视觉上布局字典很有帮助。'
- en: 'Indentation makes a huge difference on what our programs ultimately do. For
    example, let’s compare putting two consecutive loops versus nesting one in the
    other using indentation. Here are two loops in a row:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进对我们程序的最终行为有巨大影响。例如，让我们比较将两个循环放在一起与使用缩进将一个循环嵌套在另一个循环中的效果。以下是两个并列的循环：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '#1 This is the first loop.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这是第一个循环。'
- en: '#2 This is the second loop (happens after the first loop).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 这是第二个循环（发生在第一个循环之后）。'
- en: 'That caused us to get the same output twice because we looped two separate
    times through the countries list. Now, if instead we nest the loops, this happens:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致我们输出相同的结果两次，因为我们在国家列表中分别循环了两次。现在，如果我们将这两个循环嵌套在一起，就会出现以下情况：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '#1 This is the first loop.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这是第一个循环。'
- en: '#2 This is the nested loop inside of the first loop.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 这是嵌套在第一个循环中的第二个循环。'
- en: '#3 print is nested in the second loop, which is nested in the first loop.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 打印语句嵌套在第二个循环中，该循环又嵌套在第一个循环中。'
- en: We’ve used different variable names, `country1` and `country2`, for each `for`
    loop, so that we can refer to both. On the first iteration of the `country1` loop,
    `country1` refers to `Canada`. On the first iteration of the `country2` loop,
    `country2` refers to `Canada` as well. That’s why the first line of output is
    `Canada` `Canada`. Did you expect the next line of output after that to be `USA`
    `USA`? That isn’t what happens! Instead, the `country2` loop moves on to its next
    iteration, but the `country1` loop doesn’t move yet. The `country1` loop only
    moves ahead when the `country2` loop is complete. That’s why we get `Canada` `USA`
    and `Canada` `Japan` before the `country1` loop finally moves on to its second
    iteration. When one loop is inside of another loop, this is called *nested loops.*
    In general, when there’s nesting, the inner loop (`for` `country2` `in` `countries`)
    will complete all of its steps before the outer loop (`for` `country1` `in` `countries`)
    moves on to its next step, which, in turn, will restart the inner loop.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个 `for` 循环使用了不同的变量名，`country1` 和 `country2`，以便我们可以同时引用它们。在 `country1` 循环的第一次迭代中，`country1`
    引用的是 `加拿大`。在 `country2` 循环的第一次迭代中，`country2` 同样引用的是 `加拿大`。这就是为什么输出的第一行是 `加拿大`
    `加拿大`。你是否期望接下来的输出行是 `美国` `美国`？但实际情况并非如此！相反，`country2` 循环会进入它的下一次迭代，但 `country1`
    循环仍然没有前进。`country1` 循环只有在 `country2` 循环完成时才会向前移动。这就是为什么我们会先看到 `加拿大` `美国` 和 `加拿大`
    `日本`，然后 `country1` 循环才会进入它的第二次迭代。当一个循环嵌套在另一个循环内部时，这叫做 *嵌套循环*。一般来说，当有嵌套时，内层循环（`for
    country2 in countries`）会完成它的所有步骤，外层循环（`for country1 in countries`）才会继续进行下一步，这又会重新启动内层循环。
- en: If you see a loop nested inside another loop, chances are good that the loops
    are being used to process two-dimensional data. Two-dimensional data is organized
    into rows and columns, of the kind you might see in a table (e.g., table 5.1).
    This kind of data is really common in computing because it includes basic spreadsheet
    data such as CSV files, images such as photos or a single frame of video, or the
    computer screen.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到一个循环嵌套在另一个循环中，很有可能这两个循环是用来处理二维数据的。二维数据是按行和列组织的，就像你在表格中看到的那样（例如，表 5.1）。这种数据在计算机中非常常见，因为它包括基本的电子表格数据，如
    CSV 文件、图片（例如照片或视频的一帧）、或者计算机屏幕的数据。
- en: In Python, we can store two-dimensional data using a list where the values themselves
    are other lists. Each sublist in the overall list is one row of data, and each
    row has a value for each column. For example, say we had some data about the figure
    skating medals won at the 2018 Winter Olympics, as shown in table 5.1.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们可以使用列表来存储二维数据，其中的值本身也是其他列表。整体列表中的每个子列表代表一行数据，每一行都有每一列的值。例如，假设我们有一些关于
    2018 年冬奥会花样滑冰奖牌的数据，如表 5.1 所示。
- en: Table 5.1 Medals in the 2018 Winter Olympics
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 5.1 2018 年冬奥会奖牌
- en: '| Nation | Gold | Silver | Bronze |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 国家 | 金牌 | 银牌 | 铜牌 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Canada  | 2  | 0  | 2  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 加拿大  | 2  | 0  | 2  |'
- en: '| OAR  | 1  | 2  | 0  |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| OAR  | 1  | 2  | 0  |'
- en: '| Japan  | 1  | 1  | 0  |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 日本  | 1  | 1  | 0  |'
- en: '| China  | 0  | 1  | 0  |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 中国  | 0  | 1  | 0  |'
- en: '| Germany  | 1  | 0  | 0  |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 德国  | 1  | 0  | 0  |'
- en: 'We could store this as a list, with one country per row:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其存储为一个列表，每个国家占一行：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Notice that our list of lists is just storing the numeric values, and we can
    find a value in the list of lists by referring to its row and column (e.g., Japan’s
    gold medal corresponds to the row at index 2 and the column at index 0). We can
    use an index to get a complete row of data:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的列表列表仅存储了数值，并且我们可以通过引用其行和列来在列表列表中查找一个值（例如，日本的金牌对应的是索引 2 行和索引 0 列）。我们可以使用索引获取一整行数据：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '****#1 This is row 0 (first row).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '****#1 这是第 0 行（第一行）。'
- en: '#2 This is row 1 (second row).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 这是第 1 行（第二行）。'
- en: '#3 This is the last row.****  ****If we do a `for` loop on this list, we get
    each complete row, one row at a time:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 这是最后一行。****  ****如果我们对这个列表进行`for`循环，我们将一次获得每一整行：'
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '#1 The for loop gives us one value of the list at a time (i.e., one sublist
    at a time).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 `for`循环一次给我们一个列表的值（即一次一个子列表）。'
- en: 'If we want just a specific value from the medals list (not a whole row), we
    have to index twice:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想从奖牌列表中获取特定的值（而不是整行），我们需要索引两次：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '#1 This is row 0, column 0.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这是第 0 行，第 0 列。'
- en: '#2 This is row 0, column 1.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 这是第 0 行，第 1 列。'
- en: '#3 This is row 1, column 0.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 这是第 1 行，第 0 列。'
- en: Suppose we want to loop through each value individually. To do that, we can
    use nested `for` loops. To help us keep track of exactly where we are, we’ll use
    `range` `for` loops so that we can print out the current row and column numbers
    in addition to the value stored there.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要逐个遍历每个值。为此，我们可以使用嵌套的`for`循环。为了帮助我们准确跟踪当前位置，我们将使用`range` `for`循环，这样我们就可以打印出当前的行和列号，以及存储在其中的值。
- en: The outer loop will go through the rows, so we need to control it using `range`
    `(len(medals))`. The inner loop will go through the columns. How many columns
    are there? Well, the number of columns is the number of values in one of the rows,
    so we can use `range(len(medals[0]))` to control this loop.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 外部循环将遍历行，因此我们需要使用`range` `(len(medals))`来控制它。内部循环将遍历列。有多少列呢？列数就是某一行中的值的数量，因此我们可以使用`range(len(medals[0]))`来控制这个循环。
- en: 'Each line of output will provide three numbers: the row coordinate, the column
    coordinate, and the value (number of medals) at that row and column. Here’s the
    code and output:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行输出将提供三个数字：行坐标、列坐标以及该行列中的值（奖牌数）。以下是代码和输出：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '#1 Loops through the rows'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 遍历行'
- en: '#2 Loops through the columns for the current row'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 循环当前行的列'
- en: Notice how the row stays constant for the first three lines of output, during
    which the column varies from 0 to 2\. That’s how we work our way through the first
    row. Only then does the row increase to 1, at which point we complete the work
    for columns 0 to 2 on this new row.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在输出的前三行中，行保持不变，而列从 0 变化到 2。我们就是这样遍历第一行的。只有当行号增加到 1 时，我们才会开始处理第二行，并完成对该行的列
    0 到 2 的工作。
- en: Nested loops give us a systematic way to loop through each value in a two-dimensional
    list. You’ll see them frequently when dealing with two-dimensional data in general,
    such as images, board games, and spreadsheets.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套循环为我们提供了一种系统化的方式来遍历二维列表中的每个值。当处理二维数据时，您将经常遇到它们，例如图像、棋盘游戏和电子表格。
- en: '5.1.3 #8\. Dictionaries'
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '5.1.3 #8\. 字典'
- en: Remember that each value in Python has a specific type. There are a lot of different
    types because there are many kinds of values that we might want to use! We’ve
    talked about using numbers to work with numeric values, Booleans to work with
    `True`/`False` values, strings to work with text, and lists to work with a sequence
    of other values such as numbers or strings.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在 Python 中，每个值都有一个特定的类型。因为我们可能会使用许多不同种类的值，所以类型非常多！我们已经讨论过使用数字来处理数值，布尔值来处理`True`/`False`值，字符串来处理文本，以及列表来处理其他值的序列，例如数字或字符串。
- en: 'There’s one more Python type that shows up often, and it’s called a *dictionary.*
    When we talk about a dictionary in Python, we don’t mean a list of words and their
    definitions. In Python, a dictionary is a useful way of storing data whenever
    you need to keep track of associations between data. For example, imagine that
    you wanted to know which words are used most often in your favorite book. You
    could use a dictionary to map each word to the number of times it’s used. That
    dictionary would probably be huge, but a small version of such a dictionary might
    look like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个在 Python 中经常出现的类型，它叫做*字典*。当我们在 Python 中谈论字典时，我们并不是指单词及其定义的列表。在 Python 中，字典是一种非常有用的存储数据的方式，尤其是当你需要跟踪数据之间的关联时。例如，假设你想知道在你最喜欢的书中哪些单词使用得最多。你可以使用字典将每个单词映射到它使用的次数。这个字典可能非常庞大，但一个小版本的字典可能是这样的：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Each entry in the dictionary maps a word to its frequency. For example, we can
    tell from this dictionary that the word *DNA* shows up 11 times and that the word
    *Taxxon* shows up 13 times. The words here (*DNA*, *acquire*, *Taxxon*, etc.)
    are referred to as *keys,* and the frequencies (11, 11, 13, etc.) are referred
    to as *values**.* So, a dictionary maps each key to its value. We’re not allowed
    to have duplicate keys, but as shown here with the two `11` values, having duplicate
    values is no problem.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 字典中的每个条目都将一个单词映射到它的频率。例如，我们可以从这个字典中得知，单词 *DNA* 出现了 11 次，单词 *Taxxon* 出现了 13 次。这里的单词（*DNA*、*acquire*、*Taxxon*
    等）被称为 *键*，而频率（11、11、13 等）被称为 *值*。因此，字典将每个键映射到它的值。我们不允许有重复的键，但正如这里显示的那样，具有重复值并不成问题。
- en: We saw a dictionary in chapter 2 (listing 2.1) that stored each quarterback’s
    name and their associated number of passing yards. In chapter 3, we saw a dictionary
    again in our second solution for `num_points` (reproduced earlier in listing 5.9).
    There, the dictionary mapped each letter to the number of points awarded for using
    that letter.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章（列出 2.1）我们看到一个字典，存储了每个四分卫的名字和他们的传球码数。在第三章，我们再次在第二个解决方案中看到了一个字典，用来表示 `num_points`（在
    5.9 列表中复现）。在那里，字典将每个字母映射到使用该字母时获得的点数。
- en: 'Just like for strings and lists, dictionaries have methods that you can use
    to interact with them. Here are some methods operating on our `freq` dictionary:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 就像字符串和列表一样，字典也有方法可以让你与它们进行交互。以下是一些操作我们的`freq`字典的方法：
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**#1 Gets all the keys'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**#1 获取所有键'
- en: '#2 Gets all the values'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**#2 获取所有值'
- en: '#3 Gets rid of key and associated value**  **You can also use the index notation
    to access the value for a given key:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**#3 删除键及其关联值**  **你还可以使用索引符号来访问给定键的值：'
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '#1 Gets values associated with the key “DNA”'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**#1 获取与键 “DNA” 关联的值'
- en: 'Dictionaries, like lists, are mutable. This means that we can change the keys
    and values in a dictionary, which is useful for modeling data that changes over
    time. We can use indexing to change a value. The value associated with `''morph''`
    is currently `41`. Let’s change it to `6`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 字典像列表一样是可变的。这意味着我们可以更改字典中的键和值，这对于建模随时间变化的数据非常有用。我们可以使用索引来更改一个值。当前与 `'morph'`
    关联的值是 `41`，我们将其改为 `6`：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '#1 Changes value associated with key “morph” to 6'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**#1 将与键 “morph” 关联的值改为 6'
- en: 'Our `freq` dictionary allows us to start from whatever word we want and find
    its frequency. More generally, a dictionary allows us to go from *key to value.*
    However, it doesn’t allow us to easily go in the opposite direction, from value
    to key. If we wanted to do that, we’d need to produce the opposite dictionary—for
    example, one whose keys are frequencies and whose values are lists of words with
    those frequencies. That would enable us to answer questions such as the following:
    which words have a frequency of exactly 5? Which words have the minimum or maximum
    frequency of all?'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `freq` 字典允许我们从任何想要的单词开始，并找到它的频率。更一般地说，字典允许我们从 *键到值*。然而，它并不容易让我们从值到键反向查找。如果我们想做到这一点，我们需要生成一个反向字典——例如，键是频率，值是具有这些频率的单词列表。这样我们就能回答以下问题：哪些单词的频率恰好是
    5？哪些单词的频率是所有单词中最小或最大的？
- en: 'As with strings and lists, we can use a loop to process the information in
    a dictionary as well. A `for` loop gives us the dictionary keys, and we can use
    indexing to get the associated value for each key:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 就像字符串和列表一样，我们也可以使用循环来处理字典中的信息。`for` 循环为我们提供字典的键，我们可以使用索引来获取每个键的关联值：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*#1 Loops through each key in the freq dictionary'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*#1 遍历 freq 字典中的每个键'
- en: '#2 Uses the key (word) and associated value (freq[word])*  *### 5.1.4 #9\.
    Files'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**#2 使用键（单词）及其关联值（freq[word]）**  *### 5.1.4 #9\. 文件'
- en: It’s often the case that we’ll want to work with datasets that exist in files.
    For example, in chapter 2, we worked with a file of NFL stats to determine the
    most effective quarterbacks. Using files is common for other data science tasks
    as well. For example, if you’re plotting information about earthquakes around
    the world or determining whether two books are written by the same author, you’ll
    need to work with those datasets, and typically those datasets will be stored
    in files.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常需要处理存在于文件中的数据集。例如，在第二章，我们使用了 NFL 统计数据文件来确定最有效的四分卫。使用文件是其他数据科学任务中常见的做法。例如，如果你正在绘制世界各地的地震信息或确定两本书是否由同一位作者写作，你也需要处理这些数据集，而这些数据集通常会存储在文件中。
- en: In chapter 2, we worked with a file called nfl_offensive_stats.csv. Make sure
    that this file is in your current program directory because we’ll use that file
    now to further understand some of the code we used in chapter 2.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章，我们处理了一个名为nfl_offensive_stats.csv的文件。确保该文件位于当前程序目录中，因为我们将用它来进一步理解我们在第二章中使用的一些代码。
- en: 'The first step in working with data from a file is to use Python’s `open` function
    to open the file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 处理文件数据的第一步是使用Python的`open`函数打开文件：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You’ll sometimes see Copilot add an `r` as a second argument here:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你会看到Copilot在这里添加`r`作为第二个参数：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: But we don’t need the `r`; the `r` just means that we want to read from the
    file, but that’s the default anyway if we don’t specify it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不需要`r`；`r`只是表示我们想从文件中读取数据，但如果不指定，默认就是读取模式。
- en: 'We’ve used an assignment statement to assign that open file to a variable named
    `nfl_file`. Now, we can use `nfl_file` to access the contents of the file. An
    open file is a Python type, just like numbers and strings and all of the other
    types you’ve seen to this point. As such, there are methods that we can call to
    interact with the file. One method is `readline`, which gives us the next line
    of the file as a string. We’ll use it now to get the first line of our open file,
    but don’t worry about the line itself because it’s super long with tons of information
    about columns we won’t end up using:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用赋值语句将打开的文件分配给名为`nfl_file`的变量。现在，我们可以使用`nfl_file`来访问文件的内容。一个打开的文件是Python中的一种类型，就像数字、字符串以及你迄今为止看到的所有其他类型一样。因此，我们可以调用方法与文件进行交互。一个方法是`readline`，它返回文件的下一行作为字符串。我们现在就使用它来获取我们打开文件的第一行，但不用担心这一行，因为它很长，包含了很多关于我们最终不会使用的列的信息：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '#1 Reads the line from the file'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 从文件中读取一行'
- en: 'It’s not easy to pull individual values out of a messy string like that. So,
    one of the first things we tend to do with such a line is split it up into its
    individual column data. We can do that using the string `split` method. That method
    takes a separator as an argument and splits the string into a list by using that
    separator:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从这样的混乱字符串中提取单个值并不容易。因此，我们通常会先将这行数据拆分为各个列数据。我们可以使用字符串的`split`方法来做到这一点。该方法以分隔符作为参数，并使用该分隔符将字符串拆分成一个列表：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '#1 Splits the string using a comma (,) as a separator'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 使用逗号（,）作为分隔符来拆分字符串'
- en: 'Now we can look at individual column names:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以查看各个列名：
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '#1 The space at the end of the word is in the original dataset, but no other
    column headers have a space.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这个词末尾的空格在原始数据集中存在，但其他列标题没有空格。'
- en: 'That first line of the file that we’re looking at isn’t a real data line—it’s
    just the header that tells us the name of each column. The next time we do `readline`,
    we get the first real line of data:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的文件中的第一行并不是真正的数据行——它只是告诉我们每列名称的标题。下次我们调用`readline`时，将获得第一行真正的数据：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Moving one line at a time like this is fine for exploring what’s in a file,
    but eventually, we’ll probably want to process the whole thing. To do so, we can
    use a `for` loop on the file. It’ll give us back one line on each iteration, which
    we can process in any way we like. Once we’re finished with a file, we should
    call `close` on it:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样逐行读取文件对于探索文件内容是没问题的，但最终我们可能希望处理整个文件。为此，我们可以对文件使用`for`循环。每次迭代它都会返回一行，我们可以按需要处理这行数据。一旦我们处理完文件，就应该调用`close`来关闭它：
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: After closing, we aren’t allowed to use the file anymore. Now that we’ve discussed
    how to read, process, and close a file, let’s see a full example. In listing 5.10,
    we provide a new version of our program from chapter 2 that sorts quarterbacks
    by their total passing yards. In addition to showcasing files, we’re also using
    many of the Python features that we’ve seen in chapter 4 and the current chapter,
    including conditionals, strings, lists, loops, and dictionaries.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭后，我们将无法再使用该文件。现在我们已经讨论了如何读取、处理和关闭文件，让我们来看一个完整的例子。在列表5.10中，我们提供了来自第二章的新版本程序，该程序按四分卫的总传球码数对其进行排序。除了展示文件外，我们还使用了在第四章和本章中看到的许多Python特性，包括条件语句、字符串、列表、循环和字典。
- en: Listing 5.10 Alternative NFL statistics code without the csv module
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.10没有csv模块的替代NFL统计代码
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '#1 This dictionary maps quarterback names to their passing yards.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这个字典将四分卫的名字映射到他们的传球码数。'
- en: '#2 Loops through each line of the file'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 遍历文件的每一行'
- en: '#3 Focuses only on the quarterbacks'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 只关注四分卫'
- en: '#4 Quarterback is already in our dictionary.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 四分卫已经在我们的字典中了。'
- en: '#5 Add to quarterback’s total; int converts string like ''203'' to integer.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '#5 累加四分卫的总数；`int` 将像 ''203'' 这样的字符串转换为整数。'
- en: '#6 Quarterback isn’t yet in our dictionary.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '#6 四分卫尚未出现在我们的字典中。'
- en: '#7 Sets initial quarterback’s total'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '#7 设置四分卫的初始总数'
- en: '#8 Loops through quarterbacks from highest to lowest passing yards'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '#8 从最高到最低的传球码数遍历四分卫'
- en: 'That loop at the bottom, `for` `player` `in` `sorted(passing_yards,` `key=passing_yards
    .get,` `reverse=True):`, has a lot going on. We explained this line in the annotations
    as looping through the quarterbacks from highest to lowest. The `reverse=True`
    makes us sort from highest to lowest rather than the default of lowest to highest.
    The `key=passing_yards.get` focuses the sort on the number of passing yards (rather
    than, e.g., the player’s names). If you’d like to break down this line of code
    further, feel free to ask Copilot for further explanation. This highlights the
    balancing act that we’re trying to maintain here: to know enough to be able to
    get the gist of code without necessarily needing to understand every nuance.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后面的那一行 `for player in sorted(passing_yards, key=passing_yards.get, reverse=True):`
    涉及了很多内容。我们在注释中解释了这行代码是从最高到最低遍历四分卫。`reverse=True` 让我们按从高到低排序，而不是默认的从低到高排序。`key=passing_yards.get`
    使排序的重点放在传球码数上（而不是，比如，球员的名字）。如果你想进一步解析这行代码，随时可以向 Copilot 请求更多解释。这突出了我们在这里要保持的平衡：了解足够的内容，能够把握代码的大意，而不一定需要理解每个细节。
- en: This program works just fine; if you run it, you would see the same output as
    if you ran the code from chapter 2\. Sometimes, though, it’s possible to write
    a program more easily using modules (we cover modules in more depth in the next
    section), and that’s what the program from chapter 2 did. Because CSV files are
    so common, Python comes with a module to make it easier to process them. In chapter
    2, the solution that we were given used the csv module. So, let’s discuss the
    main differences between our code in listing 5.10 that doesn’t use the module
    and our code from chapter 2, reprinted here in the following listing (our prompts
    given to Copilot aren’t shown).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序运行得很好；如果你运行它，你会看到和运行第 2 章代码时相同的输出。不过，有时候，使用模块编写程序会更简单（我们将在下一节深入讲解模块），这正是第
    2 章中的程序所做的。由于 CSV 文件非常常见，Python 提供了一个模块来简化对它们的处理。在第 2 章中，我们得到的解决方案使用了 csv 模块。所以，让我们讨论一下我们在列表
    5.10 中未使用模块的代码和第 2 章代码之间的主要区别，下面的列表将再次展示第 2 章代码（我们提供给 Copilot 的提示未显示）。
- en: Listing 5.11 NFL statistics code using the csv module
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.11 使用 csv 模块的 NFL 统计代码
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '#1 Shows the alternate syntax for opening a file'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 显示打开文件的另一种语法'
- en: '#2 Uses a special csv module; reads all data from the file'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 使用特殊的 csv 模块；从文件中读取所有数据'
- en: '#3 Loops through each line of data'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 遍历每一行数据'
- en: First, listing 5.11 uses the csv module to make dealing with CSV files easier.
    The csv module knows how to manipulate CSV files, so, for example, we don’t have
    to worry about breaking a line into its columns. Second, listing 5.11 uses the
    `with` keyword, which results in the file automatically being closed when the
    program is done with it. Third, listing 5.11 reads the entire file first before
    doing any processing. By contrast, in listing 5.10, we read and process each line
    as soon as we read it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，列表 5.11 使用 csv 模块来简化处理 CSV 文件的过程。csv 模块知道如何操作 CSV 文件，因此，例如，我们不需要担心将一行数据拆分成各列。其次，列表
    5.11 使用了 `with` 关键字，这样文件在程序完成后会自动关闭。第三，列表 5.11 在进行任何处理之前会先读取整个文件。相比之下，在列表 5.10
    中，我们在读取每一行时会立即对其进行处理。
- en: More than one way to solve a programming problem
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决编程问题有多种方法
- en: There are always many different programs that can be written to solve the same
    task. Some may be easier to read than others. The most important criterion for
    code is that it does the correct thing. After that, we care most about readability
    and efficiency. So, if you find yourself struggling to understand how some code
    works, it may be worth some time looking at other code from Copilot in case there’s
    a simpler or more understandable solution available there.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有多种不同的程序可以用来解决同一个任务。有些程序可能比其他程序更容易阅读。代码最重要的标准是它是否能正确完成任务。之后，我们最关心的是可读性和效率。因此，如果你发现自己难以理解某些代码的工作原理，可能值得花些时间看看
    Copilot 的其他代码，看看是否有更简单或更易懂的解决方案。
- en: Files are used commonly in computing tasks because they are a common source
    of data to be processed. This includes CSV files like the one from this section,
    log files that keep track of events on computers or websites, and files that store
    data for graphics you might see in video games, among others. Because files are
    so commonly used, it’s no surprise there are many modules that help us read various
    file formats. That leads us to the larger topic of modules.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 文件在计算任务中广泛使用，因为它们是常见的数据来源，包括本节中的 CSV 文件、记录计算机或网站事件的日志文件，以及存储视频游戏中可能看到的图形数据的文件等等。由于文件的使用如此普遍，毫不奇怪有很多模块可以帮助我们读取各种文件格式。这引出了我们要讨论的更大话题：模块。
- en: '5.1.5 #10\. Modules'
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '5.1.5 #10\. 模块'
- en: People use Python to make all kinds of things—games, websites, and apps for
    analyzing data, automating repetitive tasks, controlling robots, you name it.
    You might be wondering how Python can possibly let you create so many different
    types of programs. Surely, the creators of Python couldn’t have anticipated or
    created all the needed support!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 人们使用 Python 来做各种各样的事情——游戏、网站、数据分析应用程序、自动化重复任务、控制机器人等等。你可能会好奇，Python 如何让你创建这么多不同类型的程序。肯定的，Python
    的创建者不可能预见到所有需要的支持，或者为此编写所有代码！
- en: The truth is that, by default, your Python program has access only to some core
    Python features (such as those we’ve showed you in the previous and current chapter).
    To get any more than that, we need to use modules. And, to use a module, you need
    to import it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 事实是，默认情况下，您的 Python 程序仅能访问一些核心的 Python 功能（比如我们在上一章和本章中展示的那些功能）。要获得更多功能，我们需要使用模块。而且，要使用模块，您需要先导入它。
- en: Modules in Python
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Python 中的模块
- en: 'A *module* is a collection of code designed for a specific purpose. Recall
    that we don’t need to know how a function works to use it. It’s the same with
    modules: we don’t need to know how modules work to be able to use them, much as
    we don’t need to know how a light switch works internally to use it. As users
    of modules, we just need to know what a module will help us do and how to write
    the code to correctly call its functions. Of course, Copilot can help us write
    that kind of code.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*模块*是为特定目的设计的代码集合。回想一下，我们在使用函数时并不需要了解它是如何工作的。模块也是如此：我们不需要了解模块是如何工作的，就能使用它，就像我们不需要了解电灯开关是如何内部工作的就能使用它一样。作为模块的使用者，我们只需要知道模块能帮助我们做什么，以及如何编写正确的代码来调用它的函数。当然，Copilot
    可以帮助我们编写这种代码。
- en: Some modules come with Python when you install it, but we still need to import
    them. Other modules we first have to install before we can import them. Trust
    us, if there’s a specific kind of task you want to do with Python, someone’s probably
    already written a module to help you out.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一些模块在安装 Python 时会随 Python 一起提供，但我们仍然需要导入它们。其他模块则需要我们先安装，才能导入它们。相信我们，如果你有某种特定的任务要用
    Python 完成，可能已经有人写过一个模块来帮你了。
- en: You might be wondering how to determine which Python modules you should use.
    How do you know which ones exist? A simple chat with Copilot or Google search
    is often helpful. For example, if we google “Python module to create a zip file,”
    the first result tells us that the module we need is part of the Python standard
    library, which means that it comes with Python. If we google “Python module for
    visualization,” we learn about modules named matplotlib, plotly, seaborn, and
    more. Searching for each of these should lead you to galleries of visualizations
    showing you their capabilities and what each is typically used for. Most modules
    are free to download and use, although your search results can help you confirm
    whether a module is free and its specific usage license. We’re going to hold off
    on installing and using newly installed modules until chapter 9, but, at that
    time, you’ll see this process of finding, installing, and using relevant modules
    to help us complete our tasks.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道如何判断应该使用哪些 Python 模块。如何知道有哪些模块？与 Copilot 聊天或进行 Google 搜索通常能帮助你。例如，如果我们在
    Google 上搜索“Python 模块来创建 zip 文件”，第一个结果告诉我们，我们需要的模块是 Python 标准库的一部分，这意味着它随 Python
    一起提供。如果我们搜索“Python 可视化模块”，我们会了解到像 matplotlib、plotly、seaborn 等模块。搜索这些模块的结果应该会带你看到一些展示它们能力的可视化内容，以及它们通常用于哪些场景。大多数模块都是免费的，尽管你的搜索结果可以帮助你确认模块是否免费以及其具体的使用许可证。我们会在第
    9 章时再开始安装和使用新安装的模块，但到那时，你会看到如何查找、安装并使用相关模块来帮助我们完成任务。
- en: Table 5.2 has a list of some of the commonly used Python modules and whether
    they are built-in or not. If a module is built-in, you can import the module and
    start using it right away; if not, you need to install it first.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.2列出了常用的Python模块，以及它们是否是内置模块。如果一个模块是内置的，你可以直接导入并开始使用；如果不是，你需要先安装它。
- en: Table 5.2 Summary of commonly used Python modules
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表5.2 常用Python模块的总结
- en: '| Module | Built-In | Description |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 模块 | 内置 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| csv  | Yes  | Aids in the reading, writing, and analysis of CSV files  |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| csv  | 是  | 帮助读取、写入和分析CSV文件  |'
- en: '| zipfile  | Yes  | Aids in the creation and extraction of compressed zip archive
    files  |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| zipfile  | 是  | 帮助创建和提取压缩的.zip归档文件  |'
- en: '| matplotlib  | No  | Graphics library for plotting that serves as the basis
    of other graphics libraries and can offer high levels of customization  |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| matplotlib  | 否  | 用于绘图的图形库，是其他图形库的基础，并提供高度定制化功能  |'
- en: '| plotly  | No  | A graphics library used for creating interactive plots for
    the web  |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| plotly  | 否  | 一个用于创建交互式网页图表的图形库  |'
- en: '| seaborn  | No  | A graphics library built on top of matplotlib that aids
    in creating high- quality plots more easily than matplotlib  |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| seaborn  | 否  | 基于matplotlib构建的图形库，比matplotlib更容易创建高质量的图表  |'
- en: '| pandas  | No  | A data processing library that specializes in data frames,
    which are analogous to spreadsheets  |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| pandas  | 否  | 一个数据处理库，专注于数据框（类似于电子表格）  |'
- en: '| scikit-learn  | No  | Contains basic tools for machine learning (i.e., helping
    to learn from data and make predictions)  |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| scikit-learn  | 否  | 包含用于机器学习的基本工具（即帮助从数据中学习并做出预测）  |'
- en: '| numpy  | No  | Offers highly efficient data processing  |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| numpy  | 否  | 提供高效的数据处理功能  |'
- en: '| pygame  | No  | A game programming library that helps to build interactive,
    graphical games in Python  |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| pygame  | 否  | 一个游戏编程库，帮助在Python中构建交互式图形游戏  |'
- en: '| django  | No  | Web development library that aids in designing websites and
    web applications  |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| django  | 否  | 一个帮助设计网站和网页应用程序的Web开发库  |'
- en: In chapter 2, our code used the csv module that comes with Python. Let’s continue
    here by learning about a different module that comes with Python.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，我们的代码使用了Python自带的csv模块。让我们继续学习一个Python自带的不同模块。
- en: When people want to organize their files, perhaps prior to backing them up or
    uploading them, they often archive them first into a .zip file. Then they can
    pass around that single .zip file, rather than potentially hundreds or thousands
    of individual files. Python comes with a module called zipfile that can help you
    create a .zip file.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们想要整理他们的文件，可能是在备份或上传之前，他们通常会先将它们打包成.zip文件。然后他们可以传送那个单独的.zip文件，而不是可能数百个甚至数千个单独的文件。Python自带一个叫做zipfile的模块，可以帮助你创建.zip文件。
- en: To try this, create a few files in your programming directory, and make them
    all end with .csv. You could start with your nfl_offensive_stats.csv file and
    then add a few more. For example, you could add one called actors.csv with the
    names of a few actors and their ages, such as
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试这个，创建几个文件并将它们的扩展名都设为.csv。你可以从你的nfl_offensive_stats.csv文件开始，然后再添加几个。例如，你可以添加一个名为actors.csv的文件，列出几个演员的名字和他们的年龄，如
- en: '[PRE35]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'and you could add one called chores.csv with a list of chores and whether you’ve
    finished each one:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加一个名为chores.csv的文件，里面列出了一些家务事以及是否完成：
- en: '[PRE36]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The contents don’t matter as long as you have a few .csv files to test with.
    Now we can use the zipfile module to add them all to a new .zip file!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你有几个.csv文件用于测试，内容并不重要。现在我们可以使用zipfile模块将它们全部添加到一个新的.zip文件中！
- en: '[PRE37]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**#1 Creates the new .zip file'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**#1 创建新的.zip文件'
- en: '#2 Adds the first file'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 添加第一个文件'
- en: '#3 Adds the second file'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 添加第二个文件'
- en: '#4 Adds the third file**  **If you run that code, you’ll find a new file called
    my_stuff.zip that contains your three .csv files. Working with .zip files directly
    used to be a very specialized, error-prone task with other earlier programming
    languages, but that’s not so with Python. Python comes with modules that are helpful
    for data science, making games, dealing with various file formats, and so on,
    but again, Python can’t come with everything. When we need more, we turn to downloadable
    modules as we’ll see in chapter 9.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 添加第三个文件**  **如果你运行那个代码，你会发现一个名为my_stuff.zip的新文件，里面包含了你的三个.csv文件。直接处理.zip文件在其他早期编程语言中通常是一个非常专业且容易出错的任务，但在Python中并非如此。Python自带的一些模块对数据科学、游戏开发、处理各种文件格式等方面都很有帮助，但同样，Python并不能包含所有东西。当我们需要更多时，我们会转向可下载的模块，正如我们将在第9章中看到的那样。'
- en: In this chapter, we introduced you to the second half of our top 10 Python features,
    as summarized in table 5.3\. We’ve covered a lot about reading code in the previous
    chapter and this chapter. Although we haven’t covered everything you might see
    Copilot produce, you’re in a good position to spot-check Copilot code to determine
    whether it’s given a good attempt at producing the code you requested. We also
    showed more examples of using the Copilot explanation tool to help you understand
    new code. In the next chapters, we’ll see how to test the code from Copilot to
    determine whether it’s correct, and what you can do when it’s not.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Python 特性排名前 10 的后半部分，概览请见表 5.3。我们在前一章和本章已经讲了很多关于如何阅读代码的内容。虽然我们没有涵盖
    Copilot 可能生成的所有代码，但你现在已经具备了检查 Copilot 代码的能力，能够判断它是否正确生成了你请求的代码。我们还展示了如何使用 Copilot
    解释工具帮助你理解新的代码。在接下来的章节中，我们将学习如何测试 Copilot 生成的代码以确定其正确性，以及在代码不正确时可以做些什么。
- en: Table 5.3 Summary of Python code features from this chapter
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 5.3 本章 Python 代码特性总结
- en: '| Code Element | Example | Brief Description |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 代码元素 | 示例 | 简短描述 |'
- en: '| --- | --- | --- |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Loops  | `for` loop: `for country in countries: print(country)` `while` loop:
    `index = 0 while index < 4: print(index) index = index + 1`  | Loops allow us
    to run the same code as many times as needed. We use a `for` loop when we know
    how many iterations there will be (e.g., number of characters in a string) and
    a `while` loop when we don’t (e.g., asking the user for a strong password).  |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 循环  | `for` 循环：`for country in countries: print(country)` `while` 循环：`index
    = 0 while index < 4: print(index) index = index + 1`  | 循环允许我们根据需要多次运行相同的代码。当我们知道循环次数时（例如字符串中的字符数），使用
    `for` 循环；当我们不知道循环次数时（例如，询问用户输入强密码），使用 `while` 循环。 |'
- en: '| Indentation  | `for country in countries: print(country)`  | Indentation
    tells Python when a piece of code belongs as part of another body of code (e.g.,
    that the `print` call is within the `for` loop).  |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 缩进  | `for country in countries: print(country)`  | 缩进告诉 Python 代码块之间的关系，例如，`print`
    调用属于 `for` 循环的一部分。 |'
- en: '| Dictionaries  | `points = {''a'': 1, ''b'': 3}`  | Dictionaries allow us
    to associate a key with a value. For example, the key `''a''` is associated with
    the value `1`.  |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 字典  | `points = {''a'': 1, ''b'': 3}`  | 字典允许我们将一个键与一个值关联。例如，键 `''a''` 与值
    `1` 关联。 |'
- en: '| Files  | `file = open(''chores.csv'') first_line = file.readline()`  | Files
    contain data and are stored on your computer. Python can be used to open many
    types of files and read their contents, allowing you to process the data in the
    file.  |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 文件  | `file = open(''chores.csv'') first_line = file.readline()`  | 文件包含数据并存储在你的计算机上。Python
    可以用来打开多种类型的文件并读取其内容，允许你处理文件中的数据。 |'
- en: '| Modules  | `import` `csv`  | Modules are already-existing libraries that
    provide additional functionality. Commonly used modules include csv, numpy, matplotlib,
    pandas, and scikit-learn. Some modules come with the standard Python distribution;
    others need to be installed separately.  |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 模块  | `import` `csv`  | 模块是已经存在的库，提供额外的功能。常用的模块包括 csv、numpy、matplotlib、pandas
    和 scikit-learn。一些模块随标准 Python 配发；另一些则需要单独安装。 |'
- en: 5.2 Exercises
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 练习
- en: Recall the `for` loop code we looked at in listing 5.3 to print animals in a
    list. What does this modified code do differently compared to the original example
    in the chapter? Specifically, what additional output does it produce?
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回想一下我们在列表 5.3 中看到的 `for` 循环代码，用来打印列表中的动物。与本章中的原始示例相比，这段修改后的代码有什么不同之处？具体来说，它产生了哪些额外的输出？
- en: '[PRE38]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 2\. Consider the following `while` loop code that seeks to repeat what we did
    using a `for` loop in listing 5.3\. When we run the code, we notice that it runs
    indefinitely. Can you identify and fix the error that would cause it to run indefinitely?
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 考虑以下 `while` 循环代码，试图重复我们在列表 5.3 中使用 `for` 循环做的事情。当我们运行代码时，我们发现它会无限运行。你能找出并修复导致它无限运行的错误吗？
- en: '[PRE39]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 3\. Arrange the following lines of code to create a `while` loop that prints
    each number in the list until it encounters the number 7\. Be careful about indentation!
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 将以下代码行排列成一个 `while` 循环，打印列表中的每个数字，直到遇到数字 7。注意缩进！
- en: '[PRE40]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 4\. Think of a real-world scenario where a `while` loop would be more appropriate
    than a `for` loop. Describe the scenario and explain why a `while` loop is the
    better choice.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4. 想一想，在什么样的现实场景下使用 `while` 循环比 `for` 循环更合适。描述这个场景并解释为什么 `while` 循环是更好的选择。
- en: 5\. Modify the `get_strong_password` function (or the `is_strong_password` function
    that it calls) to provide specific feedback on why the entered password isn’t
    strong enough. For instance, if the password doesn’t have an uppercase character,
    print “Password must include an uppercase character,” and if it doesn’t contain
    a digit, print “Password must contain at least one digit.”
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5\. 修改`get_strong_password`函数（或它调用的`is_strong_password`函数），以提供关于输入密码不够强的具体反馈。例如，如果密码没有大写字母，则打印“密码必须包含大写字母”；如果没有数字，则打印“密码必须至少包含一个数字”。
- en: 6\. Given the following `print_quarterbacks` function, can you rewrite it to
    use the “with” statement to open and close the file? Why is it important to close
    the file?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 6\. 给定以下`print_quarterbacks`函数，你能否重写它，使用“with”语句来打开和关闭文件？为什么关闭文件很重要？
- en: '[PRE41]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '7\. In this exercise, we’ll further practice working with the zipfile module
    to create a .zip file containing multiple CSV files. Follow these steps to complete
    the task and answer the questions:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 7\. 在这个练习中，我们将进一步练习使用zipfile模块来创建一个包含多个CSV文件的.zip文件。按照以下步骤完成任务并回答问题：
- en: 'First, create three CSV files in your current directory:'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在当前目录下创建三个CSV文件：
- en: nfl_offensive_stats.csv (you should already have this file)
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: nfl_offensive_stats.csv（你应该已经有这个文件）
- en: 'actors.csv with the following content:'
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: actors.csv，包含以下内容：
- en: '[PRE42]'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'chores.csv with the following content:'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: chores.csv，包含以下内容：
- en: '[PRE43]'
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Using Copilot (don’t type the code directly as we did in the chapter), write
    a Python script that uses the zipfile module to add these three CSV files to a
    .zip file named my_stuff.zip.
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Copilot（不要像我们在本章中那样直接输入代码），编写一个Python脚本，使用zipfile模块将这三个CSV文件添加到名为my_stuff.zip的.zip文件中。
- en: What are some of the other functions provided by the zipfile module that Copilot
    suggests? How can they be useful?
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Copilot建议的zipfile模块提供了哪些其他功能？它们如何有用？
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: A loop is used to repeat code as many times as needed.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环用于根据需要重复执行代码。
- en: We use a `for` loop when we know how many iterations the loop will do; we use
    a `while` loop when we don’t know how many iterations a loop will do.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们知道循环将执行多少次时，我们使用`for`循环；当我们不知道循环将执行多少次时，我们使用`while`循环。
- en: Python uses indentation to determine which lines of code go together.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python使用缩进来确定哪些代码行是一起执行的。
- en: A dictionary is a mapping from keys (e.g., words in a book) to values (e.g.,
    their frequencies).
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典是从键（例如，书中的单词）到值（例如，它们的频率）的映射。
- en: We need to open a file before we can read from it.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在读取文件之前，我们需要先打开它。
- en: Once a file is open, we can use methods (e.g., readline) or a loop to read its
    lines.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦文件被打开，我们可以使用方法（例如，readline）或循环来读取文件的行。
- en: Some modules, such as csv and zipfile, come with Python and can be used by importing
    them.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些模块，例如csv和zipfile，是Python自带的，可以通过导入它们来使用。
- en: Other modules, such as matplotlib, need to be installed first before they can
    be imported and used.***************
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他模块，如matplotlib，需要先安装，然后才能导入并使用。***************
