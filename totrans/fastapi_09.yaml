- en: Chapter 7\. Framework Comparisons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You don’t need a framework. You need a painting, not a frame.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Klaus Kinski, actor
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Preview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For developers who have used Flask, Django, or popular Python web frameworks,
    this chapter points out FastAPI’s similarities and differences. It does not go
    into every excruciating detail, because, otherwise, the binding glue wouldn’t
    hold this book together. This chapter’s comparisons can be useful if you’re thinking
    of migrating an application from one of these frameworks to FastAPI or are just
    curious.
  prefs: []
  type: TYPE_NORMAL
- en: One of the first things you might like to know about a new web framework is
    how to get started, and a top-down way is by defining *routes* (mappings from
    URLs and HTTP methods to functions). The next section compares how to do this
    with FastAPI and Flask, because they’re more similar to one another than Django
    and are more likely to be considered together for similar applications.
  prefs: []
  type: TYPE_NORMAL
- en: Flask
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Flask](https://flask.palletsprojects.com) calls itself a *microframework*.
    It provides the basics, and you download third-party packages to supplement it
    as needed. It’s smaller than Django, and faster to learn when you’re getting started.'
  prefs: []
  type: TYPE_NORMAL
- en: Flask is synchronous, based on WSGI rather than ASGI. A new project called [quart](https://quart.palletsprojects.com)
    is replicating Flask and adding ASGI support.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start at the top, showing how Flask and FastAPI define web routing.
  prefs: []
  type: TYPE_NORMAL
- en: Path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the top level, Flask and FastAPI both use a decorator to associate a route
    with a web endpoint. In [Example 7-1](#ex-7-1), let’s duplicate [Example 3-11](ch03.html#ex-3-11)
    (from back in [Chapter 3](ch03.html#ch03)), which gets the person to greet from
    the URL path.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-1\. FastAPI path
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: By default, FastAPI converts that `f"Hello? {who}?"` string to JSON and returns
    it to the web client.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 7-2](#ex-7-2) shows how Flask would do it.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-2\. Flask path
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `who` in the decorator is now bounded by `<` and `>`. In Flask,
    the method needs to be included as an argument—unless it’s the default, `GET`.
    So `meth⁠ods=​["GET"]` could have been omitted here, but being explicit never
    hurts.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Flask 2.0 supports the FastAPI-style decorators like `@app.get` instead of `app.route`.
  prefs: []
  type: TYPE_NORMAL
- en: The Flask `jsonify()` function converts its argument to a JSON string and returns
    it, along with the HTTP response header indicating that it’s JSON. If you’re returning
    a `dict` (not other data types), recent versions of Flask will automatically convert
    it to JSON and return it. Calling `jsonify()` explicitly works for all data types,
    including `dict`.
  prefs: []
  type: TYPE_NORMAL
- en: Query Parameter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Example 7-3](#ex-7-3), let’s repeat [Example 3-15](ch03.html#ex-3-15), where
    `who` is passed as a query parameter (after the `?` in the URL).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-3\. FastAPI query parameter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The Flask equivalent is shown in [Example 7-4](#ex-7-4).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-4\. Flask query parameter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In Flask, we need to get request values from the `request` object. In this case,
    `args` is a `dict` containing the query parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Example 7-5](#ex-7-5), let’s copy old [Example 3-21](ch03.html#ex-3-21).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-5\. FastAPI body
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: A Flask version looks like [Example 7-6](#ex-7-6).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-6\. Flask body
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Flask stores JSON input in *request.json*.
  prefs: []
  type: TYPE_NORMAL
- en: Header
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, let’s repeat [Example 3-24](ch03.html#ex-3-24) in [Example 7-7](#ex-7-7).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-7\. FastAPI header
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The Flask version is shown in [Example 7-8](#ex-7-8).
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-8\. Flask header
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As with query parameters, Flask keeps request data in the `request` object.
    This time, it’s the `headers dict` attribute. The header keys are supposed to
    be case-insensitive.
  prefs: []
  type: TYPE_NORMAL
- en: Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Django](https://www.djangoproject.com) is bigger and more complex than Flask
    or FastAPI, targeting “perfectionists with deadlines,” according to its website.
    Its built-in object-relational mapper (ORM) is useful for sites with major database
    backends. It’s more of a monolith than a toolkit. Whether the extra complexity
    and learning curve are justified depends on your application.'
  prefs: []
  type: TYPE_NORMAL
- en: Although Django was a traditional WSGI application, version 3.0 added support
    for ASGI.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Flask and FastAPI, Django likes to define routes (associating URLs with
    web functions, which it calls *view functions*) in a single `URLConf` table, rather
    than using decorators. This makes it easier to see all your routes in one place,
    but makes it harder to see what URL is associated with a function when you’re
    looking at just the function.
  prefs: []
  type: TYPE_NORMAL
- en: Other Web Framework Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous sections comparing the three frameworks, I’ve mainly compared
    how to define routes. A web framework might be expected to help in these other
    areas too:'
  prefs: []
  type: TYPE_NORMAL
- en: Forms
  prefs: []
  type: TYPE_NORMAL
- en: All three packages support standard HTML forms.
  prefs: []
  type: TYPE_NORMAL
- en: Files
  prefs: []
  type: TYPE_NORMAL
- en: All these packages handle file uploads and downloads, including multipart HTTP
    requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs: []
  type: TYPE_NORMAL
- en: A *template language* lets you mix text and code, and is useful for a *content-oriented*
    website (HTML text with dynamically inserted data), rather than an API website.
    The best-known Python template package is [Jinja](https://jinja.palletsprojects.com),
    and it’s supported by Flask, Django, and FastAPI. Django also has its own [template
    language](https://oreil.ly/OIbVJ).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use networking methods beyond basic HTTP, try these:'
  prefs: []
  type: TYPE_NORMAL
- en: Server-sent events
  prefs: []
  type: TYPE_NORMAL
- en: Push data to a client as needed. Supported by FastAPI ([sse-starlette](https://oreil.ly/Hv-QP)),
    Flask ([Flask-SSE](https://oreil.ly/oz518)), and Django ([Django EventStream](https://oreil.ly/NlBE5)).
  prefs: []
  type: TYPE_NORMAL
- en: Queues
  prefs: []
  type: TYPE_NORMAL
- en: Job queues, publish-subscribe, and other networking patterns are supported by
    external packages like ZeroMQ, Celery, Redis, and RabbitMQ.
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets
  prefs: []
  type: TYPE_NORMAL
- en: Supported by FastAPI (directly), Django ([Django Channels](https://channels.readthedocs.io)),
    and Flask (third-party packages).
  prefs: []
  type: TYPE_NORMAL
- en: Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask and FastAPI do not include any database handling in their base packages,
    but database handling is a key feature of Django.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your site’s Data layer might access a database at different levels:'
  prefs: []
  type: TYPE_NORMAL
- en: Direct SQL (PostgreSQL, SQLite)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Direct NoSQL (Redis, MongoDB, Elasticsearch)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An *ORM* that generates SQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object document/data mapper/manager (ODM) that generates NoSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For relational databases, [SQLAlchemy](https://www.sqlalchemy.org) is an excellent
    package that includes multiple access levels, from direct SQL up to an ORM. This
    is a common choice for Flask and FastAPI developers. The author of FastAPI has
    leveraged both SQLAlchemy and Pydantic for the [SQLModel package](https://sqlmodel.tiangolo.com),
    which is discussed more in [Chapter 14](ch14.html#ch14).
  prefs: []
  type: TYPE_NORMAL
- en: Django is often the framework choice for a site with heavy database needs. It
    has its own [ORM](https://oreil.ly/eFzZn) and an automated [database admin page](https://oreil.ly/_al42).
    Although some sources recommend letting nontechnical staff use this admin page
    for routine data management, be careful. In one case, I’ve seen a non-expert misunderstand
    an admin page warning message, resulting in the database needing to be manually
    restored from a backup.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 14](ch14.html#ch14) discusses FastAPI and databases in more depth.'
  prefs: []
  type: TYPE_NORMAL
- en: Recommendations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For API-based services, FastAPI seems to be the best choice now. Flask and FastAPI
    are about equal in terms of getting a service up and running quickly. Django takes
    more time to understand but provides many features of use for larger sites, especially
    those with heavy database reliance.
  prefs: []
  type: TYPE_NORMAL
- en: Other Python Web Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The current big three Python web frameworks are Flask, Django, and FastAPI.
    Google **`python web frameworks`** and you’ll get a wealth of suggestions, which
    I won’t repeat here. A few that might not stand out in those lists but that are
    interesting for one reason or another include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Bottle](https://bottlepy.org/docs/dev)'
  prefs: []
  type: TYPE_NORMAL
- en: A *very* minimal (single Python file) package, good for a quick proof of concept
  prefs: []
  type: TYPE_NORMAL
- en: '[Litestar](https://litestar.dev)'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to FastAPI—it’s based on ASGI/Starlette and Pydantic—but has its own
    opinions
  prefs: []
  type: TYPE_NORMAL
- en: '[AIOHTTP](https://docs.aiohttp.org)'
  prefs: []
  type: TYPE_NORMAL
- en: An ASGI client and server, with useful demo code
  prefs: []
  type: TYPE_NORMAL
- en: '[Socketify.py](https://docs.socketify.dev)'
  prefs: []
  type: TYPE_NORMAL
- en: A new entrant that claims very high performance
  prefs: []
  type: TYPE_NORMAL
- en: Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Flask and Django are the most popular Python web frameworks, although FastAPI’s
    popularity is growing faster. All three handle the basic web server tasks, with
    varying learning curves. FastAPI seems to have a cleaner syntax for specifying
    routes, and its support of ASGI allows it to run faster than its competitors in
    many cases. Coming next: let’s build a website already.'
  prefs: []
  type: TYPE_NORMAL
