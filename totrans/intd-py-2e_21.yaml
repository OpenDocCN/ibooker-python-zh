- en: Chapter 19\. Be a Pythonista
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 19 章. 成为 Pythonista
- en: Always wanted to travel back in time to try fighting a younger version of yourself?
    Software development is the career for you!
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一直想回到过去试试和年轻时的自己斗智斗勇？软件开发就是你的职业选择！
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Elliot Loh](http://bit.ly/loh-tweet)'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[Elliot Loh](http://bit.ly/loh-tweet)'
- en: This chapter is devoted to the art and science of Python development, with “best
    practice” recommendations. Absorb them, and you too can be a card-carrying Pythonista.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专注于 Python 开发的艺术和科学，提供“最佳实践”建议。吸收它们，你也能成为一名 Pythonista。
- en: About Programming
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于编程
- en: First, a few notes about programming, based on personal experience.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，根据个人经验谈一些关于编程的注意事项。
- en: My original career path was science, and I taught myself programming to analyze
    and display experimental data. I expected computer programming to be like my impression
    of accounting—precise but dull. I was surprised to find that I enjoyed it. Part
    of the fun was its logical aspects—like solving puzzles—but part was creative.
    You had to write your program correctly to get the right results, but you had
    the freedom to write it any way you wanted. It was an unusual balance of right-brain
    and left-brain thinking.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我最初的职业路径是科学，我自学编程来分析和展示实验数据。我曾以为计算机编程会像我对会计的印象一样——精确但乏味。我惊讶地发现我很喜欢它。其中一部分乐趣来自逻辑方面——像解谜题一样——但部分也来自创造性。你必须正确地编写程序才能得到正确的结果，但你有自由按照自己的方式编写。这是左右脑思维的一种不寻常的平衡。
- en: After I wandered off into a career in programming, I also learned that the field
    had many niches, with very different tasks and types of people. You could delve
    into computer graphics, operating systems, business applications—even science.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我迷失在编程职业的道路后，我也发现这个领域有很多不同的小众，有着截然不同的任务和人群。你可以深入研究计算机图形学、操作系统、商业应用甚至科学领域。
- en: If you’re a programmer, you might have had a similar experience yourself. If
    you’re not, you might try programming a bit to see if it fits your personality,
    or at least helps you to get something done. As I may have mentioned much earlier
    in this book, math skills are not so important. It seems that the ability to think
    logically is most important and that an aptitude for languages seems to help.
    Finally, patience also helps, especially when you’re tracking down an elusive
    bug in your code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名程序员，你可能也有类似的经历。如果不是，你可以尝试一点编程，看看它是否适合你的个性，或者至少能帮助你完成一些任务。正如我在这本书的早期可能提到的那样，数学技能并不是那么重要。似乎最重要的是逻辑思维能力，语言天赋也有所帮助。最后，耐心也很重要，特别是当你在代码中追踪一个难以捉摸的
    bug 时。
- en: Find Python Code
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找 Python 代码
- en: When you need to develop some code, the fastest solution is to steal it…from
    a source that allows it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要开发一些代码时，最快的解决方案是从允许的来源“借”一些代码。
- en: The Python [standard library](http://docs.python.org/3/library) is wide, deep,
    and mostly clear. Dive in and look for those pearls.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python [标准库](http://docs.python.org/3/library)非常广泛、深入且大部分清晰。深入其中，寻找那些珍珠吧。
- en: Like the halls of fame for various sports, it takes time for a module to get
    into the standard library. New packages are appearing outside constantly, and
    throughout this book, I’ve highlighted some that either do something new or do
    something old better. Python is advertised as *batteries included*, but you might
    need a new kind of battery.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 就像各种体育名人堂一样，一个模块要进入标准库需要时间。新的包不断出现在外面，本书中我突出了一些新功能或者更好的旧功能。Python 被宣传为“内置电池”，但你可能需要一种新型电池。
- en: So where, outside the standard library, should you look for good Python code?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在标准库之外，你应该去哪里寻找好的 Python 代码？
- en: The first place to look is the [Python Package Index (PyPI)](https://pypi.org).
    Formerly named the *Cheese Shop* after a Monty Python skit, this site is constantly
    updated with Python packages—more than 113,000 as I write this. When you use `pip`
    (see the next section), it searches PyPI. The main PyPI page shows the most recently
    added packages. You can also conduct a direct search by typing something into
    the search box in the middle of the PyPI home page. For example, `genealogy` yields
    21 matches, and `movies` yields 528.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要查找的地方是[Python Package Index (PyPI)](https://pypi.org)。这个网站之前被称为蒙提·派森小品《奶酪商店》（*Cheese
    Shop*），我写作时这个网站上不断更新着 Python 的包——超过 113,000 个。当你使用 `pip`（见下一节）时，它会搜索 PyPI。主 PyPI
    页面显示了最近添加的包。你还可以通过在 PyPI 主页中间的搜索框中输入内容进行直接搜索。例如，`genealogy` 返回 21 个匹配项，`movies`
    返回 528 个。
- en: Another popular repository is GitHub. See what Python packages are currently
    [trending](https://github.com/trending?l=python).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个流行的存储库是 GitHub。查看当前哪些 Python 包正在[流行](https://github.com/trending?l=python)。
- en: '[Popular Python recipes](http://bit.ly/popular-recipes) has more than four
    thousand short Python programs, on every subject.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[热门 Python 示例](http://bit.ly/popular-recipes)拥有超过四千个短的 Python 程序，涵盖各个主题。'
- en: Install Packages
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装包
- en: 'There are many ways to install Python packages:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多安装 Python 包的方法：
- en: Use `pip` if you can. It’s the most common method by far. You can install most
    of the Python packages you’re likely to encounter with `pip`.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可以的话，请使用`pip`。这是目前最常见的方法。你可以使用`pip`安装大多数你可能遇到的 Python 包。
- en: Use `pipenv`, which combines `pip` and `virtualenv`
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pipenv`，它结合了`pip`和`virtualenv`
- en: Sometimes, you can use a package manager for your operating system.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，你可以使用操作系统的包管理器。
- en: Use `conda` if you do a lot of scientific work and want to use the Anaconda
    distribution of Python. See [“Install Anaconda”](app02.html#install_anaconda)
    for details.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你经常从事科学工作并想使用 Anaconda Python 发行版，请使用`conda`。有关详情，请参阅[“安装 Anaconda”](app02.html#install_anaconda)。
- en: Install from source.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从源码安装。
- en: If you’re interested in several packages in the same area, you might find a
    Python distribution that already includes them. For instance, in [Chapter 22](ch22.html#ch_science),
    you can try out a number of numeric and scientific programs that would be tedious
    to install individually but are included with distributions such as Anaconda.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对同一领域的几个包感兴趣，你可以找到一个已经包含它们的 Python 发行版。例如，在[第22章](ch22.html#ch_science)中，你可以尝试一些数字和科学程序，这些程序单独安装会很繁琐，但在
    Anaconda 等发行版中已经包含在内。
- en: Use pip
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 pip
- en: Python packaging has had some limitations. An earlier installation tool called
    `easy_install` has been replaced by one called `pip`, but neither had been in
    the standard Python installation. If you’re supposed to install things by using
    `pip`, from where did you get `pip`? Starting with Python 3.4, `pip` will finally
    be included with the rest of Python to avoid such existential crises. If you’re
    using an earlier version of Python 3 and don’t have `pip`, you can get it from
    [*http://www.pip-installer.org*](http://www.pip-installer.org).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Python 包装存在一些限制。一个早期的安装工具叫做`easy_install`已经被一个叫做`pip`的工具取代，但它们都没有被包含在标准的 Python
    安装中。如果你应该使用`pip`来安装东西，那你从哪里获取`pip`？从 Python 3.4 开始，`pip`最终将包含在 Python 的其他部分中，以避免这种存在危机。如果你正在使用较早版本的
    Python 3 并且没有`pip`，你可以从[*http://www.pip-installer.org*](http://www.pip-installer.org)获取它。
- en: 'The simplest use of `pip` is to install the latest version of a single package
    by using the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pip`的最简单方法是使用以下命令安装最新版本的单个包：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You will see details on what it’s doing, just so you don’t think it’s goofing
    off: downloading, running *setup.py*, installing files on your disk, and other
    details.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到它正在做什么，这样你就不会认为它在闲着：下载、运行 *setup.py*、在你的磁盘上安装文件等细节。
- en: 'You can also ask `pip` to install a specific version:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以要求`pip`安装特定版本：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or, a minimum version (this is useful when some feature that you can’t live
    without turns up in a particular version):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，一个最小版本（当你不能没有某个特定版本的功能时，这是很有用的）：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, those single quotes prevent the `>` from being interpreted
    by the shell to redirect output to a file called `=0.9.0`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，那些单引号防止了`>`被 Shell 解释为将输出重定向到一个名为`=0.9.0`的文件。
- en: 'If you want to install more than one Python package, you can use a [requirements
    file](http://bit.ly/pip-require). Although it has many options, the simplest use
    is a list of packages, one per line, optionally with a specific or relative version:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想安装多个 Python 包，你可以使用一个[requirements 文件](http://bit.ly/pip-require)。虽然它有许多选项，但最简单的用法是一个包的列表，每行一个，可选地带有特定或相对版本：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Your sample *requirements.txt* file might contain this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你的示例 *requirements.txt* 文件可能包含这样的内容：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A few more examples:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 更多示例：
- en: 'Install the latest version: `pip install --upgrade *package*`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装最新版本：`pip install --upgrade *package*`
- en: 'Delete a package: `pip uninstall *package*`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除一个包：`pip uninstall *package*`
- en: Use virtualenv
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 virtualenv
- en: The standard way of installing third-party Python packages is to use `pip` and
    `virtual``env`. I show how to install `virtualenv` in [“Install virtualenv”](app02.html#install_virtualenv).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 安装第三方 Python 包的标准方式是使用`pip`和`virtual``env`。我将展示如何在[“安装 virtualenv”](app02.html#install_virtualenv)中安装`virtualenv`。
- en: A *virtual environment* is just a directory that contains the Python interpreter,
    some other programs like `pip`, and some packages. You *activate* it by running
    the shell script `activate` that’s in the `bin` directory of that virtual environment.
    This sets the environment variable `$PATH` that your shell uses to find programs.
    By activating a virtual enviroment, you put its `bin` directory ahead of the usual
    directories in your `$PATH`. The result is that when you type a command like `pip`
    or `python`, your shell first finds the one in your virtual environment, instead
    of system directories like `/bin`, `/usr/bin`, or `/usr/local/bin`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚拟环境*只是一个包含Python解释器、像`pip`这样的其他程序和一些包的目录。你可以通过运行虚拟环境中`bin`目录下的`activate`脚本来*激活*它。这会设置环境变量`$PATH`，你的shell用它来查找程序。通过激活虚拟环境，你将其`bin`目录放在通常的目录如`/bin`、`/usr/bin`或`/usr/local/bin`之前。结果是，当你输入像`pip`或`python`这样的命令时，你的shell首先在虚拟环境中找到它们，而不是系统目录中的版本。'
- en: 'You don’t want to install software into those system directories anyhow, because:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你不想将软件安装到这些系统目录中，因为：
- en: You don’t have permission to write to them.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你没有写入它们的权限。
- en: Even if you could, overwriting your system’s standard programs (like `python`)
    could cause problems.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使可以，覆盖系统的标准程序（如`python`）可能会引起问题。
- en: Use pipenv
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 pipenv
- en: 'A recent package called [pipenv](http://docs.pipenv.org) combines our friends
    `pip` and `virtualenv`. It also addresses dependency issues that can arise when
    using `pip` in different environments (such as your local development machine,
    versus staging, versus production):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最近有一个叫做[pipenv](http://docs.pipenv.org)的包结合了我们的朋友`pip`和`virtualenv`。它还解决了在不同环境中（例如本地开发机器、测试和生产环境）使用`pip`时可能出现的依赖问题。
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Its use is recommended by the [Python Packaging Authority](https://www.pypa.io)—a
    working group trying to improve Python’s packaging workflow. This is not the same
    as the group that defines core Python itself, so `pipenv` is not a part of the
    standard library.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[Python Packaging Authority](https://www.pypa.io)推荐使用它——一个致力于改进Python打包工作流程的工作组。这不同于定义核心Python本身的组织，所以`pipenv`不是标准库的一部分。'
- en: Use a Package Manager
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用包管理器
- en: Apple’s macOS includes the third-party packagers [homebrew](http://brew.sh)
    (`brew`) and [`ports`](http://www.macports.org). They work a little like `pip`,
    but aren’t restricted to Python packages.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Apple的macOS包括第三方包管理器[homebrew](http://brew.sh)（`brew`）和[`ports`](http://www.macports.org)。它们有点像`pip`，但不限于Python包。
- en: Linux has a different manager for each distribution. The most popular are `apt-get`,
    `yum`, `dpkg`, and `zypper`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Linux对于每个发行版有不同的管理器。最流行的是`apt-get`、`yum`、`dpkg`和`zypper`。
- en: Windows has the Windows Installer and package files with a *.msi* suffix. If
    you installed Python for Windows, it was probably in the MSI format.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Windows有Windows Installer和带有*.msi*后缀的包文件。如果你在Windows上安装Python，可能是以MSI格式。
- en: Install from Source
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从源代码安装
- en: 'Occasionally, a Python package is new, or the author hasn’t managed to make
    it available with `pip`. To build the package, you generally do the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个Python包是新的，或者作者还没有通过`pip`提供它。要构建这个包，通常需要执行以下步骤：
- en: Download the code.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载代码。
- en: Extract the files by using `zip`, `tar`, or another appropriate tool if they’re
    archived or compressed.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文件已经被归档或压缩，使用`zip`、`tar`或其他适当的工具来提取它们。
- en: Run `python setup.py install` in the directory containing a *setup.py* file.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在包含*setup.py*文件的目录中运行`python setup.py install`。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As always, be careful what you download and install. It’s a little harder to
    hide malware in Python programs, which are readable text, but it has happened.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，请注意你下载和安装的内容。在Python程序中隐藏恶意软件稍微困难些，因为它们是可读文本，但确实发生过。
- en: Integrated Development Environments
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成开发环境
- en: I’ve used a plain-text interface for programs in this book, but that doesn’t
    mean that you need to run everything in a console or text window. There are many
    free and commercial integrated development environments (IDEs), which are GUIs
    with support for such tools as text editors, debuggers, library searching, and
    so on.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本书中的程序都用纯文本界面，但这并不意味着你需要在控制台或文本窗口中运行所有内容。有许多免费和商业的集成开发环境（IDE），它们是带有文本编辑器、调试器、库搜索等工具支持的图形界面。
- en: IDLE
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IDLE
- en: '[IDLE](http://bit.ly/py-idle) is the only Python IDE that’s included with the
    standard distribution. It’s based on tkinter, and its GUI is plain.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[IDLE](http://bit.ly/py-idle)是唯一包含在标准发行版中的Python IDE。它基于tkinter，其GUI界面简单。'
- en: PyCharm
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyCharm
- en: '[PyCharm](http://www.jetbrains.com/pycharm) is a recent graphic IDE with many
    features. The community edition is free, and you can get a free license for the
    professional edition to use in a classroom or an open source project. [Figure 19-1](#img_pycharm)
    shows its initial display.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[PyCharm](http://www.jetbrains.com/pycharm) 是一个具有许多功能的新型图形 IDE。社区版是免费的，你可以获得专业版的免费许可证，用于课堂或开源项目中。[Figure 19-1](#img_pycharm)
    显示了它的初始显示。'
- en: '![inp2 1901](assets/inp2_1901.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![inp2 1901](assets/inp2_1901.png)'
- en: Figure 19-1\. Startup screen for PyCharm
  id: totrans-71
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 19-1\. PyCharm 的启动界面
- en: IPython
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPython
- en: '[iPython](http://ipython.org) started as an enhanced terminal (text) Python
    IDE, but evolved a graphical interface with the metaphor of a *notebook*. It integrated
    many packages that are discussed in this book, including Matplotlib and NumPy,
    and became a popular tool in scientific computing.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[iPython](http://ipython.org) 最初是一个增强的文本 Python IDE 终端，但随后演变成具有类似“笔记本”的图形界面。它集成了许多本书讨论的包，包括
    Matplotlib 和 NumPy，并成为科学计算中的热门工具。'
- en: 'You install the basic text version with (you guessed it) `pip install ipython`.
    When you start it, you’ll see something like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `pip install ipython` 安装基本的文本版本。当你启动它时，你会看到类似于这样的界面：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you know, the standard Python interpreter uses the input prompts `>>>` and
    `...` to indicate where and when you should type code. IPython tracks everything
    you type in a list called `In`, and all your output in `Out`. Each input can be
    more than one line, so you submit it by holding the Shift key while pressing Enter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，标准的 Python 解释器使用输入提示符 `>>>` 和 `...` 来指示何时何地应该输入代码。IPython 会将你输入的所有内容记录在一个名为
    `In` 的列表中，将所有的输出记录在 `Out` 中。每个输入可能包含多行，因此，你可以按住 Shift 键并同时按 Enter 键来提交它。
- en: 'Here’s a one-line example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个单行示例：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`In` and `Out` are automatically numbered lists, letting you access any of
    the inputs you typed or outputs you received.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`In` 和 `Out` 是自动编号的列表，让你可以访问你输入的任何输入或收到的输出。'
- en: 'If you type `?` after a variable, IPython tells you its type, value, ways of
    making a variable of that type, and some explanation:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个变量后面输入 `?`，IPython 将告诉你它的类型、值、创建该类型变量的方法以及一些解释：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Name lookup is a popular feature of IDEs such as IPython. If you press the
    Tab key right after some characters, IPython shows all variables, keywords, and
    functions that begin with those characters. Let’s define some variables and then
    find everything that begins with the letter `f`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 名称查找是像 IPython 这样的 IDE 的一个流行特性。如果你在一些字符后面立即按 Tab 键，IPython 将显示所有以这些字符开头的变量、关键字和函数。让我们定义一些变量，然后找出所有以字母
    `f` 开头的内容：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you type `fe` followed by the Tab key, it expands to the variable `fee`,
    which, in this program, is the only thing that starts with `fe`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入 `fe`，然后按 Tab 键，它会展开为变量 `fee`，在这个程序中，它是以 `fe` 开头的唯一内容：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There’s much more to IPython. Take a look at its [tutorial](https://oreil.ly/PIvVK)
    to get a feel for its features.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 还有更多功能。看看它的 [教程](https://oreil.ly/PIvVK)，了解它的特性。
- en: Jupyter Notebook
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jupyter Notebook
- en: '[Jupyter](https://jupyter.org) is an evolution of IPython. The name combines
    the languages Julia, Python, and R—all of which are popular in data science and
    scientific computing. Jupyter Notebooks are a modern way to develop and publish
    your code with documentation for any of these languages.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[Jupyter](https://jupyter.org) 是 IPython 的一个进化。它的名称结合了数据科学和科学计算中流行的 Julia、Python
    和 R 语言。Jupyter Notebooks 是一种现代的方式，可以用于开发和发布你的代码，并包含任何这些语言的文档。'
- en: If you’d like to play with it first before installing anything on your computer,
    you can first [try it out](https://jupyter.org/try) in your web browser.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在计算机上安装任何东西之前先玩一下，你可以首先在你的网络浏览器中 [试试](https://jupyter.org/try)。
- en: To install Jupyter Notebook locally, type `pip install jupyter`. Run it with
    `jupyter notebook`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地安装 Jupyter Notebook，请输入 `pip install jupyter`。使用 `jupyter notebook` 命令来运行它。
- en: JupyterLab
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JupyterLab
- en: JupyterLab is the next generation of Jupyter Notebook and will eventually replace
    it. As with the Notebook, you can first [try out](https://jupyter.org/try) JupyterLab
    in your browser. You install it locally with `pip install jupyterlab` and then
    run it with `jupyter lab`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: JupyterLab 是 Jupyter Notebook 的下一代，并最终将取代它。和 Notebook 一样，你可以在浏览器中 [试用](https://jupyter.org/try)
    JupyterLab。你可以通过 `pip install jupyterlab` 在本地安装它，然后用 `jupyter lab` 运行它。
- en: Name and Document
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 名称和文档
- en: 'You won’t remember what you wrote. Sometimes, I look at code that I wrote even
    recently and wonder where on earth it came from. That’s why it helps to document
    your code. Documentation can include comments and docstrings, but it can also
    incorporate informative naming of variables, functions, modules, and classes.
    Don’t be obsessive, as in this example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会记得自己写了什么。有时候，我看着自己最近写的代码，想知道它到底是从哪儿来的。这就是为什么文档化你的代码很有帮助。文档可以包括注释和文档字符串，但也可以包括对变量、函数、模块和类进行信息丰富的命名。不要过度追求，就像这个例子中一样：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Instead, say *why* you assigned the value `10`. Point out why you called the
    variable `num`. If you were writing the venerable Fahrenheit-to-Celsius converter,
    you might name variables to explain what they do rather than a lump of magic code.
    And a little test code wouldn’t hurt ([Example 19-1](#ex1901)).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，说清楚*为什么*你给变量赋值`10`。指出为什么叫变量名为`num`。如果你正在写经典的华氏度到摄氏度转换器，你可能会命名变量来解释它们的作用，而不是一团神奇的代码。而且一点测试代码也不会有什么坏处（[示例 19-1](#ex1901)）。
- en: Example 19-1\. ftoc1.py
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-1\. ftoc1.py
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s run the tests:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行测试：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can make (at least) two improvements:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做（至少）两个改进：
- en: Python doesn’t have constants, but the PEP8 stylesheet [recommends](http://bit.ly/pep-constant)
    using capital letters and underscores (e.g., `ALL_CAPS`) when naming variables
    that should be considered constants. Let’s rename those constant-y variables in
    our example.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 没有常量，但 PEP8 样式表 [建议](http://bit.ly/pep-constant) 在命名变量时使用大写字母和下划线（例如
    `ALL_CAPS`）。让我们在我们的示例中将那些看起来像常量的变量重命名。
- en: Because we precompute values based on constant values, let’s move them to the
    top level of the module. Then, they’ll be calculated only once rather than in
    every call to the `ftoc()` function.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为我们基于常量值预计算值，让我们将它们移到模块的顶层。然后，它们将只在每次调用`ftoc()`函数时计算一次，而不是每次调用时都计算。
- en: '[Example 19-2](#ex1902) shows the result of our rework.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19-2](#ex1902) 展示了我们重做的结果。'
- en: Example 19-2\. ftoc2.py
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-2\. ftoc2.py
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Add Type Hints
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加类型提示
- en: Static languages require you to define the types of your variables, and they
    can catch some errors at compile time. As you know, Python doesn’t do this, and
    you can encounter bugs only when the code is run. Python variables are names and
    only refer to actual objects. Objects have strict types, but names can point to
    any object at any time.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 静态语言要求您定义变量的类型，并且它们可以在编译时捕获一些错误。如您所知，Python 不会这样做，只有在运行代码时才会遇到错误。Python 变量是名称，只是引用实际对象。对象具有严格的类型，但名称可以随时指向任何对象。
- en: Yet in real code (in Python and other languages), a name tends to refer to a
    particular object. It would help, at least in documentation, if we could annotate
    things (variables, function returns, and so on) with the object types we expect
    them to be referencing. Then, developers would not need to look through as much
    code to see how a particular variable is supposed to act.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实际代码中（无论是 Python 还是其他语言），名称往往指向特定的对象。至少在文档中，如果我们能够注释事物（变量、函数返回等）与我们期望它们引用的对象类型，则会有所帮助。然后，开发人员就不需要查看那么多代码来了解特定变量应该如何操作。
- en: Python 3.x added *type hints* (or *type annotations*) to address this. It’s
    completely optional, and does not force types on variables. It helps developers
    who are used to static languages, where variable types *must* be declared.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.x 添加了*类型提示*（或*类型注释*）来解决这个问题。这完全是可选的，并且不会强制变量的类型。它帮助那些习惯于静态语言的开发人员，其中变量类型*必须*声明。
- en: 'Hints for a function that converts a number to a string would look like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一个将数字转换为字符串的函数的提示看起来是这样的：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: These are only hints, and they don’t change how Python works. Their main use
    is for documentation, but people are finding more uses. For example, the [FastAPI](https://fastapi.tiangolo.com)
    web framework uses hints to generate web documentation with live forms for testing.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是提示，并不会改变 Python 的运行方式。它们的主要用途是用于文档，但人们正在找到更多用途。例如，[FastAPI](https://fastapi.tiangolo.com)
    web 框架使用提示生成带有实时表单用于测试的 web 文档。
- en: Test
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'You probably already know this, but if not: even trivial code changes can break
    your program. Python lacks the type-checking of static languages, which makes
    some things easier but also lets undesirable results through the door. Testing
    is essential.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经知道了，但如果不知道的话：即使是微不足道的代码更改也可能会破坏你的程序。Python 缺乏静态语言的类型检查，这使得某些事情变得更容易，但也让不良结果通过了大门。测试是必不可少的。
- en: The very simplest way to test Python programs is to add `print()` statements.
    The Python interactive interpreter’s Read-Evaluate-Print Loop (REPL) lets you
    edit and test changes quickly. However, you don’t want `print()` statements in
    production code, so you need to remember to remove them all.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 测试Python程序的最简单方法是添加`print()`语句。Python交互式解释器的REPL（Read-Evaluate-Print Loop）允许您快速编辑和测试更改。但是，在生产代码中您不希望有`print()`语句，因此需要记住全部删除它们。
- en: Check with pylint, pyflakes, flake8, or pep8
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用pylint、pyflakes、flake8或pep8进行检查
- en: 'The next step, before creating actual test programs, is to run a Python code
    checker. The most popular are [`pylint`](http://www.pylint.org) and [`pyflakes`](http://bit.ly/pyflakes).
    You can install either or both by using `pip`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建实际测试程序之前的下一步是运行Python代码检查器。最流行的是[`pylint`](http://www.pylint.org)和[`pyflakes`](http://bit.ly/pyflakes)。您可以使用`pip`安装其中一个或两个：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: These check for actual code errors (such as referring to a variable before assigning
    it a value) and style faux pas (the code equivalent of wearing plaids and stripes).
    [Example 19-3](#ex1903) is a fairly meaningless program with a bug and style issue.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 它们检查实际的代码错误（例如在给变量赋值之前引用它）和风格上的失误（代码版的搭配格格不入）。[示例 19-3](#ex1903) 是一个有错误和风格问题的相当无意义的程序。
- en: Example 19-3\. style1.py
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-3\. style1.py
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here’s the initial output of `pylint`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`pylint`的初始输出：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Much further down, under `Global evaluation`, is our score (10.0 is perfect):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在“全局评估”下，我们的分数（10.0是完美的）进一步下降了：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Ouch. Let’s fix the bug first. That `pylint` output line starting with an `E`
    indicates an `Error`, which occurred because we didn’t assign a value to `c` before
    we printed it. Take a look at [Example 19-4](#ex1904) to see how we can fix that.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕了。让我们先修复错误。那个以`E`开头的`pylint`输出行表示一个`Error`，因为我们在打印它之前没有给`c`赋值。查看 [示例 19-4](#ex1904)
    看看我们如何修复它。
- en: Example 19-4\. style2.py
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-4\. style2.py
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Good, no more `E` lines. And our score jumped from -3.33 to 4.29:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，不再有`E`行了。我们的分数也从-3.33上升到了4.29：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`pylint` wants a docstring (a short text at the top of a module or function,
    describing the code), and it thinks short variable names such as `a`, `b`, and
    `c` are tacky. Let’s make `pylint` happier and improve *style2.py* to *style3.py*
    ([Example 19-5](#ex1905)).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`pylint`希望有一个文档字符串（一个简短的文本，位于模块或函数顶部，描述代码），并认为像`a`、`b`和`c`这样的短变量名是俗气的。让我们让`pylint`更开心，并将
    *style2.py* 改进为 *style3.py* ([示例 19-5](#ex1905))。'
- en: Example 19-5\. style3.py
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-5\. style3.py
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Hey, no complaints. And our score?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，没有抱怨。我们的分数呢？
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And there was much rejoicing.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 大家都很高兴。
- en: 'Another style checker is [`pep8`](https://pypi.python.org/pypi/pep8), which
    you can install in your sleep by now:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个风格检查器是[`pep8`](https://pypi.python.org/pypi/pep8)，您现在可能已经可以在睡觉时安装它了：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: What does it say about our style makeover?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们的风格改头换面有何建议？
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To be really stylish, it’s recommending that I add a blank line after the initial
    module docstring.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正时尚，它建议我在初始模块文档字符串后添加一个空行。
- en: Test with unittest
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用unittest进行测试
- en: We’ve verified that we’re no longer insulting the style senses of the code gods,
    so let’s move on to actual tests of the logic in your program.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经验证我们不再侮辱代码之神的审美感，所以让我们转向测试您程序逻辑的实际测试。
- en: It’s a good practice to write independent test programs first, to ensure that
    they all pass before you commit your code to any source control system. Writing
    tests can seem tedious at first, but they really do help you find problems faster—especially
    *regressions* (breaking something that used to work). Painful experience teaches
    all developers that even the teeniest change, which they swear could not possibly
    affect anything else, actually does. If you look at well-written Python packages,
    they always include a test suite.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在提交代码到任何源代码管理系统之前，先编写独立的测试程序是一个良好的实践。最初编写测试可能看起来很乏味，但它们确实能帮助您更快地发现问题，尤其是*回归*（破坏了曾经工作的东西）。痛苦的经验教会所有开发者，即使是他们发誓不可能影响其他任何东西的微小改变，实际上也会如此。看看写得好的Python包，它们总是包含一个测试套件。
- en: The standard library contains not one, but two test packages. Let’s start with
    [`unittest`](https://oreil.ly/ImFmE). We’ll write a module that capitalizes words.
    Our first version just uses the standard string function `capitalize()`, with
    some unexpected results as we’ll see. Save this as *cap.py* ([Example 19-6](#ex1906)).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中不止一个测试包。让我们从 [`unittest`](https://oreil.ly/ImFmE) 开始。我们将编写一个将单词首字母大写的模块。我们的第一个版本仅使用标准字符串函数
    `capitalize()`，结果如我们所见有些意外。将其保存为 *cap.py* ([示例 19-6](#ex1906))。
- en: Example 19-6\. cap.py
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-6\. cap.py
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The basis of testing is to decide what outcome you want from a certain input
    (here, you want the capitalized version of whatever text you input), submit the
    input to the function you’re testing, and then check whether it returned the expected
    results. The expected result is called an *assertion*, so in `unittest` you check
    your results by using methods with names that begin with `assert`, like the `assertEqual`
    method shown in [Example 19-7](#ex1907).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的基础是决定从特定输入中得到什么结果（这里，您希望输入的任何文本的大写版本），将输入提交给您正在测试的函数，然后检查它是否返回了预期的结果。预期的结果称为*断言*，因此在`unittest`中，您通过使用以`assert`开头的方法（例如在[Example 19-7](#ex1907)中显示的`assertEqual`方法）来检查结果。
- en: Save this test script as *test_cap.py*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将此测试脚本保存为*test_cap.py*。
- en: Example 19-7\. test_cap.py
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 19-7\. test_cap.py
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `setUp()` method is called before each test method, and the `tearDown()`
    method is called after each. Their purpose is to allocate and free external resources
    needed by the tests, such as a database connection or some test data. In this
    case, our tests are self-contained, and we wouldn’t even need to define `setUp()`
    and `tearDown()`, but it doesn’t hurt to have empty versions there. At the heart
    of our test are the two functions named `test_one_word()` and `test_multiple_words()`.
    Each runs the `just_do_it()` function we defined with different input and checks
    whether we got back what we expect. Okay, let’s run it. This will call our two
    test methods:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`setUp()`方法在每个测试方法之前调用，而`tearDown()`方法在每个测试方法之后调用。它们的目的是为测试分配和释放外部资源，例如数据库连接或某些测试数据。在这种情况下，我们的测试是独立的，甚至不需要定义`setUp()`和`tearDown()`，但留有空版本也无妨。在我们的测试核心是两个名为`test_one_word()`和`test_multiple_words()`的函数。每个函数都使用不同的输入运行我们定义的`just_do_it()`函数，并检查我们是否得到了预期的结果。好的，让我们运行它。这将调用我们的两个测试方法：'
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It liked the first test (`test_one_word`), but not the second (`test_multiple_words`).
    The up arrows (`^`) show where the strings actually differed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 它喜欢第一个测试（`test_one_word`），但不喜欢第二个（`test_multiple_words`）。上箭头（`^`）显示了字符串实际上有所不同的地方。
- en: 'What’s special about multiple words? Reading the documentation for the `string`
    [`capitalize`](https://oreil.ly/x1IV8) function yields an important clue: it capitalizes
    only the first letter of the first word. Maybe we should have read that first.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 多个单词有什么特别之处？阅读`string` [`capitalize`](https://oreil.ly/x1IV8)函数的文档提供了一个重要线索：它仅大写第一个单词的第一个字母。也许我们应该先读这个文档。
- en: Consequently, we need another function. Gazing down that page a bit, we find
    [`title()`](https://oreil.ly/CNKNl). So, let’s change *cap.py* to use `title()`
    instead of `capitalize()` ([Example 19-8](#ex1908)).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要另一个函数。在页面底部略微望去，我们找到了[`title()`](https://oreil.ly/CNKNl)。因此，让我们更改*cap.py*以使用`title()`而不是`capitalize()`（[Example 19-8](#ex1908)）。
- en: Example 19-8\. cap.py, revised
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 19-8\. cap.py, revised
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Rerun the tests, and let’s see what happens:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行测试，看看会发生什么：
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Everything is great. Well, actually, they’re not. We need to add at least one
    more method to *test_cap.py* ([Example 19-9](#ex1909)).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都很好。好吧，实际上并不是。我们需要在*test_cap.py*中至少再添加一个方法来测试（[Example 19-9](#ex1909)）。
- en: Example 19-9\. test_cap.py, revised
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 19-9\. test_cap.py, revised
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Go ahead and try it again:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 继续尝试一下：
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Our function capitalized the `m` in `I'm`. A quick run back to the documentation
    for `title()` shows that it doesn’t handle apostrophes well. We *really* should
    have read the entire text first.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数将`I'm`中的`m`大写化了。快速查阅`title()`的文档后显示，它不能很好地处理撇号。我们*真的*应该先完整地阅读整个文本。
- en: 'At the bottom of the standard library’s `string` documentation is another candidate:
    a helper function called `capwords()`. Let’s use it in *cap.py* ([Example 19-10](#ex1910)).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在`string`文档的底部还有另一个候选：一个名为`capwords()`的辅助函数。让我们在*cap.py*中使用它（[Example 19-10](#ex1910)）。
- en: Example 19-10\. cap.py, re-revised
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 19-10\. cap.py, re-revised
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: At last, we’re finally done! Uh, no. We have one more test to add to *test_cap.py*
    ([Example 19-11](#ex1911)).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 终于，我们终于完成了！嗯，不对。我们还需要在*test_cap.py*中添加另一个测试（[Example 19-11](#ex1911)）。
- en: Example 19-11\. test_cap.py, re-revised
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 19-11\. test_cap.py, re-revised
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Did it work?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 它工作了吗？
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: It looks like that first double quote confused even `capwords`, our favorite
    capitalizer thus far. It tried to capitalize the `"`, and lowercased the rest
    (`You're`). We should have also tested that our capitalizer left the rest of the
    string untouched.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来第一个双引号甚至搞混了我们到目前为止最喜欢的大写功能`capwords`。它尝试大写`"`，并小写了其余部分（`You're`）。我们还应该测试我们的大写器是否会保留字符串的其余部分。
- en: People who do testing for a living have a knack for spotting these edge cases,
    but developers often have blind spots when it comes to their own code.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以职业测试为生的人对于发现这些边缘情况有一种天赋，但开发人员在自己的代码中往往有盲点。
- en: '`unittest` provides a small but powerful set of assertions, letting you check
    values, confirm whether you have the class you want, determine whether an error
    was raised, and so on.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest`提供了一组小而强大的断言，让你可以检查值，确认是否有你想要的类，确定是否引发了错误等等。'
- en: Test with doctest
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用doctest进行测试
- en: 'The second test package in the standard library is [`doctest`](http://bit.ly/py-doctest).
    With this package, you can write tests within the docstring itself, also serving
    as documentation. It looks like the interactive interpreter: the characters `>>>`,
    followed by the call, and then the results on the following line. You can run
    some tests in the interactive interpreter and just paste the results into your
    test file. Let’s modify our old *cap.py* as *cap2.py* (without that troublesome
    last test with quotes), as shown in [Example 19-12](#ex1912).'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的第二个测试包是[`doctest`](http://bit.ly/py-doctest)。使用这个包，你可以在文档字符串内部编写测试，同时作为文档。它看起来像交互式解释器：字符`>>>`，然后是调用，然后是下一行的结果。你可以在交互式解释器中运行一些测试，然后将结果粘贴到你的测试文件中。让我们将我们旧的*cap.py*修改为*cap2.py*（去掉那个带引号的麻烦的最后一个测试），如[示例 19-12](#ex1912)所示。
- en: Example 19-12\. cap2.py
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-12\. cap2.py
- en: '[PRE47]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'When you run it, it doesn’t print anything if all tests passed:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行它时，如果所有测试都通过，它不会打印任何内容：
- en: '[PRE48]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Give it the verbose (`-v`) option to see what actually happened:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 给它加上详细选项（`-v`），看看到底发生了什么：
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Test with nose
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用nose进行测试
- en: 'The third-party package called [`nose`](https://oreil.ly/gWK6r) is another
    alternative to `unittest`. Here’s the command to install it:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方包叫做[`nose`](https://oreil.ly/gWK6r)是`unittest`的另一种选择。这里是安装它的命令：
- en: '[PRE51]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You don’t need to create a class that includes test methods, as we did with
    `unittest`. Any function with a name matching `test` somewhere in its name will
    be run. Let’s modify our last version of our `unittest` tester and save it as
    *test_cap_nose.py* ([Example 19-13](#ex1913)).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要创建一个包含测试方法的类，就像我们在`unittest`中所做的那样。任何函数名中包含`test`的函数都会被运行。让我们修改我们`unittest`的最新版本，并保存为*test_cap_nose.py*（[示例 19-13](#ex1913)）。
- en: Example 19-13\. test_cap_nose.py
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-13\. test_cap_nose.py
- en: '[PRE52]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Run the tests:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试：
- en: '[PRE53]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This is the same bug we found when we used `unittest` for testing; fortunately,
    there’s an exercise to fix it at the end of this chapter.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在使用`unittest`进行测试时发现的同样的bug；幸运的是，本章末尾有一个修复它的练习。
- en: Other Test Frameworks
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他测试框架
- en: 'For some reason, people like to write Python test frameworks. If you’re curious,
    you can check out some other popular ones:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于某些原因，人们喜欢编写Python测试框架。如果你感兴趣，可以看看其他流行的一些：
- en: '[`tox`](http://tox.readthedocs.org)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`tox`](http://tox.readthedocs.org)'
- en: '[`py.test`](https://pytest.org)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`py.test`](https://pytest.org)'
- en: '[`green`](https://github.com/CleanCut/green)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`green`](https://github.com/CleanCut/green)'
- en: Continuous Integration
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续集成
- en: When your group is cranking out a lot of code daily, it helps to automate tests
    as soon as changes arrive. You can automate source control systems to run tests
    on all code as it’s checked in. This way, everyone knows whether someone *broke
    the build* and just disappeared for an early lunch—or a new job.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的团队每天输出大量代码时，自动化测试在变更到来时会很有帮助。你可以自动化源代码控制系统以在检入时对所有代码运行测试。这样，每个人都知道是否有人*破坏了构建*，然后提前吃午餐——或者找新工作。
- en: 'These are big systems, and I’m not going into installation and usage details
    here. In case you need them someday, you’ll know where to find them:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是庞大的系统，我这里不会详细讨论安装和使用细节。万一有一天你需要它们，你会知道在哪里找到它们：
- en: '[`buildbot`](http://buildbot.net)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[`buildbot`](http://buildbot.net)'
- en: Written in Python, this source control system automates building, testing, and
    releasing.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个源代码控制系统用Python编写，自动化了构建、测试和发布。
- en: '[`jenkins`](http://jenkins-ci.org)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[`jenkins`](http://jenkins-ci.org)'
- en: This is written in Java, and seems to be the preferred CI tool of the moment.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用Java编写的，似乎是目前首选的CI工具。
- en: '[`travis-ci`](http://travis-ci.com)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[`travis-ci`](http://travis-ci.com)'
- en: This automates projects hosted at GitHub, and is free for open source projects.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自动化项目托管在GitHub上，并且对开源项目是免费的。
- en: '[`circleci`](https://circleci.com)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[`circleci`](https://circleci.com)'
- en: This one is commercial but free for open source and private projects.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个是商业的，但对于开源项目和私有项目是免费的。
- en: Debug Python Code
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试Python代码
- en: Debugging is like being the detective in a crime movie where you are also the
    murderer.
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 调试就像是一部侦探电影中你既是侦探又是凶手的情节。
- en: ''
  id: totrans-227
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Filipe Fortes
  id: totrans-228
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 菲利普·福尔特斯
- en: Everyone knows that debugging is twice as hard as writing a program in the first
    place. So if you’re as clever as you can be when you write it, how will you ever
    debug it?
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每个人都知道调试比一开始编写程序要难两倍。所以如果你在编写时尽可能聪明，你将如何调试呢？
- en: ''
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Brian Kernighan
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Brian Kernighan
- en: Test first. The better your tests are, the less you’ll have to fix later. Yet,
    bugs happen and need to be fixed when they’re found later.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 先测试。你的测试越好，后面就需要修复的 bug 就越少。然而，bug 会发生，需要在稍后找到并修复。
- en: When code breaks, it’s usually because of something you just did. So you typically
    debug “from the bottom up,” starting with your most recent changes.^([1](ch19.html#idm45794966587992))
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码出错时，通常是因为你刚刚做的某事。因此，你通常会“自下而上”调试，从最近的更改开始。^([1](ch19.html#idm45794966587992))
- en: But sometimes the cause is elsewhere, in something that you trusted and thought
    worked. You would think that if there were problems in something that many people
    use, someone would have noticed by now. That is not always what happens. The trickiest
    bugs that I’ve encountered, that each took more than a week to fix, had external
    causes. So after blaming the person in the mirror, question your assumptions.
    This is a “top-down” approach, and it takes longer.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时候原因在别处，可能是你信任并认为有效的某些东西。你会认为如果有问题是由很多人使用的东西引起的，现在应该已经有人注意到了。但事实并不总是如此。我遇到的最棘手的
    bug，每一个都花了一周以上的时间来修复，都是由外部原因引起的。所以，在责怪镜子中的那个人之后，要质疑你的假设。这是一种“自上而下”的方法，而且需要更长的时间。
- en: The following are some debugging techniques, from quick and dirty to slower,
    but often just as dirty.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些调试技术，从快速且脏到更慢但通常同样脏的技术。
- en: Use print()
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 print()
- en: 'The simplest way to debug in Python is to print out strings. Some useful things
    to print include `vars()`, which extracts the values of your local variables,
    including function arguments:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中调试的最简单方法是打印字符串。一些有用的要打印的东西包括 `vars()`，它提取你的局部变量的值，包括函数参数：
- en: '[PRE55]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Other things that are often worth printing are `locals()` and `globals()`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 通常值得打印的其他东西包括 `locals()` 和 `globals()`。
- en: If your code also includes normal prints to standard output, you can write your
    debugging messages to standard error output with `print(*stuff*, file=sys.stderr)`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码还包括普通的打印输出，你可以使用 `print(*stuff*, file=sys.stderr)` 将你的调试信息写入标准错误输出。
- en: Use Decorators
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用装饰器
- en: As you read in [“Decorators”](ch09.html#decorators), a decorator can call code
    before or after a function without modifying the code within the function itself.
    This means that you can use a decorator to do something before or after any Python
    function, not just ones that you wrote. Let’s define the decorator `dump` to print
    the input arguments and output values of any function as it’s called (designers
    know that a dump often needs decorating), as shown in [Example 19-14](#ex1914).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[“装饰器”](ch09.html#decorators)中所读到的，装饰器可以在函数之前或之后调用代码，而不修改函数本身的代码。这意味着你可以在任何
    Python 函数之前或之后使用装饰器来执行某些操作，而不仅仅是你编写的函数。让我们定义一个装饰器 `dump` 来打印任何函数在被调用时的输入参数和输出值（设计者知道装饰时经常需要装饰），如
    [示例 19-14](#ex1914) 所示。
- en: Example 19-14\. dump.py
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-14\. dump.py
- en: '[PRE56]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now the decoratee. This is a function called `double()` that expects numeric
    arguments, either named or unnamed, and returns them in a list with their values
    doubled ([Example 19-15](#ex1915)).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是被装饰的函数。这是一个名为 `double()` 的函数，它期望数值参数，可以是命名的或未命名的，并将它们以列表形式返回，其中包含它们的值加倍（参见
    [示例 19-15](#ex1915)）。
- en: Example 19-15\. test_dump.py
  id: totrans-246
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-15\. test_dump.py
- en: '[PRE57]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Take a moment to run it:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 花一点时间运行它：
- en: '[PRE58]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Use pdb
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 pdb
- en: These techniques help, but sometimes there’s no substitute for a real debugger.
    Most IDEs include a debugger, with varying features and user interfaces. Here,
    I describe use of the standard Python debugger, [`pdb`](https://oreil.ly/IIN4y).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术有所帮助，但有时候没有真正调试器来得有效。大多数集成开发环境都包含了调试器，具有各种功能和用户界面。在这里，我描述了如何使用标准的 Python
    调试器，[`pdb`](https://oreil.ly/IIN4y)。
- en: Note
  id: totrans-253
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you run your program with the `-i` flag, Python will drop you into its interactive
    interpreter if the program fails.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用 `-i` 标志运行你的程序，如果程序失败，Python 就会将你带入它的交互式解释器中。
- en: Here’s a program with a bug that depends on data—the kind of bug that can be
    particularly hard to find. This is a real bug from the early days of computing,
    and it baffled programmers for quite a while.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个依赖数据的 bug 的程序，这种 bug 特别难以找到。这是早期计算机的一个真正的 bug，它让程序员们困惑了很长时间。
- en: We’re going to read a file of countries and their capital cities, separated
    by a comma, and write them out as *capital*, *country*. They might be capitalized
    incorrectly, so we should fix that also when we print. Oh, and there might be
    extra spaces here and there, and you’ll want to get rid of those, too. Finally,
    although it would make sense for the program to just read to the end of the file,
    for some reason our manager told us to stop when we encounter the word `quit`
    (in any mixture of uppercase and lowercase characters). [Example 19-16](#ex1916)
    shows a sample data file.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将读取一个国家和其首都的文件，用逗号分隔，然后将它们写成 *capital*, *country* 的形式。在打印时，它们可能有错误的大写，所以我们也要修正。哦，这里可能会有额外的空格，你会想把它们去掉。最后，尽管程序读到文件末尾会更合理，但由于某种原因，我们的经理告诉我们遇到
    `quit` 这个词时要停止（不区分大小写）。[示例 19-16](#ex1916) 展示了一个样本数据文件。
- en: Example 19-16\. cities.csv
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-16\. cities.csv
- en: '[PRE60]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let’s design our *algorithm* (method for solving the problem). This is *pseudocode*—it
    looks like a program, but is just a way to explain the logic in normal language
    before converting it to an actual program. One reason programmers like Python
    is because it *looks a lot like pseudocode*, so there’s less work involved when
    it’s time to convert it to a working program:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设计我们的 *算法*（解决问题的方法）。这是 *伪代码* ——它看起来像一个程序，但只是一种在转换为实际程序之前用普通语言解释逻辑的方法。程序员喜欢Python的一个原因是因为它
    *看起来很像伪代码*，所以在转换为工作程序时工作量较少：
- en: '[PRE61]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We need to strip initial and trailing spaces from the names because that was
    a requirement. Likewise for the lowercase comparison with `quit` and converting
    the city and country names to title case. That being the case, let’s whip out
    *capitals.py*, which is sure to work perfectly ([Example 19-17](#ex1917)).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从名称中去掉开头和结尾的空格，因为那是一个要求。同样对于与 `quit` 的小写比较和将城市和国家名称转换为首字母大写格式也是如此。既然如此，让我们拿出
    *capitals.py*，它肯定能完美运行（[示例 19-17](#ex1917)）。
- en: Example 19-17\. capitals.py
  id: totrans-262
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-17\. capitals.py
- en: '[PRE62]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Let’s try it with that sample data file we made earlier. Ready, fire, aim:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用之前制作的样本数据文件。准备好了，开火：
- en: '[PRE63]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Looks great! It passed one test, so let’s put it in production, processing capitals
    and countries from around the world—until it fails, but only for this data file
    ([Example 19-18](#ex1918)).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很不错！它通过了一个测试，所以让我们把它投入到生产中，处理来自世界各地的首都和国家——直到它失败，但仅限于这个数据文件（[示例 19-18](#ex1918)）。
- en: Example 19-18\. cities2.csv
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-18\. cities2.csv
- en: '[PRE64]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The program ends after printing only 5 lines of the 15 in the data file, as
    demonstrated here:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 程序在打印了数据文件中的15行中的5行后结束，如下所示：
- en: '[PRE65]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: What happened? We can keep editing *capitals.py*, putting `print()` statements
    in likely places, but let’s see if the debugger can help us.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？我们可以继续编辑 *capitals.py*，在可能的地方加入 `print()` 语句，但让我们看看调试器能否帮助我们。
- en: 'To use the debugger, import the `pdb` module from the command line by typing
    **`-m pdb`**, like so:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用调试器，在命令行中导入 `pdb` 模块，输入 **`-m pdb`**，像这样：
- en: '[PRE66]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This starts the program and places you at the first line. If you type **`c`**
    (*continue*), the program will run until it ends, either normally or with an error:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动程序并将您放在第一行。如果您输入 **`c`**（*继续*），程序将运行直到正常结束或出现错误：
- en: '[PRE68]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: It completed normally, just as it did when we ran it earlier outside of the
    debugger. Let’s try again, using some commands to narrow down where the problem
    lies. It seems to be a *logic error* rather than a syntax problem or exception
    (which would have printed error messages).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 它完成了正常的运行，就像我们之前在调试器之外运行时一样。让我们再试一次，使用一些命令来缩小问题所在的范围。它似乎是一个逻辑错误，而不是语法问题或异常（这会打印错误消息）。
- en: 'Type **`s`** (*step*) to single-step through Python lines. This steps through
    *all* Python code lines: yours, the standard library’s, and any other modules
    you might be using. When you use `s`, you also go into functions and single-step
    within them. Type **`n`** (*next*) to single-step but *not* to go inside functions;
    when you get to a function, a single `n` causes the entire function to execute
    and take you to the next line of your program. Thus, use `s` when you’re not sure
    where the problem is; use `n` when you’re sure that a particular function isn’t
    the cause, especially if it’s a long function. Often you’ll single-step through
    your own code and step over library code, which is presumably well tested. Let’s
    use `s` to step from the beginning of the program into the function `process_cities()`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 输入**`s`**（*step*）逐行步进Python代码。这将逐行执行所有Python代码：您的代码、标准库的代码以及您可能使用的任何其他模块。当您使用`s`时，还会进入函数并在其中逐步执行。输入**`n`**（*next*）逐行步进，但不会进入函数内部；当您到达函数时，单个`n`将导致整个函数执行并将您带到程序的下一行。因此，当您不确定问题所在时，请使用`s`；当您确信特定函数不是问题的原因时，尤其是如果它是一个长函数，请使用`n`。通常情况下，您会逐步执行自己的代码并跳过库代码，因为这些代码可能已经经过充分测试。让我们使用`s`从程序的开始步进到函数`process_cities()`：
- en: '[PRE70]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Type **`l`** (*list*) to see the next few lines of your program:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 输入**`l`**（*list*）以查看程序的下几行：
- en: '[PRE80]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The arrow (`->`) denotes the current line.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头（`->`）表示当前行。
- en: 'We could continue using `s` or `n`, hoping to spot something, but let’s use
    one of the main features of a debugger: *breakpoints*. A breakpoint stops execution
    at the line you indicate. In our case, we want to know why `process_cities()`
    bails out before it’s read all of the input lines. Line 3 (`for line in file:`)
    will read every line in the input file, so that seems innocent. The only other
    place where we could return from the function before reading all of the data is
    at line 6 (`return`). Let’s set a breakpoint on line 6:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续使用`s`或`n`，希望找到一些东西，但让我们使用调试器的一个主要功能：*断点*。断点将在您指定的行停止执行。在我们的情况下，我们想知道为什么在`process_cities()`在读取所有输入行之前退出。第3行（`for
    line in file:`）将读取输入文件中的每一行，因此看起来很无辜。我们可以在函数返回所有数据之前的唯一其他地方是在第6行（`return`）。让我们在第6行设置一个断点：
- en: '[PRE82]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Next, let’s continue the program until it either hits the breakpoint or reads
    all of the input lines and finishes normally:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们继续执行程序，直到它命中断点或正常读取所有输入行并完成：
- en: '[PRE84]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Aha! It stopped at our line 6 breakpoint. This indicates that the program wants
    to return early after reading the country after Colombia. Let’s print the value
    of `line` to see what we just read:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哈！它在我们的第6行断点处停下来了。这表明程序在读取哥伦比亚后的国家后想要早些返回。让我们打印`line`的值来查看我们刚刚读到的内容：
- en: '[PRE86]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: What’s so special about—oh, never mind.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么特别之处——哦，算了。
- en: Really? **`quit`**o? Our manager never expected the string `quit` to turn up
    inside normal data, so using it as a *sentinel* (end indicator) value like this
    was a boneheaded idea. You march right in there and tell him that—while I wait
    here.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 真的吗？我们经理从未预料到字符串`quit`会出现在正常数据中，因此将其用作*标记*（结束指示）值的想法真是愚蠢至极。你直接去那里告诉他这一点，而我在这里等着。
- en: 'If at this point you still have a job, you can see all your breakpoints by
    using a plain `b` command:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此时您仍然有工作，您可以使用普通的`b`命令查看所有断点：
- en: '[PRE88]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'An `l` will show your code lines, the current line (`->`), and any breakpoints
    (`B`). A plain `l` will start listing from the end of your previous call to `l`,
    so include the optional starting line (here, let’s start from line `1`):'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`l`将显示您的代码行、当前行（`->`）和任何断点（`B`）。普通的`l`将从您上次调用`l`的末尾开始列出，因此包括可选的起始行（这里，让我们从第`1`行开始）：
- en: '[PRE90]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: OK, as shown in [Example 19-19](#ex1919), let’s fix that `quit` test to match
    only the full line, not within other characters.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，如[示例 19-19](#ex1919)所示，让我们修复`quit`测试以仅匹配完整行，而不是其他字符中间。
- en: Example 19-19\. capitals2.py
  id: totrans-312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-19\. capitals2.py
- en: '[PRE92]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Once more, with feeling:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 再来，带点感情：
- en: '[PRE93]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: That was a skimpy overview of the debugger—just enough to show you what it can
    do and what commands you’d use most of the time.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是调试器的简要概述，足以展示它的功能及您在大部分时间内会使用的命令。
- en: 'Remember: more tests, less debugging.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：多测试，少调试。
- en: Use breakpoint()
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`breakpoint()`
- en: In Python 3.7, there’s a new built-in function called `breakpoint()`. If you
    add it to your code, a debugger will automatically start up and pause at each
    location. Without this, you would need to fire up a debugger like `pdb` and set
    breakpoints manually, as you saw earlier.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3.7 中，有一个名为 `breakpoint()` 的新内置函数。如果将其添加到您的代码中，调试器将自动启动并在每个位置暂停。如果没有这个函数，您将需要启动一个像
    `pdb` 这样的调试器，并像您之前看到的那样手动设置断点。
- en: 'The default debugger is the one you’ve just seen (`pdb`), but this can be changed
    by setting the environment variable `PYTHONBREAKPOINT`. For example, you could
    specify use of the web-based remote debugger [web-pdb](https://pypi.org/project/web-pdb):'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 默认调试器是您刚刚见过的（`pdb`），但可以通过设置环境变量 `PYTHONBREAKPOINT` 来更改。例如，您可以指定使用基于Web的远程调试器
    [web-pdb](https://pypi.org/project/web-pdb)：
- en: '[PRE95]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The official documentation is a bit dry, but there are good overviews [here](https://oreil.ly/9Q9MZ)
    and [there](https://oreil.ly/2LJKy).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 官方文档有点枯燥，但这里和那里都有很好的概述 [here](https://oreil.ly/9Q9MZ) 和 [there](https://oreil.ly/2LJKy)。
- en: Log Error Messages
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录错误消息
- en: At some point you might need to graduate from using `print()` statements to
    logging messages. A log is usually a system file that accumulates messages, often
    inserting useful information such as a timestamp or the name of the user who’s
    running the program. Often logs are *rotated* (renamed) daily and compressed;
    by doing so, they don’t fill up your disk and cause problems themselves. When
    something goes wrong with your program, you can look at the appropriate log file
    to see what happened. The contents of exceptions are especially useful in logs
    because they show you the actual line at which your program croaked, and why.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些时候，您可能需要从使用 `print()` 语句转向日志消息。日志通常是累积消息的系统文件，通常会插入有用的信息，例如时间戳或运行程序的用户名称。通常日志会按日进行“轮换”（重命名）并进行压缩；通过这样做，它们不会填满您的磁盘并引发问题。当程序出现问题时，您可以查看适当的日志文件以了解发生了什么。异常的内容在日志中特别有用，因为它们显示了程序实际崩溃的行和原因。
- en: 'The standard Python library module is [`logging`](http://bit.ly/py-logging).
    I’ve found most descriptions of it somewhat confusing. After a while it makes
    more sense, but it does seem overly complicated at first. The `logging` module
    includes these concepts:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 Python 库模块是 [`logging`](http://bit.ly/py-logging)。我发现大多数对它的描述有点令人困惑。过了一会儿就会清楚些，但一开始确实看起来过于复杂。`logging`
    模块包括这些概念：
- en: The *message* that you want to save to the log
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您要保存到日志的*消息*
- en: 'Ranked priority *levels* and matching functions: `debug()`, `info()`, `warn()`,
    `error()`, and `critical()`'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排名优先级*级别*及其匹配功能：`debug()`、`info()`、`warn()`、`error()` 和 `critical()`
- en: One or more *logger* objects as the main connection with the module
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个作为与模块的主要连接的*记录器*对象
- en: '*Handlers* that direct the message to your terminal, a file, a database, or
    somewhere else'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将消息定向到您的终端、文件、数据库或其他位置的*处理程序*
- en: '*Formatters* that create the output'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成输出的*格式化程序*
- en: '*Filters* that make decisions based on the input'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据输入进行决策的*过滤器*
- en: 'For the simplest logging example, just import the module and use some of its
    functions:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最简单的日志示例，只需导入模块并使用其中的一些函数：
- en: '[PRE96]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Did you notice that `debug()` and `info()` didn’t do anything, and the other
    two printed *LEVEL*:`root`: before each message? So far, it’s like a `print()`
    statement with multiple personalities, some of them hostile.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否注意到 `debug()` 和 `info()` 没有执行任何操作，而其他两个在每条消息之前打印了*LEVEL*:`root`？到目前为止，它就像具有多重人格的
    `print()` 语句，其中一些是敌对的。
- en: But it is useful. You can scan for a particular value of *LEVEL* in a log file
    to find particular messages, compare timestamps to see what happened before your
    server crashed, and so on.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 但它很有用。您可以在日志文件中扫描特定*级别*的特定消息，比较时间戳以查看服务器崩溃前发生了什么等等。
- en: 'A lot of digging through the documentation answers the first mystery (we get
    to the second one in a page or two): the default priority *level* is `WARNING`,
    and that got locked in as soon as we called the first function (`logging.debug()`).
    We can set the default level by using `basicConfig()`. `DEBUG` is the lowest level,
    so this enables it and all the higher levels to flow through:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 大量查阅文档解答了第一个谜团（我们在一页或两页内到达第二个谜团）：默认优先级*级别*为 `WARNING`，并且在我们调用第一个函数（`logging.debug()`）时已经锁定。我们可以使用
    `basicConfig()` 设置默认级别。`DEBUG` 是最低级别，因此启用它将使所有更高级别的消息都可以流经：
- en: '[PRE97]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'We did all that with the default `logging` functions without actually creating
    a *logger* object. Each logger has a name. Let’s make one called `bunyan`:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在没有实际创建 *logger* 对象的情况下使用了默认的 `logging` 函数。每个日志记录器都有一个名称。让我们创建一个名为 `bunyan`
    的日志记录器：
- en: '[PRE98]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: If the logger name contains any dot characters, they separate levels of a hierarchy
    of loggers, each with potentially different properties. This means that a logger
    named `quark` is higher than one named `quark.charmed`. The special *root logger*
    is at the top and is called `''`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果日志记录器名称包含任何点字符，它们会分隔成一个层次结构的日志记录器，每个可能具有不同的属性。这意味着命名为 `quark` 的日志记录器高于命名为
    `quark.charmed` 的日志记录器。特殊的 *root logger* 处于顶层，称为 `''`。
- en: 'So far, we’ve just printed messages, which is not a great improvement over
    `print()`. We use *handlers* to direct the messages to different places. The most
    common is a *log file*, and here’s how you do it:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是打印了一些消息，这与 `print()` 没有太大的改进。我们使用 *handlers* 将消息定向到不同的位置。最常见的是 *log
    file*，下面是如何做的：
- en: '[PRE99]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Aha! The lines aren’t on the screen anymore; instead, they’re in the file named
    *blue_ox.log*:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哈！现在屏幕上没有这些行了；它们都在名为 *blue_ox.log* 的文件中：
- en: '[PRE100]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Calling `basicConfig()` with a `filename` argument created a `FileHandler` for
    you and made it available to your logger. The `logging` module includes at least
    15 handlers to send messages to places such as email and web servers as well as
    the screen and files.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `filename` 参数调用 `basicConfig()` 为您创建了一个 `FileHandler` 并使其对您的日志记录器可用。`logging`
    模块至少包含 15 个处理程序，可将消息发送到诸如电子邮件和 Web 服务器以及屏幕和文件等位置。
- en: 'Finally, you can control the *format* of your logged messages. In our first
    example, our default gave us something similar to this:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以控制所记录的消息的 *format*。在我们的第一个例子中，默认值给了我们类似于这样的东西：
- en: '[PRE101]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'If you provide a `format` string to `basicConfig()`, you can change to the
    format of your preference:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您向 `basicConfig()` 提供了一个 `format` 字符串，您可以更改为自己喜欢的格式：
- en: '[PRE102]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: We let the logger send output to the screen again, but changed the format.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们让日志记录器再次将输出发送到屏幕，但是更改了格式。
- en: The `logging` module recognizes a number of variable names in the `fmt` format
    string. We used `asctime` (date and time as an ISO 8601 string), `levelname`,
    `lineno` (line number), and the `message` itself. There are other built-ins, and
    you can provide your own variables, as well.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`logging` 模块在 `fmt` 格式字符串中识别多个变量名。我们使用了 `asctime`（日期和时间作为 ISO 8601 字符串）、`levelname`、`lineno`（行号）和消息本身。还有其他内置的变量，并且您可以提供自己的变量。'
- en: There’s much more to `logging` than this little overview can provide. You can
    log to more than one place at the same time, with different priorities and formats.
    The package has a lot of flexibility but sometimes at the cost of simplicity.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`logging` 的内容远远不止这个小概述所能提供的。您可以同时记录到多个位置，具有不同的优先级和格式。该包具有很大的灵活性，但有时会牺牲简单性。'
- en: Optimize
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化
- en: Python is usually fast enough—until it isn’t. In many cases, you can gain speed
    by using a better algorithm or data structure. The trick is knowing where to do
    this. Even experienced programmers guess wrong surprisingly often. You need to
    be like the careful quiltmaker and measure before you cut. And this leads us to
    *timers*.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: Python 通常足够快——直到它不快。在许多情况下，您可以通过使用更好的算法或数据结构来提高速度。关键在于知道在哪里做这些优化。即使是经验丰富的程序员也会出错得惊人。您需要像细心的被子裁缝一样，在裁剪之前进行测量。这也引出了
    *timers*。
- en: Measure Timing
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量时间
- en: You’ve seen that the `time()` function in the `time` module returns the current
    epoch time as a floating-point number of seconds. A quick way of timing something
    is to get the current time, do something, get the new time, and then subtract
    the original time from the new time. Let’s write this up, as presented in [Example 19-20](#ex1920),
    and call it (what else?) *time1.py*.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`time()` 函数位于 `time` 模块中，返回当前的时间戳作为一个浮点数秒数。要快速计时某事物，可以获取当前时间，执行某些操作，获取新的时间，然后用新时间减去原始时间。我们将按照
    [Example 19-20](#ex1920) 中的方式编写它，并命名为（当然是）*time1.py*。'
- en: Example 19-20\. time1.py
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 19-20\. time1.py
- en: '[PRE103]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'In this example, we’re measuring the time it takes to assign the value `5`
    to the name `num` and multiply it by `2`. This is *not* a realistic benchmark,
    just an example of how to measure some arbitrary Python code. Try running it a
    few times, just to see how much it can vary:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们测量将值 `5` 赋给名称 `num` 并将其乘以 `2` 所需的时间。这并不是一个现实的基准测试，只是展示如何测量任意 Python
    代码的示例。试着运行几次，看看它的变化：
- en: '[PRE104]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: That was about two or three millionths of a second. Let’s try something slower,
    such as `sleep()`.^([2](ch19.html#idm45794965496488)) If we sleep for a second,
    our timer should take a tiny bit more than a second. [Example 19-21](#ex1921)
    shows the code; save this as *time2.py*.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 那大约是两三百万分之一秒。让我们尝试一些更慢的东西，比如`sleep()`。^([2](ch19.html#idm45794965496488)) 如果我们睡一秒，我们的计时器应该需要超过一秒钟的微小时间。[示例 19-21](#ex1921)展示了代码；将其保存为*time2.py*。
- en: Example 19-21\. time2.py
  id: totrans-363
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-21\. time2.py
- en: '[PRE105]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Let’s be certain of our results, so run it a few times:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确定我们的结果，所以运行几次：
- en: '[PRE106]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: As expected, it takes about a second to run. If it didn’t, either our timer
    or `sleep()` should be embarrassed.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，它大约需要一秒钟才能运行。如果没有，要么我们的计时器，要么`sleep()`应该感到尴尬。
- en: 'There’s a handier way to measure code snippets like this: using the standard
    module [`timeit`](http://bit.ly/py-timeit). It has a function called (you guessed
    it) `timeit()`, which will do *count* runs of your test *code* and print some
    results. The syntax is: ``timeit.timeit(*`code`*``, ``number=*`count`*)``.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种更方便的方法来测量像这样的代码片段：使用标准模块[`timeit`](http://bit.ly/py-timeit)。它有一个名为（你猜对了）`timeit()`
    的函数，它将对你的测试*代码*进行*count*次运行并打印一些结果。语法是：``timeit.timeit(*`code`*``, ``number=*`count`*)``。
- en: In the examples in this section, the `code` needs to be within quotes so that
    it is not executed after you press the Return key but is executed inside `timeit()`.
    (In the next section, you’ll see how to time a function by passing its name to
    `timeit()`.) Let’s run our previous example just once and time it. Call this file
    *timeit1.py* ([Example 19-22](#ex1922)).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的示例中，`code`需要放在引号中，这样在按下Return键后它不会被执行，但是会在`timeit()`内执行。（在下一节中，您将看到如何通过将其名称传递给`timeit()`来计时一个函数。）让我们只运行一次我们之前的示例并计时它。将此文件命名为*timeit1.py*（[示例 19-22](#ex1922)）。
- en: Example 19-22\. timeit1.py
  id: totrans-370
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-22\. timeit1.py
- en: '[PRE107]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Run it a few times:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 运行几次：
- en: '[PRE108]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Again, these two code lines ran in about two millionths of a second. We can
    use the `repeat` argument of the `timeit` module’s `repeat()` function to run
    more sets. Save this as *timeit2.py* ([Example 19-23](#ex1923)).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这两行代码大约运行了两百万分之一秒。我们可以使用`timeit`模块的`repeat()`函数的`repeat`参数来运行更多的集合。将其保存为*timeit2.py*（[示例 19-23](#ex1923)）。
- en: Example 19-23\. timeit2.py
  id: totrans-375
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-23\. timeit2.py
- en: '[PRE109]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Try running it to see what transpires:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行它看看会发生什么：
- en: '[PRE110]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The first run took two millionths of a second, and the second and third runs
    were faster. Why? There could be many reasons. For one thing, we’re testing a
    very small piece of code, and its speed could depend on what else the computer
    was doing in those instants, how the Python system optimizes calculations, and
    many other things.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行花费了两百万分之一秒，第二次和第三次运行更快。为什么？原因可能有很多。首先，我们正在测试一小段代码，它的速度可能取决于计算机在这些瞬间正在做什么，Python系统如何优化计算以及许多其他因素。
- en: Using `timeit()` meant wrapping the code you’re trying to measure as a string.
    What if you have multiple lines of code? You could pass it a triple-quoted multiline
    string, but that might be hard to read.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`timeit()`意味着将要测量的代码包装为字符串。如果您有多行代码怎么办？您可以传递一个三引号的多行字符串，但这可能很难阅读。
- en: Let’s define a lazy `snooze()` function that nods off for a second, as we all
    do occasionally.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个懒惰的`snooze()`函数，偶尔打个盹，就像我们所有人偶尔做的那样。
- en: 'First, we can wrap the `snooze()` function itself. We need to include the arguments
    `globals=globals()` (this helps Python to find `snooze`) and `number=1` (run it
    only once; the default is 1000000, and we don’t have that much time):'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以包装`snooze()`函数本身。我们需要包括参数`globals=globals()`（这有助于Python找到`snooze`）和`number=1`（仅运行一次；默认为1000000，我们没有那么多时间）：
- en: '[PRE111]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Or, we can use a decorator:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用一个装饰器：
- en: '[PRE112]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Another way is to use a context manager:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用上下文管理器：
- en: '[PRE113]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The `__exit()__` method takes three extra arguments that we don’t use here;
    we could have used `*args` in their place.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`__exit()__` 方法需要三个我们在这里不使用的额外参数；我们可以使用 `*args` 来代替它们。'
- en: Okay, we’ve seen many ways to do timing. Now, let’s time some code to compare
    the efficiency of different algorithms (program logic) and data structures (storage
    mechanisms).
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经看到了许多计时的方法。现在，让我们计时一些代码，以比较不同算法（程序逻辑）和数据结构（存储机制）的效率。
- en: Algorithms and Data Structures
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算法和数据结构
- en: The [Zen of Python](http://bit.ly/zen-py) declares that *There should be one—and
    preferably only one—obvious way to do it*. Unfortunately, sometimes it isn’t obvious,
    and you need to compare alternatives. For example, is it better to use a `for`
    loop or a list comprehension to build a list? And what do we mean by *better*?
    Is it faster, easier to understand, using less memory, or more “Pythonic”?
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '[Python之禅](http://bit.ly/zen-py)提出*做一件事应该有一种——最好只有一种——显而易见的方法*。不幸的是，有时候这并不明显，你需要比较不同的选择。例如，使用`for`循环还是列表推导来构建列表更好？而*更好*的意思是什么？是更快，更容易理解，使用更少的内存，还是更符合Python风格？'
- en: In this next exercise, we build a list in different ways, comparing speed, readability,
    and Python style. Here’s *time_lists.py* ([Example 19-24](#ex1924)).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们以不同的方式构建列表，比较速度、可读性和Python风格。这是*time_lists.py*的例子([示例 19-24](#ex1924))。
- en: Example 19-24\. time_lists.py
  id: totrans-393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-24\. time_lists.py
- en: '[PRE114]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'In each function, we add 1,000 items to a list, and we call each function 1,000
    times. Notice that in this test we called `timeit()` with the function name as
    the first argument rather than code as a string. Let’s run it:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个函数中，我们向列表添加1,000个项目，并调用每个函数1,000次。请注意，在这个测试中，我们将`timeit()`的第一个参数作为函数名而不是作为字符串代码来调用。让我们运行它：
- en: '[PRE115]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The list comprehension is at least twice as fast as adding items to the list
    by using `append()`. In general, comprehensions are faster than manual construction.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导至少比使用`append()`添加项到列表快两倍。总体上，列表推导比手动构建更快。
- en: Use these ideas to make your own code faster.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这些想法使你的代码更快。
- en: Cython, NumPy, and C Extensions
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cython、NumPy和C扩展
- en: If you’re pushing Python as hard as you can and still can’t get the performance
    you want, you have yet more options.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尽了最大努力仍然无法获得想要的性能，你还有更多的选择。
- en: '[Cython](http://cython.org) is a hybrid of Python and C, designed to translate
    Python with some performance annotations to compiled C code. These annotations
    are fairly small, like declaring the types of some variables, function arguments,
    or function returns. For scientific-style loops of numeric calculations, adding
    these hints will make them much faster—as much as a thousand times faster. See
    [the Cython wiki](https://oreil.ly/MmW_v) for documentation and examples.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '[Cython](http://cython.org)是Python和C的混合体，旨在通过一些性能注释将Python代码翻译成编译的C代码。这些注释相对较少，比如声明一些变量的类型、函数参数或函数返回类型。对于科学计算中的数值计算循环，添加这些提示将使它们快得多——高达一千倍。详见[Cython
    wiki](https://oreil.ly/MmW_v)获取文档和示例。'
- en: You can read much more about NumPy in [Chapter 22](ch22.html#ch_science). It’s
    a Python math library, written in C for speed.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[第22章](ch22.html#ch_science)中深入了解NumPy。它是一个用C语言编写以提高速度的Python数学库。
- en: Many parts of Python and its standard library are written in C for speed and
    wrapped in Python for convenience. These hooks are available to you for your applications.
    If you know C and Python and really want to make your code fly, writing a C extension
    is harder, but the improvements can be worth the trouble.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: Python及其标准库的许多部分为了速度而用C编写，并包装在Python中供方便使用。这些挂钩可以用于你的应用程序。如果你了解C和Python，并且真的想让你的代码快速运行，编写C扩展虽然更难，但改进可能是值得的。
- en: PyPy
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyPy
- en: When Java first appeared about 20 years ago, it was as slow as an arthritic
    Schnauzer. When it started to mean real money to Sun and other companies, though,
    they put millions into optimizing the Java interpreter and the underlying Java
    virtual machine (JVM), borrowing techniques from earlier languages like Smalltalk
    and LISP. Microsoft likewise put great effort into optimizing its rival C# language
    and .NET VM.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 当Java大约20年前首次出现时，它慢得像一只关节炎的雪纳瑞。然而，当它开始给Sun等公司带来真正的利润时，他们投入了数百万美元来优化Java解释器和底层的Java虚拟机（JVM），借鉴了Smalltalk和LISP等早期语言的技术。微软同样致力于优化其竞争对手C#语言和.NET虚拟机。
- en: No one owns Python, so no one has pushed that hard to make it faster. You’re
    probably using the standard Python implementation. It’s written in C, and often
    called CPython (not the same as Cython).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人拥有Python，所以没有人努力使其更快。你可能正在使用标准的Python实现。它是用C语言编写的，通常称为CPython（不同于Cython）。
- en: Like PHP, Perl, and even Java, Python is not compiled to machine language, but
    translated to an intermediate language (with names such as *bytecode* or p-code)
    which is then interpreted in a *virtual machine*.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 像PHP、Perl甚至Java一样，Python并不会被编译成机器语言，而是被翻译成一个中间语言（如*字节码*或p-码），然后在*虚拟机*中解释。
- en: '[PyPy](http://pypy.org) is a new Python interpreter that applies some of the
    tricks that sped up Java. Its [benchmarks](http://speed.pypy.org) show that PyPy
    is faster than CPython in every test—more than six times faster on average, and
    up to 20 times faster in some cases. It works with Python 2 and 3. You can download
    it and use it instead of CPython. PyPy is constantly being improved, and it might
    even replace CPython some day. Read the latest release notes on the site to see
    whether it could work for your purposes.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '[PyPy](http://pypy.org)是一个新的Python解释器，应用了一些加速Java的技巧。其[基准测试](http://speed.pypy.org)显示，PyPy在每个测试中都比CPython快——平均快六倍以上，在某些情况下甚至快20倍。它适用于Python
    2和3。你可以下载并使用它来替代CPython。PyPy在不断改进，甚至有可能取代CPython。请查看网站上的最新发布说明，了解它是否适合您的需求。'
- en: Numba
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Numba
- en: You can use [Numba](http://numba.pydata.org) to compile your Python code on
    the fly to machine code and speed it up.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用[Numba](http://numba.pydata.org)来即时将您的Python代码编译成机器码并加速它。
- en: 'Install with the usual:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通常的安装方法：
- en: '[PRE117]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Let’s first time a normal Python function that calculates a hypotenuse:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一个普通的Python函数，计算斜边：
- en: '[PRE118]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Use the `@jit` decorator to speed up calls after the first:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在首次调用后使用`@jit`装饰器加速调用。
- en: '[PRE119]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Use `@jit(nopython=True)` to avoid the overhead of the normal Python interpreter:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@jit(nopython=True)`可以避免普通Python解释器的开销：
- en: '[PRE120]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Numba is especially useful with NumPy and other mathematically demanding packages.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: Numba在NumPy和其他数学需求严格的包中特别有用。
- en: Source Control
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码管理
- en: When you’re working on a small group of programs, you can usually keep track
    of your changes—until you make a boneheaded mistake and clobber a few days of
    work. Source control systems help protect your code from dangerous forces, like
    you. If you work with a group of developers, source control becomes a necessity.
    There are many commercial and open source packages in this area. The most popular
    in the open source world where Python lives are Mercurial and Git. Both are examples
    of *distributed* version control systems, which produce multiple copies of code
    repositories. Earlier systems such as Subversion run on a single server.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 当您处理一小组程序时，通常可以跟踪您的更改，直到您犯了一个愚蠢的错误并且破坏了几天的工作。源代码管理系统有助于保护您的代码免受像您这样的危险力量的侵害。如果您与一组开发人员合作，源代码管理就成为必需品。在Python生态中，最流行的开源世界中，Mercurial和Git是最受欢迎的示例。它们都是*分布式*版本控制系统的例子，可以生成代码仓库的多个副本。早期的系统如Subversion在单一服务器上运行。
- en: Mercurial
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mercurial
- en: '[Mercurial](http://mercurial-scm.org) is written in Python. It’s fairly easy
    to learn, with a handful of subcommands to download code from a Mercurial repository,
    add files, check in changes, and merge changes from different sources. [bitbucket](https://bitbucket.org)
    and [other sites](http://bit.ly/merc-host) offer free or commercial hosting.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '[Mercurial](http://mercurial-scm.org)是用Python编写的。它相当容易学习，有一些子命令可以从Mercurial仓库下载代码，添加文件，提交更改，以及合并来自不同来源的更改。[bitbucket](https://bitbucket.org)和[其他网站](http://bit.ly/merc-host)提供免费或商业托管服务。'
- en: Git
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git
- en: '[Git](http://git-scm.com) was originally written for Linux kernel development,
    but now dominates open source in general. It’s similar to Mercurial, although
    some find it slightly trickier to master. [GitHub](http://github.com) is the largest
    git host, with more than a million repositories, but there are [many other hosts](http://bit.ly/githost-scm).'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '[Git](http://git-scm.com)最初是为Linux内核开发编写的，但现在在开源社区中普遍存在。它类似于Mercurial，尽管有些人觉得它稍微难以掌握。[GitHub](http://github.com)是最大的git主机，拥有超过一百万个仓库，但也有[许多其他主机](http://bit.ly/githost-scm)。'
- en: 'The standalone program examples in this book are available in a public Git
    repository at [GitHub](https://oreil.ly/U2Rmy). If you have the `git` program
    on your computer, you can download these programs by using this command:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的独立程序示例可以在[GitHub](https://oreil.ly/U2Rmy)的公共Git仓库中找到。如果您的计算机上有`git`程序，可以使用以下命令下载这些程序：
- en: '[PRE121]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'You can also download the code from the GitHub page:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以从GitHub页面下载代码：
- en: Click “Clone in Desktop” to open your computer’s version of `git`, if installed.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单击“在桌面上克隆”以打开安装了的`git`的计算机版本。
- en: Click “Download ZIP” to get a zipped archive of the programs.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单击“下载ZIP”获取程序的压缩归档文件。
- en: If you don’t have `git` but would like to try it, read the [installation guide](http://bit.ly/git-install).
    I talk about the command-line version here, but you might be interested in sites
    such as GitHub that have extra services and might be easier to use in some cases;
    `git` has many features, but is not always intuitive.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有`git`但想尝试一下，可以阅读[安装指南](http://bit.ly/git-install)。我在这里讨论的是命令行版本，但你可能对GitHub等网站感兴趣，它们提供额外的服务，在某些情况下可能更容易使用；`git`有许多功能，但并不总是直观的。
- en: Let’s take `git` for a test drive. We won’t go far, but the ride will show a
    few commands and their output.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试驾一下`git`。我们不会走得很远，但这次旅行将展示一些命令及其输出。
- en: 'Make a new directory and change to it:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的目录并切换到该目录：
- en: '[PRE122]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Create a local Git repository in your current directory *newdir*:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前目录*newdir*中创建一个本地的Git仓库：
- en: '[PRE123]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Create a Python file called *test.py*, shown in [Example 19-25](#ex1925), with
    these contents in *newdir*.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在*newdir*中创建一个名为*test.py*的Python文件，如[示例 19-25](#ex1925)所示，其内容如下。
- en: Example 19-25\. test.py
  id: totrans-440
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-25\. test.py
- en: '[PRE125]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Add the file to the Git repository:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件添加到Git仓库中：
- en: '[PRE126]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: What do you think of that, Mr. Git?
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 你觉得怎么样，Git先生？
- en: '[PRE127]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'This means that *test.py* is part of the local repository but its changes have
    not yet been committed. Let’s *commit* it:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着*test.py*是本地仓库的一部分，但其更改尚未提交。让我们来*提交*它：
- en: '[PRE129]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: That `-m "my first commit"` was your *commit message*. If you omitted that,
    `git` would pop you into an editor and coax you to enter the message that way.
    This becomes a part of the `git` change history for that file.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 那个`-m "my first commit"`是你的*提交消息*。如果你省略了这一点，`git`将弹出一个编辑器，引导你以这种方式输入消息。这成为该文件的`git`更改历史的一部分。
- en: 'Let’s see what our current status is:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们当前的状态：
- en: '[PRE131]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Okay, all current changes have been committed. This means that we can change
    things and not worry about losing the original version. Make an adjustment now
    to *test.py*—change `Oops` to `Ops!` and save the file ([Example 19-26](#ex1926)).
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所有当前的更改已经提交。这意味着我们可以更改东西而不必担心丢失原始版本。现在调整一下*test.py*—将`Oops`改为`Ops!`并保存文件（[示例 19-26](#ex1926)）。
- en: Example 19-26\. test.py, revised
  id: totrans-455
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 19-26\. test.py，修订版
- en: '[PRE133]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Let’s check to see what `git` thinks now:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看现在`git`的想法：
- en: '[PRE134]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Use `git diff` to see what lines have changed since the last commit:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`git diff`查看自上次提交以来更改了哪些行：
- en: '[PRE136]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'If you try to commit this change now, `git` complains:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在尝试提交这个更改，`git`会抱怨：
- en: '[PRE138]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'That `staged for commit` phrase means you need to `add` the file, which roughly
    translated means *hey git, look over here*:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 那个`staged for commit`短语意味着你需要`add`这个文件，大致翻译过来就是*嘿，git，看这里*：
- en: '[PRE140]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'You could have also typed `git add .` to add *all* changed files in the current
    directory; that’s handy when you actually have edited multiple files and want
    to ensure that you check in all their changes. Now we can commit the change:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以键入`git add .`来添加当前目录中所有已更改的文件；当你实际上已经编辑了多个文件并希望确保检查所有更改时，这非常方便。现在我们可以提交更改：
- en: '[PRE141]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'If you’d like to see all the terrible things that you’ve done to *test.py*,
    most recent first, use `git log`:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要查看所有对*test.py*做过的可怕的事情（最近的在前），使用`git log`命令：
- en: '[PRE143]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Distribute Your Programs
  id: totrans-474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发你的程序
- en: You know that your Python files can be installed in files and directories, and
    you know that you can run a Python program file with the `python` interpreter.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道你的Python文件可以安装在文件和目录中，你知道可以使用`python`解释器运行Python程序文件。
- en: It’s less well known that the Python interpreter can also execute Python code
    packaged in ZIP files. It’s even less well known that special ZIP files known
    as [pex files](https://pex.readthedocs.io) can also be used.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 较少人知道Python解释器还可以执行打包在ZIP文件中的Python代码。甚至更少人知道特殊的ZIP文件（称为[pex文件](https://pex.readthedocs.io)）也可以使用。
- en: Clone This Book
  id: totrans-477
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 克隆本书
- en: You can get a copy of all the programs in this book. Visit the [Git repository](https://oreil.ly/FbFAE)
    and follow the directions to copy it to your local machine. If you have `git`,
    run the command `git clone https://github.com/madscheme/introducing-python` to
    make a Git repository on your computer. You can also download the files in ZIP
    format.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以获取本书中所有程序的副本。访问[Git仓库](https://oreil.ly/FbFAE)并按照说明将其复制到本地计算机。如果你有`git`，运行命令`git
    clone https://github.com/madscheme/introducing-python`在你的计算机上创建一个Git仓库。你也可以以ZIP格式下载这些文件。
- en: How You Can Learn More
  id: totrans-479
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何进一步学习
- en: This is an introduction. It almost certainly says too much about some things
    that you don’t care about and not enough about some things that you do. Let me
    recommend some Python resources that I’ve found helpful.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简介。它几乎肯定对一些你不关心的事情说得太多，对一些你关心的事情说得不够。让我推荐一些我发现有用的 Python 资源。
- en: Books
  id: totrans-481
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 书籍
- en: 'I’ve found the books in the following list to be especially useful. These range
    from introductory to advanced, with mixtures of Python 2 and 3:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现以下列表中的书籍特别有用。这些书籍从入门到高级，混合了 Python 2 和 3：
- en: Barry, Paul. *Head First Python (2nd Edition)* O’Reilly, 2016.
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Barry, Paul. *Head First Python (2nd Edition)* O’Reilly, 2016.
- en: Beazley, David M. *Python Essential Reference (5th Edition)*. Addison-Wesley,
    2019.
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Beazley, David M. *Python Essential Reference (5th Edition)*. Addison-Wesley,
    2019.
- en: Beazley, David M. and Brian K. Jones. *Python Cookbook (3rd Edition)*. O’Reilly,
    2013.
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Beazley, David M. and Brian K. Jones. *Python Cookbook (3rd Edition)*. O’Reilly,
    2013.
- en: Gorelick, Micha and Ian Ozsvald. *High Performance Python*. O’Reilly, 2014.
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gorelick, Micha and Ian Ozsvald. *High Performance Python*. O’Reilly, 2014.
- en: Maxwell, Aaron. *Powerful Python*. Powerful Python Press, 2017.
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maxwell, Aaron. *Powerful Python*. Powerful Python Press, 2017.
- en: 'McKinney, Wes. *Python for Data Analysis: Data Wrangling with Pandas, NumPy,
    and IPython*. O’Reilly, 2012.'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'McKinney, Wes. *Python for Data Analysis: Data Wrangling with Pandas, NumPy,
    and IPython*. O’Reilly, 2012.'
- en: Ramalho, Luciano. *Fluent Python*. O’Reilly, 2015.
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ramalho, Luciano. *Fluent Python*. O’Reilly, 2015.
- en: Reitz, Kenneth and Tanya Schlusser. *The Hitchhiker’s Guide to Python*. O’Reilly,
    2016.
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reitz, Kenneth and Tanya Schlusser. *The Hitchhiker’s Guide to Python*. O’Reilly,
    2016.
- en: Slatkin, Brett. *Effective Python*. Addison-Wesley, 2015.
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Slatkin, Brett. *Effective Python*. Addison-Wesley, 2015.
- en: 'Summerfield, Mark. *Python in Practice: Create Better Programs Using Concurrency,
    Libraries, and Patterns*. Addison-Wesley, 2013.'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Summerfield, Mark. *Python in Practice: Create Better Programs Using Concurrency,
    Libraries, and Patterns*. Addison-Wesley, 2013.'
- en: Of course, there are [many more](https://wiki.python.org/moin/PythonBooks).
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有[更多](https://wiki.python.org/moin/PythonBooks)。
- en: Websites
  id: totrans-494
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网站
- en: 'Here are some websites where you can find helpful tutorials:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你可以找到有用教程的网站：
- en: '[Python for You and Me](https://pymbook.readthedocs.io) is an introduction,
    with good Windows coverage'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Python for You and Me](https://pymbook.readthedocs.io) 是一本介绍书，有很好的 Windows
    覆盖率'
- en: '[Real Python](http://realpython.com) by various authors'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Real Python](http://realpython.com) by various authors'
- en: '[Learn Python the Hard Way](http://learnpythonthehardway.org/book) by Zed Shaw'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Learn Python the Hard Way](http://learnpythonthehardway.org/book) by Zed Shaw'
- en: '[Dive into Python 3](https://oreil.ly/UJcGM) by Mark Pilgrim'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Dive into Python 3](https://oreil.ly/UJcGM) by Mark Pilgrim'
- en: '[Mouse Vs. Python](http://www.blog.pythonlibrary.org) by Michael Driscoll'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Mouse Vs. Python](http://www.blog.pythonlibrary.org) by Michael Driscoll'
- en: 'If you’re interested in keeping up with what’s going on in the Pythonic world,
    check out these news websites:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对跟上 Python 世界发展感兴趣，可以查看这些新闻网站：
- en: '[comp.lang.python](http://bit.ly/comp-lang-python)'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[comp.lang.python](http://bit.ly/comp-lang-python)'
- en: '[comp.lang.python.announce](http://bit.ly/comp-lang-py-announce)'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[comp.lang.python.announce](http://bit.ly/comp-lang-py-announce)'
- en: '[r/python subreddit](http://www.reddit.com/r/python)'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[r/python subreddit](http://www.reddit.com/r/python)'
- en: '[Planet Python](http://planet.python.org/)'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Planet Python](http://planet.python.org/)'
- en: 'Finally, here are some good websites for finding and downloading packages:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是一些寻找和下载包的好网站：
- en: '[The Python Package Index](https://pypi.python.org/pypi)'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[The Python Package Index](https://pypi.python.org/pypi)'
- en: '[Awesome Python](https://awesome-python.com)'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Awesome Python](https://awesome-python.com)'
- en: '[Stack Overflow Python questions](https://oreil.ly/S1vEL)'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Stack Overflow Python questions](https://oreil.ly/S1vEL)'
- en: '[ActiveState Python recipes](http://code.activestate.com/recipes/langs/python)'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ActiveState Python recipes](http://code.activestate.com/recipes/langs/python)'
- en: '[Python packages trending on GitHub](https://github.com/trending?l=python)'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Python packages trending on GitHub](https://github.com/trending?l=python)'
- en: Groups
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Groups
- en: 'Computing communities have varied personalities: enthusiastic, argumentative,
    dull, hipster, button-down, and many others across a broad range. The Python community
    is friendly and civil. You can find Python groups based on location—[meetups](http://python.meetup.com)
    and local user groups [around the world](https://wiki.python.org/moin/LocalUserGroups).
    Other groups are distributed and based on common interests. For instance, [PyLadies](http://www.pyladies.com)
    is a support network for women who are interested in Python and open source.'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机社区有各种各样的个性：热情洋溢、好争辩、沉闷、时髦、正式等等。Python 社区友好且文明。你可以根据地理位置找到基于 Python 的小组—[meetups](http://python.meetup.com)
    和世界各地的本地用户组[LocalUserGroups](https://wiki.python.org/moin/LocalUserGroups)。其他群体是分布式的，基于共同的兴趣。例如，[PyLadies](http://www.pyladies.com)
    是一个支持对 Python 和开源感兴趣的女性的网络。
- en: Conferences
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Conferences
- en: Of the many [conferences](http://www.pycon.org) and workshops [around the world](https://www.python.org/community/workshops),
    the largest are held annually in [North America](https://us.pycon.org) and [Europe](https://europython.eu/en).
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多[会议](http://www.pycon.org)和[世界各地的研讨会](https://www.python.org/community/workshops)中，最大的年度活动分别在[北美](https://us.pycon.org)和[欧洲](https://europython.eu/en)举行。
- en: Getting a Python Job
  id: totrans-516
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取 Python 工作
- en: 'Useful search sites include:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 有用的搜索网站包括：
- en: '[Indeed](https://www.indeed.com)'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Indeed](https://www.indeed.com)'
- en: '[Stack Overflow](https://stackoverflow.com/jobs)'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Stack Overflow](https://stackoverflow.com/jobs)'
- en: '[ZipRecruiter](https://www.ziprecruiter.com/candidate/suggested-jobs)'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ZipRecruiter](https://www.ziprecruiter.com/candidate/suggested-jobs)'
- en: '[Simply Hired](https://www.simplyhired.com)'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Simply Hired](https://www.simplyhired.com)'
- en: '[CareerBuilder](https://www.careerbuilder.com)'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CareerBuilder](https://www.careerbuilder.com)'
- en: '[Google](https://www.google.com/search?q=jobs)'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Google](https://www.google.com/search?q=jobs)'
- en: '[LinkedIn](https://www.linkedin.com/jobs/search)'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[领英](https://www.linkedin.com/jobs/search)'
- en: 'For most of these sites, type `python` in the first box and your location in
    the other. Good local sites include the Craigslist ones, like this link for [Seattle](https://seattle.craigslist.org/search/jjj).
    Simply change the `seattle` part to `sfbay`, `boston`, `nyc`, or other craigslist
    site prefixes to search those areas. For remote (telecommuting, or “work from
    home”) Python jobs, special sites include:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数这些网站，请在第一个框中键入`python`，在另一个框中输入您的位置。像这样的好地方包括像这个链接一样的Craigslist，用于[西雅图](https://seattle.craigslist.org/search/jjj)。只需将`seattle`部分更改为`sfbay`、`boston`、`nyc`或其他
    Craigslist 网站前缀以搜索这些地区。对于远程（远程工作或“在家工作”）Python 工作，特殊网站包括：
- en: '[Indeed](https://oreil.ly/pFQwb)'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Indeed](https://oreil.ly/pFQwb)'
- en: '[Google](https://oreil.ly/LI529)'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Google](https://oreil.ly/LI529)'
- en: '[LinkedIn](https://oreil.ly/nhV6s)'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[领英](https://oreil.ly/nhV6s)'
- en: '[Stack Overflow](https://oreil.ly/R23Tx)'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Stack Overflow](https://oreil.ly/R23Tx)'
- en: '[Remote Python](https://oreil.ly/bPW1I)'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[远程 Python](https://oreil.ly/bPW1I)'
- en: '[We Work Remotely](https://oreil.ly/9c3sC)'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[我们远程办公](https://oreil.ly/9c3sC)'
- en: '[ZipRecruiter](https://oreil.ly/ohwAY)'
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ZipRecruiter](https://oreil.ly/ohwAY)'
- en: '[Glassdoor](https://oreil.ly/tK5f5)'
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Glassdoor](https://oreil.ly/tK5f5)'
- en: '[Remotely Awesome Jobs](https://oreil.ly/MkMeg)'
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[远程工作岗位](https://oreil.ly/MkMeg)'
- en: '[Working Nomads](https://oreil.ly/uHVE3)'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Working Nomads](https://oreil.ly/uHVE3)'
- en: '[GitHub](https://oreil.ly/smmrZ)'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[GitHub](https://oreil.ly/smmrZ)'
- en: Coming Up
  id: totrans-537
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即将到来
- en: But wait, there’s more! The next three chapters offer tours of Python in the
    arts, business, and science. You’ll find at least one package that you’ll want
    to explore. Bright and shiny objects abound on the net. Only you can tell which
    are costume jewelry and which are silver bullets. And even if you’re not currently
    pestered by werewolves, you might want some of those silver bullets in your pocket.
    Just in case.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等，还有更多！接下来的三章将介绍 Python 在艺术、商业和科学领域的应用。你会发现至少一个你想要探索的包。网络上充满了闪亮的物体。只有你能分辨出哪些是假的珠宝，哪些是银弹。即使你目前没有被狼人困扰，你可能也希望口袋里有些银弹。以防万一。
- en: Finally, we have answers to those annoying end-of-chapter exercises, details
    on installation of Python and friends, and a few cheat sheets for things that
    I always need to look up. Your brain is almost certainly better tuned, but they’re
    there if needed.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有了那些让人烦恼的章节末尾练习的答案，Python 及其伙伴安装的详细信息，以及一些常常需要查找的备忘单。你的大脑几乎肯定更精通，但如果需要，它们在那里。
- en: Things to Do
  id: totrans-540
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要做的事情
- en: (Pythonistas don’t have homework today.)
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: （Python 爱好者今天没有家庭作业。）
- en: '^([1](ch19.html#idm45794966587992-marker)) You, as the detective: “I know I’m
    in there! And if I don’t come out with my hands up, I’m coming in after me!”'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch19.html#idm45794966587992-marker)) 你作为侦探：“我知道我在里面！如果我不举手投降，我就要自己出来！”
- en: ^([2](ch19.html#idm45794965496488-marker)) Many computer books use Fibonacci
    number calculations in timing examples, but I’d rather sleep than calculate Fibonacci
    numbers.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch19.html#idm45794965496488-marker)) 许多计算机书籍在定时示例中使用 Fibonacci 数字计算，但我宁愿睡觉也不愿意计算
    Fibonacci 数字。
