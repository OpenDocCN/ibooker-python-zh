- en: Chapter 3\. Testing a Simple Home Page with Unit Tests
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章。使用单元测试测试简单的首页
- en: We finished the last chapter with a functional test failing, telling us that
    it wanted the home page for our site to have “To-Do” in its title. It’s time to
    start working on our application. In this chapter, we’ll build our first HTML
    page, find out about URL handling, and creating responses to HTTP requests with
    Django’s view functions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章结束时有一个功能测试失败，告诉我们它希望我们网站的首页标题中有“待办事项”。现在是开始开发我们的应用程序的时候了。在这一章中，我们将构建我们的第一个
    HTML 页面，了解 URL 处理，并使用 Django 的视图函数创建 HTTP 请求的响应。
- en: Our First Django App, and Our First Unit Test
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个 Django 应用程序及我们的第一个单元测试
- en: 'Django encourages you to structure your code into *apps*: the theory is that
    one project can have many apps, you can use third-party apps developed by other
    people, and you might even reuse one of your own apps in a different project…​although
    I admit I’ve never actually managed it myself! Still, apps are a good way to keep
    your code organised.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Django 鼓励您将代码结构化为*应用程序*：理论上，一个项目可以有多个应用程序，您可以使用其他人开发的第三方应用程序，甚至可以在不同项目中重用您自己的应用程序...
    尽管我承认我从未真正做到过！不过，应用程序是保持代码组织良好的好方法。
- en: 'Let’s start an app for our to-do lists:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的待办事项列表创建一个应用程序：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'That will create a folder called *lists*, next to *manage.py* and the existing
    *superlists* folder, and within it a number of placeholder files for things like
    models, views, and, of immediate interest to us, tests:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 *manage.py* 旁边创建一个名为 *lists* 的文件夹，并在其中创建一些占位文件，如模型、视图以及对我们非常感兴趣的测试：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Unit Tests, and How They Differ from Functional Tests
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试及其与功能测试的区别
- en: As with so many of the labels we put on things, the line between unit tests
    and functional tests can become a little blurry at times. The basic distinction,
    though, is that functional tests test the application from the outside, from the
    user’s point of view. Unit tests test the application from the inside, from the
    programmer’s point of view.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们给许多事物贴上的标签一样，单元测试和功能测试之间的界限有时可能会变得有些模糊。不过，基本的区别在于，功能测试从外部，从用户的角度测试应用程序。单元测试从内部，从程序员的角度测试应用程序。
- en: 'The TDD approach I’m demonstrating uses both types of test to drive the development
    of our application, and ensure its correctness. Our workflow will look a bit like
    this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我演示的 TDD 方法使用两种类型的测试来驱动我们应用程序的开发，并确保其正确性。我们的工作流程将看起来有点像这样：
- en: We start by writing a *functional test*, describing a typical example of our
    new functionality from the user’s point of view.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从编写*功能测试*开始，描述我们的新功能的一个典型示例，从用户的角度来看。
- en: Once we have a functional test that fails, we start to think about how to write
    code that can get it to pass (or at least to get past its current failure). We
    now use one or more *unit tests* to define how we want our code to behave—​the
    idea is that each line of production code we write should be tested by (at least)
    one of our unit tests.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有一个功能测试失败，我们开始考虑如何编写代码来使其通过（或至少通过当前的失败）。现在我们使用一个或多个*单元测试*来定义我们希望我们的代码如何运行——我们编写的每一行生产代码都应该由（至少）一个我们的单元测试来测试。
- en: Once we have a failing unit test, we write the smallest amount of *application
    code* we can, just enough to get the unit test to pass. We may iterate between
    steps 2 and 3 a few times, until we think the functional test will get a little
    further.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有一个失败的单元测试，我们编写尽可能少的*应用程序代码*，只要能让单元测试通过即可。我们可能会在步骤 2 和步骤 3 之间迭代几次，直到我们认为功能测试将进展一点。
- en: Now we can rerun our functional tests and see if they pass, or get a little
    further. That may prompt us to write some new unit tests, and some new code, and
    so on.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以重新运行我们的功能测试，看它们是否通过或者是否有所进展。这可能会促使我们编写一些新的单元测试，编写一些新代码，等等。
- en: Once we’re comfortable that the core functionality works end-to-end, we can
    extend out to cover more permutations and edge cases, using just unit tests now.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们确信核心功能端到端运行正常，我们可以扩展测试以覆盖更多的排列组合和边缘情况，现在只使用单元测试。
- en: You can see that, all the way through, the functional tests are driving what
    development we do from a high level, while the unit tests drive what we do at
    a low level.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，从始至终，功能测试在高层驱动我们的开发，而单元测试在低层驱动我们的开发。
- en: The functional tests don’t aim to cover every single tiny detail of our app’s
    behaviour, they are there to reassure us that everything is wired up correctly.
    The unit tests are there to exhaustively check all the lower level details and
    corner cases.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试的目标不是覆盖应用程序行为的每一个细节，它们是为了确保所有东西都正确连接起来。单元测试则是详尽检查所有低级细节和边缘情况。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Functional tests should help you build an application that actually works, and
    guarantee you never accidentally break it. Unit tests should help you to write
    code that’s clean and bug free.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试应该帮助你构建一个真正可用的应用程序，并确保你永远不会意外地破坏它。单元测试应该帮助你编写干净和无 bug 的代码。
- en: Enough theory for now—let’s see how it looks in practice.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在足够理论了 — 让我们看看它在实践中的表现。
- en: Table 3-1\. FTs vs Unit Tests
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-1\. FTs vs 单元测试
- en: '| FTs | Unit Tests |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| FTs | 单元测试 |'
- en: '| --- | --- |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| One test per feature / user story | Many tests per feature |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 每个功能/用户故事一个测试 | 每个功能多个测试 |'
- en: '| Test from the user’s point of view | Test the code, ie the programmer’s point
    of view |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 用户角度的测试 | 程序员角度的代码测试 |'
- en: '| Can test that the UI “really” works | Tests the internals, individual functions
    or classes |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 可以测试 UI “真正” 工作 | 测试内部，单个函数或类 |'
- en: '| Provides confidence that everything is wired together correctly, works end-to-end
    | Can exhaustively check permutations, details, edge cases |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 确保所有东西正确连接在一起的信心 | 可以详尽检查排列组合，细节，边缘情况 |'
- en: Unit Testing in Django
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Django 中的单元测试
- en: 'Let’s see how to write a unit test for our home page view. Open up the new
    file at *lists/tests.py*, and you’ll see something like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何为我们的首页视图编写一个单元测试。打开 *lists/tests.py* 中的新文件，你会看到类似这样的内容：
- en: lists/tests.py
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: lists/tests.py
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Django has helpfully suggested we use a special version of `TestCase`, which
    it provides. It’s an augmented version of the standard `unittest.TestCase`, with
    some additional Django-specific features, which we’ll discover over the next few
    chapters.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Django 已经很贴心地建议我们使用它提供的 `TestCase` 的特殊版本。它是标准的 `unittest.TestCase` 的增强版本，带有一些额外的
    Django 特定功能，我们将在接下来的几章中了解到。
- en: 'You’ve already seen that the TDD cycle involves starting with a test that fails,
    then writing code to get it to pass. Well, before we can even get that far, we
    want to know that the unit test we’re writing will definitely be run by our automated
    test runner, whatever it is. In the case of *functional_tests.py*, we’re running
    it directly, but this file made by Django is a bit more like magic. So, just to
    make sure, let’s make a deliberately silly failing test:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到 TDD 周期包括从失败的测试开始，然后编写代码使其通过。那么，在我们甚至达到那一步之前，我们希望知道我们编写的单元测试一定会被我们的自动化测试运行器运行，不管它是什么。在
    *functional_tests.py* 的情况下，我们直接运行它，但这个由 Django 创建的文件有点像魔术。所以，为了确保，让我们写一个故意愚蠢的失败测试：
- en: lists/tests.py (ch03l002)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: lists/tests.py (ch03l002)
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now let’s invoke this mysterious Django test runner. As usual, it’s a *manage.py*
    command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们调用这个神秘的 Django 测试运行器。像往常一样，这是一个 *manage.py* 命令：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Excellent. The machinery seems to be working. This is a good point for a commit:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。机制似乎在工作。这是一个提交的好时机：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you’ve no doubt guessed, the `-m` flag lets you pass in a commit message
    at the command line, so you don’t need to use an editor. It’s up to you to pick
    the way you like to use the Git command line; I’ll just show you the main ones
    I’ve seen used. For me the main big of VCS hygiene is: *make sure you always review
    what you’re about to commit before you do it*.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你无疑猜到的那样，`-m` 标志允许你在命令行传递提交消息，这样你就不需要使用编辑器了。选择如何使用 Git 命令行取决于你；我只是展示我见过的主要方式。对我来说，VCS
    卫生的主要部分是：*确保在提交之前始终审查即将提交的内容*。
- en: Django’s MVC, URLs, and View Functions
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Django 的 MVC、URL 和视图函数
- en: Django is structured along a classic *Model-View-Controller* (MVC) pattern.
    Well, *broadly*. It definitely does have models, but what Django calls views are
    really controllers, and the view part is actually provided by the templates, but
    you can see the general idea is there!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Django 沿着经典的 *Model-View-Controller* (MVC) 模式结构化。嗯，*大体上* 是这样。它确实有模型，但 Django
    称为视图的东西实际上是控制器，而视图部分实际上由模板提供，但你可以看到总体思路是一致的！
- en: If you’re interested, you can look up the finer points of the discussion [in
    the Django FAQs](https://docs.djangoproject.com/en/4.2/faq/general/#django-appears-to-be-a-mvc-framework-but-you-call-the-controller-the-view-and-the-view-the-template-how-come-you-don-t-use-the-standard-names).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣，你可以查看 [Django FAQ](https://docs.djangoproject.com/en/4.2/faq/general/#django-appears-to-be-a-mvc-framework-but-you-call-the-controller-the-view-and-the-view-the-template-how-come-you-don-t-use-the-standard-names)
    中讨论的更细节的内容。
- en: 'Irrespective of any of that, as with any web server, Django’s main job is to
    decide what to do when a user asks for a particular URL on our site. Django’s
    workflow goes something like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，就像任何 Web 服务器一样，Django 的主要工作是决定当用户请求站点上特定的 URL 时该做什么。Django 的工作流程大致如下：
- en: An HTTP *request* comes in for a particular *URL*.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个 HTTP *请求* 来自于特定的 *URL*。
- en: Django uses some rules to decide which *view* function should deal with the
    request (this is referred to as *resolving* the URL).
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Django 使用一些规则来决定哪个 *视图* 函数应该处理请求（这称为 *解析* URL）。
- en: The view function processes the request and returns an HTTP *response*.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图函数处理请求并返回一个 HTTP *响应*。
- en: 'So, we want to test two things:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们想测试两件事：
- en: Can we make this view function return the HTML we need?
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能让这个视图函数返回我们需要的 HTML 吗？
- en: Can we tell Django to use this view function when we make a request for the
    root of the site (“/”)?
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能告诉 Django 在我们请求站点根目录（“/”）时使用这个视图函数吗？
- en: Let’s start with the first.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个开始。
- en: Unit Testing a View
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试一个视图
- en: 'Open up *lists/tests.py*, and change our silly test to something like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 *lists/tests.py*，将我们愚蠢的测试更改为类似这样的内容：
- en: lists/tests.py (ch03l003)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: lists/tests.py (ch03l003)
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'What’s going on in this new test? Well, remember, a view function takes an
    HTTP request as input, and produces an HTTP response. So, to test that:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新测试中发生了什么？嗯，记住，一个视图函数以 HTTP 请求作为输入，并生成一个 HTTP 响应。所以，为了测试：
- en: '[![1](assets/1.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO1-1)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO1-1)'
- en: We import the `HttpRequest` class so that we can then create a request object
    within our test. This is the kind of object that Django will create when a user’s
    browser asks for a page.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入 `HttpRequest` 类，这样我们就可以在测试中创建一个请求对象。这是当用户的浏览器请求页面时 Django 会创建的对象。
- en: '[![2](assets/2.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO1-3)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO1-3)'
- en: We pass the `HttpRequest` object to our `home_page` view, which gives us a response.
    You won’t be surprised to hear that the response is an instance of a class called
    `HttpResponse`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `HttpRequest` 对象传递给我们的 `home_page` 视图，这给了我们一个响应。你可能不会感到惊讶，响应是一个名为 `HttpResponse`
    的类的实例。
- en: '[![3](assets/3.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO1-4)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO1-4)'
- en: Then, we extract the `.content` of the response. These are the raw bytes, the
    ones and zeros that would be sent down the wire to the user’s browser. We call
    `.decode()` to convert them into the string of HTML that’s being sent to the user.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们提取响应的 `.content`。这些是原始字节，即将发送到用户浏览器的 0 和 1。我们调用 `.decode()` 将它们转换为 HTML
    字符串，这些将发送给用户的内容。
- en: '[![4](assets/4.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO1-5)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO1-5)'
- en: 'Now we can make some assertions: we know we want an html `<title>` tag somewhere
    in there, with the words “To-Do lists” in it—​because that’s what we specified
    in our functional test.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以进行一些断言：我们知道我们希望在其中的某处有一个html `<title>` 标签，标签中包含“待办事项列表”这几个字——因为这是我们在功能测试中指定的内容。
- en: '[![5](assets/5.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO1-6)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO1-6)'
- en: And we can do a vague sanity check that it’s valid html, by checking that it
    starts with an `<html>` tag which gets closed at the end.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以做一个粗略的检查，确认它是有效的 html，通过检查它是否以 `<html>` 标签开头，并在结尾处关闭。
- en: So, what do you think will happen when we run the tests?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你认为当我们运行测试时会发生什么？
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It’s a very predictable and uninteresting error: we tried to import something
    we haven’t even written yet. But it’s still good news—​for the purposes of TDD,
    an exception which was predicted counts as an expected failure. Since we have
    both a failing functional test and a failing unit test, we have the Testing Goat’s
    full blessing to code away.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常可预测且不太有趣的错误：我们试图导入尚未编写的东西。但这仍然是好消息—​对于TDD来说，预料之中的异常算作是预期的失败。因为我们既有一个失败的功能测试又有一个失败的单元测试，我们得到了测试山羊的充分祝福，可以继续编码。
- en: At Last! We Actually Write Some Application Code!
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终于！我们真正写一些应用代码！
- en: It is exciting, isn’t it? Be warned, TDD means that long periods of anticipation
    are only defused very gradually, and by tiny increments. Especially since we’re
    learning and only just starting out, we only allow ourselves to change (or add)
    one line of code at a time—​and each time, we make just the minimal change required
    to address the current test failure.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是令人兴奋的，不是吗？请注意，TDD意味着长时间的期待只能逐渐化解，并且只能通过微小的增量来解决。特别是因为我们在学习阶段，刚刚开始，我们只允许自己每次只改变（或添加）一行代码—​每次，我们只进行最小的变更来解决当前的测试失败。
- en: 'I’m being deliberately extreme here, but what’s our current test failure? We
    can’t import `home_page` from `lists.views`? OK, let’s fix that—​and only that.
    In *lists/views.py*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意夸张一下，但是我们当前的测试失败是什么？我们无法从`lists.views`导入`home_page`？好的，让我们解决这个问题—​只解决这个问题。在*lists/views.py*中：
- en: lists/views.py (ch03l004)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: lists/views.py（ch03l004）
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*“You must be joking!”* I can hear you say.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*“你一定在开玩笑！”* 我听到你说。'
- en: I can hear you because it’s what I used to say (with feeling) when my colleagues
    first demonstrated TDD to me. Well, bear with me, and we’ll talk about whether
    or not this is all taking it too far in a little while. But for now, let yourself
    follow along, even if it’s with some exasperation, and see if our tests can help
    us write the correct code, one tiny step at a time.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以听到你的声音，因为这正是我以前（带有强烈感情地）对我的同事展示TDD时所说的话。好吧，忍耐一下，我们稍后再讨论这是否有些过火。但现在，让自己跟随一下，即使有些恼怒，看看我们的测试是否可以帮助我们一次一小步地编写正确的代码。
- en: 'Let’s run the tests again:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行测试：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We still get an error, but it’s moved on a bit. Instead of an import error,
    our tests are telling us that our `home_page` “function” is not callable. That
    gives us a justification for changing it from being `None` to being an actual
    function. At the very smallest level of detail, every single code change can be
    driven by the tests!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然收到错误消息，但情况有所改变。不再是导入错误，我们的测试告诉我们我们的`home_page`“函数”不可调用。这给了我们正当理由将其从`None`改为实际的函数。在最微小的细节层面，每一次代码变更都可以由测试驱动！
- en: 'Back in *lists/views.py*:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 回到*lists/views.py*：
- en: lists/views.py (ch03l005)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: lists/views.py（ch03l005）
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Again, we’re making the smallest, dumbest change we can possibly make, that
    addresses precisely the current test failure. Our tests wanted something callable,
    so we gave them the simplest possible callable thing, a function that takes no
    arguments and returns nothing.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们只需进行最小、最愚蠢的变更，精确解决当前的测试失败。我们的测试希望得到可调用的内容，因此我们提供了可能的最简单可调用的东西，一个不接受任何参数并且不返回任何内容的函数。
- en: 'Let’s run the tests again and see what they think:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行测试，看看它们的反应：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once more, our error message has changed slightly, and is guiding us towards
    fixing the next thing that’s wrong.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们的错误消息略有变化，并引导我们修复接下来出现的问题。
- en: The Unit-Test/Code Cycle
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试/代码循环
- en: 'We can start to settle into the TDD *unit-test/code cycle* now:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始进入TDD的*单元测试/代码循环*：
- en: In the terminal, run the unit tests and see how they fail.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中运行单元测试，看看它们如何失败。
- en: In the editor, make a minimal code change to address the current test failure.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中，进行最小化的代码变更来解决当前的测试失败。
- en: And repeat!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后重复！
- en: The more nervous we are about getting our code right, the smaller and more minimal
    we make each code change—​the idea is to be absolutely sure that each bit of code
    is justified by a test.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对代码正确性越紧张，每次代码变更就越小、越简单—​这个想法是确保每一行代码都经过测试的验证。
- en: This may seem laborious, and at first, it will be. But once you get into the
    swing of things, you’ll find yourself coding quickly even if you take microscopic
    steps—​this is how we write all of our production code at work.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能很繁琐，起初确实是这样。但一旦你进入了节奏，即使采取微小的步骤，你也会发现自己编码速度很快—​这是我们在工作中编写所有生产代码的方式。
- en: 'Let’s see how fast we can get this cycle going:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们能多快地进行这个循环：
- en: 'Minimal code change:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化代码变更：
- en: lists/views.py (ch03l006)
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: lists/views.py（ch03l006）
- en: '[PRE12]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Tests:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试：
- en: '[PRE13]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Code—​we use `django.http.HttpResponse`, as predicted:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码—​我们使用`django.http.HttpResponse`，正如预期的那样：
- en: lists/views.py (ch03l007)
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: lists/views.py (ch03l007)
- en: '[PRE14]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Tests again:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次测试：
- en: '[PRE15]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Code again:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再来一段代码：
- en: lists/views.py (ch03l008)
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: lists/views.py (ch03l008)
- en: '[PRE16]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Tests yet again:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次测试：
- en: '[PRE17]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Code yet again:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再来一段代码：
- en: lists/views.py (ch03l009)
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: lists/views.py (ch03l009)
- en: '[PRE18]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Tests—​almost there?
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试—​快了吗？
- en: '[PRE19]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Come on, one last effort:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再努把力：
- en: lists/views.py (ch03l010)
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: lists/views.py (ch03l010)
- en: '[PRE20]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Surely?
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然？
- en: '[PRE21]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Hooray! Our first ever unit test pass! That’s so momentous that I think it’s
    worthy of a commit:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 好极了！我们有史以来的第一个单元测试通过了！这是如此重要，我认为值得提交：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That was the last variation on `git commit` I’ll show, the `a` and `m` flags
    together, which adds all changes to tracked files and uses the commit message
    from the command line.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是我将展示的最后一种 `git commit` 变体了，`a` 和 `m` 标志一起使用，它将所有更改添加到已跟踪文件并使用命令行中的提交消息。
- en: Warning
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: '`git commit -am` is the quickest formulation, but also gives you the least
    feedback about what’s being committed, so make sure you’ve done a `git status`
    and a `git diff` beforehand, and are clear on what changes are about to go in.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`git commit -am` 是最快的组合，但也给出了关于正在提交的内容最少的反馈，所以确保你之前已经执行了 `git status` 和 `git
    diff`，并且清楚即将进行的更改。 '
- en: Our functional tests tell us we’re not quite done yet.
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的功能测试告诉我们我们还没有完成。
- en: We’ve got our unit test passing, so let’s go back to running our functional
    tests to see if we’ve made progress. Don’t forget to spin up the dev server again,
    if it’s not still running.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单元测试通过了，所以让我们回到运行我们的功能测试，看看我们是否有所进展。如果开发服务器还没有运行，请不要忘记重新启动它。
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Looks like something isn’t quite right. This is the reason we have functional
    tests!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来有些不太对劲。这就是我们进行功能测试的原因！
- en: Do you remember at the beginning of the chapter, we said we needed to do two
    things, firstly create a view function to produce responses for requests, and
    secondly tell the server which functions should respond to which URLs? Thanks
    to our FT, we have been reminded that we still need to do the second thing.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得在本章开头，我们说过我们需要做两件事，首先是创建一个视图函数来为请求产生响应，其次是告诉服务器哪些函数应该响应哪些 URL 吗？多亏了我们的 FT，我们被提醒我们仍然需要做第二件事。
- en: How can we write a test for URL resolution? At the moment we just test the view
    function directly by importing it and calling it. But we want to test more layers
    of the Django stack. Django, like most web frameworks, supplies a tool for doing
    just that, called the [Django Test Client](https://docs.djangoproject.com/en/4.2/topics/testing/tools/#the-test-client).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何编写 URL 解析的测试呢？目前我们只是直接导入并调用视图函数进行测试。但我们想要测试 Django 堆栈的更多层。Django，像大多数 Web
    框架一样，提供了一个工具来做这件事，称为[Django 测试客户端](https://docs.djangoproject.com/en/4.2/topics/testing/tools/#the-test-client)。
- en: 'Let’s see how to use it by adding a second, alternative test to our unit tests:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用它，通过向我们的单元测试添加第二个替代测试：
- en: lists/tests.py (ch03l011)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: lists/tests.py (ch03l011)
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[![1](assets/1.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO2-1)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO2-1)'
- en: We can access the tests client via `self.client`, which is available on any
    test that uses `django.test.TestCase`. It provides methods like `.get()` which
    simulate a browser making http requests, and take a URL as their first parameter.
    We use this instead of manually creating a request object and calling the view
    function directly
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `self.client` 访问测试客户端，它在任何使用 `django.test.TestCase` 的测试中都可用。它提供了像 `.get()`
    这样的方法，模拟浏览器发出 http 请求，并将 URL 作为其第一个参数。我们使用它来代替手动创建请求对象并直接调用视图函数
- en: '[![2](assets/2.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO2-2)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO2-2)'
- en: Django also provides some assertion helpers like `assertContains` that save
    us from having to manually extract and decode response content, and have some
    other nice properties besides, as we’ll see.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Django 还提供了一些断言辅助函数，比如 `assertContains`，它们可以帮助我们避免手动提取和解码响应内容，并且还有一些其他好处，正如我们将看到的那样。
- en: 'Let’s see how that works:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Hmm, something about 404s? Let’s dig into it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，关于 404 的问题？让我们深入了解一下。
- en: Reading Tracebacks
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读回溯
- en: 'Let’s spend a moment talking about how to read tracebacks, since it’s something
    we have to do a lot in TDD. You soon learn to scan through them and pick up relevant
    clues:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一点时间来谈谈如何阅读回溯，因为这是我们在 TDD 中经常要做的事情。你很快就会学会扫描它们并收集相关线索：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[![1](assets/1.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO3-4)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO3-4)'
- en: The first place you look is usually *the error itself*. Sometimes that’s all
    you need to see, and it will let you identify the problem immediately. But sometimes,
    like in this case, it’s not quite self-evident.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你首先要查看的地方就是*错误本身*。有时这就是你需要看到的一切，它会让你立即识别问题。但有时，就像在这种情况下一样，情况并不是那么明显。
- en: '[![2](assets/2.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO3-1)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO3-1)'
- en: 'The next thing to double-check is: *which test is failing?* Is it definitely
    the one we expected—​that is, the one we just wrote? In this case, the answer
    is yes.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步要仔细检查的是：*哪个测试失败了？* 它确实是我们期望的那个测试吗——也就是说，我们刚刚编写的测试吗？在这种情况下，答案是肯定的。
- en: '[![3](assets/3.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO3-2)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO3-2)'
- en: Then we look for the place in *our test code* that kicked off the failure. We
    work our way down from the top of the traceback, looking for the filename of the
    tests file, to check which test function, and what line of code, the failure is
    coming from. In this case it’s the line where we call the `assertContains` method.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们寻找导致失败的*测试代码*所在的位置。我们从回溯的顶部开始向下查找，查找测试文件的文件名，以检查是哪个测试函数，以及失败来自哪一行代码。在这种情况下，是我们调用`assertContains`方法的那一行。
- en: '[![4](assets/4.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO3-3)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO3-3)'
- en: In Python 3.11 and later, you can also look out for the string of carets, which
    try to tell you exactly where the exception came from. This is more useful for
    unexpected exceptions than for assertion failures like we have now.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3.11及更高版本中，你还可以查看小尖括号组成的字符串，它们试图告诉你异常来自哪里。这对于意外异常比我们现在的断言失败更有用。
- en: There is ordinarily a fifth step, where we look further down for any of *our
    own application code* which was involved with the problem. In this case it’s all
    Django code, but we’ll see plenty of examples of this fifth step later in the
    book.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通常还有第五步，我们会进一步查找*我们自己的应用代码*中是否涉及该问题。在这种情况下，这都是Django代码，但我们将在本书的后面看到许多这样的第五步示例。
- en: Pulling it all together, we interpret the traceback as telling us that, when
    we tried to do our assertion on the content of the response, Django’s test helpers
    failed saying that they could not do that, because the response is an HTML 404
    “Not Found” error instead of a normal 200 OK response.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 汇总一下，我们将回溯解释为告诉我们，在我们尝试对响应内容进行断言时，Django的测试助手失败，因为它们无法执行该操作，因为响应是HTML 404“未找到”错误，而不是正常的200
    OK响应。
- en: In other words, Django isn’t yet configured to respond to requests for the root
    URL (“/”) of our site. Let’s make that happen now.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，Django尚未配置为响应对我们站点根URL（“/”）的请求。现在让我们来实现这个功能。
- en: urls.py
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: urls.py
- en: 'Django uses a file called *urls.py* to map URLs to view functions. This mapping
    is also called *routing*. There’s a main *urls.py* for the whole site in the *superlists*
    folder. Let’s go take a look:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Django使用一个名为*urls.py*的文件来将URL映射到视图函数。这种映射也称为*路由*。整个站点的主*urls.py*位于*superlists*文件夹中。让我们去看一下：
- en: superlists/urls.py
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: superlists/urls.py
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Warning
  id: totrans-159
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: If your *urls.py* looks different or if it mentions a function called `url()`
    instead of `path()`, it’s because you’ve got the wrong version of Django. This
    book is written for Django v4\. Take another look at the [Prerequisites and Assumptions](preface02.xhtml#pre-requisites)
    section and get the right version before you go any further.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的*urls.py*看起来不同，或者提到了一个名为`url()`而不是`path()`的函数，那是因为你安装了错误版本的Django。本书是针对Django
    v4编写的。再看一下[先决条件和假设](preface02.xhtml#pre-requisites)部分，并在继续之前获取正确的版本。
- en: As usual, lots of helpful comments and default suggestions from Django. In fact,
    that very first example is pretty much exactly what we want! Let’s use that, with
    some minor changes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，Django提供了大量有用的注释和默认建议。实际上，第一个示例就是我们想要的！让我们使用它，并进行一些小的更改。
- en: superlists/urls.py (ch03l012)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: superlists/urls.py (ch03l012)
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[![1](assets/1.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO4-1)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO4-1)'
- en: No need to import `admin` from `django.contrib`. Django’s admin site is amazing,
    but it’s a topic for another book.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 无需从`django.contrib`导入`admin`。Django的管理站点非常棒，但这是另一本书的话题。
- en: '[![2](assets/2.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO4-2)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO4-2)'
- en: But we will import our home page view function.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们将导入我们的主页视图函数。
- en: '[![3](assets/3.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO4-3)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO4-3)'
- en: And we wire it up here, as a `path()` entry in the `urlpatterns` global. Django
    strips the leading slash from all urls, so `"/url/path/to"` becomes `"url/path/to"`
    and the base URL is just the empty string, `""`. So this config says, the “base
    url should point to our home page view”
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其连接在这里，作为`urlpatterns`全局变量中的`path()`条目。Django会从所有URL中去掉开头的斜杠，所以`"/url/path/to"`变成了`"url/path/to"`，而基础URL就是空字符串`""`。因此，这个配置表示：“基础URL应该指向我们的主页视图”
- en: 'Now we can run our unit tests again, with **`python manage.py test`**:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以再次运行我们的单元测试，使用**`python manage.py test`**命令：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Hooray!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 万岁！
- en: 'Time for a little tidy-up. We don’t need two separate tests, let’s move everything
    out of our low-level test that calls the view function directly, into the test
    that uses the Django test client:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候稍作整理了。我们不需要两个单独的测试，让我们将所有内容从直接调用视图函数的低级测试中移出，放入使用Django测试客户端的测试中：
- en: lists/tests.py (ch03l013)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: lists/tests.py（ch03l013）
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: But now the moment of truth, will our functional tests pass?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在真相大白了，我们的功能测试会通过吗？
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Failed? What? Oh, it’s just our little reminder? Yes? Yes! We have a web page!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 失败了？什么？哦，这只是我们的小提醒？是的？是的！我们有一个网页！
- en: Ahem. Well, *I* thought it was a thrilling end to the chapter. You may still
    be a little baffled, perhaps keen to hear a justification for all these tests,
    and don’t worry, all that will come, but I hope you felt just a tinge of excitement
    near the end there.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀。嗯，*我*认为这是章节的一个激动人心的结尾。你可能还有点困惑，也许急于听到所有这些测试的理由，别担心，一切都会有的，但我希望你在最后感受到了一丝兴奋。
- en: 'Just a little commit to calm down, and reflect on what we’ve covered:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 只需稍作提交，冷静下来，回顾一下我们所涵盖的内容：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'That was quite a chapter! Why not try typing `git log`, possibly using the
    `--oneline` flag, for a reminder of what we got up to:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 那真是一个精彩的章节！为什么不尝试输入`git log`命令，可能会使用`--oneline`选项，来回顾我们的活动：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Not bad—​we covered:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 还不错——我们涵盖了：
- en: Starting a Django app
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始一个Django应用程序
- en: The Django unit test runner
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django单元测试运行器
- en: The difference between functional-, and unit tests
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试和单元测试之间的区别
- en: Django view functions, request and response objects
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django视图函数、请求和响应对象
- en: Django URL resolving and *urls.py*
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django URL解析和*urls.py*
- en: The Django Test Client
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django测试客户端
- en: And returning basic HTML from a view.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并从视图返回基本的HTML。
