<html><head></head><body><section data-pdf-bookmark="Appendix C. Debugging with Ray" data-type="appendix" epub:type="appendix"><div class="appendix" id="appC">
<h1><span class="label">Appendix C. </span>Debugging with Ray</h1>


<p>Depending on your debugging techniques, moving to distributed systems could require a new set of techniques. Thankfully, tools like Pdb and PyCharm allow you to connect remote debuggers, and Ray’s local mode can allow you to use your existing debugging tools in many other situations. Some errors happen outside Python, making them more difficult to debug, like container out-of-memory (OOM) errors, segmentation faults, and other native errors.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Some components of this appendix are shared with <a class="orm:hideurl" href="https://oreil.ly/Fk0I6"><em>Scaling Python with Dask</em></a>, as they are general good advice for debugging all types of distributed systems.</p>
</div>






<section data-pdf-bookmark="General Debugging Tips with Ray" data-type="sect1"><div class="sect1" id="idm45354756267456">
<h1>General Debugging Tips with Ray</h1>

<p>You <a data-primary="Ray" data-secondary="debugging with" data-tertiary="tips for" data-type="indexterm" id="ray-debug-tips"/><a data-primary="debugging with Ray" data-secondary="tips for" data-type="indexterm" id="debug-tips"/>likely have your own standard debugging techniques for working with Python code, and this appendix is not meant to replace them. Here are some general tech­ni⁠ques that make more sense with Ray:</p>

<ul>
<li>
<p>Break up failing functions into smaller functions. Since <code>ray.remote</code> schedules on the block of a function, smaller functions make it easier to isolate the problem.</p>
</li>
<li>
<p>Be careful about any unintended scope capture.</p>
</li>
<li>
<p>Sample data and try to reproduce it locally (local debugging is often easier).</p>
</li>
<li>
<p>Use Mypy for type checking. While we haven’t included types in all our examples, liberal type usage can catch tricky errors in production code.</p>
</li>
<li>
<p>When issues appear regardless of parallelization, debug your code in single-threaded mode, where it can be easier to understand what’s going on.</p>
</li>
</ul>

<p>Now, with those additional general tips, it’s time to learn more about the tools and techniques to help your Ray<a data-primary="Ray" data-secondary="debugging with" data-startref="ray-debug-tips" data-tertiary="tips for" data-type="indexterm" id="idm45354756257168"/><a data-primary="debugging with Ray" data-secondary="tips for" data-startref="debug-tips" data-type="indexterm" id="idm45354756255616"/> debugging.</p>
</div></section>






<section data-pdf-bookmark="Serialization Errors" data-type="sect1"><div class="sect1" id="idm45354756254016">
<h1>Serialization Errors</h1>

<p>Serialization<a data-primary="Ray" data-secondary="debugging with" data-tertiary="serialization errors" data-type="indexterm" id="idm45354756252288"/><a data-primary="debugging with Ray" data-secondary="serialization errors" data-type="indexterm" id="idm45354756251040"/><a data-primary="serialization" data-secondary="debugging errors in" data-type="indexterm" id="idm45354756250064"/> plays an important part in Ray, but can also be a source of headaches as small changes can result in unintended variable capture and serialization failure. Thankfully, Ray has a util<a data-primary="inspect_serializability" data-type="indexterm" id="idm45354756248992"/> function <code>inspect_serializability</code> in <code>ray.util</code> that you can use to debug serialization errors. If you intentionally define a function that captures nonserializable data, like <a data-type="xref" href="#bad_ser_ex">Example C-1</a>, you can run <code>inspect_serializability</code> and see how it reports the failure (as in <a data-type="xref" href="#bad_ser_result">Example C-2</a>).</p>
<div data-type="example" id="bad_ser_ex">
<h5><span class="label">Example C-1. </span><a href="https://oreil.ly/eygeJ">Bad serialization example</a></h5>

<pre data-code-language="python" data-type="programlisting"><code class="n">pool</code> <code class="o">=</code> <code class="n">Pool</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code>

<code class="k">def</code> <code class="nf">special_business</code><code class="p">(</code><code class="n">x</code><code class="p">):</code>
    <code class="k">def</code> <code class="nf">inc</code><code class="p">(</code><code class="n">y</code><code class="p">):</code>
        <code class="k">return</code> <code class="n">y</code> <code class="o">+</code> <code class="n">x</code>
    <code class="k">return</code> <code class="n">pool</code><code class="o">.</code><code class="n">map</code><code class="p">(</code><code class="n">inc</code><code class="p">,</code> <code class="nb">range</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="n">x</code><code class="p">))</code>
<code class="n">ray</code><code class="o">.</code><code class="n">util</code><code class="o">.</code><code class="n">inspect_serializability</code><code class="p">(</code><code class="n">special_business</code><code class="p">)</code></pre></div>
<div data-type="example" id="bad_ser_result">
<h5><span class="label">Example C-2. </span>Bad serialization result</h5>

<pre data-type="programlisting">=========================================================================
Checking Serializability of &lt;function special_business at 0x7f78802820d0&gt;
=========================================================================
!!! FAIL serialization: pool objects cannot be passed between processes or pickled
Detected 1 global variables. Checking serializability...
    Serializing 'pool' &lt;multiprocessing.pool.Pool state=RUN pool_size=5&gt;...
    !!! FAIL serialization: pool objects cannot be passed between processes ...
...</pre></div>

<p>In this example, Ray checks the elements for serializability and calls out that the nonserializable value <code>pool</code> is coming in from the global scope.</p>
</div></section>






<section data-pdf-bookmark="Local Debugging with Ray Local" data-type="sect1"><div class="sect1" id="idm45354756183360">
<h1>Local Debugging with Ray Local</h1>

<p>Using<a data-primary="Ray" data-secondary="debugging with" data-tertiary="local debugging" data-type="indexterm" id="idm45354756182064"/><a data-primary="debugging with Ray" data-secondary="local debugging" data-type="indexterm" id="idm45354756180784"/><a data-primary="local debugging" data-type="indexterm" id="idm45354756179840"/> Ray in local mode allows you to use the tools you are accustomed to without having to deal with the complexity of setting up remote debugging. We won’t cover the variety of local Python debugging tools, so this section exists just to remind you to try to reproduce the problem in local mode first before you start using the fancy debugging techniques covered in the rest of this appendix.</p>
</div></section>






<section data-pdf-bookmark="Remote Debugging" data-type="sect1"><div class="sect1" id="idm45354756178784">
<h1>Remote Debugging</h1>

<p>Remote debugging <a data-primary="Ray" data-secondary="debugging with" data-tertiary="remote debugging" data-type="indexterm" id="idm45354756177248"/><a data-primary="debugging with Ray" data-secondary="remote debugging" data-type="indexterm" id="idm45354756158304"/><a data-primary="remote debugging" data-type="indexterm" id="idm45354756157456"/>can be an excellent tool but requires more access to the cluster, something that may not always be available. Ray’s own special integrated <code>ray debug</code> tool supports tracing across the entire cluster. Unfortunately, other remote Python debuggers attach to only one machine at a time, so you can’t simply point your debugger at an entire cluster.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Remote debugging can result in large performance changes and security implications. It is important to notify all users before 
<span class="keep-together">enabling</span> remote debugging on a cluster.</p>
</div>

<p>If you control your own environment, setting up remote debugging is comparatively straightforward, but in an enterprise deployment, you may find resistance to enabling this. In those situations, using a local cluster or asking for a development cluster to debug on are your best options.</p>
<div data-type="tip"><h6>Tip</h6>
<p>For interactive debuggers, you may need to work with your systems administrator to expose additional ports from your cluster.</p>
</div>








<section data-pdf-bookmark="Ray’s Integrated Debugger (via Pdb)" data-type="sect2"><div class="sect2" id="idm45354756153024">
<h2>Ray’s Integrated Debugger (via Pdb)</h2>

<p>Ray has <a data-primary="Ray" data-secondary="debugging with" data-tertiary="integrated debugger via Pdb" data-type="indexterm" id="idm45354756151728"/><a data-primary="debugging with Ray" data-secondary="integrated debugger via Pdb" data-type="indexterm" id="idm45354756150480"/><a data-primary="integrated debugger" data-type="indexterm" id="idm45354756149568"/><a data-primary="Pdb, integrated debugger via" data-type="indexterm" id="idm45354756148896"/>integrated support for debugging with Pdb, allowing you to trace code across your cluster. You still need to change the launch command (<code>ray start</code>) to include (<code>ray start --ray-debugger-external</code>) to load the debugger. With Ray’s external debugger enabled on the workers, Pdb will listen on an additional port (without any authentication) for debuggers to connect.</p>

<p>Once your cluster is configured and launched, you can start the Ray debugger on the head node.<sup><a data-type="noteref" href="app03.html#idm45354756146752" id="idm45354756146752-marker">1</a></sup> To start the debugger, you just need to run <code>ray debug</code>, and then you can use all of your favorite <a href="https://oreil.ly/mR50g">Pdb debugging commands</a>.</p>
</div></section>








<section data-pdf-bookmark="Other Tools" data-type="sect2"><div class="sect2" id="idm45354756143712">
<h2>Other Tools</h2>

<p>For nonintegrated tools,<a data-primary="Ray" data-secondary="debugging with" data-tertiary="remote functions and" data-type="indexterm" id="idm45354756142304"/><a data-primary="debugging with Ray" data-secondary="remote functions and" data-type="indexterm" id="idm45354756141056"/><a data-primary="remote functions" data-secondary="debugging" data-type="indexterm" id="idm45354756140112"/> since each call to a remote function can be scheduled on a different worker, you may find it easier to (temporarily) convert your stateless function into an actor. This will have real performance considerations, so may not be suitable for a production environment, but does mean that repeated calls will be routed to the same machine, making the task of debugging simpler.</p>










<section data-pdf-bookmark="PyCharm" data-type="sect3"><div class="sect3" id="idm45354756138912">
<h3>PyCharm</h3>

<p>PyCharm is<a data-primary="Ray" data-secondary="debugging with" data-tertiary="PyCharm" data-type="indexterm" id="idm45354756137616"/><a data-primary="debugging with Ray" data-secondary="PyCharm" data-type="indexterm" id="idm45354756136336"/><a data-primary="PyCharm" data-type="indexterm" id="idm45354756135392"/> a popular Python IDE with an integrated debugger. While it is not integrated like Pdb, you can still make it work with a few simple changes. The first step is to add the <code>pydevd-pycharm</code> package to your container/requirements. Then, in the actor you want to debug, you can enable PyCharm debugging as shown in <a data-type="xref" href="#ex_pydev_charm">Example C-3</a>.</p>
<div data-type="example" id="ex_pydev_charm">
<h5><span class="label">Example C-3. </span><a href="https://oreil.ly/eygeJ">Enabled PyCharm remote debugging</a></h5>

<pre data-code-language="python" data-type="programlisting"><code class="nd">@ray</code><code class="o">.</code><code class="n">remote</code>
<code class="k">class</code> <code class="nc">Bloop</code><code class="p">():</code>
    
    <code class="k">def</code> <code class="fm">__init__</code><code class="p">(</code><code class="bp">self</code><code class="p">,</code> <code class="n">dev_host</code><code class="p">):</code>
        <code class="kn">import</code> <code class="nn">pydevd_pycharm</code>
        <code class="c1"># Requires ability to connect to dev from prod.</code>
        <code class="k">try</code><code class="p">:</code>
            <code class="n">pydevd_pycharm</code><code class="o">.</code><code class="n">settrace</code><code class="p">(</code>
                <code class="n">dev_host</code><code class="p">,</code> <code class="n">port</code><code class="o">=</code><code class="mi">7779</code><code class="p">,</code> <code class="n">stdoutToServer</code><code class="o">=</code><code class="kc">True</code><code class="p">,</code> <code class="n">stderrToServer</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code>
        <code class="k">except</code> <code class="ne">ConnectionRefusedError</code><code class="p">:</code>
            <code class="nb">print</code><code class="p">(</code><code class="s2">"Skipping debug"</code><code class="p">)</code>
            <code class="k">pass</code>
    
    <code class="k">def</code> <code class="nf">dothing</code><code class="p">(</code><code class="n">x</code><code class="p">):</code>
        <code class="k">return</code> <code class="n">x</code> <code class="o">+</code> <code class="mi">1</code></pre></div>

<p>Your actor will then create a connection back from the executor to your PyCharm IDE.</p>
</div></section>










<section data-pdf-bookmark="Python profilers" data-type="sect3"><div class="sect3" id="idm45354756040432">
<h3>Python profilers</h3>

<p>Python profilers<a data-primary="Ray" data-secondary="debugging with" data-tertiary="Python profilers" data-type="indexterm" id="ray-debug-profiler"/><a data-primary="debugging with Ray" data-secondary="Python profilers" data-type="indexterm" id="debug-ray-profile"/><a data-primary="Python profilers" data-type="indexterm" id="python-profile"/><a data-primary="profilers" data-type="indexterm" id="profilers"/> can help track down memory leaks, hot code paths, and other important-to-address non-error states.</p>

<p>Profilers are less problematic than live remote debugging from a security point of view, as they do not require a direct connection from your machine to the cluster. Instead, the profiler runs and generates a report, which you can look at offline. Profiling still introduces performance overhead, so be careful when deciding whether to enable it.</p>

<p>To enable Python memory profiling on the executors, you can change the launch command to have the prefix <code>mprof run -E --include-children, -o memory​_pro⁠file.dat --python</code>. You can then collect the <code>memory_profile</code> and plot them with <code>matplotlib</code> on your machine to see if anything sticks out.</p>

<p>Similarly, you can enable function profiling in your <code>ray execute</code> by replacing <code>ray start</code> in your launch command with <code>echo "from ray.scripts.scripts import main; main()" &gt; launch.py; python -m cProfile -o stats launch.py</code>. This is a bit more complicated than using <code>mprof</code> since the default Ray launch script does not play nice with the <code>cProfile</code>, so you need to create a different entry point—​but conceptually it is equivalent.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>The <code>line_profiler</code> package used for annotation-based profiling does not work well with Ray, so you must use whole program<a data-primary="Ray" data-secondary="debugging with" data-startref="ray-debug-profiler" data-tertiary="Python profilers" data-type="indexterm" id="idm45354756027296"/><a data-primary="debugging with Ray" data-secondary="Python profilers" data-startref="debug-ray-profile" data-type="indexterm" id="idm45354756025776"/><a data-primary="Python profilers" data-startref="python-profile" data-type="indexterm" id="idm45354756024560"/><a data-primary="profilers" data-startref="profilers" data-type="indexterm" id="idm45354756023616"/> profiling.</p>
</div>
</div></section>
</div></section>
</div></section>






<section data-pdf-bookmark="Ray and Container Exit Codes" data-type="sect1"><div class="sect1" id="idm45354756022160">
<h1>Ray and Container Exit Codes</h1>

<p><em>Exit codes</em> are<a data-primary="Ray" data-secondary="debugging with" data-tertiary="exit codes" data-type="indexterm" id="ray-debug-exit"/><a data-primary="debugging with Ray" data-secondary="exit codes" data-type="indexterm" id="debug-ray-exit"/><a data-primary="exit codes" data-type="indexterm" id="exit-code"/> numeric codes that are set when a program exits, with any value besides 0 normally indicating failure. These codes (by convention) generally have meaning but are not 100% consistent. The following are some common exit codes:</p>
<dl>
<dt>0</dt>
<dd>
<p>Success (but often misreported, especially in shell scripts)</p>
</dd>
<dt>1</dt>
<dd>
<p>Generic error</p>
</dd>
<dt>127</dt>
<dd>
<p>Command not found (in a shell script)</p>
</dd>
<dt>130</dt>
<dd>
<p>User terminated (Ctrl-C or kill)</p>
</dd>
<dt>137</dt>
<dd>
<p>Out-of-memory error <em>or</em> kill -9 (force kill, not ignorable)</p>
</dd>
<dt>139</dt>
<dd>
<p>Segmentation fault (often null pointer dereference in native code)</p>
</dd>
</dl>

<p>You can print out the exit code of the last command run with <code>echo $?</code>. In a script running in strict mode (like some Ray launch scripts), you can print out the exit code while still propagating the error <a data-primary="Ray" data-secondary="debugging with" data-startref="ray-debug-exit" data-tertiary="exit codes" data-type="indexterm" id="idm45354756007040"/><a data-primary="debugging with Ray" data-secondary="exit codes" data-startref="debug-ray-exit" data-type="indexterm" id="idm45354756005520"/><a data-primary="exit codes" data-startref="exit-code" data-type="indexterm" id="idm45354756004304"/>with <code>[raycommand] || (error=$?; echo $error; exit $error)</code>.<sup><a data-type="noteref" href="app03.html#idm45354756002752" id="idm45354756002752-marker">2</a></sup></p>
</div></section>






<section data-pdf-bookmark="Ray Logs" data-type="sect1"><div class="sect1" id="idm45354756001104">
<h1>Ray Logs</h1>

<p>Ray’s logs <a data-primary="Ray" data-secondary="debugging with" data-tertiary="logs" data-type="indexterm" id="idm45354755999808"/><a data-primary="debugging with Ray" data-secondary="logs" data-type="indexterm" id="idm45354755998528"/><a data-primary="logs" data-type="indexterm" id="idm45354755997584"/>behave differently from those of many other distributed applications. Since Ray tends to launch worker processes on the container separate from the initial container startup,<sup><a data-type="noteref" href="app03.html#idm45354755996784" id="idm45354755996784-marker">3</a></sup> the stdout and stderr associated with the container will (most often) not contain the debugging information you need. Instead, you can access the worker container logs on the head node by looking for the latest session directory to which Ray creates a symbolic link at <em>/tmp/ray/session_latest</em>.</p>
</div></section>






<section data-pdf-bookmark="Container Errors" data-type="sect1"><div class="sect1" id="idm45354755994560">
<h1>Container Errors</h1>

<p>Debugging <a data-primary="Ray" data-secondary="debugging with" data-tertiary="container errors" data-type="indexterm" id="idm45354755993200"/><a data-primary="debugging with Ray" data-secondary="container errors" data-type="indexterm" id="idm45354755991920"/><a data-primary="container errors" data-type="indexterm" id="idm45354756243360"/>container errors can be especially challenging, as many of the standard debugging techniques explored so far have challenges. These errors can range from common occurrences, like OOM errors, to the more esoteric. It can be difficult to distinguish the cause of the container error or exit as the container exit sometimes removes the logs.</p>

<p>On Kubernetes, you can sometimes get the logs of a container that has already exited by adding <code>-p</code> to your log request (e.g., <code>kubectl logs -p</code>). You can also configure <code>terminationMessagePath</code> to point to a file that contains information regarding termination exit. If your Ray worker is exiting, it can make sense to customize the Ray container launch script to add more logging. Common types of additional logging include the last few lines from <em>syslog</em> or <em>dmesg</em> (looking for OOMs) to a file location that you can use to debug later.</p>

<p>The most common kind of container error, native memory leaks, can be challenging to debug. Tools like <a href="https://oreil.ly/8E9iG">Valgrind</a> can sometimes track down native memory leaks. The details of using tools like Valgrind are beyond the scope of this book, so check out the <a href="https://oreil.ly/jzRwT">Python Valgrind documentation</a>. Another “trick” you might want to try is effectively bisecting your code; since native memory leaks happen most frequently in library calls, you can try commenting them out and running tests to see which library call is the source of the leak.</p>
</div></section>






<section data-pdf-bookmark="Native Errors" data-type="sect1"><div class="sect1" id="idm45354755985616">
<h1>Native Errors</h1>

<p>Native errors<a data-primary="Ray" data-secondary="debugging with" data-tertiary="native errors" data-type="indexterm" id="idm45354755984288"/><a data-primary="debugging with Ray" data-secondary="native errors" data-type="indexterm" id="idm45354755983008"/><a data-primary="native errors" data-type="indexterm" id="idm45354755982064"/><a data-primary="errors" data-see="debugging with Ray" data-type="indexterm" id="idm45354755981392"/> and core dumps can be challenging to debug for the same reasons as container errors. Since these types of errors often result in the container exiting, accessing the debugging information can become challenging. A “quick” solution to this is to add <code>sleep</code> to the Ray launch script (on failure) so that you can connect to the container (e.g., <code>[raylaunchcommand] || sleep 100000</code>) and use native debugging tools.</p>

<p>However, accessing the internals of a container can be easier said than done. In many production environments, you may not be able to get remote access (e.g., <code>kubectly exec</code> on Kubernetes) for security reasons. If that is the case, you can (sometimes) add a shutdown script to your container specification that copies the core files to a location that persists after the container shuts down (e.g., s3, HDFS, or NFS).</p>
</div></section>






<section data-pdf-bookmark="Conclusion" data-type="sect1"><div class="sect1" id="idm45354755978464">
<h1>Conclusion</h1>

<p>You will have a bit more work to get started with your debugging tools in Ray, and when possible, Ray’s local mode offers a great alternative to remote debugging. You can take advantage of Ray actors to make remote functions schedule more predictably, making it easier to know where to attach your debugging tools. Not all errors are created equal, and some errors, like segmentation faults in native code, are especially challenging to debug. Good luck finding the bug(s)! We believe in you.</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45354756146752"><sup><a href="app03.html#idm45354756146752-marker">1</a></sup> Ray has the <code>ray attach</code> command to create an SSH connection to the head node; however, not all head nodes will have an SSH server. On Ray on Kubernetes, you can get to the head node by running <code>kubectl exec -it -n [rayns] [podname] – /bin/bash</code>. Each cluster manager is slightly different here, so you may have to check your cluster manager’s documentation.</p><p data-type="footnote" id="idm45354756002752"><sup><a href="app03.html#idm45354756002752-marker">2</a></sup> The exact details of where to configure this change depends on the cluster manager being used. For Ray on Kube with the autoscaler, you can change <code>workerStartRayCommands</code>. For Ray on AWS, change <code>worker_start_ray_commands</code>, etc.</p><p data-type="footnote" id="idm45354755996784"><sup><a href="app03.html#idm45354755996784-marker">3</a></sup> This is done either by <code>ssh</code> or <code>kubectl exec</code>.</p></div></div></section></body></html>