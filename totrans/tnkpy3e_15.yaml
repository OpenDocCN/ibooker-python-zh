- en: 13\. Files and Databases#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://allendowney.github.io/ThinkPython/chap13.html](https://allendowney.github.io/ThinkPython/chap13.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Most of the programs we have seen so far are **ephemeral** in the sense that
    they run for a short time and produce output, but when they end, their data disappears.
    Each time you run an ephemeral program, it starts with a clean slate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other programs are **persistent**: they run for a long time (or all the time);
    they keep at least some of their data in long-term storage; and if they shut down
    and restart, they pick up where they left off.'
  prefs: []
  type: TYPE_NORMAL
- en: A simple way for programs to maintain their data is by reading and writing text
    files. A more versatile alternative is to store data in a database. Databases
    are specialized files that can be read and written more efficiently than text
    files, and they provide additional capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll write programs that read and write text files and databases,
    and as an exercise you’ll write a program that searches a collection of photos
    for duplicates. But before you can work with a file, you have to find it, so we’ll
    start with file names, paths, and directories.
  prefs: []
  type: TYPE_NORMAL
- en: 13.1\. Filenames and paths[#](#filenames-and-paths "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Files are organized into **directories**, also called “folders”. Every running
    program has a **current working directory**, which is the default directory for
    most operations. For example, when you open a file, Python looks for it in the
    current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: The `os` module provides functions for working with files and directories (“os”
    stands for “operating system”). It provides a function called `getcwd` that gets
    the name of the current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The result in this example is the home directory of a user named `dinsdale`.
    A string like `'/home/dinsdale'` that identifies a file or directory is called
    a **path**.
  prefs: []
  type: TYPE_NORMAL
- en: A simple filename like `'memo.txt'` is also considered a path, but it is a **relative
    path** because it specifies a file name relative to the current directory. In
    this example, the current directory is `/home/dinsdale`, so `'memo.txt'` is equivalent
    to the complete path `'/home/dinsdale/memo.txt'`.
  prefs: []
  type: TYPE_NORMAL
- en: A path that begins with `/` does not depend on the current directory – it is
    called an **absolute path**. To find the absolute path to a file, you can use
    `abspath`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `os` module provides other functions for working with filenames and paths.
    `listdir` returns a list of the contents of the given directory, including files
    and other directories. Here’s an example that lists the contents of a directory
    named `photos`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This directory contains a text file named `notes.txt` and three directories.
    The directories contain image files in the JPEG format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To check whether a file or directory exists, we can use `os.path.exists`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To check whether a path refers to a file or directory, we can use `isdir`, which
    return `True` if a path refers to a directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: And `isfile` which returns `True` if a path refers to a file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: One challenge of working with paths is that they look different on different
    operating systems. On macOS and UNIX systems like Linux, the directory and file
    names in a path are separated by a forward slash, `/`. Windows uses a backward
    slash, `\`. So, if you you run these examples on Windows, you will see backward
    slashes in the paths, and you’ll have to replace the forward slashes in the examples.
  prefs: []
  type: TYPE_NORMAL
- en: Or, to write code that works on both systems, you can use `os.path.join`, which
    joins directory and filenames into a path using a forward or backward slash, depending
    on which operating system you are using.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Later in this chapter we’ll use these functions to search a set of directories
    and find all of the image files.
  prefs: []
  type: TYPE_NORMAL
- en: 13.2\. f-strings[#](#f-strings "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way for programs to store data is to write it to a text file. For example,
    suppose you are a camel spotter, and you want to record the number of camels you
    have seen during a period of observation. And suppose that in one and a half years,
    you have spotted `23` camels. The data in your camel-spotting book might look
    like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To write this data to a file, you can use the `write` method, which we saw in
    Chapter 8. The argument of `write` has to be a string, so if we want to put other
    values in a file, we have to convert them to strings. The easiest way to do that
    is with the built-in function `str`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: That works, but `write` doesn’t add a space or newline unless you include it
    explicitly. If we read back the file, we see that the two numbers are run together.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: At the very least, we should add whitespace between the numbers. And while we’re
    at it, let’s add some explanatory text.
  prefs: []
  type: TYPE_NORMAL
- en: To write a combination of strings and other values, we can use an **f-string**,
    which is a string that has the letter `f` before the opening quotation mark, and
    contains one or more Python expressions in curly braces. The following f-string
    contains one expression, which is a variable name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The result is a string where the expression has been evaluated and replaced
    with the result. There can be more than one expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: And the expressions can contain operators and function calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: So we could write the data to a text file like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Both f-strings end with the sequence `\n`, which adds a newline character.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can read the file back like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In an f-string, an expression in curly brace is converted to a string, so you
    can include lists, dictionaries, and other types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 13.3\. YAML[#](#yaml "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the reasons programs read and write files is to store **configuration
    data**, which is information that specifies what the program should do and how.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in a program that searches for duplicate photos, we might have
    a dictionary called `config` that contains the name of the directory to search,
    the name of another directory where it should store the results, and a list of
    file extensions it should use to identify image files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what it might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: To write this data in a text file, we could use f-strings, as in the previous
    section. But it is easier to use a module called `yaml` that is designed for just
    this sort of thing.
  prefs: []
  type: TYPE_NORMAL
- en: The `yaml` module provides functions to work with YAML files, which are text
    files formatted to be easy for humans *and* programs to read and write.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example that uses the `dump` function to write the `config` dictionary
    to a YAML file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If we read back the contents of the file, we can see what the YAML format looks
    like.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can use `safe_load` to read back the YAML file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The result is new dictionary that contains the same information as the original,
    but it is not the same dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Converting an object like a dictionary to a string is called **serialization**.
    Converting the string back to an object is called **deserialization**. If you
    serialize and then deserialize an object, the result should be equivalent to the
    original.
  prefs: []
  type: TYPE_NORMAL
- en: 13.4\. Shelve[#](#shelve "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far we’ve been reading and writing text files – now let’s consider databases.
    A **database** is a file that is organized for storing data. Some databases are
    organized like a table with rows and columns of information. Others are organized
    like a dictionary that maps from keys to values; they are sometimes called **key-value
    stores**.
  prefs: []
  type: TYPE_NORMAL
- en: The `shelve` module provides functions for creating and updating a key-value
    store called a “shelf”. As an example, we’ll create a shelf to contain captions
    for the figures in the `photos` directory. We’ll use the `config` dictionary to
    get the name of the directory where we should put the shelf.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We can use `os.makedirs` to create this directory, if it doesn’t already exist.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: And `os.path.join` to make a path that includes the name of the directory and
    the name of the shelf file, `captions`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now we can use `shelve.open` to open the shelf file. The argument `c` indicates
    that the file should be created if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The return value is officially a `DbfilenameShelf` object, more casually called
    a shelf object.
  prefs: []
  type: TYPE_NORMAL
- en: The shelf object behaves in many ways like a dictionary. For example, we can
    use the bracket operator to add an item, which is a mapping from a key to a value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the key is the path to an image file and the value is a string
    that describes the image.
  prefs: []
  type: TYPE_NORMAL
- en: We also use the bracket operator to look up a key and get the corresponding
    value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: If you make another assignment to an existing key, `shelve` replaces the old
    value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Some dictionary methods, like `keys`, `values` and `items`, also work with shelf
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We can use the `in` operator to check whether a key appears in the shelf.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: And we can use a `for` statement to loop through the keys.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As with other files, you should close the database when you are done.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Now if we list the contents of the data directory, we see two files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '`captions.dat` contains the data we just stored. `captions.dir` contains information
    about the organization of the database that makes it more efficient to access.
    The suffix `dir` stands for “directory”, but it has nothing to do with the directories
    we’ve been working with that contain files.'
  prefs: []
  type: TYPE_NORMAL
- en: '## 13.5\. Storing data structures[#](#storing-data-structures "Link to this
    heading")'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, the keys and values in the shelf are strings. But we
    can also use a shelf to contain data structures like lists and dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let’s revisit the anagram example from an exercise in [Chapter
    11](chap11.html#section-exercise-11). Recall that we made a dictionary that maps
    from a sorted string of letters to the list of words that can be spelled with
    those letters. For example, the key `'opst'` maps to the list `['opts', 'post',
    'pots', 'spot', 'stop', 'tops']`.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the following function to sort the letters in a word.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: And here’s an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s open a shelf called `anagram_map`. The argument `'n'` means we should
    always create a new, empty shelf, even if one already exists.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Now we can add an item to the shelf like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In this item, the key is a string and the value is a list of strings.
  prefs: []
  type: TYPE_NORMAL
- en: Now suppose we find another word that contains the same letters, like `tops`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The key is the same as in the previous example, so we want to append a second
    word to the same list of strings. Here’s how we would do it if `db` were a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: But if we run that and then look up the key in the shelf, it looks like it has
    not been updated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the problem: when we look up the key, we get a list of strings, but
    if we modify the list of strings, it does not affect the shelf. If we want to
    update the shelf, we have to read the old value, update it, and then write the
    new value back to the shelf.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Now the value in the shelf is updated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'As an exercise, you can finish this example by reading the word list and storing
    all of the anagrams in a shelf.  ## 13.6\. Checking for equivalent files[#](#checking-for-equivalent-files
    "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s get back to the goal of this chapter: searching for different files
    that contain the same data. One way to check is to read the contents of both files
    and compare.'
  prefs: []
  type: TYPE_NORMAL
- en: If the files contain images, we have to open them with mode `'rb'`, where `'r'`
    means we want to read the contents and `'b'` indicates **binary mode**. In binary
    mode, the contents are not interpreted as text – they are treated as a sequence
    of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example that opens and reads an image file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The result from `read` is a `bytes` object – as the name suggests, it contains
    a sequence of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: In general the contents of an image file and not human-readable. But if we read
    the contents from a second file, we can use the `==` operator to compare.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: These two files are not equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s encapsulate what we have so far in a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: If we have only two files, this function is a good option. But suppose we have
    a large number of files and we want to know whether any two of them contain the
    same data. It would be inefficient to compare every pair of files.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative is to use a **hash function**, which takes the contents of a
    file and computes a **digest**, which is usually a large integer. If two files
    contain the same data, they will have the same digest. If two files differ, they
    will *almost always* have different digests.
  prefs: []
  type: TYPE_NORMAL
- en: The `hashlib` module provides several hash functions – the one we’ll use is
    called `md5`. We’ll start by using `hashlib.md5` to create a `HASH` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The `HASH` object provides an `update` method that takes the contents of the
    file as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Now we can use `hexdigest` to get the digest as a string of hexadecimal digits
    that represent an integer in base 16.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The following function encapsulates these steps.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: If we hash the contents of a different file, we can confirm that we get a different
    digest.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have almost everything we need to find equivalent files. The last step
    is to search a directory and find all of the images files.  ## 13.7\. Walking
    directories[#](#walking-directories "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: The following function takes as an argument the directory we want to search.
    It uses `listdir` to loop through the contents of the directory. When it finds
    a file, it prints its complete path. When it finds a directory, it calls itself
    recursively to search the subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The order of the results depends on details of the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 13.8\. Debugging[#](#debugging "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are reading and writing files, you might run into problems with whitespace.
    These errors can be hard to debug because whitespace characters are normally invisible.
    For example, here’s a string that contains spaces, a tab represented by the sequence
    `\t`, and a newline represented by the sequence `\n`. When we print it, we don’t
    see the whitespace characters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The built-in function `repr` can help. It takes any object as an argument and
    returns a string representation of the object. For strings, it represents whitespace
    characters with backslash sequences.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: This can be helpful for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: One other problem you might run into is that different systems use different
    characters to indicate the end of a line. Some systems use a newline, represented
    `\n`. Others use a return character, represented `\r`. Some use both. If you move
    files between different systems, these inconsistencies can cause problems.
  prefs: []
  type: TYPE_NORMAL
- en: File name capitalization is another issue you might encounter if you work with
    different operating systems. In macOS and UNIX, file names can contain lowercase
    and uppercase letters, digits, and most symbols. But many Windows applications
    ignore the difference between lowercase and uppercase letters, and several symbols
    that are allowed in macOS and UNIX are not allowed in Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 13.9\. Glossary[#](#glossary "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**ephemeral:** An ephemeral program typically runs for a short time and, when
    it ends, its data are lost.'
  prefs: []
  type: TYPE_NORMAL
- en: '**persistent:** A persistent program runs indefinitely and keeps at least some
    of its data in permanent storage.'
  prefs: []
  type: TYPE_NORMAL
- en: '**directory:** A collection of files and other directories.'
  prefs: []
  type: TYPE_NORMAL
- en: '**current working directory:** The default directory used by a program unless
    another directory is specified.'
  prefs: []
  type: TYPE_NORMAL
- en: '**path:** A string that specifies a sequence of directories, often leading
    to a file.'
  prefs: []
  type: TYPE_NORMAL
- en: '**relative path:** A path that starts from the current working directory, or
    some other specified directory.'
  prefs: []
  type: TYPE_NORMAL
- en: '**absolute path:** A path that does not depend on the current directory.'
  prefs: []
  type: TYPE_NORMAL
- en: '**f-string:** A string that has the letter `f` before the opening quotation
    mark, and contains one or more expressions in curly braces.'
  prefs: []
  type: TYPE_NORMAL
- en: '**configuration data:** Data, often stored in a file, that specifies what a
    program should do and how.'
  prefs: []
  type: TYPE_NORMAL
- en: '**serialization:** Converting an object to a string.'
  prefs: []
  type: TYPE_NORMAL
- en: '**deserialization:** Converting a string to an object.'
  prefs: []
  type: TYPE_NORMAL
- en: '**database:** A file whose contents are organized to perform certain operations
    efficiently.'
  prefs: []
  type: TYPE_NORMAL
- en: '**key-value stores:** A database whose contents are organized like a dictionary
    with keys that correspond to values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**binary mode:** A way of opening a file so the contents are interpreted as
    sequence of bytes rather than a sequence of characters.'
  prefs: []
  type: TYPE_NORMAL
- en: '**hash function:** A function that takes and object and computes an integer,
    which is sometimes called a digest.'
  prefs: []
  type: TYPE_NORMAL
- en: '**digest:** The result of a hash function, especially when it is used to check
    whether two objects are the same.'
  prefs: []
  type: TYPE_NORMAL
- en: 13.10\. Exercises[#](#exercises "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 13.10.1\. Ask a virtual assistant[#](#ask-a-virtual-assistant "Link to this
    heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several topics that came up in this chapter that I did not explain
    in detail. Here are some questions you can ask a virtual assistant to get more
    information.
  prefs: []
  type: TYPE_NORMAL
- en: “What are the differences between ephemeral and persistent programs?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “What are some examples of persistent programs?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “What’s the difference between a relative path and an absolute path?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Why does the `yaml` module have functions called `load` and `safe_load`?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “When I write a Python shelf, what are the files with suffixes `dat` and `dir`?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Other than key-values stores, what other kinds of databases are there?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “When I read a file, what’s the difference between binary mode and text mode?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “What are the differences between a bytes object and a string?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “What is a hash function?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “What is an MD5 digest?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As always, if you get stuck on any of the following exercises, consider asking
    a VA for help. Along with your question, you might want to paste in the relevant
    functions from this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 13.10.2\. Exercise[#](#exercise "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Write a function called `replace_all` that takes as arguments a pattern string,
    a replacement string, and two filenames. It should read the first file and write
    the contents into the second file (creating it if necessary). If the pattern string
    appears anywhere in the contents, it should be replaced with the replacement string.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an outline of the function to get you started.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: To test your function, read the file `photos/notes.txt`, replace `'photos'`
    with `'images'`, and write the result to the file `photos/new_notes.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 13.10.3\. Exercise[#](#id1 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [a previous section](#section-storing-data-structure), we used the `shelve`
    module to make a key-value store that maps from a sorted string of letters to
    a list of anagrams. To finish the example, write a function called `add_word`
    that takes as arguments a string and a shelf object.
  prefs: []
  type: TYPE_NORMAL
- en: It should sort the letters of the word to make a key, then check whether the
    key is already in the shelf. If not, it should make a list that contains the new
    word and add it to the shelf. If so, it should append the new word to the existing
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 13.10.4\. Exercise[#](#id2 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a large collection of files, there may be more than one copy of the same
    file, stored in different directories or with different file names. The goal of
    this exercise is to search for duplicates. As an example, we’ll work with image
    files in the `photos` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it will work:'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the `walk` function from [Walking directories](#section-walking-directories)
    to search this directory for files that end with one of the extensions in `config['extensions']`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each file, we’ll use `md5_digest` from [Checking for equivalent files](#section-md5-digest)
    to compute a digest of the contents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a shelf, we’ll make a mapping from each digest to a list of paths with
    that digest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we’ll search the shelf for any digests that map to multiple files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we find any, we’ll use `same_contents` to confirm that the files contain
    the same data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’ll suggest some functions to write first, then we’ll bring it all together.
  prefs: []
  type: TYPE_NORMAL
- en: 'To identify image files, write a function called `is_image` that takes a path
    and a list of file extensions, and returns `True` if the path ends with one of
    the extensions in the list. Hint: Use `os.path.splitext` – or ask a virtual assistant
    to write this function for you.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a function called `add_path` that takes as arguments a path and a shelf.
    It should use `md5_digest` to compute a digest of the file contents. Then it should
    update the shelf, either creating a new item that maps from the digest to a list
    containing the path, or appending the path to the list if it exists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a version of `walk` called `walk_images` that takes a directory and walks
    through the files in the directory and its subdirectories. For each file, it should
    use `is_image` to check whether it’s an image file and `add_path` to add it to
    the shelf.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When everything is working, you can use the following program to create the
    shelf, search the `photos` directory and add paths to the shelf, and then check
    whether there are multiple files with the same digest.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: You should find one pair of files that have the same digest. Use `same_contents`
    to check whether they contain the same data.
  prefs: []
  type: TYPE_NORMAL
- en: '[Think Python: 3rd Edition](https://allendowney.github.io/ThinkPython/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Copyright 2024 [Allen B. Downey](https://allendowney.com)
  prefs: []
  type: TYPE_NORMAL
- en: 'Code license: [MIT License](https://mit-license.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Text license: [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
  prefs: []
  type: TYPE_NORMAL
