<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 1. Installing Python"><div class="chapter" id="chapter_installing">
<h1><span class="label">Chapter 1. </span>Installing Python</h1>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id232">
<h1>A Note for Early Release Readers</h1>
<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>

<p>This will be the first chapter of the final book. Please note that the GitHub repo will be made active later on.</p>

<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the author at <a href="mailto:mail@claudiojolowicz.com">mail@claudiojolowicz.com</a>.</p>
</div></aside>

<p>If you’ve picked up this book, you likely have Python installed on your machine
already. Most common operating systems ship with a <code>python3</code> command. This can
be the interpreter used by the system itself; on Windows and macOS, it’s a
placeholder that installs Python for you when you invoke it for the first time.</p>

<p>Why dedicate an entire chapter to the topic if it’s so easy to get Python onto a
new machine? The answer is that installing Python for long-term development can
be a complex matter, and there are several reasons for this:</p>

<ul>
<li>
<p>You generally need multiple versions of Python installed side-by-side. (If
you’re wondering why, we’ll get to that shortly.)</p>
</li>
<li>
<p>There are a few different ways to install Python across the common platforms,
each with unique advantages, tradeoffs, and sometimes pitfalls.</p>
</li>
<li>
<p>Python is a moving target: You need to keep existing installations up-to-date
with the latest maintenance release, add installations when a new feature
version is published, and remove versions that are no longer supported. You
may even need to test a prerelease of the next Python.</p>
</li>
<li>
<p>You may want your code to run on multiple platforms. While Python makes it
easy to write portable programs, setting up a developer environment requires
some familiarity with the idiosyncrasies of each platform.</p>
</li>
<li>
<p>You may want to run your code with an alternative implementation of
Python.<sup><a data-type="noteref" id="id233-marker" href="ch01.html#id233">1</a></sup></p>
</li>
</ul>

<p>In this first chapter, I’ll show you how to install multiple Python versions on
some of the major operating systems in a sustainable way, and how to keep your
little snake farm in good shape.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Even if you only develop for a single platform, I’d encourage you to learn about
working with Python on other operating systems. It’s fun—​and familiarity with
other platforms enables you to provide a better experience to the contributors
and users of your software.</p>
</div>






<section data-type="sect1" data-pdf-bookmark="Supporting Multiple Versions of Python"><div class="sect1" id="section_installing_multiple_versions">
<h1>Supporting Multiple Versions of Python</h1>

<p>Python programs often target several versions of the language and standard
library at once. This may come as a surprise. Why would you run your code with
anything but the latest Python? After all, this lets your programs benefit from
new language features and library improvements immediately.</p>

<p>As it turns out, runtime environments often come with a variety of older
versions of Python.<sup><a data-type="noteref" id="id234-marker" href="ch01.html#id234">2</a></sup> Even
if you have tight control over your deployment environments, you may want to get
into the habit of testing against multiple versions. The day the trusty Python
in your production environment features in a security advisory had better not be
the day you start porting your code to newer releases.</p>

<p>For these reasons, it’s common to support both current and past versions of
Python until their official end-of-life date, and to set up installations for
them side-by-side on a developer machine. With new feature versions coming out
every year and support extending over five years, this gives you a testing
matrix of five actively supported versions (see
<a data-type="xref" href="#figure_python_release_cycle">Figure 1-1</a>). If that sounds like a lot of work, don’t
worry: the Python ecosystem comes with tooling that makes this a breeze.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_python_release_cycle">
<h1>The Python Release Cycle</h1>
<p>Python has an annual release cycle: feature releases happen every October. Each
feature release gets a new minor version in Python’s <code>major.minor.micro</code> scheme.
By contrast, new major versions are rare and reserved for strongly incompatible
changes—​as I write this in early 2024, a Python 4 is not in sight. Python’s
backward compatibility policy allows incompatible changes in minor releases when
preceded by a two-year deprecation period.</p>

<p>Feature versions are maintained for five years, after which they reach
end-of-life. Bugfix releases for a feature version occur roughly every other
month during the first 18 months after its initial release.<sup><a data-type="noteref" id="id235-marker" href="ch01.html#id235">3</a></sup> This is followed by security updates whenever necessary during the
remainder of the five-year support period. Each maintenance release bumps the
micro version.</p>

<p>Prereleases for upcoming Python feature releases happen throughout the year
before their publication. These prereleases fall into three consecutive phases:
alphas, betas, and release candidates. You can recognize them by the suffix that
gets appended to the upcoming Python version, indicating the release status and
sequence number, such as <code>a1</code>, <code>b3</code>, <code>rc2</code>.</p>

<figure><div id="figure_python_release_cycle" class="figure">
<img src="assets/hmpt_0101.png" alt="The diagram shows a timeline of Python versions from 2024 to 2029, with prereleases, feature release, bugfix releases, and security updates." width="3544" height="1361"/>
<h6><span class="label">Figure 1-1. </span>Timeline of Python releases</h6>
</div></figure>
</div></aside>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Locating Python Interpreters"><div class="sect1" id="section_path">
<h1>Locating Python Interpreters</h1>

<p>How do you select the correct Python interpreter if you have multiple on your
system? Let’s look at a concrete example. When you type <code>python3</code> at the command
line, the shell searches the directories in the <code>PATH</code> environment variable from
left to right and invokes the first executable file named <code>python3</code>. Python
installations on macOS and Linux also provide commands named <code>python3.12</code>,
<code>python3.11</code>, and so on, to let you disambiguate between the different feature
versions.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>On Windows, <code>PATH</code>-based interpreter discovery is less relevant because Python
installations can be located via the Windows Registry (see
<a data-type="xref" href="#section_python_launcher_windows">“The Python Launcher for Windows”</a>). Windows installers only ship an
unversioned <code>python.exe</code> executable.</p>
</div>

<p><a data-type="xref" href="#figure_python_commands_on_path">Figure 1-2</a> shows a macOS machine with several Python
installations. Starting from the bottom, the first interpreter is located in
<em>/usr/bin/python3</em> and is part of Apple’s Command Line Tools (Python 3.9 at time
of writing). Next up, in <em>/opt/homebrew/bin</em>, are several interpreters from the
Homebrew distribution; the <code>python3</code> command here is its main interpreter
(Python 3.11). The Homebrew interpreters are followed by a prerelease from
<em>python.org</em> (Python 3.13). The top entry contains the current release (Python
3.12 as of this writing), also from Homebrew.</p>

<figure><div id="figure_python_commands_on_path" class="figure">
<img src="assets/hmpt_0102.png" alt="An example of a customized PATH on a macOS machine, with Python installations from Homebrew, python.org, and Apple's Command Line Tools." width="2840" height="1040"/>
<h6><span class="label">Figure 1-2. </span>A developer system with multiple Python installations. The search path is displayed as a stack of directories; commands at the top shadow those further down.</h6>
</div></figure>

<p>The order of directories on the search path matters because earlier entries take
precedence over, or “shadow”, later ones. In <a data-type="xref" href="#figure_python_commands_on_path">Figure 1-2</a>,
<code>python3</code> refers the current stable version (Python 3.12). If you omitted the
top entry, <code>python3</code> would refer to the prerelease (Python 3.13). Without the
top two entries, it would refer to Homebrew’s default interpreter, which is
still on the previous stable version (Python 3.11).</p>

<p>Locating Python interpreters on <code>PATH</code> is a common source of errors. Some
installations overwrite the <code>python3</code> command in shared directories such as
<em>/usr/local/bin</em>. Others place <code>python3</code> in a distinct directory and alter the
<code>PATH</code> to give it precedence, shadowing previously installed versions. To
address these issues, this book uses the Python Launcher for Unix (see
<a data-type="xref" href="#section_python_launcher_unix">“The Python Launcher for Unix”</a>). Nonetheless, understanding the <code>PATH</code>
variable’s mechanics will help you avoid issues with Python discovery on
Windows, macOS, and Linux.</p>

<p>A common default for the <code>PATH</code> variable is <code>/usr/local/bin:/usr/bin:/bin</code> on
Unix-like systems, usually combined with some OS-dependent locations. You can
modify the variable using the <code>export</code> built-in of many shells. Here’s how you
would add a Python installation in <em>/usr/local/opt/python</em> using the Bash shell:</p>

<pre data-type="programlisting" data-code-language="zsh"><code class="nb">export</code><code class="w"> </code><code class="nv">PATH</code><code class="o">=</code><code class="s2">"/usr/local/opt/python/bin:</code><code class="nv">$PATH</code><code class="s2">"</code><code class="w"/></pre>

<p>You’re adding the <em>bin</em> subdirectory instead of the installation root, because
that’s where the interpreter is normally located on these systems. We’ll take a
closer look at the layout of Python installations in <a data-type="xref" href="ch02.html#chapter_environments">Chapter 2</a>.
Also, you’re adding the directory to the front of the <code>PATH</code> variable. I’ll
explain shortly why this is usually what you want.</p>

<p>The line above also works with Zsh, which is the default shell on macOS. That
said, there’s a more idiomatic way to manipulate the search path on Zsh:</p>

<pre data-type="programlisting" data-code-language="zsh"><code class="nb">typeset</code><code class="w"> </code><code>-U</code><code class="w"> </code><code>path</code><code class="w"> </code><a class="co" id="co_installing_python_CO1-1" href="#callout_installing_python_CO1-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a><code class="w">
</code><code class="nv">path</code><code class="o">=</code><code class="o">(</code><code>/usr/local/opt/python/bin</code><code class="w"> </code><code class="nv">$path</code><code class="o">)</code><code class="w"> </code><a class="co" id="co_installing_python_CO1-2" href="#callout_installing_python_CO1-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_installing_python_CO1-1" href="#co_installing_python_CO1-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>This instructs the shell to remove duplicate entries from the search path.</p></dd>
<dt><a class="co" id="callout_installing_python_CO1-2" href="#co_installing_python_CO1-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>The shell keeps the <code>path</code> array synchronized with the <code>PATH</code> variable.</p></dd>
</dl>

<p>The Fish shell offers a function to uniquely and persistently prepend an entry
to the search path:</p>

<pre data-type="programlisting" data-code-language="fish">fish_add_path /usr/local/opt/python/bin</pre>

<p>It would be tedious to set up the search path manually at the start of every
shell session. Instead, you can place the commands above in your <em>shell
profile</em>—a file in your home directory that is read by the shell on startup.
<a data-type="xref" href="#table_shell_profiles">Table 1-1</a> shows the most common ones.</p>
<table id="table_shell_profiles">
<caption><span class="label">Table 1-1. </span>The startup files of some common shells</caption>
<thead>
<tr>
<th>Shell</th>
<th>Startup file</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Bash</p></td>
<td><p><em>.bash_profile</em> (Debian and Ubuntu: <em>.profile</em>)</p></td>
</tr>
<tr>
<td><p>Zsh</p></td>
<td><p><em>.zshrc</em></p></td>
</tr>
<tr>
<td><p>Fish</p></td>
<td><p><em>.config/fish/fish.config</em></p></td>
</tr>
</tbody>
</table>

<p>Why is it important to add new directories to the front of the <code>PATH</code> variable?
On a pristine macOS or Linux installation, the <code>python3</code> command often points to
an old version of Python. As a Python developer, your default interpreter should
be the latest stable release of Python. Prepending to <code>PATH</code> lets you control
which Python installation your shell chooses when faced with an ambiguous
command like <code>python3</code>. You can guarantee that <code>python3</code> points to the latest
stable release of Python, and that each <code>python3.x</code> points to the latest bugfix
or security release of the 3.x line.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Unless your system already comes with a well-curated and up-to-date selection of
interpreters, prepend Python installations to the <code>PATH</code> environment variable,
with the latest stable version at the very front.</p>
</div>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id236">
<h1>A Short History of PATH</h1>
<p>Curiously, the <code>PATH</code> mechanism has remained essentially the same since the
1970s. In the original design of the Unix operating system, the shell still
looked up commands entered by the user in a directory named <em>/bin</em>. With the 3rd
edition of Unix (1973), this directory—​or rather, the 256K drive that backed
it—​became too small to hold all available programs. Researchers at Bell Labs
introduced an additional filesystem hierarchy rooted at <em>/usr</em>, allowing a
second disk to be mounted. But now the shell had to search for programs across
multiple directories—<em>/bin</em> and <em>/usr/bin</em>. Eventually, the Unix designers
settled on storing the list of directories in an environment variable named
<code>PATH</code>. Since every process inherits its own copy of the environment, users can
customize their search path without affecting system processes.</p>
</div></aside>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Installing Python on Windows"><div class="sect1" id="id48">
<h1>Installing Python on Windows</h1>

<p>The core Python team provides official binary installers in the
<a href="https://www.python.org/downloads/windows">Downloads for Windows</a> section of the
Python website. Locate the latest release of each Python version you wish to
support, and download the 64-bit Windows installer for each.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Depending on your domain and target environment, you may prefer to use the
Windows Subsystem for Linux (WSL) for Python development. In this case, please
refer to the section <a data-type="xref" href="#section_python_linux">“Installing Python on Linux”</a> instead.</p>
</div>

<p>In general, there should be little need to customize the installation—​with one
exception: When installing the latest stable release (and only then), enable the
option to add Python to your <code>PATH</code> environment variable on the first page of
the installer dialog. This ensures that your default <code>python</code> command uses a
well-known and up-to-date Python version.</p>

<p>The <em>python.org</em> installers are an efficient way to set up multi-version Python
environments on Windows, for several reasons:</p>

<ul>
<li>
<p>They register each Python installation with the Windows Registry, making it
easy for developer tools to discover interpreters on the system (see
<a data-type="xref" href="#section_python_launcher_windows">“The Python Launcher for Windows”</a>.)</p>
</li>
<li>
<p>They don’t have some of the disadvantages of redistributed versions of Python,
such as lagging behind the official release or being subject to downstream
modifications.</p>
</li>
<li>
<p>They don’t require you to build the Python interpreter, which—​apart from
taking precious time—​involves setting up Python’s build dependencies on your
system.</p>
</li>
</ul>

<p>Binary installers are only provided up to the last bugfix release of each Python
version, which occurs around 18 months after the initial release. Security
updates for older versions, on the other hand, are provided as source
distributions only. If you don’t want to build Python from
source,<sup><a data-type="noteref" id="id237-marker" href="ch01.html#id237">4</a></sup> you can use one
of the excellent <a href="https://github.com/indygreg/python-build-standalone">Python
Standalone Builds</a>, a collection of self-contained, highly portable Python
distributions.</p>

<p>Keeping Python installations up-to-date falls on your shoulders when you’re
using the binary installers from <em>python.org</em>. New releases are announced in
many places, including the <a href="https://blog.python.org/">Python blog</a> and the
<a href="https://discuss.python.org/tags/c/committers/5/release">Python Discourse</a>. When
you install a bugfix release for a Python version that is already present on the
system, it will replace the existing installation. This preserves projects and
developer tools on the upgraded Python version and should be a seamless
experience.</p>

<p>When you install a new feature release of Python, there are some additional
steps to be mindful of:</p>

<ul>
<li>
<p>Enable the option to add the new Python to the <code>PATH</code> environment variable.</p>
</li>
<li>
<p>Remove the previous Python release from <code>PATH</code>. You can edit the environment
variables for your account using the <em>System Settings</em> tool that is part of
Windows.</p>
</li>
<li>
<p>You may also wish to reinstall some of your developer tooling, to ensure that
it runs on the latest Python version.</p>
</li>
</ul>

<p>Eventually, a Python version will reach its end of life, and you may wish to
uninstall it to free up resources. You can remove an existing installation using
the <em>Installed Apps</em> tool. Choose the <em>Uninstall</em> action for its entry in the
list of installed software. Beware that removing a Python version will break
projects and tools that are still using it, so you should upgrade those to a
newer Python beforehand.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id238">
<h1>Microsoft Store Python</h1>
<p>Windows systems ship with a <code>python</code> stub that redirects the user to the latest
Python package on the Microsoft Store. The Microsoft Store package is intended
mainly for educational purposes, and does not have full write access to some
shared locations on the filesystem and the registry. While it’s useful for
teaching Python to beginners, I would not recommend it for most intermediate and
advanced Python development.</p>
</div></aside>
</div></section>






<section data-type="sect1" data-pdf-bookmark="The Python Launcher for Windows"><div class="sect1" id="section_python_launcher_windows">
<h1>The Python Launcher for Windows</h1>

<p>Python development on Windows is special in that tooling can locate Python
installations via the Windows Registry. The Python Launcher for Windows
leverages this to provide a single entry point to interpreters on the system. It
is a utility included with every <em>python.org</em> release and associated with Python
file extensions, allowing you to launch scripts from the Windows File Explorer.</p>

<p>Running applications with a double-click is handy, but the Python Launcher is at
its most powerful when you invoke it from a command-line prompt. Open a
Powershell window and run the <code>py</code> command to start an interactive session:</p>
<pre data-type="programlisting">&gt; <strong>py</strong>
Python 3.12.2 (tags/v3.12.2:6abddd9, Feb  6 2024, 21:26:36) [...] on win32
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;</pre>

<p>By default, the Python Launcher selects the most recent version of Python
installed on the system. It’s worth noting that this may not be the same as the
<em>most recently installed</em> version on the system. This is good—​you don’t want
your default Python to change when you install a bugfix release for an older
version.</p>

<p>If you want to launch a specific version of the interpreter, you can pass the
feature version as a command-line option:</p>
<pre data-type="programlisting">&gt; <strong>py -3.11</strong>
Python 3.11.8 (tags/v3.11.8:db85d51, Feb  6 2024, 22:03:32) [...] on win32
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;</pre>

<p>Any remaining arguments to <code>py</code> are forwarded to the selected interpreter. Let’s
see how you would display the versions of two interpreters on the system:</p>
<pre data-type="programlisting">&gt; <strong>py -V</strong>
Python 3.12.2

&gt; <strong>py -3.11 -V</strong>
Python 3.11.8</pre>

<p>Using the same mechanism, you can run a script on a specific interpreter:</p>
<pre data-type="programlisting">&gt; <strong>py -3.11 path\to\script.py</strong></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>For historical reasons, <code>py</code> also inspects the first line of the script to see
if a version is specified there. The canonical form is <code>#!/usr/bin/env python3</code>,
which corresponds to <code>py -3</code> and works across all major platforms.</p>
</div>

<p>As you have seen, the Python Launcher defaults to the newest version on the
system. There is an exception to this rule: if a <em>virtual environment</em> is
active, <code>py</code> defaults to the interpreter in the virtual
environment.<sup><a data-type="noteref" id="id239-marker" href="ch01.html#id239">5</a></sup></p>

<p>When you install a prerelease of Python, the Python Launcher will use it as the
default interpreter instead of the current release—​after all, it’s the newest
version on the system. In this case, you should override the default by setting
the <code>PY_PYTHON</code> and <code>PY_PYTHON3</code> environment variables to the current release:</p>
<pre data-type="programlisting">&gt; <strong>setx PY_PYTHON 3.12</strong>
&gt; <strong>setx PY_PYTHON3 3.12</strong></pre>

<p>Restart the console for the setting to take effect. Don’t forget to remove these
variables once you upgrade from the prerelease to the final release.</p>

<p>To conclude our short tour of the Python Launcher, use the command <code>py --list</code>
to enumerate the interpreters on your system:</p>
<pre data-type="programlisting">&gt; <strong>py --list</strong>
 -V:3.13          Python 3.13 (64-bit)
 -V:3.12 *        Python 3.12 (64-bit)
 -V:3.11          Python 3.11 (64-bit)
 -V:3.10          Python 3.10 (64-bit)
 -V:3.9           Python 3.9 (64-bit)
 -V:3.8           Python 3.8 (64-bit)</pre>

<p>In this listing, the asterisk marks the default version of Python.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Even if you always use the Python Launcher yourself, you should still keep your
<code>PATH</code> up-to-date. Some third-party tools run the <code>python.exe</code> command
directly—​you don’t want them to use an outdated Python version or fall back to
the Microsoft Store shim.</p>
</div>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Installing Python on macOS"><div class="sect1" id="id50">
<h1>Installing Python on macOS</h1>

<p>You can install Python on macOS in several ways. In this section, I’ll take a
look at the Homebrew package manager and the official <em>python.org</em> installers.
Both provide multi-version binary distributions of Python. Some installation
methods that are common on Linux—​such as Pyenv—​also work on macOS. The Conda
package manager even supports Windows, macOS, and Linux. I’ll talk about them in
later sections.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id240">
<h1>Python from Apple’s Command Line Tools</h1>
<p>Apple’s macOS ships with a <code>python3</code> stub that installs Apple’s Command Line
Tools when you run it for the first time, including an older version of Python.
While it’s good to know about Python commands on your system, other
distributions will serve you better; they allow you to develop with Python
versions of your choice.</p>
</div></aside>








<section data-type="sect2" data-pdf-bookmark="Homebrew Python"><div class="sect2" id="section_homebrew">
<h2>Homebrew Python</h2>

<p>Homebrew is a third-party package manager for macOS and Linux. It provides an
<em>overlay distribution</em>, an open source software collection that you install on
top of the existing operating system. Installing the package manager is
straightforward; refer to the <a href="https://brew.sh/">official website</a> for
instructions.</p>

<p>Homebrew distributes packages for every maintained feature version of Python.
Use the <code>brew</code> command-line interface to manage them:</p>
<dl>
<dt><code>brew install python@3.<em>x</em></code></dt>
<dd>
<p>Install a new Python version.</p>
</dd>
<dt><code>brew upgrade python@3.<em>x</em></code></dt>
<dd>
<p>Upgrade a Python version to a maintenance release.</p>
</dd>
<dt><code>brew uninstall python@3.<em>x</em></code></dt>
<dd>
<p>Uninstall a Python version.</p>
</dd>
</dl>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Whenever you see names like <code>python3.<em>x</em></code> or
<code>python@3.<em>x</em></code> in this section, replace
<code>3.<em>x</em></code> with the actual feature version. For example,
use <code>python3.12</code> and <code>python@3.12</code> for Python 3.12.</p>
</div>

<p>You may find that you already have some Python versions installed for other
Homebrew packages that depend on them. Nonetheless, it’s important that you
install every version explicitly. Automatically installed packages may get
deleted when you run <code>brew autoremove</code> to clean up resources.</p>

<p>Homebrew places a <code>python3.<em>x</em></code> command for each
version on your <code>PATH</code>, as well as a <code>python3</code> command for its main Python
package—​which may be either the current or the previous stable release. You
should override this to ensure <code>python3</code> points to the latest version. First,
query the package manager for the installation root (which is
platform-dependent):</p>
<pre data-type="programlisting">$ <strong>brew --prefix python@3.12</strong>
/opt/homebrew/opt/python@3.12</pre>

<p>Next, prepend the <em>bin</em> directory from this installation to your <code>PATH</code>. Here’s
an example that works on the Bash shell:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="nb">export</code><code class="w"> </code><code class="nv">PATH</code><code class="o">=</code><code class="s2">"/opt/homebrew/opt/python@3.12/bin:</code><code class="nv">$PATH</code><code class="s2">"</code><code class="w"/></pre>

<p>Homebrew has some advantages over the official <em>python.org</em> installers:</p>

<ul>
<li>
<p>You can use the command line to install, upgrade, and uninstall Python
versions.</p>
</li>
<li>
<p>Homebrew includes security releases for older versions—​by contrast,
<em>python.org</em> installers are provided up to the last bugfix release only.</p>
</li>
<li>
<p>Homebrew Python is tightly integrated with the rest of the distribution. In
particular, the package manager can satisfy Python dependencies like OpenSSL.
This gives you the option to upgrade them independently when needed.</p>
</li>
</ul>

<p>On the other hand, Homebrew Python also comes with some limitations:</p>

<ul>
<li>
<p>Homebrew doesn’t package prereleases of upcoming Python versions.</p>
</li>
<li>
<p>Packages generally lag a few days or weeks behind official releases. They also
contain some downstream modifications, although these are quite reasonable.
For example, Homebrew separates modules related to graphical user interfaces
(GUI) from the main Python package.</p>
</li>
<li>
<p>You can’t install and uninstall Python packages system-wide unless they’re
also available as Homebrew packages. (See <a data-type="xref" href="ch02.html#section_environments_venv">“Virtual Environments”</a> for
why you shouldn’t install packages system-wide for development anyway.)</p>
</li>
</ul>

<p>By default, Homebrew upgrades Python to maintenance releases automatically. This
behavior has led to some controversy because it used to break virtual
environments installed on the previous version.<sup><a data-type="noteref" id="id241-marker" href="ch01.html#id241">6</a></sup> This isn’t the case anymore as of this
writing—​Homebrew Python is perfectly safe to use for Python development.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Personally, I recommend Homebrew for managing Python on macOS—​it’s
well-integrated with the rest of the system and easy to keep up-to-date. Use the
<em>python.org</em> installers to test your code against prereleases, which are not
available from Homebrew.</p>
</div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="The python.org Installers"><div class="sect2" id="id52">
<h2>The python.org Installers</h2>

<p>The core Python team provides official binary installers in the
<a href="https://www.python.org/downloads/macos/">Downloads for macOS</a> section of the
Python website. Download the 64-bit <em>universal2</em> installer for the release you
wish to install. The <em>universal2</em> binaries of the interpreter run natively on
both Apple Silicon and Intel chips.<sup><a data-type="noteref" id="id242-marker" href="ch01.html#id242">7</a></sup></p>

<p>For multi-version development, I recommend a custom install—​look for the
<em>Customize</em> button in the installer dialog. In the resulting list of installable
components, disable the <em>Unix command-line tools</em> and the <em>Shell profile
updater</em>. Both options are designed to put the interpreter and some other
commands on your <code>PATH</code>.<sup><a data-type="noteref" id="id243-marker" href="ch01.html#id243">8</a></sup> Instead, edit your shell profile manually. Prepend the directory
<em>/Library/Frameworks/Python.framework/Versions/3.x/bin</em> to <code>PATH</code>, replacing
<code>3.<em>x</em></code> with the actual feature version. Make sure that
the current stable release stays at the front of <code>PATH</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>After installing a Python version, run the <em>Install Certificates</em> command
located in the <em>/Applications/Python 3.x/</em> folder. This command installs
Mozilla’s curated collection of root certificates, which are required to
establish secure internet connections from Python.</p>
</div>

<p>When you install a bugfix release for a Python version that is already present
on the system, it will replace the existing installation. You can uninstall a
Python version by removing these two directories:</p>

<ul>
<li>
<p><em>/Library/Frameworks/Python.framework/Versions/3.x/</em></p>
</li>
<li>
<p><em>/Applications/Python 3.x/</em></p>
</li>
</ul>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id244">
<h1>Framework Builds on macOS</h1>
<p>Most Python installations on Mac are so-called <em>framework builds</em>—a macOS
concept for a “versioned bundle of shared resources.” You may have come across
bundles before, in the form of apps in the <em>Applications</em> folder. A <em>bundle</em> is
just a directory with a standard layout, keeping all the files in one place.</p>

<p>Frameworks contain multiple versions side-by-side in directories named
<em>Versions/3.x</em>. One of these is designated as the current version using a
<em>Versions/Current</em> symlink. Under each version in a Python Framework, you can
find a conventional Python installation layout with <code>bin</code> and <code>lib</code> directories.</p>
</div></aside>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Installing Python on Linux"><div class="sect1" id="section_python_linux">
<h1>Installing Python on Linux</h1>

<p>The core Python team does not provide binary installers for Linux. Generally,
the preferred way to install software on Linux distributions is using the
official package manager. However, this isn’t unequivocally true when installing
Python for development—​here are some important caveats:</p>

<ul>
<li>
<p>The system Python in a Linux distribution may be quite old, and not all
distributions include alternate Python versions in their main package
repositories.</p>
</li>
<li>
<p>Linux distributions have mandatory rules about how applications and libraries
may be packaged. For example, Debian’s Python Policy mandates that the
standard <code>ensurepip</code> module must be shipped in a separate package; as a
result, you can’t create virtual environments on a default Debian system (a
situation commonly fixed by installing the <code>python3-full</code> package).</p>
</li>
<li>
<p>The main Python package in a Linux distribution serves as the foundation for
other packages that require a Python interpreter. These packages may include
critical parts of the system, such as Fedora’s package manager DNF.
Distributions therefore apply safeguards to protect the integrity of the
system; for example, most distributions prevent you from installing or
uninstalling packages system-wide using pip.</p>
</li>
</ul>

<p>In the next sections, I’ll take a look at installing Python on two major Linux
distributions, Fedora and Ubuntu. Afterwards, I’ll cover some generic
installation methods that don’t use the official package manager: Homebrew, Nix,
Pyenv, and Conda. I’ll also introduce you to the Python Launcher for Unix, a
third-party package that aims to bring the <code>py</code> utility to Linux, macOS, and
similar systems.</p>








<section data-type="sect2" data-pdf-bookmark="Fedora Linux"><div class="sect2" id="id54">
<h2>Fedora Linux</h2>

<p>Fedora is an open source Linux distribution sponsored primarily by Red Hat, and
is the upstream source for Red Hat Enterprise Linux (RHEL). It aims to stay
close to upstream projects and uses a rapid release cycle to foster innovation.
Fedora is renowned for its excellent Python support, with Red Hat employing
several Python core developers.</p>

<p>Python comes pre-installed on Fedora, and you can install additional Python
versions using DNF:</p>
<dl>
<dt><code>sudo dnf install python3.<em>x</em></code></dt>
<dd>
<p>Install a new Python version.</p>
</dd>
<dt><code>sudo dnf upgrade python3.<em>x</em></code></dt>
<dd>
<p>Upgrade a Python version to a maintenance release.</p>
</dd>
<dt><code>sudo dnf remove python3.<em>x</em></code></dt>
<dd>
<p>Uninstall a Python version.</p>
</dd>
</dl>

<p>Fedora has packages for all active feature versions and prereleases of CPython,
the reference implementation of Python, as well as packages with alternative
implementations like PyPy. A convenient shorthand to install all of these at
once is to install the <code>tox</code> package:</p>
<pre data-type="programlisting">$ <strong>sudo dnf install tox</strong></pre>

<p>In case you’re wondering, tox is a test automation tool that makes it easy to
run a test suite against multiple versions of Python; its Fedora package pulls
in most available interpreters as recommended dependencies. Tox is also the
spiritual ancestor of Nox, the subject of <a data-type="xref" href="ch08.html#chapter_nox">Chapter 8</a>.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Ubuntu Linux"><div class="sect2" id="id55">
<h2>Ubuntu Linux</h2>

<p>Ubuntu is a popular Linux distribution based on Debian and funded by
Canonical Ltd. Ubuntu only ships a single version of Python in its main
repositories; other versions of Python, including prereleases, are provided by a
<em>personal package archive</em> (PPA). A PPA is a community-maintained software
repository on Launchpad, the software collaboration platform run by Canonical.</p>

<p>Your first step on an Ubuntu system should be to add the <code>deadsnakes</code> PPA:</p>
<pre data-type="programlisting">$ <strong>sudo apt update &amp;&amp; sudo apt install software-properties-common</strong>
$ <strong>sudo add-apt-repository ppa:deadsnakes/ppa &amp;&amp; sudo apt update</strong></pre>

<p>You can now install Python versions using the APT package manager:</p>
<dl>
<dt><code>sudo apt install python3.<em>x</em>-full</code></dt>
<dd>
<p>Install a new Python version.</p>
</dd>
<dt><code>sudo apt upgrade python3.<em>x</em>-full</code></dt>
<dd>
<p>Upgrade a Python version to a maintenance release.</p>
</dd>
<dt><code>sudo apt remove python3.<em>x</em>-full</code></dt>
<dd>
<p>Uninstall a Python version.</p>
</dd>
</dl>
<div data-type="tip"><h6>Tip</h6>
<p>Always remember to include the <code>-full</code> suffix when installing Python on Debian
and Ubuntu. The <code>python3.<em>x</em>-full</code> packages pull in the
entire standard library and up-to-date root certificates. In particular, they
ensure that you can create virtual environments.</p>
</div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Other Linux Distributions"><div class="sect2" id="id56">
<h2>Other Linux Distributions</h2>

<p>What do you do if your Linux distribution doesn’t package multiple versions of
Python? The traditional answer is “roll your own Python.” This may seem scary,
but we’ll see how straightforward building Python has become these days in
<a data-type="xref" href="#section_pyenv">“Installing Python with Pyenv”</a>. However, it turns out that building from source is not your
only option. Several cross-platform package managers provide binary packages of
Python; in fact, you’ve already seen one of them.</p>

<p>The Homebrew distribution (see <a data-type="xref" href="#section_homebrew">“Homebrew Python”</a>) is available on Linux and
macOS, and most of what I said above applies to Linux as well. The main
difference between both platforms is the installation root: Homebrew on Linux
installs packages under <em>/home/linuxbrew/.linuxbrew</em> by default instead of
<em>/opt/homebrew</em>. Keep this in mind when adding Homebrew’s Python installations
to your <code>PATH</code>.</p>

<p>A popular cross-platform way to install Python is the Anaconda distribution,
which is targeted at scientific computing and supports Windows, macOS, and
Linux. I’ll cover Anaconda in a separate section at the end of this chapter (see
<a data-type="xref" href="#section_anaconda">“Installing Python from Anaconda”</a>).</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id245">
<h1>The Nix Package Manager</h1>
<p>Another fascinating option for both macOS and Linux is <a href="https://nixos.org/">Nix</a>,
a purely functional package manager with reproducible builds of thousands of
software packages. Nix makes it easy and fast to set up isolated environments
with arbitrary versions of software packages. Here’s how you would set up a
development environment with two Python versions:</p>
<pre data-type="programlisting">$ <strong>nix-shell --packages python312 python311</strong>
[nix-shell]$ <strong>python -V</strong>
3.12.0rc2
[nix-shell]$ <strong>python3.11 -V</strong>
3.11.5
[nix-shell]$ <strong>exit</strong></pre>

<p>Before dropping you into the environment, Nix transparently downloads pre-built
Python binaries from the Nix Packages Collection and adds them to your <code>PATH</code>.
Each package gets a unique subdirectory on the local filesystem, using a
cryptographic hash that captures all its dependencies.</p>

<p>You can install the Nix package manager using its
<a href="https://nixos.org/download.html">official installer</a>. If you’re not ready to
install Nix permanently, you can get a taste of what’s possible using the Docker
image for NixOS, a Linux distribution built entirely using Nix:</p>
<pre data-type="programlisting">$ <strong>docker run --rm -it nixos/nix</strong></pre>
</div></aside>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="The Python Launcher for Unix"><div class="sect1" id="section_python_launcher_unix">
<h1>The Python Launcher for Unix</h1>

<p>The <a href="https://python-launcher.app/">Python Launcher for Unix</a> is a port of the
official <code>py</code> utility to Linux and macOS, as well as any other operating system
supporting the Rust programming language. Its key benefit is to offer a unified,
cross-platform way to launch Python, with a well-defined default when no version
is specified: the newest interpreter on the system.</p>

<p>The <code>py</code> command is a convenient, portable method for launching interpreters
that avoids some pitfalls of invoking Python directly (see <a data-type="xref" href="#section_path">“Locating Python Interpreters”</a>).
For this reason, I’ll use it throughout this book. You can install the
<code>python-launcher</code> package with a number of package managers, including Homebrew,
DNF, and Cargo.</p>

<p>The Python Launcher for Unix discovers interpreters by scanning the <code>PATH</code>
environment variable for <code>python<em>x</em>.<em>y</em></code>
commands. Otherwise, it works much like its Windows counterpart (see
<a data-type="xref" href="#section_python_launcher_windows">“The Python Launcher for Windows”</a>). While <code>py</code> on its own launches the newest
Python, you can also request a specific version—​for example, <code>py -3.12</code> is
equivalent to running <code>python3.12</code>.</p>

<p>Below is an example session using the macOS system from
<a data-type="xref" href="#figure_python_commands_on_path">Figure 1-2</a>. (Python 3.13 was a prerelease at the time of
writing this, so I’ve changed the default interpreter by setting <code>PY_PYTHON</code> and
<code>PY_PYTHON3</code> to <code>3.12</code>.)</p>
<pre data-type="programlisting">$ <strong>py -V</strong>
3.12.1
$ <strong>py -3.11 -V</strong>
3.11.7
$ <strong>py --list</strong>
 3.13 │ /Library/Frameworks/Python.framework/Versions/3.13/bin/python3.13
 3.12 │ /opt/homebrew/bin/python3.12
 3.11 │ /opt/homebrew/bin/python3.11
 3.10 │ /opt/homebrew/bin/python3.10</pre>

<p>If a virtual environment is active, <code>py</code> defaults to the interpreter in that
environment instead of the system-wide interpreter (see
<a data-type="xref" href="ch02.html#section_environments_venv">“Virtual Environments”</a>). A special rule in the Python Launcher for Unix
makes working with virtual environments more convenient: If the current
directory (or one of its parents) contains a virtual environment with the
standard name <em>.venv</em>, you don’t need to activate it explicitly.</p>

<p>You can run many third-party tools by passing their import name to the <code>-m</code>
interpreter option. Suppose you have installed pytest (a test framework) on
multiple Python versions. Using <code>py -m pytest</code> lets you determine which
interpreter should run the tool. By contrast, a bare <code>pytest</code> uses the command
that happens to appear first on your <code>PATH</code>.</p>

<p>If you invoke <code>py</code> with a Python script but don’t specify a version, <code>py</code>
inspects the first line of the script for a <em>shebang</em>—a line specifying the
interpreter for the script. Stick with the canonical form here: <code>#!/usr/bin/env
python3</code>. <em>Entry-point scripts</em> are a more sustainable way to link a script to a
specific interpreter, because package installers can generate the correct
interpreter path during installation (see <a data-type="xref" href="ch02.html#section_environments_scripts">“Entry-point scripts”</a>).</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>For compatibility with the Windows version, the Python Launcher only uses the
Python version from shebangs, not the full interpreter path. As a result, you
can end up with a different interpreter than if you were to invoke the script
directly without <code>py</code>.</p>
</div>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Installing Python with Pyenv"><div class="sect1" id="section_pyenv">
<h1>Installing Python with Pyenv</h1>

<p>Pyenv is a Python version manager for macOS and Linux. It includes a build
tool—also available as a stand-alone program named <code>python-build</code>—that
downloads, builds, and installs Python versions in your home directory. Pyenv
allows you to activate and deactivate these installations globally, per project
directory, or per shell session.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In this section, you’ll use Pyenv as a build tool. If you’re interested in using
Pyenv as a version manager, please refer to the
<a href="https://github.com/pyenv/pyenv#readme">official documentation</a> for additional
setup steps. I’ll discuss some of the trade-offs in <a data-type="xref" href="#sidebar_pyenv_versions">“Managing Python Versions with Pyenv”</a>.</p>
</div>

<p>The best way to install Pyenv on macOS and Linux is using Homebrew:</p>
<pre data-type="programlisting">$ <strong>brew install pyenv</strong></pre>

<p>One great benefit of installing Pyenv from Homebrew is that you’ll also get the
build dependencies of Python. If you use a different installation method, check
the <a href="https://github.com/pyenv/pyenv/wiki">Pyenv wiki</a> for platform-specific
instructions on how to set up your build environment.</p>

<p>Display the available Python versions using the following command:</p>
<pre data-type="programlisting">$ <strong>pyenv install --list</strong></pre>

<p>The list of interpreters is impressive. Not only does it cover all active
feature versions of Python, it also includes prereleases, unreleased development
versions, almost every point release published over the past two decades, and a
wealth of alternative implementations, such as PyPy, GraalPy, MicroPython,
Jython, IronPython, and Stackless Python.</p>

<p>You can build and install any of these versions by passing them to <code>pyenv
install</code>:</p>
<pre data-type="programlisting">$ <strong>pyenv install 3.<em>x</em>.<em>y</em></strong></pre>

<p>When using Pyenv as a mere build tool, as we’re doing here, you need to add each
installation to <code>PATH</code> manually. You can find its location using the command
<code>pyenv prefix 3.<em>x</em>.<em>y</em></code> and append <em>/bin</em> to
that. Here’s an example for the Bash shell:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="nb">export</code><code class="w"> </code><code class="nv">PATH</code><code class="o">=</code><code class="s2">"</code><code class="nv">$HOME</code><code class="s2">/.pyenv/versions/3.x.y/bin:</code><code class="nv">$PATH</code><code class="s2">"</code><code class="w"/></pre>

<p>Installing a maintenance release with Pyenv does <em>not</em> implicitly upgrade
existing virtual environments and developer tools on the same feature version,
so you’ll have to recreate these environments using the new release.</p>

<p>When you no longer need an installation, you can remove it like this:</p>
<pre data-type="programlisting">$ <strong>pyenv uninstall 3.<em>x</em>.<em>y</em></strong></pre>

<p>By default, Pyenv does not enable profile-guided optimization (PGO) or link-time
optimization (LTO) when building the interpreter. According to the
<a href="https://pyperformance.readthedocs.io/">Python Performance Benchmark Suite</a>, these
optimizations can lead to a significant speedup for CPU-bound Python
programs—​between 10% and 20%. You can enable them using the
<code>PYTHON_CONFIGURE_OPTS</code> environment variable:</p>
<pre data-type="programlisting">$ <strong>export PYTHON_CONFIGURE_OPTS='--enable-optimizations --with-lto'</strong></pre>

<p>Unlike most macOS installers, Pyenv defaults to a POSIX installation layout
instead of the framework builds typical for this platform. If you are on macOS,
I advise you to enable framework builds for consistency.<sup><a data-type="noteref" id="id246-marker" href="ch01.html#id246">9</a></sup> You can do so by adding the configuration option <code>--enable-framework</code>
to the list above.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_pyenv_versions">
<h1>Managing Python Versions with Pyenv</h1>
<p>Version management in Pyenv works by placing small wrapper scripts called
<em>shims</em> on your <code>PATH</code>. These shims intercept invocations of the Python
interpreter and other Python-related tools and delegate to the actual commands
in the appropriate Python installation. This can be seen as a more powerful
method of interpreter discovery than the <code>PATH</code> mechanism of the operating
system, and it avoids polluting the search path with a plethora of Python
installations.</p>

<p>Pyenv’s shim-based approach to version management is convenient, but it also
comes with a tradeoff in runtime and complexity: Shims add to the startup time
of the Python interpreter. They also put deactivated commands on <code>PATH</code>, which
can interfere with other tools that perform interpreter discovery, such as <code>py</code>,
<code>virtualenv</code>, <code>tox</code>, and Nox. When installing packages with entry-point scripts,
you need to run <code>pyenv rehash</code> for the scripts to become visible.</p>

<p>If the practical advantages of the shim mechanism convince you, you may also
like <a href="https://asdf-vm.com/">asdf</a>, a generic version manager for multiple language
runtimes; its Python plugin uses <code>python-build</code> internally. If you like
per-directory version management, but don’t like shims, take a look at
<a href="https://direnv.net/">direnv</a>, which can update your <code>PATH</code> whenever you enter a
directory. (It can even create and activate virtual environments for you.)</p>
</div></aside>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Installing Python from Anaconda"><div class="sect1" id="section_anaconda">
<h1>Installing Python from Anaconda</h1>

<p><a href="https://www.anaconda.com/download">Anaconda</a> is an open source software
distribution for scientific computing, maintained by Anaconda Inc. Its
centerpiece is <a href="https://conda.io/projects/conda/">Conda</a>, a cross-platform package
manager for Windows, macOS, and Linux. Conda packages can contain software
written in any language, such as C, C++, Python, R, or Fortran.</p>

<p>In this section, you’ll use Conda to install Python. Conda does not install
software packages globally on your system. Each Python installation is contained
in a Conda environment and isolated from the rest of your system. A typical
Conda environment is centered around the dependencies of a particular
project—​say, a set of libraries for machine learning or data science—​of which
Python is only one among many.</p>

<p>Before you can create Conda environments, you’ll need to bootstrap a base
environment containing Conda itself. There are a few ways to go about this: You
can install the full Anaconda distribution, or you can use the Miniconda
installer with just Conda and a few core packages. Both Anaconda and Miniconda
download packages from the <em>defaults</em> channel, which may require a commercial
license for enterprise use.</p>

<p>Miniforge is a third alternative—​it is similar to Miniconda but installs
packages from the community-maintained <em>conda-forge</em> channel. You can get
Miniforge using its official installers from
<a href="https://github.com/conda-forge/miniforge">GitHub</a>, or you can install it from
Homebrew on macOS and Linux:</p>
<pre data-type="programlisting">$ <strong>brew install miniforge</strong></pre>

<p>Conda requires shell integration to update the search path and shell prompt when
you activate or deactivate an environment. If you’ve installed Miniforge from
Homebrew, update your shell profile using the <code>conda init</code> command with the name
of your shell. For example:</p>
<pre data-type="programlisting">$ <strong>conda init bash</strong></pre>

<p>By default, the shell initialization code activates the base environment
automatically in every session. You may want to disable this behavior if you
also use Python installations that are not managed by Conda:</p>
<pre data-type="programlisting">$ <strong>conda config --set auto_activate_base false</strong></pre>

<p>The Windows installer does not activate the base environment globally. Interact
with Conda using the Miniforge Prompt from the Windows Start Menu.</p>

<p>Congratulations, you now have a working Conda installation on your system! Let’s
use Conda to create an environment with a specific version of Python:</p>
<pre data-type="programlisting">$ <strong>conda create --name=<em>name</em> python=3.<em>x</em></strong></pre>

<p>Before you can use this Python installation, you need to activate the environment:</p>
<pre data-type="programlisting">$ <strong>conda activate <em>name</em></strong></pre>

<p>Upgrading Python to a newer release is simple:</p>
<pre data-type="programlisting">$ <strong>conda update python</strong></pre>

<p>This command will run in the active Conda environment. What’s great about Conda
is that it won’t upgrade Python to a release that’s not yet supported by the
Python libraries in the environment.</p>

<p>When you’re done working in the environment, deactivate it like this:</p>
<pre data-type="programlisting">$ <strong>conda deactivate</strong></pre>

<p>Conda doesn’t install Python system-wide; rather, every Python installation is
part of an isolated Conda environment. Conda takes a holistic view of an
environment: Python is but one dependency of your projects, on par with system
libraries, third-party Python packages, and even software packages from other
language ecosystems.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="A Brave New World: Installing with Hatch and Rye"><div class="sect1" id="section_python_brave">
<h1>A Brave New World: Installing with Hatch and Rye</h1>

<p>While I was writing this book, the Python project managers
<a href="https://rye-up.com/">Rye</a> and <a href="https://hatch.pypa.io/">Hatch</a> added support for
installing Python interpreters on all major platforms. Both use interpreters
from the <a href="https://github.com/indygreg/python-build-standalone">Python Standalone
Builds</a> collection and the <a href="https://www.pypy.org/">PyPy</a> project.</p>

<p>Both Rye and Hatch are distributed as stand-alone executables—​in other words,
you can easily install them on a system that doesn’t already have Python. Please
refer to their official documentation for detailed installation instructions.</p>

<p>Hatch lets you install all CPython and PyPy interpreters compatible with your
platform with a single command:</p>
<pre data-type="programlisting">$ <strong>hatch python install all</strong></pre>

<p>This command also adds the installation directories to your <code>PATH</code>.<sup><a data-type="noteref" id="id247-marker" href="ch01.html#id247">10</a></sup> Re-run the command with the
<code>--update</code> option to upgrade the interpreters to newer versions. Hatch organizes
interpreters by feature version, so patch releases overwrite the existing
installation.</p>

<p>Rye fetches interpreters into the <em>~/.rye/py</em> directory. Normally, this happens
behind the scenes when you synchronize the dependencies of your project. But
it’s also available as a dedicated command:</p>
<pre data-type="programlisting">$ <strong>rye fetch 3.12</strong>
$ <strong>rye fetch 3.11.8</strong>
$ <strong>rye fetch pypy@3.10</strong></pre>

<p>The second example places the interpreter in <em>~/.rye/py/cpython@3.11.8/bin</em>
(Linux and macOS). You can install to another directory using the option
<code>--target-path=<em>&lt;dir&gt;</em></code>. This puts the
interpreter in <code><em>&lt;dir&gt;</em></code> on Windows and
<code><em>&lt;dir&gt;</em>/bin</code> on Linux and macOS. Rye doesn’t add
the interpreter to your <code>PATH</code> when you’re working outside of a project.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="An Overview of Installers"><div class="sect1" id="id61">
<h1>An Overview of Installers</h1>

<p><a data-type="xref" href="#figure_installing_python">Figure 1-3</a> provides an overview of the main Python
installation methods for Windows, Linux, and macOS.</p>

<figure><div id="figure_installing_python" class="figure">
<img src="assets/hmpt_0103.png" alt="An overview of Python installation methods for Windows, Linux, and macOS" width="1840" height="1200"/>
<h6><span class="label">Figure 1-3. </span>Python installers for Windows, Linux, and macOS</h6>
</div></figure>

<p>Here’s some case-by-case guidance on how to choose an installer:</p>

<ul>
<li>
<p>As a general rule, install Python stand-alone builds using Hatch.</p>
</li>
<li>
<p>For scientific computing, I recommend using Conda instead.</p>
</li>
<li>
<p>Get preleases from python.org if you’re on Windows or macOS. If you’re on
Linux, build them from source with pyenv.</p>
</li>
<li>
<p>On Fedora Linux, always use DNF.</p>
</li>
<li>
<p>On Ubuntu Linux, always use the deadsnakes PPA with APT.</p>
</li>
</ul>

<p>Choose Nix on macOS and Linux if you need a reproducible build of Python.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="id62">
<h1>Summary</h1>

<p>In this chapter, you’ve learned how to manage Python installations on Windows,
macOS, and Linux. Use the Python Launcher to select interpreters installed on
your system. Additionally, audit your search path to ensure you have
well-defined <code>python</code> and <code>python3</code> commands.</p>

<p>The next chapter zooms into a Python installation: its contents and structure,
and how your code interacts with it. You’ll also learn about its lightweight
cousins, virtual environments, and the tooling that has evolved around those.</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="id233"><sup><a href="ch01.html#id233-marker">1</a></sup> While CPython is the reference implementation of Python, there are quite a few more to choose from: performance-oriented forks such as PyPy and Cinder, re-implementations such as RustPython and MicroPython, and ports to other platforms like WebAssembly, Java, and .NET.</p><p data-type="footnote" id="id234"><sup><a href="ch01.html#id234-marker">2</a></sup> At the time of writing in early 2024, the long-term support release of Debian Linux ships patched versions of Python 2.7.16 and 3.7.3—​both released half a decade ago. (Debian’s “testing” distribution, which is widely used for development, comes with a current version of Python.)</p><p data-type="footnote" id="id235"><sup><a href="ch01.html#id235-marker">3</a></sup> Starting with Python 3.13, bugfix releases are provided for two years after the initial release.</p><p data-type="footnote" id="id237"><sup><a href="ch01.html#id237-marker">4</a></sup> <a href="https://stackoverflow.com/a/72209207/1355754">Stack Overflow</a> has a good step-by-step guide to building Windows installers.</p><p data-type="footnote" id="id239"><sup><a href="ch01.html#id239-marker">5</a></sup> <a data-type="xref" href="ch02.html#section_environments_venv">“Virtual Environments”</a> covers virtual environments in detail. For now, you can think of a virtual environment as a shallow copy of a full Python installation that lets you install a separate set of third-party packages.</p><p data-type="footnote" id="id241"><sup><a href="ch01.html#id241-marker">6</a></sup> Justin Mayer: <a href="https://justinmayer.com/posts/homebrew-python-is-not-for-you/">“Homebrew Python Is Not For You,”</a> February 3rd, 2021.</p><p data-type="footnote" id="id242"><sup><a href="ch01.html#id242-marker">7</a></sup> Do you have a Mac with Apple Silicon, but programs that must run on Intel processors? You’ll be pleased to know that the <em>python.org</em> installers also provide a <code>python3-intel64</code> binary using the <code>x64_64</code> instruction set. You can run it on Apple Silicon thanks to Apple’s Rosetta translation environment.</p><p data-type="footnote" id="id243"><sup><a href="ch01.html#id243-marker">8</a></sup> The <em>Unix command-line tools</em> option places symbolic links in the <em>/usr/local/bin</em> directory, which can conflict with Homebrew packages and other versions from <em>python.org</em>. A <em>symbolic link</em> is a special kind of file that points to another file, much like a shortcut in Windows.</p><p data-type="footnote" id="id246"><sup><a href="ch01.html#id246-marker">9</a></sup> For historical reasons, framework builds use a different path for the <em>per-user site directory</em>, the location where packages are installed if you invoke pip outside of a virtual environment and without administrative privileges. This different installation layout can prevent you from importing a previously installed package.</p><p data-type="footnote" id="id247"><sup><a href="ch01.html#id247-marker">10</a></sup> In a future release, Hatch will add interpreters to the Windows registry as well, letting you use them with the Python Launcher.</p></div></div></section></div>
</div>
</body></html>