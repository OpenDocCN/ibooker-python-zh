- en: Chapter 12\. Persistence and Databases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。持久性和数据库
- en: Python supports several ways of persisting data. One way, *serialization*, views
    data as a collection of Python objects. These objects can be *serialized* (saved)
    to a byte stream, and later *deserialized* back (loaded and re-created) from the
    byte stream. *Object persistence* relies on serialization, adding features such
    as object naming. This chapter covers the Python modules that support serialization
    and object persistence.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python支持几种持久化数据的方式。一种方式是*序列化*，将数据视为Python对象的集合。这些对象可以*序列化*（保存）到字节流中，稍后可以从字节流中*反序列化*（加载和重新创建）。*对象持久性*依赖于序列化，添加了诸如对象命名等功能。本章介绍了支持序列化和对象持久性的Python模块。
- en: Another way to make data persistent is to store it in a database (DB). One simple
    category of DBs are files that use *keyed access* to enable selective reading
    and updating of parts of the data. This chapter covers Python standard library
    modules that support several variations of such a file format, known as *DBM*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种使数据持久化的方法是将其存储在数据库（DB）中。一个简单的DB类别是使用*键访问*的文件，以便选择性地读取和更新数据的部分。本章涵盖了支持几种此类文件格式变体的Python标准库模块，称为*DBM*。
- en: A *relational DB management system* (RDBMS), such as PostgreSQL or Oracle, offers
    a more powerful approach to storing, searching, and retrieving persistent data.
    Relational DBs rely on dialects of Structured Query Language (SQL) to create and
    alter a DB’s schema, insert and update data in the DB, and query the DB with search
    criteria. (This book does not provide reference material on SQL; for this purpose
    we recommend O’Reilly’s [*SQL in a Nutshell*](https://www.oreilly.com/library/view/sql-in-a/9781492088851),
    by Kevin Kline, Regina Obe, and Leo Hsu.) Unfortunately, despite the existence
    of SQL standards, no two RDBMSs implement exactly the same SQL dialect.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型DB管理系统（RDBMS），如PostgreSQL或Oracle，提供了一种更强大的方法来存储、搜索和检索持久化数据。关系型DB依赖于结构化查询语言（SQL）的方言来创建和更改DB的模式，在DB中插入和更新数据，并使用搜索条件查询DB。（本书不提供SQL的参考资料；为此，我们推荐O'Reilly的[*SQL
    in a Nutshell*](https://www.oreilly.com/library/view/sql-in-a/9781492088851)，作者是Kevin
    Kline、Regina Obe和Leo Hsu。）不幸的是，尽管存在SQL标准，但没有两个RDBMS实现完全相同的SQL方言。
- en: The Python standard library does not come with an RDBMS interface. However,
    many third-party modules let your Python programs access a specific RDBMS. Such
    modules mostly follow the [Python Database API 2.0](https://oreil.ly/sktml) standard,
    also known as the *DBAPI*. This chapter covers the DBAPI standard and mentions
    a few of the most popular third-party modules that implement it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库没有提供RDBMS接口。然而，许多第三方模块让您的Python程序访问特定的RDBMS。这些模块大多遵循[Python数据库API 2.0](https://oreil.ly/sktml)标准，也称为*DBAPI*。本章介绍了DBAPI标准，并提到了一些最受欢迎的实现它的第三方模块。
- en: A DBAPI module that is particularly handy (because it comes with every standard
    installation of Python) is [sqlite3](https://oreil.ly/mAq7b), which wraps [SQLite](https://www.sqlite.org).
    SQLite, “a self-contained, server-less, zero-configuration, transactional SQL
    DB engine,” is the most widely deployed relational DB engine in the world. We
    cover sqlite3 in [“SQLite”](#sqlite).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 特别方便的DBAPI模块（因为它随着每个Python标准安装而提供）是[sqlite3](https://oreil.ly/mAq7b)，它封装了[SQLite](https://www.sqlite.org)。SQLite是“一个自包含的、无服务器的、零配置的、事务性的SQL
    DB引擎”，是世界上部署最广泛的关系型DB引擎。我们在[“SQLite”](#sqlite)中介绍sqlite3。
- en: Besides relational DBs, and the simpler approaches covered in this chapter,
    there exist several [NoSQL](http://nosql-database.org) DBs, such as [Redis](https://redis.io)
    and [MongoDB](https://www.mongodb.com), each with Python interfaces. We do not
    cover advanced nonrelational DBs in this book.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 除了关系型DB和本章介绍的更简单的方法之外，还存在几种[NoSQL](http://nosql-database.org) DB，如[Redis](https://redis.io)和[MongoDB](https://www.mongodb.com)，每种都有Python接口。本书不涵盖高级非关系型DB。
- en: Serialization
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化
- en: Python supplies several modules to *serialize* (save) Python objects to various
    kinds of byte streams and *deserialize* (load and re-create) Python objects back
    from streams. Serialization is also known as *marshaling*, which means formatting
    for *data interchange*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了几个模块来将Python对象*序列化*（保存）到各种字节流中，并从流中*反序列化*（加载和重新创建）Python对象。序列化也称为*编组*，意味着格式化用于*数据交换*。
- en: Serialization approaches span a vast range, from the low-level, Python-version-specific
    marshal and language-independent JSON (both limited to elementary data types)
    to the richer but Python-specific pickle and cross-language formats such as XML,
    [YAML](http://yaml.org), [protocol buffers](https://developers.google.com/protocol-buffers),
    and [MessagePack](http://msgpack.org).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化方法涵盖了一个广泛的范围，从低级别的、特定于 Python 版本的 marshal 和独立于语言的 JSON（两者都限于基本数据类型），到更丰富但特定于
    Python 的 pickle 和跨语言格式，如 XML、[YAML](http://yaml.org)、[协议缓冲区](https://developers.google.com/protocol-buffers)
    和 [MessagePack](http://msgpack.org)。
- en: In this section, we cover Python’s csv, json, pickle, and shelve modules. We
    cover XML in [Chapter 23](ch23.xhtml#structured_text_xml). marshal is too low-level
    to use in applications; should you need to maintain old code using it, refer to
    the [online docs](https://oreil.ly/wZZ3s). As for protocol buffers, MessagePack,
    YAML, and other data-interchange/serialization approaches (each with specific
    advantages and weaknesses), we cannot cover everything in this book; we recommend
    studying them via the resources available on the web.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们涵盖了 Python 的 csv、json、pickle 和 shelve 模块。我们在 [第 23 章](ch23.xhtml#structured_text_xml)
    中介绍了 XML。marshal 过于低级，不适合在应用程序中使用；如果你需要维护使用它的旧代码，请参考[在线文档](https://oreil.ly/wZZ3s)。至于协议缓冲区、MessagePack、YAML
    和其他数据交换/序列化方法（每种都具有特定的优点和缺点），我们无法在本书中覆盖所有内容；我们建议通过网络上可用的资源来学习它们。
- en: The csv Module
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSV 模块
- en: While the CSV (standing for *comma-separated values*^([1](ch12.xhtml#ch01fn106)))
    format isn’t usually considered a form of serialization, it is a widely used and
    convenient interchange format for tabular data. Since much data is tabular, CSV
    data is used a lot, despite some lack of agreement on exactly how it should be
    represented in files. To overcome this issue, the csv module provides a number
    of *dialects* (specifications of the way particular sources encode CSV data) and
    lets you define your own dialects. You can register additional dialects and list
    the available dialects by calling the csv.list_dialects function. For further
    information on dialects, consult [the module’s documentation](https://oreil.ly/3_o6_).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 CSV（代表*逗号分隔值*^([1](ch12.xhtml#ch01fn106))）格式通常不被视为一种序列化形式，但它是一种广泛使用且方便的表格数据交换格式。由于许多数据是表格形式的，因此尽管在如何在文件中表示它存在一些争议，但
    CSV 数据仍然被广泛使用。为了解决这个问题，csv 模块提供了一些*方言*（特定来源编码 CSV 数据方式的规范），并允许你定义自己的方言。你可以注册额外的方言，并通过调用
    csv.list_dialects 函数列出可用的方言。有关方言的更多信息，请参阅[模块文档](https://oreil.ly/3_o6_)。
- en: csv functions and classes
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: csv 函数和类
- en: The csv module exposes the functions and classes detailed in [Table 12-1](#functions_and_classes_of_the_csv_module).
    It provides two kinds of readers and writers to let you handle CSV data rows in
    Python as either lists or dictionaries.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: csv 模块公开了 [表 12-1](#functions_and_classes_of_the_csv_module) 中详细介绍的函数和类。它提供了两种读取器和写入器，让你在
    Python 中处理 CSV 数据行时可以选择使用列表或字典。
- en: Table 12-1\. Functions and classes of the csv module
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-1\. csv 模块的函数和类
- en: '| reader | reader(*csvfile*, dialect=''excel'', ***kw*) Creates and returns
    a reader object *r*. *csvfile* can be any iterable object yielding text rows as
    strs (usually a list of lines or a file opened with newline=''''^([a](ch12.xhtml#ch01fn107)));
    dialect is the name of a registered dialect. To modify the dialect, add named
    arguments: their values override dialect fields of the same name. Iterating over
    *r* yields a sequence of lists, each containing the elements from one row of *csvfile*.
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| reader | reader(*csvfile*, dialect=''excel'', ***kw*) 创建并返回一个 reader 对象 *r*。*csvfile*
    可以是任何产生文本行（通常是行列表或使用 newline='''' 打开的文件）的可迭代对象，dialect 是已注册方言的名称。要修改方言，请添加命名参数：它们的值将覆盖相同名称的方言字段。对
    *r* 进行迭代将产生一个列表序列，每个列表包含 *csvfile* 的一行元素。'
- en: '| writer | writer(*csvfile*, dialect=''excel'', ***kw*) Creates and returns
    a writer object *w*. *csvfile* is an object with a write method (if a file, open
    it with newline=''''); *dialect* is the name of a registered dialect. To modify
    the dialect, add named arguments: their values override dialect fields of the
    same name. *w.*writerow accepts a sequence of values and writes their CSV representation
    as a row to *csvfile*. *w.*writerows accepts an iterable of such sequences and
    calls *w.*writerow on each. You are responsible for closing *csvfile*. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| writer | writer(*csvfile*, dialect=''excel'', ***kw*) 创建并返回一个写入对象 *w*。 *csvfile*
    是一个带有写入方法的对象（如果是文件，请使用 newline='''' 打开）； *dialect* 是一个已注册方言的名称。要修改方言，请添加命名参数：它们的值将覆盖同名的方言字段。
    *w.*writerow 接受值序列，并将它们的 CSV 表示作为一行写入 *csvfile*。 *w.*writerows 接受这样的序列的可迭代对象，并对每个调用
    *w.*writerow。您有责任关闭 *csvfile*。 |'
- en: '| D⁠i⁠c⁠t​R⁠e⁠a⁠d⁠e⁠r | DictReader(*csvfile,* fieldnames=**None**, restkey=**None**,
    restval=**None**, dialect=''excel'', **args,**kw*)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '| D⁠i⁠c⁠t​R⁠e⁠a⁠d⁠e⁠r | DictReader(*csvfile,* fieldnames=**None**, restkey=**None**,
    restval=**None**, dialect=''excel'', **args,**kw*)'
- en: Creates and returns an object *r* that iterates over *csvfile* to generate an
    iterable of dictionaries (-3.8 OrderedDicts), one for each row. When the fieldnames
    argument is given, it is used to name the fields in *csvfile*; otherwise, the
    field names are taken from the first row of *csvfile*. If a row contains more
    columns than field names, the extra values are saved as a list with the key restkey.
    If there are insufficient values in any row, then those column values will be
    set to restval. dialect, *kw*, and *args* are passed to the underlying reader
    object. |
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并返回一个对象 *r*，该对象迭代 *csvfile* 以生成一个字典的可迭代对象（-3.8 有序字典），每一行一个字典。当给出 fieldnames
    参数时，它用于命名 *csvfile* 中的字段；否则，字段名来自 *csvfile* 的第一行。如果一行包含比字段名更多的列，则额外的值保存为带有键 restkey
    的列表。如果任何行中的值不足，则将这些列值设置为 restval。 dialect、*kw* 和 *args* 传递给底层的读取器对象。 |
- en: '| DictWriter | DictWriter(*csvfile*, *fieldnames*, restval='''', extrasaction=''raise'',
    dialect=''excel''*, *args, **kwds*)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '| DictWriter | DictWriter(*csvfile*, *fieldnames*, restval='''', extrasaction=''raise'',
    dialect=''excel''*, *args, **kwds*)'
- en: 'Creates and returns an object *w* whose writerow and writerows methods take
    a dictionary or iterable of dictionaries and write them using the *csvfile*’s
    write method. *fieldnames* is a sequence of strs, the keys to the dictionaries.
    *restval* is the value used to fill up a dictionary that’s missing some keys.
    extrasaction specifies what to do when a dictionary has extra keys not listed
    in *fieldnames*: when ''raise'', the default, the function raises ValueError in
    such cases; when ''ignore'', the function ignores such errors. dialect, *kw*,
    and *args* are passed to the underlying reader object. You are responsible for
    closing *csvfile* (usually a file opened with newline=''''). |'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并返回一个对象 *w*，其 writerow 和 writerows 方法接受字典或字典的可迭代对象，并使用 *csvfile* 的写入方法写入它们。
    *fieldnames* 是一个 strs 序列，字典的键。 *restval* 是用于填充缺少某些键的字典的值。 extrasaction 指定字典具有未列在
    *fieldnames* 中的额外键时该如何处理：当 'raise' 时，默认时，函数在这些情况下引发 ValueError；当 'ignore' 时，函数忽略此类错误。
    dialect、*kw* 和 *args* 传递给底层的读取器对象。您有责任关闭 *csvfile*（通常是使用 newline='' 打开的文件）。 |
- en: '| ^([a](ch12.xhtml#ch01fn107-marker)) Opening a file with newline='''' allows
    the csv module to use its own newline processing and correctly handle dialects
    in which text fields may contain newlines. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch12.xhtml#ch01fn107-marker)) 使用 newline='''' 打开文件允许 csv 模块使用自己的换行处理，并正确处理文本字段可能包含换行符的方言。
    |'
- en: A csv example
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个 csv 示例
- en: 'Here is a simple example using csv to read color data from a list of strings:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的示例，使用 csv 从字符串列表中读取颜色数据：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that the integer values are read as strings. csv does not do any data conversion;
    that needs to be done by your program code with the dicts returned from DictReader.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，整数值被读取为字符串。csv 不执行任何数据转换；这需要通过您的程序代码与从 DictReader 返回的字典来完成。
- en: The json Module
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: json 模块
- en: The standard library’s json module supports serialization for Python’s native
    data types (tuple, list, dict, int, str, etc.). To serialize instances of your
    own custom classes, you should implement corresponding classes inheriting from
    JSONEncoder and JSONDecoder.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库的 json 模块支持 Python 本地数据类型（元组、列表、字典、整数、字符串等）的序列化。要序列化自定义类的实例，应实现继承自 JSONEncoder
    和 JSONDecoder 的相应类。
- en: json functions
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: json 函数
- en: The json module supplies four key functions, detailed in [Table 12-2](#functions_of_the_json_module).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: json 模块提供了四个关键函数，详见 [表 12-2](#functions_of_the_json_module)。
- en: Table 12-2\. Functions of the json module
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-2\. json 模块的函数
- en: '| dump | dump(*value*, *fileobj*, skipkeys=**False**, ensure_ascii=**True**,
    check_circular=**True**, allow_nan=**True**, cls=JSONEncoder, indent=**None**,
    separators=('', '', '': ''), default=**None**, sort_keys=**False**, ***kw*) Writes
    the JSON serialization of object *value* to file-like object *fileobj*, which
    must be opened for writing in text mode, via calls to *fileobj*.write. Each call
    to *fileobj*.write passes a text string as an argument.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '| dump | dump(*value*, *fileobj*, skipkeys=**False**, ensure_ascii=**True**,
    check_circular=**True**, allow_nan=**True**, cls=JSONEncoder, indent=**None**,
    separators=('', '', '': ''), default=**None**, sort_keys=**False**, ***kw*) 将对象*value*的JSON序列化写入到文件对象*fileobj*中，*fileobj*必须以文本模式打开进行写入，通过调用*fileobj*.write来传递文本字符串作为参数。'
- en: 'When skipkeys is **True** (by default, it’s **False**), dict keys that are
    not scalars (i.e., are not of types bool, float, int, str, or **None****)** raise
    an exception. In any case, keys that *are* scalars are turned into strings (e.g.,
    **None** becomes ''null''): JSON only allows strings as keys in its mappings.
    |'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当skipkeys为**True**（默认为**False**）时，非标量类型（即不是bool、float、int、str或**None**的键）会引发异常。无论如何，标量类型的键会被转换为字符串（例如，**None**会变成'null'）：JSON只允许在其映射中使用字符串作为键。
- en: '| dump *(cont.)* | When ensure_ascii is **True** (the default), all non-ASCII
    characters in the output are escaped; when it’s **False**, they’re output as is.
    When check_circular is **True** (the default), containers in *value* are checked
    for circular references and a ValueError exception is raised if any are found;
    when it’s **False**, the check is skipped, and many different exceptions can get
    raised as a result (even a crash is possible).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '| dump *(cont.)* | 当ensure_ascii为**True**（默认值）时，输出中的所有非ASCII字符都会被转义；当其为**False**时，它们将原样输出。当check_circular为**True**（默认值）时，*value*中的容器会检查循环引用，如果发现任何循环引用，则会引发ValueError异常；当其为**False**时，则跳过检查，并可能引发多种不同的异常（甚至可能导致崩溃）。'
- en: When allow_nan is **True** (the default), float scalars nan, inf, and -inf are
    output as their respective JavaScript equivalents, NaN, Infinity, and -Infinity;
    when it’s **False**, the presence of such scalars raises a ValueError exception.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当allow_nan为**True**（默认值）时，浮点标量nan、inf和-inf会输出为它们相应的JavaScript等效项NaN、Infinity和-Infinity；当其为**False**时，存在这些标量会引发ValueError异常。
- en: You can optionally pass cls in order to use a customized subclass of JSONEncoder
    (such advanced customization is rarely needed, and we don’t cover it in this book);
    in this case, ***kw* gets passed in the call to cls that instantiates it. By default,
    encoding uses the JSONEncoder class directly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择传递cls来使用JSONEncoder的自定义子类（这种高级定制很少需要，在本书中我们不涵盖这部分）；在这种情况下，***kw*会在实例化cls时传递给它的调用中使用。默认情况下，编码使用JSONEncoder类直接进行。
- en: When indent is an int > 0, dump “pretty-prints” the output by prepending that
    many spaces to each array element and object member; when it’s an int <= 0, dump
    just inserts \n characters. When indent is **None** (the default), dump uses the
    most compact representation. indent can also be a str—for example, '\t'—and in
    that case dump uses that string for indenting.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当缩进为大于0的整数时，dump函数会在每个数组元素和对象成员前面加上相应数量的空格来实现“美观打印”；当缩进为小于等于0的整数时，dump函数仅插入换行符。当缩进为**None**（默认值）时，dump函数使用最紧凑的表示方式。缩进也可以是一个字符串，例如'\t'，在这种情况下，dump函数使用该字符串作为缩进。
- en: separators must be a tuple with two items, respectively the strings used to
    separate items and to separate keys from values. You can explicitly pass separators=(',',
    ':') to ensure dump inserts no whitespace.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: separators必须是一个包含两个元素的元组，分别是用于分隔项的字符串和用于分隔键值对的字符串。您可以显式地传递separators=(',', ':')来确保dump函数不插入任何空白字符。
- en: You can optionally pass default in order to transform some otherwise nonserializable
    objects into serializable ones. default is a function called with a single argument
    that’s a nonserializable object, and it must return a serializable object or raise
    ValueError (by default, the presence of nonserializable objects raises ValueError).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择传递default以将一些本来不能被序列化的对象转换为可序列化对象。default是一个函数，接受一个非序列化对象作为参数，并且必须返回一个可序列化对象，或者引发ValueError异常（默认情况下，存在非序列化对象会引发ValueError异常）。
- en: When sort_keys is **True** (by default, it’s **False**), mappings are output
    in sorted order of their keys; when **False**, they’re output in whatever is their
    natural order of iteration (nowadays, for most mappings, insertion order). |
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当sort_keys为**True**（默认为**False**）时，映射将按其键的排序顺序输出；当**False**时，它们将按照它们的自然迭代顺序输出（如今，对于大多数映射，是插入顺序）。
- en: '| dumps | dumps(*value*, skipkeys=**False**, ensure_ascii=**True**, check_circular=**True**,
    allow_nan=**True**, cls=JSONEncoder, indent=**None**, separators=('', '', '':
    ''), default=**None**, sort_keys=**False**, ***kw*)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '| dumps | dumps(*value*, skipkeys=**False**, ensure_ascii=**True**, check_circular=**True**,
    allow_nan=**True**, cls=JSONEncoder, indent=**None**, separators=('', '', '':
    ''), default=**None**, sort_keys=**False**, ***kw*)'
- en: Returns the string that’s the JSON serialization of object *value*—that is,
    the string that dump would write to its file object argument. All arguments to
    dumps have exactly the same meaning as the arguments to dump.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个字符串，该字符串是对象*value*的JSON序列化结果，即dump将写入其文件对象参数的字符串。dumps的所有参数与dump的参数完全相同。
- en: JSON Serializes Just One Object per File
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON仅序列化一个对象到每个文件中
- en: 'JSON is not what is known as a *framed format*: this means it is *not* possible
    to call dump more than once in order to serialize multiple objects into the same
    file, nor to later call load more than once to deserialize the objects, as would
    be possible, for example, with pickle (discussed in the following section). So,
    technically, JSON serializes just one object per file. However, that one object
    can be a list or dict that can contain as many items as you wish.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: JSON并非所谓的*框架格式*：这意味着无法多次调用dump来将多个对象序列化到同一个文件中，也不能稍后多次调用load来反序列化对象，就像使用pickle（在下一节讨论）那样。因此，从技术上讲，JSON仅序列化单个对象到一个文件中。但是，该对象可以是一个列表或字典，其中可以包含任意数量的条目。
- en: '|'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| load | load(*fileobj*, encoding=''utf-8'', cls=JSONDecoder, object_hook=**None**,
    parse_float=float, parse_int=int, parse_constant=**None**, object_pairs_hook=**None**,
    ***kw*) Creates and returns the object *v* previously serialized into file-like
    object *fileobj*, which must be opened for reading in text mode, getting *fileobj*’s
    contents via a call to *fileobj*.read. The call to *fileobj*.read must return
    a text (Unicode) string.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '| load | load(*fileobj*, encoding=''utf-8'', cls=JSONDecoder, object_hook=**None**,
    parse_float=float, parse_int=int, parse_constant=**None**, object_pairs_hook=**None**,
    ***kw*) 创建并返回先前序列化为文件类对象*fileobj*中的对象*v*，*fileobj*必须以文本模式打开，通过调用*fileobj*.read获取*fileobj*的内容。调用*fileobj*.read必须返回文本（Unicode）字符串。'
- en: 'The functions load and dump are complementary. In other words, a single call
    to load(*f*) deserializes the same value previously serialized when *f*’s contents
    were created by a single call to dump(*v*, *f*) (possibly with some alterations:
    e.g., all dictionary keys are turned into strings).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 函数load和dump是互补的。换句话说，单个调用load(*f*)将反序列化在调用dump(*v*, *f*)时序列化的相同值（可能会有一些修改：例如，所有字典键都变成字符串时）的值。
- en: You can optionally pass cls in order to use a customized subclass of JSONDecoder
    (such advanced customization is rarely needed, and we don’t cover it in this book);
    in this case, ***kw* gets passed in the call to cls, which instantiates it. By
    default, decoding uses the JSONDecoder class directly.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 可以选择传递cls以使用JSONDecoder的自定义子类（这种高级定制很少需要，在本书中我们不涵盖它）；在这种情况下，***kw*将在调用cls时传递，并由其实例化。默认情况下，解码直接使用JSONDecoder类。
- en: You can optionally pass object_hook or object_pairs_hook (if you pass both,
    object_hook is ignored and only object_pairs_hook is used), a function that lets
    you implement custom decoders. When you pass object_hook but not object_pairs_hook,
    each time an object is decoded into a dict, load calls object_hook with the dict
    as the only argument, and uses object_hook’s return value instead of that dict.
    When you pass object_pairs_hook, each time an object is decoded, load calls object_pairs_hook
    with, as the only argument, a list of the pairs of (*key*, *value*) items of the
    object, in the order in which they are present in the input, and uses object_pairs_hooks’s
    return value. This lets you perform specialized decoding that potentially depends
    on the order of (*key*, *value*) pairs in the input.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以选择传递object_hook或object_pairs_hook（如果两者都传递，则object_hook将被忽略，只使用object_pairs_hook），这是一个允许您实现自定义解码器的函数。当传递object_hook但没有传递object_pairs_hook时，每次将对象解码为字典时，load都会使用object_hook，并以该字典作为唯一参数调用object_hook，并使用object_hook的返回值而不是该字典。当传递object_pairs_hook时，每次解码对象时，load将使用object_pairs_hook，并将对象的(*key*,
    *value*)对的列表作为唯一参数传递，顺序与输入中的顺序相同，并使用object_pairs_hook的返回值。这使您可以执行依赖于输入中(*key*,
    *value*)对顺序的专门解码。
- en: 'parse_float, parse_int, and parse_constant are functions called with a single
    argument: a str representing a float, an int, or one of the three special constants
    ''NaN'', ''Infinity'', or ''-Infinity''. load calls the appropriate function each
    time it identifies in the input a str representing a number, and uses the function’s
    return value. By default, parse_float is the built-in function float, parse_int
    is int, and parse_constant is a function that returns one of the three special
    float scalars nan, inf, or -inf, as appropriate. For example, you could pass parse_float=decimal.Decimal
    to ensure that all numbers in the result that would normally be floats are instead
    decimals (covered in [“The decimal Module”](ch16.xhtml#the_decimal_module)). |'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: parse_float、parse_int 和 parse_constant 是使用单个参数调用的函数：表示浮点数、整数或三个特殊常量之一（'NaN'、'Infinity'
    或 '-Infinity'）的 str。每次识别输入中表示数字的 str 时，load 调用适当的函数，并使用函数的返回值。默认情况下，parse_float
    是内置的 float 函数，parse_int 是 int，parse_constant 是一个返回特殊浮点数标量 nan、inf 或 -inf 的函数。例如，可以传递
    parse_float=decimal.Decimal 以确保结果中的所有数字正常情况下都是小数（如 [“decimal 模块”](ch16.xhtml#the_decimal_module)
    中所述）。 |
- en: '| loads | loads(*s*, cls=JSONDecoder, object_hook=**None**, parse_float=float,
    parse_int=int, parse_constant=**None**, object_pairs_hook=**None**, ***kw*) Creates
    and returns the object *v* previously serialized into the string *s*. All arguments
    to loads have exactly the same meaning as the arguments to load. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| loads | loads(*s*, cls=JSONDecoder, object_hook=**None**, parse_float=float,
    parse_int=int, parse_constant=**None**, object_pairs_hook=**None**, ***kw*) 创建并返回之前已序列化为字符串
    *s* 的对象 *v*。loads 的所有参数与 load 的参数完全相同。 |'
- en: A json example
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个 JSON 示例
- en: 'Say you need to read several text files, whose names are given as your program’s
    arguments, recording where each distinct word appears in the files. What you need
    to record for each word is a list of (*filename*, *linenumber*) pairs. The following
    example uses the fileinput module to iterate through all the files given as program
    arguments, and json to encode the lists of (*filename*, *linenumber*) pairs as
    strings and store them in a DBM-like file (as covered in [“DBM Modules”](#dbm_modules)).
    Since these lists contain tuples, each containing a string and a number, they
    are within json’s abilities to serialize:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要读取多个文本文件，其文件名作为程序参数给出，并记录每个单词在文件中出现的位置，你需要记录每个单词的 (*文件名*, *行号*) 对列表。以下示例使用
    fileinput 模块迭代所有作为程序参数给出的文件，并使用 json 将 (*文件名*, *行号*) 对列表编码为字符串，并存储在类似 DBM 的文件中（如
    [“DBM 模块”](#dbm_modules) 中所述）。由于这些列表包含元组，每个元组包含字符串和数字，它们可以被 json 序列化：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can then use json to deserialize the data stored in the DBM-like file *indexfilem*,
    as in the following example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 json 解序列化存储在类似 DBM 文件 *indexfilem* 中的数据，如以下示例所示：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The pickle Module
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: pickle 模块
- en: The pickle module supplies factory functions, named Pickler and Unpickler, to
    generate objects (instances of nonsubclassable types, not classes) that wrap files
    and supply Python-specific serialization mechanisms. Serializing and deserializing
    via these modules is also known as *pickling* and *unpickling*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: pickle 模块提供了名为 Pickler 和 Unpickler 的工厂函数，用于生成对象（不可子类化类型的实例，而不是类），这些对象包装文件并提供
    Python 特定的序列化机制。通过这些模块进行序列化和反序列化也称为 *pickling* 和 *unpickling*。
- en: 'Serialization shares some of the issues of deep copying, covered in [“The copy
    Module”](ch08.xhtml#the_copy_module). The pickle module deals with these issues
    in much the same way as the copy module does. Serialization, like deep copying,
    implies a recursive walk over a directed graph of references. pickle preserves
    the graph’s shape: when the same object is encountered more than once, the object
    is serialized only the first time, and other occurrences of the same object serialize
    references to that single value. pickle also correctly serializes graphs with
    reference cycles. However, this means that if a mutable object *o* is serialized
    more than once to the same Pickler instance *p*, any changes to *o* after the
    first serialization of *o* to *p* are not saved.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化与深拷贝具有某些相同的问题，如 [“copy 模块”](ch08.xhtml#the_copy_module) 中所述。pickle 模块处理这些问题的方式与
    copy 模块非常相似。序列化，就像深拷贝一样，意味着在引用的有向图上进行递归遍历。pickle 保留了图的形状：当多次遇到相同的对象时，仅第一次序列化该对象，其他出现的相同对象序列化为对该单一值的引用。pickle
    还正确地序列化具有引用循环的图。然而，这意味着如果可变对象 *o* 被序列化多次到同一个 Pickler 实例 *p*，则在第一次将 *o* 序列化到 *p*
    后对 *o* 的任何更改都不会被保存。
- en: Don’t Alter Objects While Their Serialization Is Underway
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在序列化正在进行时不要更改对象
- en: For clarity, correctness, and simplicity, don’t alter objects that are being
    serialized while serialization to a Pickler instance is in progress.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰、正确和简单起见，在 Pickler 实例序列化过程中不要更改正在序列化的对象。
- en: pickle can serialize with a legacy ASCII protocol or with one of several compact
    binary protocols. [Table 12-3](#pickle_protocols) lists the available protocols.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: pickle可以使用遗留ASCII协议或多个紧凑的二进制协议进行序列化。[表 12-3](#pickle_protocols)列出了可用的协议。
- en: Table 12-3\. pickle protocols
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-3\. pickle 协议
- en: '| Protocol | Format | Added in Python version | Description |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 协议 | 格式 | Python 版本新增 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | ASCII | 1.4^([a](ch12.xhtml#ch01fn108)) | Human-readable format, slow
    to serialize/deserialize |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 0 | ASCII | 1.4^([a](ch12.xhtml#ch01fn108)) | 可读性强，序列化/反序列化速度慢 |'
- en: '| 1 | Binary | 1.5 | Early binary format, superseded by protocol 2 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 二进制 | 1.5 | 早期二进制格式，被协议 2 取代 |'
- en: '| 2 | Binary | 2.3 | Improved support for later Python 2 features |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 二进制 | 2.3 | 改进对后期 Python 2 特性的支持 |'
- en: '| 3 | Binary | 3.0 | (-3.8 default) Added specific support for bytes objects
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 二进制 | 3.0 | （-3.8 默认）增加对字节对象的具体支持 |'
- en: '| 4 | Binary | 3.4 | (3.8+ default) Included support for very large objects
    |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 二进制 | 3.4 | （3.8+ 默认）支持非常大的对象 |'
- en: '| 5 | Binary | 3.8 | 3.8+ Added features to support pickling as serialization
    for transport between processes, per [PEP 574](https://oreil.ly/PcSYs) |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 二进制 | 3.8 | 3.8+ 添加了支持作为传输过程中序列化的 pickling 特性，参见 [PEP 574](https://oreil.ly/PcSYs)
    |'
- en: '| ^([a](ch12.xhtml#ch01fn108-marker)) Or possibly earlier. This is the oldest
    version of documentation available at [Python.org](http://Python.org). |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch12.xhtml#ch01fn108-marker)) 或可能更早。这是可在 [Python.org](http://Python.org)
    上找到的最古老版本的文档。 |'
- en: Always Pickle with Protocol 2 or Higher
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 始终使用协议 2 或更高版本进行 Pickle
- en: Always use *at least* protocol 2. The size and speed savings can be substantial,
    and binary format has basically no downside except loss of compatibility of resulting
    pickles with truly ancient versions of Python.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 始终使用*至少*协议 2。尺寸和速度节省可观，并且二进制格式基本没有任何缺点，除了导致生成的 pickle 与真正古老版本的 Python 不兼容之外。
- en: When you reload objects, pickle transparently recognizes and uses any protocol
    that the Python version you’re currently using supports.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当重新加载对象时，pickle会透明地识别并使用当前Python版本支持的任何协议。
- en: 'pickle serializes classes and functions by name, not by value.^([2](ch12.xhtml#ch01fn109))
    pickle can therefore deserialize a class or function only by importing it from
    the same module where the class or function was found when pickle serialized it.
    In particular, pickle can normally serialize and deserialize classes and functions
    only if they are top-level names (i.e., attributes) of their respective modules.
    Consider the following example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: pickle（腌制）通过名称而非数值序列化类和函数^([2](ch12.xhtml#ch01fn109))。因此，pickle只能在反序列化时从与pickle序列化时相同模块中导入类或函数。特别地，pickle通常只能序列化和反序列化类和函数，如果它们是其各自模块的顶级名称（即属性）。考虑以下示例：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This code binds a closure to name plus5 (as covered in [“Nested functions and
    nested scopes”](ch03.xhtml#nested_functions_and_nested_scopes))—a nested function
    inner plus an appropriate outer scope. Therefore, trying to pickle plus5 raises
    an AttributeError: a function can be pickled only when it is top-level, and the
    function inner, whose closure is bound to the name plus5 in this code, is not
    top-level but rather is nested inside the function adder. Similar issues apply
    to pickling nested functions and nested classes (i.e., classes not at the top
    level).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将一个闭包绑定到名称 plus5（如[“嵌套函数和嵌套作用域”](ch03.xhtml#nested_functions_and_nested_scopes)中所述）——一个内部函数
    inner 与适当的外部作用域。因此，尝试对 plus5 进行 pickle 会引发 AttributeError：只有当函数处于顶级时，才能对其进行 pickle，而此代码中其闭包绑定到名称
    plus5 的函数 inner 并非顶级，而是嵌套在函数 adder 内部。类似的问题也适用于序列化嵌套函数和嵌套类（即不在顶层的类）。
- en: pickle functions and classes
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pickle 函数和类
- en: The pickle module exposes the functions and classes listed in [Table 12-4](#functions_and_classes_of_the_pickle_mod).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: pickle 模块公开了[表 12-4](#functions_and_classes_of_the_pickle_mod)中列出的函数和类。
- en: Table 12-4\. Functions and classes of the pickle module
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-4\. pickle 模块的函数和类
- en: '| dump, dumps | dump(*value*, *fileobj,* protocol=**None**, bin=**None**),
    dumps(*value*, protocol=**None**, bin=**None**)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '| dump, dumps | dump(*value*, *fileobj,* protocol=**None**, bin=**None**),
    dumps(*value*, protocol=**None**, bin=**None**)'
- en: dumps returns a bytestring representing the object *value*. dump writes the
    same string to the file-like object *fileobj*, which must be opened for writing.
    dump(*v*, *f*) is like *f*.write(dumps(*v*)). The protocol parameter can be 0
    (ASCII output, the slowest and bulkiest option), or a larger int for various kinds
    of binary output (see [Table 12-3](#pickle_protocols)). Unless protocol is 0,
    the *fileobj* parameter to dump must be open for binary writing. Do not pass the
    bin parameter, which exists only for compatibility with old versions of Python.
    |
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: dumps 返回表示对象 *value* 的字节串。dump 将相同的字符串写入类似文件的对象 *fileobj*，该对象必须已打开以供写入。dump(*v*,
    *f*) 就像 *f*.write(dumps(*v*))。protocol 参数可以是 0（ASCII 输出，最慢和最庞大的选项），或者更大的整数表示各种类型的二进制输出（参见
    [Table 12-3](#pickle_protocols)）。除非 protocol 是 0，否则传递给 dump 的 *fileobj* 参数必须已打开以供二进制写入。不要传递
    bin 参数，它仅为与旧版本 Python 的兼容性而存在。 |
- en: '| load, loads | load(*fileobj*), loads(*s*, *, fix_imports=True, encoding="ASCII",
    errors="strict")'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '| load, loads | load(*fileobj*), loads(*s*, *, fix_imports=True, encoding="ASCII",
    errors="strict")'
- en: The functions load and dump are complementary. In other words, a sequence of
    calls to load(*f*) deserializes the same values previously serialized when *f*’s
    contents were created by a sequence of calls to dump(*v, f*). load reads the right
    number of bytes from file-like object *fileobj* and creates and returns the object
    *v* represented by those bytes. load and loads transparently support pickles performed
    in any binary or ASCII protocol. If data is pickled in any binary format, the
    file must be open as binary for both dump and load. load(*f*) is like Unpickler(*f*).load().
    |
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 load 和 dump 是互补的。换句话说，对 load(*f*) 的一系列调用将反序列化与之前通过对 dump(*v, f*) 进行一系列调用而创建
    *f* 内容时序列化的相同值。load 从类似文件的对象 *fileobj* 中读取正确数量的字节，并创建并返回由这些字节表示的对象 *v*。load 和
    loads 透明地支持在任何二进制或 ASCII 协议中执行的 pickles。如果数据以任何二进制格式进行 pickle，文件必须对于 dump 和 load
    都以二进制方式打开。load(*f*) 就像 Unpickler(*f*).load()。 |
- en: '| load, loads'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '| load, loads'
- en: '*(cont.)* | loads creates and returns the object *v* represented by bytestring
    *s*, so that for any object *v* of a supported type, *v*==loads(dumps(*v*)). If
    *s* is longer than dumps(*v*), loads ignores the extra bytes. Optional arguments
    fix_imports, encoding, and errors are provided for handling streams generated
    by Python 2 code; see the pickle.loads [documentation](https://oreil.ly/VSepJ)
    for further information.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*(cont.)* | loads 创建并返回由字节串 *s* 表示的对象 *v*，因此对于任何支持的类型的对象 *v*，*v*==loads(dumps(*v*))。如果
    *s* 比 dumps(*v*) 长，loads 会忽略额外的字节。提供了可选参数 fix_imports、encoding 和 errors 来处理由 Python
    2 代码生成的流；请参阅 [pickle.loads 文档](https://oreil.ly/VSepJ) 以获取更多信息。'
- en: Never Unpickle Untrusted Data
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 永远不要反序列化不受信任的数据
- en: Unpickling from an untrusted data source is a security risk; an attacker could
    exploit this vulnerability to execute arbitrary code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从不受信任的数据源进行反序列化是一种安全风险；攻击者可能利用此漏洞执行任意代码。
- en: '|'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Pickler | Pickler(*fileobj*, protocol=**None**, bin=**None**) Creates and
    returns an object *p* such that calling *p*.dump is equivalent to calling the
    function dump with the *fileobj*, protocol, and bin arguments passed to Pickler.
    To serialize many objects to a file, Pickler is more convenient and faster than
    repeated calls to dump. You can subclass pickle.Pickler to override Pickler methods
    (particularly the method persistent_id) and create your own persistence framework.
    However, this is an advanced topic and is not covered further in this book. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 序列化器 | 序列化器(*fileobj*, protocol=**None**, bin=**None**) 创建并返回一个对象 *p*，使得调用
    *p*.dump 相当于调用 dump 函数并传递给 Pickler *fileobj*、protocol 和 bin 参数。为了将多个对象序列化到文件中，Pickler
    比重复调用 dump 更方便且更快。你可以子类化 pickle.Pickler 来覆盖 Pickler 方法（尤其是 persistent_id 方法）并创建你自己的持久化框架。然而，这是一个高级主题，在本书中不再进一步讨论。
    |'
- en: '| Unpickler | Unpickler(*fileobj*) Creates and returns an object *u* such that
    calling the *u*.load is equivalent to calling load with the *fileobj* argument
    passed to Unpickler. To deserialize many objects from a file, Unpickler is more
    convenient and faster than repeated calls to the function load. You can subclass
    pickle.Unpickler to override Unpickler methods (particularly the method persistent_load)
    and create your own persistence framework. However, this is an advanced topic
    and is not covered further in this book. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 反序列化器 | 反序列化器(*fileobj*) 创建并返回一个对象 *u*，使得调用 *u*.load 相当于调用 load 并传递 *fileobj*
    参数给 Unpickler。为了从文件中反序列化多个对象，Unpickler 比重复调用 load 函数更方便且更快。你可以子类化 pickle.Unpickler
    来覆盖 Unpickler 方法（尤其是 persistent_load 方法）并创建你自己的持久化框架。然而，这是一个高级主题，在本书中不再进一步讨论。
    |'
- en: A pickling example
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个序列化的例子
- en: 'The following example handles the same task as the json example shown earlier,
    but uses pickle instead of json to serialize lists of (*filename*, *linenumber*)
    pairs as strings:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例处理与之前显示的json示例相同的任务，但使用pickle而不是json将(*filename*, *linenumber*)对的列表序列化为字符串：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can then use pickle to read back the data stored to the DBM-like file *indexfilep*,
    as shown in the following example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用pickle从类似DBM的文件*indexfilep*中读回存储的数据，如下例所示：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Pickling instances
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对实例进行pickle
- en: 'In order for pickle to reload an instance *x*, pickle must be able to import
    *x*’s class from the same module in which the class was defined when pickle saved
    the instance. Here is how pickle saves the state of instance object *x* of class
    *T* and later reloads the saved state into a new instance *y* of *T* (the first
    step of the reloading is always to make a new empty instance *y* of *T*, except
    where we explicitly say otherwise):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让pickle重新加载实例*x*，pickle必须能够从pickle保存实例时定义类的同一模块中导入*x*的类。以下是pickle如何保存类*T*的实例对象*x*的状态，并将保存的状态重新加载到类*T*的新实例*y*中（重新加载的第一步始终是创建*T*的新空实例*y*，除非另有明确说明）：
- en: When *T* supplies the method __getstate__, pickle saves the result *d* of calling
    *T*.__getstate__(*x*).
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当*T*提供方法__getstate__时，pickle保存调用*T*.__getstate__(*x*)的结果*d*。
- en: When *T* supplies the method __setstate__, *d* can be of any type, and pickle
    reloads the saved state by calling *T*.__setstate__(*y, d*).
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当*T*提供方法__setstate__时，*d*可以是任何类型，并且pickle通过调用*T*.__setstate__(*y, d*)重新加载保存的状态。
- en: Otherwise, *d* must be a dictionary, and pickle just sets *y*.__dict__ = *d*.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，*d*必须是一个字典，pickle只需设置*y*.__dict__ = *d*。
- en: Otherwise, when *T* supplies the method __getnewargs__, and pickle is pickling
    with protocol 2 or higher, pickle saves the result *t* of calling *T*.__getnewargs__(*x*);
    *t* must be a tuple.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，当*T*提供方法__getnewargs__，并且pickle使用协议2或更高版本进行pickle时，pickle保存调用*T*.__getnewargs__(*x*)的结果*t*；*t*必须是一个元组。
- en: pickle, in this one case, does not start with an empty *y*, but rather creates
    *y* by executing *y* = *T*.__new__(*T*, **t*), which concludes the reloading.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，pickle不会从空*y*开始，而是通过执行*y* = *T*.__new__(*T*, **t*)来创建*y*，从而完成重新加载。
- en: Otherwise, by default, pickle saves as *d* the dictionary *x*.__dict__.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，默认情况下，pickle将*x*.__dict__保存为字典*d*。
- en: When *T* supplies the method __setstate__, pickle reloads the saved state by
    calling *T*.__setstate__(*y, d*).
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当*T*提供方法__setstate__时，pickle通过调用*T*.__setstate__(*y, d*)重新加载保存的状态。
- en: Otherwise, pickle just sets *y*.__dict__ = *d*.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，pickle只需设置*y*.__dict__ = *d*。
- en: All the items in the *d* or *t* object that pickle saves and reloads (normally
    a dictionary or tuple) must, in turn, be instances of types suitable for pickling
    and unpickling (aka *pickleable* objects), and the procedure just outlined may
    be repeated recursively, if necessary, until pickle reaches primitive pickleable
    built-in types (dictionaries, tuples, lists, sets, numbers, strings, etc.).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: pickle保存和重新加载的*d*或*t*对象中的所有项（通常是字典或元组）必须依次是适合进行pickle和unpickle（即*pickleable*）的类型的实例，并且如有必要，该过程可以递归重复进行，直到pickle到达原始的pickleable内置类型（如字典、元组、列表、集合、数字、字符串等）。
- en: As mentioned in [“The copy Module”](ch08.xhtml#the_copy_module), the __getnewargs__,
    __getstate__, and __setstate__ special methods also control the way instance objects
    are copied and deep copied. If a class defines __slots__, and therefore its instances
    do not have a __dict__ attribute, pickle does its best to save and restore a dictionary
    equivalent to the names and values of the slots. However, such a class should
    define __getstate__ and __setstate__; otherwise, its instances may not be correctly
    pickleable and copied through such best-effort endeavors.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如[“copy模块”](ch08.xhtml#the_copy_module)中所述，__getnewargs__、__getstate__和__setstate__特殊方法还控制实例对象的复制和深度复制方式。如果一个类定义了__slots__，因此其实例没有__dict__属性，pickle会尽力保存和恢复等同于slots名称和值的字典。然而，这样的类应该定义__getstate__和__setstate__；否则，其实例可能无法正确进行pickle和复制。
- en: Pickling customization with the copyreg module
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用copyreg模块进行pickle定制
- en: You can control how pickle serializes and deserializes objects of an arbitrary
    type by registering factory and reduction functions with the module copyreg. This
    is particularly, though not exclusively, useful when you define a type in a C-coded
    Python extension. The copyreg module supplies the functions listed in [Table 12-5](#functions_of_the_copy_reg_module).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向 copyreg 模块注册工厂和减少函数，可以控制 pickle 如何序列化和反序列化任意类型的对象。当您在 C 代码的 Python 扩展中定义类型时，这尤为有用。copyreg
    模块提供了 [表 12-5](#functions_of_the_copy_reg_module) 中列出的函数。
- en: Table 12-5\. Functions of the copyreg module
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-5\. copyreg 模块的函数
- en: '| constructor | constructor(*fcon*) Adds *fcon* to the table of constructors,
    which lists all factory functions that pickle may call. *fcon* must be callable
    and is normally a function. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| constructor | constructor(*fcon*) 将 *fcon* 添加到构造函数表中，该表列出 pickle 可能调用的所有工厂函数。*fcon*
    必须是可调用的，通常是一个函数。 |'
- en: '| pickle | pickle(*type*, *fred*, fcon=**None**) Registers function *fred*
    as the *reduction function* for type *type*, where *type* must be a type object.
    To save an object *o* of type *type*, the module pickle calls *fred*(*o*) and
    saves the result. *fred*(*o*) must return a tuple (fcon, *t*) or (fcon, *t*, *d*),
    where *fcon* is a constructor and *t* is a tuple. To reload *o*, pickle uses *o*=fcon(**t*).
    Then, when *fred* also returns a *d*, pickle uses *d* to restore *o*’s state (when
    *o* supplies __setstate__, *o*.__setstate__(*d*); otherwise, *o*.__dict__.update(*d*)),
    as described in the previous section. If *fcon* is not **None**, pickle also calls
    constructor(*fcon*) to register *fcon* as a constructor.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '| pickle | pickle(*type*, *fred*, fcon=**None**) 将函数 *fred* 注册为类型 *type* 的减少函数，其中
    *type* 必须是一个类型对象。要保存类型为 *type* 的对象 *o*，模块 pickle 调用 *fred*(*o*) 并保存结果。*fred*(*o*)
    必须返回一个元组 (fcon, *t*) 或 (fcon, *t*, *d*)，其中 *fcon* 是一个构造函数，*t* 是一个元组。要重新加载 *o*，pickle
    使用 *o*=fcon(**t*)。然后，当 *fred* 还返回 *d* 时，pickle 使用 *d* 来恢复 *o* 的状态（如果 *o* 提供了 __setstate__，则
    *o*.__setstate__(*d*)；否则，*o*.__dict__.update(*d*)），如前一节所述。如果 *fcon* 不为 **None**，pickle
    还会调用构造函数 (*fcon*) 来注册 *fcon* 作为构造函数。'
- en: 'pickle does not support pickling of code objects, but marshal does. Here’s
    how you could customize pickling to support code objects by delegating the work
    to marshal thanks to copyreg:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: pickle 不支持对代码对象的 pickle 操作，但 marshal 支持。以下是如何通过利用 copyreg 将 pickle 定制以支持代码对象的示例：
- en: '[PRE6]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using marshal Makes Your Code Python Version Dependent
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 marshal 使你的代码依赖于 Python 版本
- en: Be careful when using marshal in your code, as the preceding example does. marshal’s
    serialization isn’t guaranteed to be stable across versions, so using marshal
    means that programs written in other versions of Python may be unable to load
    the objects your program has serialized.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中使用 marshal 时要小心，就像前面的示例一样。marshal 的序列化不能保证跨版本稳定，因此使用 marshal 意味着其他版本的
    Python 编写的程序可能无法加载你的程序序列化的对象。
- en: '|'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The shelve Module
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: shelve 模块
- en: The shelve module orchestrates the modules pickle, io, and dbm (and its underlying
    modules for access to DBM-like archive files, as discussed in the following section)
    in order to provide a simple, lightweight persistence mechanism.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: shelve 模块通过协调 pickle、io 和 dbm（及其底层访问 DBM 类型归档文件的模块，如下一节所述），提供了一个简单、轻量级的持久化机制。
- en: shelve supplies a function, open, that is polymorphic to dbm.open. The mapping
    *s* returned by shelve.open is less limited, however, than the mapping *a* returned
    by dbm.open. *a*’s keys and values must be strings.^([3](ch12.xhtml#idm44924511774592))
    *s*’s keys must also be strings, but *s*’s values may be of any pickleable types.
    pickle customizations (copyreg, __getnewargs__, __getstate__, and __setstate__)
    also apply to shelve, as shelve delegates serialization to pickle. Keys and values
    are stored as bytes. When strings are used, they are implicitly converted to the
    default encoding before being stored.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: shelve 提供了一个函数 open，其多态性类似于 dbm.open。shelve.open 返回的映射 *s* 比 dbm.open 返回的映射
    *a* 更为灵活。*a* 的键和值必须是字符串。^([3](ch12.xhtml#idm44924511774592)) *s* 的键也必须是字符串，但 *s*
    的值可以是任何可 pickle 的类型。pickle 定制（copyreg、__getnewargs__、__getstate__ 和 __setstate__）同样适用于
    shelve，因为 shelve 将序列化工作委托给 pickle。键和值以字节形式存储。使用字符串时，在存储之前会隐式地转换为默认编码。
- en: 'Beware of a subtle trap when you use shelve with mutable objects: when you
    operate on a mutable object held in a shelf, the changes aren’t stored back unless
    you assign the changed object back to the same index. For example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在使用 shelve 与可变对象时要小心一个微妙的陷阱：当你对一个存储在 shelf 中的可变对象进行操作时，除非将更改的对象重新分配回相同的索引，否则更改不会存储回去。例如：
- en: '[PRE8]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can finesse this issue by passing the named argument writeback=**True**
    when you call shelve.open, but this can seriously impair the performance of your
    program.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 shelve.open 时，通过传递命名参数 writeback=**True**，可以解决这个问题，但这可能严重影响程序的性能。
- en: A shelving example
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个 shelve 示例
- en: 'The following example handles the same task as the earlier json and pickle
    examples, but uses shelve to persist lists of (*filename*, *linenumber*) pairs:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例处理与之前的 json 和 pickle 示例相同的任务，但使用 shelve 来持久化 (*filename*, *linenumber*)
    对的列表：
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We must then use shelve to read back the data stored to the DBM-like file *indexfiles*,
    as shown in the following example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须使用 shelve 读取存储到类似 DBM 的文件 *indexfiles* 中的数据，如下例所示：
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These two examples are the simplest and most direct of the various equivalent
    pairs of examples shown throughout this section. This reflects the fact that shelve
    is higher level than the modules used in previous examples.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个示例是本节中显示的各种等效示例中最简单、最直接的示例。这反映了 shelve 比之前示例中使用的模块更高级的事实。
- en: DBM Modules
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DBM 模块
- en: '[DBM](https://oreil.ly/osARc), a longtime Unix mainstay, is a family of libraries
    supporting data files containing pairs of bytestrings (*key*, *data*). DBM offers
    fast fetching and storing of the data given a key, a usage pattern known as *keyed
    access*. Keyed access, while nowhere near as powerful as the data access functionality
    of relational DBs, imposes less overhead, and it may suffice for some programs’
    needs. If DBM-like files are sufficient for your purposes, with this approach
    you can end up with a program that is smaller and faster than one using a relational
    DB.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[DBM](https://oreil.ly/osARc)，长期以来是 Unix 的主要组成部分，是一组支持包含字节串对 (*key*, *data*)
    的数据文件的库。DBM 提供了根据键快速获取和存储数据的功能，这种使用模式称为 *键访问*。尽管键访问远不及关系数据库的数据访问功能强大，但它的开销较小，对于某些程序的需求可能足够。如果
    DBM 类似的文件对您的目的足够，通过这种方法，您可以得到一个比使用关系数据库更小更快的程序。'
- en: DBM Databases Are Bytes-Oriented
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DBM 数据库以字节为导向
- en: DBM databases require both keys and values to be bytes values. You will see
    in the example included later that the text input is explicitly encoded in UTF-8
    before storage. Similarly, the inverse decoding must be performed when reading
    back the values.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: DBM 数据库要求键和值都是字节值。稍后包含的示例中，您将看到文本输入在存储之前被明确编码为 UTF-8。类似地，在读取值时必须执行逆解码。
- en: 'DBM support in Python’s standard library is organized in a clean and elegant
    way: the dbm package exposes two general functions, and within the same package
    live other modules supplying specific implementations.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Python 标准库中的 DBM 支持以一种清晰而优雅的方式组织：dbm 包公开了两个通用函数，同一包中还有其他模块提供特定的实现。
- en: Berkeley DB Interfacing
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Berkeley DB 接口
- en: The bsddb module has been removed from the Python standard library. If you need
    to interface to a BSD DB archive, we recommend the excellent third-party package
    [bsddb3](https://oreil.ly/xizEg).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: bsddb 模块已从 Python 标准库中移除。如果您需要与 BSD DB 存档交互，我们建议使用出色的第三方包 [bsddb3](https://oreil.ly/xizEg)。
- en: The dbm Package
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DBM 包
- en: The dbm package provides the top-level functions described in [Table 12-6](#functions_of_the_dbm_package).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: dbm 包提供了 [表 12-6](#dbm_package_functions) 中描述的顶层函数。
- en: Table 12-6\. Functions of the dbm package
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-6\. dbm 包的函数
- en: '| open | open(*filepath*, flag=''r'', mode=0o666) Opens or creates the DBM
    file named by *filepath* (any path to a file) and returns a mapping object corresponding
    to the DBM file. When the DBM file already exists, open uses the function whichdb
    to determine which DBM submodule can handle the file. When open creates a new
    DBM file, it chooses the first available dbm submodule in the following order
    of preference: gnu, ndbm, dumb.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '| open | open(*filepath*, flag=''r'', mode=0o666) 打开或创建由 *filepath*（任何文件的路径）指定的
    DBM 文件，并返回与 DBM 文件对应的映射对象。当 DBM 文件已经存在时，open 使用 whichdb 函数来确定哪个 DBM 子模块可以处理文件。当
    open 创建新的 DBM 文件时，它会按照以下偏好顺序选择第一个可用的 dbm 子模块：gnu、ndbm、dumb。'
- en: flag is a one-character string that tells open how to open the file and whether
    to create it, according to the rules shown in [Table 12-7](#flag_values_for_dbmdotopen).
    mode is an integer that open uses as the file’s permission bits if open creates
    the file, as covered in [“Creating a File Object with open”](ch11.xhtml#creating_a_file_object_with_open).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: flag 是一个告诉 open 如何打开文件以及是否创建文件的单字符字符串，根据 [表 12-7](#flag_values_for_dbmdotopen)
    中所示的规则。mode 是一个整数，如果 open 创建文件，则 open 会将其用作文件的权限位，如 [“使用 open 创建文件对象”](ch11.xhtml#creating_a_file_object_with_open)
    中所述。
- en: Table 12-7\. Flag values for dbm.open
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-7\. dbm.open 的标志值
- en: '&#124; Flag &#124; Read-only? &#124; If file exists: &#124; If file does not
    exist: &#124;'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 标志 &#124; 只读？ &#124; 如果文件存在： &#124; 如果文件不存在： &#124;'
- en: '&#124; --- &#124; --- &#124; --- &#124; --- &#124;'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; --- &#124; --- &#124; --- &#124; --- &#124;'
- en: '&#124; ''r'' &#124; Yes &#124; Opens the file &#124; Raises error &#124;'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; ''r'' &#124; 是 &#124; 打开文件 &#124; 报错 &#124;'
- en: '&#124; ''w'' &#124; No &#124; Opens the file &#124; Raises error &#124;'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; ''w'' &#124; 否 &#124; 打开文件 &#124; 报错 &#124;'
- en: '&#124; ''c'' &#124; No &#124; Opens the file &#124; Creates the file &#124;'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; ''c'' &#124; 否 &#124; 打开文件 &#124; 创建文件 &#124;'
- en: '&#124; ''n'' &#124; No &#124; Truncates the file &#124; Creates the file &#124;'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; ''n'' &#124; 否 &#124; 截断文件 &#124; 创建文件 &#124;'
- en: dbm.open returns a mapping object *m* with a subset of the functionality of
    dictionaries (covered in [“Dictionary Operations”](ch03.xhtml#dictionary_operation)).
    *m* only accepts bytes as keys and values, and the only nonspecial mapping methods
    *m* supplies are *m*.get, *m*.keys, and *m*.setdefault. You can bind, rebind,
    access, and unbind items in *m* with the same indexing syntax *m*[*key*] that
    you would use if *m* were a dictionary. If flag is 'r', *m* is read-only, so that
    you can only access *m*’s items, not bind, rebind, or unbind them. You can check
    if a string *s* is a key in *m* with the usual expression *s* **in** *m*; you
    cannot iterate directly on *m*, but you can, equivalently, iterate on *m*.keys().
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: dbm.open返回一个映射对象*m*，其功能子集类似于字典（详见[“Dictionary Operations”](ch03.xhtml#dictionary_operation)）。*m*只接受字节作为键和值，而且*m*提供的唯一非特殊映射方法是*m*.get、*m*.keys和*m*.setdefault。你可以使用与字典相同的索引语法*m*[*键*]绑定、重新绑定、访问和解绑*m*中的项目。如果标志是'r'，则*m*是只读的，因此你只能访问*m*的项目，而不能绑定、重新绑定或解绑它们。你可以使用通常的表达式*s*
    **in** *m*检查字符串*s*是否是*m*的键；你不能直接在*m*上进行迭代，但可以等效地在*m*.keys()上进行迭代。
- en: One extra method that *m* supplies is *m*.close, with the same semantics as
    the close method of a file object. Just like for file objects, you should ensure
    *m*.close is called when you’re done using *m*. The **try**/**finally** statement
    (covered in [“try/finally”](ch06.xhtml#trysolidusfinally)) is one way to ensure
    finalization, but the **with** statement, covered in [“The with Statement and
    Context Managers”](ch06.xhtml#the_with_statement_and_context_managers), is even
    better (you can use **with**, since *m* is a context manager). |
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*m*提供的一个额外方法是*m*.close，其语义与文件对象的close方法相同。与文件对象一样，当你使用完*m*后，应确保调用*m*.close。使用[“try/finally”](ch06.xhtml#trysolidusfinally)中介绍的**try**/**finally**语句是确保最终化的一种方式，但使用[“The
    with Statement and Context Managers”](ch06.xhtml#the_with_statement_and_context_managers)中介绍的**with**语句更好（因为*m*是上下文管理器，你可以使用**with**）。
    |'
- en: '| whichdb | whichdb(*filepath*) Opens and reads the file specified by *filepath*
    to discover which dbm submodule created the file. whichdb returns **None** when
    the file does not exist or cannot be opened and read. It returns '''' when the
    file exists and can be opened and read, but it is not possible to determine which
    dbm submodule created the file (typically, this means that the file is not a DBM
    file). If it can find out which module can read the DBM-like file, whichdb returns
    a string that names a dbm submodule, such as ''dbm.ndbm'', ''dbm.dumb'', or ''dbm.gdbm''.
    |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '&#124; whichdb &#124; whichdb(*文件路径*) 打开并读取指定的*文件路径*，以确定创建文件的dbm子模块。当文件不存在或无法打开和读取时，whichdb返回**None**。当文件存在并可以打开和读取，但无法确定创建文件的dbm子模块时（通常意味着文件不是DBM文件），whichdb返回''''。如果可以找出哪个模块可以读取类似DBM的文件，whichdb返回一个命名dbm子模块的字符串，例如''dbm.ndbm''、''dbm.dumb''或''dbm.gdbm''。
    |'
- en: In addition to these two top-level functions, the dbm package contains specific
    modules, such as ndbm, gnu, and dumb, that provide various implementations of
    DBM functionality, which you normally access only via the these top-level functions.
    Third-party packages can install further implementation modules in dbm.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这两个顶级函数外，dbm包还包含特定模块，如ndbm、gnu和dumb，提供各种DBM功能的实现，通常你只通过这些顶级函数访问。第三方包可以在dbm中安装更多的实现模块。
- en: 'The only implementation module of the dbm package that’s guaranteed to exist
    on all platforms is dumb. dumb has minimal DBM functionality and mediocre performance;
    its only advantage is that you can use it anywhere, since dumb does not rely on
    any library. You don’t normally **import** dbm.dumb: rather, **import** dbm, and
    let dbm.open supply the best DBM module available, defaulting to dumb if no better
    submodule is available in the current Python installation. The only case in which
    you import dumb directly is the rare one in which you need to create a DBM-like
    file that must be readable in any Python installation. The dumb module supplies
    an open function polymorphic to dbm’s.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: DBM 包唯一保证在所有平台上存在的实现模块是 dumb。dumb 提供了最小的 DBM 功能和一般性能；其唯一优点是您可以在任何地方使用，因为 dumb
    不依赖于任何库。通常您不会直接 **import** dbm.dumb：而是 **import** dbm，让 dbm.open 在当前 Python 安装中提供最好的可用
    DBM 模块，如果没有更好的子模块，则默认使用 dumb。唯一需要直接导入 dumb 的情况是在需要创建一个在任何 Python 安装中都可读的类似 DBM
    的文件时。dumb 模块提供了一个 open 函数，与 dbm 的 open 函数多态。
- en: Examples of DBM-Like File Use
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DBM-Like 文件的使用示例
- en: 'DBM’s keyed access is suitable when your program needs to record persistently
    the equivalent of a Python dictionary, with strings as both keys and values. For
    example, suppose you need to analyze several text files, whose names are given
    as your program’s arguments, and record where each word appears in those files.
    In this case, the keys are words and, therefore, intrinsically strings. The data
    you need to record for each word is a list of (*filename*, *linenumber*) pairs.
    However, you can encode the data as a string in several ways—for example, by exploiting
    the fact that the path separator string, os.pathsep (covered in [“Path-string
    attributes of the os module”](ch11.xhtml#path_string_attributes_of_the_os_module)),
    does not normally appear in filenames. (More general approaches to the issue of
    encoding data as strings were covered in the opening section of this chapter,
    with the same example.) With this simplification, a program to record word positions
    in files might be as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: DBM 的键控访问适合在程序需要持久记录类似 Python 字典的等效内容时使用，其中键和值都是字符串。例如，假设您需要分析几个文本文件，这些文件名是作为程序参数给出的，并记录每个单词在这些文件中出现的位置。在这种情况下，键是单词，因此本质上是字符串。您需要记录的每个单词的数据是一个
    (*filename*, *linenumber*) 对的列表。然而，您可以通过几种方法将数据编码为字符串，例如利用路径分隔符字符串 `os.pathsep`（在[“os
    模块的路径字符串属性”](ch11.xhtml#path_string_attributes_of_the_os_module)中介绍），因为该字符串通常不会出现在文件名中。（关于将数据编码为字符串的更一般方法在本章开头的部分有介绍，使用了相同的例子。）在这种简化情况下，编写一个记录文件中单词位置的程序可能如下所示：
- en: '[PRE11]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can read back the data stored to the DBM-like file *indexfile* in several
    ways. The following example accepts words as command-line arguments and prints
    the lines where the requested words appear:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过几种方式读取存储在类似 DBM 文件 *indexfile* 中的数据。下面的示例接受单词作为命令行参数，并打印请求单词出现的行：
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The Python Database API (DBAPI)
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 数据库 API（DBAPI）
- en: As we mentioned earlier, the Python standard library does not come with an RDBMS
    interface (except for sqlite3, covered in [“SQLite”](#sqlite), which is a rich
    implementation, not just an interface). Many third-party modules let your Python
    programs access specific DBs. Such modules mostly follow the Python Database API
    2.0 standard, aka the DBAPI, as specified in [PEP 249](https://oreil.ly/-yhzm).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，Python 标准库并不附带关系数据库管理系统接口（除了 sqlite3，在[“SQLite”](#sqlite)中介绍的，它是一个丰富的实现，而不仅仅是接口）。许多第三方模块允许您的
    Python 程序访问特定的数据库。这些模块大多遵循 Python 数据库 API 2.0 标准，也称为 DBAPI，如 [PEP 249](https://oreil.ly/-yhzm)
    中所述。
- en: After importing any DBAPI-compliant module, you can call the module’s connect
    function with DB-specific parameters. connect returns *x*, an instance of Connection,
    which represents a connection to the DB. *x* supplies commit and rollback methods
    to deal with transactions, a close method to call as soon as you’re done with
    the DB, and a cursor method to return *c*, an instance of Cursor. *c* supplies
    the methods and attributes used for DB operations. A DBAPI-compliant module also
    supplies exception classes, descriptive attributes, factory functions, and type-description
    attributes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 导入任何符合 DBAPI 标准的模块后，您可以使用特定于 DB 的参数调用模块的 connect 函数。connect 返回 *x*，Connection
    的一个实例，表示与 DB 的连接。*x* 提供 commit 和 rollback 方法来处理事务，提供一个 close 方法，在您完成 DB 操作后调用，以及一个
    cursor 方法来返回 *c*，Cursor 的一个实例。*c* 提供了用于 DB 操作的方法和属性。符合 DBAPI 标准的模块还提供了异常类、描述性属性、工厂函数和类型描述属性。
- en: Exception Classes
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常类
- en: 'A DBAPI-compliant module supplies the exception classes Warning, Error, and
    several subclasses of Error. Warning indicates anomalies such as data truncation
    on insertion. Error’s subclasses indicate various kinds of errors that your program
    can encounter when dealing with the DB and the DBAPI-compliant module that interfaces
    to it. Generally, your code uses a statement of the form:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 符合 DBAPI 标准的模块提供了异常类 Warning、Error 和 Error 的几个子类。Warning 指示插入时的数据截断等异常。Error
    的子类指示您的程序在处理与 DB 和与之接口的符合 DBAPI 标准的模块时可能遇到的各种错误。通常，您的代码使用以下形式的语句：
- en: '[PRE13]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: to trap all DB-related errors that you need to handle without terminating.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以捕获您需要处理而不终止的所有与 DB 相关的错误。
- en: Thread Safety
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程安全
- en: When a DBAPI-compliant module has a threadsafety attribute greater than 0, the
    module is asserting some level of thread safety for DB interfacing. Rather than
    relying on this, it’s usually safer, and always more portable, to ensure that
    a single thread has exclusive access to any given external resource, such as a
    DB, as outlined in [“Threaded Program Architecture”](ch15.xhtml#threaded_program_architecture).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当 DBAPI 兼容的模块具有大于 0 的 threadsafety 属性时，该模块在 DB 接口中断言了某种程度的线程安全性。与依赖于此不同，通常更安全，且始终更可移植，要确保单个线程对任何给定的外部资源（如
    DB）具有独占访问权，如 [“线程化程序架构”](ch15.xhtml#threaded_program_architecture) 中所述。
- en: Parameter Style
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数样式
- en: 'A DBAPI-compliant module has an attribute called paramstyle to identify the
    style of markers used as placeholders for parameters. Insert such markers in SQL
    statement strings that you pass to methods of Cursor instances, such as the method
    execute, to use runtime-determined parameter values. Say, for example, that you
    need to fetch the rows of DB table *ATABLE* where field *AFIELD* equals the current
    value of Python variable *x*. Assuming the cursor instance is named *c*, you *could*
    theoretically (but very ill-advisedly!) perform this task with Python’s string
    formatting:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 符合 DBAPI 标准的模块有一个称为 paramstyle 的属性，用于识别用作参数占位符的标记样式。在传递给 Cursor 实例方法（如 execute
    方法）的 SQL 语句字符串中插入这些标记，以使用运行时确定的参数值。举个例子，假设您需要获取字段 *AFIELD* 等于 Python 变量 *x* 当前值的
    DB 表 *ATABLE* 的行。假设光标实例命名为 *c*，您*理论上*（但非常不建议！）可以使用 Python 的字符串格式化执行此任务：
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Avoid SQL Query String Formatting: Use Parameter Substitution'
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免使用 SQL 查询字符串格式化：使用参数替换
- en: String formatting is *not* the recommended approach. It generates a different
    string for each value of *x*, requiring statements to be parsed and prepared anew
    each time; it also opens up the possibility of security weaknesses, such as [SQL
    injection](https://oreil.ly/hpUlv) vulnerabilities. With parameter substitution,
    you pass to execute a single statement string, with a placeholder instead of the
    parameter value. This lets execute parse and prepare the statement just once,
    for better performance; more importantly, parameter substitution improves solidity
    and security, hampering SQL injection attacks.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串格式化*不*是推荐的方法。它为每个 *x* 的值生成不同的字符串，每次都需要解析和准备语句；它还存在安全弱点的可能性，如 [SQL 注入](https://oreil.ly/hpUlv)
    漏洞。使用参数替换，您将传递一个具有占位符而不是参数值的单个语句字符串给 execute。这样一来，execute 只需解析和准备语句一次，以获得更好的性能；更重要的是，参数替换提高了稳固性和安全性，阻碍了
    SQL 注入攻击。
- en: 'For example, when a module’s paramstyle attribute (described next) is ''qmark'',
    you could express the preceding query as:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当模块的 paramstyle 属性（下文描述）为 'qmark' 时，您可以将前面的查询表示为：
- en: '[PRE15]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The read-only string attribute paramstyle tells your program how it should use
    parameter substitution with that module. The possible values of paramstyle are
    shown in [Table 12-8](#possible_values_of_the_paramstyle_attri).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 只读字符串属性 paramstyle 告诉您的程序如何使用该模块进行参数替换。paramstyle 的可能值如 [表 12-8](#possible_values_of_the_paramstyle_attri)
    中所示。
- en: Table 12-8\. Possible values of the paramstyle attribute
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-8\. paramstyle 属性的可能值
- en: '| format | The marker is %s, as in old-style string formatting (always with
    s: never use other type indicator letters, whatever the data’s type). A query
    looks like:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '| format | 标记是 %s，就像旧式字符串格式化一样（始终使用 s：不要使用其他类型指示符字母，无论数据的类型是什么）。一个查询看起来像：'
- en: '[PRE16]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| named | The marker is :*name*, and parameters are named. A query looks like:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '| named | 标记是：*name*，参数是命名的。一个查询看起来像：'
- en: '[PRE17]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| numeric | The marker is :n, giving the parameter’s number, 1 and up. A query
    looks like:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '| numeric | 标记是：n，给出参数的编号，从 1 开始。一个查询看起来像：'
- en: '[PRE18]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| pyformat | The marker is %(*name*)s, and parameters are named. Always use
    s: never use other type indicator letters, whatever the data’s type. A query looks
    like:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '| pyformat | 标记为 %(*name*)s，参数带有命名。始终使用 s：永不使用其他类型指示符，无论数据类型如何。查询的样子是：'
- en: '[PRE19]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| qmark | The marker is ?. A query looks like:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '| qmark | 标记为 ?。查询的样子是：'
- en: '[PRE20]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: When parameters are named (i.e., when paramstyle is 'pyformat' or 'named'),
    the second argument of the execute method is a mapping. Otherwise, the second
    argument is a sequence.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当参数被命名时（即 paramstyle 是 'pyformat' 或 'named'），execute 方法的第二个参数是一个映射。否则，第二个参数是一个序列。
- en: format and pyformat Only Accept Type Indicator s
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: format 和 pyformat 只接受类型指示符 s
- en: The *only* valid type indicator letter for format or pyformat is s; neither
    accepts any other type indicator—for example, never use %d or %(*name*)d. Use
    %s or %(*name*)s for all parameter substitutions, regardless of the type of the
    data.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 格式或 pyformat 的*唯一*有效类型指示符是 s；不接受任何其他类型指示符——例如，永远不要使用 %d 或 %(*name*)d。无论数据类型如何，都要使用
    %s 或 %(*name*)s 进行所有参数替换。
- en: Factory Functions
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂函数
- en: 'Parameters passed to the DB via placeholders must typically be of the right
    type: this means Python numbers (integers or floating-point values), strings (bytes
    or Unicode), and **None** to represent SQL NULL. There is no type universally
    used to represent dates, times, and binary large objects (BLOBs). A DBAPI-compliant
    module supplies factory functions to build such objects. The types used for this
    purpose by most DBAPI-compliant modules are those supplied by the datetime module
    (covered in [Chapter 13](ch13.xhtml#time_operations)), and strings or buffer types
    for BLOBs. The factory functions specified by the DBAPI are listed in [Table 12-9](#dbapi_factory_functions).
    (The *FromTicks methods take an integer timestamp *s* representing the number
    of seconds since the epoch of module time, covered in [Chapter 13](ch13.xhtml#time_operations).)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过占位符传递给数据库的参数通常必须是正确的类型：这意味着 Python 数字（整数或浮点数值）、字符串（字节或 Unicode）以及**None**表示
    SQL NULL。没有普遍用于表示日期、时间和二进制大对象（BLOBs）的类型。DBAPI 兼容模块提供工厂函数来构建这些对象。大多数 DBAPI 兼容模块用于此目的的类型由
    datetime 模块提供（在[第 13 章](ch13.xhtml#time_operations)中详述），并且用于 BLOBs 的类型为字符串或缓冲区类型。DBAPI
    指定的工厂函数列在[表 12-9](#dbapi_factory_functions)中。（*FromTicks 方法接受整数时间戳 *s*，表示自模块 time
    纪元以来的秒数，在[第 13 章](ch13.xhtml#time_operations)中详述。）
- en: Table 12-9\. DBAPI factory functions
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-9\. DBAPI 工厂函数
- en: '| Binary | Binary(*string*) Returns an object representing the given *string*
    of bytes as a BLOB. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 二进制 | Binary(*string*) 返回表示给定字节*string*的对象作为 BLOB。 |'
- en: '| Date | Date(*year*, *month*, *day*) Returns an object representing the specified
    date. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 日期 | Date(*year*, *month*, *day*) 返回表示指定日期的对象。 |'
- en: '| DateFromTicks | DateFromTicks(*s*) Returns an object representing the date
    for integer timestamp *s*. For example, DateFromTicks(time.time()) means “today.”
    |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| DateFromTicks | DateFromTicks(*s*) 返回表示整数时间戳 *s* 的日期对象。例如，DateFromTicks(time.time())
    表示“今天”。 |'
- en: '| Time | Time(*hour*, *minute*, *second*) Returns an object representing the
    specified time. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 时间 | Time(*hour*, *minute*, *second*) 返回表示指定时间的对象。 |'
- en: '| TimeFromTicks | TimeFromTicks(*s*) Returns an object representing the time
    for integer timestamp *s*. For example, TimeFromTicks(time.time()) means “the
    current time of day.” |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| TimeFromTicks | TimeFromTicks(*s*) 返回表示整数时间戳 *s* 的时间对象。例如，TimeFromTicks(time.time())
    表示“当前时间”。 |'
- en: '| Timestamp | Timestamp(*year*, *month*, *day*, *hour*, *minute*, *second*)
    Returns an object representing the specified date and time. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 时间戳 | Timestamp(*year*, *month*, *day*, *hour*, *minute*, *second*) 返回表示指定日期和时间的对象。
    |'
- en: '| TimestampFromTicks | TimestampFromTicks(*s*) Returns an object representing
    the date and time for integer timestamp *s*. For example, TimestampFromTicks(time.time())
    is the current date and time. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| TimestampFromTicks | TimestampFromTicks(*s*) 返回表示整数时间戳 *s* 的日期和时间对象。例如，TimestampFromTicks(time.time())
    是当前日期和时间。 |'
- en: Type Description Attributes
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型描述属性
- en: 'A Cursor instance’s description attribute describes the types and other characteristics
    of each column of the SELECT query you last executed on that cursor. Each column’s
    *type* (the second item of the tuple describing the column) equals one of the
    following attributes of the DBAPI-compliant module:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 游标实例的 description 属性描述了您在该游标上最后执行的每个 SELECT 查询的列的类型和其他特征。每列的*类型*（描述列的元组的第二项）等于
    DBAPI 兼容模块的以下属性之一：
- en: '| BINARY | Describes columns containing BLOBs |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 二进制 | 描述包含 BLOBs 的列 |'
- en: '| DATETIME | Describes columns containing dates, times, or both |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| DATETIME | 描述包含日期、时间或两者的列 |'
- en: '| NUMBER | Describes columns containing numbers of any kind |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| NUMBER | 描述包含任何类型数字的列 |'
- en: '| ROWID | Describes columns containing a row-identification number |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| ROWID | 描述包含行标识号的列 |'
- en: '| STRING | Describes columns containing text of any kind |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| STRING | 描述包含任何类型文本的列 |'
- en: A cursor’s description, and in particular each column’s type, is mostly useful
    for introspection about the DB your program is working with. Such introspection
    can help you write general modules and work with tables using different schemas,
    including schemas that may not be known at the time you are writing your code.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 cursor 的描述，尤其是每一列的类型，对于了解程序所使用的 DB 是非常有用的。这种内省可以帮助你编写通用的模块，并使用不同模式的表，包括在编写代码时可能不知道的模式。
- en: The connect Function
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: connect 函数
- en: 'A DBAPI-compliant module’s connect function accepts arguments that depend on
    the kind of DB and the specific module involved. The DBAPI standard recommends
    that connect accept named arguments. In particular, connect should at least accept
    optional arguments with the following names:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 DBAPI 兼容模块的 `connect` 函数接受依赖于 DB 类型和具体模块的参数。DBAPI 标准建议 `connect` 接受命名参数。特别是，`connect`
    至少应接受以下名称的可选参数：
- en: '| database | Name of the specific database to connect to |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| database | 要连接的具体数据库名称 |'
- en: '| dsn | Name of the data source to use for the connection |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| dsn | 用于连接的数据源名称 |'
- en: '| host | Hostname on which the database is running |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| host | 数据库运行的主机名 |'
- en: '| password | Password to use for the connection |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| password | 用于连接的密码 |'
- en: '| user | Username to use for the connection |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| user | 用于连接的用户名 |'
- en: Connection Objects
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Connection 对象
- en: A DBAPI-compliant module’s connect function returns an object *x* that is an
    instance of the class Connection. *x* supplies the methods listed in [Table 12-10](#methods_of_an_instance_x_of_class_conne).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 DBAPI 兼容模块的 `connect` 函数返回一个对象 *x*，它是 `Connection` 类的一个实例。 *x* 提供了 [Table 12-10](#methods_of_an_instance_x_of_class_conne)
    中列出的方法。
- en: Table 12-10\. Methods of an instance x of class Connection
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Table 12-10\. 类 Connection 的实例 x 的方法
- en: '| close | *x*.close() Terminates the DB connection and releases all related
    resources. Call close as soon as you’re done with the DB. Keeping DB connections
    open needlessly can be a serious resource drain on the system. |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| close | *x*.close() 终止 DB 连接并释放所有相关资源。在完成 DB 操作后立即调用 close。不必要地保持 DB 连接开启可能会严重消耗系统资源。'
- en: '| commit | *x*.commit() Commits the current transaction in the DB. If the DB
    does not support transactions, *x*.commit() is an innocuous no-op. |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| commit | *x*.commit() 提交当前的 DB 事务。如果 DB 不支持事务，则 *x*.commit() 不会有任何操作。'
- en: '| cursor | *x*.cursor() Returns a new instance of the class Cursor (covered
    in the following section). |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| cursor | *x*.cursor() 返回 `Cursor` 类的一个新实例（在下一节中介绍）。'
- en: '| rollback | *x*.rollback() Rolls back the current transaction in the DB. If
    the DB does not support transactions, *x*.rollback() raises an exception. The
    DBAPI recommends that, for DBs that do not support transactions, the class Connection
    supplies no rollback method, so that *x*.rollback() raises AttributeError: you
    can test whether transactions are supported with hasattr(*x*, ''rollback''). |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| rollback | *x*.rollback() 回滚当前的 DB 事务。如果 DB 不支持事务，则 *x*.rollback() 会引发异常。DBAPI
    建议，对于不支持事务的 DB，`Connection` 类不应提供回滚方法，因此 *x*.rollback() 会引发 AttributeError：你可以通过
    hasattr(*x*, ''rollback'') 测试是否支持事务。'
- en: Cursor Objects
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cursor 对象
- en: A Connection instance provides a cursor method that returns an object *c* that
    is an instance of the class Cursor. A SQL cursor represents the set of results
    of a query and lets you work with the records in that set, in sequence, one at
    a time. A cursor as modeled by the DBAPI is a richer concept, since it’s the only
    way your program executes SQL queries in the first place. On the other hand, a
    DBAPI cursor allows you only to advance in the sequence of results (some relational
    DBs, but not all, also provide higher-functionality cursors that are able to go
    backward as well as forward), and does not support the SQL clause WHERE CURRENT
    OF CURSOR. These limitations of DBAPI cursors enable DBAPI-compliant modules to
    provide DBAPI cursors even on RDBMSs that supply no real SQL cursors at all. An
    instance *c* of the class Cursor supplies many attributes and methods; the most
    frequently used ones are shown in [Table 12-11](#commonly_used_attributes_and_methods_of).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 连接实例提供了一个 cursor 方法，返回一个名为 *c* 的 Cursor 类实例对象。SQL 游标表示查询结果集，并允许您按顺序逐个处理该集合中的记录。由
    DBAPI 建模的游标是一个更丰富的概念，因为它是程序执行 SQL 查询的唯一方式。另一方面，DBAPI 游标只允许您在结果序列中前进（一些关系型数据库，但不是所有的，还提供更高功能的游标，可以前后移动），并且不支持
    SQL 子句 WHERE CURRENT OF CURSOR。DBAPI 游标的这些限制使得 DBAPI 兼容模块能够在根本不提供真正 SQL 游标的 RDBMS
    上提供 DBAPI 游标。类 Cursor 的实例 *c* 提供了许多属性和方法；最常用的属性和方法如 [Table 12-11](#commonly_used_attributes_and_methods_of)
    所示。 |
- en: Table 12-11\. Commonly used attributes and methods of an instance c of class
    Cursor
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-11\. 类 Cursor 的实例 *c* 的常用属性和方法
- en: '| close | *c*.close() Closes the cursor and releases all related resources.
    |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| close | *c*.close() 关闭游标并释放所有相关资源。 |'
- en: '| description | A read-only attribute that is a sequence of seven-item tuples,
    one per column in the last query executed: name, typecode, displaysize, internalsize,
    precision, scale,'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '| description | 只读属性，是一个由七项元组组成的序列，每项对应最后执行的查询中的一个列：名称、类型代码、显示大小、内部大小、精度、比例。'
- en: nullable
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 可为空
- en: '*c*.description is **None** if the last operation on *c* was not a SELECT query
    or returned no usable description of the columns involved. A cursor’s description
    is mostly useful for introspection about the DB your program is working with.
    Such introspection can help you write general modules that are able to work with
    tables using different schemas, including schemas that may not be fully known
    at the time you are writing your code. |'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*c*.description 如果最后对 *c* 的操作不是 SELECT 查询或返回的列描述不可用，则为 **None**。游标的描述主要用于关于程序正在使用的数据库的内省。这种内省可以帮助您编写通用模块，能够处理使用不同模式的表，包括编写代码时可能不完全了解的模式。
    |'
- en: '| execute | *c*.execute(*statement*, parameters=**None**) Executes a SQL *statement*
    string on the DB with the given parameters*.* parameters is a sequence when the
    module’s paramstyle is ''format'', ''numeric'', or ''qmark'', and a mapping when
    paramstyle is ''named'' or ''pyformat''. Some DBAPI modules require the sequences
    to be specifically tuples. |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| execute | *c*.execute(*statement*, parameters=**None**) 在给定参数的情况下，在 DB 上执行
    SQL *statement* 字符串。当模块的 paramstyle 为 ''format''、''numeric'' 或 ''qmark'' 时，parameters
    是一个序列；当 paramstyle 为 ''named'' 或 ''pyformat'' 时，parameters 是一个映射。某些 DBAPI 模块要求序列必须明确为元组。
    |'
- en: '| executemany | *c*.executemany(*statement*, **parameters*) Executes a SQL
    *statement* on the DB, once for each item of the given *parameters*. *parameters*
    is a sequence of sequences when the module’s paramstyle is ''format'', ''numeric'',
    or ''qmark'', and a sequence of mappings when paramstyle is ''named'' or ''pyformat''.
    For example, when paramstyle is ''qmark'', the statement:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '| executemany | *c*.executemany(*statement*, **parameters*) 对 DB 执行 SQL *statement*，对给定的
    *parameters* 中的每个项执行一次。当模块的 paramstyle 为 ''format''、''numeric'' 或 ''qmark'' 时，parameters
    是一个序列的序列；当 paramstyle 为 ''named'' 或 ''pyformat'' 时，parameters 是映射的序列。例如，当 paramstyle
    为 ''qmark'' 时，语句：'
- en: '[PRE21]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'is equivalent to—but faster than—the two statements:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于但比以下两个语句更快：
- en: '[PRE22]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| fetchall | c.fetchall() Returns all remaining rows from the last query as
    a sequence of tuples. Raises an exception if the last operation was not a SELECT.
    |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| fetchall | *c*.fetchall() 返回最后查询的所有剩余行作为元组序列。如果最后的操作不是 SELECT，则会引发异常。 |'
- en: '| fetchmany | c.fetchmany(*n*) Returns up to *n* remaining rows from the last
    query as a sequence of tuples. Raises an exception if the last operation was not
    a SELECT. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| fetchmany | *c*.fetchmany(*n*) 返回最后查询的最多 *n* 行作为元组序列。如果最后的操作不是 SELECT，则会引发异常。
    |'
- en: '| fetchone | c.fetchone() Returns the next row from the last query as a tuple.
    Raises an exception if the last operation was not a SELECT. |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| fetchone | c.fetchone() 将从上次查询中返回下一行作为元组。如果上次操作不是SELECT，则引发异常。 |'
- en: '| rowcount | A read-only attribute that specifies the number of rows fetched
    or affected by the last operation, or -1 if the module is unable to determine
    this value. |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| rowcount | 一个只读属性，指定了最后一个操作获取或影响的行数，如果模块无法确定这个值，则为 -1。 |'
- en: DBAPI-Compliant Modules
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DBAPI兼容模块
- en: Whatever relational DB you want to use, there’s at least one (often more than
    one) Python DBAPI-compliant module downloadable from the internet. There are so
    many DBs and modules, and the set of possibilities changes so constantly, that
    we couldn’t possibly list them all, nor (importantly) could we maintain the list
    over time. Rather, we recommend you start from the community-maintained [wiki
    page](https://oreil.ly/ubKe7), which has at least a fighting chance to be complete
    and up-to-date at any time.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你想使用哪种关系型数据库，至少有一个（通常是多个）Python DBAPI兼容模块可以从互联网上下载。有这么多的数据库和模块，可能性的集合如此不断变化，我们不可能列出所有的，也无法长期维护这个列表。因此，我们建议你从社区维护的
    [wiki 页面](https://oreil.ly/ubKe7) 开始，这个页面有可能在任何时候都是完整和最新的。
- en: 'What follows is therefore only a very short, time-specific list of a very few
    DBAPI-compliant modules that, at the time of writing, are very popular and interface
    to very popular open source DBs:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，接下来只是一个非常短暂且特定时间的，与撰写时非常流行且与非常流行的开源数据库接口的非常少量DBAPI兼容模块的列表：
- en: ODBC modules
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ODBC 模块
- en: Open Database Connectivity (ODBC) is a standard way to connect to many different
    DBs, including a few not supported by other DBAPI-compliant modules. For an ODBC-compliant
    DBAPI-compliant module with a liberal open source license, use [pyodbc](https://oreil.ly/MNAt9);
    for a commercially supported one, use [mxODBC](https://oreil.ly/hPUU0).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Open Database Connectivity (ODBC) 是连接许多不同的数据库的标准方法，包括一些其他DBAPI兼容模块不支持的数据库。对于具有自由开源许可的ODBC兼容DBAPI兼容模块，请使用
    [pyodbc](https://oreil.ly/MNAt9)；对于商业支持的模块，请使用 [mxODBC](https://oreil.ly/hPUU0)。
- en: MySQL modules
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 模块
- en: MySQL is a popular open source RDBMS, purchased by Oracle in 2010\. Oracle’s
    “official” DBAPI-compliant interface to it is [mysql-connector-python](https://oreil.ly/iWzpg).
    The MariaDB project also provides a DBAPI-compliant interface, [mariadb](https://oreil.ly/zmCLT),
    connecting to both MySQL and MariaDB (a GPL-licensed fork).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 是一个流行的开源关系型数据库管理系统，于2010年被Oracle收购。Oracle提供的“官方”DBAPI兼容接口是 [mysql-connector-python](https://oreil.ly/iWzpg)。MariaDB
    项目也提供了一个DBAPI兼容接口，[mariadb](https://oreil.ly/zmCLT)，连接到 MySQL 和 MariaDB（一个GPL许可的分支）。
- en: PostgreSQL modules
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 模块
- en: PostgreSQL is another popular open source RDBMS. A widely used DBAPI-compliant
    interface to it is [psycopg3](https://oreil.ly/pXc-t), a rationalized rewrite
    and extension of the hallowed [psycopg2](https://oreil.ly/gOTn7) package.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 是另一个流行的开源关系型数据库管理系统。它的一个广泛使用的DBAPI兼容接口是 [psycopg3](https://oreil.ly/pXc-t)，它是受欢迎的
    [psycopg2](https://oreil.ly/gOTn7) 包的合理化重写和扩展。
- en: SQLite
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQLite
- en: '[SQLite](http://www.sqlite.org) is a C-coded library that implements a relational
    DB within a single file, or even in memory for sufficiently small and transient
    cases. Python’s standard library supplies the package sqlite3, which is a DBAPI-compliant
    interface to SQLite.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLite](http://www.sqlite.org) 是一个用C编写的库，实现了一个关系型数据库，可以存储在单个文件中，甚至在内存中用于足够小和短暂的情况。Python的标准库提供了
    sqlite3 包，它是与 SQLite 兼容的DBAPI接口。'
- en: SQLite has rich advanced functionality, with many options you can choose; sqlite3
    offers access to much of that functionality, plus further possibilities to make
    interoperation between your Python code and the underlying DB smoother and more
    natural. We don’t have the space in this book to cover every nook and cranny of
    these two powerful software systems; instead, we focus on the subset of functions
    that are most commonly used and most useful. For a greater level of detail, including
    examples and tips on best practices, see the documentation for [SQLite](https://oreil.ly/-6LhJ)
    and [sqlite3](https://oreil.ly/S6VE1), and Jay Kreibich’s [*Using SQLite*](https://learning.oreilly.com/library/view/using-sqlite/9781449394592)
    (O’Reilly).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 具有丰富的高级功能，有许多选项可供选择；sqlite3 提供了访问这些功能的大部分能力，同时提供更多可能性，使得 Python 代码与底层数据库之间的交互更加平稳和自然。我们无法在本书中涵盖这两个强大软件系统的每一个细节；相反，我们专注于最常用和最有用的函数子集。要获取更详细的信息，包括示例和最佳实践建议，请参阅
    [SQLite](https://oreil.ly/-6LhJ) 和 [sqlite3](https://oreil.ly/S6VE1) 的文档，以及 Jay
    Kreibich 的 [*Using SQLite*](https://learning.oreilly.com/library/view/using-sqlite/9781449394592)（O’Reilly）。
- en: Among others, the sqlite3 package supplies the functions in [Table 12-12](#some_useful_functions_of_the_sqlitethre).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: sqlite3 包还提供了 [表 12-12](#some_useful_functions_of_the_sqlitethre) 中的函数，以及其他函数。
- en: Table 12-12\. Some useful functions of the sqlite3 module
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12-12\. sqlite3 模块的一些有用函数
- en: '| connect | connect(*filepath*, timeout=5.0, detect_types=0, isolation_level='''',
    check_same_thread=**True**, factory=Connection, cached_statements=100, uri=**False**)
    Connects to the SQLite DB in the file named by *filepath* (creating it if necessary)
    and returns an instance of the Connection class (or subclass thereof passed as
    factory). To create an in-memory DB, pass '':memory:'' as the first argument,
    *filepath*.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '| connect | connect(*filepath*, timeout=5.0, detect_types=0, isolation_level='''',
    check_same_thread=**True**, factory=Connection, cached_statements=100, uri=**False**)
    连接到名为 *filepath* 的 SQLite 数据库文件（如果需要则创建），并返回 Connection 类的实例（或传递的子类）。要创建内存中的数据库，请将
    '':memory:'' 作为第一个参数传递给 *filepath*。'
- en: If **True**, the uri argument activates SQLite’s [URI functionality](https://oreil.ly/S2h8r),
    allowing a few extra options to be passed along with the filepath via the *filepath*
    argument.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 **True**，uri 参数激活 SQLite 的 [URI 功能](https://oreil.ly/S2h8r)，允许通过 *filepath*
    参数一起传递一些额外的选项。
- en: timeout is the number of seconds to wait before raising an exception if another
    connection is keeping the DB locked in a transaction.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: timeout 是在事务中有另一个连接锁定数据库时等待抛出异常之前的秒数。
- en: 'sqlite3 directly supports only the following SQLite native types, converting
    them to the indicated Python types:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: sqlite3 直接支持以下 SQLite 原生类型，将其转换为相应的 Python 类型：
- en: 'BLOB: Converted to bytes'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BLOB：转换为字节
- en: 'INTEGER: Converted to int'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: INTEGER：转换为整数
- en: 'NULL: Converted to **None**'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NULL：转换为 **None**
- en: 'REAL: Converted to float'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REAL：转换为浮点数
- en: 'TEXT: Depends on the text_factory attribute of the Connection instance, covered
    in [Table 12-13](#additional_methods_and_attributes_of_th); by default, str'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TEXT：取决于 Connection 实例的 text_factory 属性，在 [表 12-13](#additional_methods_and_attributes_of_th)
    中有所涉及；默认为 str
- en: Any other type name is treated as TEXT unless properly detected and passed through
    a converter registered with the function register_converter, covered later in
    this table. To allow type name detection, pass as detect_types either of the constants
    PARSE_COLNAMES or PARSE_DECLTYPES, supplied by the sqlite3 package (or both, joining
    them with the &#124; bitwise OR operator).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 除此以外的任何类型名称被视为 TEXT，除非经过适当的检测并通过函数 register_converter 注册的转换器传递。为了允许类型名称检测，可以传递
    detect_types 参数，该参数可以是 sqlite3 包提供的 PARSE_COLNAMES 或 PARSE_DECLTYPES 常量（或两者都使用，通过
    &#124; 位 OR 运算符连接）。
- en: When you pass detect_types=sqlite3.PARSE_COLNAMES, the type name is taken from
    the name of the column in the SQL SELECT statement that retrieves the column;
    for example, a column retrieved as *foo* AS [*foo* CHAR(10)] has a type name of
    CHAR.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当你传递 detect_types=sqlite3.PARSE_COLNAMES 时，类型名称取自于 SQL SELECT 语句中检索列的列名；例如，检索为
    *foo* AS [*foo* CHAR(10)] 的列具有类型名称 CHAR。
- en: When you pass detect_types=sqlite3.PARSE_DECLTYPES, the type name is taken from
    the declaration of the column in the original CREATE TABLE or ALTER TABLE SQL
    statement that added the column; for example, a column declared as *foo* CHAR(10)
    has a type name of CHAR.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当你传递 detect_types=sqlite3.PARSE_DECLTYPES 时，类型名称取自于原始 CREATE TABLE 或 ALTER TABLE
    SQL 语句中添加列的声明；例如，声明为 *foo* CHAR(10) 的列具有类型名称 CHAR。
- en: When you pass detect_types=sqlite3.PARSE_COLNAMES &#124; sqlite3.PARSE_DECLTYPES,
    both mechanisms are used, with precedence given to the column name when it has
    at least two words (the second word gives the type name in this case), falling
    back to the type that was given for that column at declaration (the first word
    of the declaration type gives the type name in this case).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当你传递 detect_types=sqlite3.PARSE_COLNAMES &#124; sqlite3.PARSE_DECLTYPES 时，两种机制都会被使用，优先使用列名（当列名至少有两个单词时，第二个单词在这种情况下给出类型名），如果没有则回退到声明时给定的类型（在这种情况下，声明类型的第一个单词给出类型名）。
- en: isolation_level lets you exercise some control over how SQLite processes transactions;
    it can be '' (the default), **None** (to use *autocommit* mode), or one of the
    three strings ‘DEFERRED’, 'EXCLUSIVE', or 'IMMEDIATE'. The [SQLite online docs](https://oreil.ly/IuKIz)
    cover the details of [types of transactions](https://oreil.ly/AnFtn) and their
    relation to the various levels of [file locking](https://oreil.ly/cpWkt) that
    SQLite intrinsically performs. |
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: isolation_level 允许你在 SQLite 处理事务时行使一些控制；它可以是 ''（默认值）、**None**（使用 *autocommit*
    模式）或三个字符串之一：'DEFERRED'、'EXCLUSIVE' 或 'IMMEDIATE'。[SQLite 在线文档](https://oreil.ly/IuKIz)详细介绍了
    [事务类型](https://oreil.ly/AnFtn) 及其与 SQLite 固有执行的各种 [文件锁定](https://oreil.ly/cpWkt)
    的关系。
- en: '| connect *(cont.)* | By default, a connection object can be used only in the
    Python thread that created it, to avoid accidents that could easily corrupt the
    DB due to minor bugs in your program (minor bugs are, alas, common in multithreaded
    programming). If you’re entirely confident about your threads’ use of locks and
    other synchronization mechanisms, and you need to reuse a connection object among
    multiple threads, you can pass check_same_thread=**False**. sqlite3 will then
    perform no checks, trusting your assertion that you know what you’re doing and
    that your multithreading architecture is 100% bug-free—good luck! cached_statements
    is the number of SQL statements that sqlite3 caches in a parsed and prepared state,
    to avoid the overhead of parsing them repeatedly. You can pass in a value lower
    than the default 100 to save a little memory, or a larger one if your application
    uses a dazzling variety of SQL statements. |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 连接 *(续)* | 默认情况下，连接对象只能在创建它的Python线程中使用，以避免因程序中的轻微错误（多线程编程中常见的不幸问题）而导致数据库损坏。如果你对线程在使用锁和其他同步机制方面完全自信，并且需要在多个线程之间重用连接对象，你可以传递
    check_same_thread=**False**。sqlite3 将不再执行任何检查，相信你知道自己在做什么，并且你的多线程架构没有任何缺陷——祝你好运！cached_statements
    是 sqlite3 缓存的 SQL 语句数量，以解析和准备的状态保存，以避免重复解析它们所带来的开销。你可以传递一个低于默认值 100 的值以节省一些内存，或者如果你的应用程序使用了多种多样的
    SQL 语句，可以传递一个更大的值。 |'
- en: '| r⁠e⁠g⁠i⁠s⁠t⁠e⁠r⁠_​a⁠d⁠a⁠p⁠t⁠e⁠r | register_adapter(*type*, *callable*) Registers
    *callable* as the *adapter* from any object of Python type *type* to a corresponding
    value of one of the few Python types that sqlite3 handles directly: int, float,
    str, and bytes. *callable* must accept a single argument, the value to adapt,
    and return a value of a type that sqlite3 handles directly. |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| r⁠e⁠g⁠i⁠s⁠t⁠e⁠r⁠_​a⁠d⁠a⁠p⁠t⁠e⁠r | register_adapter(*type*, *callable*) 将
    *callable* 注册为从任何 Python 类型 *type* 的对象到 sqlite3 直接处理的几种 Python 类型之一（int、float、str
    和 bytes）的相应值的 *adapter*。*callable* 必须接受一个参数，即要适配的值，并返回一个 sqlite3 直接处理的类型的值。 |'
- en: '| r⁠e⁠g⁠i⁠s⁠t⁠e⁠r⁠_​c⁠o⁠n⁠v⁠e⁠r⁠t⁠e⁠r | register_converter(*typename*, *callable*)
    Registers *callable* as the *converter* from any value identified in SQL as being
    of type *typename* (see the description of the connect function’s detect_types
    parameter for an explanation of how the type name is identified) to a corresponding
    Python object. *callable* must accept a single argument, the string form of the
    value obtained from SQL, and return the corresponding Python object. The *typename*
    matching is case-sensitive. |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| r⁠e⁠g⁠i⁠s⁠t⁠e⁠r⁠_​c⁠o⁠n⁠v⁠e⁠r⁠t⁠e⁠r | register_converter(*typename*, *callable*)
    将 *callable* 注册为从 SQL 中标识为某种 *typename* 类型的值（请参阅 connect 函数的 detect_types 参数的描述，了解类型名是如何确定的）到相应
    Python 对象的 *converter*。*callable* 必须接受一个参数，即从 SQL 获取的值的字符串形式，并返回相应的 Python 对象。*typename*
    的匹配区分大小写。 |'
- en: In addition, sqlite3 supplies the classes Connection, Cursor, and Row. Each
    can be subclassed for further customization; however, this is an advanced topic
    that we do not cover further in this book. The Cursor class is a standard DBAPI
    cursor class, except for an extra convenience method, executescript, accepting
    a single argument, a string of multiple statements separated by ; (no parameters).
    The other two classes are covered in the following sections.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，sqlite3 还提供了 Connection、Cursor 和 Row 类。每个类都可以进一步定制为子类；但这是一个我们在本书中不再详细讨论的高级主题。Cursor
    类是标准的 DBAPI 游标类，除了一个额外的便利方法 executescript，接受一个参数，即由多条语句以 ; 分隔的字符串（无参数）。其他两个类将在接下来的章节中介绍。
- en: The sqlite3.Connection class
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: sqlite3.Connection 类
- en: In addition to the methods common to all Connection classes of DBAPI-compliant
    modules, covered in [“Connection Objects”](#connection_objects), sqlite3.Connection
    supplies the methods and attributes in [Table 12-13](#additional_methods_and_attributes_of_th).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有符合 DBAPI 标准模块 Connection 类通用的方法外，详情请参见 [“Connection Objects”](#connection_objects)，sqlite3.Connection
    还提供了 [Table 12-13](#additional_methods_and_attributes_of_th) 中的方法和属性。
- en: Table 12-13\. Additional methods and attributes of the sqlite3.Connection class
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Table 12-13\. sqlite3.Connection 类的附加方法和属性
- en: '| crea⁠t⁠e⁠_​a⁠g⁠g⁠regate | create_aggregate(*name*, *num_params*, *aggregate_class*)
    *aggregate_class* must be a class supplying two instance methods: step, accepting
    exactly *num_param* arguments, and *finalize*, accepting no arguments and returning
    the final result of the aggregate, a value of a type natively supported by sqlite3.
    The aggregate function can be used in SQL statements by the given *name*. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| crea⁠t⁠e⁠_​a⁠g⁠g⁠r⁠e⁠g⁠a⁠t⁠e | create_aggregate(*name*, *num_params*, *aggregate_class*)
    *aggregate_class* 必须是一个类，提供两个实例方法：step，接受确切 *num_param* 个参数；finalize，不接受参数，并返回聚合的最终结果，即
    sqlite3 原生支持的类型的值。这个聚合函数可以通过给定的 *name* 在 SQL 语句中使用。 |'
- en: '| c⁠r⁠e⁠a⁠t⁠e⁠_​c⁠o⁠l⁠l⁠a⁠t⁠i⁠o⁠n | crea⁠t⁠e⁠_​c⁠o⁠l⁠lation(*name*, *callable*)
    *callable* must accept two bytestring arguments (encoded in ''utf-8'') and return
    -1 if the first must be considered “less than” the second, 1 if it must be considered
    “greater than,” and 0 if it must be considered “equal,” for the purposes of this
    comparison. Such a collation can be named by the given *name* in a SQL ORDER BY
    clause in a SELECT statement. |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| c⁠r⁠e⁠a⁠t⁠e⁠_​c⁠o⁠l⁠l⁠a⁠t⁠i⁠o⁠n | crea⁠t⁠e⁠_​c⁠o⁠l⁠l⁠a⁠t⁠i⁠o⁠n(*name*, *callable*)
    *callable* 必须接受两个字节字符串参数（编码为 ''utf-8''），如果第一个参数应被视为“小于”第二个参数，则返回 -1；如果应被视为“大于”，则返回
    1；如果应被视为“等于”，则返回 0。此类排序规则可以在 SQL SELECT 语句的 ORDER BY 子句中以 *name* 命名使用。 |'
- en: '| crea⁠t⁠e⁠_​f⁠u⁠n⁠ction | create_function(*name*, *num_params*, *func*) *func*
    must accept exactly *num_params* arguments and return a value of a type natively
    supported by sqlite3; such a user-defined function can be used in SQL statements
    by the given *name*. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| crea⁠t⁠e⁠_​f⁠u⁠n⁠c⁠t⁠i⁠o⁠n | create_function(*name*, *num_params*, *func*)
    *func* 必须接受确切 *num_params* 个参数，并返回 sqlite3 原生支持的类型的值；这样的用户定义函数可以通过给定的 *name* 在
    SQL 语句中使用。 |'
- en: '| interrupt | interrupt() Call from any other thread to abort all queries executing
    on this connection (raising an exception in the thread using the connection).
    |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| interrupt | interrupt() 可以从任何其他线程调用，以中止在此连接上执行的所有查询（在使用连接的线程中引发异常）。 |'
- en: '| isolati⁠o⁠n⁠_​l⁠e⁠v⁠el | A read-only attribute that’s the value given as
    the isolation_level parameter to the connect function. |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| isolati⁠o⁠n⁠_​l⁠e⁠v⁠e⁠l | 一个只读属性，其值为连接函数的 isolation_level 参数提供的值。 |'
- en: '| iterdump | iterdump() Returns an iterator that yields strings: the SQL statements
    that build the current DB from scratch, including both the schema and contents.
    Useful, for example, to persist an in-memory DB to disk for future reuse. |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| iterdump | iterdump() 返回一个迭代器，生成字符串：构建当前数据库的 SQL 语句，包括模式和内容。例如，可用于将内存中的数据库持久化到磁盘以供将来重用。
    |'
- en: '| row_factory | A callable that accepts the cursor and the original row as
    a tuple, and returns an object to use as the real result row. A common idiom is
    *x*.row_factory=sqlite3.Row, to use the highly optimized Row class covered in
    the following section, supplying both index-based and case-insensitive name-based
    access to columns with negligible overhead. |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| row_factory | 一个可调用对象，接受游标和原始行作为元组，并返回用作真实结果行的对象。一个常见的惯用法是 *x*.row_factory=sqlite3.Row，使用在下一节详细介绍的高度优化的
    Row 类，提供基于索引和不区分大小写的名称访问列，几乎没有额外开销。 |'
- en: '| text_factory | A callable that accepts a single bytestring parameter and
    returns the object to use for that TEXT column value—by default, str, but you
    can set it to any similar callable. |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| text_factory | 一个接受单一字节字符串参数并返回用于 TEXT 列值的对象的可调用函数——默认为 str，但你可以设置为任何类似的可调用函数。
    |'
- en: '| total_changes | The total number of rows that have been modified, inserted,
    or deleted since the connection was created. |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| total_changes | 自连接创建以来已修改、插入或删除的总行数。 |'
- en: A Connection object can also be used as a context manager, to automatically
    commit database updates or roll back if an exception occurs; however, you will
    need to call Connection.close() explicitly to close the connection in this case.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 连接对象还可以作为上下文管理器使用，以自动提交数据库更新或在发生异常时回滚；然而，在这种情况下，你需要显式调用 Connection.close() 来关闭连接。
- en: The sqlite3.Row class
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: sqlite3.Row 类
- en: sqlite3 also supplies the class Row. A Row object is mostly like a tuple but
    also supplies the method keys, returning a list of column names, and supports
    indexing by a column name as an alternative to indexing by column number.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: sqlite3 还提供了 Row 类。Row 对象大部分类似于元组，但还提供了 keys 方法，返回列名列表，并支持通过列名而不是列编号进行索引。
- en: A sqlite3 example
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个 sqlite3 示例
- en: 'The following example handles the same task as the examples shown earlier in
    the chapter, but uses sqlite3 for persistence, without creating the index in memory:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例处理与本章早些时候展示的示例相同的任务，但使用 sqlite3 进行持久化，而不是在内存中创建索引：
- en: '[PRE23]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can then use sqlite3 to read back the data stored in the DB file *database.db*,
    as shown in the following example:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用 sqlite3 读取存储在 DB 文件 *database.db* 中的数据，如下例所示：
- en: '[PRE24]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ^([1](ch12.xhtml#ch01fn106-marker)) In fact, “CSV” is something of a misnomer,
    since some dialects use tabs or other characters rather than commas as the field
    separator. It might be easier to think of them as “delimiter-separated values.”
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch12.xhtml#ch01fn106-marker)) 实际上，“CSV” 有点名不副实，因为一些方言使用制表符或其他字符作为字段分隔符，而不是逗号。更容易将它们视为“分隔符分隔的值”。
- en: ^([2](ch12.xhtml#ch01fn109-marker)) Consider the third-party package [dill](https://oreil.ly/mU15t)
    if you need to extend pickle in this and other aspects.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch12.xhtml#ch01fn109-marker)) 如果你需要在此及其他方面扩展 pickle，请考虑第三方包 [dill](https://oreil.ly/mU15t)。
- en: ^([3](ch12.xhtml#idm44924511774592-marker)) dbm keys and values must be bytes;
    shelve will accept bytes or str and encode the strings transparently.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch12.xhtml#idm44924511774592-marker)) dbm 的键和值必须是字节；shelve 将接受字节或 str，并且会透明地对字符串进行编码。
