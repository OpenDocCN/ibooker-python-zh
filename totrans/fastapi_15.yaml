- en: Chapter 12\. Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 12 章。测试
- en: A QA engineer walks into a bar. Orders a beer. Orders 0 beers. Orders 99999999999
    beers. Orders a lizard. Orders –1 beers. Orders a ueicbksjdhd.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个 QA 工程师走进一家酒吧。点了一杯啤酒。点了 0 杯啤酒。点了 99999999999 杯啤酒。点了一只蜥蜴。点了 -1 杯啤酒。点了一个 ueicbksjdhd。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: First real customer walks in and asks where the bathroom is. The bar bursts
    into flames, killing everyone.
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 第一个真正的客户走进来问洗手间在哪里。酒吧突然起火，所有人都死了。
- en: ''
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Brenan Keller, Twitter
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Brenan Keller，Twitter
- en: Preview
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预览
- en: 'This chapter discusses the kinds of testing that you would perform on a FastAPI
    site: *unit*, *integration*, and *full*. It features *pytest* and automated test
    development.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了在 FastAPI 站点上进行的各种测试类型：*单元*，*集成* 和 *完整*。它以 *pytest* 和自动化测试开发为特色。
- en: Web API Testing
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web API 测试
- en: 'You’ve already seen several manual API testing tools as endpoints have been
    added:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到几个手动 API 测试工具，因为已经添加了端点：
- en: HTTPie
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTPie
- en: Requests
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求
- en: HTTPX
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTPX
- en: The web browser
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web 浏览器
- en: 'And many more testing tools are available:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他测试工具可用：
- en: '[Curl](https://curl.se) is very well known, although in this book I’ve used
    HTTPie instead for its simpler syntax.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Curl](https://curl.se) 是非常有名的，尽管在本书中我使用了更简单语法的 HTTPie。'
- en: '[Httpbin](http://httpbin.org), written by the author of Requests, is a free
    test server that provides many views into your HTTP request.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Httpbin](http://httpbin.org)，由 Requests 的作者编写，是一个提供许多视图来查看您的 HTTP 请求的免费测试服务器。'
- en: '[Postman](https://www.postman.com) is a full API test platform.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Postman](https://www.postman.com) 是一个完整的 API 测试平台。'
- en: '[Chrome DevTools](https://oreil.ly/eUK_R) is a rich toolset, part of the Chrome
    browser.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Chrome DevTools](https://oreil.ly/eUK_R) 是 Chrome 浏览器的一个丰富工具集。'
- en: These can all be used for full (end-to-end) tests, such as those you’ve seen
    in the previous chapters. Those manual tests have been useful for quickly verifying
    code just after it’s typed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都可以用于完整（端到端）测试，例如您在前几章中看到的那些。那些手动测试在代码刚敲完后迅速验证是非常有用的。
- en: But what if a change that you make later breaks one of those earlier manual
    tests (a *regression*)? You don’t want to rerun dozens of tests after every code
    change. That’s when *automated* tests become important. The rest of this chapter
    focuses on these, and how to build them with pytest.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果您稍后进行的更改破坏了早期的某些手动测试（*回归*）怎么办？您不想在每次代码更改后重新运行数十个测试。这时*自动化*测试变得重要。本章的其余部分将重点介绍这些内容，并讲解如何使用
    pytest 构建它们。
- en: Where to Test
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试位置
- en: 'I’ve mentioned the varieties of tests:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提到了各种测试：
- en: Unit
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 单元
- en: Within a layer, tests individual functions
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个层内，测试单个函数
- en: Integration
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 集成
- en: Across layers, tests connectivity
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 跨层测试连接性
- en: Full
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 完整
- en: Tests the full API and stack beneath it
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 测试完整的 API 和其下的堆栈
- en: Sometimes these are called a *test pyramid*, with the width indicating the relative
    number of tests that should be in each group ([Figure 12-1](#fig-pyramid)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有时这些被称为*测试金字塔*，宽度表示每个组中应该有的相对测试数量（[图 12-1](#fig-pyramid)）。
- en: '![fapi 1201](assets/fapi_1201.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![fapi 1201](assets/fapi_1201.png)'
- en: Figure 12-1\. Test pyramid
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-1。测试金字塔
- en: What to Test
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么要测试
- en: 'What should you test as you’re writing code? Basically, for a given input,
    confirm that you get the correct output. You might check the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，您应该测试什么？基本上，对于给定的输入，请确认您得到了正确的输出。您可以检查以下内容：
- en: Missing inputs
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺少输入
- en: Duplicate inputs
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复输入
- en: Incorrect input types
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不正确的输入类型
- en: Incorrect input order
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不正确的输入顺序
- en: Invalid input values
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无效的输入值
- en: Huge inputs or outputs
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大输入或输出
- en: 'Errors can happen anywhere:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 错误可能发生在任何地方：
- en: The Web layer
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Web 层
- en: Pydantic will catch any mismatch with the model and return a `422` HTTP status
    code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic 将捕获模型不匹配，并返回 `422` HTTP 状态码。
- en: The Data layer
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 数据层
- en: The database will raise exceptions for missing or duplicate data, as well as
    SQL query syntax errors. Timeouts or memory exhaustion may occur when passing
    a huge data result in one piece, instead of in chunks with a generator or pagination.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库将因为缺失或重复数据，以及 SQL 查询语法错误而引发异常。当一次传递大量数据结果而不是使用生成器或分页时，可能会发生超时或内存耗尽。
- en: Any layer
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 任何层
- en: Plain old bugs and oversights can occur.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 可能发生普通的错误和疏忽。
- en: 'Chapters [8](ch08.html#ch08) through [10](ch10.html#ch10) contained some of
    these tests:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 章节 [8](ch08.html#ch08) 到 [10](ch10.html#ch10) 包含了一些这样的测试：
- en: '*Full manual tests*, using tools like HTTPie'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*完全手动测试*，使用像 HTTPie 这样的工具'
- en: '*Unit manual tests*, as Python fragments'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单元手动测试*，作为 Python 片段'
- en: '*Automated tests*, using pytest scripts'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*自动化测试*，使用 pytest 脚本'
- en: The next few sections expand on pytest.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几节将详细介绍 pytest。
- en: Pytest
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pytest
- en: Python has long had the standard package [unittest](https://oreil.ly/3u0M_).
    A later third-party package called [nose](https://nose.readthedocs.io) tried to
    improve on it. Most Python developers now prefer [pytest](https://docs.pytest.org),
    which does more than either of these and is easier to use. It isn’t built into
    Python, so you’ll need to run `pip install pytest` if you don’t already have it.
    Also, run `pip install pytest-mock` to get the automatic `mocker` fixture; you’ll
    see this later in this chapter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Python 一直拥有标准包 [unittest](https://oreil.ly/3u0M_)。稍后的第三方包称为 [nose](https://nose.readthedocs.io)，试图对其进行改进。现在大多数
    Python 开发者更喜欢 [pytest](https://docs.pytest.org)，它比这两者都更强大且更易于使用。它没有内置在 Python
    中，因此如果没有安装，你需要运行 `pip install pytest`。此外，运行 `pip install pytest-mock` 可获取自动的 `mocker`
    固定装置；稍后在本章中你将看到这一点。
- en: 'What does pytest offer? Nice automatic features include the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: pytest 提供了什么？其中包括以下不错的自动功能：
- en: Test discovery
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 测试发现
- en: A test prefix or test suffix in a Python filename will be run automatically.
    This filename matching goes down into subdirectories, executing as many tests
    as you have there.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Python 文件名中的测试前缀或测试后缀将自动运行。此文件名匹配会进入子目录，执行那里的所有测试。
- en: Assertion failure details
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 断言失败的详细信息
- en: A failing `assert` statement prints what was expected and what actually happened.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一个失败的 `assert` 语句会打印预期的内容和实际发生的内容。
- en: Fixtures
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 固定装置
- en: 'These functions can run once for the whole test script, or run for every test
    (its *scope*), providing test functions with parameters like standard test data
    or database initialization. Fixtures are a sort of dependency injection, like
    FastAPI offers for web path functions: specific data passed to a general test
    function.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数可以为整个测试脚本运行一次，或者为每个测试运行一次（其*作用域*），为测试函数提供参数，如标准测试数据或数据库初始化。固定装置类似于依赖注入，就像
    FastAPI 为 Web 路径函数提供的那样：特定的数据传递给通用的测试函数。
- en: Parameterization
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化
- en: This provides multiple test data to a test function.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这为测试函数提供了多个测试数据。
- en: Layout
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局
- en: 'Where should you put your tests? There doesn’t seem to be wide agreement, but
    here are two reasonable designs:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该把测试放在哪里？似乎没有广泛的一致意见，但这里有两种合理的设计：
- en: A *test* directory at the top, with subdirectories for the code area being tested
    (like *web*, *service*, etc.)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶层有一个 *test* 目录，其中包含被测试的代码区域的子目录（如 *web*、*service* 等）。
- en: A *test* directory under each code directory (like *web*, *service*, etc.).
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个代码目录下都有一个 *test* 目录（如 *web*、*service* 等）。
- en: 'Also, within the specific subdirectory like *test/web*, should you make more
    directories for different test types (like *unit*, *integration*, and *full*)?
    In this book, I’m using this hierarchy:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在特定的子目录中（如 *test/web*），是否应该为不同的测试类型（如 *unit*、*integration* 和 *full*）创建更多目录？在本书中，我使用了这种层次结构：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Individual test scripts live within the bottom directories. Those are in this
    chapter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 各个测试脚本存放在底层目录中。这些在本章中。
- en: Automated Unit Tests
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化单元测试
- en: A unit test should check one thing, within one layer. This usually means passing
    parameter(s) to a function and asserting what should be returned.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应该检查一个事物，在一个层次内。通常意味着向函数传递参数，并断言应该返回什么。
- en: Unit tests require *isolation* of the code being tested. If not, you’re also
    testing something else. So, how do you isolate code for unit tests?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试要求对被测试的代码进行*隔离*。如果不这样做，你也在测试其他东西。那么，如何为单元测试隔离代码呢？
- en: Mocking
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟
- en: In this book’s code stack, accessing a URL via a web API generally calls a function
    in the Web layer, which calls a function in the Service layer, which calls a function
    in the Data layer, which accesses a database. The results flow back up the chain,
    eventually back out of the Web layer to the caller.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的代码堆栈中，通过 Web API 访问 URL 通常会调用 Web 层中的函数，该函数调用服务层中的函数，后者调用数据层中的函数，后者访问数据库。结果通过链条向上流动，最终从
    Web 层返回给调用者。
- en: 'Unit testing sounds simple. For each function in your codebase, pass in test
    arguments and confirm that it returns expected values. This works well for a *pure
    function*: one that takes input arguments and returns responses without referencing
    any external code. But most functions also call other functions, so how can you
    control what those other functions do? What about the data that comes from these
    external sources? The most common external factor to control is database access,
    but really it can be anything.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试听起来很简单。对于代码库中的每个函数，传入测试参数并确认其返回预期值即可。这对于*纯函数*（仅接受输入参数并返回响应，不引用任何外部代码）非常有效。但大多数函数还会调用其他函数，那么如何控制这些其他函数的操作？那么这些来自外部来源的数据如何处理？最常见的外部因素是控制数据库访问，但实际上可以是任何东西。
- en: One method is to *mock* each external function call. Because functions are first-class
    objects in Python, you can substitute one function for another. The unittest package
    has a mock module that does this.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是*模拟*每个外部函数调用。因为在Python中函数是一级对象，你可以用另一个函数替换一个函数。unittest包有一个mock模块可以做到这一点。
- en: Many developers believe that mocking is the best way to isolate unit tests.
    I’ll first show examples of mocking here, along with the argument that often mocking
    requires too much knowledge of *how* your code works, rather than the results.
    You may hear the terms *structural testing* (as in mocks, where the tested code
    is quite visible) and *behavioral testing* (where the code internals are not needed).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者认为模拟是隔离单元测试的最佳方法。我将首先在这里展示模拟的例子，并且提出一个论点：模拟往往需要对*代码如何运作*有太多了解，而不是其结果。你可能会听到*结构化测试*（如模拟，其中被测试的代码非常可见）和*行为测试*（其中代码内部不需要）这些术语。
- en: Examples [12-1](#ex-12-1) and [12-2](#ex-12-2) define the modules *mod1.py*
    and *mod2.py*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 [12-1](#ex-12-1) 和 [12-2](#ex-12-2) 定义了*mod1.py* 和 *mod2.py* 这两个模块。
- en: Example 12-1\. Called module (mod1.py)
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-1\. 被调用的模块（mod1.py）
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Example 12-2\. Calling module (mod2.py)
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-2\. 被调用的模块（mod2.py）
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `summer()` function calculates the sum of its arguments, and returns a string
    with a preamble and the sum. [Example 12-3](#ex-12-3) is a minimal pytest script
    to verify `summer()`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`summer()`函数计算其参数的和，并返回一个包含前文和总和的字符串。[示例 12-3](#ex-12-3) 是一个最小化的pytest脚本，用于验证`summer()`。'
- en: Example 12-3\. Pytest script test_summer1.py
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-3\. Pytest脚本 test_summer1.py
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Example 12-4](#ex-12-4) runs the test successfully.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 12-4](#ex-12-4) 成功运行了测试。'
- en: Example 12-4\. Run the pytest script
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-4\. 运行pytest脚本
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: (The `-q` runs the test quietly, without lots of extra printed details.) OK,
    it passed. But the `summer()` function got some text from the `preamble` function.
    What if we just want to test that the addition succeeded?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: （`-q` 可以安静地运行测试，不会输出大量额外的细节。）好的，测试通过了。但`summer()`函数从`preamble`函数中得到了一些文本。如果我们只是想测试加法是否成功呢？
- en: We could write a new function that just returns the stringified sum of two numbers,
    and then rewrite `summer()` to return this appended to the `preamble()` string.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个新函数，它只返回两个数字的字符串化的和，然后重写`summer()`函数将其返回附加到`preamble()`字符串中。
- en: Or, we could mock `preamble()` to remove its effect, as shown in multiple ways
    in [Example 12-5](#ex-12-5).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以模拟`preamble()`以消除其效果，正如在[示例 12-5](#ex-12-5) 中展示的多种方式那样。
- en: Example 12-5\. Pytest with a mock (test_summer2.py)
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-5\. Pytest中的模拟（test_summer2.py）
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'These tests show that mocks can be created in more than one way. The function
    `test_caller_a()` uses `mock.patch()` as a Python *context manager* (the `with`
    statement). Its arguments are listed here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试显示，模拟对象可以通过多种方式创建。`test_caller_a()`函数使用`mock.patch()`作为Python的*上下文管理器*（使用`with`语句）。其参数列在此处：
- en: '`"mod1.preamble"`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`"mod1.preamble"`'
- en: The full string name of the `preamble()` function in module `mod1`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块`mod1`中，`preamble()`函数的完整字符串名称。
- en: '`return_value=""`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`return_value=""`'
- en: Makes this mocked version return an empty string.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使得这个模拟版本返回一个空字符串。
- en: The `test_caller_b()` function is almost the same, but adds `as mock_preamble`
    to use the mock object on the next line.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_caller_b()`函数几乎相同，但在下一行添加了`as mock_preamble`来使用模拟对象。'
- en: The `test_caller_c()` function defines the mock with a Python *decorator*. The
    mocked object is passed as an argument to `test_caller2()`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_caller_c()`函数使用Python的*装饰器*定义了模拟对象。模拟对象作为参数传递给了`test_caller2()`。'
- en: The `test_caller_d()` function is like `test_caller_b()`, setting the `return_value`
    in a separate call to `mock_preamble`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_caller_d()`函数类似于`test_caller_b()`，但在对`mock_preamble`进行单独调用设置`return_value`时添加了`as
    mock_preamble`。'
- en: In each case, the string name of the thing to be mocked must match the way it’s
    called in the code that’s being tested—in this case, `summer()`. The mock library
    converts this string name to a variable that will intercept any references to
    the original variable with that name. (Remember that in Python, variables are
    just references to the real objects.)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，要模拟的事物的字符串名称必须与在正在测试的代码中调用它的方式匹配——在本例中是`summer()`。模拟库将该字符串名称转换为一个变量，该变量将拦截对原始具有该名称的任何变量的引用。（请记住，在
    Python 中，变量只是对真实对象的引用。）
- en: So, when [Example 12-6](#ex-12-6) is run, in all four `summer()` test functions,
    when `summer(5,6)` is called, the changeling mock `preamble()` is called instead
    of the real one. The mocked version drops that string, so the test can ensure
    that `summer()` returns a string version of the sum of its two arguments.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行[示例 12-6](#ex-12-6)时，在所有四个`summer()`测试函数中，当调用`summer(5,6)`时，替代的变身模拟`preamble()`被调用而不是真正的函数。模拟版本会丢弃该字符串，因此测试可以确保`summer()`返回其两个参数的字符串版本的和。
- en: Example 12-6\. Run mocked pytest
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-6\. 运行模拟的 pytest
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-106
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: That was a contrived case, for simplicity. Mocking can be quite complex; see
    articles like [“Understanding the Python Mock Object Library” by Alex Ronquillo](https://oreil.ly/I0bkd)
    for clear examples, and the official [Python docs](https://oreil.ly/hN9lZ) for
    the harrowing details.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 那是一个刻意的案例，为了简单起见。模拟可以非常复杂；查看像 [“Understanding the Python Mock Object Library”
    by Alex Ronquillo](https://oreil.ly/I0bkd) 这样的文章，以及官方的 [Python 文档](https://oreil.ly/hN9lZ)
    获取详细信息。
- en: Test Doubles and Fakes
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 Doubles 和 Fakes
- en: To perform that mock, you needed to know that the `summer()` function imported
    the function `preamble()` from the module `mod1`. This was a structural test,
    requiring knowledge of specific variable and module names.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行该模拟，您需要知道`summer()`函数从模块`mod1`导入了函数`preamble()`。这是一个结构测试，需要了解特定变量和模块名称。
- en: Is there a way to perform a behavioral test that doesn’t need this?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 是否有一种不需要这样做的行为测试方法？
- en: 'One way is to define a *double*: separate code that does what we want in the
    test—in this case, make `preamble()` return an empty string. One way to do this
    is with imports. Apply this to this example first, before using it for unit tests
    in the layers of the next three sections.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是定义一个 *double*：在测试中执行我们希望的操作的独立代码——在本例中，使`preamble()`返回一个空字符串。其中一种方法是使用导入。在接下来的三个部分的层中使用它进行单元测试之前，首先将其应用于此示例。
- en: First, redefine *mod2.py* in [Example 12-7](#ex-12-7).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在[示例 12-7](#ex-12-7) 中重新定义 *mod2.py*。
- en: Example 12-7\. Make mod2.py import a double if unit testing
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-7\. 如果进行单元测试，使 mod2.py 导入一个 double
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[Example 12-8](#ex-12-8) defines that double module *fake_mod1.py*.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 12-8](#ex-12-8) 定义了双重模块 *fake_mod1.py*。'
- en: Example 12-8\. Double fake_mod1.py
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-8\. 双重 fake_mod1.py
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: And [Example 12-9](#ex-12-9) is the test.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 而[示例 12-9](#ex-12-9) 是测试。
- en: Example 12-9\. Test script test_summer_fake.py
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-9\. 测试脚本 test_summer_fake.py
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: …​.which [Example 12-10](#ex-12-10) runs.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: …​.运行[示例 12-10](#ex-12-10)。
- en: Example 12-10\. Run the new unit test
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-10\. 运行新的单元测试
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This import-switching method does require adding a check for an environment
    variable, but avoids having to write specific mocks for function calls. You can
    be the judge of which you prefer. The next few sections will use the `import`
    method, which works nicely with the *fake* package that I’d been using as I defined
    the code layers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这种导入切换方法确实需要添加一个环境变量的检查，但避免了必须为函数调用编写特定的模拟。您可以自行决定喜欢哪种方法。接下来的几节将使用`import`方法，这与我在定义代码层时使用的
    *fake* 包非常匹配。
- en: To summarize, these examples replaced `preamble()` with a *mock* in a test script
    or imported a doppelgänger *double*. You can isolate the code being tested in
    other ways, but these work and are not as tricky as others that Google might find
    for you.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，这些示例将`preamble()`替换为测试脚本中的模拟，或者导入了一个 *double*。您可以以其他方式隔离被测试的代码，但这些方法工作起来并不像
    Google 可能为您找到的其他方法那么棘手。
- en: Web
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web
- en: This layer implements the site’s API. Ideally, each path function (endpoint)
    should have at least one test—maybe more, if the function could fail in more than
    one way. At the Web layer, you typically want to see if the endpoint exists, works
    with the correct parameters, and returns the right status code and data.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该层实现了站点的 API。理想情况下，每个路径函数（终点）都应至少有一个测试——也许更多，如果该函数可能以多种方式失败。在 Web 层，您通常希望查看端点是否存在，是否能够使用正确的参数工作，并返回正确的状态代码和数据。
- en: Note
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: These are shallow API tests, testing solely within the Web layer. So, Service-layer
    calls (which would in turn call the Data layer and the database) need to be intercepted,
    along with any other calls that exit the Web layer.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是浅层 API 测试，仅在 Web 层内部进行测试。因此，需要拦截服务层调用（这些调用将进一步调用数据层和数据库），以及任何其他退出 Web 层的调用。
- en: 'Using the `import` idea of the previous section, use the environment variable
    `CRYPTID_UNIT_TEST` to import the *fake* package as `service`, instead of the
    real `service`. This stops Web functions from calling Service functions, and instead
    short-circuits them to the *fake* (doubles) version. Then the lower Data layer
    and database aren’t involved, either. We get what we want: unit tests. [Example 12-11](#ex-12-11)
    has the modified *web/creature.py* file.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上一节的 `import` 思想，使用环境变量 `CRYPTID_UNIT_TEST` 将 *fake* 包作为 `service` 导入，而不是真正的
    `service`。这样一来，Web 函数不再调用 Service 函数，而是直接绕过它们到达 *fake*（双重）版本。然后，较低的数据层和数据库也不参与其中。我们得到了想要的单元测试。[例子
    12-11](#ex-12-11) 有修改后的 *web/creature.py* 文件。
- en: Example 12-11\. Modified web/creature.py
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子 12-11\. 修改后的 web/creature.py
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Example 12-12](#ex-12-12) has tests, using two pytest fixtures:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[例子 12-12](#ex-12-12) 有两个 pytest fixtures 的测试：'
- en: '`sample()`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`sample()`'
- en: A new `Creature` object
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的 `Creature` 对象
- en: '`fakes()`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`fakes()`'
- en: A list of “existing” creatures
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一个“现有”生物列表
- en: The fakes are obtained from a lower-level module. By setting the environment
    variable `CRYPTID_UNIT_TEST`, the Web module from [Example 12-11](#ex-12-11) imports
    the fake service version (providing fake data rather than calling the database)
    instead of the real one. This isolates the tests, which is the point.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 假物是从一个更低层次的模块中获取的。通过设置环境变量 `CRYPTID_UNIT_TEST`，Web 模块从 [例子 12-11](#ex-12-11)
    导入假服务版本（提供虚假数据而不调用数据库），而不是真实的版本。这隔离了测试，这正是它的目的。
- en: Example 12-12\. Web unit tests for creatures, using fixtures
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子 12-12\. 用于生物的 Web 单元测试，使用 fixtures
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Service
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务
- en: In a way, the Service layer is the important one and could be connected to different
    Web and Data layers. [Example 12-13](#ex-12-13) is similar to [Example 12-11](#ex-12-11),
    differing mainly in the `import` and use of the lower-level data module. It also
    doesn’t catch any exceptions that might arise from the Data layer, leaving them
    to be handled by the Web layer.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种角度来看，服务层是重要的一层，可以连接到不同的 Web 和数据层。[例子 12-13](#ex-12-13) 类似于 [例子 12-11](#ex-12-11)，主要区别在于
    `import` 和对较低级数据模块的使用。它还没有捕捉到可能来自数据层的任何异常，这些异常留待 Web 层处理。
- en: Example 12-13\. Modified service/creature.py
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子 12-13\. 修改后的 service/creature.py
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[Example 12-14](#ex-12-14) has the corresponding unit tests.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[例子 12-14](#ex-12-14) 有相应的单元测试。'
- en: Example 12-14\. Service tests in test/unit/service/test_creature.py
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子 12-14\. 在 test/unit/service/test_creature.py 中的服务测试
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Data
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据
- en: 'The Data layer is simpler to test in isolation, because there’s no worry about
    accidentally calling a function in an even lower layer. Unit tests should cover
    both the functions in this layer and the specific database queries that they use.
    So far, SQLite has been the database “server” and SQL the query language. But
    as I mention in [Chapter 14](ch14.html#ch14), you may decide to work with a package
    like SQLAlchemy, and use its SQLAlchemy Expression Language or its ORM. Then these
    would need full tests. So far, I’ve kept to the lowest level: Python’s DB-API
    and vanilla SQL queries.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 数据层更容易在隔离环境中进行测试，因为不必担心意外调用更低层的函数。单元测试应覆盖该层中的函数以及它们使用的具体数据库查询。到目前为止，SQLite 一直是数据库“服务器”，SQL
    是查询语言。但正如我在 [第 14 章](ch14.html#ch14) 中提到的，您可能决定使用像 SQLAlchemy 这样的包，并使用其 SQLAlchemy
    表达语言或其 ORM。那么这些需要完整的测试。到目前为止，我一直保持在最低层次：Python 的 DB-API 和原始的 SQL 查询。
- en: Unlike the Web and Service unit tests, this time we don’t need “fake” modules
    to replace the existing Data layer modules. Instead, set a different environment
    variable to get the Data layer to use a memory-only SQLite instance instead of
    a file-based one. This doesn’t require any changes to the existing Data modules,
    just a setting in [Example 12-15](#ex-12-15)’s test *before* importing any Data
    modules.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Web 和服务单元测试不同，这次我们不需要“fake”模块来替换现有的数据层模块。相反，设置一个不同的环境变量，使数据层使用内存中的 SQLite
    实例而不是基于文件的实例。这不需要对现有的数据模块进行任何更改，只需在 [例子 12-15](#ex-12-15) 的测试 *之前* 设置。
- en: Example 12-15\. Data unit tests test/unit/data/test_creature.py
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子 12-15\. 数据单元测试 test/unit/data/test_creature.py
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Automated Integration Tests
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化集成测试
- en: Integration tests show how well different code interacts *between* layers. But
    if you look for examples of this, you get many different answers. Should you test
    partial call trails like Web → Service, Web → Data, and so on?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试展示了不同代码在层之间交互的良好程度。但是如果你寻找这方面的例子，你会得到许多不同的答案。你是否应该测试像 Web → Service、Web
    → Data 等部分调用轨迹的例子呢？
- en: 'To fully test every connection in an A → B → C pipeline, you’d need to test
    the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全测试 A → B → C 管道中的每个连接，您需要测试以下内容：
- en: A → B
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A → B
- en: B → C
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B → C
- en: A → C
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A → C
- en: And the arrows would fill a quiver if you have more than these three junctions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有更多的三个连接点，箭头将填充箭袋。
- en: Or should integration tests be essentially full tests, but with the very end
    piece—data storage on disk—mocked?
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 或者集成测试应该基本上是完整的测试，但最后一部分——磁盘上的数据存储——被模拟了吗？
- en: 'So far, you’ve been using SQLite as the database, and you can use in-memory
    SQLite as a double (fake) for the on-disk SQLite database. If your queries are
    *very* standard SQL, SQLite-in-memory may be an adequate mock for other databases
    as well. If not, these modules are tailored to mock specific databases:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直在使用 SQLite 作为数据库，你可以使用内存中的 SQLite 作为磁盘上 SQLite 数据库的双倍（假）模拟。如果您的查询非常标准的
    SQL，SQLite-in-memory 可能是其他数据库的足够模拟。如果不是，这些模块专门用于模拟特定的数据库：
- en: PostgreSQL
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: '[pgmock](https://pgmock.readthedocs.io)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[pgmock](https://pgmock.readthedocs.io)'
- en: MongoDB
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB
- en: '[Mongomock](https://github.com/mongomock/mongomock)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[Mongomock](https://github.com/mongomock/mongomock)'
- en: Many
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 许多
- en: '[Pytest Mock Resources](https://pytest-mock-resources.readthedocs.io) spins
    up various test databases in Docker containers, and is integrated with pytest.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[Pytest Mock Resources](https://pytest-mock-resources.readthedocs.io) 在 Docker
    容器中启动各种测试数据库，并与 pytest 集成。'
- en: Finally, you could just fire up a test database of the same kind as production.
    An environment variable could contain the specifics, much like the unit test/fake
    trick you’ve been using.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以只需启动与生产相同类型的测试数据库。环境变量可以包含具体信息，就像您一直在使用的单元测试/假技巧一样。
- en: The Repository Pattern
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓储模式
- en: Although I did not implement it for this book, the [Repository pattern](https://oreil.ly/3JMKH)
    is an interesting approach. A *repository* is a simple intermediate in-memory
    data store—like the fake Data layer that you’ve seen here so far. This then talks
    to pluggable backends for real databases. It’s accompanied by a [*Unit of Work*
    pattern](https://oreil.ly/jHGV8), which ensures that a group of operations in
    a single *session* is either committed or rolled back as a whole.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我没有在本书中实现它，但[仓储模式](https://oreil.ly/3JMKH)是一个有趣的方法。*仓储* 是一个简单的内存中间数据存储器——就像你到目前为止在这里看到的假数据层一样。然后它与真实数据库的可插拔后端进行通信。它伴随着
    [*工作单元* 模式](https://oreil.ly/jHGV8)，它确保单个 *会话* 中的一组操作要么全部提交，要么全部回滚。
- en: So far, the database queries in this book have been atomic. For real-world database
    work, you may need multistep queries, and some kind of session handling. The Repository
    pattern also dovetails with [dependency injection](https://oreil.ly/0f0Q3), which
    you’ve seen elsewhere in this book and probably appreciate a little by now.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书中的数据库查询都是原子性的。对于真实世界的数据库工作，您可能需要多步查询，并进行某种形式的会话处理。仓储模式还与[依赖注入](https://oreil.ly/0f0Q3)结合，这是您在本书的其他地方已经看到并且现在可能已经有点欣赏了。
- en: Automated Full Tests
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化完整测试
- en: 'Full tests exercise all the layers together, as close to production use as
    possible. Most of the tests that you’ve already seen in this book have been full:
    call the Web endpoint, run through Servicetown to downtown Dataville, and return
    with groceries. These are closed tests. Everything is live, and you don’t care
    how it does it, just that it does it.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的测试将所有层次一起练习，尽可能接近生产使用。这本书中大多数你已经看过的测试都是完整的：调用 Web 端点，通过 Servicetown 到市中心
    Dataville，然后返回带有杂货。这些是封闭的测试。一切都是真实的，你不关心它是如何做到的，只关心它是否做到了。
- en: 'You can fully test each endpoint in the overall API in two ways:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过两种方式完全测试整体 API 中的每个端点：
- en: Over HTTP/HTTPS
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 HTTP/HTTPS
- en: Write individual Python test clients that access the server. Many examples in
    this book have done this, with standalone clients like HTTPie, or in scripts using
    Requests.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 编写独立的 Python 测试客户端来访问服务器。本书中的许多示例都已经这样做了，使用像 HTTPie 这样的独立客户端，或者在使用 Requests
    的脚本中。
- en: Using `TestClient`
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `TestClient`
- en: Use this built-in FastAPI/Starlette object to access the server directly, without
    an overt TCP connection.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个内置的 FastAPI/Starlette 对象直接访问服务器，而无需显式的 TCP 连接。
- en: 'But these approaches require writing one or more tests for each endpoint. This
    can become medieval, and we’re a few centuries past medieval now. A more recent
    approach is based on *property-based testing*. This takes advantage of FastAPI’s
    autogenerated documentation. An OpenAPI *schema* called *openapi.json* is created
    by FastAPI every time you change a path function or path decorator in the Web
    layer. This schema details everything about every endpoint: arguments, return
    values, and so on. That’s what OpenAPI is for, as described here by the [OpenAPI
    Initiative’s FAQ page](https://www.openapis.org/faq):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些方法需要为每个端点编写一个或多个测试。这可能有点过时，我们现在已经过了几个世纪。一个更近代的方法基于 *基于属性的测试*。它利用 FastAPI
    自动生成的文档。每次在 Web 层更改路径函数或路径装饰器时，FastAPI 都会创建一个名为 *openapi.json* 的 OpenAPI *模式*。此模式详细描述了每个端点的所有内容：参数、返回值等等。这就是
    OpenAPI 的作用，正如[OpenAPI Initiative’s FAQ page](https://www.openapis.org/faq)所述：
- en: The OAS defines a standard, programming language-agnostic interface description
    for REST APIs, which allows both humans and computers to discover and understand
    the capabilities of a service without requiring access to source code, additional
    documentation, or inspection of network traffic.
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: OAS 定义了一个标准的、与编程语言无关的接口描述，用于 REST API，允许人类和计算机在不需要访问源代码、额外文档或检查网络流量的情况下发现和理解服务的能力。
- en: ''
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: OAS (OpenAPI Specification)
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: OAS（OpenAPI 规范）
- en: 'Two packages are needed:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 需要两个包：
- en: '[Hypothesis](https://hypothesis.works)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[Hypothesis](https://hypothesis.works)'
- en: '`pip install hypothesis`'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip install hypothesis`'
- en: '[Schemathesis](https://schemathesis.readthedocs.io)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[Schemathesis](https://schemathesis.readthedocs.io)'
- en: '`pip install schemathesis`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip install schemathesis`'
- en: Hypothesis is the base library, and Schemathesis applies it to the OpenAPI 3.0
    schema that FastAPI generates. Running Schemathesis reads this schema, generates
    gobs of tests with varying data (that you don’t need to come up with!), and works
    with pytest.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 假设是基础库，而 Schemathesis 则将其应用于 FastAPI 生成的 OpenAPI 3.0 模式。运行 Schemathesis 读取此模式，使用不同的数据生成大量测试（无需自行生成！），并与
    pytest 协同工作。
- en: To keep this brief, [Example 12-16](#ex-12-16) first slims *main.py* down to
    its base creature and explorer endpoints.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，[示例 12-16](#ex-12-16) 首先将 *main.py* 精简到其基础的 creature 和 explorer 端点。
- en: Example 12-16\. Bare-bones main.py
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-16\. 简化后的 main.py
- en: '[PRE16]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[Example 12-17](#ex-12-17) runs the tests.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 12-17](#ex-12-17) 运行测试。'
- en: Example 12-17\. Run Schemathesis tests
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 12-17\. 运行 Schemathesis 测试
- en: '[PRE17]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: I got two F’s, both in `PATCH` calls (`modify()` functions). How mortifying.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我得到两个 F，都是在 `PATCH` 调用中 (`modify()` 函数)。真尴尬。
- en: 'This output section is followed by one marked `FAILURES`, with detailed stack
    traces of any tests that failed. Those need to be fixed. The final section is
    marked `SUMMARY`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '这个输出部分后面是一个标记为 `FAILURES` 的部分，显示任何失败测试的详细堆栈跟踪。这些需要修复。最后一个部分标记为 `SUMMARY`：  '
- en: '[PRE18]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That was fast, and multiple tests were not needed for each endpoint, imagining
    inputs that might break them. Property-based testing reads the types and constraints
    of the input arguments from the API schema, and generates a range of values to
    shoot at each endpoint.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这真是太快了，每个端点并不需要多个测试，只需想象可能导致它们出错的输入即可。基于属性的测试从 API 模式中读取输入参数的类型和约束，并为每个端点生成一系列值。
- en: 'This is yet another unexpected benefit of type hints, which at first seemed
    to be just nice things:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是类型提示的又一个意想不到的好处，最初它们似乎只是一些美好的东西：
- en: type hints → OpenAPI schema → generated documentation *and* tests
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型提示 → OpenAPI 模式 → 生成的文档 *和* 测试
- en: Security Testing
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全测试
- en: Security isn’t one thing, but everything. You need to defend against malice
    but also against plain old mistakes, and even events that you have no control
    over. Let’s defer scaling issues to the next section and deal mainly here with
    the analysis of potential threats.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 安全不是单一的事物，而是一切。你需要防范恶意行为，也要防止简单的错误，甚至是无法控制的事件。让我们把扩展性问题推迟到下一节，主要在这里分析潜在威胁。
- en: '[Chapter 11](ch11.html#ch11) discussed authentication and authorization. These
    factors are always messy and error-prone. It’s tempting to use clever methods
    to counteract clever attacks, and it’s always a challenge to design protection
    that’s easy to understand and implement.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 11 章](ch11.html#ch11) 讨论了认证和授权。这些因素总是混乱且容易出错。诱人的是使用聪明的方法来对抗聪明的攻击，设计易于理解和实施的保护措施总是一种挑战。'
- en: But now that you know about Schemathesis, read its [documentation](https://oreil.ly/v_O-Q)
    on property-based testing for authentication. Just as it vastly simplified testing
    most of the API, it can automate much of the tests for endpoints that need authentication.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在您已了解了Schemathesis，请阅读其关于身份验证基于属性的测试的[文档](https://oreil.ly/v_O-Q)。就像它极大地简化了大多数API的测试一样，它可以自动化需要身份验证的端点的大部分测试。
- en: Load Testing
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 负载测试
- en: 'Load tests show how your application handles heavy traffic:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 负载测试展示您的应用程序如何处理大量流量：
- en: API calls
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API调用
- en: Database reads or writes
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库读取或写入
- en: Memory use
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存使用
- en: Disk use
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘使用
- en: Network latency and bandwidth
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络延迟和带宽
- en: Some can be *full* tests that simulate an army of users clamoring to use your
    service; you want to be ready before that day arrives. The content in this section
    overlaps with that in [“Performance”](ch13.html#performanceSect) and [“Troubleshooting”](ch13.html#troubleshooting).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一些可以是*完整*测试，模拟一群用户争先使用您的服务；在那一天到来之前，您需要做好准备。本节内容与[“性能”](ch13.html#performanceSect)和[“故障排除”](ch13.html#troubleshooting)中的内容有所重叠。
- en: Many good load testers out are there, but here I’ll recommend [Locust](https://locust.io).
    With Locust, you define all your tests with plain Python scripts. It can simulate
    hundreds of thousands of users, all pounding away at your site, or even multiple
    servers, at once.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多优秀的负载测试工具，但我在这里推荐[Locust](https://locust.io)。使用Locust，您可以用简单的Python脚本定义所有测试。它可以模拟数十万用户同时访问您的网站，甚至多台服务器。
- en: Install it locally with `pip install locust`. Your first test may be how many
    concurrent visitors your site can handle. This is like testing how much extreme
    weather a building can withstand when faced with a hurricane/earthquake/blizzard
    or other home insurance event. So, you need some website structural tests. Follow
    the Locust [docs](https://docs.locust.io) for all the details.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pip install locust`在本地安装它。您的第一个测试可能是您的网站可以处理多少并发访问者。这就像在面对飓风/地震/暴风雪或其他家庭保险事件时测试建筑物能承受多少极端天气。因此，您需要一些网站结构测试。查看Locust的[文档](https://docs.locust.io)获取所有详细信息。
- en: But, as they say on TV, there’s more! Recently, [Grasshopper](https://github.com/alteryx/locust-grasshopper)
    extended Locust to do things like measuring time across multiple HTTP calls. To
    try this extension out, install with `pip install locust-grasshopper`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如电视上所说的，这还不是全部！最近，[Grasshopper](https://github.com/alteryx/locust-grasshopper)扩展了Locust，可以测量跨多个HTTP调用的时间等功能。要尝试此扩展，请使用`pip
    install locust-grasshopper`进行安装。
- en: Review
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾
- en: This chapter fleshed out the types of testing, with examples of pytest performing
    automated code testing at the unit, integration, and full levels. API tests can
    be automated with Schemathesis. This chapter also discussed how to expose security
    and performance problems before they strike.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细介绍了各种测试类型，并举例说明了pytest在单元测试、集成测试和完整测试中的自动化代码测试。API测试可以使用Schemathesis进行自动化。本章还讨论了如何在问题出现之前暴露安全性和性能问题。
