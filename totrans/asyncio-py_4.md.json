["```py\n# msgproto.py\nfrom asyncio import StreamReader, StreamWriter\n\nasync def read_msg(stream: StreamReader) -> bytes:\n    size_bytes = await stream.readexactly(4)  ![1](assets/1.png)\n    size = int.from_bytes(size_bytes, byteorder='big')  ![2](assets/2.png)\n    data = await stream.readexactly(size)  ![3](assets/3.png)\n    return data\n\nasync def send_msg(stream: StreamWriter, data: bytes):\n    size_bytes = len(data).to_bytes(4, byteorder='big')\n    stream.writelines([size_bytes, data])  ![4](assets/4.png)\n    await stream.drain()\n```", "```py\n# mq_server.py\nimport asyncio\nfrom asyncio import StreamReader, StreamWriter, gather\nfrom collections import deque, defaultdict\nfrom typing import Deque, DefaultDict\nfrom msgproto import read_msg, send_msg  ![1](assets/1.png)\n\nSUBSCRIBERS: DefaultDict[bytes, Deque] = defaultdict(deque) ![2](assets/2.png)\n\nasync def client(reader: StreamReader, writer: StreamWriter):\n  peername = writer.get_extra_info('peername')  ![3](assets/3.png)\n  subscribe_chan = await read_msg(reader)  ![4](assets/4.png)\n  SUBSCRIBERS[subscribe_chan].append(writer)  ![5](assets/5.png)\n  print(f'Remote {peername} subscribed to {subscribe_chan}')\n  try:\n    while channel_name := await read_msg(reader):  ![6](assets/6.png)\n      data = await read_msg(reader)  ![7](assets/7.png)\n      print(f'Sending to {channel_name}: {data[:19]}...')\n      conns = SUBSCRIBERS[channel_name]  ![8](assets/8.png)\n      if conns and channel_name.startswith(b'/queue'):  ![9](assets/9.png)\n          conns.rotate()  ![10](assets/10.png)\n          conns = [conns[0]]  ![11](assets/11.png)\n      await gather(*[send_msg(c, data) for c in conns]) ![12](assets/12.png)\n  except asyncio.CancelledError:\n    print(f'Remote {peername} closing connection.')\n    writer.close()\n    await writer.wait_closed()\n  except asyncio.IncompleteReadError:\n    print(f'Remote {peername} disconnected')\n  finally:\n    print(f'Remote {peername} closed')\n    SUBSCRIBERS[subscribe_chan].remove(writer)  ![13](assets/13.png)\n\nasync def main(*args, **kwargs):\n    server = await asyncio.start_server(*args, **kwargs)\n    async with server:\n        await server.serve_forever()\n\ntry:\n    asyncio.run(main(client, host='127.0.0.1', port=25000))\nexcept KeyboardInterrupt:\n    print('Bye!')\n```", "```py\n# mq_client_listen.py\nimport asyncio\nimport argparse, uuid\nfrom msgproto import read_msg, send_msg\n\nasync def main(args):\n  me = uuid.uuid4().hex[:8] ![1](assets/1.png)\n  print(f'Starting up {me}')\n  reader, writer = await asyncio.open_connection(\n    args.host, args.port) ![2](assets/2.png)\n  print(f'I am {writer.get_extra_info(\"sockname\")}')\n  channel = args.listen.encode()  ![3](assets/3.png)\n  await send_msg(writer, channel)  ![4](assets/4.png)\n  try:\n    while data := await read_msg(reader):  ![5](assets/5.png)\n      print(f'Received by {me}: {data[:20]}')\n    print('Connection ended.')\n  except asyncio.IncompleteReadError:\n    print('Server closed.')\n  finally:\n    writer.close()\n    await writer.wait_closed()\n\nif __name__ == '__main__':\n  parser = argparse.ArgumentParser() ![6](assets/6.png)\n  parser.add_argument('--host', default='localhost')\n  parser.add_argument('--port', default=25000)\n  parser.add_argument('--listen', default='/topic/foo')\n  try:\n    asyncio.run(main(parser.parse_args()))\n  except KeyboardInterrupt:\n    print('Bye!')\n```", "```py\n# mq_client_sender.py\nimport asyncio\nimport argparse, uuid\nfrom itertools import count\nfrom msgproto import send_msg\n\nasync def main(args):\n    me = uuid.uuid4().hex[:8]  ![1](assets/1.png)\n    print(f'Starting up {me}')\n    reader, writer = await asyncio.open_connection(\n        host=args.host, port=args.port)  ![2](assets/2.png)\n    print(f'I am {writer.get_extra_info(\"sockname\")}')\n\n    channel = b'/null'  ![3](assets/3.png)\n    await send_msg(writer, channel) ![4](assets/4.png)\n\n    chan = args.channel.encode()  ![5](assets/5.png)\n    try:\n        for i in count():  ![6](assets/6.png)\n            await asyncio.sleep(args.interval)  ![7](assets/7.png)\n            data = b'X'*args.size or f'Msg {i} from {me}'.encode()\n            try:\n                await send_msg(writer, chan)\n                await send_msg(writer, data) ![8](assets/8.png)\n            except OSError:\n                print('Connection ended.')\n                break\n    except asyncio.CancelledError:\n        writer.close()\n        await writer.wait_closed()\n\nif __name__ == '__main__':\n  parser = argparse.ArgumentParser()  ![9](assets/9.png)\n  parser.add_argument('--host', default='localhost')\n  parser.add_argument('--port', default=25000, type=int)\n  parser.add_argument('--channel', default='/topic/foo')\n  parser.add_argument('--interval', default=1, type=float)\n  parser.add_argument('--size', default=0, type=int)\n  try:\n    asyncio.run(main(parser.parse_args()))\n  except KeyboardInterrupt:\n    print('Bye!')\n```", "```py\n$ mq_server.py\nRemote ('127.0.0.1', 55382) subscribed to b'/queue/blah'\nRemote ('127.0.0.1', 55386) subscribed to b'/queue/blah'\nRemote ('127.0.0.1', 55390) subscribed to b'/null'\nSending to b'/queue/blah': b'Msg 0 from 6b5a8e1d'...\nSending to b'/queue/blah': b'Msg 1 from 6b5a8e1d'...\nSending to b'/queue/blah': b'Msg 2 from 6b5a8e1d'...\nSending to b'/queue/blah': b'Msg 3 from 6b5a8e1d'...\nSending to b'/queue/blah': b'Msg 4 from 6b5a8e1d'...\nSending to b'/queue/blah': b'Msg 5 from 6b5a8e1d'...\n^CBye!\nRemote ('127.0.0.1', 55382) closing connection.\nRemote ('127.0.0.1', 55382) closed\nRemote ('127.0.0.1', 55390) closing connection.\nRemote ('127.0.0.1', 55390) closed\nRemote ('127.0.0.1', 55386) closing connection.\nRemote ('127.0.0.1', 55386) closed\n\n```", "```py\n$ mq_client_sender.py --channel /queue/blah\nStarting up 6b5a8e1d\nI am ('127.0.0.1', 55390)\nConnection ended.\n\n```", "```py\n$ mq_client_listen.py --listen /queue/blah\nStarting up 9ae04690\nI am ('127.0.0.1', 55382)\nReceived by 9ae04690: b'Msg 1 from 6b5a8e1d'\nReceived by 9ae04690: b'Msg 3 from 6b5a8e1d'\nReceived by 9ae04690: b'Msg 5 from 6b5a8e1d'\nServer closed.\n\n```", "```py\n$ mq_client_listen.py --listen /queue/blah\nStarting up bd4e3baa\nI am ('127.0.0.1', 55386)\nReceived by bd4e3baa: b'Msg 0 from 6b5a8e1d'\nReceived by bd4e3baa: b'Msg 2 from 6b5a8e1d'\nReceived by bd4e3baa: b'Msg 4 from 6b5a8e1d'\nServer closed.\n\n```", "```py\n# mq_server_plus.py\nimport asyncio\nfrom asyncio import StreamReader, StreamWriter, Queue\nfrom collections import deque, defaultdict\nfrom contextlib import suppress\nfrom typing import Deque, DefaultDict, Dict\nfrom msgproto import read_msg, send_msg\n\nSUBSCRIBERS: DefaultDict[bytes, Deque] = defaultdict(deque)\nSEND_QUEUES: DefaultDict[StreamWriter, Queue] = defaultdict(Queue)\nCHAN_QUEUES: Dict[bytes, Queue] = {}  ![1](assets/1.png)\n\nasync def client(reader: StreamReader, writer: StreamWriter):\n  peername = writer.get_extra_info('peername')\n  subscribe_chan = await read_msg(reader)\n  SUBSCRIBERS[subscribe_chan].append(writer)  ![2](assets/2.png)\n  send_task = asyncio.create_task(\n      send_client(writer, SEND_QUEUES[writer]))  ![3](assets/3.png)\n  print(f'Remote {peername} subscribed to {subscribe_chan}')\n  try:\n    while channel_name := await read_msg(reader):\n      data = await read_msg(reader)\n      if channel_name not in CHAN_QUEUES:  ![4](assets/4.png)\n        CHAN_QUEUES[channel_name] = Queue(maxsize=10)  ![5](assets/5.png)\n        asyncio.create_task(chan_sender(channel_name))  ![6](assets/6.png)\n      await CHAN_QUEUES[channel_name].put(data)  ![7](assets/7.png)\n  except asyncio.CancelledError:\n    print(f'Remote {peername} connection cancelled.')\n  except asyncio.IncompleteReadError:\n    print(f'Remote {peername} disconnected')\n  finally:\n    print(f'Remote {peername} closed')\n    await SEND_QUEUES[writer].put(None)  ![8](assets/8.png)\n    await send_task  ![9](assets/9.png)\n    del SEND_QUEUES[writer]  ![10](assets/10.png)\n    SUBSCRIBERS[subscribe_chan].remove(writer)\n\nasync def send_client(writer: StreamWriter, queue: Queue):  ![11](assets/11.png)\n    while True:\n        try:\n            data = await queue.get()\n        except asyncio.CancelledError:\n            continue\n\n        if not data:\n            break\n\n        try:\n            await send_msg(writer, data)\n        except asyncio.CancelledError:\n            await send_msg(writer, data)\n\n    writer.close()\n    await writer.wait_closed()\n\nasync def chan_sender(name: bytes):\n    with suppress(asyncio.CancelledError):\n        while True:\n            writers = SUBSCRIBERS[name]\n            if not writers:\n                await asyncio.sleep(1)\n                continue  ![12](assets/12.png)\n            if name.startswith(b'/queue'):  ![13](assets/13.png)\n                writers.rotate()\n                writers = [writers[0]]\n            if not (msg := await CHAN_QUEUES[name].get()): ![14](assets/14.png)\n                break\n            for writer in writers:\n                if not SEND_QUEUES[writer].full():\n                    print(f'Sending to {name}: {msg[:19]}...')\n                    await SEND_QUEUES[writer].put(msg)  ![15](assets/15.png)\n\nasync def main(*args, **kwargs):\n    server = await asyncio.start_server(*args, **kwargs)\n    async with server:\n        await server.serve_forever()\ntry:\n    asyncio.run(main(client, host='127.0.0.1', port=25000))\nexcept KeyboardInterrupt:\n    print('Bye!')\n```", "```py\n@defer.inlineCallbacks  ![1](assets/1.png)\ndef f():\n    yield\n    defer.returnValue(123)  ![2](assets/2.png)\n\n@defer.inlineCallbacks\ndef my_coro_func():\n    value = yield f()  ![3](assets/3.png)\n    assert value == 123\n```", "```py\n# twisted_asyncio.py\nfrom time import ctime\nfrom twisted.internet import asyncioreactor\nasyncioreactor.install()  ![1](assets/1.png)\nfrom twisted.internet import reactor, defer, task  ![2](assets/2.png)\n\nasync def main():  ![3](assets/3.png)\n    for i in range(5):\n        print(f'{ctime()} Hello {i}')\n        await task.deferLater(reactor, 1, lambda: None)  ![4](assets/4.png)\n\ndefer.ensureDeferred(main())  ![5](assets/5.png)\nreactor.run()  ![6](assets/6.png)\n```", "```py\n$ twisted_asyncio.py\nMon Oct 16 16:19:49 2019 Hello 0\nMon Oct 16 16:19:50 2019 Hello 1\nMon Oct 16 16:19:51 2019 Hello 2\nMon Oct 16 16:19:52 2019 Hello 3\nMon Oct 16 16:19:53 2019 Hello 4\n\n```", "```py\n# janus_demo.py\nimport asyncio\nimport random\nimport time\n\nimport janus\n\nasync def main():\n    loop = asyncio.get_running_loop()\n    queue = janus.Queue(loop=loop)  ![1](assets/1.png)\n    future = loop.run_in_executor(None, data_source, queue)\n    while (data := await queue.async_q.get()) is not None:  ![2](assets/2.png)\n        print(f'Got {data} off queue')  ![3](assets/3.png)\n    print('Done.')\n\ndef data_source(queue):\n    for i in range(10):\n        r = random.randint(0, 4)\n        time.sleep(r)  ![4](assets/4.png)\n        queue.sync_q.put(r)  ![5](assets/5.png)\n    queue.sync_q.put(None)\n\nasyncio.run(main())\n```", "```py\n$ <name>\nGot 2 off queue\nGot 4 off queue\nGot 4 off queue\nGot 2 off queue\nGot 3 off queue\nGot 4 off queue\nGot 1 off queue\nGot 1 off queue\nGot 0 off queue\nGot 4 off queue\nDone.\n\n```", "```py\nfrom aiohttp import web\n\nasync def hello(request):\n    return web.Response(text=\"Hello, world\")\n\napp = web.Application()  ![1](assets/1.png)\napp.router.add_get('/', hello)  ![2](assets/2.png)\nweb.run_app(app, port=8080)  ![3](assets/3.png)\n```", "```py\n$ docker pull scrapinghub/splash\n$ docker run --rm -p 8050:8050 scrapinghub/splash\n\n```", "```py\nfrom asyncio import gather, create_task\nfrom string import Template\nfrom aiohttp import web, ClientSession\nfrom bs4 import BeautifulSoup\n\nasync def news(request):  ![1](assets/1.png)\n    sites = [\n        ('http://edition.cnn.com', cnn_articles),  ![2](assets/2.png)\n        ('http://www.aljazeera.com', aljazeera_articles),\n    ]\n    tasks = [create_task(news_fetch(*s)) for s in sites] ![3](assets/3.png)\n    await gather(*tasks)  ![4](assets/4.png)\n\n    items = {  ![5](assets/5.png)\n        text: (  ![6](assets/6.png)\n            f'<div class=\"box {kind}\">'\n            f'<span>'\n            f'<a href=\"{href}\">{text}</a>'\n            f'</span>'\n            f'</div>'\n        )\n        for task in tasks for href, text, kind in task.result()\n    }\n    content = ''.join(items[x] for x in sorted(items))\n\n    page = Template(open('index.html').read())  ![7](assets/7.png)\n    return web.Response(\n        body=page.safe_substitute(body=content),  ![8](assets/8.png)\n        content_type='text/html',\n    )\n\nasync def news_fetch(url, postprocess):\n    proxy_url = (\n        f'http://localhost:8050/render.html?'  ![9](assets/9.png)\n        f'url={url}&timeout=60&wait=1'\n    )\n    async with ClientSession() as session:\n        async with session.get(proxy_url) as resp:  ![10](assets/10.png)\n            data = await resp.read()\n            data = data.decode('utf-8')\n    return postprocess(url, data)  ![11](assets/11.png)\n\ndef cnn_articles(url, page_data):  ![12](assets/12.png)\n    soup = BeautifulSoup(page_data, 'lxml')\n    def match(tag):\n        return (\n            tag.text and tag.has_attr('href')\n            and tag['href'].startswith('/')\n            and tag['href'].endswith('.html')\n            and tag.find(class_='cd__headline-text')\n        )\n    headlines = soup.find_all(match)  ![13](assets/13.png)\n    return [(url + hl['href'], hl.text, 'cnn')\n            for hl in headlines]\n\ndef aljazeera_articles(url, page_data):  ![14](assets/14.png)\n    soup = BeautifulSoup(page_data, 'lxml')\n    def match(tag):\n        return (\n            tag.text and tag.has_attr('href')\n            and tag['href'].startswith('/news')\n            and tag['href'].endswith('.html')\n        )\n    headlines = soup.find_all(match)\n    return [(url + hl['href'], hl. text, 'aljazeera')\n            for hl in headlines]\n\napp = web.Application()\napp.router.add_get('/news', news)\nweb.run_app(app, port=8080)\n```", "```py\n# poller.py\nimport zmq\n\ncontext = zmq.Context()\nreceiver = context.socket(zmq.PULL)  ![1](assets/1.png)\nreceiver.connect(\"tcp://localhost:5557\")\n\nsubscriber = context.socket(zmq.SUB)  ![2](assets/2.png)\nsubscriber.connect(\"tcp://localhost:5556\")\nsubscriber.setsockopt_string(zmq.SUBSCRIBE, '')\n\npoller = zmq.Poller()  ![3](assets/3.png)\npoller.register(receiver, zmq.POLLIN)\npoller.register(subscriber, zmq.POLLIN)\n\nwhile True:\n    try:\n        socks = dict(poller.poll())  ![4](assets/4.png)\n    except KeyboardInterrupt:\n        break\n\n    if receiver in socks:\n        message = receiver.recv_json()\n        print(f'Via PULL: {message}')\n\n    if subscriber in socks:\n        message = subscriber.recv_json()\n        print(f'Via SUB: {message}')\n```", "```py\n# poller_srv.py\nimport zmq, itertools, time\n\ncontext = zmq.Context()\npusher = context.socket(zmq.PUSH)\npusher.bind(\"tcp://*:5557\")\n\npublisher = context.socket(zmq.PUB)\npublisher.bind(\"tcp://*:5556\")\n\nfor i in itertools.count():\n    time.sleep(1)\n    pusher.send_json(i)\n    publisher.send_json(i)\n```", "```py\n$ poller.py\nVia PULL: 0\nVia SUB: 0\nVia PULL: 1\nVia SUB: 1\nVia PULL: 2\nVia SUB: 2\nVia PULL: 3\nVia SUB: 3\n\n```", "```py\n# poller_aio.py\nimport asyncio\nimport zmq\nfrom zmq.asyncio import Context\n\ncontext = Context()\n\nasync def do_receiver():\n    receiver = context.socket(zmq.PULL)  ![1](assets/1.png)\n    receiver.connect(\"tcp://localhost:5557\")\n    while message := await receiver.recv_json():  ![2](assets/2.png)\n        print(f'Via PULL: {message}')\n\nasync def do_subscriber():\n    subscriber = context.socket(zmq.SUB)  ![3](assets/3.png)\n    subscriber.connect(\"tcp://localhost:5556\")\n    subscriber.setsockopt_string(zmq.SUBSCRIBE, '')\n    while message := await subscriber.recv_json():  ![4](assets/4.png)\n        print(f'Via SUB: {message}')\n\nasync def main():\n    await asyncio.gather(\n        do_receiver(),\n        do_subscriber(),\n    )\n\nasyncio.run(main())\n```", "```py\nimport argparse\nimport asyncio\nfrom random import randint, uniform\nfrom datetime import datetime as dt\nfrom datetime import timezone as tz\nfrom contextlib import suppress\nimport zmq, zmq.asyncio, psutil\n\nctx = zmq.asyncio.Context()\n\nasync def stats_reporter(color: str):  ![1](assets/1.png)\n    p = psutil.Process()\n    sock = ctx.socket(zmq.PUB)  ![2](assets/2.png)\n    sock.setsockopt(zmq.LINGER, 1)\n    sock.connect('tcp://localhost:5555')  ![3](assets/3.png)\n    with suppress(asyncio.CancelledError):  ![4](assets/4.png)\n        while True:  ![5](assets/5.png)\n            await sock.send_json(dict(  ![6](assets/6.png)\n                color=color,\n                timestamp=dt.now(tz=tz.utc).isoformat(),  ![7](assets/7.png)\n                cpu=p.cpu_percent(),\n                mem=p.memory_full_info().rss / 1024 / 1024\n            ))\n            await asyncio.sleep(1)\n    sock.close()  ![8](assets/8.png)\n\nasync def main(args):\n    asyncio.create_task(stats_reporter(args.color))\n    leak = []\n    with suppress(asyncio.CancelledError):\n        while True:\n            sum(range(randint(1_000, 10_000_000)))  ![9](assets/9.png)\n            await asyncio.sleep(uniform(0, 1))\n            leak += [0] * args.leak\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--color', type=str)  ![10](assets/10.png)\n    parser.add_argument('--leak', type=int, default=0)\n    args = parser.parse_args()\n    try:\n        asyncio.run(main(args))\n    except KeyboardInterrupt:\n        print('Leaving...')\n        ctx.term()  ![11](assets/11.png)\n```", "```py\n# metric-server.py\nimport asyncio\nfrom contextlib import suppress\nimport zmq\nimport zmq.asyncio\nimport aiohttp\nfrom aiohttp import web\nfrom aiohttp_sse import sse_response\nfrom weakref import WeakSet\nimport json\n\n# zmq.asyncio.install()\nctx = zmq.asyncio.Context()\nconnections = WeakSet()  ![1](assets/1.png)\n\nasync def collector():\n    sock = ctx.socket(zmq.SUB)  ![2](assets/2.png)\n    sock.setsockopt_string(zmq.SUBSCRIBE, '')  ![3](assets/3.png)\n    sock.bind('tcp://*:5555')  ![4](assets/4.png)\n    with suppress(asyncio.CancelledError):\n        while data := await sock.recv_json():  ![5](assets/5.png)\n            print(data)\n            for q in connections:\n                await q.put(data)  ![6](assets/6.png)\n    sock.close()\n\nasync def feed(request):  ![7](assets/7.png)\n    queue = asyncio.Queue()\n    connections.add(queue)  ![8](assets/8.png)\n    with suppress(asyncio.CancelledError):\n        async with sse_response(request) as resp:  ![9](assets/9.png)\n            while data := await queue.get():  ![10](assets/10.png)\n                print('sending data:', data)\n                resp.send(json.dumps(data))  ![11](assets/11.png)\n    return resp\n\nasync def index(request):  ![12](assets/12.png)\n    return aiohttp.web.FileResponse('./charts.html')\n\nasync def start_collector(app):  ![13](assets/13.png)\n    app['collector'] = app.loop.create_task(collector())\n\nasync def stop_collector(app):\n    print('Stopping collector...')\n    app['collector'].cancel()  ![14](assets/14.png)\n    await app['collector']\n    ctx.term()\n\nif __name__ == '__main__':\n    app = web.Application()\n    app.router.add_route('GET', '/', index)\n    app.router.add_route('GET', '/feed', feed)\n    app.on_startup.append(start_collector)  ![15](assets/15.png)\n    app.on_cleanup.append(stop_collector)\n    web.run_app(app, host='127.0.0.1', port=8088)\n```", "```py\n<snip>\nvar evtSource = new EventSource(\"/feed\");  ![1](assets/1.png)\nevtSource.onmessage = function(e) {\n    var obj = JSON.parse(e.data);  ![2](assets/2.png)\n    if (!(obj.color in cpu)) {\n        add_timeseries(cpu, cpu_chart, obj.color);\n    }\n    if (!(obj.color in mem)) {\n        add_timeseries(mem, mem_chart, obj.color);\n    }\n    cpu[obj.color].append(\n        Date.parse(obj.timestamp), obj.cpu);  ![3](assets/3.png)\n    mem[obj.color].append(\n        Date.parse(obj.timestamp), obj.mem);\n};\n<snip>\n```", "```py\n$ metric-server.py\n======== Running on http://127.0.0.1:8088 ========\n(Press CTRL+C to quit)\n\n```", "```py\n$ backend-app.py --color red &\n$ backend-app.py --color blue --leak 10000 &\n$ backend-app.py --color green --leak 100000 &\n\n```", "```py\n$ docker run -d --rm -p 55432:5432 postgres\n\n```", "```py\n# asyncpg-basic.py\nimport asyncio\nimport asyncpg\nimport datetime\nfrom util import Database  ![1](assets/1.png)\n\nasync def main():\n    async with Database('test', owner=True) as conn:  ![2](assets/2.png)\n        await demo(conn)\n\nasync def demo(conn: asyncpg.Connection):\n    await conn.execute('''\n CREATE TABLE users(\n id serial PRIMARY KEY,\n name text,\n dob date\n )'''\n    )  ![3](assets/3.png)\n\n    pk = await conn.fetchval(  ![4](assets/4.png)\n        'INSERT INTO users(name, dob) VALUES($1, $2) '\n        'RETURNING id', 'Bob', datetime.date(1984, 3, 1)\n    )\n\n    async def get_row():  ![5](assets/5.png)\n        return await conn.fetchrow(  ![6](assets/6.png)\n            'SELECT * FROM users WHERE name = $1',\n            'Bob'\n        )\n    print('After INSERT:', await get_row())  ![7](assets/7.png)\n\n    await conn.execute(\n        'UPDATE users SET dob = $1 WHERE id=1',\n        datetime.date(1985, 3, 1)  ![8](assets/8.png)\n    )\n    print('After UPDATE:', await get_row())\n\n    await conn.execute(\n        'DELETE FROM users WHERE id=1'\n    )\n    print('After DELETE:', await get_row())\n\nif __name__ == '__main__':\n    asyncio.run(main())\n```", "```py\n$ asyncpg-basic.py\nAfter INSERT: <Record id=1 name='Bob' dob=datetime.date(1984, 3, 1)>\nAfter UPDATE: <Record id=1 name='Bob' dob=datetime.date(1985, 3, 1)>\nAfter DELETE: None\n\n```", "```py\n# util.py\nimport argparse, asyncio, asyncpg\nfrom asyncpg.pool import Pool\n\nDSN = 'postgresql://{user}@{host}:{port}'\nDSN_DB = DSN + '/{name}'\nCREATE_DB = 'CREATE DATABASE {name}'\nDROP_DB = 'DROP DATABASE {name}'\n\nclass Database:\n    def __init__(self, name, owner=False, **kwargs):\n        self.params = dict(\n            user='postgres', host='localhost',\n            port=55432, name=name)  ![1](assets/1.png)\n        self.params.update(kwargs)\n        self.pool: Pool = None\n        self.owner = owner\n        self.listeners = []\n\n    async def connect(self) -> Pool:\n        if self.owner:\n            await self.server_command(\n                CREATE_DB.format(**self.params))  ![3](assets/3.png)\n\n        self.pool = await asyncpg.create_pool(  ![4](assets/4.png)\n            DSN_DB.format(**self.params))\n        return self.pool\n\n    async def disconnect(self):\n        \"\"\"Destroy the database\"\"\"\n        if self.pool:\n            releases = [self.pool.release(conn)\n                        for conn in self.listeners]\n            await asyncio.gather(*releases)\n            await self.pool.close()  ![5](assets/5.png)\n        if self.owner:\n            await self.server_command(  ![6](assets/6.png)\n                DROP_DB.format(**self.params))\n\n    async def __aenter__(self) -> Pool:  ![2](assets/2.png)\n        return await self.connect()\n\n    async def __aexit__(self, *exc):\n        await self.disconnect()\n\n    async def server_command(self, cmd):  ![7](assets/7.png)\n        conn = await asyncpg.connect(\n            DSN.format(**self.params))\n        await conn.execute(cmd)\n        await conn.close()\n\n    async def add_listener(self, channel, callback):  ![8](assets/8.png)\n        conn: asyncpg.Connection = await self.pool.acquire()\n        await conn.add_listener(channel, callback)\n        self.listeners.append(conn)\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--cmd', choices=['create', 'drop'])\n    parser.add_argument('--name', type=str)\n    args = parser.parse_args()\n    d = Database(args.name, owner=True)\n    if args.cmd == 'create':\n        asyncio.run(d.connect())\n    elif args.cmd == 'drop':\n        asyncio.run(d.disconnect())\n    else:\n        parser.print_help()\n```", "```py\n$ curl -d '{\"name\": \"Carol\", \"fav_dish\": \"SPAM Bruschetta\"}' \\\n    -H \"Content-Type: application/json\" \\\n    -X POST \\\n    http://localhost:8000/patron\n{\"msg\":\"ok\",\"id\":37}\n```", "```py\n$ curl -X GET http://localhost:8000/patron/37\n```", "```py\n{\"id\":37,\"name\":\"Carol\",\"fav_dish\":\"SPAM Bruschetta\"}\n```", "```py\n$ curl -d '{\"name\": \"Eric\", \"fav_dish\": \"SPAM Bruschetta\"}' \\\n    -H \"Content-Type: application/json\" \\\n    -X PUT \\\n    http://localhost:8000/patron/37\n$ curl -X GET http://localhost:8000/patron/37\n{\"msg\":\"ok\"}\n{\"id\":37,\"name\":\"Eric\",\"fav_dish\":\"SPAM Bruschetta\"}\n```", "```py\n$ curl -X DELETE http://localhost:8000/patron/37\n$ curl -X GET http://localhost:8000/patron/37\n{\"msg\":\"ok\"}\nnull\n```", "```py\n$ curl -X GET http://localhost:8000/patron/29\n$ curl -X GET http://localhost:8000/patron/29\n{\"id\":29,\"name\":\"John Cleese\",\"fav_dish\":\"Gravy on Toast\"}\n{\"id\":29,\"name\":\"John Cleese\",\"fav_dish\":\"Gravy on Toast\"}\n```", "```py\n$ sanic_demo.py\n2019-09-29 16:20:33 - (sanic)[DEBUG]:\n                 ▄▄▄▄▄\n        ▀▀▀██████▄▄▄       _______________\n      ▄▄▄▄▄  █████████▄  /                 \\\n     ▀▀▀▀█████▌ ▀▐▄ ▀▐█ |   Gotta go fast!  |\n   ▀▀█████▄▄ ▀██████▄██ | _________________/\n   ▀▄▄▄▄▄  ▀▀█▄▀█════█▀ |/\n        ▀▀▀▄  ▀▀███ ▀       ▄▄\n     ▄███▀▀██▄████████▄ ▄▀▀▀▀▀▀█▌\n   ██▀▄▄▄██▀▄███▀ ▀▀████      ▄██\n▄▀▀▀▄██▄▀▀▌████▒▒▒▒▒▒███     ▌▄▄▀\n▌    ▐▀████▐███▒▒▒▒▒▐██▌\n▀▄▄▄▄▀   ▀▀████▒▒▒▒▄██▀\n          ▀▀█████████▀\n        ▄▄██▀██████▀█\n      ▄██▀     ▀▀▀  █\n     ▄█             ▐▌\n ▄▄▄▄█▌              ▀█▄▄▄▄▀▀▄\n▌     ▐                ▀▀▄▄▄▀\n ▀▀▄▄▀\n\n2019-09-29 16:20:33 (sanic): Goin' Fast @ http://0.0.0.0:8000\n2019-09-29 16:20:33 (sanic): Starting worker [10366]  ![1](assets/1.png)\n2019-09-29 16:25:27 (perf): id=37 Cache miss  ![2](assets/2.png)\n2019-09-29 16:25:27 (perf): get Elapsed: 4.26 ms ![3](assets/3.png)\n2019-09-29 16:25:27 (perf): get Elapsed: 0.04 ms ![4](assets/4.png)\n```", "```py\n$ sanic_demo.py --port 8001\n<snip>\n2017-10-02 08:09:56 - (sanic): Goin' Fast @ http://0.0.0.0:8001\n2017-10-02 08:09:56 - (sanic): Starting worker [385]\n\n```", "```py\n$ curl -d '{\"name\": \"John Cleese\", \"fav_dish\": \"SPAM on toast\"}' \\\n    -H \"Content-Type: application/json\" \\\n    -X PUT \\\n    http://localhost:8000/patron/29\n{\"msg\":\"ok\"}\n```", "```py\n2019-10-02 08:35:49 - (perf)[INFO]: Got DB event:\n{\n    \"table\": \"patron\",\n    \"id\": 29,\n    \"type\": \"UPDATE\",\n    \"data\": {\n        \"old\": {\n            \"id\": 29,\n            \"name\": \"John Cleese\",\n            \"fav_dish\": \"Gravy on Toast\"\n        },\n        \"new\": {\n            \"id\": 29,\n            \"name\": \"John Cleese\",\n            \"fav_dish\": \"SPAM on toast\"\n        },\n        \"diff\": {\n            \"fav_dish\": \"SPAM on toast\"\n        }\n    }\n}\n```", "```py\n$ curl -X GET http://localhost:8001/patron/29\n{\"id\":29,\"name\":\"John Cleese\",\"fav_dish\":\"SPAM on toast\"}\n```", "```py\n2019-10-02 08:46:45 - (perf)[INFO]: get Elapsed: 0.04 ms\n```", "```py\n# sanic_demo.py\nimport argparse\nfrom sanic import Sanic\nfrom sanic.views import HTTPMethodView\nfrom sanic.response import json\nfrom util import Database  ![1](assets/1.png)\nfrom perf import aelapsed, aprofiler  ![2](assets/2.png)\nimport model\n\napp = Sanic()  ![3](assets/3.png)\n\n@aelapsed\nasync def new_patron(request):  ![4](assets/4.png)\n    data = request.json  ![5](assets/5.png)\n    id = await model.add_patron(app.pool, data)  ![6](assets/6.png)\n    return json(dict(msg='ok', id=id))  ![7](assets/7.png)\n\nclass PatronAPI(HTTPMethodView, metaclass=aprofiler):  ![8](assets/8.png)\n    async def get(self, request, id):\n        data = await model.get_patron(app.pool, id)  ![9](assets/9.png)\n        return json(data)\n\n    async def put(self, request, id):\n        data = request.json\n        ok = await model.update_patron(app.pool, id, data)\n        return json(dict(msg='ok' if ok else 'bad'))  ![10](assets/10.png)\n\n    async def delete(self, request, id):\n        ok = await model.delete_patron(app.pool, id)\n        return json(dict(msg='ok' if ok else 'bad'))\n\n@app.listener('before_server_start')  ![11](assets/11.png)\nasync def db_connect(app, loop):\n    app.db = Database('restaurant', owner=False)  ![12](assets/12.png)\n    app.pool = await app.db.connect()  ![13](assets/13.png)\n    await model.create_table_if_missing(app.pool)  ![14](assets/14.png)\n    await app.db.add_listener('chan_patron', model.db_event)  ![15](assets/15.png)\n\n@app.listener('after_server_stop')  ![16](assets/16.png)\nasync def db_disconnect(app, loop):\n    await app.db.disconnect()\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--port', type=int, default=8000)\n    args = parser.parse_args()\n    app.add_route(\n        new_patron, '/patron', methods=['POST'])  ![17](assets/17.png)\n    app.add_route(\n        PatronAPI.as_view(), '/patron/<id:int>')  ![18](assets/18.png)\n    app.run(host=\"0.0.0.0\", port=args.port)\n```", "```py\n# model.py\nimport logging\nfrom json import loads, dumps\nfrom triggers import (\n    create_notify_trigger, add_table_triggers)  ![1](assets/1.png)\nfrom boltons.cacheutils import LRU  ![2](assets/2.png)\n\nlogger = logging.getLogger('perf')\n\nCREATE_TABLE = ('CREATE TABLE IF NOT EXISTS patron('  ![3](assets/3.png)\n                'id serial PRIMARY KEY, name text, '\n                'fav_dish text)')\nINSERT = ('INSERT INTO patron(name, fav_dish) '\n          'VALUES ($1, $2) RETURNING id')\nSELECT = 'SELECT * FROM patron WHERE id = $1'\nUPDATE = 'UPDATE patron SET name=$1, fav_dish=$2 WHERE id=$3'\nDELETE = 'DELETE FROM patron WHERE id=$1'\nEXISTS = \"SELECT to_regclass('patron')\"\n\nCACHE = LRU(max_size=65536)  ![4](assets/4.png)\n\nasync def add_patron(conn, data: dict) -> int:  ![5](assets/5.png)\n    return await conn.fetchval(\n        INSERT, data['name'], data['fav_dish'])\n\nasync def update_patron(conn, id: int, data: dict) -> bool:\n    result = await conn.execute(  ![6](assets/6.png)\n        UPDATE, data['name'], data['fav_dish'], id)\n    return result == 'UPDATE 1'\n\nasync def delete_patron(conn, id: int):  ![7](assets/7.png)\n    result = await conn.execute(DELETE, id)\n    return result == 'DELETE 1'\n\nasync def get_patron(conn, id: int) -> dict:  ![8](assets/8.png)\n    if id not in CACHE:\n        logger.info(f'id={id} Cache miss')\n        record = await conn.fetchrow(SELECT, id)  ![9](assets/9.png)\n        CACHE[id] = record and dict(record.items())\n    return CACHE[id]\n\ndef db_event(conn, pid, channel, payload):  ![10](assets/10.png)\n    event = loads(payload)  ![11](assets/11.png)\n    logger.info('Got DB event:\\n' + dumps(event, indent=4))\n    id = event['id']\n    if event['type'] == 'INSERT':\n        CACHE[id] = event['data']\n    elif event['type'] == 'UPDATE':\n        CACHE[id] = event['data']['new']  ![12](assets/12.png)\n    elif event['type'] == 'DELETE':\n        CACHE[id] = None\n\nasync def create_table_if_missing(conn):  ![13](assets/13.png)\n    if not await conn.fetchval(EXISTS):\n        await conn.fetchval(CREATE_TABLE)\n        await create_notify_trigger(\n            conn, channel='chan_patron')\n        await add_table_triggers(\n            conn, table='patron')\n```"]