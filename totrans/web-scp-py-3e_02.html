<html><head></head><body><section data-pdf-bookmark="Chapter 1. How the Internet Works" data-type="chapter" epub:type="chapter"><div class="chapter" id="c-1">&#13;
<h1><span class="label">Chapter 1. </span>How the Internet Works</h1>&#13;
&#13;
<p>I have met very few people in my life who truly know how the internet works, and I am certainly not one of them.</p>&#13;
&#13;
<p>The vast majority of us are making do with a set of mental abstractions that allow us to use the internet just as much as we need to. Even for programmers, these abstractions might extend only as far as what was required for them to solve a particularly tricky problem once in their career.</p>&#13;
&#13;
<p>Due to limitations in page count and the knowledge of the author, this chapter must also rely on these sorts of abstractions. It describes the mechanics of the internet and web applications, to the extent needed to scrape the web (and then, perhaps a little more).</p>&#13;
&#13;
<p>This chapter, in a sense, describes the world in which web scrapers operate: the customs, practices, protocols, and standards that will be revisited throughout the book.</p>&#13;
&#13;
<p>When you type a URL into the address bar of your web browser and hit Enter, interactive text, images, and media spring up as if by magic. This same magic is happening for billions of other people every day. They’re visiting the same websites, using the same applications—often getting media and text customized just for them.</p>&#13;
&#13;
<p>And these billions of people are all using different types of devices and software applications, written by different developers at different (often competing!) <span class="keep-together">companies.</span></p>&#13;
&#13;
<p>Amazingly, there is no all-powerful governing body regulating the internet and coordinating its development with any sort of legal force. Instead, different parts of the internet are governed by several different organizations that evolved over time on a somewhat ad hoc and opt-in basis.</p>&#13;
&#13;
<p>Of course, choosing <em>not</em> to opt into the standards that these organizations publish may result in your contributions to the internet simply...not working. If your website can’t be displayed in popular web browsers, people likely aren’t going to visit it. If the data your router is sending can’t be interpreted by any other router, that data will be ignored.</p>&#13;
&#13;
<p>Web scraping is, essentially, the practice of substituting a web browser for an application of your own design. Because of this, it’s important to understand the standards and frameworks that web browsers are built on. As a web scraper, you must both mimic and, at times, subvert the expected internet customs and practices.</p>&#13;
&#13;
<section data-pdf-bookmark="Networking" data-type="sect1"><div class="sect1" id="id1">&#13;
<h1>Networking</h1>&#13;
&#13;
<p>In the early days of the telephone system, each telephone was connected by a physical wire to a central switchboard. If you wanted to make a call to a nearby friend, you picked up the phone, asked the switchboard operator to connect you, and the switchboard operator physically created (via plugs and jacks) a dedicated connection between your phone and your friend’s phone.</p>&#13;
&#13;
<p>Long-distance calls were expensive and could take minutes to connect. Placing a long-distance call from Boston to Seattle would result in the coordination of switchboard operators across the United States creating a single enormous length of wire directly connecting your phone to the recipient’s.</p>&#13;
&#13;
<p>Today, rather than make a telephone call over a temporary dedicated connection, we can make a video call from our house to anywhere in the world across a persistent web of wires. The wire doesn’t tell the data where to go, the data guides itself, in a process <a contenteditable="false" data-primary="networks" data-secondary="packet switching" data-type="indexterm" id="id258"/><a contenteditable="false" data-primary="packet switching" data-type="indexterm" id="pckwch"/>called <em>packet switching</em>. Although many technologies over the years contributed to what we think of as “the internet,” packet switching is really the technology that single-handedly started it all.</p>&#13;
&#13;
<p>In a packet-switched network, the <a contenteditable="false" data-primary="networks" data-secondary="packets" data-type="indexterm" id="id259"/>message to be sent is divided into discrete ordered packets, each with its own sender and destination address. These packets are routed dynamically to any destination on the network, based on that address. Rather than being forced to blindly traverse the single dedicated connection from receiver to sender, the packets can take any path the network chooses. In fact, packets in the same message transmission might take different routes across the network and be reordered by the receiving computer when they arrive.</p>&#13;
&#13;
<p>If the old phone networks were like a zip line—taking passengers from a single destination at the top of a hill to a single destination at the bottom—then packet-switched networks are like a highway system, where cars going to and from multiple destinations are all able to use the same roads.</p>&#13;
&#13;
<p>A modern packet-switching network is usually <a contenteditable="false" data-primary="OSI (Open Systems Interconnection) model" data-secondary="packet-switched networks" data-type="indexterm" id="id260"/>described using the Open Systems Interconnection (OSI) model, which is composed of seven layers of routing, encoding, and error handling:</p>&#13;
&#13;
<ol>&#13;
	<li>Physical layer</li>&#13;
	<li>Data link layer</li>&#13;
	<li>Network layer</li>&#13;
	<li>Transport layer</li>&#13;
	<li>Session layer</li>&#13;
	<li>Presentation layer</li>&#13;
	<li>Application layer</li>&#13;
</ol>&#13;
&#13;
<p>Most web application developers spend their days entirely in layer 7, the application layer. This is also the layer where the most time is spent in this book. However, it is important to have at least conceptual knowledge of the other layers when scraping the web. For example, TLS fingerprinting, discussed in <a data-type="xref" href="ch17.html#c-17">Chapter 17</a>, is a web scraping detection method that involves the transport layer.</p>&#13;
&#13;
<p>In addition, knowing about all of the layers of data encapsulation and transmission can help troubleshoot errors in your web applications and web scrapers.</p>&#13;
&#13;
<section data-pdf-bookmark="Physical Layer" data-type="sect2"><div class="sect2" id="id2">&#13;
<h2>Physical Layer</h2>&#13;
&#13;
<p>The <em>physical layer</em> specifies <a contenteditable="false" data-primary="OSI (Open Systems Interconnection) model" data-secondary="physical layer" data-type="indexterm" id="id261"/><a contenteditable="false" data-primary="physical layer, OSI model" data-type="indexterm" id="id262"/>how information is physically transmitted with electricity over the Ethernet wire in your house (or on any local network). It defines things like the voltage levels that encode 1’s and 0’s, and how fast those voltages can be pulsed. It also defines how radio waves over Bluetooth and WiFi are interpreted.</p>&#13;
&#13;
<p>This layer does not involve any programming or digital instructions but is based purely on physics and electrical standards.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Data Link Layer" data-type="sect2"><div class="sect2" id="id3">&#13;
<h2>Data Link Layer</h2>&#13;
&#13;
<p>The <em>data link layer</em> specifies how information is transmitted between two nodes in a local <a contenteditable="false" data-primary="OSI (Open Systems Interconnection) model" data-secondary="data link layer" data-type="indexterm" id="id263"/><a contenteditable="false" data-primary="data link layer, OSI model" data-type="indexterm" id="id264"/>network, for example, between your computer and a router. It defines the beginning and ending of a single transmission and provides for error correction if the transmission is lost or garbled.</p>&#13;
&#13;
<p>At this layer, the packets are wrapped in an additional “digital envelope” containing routing information and are referred to as <em>frames</em>. When the information in the frame is no longer needed, it is unwrapped and sent across the network as a packet.</p>&#13;
&#13;
<p class="pagebreak-before">It’s important to note that, at the data link layer, all devices on a network are receiving the same data at all times—there’s no actual “switching” or control over where the data is going. However, devices that the data is not addressed to will generally ignore the data and wait until they get something that’s meant for them.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Network Layer" data-type="sect2"><div class="sect2" id="id4">&#13;
<h2>Network Layer</h2>&#13;
&#13;
<p>The <em>network layer</em> is where <a contenteditable="false" data-primary="OSI (Open Systems Interconnection) model" data-secondary="network layer" data-type="indexterm" id="id265"/><a contenteditable="false" data-primary="network layer, OSI model" data-type="indexterm" id="id266"/>packet switching, and therefore “the internet,” happens. This is the layer that allows packets from your computer to be forwarded by a router and reach devices beyond their immediate network.</p>&#13;
&#13;
<p>The network layer involves the Internet Protocol (IP) part <a contenteditable="false" data-primary="IP (Internet Protocol) network layer (OSI)" data-type="indexterm" id="id267"/><a contenteditable="false" data-primary="TCP/IP (Transmission Control Protocol/Internet Protocol) network layer (OSI)" data-type="indexterm" id="id268"/>of the Transmission Control Protocol/Internet Protocol (TCP/IP). IP is where we get IP addresses from. For instance, my IP address on the global internet is currently 173.48.178.92. This allows any computer in the world to send data to me and for me to send data to any other address from my own address.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Transport Layer" data-type="sect2"><div class="sect2" id="id5">&#13;
<h2>Transport Layer</h2>&#13;
&#13;
<p>Layer 4, the <em>transport layer</em>, concerns <a contenteditable="false" data-primary="OSI (Open Systems Interconnection) model" data-secondary="transport layer" data-type="indexterm" id="id269"/><a contenteditable="false" data-primary="transport layer, OSI model" data-type="indexterm" id="id270"/>itself with connecting a specific service or application running on a computer to a specific application running on another computer, rather than just connecting the computers themselves. It’s also responsible for any error correction or retrying needed in the stream of data.</p>&#13;
&#13;
<p>TCP, for example, is very picky and will keep requesting any missing packets until all of them are correctly received. TCP is often used for file transfers, where all packets must be correctly received in the right order for the file to work.</p>&#13;
&#13;
<p>In contrast, the User Datagram Protocol (UDP) will <a contenteditable="false" data-primary="UDP (User Datagram Protocol)" data-type="indexterm" id="id271"/><a contenteditable="false" data-primary="packet switching" data-startref="pckwch" data-type="indexterm" id="id272"/>happily skip over missing packets in order to keep the data streaming in. It’s often used for videoconferencing or audioconferencing, where a temporary drop in transmission quality is preferable to a lag in the conversation.</p>&#13;
&#13;
<p>Because different applications on your computer can have different data reliability needs at the same time (for instance, making a phone call while downloading a file), the transport layer is also where the port number comes in. The operating system assigns each application or service running on your computer to a specific port, from where it sends and receives data.</p>&#13;
&#13;
<p>This port is often written as a number after the IP address, separated by a colon. For example, 71.245.238.173:8080 indicates the application assigned by the operating system to port 8080 on the computer assigned by the network at IP address 71.245.238.173.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Session Layer" data-type="sect2"><div class="sect2" id="id6">&#13;
<h2>Session Layer</h2>&#13;
&#13;
<p>The <em>session layer</em> is responsible <a contenteditable="false" data-primary="OSI (Open Systems Interconnection) model" data-secondary="session layer" data-type="indexterm" id="id273"/><a contenteditable="false" data-primary="session layer, OSI model" data-type="indexterm" id="id274"/>for opening and closing a session between two applications. This session allows stateful information about what data has and hasn’t been sent, and who the computer is communicating with. The session generally stays open for as long as it takes to complete the data request, and then closes.</p>&#13;
&#13;
<p>The session layer allows for retrying a transmission in case of a brief crash or <span class="keep-together">disconnect.</span></p>&#13;
&#13;
<div data-type="note" epub:type="note">&#13;
<h1>Sessions Versus Sessions</h1>&#13;
&#13;
<p>Sessions in the session layer of the OSI model are different from sessions and session data that web developers usually talk about. Session variables in a web application are a concept in the application layer that are implemented by the web browser software.</p>&#13;
&#13;
<p>Session variables, in the application layer, stay in the browser for as long as they need to or until the user closes the browser window. In the session layer of the OSI model, the session usually only lasts for as long as it takes to transmit a single file!</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Presentation Layer" data-type="sect2"><div class="sect2" id="id7">&#13;
<h2>Presentation Layer</h2>&#13;
&#13;
<p>The <em>presentation layer</em> transforms <a contenteditable="false" data-primary="OSI (Open Systems Interconnection) model" data-secondary="presentation layer" data-type="indexterm" id="id275"/><a contenteditable="false" data-primary="presentation layer, OSI model" data-type="indexterm" id="id276"/>incoming data from character strings into a format that the application can understand and use. It is also responsible for character encoding and data compression. The presentation layer cares about whether incoming data received by the application represents a PNG file or an HTML file, and hands this file to the application layer accordingly.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Application Layer" data-type="sect2"><div class="sect2" id="id8">&#13;
<h2>Application Layer</h2>&#13;
&#13;
<p>The <em>application layer</em> interprets the data encoded by the presentation layer and uses it appropriately <a contenteditable="false" data-primary="OSI (Open Systems Interconnection) model" data-secondary="application layer" data-type="indexterm" id="id277"/><a contenteditable="false" data-primary="application layer, OSI model" data-type="indexterm" id="id278"/>for the application. I like to think of the presentation layer as being concerned with transforming and identifying things, while the application layer is concerned with “doing” things. For instance, HTTP with its methods and statuses is an application layer protocol. The more banal JSON and HTML (because they are file types that define how data is encoded) are presentation layer protocols.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="HTML" data-type="sect1"><div class="sect1" id="id9">&#13;
<h1>HTML</h1>&#13;
&#13;
<p>The primary function of a web browser is to <a contenteditable="false" data-primary="HTML (HyperText Markup Language)" data-type="indexterm" id="hmltyx"/>display HTML (HyperText Markup Language) documents. HTML documents are files that end in <em>.html</em> or, less frequently, <em>.htm</em>.</p>&#13;
&#13;
<p>Like text files, HTML files are encoded with plain-text characters, usually ASCII (see <a data-type="xref" href="ch10.html#ch10sec2">“Text Encoding and the Global Internet”</a>). This means that they can be opened and read with any text editor.</p>&#13;
&#13;
<p>This is an example of a simple HTML file:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
&lt;html&gt;&#13;
  &lt;head&gt;&#13;
    &lt;title&gt;A Simple Webpage&lt;/title&gt;&#13;
  &lt;/head&gt;&#13;
  &lt;body&gt;&#13;
    &lt;!-- This comment text is not displayed in the browser --&gt;&#13;
    &lt;h1&gt;Hello, World!&lt;/h1&gt;&#13;
  &lt;/body&gt;&#13;
&lt;/html&gt; </pre>&#13;
&#13;
<p>HTML files are a special type of XML (Extensible Markup Language) files. Each string beginning <a contenteditable="false" data-primary="HTML (HyperText Markup Language)" data-secondary="XML (Extensible Markup Language) and" data-type="indexterm" id="id279"/><a contenteditable="false" data-primary="XML (Extensible Markup Language)" data-type="indexterm" id="id280"/>with a <code>&lt;</code> and ending with a <code>&gt;</code> is called a <em>tag</em>.</p>&#13;
&#13;
<p>The XML standard defines the concept of opening or <em>starting tags</em> like <code>&lt;html&gt;</code> and closing or <em>ending tags</em> that begin with a <code>&lt;/</code>, like <code>&lt;/html&gt;</code>. Between the starting and ending tags is the <em>content</em> of the tags.</p>&#13;
&#13;
<p>In the case where it’s unnecessary for tags to have any content at all, you may see a tag that acts as its own closing tag. This is called an empty element tag or a self-closing tag and looks like:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
&lt;p /&gt;</pre>&#13;
&#13;
<p>Tags can also have attributes in the form of <code>attributeKey="attribute value"</code>, for example:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
&lt;div class="content"&gt;&#13;
  Lorem ipsum dolor sit amet, consectetur adipiscing elit&#13;
&lt;/div&gt;&#13;
</pre>&#13;
&#13;
<p>Here, the <code>div</code> tag has the attribute <code>class</code> which has the value <code>main-content</code>.</p>&#13;
&#13;
<p>An HTML <em>element</em> has a starting tag with some optional attributes, some content, and a closing tag. An element can also contain multiple other elements, in which case they are <em>nested</em> elements.</p>&#13;
&#13;
<p>While XML defines these basic concepts of tags, content, attributes, and values, HTML defines what those tags can and can’t be, what they can and cannot contain, and how they must be interpreted and displayed by the browser.</p>&#13;
&#13;
<p>For example, the HTML standard defines the usage of the <code>class</code> <em>attribute</em> and the <code>id</code> <em>attribute</em>, which are often used to organize and control the display of HTML <span class="keep-together">elements:</span></p>&#13;
&#13;
<pre class="pagebreak-before" data-type="programlisting">&#13;
&lt;h1 id="main-title"&gt;Some Title&lt;/h1&gt;&#13;
&lt;div class="content"&gt;&#13;
  Lorem ipsum dolor sit amet, consectetur adipiscing elit&#13;
&lt;/div&gt;</pre>&#13;
&#13;
<p>As a rule, multiple elements on the page can contain the same <code>class</code> value; however, any value in the <code>id</code> field must be unique on that page. So multiple elements could have the <code>class content</code>, but there can only be one element with the <code>id main-title</code>.</p>&#13;
&#13;
<p>How the elements in an HTML document are displayed in the web browser is entirely dependent on how the web browser, as a piece of software, is programmed. If one web browser is programmed to display an element differently than another web browser, this will result in inconsistent experiences for users of different web <span class="keep-together">browsers.</span></p>&#13;
&#13;
<p>For this reason, it’s important to coordinate <a contenteditable="false" data-primary="HTML (HyperText Markup Language)" data-secondary="W3C (World Wide Web Consortium) and" data-type="indexterm" id="id281"/><a contenteditable="false" data-primary="W3C (World Wide Web Consortium), HTML and" data-type="indexterm" id="id282"/>exactly what the HTML tags are supposed to do and codify this into a single standard. The HTML standard is currently controlled by the World Wide Web Consortium (W3C). The current specification for all HTML tags can be found at <a href="https://html.spec.whatwg.org/multipage/"><em class="hyperlink">https://html.spec.whatwg.org/multipage/</em></a>.</p>&#13;
&#13;
<p>However, the formal W3C HTML standard is probably not the best place to learn HTML if you’ve never encountered it. A large part of web scraping involves reading and interpreting raw HTML files found on the web. If you’ve never dealt with HTML before, I highly recommend a book like <a class="orm:hideurl" href="https://www.oreilly.com/library/view/html-css/9781449381943/"><em>HTML &amp; CSS: The Good Parts</em></a> to get familiar with some of the more common HTML tags.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="CSS" data-type="sect1"><div class="sect1" id="id10">&#13;
<h1>CSS</h1>&#13;
&#13;
<p>Cascading Style Sheets (CSS) define the <a contenteditable="false" data-primary="HTML (HyperText Markup Language)" data-startref="hmltyx" data-type="indexterm" id="id283"/><a contenteditable="false" data-primary="Cascading Style Sheets (CSS)" data-see="CSS (Cascading Style Sheets)" data-type="indexterm" id="id284"/><a contenteditable="false" data-primary="CSS (Cascading Style Sheets)" data-type="indexterm" id="csscss"/><a contenteditable="false" data-primary="HTML (HyperText Markup Language)" data-secondary="CSS" data-see="CSS (Cascading Style Sheets)" data-type="indexterm" id="id285"/>appearance of HTML elements on a web page. CSS defines things like layout, colors, position, size, and other properties that transform a boring HTML page with browser-defined default styles into something more appealing for a modern web viewer.</p>&#13;
&#13;
<p>Using the HTML example from earlier:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
&lt;html&gt;&#13;
  &lt;head&gt;&#13;
    &lt;title&gt;A Simple Webpage&lt;/title&gt;&#13;
  &lt;/head&gt;&#13;
  &lt;body&gt;&#13;
    &lt;!-- This comment text is not displayed in the browser --&gt;&#13;
    &lt;h1&gt;Hello, World!&lt;/h1&gt;&#13;
  &lt;/body&gt;&#13;
&lt;/html&gt; &#13;
</pre>&#13;
&#13;
<p class="pagebreak-before">some corresponding CSS might be:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
h1 {&#13;
  font-size: 20px;&#13;
  color: green;&#13;
}</pre>&#13;
&#13;
<p>This CSS will set the <code>h1</code> tag’s content font size to be 20 pixels and display it in green text.</p>&#13;
&#13;
<p>The <code>h1</code> part of this CSS is called the <em>selector</em> or the CSS selector. This CSS selector indicates that the CSS inside the curly braces will be applied to the content of any <code>h1</code> tags.</p>&#13;
&#13;
<p>CSS selectors can also be written to apply only to elements with certain <code>class</code> or <code>id</code> attributes. For example, using the HTML:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
&lt;h1 id="main-title"&gt;Some Title&lt;/h1&gt;&#13;
&lt;div class="content"&gt;&#13;
  Lorem ipsum dolor sit amet, consectetur adipiscing elit&#13;
&lt;/div&gt;</pre>&#13;
&#13;
<p>the corresponding CSS might be:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
h1#main-title {&#13;
  font-size: 20px;&#13;
}&#13;
&#13;
div.content {&#13;
  color: green;&#13;
}&#13;
</pre>&#13;
&#13;
<p>A <code>#</code> is used to indicate the value of an <code>id</code> attribute, and a <code>.</code> is used to indicate the value of a <code>class</code> attribute.</p>&#13;
&#13;
<p>If it’s unimportant what the value of the tag is, the tag name can be omitted entirely. For instance, this CSS would turn the contents of any element having the class content green:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
.content {&#13;
  color: green;&#13;
}</pre>&#13;
&#13;
<p>CSS data can be contained either in the HTML itself or in a separate CSS file with a <em>.css</em> file extension. CSS in the HTML file is placed inside <code>&lt;style&gt;</code> tags in the head of the HTML document:</p>&#13;
&#13;
<pre class="pagebreak-before" data-type="programlisting">&#13;
&lt;html&gt;&#13;
  &lt;head&gt;&#13;
    &lt;style&gt;&#13;
      .content {&#13;
        color: green;&#13;
      }&#13;
    &lt;/style&gt;&#13;
...</pre>&#13;
&#13;
<p>More commonly, you’ll see CSS being imported in the head of the document using the <code>link</code> tag:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
&lt;html&gt;&#13;
  &lt;head&gt;&#13;
  &lt;link rel="stylesheet" href="mystyle.css"&gt;&#13;
...&#13;
</pre>&#13;
&#13;
<p>As a web scraper, you won’t often find yourself writing style sheets to make the HTML pretty. However, it is important to be able to read and recognize how an HTML page is being transformed by the CSS in order to relate what you’re seeing in your web browser to what you’re seeing in code.</p>&#13;
&#13;
<p>For instance, you may be confused when an HTML element doesn’t appear on the page. When you read the element’s applied CSS, you see:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
.mystery-element {&#13;
    display: none;&#13;
}</pre>&#13;
&#13;
<p>This sets the <code>display</code> attribute of the element to <code>none</code>, hiding it from the page.</p>&#13;
&#13;
<p>If you’ve never encountered CSS before, you likely won’t need to study it in any depth in order to scrape the web, but you should be comfortable with its syntax and note the CSS rules that are <a contenteditable="false" data-primary="CSS (Cascading Style Sheets)" data-startref="csscss" data-type="indexterm" id="id286"/>mentioned in this book.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="JavaScript" data-type="sect1"><div class="sect1" id="id11">&#13;
<h1>JavaScript</h1>&#13;
&#13;
<p>When a client makes a request to a web <a contenteditable="false" data-primary="JavaScript" data-type="indexterm" id="id287"/><a contenteditable="false" data-primary="server-side code" data-type="indexterm" id="id288"/><a contenteditable="false" data-primary="HTML (HyperText Markup Language)" data-secondary="JavaScript and" data-type="indexterm" id="htmljsc"/>server for a particular web page, the web server executes some code to create the web page that it sends back. This code, called <em>server-side code</em>, can be as simple as retrieving a static HTML file and sending it on. Or, it can be a complex application written in Python (the best language), Java, PHP, or any number of common server-side programming languages.</p>&#13;
&#13;
<p>Ultimately, this server-side code creates some sort of stream of data that gets sent to the browser and displayed. But what if you want some type of interaction or <span class="keep-together">behavior—a</span> text change or a drag-and-drop element, for example—to happen without going back to the server to run more code? For this, you use <em>client-side code</em>.</p>&#13;
&#13;
<p class="pagebreak-before">Client-side code is <a contenteditable="false" data-primary="client-side code" data-type="indexterm" id="id289"/>any code that is sent over by a web server but actually executed by the client’s browser. In the olden days of the internet (pre-mid-2000s), client-side code was written in a number of languages. You may remember Java applets and Flash applications, for example. But JavaScript emerged as the lone option for client-side code for a simple reason: it was the only language supported by the browsers themselves, without the need to download and update separate software (like Adobe Flash Player) in order to run the programs.</p>&#13;
&#13;
<p>JavaScript originated in the mid-90s as a new <a contenteditable="false" data-primary="Netscape Navigator" data-type="indexterm" id="id290"/><a contenteditable="false" data-primary="Internet Explorer" data-type="indexterm" id="id291"/>feature in Netscape Navigator. It was quickly adopted by Internet Explorer, making it the standard for both major web browsers at the time.</p>&#13;
&#13;
<p>Despite the name, JavaScript has almost nothing to do with Java, the server-side programming language. Aside from a small handful of superficial syntactic similarities, they are extremely dissimilar languages.</p>&#13;
&#13;
<p>In 1996, Netscape (the creator of JavaScript) and Sun Microsystems (the creator of Java) did a license agreement allowing Netscape to use the name “JavaScript,” <span class="keep-together">anticipating</span> some further collaboration <a href="https://www.infoworld.com/article/2653798/javascript-creator-ponders-past--future.html">between the two languages</a>. However, this collaboration never happened, and it’s been a confusing misnomer ever since.</p>&#13;
&#13;
<p>Although it had an uncertain start as a scripting language for a now-defunct web browser, JavaScript is now the most popular programming language in the world. This popularity is boosted by the fact that it can also be used server-side, using Node.js. But its popularity is certainly cemented by the fact that it’s the only client-side programming language available.</p>&#13;
&#13;
<p>JavaScript is embedded into HTML pages using the <code>&lt;script&gt;</code> tag. The JavaScript code can be inserted as content:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
&lt;script&gt;&#13;
  alert('Hello, world!');&#13;
&lt;/script&gt;&#13;
</pre>&#13;
&#13;
<p>Or it can be referenced in a separate file using the <code>src</code> attribute:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
&lt;script src="someprogram.js"&gt;&lt;/script&gt;</pre>&#13;
&#13;
<p>Unlike HTML and CSS, you likely won’t need to read or write JavaScript while scraping the web, but it is handy to at least get a feel for what it looks like. It can sometimes contain useful data. For example:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
&lt;script&gt;&#13;
  const data = '{"some": 1, "data": 2, "here": 3}';&#13;
&lt;/script&gt;</pre>&#13;
&#13;
<p>Here, a JavaScript variable is being declared with the keyword <code>const</code> (which stands for “constant”) and is being set to a JSON-formatted string containing some data, which can be parsed by a web scraper directly.</p>&#13;
&#13;
<p>JSON (JavaScript Object Notation) is a text format that contains human-readable data, is easily parsed by web scrapers, and is ubiquitous on the web. I will discuss it further in <a data-type="xref" href="ch15.html#c-15">Chapter 15</a>.</p>&#13;
&#13;
<p>You may also see JavaScript making a request to a different source entirely for data:</p>&#13;
&#13;
<pre data-type="programlisting">&#13;
&lt;script&gt;&#13;
  fetch('http://example.com/data.json')&#13;
    .then((response) =&gt; {&#13;
      console.log(response.json());&#13;
    });&#13;
&lt;/script&gt;&#13;
</pre>&#13;
&#13;
<p>Here, JavaScript is creating a request to <code>http://example.com/data.json</code> and, after the response is received, logging it to the console (more about the “console” in the next section).</p>&#13;
&#13;
<p>JavaScript was originally created to provide dynamic interactivity and animation in an otherwise static web. However, today, not all dynamic behavior is created by JavaScript. HTML and CSS also have some features that allow them to change the content on the page.</p>&#13;
&#13;
<p>For example, CSS keyframe animation can allow elements to move, change color, change size, or undergo other transformations when the user clicks on or hovers over that element.</p>&#13;
&#13;
<p>Recognizing how the (often literally) moving parts of a website are put together can help you avoid wild goose chases <a contenteditable="false" data-primary="HTML (HyperText Markup Language)" data-secondary="JavaScript and" data-startref="htmljsc" data-type="indexterm" id="id292"/>when you’re trying to locate data.</p>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="Watching Websites with Developer Tools" data-type="sect1"><div class="sect1" id="id12">&#13;
<h1>Watching Websites with Developer Tools</h1>&#13;
&#13;
<p>Like a jeweler’s loupe or a cardiologist’s <a contenteditable="false" data-primary="developer tools" data-secondary="accessing" data-type="indexterm" id="dvpcss"/>stethoscope, your browser’s <em>developer tools</em> are essential to the practice of web scraping. To collect data from a website, you have to know how it’s put together. The developer tools show you just that.</p>&#13;
&#13;
<p>Throughout this book, I will use developer tools as shown in Google Chrome. However, the developer tools in Firefox, Microsoft Edge, and other browsers are all very similar to each other.</p>&#13;
&#13;
<p>To access the developer tools in your browser’s menu, use the following instructions:</p>&#13;
&#13;
<p><strong>Chrome</strong></p>&#13;
&#13;
<p>View→ Developer → Developer Tools</p>&#13;
&#13;
<p class="pagebreak-before"><strong>Safari</strong></p>&#13;
&#13;
<p>Safari → Preferences → Advanced → Check “Show Develop menu in menu bar”</p>&#13;
&#13;
<p>Then, using the Develop menu: Develop → Show web inspector</p>&#13;
&#13;
<p><strong>Microsoft Edge</strong></p>&#13;
&#13;
<p>Using the menu: Tools → Developer → Developer Tools</p>&#13;
&#13;
<p><strong>Firefox</strong></p>&#13;
&#13;
<p>Tools → Browser Tools → Web Developer Tools</p>&#13;
&#13;
<p>Across all browsers, the keyboard shortcut for opening the developer tools is the same, and depending on your operating system.</p>&#13;
&#13;
<p><strong>Mac</strong></p>&#13;
&#13;
<p>Option + Command + I</p>&#13;
&#13;
<p><strong>Windows</strong></p>&#13;
&#13;
<p>CTRL + Shift + I</p>&#13;
&#13;
<p>When web scraping, you’ll likely spend most of your time in the Network tab (shown in <a data-type="xref" href="#fig-1-1">Figure 1-1</a>) and the Elements tab.</p>&#13;
&#13;
<figure><div class="figure" id="fig-1-1"><img alt="" class="iimageschrome_developer_toolspng" src="assets/wsp3_0101.png"/>&#13;
<h6><span class="label">Figure 1-1. </span>The Chrome Developer tools showing a page load from Wikipedia</h6>&#13;
</div></figure>&#13;
&#13;
<p>The Network tab shows all of the requests made by the page as the page is loading. If you’ve never used it before, you might be in for a surprise! It’s common for complex pages to make dozens or even hundreds of requests for assets as they’re loading. In some cases, the pages may even continue to make steady streams of requests for the duration of your stay on them. For instance, they may be sending data to action tracking <a contenteditable="false" data-primary="developer tools" data-secondary="accessing" data-startref="dvpcss" data-type="indexterm" id="id293"/>software, or polling for updates.</p>&#13;
&#13;
<div data-type="note" epub:type="note">&#13;
<h1>Don’t See Anything in the Network Tab?</h1>&#13;
&#13;
<p>Note that the developer tools <a contenteditable="false" data-primary="developer tools" data-secondary="Network tab" data-type="indexterm" id="dvntb"/><a contenteditable="false" data-primary="Network tab" data-type="indexterm" id="nwktb"/>must be open <em>while</em> the page is making its requests in order for those requests to be captured. If you load a page without having the developer tab open, and then decide to inspect it by opening the developer tools, you may want to refresh the page to reload it and see the requests it is making.</p>&#13;
</div>&#13;
&#13;
<p>If you click on a single network request in the Network tab, you’ll see all of the data associated with that request. The layout of this network request inspection tool differs slightly from browser to browser, but generally allows you to see:</p>&#13;
&#13;
<ul>&#13;
	<li>The URL the request was sent to</li>&#13;
	<li>The HTTP method used</li>&#13;
	<li>The response status</li>&#13;
	<li>All headers and cookies associated with the request</li>&#13;
	<li>The payload  </li>&#13;
	<li>The response</li>&#13;
</ul>&#13;
&#13;
<p>This information is useful for writing web scrapers that replicate these requests in order to fetch the same data the page is fetching.</p>&#13;
&#13;
<p>The Elements tab (see Figures <a data-type="xref" data-xrefstyle="select:labelnumber" href="#fig-1-2">1-2</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#fig-1-3">1-3</a>) is used to examine the structure and contents of HTML files. It’s extremely handy for examining specific pieces of data on a page in order to locate the HTML tags surrounding that data and write scrapers to grab it.</p>&#13;
&#13;
<p>As you hover over the text of each HTML element in the Elements tab, you’ll see the corresponding element on the page visually highlight in the browser. Using this tool is a great way to explore the pages and develop a deeper understanding of how they’re constructed (<a data-type="xref" href="#fig-1-3">Figure 1-3</a>).</p>&#13;
&#13;
<figure><div class="figure" id="fig-1-2"><img alt="" class="iinspect_elementpng" src="assets/wsp3_0102.png"/>&#13;
<h6><span class="label">Figure 1-2. </span>Right-click on any piece of text or data and select Inspect to view the elements surrounding that data in the Elements tab</h6>&#13;
</div></figure>&#13;
&#13;
<figure><div class="figure" id="fig-1-3"><img alt="" class="iimageswswp3_0103png" src="assets/wsp3_0103.png"/>&#13;
<h6><span class="label">Figure 1-3. </span>Hovering over the element in the HTML will highlight the corresponding structure on the page</h6>&#13;
</div></figure>&#13;
&#13;
<p>You don’t need to be an expert <a contenteditable="false" data-primary="developer tools" data-secondary="Network tab" data-startref="dvntb" data-type="indexterm" id="id294"/><a contenteditable="false" data-primary="Network tab" data-startref="nwktb" data-type="indexterm" id="id295"/>on the internet, networking, or even programming to begin scraping the web. However, having a basic understanding of how the pieces fit together, and how your browser’s developer tools show those pieces, is essential.</p>&#13;
</div></section>&#13;
</div></section></body></html>