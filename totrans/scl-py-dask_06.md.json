["```py\nfrom dask.distributed import Client\nclient = Client()\n\ndef slow(x):\n    time.sleep(3 * x)\n    return 3 * x\n\nslow_future = client.submit(slow, 1)\nslow_futures = client.map(slow, range(1, 5))\n```", "```py\nmyfuture = client.submit(slow, 5) # Starts running\nmyfuture = None # future may be GCd and then stop since there are no other references\n\nmyfuture = client.submit(slow, 5) # Starts running\ndel myfuture # future may be GCd and then stop since there are no other references\n\nmyfuture = client.submit(slow, 5) # Starts running\n# Future stops running, any other references point to canceled future\nmyfuture.cancel()\n```", "```py\nfrom dask.distributed import fire_and_forget\n\ndef do_some_io(data):\n    \"\"\"\n Do some io we don't need to block on :)\n \"\"\"\n    import requests\n    return requests.get('https://httpbin.org/get', params=data)\n\ndef business_logic():\n    # Make a future, but we don't really care about its result, just that it\n    # happens\n    future = client.submit(do_some_io, {\"timbit\": \"awesome\"})\n    fire_and_forget(future)\n\nbusiness_logic()\n```", "```py\nfuture = client.submit(do_some_io, {\"timbit\": \"awesome\"})\nfuture.result()\n```", "```py\nfor f in futures:\n    time.sleep(2) # Business numbers logic\n    print(f.result())\n```", "```py\nfrom dask.distributed import as_completed\n\nfor f in as_completed(futures):\n    time.sleep(2) # Business numbers logic\n    print(f.result())\n```", "```py\nfrom dask.distributed import wait\nfrom dask.distributed.client import FIRST_COMPLETED\n\n# Will throw an exception if no future completes in time.\n# If it does not throw, the result has two lists:\n# The done list may return between one and all futures.\n# The not_done list may contain zero or more futures.\nfinished = wait(futures, 1, return_when=FIRST_COMPLETED)\n\n# Process the returned futures\nfor f in finished.done:\n    print(f.result())\n\n# Cancel the futures we don't need\nfor f in finished.not_done:\n    f.cancel()\n```", "```py\nmax_wait = 10\nstart = time.time()\n\nwhile len(futures) > 0 and time.time() - start < max_wait:\n    try:\n        finished = wait(futures, 1, return_when=FIRST_COMPLETED)\n        for f in finished.done:\n            print(f.result())\n        futures = finished.not_done\n    except TimeoutError:\n        True # No future finished in this cycle\n\n# Cancel any remaining futures\nfor f in futures:\n    f.cancel()\n```", "```py\nslow_future = client.submit(slow, 1)\nslow_delayed = dask.delayed(slow)(1)\n# Pretend we do some other work here\ntime.sleep(1)\nfuture_time = timeit.timeit(lambda: slow_future.result(), number=1)\ndelayed_time = timeit.timeit(lambda: dask.compute(slow_delayed), number=1)\nprint(\n    f\"\"\"So as you can see by the future time {future_time} v.s. {delayed_time}\n the future starts running right away.\"\"\"\n)\n```", "```py\nfrom dask.distributed import get_client\n\ndef nested(x):\n    client = get_client() # The client is serializable, so we use get_client\n    futures = client.map(slow, range(0, x))\n    r = 0\n    for f in as_completed(futures):\n        r = r + f.result()\n    return r\n\nf = client.submit(nested, 3)\nf.result()\n```"]