- en: Chapter 15\. More About Type Hints
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章。关于类型提示的更多内容
- en: I learned a painful lesson that for small programs, dynamic typing is great.
    For large programs you need a more disciplined approach. And it helps if the language
    gives you that discipline rather than telling you “Well, you can do whatever you
    want”.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我学到了一个痛苦的教训，对于小程序来说，动态类型很棒。对于大型程序，你需要更加纪律严明的方法。如果语言给予你这种纪律，而不是告诉你“嗯，你可以做任何你想做的事情”，那会更有帮助。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Guido van Rossum, a fan of Monty Python^([1](ch15.html#idm46582416463296))
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Guido van Rossum，蒙提·派森的粉丝^([1](ch15.html#idm46582416463296))
- en: 'This chapter is a sequel to [Chapter 8](ch08.html#type_hints_in_def_ch), covering
    more of Python’s gradual type system. The main topics are:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是[第8章](ch08.html#type_hints_in_def_ch)的续集，涵盖了更多关于Python渐进类型系统的内容。主要议题包括：
- en: Overloaded function signatures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载函数签名
- en: '`typing.TypedDict` for type hinting `dicts` used as records'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`typing.TypedDict`用于对作为记录使用的`dicts`进行类型提示'
- en: Type casting
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型转换
- en: Runtime access to type hints
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时访问类型提示
- en: Generic types
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用类型
- en: Declaring a generic class
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个通用类
- en: 'Variance: invariant, covariant, and contravariant types'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变异：不变、协变和逆变类型
- en: Generic static protocols
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用静态协议
- en: What’s New in This Chapter
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章的新内容
- en: This chapter is new in the second edition of *Fluent Python*. Let’s start with
    overloads.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是《流畅的Python》第二版中的新内容。让我们从重载开始。
- en: Overloaded Signatures
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重载签名
- en: Python functions may accept different combinations of arguments. The `@typing.overload`
    decorator allows annotating those different combinations. This is particularly
    important when the return type of the function depends on the type of two or more
    parameters.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Python函数可以接受不同组合的参数。`@typing.overload`装饰器允许对这些不同组合进行注释。当函数的返回类型取决于两个或更多参数的类型时，这一点尤为重要。
- en: 'Consider the `sum` built-in function. This is the text of `help(sum)`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑内置函数`sum`。这是`help(sum)`的文本：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `sum` built-in is written in C, but *typeshed* has overloaded type hints
    for it, in [*builtins.pyi*](https://fpy.li/15-2):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 内置函数`sum`是用C编写的，但*typeshed*为其提供了重载类型提示，在[*builtins.pyi*](https://fpy.li/15-2)中有：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First let’s look at the overall syntax of overloads. That’s all the code about
    the `sum` you’ll find in the stub file (*.pyi*). The implementation would be in
    a different file. The ellipsis (`...`) has no function other than to fulfill the
    syntactic requirement for a function body, similar to `pass`. So *.pyi* files
    are valid Python files.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们看看重载的整体语法。这是存根文件（*.pyi*）中关于`sum`的所有代码。实现将在另一个文件中。省略号（`...`）除了满足函数体的语法要求外没有其他作用，类似于`pass`。因此，*.pyi*文件是有效的Python文件。
- en: As mentioned in [“Annotating Positional Only and Variadic Parameters”](ch08.html#arbitrary_arguments_sec),
    the two leading underscores in `__iterable` are a PEP 484 convention for positional-only
    arguments that is enforced by Mypy. It means you can call `sum(my_list)`, but
    not `sum(__iterable = my_list)`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[“注释位置参数和可变参数”](ch08.html#arbitrary_arguments_sec)中提到的，`__iterable`中的两个下划线是PEP
    484对位置参数的约定，由Mypy强制执行。这意味着你可以调用`sum(my_list)`，但不能调用`sum(__iterable = my_list)`。
- en: The type checker tries to match the given arguments with each overloaded signature,
    in order. The call `sum(range(100), 1000)` doesn’t match the first overload, because
    that signature has only one parameter. But it matches the second.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 类型检查器尝试将给定的参数与每个重载签名进行匹配，按顺序。调用`sum(range(100), 1000)`不匹配第一个重载，因为该签名只有一个参数。但它匹配第二个。
- en: You can also use `@overload` in a regular Python module, by writing the overloaded
    signatures right before the function’s actual signature and implementation. [Example 15-1](#sum_overload_ex)
    shows how `sum` would appear annotated and implemented in a Python module.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在普通的Python模块中使用`@overload`，只需在函数的实际签名和实现之前写上重载的签名即可。[示例15-1](#sum_overload_ex)展示了如何在Python模块中注释和实现`sum`。
- en: 'Example 15-1\. *mysum.py*: definition of the `sum` function with overloaded
    signatures'
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例15-1。*mysum.py*：带有重载签名的`sum`函数的定义
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_more_about_type_hints_CO1-1)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_more_about_type_hints_CO1-1)'
- en: We need this second `TypeVar` in the second overload.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第二个重载中需要这第二个`TypeVar`。
- en: '[![2](assets/2.png)](#co_more_about_type_hints_CO1-2)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_more_about_type_hints_CO1-2)'
- en: 'This signature is for the simple case: `sum(my_iterable)`. The result type
    may be `T`—the type of the elements that `my_iterable` yields—or it may be `int`
    if the iterable is empty, because the default value of the `start` parameter is
    `0`.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个签名是针对简单情况的：`sum(my_iterable)`。结果类型可能是`T`——`my_iterable`产生的元素的类型，或者如果可迭代对象为空，则可能是`int`，因为`start`参数的默认值是`0`。
- en: '[![3](assets/3.png)](#co_more_about_type_hints_CO1-3)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_more_about_type_hints_CO1-3)'
- en: When `start` is given, it can be of any type `S`, so the result type is `Union[T,
    S]`. This is why we need `S`. If we reused `T`, then the type of `start` would
    have to be the same type as the elements of `Iterable[T]`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当给定`start`时，它可以是任何类型`S`，因此结果类型是`Union[T, S]`。这就是为什么我们需要`S`。如果我们重用`T`，那么`start`的类型将必须与`Iterable[T]`的元素类型相同。
- en: '[![4](assets/4.png)](#co_more_about_type_hints_CO1-4)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_more_about_type_hints_CO1-4)'
- en: The signature of the actual function implementation has no type hints.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 实际函数实现的签名没有类型提示。
- en: That’s a lot of lines to annotate a one-line function. Probably overkill, I
    know. At least it wasn’t a `foo` function.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了注释一行函数而写的很多行代码。我知道这可能有点过头了。至少这不是一个`foo`函数。
- en: If you want to learn about `@overload` by reading code, *typeshed* has hundreds
    of examples. On *typeshed*, the [stub file](https://fpy.li/15-3) for Python’s
    built-ins has 186 overloads as I write this—more than any other in the standard
    library.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想通过阅读代码了解`@overload`，*typeshed*有数百个示例。在*typeshed*上，Python内置函数的[存根文件](https://fpy.li/15-3)在我写这篇文章时有186个重载——比标准库中的任何其他函数都多。
- en: Take Advantage of Gradual Typing
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用渐进类型
- en: Aiming for 100% of annotated code may lead to type hints that add lots of noise
    but little value. Refactoring to simplify type hinting can lead to cumbersome
    APIs. Sometimes it’s better to be pragmatic and leave a piece of code without
    type hints.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 追求 100% 的注释代码可能会导致添加大量噪音但很少价值的类型提示。简化类型提示以简化重构可能会导致繁琐的 API。有时最好是务实一些，让一段代码没有类型提示。
- en: 'The handy APIs we call Pythonic are often hard to annotate. In the next section
    we’ll see an example: six overloads are needed to properly annotate the flexible
    `max` built-in function.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称之为 Pythonic 的方便 API 往往很难注释。在下一节中，我们将看到一个例子：需要六个重载才能正确注释灵活的内置 `max` 函数。
- en: Max Overload
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Max Overload
- en: It is difficult to add type hints to functions that leverage the powerful dynamic
    features of Python.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 给利用 Python 强大动态特性的函数添加类型提示是困难的。
- en: 'While studying typeshed, I found bug report [#4051](https://fpy.li/shed4051):
    Mypy failed to warn that it is illegal to pass `None` as one of the arguments
    to the built-in `max()` function, or to pass an iterable that at some point yields
    `None`. In either case, you get a runtime exception like this one:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究 typeshed 时，我发现了 bug 报告 [#4051](https://fpy.li/shed4051)：Mypy 没有警告说将 `None`
    作为内置 `max()` 函数的参数之一是非法的，或者传递一个在某个时刻产生 `None` 的可迭代对象也是非法的。在任一情况下，你会得到像这样的运行时异常：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The documentation of `max` starts with this sentence:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`max` 的文档以这句话开头：'
- en: Return the largest item in an iterable or the largest of two or more arguments.
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回可迭代对象中的最大项或两个或多个参数中的最大项。
- en: To me, that’s a very intuitive description.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，这是一个非常直观的描述。
- en: 'But if I must annotate a function described in those terms, I have to ask:
    which is it? An iterable or two or more arguments?'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我必须为以这些术语描述的函数注释，我必须问：它是哪个？一个可迭代对象还是两个或更多参数？
- en: 'The reality is more complicated because `max` also takes two optional keyword
    arguments: `key` and `default`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 实际情况更加复杂，因为 `max` 还接受两个可选关键字参数：`key` 和 `default`。
- en: I coded `max` in Python to make it easier to see the relationship between how
    it works and the overloaded annotations (the built-in `max` is in C); see [Example 15-2](#mymax_ex).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 Python 中编写了 `max` 来更容易地看到它的工作方式和重载注释之间的关系（内置的 `max` 是用 C 编写的）；参见 [Example 15-2](#mymax_ex)。
- en: 'Example 15-2\. *mymax.py*: Python rewrite of `max` function'
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 15-2\. *mymax.py*：`max` 函数的 Python 重写
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The focus of this example is not the logic of `max`, so I will not spend time
    with its implementation, other than explaining `MISSING`. The `MISSING` constant
    is a unique `object` instance used as a sentinel. It is the default value for
    the `default=` keyword argument, so that `max` can accept `default=None` and still
    distinguish between these two situations:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的重点不是 `max` 的逻辑，所以我不会花时间解释它的实现，除了解释 `MISSING`。`MISSING` 常量是一个用作哨兵的唯一 `object`
    实例。它是 `default=` 关键字参数的默认值，这样 `max` 可以接受 `default=None` 并仍然区分这两种情况：
- en: The user did not provide a value for `default=`, so it is `MISSING`, and `max`
    raises `ValueError` if `first` is an empty iterable.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户没有为 `default=` 提供值，因此它是 `MISSING`，如果 `first` 是一个空的可迭代对象，`max` 将引发 `ValueError`。
- en: The user provided some value for `default=`, including `None`, so `max` returns
    that value if `first` is an empty iterable.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户为 `default=` 提供了一些值，包括 `None`，因此如果 `first` 是一个空的可迭代对象，`max` 将返回该值。
- en: 'To fix [issue #4051](https://fpy.li/shed4051), I wrote the code in [Example 15-3](#mymax_types_ex).^([2](ch15.html#idm46582415940880))'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '为了修复 [问题 #4051](https://fpy.li/shed4051)，我写了 [Example 15-3](#mymax_types_ex)
    中的代码。^([2](ch15.html#idm46582415940880))'
- en: 'Example 15-3\. *mymax.py*: top of the module, with imports, definitions, and
    overloads'
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 15-3\. *mymax.py*：模块顶部，包括导入、定义和重载
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: My Python implementation of `max` is about the same length as all those typing
    imports and declarations. Thanks to duck typing, my code has no `isinstance` checks,
    and provides the same error checking as those type hints—but only at runtime,
    of course.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我的 Python 实现的 `max` 与所有那些类型导入和声明的长度大致相同。由于鸭子类型，我的代码没有 `isinstance` 检查，并且提供了与那些类型提示相同的错误检查，但当然只在运行时。
- en: A key benefit of `@overload` is declaring the return type as precisely as possible,
    according to the types of the arguments given. We’ll see that benefit next by
    studying the overloads for `max` in groups of one or two at a time.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`@overload` 的一个关键优势是尽可能精确地声明返回类型，根据给定的参数类型。我们将通过逐组一到两个地研究`max`的重载来看到这个优势。'
- en: Arguments implementing SupportsLessThan, but key and default not provided
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现了 SupportsLessThan 的参数，但未提供 key 和 default
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In these cases, the inputs are either separate arguments of type `LT` implementing
    `SupportsLessThan`, or an `Iterable` of such items. The return type of `max` is
    the same as the actual arguments or items, as we saw in [“Bounded TypeVar”](ch08.html#bounded_typevar_sec).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，输入要么是实现了 `SupportsLessThan` 的类型 `LT` 的单独参数，要么是这些项目的 `Iterable`。`max`
    的返回类型与实际参数或项目相同，正如我们在 [“Bounded TypeVar”](ch08.html#bounded_typevar_sec) 中看到的。
- en: 'Sample calls that match these overloads:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 符合这些重载的示例调用：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Argument key provided, but no default
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供了 key 参数，但没有提供 default
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The inputs can be separate items of any type `T` or a single `Iterable[T]`,
    and `key=` must be a callable that takes an argument of the same type `T`, and
    returns a value that implements `SupportsLessThan`. The return type of `max` is
    the same as the actual arguments.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 输入可以是任何类型 `T` 的单独项目或单个 `Iterable[T]`，`key=` 必须是一个接受相同类型 `T` 的参数并返回一个实现 `SupportsLessThan`
    的值的可调用对象。`max` 的返回类型与实际参数相同。
- en: 'Sample calls that match these overloads:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 符合这些重载的示例调用：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Argument default provided, but no key
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供了 default 参数，但没有 key
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The input is an iterable of items of type `LT` implementing `SupportsLessThan`.
    The `default=` argument is the return value when the `Iterable` is empty. Therefore
    the return type of `max` must be a `Union` of type `LT` and the type of the `default`
    argument.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 输入是一个实现 `SupportsLessThan` 的类型 `LT` 的项目的可迭代对象。`default=` 参数是当 `Iterable` 为空时的返回值。因此，`max`
    的返回类型必须是 `LT` 类型和 `default` 参数类型的 `Union`。
- en: 'Sample calls that match these overloads:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 符合这些重载的示例调用：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Arguments key and default provided
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供了 key 和 default 参数
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The inputs are:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 输入是：
- en: An `Iterable` of items of any type `T`
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何类型 `T` 的项目的可迭代对象
- en: Callable that takes an argument of type `T` and returns a value of type `LT`
    that implements `SupportsLessThan`
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受类型为`T`的参数并返回实现`SupportsLessThan`的类型`LT`的值的可调用函数
- en: A default value of any type `DT`
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何类型`DT`的默认值
- en: 'The return type of `max` must be a `Union` of type `T` or the type of the `default`
    argument:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`max`的返回类型必须是类型`T`或`default`参数的类型的`Union`：'
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Takeaways from Overloading max
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从重载`max`中得到的经验教训
- en: 'Type hints allow Mypy to flag a call like `max([None, None])` with this error
    message:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示允许Mypy标记像`max([None, None])`这样的调用，并显示以下错误消息：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: On the other hand, having to write so many lines to support the type checker
    may discourage people from writing convenient and flexible functions like `max`.
    If I had to reinvent the `min` function as well, I could refactor and reuse most
    of the implementation of `max`. But I’d have to copy and paste all overloaded
    declarations—even though they would be identical for `min`, except for the function
    name.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，为了���持类型检查器而写这么多行可能会阻止人们编写方便灵活的函数，如`max`。如果我不得不重新发明`min`函数，我可以重构并重用大部分`max`的实现。但我必须复制并粘贴所有重载的声明——尽管它们对于`min`来说是相同的，除了函数名称。
- en: 'My friend João S. O. Bueno—one of the smartest Python devs I know—tweeted [this](https://fpy.li/15-4):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我的朋友João S. O. Bueno——我认识的最聪明的Python开发者之一——在推特上发表了[这篇推文](https://fpy.li/15-4)：
- en: Although it is this hard to express the signature of `max`—it fits in one’s
    mind quite easily. My understanding is that the expressiveness of annotation markings
    is very limited, compared to that of Python.
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管很难表达`max`的签名——但它很容易理解。我理解的是，与Python相比，注释标记的表现力非常有限。
- en: Now let’s study the `TypedDict` typing construct. It is not as useful as I imagined
    at first, but has its uses. Experimenting with `TypedDict` demonstrates the limitations
    of static typing for handling dynamic structures, such as JSON data.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来研究`TypedDict`类型构造。一开始我认为它并不像我想象的那么有用，但它有其用途。尝试使用`TypedDict`来处理动态结构（如JSON数据）展示了静态类型处理的局限性。
- en: TypedDict
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypedDict
- en: Warning
  id: totrans-91
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: It’s tempting to use `TypedDict` to protect against errors while handling dynamic
    data structures like JSON API responses. But the examples here make clear that
    correct handling of JSON must be done at runtime, and not with static type checking.
    For runtime checking of JSON-like structures using type hints, check out the [*pydantic*](https://fpy.li/15-5)
    package on PyPI.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`TypedDict`来保护处理动态数据结构（如JSON API响应）中的错误是很诱人的。但这里的示例清楚地表明，对JSON的正确处理必须在运行时完成，而不是通过静态类型检查。要使用类型提示对类似JSON的结构进行运行时检查，请查看PyPI上的[*pydantic*](https://fpy.li/15-5)包。
- en: Python dictionaries are sometimes used as records, with the keys used as field
    names and field values of different types.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Python字典有时被用作记录，其中键用作字段名称，不同类型的字段值。
- en: 'For example, consider a record describing a book in JSON or Python:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑描述JSON或Python中的一本书的记录：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Before Python 3.8, there was no good way to annotate a record like that, because
    the mapping types we saw in [“Generic Mappings”](ch08.html#mapping_type_sec) limit
    all values to have the same type.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3.8之前，没有很好的方法来注释这样的记录，因为我们在[“通用映射”](ch08.html#mapping_type_sec)中看到的映射类型限制所有值具有相同的类型。
- en: 'Here are two lame attempts to annotate a record like the preceding JSON object:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个尴尬的尝试来注释类似前述JSON对象的记录：
- en: '`Dict[str, Any]`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dict[str, Any]`'
- en: The values may be of any type.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 值可以是任何类型。
- en: '`Dict[str, Union[str, int, List[str]]]`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dict[str, Union[str, int, List[str]]]`'
- en: 'Hard to read, and doesn’t preserve the relationship between field names and
    their respective field types: `title` is supposed to be a `str`, it can’t be an
    `int` or a `List[str]`.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 难以阅读，并且不保留字段名称和其相应字段类型之间的关系：`title`应该是一个`str`，不能是一个`int`或`List[str]`。
- en: '[PEP 589—TypedDict: Type Hints for Dictionaries with a Fixed Set of Keys](https://fpy.li/pep589)
    addressed that problem. [Example 15-4](#bookdict_ex) shows a simple `TypedDict`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[PEP 589—TypedDict: 具有固定键集的字典的类型提示](https://fpy.li/pep589)解决了这个问题。[示例 15-4](#bookdict_ex)展示了一个简单的`TypedDict`。'
- en: 'Example 15-4\. *books.py*: the `BookDict` definition'
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例15-4。*books.py*：`BookDict`定义
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: At first glance, `typing.TypedDict` may seem like a data class builder, similar
    to `typing.NamedTuple`—covered in [Chapter 5](ch05.html#data_class_ch).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，`typing.TypedDict`可能看起来像是一个数据类构建器，类似于`typing.NamedTuple`—在[第5章](ch05.html#data_class_ch)中介绍过。
- en: The syntactic similarity is misleading. `TypedDict` is very different. It exists
    only for the benefit of type checkers, and has no runtime effect.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 语法上的相似性是误导的。`TypedDict`非常不同。它仅存在于类型检查器的利益，并且在运行时没有影响。
- en: '`TypedDict` provides two things:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`TypedDict`提供了两个东西：'
- en: Class-like syntax to annotate a `dict` with type hints for the value of each
    “field.”
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似类的语法来注释每个“字段”的值的`dict`类型提示。
- en: A constructor that tells the type checker to expect a `dict` with the keys and
    values as specified.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个构造函数，告诉类型检查器期望一个带有指定键和值的`dict`。
- en: 'At runtime, a `TypedDict` constructor such as `BookDict` is a placebo: it has
    the same effect as calling the `dict` constructor with the same arguments.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，像`BookDict`这样的`TypedDict`构造函数是一个安慰剂：它与使用相同参数调用`dict`构造函数具有相同效果。
- en: 'The fact that `BookDict` creates a plain `dict` also means that:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookDict`创建一个普通的`dict`也意味着：'
- en: The “fields” in the pseudoclass definition don’t create instance attributes.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伪类定义中的“字段”不会创建实例属性。
- en: You can’t write initializers with default values for the “fields.”
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能为“字段”编写具有默认值的初始化程序。
- en: Method definitions are not allowed.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许方法定义。
- en: Let’s explore the behavior of a `BookDict` at runtime ([Example 15-5](#bookdict_first_use_ex)).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在运行时探索一个`BookDict`的行为（[示例 15-5](#bookdict_first_use_ex)）。
- en: Example 15-5\. Using a `BookDict`, but not quite as intended
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例15-5。使用`BookDict`，但并非完全按照预期
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](assets/1.png)](#co_more_about_type_hints_CO2-1)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_more_about_type_hints_CO2-1)'
- en: You can call `BookDict` like a `dict` constructor with keyword arguments, or
    passing a `dict` argument—including a `dict` literal.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像使用`dict`构造函数一样调用`BookDict`，使用关键字参数，或传递一个`dict`参数，包括`dict`文字。
- en: '[![2](assets/2.png)](#co_more_about_type_hints_CO2-2)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_more_about_type_hints_CO2-2)'
- en: Oops…I forgot `authors` takes a list. But gradual typing means no type checking
    at runtime.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕…我忘记了 `authors` 接受一个列表。但渐进式类型意味着在运行时没有类型检查。
- en: '[![3](assets/3.png)](#co_more_about_type_hints_CO2-3)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_more_about_type_hints_CO2-3)'
- en: The result of calling `BookDict` is a plain `dict`…
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `BookDict` 的结果是一个普通的 `dict`…
- en: '[![4](assets/4.png)](#co_more_about_type_hints_CO2-4)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_more_about_type_hints_CO2-4)'
- en: …therefore you can’t read the data using `object.field` notation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: …因此您不能使用 `object.field` 记法读取数据。
- en: '[![5](assets/5.png)](#co_more_about_type_hints_CO2-5)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_more_about_type_hints_CO2-5)'
- en: The type hints are in `BookDict.__annotations__`, and not in `pp`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示位于 `BookDict.__annotations__` 中，而不是 `pp`。
- en: 'Without a type checker, `TypedDict` is as useful as comments: it may help people
    read the code, but that’s it. In contrast, the class builders from [Chapter 5](ch05.html#data_class_ch)
    are useful even if you don’t use a type checker, because at runtime they generate
    or enhance a custom class that you can instantiate. They also provide several
    useful methods or functions listed in [Table 5-1](ch05.html#builders_compared_tbl).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 没有类型检查器，`TypedDict` 就像注释一样有用：它可以帮助人们阅读代码，但仅此而已。相比之下，来自 [第 5 章](ch05.html#data_class_ch)
    的类构建器即使不使用类型检查器也很有用，因为在运行时它们会生成或增强一个自定义类，您可以实例化。它们还提供了 [表 5-1](ch05.html#builders_compared_tbl)
    中列出的几个有用的方法或函数。
- en: '[Example 15-6](#bookdict_demo_ex) builds a valid `BookDict` and tries some
    operations on it. This shows how `TypedDict` enables Mypy to catch errors, shown
    in [Example 15-7](#bookdict_demo_check).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-6](#bookdict_demo_ex) 构建了一个有效的 `BookDict`，并尝试对其进行一些操作。这展示了 `TypedDict`
    如何使 Mypy 能够捕获错误，如 [示例 15-7](#bookdict_demo_check) 中所示。'
- en: 'Example 15-6\. *demo_books.py*: legal and illegal operations on a `BookDict`'
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '示例 15-6\. *demo_books.py*: 在 `BookDict` 上进行合法和非法操作'
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](assets/1.png)](#co_more_about_type_hints_CO3-1)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_more_about_type_hints_CO3-1)'
- en: Remember to add a return type, so that Mypy doesn’t ignore the function.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 记得添加返回类型，这样 Mypy 不会忽略函数。
- en: '[![2](assets/2.png)](#co_more_about_type_hints_CO3-2)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_more_about_type_hints_CO3-2)'
- en: 'This is a valid `BookDict`: all the keys are present, with values of the correct
    types.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有效的 `BookDict`：所有键都存在，并且具有正确类型的值。
- en: '[![3](assets/3.png)](#co_more_about_type_hints_CO3-3)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_more_about_type_hints_CO3-3)'
- en: Mypy will infer the type of `authors` from the annotation for the `'authors'`
    key in `BookDict`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy 将从 `BookDict` 中 `'authors'` 键的注释中推断出 `authors` 的类型。
- en: '[![4](assets/4.png)](#co_more_about_type_hints_CO3-4)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_more_about_type_hints_CO3-4)'
- en: '`typing.TYPE_CHECKING` is only `True` when the program is being type checked.
    At runtime, it’s always false.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`typing.TYPE_CHECKING` 仅在程序进行类型检查时为 `True`。在运行时，它始终为 false。'
- en: '[![5](assets/5.png)](#co_more_about_type_hints_CO3-5)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_more_about_type_hints_CO3-5)'
- en: The previous `if` statement prevents `reveal_type(authors)` from being called
    at runtime. `reveal_type` is not a runtime Python function, but a debugging facility
    provided by Mypy. That’s why there is no `import` for it. See its output in [Example 15-7](#bookdict_demo_check).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个 `if` 语句阻止了在运行时调用 `reveal_type(authors)`。`reveal_type` 不是运行时 Python 函数，而是
    Mypy 提供的调试工具。这就是为什么没有为它导入的原因。在 [示例 15-7](#bookdict_demo_check) 中查看其输出。
- en: '[![6](assets/6.png)](#co_more_about_type_hints_CO3-6)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_more_about_type_hints_CO3-6)'
- en: The last three lines of the `demo` function are illegal. They will cause error
    messages in [Example 15-7](#bookdict_demo_check).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`demo` 函数的最后三行是非法的。它们会在 [示例 15-7](#bookdict_demo_check) 中导致错误消息。'
- en: Type checking *demo_books.py* from [Example 15-6](#bookdict_demo_ex), we get
    [Example 15-7](#bookdict_demo_check).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对 *demo_books.py* 进行类型检查，来自 [示例 15-6](#bookdict_demo_ex)，我们得到 [示例 15-7](#bookdict_demo_check)。
- en: Example 15-7\. Type checking *demo_books.py*
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-7\. 对 *demo_books.py* 进行类型检查
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](assets/1.png)](#co_more_about_type_hints_CO4-1)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_more_about_type_hints_CO4-1)'
- en: This note is the result of `reveal_type(authors)`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个注释是 `reveal_type(authors)` 的结果。
- en: '[![2](assets/2.png)](#co_more_about_type_hints_CO4-2)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_more_about_type_hints_CO4-2)'
- en: The type of the `authors` variable was inferred from the type of the `book['authors']`
    expression that initialized it. You can’t assign a `str` to a variable of type
    `List[str]`. Type checkers usually don’t allow the type of a variable to change.^([3](ch15.html#idm46582414569344))
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`authors` 变量的类型是从初始化它的 `book[''authors'']` 表达式的类型推断出来的。您不能将 `str` 赋给类型为 `List[str]`
    的变量。类型检查器通常不允许变量的类型更改。^([3](ch15.html#idm46582414569344))'
- en: '[![3](assets/3.png)](#co_more_about_type_hints_CO4-3)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_more_about_type_hints_CO4-3)'
- en: Cannot assign to a key that is not part of the `BookDict` definition.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 无法为不属于 `BookDict` 定义的键赋值。
- en: '[![4](assets/4.png)](#co_more_about_type_hints_CO4-4)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_more_about_type_hints_CO4-4)'
- en: Cannot delete a key that is part of the `BookDict` definition.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 无法删除属于 `BookDict` 定义的键。
- en: Now let’s see `BookDict` used in function signatures, to type check function
    calls.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看在函数签名中使用 `BookDict`，以进行函数调用的类型检查。
- en: 'Imagine you need to generate XML from book records, similar to this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你需要从书籍记录生成类似于这样的 XML：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you were writing MicroPython code to be embedded in a tiny microcontroller,
    you might write a function like what’s shown in [Example 15-8](#to_xml_ex).^([4](ch15.html#idm46582414555152))
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在编写要嵌入到微型微控制器中的 MicroPython 代码，您可能会编写类似于 [示例 15-8](#to_xml_ex) 中所示的函数。^([4](ch15.html#idm46582414555152))
- en: 'Example 15-8\. *books.py*: `to_xml` function'
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '示例 15-8\. *books.py*: `to_xml` 函数'
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[![1](assets/1.png)](#co_more_about_type_hints_CO5-1)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_more_about_type_hints_CO5-1)'
- en: 'The whole point of the example: using `BookDict` in the function signature.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 示例的整个重点：在函数签名中使用 `BookDict`。
- en: '[![2](assets/2.png)](#co_more_about_type_hints_CO5-2)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_more_about_type_hints_CO5-2)'
- en: It’s often necessary to annotate collections that start empty, otherwise Mypy
    can’t infer the type of the elements.^([5](ch15.html#idm46582414400144))
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 经常需要注释开始为空的集合，否则 Mypy 无法推断元素的类型。^([5](ch15.html#idm46582414400144))
- en: '[![3](assets/3.png)](#co_more_about_type_hints_CO5-3)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_more_about_type_hints_CO5-3)'
- en: Mypy understands `isinstance` checks, and treats `value` as a `list` in this
    block.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy 理解 `isinstance` 检查，并在此块中将 `value` 视为 `list`。
- en: '[![4](assets/4.png)](#co_more_about_type_hints_CO5-4)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_more_about_type_hints_CO5-4)'
- en: 'When I used `key == ''authors''` as the condition for the `if` guarding this
    block, Mypy found an error in this line: `"object" has no attribute "__iter__"`,
    because it inferred the type of `value` returned from `book.items()` as `object`,
    which doesn’t support the `__iter__` method required by the generator expression.
    With the `isinstance` check, this works because Mypy knows that `value` is a `list`
    in this block.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我将`key == 'authors'`作为`if`条件来保护这个块时，Mypy在这一行发现了一个错误：“"object"没有属性"__iter__"”，因为它推断出从`book.items()`返回的`value`类型为`object`，而`object`不支持生成器表达式所需的`__iter__`方法。通过`isinstance`检查，这可以工作，因为Mypy知道在这个块中`value`是一个`list`。
- en: '[Example 15-9](#from_json_any_ex) shows a function that parses a JSON `str`
    and returns a `BookDict`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 15-9（#from_json_any_ex）展示了一个解析JSON `str`并返回`BookDict`的函数。
- en: 'Example 15-9\. books_any.py: `from_json` function'
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-9\. books_any.py：`from_json`函数
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[![1](assets/1.png)](#co_more_about_type_hints_CO6-1)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_more_about_type_hints_CO6-1)'
- en: The return type of `json.loads()` is `Any`.^([6](ch15.html#idm46582414301776))
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`json.loads()`的返回类型是`Any`。^([6](ch15.html#idm46582414301776))'
- en: '[![2](assets/2.png)](#co_more_about_type_hints_CO6-2)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_more_about_type_hints_CO6-2)'
- en: I can return `whatever`—of type `Any`—because `Any` is *consistent-with* every
    type, including the declared return type, `BookDict`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以返回`whatever`—类型为`Any`—因为`Any`与每种类型都*一致*，包括声明的返回类型`BookDict`。
- en: 'The second point of [Example 15-9](#from_json_any_ex) is very important to
    keep in mind: Mypy will not flag any problem in this code, but at runtime the
    value in `whatever` may not conform to the `BookDict` structure—in fact, it may
    not be a `dict` at all!'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-9](#from_json_any_ex)的第二点非常重要要记住：Mypy不会在这段代码中标记任何问题，但在运行时，`whatever`中的值可能不符合`BookDict`结构—实际上，它可能根本不是`dict`！'
- en: 'If you run Mypy with `--disallow-any-expr`, it will complain about the two
    lines in the body of `from_json`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`--disallow-any-expr`运行Mypy，它会抱怨`from_json`函数体中的两行代码：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Lines 30 and 31 mentioned in the previous snippet are the body of the `from_json`
    function. We can silence the type error by adding a type hint to the initialization
    of the `whatever` variable, as in [Example 15-10](#from_json_ex).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 前一段代码中提到的第30行和31行是`from_json`函数的主体。我们可以通过在`whatever`变量初始化时添加类型提示来消除类型错误，就像[示例
    15-10](#from_json_ex)中那样。
- en: 'Example 15-10\. books.py: `from_json` function with variable annotation'
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-10\. books.py：带有变量注释的`from_json`函数。
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[![1](assets/1.png)](#co_more_about_type_hints_CO7-1)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_more_about_type_hints_CO7-1)'
- en: '`--disallow-any-expr` does not cause errors when an expression of type `Any`
    is immediately assigned to a variable with a type hint.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当将类型为`Any`的表达式立即分配给带有类型提示的变量时，`--disallow-any-expr`不会导致错误。
- en: '[![2](assets/2.png)](#co_more_about_type_hints_CO7-2)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_more_about_type_hints_CO7-2)'
- en: Now `whatever` is of type `BookDict`, the declared return type.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`whatever`的类型是`BookDict`，即声明的返回类型。
- en: Warning
  id: totrans-186
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Don’t be lulled into a false sense of type safety by [Example 15-10](#from_json_ex)!
    Looking at the code at rest, the type checker cannot predict that `json.loads()`
    will return anything that resembles a `BookDict`. Only runtime validation can
    guarantee that.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被[示例 15-10](#from_json_ex)的虚假类型安全感所蒙蔽！从静态代码看，类型检查器无法预测`json.loads()`会返回任何类似于`BookDict`的东西。只有运行时验证才能保证这一点。
- en: Static type checking is unable to prevent errors with code that is inherently
    dynamic, such as `json.loads()`, which builds Python objects of different types
    at runtime, as Examples [15-11](#bookdict_demo_not_book_ex), [15-12](#bookdict_demo_not_book_check),
    and [15-13](#bookdict_demo_not_book_run) demonstrate.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型检查无法防止与本质上动态的代码出现错误，比如`json.loads()`，它在运行时构建不同类型的Python对象，正如示例[15-11](#bookdict_demo_not_book_ex)、[15-12](#bookdict_demo_not_book_check)和[15-13](#bookdict_demo_not_book_run)所展示的。
- en: 'Example 15-11\. demo_not_book.py: `from_json` returns an invalid `BookDict`,
    and `to_xml` accepts it'
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-11\. demo_not_book.py：`from_json`返回一个无效的`BookDict`，而`to_xml`接受它
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[![1](assets/1.png)](#co_more_about_type_hints_CO8-1)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_more_about_type_hints_CO8-1)'
- en: This line does not produce a valid `BookDict`—see the content of `NOT_BOOK_JSON`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码不会产生有效的`BookDict`—查看`NOT_BOOK_JSON`的内容。
- en: '[![2](assets/2.png)](#co_more_about_type_hints_CO8-2)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_more_about_type_hints_CO8-2)'
- en: Let’s have Mypy reveal a couple of types.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们揭示一些类型。
- en: '[![3](assets/3.png)](#co_more_about_type_hints_CO8-3)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_more_about_type_hints_CO8-3)'
- en: 'This should not be a problem: `print` can handle `object` and every other type.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这不应该是问题：`print`可以处理`object`和其他任何类型。
- en: '[![4](assets/4.png)](#co_more_about_type_hints_CO8-4)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_more_about_type_hints_CO8-4)'
- en: '`BookDict` has no `''flavor''` key, but the JSON source does…what will happen?'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`BookDict`没有`''flavor''`键，但JSON源有…会发生什么？'
- en: '[![5](assets/5.png)](#co_more_about_type_hints_CO8-5)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_more_about_type_hints_CO8-5)'
- en: 'Remember the signature: `def to_xml(book: BookDict) -> str:`.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '记住签名：`def to_xml(book: BookDict) -> str:`'
- en: '[![6](assets/6.png)](#co_more_about_type_hints_CO8-6)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_more_about_type_hints_CO8-6)'
- en: What will the XML output look like?
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: XML输出会是什么样子？
- en: Now we check *demo_not_book.py* with Mypy ([Example 15-12](#bookdict_demo_not_book_check)).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们用Mypy检查*demo_not_book.py*（[示例 15-12](#bookdict_demo_not_book_check)）。
- en: Example 15-12\. Mypy report for *demo_not_book.py*, reformatted for clarity
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-12\. *demo_not_book.py*的Mypy报告，为了清晰起见重新格式化
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[![1](assets/1.png)](#co_more_about_type_hints_CO9-1)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_more_about_type_hints_CO9-1)'
- en: The revealed type is the nominal type, not the runtime content of `not_book`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 显式类型是名义类型，而不是`not_book`的运行时内容。
- en: '[![2](assets/2.png)](#co_more_about_type_hints_CO9-2)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_more_about_type_hints_CO9-2)'
- en: Again, this is the nominal type of `not_book['authors']`, as defined in `BookDict`.
    Not the runtime type.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这是`not_book['authors']`的名义类型，如`BookDict`中定义的那样。而不是运行时类型。
- en: '[![3](assets/3.png)](#co_more_about_type_hints_CO9-3)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_more_about_type_hints_CO9-3)'
- en: 'This error is for line `print(not_book[''flavor''])`: that key does not exist
    in the nominal type.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误是针对`print(not_book['flavor'])`这一行的：该键在名义类型中不存在。
- en: Now let’s run *demo_not_book.py*, showing the output in [Example 15-13](#bookdict_demo_not_book_run).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行*demo_not_book.py*，并在[示例 15-13](#bookdict_demo_not_book_run)中显示输出。
- en: Example 15-13\. Output of running `demo_not_book.py`
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-13\. 运行 `demo_not_book.py` 的输出
- en: '[PRE27]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[![1](assets/1.png)](#co_more_about_type_hints_CO10-1)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_more_about_type_hints_CO10-1)'
- en: This is not really a `BookDict`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上不是一个 `BookDict`。
- en: '[![2](assets/2.png)](#co_more_about_type_hints_CO10-2)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_more_about_type_hints_CO10-2)'
- en: The value of `not_book['flavor']`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`not_book[''flavor'']` 的值。'
- en: '[![3](assets/3.png)](#co_more_about_type_hints_CO10-3)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_more_about_type_hints_CO10-3)'
- en: '`to_xml` takes a `BookDict` argument, but there is no runtime checking: garbage
    in, garbage out.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`to_xml` 接受一个 `BookDict` 参数，但没有运行时检查：垃圾进，垃圾出。'
- en: '[Example 15-13](#bookdict_demo_not_book_run) shows that *demo_not_book.py*
    outputs nonsense, but has no runtime errors. Using a `TypedDict` while handling
    JSON data did not provide much type safety.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-13](#bookdict_demo_not_book_run) 显示 *demo_not_book.py* 输出了无意义的内容，但没有运行时错误。在处理
    JSON 数据时使用 `TypedDict` 并没有提供太多类型安全性。'
- en: 'If you look at the code for `to_xml` in [Example 15-8](#to_xml_ex) through
    the lens of duck typing, the argument `book` must provide an `.items()` method
    that returns an iterable of tuples like `(key, value)` where:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过鸭子类型的视角查看[示例 15-8](#to_xml_ex)中`to_xml`的代码，那么参数`book`必须提供一个返回类似`(key, value)`元组可迭代对象的`.items()`方法，其中：
- en: '`key` must have an `.upper()` method'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key` 必须有一个 `.upper()` 方法'
- en: '`value` can be anything'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value` 可以是任何东西'
- en: 'The point of this demonstration: when handling data with a dynamic structure,
    such as JSON or XML, `TypedDict` is absolutely not a replacement for data validation
    at runtime. For that, use [*pydantic*](https://fpy.li/15-5).'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示的重点是：当处理具有动态结构的数据，比如 JSON 或 XML 时，`TypedDict` 绝对不能替代运行时的数据验证。为此，请使用[*pydantic*](https://fpy.li/15-5)。
- en: '`TypedDict` has more features, including support for optional keys, a limited
    form of inheritance, and an alternative declaration syntax. If you want to know
    more about it, please review [PEP 589—TypedDict: Type Hints for Dictionaries with
    a Fixed Set of Keys](https://fpy.li/pep589).'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`TypedDict` 具有更多功能，包括支持可选键、有限形式的继承以及另一种声明语法。如果您想了解更多，请查看 [PEP 589—TypedDict:
    Type Hints for Dictionaries with a Fixed Set of Keys](https://fpy.li/pep589)。'
- en: 'Now let’s turn our attention to a function that is best avoided, but sometimes
    is unavoidable: `typing.cast`.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将注意力转向一个最好避免但有时不可避免的函数：`typing.cast`。
- en: Type Casting
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型转换
- en: No type system is perfect, and neither are the static type checkers, the type
    hints in the *typeshed* project, or the type hints in the third-party packages
    that have them.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 没有完美的类型系统，静态类型检查器、*typeshed* 项目中的类型提示或具有类型提示的第三方包也不是完美的。
- en: 'The `typing.cast()` special function provides one way to handle type checking
    malfunctions or incorrect type hints in code we can’t fix. The [Mypy 0.930 documentation](https://fpy.li/15-14)
    explains:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`typing.cast()` 特殊函数提供了一种处理类型检查故障或代码中不正确类型提示的方法。[Mypy 0.930 文档](https://fpy.li/15-14)解释：'
- en: Casts are used to silence spurious type checker warnings and give the type checker
    a little help when it can’t quite understand what is going on.
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Casts 用于消除杂乱的类型检查器警告，并在类型检查器无法完全理解情况时为其提供一点帮助。
- en: 'At runtime, `typing.cast` does absolutely nothing. This is its [implementation](https://fpy.li/15-15):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，`typing.cast` 绝对不起作用。这是它的[实现](https://fpy.li/15-15)：
- en: '[PRE28]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'PEP 484 requires type checkers to “blindly believe” the type stated in the
    `cast`. The [“Casts” section of PEP 484](https://fpy.li/15-16) gives an example
    where the type checker needs the guidance of `cast`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 484 要求类型检查器“盲目相信”`cast` 中声明的类型。[PEP 484 的“Casts”部分](https://fpy.li/15-16)提供了一个需要
    `cast` 指导的示例：
- en: '[PRE29]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `next()` call on the generator expression will either return the index of
    a `str` item or raise `StopIteration`. Therefore, `find_first_str` will always
    return a `str` if no exception is raised, and `str` is the declared return type.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对生成器表达式的 `next()` 调用将返回 `str` 项的索引或引发 `StopIteration`。因此，如果没有引发异常，`find_first_str`
    将始终返回一个 `str`，而 `str` 是声明的返回类型。
- en: But if the last line were just `return a[index]`, Mypy would infer the return
    type as `object` because the `a` argument is declared as `list[object]`. So the
    `cast()` is required to guide Mypy.^([7](ch15.html#idm46582413846128))
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果最后一行只是 `return a[index]`，Mypy 将推断返回类型为 `object`，因为 `a` 参数声明为 `list[object]`。因此，需要
    `cast()` 来指导 Mypy。^([7](ch15.html#idm46582413846128))
- en: 'Here is another example with `cast`, this time to correct an outdated type
    hint for Python’s standard library. In [Example 21-12](ch21.html#tcp_mojifinder_main),
    I create an *asyncio* `Server` object and I want to get the address the server
    is listening to. I coded this line:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个使用 `cast` 的示例，这次是为了纠正 Python 标准库中过时的类型提示。在[示例 21-12](ch21.html#tcp_mojifinder_main)中，��创建了一个
    *asyncio* `Server` 对象，并且我想获取服务器正在侦听的地址。我编写了这行代码：
- en: '[PRE30]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'But Mypy reported this error:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 但 Mypy 报告了这个错误：
- en: '[PRE31]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The type hint for `Server.sockets` on *typeshed* in May 2021 is valid for Python
    3.6, where the `sockets` attribute could be `None`. But in Python 3.7, `sockets`
    became a property with a getter that always returns a `list`—which may be empty
    if the server has no sockets. And since Python 3.8, the getter returns a `tuple`
    (used as an immutable sequence).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 2021 年 5 月 *typeshed* 中 `Server.sockets` 的类型提示对 Python 3.6 是有效的，其中 `sockets`
    属性可以是 `None`。但在 Python 3.7 中，`sockets` 变成了一个始终返回 `list` 的属性，如果服务器没有 sockets，则可能为空。自
    Python 3.8 起，getter 返回一个 `tuple`（用作不可变序列）。
- en: 'Since I can’t fix *typeshed* right now,^([8](ch15.html#idm46582413762864))
    I added a `cast`, like this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我现在无法修复 *typeshed*，^([8](ch15.html#idm46582413762864)) 我添加了一个 `cast`，就像这样：
- en: '[PRE32]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Using `cast` in this case required a couple of hours to understand the problem
    and read *asyncio* source code to find the correct type of the sockets: the `TransportSocket`
    class from the undocumented `asyncio.trsock` module. I also had to add two `import`
    statements and another line of code for readability.^([9](ch15.html#idm46582413751952))
    But the code is safer.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下使用 `cast` 需要花费几个小时来理解问题，并阅读 *asyncio* 源代码以找到正确的 sockets 类型：来自未记录的 `asyncio.trsock`
    模块的 `TransportSocket` 类。我还必须添加两个 `import` 语句和另一行代码以提高可读性。^([9](ch15.html#idm46582413751952))
    但代码更安全。
- en: The careful reader may note that `sockets[0]` could raise `IndexError` if `sockets`
    is empty. However, as far as I understand `asyncio`, that cannot happen in [Example 21-12](ch21.html#tcp_mojifinder_main)
    because the `server` is ready to accept connections by the time I read its `sockets`
    attribute, therefore it will not be empty. Anyway, `IndexError` is a runtime error.
    Mypy can’t spot the problem even in a trivial case like `print([][0])`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 细心的读者可能会注意到，如果 `sockets` 为空，`sockets[0]` 可能会引发 `IndexError`。但就我对 `asyncio` 的理解而言，在
    [示例 21-12](ch21.html#tcp_mojifinder_main) 中不会发生这种情况，因为 `server` 在我读取其 `sockets`
    属性时已准备好接受连接，因此它不会为空。无论如何，`IndexError` 是一个运行时错误。Mypy 甚至在像 `print([][0])` 这样的简单情况下也无法发现问题。
- en: Warning
  id: totrans-247
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Don’t get too comfortable using `cast` to silence Mypy, because Mypy is usually
    right when it reports an error. If you are using `cast` very often, that’s a [code
    smell](https://fpy.li/15-20). Your team may be misusing type hints, or you may
    have low-quality dependencies in your codebase.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过于依赖 `cast` 来消除 Mypy 的警告，因为当 Mypy 报告错误时，通常是正确的。如果你经常使用 `cast`，那是一个[代码异味](https://fpy.li/15-20)。你的团队可能在误用类型提示，或者你的代码库中可能存在低质量的依赖项。
- en: 'Despite the downsides, there are valid uses for `cast`. Here is something Guido
    van Rossum wrote about it:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在缺点，`cast` 也有其有效用途。以下是 Guido van Rossum 关于它的一些观点：
- en: 'What’s wrong with the occasional `cast()` call or `# type: ignore` comment?^([10](ch15.html#idm46582413669200))'
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '有什么问题，偶尔调用 `cast()` 或添加 `# type: ignore` 注释吗？^([10](ch15.html#idm46582413669200))'
- en: 'It is unwise to completely ban the use of `cast`, especially because the other
    workarounds are worse:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 完全禁止使用 `cast` 是不明智的，特别是因为其他解决方法更糟糕：
- en: '`# type: ignore` is less informative.^([11](ch15.html#idm46582413665424))'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`# type: ignore` 提供的信息较少。^([11](ch15.html#idm46582413665424))'
- en: 'Using `Any` is contagious: since `Any` is *consistent-with* all types, abusing
    it may produce cascading effects through type inference, undermining the type
    checker’s ability to detect errors in other parts of the code.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Any` 是具有传染性的：由于 `Any` 与所有类型*一致*，滥用它可能通过类型推断产生级联效应，削弱类型检查器在代码其他部分检测错误的能力。
- en: 'Of course, not all typing mishaps can be fixed with `cast`. Sometimes we need
    `# type: ignore`, the occasional `Any`, or even leaving a function without type
    hints.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '当然，并非所有类型错误都可以使用 `cast` 修复。有时我们需要 `# type: ignore`，偶尔需要 `Any`，甚至可以在函数中不留类型提示。'
- en: Next, let’s talk about using annotations at runtime.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈在运行时使用注释。
- en: Reading Type Hints at Runtime
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时读取类型提示
- en: At import time, Python reads the type hints in functions, classes, and modules,
    and stores them in attributes named `__annotations__`. For instance, consider
    the `clip` function in [Example 15-14](#ex_clip_annot).^([12](ch15.html#idm46582413651904))
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入时，Python 读取函数、类和模块中的类型提示，并将它们存储在名为 `__annotations__` 的属性中。例如，考虑 [示例 15-14](#ex_clip_annot)
    中的 `clip` 函数。^([12](ch15.html#idm46582413651904))
- en: 'Example 15-14\. clipannot.py: annotated signature of a `clip` function'
  id: totrans-258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-14\. clipannot.py：`clip` 函数的带注释签名
- en: '[PRE33]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The type hints are stored as a `dict` in the `__annotations__` attribute of
    the function:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示存储为函数的 `__annotations__` 属性中的 `dict`：
- en: '[PRE34]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `'return'` key maps to the return type hint after the `->` symbol in [Example 15-14](#ex_clip_annot).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`''return''` 键映射到 `->` 符号后的返回类型提示，在 [示例 15-14](#ex_clip_annot) 中。'
- en: Note that the annotations are evaluated by the interpreter at import time, just
    as parameter default values are also evaluated. That’s why the values in the annotations
    are the Python classes `str` and `int`, and not the strings `'str'` and `'int'`.
    The import time evaluation of annotations is the standard as of Python 3.10, but
    that may change if [PEP 563](https://fpy.li/pep563) or [PEP 649](https://fpy.li/pep649)
    become the standard behavior.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，注释在导入时由解释器评估，就像参数默认值也会被评估一样。这就是为什么注释中的值是 Python 类 `str` 和 `int`，而不是字符串 `'str'`
    和 `'int'`。注释的导入时评估是 Python 3.10 的标准，但如果 [PEP 563](https://fpy.li/pep563) 或 [PEP
    649](https://fpy.li/pep649) 成为标准行为，这可能会改变。
- en: Problems with Annotations at Runtime
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时的注释问题
- en: 'The increased use of type hints raised two problems:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示的增加使用引发了两个问题：
- en: Importing modules uses more CPU and memory when many type hints are used.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用许多类型提示时，导入模块会消耗更多的 CPU 和内存。
- en: Referring to types not yet defined requires using strings instead of actual
    types.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用尚未定义的类型需要使用字符串而不是实际类型。
- en: 'Both issues are relevant. The first is because of what we just saw: annotations
    are evaluated by the interpreter at import time and stored in the `__annotations__`
    attribute. Let’s focus now on the second issue.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个问题都很重要。第一个问题是因为我们刚刚看到的：注释在导入时由解释器评估并存储在 `__annotations__` 属性中。现在让我们专注于第二个问题。
- en: 'Storing annotations as strings is sometimes required because of the “forward
    reference” problem: when a type hint needs to refer to a class defined below in
    the same module. However, a common manifestation of the problem in source code
    doesn’t look like a forward reference at all: that’s when a method returns a new
    object of the same class. Since the class object is not defined until Python completely
    evaluates the class body, type hints must use the name of the class as a string.
    Here is an example:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要将注释存储为字符串，因为存在“前向引用”问题：当类型提示需要引用在同一模块下定义的类时。然而，在源代码中问题的常见表现根本不像前向引用：当方法返回同一类的新对象时。由于在
    Python 完全评估类体之前类对象未定义，类型提示必须使用类名作为字符串。以下是一个示例：
- en: '[PRE35]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Writing forward referencing type hints as strings is the standard and required
    practice as of Python 3.10. Static type checkers were designed to deal with that
    issue from the beginning.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 将前向引用类型提示写为字符串是 Python 3.10 的标准和必需做法。静态类型检查器从一开始就设计用于处理这个问题。
- en: But at runtime, if you write code to read the `return` annotation for `stretch`,
    you will get a string `'Rectangle'` instead of a reference to the actual type,
    the `Rectangle` class. Now your code needs to figure out what that string means.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 但在运行时，如果编写代码读取 `stretch` 的 `return` 注释，你将得到一个字符串 `'Rectangle'` 而不是实际类型，即 `Rectangle`
    类的引用。现在你的代码需要弄清楚那个字符串的含义。
- en: 'The `typing` module includes three functions and a class categorized as [Introspection
    helpers](https://fpy.li/15-24), the most important being `typing.get_type_hints`.
    Part of its documentation states:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`typing`模块包括三个函数和一个分类为[内省助手](https://fpy.li/15-24)��类，其中最重要的是`typing.get_type_hints`。其部分文档如下：'
- en: '`get_type_hints(obj, globals=None, locals=None, include_extras=False)`'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_type_hints(obj, globals=None, locals=None, include_extras=False)`'
- en: '[…] This is often the same as `obj.__annotations__`. In addition, forward references
    encoded as string literals are handled by evaluating them in `globals` and `locals`
    namespaces. […]'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[…] 这通常与`obj.__annotations__`相同。此外，以字符串文字编码的前向引用通过在`globals`和`locals`命名空间中评估来处理。[…]'
- en: Warning
  id: totrans-276
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Since Python 3.10, the new [`inspect.get_annotations(…)`](https://fpy.li/15-25)
    function should be used instead of `typing.​get_​type_​hints`. However, some readers
    may not be using Python 3.10 yet, so in the examples I’ll use `typing.​get_​type_​hints`,
    which is available since the `typing` module was added in Python 3.5.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Python 3.10 开始，应该使用新的[`inspect.get_annotations(…)`](https://fpy.li/15-25)函数，而不是`typing.​get_​type_​hints`。然而，一些读者可能尚未使用
    Python 3.10，因此在示例中我将使用`typing.​get_​type_​hints`，自从`typing`模块在 Python 3.5 中添加以来就可用。
- en: '[PEP 563—Postponed Evaluation of Annotations](https://fpy.li/pep563) was approved
    to make it unnecessary to write annotations as strings, and to reduce the runtime
    costs of type hints. Its main idea is described in these two sentences of the
    [“Abstract”](https://fpy.li/15-26):'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[PEP 563—注释的延迟评估](https://fpy.li/pep563)已经获得批准，使得不再需要将注释写成字符串，并减少类型提示的运行时成本。其主要思想在[“摘要”](https://fpy.li/15-26)的这两句话中描述：'
- en: This PEP proposes changing function annotations and variable annotations so
    that they are no longer evaluated at function definition time. Instead, they are
    preserved in *annotations* in string form.
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本PEP建议更改函数注释和变量注释，使其不再在函数定义时评估。相反，它们以字符串形式保留在*注释*中。
- en: 'Beginning with Python 3.7, that’s how annotations are handled in any module
    that starts with this `import` statement:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 3.7 开始，这就是在任何以此`import`语句开头的模块中处理注释的方式：
- en: '[PRE36]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To demonstrate its effect, I put a copy of the same `clip` function from [Example 15-14](#ex_clip_annot)
    in a *clip_annot_post.py* module with that `__future__` import line at the top.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示其效果，我将与顶部的`__future__`导入行相同的`clip`函数的副本放在了一个名为*clip_annot_post.py*的模块中。
- en: 'At the console, here’s what I get when I import that module and read the annotations
    from `clip`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台上，当我导入该模块并读取`clip`的注释时，这是我得到的结果：
- en: '[PRE37]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, all the type hints are now plain strings, despite the fact they
    are not written as quoted strings in the definition of `clip` ([Example 15-14](#ex_clip_annot)).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所有类型提示现在都是普通字符串，尽管它们在`clip`的定义中并非作为引号字符串编写（[示例 15-14](#ex_clip_annot)）。
- en: 'The `typing.get_type_hints` function is able to resolve many type hints, including
    those in `clip`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`typing.get_type_hints`函数能够解析许多类型提示，包括`clip`中的类型提示：'
- en: '[PRE38]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Calling `get_type_hints` gives us the real types—even in some cases where the
    original type hint is written as a quoted string. That’s the recommended way to
    read type hints at runtime.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`get_type_hints`会给我们真实的类型，即使在某些情况下原始类型提示是作为引号字符串编写的。这是在运行时读取类型提示的推荐方式。
- en: The PEP 563 behavior was scheduled to become default in Python 3.10, with no
    `__future__` import needed. However, the maintainers of *FastAPI* and *pydantic*
    raised the alarm that the change would break their code which relies on type hints
    at runtime, and cannot use `get_type_hints` reliably.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 563的行为原计划在 Python 3.10 中成为默认行为，无需`__future__`导入。然而，*FastAPI* 和 *pydantic*
    的维护者发出警告，称这一变化将破坏依赖运行时类型提示的代码，并且无法可靠使用`get_type_hints`。
- en: 'In the ensuing discussion on the python-dev mailing list, Łukasz Langa—the
    author of PEP 563—described some limitations of that function:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在 python-dev 邮件列表上的讨论中，PEP 563的作者 Łukasz Langa 描述了该函数的一些限制：
- en: '[…] it turned out that `typing.get_type_hints()` has limits that make its use
    in general costly at runtime, and more importantly insufficient to resolve all
    types. The most common example deals with non-global context in which types are
    generated (e.g., inner classes, classes within functions, etc.). But one of the
    crown examples of forward references: classes with methods accepting or returning
    objects of their own type, also isn’t properly handled by `typing.get_type_hints()`
    if a class generator is used. There’s some trickery we can do to connect the dots
    but in general it’s not great.^([13](ch15.html#idm46582413403536))'
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[…] 结果表明，`typing.get_type_hints()`存在一些限制，使得其在一般情况下在运行时成本高昂，并且更重要的是无法解析所有类型。最常见的例子涉及生成类型的非全局上下文（例如，内部类、函数内的类等）。但是，一个前向引用的典型例子是：具有接受或返回其自身类型对象的方法的类，如果使用类生成器，则`typing.get_type_hints()`也无法正确处理。我们可以做一些技巧来连接这些点，但总体来说并不是很好。^([13](ch15.html#idm46582413403536))'
- en: Python’s Steering Council decided to postpone making PEP 563 the default behavior
    until Python 3.11 or later, giving more time to developers to come up with a solution
    that addresses the issues PEP 563 tried to solve, without breaking widespread
    uses of type hints at runtime. [PEP 649—Deferred Evaluation Of Annotations Using
    Descriptors](https://fpy.li/pep649) is under consideration as a possible solution,
    but a different compromise may be reached.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Python的指导委员会决定将PEP 563的默认行为推迟到 Python 3.11 或更高版本，以便开发人员有更多时间提出解决PEP 563试图解决的问题的解决方案，而不会破坏运行时类型提示的广泛使用。[PEP
    649—使用描述符推迟评估注释](https://fpy.li/pep649)正在考虑作为可能的解决方案，但可能会达成不同的妥协。
- en: 'To summarize: reading type hints at runtime is not 100% reliable as of Python
    3.10 and is likely to change in 2022.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下：截至 Python 3.10，运行时读取类型提示并不是100%可靠的，可能会在 2022 年发生变化。
- en: Note
  id: totrans-294
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Companies using Python at a very large scale want the benefits of static typing,
    but they don’t want to pay the price for the evaluation of the type hints at import
    time. Static checking happens at developer workstations and dedicated CI servers,
    but loading modules happens at a much higher frequency and volume in the production
    containers, and this cost is not negligible at scale.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在大规模使用 Python 的公司中，他们希望获得静态类型的好处，但不想在导入时评估类型提示的代价。静态检查发生在开发人员的工作站和专用 CI 服务器上，但在生产容器中，模块的加载频率和数量要高得多，这种成本在规模上是不可忽略的。
- en: This creates tension in the Python community between those who want type hints
    to be stored as strings only—to reduce the loading costs—versus those who also
    want to use type hints at runtime, like the creators and users of *pydantic* and
    *FastAPI*, who would rather have type objects stored instead of having to evaluate
    those annotations, a challenging task.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 Python 社区中引发了紧张气氛，一方面是希望类型提示仅以字符串形式存储，以减少加载成本，另一方面是希望在运行时也使用类型提示的人，比如 *pydantic*
    和 *FastAPI* 的创建者和用户，他们更希望将类型对象存储起来，而不是评估这些注释，这是一项具有挑战性的任务。
- en: Dealing with the Problem
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理问题
- en: 'Given the unstable situation at present, if you need to read annotations at
    runtime, I recommend:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于目前的不稳定局势，如果您需要在运行时阅读注释，我建议：
- en: Avoid reading `__annotations__` directly; instead, use `inspect.get_annotations`
    (from Python 3.10) or `typing.get_type_hints` (since Python 3.5).
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免直接读取`__annotations__`；而是使用`inspect.get_annotations`（从 Python 3.10 开始）或`typing.get_type_hints`（自
    Python 3.5 起）。
- en: Write a custom function of your own as a thin wrapper around `in​spect​.get_annotations`
    or `typing.get_type_hints`, and have the rest of your codebase call that custom
    function, so that future changes are localized to a single function.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自己的自定义函数，作为`in​spect​.get_annotations`或`typing.get_type_hints`周围的薄包装，让您的代码库的其余部分调用该自定义函数，以便将来的更改局限于单个函数。
- en: 'To demonstrate the second point, here are the first lines of the `Checked`
    class defined in [Example 24-5](ch24.html#checked_class_top_ex), which we’ll study
    in [Chapter 24](ch24.html#class_metaprog):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示第二点，这里是在 [示例 24-5](ch24.html#checked_class_top_ex) 中定义的`Checked`类的前几行，我们将在
    [第 24 章](ch24.html#class_metaprog) 中学习：
- en: '[PRE39]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `Checked._fields` class method protects other parts of the module from depending
    directly on `typing.get_type_hints`. If `get_type_hints` changes in the future,
    requiring additional logic, or you want to replace it with `inspect.get_annotations`,
    the change is limited to `Checked._fields` and does not affect the rest of your
    program.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`Checked._fields` 类方法保护模块的其他部分不直接依赖于`typing.get_type_hints`。如果`get_type_hints`在将来发生变化，需要额外的逻辑，或者您想用`inspect.get_annotations`替换它，更改将局限于`Checked._fields`，不会影响程序的其余部分。'
- en: Warning
  id: totrans-304
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Given the ongoing discussions and proposed changes for runtime inspection of
    type hints, the official [“Annotations Best Practices”](https://fpy.li/15-28)
    document is required reading, and is likely to be updated on the road to Python
    3.11. That how-to was written by Larry Hastings, the author of [PEP 649—Deferred
    Evaluation Of Annotations Using Descriptors](https://fpy.li/pep649), an alternative
    proposal to address the runtime issues raised by [PEP 563—Postponed Evaluation
    of Annotations](https://fpy.li/pep563).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于关于运行时检查类型提示的持续讨论和提出的更改，官方的[“注释最佳实践”](https://fpy.li/15-28)文档是必读的，并且可能会在通往
    Python 3.11 的道路上进行更新。这篇指南是由 Larry Hastings 撰写的，他是 [PEP 649—使用描述符延迟评估注释](https://fpy.li/pep649)
    的作者，这是一个解决由 [PEP 563—延迟评估注释](https://fpy.li/pep563) 提出的运行时问题的替代提案。
- en: The remaining sections of this chapter cover generics, starting with how to
    define a generic class that can be parameterized by its users.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分涵盖了泛型，从如何定义一个可以由用户参数化的泛型类开始。
- en: Implementing a Generic Class
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个通用类
- en: 'In [Example 13-7](ch13.html#ex_tombola_abc) we defined the `Tombola` ABC: an
    interface for classes that work like a bingo cage. The `LottoBlower` class from
    [Example 13-10](ch13.html#ex_lotto) is a concrete implementation. Now we’ll study
    a generic version of `LottoBlower` used like in [Example 15-15](#ex_generic_lotto_demo).'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 13-7](ch13.html#ex_tombola_abc) 中，我们定义了`Tombola` ABC：一个类似于宾果笼的接口。来自 [示例
    13-10](ch13.html#ex_lotto) 的`LottoBlower` 类是一个具体的实现。现在我们将研究一个通用版本的`LottoBlower`，就像在
    [示例 15-15](#ex_generic_lotto_demo) 中使用的那样。
- en: 'Example 15-15\. generic_lotto_demo.py: using a generic lottery blower class'
  id: totrans-309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-15\. generic_lotto_demo.py：使用通用抽奖机类
- en: '[PRE40]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[![1](assets/1.png)](#co_more_about_type_hints_CO11-1)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_more_about_type_hints_CO11-1)'
- en: To instantiate a generic class, we give it an actual type parameter, like `int`
    here.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要实例化一个通用类，我们给它一个实际的类型参数，比如这里的`int`。
- en: '[![2](assets/2.png)](#co_more_about_type_hints_CO11-2)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_more_about_type_hints_CO11-2)'
- en: Mypy will correctly infer that `first` is an `int`…
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy 将正确推断`first`是一个`int`…
- en: '[![3](assets/3.png)](#co_more_about_type_hints_CO11-3)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_more_about_type_hints_CO11-3)'
- en: … and that `remain` is a `tuple` of integers.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: … 而`remain`是一个整数��元组。
- en: In addition, Mypy reports violations of the parameterized type with helpful
    messages, such as what’s shown in [Example 15-16](#ex_generic_lotto_errors).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Mypy 还报告了参数化类型的违规情况，并提供了有用的消息，就像 [示例 15-16](#ex_generic_lotto_errors) 中显示的那样。
- en: 'Example 15-16\. generic_lotto_errors.py: errors reported by Mypy'
  id: totrans-318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-16\. generic_lotto_errors.py：Mypy 报告的错误
- en: '[PRE41]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[![1](assets/1.png)](#co_more_about_type_hints_CO12-1)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_more_about_type_hints_CO12-1)'
- en: Upon instantiation of `LottoBlower[int]`, Mypy flags the `float`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化`LottoBlower[int]`时，Mypy 标记了`float`。
- en: '[![2](assets/2.png)](#co_more_about_type_hints_CO12-2)'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_more_about_type_hints_CO12-2)'
- en: 'When calling `.load(''ABC'')`, Mypy explains why a `str` won’t do: `str.__iter__`
    returns an `Iterator[str]`, but `LottoBlower[int]` requires an `Iterator[int]`.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`.load('ABC')`时，Mypy 解释了为什么`str`不行：`str.__iter__`返回一个`Iterator[str]`，但`LottoBlower[int]`需要一个`Iterator[int]`。
- en: '[Example 15-17](#ex_generic_lotto) is the implementation.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-17](#ex_generic_lotto) 是实现。'
- en: 'Example 15-17\. generic_lotto.py: a generic lottery blower class'
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-17\. generic_lotto.py：一个通用的抽奖机类
- en: '[PRE42]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[![1](assets/1.png)](#co_more_about_type_hints_CO13-1)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_more_about_type_hints_CO13-1)'
- en: Generic class declarations often use multiple inheritance, because we need to
    subclass `Generic` to declare the formal type parameters—in this case, `T`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类声明通常使用多重继承，因为我们需要子类化`Generic`来声明形式类型参数——在本例中为`T`。
- en: '[![2](assets/2.png)](#co_more_about_type_hints_CO13-2)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_more_about_type_hints_CO13-2)'
- en: The `items` argument in `__init__` is of type `Iterable[T]`, which becomes `Iterable[int]`
    when an instance is declared as `LottoBlower[int]`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__`中的`items`参数的类型为`Iterable[T]`，当实例声明为`LottoBlower[int]`时，变为`Iterable[int]`。'
- en: '[![3](assets/3.png)](#co_more_about_type_hints_CO13-3)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_more_about_type_hints_CO13-3)'
- en: The `load` method is likewise constrained.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`load`方法也受到限制。'
- en: '[![4](assets/4.png)](#co_more_about_type_hints_CO13-4)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_more_about_type_hints_CO13-4)'
- en: The return type of `T` now becomes `int` in a `LottoBlower[int]`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`T`的返回类型现在在`LottoBlower[int]`中变为`int`。'
- en: '[![5](assets/5.png)](#co_more_about_type_hints_CO13-5)'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_more_about_type_hints_CO13-5)'
- en: No type variable here.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有类型变量。
- en: '[![6](assets/6.png)](#co_more_about_type_hints_CO13-6)'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_more_about_type_hints_CO13-6)'
- en: Finally, `T` sets the type of the items in the returned `tuple`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`T`设置了返回的`tuple`中项目的类型。
- en: Tip
  id: totrans-339
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The [“User-defined generic types”](https://fpy.li/15-29) section of the `typing`
    module documentation is short, presents good examples, and provides a few more
    details that I do not cover here.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`typing`模块文档中的[“用户定义的泛型类型”](https://fpy.li/15-29)部分很简短，提供了很好的例子，并提供了一些我这里没有涵盖的更多细节。'
- en: Now that we’ve seen how to implement a generic class, let’s define the terminology
    to talk about generics.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到如何实现泛型类，让我们定义术语来谈论泛型。
- en: Basic Jargon for Generic Types
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型类型的基本术语
- en: Here are a few definitions that I found useful when studying generics:^([14](ch15.html#idm46582412814672))
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个我在学习泛型时发现有用的定义：^([14](ch15.html#idm46582412814672))
- en: Generic type
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型
- en: A type declared with one or more type variables.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 声明有一个或多个类型变量的类型。
- en: 'Examples: `LottoBlower[T]`, `abc.Mapping[KT, VT]`'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 例子：`LottoBlower[T]`，`abc.Mapping[KT, VT]`
- en: Formal type parameter
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 形式类型参数
- en: The type variables that appear in a generic type declaration.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 出现在泛型类型声明中的类型变量。
- en: 'Example: `KT` and `VT` in the previous example `abc.Mapping[KT, VT]`'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 例子：前面例子`abc.Mapping[KT, VT]`中的`KT`和`VT`
- en: Parameterized type
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化类型
- en: A type declared with actual type parameters.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 声明为具有实际类型参数的类型。
- en: 'Examples: `LottoBlower[int]`, `abc.Mapping[str, float]`'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 例子：`LottoBlower[int]`，`abc.Mapping[str, float]`
- en: Actual type parameter
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 实际类型参数
- en: The actual types given as parameters when a parameterized type is declared.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明参数化类型时给定的实际类型。
- en: 'Example: the `int` in `LottoBlower[int]`'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 例子：`LottoBlower[int]`中的`int`
- en: The next topic is about how to make generic types more flexible, introducing
    the concepts of covariance, contravariance, and invariance.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个主题是如何使泛型类型更灵活，引入协变、逆变和不变的概念。
- en: Variance
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方差
- en: Note
  id: totrans-358
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Depending on your experience with generics in other languages, this may be the
    most challenging section in the book. The concept of variance is abstract, and
    a rigorous presentation would make this section look like pages from a math book.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您在其他语言中对泛型的经验，这可能是本书中最具挑战性的部分。方差的概念是抽象的，严谨的表述会使这一部分看起来像数学书中的页面。
- en: In practice, variance is mostly relevant to library authors who want to support
    new generic container types or provide callback-based APIs. Even then, you can
    avoid much complexity by supporting only invariant containers—which is mostly
    what we have now in the Python standard library. So, on a first reading, you can
    skip the whole section or just read the sections about invariant types.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，方差主要与想要支持新的泛型容器类型或提供基于回调的API的库作者有关。即使如此，通过仅支持不变容器，您可以避免许多复杂性——这基本上是我们现在在Python标准库中所拥有的。因此，在第一次阅读时，您可以跳过整个部分，或者只阅读关于不变类型的部分。
- en: We first saw the concept of *variance* in [“Variance in Callable types”](ch08.html#callable_variance_sec),
    applied to parameterized generic `Callable` types. Here we’ll expand the concept
    to cover generic collection types, using a “real world” analogy to make this abstract
    concept more concrete.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首次在[“可调用类型的方差”](ch08.html#callable_variance_sec)中看到了*方差*的概念，应用于参数化泛型`Callable`类型。在这里，我们将扩展这个概念，涵盖泛型集合类型，使用“现实世界”的类比使这个抽象概念更具体。
- en: Imagine that a school cafeteria has a rule that only juice dispensers can be
    installed.^([15](ch15.html#idm46582412790496)) General beverage dispensers are
    not allowed because they may serve sodas, which are banned by the school board.^([16](ch15.html#idm46582412788720))
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下学校食堂有一个规定，只能安装果汁分配器。只有果汁分配器是被允许的，因为它们可能提供被学校董事会禁止的苏打水。^([15](ch15.html#idm46582412790496))^([16](ch15.html#idm46582412788720))
- en: An Invariant Dispenser
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不变的分配器
- en: Let’s try to model the cafeteria scenario with a generic `BeverageDispenser`
    class that can be parameterized on the type of beverage. See [Example 15-18](#invariant_dispenser_types_ex).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试用一个可以根据饮料类型进行参数化的泛型`BeverageDispenser`类来模拟食堂场景。请参见[例15-18](#invariant_dispenser_types_ex)。
- en: 'Example 15-18\. invariant.py: type definitions and `install` function'
  id: totrans-365
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例15-18\. invariant.py：类型定义和`install`函数
- en: '[PRE43]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[![1](assets/1.png)](#co_more_about_type_hints_CO14-1)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_more_about_type_hints_CO14-1)'
- en: '`Beverage`, `Juice`, and `OrangeJuice` form a type hierarchy.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`Beverage`、`Juice`和`OrangeJuice`形成一个类型层次结构。'
- en: '[![2](assets/2.png)](#co_more_about_type_hints_CO14-2)'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_more_about_type_hints_CO14-2)'
- en: Simple `TypeVar` declaration.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的`TypeVar`声明。
- en: '[![3](assets/3.png)](#co_more_about_type_hints_CO14-3)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_more_about_type_hints_CO14-3)'
- en: '`BeverageDispenser` is parameterized on the type of beverage.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`BeverageDispenser`的类型参数化为饮料的类型。'
- en: '[![4](assets/4.png)](#co_more_about_type_hints_CO14-4)'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_more_about_type_hints_CO14-4)'
- en: '`install` is a module-global function. Its type hint enforces the rule that
    only a juice dispenser is acceptable.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`install`是一个模块全局函数。它的类型提示强制执行只有果汁分配器是可接受的规则。'
- en: 'Given the definitions in [Example 15-18](#invariant_dispenser_types_ex), the
    following code is legal:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于[例15-18](#invariant_dispenser_types_ex)中的定义，以下代码是合法的：
- en: '[PRE44]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'However, this is not legal:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是不合法的：
- en: '[PRE45]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: A dispenser that serves any `Beverage` is not acceptable because the cafeteria
    requires a dispenser that is specialized for `Juice`.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 任何`饮料`的分配器都是不可接受的，因为食堂需要专门用于`果汁`的分配器。
- en: 'Somewhat surprisingly, this code is also illegal:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，这段代码也是非法的：
- en: '[PRE46]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: A dispenser specialized for `OrangeJuice` is not allowed either. Only `BeverageDispenser[Juice]`
    will do. In the typing jargon, we say that `BeverageDispenser(Generic[T])` is
    invariant when `BeverageDispenser[OrangeJuice]` is not compatible with `BeverageDispenser[Juice]`—despite
    the fact that `OrangeJuice` is a *subtype-of* `Juice`.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 专门用于`橙汁`的分配器也是不允许的。只有`BeverageDispenser[Juice]`才行。在类型术语中，我们说`BeverageDispenser(Generic[T])`是不变的，当`BeverageDispenser[OrangeJuice]`与`BeverageDispenser[Juice]`不兼容时——尽管`OrangeJuice`是`Juice`的*子类型*。
- en: Python mutable collection types—such as `list` and `set`—are invariant. The
    `LottoBlower` class from [Example 15-17](#ex_generic_lotto) is also invariant.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: Python可变集合类型——如`list`和`set`——是不变的。来自[示例 15-17](#ex_generic_lotto)的`LottoBlower`类也是不变的。
- en: A Covariant Dispenser
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个协变分配器
- en: If we want to be more flexible and model dispensers as a generic class that
    can accept some beverage type and also its subtypes, we must make it covariant.
    [Example 15-19](#covariant_dispenser_types_ex) shows how we’d declare `BeverageDispenser`.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想更灵活地建模分配器作为一个通用类，可以接受某种饮料类型及其子类型，我们必须使其协变。[示例 15-19](#covariant_dispenser_types_ex)展示了如何声明`BeverageDispenser`。
- en: 'Example 15-19\. *covariant.py*: type definitions and `install` function'
  id: totrans-386
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-19\. *covariant.py*：类型定义和`install`函数
- en: '[PRE47]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[![1](assets/1.png)](#co_more_about_type_hints_CO15-1)'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_more_about_type_hints_CO15-1)'
- en: Set `covariant=True` when declaring the type variable; `_co` is a conventional
    suffix for covariant type parameters on *typeshed*.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明类型变量时，设置`covariant=True`；`_co`是*typeshed*上协变类型参数的常规后缀。
- en: '[![2](assets/2.png)](#co_more_about_type_hints_CO15-2)'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_more_about_type_hints_CO15-2)'
- en: Use `T_co` to parameterize the `Generic` special class.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`T_co`来为`Generic`特殊类进行参数化。
- en: '[![3](assets/3.png)](#co_more_about_type_hints_CO15-3)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_more_about_type_hints_CO15-3)'
- en: Type hints for `install` are the same as in [Example 15-18](#invariant_dispenser_types_ex).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`install`的类型提示与[示例 15-18](#invariant_dispenser_types_ex)中的相同。
- en: 'The following code works because now both the `Juice` dispenser and the `OrangeJuice`
    dispenser are valid in a covariant `BeverageDispenser`:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码有效，因为现在`Juice`分配器和`OrangeJuice`分配器都在协变`BeverageDispenser`中有效：
- en: '[PRE48]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'But a dispenser for an arbitrary `Beverage` is not acceptable:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，任意`饮料`的分配器也是不可接受的：
- en: '[PRE49]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'That’s covariance: the subtype relationship of the parameterized dispensers
    varies in the same direction as the subtype relationship of the type parameters.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是协变性：参数化分配器的子类型关系与类型参数的子类型关系方向相同变化。
- en: A Contravariant Trash Can
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逆变垃圾桶
- en: Now we’ll model the cafeteria rule for deploying a trash can. Let’s assume food
    and drinks are served in biodegradable packages, and leftovers as well as single-use
    utensils are also biodegradable. The trash cans must be suitable for biodegradable
    refuse.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将模拟食堂设置垃圾桶的规则。让���们假设食物和饮料都是用生物降解包装，剩菜剩饭以及一次性餐具也是生物降解的。垃圾桶必须适用于生物降解的废物。
- en: Note
  id: totrans-401
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'For the sake of this didactic example, let’s make simplifying assumptions to
    classify trash in a neat hierarchy:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个教学示例，让我们做出简化假设，将垃圾分类为一个整洁的层次结构：
- en: '`Refuse` is the most general type of trash. All trash is refuse.'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`废物`是最一般的垃圾类型。所有垃圾都是废物。'
- en: '`Biodegradable` is a specific type of trash that can be decomposed by organisms
    over time. Some `Refuse` is not `Biodegradable`.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`生物降解`是一种可以随时间被生物分解的垃圾类型。一些`废物`不是`生物降解`的。'
- en: '`Compostable` is a specific type of `Biodegradable` trash that can be efficiently
    turned into organic fertilizer in a compost bin or in a composting facility. Not
    all `Biodegradable` trash is `Compostable` in our definition.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`可堆肥`是一种特定类型的`生物降解`垃圾，可以在堆肥桶或堆肥设施中高效地转化为有机肥料。在我们的定义中，并非所有`生物降解`垃圾都是`可堆肥`的。'
- en: In order to model the rule for an acceptable trash can in the cafeteria, we
    need to introduce the concept of “contravariance” through an example using it,
    as shown in [Example 15-20](#contravariant_trash_ex).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟食堂中可接受垃圾桶的规则，我们需要通过一个示例引入“逆变性”概念，如[示例 15-20](#contravariant_trash_ex)所示。
- en: 'Example 15-20\. *contravariant.py*: type definitions and `install` function'
  id: totrans-407
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-20\. *contravariant.py*：类型定义和`install`函数
- en: '[PRE50]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[![1](assets/1.png)](#co_more_about_type_hints_CO16-1)'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_more_about_type_hints_CO16-1)'
- en: 'A type hierarchy for refuse: `Refuse` is the most general type, `Compostable`
    is the most specific.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾的类型层次结构：`废物`是最一般的类型，`可堆肥`是最具体的。
- en: '[![2](assets/2.png)](#co_more_about_type_hints_CO16-2)'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_more_about_type_hints_CO16-2)'
- en: '`T_contra` is a conventional name for a contravariant type variable.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`T_contra`是逆变类型变量的常规名称。'
- en: '[![3](assets/3.png)](#co_more_about_type_hints_CO16-3)'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_more_about_type_hints_CO16-3)'
- en: '`TrashCan` is contravariant on the type of refuse.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`TrashCan`在废物类型上是逆变的。'
- en: 'Given those definitions, these types of trash cans are acceptable:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些定义，以下类型的垃圾桶是可接受的：
- en: '[PRE51]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The more general `TrashCan[Refuse]` is acceptable because it can take any kind
    of refuse, including `Biodegradable`. However, a `TrashCan[Compostable]` will
    not do, because it cannot take `Biodegradable`:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般的`TrashCan[Refuse]`是可接受的，因为它可以接受任何类型的废物，包括`生物降解`。然而，`TrashCan[Compostable]`不行，因为它不能接受`生物降解`：
- en: '[PRE52]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Let’s summarize the concepts we just saw.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下我们刚刚看到的概念。
- en: Variance Review
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变异回顾
- en: Variance is a subtle property. The following sections recap the concept of invariant,
    covariant, and contravariant types, and provide some rules of thumb to reason
    about them.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 变异是一个微妙的属性。以下部分总结了不变、协变和逆变类型的概念，并提供了一些关于它们推理的经验法则。
- en: Invariant types
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不变类型
- en: A generic type `L` is invariant when there is no supertype or subtype relationship
    between two parameterized types, regardless of the relationship that may exist
    between the actual parameters. In other words, if `L` is invariant, then `L[A]`
    is not a supertype or a subtype of `L[B]`. They are inconsistent in both ways.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个参数化类型之间没有超类型或子类型关系时，泛型类型 `L` 是不变的，而不管实际参数之间可能存在的关系。换句话说，如果 `L` 是不变的，那么 `L[A]`
    不是 `L[B]` 的超类型或子类型。它们在两个方面都不一致。
- en: 'As mentioned, Python’s mutable collections are invariant by default. The `list`
    type is a good example: `list[int]` is not *consistent-with* `list[float]` and
    vice versa.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Python的可变集合默认是不变的。`list` 类型是一个很好的例子：`list[int]` 与 `list[float]` 不一致，反之亦然。
- en: In general, if a formal type parameter appears in type hints of method arguments,
    and the same parameter appears in method return types, that parameter must be
    invariant to ensure type safety when updating and reading from the collection.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果一个形式类型参数出现在方法参数的类型提示中，并且相同的参数出现在方法返回类型中，那么为了确保在更新和读取集合时的类型安全，该参数必须是不变的。
- en: 'For example, here is part of the type hints for the `list` built-in on [*typeshed*](https://fpy.li/15-30):'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是 `list` 内置的类型提示的一部分[*typeshed*](https://fpy.li/15-30)：
- en: '[PRE53]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note that `_T` appears in the arguments of `__init__`, `append`, and `extend`,
    and as the return type of `pop`. There is no way to make such a class type safe
    if it is covariant or contravariant in `_T`.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `_T` 出现在 `__init__`、`append` 和 `extend` 的参数中，以及 `pop` 的返回类型中。如果 `_T` 在 `_T`
    中是协变或逆变的，那么没有办法使这样的类类型安全。
- en: Covariant types
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协变类型
- en: 'Consider two types `A` and `B`, where `B` is *consistent-with* `A`, and neither
    of them is `Any`. Some authors use the `<:` and `:>` symbols to denote type relationships
    like this:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑两种类型 `A` 和 `B`，其中 `B` 与 `A` 一致，且它们都不是 `Any`。一些作者使用 `<:` 和 `:>` 符号来表示这样的类型关系：
- en: '`A :> B`'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`A :> B`'
- en: '`A` is a *supertype-of* or the same as `B`.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '`A` 是 `B` 的超类型或相同。'
- en: '`B <: A`'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '`B <: A`'
- en: '`B` is a *subtype-of* or the same as `A`.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`B` 是 `A` 的子类型或相同。'
- en: Given `A :> B`, a generic type `C` is covariant when `C[A] :> C[B]`.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 `A :> B`，泛型类型 `C` 在 `C[A] :> C[B]` 时是协变的。
- en: Note the direction of the `:>` symbol is the same in both cases where `A` is
    to the left of `B`. Covariant generic types follow the subtype relationship of
    the actual type parameters.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `:>` 符号的方向在 `A` 在 `B` 的左侧时是相同的。协变泛型类型遵循实际类型参数的子类型关系。
- en: 'Immutable containers can be covariant. For example, this is how the `typing.FrozenSet`
    class is [documented](https://fpy.li/15-31) as a covariant with a type variable
    using the conventional name `T_co`:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变容器可以是协变的。例如，`typing.FrozenSet` 类是如何 [文档化](https://fpy.li/15-31) 作为一个协变的，使用传统名称
    `T_co` 的类型变量：
- en: '[PRE54]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Applying the `:>` notation to parameterized types, we have:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `:>` 符号应用于参数化类型，我们有：
- en: '[PRE55]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Iterators are another example of covariant generics: they are not read-only
    collections like a `frozenset`, but they only produce output. Any code expecting
    an `abc.Iterator[float]` yielding floats can safely use an `abc.Iterator[int]`
    yielding integers. `Callable` types are covariant on the return type for a similar
    reason.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是协变泛型的另一个例子：它们不是只读集合，如 `frozenset`，但它们只产生输出。任何期望一个产生浮点数的 `abc.Iterator[float]`
    的代码可以安全地使用一个产生整数的 `abc.Iterator[int]`。`Callable` 类型在返回类型上是协变的，原因类似。
- en: Contravariant types
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逆变类型
- en: 'Given `A :> B`, a generic type `K` is contravariant if `K[A] <: K[B]`.'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '给定 `A :> B`，泛型类型 `K` 在 `K[A] <: K[B]` 时是逆变的。'
- en: Contravariant generic types reverse the subtype relationship of the actual type
    parameters.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 逆变泛型类型颠倒了实际类型参数的子类型关系。
- en: 'The `TrashCan` class exemplifies this:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '`TrashCan` 类是一个例子：'
- en: '[PRE56]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: A contravariant container is usually a write-only data structure, also known
    as a “sink.” There are no examples of such collections in the standard library,
    but there are a few types with contravariant type parameters.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 逆变容器通常是一个只写数据结构，也称为“接收器”。标准库中没有这样的集合的例子，但有一些具有逆变类型参数的类型。
- en: '`Callable[[ParamType, …], ReturnType]` is contravariant on the parameter types,
    but covariant on the `ReturnType`, as we saw in [“Variance in Callable types”](ch08.html#callable_variance_sec).
    In addition, [`Generator`](https://fpy.li/15-32), [`Coroutine`](https://fpy.li/typecoro),
    and [`AsyncGenerator`](https://fpy.li/15-33) have one contravariant type parameter.
    The `Generator` type is described in [“Generic Type Hints for Classic Coroutines”](ch17.html#generic_classic_coroutine_types_sec);
    `Coroutine` and `AsyncGenerator` are described in [Chapter 21](ch21.html#async_ch).'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`Callable[[ParamType, …], ReturnType]` 在参数类型上是逆变的，但在 `ReturnType` 上是协变的，正如我们在
    [“Callable 类型的方差”](ch08.html#callable_variance_sec) 中看到的。此外，[`Generator`](https://fpy.li/15-32)、[`Coroutine`](https://fpy.li/typecoro)
    和 [`AsyncGenerator`](https://fpy.li/15-33) 有一个逆变类型参数。`Generator` 类型在 [“经典协程的泛型类型提示”](ch17.html#generic_classic_coroutine_types_sec)
    中有描述；`Coroutine` 和 `AsyncGenerator` 在 [第21章](ch21.html#async_ch) 中有描述。'
- en: For the present discussion about variance, the main point is that the contravariant
    formal parameter defines the type of the arguments used to invoke or send data
    to the object, while different covariant formal parameters define the types of
    outputs produced by the object—the yield type or the return type, depending on
    the object. The meanings of “send” and “yield” are explained in [“Classic Coroutines”](ch17.html#classic_coroutines_sec).
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 对于关于方差的讨论，主要观点是逆变的形式参数定义了用于调用或发送数据到对象的参数类型，而不同的协变形式参数定义了对象产生的输出类型——产生类型或返回类型，取决于对象。
    “发送” 和 “产出” 的含义在 [“经典协程”](ch17.html#classic_coroutines_sec) 中有解释。
- en: We can derive useful guidelines from these observations of covariant outputs
    and contravariant inputs.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从这些关于协变输出和逆变输入的观察中得出有用的指导方针。
- en: Variance rules of thumb
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协变的经验法则
- en: 'Finally, here are a few rules of thumb to reason about when thinking through
    variance:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下是一些关于推理方差时的经验法则：
- en: If a formal type parameter defines a type for data that comes out of the object,
    it can be covariant.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个形式类型参数定义了从对象中输出的数据类型，那么它可以是协变的。
- en: If a formal type parameter defines a type for data that goes into the object
    after its initial construction, it can be contravariant.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果形式类型参数定义了一个类型，用于在对象初始构建后进入对象的数据，它可以是逆变的。
- en: If a formal type parameter defines a type for data that comes out of the object
    and the same parameter defines a type for data that goes into the object, it must
    be invariant.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果形式类型参数定义了一个用于从对象中提取数据的类型，并且同一参数定义了一个用于将数据输入对象的类型，则它必须是不变的。
- en: To err on the safe side, make formal type parameters invariant.
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了保险起见，使形式类型参数不变。
- en: '`Callable[[ParamType, …], ReturnType]` demonstrates rules #1 and #2: The `ReturnType`
    is covariant, and each `ParamType` is contravariant.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`Callable[[ParamType, …], ReturnType]`展示了规则#1和#2：`ReturnType`是协变的，而每个`ParamType`是逆变的。'
- en: By default, `TypeVar` creates formal parameters that are invariant, and that’s
    how the mutable collections in the standard library are annotated.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`TypeVar`创建的形式参数是不变的，这就是标准库中的可变集合是如何注释的。
- en: '[“Generic Type Hints for Classic Coroutines”](ch17.html#generic_classic_coroutine_types_sec)
    continues the present discussion about variance.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '[“经典协程的通用类型提示”](ch17.html#generic_classic_coroutine_types_sec)继续讨论关于方差的内容。'
- en: Next, let’s see how to define generic static protocols, applying the idea of
    covariance to a couple of new examples.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何定义通用的静态协议，将协变的思想应用到几个新的示例中。
- en: Implementing a Generic Static Protocol
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现通用的静态协议
- en: 'The Python 3.10 standard library provides a few generic static protocols. One
    of them is `SupportsAbs`, implemented like this in [the *typing* module](https://fpy.li/15-34):'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.10标准库提供了一些通用的静态协议。其中之一是`SupportsAbs`，在[typing模块](https://fpy.li/15-34)中实现如下：
- en: '[PRE57]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`T_co` is declared according to the naming convention:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '`T_co`根据命名约定声明：'
- en: '[PRE58]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Thanks to `SupportsAbs`, Mypy recognizes this code as valid, as you can see
    in [Example 15-21](#ex_abs_demo).
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`SupportsAbs`，Mypy将此代码识别为有效，如您在[示例15-21](#ex_abs_demo)中所见。
- en: 'Example 15-21\. *abs_demo.py*: use of the generic `SupportsAbs` protocol'
  id: totrans-467
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例15-21。*abs_demo.py*：使用通用的`SupportsAbs`协议
- en: '[PRE59]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[![1](assets/1.png)](#co_more_about_type_hints_CO17-1)'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_more_about_type_hints_CO17-1)'
- en: Defining `__abs__` makes `Vector2d` *consistent-with* `SupportsAbs`.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 定义`__abs__`使`Vector2d`与`SupportsAbs`*一致*。
- en: '[![2](assets/2.png)](#co_more_about_type_hints_CO17-2)'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_more_about_type_hints_CO17-2)'
- en: Parameterizing `SupportsAbs` with `float` ensures…
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`float`参数化`SupportsAbs`确保…
- en: '[![3](assets/3.png)](#co_more_about_type_hints_CO17-3)'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_more_about_type_hints_CO17-3)'
- en: …that Mypy accepts `abs(v)` as the first argument for `math.isclose`.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: …Mypy接受`abs(v)`作为`math.isclose`的第一个参数。
- en: '[![4](assets/4.png)](#co_more_about_type_hints_CO17-4)'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_more_about_type_hints_CO17-4)'
- en: Thanks to `@runtime_checkable` in the definition of `SupportsAbs`, this is a
    valid runtime assertion.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SupportsAbs`的定义中，感谢`@runtime_checkable`，这是一个有效的运行时断言。
- en: '[![5](assets/5.png)](#co_more_about_type_hints_CO17-5)'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_more_about_type_hints_CO17-5)'
- en: The remaining code all passes Mypy checks and runtime assertions.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 剩���的代码都通过了Mypy检查和运行时断言。
- en: '[![6](assets/6.png)](#co_more_about_type_hints_CO17-6)'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_more_about_type_hints_CO17-6)'
- en: The `int` type is also *consistent-with* `SupportsAbs`. According to [*typeshed*](https://fpy.li/15-35),
    `int.__abs__` returns an `int`, which is *consistent-with* the `float` type parameter
    declared in the `is_unit` type hint for the `v` argument.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '`int`类型也与`SupportsAbs`*一致*。根据[*typeshed*](https://fpy.li/15-35)，`int.__abs__`返回一个`int`，这与`is_unit`类型提示中为`v`参数声明的`float`类型参数*一致*。'
- en: Similarly, we can write a generic version of the `RandomPicker` protocol presented
    in [Example 13-18](ch13.html#ex_randompick_protocol), which was defined with a
    single method `pick` returning `Any`.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以编写`RandomPicker`协议的通用版本，该协议在[示例13-18](ch13.html#ex_randompick_protocol)中介绍，该协议定义了一个返回`Any`的单个方法`pick`。
- en: '[Example 15-22](#ex_generic_randompick_protocol) shows how to make a generic
    `RandomPicker` covariant on the return type of `pick`.'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例15-22](#ex_generic_randompick_protocol)展示了如何使通用的`RandomPicker`在`pick`的返回类型上具有协变性。'
- en: 'Example 15-22\. *generic_randompick.py*: definition of generic `RandomPicker`'
  id: totrans-483
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例15-22。*generic_randompick.py*：定义通用的`RandomPicker`
- en: '[PRE60]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[![1](assets/1.png)](#co_more_about_type_hints_CO18-1)'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_more_about_type_hints_CO18-1)'
- en: Declare `T_co` as `covariant`.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 将`T_co`声明为`协变`。
- en: '[![2](assets/2.png)](#co_more_about_type_hints_CO18-2)'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_more_about_type_hints_CO18-2)'
- en: This makes `RandomPicker` generic with a covariant formal type parameter.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 这使`RandomPicker`具有协变的形式类型参数。
- en: '[![3](assets/3.png)](#co_more_about_type_hints_CO18-3)'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_more_about_type_hints_CO18-3)'
- en: Use `T_co` as the return type.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`T_co`作为返回类型。
- en: The generic `RandomPicker` protocol can be covariant because its only formal
    parameter is used in a return type.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 通用的`RandomPicker`协议可以是协变的，因为它的唯一形式参数用于返回类型。
- en: With this, we can call it a chapter.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以称之为一个章节。
- en: Chapter Summary
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节总结
- en: 'The chapter started with a simple example of using `@overload`, followed by
    a much more complex example that we studied in detail: the overloaded signatures
    required to correctly annotate the `max` built-in function.'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 章节以一个简单的使用`@overload`的例子开始，接着是一个我们详细研究的更复杂的例子：正确注释`max`内置函数所需的重载签名。
- en: The `typing.TypedDict` special construct came next. I chose to cover it here,
    and not in [Chapter 5](ch05.html#data_class_ch) where we saw `typing.NamedTuple`,
    because `TypedDict` is not a class builder; it’s merely a way to add type hints
    to a variable or argument that requires a `dict` with a specific set of string
    keys, and specific types for each key—which happens when we use a `dict` as a
    record, often in the context of handling with JSON data. That section was a bit
    long because using `TypedDict` can give a false sense of security, and I wanted
    to show how runtime checks and error handling are really inevitable when trying
    to make statically structured records out of mappings that are dynamic in nature.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`typing.TypedDict`特殊构造。我选择在这里介绍它，而不是在[第5章](ch05.html#data_class_ch)中看到`typing.NamedTuple`，因为`TypedDict`不是一个类构建器；它只是一种向需要具有特定一组字符串键和每个键特定类型的`dict`添加类型提示的方式——当我们将`dict`用作记录时，通常在处理JSON数据时会发生这种情况。该部分有点长，因为使用`TypedDict`可能会给人一种虚假的安全感，我想展示在尝试将静态结构化记录转换为本质上是动态的映射时，运行时检查和错误处理是不可避免的。
- en: Next we talked about `typing.cast`, a function designed to let us guide the
    work of the type checker. It’s important to carefully consider when to use `cast`,
    because overusing it hinders the type checker.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们讨论了`typing.cast`，这是一个旨在指导类型检查器工作的函数。仔细考虑何时使用`cast`很重要，因为过度使用会妨碍类型检查器。
- en: Runtime access to type hints came next. The key point was to use `typing.​get_type_hints`
    instead of reading the `__annotations__` attribute directly. However, that function
    may be unreliable with some annotations, and we saw that Python core developers
    are still working on a way to make type hints usable at runtime, while reducing
    their impact on CPU and memory usage.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是运行时访问类型提示。关键点是使用`typing.​get_type_hints`而不是直接读取`__annotations__`属性。然而，该函数可能对某些注解不可靠，我们看到Python核心开发人员仍在努力找到一种方法，在减少对CPU和内存使用的影响的同时使类型提示在运行时可用。
- en: 'The final sections were about generics, starting with the `LottoBlower` generic
    class—which we later learned is an invariant generic class. That example was followed
    by definitions of four basic terms: generic type, formal type parameter, parameterized
    type, and actual type parameter.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 最后几节是关于泛型的，首先是`LottoBlower`泛型类——我们后来了解到它是一个不变的泛型类。该示例后面是四个基本术语的定义：泛型类型、形式类型参数、参数化类型和���际类型参数。
- en: The major topic of variance was presented next, using cafeteria beverage dispensers
    and trash cans as “real life” examples of invariant, covariant, and contravariant
    generic types. Next we reviewed, formalized, and further applied those concepts
    to examples in Python’s standard library.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来介绍了主题的主要内容，使用自助餐厅饮料分配器和垃圾桶作为不变、协变和逆变通用类型的“现实生活”示例。接下来，我们对Python标准库中的示例进行了复习、形式化和进一步应用这些概念。
- en: Lastly, we saw how a generic static protocol is defined, first considering the
    `typing.SupportsAbs` protocol, and then applying the same idea to the `RandomPicker`
    example, making it more strict than the original protocol from [Chapter 13](ch13.html#ifaces_prot_abc).
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到了如何定义通用的静态协议，首先考虑`typing.SupportsAbs`协议，然后将相同的思想应用于`RandomPicker`示例，使其比[第13章](ch13.html#ifaces_prot_abc)中的原始协议更加严格。
- en: Note
  id: totrans-501
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Python’s type system is a huge and rapidly evolving subject. This chapter is
    not comprehensive. I chose to focus on topics that are either widely applicable,
    particularly challenging, or conceptually important and therefore likely to be
    relevant for a long time.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: Python的类型系统是一个庞大且快速发展的主题。本章不是全面的。我选择关注那些广泛适用、特别具有挑战性或在概念上重要且因此可能长期相关的主题。
- en: Further Reading
  id: totrans-503
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Python’s static type system was complex as initially designed, and is getting
    more complex with each passing year. [Table 15-1](#typing_peps_tbl) lists all
    the PEPs that I am aware of as of May 2021. It would take a whole book to cover
    everything.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: Python的静态类型系统最初设计复杂，随着每年的发展变得更加复杂。[表15-1](#typing_peps_tbl)列出了截至2021年5月我所知道的所有PEP。要覆盖所有内容需要一整本书。
- en: Table 15-1\. PEPs about type hints, with links in the titles. PEP with numbers
    marked with * are important enough to be mentioned in the opening paragraph of
    the [`typing` documentation](https://fpy.li/typing). Question marks in the Python
    column indicate PEPs under discussion or not yet implemented; “n/a” appears in
    informational PEPs with no specific Python version.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 表15-1。关于类型提示的PEP，标题中带有链接。带有*号的PEP编号在[`typing`文档](https://fpy.li/typing)的开头段落中提到。Python列中的问号表示正在讨论或尚未实施的PEP；“n/a”出现在没有特定Python版本的信息性PEP中。
- en: '| PEP | Title | Python | Year |'
  id: totrans-506
  prefs: []
  type: TYPE_TB
  zh: '| PEP | 标题 | Python | 年份 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-507
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 3107 | [Function Annotations](https://fpy.li/pep3107) | 3.0 | 2006 |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
  zh: '| 3107 | [函数注解](https://fpy.li/pep3107) | 3.0 | 2006 |'
- en: '| 483* | [The Theory of Type Hints](https://fpy.li/pep483) | n/a | 2014 |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '| 483* | [类型提示理论](https://fpy.li/pep483) | n/a | 2014 |'
- en: '| 484* | [Type Hints](https://fpy.li/pep484) | 3.5 | 2014 |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
  zh: '| 484* | [类型提示](https://fpy.li/pep484) | 3.5 | 2014 |'
- en: '| 482 | [Literature Overview for Type Hints](https://fpy.li/pep482) | n/a |
    2015 |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
  zh: '| 482 | [类型提示文献综述](https://fpy.li/pep482) | n/a | 2015 |'
- en: '| 526* | [Syntax for Variable Annotations](https://fpy.li/pep526) | 3.6 | 2016
    |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '| 526* | [变量注解的语法](https://fpy.li/pep526) | 3.6 | 2016 |'
- en: '| 544* | [Protocols: Structural subtyping (static duck typing)](https://fpy.li/pep544)
    | 3.8 | 2017 |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '| 544* | [协议：结构子类型（静态鸭子类型）](https://fpy.li/pep544) | 3.8 | 2017 |'
- en: '| 557 | [Data Classes](https://fpy.li/pep557) | 3.7 | 2017 |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '| 557 | [数据类](https://fpy.li/pep557) | 3.7 | 2017 |'
- en: '| 560 | [Core support for typing module and generic types](https://fpy.li/pep560)
    | 3.7 | 2017 |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '| 560 | [类型模块和泛型类型的核心支持](https://fpy.li/pep560) | 3.7 | 2017 |'
- en: '| 561 | [Distributing and Packaging Type Information](https://fpy.li/pep561)
    | 3.7 | 2017 |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '| 561 | [分发和打包类型信息](https://fpy.li/pep561) | 3.7 | 2017 |'
- en: '| 563 | [Postponed Evaluation of Annotations](https://fpy.li/pep563) | 3.7
    | 2017 |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
  zh: '| 563 | [注解的延迟评估](https://fpy.li/pep563) | 3.7 | 2017 |'
- en: '| 586* | [Literal Types](https://fpy.li/pep586) | 3.8 | 2018 |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '| 586* | [字面类型](https://fpy.li/pep586) | 3.8 | 2018 |'
- en: '| 585 | [Type Hinting Generics In Standard Collections](https://fpy.li/pep585)
    | 3.9 | 2019 |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '| 585 | [标准集合中的泛型类型提示](https://fpy.li/pep585) | 3.9 | 2019 |'
- en: '| 589* | [TypedDict: Type Hints for Dictionaries with a Fixed Set of Keys](https://fpy.li/pep589)
    | 3.8 | 2019 |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
  zh: '| 589* | [TypedDict：具有固定键集的字典的类型提示](https://fpy.li/pep589) | 3.8 | 2019 |'
- en: '| 591* | [Adding a final qualifier to typing](https://fpy.li/pep591) | 3.8
    | 2019 |'
  id: totrans-521
  prefs: []
  type: TYPE_TB
  zh: '| 591* | [向 typing 添加 final 修饰符](https://fpy.li/pep591) | 3.8 | 2019 |'
- en: '| 593 | [Flexible function and variable annotations](https://fpy.li/pep593)
    | ? | 2019 |'
  id: totrans-522
  prefs: []
  type: TYPE_TB
  zh: '| 593 | [灵活的函数和变量注释](https://fpy.li/pep593) | ? | 2019 |'
- en: '| 604 | [Allow writing union types as X &#124; Y](https://fpy.li/pep604) |
    3.10 | 2019 |'
  id: totrans-523
  prefs: []
  type: TYPE_TB
  zh: '| 604 | [将联合类型写为 X &#124; Y](https://fpy.li/pep604) | 3.10 | 2019 |'
- en: '| 612 | [Parameter Specification Variables](https://fpy.li/pep612) | 3.10 |
    2019 |'
  id: totrans-524
  prefs: []
  type: TYPE_TB
  zh: '| 612 | [参数规范变量](https://fpy.li/pep612) | 3.10 | 2019 |'
- en: '| 613 | [Explicit Type Aliases](https://fpy.li/pep613) | 3.10 | 2020 |'
  id: totrans-525
  prefs: []
  type: TYPE_TB
  zh: '| 613 | [显式类型别名](https://fpy.li/pep613) | 3.10 | 2020 |'
- en: '| 645 | [Allow writing optional types as x?](https://fpy.li/pep645) | ? | 2020
    |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
  zh: '| 645 | [允许将可选类型写为 x?](https://fpy.li/pep645) | ? | 2020 |'
- en: '| 646 | [Variadic Generics](https://fpy.li/pep646) | ? | 2020 |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
  zh: '| 646 | [可变泛型](https://fpy.li/pep646) | ? | 2020 |'
- en: '| 647 | [User-Defined Type Guards](https://fpy.li/pep647) | 3.10 | 2021 |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
  zh: '| 647 | [用户定义的类型守卫](https://fpy.li/pep647) | 3.10 | 2021 |'
- en: '| 649 | [Deferred Evaluation Of Annotations Using Descriptors](https://fpy.li/pep649)
    | ? | 2021 |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
  zh: '| 649 | [使用描述符延迟评估注释](https://fpy.li/pep649) | ? | 2021 |'
- en: '| 655 | [Marking individual TypedDict items as required or potentially-missing](https://fpy.li/pep655)
    | ? | 2021 |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
  zh: '| 655 | [将个别 TypedDict 项目标记为必需或可能缺失](https://fpy.li/pep655) | ? | 2021 |'
- en: Python’s official documentation hardly keeps up with all that, so [Mypy’s documentation](https://fpy.li/mypy)
    is an essential reference. [*Robust Python*](https://fpy.li/15-36) by Patrick
    Viafore (O’Reilly) is the first book with extensive coverage of Python’s static
    type system that I know about, published August 2021\. You may be reading the
    second such book right now.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的官方文档几乎无法跟上所有内容，因此[Mypy 的文档](https://fpy.li/mypy)是一个必不可少的参考。[*强大的 Python*](https://fpy.li/15-36)
    作者：帕特里克·维亚福雷（O’Reilly）是我知道的第一本广泛涵盖 Python 静态类型系统的书籍，于 2021 年 8 月出版。你现在可能正在阅读第二本这样的书籍。
- en: The subtle topic of variance has its own [section in PEP 484](https://fpy.li/15-37),
    and is also covered in the [“Generics”](https://fpy.li/15-38) page of Mypy, as
    well as in its invaluable [“Common Issues”](https://fpy.li/15-39) page.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 关于协变的微妙主题在 PEP 484 的[章节中](https://fpy.li/15-37)有专门讨论，同时也在 Mypy 的[“泛型”](https://fpy.li/15-38)页面以及其宝贵的[“常见问题”](https://fpy.li/15-39)页面中有涵盖。
- en: '[PEP 362—Function Signature Object](https://fpy.li/pep362) is worth reading
    if you intend to use the `inspect` module that complements the `typing.get_type_hints`
    function.'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读值得的[PEP 362—函数签名对象](https://fpy.li/pep362)，如果你打算使用补充`typing.get_type_hints`函数的`inspect`模块。
- en: If you are interested in the history of Python, you may like to know that Guido
    van Rossum posted [“Adding Optional Static Typing to Python”](https://fpy.li/15-40)
    on December 23, 2004.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对 Python 的历史感兴趣，你可能会喜欢知道，Guido van Rossum 在 2004 年 12 月 23 日发布了[“向 Python
    添加可选静态类型”](https://fpy.li/15-40)。
- en: '[“Python 3 Types in the Wild: A Tale of Two Type Systems”](https://fpy.li/15-41)
    is a research paper by Ingkarat Rak-amnouykit and others from the Rensselaer Polytechnic
    Institute and IBM TJ Watson Research Center. The paper surveys the use of type
    hints in open source projects on GitHub, showing that most projects don’t use
    them, and also that most projects that have type hints apparently don’t use a
    type checker. I found most interesting the discussion of the different semantics
    of Mypy and Google’s *pytype*, which they conclude are “essentially two different
    type systems.”'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '[“Python 3 中的类型在野外：两种类型系统的故事”](https://fpy.li/15-41) 是由 Rensselaer Polytechnic
    Institute 和 IBM TJ Watson 研究中心的 Ingkarat Rak-amnouykit 等人撰写的研究论文。该论文调查了 GitHub
    上开源项目中类型提示的使用情况，显示大多数项目并未使用它们，而且大多数具有类型提示的项目显然也没有使用类型检查器。我发现最有趣的是对 Mypy 和 Google
    的 *pytype* 不同语义的讨论，他们得出结论称它们“本质上是两种不同的类型系统”。'
- en: 'Two seminal papers about gradual typing are Gilad Bracha’s [“Pluggable Type
    Systems”](https://fpy.li/15-42), and [“Static Typing Where Possible, Dynamic Typing
    When Needed: The End of the Cold War Between Programming Languages”](https://fpy.li/15-43)
    by Eric Meijer and Peter Drayton.^([17](ch15.html#idm46582411210000))'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 两篇关于渐进式类型的重要论文是吉拉德·布拉查的[“可插入式类型系统”](https://fpy.li/15-42)，以及埃里克·迈杰和彼得·德雷顿撰写的[“可能时使用静态类型，需要时使用动态类型：编程语言之间的冷战结束”](https://fpy.li/15-43)^([17](ch15.html#idm46582411210000))
- en: 'I learned a lot reading the relevant parts of some books about other languages
    that implement some of the same ideas:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读其他语言实现相同思想的一些书籍的相关部分，我学到了很多：
- en: '[*Atomic Kotlin*](https://fpy.li/15-44) by Bruce Eckel and Svetlana Isakova
    (Mindview)'
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*原子 Kotlin*](https://fpy.li/15-44) 作者：布鲁斯·埃克尔和斯维特兰娜·伊萨科娃（Mindview）'
- en: '[*Effective Java*, 3rd ed.,](https://fpy.li/15-45) by Joshua Bloch (Addison-Wesley)'
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*Effective Java*，第三版](https://fpy.li/15-45) 作者：乔舒亚·布洛克（Addison-Wesley）'
- en: '[*Programming with Types: TypeScript Examples*](https://fpy.li/15-46) by Vlad
    Riscutia (Manning)'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*使用类型编程：TypeScript 示例*](https://fpy.li/15-46) 作者：弗拉德·里斯库蒂亚（Manning）'
- en: '[*Programming TypeScript*](https://fpy.li/15-47) by Boris Cherny (O’Reilly)'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*编程 TypeScript*](https://fpy.li/15-47) 作者：鲍里斯·切尔尼（O’Reilly）'
- en: '[*The Dart Programming Language*](https://fpy.li/15-48) by Gilad Bracha (Addison-Wesley)^([18](ch15.html#idm46582411197760))'
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*Dart 编程语言*](https://fpy.li/15-48) 作者：吉拉德·布拉查（Addison-Wesley）^([18](ch15.html#idm46582411197760))'
- en: For some critical views on type systems, I recommend Victor Youdaiken’s posts
    [“Bad ideas in type theory”](https://fpy.li/15-49) and [“Types considered harmful
    II”](https://fpy.li/15-50).
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些关于类型系统的批判观点，我推荐阅读维克多·尤代肯的文章[“类型理论中的坏主意”](https://fpy.li/15-49)和[“类型有害 II”](https://fpy.li/15-50)。
- en: Finally, I was surprised to find [“Generics Considered Harmful”](https://fpy.li/15-51)
    by Ken Arnold, a core contributor to Java from the beginning, as well as coauthor
    of the first four editions of the official *The Java Programming Language* book
    (Addison-Wesley)—in collaboration with James Gosling, the lead designer of Java.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我惊讶地发现了Ken Arnold的[“泛型有害论”](https://fpy.li/15-51)，他是Java的核心贡献者，也是官方*Java编程语言*书籍（Addison-Wesley）前四版的合著者之一——与Java的首席设计师James
    Gosling合作。
- en: 'Sadly, Arnold’s criticism applies to Python’s static type system as well. While
    reading the many rules and special cases of the typing PEPs, I was constantly
    reminded of this passage from Gosling’s post:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，Arnold的批评也适用于Python的静态类型系统。在阅读许多有关类型提示PEP的规则和特例时，我不断想起Gosling文章中的这段话：
- en: 'Which brings up the problem that I always cite for C++: I call it the “N^(th)
    order exception to the exception rule.” It sounds like this: “You can do x, except
    in case y, unless y does z, in which case you can if …”'
  id: totrans-546
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这就提出了我总是为C++引用的问题：我称之为“例外规则的N^(th)次例外”。听起来是这样的：“你可以做x，但在情况y下除外，除非y做z，那么你可以如果...”
- en: 'Fortunately, Python has a key advantage over Java and C++: an optional type
    system. We can squelch type checkers and omit type hints when they become too
    cumbersome.'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Python比Java和C++有一个关键优势：可选的类型系统。当类型提示变得太繁琐时，我们可以关闭类型检查器并省略类型提示。
- en: '^([1](ch15.html#idm46582416463296-marker)) From YouTube video of “A Language
    Creators’ Conversation: Guido van Rossum, James Gosling, Larry Wall, and Anders
    Hejlsberg,” streamed live on April 2, 2019\. Quote starts at [1:32:05](https://fpy.li/15-1),
    edited for brevity. Full transcript available at [*https://github.com/fluentpython/language-creators*](https://github.com/fluentpython/language-creators).'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch15.html#idm46582416463296-marker)) 来自YouTube视频“语言创作者对话：Guido van Rossum、James
    Gosling、Larry Wall和Anders Hejlsberg”，于2019年4月2日直播。引用开始于[1:32:05](https://fpy.li/15-1)，经过简化编辑。完整的文字记录可在[*https://github.com/fluentpython/language-creators*](https://github.com/fluentpython/language-creators)找到。
- en: ^([2](ch15.html#idm46582415940880-marker)) I am grateful to Jelle Zijlstra—a
    *typeshed* maintainer—who taught me several things, including how to reduce my
    original nine overloads to six.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch15.html#idm46582415940880-marker)) 我要感谢Jelle Zijlstra——一个*typeshed*的维护者——教会了我很多东西，包括如何将我最初的九个重载减少到六个。
- en: ^([3](ch15.html#idm46582414569344-marker)) As of May 2020, pytype allows it.
    But its [FAQ](https://fpy.li/15-6) says it will be disallowed in the future. See
    the question, “Why didn’t pytype catch that I changed the type of an annotated
    variable?” in the pytype [FAQ](https://fpy.li/15-6).
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch15.html#idm46582414569344-marker)) 截至2020年5月，pytype允许这样做。但其[常见问题解答](https://fpy.li/15-6)中表示将来会禁止这样做。请参见pytype[常见问题解答](https://fpy.li/15-6)中的“为什么pytype没有捕捉到我更改了已注释变量的类型？”问题。
- en: '^([4](ch15.html#idm46582414555152-marker)) I prefer to use the [lxml](https://fpy.li/15-8)
    package to generate and parse XML: it’s easy to get started, full-featured, and
    fast. Unfortunately, lxml and Python’s own [*ElementTree*](https://fpy.li/15-9)
    don’t fit the limited RAM of my hypothetical microcontroller.'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch15.html#idm46582414555152-marker)) 我更喜欢使用[lxml](https://fpy.li/15-8)包来生成和解析XML：它易于上手，功能齐全且速度快。不幸的是，lxml和Python自带的[*ElementTree*](https://fpy.li/15-9)不适用于我假想的微控制器的有限RAM。
- en: ^([5](ch15.html#idm46582414400144-marker)) The Mypy documentation discusses
    this in its [“Common issues and solutions” page](https://fpy.li/15-10), in the
    section, [“Types of empty collections”](https://fpy.li/15-11).
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch15.html#idm46582414400144-marker)) Mypy文档在其[“常见问题和解决方案”页面](https://fpy.li/15-10)中讨论了这个问题，在“空集合的类型”一节中有详细说明。
- en: '^([6](ch15.html#idm46582414301776-marker)) Brett Cannon, Guido van Rossum,
    and others have been discussing how to type hint `json.loads()` since 2016 in
    [Mypy issue #182: Define a JSON type](https://fpy.li/15-12).'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch15.html#idm46582414301776-marker)) Brett Cannon、Guido van Rossum等人自2016年以来一直在讨论如何为`json.loads()`添加类型提示，在[Mypy问题＃182：定义JSON类型](https://fpy.li/15-12)中。
- en: ^([7](ch15.html#idm46582413846128-marker)) The use of `enumerate` in the example
    is intended to confuse the type checker. A simpler implementation yielding strings
    directly instead of going through the `enumerate` index is correctly analyzed
    by Mypy, and the `cast()` is not needed.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch15.html#idm46582413846128-marker)) 示例中使用`enumerate`旨在混淆类型检查器。Mypy可以正确分析直接生成字符串而不经过`enumerate`索引的更简单的实现，因此不需要`cast()`。
- en: '^([8](ch15.html#idm46582413762864-marker)) I reported *typeshed* [issue #5535](https://fpy.li/15-17),
    “Wrong type hint for asyncio.base_events.Server sockets attribute.” and it was
    quickly fixed by Sebastian Rittau. However, I decided to keep the example because
    it illustrates a common use case for `cast`, and the `cast` I wrote is harmless.'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch15.html#idm46582413762864-marker)) 我报告了*typeshed*的[问题＃5535](https://fpy.li/15-17)，“asyncio.base_events.Server
    sockets属性的错误类型提示”，Sebastian Rittau很快就修复了。然而，我决定保留这个例子，因为它展示了`cast`的一个常见用例，而我写的`cast`是无害的。
- en: '^([9](ch15.html#idm46582413751952-marker)) To be honest, I originally appended
    a `# type: ignore` comment to the line with `server.sockets[0]` because after
    a little research I found similar lines the *asyncio* [documentation](https://fpy.li/15-18)
    and in a [test case](https://fpy.li/15-19), so I suspected the problem was not
    in my code.'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '^([9](ch15.html#idm46582413751952-marker)) 老实说，我最初在带有`server.sockets[0]`的行末添加了一个`#
    type: ignore`注释，因为经过一番调查，我在*asyncio* [文档](https://fpy.li/15-18)和一个[测试用例](https://fpy.li/15-19)中找到了类似的行，所以我怀疑问题不在我的代码中。'
- en: ^([10](ch15.html#idm46582413669200-marker)) [19 May 2020 message](https://fpy.li/15-21)
    to the typing-sig mailing list.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch15.html#idm46582413669200-marker)) [2020年5月19日消息](https://fpy.li/15-21)发送至typing-sig邮件列表。
- en: '^([11](ch15.html#idm46582413665424-marker)) The syntax `# type: ignore[code]`
    allows you to specify which Mypy error code is being silenced, but the codes are
    not always easy to interpret. See [“Error codes”](https://fpy.li/15-22) in the
    Mypy documentation.'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '^([11](ch15.html#idm46582413665424-marker)) 语法`# type: ignore[code]`允许您指定要消除的Mypy错误代码，但这些代码并不总是容易解释。请参阅Mypy文档中的[“错误代码”](https://fpy.li/15-22)。'
- en: ^([12](ch15.html#idm46582413651904-marker)) I will not go into the implementation
    of `clip`, but you can read the whole module in [*clip_annot.py*](https://fpy.li/15-23)
    if you’re curious.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: ^([12](ch15.html#idm46582413651904-marker)) 我不会详细介绍 `clip` 的实现，但如果你感兴趣，可以阅读
    [*clip_annot.py*](https://fpy.li/15-23) 中的整个模块。
- en: ^([13](ch15.html#idm46582413403536-marker)) Message [“PEP 563 in light of PEP
    649”](https://fpy.li/15-27), posted April 16, 2021.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: ^([13](ch15.html#idm46582413403536-marker)) 2021 年 4 月 16 日发布的信息 [“PEP 563 in
    light of PEP 649”](https://fpy.li/15-27)。
- en: ^([14](ch15.html#idm46582412814672-marker)) The terms are from Joshua Bloch’s
    classic book, *Effective Java*, 3rd ed. (Addison-Wesley). The definitions and
    examples are mine.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: ^([14](ch15.html#idm46582412814672-marker)) 这些术语来自 Joshua Bloch 的经典著作 *Effective
    Java*，第三版（Addison-Wesley）。定义和示例是我自己的。
- en: ^([15](ch15.html#idm46582412790496-marker)) I first saw the cafeteria analogy
    for variance in Erik Meijer’s *Foreword* in *The Dart Programming Language* book
    by Gilad Bracha (Addison-Wesley).
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: ^([15](ch15.html#idm46582412790496-marker)) 我第一次看到 Erik Meijer 在 Gilad Bracha
    的 *The Dart Programming Language* 一书（Addison-Wesley）的 *前言* 中使用自助餐厅类比来解释方差。
- en: ^([16](ch15.html#idm46582412788720-marker)) Much better than banning books!
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: ^([16](ch15.html#idm46582412788720-marker)) 比禁书好多了！
- en: ^([17](ch15.html#idm46582411210000-marker)) As a reader of footnotes, you may
    recall that I credited Erik Meijer for the cafeteria analogy to explain variance.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: ^([17](ch15.html#idm46582411210000-marker)) 作为脚注的读者，你可能记得我将 Erik Meijer 归功于用自助餐厅类比来解释方差。
- en: ^([18](ch15.html#idm46582411197760-marker)) That book was written for Dart 1\.
    There are significant changes in Dart 2, including in the type system. Nevertheless,
    Bracha is an important researcher in the field of programming language design,
    and I found the book valuable for his perspective on the design of Dart.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: ^([18](ch15.html#idm46582411197760-marker)) 那本书是为 Dart 1 写的。Dart 2 有重大变化，包括类型系统。尽管如此，Bracha
    是编程语言设计领域的重要研究者，我发现这本书对 Dart 的设计视角很有价值。
- en: ^([19](ch15.html#idm46582411168720-marker)) See the last paragraph of the section
    [“Covariance and Contravariance”](https://fpy.li/15-37) in PEP 484.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: ^([19](ch15.html#idm46582411168720-marker)) 参见 PEP 484 中 [“Covariance and Contravariance”](https://fpy.li/15-37)
    部分的最后一段。
