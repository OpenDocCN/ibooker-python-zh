<html><head></head><body><section data-pdf-bookmark="Chapter 4. Async, Concurrency, and Starlette Tour" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch04">&#13;
<h1><span class="label">Chapter 4. </span>Async, Concurrency, and Starlette Tour</h1>&#13;
&#13;
<blockquote>&#13;
<p>Starlette<a data-primary="Starlette" data-secondary="defined" data-type="indexterm" id="id499"/> <a data-primary="Christie, Tom" data-type="indexterm" id="id500"/>is a lightweight ASGI framework/toolkit,&#13;
which is ideal for building async web services in Python.</p>&#13;
<p data-type="attribution">Tom Christie, <cite>creator of Starlette</cite></p>&#13;
</blockquote>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Preview" data-type="sect1"><div class="sect1" id="id302">&#13;
<h1>Preview</h1>&#13;
&#13;
<p>The previous chapter briefly introduced the first things a developer&#13;
would encounter on writing a new FastAPI application.&#13;
This chapter&#13;
emphasizes FastAPI’s underlying Starlette library,&#13;
particularly its support of <em>async</em> processing.&#13;
After an overview of multiple ways of&#13;
“doing more things at once” in Python,&#13;
you’ll see how its newer <code>async</code> and <code>await</code>&#13;
keywords have been incorporated into Starlette and FastAPI.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Starlette" data-type="sect1"><div class="sect1" id="id42">&#13;
<h1>Starlette</h1>&#13;
&#13;
<p>Much <a data-primary="Starlette" data-type="indexterm" id="icd029"/>of FastAPI’s web code is based on the&#13;
<a href="https://www.starlette.io">Starlette package</a>,&#13;
which was created by Tom Christie.&#13;
It can be used as a web framework in its own right&#13;
or as a library for other frameworks, such as FastAPI.&#13;
Like any other web framework,&#13;
Starlette handles all the usual HTTP request parsing&#13;
and response generation.&#13;
It’s similar <a data-primary="Werkzeug" data-type="indexterm" id="id501"/>to&#13;
<a href="https://werkzeug.palletsprojects.com">Werkzeug</a>,&#13;
the package that underlies Flask.</p>&#13;
&#13;
<p>But its most important feature is its support of the modern&#13;
Python <a data-primary="asynchronous processing" data-secondary="asynchronous web standard" data-type="indexterm" id="id502"/>asynchronous&#13;
web standard:&#13;
<a href="https://asgi.readthedocs.io">ASGI</a>.&#13;
Until now, most Python web frameworks&#13;
(like Flask and Django)&#13;
have been based on the traditional <a data-primary="synchronous processing" data-secondary="synchronous web standard" data-type="indexterm" id="id503"/>synchronous&#13;
<a href="https://wsgi.readthedocs.io">WSGI standard</a>.&#13;
Because web applications so frequently connect to&#13;
much slower code (e.g., database, file, and network access),&#13;
ASGI avoids the blocking and busy waiting&#13;
of WSGI-based applications.</p>&#13;
&#13;
<p class="pagebreak-before">As a result, Starlette and frameworks that use it&#13;
are the fastest Python web packages,&#13;
rivaling even Go and Node.js applications<a data-primary="Starlette" data-startref="icd029" data-type="indexterm" id="id504"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Types of Concurrency" data-type="sect1"><div class="sect1" id="id43">&#13;
<h1>Types of Concurrency</h1>&#13;
&#13;
<p>Before <a data-primary="concurrency" data-type="indexterm" id="icd030"/>getting into the details of the <em>async</em> support&#13;
provided by Starlette and FastAPI,&#13;
it’s useful to know the multiple ways we can implement&#13;
<em>concurrency</em>.</p>&#13;
&#13;
<p>In <a data-primary="parallel computing" data-type="indexterm" id="id505"/><em>parallel</em> computing,&#13;
a task is spread across multiple dedicated CPUs at the same time.&#13;
This is common in “number-crunching”&#13;
applications like graphics and machine learning.</p>&#13;
&#13;
<p>In <em>concurrent</em> computing,&#13;
each CPU switches among multiple tasks.&#13;
Some tasks take longer than others,&#13;
and we want to reduce the total time needed.&#13;
Reading a file or accessing a remote network service&#13;
is literally thousands to millions of times&#13;
slower than running calculations in the CPU.</p>&#13;
&#13;
<p>Web applications do a lot of this slow work.&#13;
How can we make web servers, or any servers, run faster?&#13;
This section discusses some possibilities,&#13;
from system-wide&#13;
down to the focus of this chapter:&#13;
FastAPI’s implementation of Python’s&#13;
<code>async</code> and <code>await</code>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Distributed and Parallel Computing" data-type="sect2"><div class="sect2" id="id44">&#13;
<h2>Distributed and Parallel Computing</h2>&#13;
&#13;
<p>If <a data-primary="distributed computing" data-type="indexterm" id="id506"/>you have a really big application—one that would huff and puff on a single CPU—you can break it into pieces and make those pieces&#13;
run on separate CPUs in a single machine&#13;
or on multiple machines.&#13;
You can do this in many, many ways,&#13;
and if you have such an application, you already know a&#13;
number of them.&#13;
Managing all these pieces is more complex and expensive than managing a single server.</p>&#13;
&#13;
<p>In this book, the focus is on small- to medium-sized&#13;
applications that could fit on a single box.&#13;
And these applications can have a mixture&#13;
of synchronous and asynchronous code,&#13;
nicely managed by FastAPI.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Operating System Processes" data-type="sect2"><div class="sect2" id="id45">&#13;
<h2>Operating System Processes</h2>&#13;
&#13;
<p>An <a data-primary="OSs (operating systems)" data-secondary="processes" data-type="indexterm" id="id507"/>operating<a data-primary="processes" data-type="indexterm" id="id508"/> system&#13;
(or <em>OS</em>, because typing hurts)&#13;
schedules resources:&#13;
memory, CPUs, devices, networks, and so on.&#13;
Every program that it runs executes its code in one or more&#13;
<em>processes</em>.&#13;
The OS provides each process with managed, protected&#13;
access to resources,&#13;
including when they can use the CPU.</p>&#13;
&#13;
<p>Most systems use <a data-primary="preemptive process scheduling" data-type="indexterm" id="id509"/><em>preemptive</em> process scheduling,&#13;
not allowing any process to hog the CPU, memory,&#13;
or any other resource.&#13;
An OS continually suspends and resumes processes,&#13;
according to its design and settings.</p>&#13;
&#13;
<p>For developers, the good news is:&#13;
not your problem!&#13;
But the bad news&#13;
(which usually seems to shadow the good)&#13;
is:&#13;
you can’t do much to change it, even if you want to.</p>&#13;
&#13;
<p>With CPU-intensive Python applications,&#13;
the usual solution is to use multiple processes&#13;
and let the OS manage them.&#13;
Python has a&#13;
<a href="https://oreil.ly/YO4YE">multiprocessing module</a> for this.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Operating System Threads" data-type="sect2"><div class="sect2" id="id46">&#13;
<h2>Operating System Threads</h2>&#13;
&#13;
<p>You <a data-primary="OSs (operating systems)" data-secondary="threads" data-type="indexterm" id="id510"/>can <a data-primary="threads" data-type="indexterm" id="id511"/>also run <em>threads</em> of control within a single process.&#13;
Python’s&#13;
<a href="https://oreil.ly/xwVB1">threading package</a> manages these.</p>&#13;
&#13;
<p>Threads are often recommended when your program is I/O bound,&#13;
and multiple processes are recommended when you’re CPU bound.&#13;
But threads are tricky to program&#13;
and can cause errors that are hard to find.&#13;
In <em>Introducing Python</em>,&#13;
I likened threads to&#13;
ghosts wafting around in a haunted house:&#13;
independent and invisible,&#13;
detected only by their effects.&#13;
Hey, who moved that candlestick?</p>&#13;
&#13;
<p>Traditionally,&#13;
Python <a data-primary="Python" data-secondary="process-based and thread-based libraries" data-type="indexterm" id="id512"/>kept the process-based and thread-based&#13;
libraries separate.&#13;
Developers had to learn the arcane details of either to use them.&#13;
A more recent package called&#13;
<a href="https://oreil.ly/dT150">concurrent.futures</a>&#13;
is a higher-level interface that makes them easier to use.</p>&#13;
&#13;
<p>As you’ll see, you can get the benefits of threads more easily&#13;
with the newer async functions.&#13;
FastAPI also manages threads for&#13;
normal synchronous functions (<code>def</code>, not <code>async def</code>)&#13;
via threadpools.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Green Threads" data-type="sect2"><div class="sect2" id="id47">&#13;
<h2>Green Threads</h2>&#13;
&#13;
<p>A more mysterious <a data-primary="greenlet" data-type="indexterm" id="id513"/><a data-primary="gevent" data-type="indexterm" id="id514"/>mechanism is presented by&#13;
<a data-primary="green threads" data-type="indexterm" id="id515"/><em>green threads</em> such as&#13;
<a href="https://greenlet.readthedocs.io">greenlet</a>,&#13;
<a href="http://www.gevent.org">gevent</a>&#13;
and&#13;
<a href="https://eventlet.net">Eventlet</a>.&#13;
These <a data-primary="Eventlet" data-type="indexterm" id="id516"/>are <em>cooperative</em> (not preemptive).&#13;
They’re similar to OS threads&#13;
but run in user space (i.e., your program)&#13;
rather than in the OS kernel.&#13;
They work by <em>monkey-patching</em>&#13;
standard Python functions (modifying standard Python functions as they’re running) to make concurrent code look like normal sequential code:&#13;
they give up control when they would block&#13;
waiting for I/O.</p>&#13;
&#13;
<p>OS threads are “lighter” (use less memory) than OS processes,&#13;
and green threads are lighter than OS threads.&#13;
In some&#13;
<a href="https://oreil.ly/1NFYb">benchmarks</a>,&#13;
all the async methods were generally faster&#13;
than their sync counterparts.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>After you’ve read this chapter,&#13;
you may wonder which is better: gevent or asyncio?&#13;
I don’t think there’s a single preference for all uses.&#13;
Green threads were implemented earlier&#13;
(using ideas from the multiplayer game <em>Eve Online</em>).&#13;
This book features Python’s standard asyncio,&#13;
which is used by FastAPI,&#13;
is simpler than threads,&#13;
and performs well.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Callbacks" data-type="sect2"><div class="sect2" id="id48">&#13;
<h2>Callbacks</h2>&#13;
&#13;
<p>Developers <a data-primary="callbacks" data-type="indexterm" id="id517"/>of interactive applications like&#13;
games and graphic user interfaces&#13;
are probably familiar with <em>callbacks</em>.&#13;
You write functions and associate them with an event,&#13;
like a mouse click, keypress, or time.&#13;
The prominent Python <a data-primary="Twisted package" data-type="indexterm" id="id518"/>package in this category is&#13;
<a href="https://twisted.org">Twisted</a>.&#13;
Its name reflects the reality that callback-based&#13;
programs are a bit “inside-out” and hard to follow.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Python Generators" data-type="sect2"><div class="sect2" id="id49">&#13;
<h2>Python Generators</h2>&#13;
&#13;
<p>Like <a data-primary="Python" data-secondary="generators" data-type="indexterm" id="icd031"/>most<a data-primary="generators" data-type="indexterm" id="icd032"/> languages, Python usually executes code sequentially.&#13;
When you call a function,&#13;
Python runs it from its first line until its end&#13;
or a <code>return</code>.</p>&#13;
&#13;
<p>But in a Python <em>generator function</em>,&#13;
you can stop and return from any point,&#13;
<em>and go back to that point</em> later.&#13;
The trick is the <code>yield</code> keyword.</p>&#13;
&#13;
<p>In one <em>Simpsons</em> episode, Homer crashes his car into a deer statue,&#13;
followed by three lines of dialogue.&#13;
<a data-type="xref" href="#ex-4-1">Example 4-1</a> defines&#13;
a normal Python function to <code>return</code> these lines&#13;
as a list and have the caller iterate over them.</p>&#13;
<div data-type="example" id="ex-4-1">&#13;
<h5><span class="label">Example 4-1. </span>Use <code>return</code></h5>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="o">&gt;&gt;&gt;</code> <code class="k">def</code> <code class="nf">doh</code><code class="p">():</code>&#13;
<code class="o">...</code>     <code class="k">return</code> <code class="p">[</code><code class="s2">"Homer: D'oh!"</code><code class="p">,</code> <code class="s2">"Marge: A deer!"</code><code class="p">,</code> <code class="s2">"Lisa: A female deer!"</code><code class="p">]</code>&#13;
<code class="o">...</code>&#13;
<code class="o">&gt;&gt;&gt;</code> <code class="k">for</code> <code class="n">line</code> <code class="ow">in</code> <code class="n">doh</code><code class="p">():</code>&#13;
<code class="o">...</code>     <code class="nb">print</code><code class="p">(</code><code class="n">line</code><code class="p">)</code>&#13;
<code class="o">...</code>&#13;
<code class="n">Homer</code><code class="p">:</code> <code class="n">D</code><code class="s1">'oh!</code><code class="w"/>&#13;
<code class="n">Marge</code><code class="p">:</code> <code class="n">A</code> <code class="n">deer</code><code class="err">!</code>&#13;
<code class="n">Lisa</code><code class="p">:</code> <code class="n">A</code> <code class="n">female</code> <code class="n">deer</code><code class="err">!</code></pre></div>&#13;
&#13;
<p>This works perfectly when lists are relatively small.&#13;
But what if we’re grabbing all the dialogue from all the <em>Simpsons</em>&#13;
episodes?&#13;
Lists use memory.</p>&#13;
&#13;
<p><a data-type="xref" href="#ex-4-2">Example 4-2</a> shows how a generator function would dole out the lines.</p>&#13;
<div data-type="example" id="ex-4-2">&#13;
<h5><span class="label">Example 4-2. </span>Use <code>yield</code></h5>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="o">&gt;&gt;&gt;</code> <code class="k">def</code> <code class="nf">doh2</code><code class="p">():</code>&#13;
<code class="o">...</code>     <code class="k">yield</code> <code class="s2">"Homer: D'oh!"</code>&#13;
<code class="o">...</code>     <code class="k">yield</code> <code class="s2">"Marge: A deer!"</code>&#13;
<code class="o">...</code>     <code class="k">yield</code> <code class="s2">"Lisa: A female deer!"</code>&#13;
<code class="o">...</code>&#13;
<code class="o">&gt;&gt;&gt;</code> <code class="k">for</code> <code class="n">line</code> <code class="ow">in</code> <code class="n">doh2</code><code class="p">():</code>&#13;
<code class="o">...</code>     <code class="nb">print</code><code class="p">(</code><code class="n">line</code><code class="p">)</code>&#13;
<code class="o">...</code>&#13;
<code class="n">Homer</code><code class="p">:</code> <code class="n">D</code><code class="s1">'oh!</code><code class="w"/>&#13;
<code class="n">Marge</code><code class="p">:</code> <code class="n">A</code> <code class="n">deer</code><code class="err">!</code>&#13;
<code class="n">Lisa</code><code class="p">:</code> <code class="n">A</code> <code class="n">female</code> <code class="n">deer</code><code class="err">!</code></pre></div>&#13;
&#13;
<p>Instead of iterating over a list returned by&#13;
the plain function <code>doh()</code>,&#13;
we’re iterating over a <em>generator object</em>&#13;
returned by the&#13;
<em>generator function</em> <code>doh2()</code>.&#13;
The actual iteration (<code>for...in</code>) looks the same.&#13;
Python returns the first string from <code>doh2()</code>,&#13;
but keeps track of where it is for the next iteration,&#13;
and so on until the function runs out of dialogue.</p>&#13;
&#13;
<p>Any function containing <code>yield</code> is a generator function.&#13;
Given this ability to go back into the middle of a function&#13;
and resume execution, the next section looks like a&#13;
logical <a data-primary="generators" data-startref="icd032" data-type="indexterm" id="id519"/>adaptation<a data-primary="Python" data-secondary="generators" data-startref="icd031" data-type="indexterm" id="id520"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Python async, await, and asyncio" data-type="sect2"><div class="sect2" id="id50">&#13;
<h2>Python async, await, and asyncio</h2>&#13;
&#13;
<p>Python’s&#13;
<a href="https://oreil.ly/cBMAc">asyncio</a>&#13;
features <a data-primary="Python" data-secondary="asyncio" data-type="indexterm" id="icd033"/>have <a data-primary="asyncio" data-type="indexterm" id="icd036"/>been introduced over various releases.&#13;
You’re running at least Python 3.7,&#13;
when <a data-primary="async keyword and function" data-type="indexterm" id="icd034"/>the <code>async</code> and<a data-primary="await keyword and function" data-type="indexterm" id="icd035"/> <code>await</code> terms became reserved keywords.</p>&#13;
&#13;
<p>The following examples show a joke that’s funny only when run asynchronously.&#13;
Run both yourself, because the timing matters.</p>&#13;
&#13;
<p>First, run the unfunny <a data-type="xref" href="#ex-4-3">Example 4-3</a>.</p>&#13;
<div data-type="example" id="ex-4-3">&#13;
<h5><span class="label">Example 4-3. </span>Dullness</h5>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="o">&gt;&gt;&gt;</code> <code class="kn">import</code> <code class="nn">time</code>&#13;
<code class="o">&gt;&gt;&gt;</code>&#13;
<code class="o">&gt;&gt;&gt;</code> <code class="k">def</code> <code class="nf">q</code><code class="p">():</code>&#13;
<code class="o">...</code>     <code class="nb">print</code><code class="p">(</code><code class="s2">"Why can't programmers tell jokes?"</code><code class="p">)</code>&#13;
<code class="o">...</code>     <code class="n">time</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code>&#13;
<code class="o">...</code>&#13;
<code class="o">&gt;&gt;&gt;</code> <code class="k">def</code> <code class="nf">a</code><code class="p">():</code>&#13;
<code class="o">...</code>     <code class="nb">print</code><code class="p">(</code><code class="s2">"Timing!"</code><code class="p">)</code>&#13;
<code class="o">...</code>&#13;
<code class="o">&gt;&gt;&gt;</code> <code class="k">def</code> <code class="nf">main</code><code class="p">():</code>&#13;
<code class="o">...</code>     <code class="n">q</code><code class="p">()</code>&#13;
<code class="o">...</code>     <code class="n">a</code><code class="p">()</code>&#13;
<code class="o">...</code>&#13;
<code class="o">&gt;&gt;&gt;</code> <code class="n">main</code><code class="p">()</code>&#13;
<code class="n">Why</code> <code class="n">can</code><code class="s1">'t programmers tell jokes?</code><code class="w"/>&#13;
<code class="n">Timing</code><code class="err">!</code></pre></div>&#13;
&#13;
<p>You’ll see a three-second gap between the question and answer.&#13;
Yawn.</p>&#13;
&#13;
<p>But the async <a data-type="xref" href="#ex-4-4">Example 4-4</a> is a little different.</p>&#13;
<div data-type="example" id="ex-4-4">&#13;
<h5><span class="label">Example 4-4. </span>Hilarity</h5>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="o">&gt;&gt;&gt;</code> <code class="kn">import</code> <code class="nn">asyncio</code>&#13;
<code class="o">&gt;&gt;&gt;</code>&#13;
<code class="o">&gt;&gt;&gt;</code> <code class="k">async</code> <code class="k">def</code> <code class="nf">q</code><code class="p">():</code>&#13;
<code class="o">...</code>     <code class="nb">print</code><code class="p">(</code><code class="s2">"Why can't programmers tell jokes?"</code><code class="p">)</code>&#13;
<code class="o">...</code>     <code class="k">await</code> <code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code>&#13;
<code class="o">...</code>&#13;
<code class="o">&gt;&gt;&gt;</code> <code class="k">async</code> <code class="k">def</code> <code class="nf">a</code><code class="p">():</code>&#13;
<code class="o">...</code>     <code class="nb">print</code><code class="p">(</code><code class="s2">"Timing!"</code><code class="p">)</code>&#13;
<code class="o">...</code>&#13;
<code class="o">&gt;&gt;&gt;</code> <code class="k">async</code> <code class="k">def</code> <code class="nf">main</code><code class="p">():</code>&#13;
<code class="o">...</code>     <code class="k">await</code> <code class="n">asyncio</code><code class="o">.</code><code class="n">gather</code><code class="p">(</code><code class="n">q</code><code class="p">(),</code> <code class="n">a</code><code class="p">())</code>&#13;
<code class="o">...</code>&#13;
<code class="o">&gt;&gt;&gt;</code> <code class="n">asyncio</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="n">main</code><code class="p">())</code>&#13;
<code class="n">Why</code> <code class="n">can</code><code class="s1">'t programmers tell jokes?</code><code class="w"/>&#13;
<code class="n">Timing</code><code class="err">!</code></pre></div>&#13;
&#13;
<p>This time, the answer should pop out right after the question,&#13;
followed by three seconds of silence—just as though a programmer is telling it.&#13;
Ha ha! Ahem.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>I’ve used <code>asyncio.gather()</code> and <code>asyncio.run()</code>&#13;
in <a data-type="xref" href="#ex-4-4">Example 4-4</a>, but there are multiple ways of calling&#13;
async functions.&#13;
When using FastAPI, you won’t need to use these.</p>&#13;
</div>&#13;
&#13;
<p>Python thinks this when running <a data-type="xref" href="#ex-4-4">Example 4-4</a>:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Execute <code>q()</code>. Well, just the first line right now.</p>&#13;
</li>&#13;
<li>&#13;
<p>OK, you lazy async <code>q()</code>, I’ve set my stopwatch and I’ll come back to you in three seconds.</p>&#13;
</li>&#13;
<li>&#13;
<p>In the meantime I’ll run <code>a()</code>, printing the answer right away.</p>&#13;
</li>&#13;
<li>&#13;
<p>No other <code>await</code>, so back to <code>q()</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Boring event loop! I’ll sit here aaaand stare for the rest of the three seconds.</p>&#13;
</li>&#13;
<li>&#13;
<p>OK, now I’m done.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>This example uses <code>asyncio.sleep()</code> for a function that takes some time,&#13;
much like a function that reads a file or accesses a website.&#13;
You put <code>await</code> in front of the function that might spend most&#13;
of its time waiting.&#13;
And that function needs to have <code>async</code> before its <code>def</code><a data-primary="concurrency" data-startref="icd030" data-type="indexterm" id="id521"/>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If you define a function with <code>async def</code>,&#13;
its caller must put&#13;
an <code>await</code> before the call to it.&#13;
And the caller itself must be declared&#13;
<code>async def</code>, and <em>its</em> caller must <code>await</code> it, all the way up.</p>&#13;
&#13;
<p>By the way, you can declare a function as <code>async</code>&#13;
even if it doesn’t&#13;
contain an <code>await</code> call to <a data-primary="await keyword and function" data-startref="icd035" data-type="indexterm" id="id522"/>another async <a data-primary="async keyword and function" data-startref="icd034" data-type="indexterm" id="id523"/>function.&#13;
It doesn’t <a data-primary="asyncio" data-startref="icd036" data-type="indexterm" id="id524"/>hurt<a data-primary="Python" data-secondary="asyncio" data-startref="icd033" data-type="indexterm" id="id525"/>.</p>&#13;
</div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="FastAPI and Async" data-type="sect1"><div class="sect1" id="id51">&#13;
<h1>FastAPI and Async</h1>&#13;
&#13;
<p>After<a data-primary="asynchronous processing" data-secondary="FastAPI and" data-type="indexterm" id="icd038"/> that<a data-primary="FastAPI" data-secondary="asynchronous processing and" data-type="indexterm" id="icd037"/> long field trip over hill and dale,&#13;
let’s get back to FastAPI and why any of it matters.</p>&#13;
&#13;
<p>Because web servers spend a lot of time waiting,&#13;
performance can be increased by avoiding some of that waiting—in other words, concurrency.&#13;
Other web servers use many of the methods mentioned earlier: threads, gevent, and so on.&#13;
One of the reasons that FastAPI is one of the fastest&#13;
Python web frameworks is its incorporation of async code,&#13;
via the underlying Starlette package’s ASGI support,&#13;
and some of its own inventions.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The use of <code>async</code> and <code>await</code> on their own does not&#13;
make code run faster. In fact, it might be a little slower,&#13;
from async setup overhead. The main use of <code>async</code> is to avoid&#13;
long waits for I/O.</p>&#13;
</div>&#13;
&#13;
<p>Now, let’s look at our earlier web endpoint calls and&#13;
see how to make them async.</p>&#13;
&#13;
<p>The <a data-primary="path functions (web endpoints)" data-type="indexterm" id="id526"/>functions<a data-primary="web endpoints (path functions)" data-type="indexterm" id="id527"/> that map URLs to code are called&#13;
<em>path functions</em>&#13;
in the FastAPI docs.&#13;
I’ve also called them <em>web endpoints</em>,&#13;
and you saw synchronous examples of them in <a data-type="xref" href="ch03.html#ch03">Chapter 3</a>.&#13;
Let’s make some async ones.&#13;
As in those earlier examples,&#13;
we’ll just use simple types like numbers and strings for now.&#13;
<a data-type="xref" href="ch05.html#ch05">Chapter 5</a> introduces <em>type hints</em> and Pydantic,&#13;
which we’ll need to handle fancier data structures.</p>&#13;
&#13;
<p><a data-type="xref" href="#ex-4-5">Example 4-5</a> revisits the first FastAPI&#13;
program from the previous chapter&#13;
and makes it asynchronous.</p>&#13;
<div data-type="example" id="ex-4-5">&#13;
<h5><span class="label">Example 4-5. </span>A shy async endpoint (<span class="plain">greet_async.py</span>)</h5>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="kn">from</code> <code class="nn">fastapi</code> <code class="kn">import</code> <code class="n">FastAPI</code>&#13;
<code class="kn">import</code> <code class="nn">asyncio</code>&#13;
&#13;
<code class="n">app</code> <code class="o">=</code> <code class="n">FastAPI</code><code class="p">()</code>&#13;
&#13;
<code class="nd">@app</code><code class="o">.</code><code class="n">get</code><code class="p">(</code><code class="s2">"/hi"</code><code class="p">)</code>&#13;
<code class="k">async</code> <code class="k">def</code> <code class="nf">greet</code><code class="p">():</code>&#13;
    <code class="k">await</code> <code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="s2">"Hello? World?"</code></pre></div>&#13;
&#13;
<p>To run that chunk of web code, you need a web server like&#13;
Uvicorn.</p>&#13;
&#13;
<p>The first way is to run Uvicorn on the command line:</p>&#13;
&#13;
<pre data-type="programlisting">$ <strong>uvicorn greet_async:app</strong></pre>&#13;
&#13;
<p>The second,&#13;
as in <a data-type="xref" href="#ex-4-6">Example 4-6</a>,&#13;
is to call Uvicorn from inside the example code,&#13;
when it’s run as a main program instead of a module.</p>&#13;
<div data-type="example" id="ex-4-6">&#13;
<h5><span class="label">Example 4-6. </span>Another shy async endpoint (<span class="plain">greet_async_uvicorn.py</span>)</h5>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="kn">from</code> <code class="nn">fastapi</code> <code class="kn">import</code> <code class="n">FastAPI</code>&#13;
<code class="kn">import</code> <code class="nn">asyncio</code>&#13;
<code class="kn">import</code> <code class="nn">uvicorn</code>&#13;
&#13;
<code class="n">app</code> <code class="o">=</code> <code class="n">FastAPI</code><code class="p">()</code>&#13;
&#13;
<code class="nd">@app</code><code class="o">.</code><code class="n">get</code><code class="p">(</code><code class="s2">"/hi"</code><code class="p">)</code>&#13;
<code class="k">async</code> <code class="k">def</code> <code class="nf">greet</code><code class="p">():</code>&#13;
    <code class="k">await</code> <code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="s2">"Hello? World?"</code>&#13;
&#13;
<code class="k">if</code> <code class="vm">__name__</code> <code class="o">==</code> <code class="s2">"__main__"</code><code class="p">:</code>&#13;
    <code class="n">uvicorn</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="s2">"greet_async_uvicorn:app"</code><code class="p">)</code></pre></div>&#13;
&#13;
<p>When run as a standalone program, Python names it <code>main</code>.&#13;
That <code>if __name__...</code> stuff is Python’s way of running it only when called as a main program.&#13;
Yes, it’s ugly.</p>&#13;
&#13;
<p>This code will pause for one second before returning&#13;
its timorous greeting.&#13;
The only difference from a synchronous function&#13;
that used the standard <code>sleep(1)</code> function is that the web server can handle other requests in the&#13;
meantime with the async <span class="keep-together">example</span>.</p>&#13;
&#13;
<p>Using <code>asyncio.sleep(1)</code> fakes a real-world&#13;
function that might take one second, like&#13;
calling a database or downloading a web page.&#13;
Later chapters will show examples of such calls from this&#13;
Web layer to the Service layer,&#13;
and from there to the Data layer,&#13;
actually spending that wait time on real work.</p>&#13;
&#13;
<p>FastAPI calls this async <code>greet()</code> path function&#13;
itself when it receives a&#13;
<code>GET</code> request for the URL <em>/hi</em>.&#13;
You don’t need to add an <code>await</code> anywhere.&#13;
But for any other <code>async def</code> function definitions that you make,&#13;
the caller must put an <code>await</code> before each call.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>FastAPI runs an async<a data-primary="event loops" data-type="indexterm" id="id528"/> <em>event loop</em> <a data-primary="asynchronous processing" data-secondary="event loops" data-type="indexterm" id="id529"/>that coordinates&#13;
the async path functions,&#13;
and a <a data-primary="threadpools" data-type="indexterm" id="id530"/><em>threadpool</em> <a data-primary="synchronous processing" data-secondary="threadpools" data-type="indexterm" id="id531"/>for synchronous path functions.&#13;
A developer doesn’t need to know the tricky details,&#13;
which is a great plus.&#13;
For example, you don’t need to run methods like&#13;
<span class="keep-together"><code>asyncio.gather()</code></span> or <code>asyncio.run()</code>, as in the&#13;
(standalone, non-FastAPI) joke example<a data-primary="FastAPI" data-secondary="asynchronous processing and" data-startref="icd037" data-type="indexterm" id="id532"/> earlier<a data-primary="asynchronous processing" data-secondary="FastAPI and" data-startref="icd038" data-type="indexterm" id="id533"/>.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Starlette Directly" data-type="sect1"><div class="sect1" id="id182">&#13;
<h1>Using Starlette Directly</h1>&#13;
&#13;
<p>FastAPI <a data-primary="Starlette" data-secondary="writing apps directly" data-type="indexterm" id="id534"/>doesn’t expose Starlette as much as it does Pydantic.&#13;
Starlette is largely the machinery humming in the engine room,&#13;
keeping the ship running smoothly.</p>&#13;
&#13;
<p>But if you’re curious,&#13;
you could use Starlette directly to write a web application.&#13;
<a data-type="xref" href="ch03.html#ex-3-1">Example 3-1</a> in the previous chapter&#13;
might look like <a data-type="xref" href="#ex-4-7">Example 4-7</a>.</p>&#13;
<div data-type="example" id="ex-4-7">&#13;
<h5><span class="label">Example 4-7. </span>Using Starlette: <span class="plain">starlette_hello.py</span></h5>&#13;
&#13;
<pre data-type="programlisting">from starlette.applications import Starlette&#13;
from starlette.responses import JSONResponse&#13;
from starlette.routing import Route&#13;
&#13;
async def greeting(request):&#13;
    return JSONResponse('Hello? World?')&#13;
&#13;
app = Starlette(debug=True, routes=[&#13;
    Route('/hi', greeting),&#13;
])</pre></div>&#13;
&#13;
<p>Run this web application with this:</p>&#13;
&#13;
<pre data-type="programlisting">$ <strong>uvicorn starlette_hello:app</strong></pre>&#13;
&#13;
<p>In my opinion, the FastAPI additions&#13;
make web API development much easier.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Interlude: Cleaning the Clue House" data-type="sect1"><div class="sect1" id="id183">&#13;
<h1>Interlude: Cleaning the Clue House</h1>&#13;
&#13;
<p>You <a data-primary="asynchronous processing" data-secondary="Clue house cleaning example" data-type="indexterm" id="icd039"/>own a small (very small: just you) house-cleaning company.&#13;
You’ve been living on ramen but just landed a contract&#13;
that will let you afford much better ramen.</p>&#13;
&#13;
<p>Your client bought an old mansion that was built in the style of the&#13;
board game Clue and wants to host a character party there soon.&#13;
But the place is an incredible mess.&#13;
If Marie Kondo saw the place,&#13;
she might do the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Scream</p>&#13;
</li>&#13;
<li>&#13;
<p>Gag</p>&#13;
</li>&#13;
<li>&#13;
<p>Run away</p>&#13;
</li>&#13;
<li>&#13;
<p>All of the above</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Your contract includes a speed bonus.&#13;
How can you clean the place thoroughly,&#13;
in the least amount of elapsed time?&#13;
The best approach would have been to have more Clue Preservation Units (CPUs), but you’re it.</p>&#13;
&#13;
<p class="pagebreak-before">So you can try one of these:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Do everything in one room, then everything in the next, etc.</p>&#13;
</li>&#13;
<li>&#13;
<p>Do a specific task in one room, then the next, etc.&#13;
Like polishing the silver in the Kitchen and Dining Room,&#13;
or the pool balls in the Billiard Room.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Would your total time for these approaches differ?&#13;
Maybe. But it might be more important to consider whether&#13;
you have to wait an appreciable time for any step.&#13;
An example might be underfoot:&#13;
after cleaning rugs and waxing floors, they might need to&#13;
dry for hours before moving furniture back onto them.</p>&#13;
&#13;
<p>So, here’s your plan for each room:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Clean all the static parts (windows, etc.).</p>&#13;
</li>&#13;
<li>&#13;
<p>Move all the furniture from the room into the Hall.</p>&#13;
</li>&#13;
<li>&#13;
<p>Remove years of grime from the rug and/or hardwood floor.</p>&#13;
</li>&#13;
<li>&#13;
<p>Do either of these:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Wait for the rug or wax to dry, but wave your bonus goodbye.</p>&#13;
</li>&#13;
<li>&#13;
<p>Go to the next room now, and repeat. After the last room,&#13;
move the furniture back into the first room, and so on.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>The waiting-to-dry approach is the synchronous one,&#13;
and it might be best if&#13;
time isn’t a factor and you need a break.&#13;
The second is async and saves the waiting time for each room.</p>&#13;
&#13;
<p>Let’s assume you choose the async path, because money.&#13;
You get the old dump to sparkle&#13;
and receive that bonus from your grateful client.&#13;
The later party turns out to be a great success, except for these issues:</p>&#13;
<ol>&#13;
<li>&#13;
<p>One memeless guest came as Mario.</p>&#13;
</li>&#13;
<li>&#13;
<p>You overwaxed the dance floor in the Ball Room, and a tipsy&#13;
Professor Plum skated about in his socks, until he sailed into a&#13;
table and spilled champagne on Miss Scarlet.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Morals of this story:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Requirements can be conflicting and/or strange.</p>&#13;
</li>&#13;
<li>&#13;
<p>Estimating time and effort can depend on many factors.</p>&#13;
</li>&#13;
<li>&#13;
<p>Sequencing tasks may be as much art as science.</p>&#13;
</li>&#13;
<li>&#13;
<p>You’ll feel great when it’s all done.  Mmm, ramen<a data-primary="asynchronous processing" data-secondary="Clue house cleaning example" data-startref="icd039" data-type="indexterm" id="id535"/>.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Review" data-type="sect1"><div class="sect1" id="id303">&#13;
<h1>Review</h1>&#13;
&#13;
<p>After an overview of ways of increasing concurrency,&#13;
this chapter expanded on functions that use the recent Python&#13;
keywords <code>async</code> and <code>await</code>.&#13;
It showed how FastAPI and Starlette handle both&#13;
plain old synchronous functions and these new async&#13;
funky functions.</p>&#13;
&#13;
<p>The next chapter introduces the second leg of FastAPI:&#13;
how Pydantic helps you define your data.</p>&#13;
</div></section>&#13;
</div></section></body></html>