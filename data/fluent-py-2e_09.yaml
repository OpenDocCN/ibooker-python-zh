- en: Chapter 7\. Functions as First-Class Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章。函数作为一等对象
- en: I have never considered Python to be heavily influenced by functional languages,
    no matter what people say or think. I was much more familiar with imperative languages
    such as C and Algol 68 and although I had made functions first-class objects,
    I didn’t view Python as a functional programming language.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我从未认为 Python 受到函数式语言的重大影响，无论���们说什么或想什么。我更熟悉命令式语言，如 C 和 Algol 68，尽管我将函数作为一等对象，但我并不认为
    Python 是一种函数式编程语言。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Guido van Rossum, Python BDFL^([1](ch07.html#idm46582448753712))
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Guido van Rossum，Python BDFL^([1](ch07.html#idm46582448753712))
- en: 'Functions in Python are first-class objects. Programming language researchers
    define a “first-class object” as a program entity that can be:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的函数是一等对象。编程语言研究人员将“一等对象”定义为一个程序实体，可以：
- en: Created at runtime
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时创建
- en: Assigned to a variable or element in a data structure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值给变量或数据结构中的元素
- en: Passed as an argument to a function
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为参数传递给函数
- en: Returned as the result of a function
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为函数的结果返回
- en: Integers, strings, and dictionaries are other examples of first-class objects
    in Python—nothing fancy here. Having functions as first-class objects is an essential
    feature of functional languages, such as Clojure, Elixir, and Haskell. However,
    first-class functions are so useful that they’ve been adopted by popular languages
    like JavaScript, Go, and Java (since JDK 8), none of which claim to be “functional
    languages.”
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，整数、字符串和字典是函数的一等对象的其他示例——这里没有什么花哨的东西。将函数作为一等对象是函数式语言（如 Clojure、Elixir
    和 Haskell）的一个重要特性。然而，一等函数非常有用，以至于它们被流行的语言（如 JavaScript、Go 和 Java（自 JDK 8 起））采用，这些语言都不声称自己是“函数式语言”。
- en: This chapter and most of Part III explore the practical applications of treating
    functions as objects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和第三部分的大部分内容探讨了将函数视为对象的实际应用。
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The term “first-class functions” is widely used as shorthand for “functions
    as first-class objects.” It’s not ideal because it implies an “elite” among functions.
    In Python, all functions are first-class.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 术语“一等函数”被广泛用作“函数作为一等对象”的简称。这并不理想，因为它暗示了函数中的“精英”。在 Python 中，所有函数都是一等对象。
- en: What’s New in This Chapter
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章的新内容
- en: The section [“The Nine Flavors of Callable Objects”](#flavors_of_callables)
    was titled “The Seven Flavors of Callable Objects” in the first edition of this
    book. The new callables are native coroutines and asynchronous generators, introduced
    in Python 3.5 and 3.6, respectively. Both are covered in [Chapter 21](ch21.html#async_ch),
    but they are mentioned here along with the other callables for completeness.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 部分[“可调用对象的九种类型”](#flavors_of_callables)在本书第一版中标题为“可调用对象的七种类型”。新的可调用对象是原生协程和异步生成器，分别在
    Python 3.5 和 3.6 中引入。它们都在[第 21 章](ch21.html#async_ch)中介绍，但为了完整起见，它们与其他可调用对象一起提及在这里。
- en: '[“Positional-Only Parameters”](#positional_only_params) is a new section, covering
    a feature added in Python 3.8.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[“仅位置参数”](#positional_only_params) 是一个新的部分，涵盖了 Python 3.8 中添加的一个特性。'
- en: I moved the discussion of runtime access to function annotations to [“Reading
    Type Hints at Runtime”](ch15.html#runtime_annot_sec). When I wrote the first edition,
    [PEP 484—Type Hints](https://fpy.li/pep484) was still under consideration, and
    people used annotations in different ways. Since Python 3.5, annotations should
    conform to PEP 484. Therefore, the best place to cover them is when discussing
    type hints.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我将运行时访问函数注解的讨论移到了[“在运行时读取类型提示”](ch15.html#runtime_annot_sec)。在我写第一版时，[PEP 484—类型提示](https://fpy.li/pep484)
    仍在考虑中，人们以不同的方式使用注解。自 Python 3.5 起，注解应符合 PEP 484。因此，在讨论类型提示时，最好的地方是在这里。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The first edition of this book had sections about the introspection of function
    objects that were too low-level and distracted from the main subject of this chapter.
    I merged those sections into a post titled [“Introspection of Function Parameters”
    at *fluentpython.com*](https://fpy.li/7-2).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的第一版有关函数对象内省的部分过于低级，分散了本章的主题。我将这些部分合并到了一个名为[“函数参数内省”在 *fluentpython.com*](https://fpy.li/7-2)的帖子中。
- en: Now let’s see why Python functions are full-fledged objects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看为什么 Python 函数是完整的对象。
- en: Treating a Function Like an Object
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数视为对象
- en: The console session in [Example 7-1](#func_object_demo) shows that Python functions
    are objects. Here we create a function, call it, read its `__doc__` attribute,
    and check that the function object itself is an instance of the `function` class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7-1](#func_object_demo) 中的控制台会话显示了 Python 函数是对象。在这里，我们创建一个函数，调用它，读取其 `__doc__`
    属性，并检查函数对象本身是否是 `function` 类的一个实例。'
- en: Example 7-1\. Create and test a function, then read its `__doc__` and check
    its type
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-1。创建和测试一个函数，然后读取其 `__doc__` 并检查其类型
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_functions_as_first_class_objects_CO1-1)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functions_as_first_class_objects_CO1-1)'
- en: This is a console session, so we’re creating a function at “runtime.”
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个控制台会话，所以我们在“运行时”创建一个函数。
- en: '[![2](assets/2.png)](#co_functions_as_first_class_objects_CO1-2)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functions_as_first_class_objects_CO1-2)'
- en: '`__doc__` is one of several attributes of function objects.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`__doc__` 是函数对象的几个属性之一。'
- en: '[![3](assets/3.png)](#co_functions_as_first_class_objects_CO1-3)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functions_as_first_class_objects_CO1-3)'
- en: '`factorial` is an instance of the `function` class.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`factorial` 是 `function` 类的一个实例。'
- en: The `__doc__` attribute is used to generate the help text of an object. In the
    Python console, the command `help(factorial)` will display a screen like [Figure 7-1](#factorial_help).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`__doc__` 属性用于生成对象的帮助文本。在 Python 控制台中，命令 `help(factorial)` 将显示类似于 [图 7-1](#factorial_help)
    的屏幕。'
- en: '![Help screen for the factorial function](assets/flpy_0701.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![factorial 函数的帮助屏幕](assets/flpy_0701.png)'
- en: Figure 7-1\. Help screen for `factorial`; the text is built from the `__doc__`
    attribute of the function.
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-1。`factorial` 的帮助屏幕；文本是从函数的 `__doc__` 属性构建的。
- en: '[Example 7-2](#func_object_demo2) shows the “first class” nature of a function
    object. We can assign it a variable `fact` and call it through that name. We can
    also pass `factorial` as an argument to the [`map`](https://fpy.li/7-3) function.
    Calling `map(function, iterable)` returns an iterable where each item is the result
    of calling the first argument (a function) to successive elements of the second
    argument (an iterable), `range(10)` in this example.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7-2](#func_object_demo2)展示了函数对象的“第一类”特性。我们可以将其赋值给变量`fact`，并通过该名称调用它。我们还可以将`factorial`作为参数传递给[`map`](https://fpy.li/7-3)函数。调用`map(function,
    iterable)`会返回一个可迭代对象，其中每个项目都是调用第一个参数（一个函数）对第二个参数（一个可迭代对象）中的连续元素的结果，本例中为`range(10)`。'
- en: Example 7-2\. Use `factorial` through a different name, and pass `factorial`
    as an argument
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-2\. 通过不同名称使用`factorial`，并将`factorial`作为参数传递
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Having first-class functions enables programming in a functional style. One
    of the hallmarks of [functional programming](https://fpy.li/7-4) is the use of
    higher-order functions, our next topic.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有头等函数使得以函数式风格编程成为可能。[函数式编程](https://fpy.li/7-4)的一个特点是使用高阶函数，我们的下一个主题。
- en: Higher-Order Functions
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数
- en: 'A function that takes a function as an argument or returns a function as the
    result is a *higher-order function*. One example is `map`, shown in [Example 7-2](#func_object_demo2).
    Another is the built-in function `sorted`: the optional `key` argument lets you
    provide a function to be applied to each item for sorting, as we saw in [“list.sort
    Versus the sorted Built-In”](ch02.html#sort_x_sorted). For example, to sort a
    list of words by length, pass the `len` function as the `key`, as in [Example 7-3](#higher_order_sort).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一个将函数作为参数或返回函数作为结果的函数是*高阶函数*。一个例子是`map`，如[示例 7-2](#func_object_demo2)所示。另一个是内置函数`sorted`：可选的`key`参数允许您提供一个要应用于每个项目以进行排序的函数，正如我们在[“list.sort与sorted内置函数”](ch02.html#sort_x_sorted)中看到的。例如，要按长度对单词列表进行排序，可以将`len`函数作为`key`传递，如[示例 7-3](#higher_order_sort)所示。
- en: Example 7-3\. Sorting a list of words by length
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-3\. 按长度对单词列表进行排序
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Any one-argument function can be used as the key. For example, to create a rhyme
    dictionary it might be useful to sort each word spelled backward. In [Example 7-4](#higher_order_sort_reverse),
    note that the words in the list are not changed at all; only their reversed spelling
    is used as the sort criterion, so that the berries appear together.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 任何一个参数为一个参数的函数都可以用作键。例如，为了创建一个韵典，将每个单词倒着拼写可能很有用。在[示例 7-4](#higher_order_sort_reverse)中，请注意列表中的单词根本没有改变；只有它们的反向拼写被用作排序标准，以便浆果出现在一起。
- en: Example 7-4\. Sorting a list of words by their reversed spelling
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-4\. 按单词的反向拼写对单词列表进行排序
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the functional programming paradigm, some of the best known higher-order
    functions are `map`, `filter`, `reduce`, and `apply`. The `apply` function was
    deprecated in Python 2.3 and removed in Python 3 because it’s no longer necessary.
    If you need to call a function with a dynamic set of arguments, you can write
    `fn(*args, **kwargs)` instead of `apply(fn, args, kwargs)`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程范式中，一些最著名的高阶函数包括`map`、`filter`、`reduce`和`apply`。`apply`函数在Python 2.3中已被弃用，并在Python
    3中移除，因为它不再必要。如果需要使用动态参数集调用函数，可以编写`fn(*args, **kwargs)`，而不是`apply(fn, args, kwargs)`。
- en: The `map`, `filter`, and `reduce` higher-order functions are still around, but
    better alternatives are available for most of their use cases, as the next section
    shows.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`、`filter`和`reduce`高阶函数仍然存在，但对于它们的大多数用例，都有更好的替代方案，如下一节所示。'
- en: Modern Replacements for map, filter, and reduce
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: map、filter和reduce的现代替代品
- en: Functional languages commonly offer the `map`, `filter`, and `reduce` higher-order
    functions (sometimes with different names). The `map` and `filter` functions are
    still built-ins in Python 3, but since the introduction of list comprehensions
    and generator expressions, they are not as important. A listcomp or a genexp does
    the job of `map` and `filter` combined, but is more readable. Consider [Example 7-5](#reduce_x_sum).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式语言通常提供`map`、`filter`和`reduce`高阶函数（有时使用不同的名称）。`map`和`filter`函数在Python 3中仍然是内置函数，但自列表推导式和生成器表达式引入以来，它们变得不再那么重要。列表推导式或生成器表达式可以完成`map`和`filter`的工作，但更易读。考虑[示例 7-5](#reduce_x_sum)。
- en: Example 7-5\. Lists of factorials produced with `map` and `filter` compared
    to alternatives coded as list comprehensions
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-5\. 使用`map`和`filter`生成的阶乘列表与编码为列表推导式的替代方案进行比较
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_functions_as_first_class_objects_CO2-1)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functions_as_first_class_objects_CO2-1)'
- en: Build a list of factorials from 0! to 5!.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从0!到5!构建一个阶乘列表。
- en: '[![2](assets/2.png)](#co_functions_as_first_class_objects_CO2-2)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functions_as_first_class_objects_CO2-2)'
- en: Same operation, with a list comprehension.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表推导式进行相同的操作。
- en: '[![3](assets/3.png)](#co_functions_as_first_class_objects_CO2-3)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functions_as_first_class_objects_CO2-3)'
- en: List of factorials of odd numbers up to 5!, using both `map` and `filter`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列出了奇数阶乘数的列表，直到5!，同时使用`map`和`filter`。
- en: '[![4](assets/4.png)](#co_functions_as_first_class_objects_CO2-4)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_functions_as_first_class_objects_CO2-4)'
- en: List comprehension does the same job, replacing `map` and `filter`, and making
    `lambda` unnecessary.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式可以完成相同的工作，取代`map`和`filter`，使得`lambda`变得不再必要。
- en: In Python 3, `map` and `filter` return generators—a form of iterator—so their
    direct substitute is now a generator expression (in Python 2, these functions
    returned lists, therefore their closest alternative was a listcomp).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3中，`map`和`filter`返回生成器——一种迭代器形式，因此它们的直��替代品现在是生成器表达式（在Python 2中，这些函数返回列表，因此它们最接近的替代品是列表推导式）。
- en: The `reduce` function was demoted from a built-in in Python 2 to the `functools`
    module in Python 3\. Its most common use case, summation, is better served by
    the `sum` built-in available since Python 2.3 was released in 2003\. This is a
    big win in terms of readability and performance (see [Example 7-6](#reduce_x_sum2)).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce`函数从Python 2中的内置函数降级为Python 3中的`functools`模块。它最常见的用例，求和，更适合使用自2003年发布Python
    2.3以来可用的`sum`内置函数。这在可读性和性能方面是一个巨大的胜利（参见[示例 7-6](#reduce_x_sum2)）。'
- en: Example 7-6\. Sum of integers up to 99 performed with `reduce` and `sum`
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-6\. 使用 `reduce` 和 `sum` 对整数求和，直到 99
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_functions_as_first_class_objects_CO3-1)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functions_as_first_class_objects_CO3-1)'
- en: Starting with Python 3.0, `reduce` is no longer a built-in.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 3.0 开始，`reduce` 不再是内置函数。
- en: '[![2](assets/2.png)](#co_functions_as_first_class_objects_CO3-2)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functions_as_first_class_objects_CO3-2)'
- en: Import `add` to avoid creating a function just to add two numbers.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 `add` 来避免创建一个仅用于添加两个数字的函数。
- en: '[![3](assets/3.png)](#co_functions_as_first_class_objects_CO3-3)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functions_as_first_class_objects_CO3-3)'
- en: Sum integers up to 99.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对整数求和，直到 99。
- en: '[![4](assets/4.png)](#co_functions_as_first_class_objects_CO3-4)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_functions_as_first_class_objects_CO3-4)'
- en: Same task with `sum`—no need to import and call `reduce` and `add`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `sum` 完成相同的任务—无需导入和调用 `reduce` 和 `add`。
- en: Note
  id: totrans-70
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The common idea of `sum` and `reduce` is to apply some operation to successive
    items in a series, accumulating previous results, thus reducing a series of values
    to a single value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum` 和 `reduce` 的共同思想是对系列中的连续项目应用某种操作，累积先前的结果，从而将一系列值减少为单个值。'
- en: 'Other reducing built-ins are `all` and `any`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 其他减少内置函数是 `all` 和 `any`：
- en: '`all(iterable)`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`all(iterable)`'
- en: Returns `True` if there are no falsy elements in the iterable; `all([])` returns
    `True`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可迭代对象中没有假值元素，则返回 `True`；`all([])` 返回 `True`。
- en: '`any(iterable)`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`any(iterable)`'
- en: Returns `True` if any element of the `iterable` is truthy; `any([])` returns
    `False`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可迭代对象中有任何元素为真，则返回 `True`；`any([])` 返回 `False`。
- en: 'I give a fuller explanation of `reduce` in [“Vector Take #4: Hashing and a
    Faster ==”](ch12.html#multi_hashing) where an ongoing example provides a meaningful
    context for the use of this function. The reducing functions are summarized later
    in the book when iterables are in focus, in [“Iterable Reducing Functions”](ch17.html#iterable_reducing_sec).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '我在 [“向量取 #4：哈希和更快的 ==”](ch12.html#multi_hashing) 中对 `reduce` 进行了更详细的解释，在那里，一个持续的示例为使用这个函数提供了有意义的上下文。在本书后面的部分，当重点放在可迭代对象上时，将总结减少函数，见
    [“可迭代对象减少函数”](ch17.html#iterable_reducing_sec)。'
- en: To use a higher-order function, sometimes it is convenient to create a small,
    . one-off function. That is why anonymous functions exist. We’ll cover them next.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用高阶函数，有时创建一个小的、一次性的函数是很方便的。这就是匿名函数存在的原因。我们将在下面介绍它们。
- en: Anonymous Functions
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名函数
- en: The `lambda` keyword creates an anonymous function within a Python expression.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda` 关键字在 Python 表达式中创建一个匿名函数。'
- en: However, the simple syntax of Python limits the body of `lambda` functions to
    be pure expressions. In other words, the body cannot contain other Python statements
    such as `while`, `try`, etc. Assignment with `=` is also a statement, so it cannot
    occur in a `lambda`. The new assignment expression syntax using `:=` can be used—but
    if you need it, your `lambda` is probably too complicated and hard to read, and
    it should be refactored into a regular function using `def`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Python 的简单语法限制了 `lambda` 函数的主体必须是纯表达式。换句话说，主体不能包含其他 Python 语句，如 `while`、`try`
    等。赋值语句 `=` 也是一个语句，因此不能出现在 `lambda` 中。可以使用新的赋值表达式语法 `:=`，但如果你需要它，你的 `lambda` 可能太复杂和难以阅读，应该重构为使用
    `def` 的常规函数。
- en: The best use of anonymous functions is in the context of an argument list for
    a higher-order function. For example, [Example 7-7](#higher_order_sort_reverse_lambda)
    is the rhyme index example from [Example 7-4](#higher_order_sort_reverse) rewritten
    with `lambda`, without defining a `reverse` function.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数的最佳用法是在作为高阶函数的参数列表的上下文中。例如，[示例 7-7](#higher_order_sort_reverse_lambda) 是从
    [示例 7-4](#higher_order_sort_reverse) 重写的韵脚索引示例，使用 `lambda`，而不定义一个 `reverse` 函数。
- en: Example 7-7\. Sorting a list of words by their reversed spelling using `lambda`
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-7\. 使用 `lambda` 按照它们的反向拼写对单词列表进行排序
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Outside the limited context of arguments to higher-order functions, anonymous
    functions are rarely useful in Python. The syntactic restrictions tend to make
    nontrivial `lambdas` either unreadable or unworkable. If a `lambda` is hard to
    read, I strongly advise you follow Fredrik Lundh’s refactoring advice.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在高阶函数的参数的有限上下文之外，匿名函数在 Python 中很少有用。语法限制往往使得非平凡的 `lambda` 要么难以阅读，要么无法工作。如果一个
    `lambda` 难以阅读，我强烈建议您遵循 Fredrik Lundh 的重构建议。
- en: 'The `lambda` syntax is just syntactic sugar: a `lambda` expression creates
    a function object just like the `def` statement. That is just one of several kinds
    of callable objects in Python. The following section reviews all of them.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda` 语法只是一种语法糖：`lambda` 表达式创建一个函数对象，就像 `def` 语句一样。这只是 Python 中几种可调用对象中的一种。下一节将回顾所有这些对象。'
- en: The Nine Flavors of Callable Objects
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可调用对象的九种类型
- en: 'The call operator `()` may be applied to other objects besides functions. To
    determine whether an object is callable, use the `callable()` built-in function.
    As of Python 3.9, the [data model documentation](https://fpy.li/7-6) lists nine
    callable types:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 调用运算符 `()` 可以应用于除函数以外的其他对象。要确定对象是否可调用，请使用内置函数 `callable()`。截至 Python 3.9，[数据模型文档](https://fpy.li/7-6)
    列出了九种可调用类型：
- en: User-defined functions
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的函数
- en: Created with `def` statements or `lambda` expressions.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `def` 语句或 `lambda` 表达式创建。
- en: Built-in functions
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 内置函数
- en: A function implemented in C (for CPython), like `len` or `time.strftime`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 中实现的函数（对于 CPython），如 `len` 或 `time.strftime`。
- en: Built-in methods
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 内置方法
- en: Methods implemented in C, like `dict.get`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 中实现的方法，比如 `dict.get`。
- en: Methods
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 方法
- en: Functions defined in the body of a class.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的主体中定义的函数。
- en: Classes
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: When invoked, a class runs its `__new__` method to create an instance, then
    `__init__` to initialize it, and finally the instance is returned to the caller.
    Because there is no `new` operator in Python, calling a class is like calling
    a function.^([2](ch07.html#idm46582448020576))
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用一个类时，它运行其 `__new__` 方法来创建一个实例，然后运行 `__init__` 来初始化它，最后将实例返回给调��者。因为 Python
    中没有 `new` 运算符，调用一个类就像调用一个函数一样。^([2](ch07.html#idm46582448020576))
- en: Class instances
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 类实例
- en: If a class defines a `__call__` method, then its instances may be invoked as
    functions—that’s the subject of the next section.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类定义了 `__call__` 方法，那么它的实例可以被调用为函数—这是下一节的主题。
- en: Generator functions
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数
- en: Functions or methods that use the `yield` keyword in their body. When called,
    they return a generator object.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在其主体中使用`yield`关键字的函数或方法。调用时，它们返回一个生成器对象。
- en: Native coroutine functions
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本机协程函数
- en: Functions or methods defined with `async def`. When called, they return a coroutine
    object. Added in Python 3.5.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`async def`定义的函数或方法。调用时，它们返回一个协程对象。在Python 3.5中添加。
- en: Asynchronous generator functions
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 异步生成器函数
- en: Functions or methods defined with `async def` that have `yield` in their body.
    When called, they return an asynchronous generator for use with `async for`. Added
    in Python 3.6.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`async def`定义的函数或方法，在其主体中有`yield`。调用时，它们返回一个用于与`async for`一起使用的异步生成器。在Python
    3.6中添加。
- en: Generators, native coroutines, and asynchronous generator functions are unlike
    other callables in that their return values are never application data, but objects
    that require further processing to yield application data or perform useful work.
    Generator functions return iterators. Both are covered in [Chapter 17](ch17.html#iterables2generators).
    Native coroutine functions and asynchronous generator functions return objects
    that only work with the help of an asynchronous programming framework, such as
    *asyncio*. They are the subject of [Chapter 21](ch21.html#async_ch).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器、本机协程和异步生成器函数与其他可调用对象不同，它们的返回值永远不是应用程序数据，而是需要进一步处理以产生应用程序数据或执行有用工作的对象。生成器函数返回迭代器。这两者在[第17章](ch17.html#iterables2generators)中有所涉及。本机协程函数和异步生成器函数返回的对象只能在异步编程框架（如*asyncio*）的帮助下使用。它们是[第21章](ch21.html#async_ch)的主题。
- en: Tip
  id: totrans-108
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'Given the variety of existing callable types in Python, the safest way to determine
    whether an object is callable is to use the `callable()` built-in:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于Python中存在各种可调用类型，确定对象是否可调用的最安全方法是使用`callable()`内置函数：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We now move on to building class instances that work as callable objects.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在开始构建作为可调用对象的类实例。
- en: User-Defined Callable Types
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户定义的可调用类型
- en: Not only are Python functions real objects, but arbitrary Python objects may
    also be made to behave like functions. Implementing a `__call__` instance method
    is all it takes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Python函数不仅是真实对象，而且任意Python对象也可以被制作成类似函数的行为。实现`__call__`实例方法就是全部所需。
- en: '[Example 7-8](#ex_bingo_callable) implements a `BingoCage` class. An instance
    is built from any iterable, and stores an internal `list` of items, in random
    order. Calling the instance pops an item.^([3](ch07.html#idm46582447990112))'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例7-8](#ex_bingo_callable)实现了一个`BingoCage`类。可以从任何可迭代对象构建一个实例，并且以随机顺序存储内部项目的`list`。调用实例会弹出一个项目。^([3](ch07.html#idm46582447990112))'
- en: 'Example 7-8\. bingocall.py: A `BingoCage` does one thing: picks items from
    a shuffled list'
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例7-8\. bingocall.py：`BingoCage`只做一件事：从一个打乱顺序的列表中挑选项目
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_functions_as_first_class_objects_CO4-1)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functions_as_first_class_objects_CO4-1)'
- en: '`__init__` accepts any iterable; building a local copy prevents unexpected
    side effects on any `list` passed as an argument.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__`接受任何可迭代对象；构建本地副本可防止对作为参数传递的任何`list`产生意外副作用。'
- en: '[![2](assets/2.png)](#co_functions_as_first_class_objects_CO4-2)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functions_as_first_class_objects_CO4-2)'
- en: '`shuffle` is guaranteed to work because `self._items` is a `list`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`shuffle`能够正常工作，因为`self._items`是一个`list`。'
- en: '[![3](assets/3.png)](#co_functions_as_first_class_objects_CO4-3)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functions_as_first_class_objects_CO4-3)'
- en: The main method.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 主要方法。
- en: '[![4](assets/4.png)](#co_functions_as_first_class_objects_CO4-4)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_functions_as_first_class_objects_CO4-4)'
- en: Raise exception with custom message if `self._items` is empty.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`self._items`为空，则使用自定义消息引发异常。
- en: '[![5](assets/5.png)](#co_functions_as_first_class_objects_CO4-5)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_functions_as_first_class_objects_CO4-5)'
- en: 'Shortcut to `bingo.pick()`: `bingo()`.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`bingo.pick()`的快捷方式：`bingo()`。'
- en: 'Here is a simple demo of [Example 7-8](#ex_bingo_callable). Note how a `bingo`
    instance can be invoked as a function, and the `callable()` built-in recognizes
    it as a callable object:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是[示例7-8](#ex_bingo_callable)的简单演示。请注意`bingo`实例如何被调用为函数，并且`callable()`内置函数将其识别为可调用对象：
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A class implementing `__call__` is an easy way to create function-like objects
    that have some internal state that must be kept across invocations, like the remaining
    items in the `BingoCage`. Another good use case for `__call__` is implementing
    decorators. Decorators must be callable, and it is sometimes convenient to “remember”
    something between calls of the decorator (e.g., for memoization—caching the results
    of expensive computations for later use) or to split a complex implementation
    into separate methods.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`__call__`的类是创建类似函数的对象的简单方法，这些对象具有必须在调用之间保持的一些内部状态，例如`BingoCage`中剩余项目的情况。`__call__`的另一个很好的用例是实现装饰器。装饰器必须是可调用的，有时方便在装饰器的调用之间“记住”一些东西（例如，用于记忆化的缓存昂贵计算的结果以供以后使用）或将复杂实现拆分为单独的方法。
- en: The functional approach to creating functions with internal state is to use
    closures. Closures, as well as decorators, are the subject of [Chapter 9](ch09.html#closures_and_decorators).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用闭包是创建具有内部状态的函数的功能方法。闭包以及装饰器是[第9章](ch09.html#closures_and_decorators)的主题。
- en: Now let’s explore the powerful syntax Python offers to declare function parameters
    and pass arguments into them.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们探索Python提供的强大语法，用于声明函数参数并将参数传递给它们。
- en: From Positional to Keyword-Only Parameters
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从位置参数到仅关键字参数
- en: One of the best features of Python functions is the extremely flexible parameter
    handling mechanism. Closely related are the use of `*` and `**` to unpack iterables
    and mappings into separate arguments when we call a function. To see these features
    in action, see the code for [Example 7-9](#tagger_ex) and tests showing its use
    in [Example 7-10](#tagger_demo).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Python函数最好的特性之一是极其灵活的参数处理机制。与之密切相关的是在调用函数时使用`*`和`**`将可迭代对象和映射解包为单独的参数。要查看这些功能的实际应用，请参见[示例7-9](#tagger_ex)的代码以及在[示例7-10](#tagger_demo)中展示其用法的测试。
- en: Example 7-9\. `tag` generates HTML elements; a keyword-only argument `class_`
    is used to pass “class” attributes as a workaround because `class` is a keyword
    in Python
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-9。`tag`生成HTML元素；一个关键字参数`class_`用于传递“class”属性，因为`class`是Python中的关键字
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `tag` function can be invoked in many ways, as [Example 7-10](#tagger_demo)
    shows.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`tag`函数可以以许多方式调用，就像[示例 7-10](#tagger_demo)所示。'
- en: Example 7-10\. Some of the many ways of calling the `tag` function from [Example 7-9](#tagger_ex)
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-10。从[示例 7-9](#tagger_ex)调用`tag`函数的许多方法
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_functions_as_first_class_objects_CO5-1)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functions_as_first_class_objects_CO5-1)'
- en: A single positional argument produces an empty `tag` with that name.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 单个位置参数会生成一个具有该名称的空`tag`。
- en: '[![2](assets/2.png)](#co_functions_as_first_class_objects_CO5-2)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functions_as_first_class_objects_CO5-2)'
- en: Any number of arguments after the first are captured by `*content` as a `tuple`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数之后的任意数量的参数将被`*content`捕获为一个`tuple`。
- en: '[![3](assets/3.png)](#co_functions_as_first_class_objects_CO5-3)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functions_as_first_class_objects_CO5-3)'
- en: Keyword arguments not explicitly named in the `tag` signature are captured by
    `**attrs` as a `dict`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tag`签名中未明确命名的关键字参数将被`**attrs`捕获为一个`dict`。
- en: '[![4](assets/4.png)](#co_functions_as_first_class_objects_CO5-4)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_functions_as_first_class_objects_CO5-4)'
- en: The `class_` parameter can only be passed as a keyword argument.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`class_`参数只能作为关键字参数传递。'
- en: '[![5](assets/5.png)](#co_functions_as_first_class_objects_CO5-5)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_functions_as_first_class_objects_CO5-5)'
- en: The first positional argument can also be passed as a keyword.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个位置参数也可以作为关键字传递。
- en: '[![6](assets/6.png)](#co_functions_as_first_class_objects_CO5-6)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_functions_as_first_class_objects_CO5-6)'
- en: Prefixing the `my_tag` `dict` with `**` passes all its items as separate arguments,
    which are then bound to the named parameters, with the remaining caught by `**attrs`.
    In this case we can have a `'class'` key in the arguments `dict`, because it is
    a string, and does not clash with the `class` reserved word.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`**`前缀`my_tag` `dict`将其所有项作为单独的参数传递，然后绑定到命名参数，其余参数由`**attrs`捕获。在这种情况下，我们可以在参数`dict`中有一个`'class'`键，因为它是一个字符串，不会与Python中的`class`保留字冲突。
- en: 'Keyword-only arguments are a feature of Python 3. In [Example 7-9](#tagger_ex),
    the `class_` parameter can only be given as a keyword argument—it will never capture
    unnamed positional arguments. To specify keyword-only arguments when defining
    a function, name them after the argument prefixed with `*`. If you don’t want
    to support variable positional arguments but still want keyword-only arguments,
    put a `*` by itself in the signature, like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数是Python 3的一个特性。在[示例 7-9](#tagger_ex)中，`class_`参数只能作为关键字参数给出，永远不会捕获未命名的位置参数。要在定义函数时指定关键字参数，请在参数前加上`*`命名它们。如果您不想支持可变位置参数但仍想要关键字参数，请在签名中放置一个单独的`*`，就像这样：
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that keyword-only arguments do not need to have a default value: they
    can be mandatory, like `b` in the preceding example.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，关键字参数不需要具有默认值：它们可以是强制性的，就像前面示例中的`b`一样。
- en: Positional-Only Parameters
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅限位置参数
- en: Since Python 3.8, user-defined function signatures may specify positional-only
    parameters. This feature always existed for built-in functions, such as `divmod(a,
    b)`, which can only be called with positional parameters, and not as `divmod(a=10,
    b=4)`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 自Python 3.8以来，用户定义的函数签名可以指定位置参数。这个特性在内置函数中一直存在，比如`divmod(a, b)`，它只能使用位置参数调用，而不能像`divmod(a=10,
    b=4)`那样调用。
- en: To define a function requiring positional-only parameters, use `/` in the parameter
    list.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个需要位置参数的函数，请在参数列表中使用`/`。
- en: 'This example from [“What’s New In Python 3.8”](https://fpy.li/7-7) shows how
    to emulate the `divmod` built-in function:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个来自[“Python 3.8 有什么新特性”](https://fpy.li/7-7)的示例展示了如何模拟`divmod`内置函数：
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: All arguments to the left of the `/` are positional-only. After the `/`, you
    may specify other arguments, which work as usual.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`/`左侧的所有参数都是仅限位置的。在`/`之后，您可以指定其他参数，它们的工作方式与通常一样。'
- en: Warning
  id: totrans-160
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The `/` in the parameter list is a syntax error in Python 3.7 or earlier.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 参数列表中的`/`在Python 3.7或更早版本中是语法错误。
- en: 'For example, consider the `tag` function from [Example 7-9](#tagger_ex). If
    we want the `name` parameter to be positional only, we can add a `/` after it
    in the function signature, like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑来自[示例 7-9](#tagger_ex)的`tag`函数。如果我们希望`name`参数是仅限位置的，我们可以在函数签名中的它后面添加`/`，就像这样：
- en: '[PRE14]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can find other examples of positional-only parameters in [“What’s New In
    Python 3.8”](https://fpy.li/7-7) and in [PEP 570](https://fpy.li/pep570).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[“Python 3.8 有什么新特性”](https://fpy.li/7-7)和[PEP 570](https://fpy.li/pep570)中找到其他仅限位置参数的示例。
- en: After diving into Python’s flexible argument declaration features, the remainder
    of this chapter covers the most useful packages in the standard library for programming
    in a functional style.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究Python灵活的参数声明功能后，本章的其余部分将介绍标准库中用于以函数式风格编程的最有用的包。
- en: Packages for Functional Programming
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程包
- en: Although Guido makes it clear that he did not design Python to be a functional
    programming language, a functional coding style can be used to good extent, thanks
    to first-class functions, pattern matching, and the support of packages like `operator`
    and `functools`, which we cover in the next two sections.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Guido明确表示他并没有设计Python成为一个函数式编程语言，但由于头等函数、模式匹配以及像`operator`和`functools`这样的包的支持，函数式编码风格可以被很好地使用，我们将在接下来的两节中介绍它们。
- en: The operator Module
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算符模块
- en: Often in functional programming it is convenient to use an arithmetic operator
    as a function. For example, suppose you want to multiply a sequence of numbers
    to calculate factorials without using recursion. To perform summation, you can
    use `sum`, but there is no equivalent function for multiplication. You could use
    `reduce`—as we saw in [“Modern Replacements for map, filter, and reduce”](#map_filter_reduce)—but
    this requires a function to multiply two items of the sequence. [Example 7-11](#fact_reduce_lambda_ex)
    shows how to solve this using `lambda`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，使用算术运算符作为函数很方便。例如，假设您想要乘以一系列数字以计算阶乘而不使用递归。要执行求和，您可以使用 `sum`，但没有相应的乘法函数。您可以使用
    `reduce`——正如我们在 [“map、filter 和 reduce 的现代替代品”](#map_filter_reduce) 中看到的那样——但这需要一个函数来将序列的两个项相乘。[示例
    7-11](#fact_reduce_lambda_ex) 展示了如何使用 `lambda` 解决这个问题。
- en: Example 7-11\. Factorial implemented with `reduce` and an anonymous function
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-11\. 使用 `reduce` 和匿名函数实现阶乘
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `operator` module provides function equivalents for dozens of operators
    so you don’t have to code trivial functions like `lambda a, b: a*b`. With it,
    we can rewrite [Example 7-11](#fact_reduce_lambda_ex) as [Example 7-12](#fact_reduce_operator_ex).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator` 模块提供了几十个运算符的函数等效版本，因此您不必编写像 `lambda a, b: a*b` 这样的琐碎函数。有了它，我们可以将
    [示例 7-11](#fact_reduce_lambda_ex) 重写为 [示例 7-12](#fact_reduce_operator_ex)。'
- en: Example 7-12\. Factorial implemented with `reduce` and `operator.mul`
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-12\. 使用 `reduce` 和 `operator.mul` 实现阶乘
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Another group of one-trick `lambda`s that `operator` replaces are functions
    to pick items from sequences or read attributes from objects: `itemgetter` and
    `attrgetter` are factories that build custom functions to do that.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator` 替换的另一组单一用途的 `lambda` 是用于从序列中选择项或从对象中读取属性的函数：`itemgetter` 和 `attrgetter`
    是构建自定义函数的工厂来执行这些操作。'
- en: '[Example 7-13](#itemgetter_demo) shows a common use of `itemgetter`: sorting
    a list of tuples by the value of one field. In the example, the cities are printed
    sorted by country code (field 1). Essentially, `itemgetter(1)` creates a function
    that, given a collection, returns the item at index 1. That’s easier to write
    and read than `lambda fields: fields[1]`, which does the same thing.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7-13](#itemgetter_demo) 展示了 `itemgetter` 的一个常见用法：按一个字段的值对元组列表进行排序。在示例中，城市按国家代码（字段
    1）排序打印。本质上，`itemgetter(1)` 创建一个函数，给定一个集合，返回索引 1 处的项。这比编写和阅读 `lambda fields: fields[1]`
    更容易，后者执行相同的操作。'
- en: Example 7-13\. Demo of `itemgetter` to sort a list of tuples (data from [Example 2-8](ch02.html#ex_nested_tuple))
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-13\. 使用 `itemgetter` 对元组列表进行排序（数据来自 [示例 2-8](ch02.html#ex_nested_tuple)）
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you pass multiple index arguments to `itemgetter`, the function it builds
    will return tuples with the extracted values, which is useful for sorting on multiple
    keys:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将多个索引参数传递给 `itemgetter`，则它构建的函数将返回提取的值的元组，这对于按多个键排序很有用：
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Because `itemgetter` uses the `[]` operator, it supports not only sequences
    but also mappings and any class that implements `__getitem__`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `itemgetter` 使用 `[]` 运算符，它不仅支持序列，还支持映射和任何实现 `__getitem__` 的类。
- en: A sibling of `itemgetter` is `attrgetter`, which creates functions to extract
    object attributes by name. If you pass `attrgetter` several attribute names as
    arguments, it also returns a tuple of values. In addition, if any argument name
    contains a `.` (dot), `attrgetter` navigates through nested objects to retrieve
    the attribute. These behaviors are shown in [Example 7-14](#attrgetter_demo).
    This is not the shortest console session because we need to build a nested structure
    to showcase the handling of dotted attributes by `attrgetter`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`itemgetter` 的姐妹是 `attrgetter`，它通过名称创建提取对象属性的函数。如果将多个属性名称作为参数传递给 `attrgetter`，它还会返回一个值元组。此外，如果任何参数名称包含
    `.`（点），`attrgetter` 将浏览嵌套对象以检索属性。这些行为在 [示例 7-14](#attrgetter_demo) 中展示。这不是���短的控制台会话，因为我们需要构建一个嵌套结构来展示
    `attrgetter` 处理带点属性的方式。'
- en: Example 7-14\. Demo of `attrgetter` to process a previously defined list of
    `namedtuple` called `metro_data` (the same list that appears in [Example 7-13](#itemgetter_demo))
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-14\. 使用 `attrgetter` 处理先前定义的 `namedtuple` 列表 `metro_data`（与 [示例 7-13](#itemgetter_demo)
    中出现的相同列表）
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](assets/1.png)](#co_functions_as_first_class_objects_CO6-1)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functions_as_first_class_objects_CO6-1)'
- en: Use `namedtuple` to define `LatLon`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `namedtuple` 定义 `LatLon`。
- en: '[![2](assets/2.png)](#co_functions_as_first_class_objects_CO6-2)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functions_as_first_class_objects_CO6-2)'
- en: Also define `Metropolis`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 还要定义 `Metropolis`。
- en: '[![3](assets/3.png)](#co_functions_as_first_class_objects_CO6-3)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functions_as_first_class_objects_CO6-3)'
- en: Build `metro_areas` list with `Metropolis` instances; note the nested tuple
    unpacking to extract `(lat, lon)` and use them to build the `LatLon` for the `coord`
    attribute of `Metropolis`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Metropolis` 实例构建 `metro_areas` 列表；注意嵌套元组解包以提取 `(lat, lon)` 并将其用于构建 `Metropolis`
    的 `coord` 属性的 `LatLon`。
- en: '[![4](assets/4.png)](#co_functions_as_first_class_objects_CO6-4)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_functions_as_first_class_objects_CO6-4)'
- en: Reach into element `metro_areas[0]` to get its latitude.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 访问元素 `metro_areas[0]` 以获取其纬度。
- en: '[![5](assets/5.png)](#co_functions_as_first_class_objects_CO6-5)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_functions_as_first_class_objects_CO6-5)'
- en: Define an `attrgetter` to retrieve the `name` and the `coord.lat` nested attribute.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个 `attrgetter` 来检索 `name` 和 `coord.lat` 嵌套属性。
- en: '[![6](assets/6.png)](#co_functions_as_first_class_objects_CO6-6)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_functions_as_first_class_objects_CO6-6)'
- en: Use `attrgetter` again to sort list of cities by latitude.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用 `attrgetter` 按纬度对城市列表进行排序。
- en: '[![7](assets/7.png)](#co_functions_as_first_class_objects_CO6-7)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_functions_as_first_class_objects_CO6-7)'
- en: Use the `attrgetter` defined in ![5](assets/5.png) to show only the city name
    and latitude.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ![5](assets/5.png) 中定义的 `attrgetter` 仅显示城市名称和纬度。
- en: 'Here is a partial list of functions defined in `operator` (names starting with
    `_` are omitted, because they are mostly implementation details):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 `operator` 中定义的函数的部分列表（以 `_` 开头的名称被省略，因为它们主要是实现细节）：
- en: '[PRE20]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Most of the 54 names listed are self-evident. The group of names prefixed with
    `i` and the name of another operator—e.g., `iadd`, `iand`, etc.—correspond to
    the augmented assignment operators—e.g., `+=`, `&=`, etc. These change their first
    argument in place, if it is mutable; if not, the function works like the one without
    the `i` prefix: it simply returns the result of the operation.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的54个名称中大多数都是不言自明的。以`i`为前缀的名称组和另一个运算符的名称，例如`iadd`、`iand`等，对应于增强赋值运算符，例如`+=`、`&=`等。如果第一个参数是可变的，这些会在原地更改第一个参数；如果不是，该函数的工作方式类似于没有`i`前缀的函数：它只是返回操作的结果。
- en: Of the remaining `operator` functions, `methodcaller` is the last we will cover.
    It is somewhat similar to `attrgetter` and `itemgetter` in that it creates a function
    on the fly. The function it creates calls a method by name on the object given
    as argument, as shown in [Example 7-15](#methodcaller_demo).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在剩余的`operator`函数中，`methodcaller`是我们将要介绍的最后一个。它在某种程度上类似于`attrgetter`和`itemgetter`，因为它会即时创建一个函数。它创建的函数会按名称在给定的对象上调用一个方法，就像[示例 7-15](#methodcaller_demo)中所示的那样。
- en: 'Example 7-15\. Demo of `methodcaller`: second test shows the binding of extra
    arguments'
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-15。`methodcaller`的演示：第二个测试显示了额外参数的绑定
- en: '[PRE21]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The first test in [Example 7-15](#methodcaller_demo) is there just to show
    `methodcaller` at work, but if you need to use the `str.upper` as a function,
    you can just call it on the `str` class and pass a string as an argument, like
    this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7-15](#methodcaller_demo)中的第一个测试只是为了展示`methodcaller`的工作原理，但如果您需要将`str.upper`作为一个函数使用，您可以直接在`str`类上调用它，并传递一个字符串作为参数，就像这样：'
- en: '[PRE22]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The second test in [Example 7-15](#methodcaller_demo) shows that `methodcaller`
    can also do a partial application to freeze some arguments, like the `functools.partial`
    function does. That is our next subject.*Bold Text*opmod07
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7-15](#methodcaller_demo)中的第二个测试表明，`methodcaller`也可以进行部分应用，冻结一些参数，就像`functools.partial`函数一样。这是我们下一个主题。*Bold
    Text*opmod07'
- en: Freezing Arguments with functools.partial
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`functools.partial`冻结参数
- en: 'The `functools` module provides several higher-order functions. We saw `reduce`
    in [“Modern Replacements for map, filter, and reduce”](#map_filter_reduce). Another
    is `partial`: given a callable, it produces a new callable with some of the arguments
    of the original callable bound to predetermined values. This is useful to adapt
    a function that takes one or more arguments to an API that requires a callback
    with fewer arguments. [Example 7-16](#ex_partial_mul) is a trivial demonstration.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`functools`模块提供了几个高阶函数。我们在[“map、filter和reduce的现代替代品”](#map_filter_reduce)中看到了`reduce`。另一个是`partial`：给定一个可调用对象，它会生成一个新的可调用对象，其中原始可调用对象的一些参数绑定为预定值。这对于将接受一个或多个参数的函数适应需要较少参数的回调函数的API很有用。[示例 7-16](#ex_partial_mul)是一个微不足道的演示。'
- en: Example 7-16\. Using `partial` to use a two-argument function where a one-argument
    callable is required
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-16。使用`partial`在需要一个参数可调用对象的地方使用两个参数函数
- en: '[PRE23]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](assets/1.png)](#co_functions_as_first_class_objects_CO7-1)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functions_as_first_class_objects_CO7-1)'
- en: Create new `triple` function from `mul`, binding the first positional argument
    to `3`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 从`mul`创建新的`triple`函数，将第一个位置参数绑定为`3`。
- en: '[![2](assets/2.png)](#co_functions_as_first_class_objects_CO7-2)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functions_as_first_class_objects_CO7-2)'
- en: Test it.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 测试它。
- en: '[![3](assets/3.png)](#co_functions_as_first_class_objects_CO7-3)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functions_as_first_class_objects_CO7-3)'
- en: Use `triple` with `map`; `mul` would not work with `map` in this example.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`triple`与`map`；在这个例子中，`mul`无法与`map`一起使用。
- en: A more useful example involves the `unicode.normalize` function that we saw
    in [“Normalizing Unicode for Reliable Comparisons”](ch04.html#normalizing_unicode).
    If you work with text from many languages, you may want to apply `unicode.normalize('NFC',
    s)` to any string `s` before comparing or storing it. If you do that often, it’s
    handy to have an `nfc` function to do so, as in [Example 7-17](#ex_partial_nfc).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更有用的示例涉及到我们在[“为可靠比较标准化Unicode”](ch04.html#normalizing_unicode)中看到的`unicode.normalize`函数。如果您使用来自许多语言的文本，您可能希望在比较或存储之前对任何字符串`s`应用`unicode.normalize('NFC',
    s)`。如果您经常这样做，最好有一个`nfc`函数来执行，就像[示例 7-17](#ex_partial_nfc)中那样。
- en: Example 7-17\. Building a convenient Unicode normalizing function with `partial`
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-17。使用`partial`构建一个方便的Unicode标准化函数
- en: '[PRE24]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`partial` takes a callable as first argument, followed by an arbitrary number
    of positional and keyword arguments to bind.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`partial`以可调用对象作为第一个参数，后跟要绑定的任意数量的位置参数和关键字参数。'
- en: '[Example 7-18](#partial_demo) shows the use of `partial` with the `tag` function
    from [Example 7-9](#tagger_ex), to freeze one positional argument and one keyword
    argument.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7-18](#partial_demo)展示了`partial`与[示例 7-9](#tagger_ex)中的`tag`函数一起使用，冻结一个位置参数和一个关键字参数。'
- en: Example 7-18\. Demo of `partial` applied to the `function tag` from [Example 7-9](#tagger_ex)
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-18。演示`partial`应用于[示例 7-9](#tagger_ex)中的`tag`函数
- en: '[PRE25]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[![1](assets/1.png)](#co_functions_as_first_class_objects_CO8-1)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functions_as_first_class_objects_CO8-1)'
- en: Import `tag` from [Example 7-9](#tagger_ex) and show its ID.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 从[示例 7-9](#tagger_ex)导入`tag`并显示其ID。
- en: '[![2](assets/2.png)](#co_functions_as_first_class_objects_CO8-2)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functions_as_first_class_objects_CO8-2)'
- en: Create the `picture` function from `tag` by fixing the first positional argument
    with `'img'` and the `class_` keyword argument with `'pic-frame'`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`tag`从`tag`创建`picture`函数，通过使用`'img'`固定第一个位置参数和`'pic-frame'`关键字参数。
- en: '[![3](assets/3.png)](#co_functions_as_first_class_objects_CO8-3)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functions_as_first_class_objects_CO8-3)'
- en: '`picture` works as expected.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`picture`按预期工作。'
- en: '[![4](assets/4.png)](#co_functions_as_first_class_objects_CO8-4)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_functions_as_first_class_objects_CO8-4)'
- en: '`partial()` returns a `functools.partial` object.^([4](ch07.html#idm46582446040448))'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`partial()`返回一个`functools.partial`对象。^([4](ch07.html#idm46582446040448))'
- en: '[![5](assets/5.png)](#co_functions_as_first_class_objects_CO8-5)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_functions_as_first_class_objects_CO8-5)'
- en: A `functools.partial` object has attributes providing access to the original
    function and the fixed arguments.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`functools.partial`对象具有提供对原始函数和固定参数的访问的属性。
- en: The `functools.partialmethod` function does the same job as `partial`, but is
    designed to work with methods.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`functools.partialmethod` 函数与 `partial` 执行相同的工作，但设计用于与方法一起使用。'
- en: The `functools` module also includes higher-order functions designed to be used
    as function decorators, such as `cache` and `singledispatch`, among others. Those
    functions are covered in [Chapter 9](ch09.html#closures_and_decorators), which
    also explains how to implement custom decorators.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`functools` 模块还包括设计用作函数装饰器的高阶函数，例如 `cache` 和 `singledispatch` 等。这些函数在[第9章](ch09.html#closures_and_decorators)中有介绍，该章还解释了如何实现自定义装饰器。'
- en: Chapter Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节总结
- en: The goal of this chapter was to explore the first-class nature of functions
    in Python. The main ideas are that you can assign functions to variables, pass
    them to other functions, store them in data structures, and access function attributes,
    allowing frameworks and tools to act on that information.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是探索 Python 中函数的头等性质。主要思想是你可以将函数分配给变量，将它们传递给其他函数，将它们存储在数据结构中，并访问函数属性，从而使框架和工具能够根据这些信息进行操作。
- en: Higher-order functions, a staple of functional programming, are common in Python.
    The `sorted`, `min`, and `max` built-ins, and `functools.partial` are examples
    of commonly used higher-order functions in the language. Using `map`, `filter`,
    and `reduce` is not as common as it used to be, thanks to list comprehensions
    (and similar constructs like generator expressions) and the addition of reducing
    built-ins like `sum`, `all`, and `any`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数，作为函数式编程的基本要素，在 Python 中很常见。`sorted`、`min` 和 `max` 内置函数，以及 `functools.partial`
    都是该语言中常用的高阶函数的例子。使用 `map`、`filter` 和 `reduce` 不再像以前那样常见，这要归功于列表推导式（以及类似的生成器表达式）以及新增的归约内置函数如
    `sum`、`all` 和 `any`。
- en: Callables come in nine different flavors since Python 3.6, from the simple functions
    created with `lambda` to instances of classes implementing `__call__`. Generators
    and coroutines are also callable, although their behavior is very different from
    other callables. All callables can be detected by the `callable()` built-in. Callables
    offer rich syntax for declaring formal parameters, including keyword-only parameters,
    positional-only parameters, and annotations.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Python 3.6 起，可调用对象有九种不同的类型，从使用 `lambda` 创建的简单函数到实现 `__call__` 的类实例。生成器和协程也是可调用的，尽管它们的行为与其他可调用对象非常不同。所有可调用对象都可以通过内置函数
    `callable()` 进行检测。可调用对象提供了丰富的语法来声明形式参数，包括仅限关键字参数、仅限位置参数和注释。
- en: Lastly, we covered some functions from the `operator` module and `functools.partial`,
    which facilitate functional programming by minimizing the need for the functionally
    challenged `lambda` syntax.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了 `operator` 模块和 `functools.partial` 中的一些函数，通过最小化对功能受限的 `lambda` 语法的需求，促进了函数式编程。
- en: Further Reading
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The next chapters continue our exploration of programming with function objects.
    [Chapter 8](ch08.html#type_hints_in_def_ch) is devoted to type hints in function
    parameters and return values. [Chapter 9](ch09.html#closures_and_decorators) dives
    into function decorators—a special kind of higher-order function—and the closure
    mechanism that makes them work. [Chapter 10](ch10.html#rethinking_design_patterns)
    shows how first-class functions can simplify some classic object-oriented design
    patterns.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节将继续探讨使用函数对象进行编程。[第8章](ch08.html#type_hints_in_def_ch)专注于函数参数和返回值中的类型提示。[第9章](ch09.html#closures_and_decorators)深入探讨了函数装饰器——一种特殊的高阶函数，以及使其工作的闭包机制。[第10章](ch10.html#rethinking_design_patterns)展示了头等函数如何简化一些经典的面向对象设计模式。
- en: In *The Python Language Reference*, [“3.2\. The standard type hierarchy”](https://fpy.li/7-10)
    presents the nine callable types, along with all the other built-in types.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Python 语言参考*中，[“3.2\. 标准类型层次结构”](https://fpy.li/7-10)介绍了九种可调用类型，以及所有其他内置类型。
- en: Chapter 7 of the *[Python Cookbook](https://fpy.li/pycook3)*, 3rd ed. (O’Reilly),
    by David Beazley and Brian K. Jones, is an excellent complement to the current
    chapter as well as [Chapter 9](ch09.html#closures_and_decorators) of this book,
    covering mostly the same concepts with a different approach.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*[Python Cookbook](https://fpy.li/pycook3)* 第3版（O’Reilly）的第7章，由 David Beazley
    和 Brian K. Jones 撰写，是对当前章节以及本书的[第9章](ch09.html#closures_and_decorators)的极好补充，主要涵盖了相同概念但采用不同方法。'
- en: See [PEP 3102—Keyword-Only Arguments](https://fpy.li/pep3102) if you are interested
    in the rationale and use cases for that feature.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对关键字参数的原理和用例感兴趣，请参阅[PEP 3102—关键字参数](https://fpy.li/pep3102)。
- en: A great introduction to functional programming in Python is A. M. Kuchling’s
    [“Python Functional Programming HOWTO”](https://fpy.li/7-5). The main focus of
    that text, however, is the use of iterators and generators, which are the subject
    of [Chapter 17](ch17.html#iterables2generators).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 Python 中函数式编程的绝佳入门是 A. M. Kuchling 的[“Python 函数式编程 HOWTO”](https://fpy.li/7-5)。然而，该文本的主要焦点是迭代器和生成器的使用，这是[第17章](ch17.html#iterables2generators)的主题。
- en: 'The StackOverflow question [“Python: Why is functools.partial necessary?”](https://fpy.li/7-12)
    has a highly informative (and funny) reply by Alex Martelli, coauthor of the classic
    *Python in a Nutshell* (O’Reilly).'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 'StackOverflow 上的问题[“Python: 为什么 functools.partial 是必要的？”](https://fpy.li/7-12)有一篇由经典著作*Python
    in a Nutshell*（O’Reilly）的合著者 Alex Martelli 所撰写的高度信息化（且有趣）的回答。'
- en: Reflecting on the question “Is Python a functional language?”, I created one
    of my favorite talks, “Beyond Paradigms,” which I presented at PyCaribbean, PyBay,
    and PyConDE. See the [slides](https://fpy.li/7-13) and [video](https://fpy.li/7-14)
    from the Berlin presentation—where I met Miroslav Šedivý and Jürgen Gmach, two
    of the technical reviewers of this book.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 思考问题“Python 是一种函数式语言吗？”，我创作了��最喜欢的演讲之一，“超越范式”，我在 PyCaribbean、PyBay 和 PyConDE
    上做过演讲。请查看我在柏林演讲中遇到本书两位技术审阅者 Miroslav Šedivý 和 Jürgen Gmach 的[幻灯片](https://fpy.li/7-13)和[视频](https://fpy.li/7-14)。
- en: ^([1](ch07.html#idm46582448753712-marker)) [“Origins of Python’s ‘Functional’
    Features”](https://fpy.li/7-1), from Guido’s *The History of Python* blog.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch07.html#idm46582448753712-marker)) 来自 Guido 的*Python 的起源*博客的[“Python‘函数式’特性的起源”](https://fpy.li/7-1)。
- en: ^([2](ch07.html#idm46582448020576-marker)) Calling a class usually creates an
    instance of that same class, but other behaviors are possible by overriding `__new__`.
    We’ll see an example of this in [“Flexible Object Creation with __new__”](ch22.html#flexible_new_sec).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch07.html#idm46582448020576-marker)) 调用一个类通常会创建该类的一个实例，但通过重写`__new__`可以实现其他行为。我们将在[“使用__new__实现灵活的对象创建”](ch22.html#flexible_new_sec)中看到一个例子。
- en: ^([3](ch07.html#idm46582447990112-marker)) Why build a `BingoCage` when we already
    have `random.choice`? The `choice` function may return the same item multiple
    times, because the picked item is not removed from the collection given. Calling
    `BingoCage` never returns duplicate results—as long as the instance is filled
    with unique values.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch07.html#idm46582447990112-marker)) 既然我们已经有了`random.choice`，为什么要构建一个`BingoCage`？`choice`函数可能多次返回相同的项，因为选定的项未从给定的集合中移除。调用`BingoCage`永远不会返回重复的结果——只要实例填充了唯一的值。
- en: ^([4](ch07.html#idm46582446040448-marker)) The [source code](https://fpy.li/7-9)
    for *functools.py* reveals that `functools.partial` is implemented in C and is
    used by default. If that is not available, a pure-Python implementation of `partial`
    is available since Python 3.4.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch07.html#idm46582446040448-marker)) *functools.py*的[源代码](https://fpy.li/7-9)显示，`functools.partial`是用C实现的，并且默认情况下使用。
    如果不可用，自Python 3.4起提供了`partial`的纯Python实现。
- en: ^([5](ch07.html#idm46582445978576-marker)) There is also the problem of lost
    indentation when pasting code to web forums, but I digress.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch07.html#idm46582445978576-marker)) 在将代码粘贴到网络论坛时，还存在缩进丢失的问题，但我岔开了话题。
