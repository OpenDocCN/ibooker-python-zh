<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" class="pagenumrestart" data-pdf-bookmark="Chapter 1. What Is Dask?"><div class="chapter" id="ch1_what_is_dask">
<h1><span class="label">Chapter 1. </span>What Is Dask?</h1>


<p>Dask is a framework for parallelized computing with Python that scales from multiple cores on one machine to data centers with thousands of machines. It has both low-level task APIs and higher-level data-focused APIs. The low-level task APIs power Dask’s integration with a wide variety of Python libraries. Having public APIs has allowed an ecosystem of tools to grow around Dask for various use cases.</p>

<p>Continuum Analytics, now <a data-type="indexterm" data-primary="Continuum Analytics" id="id287"/>known as Anaconda Inc, started the open source, DARPA-funded <a href="https://oreil.ly/FyqwQ">Blaze project</a>, which has evolved into Dask.
Continuum has participated in developing many essential libraries and even conferences in the Python data analytics space. Dask remains an open source project, with much of its development now being supported by <a href="https://oreil.ly/BMLuP">Coiled</a>.</p>

<p>Dask is unique in the distributed computing ecosystem, because it integrates popular data science, parallel, and scientific computing libraries. Dask’s integration of different libraries allows developers to reuse much of their existing knowledge at scale. They can also frequently reuse some of their code with minimal changes.</p>






<section data-type="sect1" data-pdf-bookmark="Why Do You Need Dask?"><div class="sect1" id="id250">
<h1>Why Do You Need Dask?</h1>

<p>Dask simplifies scaling analytics, ML, and other  code written in Python,<sup><a data-type="noteref" id="id288-marker" href="ch01.xhtml#id288">1</a></sup> allowing you to handle larger and more complex data and problems.
Dask aims to fill the space where your existing tools, like pandas DataFrames, or your scikit-learn machine learning pipelines start to become too slow (or do not succeed).
While the term “big data” is perhaps less in vogue now than a few years ago, the data size of the problems has not gotten smaller, and the complexity of the computation and models has not gotten simpler.
Dask allows you to primarily use the existing interfaces that you are used to (such as pandas and multi-processing) while going beyond the scale of a single core or even a single machine.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>On the other hand, if all your data fits in memory on a laptop, and you can finish your analysis before you’ve had a chance to brew a cup of your favorite warm beverage, you probably don’t need 
<span class="keep-together">Dask yet.</span></p>
</div>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Where Does Dask Fit in the Ecosystem?"><div class="sect1" id="id2">
<h1>Where Does Dask Fit in the Ecosystem?</h1>

<p>Dask provides scalability to multiple, traditionally distinct tools. It is most often used to scale Python data libraries like pandas and NumPy. Dask extends existing tools for scaling, such as multi-processing, allowing them to exceed their current limits of single machines to multi-core and multi-machine. The following provides a quick look at the ecosystem evolution:</p>
<dl>
<dt>Early “big data” query</dt>
<dd>
<p>Apache Hadoop and Apache Hive</p>
</dd>
<dt>Later “big data” query</dt>
<dd>
<p>Apache Flink and Apache Spark</p>
</dd>
<dt>DataFrame-focused distributed tools</dt>
<dd>
<p>Koalas, Ray, and Dask</p>
</dd>
</dl>

<p>From an abstraction point of view, Dask sits above the machines and cluster management tools, allowing you to focus on Python code instead of the intricacies of machine-to-machine communication:</p>
<dl>
<dt>Scalable data and ML tools</dt>
<dd>
<p>Hadoop, Hive, Flink, <a data-type="indexterm" data-primary="Hadoop" id="id289"/><a data-type="indexterm" data-primary="Hive" id="id290"/><a data-type="indexterm" data-primary="Flink" id="id291"/><a data-type="indexterm" data-primary="Spark" id="id292"/><a data-type="indexterm" data-primary="TensorFlow" id="id293"/><a data-type="indexterm" data-primary="Koalas" id="id294"/><a data-type="indexterm" data-primary="Ray" id="id295"/>Spark, TensorFlow, Koalas, Ray, Dask, etc.</p>
</dd>
<dt>Compute resources</dt>
<dd>
<p>Apache Hadoop YARN, <a data-type="indexterm" data-primary="Hadoop YARN" id="id296"/><a data-type="indexterm" data-primary="Kubernetes" id="id297"/><a data-type="indexterm" data-primary="Amazon Web Services (AWS)" id="id298"/><a data-type="indexterm" data-primary="AWS (Amazon Web Services)" id="id299"/><a data-type="indexterm" data-primary="Slurm Workload Manager" id="id300"/>Kubernetes, Amazon Web Services, Slurm Workload Manager, etc.</p>
</dd>
</dl>

<p>We say a problem is <em>compute-bound</em> if the limiting <a data-type="indexterm" data-primary="compute-bound problems" id="id301"/>factor is not the amount of data but rather the work we are doing on the data. <em>Memory-bound</em> problems are <a data-type="indexterm" data-primary="memory-bound problems" id="id302"/>problems in which the computation is not the limiting factor; rather, the ability to store all the data in memory is the limiting factor. Some problems can be both compute-bound and memory-bound, as is often the case for large deep-learning problems.</p>

<p class="pagebreak-before">Multi-core (think multi-threading) processing <a data-type="indexterm" data-primary="multi-core processing" id="id303"/>can help with compute-bound problems (up to the limit of the number of cores in a machine). Generally, multi-core processing is unable to help with memory-bound problems, as all Central Processing Units (CPUs) have similar access to the memory.<sup><a data-type="noteref" id="id304-marker" href="ch01.xhtml#id304">2</a></sup></p>

<p>Accelerated processing, including the use of specialized <a data-type="indexterm" data-primary="accelerated processing" id="id305"/>instruction sets or specialized hardware like Tensor Processing Units or Graphics Processing Units, is generally useful only for compute-bound problems. Sometimes using accelerated processing introduces memory-bound problems, as the amount of memory available to the accelerated computation can be smaller than the “main” system memory.</p>

<p>Multi-machine processing is <a data-type="indexterm" data-primary="multi-machine processing" id="id306"/>important for both classes of problems. Since the number of cores you can get in a machine (affordably) is limited, even if a problem is “only” compute bound at certain scales, you will need to consider multi-machine processing. More commonly, memory-bound problems are a good fit for multi-machine scaling, as Dask can often split the data between the different machines.</p>

<p>Dask has both multi-core and multi-machine scaling, allowing you to scale your Python code as you see fit.</p>

<p>Much of Dask’s power comes from the tools and libraries built on top of it, which fit into their parts of the data processing ecosystem (such as BlazingSQL). Your background and interest will naturally shape how you first view Dask, so in the following subsections, we’ll briefly discuss how you can use Dask for different types of problems, as well as how it compares to some existing tools.</p>








<section data-type="sect2" data-pdf-bookmark="Big Data"><div class="sect2" id="id3">
<h2>Big Data</h2>

<p>Dask has better Python library <a data-type="indexterm" data-primary="big data" id="id307"/><a data-type="indexterm" data-primary="PySpark" id="id308"/>integrations and lower overhead for tasks than many alternatives.
Apache Spark (and its Python companion, PySpark) is one of the most popular tools for big data.
Existing big data tools, such as PySpark, have more data sources and optimizers (like predicate push-down) but higher overhead per task. Dask’s lower overhead is due mainly to the rest of the Python big data ecosystem being built primarily on top of the JVM. These tools have advanced features such as query optimizers, but with the cost of copying data between the JVM and Python.</p>

<p class="pagebreak-after">Unlike many other traditional big data tools, such as Spark and Hadoop, Dask considers local mode a first-class citizen. The traditional big data ecosystem focuses on using the local mode for testing, but Dask focuses on good performance when running on a single node.</p>

<p>Another significant cultural difference comes from packaging, with many projects in big data putting everything together (for example, Spark SQL, Spark Kubernetes, and so on are released together). Dask takes a more modular approach, with its components following their own development and release cadence. Dask’s approach can iterate faster, at the cost of occasional incompatibilities between libraries.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Data Science"><div class="sect2" id="id4">
<h2>Data Science</h2>

<p>One of the most popular Python libraries in the data <a data-type="indexterm" data-primary="pandas" id="id309"/>science ecosystem is pandas.
Apache Spark (and its Python companion, PySpark) is also one of the most popular tools for distributed data science. It has support for both Python and JVM languages. Spark’s first attempt at DataFrames more closely resembled SQL than what you may think of as DataFrames. While Spark has started to integrate pandas support with the <a href="https://oreil.ly/VmU6O">Koalas project</a>, Dask’s support of data science library APIs is best in class, in our opinion.<sup><a data-type="noteref" id="id310-marker" href="ch01.xhtml#id310">3</a></sup>
In addition to the pandas APIs, Dask supports scaling NumPy, scikit-learn, and other data science tools.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Dask can be extended to support data types besides NumPy and pandas, and this is how GPU support is implemented with <a href="https://oreil.ly/m-K8W">cuDF</a>.</p>
</div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Parallel to Distributed Python"><div class="sect2" id="id5">
<h2>Parallel to Distributed Python</h2>

<p class="pagebreak-after"><em>Parallel computing</em> refers to running multiple operations at the same time, and <em>distributed computing</em> carries this on to multiple operations on multiple machines.
Parallel Python encompasses a <a data-type="indexterm" data-primary="Python" data-secondary="parallel" id="id311"/><a data-type="indexterm" data-primary="Python" data-secondary="distributed" id="id312"/><a data-type="indexterm" data-primary="parallel Python" id="id313"/><a data-type="indexterm" data-primary="distributed Python" id="id314"/>wide variety of tools ranging from multi-processing to Celery.<sup><a data-type="noteref" id="id315-marker" href="ch01.xhtml#id315">4</a></sup> Dask gives you the ability to specify an arbitrary graph of dependencies and execute them in parallel. Under the hood, this execution can either be backed by a single machine (with threads or processes) or be distributed across multiple workers.</p>
<div data-type="note" epub:type="note" class="less_space"><h6>Note</h6>
<p>Many big data tools have similar low-level task APIs, but they are internal and are not exposed for our use or protected against failures.</p>
</div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Dask Community Libraries"><div class="sect2" id="id6">
<h2>Dask Community Libraries</h2>

<p>Dask’s true power comes from the <a data-type="indexterm" data-primary="libraries" data-secondary="community libraries" id="id316"/><a data-type="indexterm" data-primary="community libraries" id="id317"/>ecosystem built around it. Different libraries are built on top of Dask, giving you the ability to use multiple tools in the same framework. These community libraries are so powerful in part because of the combination of low-level and high-level APIs that are available for more than just first-party development.</p>










<section data-type="sect3" data-pdf-bookmark="Accelerated Python"><div class="sect3" id="id153">
<h3>Accelerated Python</h3>

<p>You can accelerate Python in a few <a data-type="indexterm" data-primary="libraries" data-secondary="community libraries" data-tertiary="accelerated Python" id="id318"/><a data-type="indexterm" data-primary="community libraries" data-secondary="accelerated Python" id="id319"/><a data-type="indexterm" data-primary="Python" data-secondary="accelerated" id="id320"/>different ways, ranging from code generation (such as Numba) to libraries for special hardware such as NVidia’s CUDA (and wrappers like cuDF), AMD’s ROCm, and Intel’s MKL.</p>

<p>Dask itself is not a library for accelerated Python, but you can use it in conjunction with accelerated Python tools. For ease of use, some community projects integrate acceleration tools, such as cuDF and dask-cuda, with Dask.  When using accelerated Python tools with Dask, you’ll need to be careful to structure your code to avoid serialization errors (see <a data-type="xref" href="ch03.xhtml#ser_pick_dtl">“Serialization and Pickling”</a>).</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Accelerated Python libraries tend to use more “native” memory structures, which are not as easily handled by pickle.</p>
</div>
</div></section>










<section data-type="sect3" data-pdf-bookmark="SQL engines"><div class="sect3" id="id154">
<h3>SQL engines</h3>

<p class="pagebreak-after">Dask itself does not have a SQL engine; however, <a href="https://oreil.ly/sBLQM">FugueSQL</a>, <a href="https://oreil.ly/ZMVD1">Dask-SQL</a>, and <a href="https://oreil.ly/4gHru">BlazingSQL</a> use Dask to <a data-type="indexterm" data-primary="libraries" data-secondary="community libraries" data-tertiary="SQL engines" id="id321"/><a data-type="indexterm" data-primary="community libraries" data-secondary="SQL engines" id="id322"/>provide a distributed SQL engine.<sup><a data-type="noteref" id="id323-marker" href="ch01.xhtml#id323">5</a></sup> Dask-SQL uses the popular Apache Calcite project, which powers many other SQL engines. BlazingSQL extends Dask DataFrames to support GPU operations. cuDF DataFrames have a slightly different representation. Apache Arrow makes it straightforward to convert a Dask DataFrame to cuDF and vice versa.</p>

<p>Dask allows these different SQL engines to scale both memory- and compute-wise, handling larger data sizes than fit in memory on a single computer and processing rows on multiple computers. Dask also powers the important aggregation step of combining the results from the different machines into a cohesive view of the data.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Dask-SQL can read data from parts of the Hadoop ecosystem that Dask cannot read from (e.g., Hive).</p>
</div>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Workflow scheduling"><div class="sect3" id="id7">
<h3>Workflow scheduling</h3>

<p>Most organizations have the need for some kind of scheduled work, from programs that run at specific times (such as those that calculate end-of-day or end-of-month financials) to programs that run in response to events. These events can be things like data becoming available (such as after the daily financials are run) or a new email coming in, or they can be user triggered. In the simplest case the scheduled work can be a single program, but it is often more complex than that.</p>

<p>As mentioned previously, you can <a data-type="indexterm" data-primary="libraries" data-secondary="community libraries" data-tertiary="workflow scheduling" id="id324"/><a data-type="indexterm" data-primary="community libraries" data-secondary="workflow scheduling" id="id325"/><a data-type="indexterm" data-primary="workflows, community libraries" id="id326"/>specify arbitrary graphs in Dask, and if you chose to, you could write your workflows using Dask itself. You can call system commands and parse their results, but just because you can do something doesn’t mean it will be fun or simple.</p>

<p class="pagebreak-after">The household name<sup><a data-type="noteref" id="id327-marker" href="ch01.xhtml#id327">6</a></sup> for workflow scheduling in the big data ecosystem is Apache Airflow. While Airflow has a wonderful collection of operators, making it easy to express complex task types easily, it is notoriously difficult to scale.<sup><a data-type="noteref" id="id328-marker" href="ch01.xhtml#id328">7</a></sup> Dask can be used to run <a href="https://oreil.ly/Vw54J">Airflow tasks</a>. Alternatively, it can be used as a backend for other task scheduling systems like <a href="https://oreil.ly/9Xmvo">Prefect</a>. Prefect aims to bring Airflow-like functionality to Dask with a large predefined task library. Since Prefect used Dask as an execution backend from the start, it has a tighter integration and lower overhead than Airflow on Dask.</p>
<div data-type="note" epub:type="note" class="less_space"><h6>Note</h6>
<p>Few tools cover all of the same areas, with the most similar tool being Ray.
Dask and Ray both expose Python APIs, with underlying extensions when needed. There is a <a href="https://oreil.ly/cPJpW">GitHub issue</a> where the creators of both systems compare their similarities and differences.
From a systems perspective, the biggest differences between Ray and Dask are handling state, fault tolerance, and centralized versus decentralized scheduling. Ray implements more of its logic in 
<span class="keep-together">C++</span>, which can have performance benefits but is also more difficult to read. From a user point of view, Dask has more of a data science focus, and Ray emphasizes distributed state and actor support. Dask can use Ray as a backend for scheduling.<sup><a data-type="noteref" id="id329-marker" href="ch01.xhtml#id329">8</a></sup></p>
</div>
</div></section>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="What Dask Is Not"><div class="sect1" id="id251">
<h1>What Dask Is Not</h1>

<p>While Dask is many things, it is not a magic wand you wave over your code to make it faster.
There are places where Dask has largely compatible drop-in APIs, but misusing them can result in slower execution.
Dask is not a code rewriting or just-in-time (JIT) tool; instead, Dask allows you to scale these tools to run on clusters. Dask focuses on Python and may not be the right tool for scaling languages not tightly integrated with Python (such as Go). Dask does not have built-in catalog support (e.g., Hive or Iceberg), so reading and writing data from tables stored with the catalogs can pose a challenge.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="id252">
<h1>Conclusion</h1>

<p>Dask is one of the possible options for scaling your analytical Python code. It covers various deployment options, from multiple cores on a single computer to data centers. Dask takes a modular approach compared to many other tools in similar spaces, which means that taking the time to understand the ecosystem and libraries around it is essential. The right choice to scale your software depends on your code and on the ecosystem, data consumers, and sources for your project. We hope we’ve convinced you that it’s worth the time to play with Dask a bit, which you do in the next chapter.</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="id288"><sup><a href="ch01.xhtml#id288-marker">1</a></sup> Not <em>all</em> Python code, however; for example, Dask would be a bad choice for scaling a web server (very stateful from the web socket needs).</p><p data-type="footnote" id="id304"><sup><a href="ch01.xhtml#id304-marker">2</a></sup> With the exception of non-uniform memory access (NUMA) systems.</p><p data-type="footnote" id="id310"><sup><a href="ch01.xhtml#id310-marker">3</a></sup> Of course, opinions vary. See, for example, <a href="https://oreil.ly/HBExc">“Single Node Processing — Spark, Dask, Pandas, Modin, Koalas Vol. 1”</a>, <a href="https://oreil.ly/PNZPm">“Benchmark: Koalas (PySpark) and Dask”</a>, and <a href="https://oreil.ly/eA28o">“Spark vs. Dask vs. Ray”</a>.</p><p data-type="footnote" id="id315"><sup><a href="ch01.xhtml#id315-marker">4</a></sup> Celery, often used for background job management, is an asynchronous task queue that can also split up and distribute work. But it is at a lower level than Dask and does not have the same high-level conveniences as Dask.</p><p data-type="footnote" id="id323"><sup><a href="ch01.xhtml#id323-marker">5</a></sup> BlazingSQL is no longer maintained, though its concepts are interesting and may find life in another project.</p><p data-type="footnote" id="id327"><sup><a href="ch01.xhtml#id327-marker">6</a></sup> Assuming a fairly nerdy household.</p><p data-type="footnote" id="id328"><sup><a href="ch01.xhtml#id328-marker">7</a></sup> With one thousand tasks per hour taking substantial tuning and manual consideration; see <a href="https://oreil.ly/tVbSf">“Scaling Airflow to 1000 Tasks/Hour”</a>.</p><p data-type="footnote" id="id329"><sup><a href="ch01.xhtml#id329-marker">8</a></sup> Or, flipping the perspective, Ray is capable of using Dask to provide data science functionality.</p></div></div></section></div></body></html>