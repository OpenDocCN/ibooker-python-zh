- en: Chapter 4\. What Are We Doing with All These Tests? (And, Refactoring)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章。我们对所有这些测试究竟做了什么？（以及重构）
- en: Now that we’ve seen the basics of TDD in action, it’s time to pause and talk
    about why we’re doing it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到 TDD 的基础行动了，是时候暂停一下，谈谈我们为什么要这样做了。
- en: 'I’m imagining several of you, dear readers, have been holding back some seething
    frustration—​perhaps some of you have done a bit of unit testing before, and perhaps
    some of you are just in a hurry. You’ve been biting back questions like:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我想象着你们中的一些，亲爱的读者，一直在忍受着一些愤怒和沮丧——也许你们中的一些之前进行过一些单元测试，也许你们中的一些只是匆忙之间。你们一直在忍耐着像这样的问题：
- en: Aren’t all these tests a bit excessive?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有这些测试难道不是有点过多了吗？
- en: Surely some of them are redundant? There’s duplication between the functional
    tests and the unit tests.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当然，其中一些是多余的吗？功能测试和单元测试之间存在重复。
- en: Those unit tests seemed way too trivial—​testing a one-line function that returns
    a constant! Isn’t that just a waste of time? Shouldn’t we save our tests for more
    complex things?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那些单元测试看起来太琐碎了——测试一个返回常量的单行函数！那不是在浪费时间吗？我们不应该把测试留给更复杂的事情吗？
- en: What about all those tiny changes during the unit-test/code cycle? Couldn’t
    we just skip to the end? I mean, `home_page = None`!? Really?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那么在单元测试/编码周期中的所有这些微小变化呢？我们可以直接跳到最后吗？我的意思是，`home_page = None`！？真的吗？
- en: You’re not telling me you *actually* code like this in real life?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不是真的在生活中 *真的* 像这样编码吧？
- en: Ah, young grasshopper. I too was once full of questions like these. But only
    because they’re perfectly good questions. In fact, I still ask myself questions
    like these, all the time. Does all this stuff really have value? Is this a bit
    of a cargo cult?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，年轻的蚱蜢啊。我也曾经充满了这些问题。但只因为它们确实是好问题。事实上，我一直都在问自己这样的问题，时时刻刻。这些东西真的有价值吗？这是不是某种崇拜船运的表现？
- en: Programming Is Like Pulling a Bucket of Water Up from a Well
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程就像是从井里提水一样
- en: 'Ultimately, programming is hard. Often, we are smart, so we succeed. TDD is
    there to help us out when we’re not so smart. Kent Beck (who basically invented
    TDD) uses the metaphor of lifting a bucket of water out of a well with a rope:
    when the well isn’t too deep, and the bucket isn’t very full, it’s easy. And even
    lifting a full bucket is pretty easy at first. But after a while, you’re going
    to get tired. TDD is like having a ratchet that lets you save your progress, so
    you can take a break, and make sure you never slip backwards.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，编程是困难的。通常情况下，我们很聪明，所以我们成功了。TDD 在我们不那么聪明时帮了我们很多。Kent Beck（基本上发明了 TDD）用提水井中的水桶抽水的比喻来解释：当井不太深，水桶没有装满时，这很容易。即使开始时提起一个满满的水桶也相对容易。但是过了一会儿，你会感到疲倦。TDD
    就像是一把棘轮，让你保存进度，这样你可以休息一下，并确保你永远不会倒退。
- en: That way you don’t have to be smart *all* the time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这样你就不必一直聪明到底了。
- en: '![Test ALL the things](assets/twp2_0401.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![测试所有东西](assets/twp2_0401.png)'
- en: 'Figure 4-1\. Test ALL the things (original illustration source: [Allie Brosh,
    Hyperbole and a Half](http://bit.ly/1iXxdYp))'
  id: totrans-13
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-1。测试所有东西（原始插图来源：[Allie Brosh, Hyperbole and a Half](http://bit.ly/1iXxdYp)）
- en: OK, perhaps *in general*, you’re prepared to concede that TDD is a good idea,
    but maybe you still think I’m overdoing it? Testing the tiniest thing, and taking
    ridiculously many small steps?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，也许 *总体上* 你愿意承认 TDD 是个好主意，但也许你仍然认为我做得过火了？测试最微小的东西，采取荒谬地多的小步骤？
- en: TDD is a *discipline*, and that means it’s not something that comes naturally;
    because many of the payoffs aren’t immediate but only come in the longer term,
    you have to force yourself to do it in the moment. That’s what the image of the
    Testing Goat is supposed to represent—​you need to be a bit bloody-minded about
    it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 是一种 *纪律*，这意味着它不是什么天生的技能；因为许多好处不是即刻显现的，而是长期的，你必须在当下强迫自己去做。这就是测试山羊形象想要表达的——你需要在这件事上有点固执。
- en: Now, let us return to our muttons.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到正题。
- en: Using Selenium to Test User Interactions
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Selenium 进行用户交互测试
- en: 'Where were we at the end of the last chapter? Let’s rerun the test and find
    out:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章末尾我们到了哪里？让我们重新运行测试看看：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Did you try it, and get an error saying *Problem loading page* or *Unable to
    connect*? So did I. It’s because we forgot to spin up the dev server first using
    `manage.py runserver`. Do that, and you’ll get the failure message we’re after.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有试过，出现了 *问题加载页面* 或 *无法连接* 的错误？我也试过。那是因为我们忘记先用 `manage.py runserver` 启动开发服务器。做到这一点，你会得到我们需要的失败消息。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: One of the great things about TDD is that you never have to worry about forgetting
    what to do next—​just rerun your tests and they will tell you what you need to
    work on.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的一个很棒的地方就是你永远不用担心忘记接下来要做什么—只需重新运行你的测试，它们会告诉你接下来需要做什么。
- en: '“Finish the test”, it says, so let’s do just that! Open up *functional_tests.py*
    and we’ll extend our FT:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: “完成测试”，它说，那我们就这样做吧！打开 *functional_tests.py*，我们将扩展我们的FT：
- en: functional_tests.py (ch04l001)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: functional_tests.py（ch04l001）
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_what_are_we_doing_with_all_these_tests___and__refactoring__CO1-1)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_what_are_we_doing_with_all_these_tests___and__refactoring__CO1-1)'
- en: 'We’re using the two methods that Selenium provides to examine web pages: `find_element`
    and `find_elements` (notice the extra `s`, which means it will return several
    elements rather than just one). Each one is parameterized with a `By.SOMETHING`
    which lets us search using different HTML properties and attributes.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用 Selenium 提供的两种方法来检查网页：`find_element` 和 `find_elements`（注意额外的 `s`，这意味着它将返回多个元素而不仅仅是一个）。每一个都是使用
    `By.SOMETHING` 参数化的，这让我们可以使用不同的HTML属性和属性来搜索。
- en: '[![2](assets/2.png)](#co_what_are_we_doing_with_all_these_tests___and__refactoring__CO1-3)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_what_are_we_doing_with_all_these_tests___and__refactoring__CO1-3)'
- en: We also use `send_keys`, which is Selenium’s way of typing into input elements.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用 `send_keys`，这是Selenium在输入元素上键入的方式。
- en: '[![3](assets/3.png)](#co_what_are_we_doing_with_all_these_tests___and__refactoring__CO1-4)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_what_are_we_doing_with_all_these_tests___and__refactoring__CO1-4)'
- en: The `Keys` class (don’t forget to import it) lets us send special keys like
    Enter.^([1](ch04.xhtml#id262))
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`Keys` 类（不要忘记导入它）让我们发送像 Enter 这样的特殊键。^([1](ch04.xhtml#id262))'
- en: '[![4](assets/4.png)](#co_what_are_we_doing_with_all_these_tests___and__refactoring__CO1-5)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_what_are_we_doing_with_all_these_tests___and__refactoring__CO1-5)'
- en: When we hit Enter, the page will refresh. The `time.sleep` is there to make
    sure the browser has finished loading before we make any assertions about the
    new page. This is called an “explicit wait” (a very simple one; we’ll improve
    it in [Chapter 6](ch06.xhtml#chapter_explicit_waits_1)).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们按Enter键时，页面将刷新。 `time.sleep` 的作用是确保浏览器在我们对新页面进行任何断言之前已经加载完成。这称为“显式等待”（一个非常简单的等待方式；我们将在[第6章](ch06.xhtml#chapter_explicit_waits_1)中进行改进）。
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Watch out for the difference between the Selenium `find_element()` and `find_elements()`
    functions. One returns an element and raises an exception if it can’t find it,
    whereas the other returns a list, which may be empty.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Selenium 的 `find_element()` 和 `find_elements()` 函数之间的区别。一个返回一个元素并在找不到时引发异常，而另一个返回一个可能为空的列表。
- en: Also, just look at that `any()` function. It’s a little-known Python built-in.
    I don’t even need to explain it, do I? Python is such a joy.^([2](ch04.xhtml#id263))
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 还有，看看那个 `any()` 函数。这是一个鲜为人知的Python内置函数。我甚至不需要解释它，对吧？Python 真是一种乐趣。^([2](ch04.xhtml#id263))
- en: Note
  id: totrans-37
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re one of my readers who doesn’t know Python, what’s happening *inside*
    the `any()` may need some explaining. The basic syntax is that of a *list comprehension*,
    and if you haven’t learned about them, you should do so immediately! [Trey Hunner’s
    explanation is excellent.](https://www.pythonmorsels.com/what-are-list-comprehensions/)
    In point of fact, because we’re omitting the square brackets, we’re actually using
    a *generator expression* rather than a list comprehension. It’s probably less
    important to understand the difference between those two, but if you’re curious,
    check out this [blog post by Guido himself](http://python-history.blogspot.com/2010/06/from-list-comprehensions-to-generator.xhtml)
    explaining the difference.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是我这些读者中的一个，不懂Python，`any()` 函数内部发生了什么可能需要一些解释。基本语法是*列表推导式*，如果你还没学过，现在就应该去学了！
    [Trey Hunner 的解释非常出色。](https://www.pythonmorsels.com/what-are-list-comprehensions/)
    实际上，因为我们省略了方括号，所以我们实际上使用的是*生成器表达式*而不是列表推导式。了解这两者之间的区别可能不那么重要，但如果你感兴趣，可以看看[Guido
    自己的这篇博客文章](http://python-history.blogspot.com/2010/06/from-list-comprehensions-to-generator.xhtml)来解释这两者的区别。
- en: 'Let’s see how it gets on:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它的表现：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Decoding that, the test is saying it can’t find an `<h1>` element on the page.
    Let’s see what we can do to add that to the HTML of our home page.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 解码后，测试显示无法在页面上找到 `<h1>` 元素。让我们看看如何将其添加到我们主页的HTML中。
- en: 'Big changes to a functional test are usually a good thing to commit on their
    own. I failed to do so when I was first working out the code for this chapter,
    and I regretted it later when I changed my mind and had the change mixed up with
    a bunch of others. The more atomic your commits, the better:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对功能测试进行大的更改通常是一个好主意。当我首次为本章编写代码时，我没有这样做，后来当我改变主意并且改变混合了一堆其他更改时，我后悔了。您的提交越原子化，越好：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The “Don’t Test Constants” Rule, and Templates to the Rescue
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “不要测试常量”规则，以及模板的拯救
- en: Let’s take a look at our unit tests, *lists/tests.py*. Currently we’re looking
    for specific HTML strings, but that’s not a particularly efficient way of testing
    HTML. In general, one of the rules of unit testing is *Don’t test constants*,
    and testing HTML as text is a lot like testing a constant.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的单元测试，*lists/tests.py*。目前，我们正在寻找特定的HTML字符串，但这不是测试HTML的特别有效的方法。一般来说，单元测试的一个规则是*不要测试常量*，而测试HTML作为文本很像测试一个常量。
- en: 'In other words, if you have some code that says:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果你有一些代码，如下所示：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There’s not much point in a test that says:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一个说法并没有多大意义：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Unit tests are really about testing logic, flow control, and configuration.
    Making assertions about exactly what sequence of characters we have in our HTML
    strings isn’t doing that.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试实际上是关于测试逻辑、流控制和配置的。对我们的HTML字符串中确切字符序列进行断言并不能做到这一点。
- en: It’s not *quite* that simple, since HTML is code after all, and we do want something
    to check that we’ve written code that works, but that’s our FT’s job, not the
    unit tests’.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 其实并不*完全*那么简单，因为HTML毕竟也是代码，我们确实希望有一些东西来检查我们编写的代码是否有效，但这是我们功能测试的工作，而不是单元测试的工作。
- en: In any case, mangling raw strings in Python really isn’t a great way of dealing
    with HTML. There’s a much better solution, which is to use templates. Quite apart
    from anything else, if we can keep HTML to one side in a file whose name ends
    in *.xhtml*, we’ll get better syntax highlighting! There are lots of Python templating
    frameworks out there, and Django has its own which works very well. Let’s use
    that.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，在Python中操纵原始字符串并不是处理HTML的好方法。有一个更好的解决方案，那就是使用模板。除此之外，如果我们能够将HTML保留在以*.xhtml*结尾的文件中，我们将获得更好的语法高亮！市面上有很多Python模板框架，而Django也有自己的模板框架，非常好用。让我们使用它。
- en: Refactoring to Use a Template
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构以使用模板
- en: What we want to do now is make our view function return exactly the same HTML,
    but just using a different process. That’s a refactor—​when we try to improve
    the code *without changing its functionality*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想做的是使我们的视图函数返回完全相同的HTML，但只是使用不同的过程。这就是重构——试图改进代码*而不改变其功能*。
- en: 'That last bit is really important. If you try to add new functionality at the
    same time as refactoring, you’re much more likely to run into trouble. Refactoring
    is actually a whole discipline in itself, and it even has a reference book: Martin
    Fowler’s [*Refactoring*](http://refactoring.com/).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点非常重要。如果您在重构的同时尝试添加新功能，那么遇到问题的可能性要高得多。重构实际上是一门完整的学科，甚至有一本参考书：Martin Fowler的[*Refactoring*](http://refactoring.com/)。
- en: 'The first rule is that you can’t refactor without tests. Thankfully, we’re
    doing TDD, so we’re way ahead of the game. Let’s check that our tests pass; they
    will be what makes sure that our refactoring is behaviour-preserving:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条规则是，在没有测试的情况下不能重构。幸运的是，我们正在进行TDD，所以我们已经领先了。让我们检查一下我们的测试是否通过；它们将确保我们的重构保持行为不变：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Great! We’ll start by taking our HTML string and putting it into its own file.
    Create a directory called *lists/templates* to keep templates in, and then open
    a file at *lists/templates/home.xhtml*, to which we’ll transfer our HTML:^([3](ch04.xhtml#id270))
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！我们将从将HTML字符串放入自己的文件开始。创建一个名为*lists/templates*的目录以存放模板，并打开一个文件*lists/templates/home.xhtml*，将HTML转移到其中：^([3](ch04.xhtml#id270))
- en: lists/templates/home.xhtml (ch04l002)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: lists/templates/home.xhtml（ch04l002）
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Mmmh, syntax-highlighted…​much nicer! Now to change our view function:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，语法高亮……好多了！现在来修改我们的视图函数：
- en: lists/views.py (ch04l003)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: lists/views.py（ch04l003）
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Instead of building our own `HttpResponse`, we now use the Django `render()`
    function. It takes the request as its first parameter (for reasons we’ll go into
    later) and the name of the template to render. Django will automatically search
    folders called *templates* inside any of your apps’ directories. Then it builds
    an `HttpResponse` for you, based on the content of the template.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不再构建自己的`HttpResponse`，而是使用 Django 的`render()`函数。它将请求作为其第一个参数（我们稍后会解释原因），并指定要渲染的模板的名称。Django
    会自动搜索任何应用程序目录中名为 *templates* 的文件夹。然后它根据模板的内容为您构建一个`HttpResponse`。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Templates are a very powerful feature of Django’s, and their main strength consists
    of substituting Python variables into HTML text. We’re not using this feature
    yet, but we will in future chapters. That’s why we use `render()` rather than,
    say, manually reading the file from disk with the built-in `open()`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是 Django 的一个非常强大的特性，其主要优势在于将 Python 变量替换为 HTML 文本。我们现在还没有使用这个功能，但在未来的章节中会用到。这就是为什么我们使用`render()`而不是手动使用内置的`open()`从磁盘读取文件。
- en: 'Let’s see if it works:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是否有效：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Another chance to analyse a traceback:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 又一次分析回溯的机会：
- en: '[![1](assets/1.png)](#co_what_are_we_doing_with_all_these_tests___and__refactoring__CO2-4)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_what_are_we_doing_with_all_these_tests___and__refactoring__CO2-4)'
- en: 'We start with the error: it can’t find the template.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从错误开始：它找不到模板。
- en: '[![2](assets/2.png)](#co_what_are_we_doing_with_all_these_tests___and__refactoring__CO2-1)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_what_are_we_doing_with_all_these_tests___and__refactoring__CO2-1)'
- en: 'Then we double-check what test is failing: sure enough, it’s our test of the
    view HTML.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们再次确认哪个测试失败了：果然，是我们对视图 HTML 的测试。
- en: '[![3](assets/3.png)](#co_what_are_we_doing_with_all_these_tests___and__refactoring__CO2-2)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_what_are_we_doing_with_all_these_tests___and__refactoring__CO2-2)'
- en: 'Then we find the line in our tests that caused the failure: it’s when we request
    the root URL (“/”).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们找到在测试中导致失败的行：当我们请求根 URL（“/”）时。
- en: '[![4](assets/4.png)](#co_what_are_we_doing_with_all_these_tests___and__refactoring__CO2-3)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_what_are_we_doing_with_all_these_tests___and__refactoring__CO2-3)'
- en: 'Finally, we look for the part of our own application code that caused the failure:
    it’s when we try to call `render`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们寻找导致失败的自己应用代码的部分：就是当我们尝试调用`render`时。
- en: So why can’t Django find the template? It’s right where it’s supposed to be,
    in the *lists/templates* folder.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么 Django 找不到模板呢？它就在应该在的地方，即*lists/templates*文件夹中。
- en: 'The thing is that we haven’t yet *officially* registered our lists app with
    Django. Unfortunately, just running the `startapp` command and having what is
    obviously an app in your project folder isn’t quite enough. You have to tell Django
    that you *really* mean it, and add it to *settings.py* as well. Belt and braces.
    Open it up and look for a variable called `INSTALLED_APPS`, to which we’ll add
    `lists`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于我们尚未*正式*向 Django 注册我们的 lists 应用程序。不幸的是，只运行`startapp`命令并在项目文件夹中有明显的应用程序并不够。您必须告诉
    Django 您*确实*是这样想的，并将其添加到*settings.py*中。加上腰带和裤子。打开它并查找一个名为`INSTALLED_APPS`的变量，我们将向其中添加`lists`：
- en: superlists/settings.py (ch04l004)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: superlists/settings.py（ch04l004）
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can see there’s lots of apps already in there by default. We just need to
    add ours to the bottom of the list. Don’t forget the trailing comma—​it may not
    be required, but one day you’ll be really annoyed when you forget it and Python
    concatenates two strings on different lines…​
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到默认已经有很多应用程序了。我们只需将我们的应用程序添加到列表底部即可。不要忘记最后的逗号—​它可能不是必需的，但有一天当你忘记它时，Python
    会连接两行不同行的字符串…​
- en: 'Now we can try running the tests again:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以尝试再次运行测试：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Our refactor of the code is now complete, and the tests mean we’re happy that
    behaviour is preserved. Now we can change the tests so that they’re no longer
    testing constants; instead, they should just check that we’re rendering the right
    template.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对代码的重构现在已经完成，而且测试表明我们对行为感到满意。现在我们可以修改测试，使其不再测试常量；相反，它们应该只检查我们是否渲染了正确的模板。
- en: Checking template rendering
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查模板渲染
- en: 'The Django test client has a method, `assertTemplateUsed`, which can do just
    what we want:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Django 测试客户端有一个方法，`assertTemplateUsed`，可以做我们想要的事情：
- en: lists/tests.py (ch04l005)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: lists/tests.py（ch04l005）
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_what_are_we_doing_with_all_these_tests___and__refactoring__CO3-1)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_what_are_we_doing_with_all_these_tests___and__refactoring__CO3-1)'
- en: We’ll leave the old tests there for now, just to make sure everything is working
    the way we think it is.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在先保留旧的测试，只是为了确保一切都按照我们的想法工作。
- en: '[![2](assets/2.png)](#co_what_are_we_doing_with_all_these_tests___and__refactoring__CO3-2)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_what_are_we_doing_with_all_these_tests___and__refactoring__CO3-2)'
- en: '`.assertTemplateUsed` lets us check what template was used to render a response
    (NB: it will only work for responses that were retrieved by the test client).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`.assertTemplateUsed`让我们检查用于渲染响应的模板（注：它仅适用于测试客户端检索到的响应）。'
- en: 'And that test will still pass:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 而且那个测试仍然通过：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Just because I’m always suspicious of a test I haven’t seen fail, let’s deliberately
    break it:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我总是对我没有见过失败的测试持怀疑态度，所以让我们故意破坏它一下：
- en: lists/tests.py (ch04l006)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: lists/tests.py (ch04l006)
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'That way we’ll also learn what its error messages look like:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们还会了解它的错误消息是什么样的：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That’s very helpful! Let’s change the assert back to the right thing. While
    we’re at it, we can delete our old assertions, and give the test method a more
    specific name:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有帮助！让我们把断言改回正确的内容。顺便说一下，我们可以删除旧的断言，并给测试方法一个更具体的名称：
- en: lists/tests.py (ch04l007)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: lists/tests.py (ch04l007)
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The main point, though, is that instead of testing constants we’re testing our
    implementation. Great!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但主要的观点是，我们不是测试常量，而是测试我们的实现。太好了！
- en: On Refactoring
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于重构
- en: 'That was an absolutely trivial example of refactoring. But, as Kent Beck puts
    it in *Test-Driven Development: By Example*, “Am I recommending that you actually
    work this way? No. I’m recommending that you be *able* to work this way”.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 那只是重构的一个绝对微不足道的例子。但正如肯特·贝克在《*测试驱动开发：通过示例学习*》中所说，“我推荐你真的要这样工作吗？不，我推荐你*能够*这样工作”。
- en: 'In fact, as I was writing this my first instinct was to dive in and change
    the test first—​make it use the `assertTemplateUsed` function straight away; delete
    the three superfluous assertions, leaving just a check of the contents against
    the expected render; and then go ahead and make the code change. But notice how
    that actually would have left space for me to break things: I could have defined
    the template as containing *any* arbitrary string, instead of the string with
    the right `<html>` and `<title>` tags.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当我写这篇文章时，我的第一反应是立即进行测试优先——直接使用`assertTemplateUsed`函数；删除三个多余的断言，只留下一个检查内容是否与预期渲染一致的断言；然后进行代码更改。但请注意，这实际上会给我留下破坏事物的空间：我本可以将模板定义为包含*任何*任意字符串，而不仅仅是具有正确的`<html>`和`<title>`标签的字符串。
- en: Tip
  id: totrans-108
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: When refactoring, work on either the code or the tests, but not both at once.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在重构时，要么修改代码，要么修改测试，但不能同时进行。
- en: There’s always a tendency to skip ahead a couple of steps, to make a couple
    of tweaks to the behaviour while you’re refactoring, but pretty soon you’ve got
    changes to half a dozen different files, you’ve totally lost track of where you
    are, and nothing works any more. If you don’t want to end up like [Refactoring
    Cat](http://bit.ly/1iXyRt4) ([Figure 4-2](#RefactoringCat)), stick to small steps;
    keep refactoring and functionality changes entirely separate.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有一种倾向，跳过几个步骤，一边重构一边进行一些行为调整，但很快你就会对半打不同的文件进行更改，完全失去自己的方向，并且什么都不再起作用。如果你不想像[重构猫](http://bit.ly/1iXyRt4)（[图 4-2](#RefactoringCat)）那样结束，请坚持小步骤；完全将重构和功能更改分开。
- en: '![An adventurous cat, trying to refactor its way out of a slippery bathtub](assets/twp2_0402.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![一只冒险的猫，试图通过重构摆脱滑溜的浴缸](assets/twp2_0402.png)'
- en: 'Figure 4-2\. Refactoring Cat—​be sure to look up the full animated GIF (source:
    4GIFs.com)'
  id: totrans-112
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-2\. 重构猫——确保查看完整的动画GIF（来源：4GIFs.com）
- en: Note
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We’ll come across “Refactoring Cat” again during this book, as an example of
    what happens when we get carried away and want to change too many things at once.
    Think of it as the little cartoon demon counterpart to the Testing Goat, popping
    up over your other shoulder and giving you bad advice.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的过程中，我们还会再次遇到“重构猫”，作为我们过度沉迷于想要一次性改变太多事物时的一个例子。把它想象成测试山羊的小卡通恶魔对手，突然跳到你的另一只肩膀上，给出了不良建议。
- en: 'It’s a good idea to do a commit after any refactoring:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何重构之后进行提交是个好主意：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A Little More of Our Front Page
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们前页的一点小进展
- en: In the meantime, our functional test is still failing. Let’s now make an actual
    code change to get it passing. Because our HTML is now in a template, we can feel
    free to make changes to it, without needing to write any extra unit tests.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，我们的功能测试仍然失败。现在让我们进行实际的代码更改，使其通过。因为我们的HTML现在在模板中，所以可以随意进行更改，而不需要编写额外的单元测试。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This is another distinction between FTs and unit tests; Because the FTs use
    a real web browser, we use them as the primary tool for testing our UI, and the
    HTML that implements it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是FT和单元测试之间的另一个区别；由于FT使用真实的网络浏览器，我们将它们用作测试UI及其实现的HTML的主要工具。
- en: 'So, wanted an `<h1>`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，想要一个`<h1>`：
- en: lists/templates/home.xhtml (ch04l008)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: lists/templates/home.xhtml（ch04l008）
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let’s see if our functional test likes it a little better:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们的功能测试是否稍微满意：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'OK, let’s add an input with that ID:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们添加一个带有该ID的输入：
- en: lists/templates/home.xhtml (ch04l009)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: lists/templates/home.xhtml（ch04l009）
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: And now what does the FT say?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在FT说什么？
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We add our placeholder text…​
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加我们的占位文本……
- en: lists/templates/home.xhtml (ch04l010)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: lists/templates/home.xhtml（ch04l010）
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Which gives:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'So we can go ahead and put the table onto the page. At this stage it’ll just
    be empty:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以继续将表格放在页面上。在这个阶段，它将是空的：
- en: lists/templates/home.xhtml (ch04l011)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: lists/templates/home.xhtml（ch04l011）
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: What does the FT think?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: FT怎么看？
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Slightly cryptic! We can use the line number to track it down, and it turns
    out it’s that `any()` function I was so smug about earlier—​or, more precisely,
    the `assertTrue`, which doesn’t have a very explicit failure message. We can pass
    a custom error message as an argument to most `assertX` methods in `unittest`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有点神秘！我们可以使用行号来跟踪它，原来是`any()`函数，我之前为此感到很自豪——或者更精确地说，是`assertTrue`，它没有非常明确的失败消息。在`unittest`中，我们可以将自定义错误消息作为参数传递给大多数`assertX`方法：
- en: functional_tests.py (ch04l012)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: functional_tests.py（ch04l012）
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you run the FT again, you should see our helpful message:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您再次运行FT，您应该会看到我们的帮助信息：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: But now, to get this to pass, we will need to actually process the user’s form
    submission. And that’s a topic for the next chapter.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在，为了使其通过，我们需要实际处理用户的表单提交。这是下一章的主题。
- en: 'For now let’s do a commit:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进行一次提交：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Thanks to a bit of refactoring, we’ve got our view set up to render a template,
    we’ve stopped testing constants, and we’re now well placed to start processing
    user input.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了一点重构，我们已经设置好视图以渲染模板，停止了测试常量，并且现在很好地开始处理用户输入。
- en: 'Recap: The TDD Process'
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小结：TDD过程
- en: 'We’ve now seen all the main aspects of the TDD process, in practice:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经在实践中看到了TDD过程的所有主要方面：
- en: Functional tests
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能测试
- en: Unit tests
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: The unit-test/code cycle
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试/代码循环
- en: Refactoring
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构
- en: It’s time for a little recap, and perhaps even some flowcharts (forgive me,
    my years misspent as a management consultant have ruined me. On the plus side,
    said flowcharts will feature recursion!)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候做一点小结了，也许甚至是一些流程图（原谅我，我在管理顾问的岁月里荒废了。好的一面是，这些流程图将包含递归！）
- en: What does the overall TDD process look like?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 整个TDD过程是什么样子？
- en: We write a test.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们编写一个测试。
- en: We run the test and see it fail.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们运行测试，看到它失败。
- en: We write some minimal code to get it a little further.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们编写一些最小的代码，使其进展一点。
- en: We rerun the test and repeat until it passes (the unit test / code cycle)
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们重新运行测试，并重复直到通过（单元测试/代码循环）
- en: Then, we look for opportunities to refactor our code, using our tests to make
    sure we don’t break anything.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们寻找重构我们的代码的机会，利用我们的测试来确保不会出现任何问题。
- en: And start again from the top!
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并从头再开始！
- en: See [Figure 4-3](#simple-tdd-diagram).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[图4-3](#simple-tdd-diagram)。
- en: '![A flowchart with boxes for tests, coding and refactoring, with yes/no labels
    showing when we move forwards or backwards](assets/tdd-process-unit-tests-only-excalidraw.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![一个流程图，其中包含用于测试、编码和重构的框，带有标签显示何时向前或向后移动](assets/tdd-process-unit-tests-only-excalidraw.png)'
- en: Figure 4-3\. TDD process as a flowchart, including the unit test / code cycle
  id: totrans-166
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-3。TDD过程作为流程图，包括单元测试/代码循环
- en: It’s very common to talk about this process using the three words *Red, Green,
    Refactor*. See [Figure 4-4](#red-green-refactor).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 非常普遍地使用三个词*Red, Green, Refactor*来描述这个过程。见[图4-4](#red-green-refactor)。
- en: '![Red, Green and Refactor as three nodes in a circle, with arrows flowing around.](assets/red-green-refactor-excalidraw.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![Red, Green and Refactor作为圆圈中的三个节点，箭头在其间流动。](assets/red-green-refactor-excalidraw.png)'
- en: Figure 4-4\. Red, Green, Refactor
  id: totrans-169
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-4。红色、绿色、重构
- en: We write a test, and see it fail (“Red”).
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们编写一个测试，并看到它失败（“Red”）。
- en: 'We cycle between code and tests until the test passes: “Green”.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在代码和测试之间循环，直到测试通过：“Green”。
- en: Then, we look for opportunities to refactor.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们寻找重构的机会。
- en: Repeat as required!
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据需要重复！
- en: Double-loop TDD
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双重循环TDD
- en: But how does this apply when we have functional tests *and* unit tests? Well,
    you can think of the functional test as driving a higher-level version of the
    same cycle, with an inner red/green/refactor loop being required to get an FT
    from Red to Green; see ee [Figure 4-5](#double-loop-tdd-diagram).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当我们既有功能测试 *又有* 单元测试时，这又如何应用呢？嗯，你可以将功能测试看作是驱动同一循环的更高层版本，需要一个内部的红/绿/重构循环，以将功能测试从红色变为绿色；参见
    [图 4-5](#double-loop-tdd-diagram)。
- en: '![An inner red/green/refactor loop surrounded by an outer red/green of FTs](assets/double-loop-tdd-simpler.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![一个内部红/绿/重构循环被外部功能测试的红/绿环绕](assets/double-loop-tdd-simpler.png)'
- en: 'Figure 4-5\. Double-Loop TDD: Inner and Outer Loops'
  id: totrans-177
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-5\. 双循环 TDD：内部和外部循环
- en: When a new feature or business requirement comes along, we write a new (failing)
    FT to capture a high level view of the requirement. It may not cover every last
    edge case, but it should be enough to reassure ourselves that things are working.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当出现新的特性或业务需求时，我们编写一个新的（失败的）功能测试来捕获需求的高级视图。它可能不涵盖每一个边界情况，但应足以让我们放心事情在运行。
- en: To get that functional test to green, we then enter into the lower-level unit
    tests cycle, where we put together all the moving parts required, add tests for
    all the edge cases. Any time we get to green & refactored at the unit tests level,
    we can pop back up to the FT level to guide us towards the next thing we need
    to work. Once both levels are green, we can do any extra refactoring or work on
    edge cases.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要让功能测试通过，我们接着进入更低层级的单元测试循环，组装所需的所有移动部件，为所有边界情况添加测试。每当我们在单元测试层面达到绿灯并进行重构时，我们可以回到功能测试层面，引导我们进行下一步工作。一旦两个层次都通过测试，我们可以进行额外的重构或处理边界情况。
- en: We’ll explore all of the different parts of this workflow in more detail over
    the coming chapters.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中更详细地探讨这个工作流程的各个部分。
- en: ^([1](ch04.xhtml#id262-marker)) You could also just use the string `"\n"`, but
    `Keys` also lets you send special keys like Ctrl so I thought I’d show it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch04.xhtml#id262-marker)) 你也可以只使用字符串 `"\n"`，但 `Keys` 还让你发送像 Ctrl 这样的特殊键，所以我觉得有必要展示一下它。
- en: ^([2](ch04.xhtml#id263-marker)) Python *is* most definitely a joy, but if you
    think I’m being a bit smug here, I don’t blame you! Actually I wish I’d picked
    up on this feeling of self-satisfaction and seen it as a warning sign that I was
    being a little *too* clever. In the next chapter, you’ll see I get my comeuppance.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch04.xhtml#id263-marker)) Python *确实* 非常有趣，但如果你认为我在这里有点自鸣得意，我也不怪你！事实上，我希望我能意识到这种自满感，并把它看作是我过于聪明的一个警示标志。在下一章中，你会看到我受到了惩罚。
- en: ^([3](ch04.xhtml#id270-marker)) Some people like to use another subfolder named
    after the app (i.e., *lists/templates/lists*) and then refer to the template as
    *lists/home.xhtml*. This is called “template namespacing”. I figured it was overcomplicated
    for this small project, but it may be worth it on larger projects. There’s more
    in the [Django tutorial](https://docs.djangoproject.com/en/4.2/intro/tutorial03/#write-views-that-actually-do-something).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch04.xhtml#id270-marker)) 有些人喜欢使用另一个以应用程序命名的子文件夹（即 *lists/templates/lists*），然后将模板命名为
    *lists/home.xhtml*。这被称为“模板命名空间”。我觉得对于这个小项目来说，这有点复杂了，但在大型项目上可能是值得的。在 [Django 教程](https://docs.djangoproject.com/en/4.2/intro/tutorial03/#write-views-that-actually-do-something)
    中有更多内容。
