- en: Chapter 5\. Type Annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Annotating your Python code with type information is an optional step which
    can be very helpful during development and maintenance of a large project or a
    library. Static type checkers and lint tools help identify and locate data type
    mismatches in function arguments and return values. IDEs can use these *type annotations*
    (also called *type hints*) to improve autocompletion and to provide pop-up documentation.
    Third-party packages and frameworks can use type annotations to tailor runtime
    behavior, or to autogenerate code based on type annotations for methods and variables.
  prefs: []
  type: TYPE_NORMAL
- en: Type annotations and checking in Python continue to evolve, and touch on many
    complicated issues. This chapter covers some of the most common use cases for
    type annotations; you can find more comprehensive material in the resources listed
    at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Type Annotation Support Varies by Python Version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python’s features supporting type annotations have evolved from version to version,
    with some significant additions and deletions. The rest of this chapter will describe
    the type annotation support in the most recent versions of Python (3.10 and later),
    with notes to indicate features that might be present or absent in other versions.
  prefs: []
  type: TYPE_NORMAL
- en: History
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is, fundamentally, a *dynamically typed* language. This lets you rapidly
    develop code by naming and using variables without having to declare them. Dynamic
    typing allows for flexible coding idioms, generic containers, and polymorphic
    data handling without requiring explicit definition of interface types or class
    hierarchies. The downside is that the language offers no help during development
    in flagging variables of incompatible types being passed to or returned from functions.
    In place of the development-time compile step that some languages utilize to detect
    and report data type issues, Python relies on developers to maintain comprehensive
    unit tests, especially (though far from exclusively!^([1](ch05.xhtml#ch01fn72)))
    to uncover data type errors by re-creating the runtime environment in a series
    of test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Type Annotations Are Not Enforced
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type annotations are *not* enforced at runtime. Python does not perform any
    type validation or data conversion based on them; the executable Python code is
    still responsible for using variables and function arguments properly. However,
    type annotations must be syntactically correct. A late-imported or dynamically
    imported module containing an invalid type annotation raises a SyntaxError exception
    in your running Python program, just like any invalid Python statement.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, the absence of any kind of type checking was often seen as a shortcoming
    of Python, with some programmers citing this as a reason for choosing other programming
    languages. However, the community wanted Python to maintain its runtime type freedom,
    so the logical approach was to add support for static type checks performed at
    development time by lint-like tools (described further in the following section)
    and IDEs. Some attempts were made at type checking based on parsing function signatures
    or docstrings. Guido van Rossum cited several cases on the [Python Developers
    mailing list](https://oreil.ly/GFMBC) showing that type annotations could be helpful;
    for example, when maintaining large legacy codebases. With an annotation syntax,
    development tools could perform static type checks to highlight variable and function
    usages that conflict with the intended types.
  prefs: []
  type: TYPE_NORMAL
- en: The first official version of type annotations used specially formatted comments
    to indicate variable types and return codes, as defined in [PEP 484](https://oreil.ly/61GSZ),
    a provisional PEP for Python 3.5.^([2](ch05.xhtml#ch01fn73)) Using comments allowed
    for rapid implementation of, and experimentation with, the new typing syntax,
    without having to modify the Python compiler itself.^([3](ch05.xhtml#ch01fn74))
    The third-party package [mypy](http://mypy-lang.org) gained broad acceptance performing
    static type checking using these comments. With the adoption of [PEP 526](https://oreil.ly/S8kI3)
    in Python 3.6, type annotations were fully incorporated into the Python language
    itself, with a supporting typing module added to the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Type-Checking Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As type annotations have become an established part of Python, type-checking
    utilities and IDE plug-ins have also become part of the Python ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: mypy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The standalone [mypy](https://oreil.ly/6fMPM) utility continues to be a mainstay
    for static type checking, always up-to-date (give or take a Python version!) with
    evolving Python type annotation forms. mypy is also available as a plug-in for
    editors including Vim, Emacs, and SublimeText, and for the Atom, PyCharm, and
    VS Code IDEs. (PyCharm, VS Code, and Wing IDE also incorporate their own type-checking
    features separate from mypy.) The most common command for running mypy is simply
    **mypy my_python_script.py**.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more detailed usage examples and command-line options in the [mypy
    online documentation](https://oreil.ly/rQPK0), as well as a [cheat sheet](https://oreil.ly/CT6FE)
    that serves as a handy reference. Code examples later in this section will include
    example mypy error messages to illustrate the kinds of Python errors that can
    be caught using type checking.
  prefs: []
  type: TYPE_NORMAL
- en: Other Type Checkers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Other type checkers to consider using include:'
  prefs: []
  type: TYPE_NORMAL
- en: MonkeyType
  prefs: []
  type: TYPE_NORMAL
- en: Instagram’s [MonkeyType](https://oreil.ly/RHqNo) uses the sys.setprofile hook
    to detect types dynamically at runtime; like pytype (see below), it can also generate
    a *.pyi* (stub) file instead of, or in addition to, inserting type annotations
    in the Python code file itself.
  prefs: []
  type: TYPE_NORMAL
- en: pydantic
  prefs: []
  type: TYPE_NORMAL
- en: '[pydantic](https://oreil.ly/-zNQj) also works at runtime, but it does not generate
    stubs or insert type annotations; rather, its primary goal is to parse inputs
    and ensure that Python code receives clean data. As described in the [online docs](https://oreil.ly/0Ucvm),
    it also allows you to extend its validation features for your own environment.
    See [“FastAPI”](ch20.xhtml#fastapi) for a simple example.'
  prefs: []
  type: TYPE_NORMAL
- en: Pylance
  prefs: []
  type: TYPE_NORMAL
- en: '[Pylance](https://oreil.ly/uB5XN) is a type checking module primarily meant
    to embed Pyright (see below) into VS Code.'
  prefs: []
  type: TYPE_NORMAL
- en: Pyre
  prefs: []
  type: TYPE_NORMAL
- en: Facebook’s [Pyre](https://oreil.ly/HJ-qQ) can also generate *.pyi* files. It
    currently does not run on Windows, unless you have the [Windows Subsystem for
    Linux (WSL)](https://oreil.ly/DwB82) installed.
  prefs: []
  type: TYPE_NORMAL
- en: Pyright
  prefs: []
  type: TYPE_NORMAL
- en: '[Pyright](https://oreil.ly/wwuA8) is Microsoft’s static type checking tool,
    available as a command-line utility and a VS Code extension.'
  prefs: []
  type: TYPE_NORMAL
- en: pytype
  prefs: []
  type: TYPE_NORMAL
- en: '[pytype](https://oreil.ly/QuhCB) from Google is a static type checker that
    focuses on *type inferencin*g (and offers advice even in the absence of type hints)
    in addition to type annotations. Type inferencing offers a powerful capability
    for detecting type errors even in code without annotations. pytype can also generate
    *.pyi* files and merge stub files back into *.py* sources (the most recent versions
    of mypy are following suit on this). Currently, pytype does not run on Windows
    unless you first install [WSL](https://oreil.ly/7G_j-).'
  prefs: []
  type: TYPE_NORMAL
- en: The emergence of type-checking applications from multiple major software organizations
    is a testimonial to the widespread interest in the Python developer community
    in using type annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Type Annotation Syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A *type annotation* is specified in Python using the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*type_specification* can be any Python expression, but usually involves one
    or more built-in types (for example, just mentioning a Python type is a perfectly
    valid expression) and/or attributes imported from the typing module (discussed
    in the following section). The typical form is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples of type expressions used as type annotations for a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that **lambda**s do *not* accept type annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To annotate a function with a return type, use the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'where each *argument* takes the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example of an annotated function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that when an annotated parameter has a default value, PEP 8 recommends
    using spaces around the equals sign.
  prefs: []
  type: TYPE_NORMAL
- en: Forward-Referencing Types That Are Not Yet Fully Defined
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At times, a function or variable definition needs to reference a type that
    has not yet been defined. This is quite common in class methods, or methods that
    must define arguments or return values of the type of the current class. Those
    function signatures are parsed at compile time, and at that point the type is
    not yet defined. For example, this classmethod fails to compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Since class A has not yet been defined when Python compiles factory_method,
    the code raises NameError.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem can be resolved by enclosing the return type A in quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A future version of Python may defer the evaluation of type annotations until
    runtime, making the enclosing quotes unnecessary (Python’s Steering Committee
    is evaluating various possibilities). You can preview this behavior using **from**
    __future__ **import** annotations.
  prefs: []
  type: TYPE_NORMAL
- en: The typing Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The typing module supports type hints. It contains definitions that are useful
    when creating type annotations, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes and functions for defining types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes and functions for modifying type expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract base classes (ABCs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilities and decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes for defining custom types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The initial implementations of the typing module included definitions of types
    corresponding to Python built-in containers and other types, as well as types
    from standard library modules. Many of these types have since been deprecated
    (see below), but some are still useful, since they do not correspond directly
    to any Python built-in type. [Table 5-1](#useful_definitions_in_the_typing_module)
    lists the typing types still useful in Python 3.9 and later.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-1\. Useful definitions in the typing module
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Any | Matches any type. |'
  prefs: []
  type: TYPE_TB
- en: '| AnyStr | Equivalent to str &#124; bytes. AnyStr is meant to be used to annotate
    function arguments and return types where either string type is acceptable, but
    the types should not be mixed between multiple arguments, or arguments and return
    types. |'
  prefs: []
  type: TYPE_TB
- en: '| BinaryIO | Matches streams with binary (bytes) content such as those returned
    from open with mode=''b'', or io.BytesIO. |'
  prefs: []
  type: TYPE_TB
- en: '| Callable | Callable[[*argument_type*, ...], *return_type*] Defines the type
    signature for a callable object. Takes a list of types corresponding to the arguments
    to the callable, and a type for the return value of the function. If the callable
    takes no arguments, indicate this with an empty list, []. If the callable has
    no return value, use **None** for *return_type*. |'
  prefs: []
  type: TYPE_TB
- en: '| IO | Equivalent to BinaryIO &#124; TextIO. |'
  prefs: []
  type: TYPE_TB
- en: '| Lit⁠e⁠r⁠a⁠l​[*⁠e⁠x⁠p⁠ression*,...] | 3.8+ Specifies a list of valid values
    that the variable may take. |'
  prefs: []
  type: TYPE_TB
- en: '| LiteralString | 3.11+ Specifies a str that must be implemented as a literal
    quoted value. Used to guard against leaving code open to injection attacks. |'
  prefs: []
  type: TYPE_TB
- en: '| NoReturn | Use as the return type for functions that “run forever,” such
    as those that call http.serve_forever or event_loop.run_forever without returning.
    This is *not* intended for functions that simply return with no explicit value;
    for those use -> **None**. More discussion of return types can be found in [“Adding
    Type Annotations to Existing Code (Gradual Typing)”](#adding_type_annotations_to_existing_cod).
    |'
  prefs: []
  type: TYPE_TB
- en: '| Self | 3.11+ Use as the return type for instance functions that **return**
    self (and in a few other cases, as exemplified in [PEP 673](https://oreil.ly/NMMaw)).
    |'
  prefs: []
  type: TYPE_TB
- en: '| TextIO | Matches streams with text (str) content, such as those returned
    from open with mode=''t'', or io.StringIO. |'
  prefs: []
  type: TYPE_TB
- en: '-3.9 Prior to 3.9, the definitions in the typing module were used to create
    types representing built-in types, such as List[int] for a list of ints. From
    3.9 onward, these names are deprecated, as their corresponding built-in or standard
    library types now support the [] syntax: a list of ints is now simply typed using
    list[int]. [Table 5-2](#python_built_in_types_and_their_pre_thr) lists the definitions
    from the typing module that were necessary prior to Python 3.9 for type annotations
    using built-in types.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-2\. Python built-in types and their pre-3.9 definitions in the typing
    module
  prefs: []
  type: TYPE_NORMAL
- en: '| Built-in type | Pre-3.9 typing module equivalent |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| dict | Dict |'
  prefs: []
  type: TYPE_TB
- en: '| frozenset | FrozenSet |'
  prefs: []
  type: TYPE_TB
- en: '| list | List |'
  prefs: []
  type: TYPE_TB
- en: '| set | Set |'
  prefs: []
  type: TYPE_TB
- en: '| str | Text |'
  prefs: []
  type: TYPE_TB
- en: '| tuple | Tuple |'
  prefs: []
  type: TYPE_TB
- en: '| type | Type |'
  prefs: []
  type: TYPE_TB
- en: '| collections.ChainMap | ChainMap |'
  prefs: []
  type: TYPE_TB
- en: '| collections.Counter | Counter |'
  prefs: []
  type: TYPE_TB
- en: '| collections.defaultdict | DefaultDict |'
  prefs: []
  type: TYPE_TB
- en: '| collections.deque | Deque |'
  prefs: []
  type: TYPE_TB
- en: '| collections.OrderedDict | OrderedDict |'
  prefs: []
  type: TYPE_TB
- en: '| re.Match | Match |'
  prefs: []
  type: TYPE_TB
- en: '| re.Pattern | Pattern |'
  prefs: []
  type: TYPE_TB
- en: Type Expression Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some types defined in the typing module modify other type expressions. The types
    listed in [Table 5-3](#type_expression_parameters) provide additional typing information
    or constraints for the modified types in *type_expression*.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-3\. Type expression parameters
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Usage and description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Annotated | Annotated[*type_expression, expression, ...*] 3.9+ Extends the
    *type_expression* with additional metadata. The extra metadata values for function
    *fn* can be retrieved at runtime using get_type_hints(*fn*, include_extras=**True**).
    |'
  prefs: []
  type: TYPE_TB
- en: '| ClassVar | ClassVar[*type_expression*] Indicates that the variable is a class
    variable, and should not be assigned as an instance variable. |'
  prefs: []
  type: TYPE_TB
- en: '| Final | Final[*type_expression*] 3.8+ Indicates that the variable should
    not be written to or overridden in a subclass. |'
  prefs: []
  type: TYPE_TB
- en: '| Optional | Optional[*type_expression*] Equivalent to *type_expression* &#124;
    **None**. Often used for named arguments with a default value of **None**. (Optional
    does not automatically define **None** as the default value, so you must still
    follow it with =**None** in a function signature.) 3.10+ With the availability
    of the &#124; operator for specifying alternative type attributes, there is a
    growing consensus to prefer *type_expression* &#124; **None** over using Optional[*type_expression*].
    |'
  prefs: []
  type: TYPE_TB
- en: Abstract Base Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as for built-in types, the initial implementations of the typing module
    included definitions of types corresponding to abstract base classes in the collections.abc
    module. Many of these types have since been deprecated (see below), but two definitions
    have been retained as aliases to ABCs in collections.abc (see [Table 5-4](#abstract_base_class_aliases)).
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-4\. Abstract base class aliases
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Method subclasses must implement |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Hashable | __hash__ |'
  prefs: []
  type: TYPE_TB
- en: '| Sized | __len__ |'
  prefs: []
  type: TYPE_TB
- en: '-3.9 Prior to Python 3.9, the following definitions in the typing module represented
    abstract base classes defined in the collections.abc module, such as Sequence[int]
    for a sequence of ints. From 3.9 onward, these names in the typing module are
    deprecated, as their corresponding types in collections.abc now support the []
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '| AbstractSet | Container | Mapping |'
  prefs: []
  type: TYPE_TB
- en: '| AsyncContextManager | ContextManager | MappingView |'
  prefs: []
  type: TYPE_TB
- en: '| AsyncGenerator | Coroutine | MutableMapping |'
  prefs: []
  type: TYPE_TB
- en: '| AsyncIterable | Generator | MutableSequence |'
  prefs: []
  type: TYPE_TB
- en: '| AsyncIterator | ItemsView | MutableSet |'
  prefs: []
  type: TYPE_TB
- en: '| Awaitable | Iterable | Reversible |'
  prefs: []
  type: TYPE_TB
- en: '| ByteString | Iterator | Sequence |'
  prefs: []
  type: TYPE_TB
- en: '| Collection | KeysView | ValuesView |'
  prefs: []
  type: TYPE_TB
- en: Protocols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The typing module defines several *protocols*, which are similar to what some
    other languages call “interfaces.” Protocols are abstract base classes intended
    to concisely express constraints on a type, ensuring it contains certain methods.
    Each protocol currently defined in the typing module relates to a single special
    method, and its name starts with Supports followed by the name of the method (however,
    other libraries, such as those defined in [typeshed](https://oreil.ly/adB9Z),
    need not follow the same constraints). Protocols can be used as minimal abstract
    classes to determine a class’s support for that protocol’s capabilities: all that
    a class needs to do to comply with a protocol is to implement the protocol’s special
    method(s).'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 5-5](#protocols_in_the_typing_module_and_thei) lists the protocols defined
    in the typing module.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-5\. Protocols in the typing module and their required methods
  prefs: []
  type: TYPE_NORMAL
- en: '| Protocol | Has method |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| SupportsAbs | __abs__ |'
  prefs: []
  type: TYPE_TB
- en: '| SupportsBytes | __bytes__ |'
  prefs: []
  type: TYPE_TB
- en: '| SupportsComplex | __complex__ |'
  prefs: []
  type: TYPE_TB
- en: '| SupportsFloat | __float__ |'
  prefs: []
  type: TYPE_TB
- en: '| SupportsIndex 3.8+ | __index__ |'
  prefs: []
  type: TYPE_TB
- en: '| SupportsInt | __int__ |'
  prefs: []
  type: TYPE_TB
- en: '| SupportsRound | __round__ |'
  prefs: []
  type: TYPE_TB
- en: 'A class does not have to explicitly inherit from a protocol in order to satisfy
    issubclass(*cls*, *protocol_type*), or for its instances to satisfy isinstance(*obj*,
    *protocol_type*). The class simply has to implement the method(s) defined in the
    protocol. Imagine, for example, a class implementing Roman numerals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To create an instance of this class (to, say, represent a sequel in a movie
    title) and get its value, you could use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: RomanNumeral satisfies issubclass, and isinstance checks with SupportsInt because
    it implements __int__, even though it does not inherit explicitly from the protocol
    class SupportsInt:^([4](ch05.xhtml#ch01fn75))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Utilities and Decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 5-6](#commonly_used_functions_and_decorators) lists commonly used functions
    and decorators defined in the typing module; it’s followed by a few examples.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-6\. Commonly used functions and decorators defined in the typing module
  prefs: []
  type: TYPE_NORMAL
- en: '| Function/decorator | Usage and description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| cast | cast(*type*, *var*) Signals to the static type checker that *var*
    should be considered as type *type*. Returns *var*; at runtime there is no change,
    conversion, or validation of *var*. See the example after the table. |'
  prefs: []
  type: TYPE_TB
- en: '| final | @final 3.8+ Used to decorate a method in a class definition, to warn
    if the method is overridden in a subclass. Can also be used as a class decorator,
    to warn if the class itself is being subclassed. |'
  prefs: []
  type: TYPE_TB
- en: '| get_args | get_args(*custom_type*) Returns the arguments used to construct
    a custom type. |'
  prefs: []
  type: TYPE_TB
- en: '| get_origin | get_origin(*custom_type*) 3.8+ Returns the base type used to
    construct a custom type. |'
  prefs: []
  type: TYPE_TB
- en: '| get_type_hints | get_type_hints(*obj*) Returns results as if accessing *obj*.__annotations__.
    Can be called with optional globalns and localns namespace arguments to resolve
    forward type references given as strings, and/or with optional Boolean include_extras
    argument to include any nontyping annotations added using Annotations. |'
  prefs: []
  type: TYPE_TB
- en: '| NewType | NewType(*type_name*, *type*) Defines a custom type derived from
    *type*. *type_name* is a string that should match the local variable to which
    the NewType is being assigned. Useful for distinguishing different uses for common
    types, such as a str used for an employee name versus a str used for a department
    name. See [“NewType”](#newtype) for more on this function. |'
  prefs: []
  type: TYPE_TB
- en: '| no_type_check | @no_type_check Used to indicate that annotations are not
    intended to be used as type information. Can be applied to a class or function.
    |'
  prefs: []
  type: TYPE_TB
- en: '| no_type_che⁠c⁠k⁠_​d⁠e⁠c⁠orator | @no_type_check_decorator Used to add no_type_check
    behavior to another decorator. |'
  prefs: []
  type: TYPE_TB
- en: '| overload | @overload Used to allow defining multiple methods with the same
    name but differing types in their signatures. See the example after the table.
    |'
  prefs: []
  type: TYPE_TB
- en: '| r⁠u⁠n⁠t⁠i⁠m⁠e⁠_​c⁠h⁠e⁠c⁠k⁠a⁠b⁠l⁠e | @runtime_checkable 3.8+ Used to add isinstance
    and issubclass support for custom protocol classes. See [“Using Type Annotations
    at Runtime”](#using_type_annotations_at_runtime) for more on this decorator. |'
  prefs: []
  type: TYPE_TB
- en: '| TypeAlias | *name*: TypeAlias = *type_expression* 3.10+ Used to distinguish
    the definition of a type alias from a simple assignment. Most useful in cases
    where *type_expression* is a simple class name or a string value referring to
    a class that is not yet defined, which might look like an assignment. TypeAlias
    may only be used at module scope. A common use is to make it easier to consistently
    reuse a lengthy type expression, e.g.: Number: TypeAlias = int &#124; float &#124;
    Fraction. See [“TypeAlias”](#typealias) for more on this annotation. |'
  prefs: []
  type: TYPE_TB
- en: '| type_check_only | @type_check_only Used to indicate that the class or function
    is only used at type-checking time and is not available at runtime. |'
  prefs: []
  type: TYPE_TB
- en: '| TYPE_CHECKING | A special constant that static type checkers evaluate as
    **True** but that is set to **False** at runtime. Use this to skip imports of
    large, slow-to-import modules used solely to support type checking (so that the
    import is not needed at runtime). |'
  prefs: []
  type: TYPE_TB
- en: '| TypeVar | TypeVar(*type_name*, **types*) Defines a type expression element
    for use in complex generic types using Generic. *type_name* is a string that should
    match the local variable to which the TypeVar is being assigned. If *types* are
    not given, then the associated Generic will accept any type. If *types* are given,
    then the Generic will only accept instances of any of the provided types or their
    subclasses. Also accepts the named Boolean arguments covariant and contravariant
    (both defaulting to False), and the argument bound. These are described in more
    detail in [“Generics and TypeVars”](#generics_and_typevars) and in the [typing
    module docs](https://oreil.ly/069u4). |'
  prefs: []
  type: TYPE_TB
- en: 'Use overload at type-checking time to flag named arguments that must be used
    in particular combinations. In this case, fn must be called with either a str
    key and int value pair, or with a single bool value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that the overload decorator is used purely for static type checking. To
    actually dispatch to different methods based on a parameter type at runtime, use
    functools.singledispatch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the cast function to force a type checker to treat a variable as being
    of a particular type, within the scope of the cast:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Use cast with Caution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: cast is a way of overriding any inferences or prior annotations that may be
    present at a particular place in your code. It may hide actual type errors in
    your code, rendering the type-checking pass incomplete or inaccurate. The func
    in the preceding example raises no mypy warnings itself, but fails at runtime
    if passed a list of mixed ints and strs.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Custom Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as Python’s **class** syntax permits the creation of new runtime types
    and behavior, the typing module constructs discussed in this section enable the
    creation of specialized type expressions for advanced type checking.
  prefs: []
  type: TYPE_NORMAL
- en: The typing module includes three classes from which your classes can inherit
    to get type definitions and other default features, listed in [Table 5-7](#base_classes_for_defining_custom_types).
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-7\. Base classes for defining custom types
  prefs: []
  type: TYPE_NORMAL
- en: '| Generic | Generic[*type_var*, ...] Defines a type-checking abstract base
    class for a class whose methods reference one or more TypeVar-defined types. Generics
    are described in more detail in the following subsection. |'
  prefs: []
  type: TYPE_TB
- en: '| NamedTuple | NamedTuple A typed implementation of collections.namedtuple.
    See [“NamedTuple”](#namedtuple) for further details and examples. |'
  prefs: []
  type: TYPE_TB
- en: '| TypedDict | TypedDict 3.8+ Defines a type-checking dict that has specific
    keys and value types for each key. See [“TypedDict”](#typeddict) for details.
    |'
  prefs: []
  type: TYPE_TB
- en: Generics and TypeVars
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Generics* are types that define a template for classes that can adapt the
    type annotations of their method signatures based on one or more type parameters.
    For instance, dict is a generic that takes two type parameters: the type for the
    dictionary keys and the type for the dictionary values. Here is how dict might
    be used to define a dictionary that maps color names to RGB triples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The variable color_lookup will support statements like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the following statements generate mypy errors, due to a mismatched
    key or value type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Generic typing permits the definition of behavior in a class that is independent
    of the specific types of the objects that class works with. Generics are often
    used for defining container types, such as dict, list, set, etc. By defining a
    generic type, we avoid the necessity of exhaustively defining types for DictOfStrInt,
    DictOfIntEmployee, and so on. Instead, a generic dict is defined as dict[*KT*,
    *VT*], where *KT* and *VT* are placeholders for the dict’s key type and value
    type, and the specific types for any particular dict can be defined when the dict
    is instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s define a hypothetical generic class: an accumulator that
    can be updated with values, but which also supports an undo method. Since the
    accumulator is a generic container, we declare a TypeVar to represent the type
    of the contained objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The Accumulator class is defined as a subclass of Generic, with T as a type
    parameter. Here is the class declaration and its __init__ method, which creates
    a contained list, initially empty, of objects of type T:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To add the update and undo methods, we define arguments that reference the
    contained objects as being of type T:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we add __len__ and __iter__ methods so that Accumulator instances can
    be iterated over:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now this class can be used to write code using Accumulator[int] to collect
    a number of int values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Because acc is an Accumulator containing ints, the following statements generate
    mypy error messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Restricting TypeVar to specific types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nowhere in our Accumulator class do we ever invoke methods directly on the contained
    T objects themselves. For this example, the T TypeVar is purely untyped, so type
    checkers like mypy cannot infer the presence of any attributes or methods of the
    T objects. If the generic needs to access attributes of the T objects it contains,
    then T should be defined using a modified form of TypeVar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of TypeVar definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: These forms of T allow a generic defined on T to use methods from these types
    in T’s TypeVar definition.
  prefs: []
  type: TYPE_NORMAL
- en: NamedTuple
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The collections.namedtuple function simplifies the definition of class-like
    tuple types that support named access to the tuple elements. NamedTuple provides
    a typed version of this feature, using a class with attributes-style syntax similar
    to dataclasses (covered in [“Data Classes”](ch04.xhtml#data_classes)). Here’s
    a NamedTuple with four elements, with names, types, and optional default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'NamedTuple classes generate a default constructor, accepting positional or
    named arguments for each named field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Attempting to create a tuple with too few elements raises a runtime error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: TypedDict
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '3.8+ Python dict variables are often difficult to decipher in legacy codebases,
    because dicts are used in two ways: as collections of key/value pairs (such as
    a mapping from user ID to username), and records mapping known field names to
    values. It is usually easy to see that a function argument is to be passed as
    a dict, but the actual keys and value types are dependent on the code that may
    call that function. Beyond simply defining that a dict may be a mapping of str
    values to int values, as in dict[str, int], a TypedDict defines the expected keys
    and the types of each corresponding value. The following example defines a TypedDict
    version of the previous house listing type (note that TypedDict definitions do
    not accept default value definitions):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'TypedDict classes generate a default constructor, accepting named arguments
    for each defined key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the NamedTuple example, listing2 will not raise a runtime error, simply
    creating a dict with just the given keys. However, mypy will flag listing2 as
    a type error with the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To indicate to the type checker that some keys may be omitted (but to still
    validate those that are given), add total=False to the class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '3.11+ Individual fields can also use the Required or NotRequired type annotations
    to explicitly mark them as required or optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'TypedDict can be used to define a generic type, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Do Not Use the Legacy TypedDict(name, **fields) Format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To support backporting to older versions of Python, the initial release of
    TypedDict also let you use a syntax similar to that for namedtuple, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: These forms are deprecated in Python 3.11, and are planned to be removed in
    Python 3.13.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that TypedDict does not actually define a new type. Classes created by
    inheriting from TypedDict actually serve as dict factories, such that instances
    created from them *are* dicts. Reusing the previous code snippet defining the
    Node class, we can see this using the type built-in function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: There is no special runtime conversion or initialization when using TypedDict;
    the benefits of TypedDict are those of static type checking and self documentation,
    which naturally accrue from using type annotations.
  prefs: []
  type: TYPE_NORMAL
- en: TypeAlias
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '3.10+ Defining a simple type alias can be misinterpreted as assigning a class
    to a variable. For instance, here we define a type for record identifiers in a
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To clarify that this statement is intended to define a custom type name for
    the purposes of type checking, use TypeAlias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeAlias is also useful when defining an alias for a type that is not yet
    defined, and so referenced as a string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: TypeAlias types may only be defined at module scope. Custom types defined using
    TypeAlias are interchangeable with the target type. Contrast TypeAlias (which
    does not create a new type, just gives a new name for an existing one) with NewType,
    covered in the following section, which does create a new type.
  prefs: []
  type: TYPE_NORMAL
- en: NewType
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NewType allows you to define application-specific subtypes, to avoid confusion
    that might result from using the same type for different variables. If your program
    uses str values for different types of data, for example, it is easy to accidentally
    interchange values. Suppose you have a program that models employees in departments.
    The following type declaration is not sufficiently descriptive—which is the key
    and which is the value?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Defining types for employee and department IDs makes this declaration clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'These type definitions will also allow type checkers to flag this incorrect
    usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Running mypy reports these errors for the line employee_department_map[to_dept]
    = empid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Using NewType often requires you to use typing.cast too; for example, to create
    an EmpId, you need to cast a str to the EmpId type.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use NewType to indicate the desired implementation type for an
    application-specific type. For instance, the basic US postal zip code is five
    numeric digits. It is common to see this implemented using int, which becomes
    problematic with zip codes that have a leading 0. To indicate that zip codes should
    be implemented using str, your code can define this type-checking type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Annotating variables and function arguments using ZipCode will help flag incorrect
    uses of int for zip code values.
  prefs: []
  type: TYPE_NORMAL
- en: Using Type Annotations at Runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Function and class variable annotations can be introspected by accessing the
    function or class’s __annotations__ attribute (although a [better practice](https://oreil.ly/r-YsZ)
    is to instead call inspect.get_annotations()):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This feature is used by third-party packages such as pydantic and FastAPI to
    provide extra code generation and validation capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 3.8+ To define your own custom protocol class that supports runtime checking
    with issubclass and isinstance, define that class as a subclass of typing.Protocol,
    with empty method definitions for the required protocol methods, and decorate
    the class with @runtime_checkable (covered in [Table 5-6](#commonly_used_functions_and_decorators)).
    If you *don’t* decorate it with @runtime_checkable, you’re still defining a Protocol
    that’s quite usable for static type checking, but it won’t be runtime-checkable
    with issubclass and isinstance.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could define a protocol that indicates that a class implements
    the update and undo methods as follows (the Python Ellipsis, ..., is a convenient
    syntax for indicating an empty method definition):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Without making any changes to the inheritance path of Accumulator (defined
    in [“Generics and TypeVars”](#generics_and_typevars)), it now satisfies runtime
    type checks with SupportsUpdateUndo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In addition, any other class that implements update and undo methods will now
    qualify as a SupportsUpdateUndo “subclass.”
  prefs: []
  type: TYPE_NORMAL
- en: How to Add Type Annotations to Your Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having seen some of the features and capabilities provided by using type annotations,
    you may be wondering about the best way to get started. This section describes
    a few scenarios and approaches to adding type annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Type Annotations to New Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you start writing a short Python script, adding type annotations may seem
    like an unnecessary extra burden. As a spinoff of the [Two Pizza Rule](https://oreil.ly/SWLnG),
    we suggest the Two Function Rule: as soon as your script contains two functions
    or methods, go back and add type annotations to the method signatures, and any
    shared variables or types as necessary. Use TypedDict to annotate any dict structures
    that are used in place of classes, so that dict keys get clearly defined up front
    or get documented as you go; use NamedTuples (or dataclasses: some of this book’s
    authors *strongly* prefer the latter option) to define the specific attributes
    needed for those data “bundles.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are beginning a major project with many modules and classes, then you
    should definitely use type annotations from the beginning. They can easily make
    you more productive, as they help avoid common naming and typing mistakes and
    ensure you get more fully supported autocompletion while working in your IDE.
    This is even more important on projects with multiple developers: having documented
    types helps tell everyone on the team the expectations for types and values to
    be used across the project. Capturing these types in the code itself makes them
    immediately accessible and visible during development, much more so than separate
    documentation or specifications.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are developing a library to be shared across projects, then you should
    also use type annotations from the very start, most likely paralleling the function
    signatures in your API design. Having type annotations in a library will make
    life easier for your client developers, as all modern IDEs include type annotation
    plug-ins to support static type checking and function autocompletion and documentation.
    They will also help you when writing your unit tests, since you will benefit from
    the same rich IDE support.
  prefs: []
  type: TYPE_NORMAL
- en: For any of these projects, add a type-checking utility to your pre-commit hooks,
    so that you stay ahead of any type infractions that might creep into your new
    codebase. This way you can fix them as they occur, instead of waiting until you
    do a large commit and finding that you have made some fundamental typing errors
    in multiple places.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Type Annotations to Existing Code (Gradual Typing)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several companies that have run projects to apply type annotations to large
    existing codebases recommend an incremental approach, referred to as *gradual
    typing*. With gradual typing, you can work through your codebase in a stepwise
    manner, adding and validating type annotations a few classes or modules at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Some utilities, like mypy, will let you add type annotations function by function.
    mypy, by default, skips functions without typed signatures, so you can methodically
    go through your codebase a few functions at a time. This incremental process allows
    you to focus your efforts on individual parts of the code, as opposed to adding
    type annotations everywhere and then trying to sort out an avalanche of type-checker
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some recommended approaches are:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify your most heavily used modules, and begin adding types to them, a method
    at a time. (These could be core application class modules, or widely shared utility
    modules.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotate a few methods at a time, so that type-checking issues get raised and
    resolved gradually.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use pytype or pyre inference to generate initial *.pyi* stub files (discussed
    in the following section). Then, steadily migrate types from the *.pyi* files,
    either manually or using automation such as pytype’s merge_pyi utility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Begin using type checkers in a lenient default mode, so that most code is skipped
    and you can focus attention on specific files. As work progresses, shift to a
    stricter mode so that remaining items are made more prominent, and files that
    have been annotated do not regress by taking on new nonannotated code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using .pyi Stub Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you don’t have access to Python type annotations. For example, you
    might be using a library that does not have type annotations, or using a module
    whose functions are implemented in C.
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, you can use separate *.pyi* stub files containing just the related
    type annotations. Several of the type checkers mentioned at the beginning of this
    chapter can generate these stub files. You can download stub files for popular
    Python libraries, as well as the Python standard library itself, from the [typeshed
    repository](https://oreil.ly/jKhNR). You can maintain stub files from the Python
    source, or, using merging utilities available in some of the type checkers, integrate
    them back into the original Python source.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has steadily risen to prominence as a powerful language and programming
    ecosystem, supporting important enterprise applications. What was once a utility
    language for scripting and task automation has become a platform for significant
    and complex applications affecting millions of users, used in mission-critical
    and even extraterrestrial systems.^([5](ch05.xhtml#ch01fn76)) Adding type annotations
    is a significant step in developing and maintaining these systems.
  prefs: []
  type: TYPE_NORMAL
- en: The [online documentation](https://oreil.ly/Zg_NX) for type annotations provides
    up-to-date descriptions, examples, and [best practices](https://oreil.ly/xhq5g)
    as the syntax and practices for annotating types continue to evolve. The authors
    also recommend [*Fluent Python*, 2nd edition](http://oreilly.com/library/view/fluent-python-2nd/9781492056348),
    by Luciano Ramalho (O’Reilly), especially Chapters 8 and 15, which deal specifically
    with Python type annotations.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch05.xhtml#ch01fn72-marker)) Strong, extensive unit tests will also guard
    against many business logic problems that no amount of type checking would ever
    catch for you—so, type hints are not to be used *instead of* unit tests, but *in
    addition* to them.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch05.xhtml#ch01fn73-marker)) The *syntax* for type annotation was introduced
    in Python 3.0, but only later were its *semantics* specified.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch05.xhtml#ch01fn74-marker)) This approach was also compatible with Python
    2.7 code, still in widespread use at the time.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch05.xhtml#ch01fn75-marker)) And SupportsInt uses the runtime_checkable
    decorator.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch05.xhtml#ch01fn76-marker)) NASA’s Jet Propulsion Lab used Python for
    the Persistence Mars Rover and the Ingenuity Mars Helicopter; the team responsible
    for the discovery of gravitational waves used Python both to coordinate the instrumentation
    and to analyze the resulting hoard of data.
  prefs: []
  type: TYPE_NORMAL
