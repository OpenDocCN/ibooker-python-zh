<html><head></head><body>
<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Introduction to Python Types" class="preface"><div class="preface" id="types">
<h1 class="calibre10" id="calibre_pb_0"><span class="calibre">Chapter 2. </span>Introduction to Python Types</h1>


<p class="author1">To write maintainable Python, you must be aware of the nature of types and be deliberate about using them.  I’ll start by talking about what a type actually is and why that matters. I’ll then move on to how the Python language’s decisions about its type system affects the robustness of your codebase.</p>






</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Introduction to Python Types" class="preface">
<div class="preface" id="types">
<section data-type="sect1" data-pdf-bookmark="What’s in a Type?" class="preface"><div class="preface" id="idm45644757540232">
<h1 class="calibre12" id="calibre_pb_1">What’s in a Type?</h1>

<p class="author1">I want you to pause and answer a question: without mentioning numbers, strings, text, or Booleans, how would you explain what a type is?<a data-type="indexterm" data-primary="types" data-secondary="defined" id="idm45644757538504" class="calibre5"/></p>

<p class="author1">It’s not a simple answer for everyone. It’s even harder to explain what the benefits are, especially in a language like Python where you do not have to explicitly declare types of variables.</p>

<p class="author1">I consider a type to have a very simple definition: a communication method. Types convey information. They provide a representation that users and computers can reason about. I break the representation down into two different facets:</p>
<dl class="calibre13">
<dt class="calibre14">Mechanical representation</dt>
<dd class="calibre15">
<p class="calibre16">Types communicate behaviors and constraints to the Python language itself.</p>
</dd>
<dt class="calibre14">Semantic representation</dt>
<dd class="calibre15">
<p class="calibre16">Types communicate behaviors and constraints to other developers.</p>
</dd>
</dl>

<p class="author1">Let’s go learn a little more about each representation.</p>








</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Introduction to Python Types" class="preface">
<div class="preface" id="types">
<section data-type="sect1" data-pdf-bookmark="What’s in a Type?" class="preface">
<div class="preface" id="idm45644757540232">
<section data-type="sect2" data-pdf-bookmark="Mechanical Representation" class="preface"><div class="preface" id="idm45644757532680">
<h2 class="calibre34" id="calibre_pb_2">Mechanical Representation</h2>

<p class="author1">At its core, computers are all about binary code.<a data-type="indexterm" data-primary="mechanical representation of types" id="idm45644757530984" class="calibre5"/><a data-type="indexterm" data-primary="types" data-secondary="mechanical representation" id="idm45644757530264" class="calibre5"/> Your processor doesn’t speak Python; all it sees is the presence or absence of electrical current on circuits going through it. Same goes for what’s in your computer memory.</p>

<p class="author1">Suppose your memory looked like the following:</p>

<pre data-type="programlisting" class="calibre35">0011001010001001000101001001000100100010000010101
0010101010101000000111111110010010100111110100100
0100100010010100101011101111011010101010101010101

010100000100000101010100

10100100100100010101000101001001010101001001001001
00011110101011010110100101011100000000000000000111</pre>

<p class="author1">Looks like a bunch of gibberish. Let’s zoom in on the middle part there:</p>

<pre data-type="programlisting" class="calibre35">01010000 01000001 01010100</pre>

<p class="author1">There is no way to tell exactly what this number means by itself. Depending on computer architecture it is plausible that this could represent the number 5259604 or 5521744.  It could also be the string “PAT.” Without any sort of context, you can’t know for certain. This is why Python needs types. Type information gives Python what it needs to know to make sense of all the ones and zeroes. Let’s see it in action:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">ctypes</code> <code class="k">import</code> <code class="n">string_at</code>
<code class="k">from</code> <code class="nn">sys</code> <code class="k">import</code> <code class="n">getsizeof</code>
<code class="k">from</code> <code class="nn">binascii</code> <code class="k">import</code> <code class="n">hexlify</code>

<code class="n">a</code> <code class="calibre17">=</code> <code class="calibre17">0b01010000</code><code class="n">_01000001_01010100</code>
<code class="k">print</code><code class="calibre17">(</code><code class="n">a</code><code class="calibre17">)</code>
<code class="calibre17">&gt;&gt;&gt;</code> <code class="mi">5259604</code>

<code class="c"># prints out the memory of the variable</code>
<code class="k">print</code><code class="calibre17">(</code><code class="n">hexlify</code><code class="calibre17">(</code><code class="n">string_at</code><code class="calibre17">(</code><code class="nb">id</code><code class="calibre17">(</code><code class="n">a</code><code class="calibre17">),</code> <code class="n">getsizeof</code><code class="calibre17">(</code><code class="n">a</code><code class="calibre17">))))</code>
<code class="calibre17">&gt;&gt;&gt;</code> <code class="calibre17">b</code><code class="s">'0100000000000000607c054995550000010000000000000054415000'</code>

<code class="n">text</code> <code class="calibre17">=</code> <code class="s">"PAT"</code>
<code class="k">print</code><code class="calibre17">(</code><code class="n">hexlify</code><code class="calibre17">(</code><code class="n">string_at</code><code class="calibre17">(</code><code class="nb">id</code><code class="calibre17">(</code><code class="n">text</code><code class="calibre17">),</code> <code class="n">getsizeof</code><code class="calibre17">(</code><code class="n">text</code><code class="calibre17">))))</code>
<code class="calibre17">&gt;&gt;&gt;</code><code class="calibre17">b</code><code class="s">'0100000000000000a00f0649955500000300000000000000375c9f1f02'</code>
   <code class="calibre17">b</code><code class="s">'acdbe4e5379218b77f0000000000000000000050415400'</code></pre>
<div data-type="note" epub:type="note" class="calibre21"><h6 class="calibre22">Note</h6>
<p class="author1">I am running CPython 3.9.0 on a little-endian machine, so if you see different results, don’t worry, there are subtle things that can change your answers. (This code is not guaranteed to run on other Python implementations such as Jython or PyPy.)</p>
</div>

<p class="author1">These hex strings display the contents of the memory containing a Python object.<a data-type="indexterm" data-primary="memory, Python types in" id="idm45644757414216" class="calibre5"/> You’ll find pointers to the next and previous object in a linked list (for garbage collection purposes), a reference count, a type, and the actual data itself. You can see the bytes at the end of each returned value to see the number or string (look for the bytes <code class="calibre17">0x544150</code> or <code class="calibre17">0x504154</code>). The important part of this is that there is a type encoded into that memory. When Python looks at a variable, it knows exactly what type everything is at runtime (just as when you use the <code class="calibre17">type()</code> function.)</p>

<p class="author1">It’s easy to think that this is the only reason for types—the computer needs to know how to interpret various blobs of memory. It is important to be aware of how Python uses types, as it has some implications for writing robust code, but even more important is the second representation: semantic representation.</p>
</div></section>













</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Introduction to Python Types" class="preface">
<div class="preface" id="types">
<section data-type="sect1" data-pdf-bookmark="What’s in a Type?" class="preface">
<div class="preface" id="idm45644757540232">
<section data-type="sect2" data-pdf-bookmark="Semantic Representation" class="preface"><div class="preface" id="idm45644757532056">
<h2 class="calibre34" id="calibre_pb_3">Semantic Representation</h2>

<p class="author1">While the first definition of types is great for lower-level programming, it’s the second definition that applies to every developer.<a data-type="indexterm" data-primary="types" data-secondary="semantic representation" id="idm45644757408984" class="calibre5"/> Types, in addition to having a mechanical representation, also manifest a semantic representation.<a data-type="indexterm" data-primary="semantic representation of types" id="idm45644757407768" class="calibre5"/> A semantic representation is a communication tool; the types you choose communicate information across time and space to a future developer.</p>

<p class="author1">Types tell a user what behaviors they can expect when interacting with that entity. In this context, “behaviors” are the operations that you associate with that type (plus any preconditions or postconditions). They are the boundaries, constraints, and freedoms that a user interacts with whenever they use that type. Types used correctly have low barriers to understanding; they become natural to use. Conversely, types used poorly are a hindrance.</p>

<p class="author1">Consider the lowly <code class="calibre17">int</code>. Take a minute<a data-type="indexterm" data-primary="int type" id="idm45644757405032" class="calibre5"/> to think about what behaviors an integer has in Python.  Here’s a quick (noncomprehensive) list I came up with:</p>

<ul class="printings">
<li class="calibre9">
<p class="author1">Constructible from integers, floats, or strings</p>
</li>
<li class="calibre9">
<p class="author1">Mathematical operations such as addition, subtraction, division, multiplication, exponentiation, and negation</p>
</li>
<li class="calibre9">
<p class="author1">Relational comparison such as &lt;, &gt;, ==, and !=</p>
</li>
<li class="calibre9">
<p class="author1">Bitwise operations (manipulating individual bits of a number) such as &amp;, |, ^, ~, and shifting</p>
</li>
<li class="calibre9">
<p class="author1">Convertible to a string using <code class="calibre17">str</code> or <code class="calibre17">repr</code> functions</p>
</li>
<li class="calibre9">
<p class="author1">Able to be rounded through <code class="calibre17">ceil</code>, <code class="calibre17">floor</code>, and <code class="calibre17">round</code> methods (even though they return the integer itself, these are supported methods)</p>
</li>
</ul>

<p class="author1">An <code class="calibre17">int</code> has many behaviors. You can view the full list if you if you type <code class="calibre17">help(int)</code> into your interactive Python console.</p>

<p class="author1">Now consider a <code class="calibre17">datetime</code>:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="calibre17">&gt;&gt;&gt;</code><code class="k">import</code> <code class="nn">datetime</code>
<code class="calibre17">&gt;&gt;&gt;</code><code class="n">datetime</code><code class="calibre17">.</code><code class="n">datetime</code><code class="calibre17">.</code><code class="n">now</code><code class="calibre17">()</code>
<code class="n">datetime</code><code class="calibre17">.</code><code class="n">datetime</code><code class="calibre17">(</code><code class="mi">2020</code><code class="calibre17">,</code> <code class="mi">9</code><code class="calibre17">,</code> <code class="mi">8</code><code class="calibre17">,</code> <code class="mi">22</code><code class="calibre17">,</code> <code class="mi">19</code><code class="calibre17">,</code> <code class="mi">28</code><code class="calibre17">,</code> <code class="mi">838667</code><code class="calibre17">)</code></pre>

<p class="author1">A <code class="calibre17">datetime</code> is <a data-type="indexterm" data-primary="datetime type" id="idm45644757317048" class="calibre5"/>not that different from an <code class="calibre17">int</code>. Typically, it’s represented as a number of seconds or milliseconds from some epoch of time (such as January 1, 1970). But think about the behaviors a <code class="calibre17">datetime</code> has (I’ve italicized the differences in behavior from an integer):</p>

<ul class="printings">
<li class="calibre9">
<p class="author1">Constructible from a <em class="calibre6">string, or a set of integers representing day/month/year/etc</em>.</p>
</li>
<li class="calibre9">
<p class="author1">Mathematical operations such as addition and subtraction of <em class="calibre6">time deltas</em></p>
</li>
<li class="calibre9">
<p class="author1">Relational comparison</p>
</li>
<li class="calibre9">
<p class="author1"><em class="calibre6">No bitwise operations available</em></p>
</li>
<li class="calibre9">
<p class="author1">Convertible to a string using <code class="calibre17">str</code> or <code class="calibre17">repr</code> functions</p>
</li>
<li class="calibre9">
<p class="author1"><em class="calibre6">Is not</em> able to be rounded through <code class="calibre17">ceil</code>, <code class="calibre17">floor</code>, or <code class="calibre17">round</code> methods</p>
</li>
</ul>

<p class="author1">A <code class="calibre17">datetime</code> supports addition and subtraction, but not of other datetimes. We only add time deltas (such as adding a day or subtracting a year). Multiplying and dividing really don’t make sense for a <code class="calibre17">datetime</code>. Similarly, rounding dates is not a supported operation in the standard library. However, <code class="calibre17">datetime</code>s do offer comparison and string formatting operations with similar semantics to an integer. So even though <code class="calibre17">datetime</code> is at heart an integer, it contains a constrained subset of operations.</p>
<div data-type="note" epub:type="note" class="calibre21"><h6 class="calibre22">Note</h6>
<p class="author1"><em class="calibre6">Semantics</em> refers to the meaning of an operation. While <code class="calibre17">str(int)</code> and <code class="calibre17">str(datetime.datetime.now())</code> will return differently formatted strings, the meaning is the same: I am creating a string from a value.</p>
</div>

<p class="author1">Datetimes also support their own behaviors, to further distinguish them from integers. These include:</p>

<ul class="printings">
<li class="calibre9">
<p class="author1">Changing values based on time zones</p>
</li>
<li class="calibre9">
<p class="author1">Being able to control the format of strings</p>
</li>
<li class="calibre9">
<p class="author1">Finding what weekday it is</p>
</li>
</ul>

<p class="author1">Again, if you’d like a full list of behaviors, type <code class="calibre17">import datetime; help(date⁠time.datetime)</code> into your REPL.</p>

<p class="author1">A <code class="calibre17">datetime</code> is more specific than an <code class="calibre17">int</code>. It conveys a more specific use case than just a plain old number. When you choose to use a more specific type, you are telling future contributors that there are operations that are possible and constraints to be aware of that aren’t present in the less specific type.</p>

<p class="author1">Let’s dive into how this ties into robust code. Say you inherit a codebase that handles the opening and closing of a completely automated kitchen. You need to add in functionality to be able to change closing time (say, for extending a kitchen’s hours on <span class="calibre">holidays</span>).</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">close_kitchen_if_past_cutoff_time</code><code class="calibre17">(</code><code class="n">point_in_time</code><code class="calibre17">):</code>
    <code class="k">if</code> <code class="n">point_in_time</code> <code class="calibre17">&gt;=</code> <code class="n">closing_time</code><code class="calibre17">():</code>
        <code class="n">close_kitchen</code><code class="calibre17">()</code>
        <code class="n">log_time_closed</code><code class="calibre17">(</code><code class="n">point_in_time</code><code class="calibre17">)</code></pre>

<p class="author1">You know you need to be operating on <code class="calibre17">point_in_time</code>, but how do you get started? What type are you even dealing with? Is it a <code class="calibre17">str</code>, <code class="calibre17">int</code>, <code class="calibre17">datetime</code>, or some custom class? What operations are you allowed to perform on <code class="calibre17">point_in_time</code>? You didn’t write this code, and you have no history with it. The same problems exist if you want to call the code as well. You have no idea what is legal to pass into this function.</p>

<p class="author1">If you make an incorrect assumption one way or the other, and that code makes it to production, you will have made the code less robust.<a data-type="indexterm" data-primary="robustness" data-secondary="types and" id="idm45644757276296" class="calibre5"/> Maybe that code doesn’t lie on a codepath that is executed often. Maybe some other bug is hiding this code from being run. Maybe there aren’t a whole lot of tests around this piece of code, and it becomes a runtime error later on. No matter what, there is a bug lurking in the code, and you’ve decreased maintainability.</p>

<p class="author1">Responsible developers do their best not to have bugs hit production. They will search for tests, documentation (with a grain of salt, of course—documentation can go out of date quickly), or calling code. They will look at <code class="calibre17">closing_time()</code> and <code class="calibre17">log_time_closed()</code> to see what types they expect or provide, and plan accordingly. This is a correct path in this case, but I still consider it a suboptimal path. While an error won’t reach production, they are still expending time in looking through the code, which prevents value from being delivered as quickly. With such a small example, you would be forgiven for thinking that this isn’t that big a problem if it happens once. But beware of death by a thousand cuts: any one slice isn’t too detrimental on its own, but thousands piled up and strewn across a codebase will leave you limping along, trying to deliver code.</p>

<p class="author1">The root cause is that the semantic representation was not clear for the parameter. As you write code, do what you can to express your intent through types.<a data-type="indexterm" data-primary="type annotations" id="idm45644757271992" class="calibre5"/> You can do it as a comment where needed, but I recommend using type annotations (supported in Python 3.5+) to explain parts of your code.</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">close_kitchen_if_past_cutoff_time</code><code class="calibre17">(</code><code class="n">point_in_time</code><code class="calibre17">:</code> <code class="n">datetime</code><code class="calibre17">.</code><code class="n">datetime</code><code class="calibre17">):</code>
    <code class="k">if</code> <code class="n">point_in_time</code> <code class="calibre17">&gt;=</code> <code class="n">closing_time</code><code class="calibre17">():</code>
        <code class="n">close_kitchen</code><code class="calibre17">()</code>
        <code class="n">log_time_closed</code><code class="calibre17">(</code><code class="n">point_in_time</code><code class="calibre17">)</code></pre>

<p class="author1">All I need to do is put in a <code class="calibre17">: &lt;type&gt;</code> after my parameters. Most code examples in this book will utilize type annotations to make it clear what type the code expects.</p>

<p class="author1">Now, as developers come across this code, they will know what’s expected of <code class="calibre17">point_in_time</code>. They don’t have to look through other methods, tests, or documentation to know how to manipulate the variable. They have a crystal clear clue on what to do, and they can get right to work performing the modifications they need to do. You are conveying semantic representation to future developers, without ever directly talking to them.</p>

<p class="author1">Furthermore, as developers use a type more and more, they become familiar with it. They won’t need to look up documentation or <code class="calibre17">help()</code> to use that type when they come across it. You begin to create a vocabulary of well-known types across your codebase. This lessens the burden of maintenance. When a developer is modifying existing code, they want to focus on the changes they need to make without getting bogged down.</p>

<p class="author1">Semantic representation of a type is extremely important, and the rest of <a data-type="xref" href="part0004.html#part_1" class="calibre5">Part I</a> will be dedicated to covering how you can use types to your advantage. Before I move on, though, I need to walk through some fundamental structural elements of Python as a language, and how they impact codebase robustness.</p>
</div></section>





</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Introduction to Python Types" class="preface">
<div class="preface" id="types">
<section data-type="sect1" data-pdf-bookmark="What’s in a Type?" class="preface">
<div class="preface" id="idm45644757540232">
<section data-type="sect2" data-pdf-bookmark="Semantic Representation" class="preface">
<div class="preface" id="idm45644757532056">
<div data-type="note" epub:type="note" class="calibre21"><h1 class="calibre38" id="calibre_pb_4">Discussion Topic</h1>
<p class="author1">Think about types used in your codebase. Pick a few and ask yourself what their semantic representations are. Enumerate their constraints, use cases, and behaviors. Could you be using these types in more places? Are there places where you are misusing types?</p>
</div>
</div></section>





</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Introduction to Python Types" class="preface">
<div class="preface" id="types">
<section data-type="sect1" data-pdf-bookmark="Typing Systems" class="preface"><div class="preface" id="idm45644757409976">
<h1 class="calibre12" id="calibre_pb_5">Typing Systems</h1>

<p class="author1">As discussed earlier in the chapter, a type system aims to give a user some way to model the behaviors and constraints in the language.<a data-type="indexterm" data-primary="type systems" id="ix_typsys" class="calibre5"/> Programming languages set expectations about how their specific type systems work, both during code construction and runtime.</p>








</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Introduction to Python Types" class="preface">
<div class="preface" id="types">
<section data-type="sect1" data-pdf-bookmark="Typing Systems" class="preface">
<div class="preface" id="idm45644757409976">
<section data-type="sect2" data-pdf-bookmark="Strong Versus Weak" class="preface"><div class="preface" id="idm45644757216024">
<h2 class="calibre34" id="calibre_pb_6">Strong Versus Weak</h2>

<p class="author1">Typing systems are classified on a spectrum from weak to strong. Languages toward the stronger side of the spectrum tend to restrict the use of operations to the types that support them.<a data-type="indexterm" data-primary="type systems" data-secondary="strong versus weak typing" id="idm45644757214280" class="calibre5"/><a data-type="indexterm" data-primary="strong versus weak typing" id="idm45644757213336" class="calibre5"/><a data-type="indexterm" data-primary="weak versus strong typing" id="idm45644757212696" class="calibre5"/> In other words, if you break the semantic representation of the type, you are told (sometimes quite loudly) through a compiler error or a runtime error. Languages such as Haskell, TypeScript, and Rust are all considered strongly typed. Proponents advocate strongly typed languages because errors are more apparent when building or running code.</p>

<p class="author1">In contrast, languages toward the weaker side of the spectrum will not restrict the use of operations to the types that support them. Types are often coerced into a different type to make sense of an operation. <a data-type="indexterm" data-primary="coercion of types" id="idm45644757210952" class="calibre5"/>Languages such as JavaScript, Perl, and older versions of C are weakly typed. Proponents advocate the speed with which developers can quickly iterate on code without fighting language along the way.</p>

<p class="author1">Python falls toward the stronger side of the spectrum. There are very few implicit conversions that happen between types. It is noticeable when you perform illegal operations:</p>
<pre class="calibre35">&gt;&gt;&gt;[] + {}
TypeError: can only concatenate list (not "dict") to list

&gt;&gt;&gt; {} + []
TypeError: unsupported operand type(s) for +: 'dict' and list</pre>

<p class="author1">Contrast that with a weakly typed language, such as JavaScript:</p>
<pre class="calibre35">&gt;&gt;&gt; [] + {}
"[object Object]"

&gt;&gt;&gt; {} + []
0</pre>

<p class="author1">In terms of robustness, a strongly typed language such as Python certainly helps us out.<a data-type="indexterm" data-primary="robustness" data-secondary="strong versus weak typing" id="idm45644757207400" class="calibre5"/> While errors still will show up at runtime instead of at development time, they still will show up in an obvious <code class="calibre17">TypeError</code> exception. This reduces the time taken to debug issues significantly, again allowing you to deliver incremental value more quickly.</p>
</div></section>













</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Introduction to Python Types" class="preface">
<div class="preface" id="types">
<section data-type="sect1" data-pdf-bookmark="Typing Systems" class="preface">
<div class="preface" id="idm45644757409976">
<section data-type="sect2" data-pdf-bookmark="Strong Versus Weak" class="preface">
<div class="preface" id="idm45644757216024">
<div data-type="note" epub:type="note" class="calibre21"><h1 class="calibre38" id="calibre_pb_7">Are Weakly Typed Languages Inherently Not Robust?</h1>
<p class="author1">Codebases in weakly typed languages can absolutely be robust; by no means am I dumping on those languages. Consider the sheer amount of production-grade JavaScript that the world runs on. However, a weakly typed language requires extra care to be robust. It’s easy to mistake the type of a variable and make incorrect assumptions. Developers come to rely very heavily on linters, tests, and other tools to improve maintainability.</p>
</div>
</div></section>













</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Introduction to Python Types" class="preface">
<div class="preface" id="types">
<section data-type="sect1" data-pdf-bookmark="Typing Systems" class="preface">
<div class="preface" id="idm45644757409976">
<section data-type="sect2" data-pdf-bookmark="Dynamic Versus Static" class="preface"><div class="preface" id="idm45644757203656">
<h2 class="calibre34" id="calibre_pb_8">Dynamic Versus Static</h2>

<p class="author1">There is another typing spectrum I need to discuss: static versus dynamic typing. This is fundamentally a difference in handling mechanical representation of types.<a data-type="indexterm" data-primary="dynamic typing" data-secondary="versus static typing" data-secondary-sortas="static" id="idm45644757201880" class="calibre5"/><a data-type="indexterm" data-primary="static versus dynamic typing" id="idm45644757200632" class="calibre5"/><a data-type="indexterm" data-primary="type systems" data-secondary="static versus dynamic typing" id="idm45644757199992" class="calibre5"/></p>

<p class="author1">Languages that offer static typing embed their typing information in variables during build time. Developers may explicitly add type information to variables, or some tool such as a compiler infers types for the developer.  Variables do not change their type at runtime (hence, “static”). Proponents of static typing tout the ability to write safe code out of the gate and to benefit from a strong safety net.</p>

<p class="author1">Dynamic typing, on the other hand, embeds type information with the value or variable itself. Variables can change types at runtime quite easily, because there is no type information tied to that variable. Proponents of dynamic typing advocate the flexibility and speed that it takes to develop; there’s nowhere near as much fighting with compilers.</p>

<p class="author1">Python is a dynamically typed language. As you saw during the discussion about mechanical representation, there was type information embedded inside the values of a variable. Python has no qualms about changing the type of a variable at runtime:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="calibre17">&gt;&gt;&gt;</code> <code class="n">a</code> <code class="calibre17">=</code> <code class="mi">5</code>
<code class="calibre17">&gt;&gt;&gt;</code> <code class="n">a</code> <code class="calibre17">=</code> <code class="s">"string"</code>
<code class="calibre17">&gt;&gt;&gt;</code> <code class="n">a</code>
<code class="s">"string"</code>

<code class="calibre17">&gt;&gt;&gt;</code> <code class="n">a</code> <code class="calibre17">=</code> <code class="nb">tuple</code><code class="calibre17">()</code>
<code class="calibre17">&gt;&gt;&gt;</code> <code class="n">a</code>
<code class="calibre17">()</code></pre>

<p class="author1">Unfortunately, the ability to change types at runtime is a hindrance to robust code in many cases.<a data-type="indexterm" data-primary="robustness" data-secondary="static versus dynamic typing" id="idm45644757151912" class="calibre5"/> You cannot make strong assumptions about a variable throughout its lifetime. As assumptions are broken, it’s easy to write unstable assumptions on top of them, leading to a ticking logic bomb in your code.</p>
</div></section>













</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Introduction to Python Types" class="preface">
<div class="preface" id="types">
<section data-type="sect1" data-pdf-bookmark="Typing Systems" class="preface">
<div class="preface" id="idm45644757409976">
<section data-type="sect2" data-pdf-bookmark="Dynamic Versus Static" class="preface">
<div class="preface" id="idm45644757203656">
<div data-type="note" epub:type="note" class="calibre21"><h1 class="calibre38" id="calibre_pb_9">Are Dynamically Typed Languages Inherently Not Robust?</h1>
<p class="author1">Just like weakly typed languages, it is still absolutely possible to write robust code in a dynamically typed language. You just have to work a little harder for it. You will have to make more deliberate decisions to make your codebase more maintainable. On the flip side, being statically typed doesn’t guarantee robustness either; one can do the bare minimum with types and see little benefit.</p>
</div>

<p class="author1">To make things worse, the type annotations I showed earlier have no effect on this behavior at runtime:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="calibre17">&gt;&gt;&gt;</code> <code class="n">a</code><code class="calibre17">:</code> <code class="nb">int</code> <code class="calibre17">=</code> <code class="mi">5</code>
<code class="calibre17">&gt;&gt;&gt;</code> <code class="n">a</code> <code class="calibre17">=</code> <code class="s">"string"</code>
<code class="calibre17">&gt;&gt;&gt;</code> <code class="n">a</code>
<code class="s">"string"</code></pre>

<p class="author1">No errors, no warnings, no anything. But hope is not lost, and you have plenty of strategies to make code more robust (otherwise, this would be quite the short book). We will discuss one last thing as a contributor to robust code, and then start diving into the meat of improving our codebase.</p>
</div></section>













</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Introduction to Python Types" class="preface">
<div class="preface" id="types">
<section data-type="sect1" data-pdf-bookmark="Typing Systems" class="preface">
<div class="preface" id="idm45644757409976">
<section data-type="sect2" data-pdf-bookmark="Duck Typing" class="preface"><div class="preface" id="idm45644757203032">
<h2 class="calibre34" id="calibre_pb_10">Duck Typing</h2>

<p class="author1">It is perhaps an unwritten law that whenever someone mentions duck typing, someone <a data-type="indexterm" data-primary="duck typing" id="ix_dcktyp" class="calibre5"/><a data-type="indexterm" data-primary="type systems" data-secondary="duck typing" id="ix_typsysdck" class="calibre5"/>must reply with:</p>
<blockquote class="pcalibre2 calibre28 pcalibre1">
<p class="calibre29">If it walks like a duck and it quacks like a duck, then it must be a duck.</p></blockquote>

<p class="author1">My problem with this saying is that I find it completely unhelpful for explaining what duck typing actually is. It’s catchy, concise, and, crucially, only comprehensible to those who already understand duck typing. When I was younger, I just nodded politely, afraid that I was missing something profound in this simple phrase. It wasn’t until later on that I truly understood the power of duck typing.</p>

<p class="author1"><em class="calibre6">Duck typing</em> is the ability to use objects and entities in a programming language as long as they adhere to some interface. It is a wonderful thing in Python, and most people use it without even knowing it. Let’s look at a simple example to illustrate what I’m talking about:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">typing</code> <code class="k">import</code> <code class="n">Iterable</code>
<code class="k">def</code> <code class="nf">print_items</code><code class="calibre17">(</code><code class="n">items</code><code class="calibre17">:</code> <code class="n">Iterable</code><code class="calibre17">):</code>
    <code class="k">for</code> <code class="n">item</code> <code class="calibre19">in</code> <code class="n">items</code><code class="calibre17">:</code>
        <code class="k">print</code><code class="calibre17">(</code><code class="n">item</code><code class="calibre17">)</code>

<code class="n">print_items</code><code class="calibre17">([</code><code class="mi">1</code><code class="calibre17">,</code><code class="mi">2</code><code class="calibre17">,</code><code class="mi">3</code><code class="calibre17">])</code>
<code class="n">print_items</code><code class="calibre17">({</code><code class="mi">4</code><code class="calibre17">,</code> <code class="mi">5</code><code class="calibre17">,</code> <code class="mi">6</code><code class="calibre17">})</code>
<code class="n">print_items</code><code class="calibre17">({</code><code class="s">"A"</code><code class="calibre17">:</code> <code class="mi">1</code><code class="calibre17">,</code> <code class="s">"B"</code><code class="calibre17">:</code> <code class="mi">2</code><code class="calibre17">,</code> <code class="s">"C"</code><code class="calibre17">:</code> <code class="mi">3</code><code class="calibre17">})</code></pre>

<p class="author1">In all three invocations of <code class="calibre17">print_items</code>, we loop through the collection and print each item. Think about how this works. <code class="calibre17">print_items</code> has absolutely no knowledge of what type it will receive. It just receives a type at runtime and operates upon it. It’s not introspecting each argument and deciding to do different things based on the type. The truth is much simpler. Instead, all <code class="calibre17">print_items</code> is doing is checking that whatever is passed in can be iterated upon (by calling an <code class="calibre17">__iter__</code> method). If the attribute <code class="calibre17">__iter__</code> exists, it’s called and the returned iterator is looped over.</p>

<p class="author1">We can verify this with a simple code example:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="calibre17">&gt;&gt;&gt;</code> <code class="n">print_items</code><code class="calibre17">(</code><code class="mi">5</code><code class="calibre17">)</code>

<code class="n">Traceback</code> <code class="calibre17">(</code><code class="n">most</code> <code class="n">recent</code> <code class="n">call</code> <code class="n">last</code><code class="calibre17">):</code>
  <code class="n">File</code> <code class="s">"&lt;stdin&gt;"</code><code class="calibre17">,</code> <code class="n">line</code> <code class="mi">1</code><code class="calibre17">,</code> <code class="calibre19">in</code> <code class="calibre17">&lt;</code><code class="n">module</code><code class="calibre17">&gt;</code>
  <code class="n">File</code> <code class="s">"&lt;stdin&gt;"</code><code class="calibre17">,</code> <code class="n">line</code> <code class="mi">2</code><code class="calibre17">,</code> <code class="calibre19">in</code> <code class="n">print_items</code>
<code class="ne">TypeError</code><code class="calibre17">:</code> <code class="s">'int'</code> <code class="nb">object</code> <code class="calibre19">is</code> <code class="calibre19">not</code> <code class="n">iterable</code>

<code class="calibre17">&gt;&gt;&gt;</code> <code class="s">'__iter__'</code> <code class="calibre19">in</code> <code class="nb">dir</code><code class="calibre17">(</code><code class="nb">int</code><code class="calibre17">)</code>
<code class="nb">False</code>
<code class="calibre17">&gt;&gt;&gt;</code> <code class="s">'__iter__'</code> <code class="calibre19">in</code> <code class="nb">dir</code><code class="calibre17">(</code><code class="nb">list</code><code class="calibre17">)</code>
<code class="nb">True</code></pre>

<p class="author1">Duck typing is what makes this possible. As long as a type supports the variables and methods used by a function, you can use that type in that function freely.</p>

<p class="author1">Here’s another example:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="calibre17">&gt;&gt;&gt;</code><code class="k">def</code> <code class="nf">double_value</code><code class="calibre17">(</code><code class="n">value</code><code class="calibre17">):</code>
<code class="calibre17">&gt;&gt;&gt;</code>    <code class="k">return</code> <code class="n">value</code> <code class="calibre17">+</code> <code class="n">value</code>

<code class="calibre17">&gt;&gt;&gt;</code><code class="n">double_value</code><code class="calibre17">(</code><code class="mi">5</code><code class="calibre17">)</code>
<code class="mi">10</code>

<code class="calibre17">&gt;&gt;&gt;</code><code class="n">double_value</code><code class="calibre17">(</code><code class="s">"abc"</code><code class="calibre17">)</code>
<code class="s">"abcabc"</code></pre>

<p class="author1">It doesn’t matter that we’re passing an integer in one place or a string in another; both support the + operator, so either will work just fine. Any object that supports the + operator can be passed in. We can even do it with a list:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="calibre17">&gt;&gt;&gt;</code><code class="n">double_value</code><code class="calibre17">([</code><code class="mi">1</code><code class="calibre17">,</code> <code class="mi">2</code><code class="calibre17">,</code> <code class="mi">3</code><code class="calibre17">])</code>
<code class="calibre17">[</code><code class="mi">1</code><code class="calibre17">,</code> <code class="mi">2</code><code class="calibre17">,</code> <code class="mi">3</code><code class="calibre17">,</code> <code class="mi">1</code><code class="calibre17">,</code> <code class="mi">2</code><code class="calibre17">,</code> <code class="mi">3</code><code class="calibre17">]</code></pre>

<p class="author1">So how does this play into robustness? It turns out that duck typing is a double-edged sword.<a data-type="indexterm" data-primary="robustness" data-secondary="duck typing and" id="idm45644756912488" class="calibre5"/> It can increase robustness because it increases composability (we’ll learn more about composability in <a data-type="xref" href="part0022_split_000.html#composability" class="calibre5">Chapter 17</a>). Building up a library of solid abstractions able to handle a multitude of types lessens the need for complex special cases. However, if duck typing is overused, you start to break down assumptions that a developer can rely upon. When updating code, it’s not simple enough to just make the changes; you must look at all calling code and make sure that the types passed into your function satisfy your new changes as well.</p>

<p class="author1">With all this in mind, it might be best to reword the idiom earlier in this section as such:</p>
<blockquote class="pcalibre2 calibre28 pcalibre1">
<p class="calibre29">If it walks like a duck and quacks like a duck, and you are looking for things that walk and quack like ducks, then you can treat it as if it were a duck.</p></blockquote>

<p class="author1">Doesn’t roll off the tongue as well, does it?</p>
</div></section>





</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Introduction to Python Types" class="preface">
<div class="preface" id="types">
<section data-type="sect1" data-pdf-bookmark="Typing Systems" class="preface">
<div class="preface" id="idm45644757409976">
<section data-type="sect2" data-pdf-bookmark="Duck Typing" class="preface">
<div class="preface" id="idm45644757203032">
<div data-type="note" epub:type="note" class="calibre21"><h1 class="calibre38" id="calibre_pb_11">Discussion Topic</h1>
<p class="author1">Do you use duck typing in your codebase? Are there places where you can pass in types that don’t match what the code is looking for, but things still work? Do you think these increase or decrease robustness for your use cases?</p>
</div>
</div></section>





</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Introduction to Python Types" class="preface">
<div class="preface" id="types">
<section data-type="sect1" data-pdf-bookmark="Closing Thoughts" class="preface"><div class="preface" id="idm45644757135800">
<h1 class="calibre12" id="calibre_pb_12">Closing Thoughts</h1>

<p class="author1">Types are a pillar of clean, maintainable code and serve as a communication tool to other developers.<a data-type="indexterm" data-primary="type systems" data-secondary="duck typing" data-startref="ix_typsysdck" id="idm45644756816888" class="calibre5"/><a data-type="indexterm" data-primary="duck typing" data-startref="ix_dcktyp" id="idm45644756815640" class="calibre5"/><a data-type="indexterm" data-primary="type systems" data-startref="ix_typsys" id="idm45644756814696" class="calibre5"/> If you take care with types, you communicate a great deal, creating less burden for future maintainers. The rest of <a data-type="xref" href="part0004.html#part_1" class="calibre5">Part I</a> will show you how to use types to enhance a codebase’s robustness.</p>

<p class="author1">Remember, Python is dynamically and strongly typed.<a data-type="indexterm" data-primary="Python" data-secondary="dynamic and strong typing" id="idm45644756812312" class="calibre5"/> The strongly typed nature will be a boon for us; Python will notify us about errors when we use incompatible types. But its dynamically typed nature is something we will have to overcome in order to write better code. These language choices shape how Python code is written and you should keep them in mind as you write your code.</p>

<p class="author1">In the next chapter, we’re going to talk about type annotations, which is how we can be explicit about the type we use. Type annotations serve a crucial role: our primary communication method of behaviors to future developers. They help overcome the limitations of a dynamically typed language and allow you to enforce intentions throughout a codebase.</p>
</div></section>







</div></section></body></html>