- en: 7 Problem decomposition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Understanding problem decomposition and why we need to do it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using top-down design to carry out problem decomposition and write programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a spelling suggestions program using top-down design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In chapter 3, we talked about why we shouldn’t ask Copilot to solve big problems.
    Imagine what could happen if we asked Copilot to “Design a two-player strategy
    game.”
  prefs: []
  type: TYPE_NORMAL
- en: In the worst case, Copilot wouldn’t do anything useful. We observe this sometimes
    when Copilot gives us comments again and again but never provides us with real
    code.
  prefs: []
  type: TYPE_NORMAL
- en: In the best case, we’d get a canned program with all the decisions made for
    us. That program may not match what we wanted. Part of the power of being a programmer
    is customizing what we’re creating. Even if we didn’t want to customize anything,
    what would we do if the program from Copilot had flaws? It would be difficult
    for us to fix a large program that we don’t understand.
  prefs: []
  type: TYPE_NORMAL
- en: For us to get a program that does what we want, we need to feed small subproblems
    to Copilot and assemble those solutions into our own program. The focus of this
    chapter is learning how to break large problems into smaller subproblems, which
    is essential to being able to solve the large problems we want to solve.
  prefs: []
  type: TYPE_NORMAL
- en: 7.1 Problem decomposition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Problem decomposition involves starting with a large problem that may not be
    fully specified and breaking it down into subproblems, each of which is well-defined
    and useful for solving our overall problem. Our goal is then to write a function
    to solve each of those subproblems. We may be able to do this for some subproblems
    with a reasonable amount of code, but other subproblems may still be too big for
    us to capture in a function of reasonable size. (In chapter 3, we mentioned that
    we want to keep functions short—something like 12–20 lines—to give us the best
    chance of getting good code from Copilot, testing that code, and fixing bugs in
    that code if necessary.) If a subproblem is still too large to be implemented
    in a single function, then we further divide that subproblem into sub-subproblems
    of their own. Hopefully, each of those sub-subproblems will be small enough now,
    but if not, we’ll continue dividing those too! The key reason we do this is to
    manage complexity. Each function should be simple enough so that we can understand
    its purpose and so that Copilot can solve it well. If something does go wrong,
    we won’t have too much code to trawl through to find the problem. When we write
    code that is extremely complex, we’re likely to make mistakes. The same goes for
    Copilot! And, when we have mistakes in long, complex code, they aren’t easy to
    find and fix. It’s hard to overstate the importance of problem decomposition for
    quality code.
  prefs: []
  type: TYPE_NORMAL
- en: The process of starting with a large problem and breaking it down is called
    *problem decomposition*. The way we’re doing this here is synonymous with the
    software engineering technique known as *top-down design*. It’s called top-down
    design because we’re starting with the large task we want to complete and breaking
    it down into smaller tasks. Once we’ve completed the top-down design, we can implement
    the resulting functions in code. We’ll have one function for our overall problem,
    which will call the functions for each of our subproblems. Each of those subproblem
    functions will further call their own functions, as needed, to solve any of their
    sub-subproblems, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in chapter 3, we’re looking to end up with functions that each
    have a small role to play in our overall program and whose behavior is clearly
    defined. We need those functions so that we can call them to reduce the complexity
    of functions that would otherwise be too complex. To improve clarity and ease
    of understanding, we seek to design functions that have a small number of parameters
    and return a small amount of highly useful information.
  prefs: []
  type: TYPE_NORMAL
- en: 7.2 Small examples of top-down design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll soon jump into a more authentic example of how top-down design works,
    but we’d first like to set the stage using a couple of our earlier examples. Let’s
    think about the design of a function we previously wrote in chapter 3: `get_strong_password`.
    It repeatedly prompts the user for a password until they enter a strong password.
    Don’t go back and look at that code—we want to start fresh here.'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that we want to use a top-down design to solve this task. If it were
    one small, well-defined task, we could implement it directly as a single function.
    However, for this task, we do see a subtask; namely, what’s a strong password?
    What are the rules around that? To us, this sounds like a subtask that we can
    try to carve out of this function to make it simpler. Indeed, in chapter 3, when
    we wrote this function, we did call our earlier `is_strong_password` function,
    which makes the True/False decision about what it means for a password to be strong.
  prefs: []
  type: TYPE_NORMAL
- en: We can depict this top-down design as shown in figure 7.1\. For ease of displaying
    what will ultimately be large figures later in the chapter, we’re going to consistently
    show the design from left to right rather than top to bottom, but the same fundamental
    principles still apply.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/7-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 Functions diagram for the `get_strong_password` function. `get_strong_password`
    calls `is_strong_password`.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This figure indicates that it’s our goal to have `get_strong_password` call
    `is_strong_ password` to do some of its work.
  prefs: []
  type: TYPE_NORMAL
- en: Now, for our second example, recall from chapter 3 that we also wrote a `best_word`
    function that takes a list of words as its parameter and returns the one worth
    the most points. Again, don’t go back and look at that code—we want to figure
    it out again here. Let’s think about what the code for this task might look like.
    It will probably use a loop to consider each word, and in that loop, it will need
    to keep track of the best word we’ve seen so far. For each word, we need to figure
    out how many points it’s worth by adding up the number of points for each of its
    letters. Remember that *a* is worth 1 point, *b* is worth 3 points, *c* is worth
    3 points, *d* is worth 2 points, *e* is worth 1 point, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whoa there! We’re really going in-depth on this “How many points each letter
    is worth” thing. This sounds like a subtask to us. If we had a function that we
    could call to tell us the number of points each word is worth, we wouldn’t need
    to worry about this points business in our `best_word` function. In chapter 3,
    we wrote a function called `num_points` that carries out exactly this subtask:
    take a word as a parameter and return its total point value. We can call `num_points`
    from `best_word`, as depicted in figure 7.2\. Again, this makes the task of `best_word`
    easier for us.'
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/7-2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 Functions diagram for `best_word`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In chapter 3, we happened to write these functions from subtask to task, from
    the leaf function to the parent function. We’ll continue to do that in this chapter,
    but we’ll do the top-down design first to figure out which functions we’ll need.
  prefs: []
  type: TYPE_NORMAL
- en: These two examples from chapter 3 we just talked about are small, and you may
    indeed be able to get their code written by powering ahead with a single function.
    But with large examples, problem decomposition is the only way to keep the complexity
    under control.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll next dive into a larger example of top-down design. The key skill that
    we want you to take from this chapter is how to break a large problem down into
    smaller subproblems. We encourage you to read through the upcoming example multiple
    times. On your first read, aim for a high-level view of how the pieces fit together
    to solve the overall problem. On your second read, feel free to dive deeper into
    how each function works on its own.
  prefs: []
  type: TYPE_NORMAL
- en: 7.3 Spelling suggestions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the rest of the chapter, we’re going to solve a problem from beginning to
    end using top-down design. We want you to be sucessful when you use this approach
    on your own to solve your own problems, so you’ll see top-down design reappear
    throughout the remainder of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Oops—did we have a typo there? *Sucessful*? That was supposed to be *successful*.
    English words can be tricky to spell sometimes! You’ve probably run into many
    such words. Is it thorough or thourough? Acceptable or acceptible? Receive or
    recieve? We’re going to write a program that takes a word that’s potentially misspelled
    and offers possible corrections to that misspelling. It’s a basic spell-checker
    for individual words!
  prefs: []
  type: TYPE_NORMAL
- en: How are we supposed to come up with these possible corrections? Well, let’s
    look at the pairs of words we just provided and discuss the types of mistakes
    they exemplify.
  prefs: []
  type: TYPE_NORMAL
- en: The mistake we made with the word *sucessful* is that we left out one letter—we
    need to add a *c* in there to get the correct word *successful*. So, in general,
    it seems like a good idea to consider adding a letter to a misspelled word because
    that might be exactly what’s needed to fix it. We’re going to consider adding
    any possible letter in any possible position, not just adding a copy of a letter
    that’s already there. This will help us fix misspelled words such as *acknowlege*
    (which is missing a *d*).
  prefs: []
  type: TYPE_NORMAL
- en: There are other types of mistakes we’ll want to consider too. For example, the
    mistake in *thourough* isn’t that we’re missing a letter, but that we have an
    extra letter—we need to delete the first *u* to get *thorough*. We’re therefore
    going to consider removing any single letter from a misspelled word to see if
    that fixes it.
  prefs: []
  type: TYPE_NORMAL
- en: 'What other mistakes can we fix? Well, there’s that misspelled word *acceptible*.
    That’s a new type of mistake: there’s no missing or extra letter, but there is
    a letter that should be changed to another letter. That is, if we change the *i*
    to an *a*, we arrive at the correctly spelled word *acceptable*. To that end,
    we can try changing each letter to each other letter in the alphabet to see if
    that fixes the misspelling.'
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to fix misspelled words beyond the three that we just gave.
    But we’ll stop here because we think that fixing three types of mistakes is sufficient
    for our purposes of demonstrating top-down design. This means that our program
    will fail to correct the misspelled word *recieve* to *receive*, because we won’t
    be fixing the mistake of having two letters in the wrong order. We’ll also fail
    to correct the misspelled word *camoflague* to camouflage, because we’ll be fixing
    only one mistake in a misspelled word (*camoflague* has two different errors,
    one missing *u* and one added *u*). Once you finish the chapter, we encourage
    you to continue to improve your program and learn more about correcting misspelled
    words if you’d like to go further.
  prefs: []
  type: TYPE_NORMAL
- en: 7.4 Spelling suggestions using top-down design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our task is to “write a program that takes a word that’s potentially misspelled
    and offers possible corrections to that misspelling.” That’s a big task that we
    definitely don’t want to try to jam into a single function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many programs—whether they analyze data, provide spelling suggestions, or guess
    the author of an unknown text—have three distinct tasks to perform. First, there’s
    the input task: we need to acquire the data on which our program will run. Second,
    there’s the process task, where the program does whatever it’s supposed to do
    with that data. Now, processing the data is all well and good, but it’s useless
    if our users don’t know what our programs discovered through that processing.
    That’s where the third step, the output step, comes in, and it’s where we communicate
    something to the user. Table 7.1 summarizes this process.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 7.1 A summary of the input, process data, and output tasks
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Phase | Role | Spelling Suggestions Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Input  | Take, as input, the information needed for the function.  | Provide
    the misspelled word *sucessful* and a collection of real words (properly spelled
    words).  |'
  prefs: []
  type: TYPE_TB
- en: '| Process data  | Perform the operation specified by the function on that data.  |
    Consider changes to that word that might result in a correctly spelled word, for
    example, adding a letter *c* either before or after the *c* in *sucessful* would
    produce the real word *successful*. Many other incorrect words (i.e., *scucessful*
    obtained by adding the letter *c* before the *u*) may also be attempted, but only
    real words should be in the result.  |'
  prefs: []
  type: TYPE_TB
- en: '| Output  | Return the result of that data processing.  | Return the suggestion
    “successful”.  |'
  prefs: []
  type: TYPE_TB
- en: You can see this input-process-output model at work back in our data processing
    example from chapter 2\. We needed to read the data from the CSV file (that’s
    the input step), determine the number of passing yards for each quarterback (that’s
    the process step), and then output the quarterbacks and their passing yards (that’s
    the output step).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can think about our Spelling Suggestions problem in a similar way. What’s
    amazing here is that the input-process-output model gives us exactly the three
    subproblems that we’ll want to solve in our top-down design. Here’s what we mean
    (also see the example in table 7.1):'
  prefs: []
  type: TYPE_NORMAL
- en: For the input step, we need to ask the user for the word for which they want
    to obtain spelling suggestions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the process step, we need to figure out all the possible suggestions for
    the user’s word.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the output step, we need to tell the user about all the spelling suggestions
    that we found during the process step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that we started with one large problem to solve (the overall Spelling
    Suggestions problem), and now we have three smaller problems to solve. Our main
    or top-level function will end up calling any functions that result from this
    problem decomposition. We’ll name this main function `spell_check`.
  prefs: []
  type: TYPE_NORMAL
- en: It’s often but not always the case that we need a separate function for each
    of the subproblems we identify. Take a look at the input step again. We need to
    ask the user for a word. While we could split off a separate function for this
    subtask, that would be overkill. Why? This is because Python already has a built-in
    function for asking the user for input! The function is called `input`, and we
    saw it at work in chapter 3, section 3.3.7, when we were asking the user to enter
    passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Do we need to split off a separate function for the output step? No again! The
    output step is just outputting stuff to the user. We know that we can do that
    with Python’s already-existing print function. Again, it wouldn’t be a mistake
    to split off a function for this, and you may have done so if you were doing this
    problem decomposition on your own. What you’d notice, though, is that the function
    would be very short, consisting of not much more than a call of `print`—and at
    that point you might think again about whether you want it as a separate function
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: The process step, by comparison, is going to involve a lot more work. There’s
    quite a bit that goes into figuring out all the possible spelling suggestions!
    We have to support deleting a letter, inserting a letter, changing one letter
    to another, and so on, which is way too much to keep all in our main `spell_check`
    function. We need a separate function for the process step. This is what we need
    to work on next.
  prefs: []
  type: TYPE_NORMAL
- en: 7.5 Breaking down the process subproblem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need a name for our function that implements the process step. We’ll call
    it `get_spelling_suggestions` because it will be responsible for returning the
    spelling suggestions for what the user typed. It certainly needs to take the user’s
    misspelled word as an argument, or it wouldn’t have access to it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Pause here for a second, though: Do you think this function needs any additional
    parameters? Answer: it does! Somehow the function needs to know which strings
    are real words in English. For example, it has to know about the words *successful*,
    *thorough*, *acceptable*, and thousands of other English words. We could do that
    in a couple of ways: we could pass a list or (Python) dictionary of real words
    as a parameter, or we could pass the name of a file that contains all the real
    words as a parameter. When you’re designing your functions, you’ll need to make
    similar decisions, focused on the inputs that the function needs to do its work
    and the return value that we need when it’s done.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the misspelled word, we’re going to have our function take a
    parameter giving the name of a file that contains the list of valid words. There
    will be one valid word per line of this file. In the resources for this book,
    we’ve included one sample word list file called wordlist.txt that you can use.
    (We found a list of free dictionary words online with a simple internet search.)
  prefs: []
  type: TYPE_NORMAL
- en: 'What do we need to do for this process step? We can think of four subtasks.
    This is more problem decomposition! Those subtasks are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Get a list of words from the word list file.* A file of words is a good start,
    but it’s more convenient to have the words inside a Python list. That way, we
    can easily determine if a string is a valid word. We’ll name this function `create_word_list`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Generate a list of all possible words from the user’s string.* We need to
    delete a letter, insert a letter, or change one letter to another letter. This
    is going to generate many strings, some of which are real words and others that
    aren’t real words. For example, from the string `sucessful`, it would generate
    the real word *successful*, but also the strings `xsuccesful`, `sucxcesful`, and
    `succesfrl`, which are clearly not real words. But that’s OK. For now, we just
    want to generate every possible word so that we don’t miss any. We’ll name this
    function `all_possible_words`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using the list of all possible words, generate a list of only the real words.*
    This is the step where we prune our full list of potential words down to those
    words that actually exist in English. We’ll name this function `all_real_words`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Return a list of the unique words.* Why unique? We don’t want to return the
    same spelling suggestion twice, even though there may be two or more ways to arrive
    at that spelling suggestion from the user’s string. For example, to fix the word
    *sucessful*, there are two ways to do it: we can add the missing *c* before the
    *c* that’s already there, or we can add the *c* before the *e*. Both result in
    the correctly spelled word *successful*, but we only want to maintain that word
    once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we were to split out that final subtask—obtaining a list of unique words—into
    its own function, we’d call it something like `unique_words` or `only_unique_words`.
    While we could split out that subtask, and you’d be justified in doing so, we’ve
    decided to keep it as part of the `get_spelling_suggestions` function. The reason
    is that in Python, it ends up being just one line of code to remove duplicates
    from a list. For expediency, we’re telling you this now, but again, this would
    be a perfectly good subtask if you were doing this top-down design on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple ways to break down problems
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There’s no single correct way to do a top-down design and no single correct
    way to decompose problems into subproblems. For example, you may have been surprised
    that we decided to first generate all possible words (including fake ones that
    aren’t actually English words), and then prune that to the list of actual English
    words. Why not just check each possible word first, and only add it to our list
    if it’s a real word? We certainly could have done it that way too! If you had
    this alternate decomposition in mind, or we’ve piqued your curiosity, we encourage
    you to try this alternate design on your own after you’ve finished with the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There’s also no shame in trying a top-down design and then abandoning it if
    the design isn’t working out. What might it mean for the design to not work out?
    Well, maybe you’re finding it difficult to break up large functions into distinct
    subproblems. Or maybe you’re getting dozens of tiny functions and starting to
    worry that your functions are too specific and not solving general problems. Or
    maybe you’re having to pass around many parameters, perhaps some of which are
    only there to be passed further and further until finally a function needs them.
    Or maybe you just want to play out an alternate top-down design to see how it
    goes!
  prefs: []
  type: TYPE_NORMAL
- en: We encourage experimentation at the design phase before you settle on a final
    design for the code. In this experimentation, you’d try different possible functions
    and different inputs/outputs for functions. For example, earlier we debated whether
    the `get_spelling_suggestions` function should take a name of a file containing
    real words or a list (or dictionary) containing real words. Both options would
    be worth considering during your design phase.
  prefs: []
  type: TYPE_NORMAL
- en: That leaves us with three subtasks we need to solve. We’re going to do our top-down
    design on these shortly. But first, let’s take stock of where we are right now
    (see figure 7.3).
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/7-3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 Functions diagram showing the three subtasks of `get_spelling_suggestions`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 7.5.1 Getting the list of words from the word list file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The function for this task is `create_word_list`. It will take one parameter,
    which is the name of the word list file, and will return the list of words from
    that file.
  prefs: []
  type: TYPE_NORMAL
- en: Do we need any further top-down design on this function? Let’s imagine we thought
    the answer was yes. What subtasks could we split out? We could imagine the tasks
    of opening the file, reading its contents, and closing the file. But opening the
    file, as we learned in chapter 5, section 5.1.4, is done by just calling Python’s
    `open` function. Similarly, closing the file is done by just calling Python’s
    `close` function. What about reading the words from the file? That doesn’t sound
    much different from reading the lines of the CSV file in chapter 5, section 5.1.4\.
    So we feel justified in leaving this function alone, without any further subtask
    splitting.
  prefs: []
  type: TYPE_NORMAL
- en: 7.5.2 Generating the list of all possible words
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The function for this task is `all_possible_words`, which will take one parameter
    giving us the string for which we want to provide spelling suggestions. It will
    return the list of all possible words that can be obtained by adding one letter,
    deleting one letter, or changing one letter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding one letter, deleting one letter, and changing one letter are three distinct
    types of tasks. Moreover, they don’t strike us as particularly simple tasks: they’re
    going to involve some sort of loop over the letters in the user’s string. Aha!
    Looks like we have some further top-down design to do on this one. In particular,
    we’re going to split three subtasks out of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add_letter`—This function will take a string parameter and return a list of
    all strings that can be obtained by adding one letter anywhere in the word.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete_letter`—This function will take a string parameter and return a list
    of all strings that can be obtained by deleting one letter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`change_letter`—This function will take a string parameter and return a list
    of all strings that can be obtained by changing one letter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Table 7.2 provides what we expect each function will return for two different
    input strings. For both add_letter and change_letter, a large number of strings
    are returned because they will consider adding or changing every letter in English
    in every location in the input string.
  prefs: []
  type: TYPE_NORMAL
- en: Table 7.2 Examples of the `add_letter`, `delete_letter`, and `change_letter`
    function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Input String | Strings Returned by `add_letter` | Strings Returned by `delete_letter`
    | Strings Returned by `change_letter` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `cu`  | `acu, bcu, ccu, …, zcu cau, cbu, ccu, …, czu cua, cub, cuc, …, cuz`  |
    `u, c`  | `au, bu, du, …, zu, ca, cb, cc, …, cz`  |'
  prefs: []
  type: TYPE_TB
- en: '| `cad`  | `acad, bcad, ccad, …, zcad caad, cbad, ccad, …, czad caad, cabd,
    cacd, …, cazd cada, cadb, cadc, …, cadz`  | `ad, cd, ca`  | `aad, bad, dad, …,
    za cbd, ccd, cdd, …, czd caa, cab, cac, …, caz`  |'
  prefs: []
  type: TYPE_TB
- en: As usual, it’s important to think through whether we need to split out further
    subtasks from these three functions. However, given that the pattern we expect
    to see is just a loop through the letters, we’d be comfortable pushing forward
    here and revisiting our top-down design if our assumption proves to be incorrect.
    For now, we can tell you that we’ll be just fine without any further splitting.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing when to stop dividing into subtasks
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In general, knowing when to stop breaking a task into smaller subtasks is more
    art than science. It takes practice designing programs to get intuition about
    where to stop. Many experienced developers often pause for each subtask and consider
    how complex it is to program and sketch the steps of the function out in their
    mind. If the solution isn’t straightforward, they often choose to divide it into
    more steps. But we don’t expect you to be able to do this yet. Some companies
    put out guidelines to encourage simple functions by suggesting limits on the number
    of lines permitted (e.g., no more than 12 lines), but many feel the limit should
    be on the complexity moreso than the length, although length and complexity are
    certainly related.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re just getting started, a decent proxy then is to limit the number
    of lines per function to something like 12–20\. If you later find that a function
    ends up being just a single line, it’s still a subtask, but may not deserve its
    own function. (Sometimes, it’s okay to keep a short function though if it’s called
    many times by different functions or helps simplify the calling function.)
  prefs: []
  type: TYPE_NORMAL
- en: It’s okay to get this wrong when you’re first practicing; we certainly have.
    Sometimes a subtask seems like it’ll make a simple function, only to end up being
    much more difficult than expected. In cases like that, you know to just subdivide
    it more. Likewise, we’ve had functions that were a single line and if they were
    used commonly or made the calling function simpler to understand, we just kept
    that line as a function.
  prefs: []
  type: TYPE_NORMAL
- en: 7.5.3 Generating the list of all real words
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The function for this task is `all_real_words`. It will take two parameters:
    the list of real words, and the list of all possible words. It will return a list
    consisting of only the real words from the full list of possible words. The code
    for this function would involve going through the list of possible words and checking
    whether each one shows up in the list of real words. As this task is a small,
    well-defined task that won’t yield a lot of code, we’re comfortable leaving this
    function alone without any further splitting.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.6 Summary of our top-down design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve reached the end of our top-down design process. You can see our final
    top-down design in figure 7.4.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/7-4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 Functions diagram with the three subtasks of `all_possible_words`
    added
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s not lose the forest for the trees here. If we zoom out, what we’ve done
    is break down our original big problem into several smaller problems, each of
    which we’re going to implement as a function. Our original `spell_check` problem
    may have felt overwhelming. That’s OK, though, because we broke it down into one
    primary subtask of `get_spelling_suggestions`. The `get_spelling_suggestions`
    function is still a big problem in its own right, but we were able to solve that
    through the same process: we split it into three subtasks. Two of those subtasks,
    `create_word_list` and `all_real_words`, felt as though they could be solved in
    a single function, but the other task, `all_possible_words`, was complex enough
    that we felt it needed three more additional subtasks (`add_letter`, `delete_letter`,
    and `change_letter`). The important thing we want you to take away from this is
    that we used the same technique of problem decomposition at every step to turn
    an initially daunting task into just a collection of solvable subtasks that will
    become functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Our next step is to move from design to implementation. We know which functions
    we need now to solve our problem. It’s time for the code!
  prefs: []
  type: TYPE_NORMAL
- en: 7.7 Implementing our functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you’re doing a top-down design, as we just did, you start with your overall
    problem and break it into subproblems. That’s why we started with `spell_check`
    (our overall problem) and eventually reached functions such as `add_letter`, which
    didn’t need any further splitting. But when we ask Copilot to implement these
    functions, we’re not going to work in the same order. Rather, we’re going to work
    in the *opposite* order, doing the smallest subproblems first, then moving onto
    the functions that depend on those subproblems. This corresponds to moving from
    right to left in a figure such as figure 7.4, starting with leaf functions and
    continuing to nonleaf functions.
  prefs: []
  type: TYPE_NORMAL
- en: We implement functions in the opposite order like this so that Copilot knows
    about the smaller functions by the time we want to implement larger functions.
    That way, Copilot will be more likely to call our subtask functions as desired.
  prefs: []
  type: TYPE_NORMAL
- en: We want to stay squarely focused on problem decomposition here, and we’ve made
    some decisions toward that end. First, while we’ll include some tests in our docstrings,
    we won’t be pursuing full testing in this example as we would have done in chapter
    6\. We encourage you to use doctest to run the tests that we do provide as well
    as add your own tests for further confidence in the code. Second, we haven’t dwelled
    much on our prompt engineering, instead focusing on the prompts that yielded good
    results. In the next chapter, we’ll focus on debugging, and that’s where we’ll
    return to prompt engineering. Third, we’re not focusing on reading and understanding
    the code in full detail. That said, we’ve included some annotations to explain
    what the code is doing and how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 7.7.1 create_word_list
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll start with our `create_word_list` function. As in chapter 3, we write
    the function header (the `def` line) and the docstring, and Copilot fills in the
    code. This is how we’ll have Copilot write the code for all the functions in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already know what our `create_word_list` function is supposed to do: read
    the words from the word list file and return them as a Python list of words. We
    carefully write what we want in the docstring, as shown in listing 7.1.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 7.1 Function to read the list of words
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '#1 The header we wrote ourselves'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 The docstring we wrote ourselves'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Opens the file'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Loops through each line of the file'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Adds each word to our list of words'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve used a descriptive parameter name, `filename`, which gives a good clue
    to the purpose of the parameter. We’ve also been careful to use this parameter
    name in the docstring. Our docstring also makes it explicit that we want to *return*
    the list (rather than, say, print it).
  prefs: []
  type: TYPE_NORMAL
- en: We haven’t included a test in the docstring for this function, and that’s because
    we didn’t want to distract from the overall goal of implementing each of our functions.
    If you wanted to, though, you know how! Specifically, we did this in chapter 6
    where we created a small file for purposes of testing. Here, you could create
    a small file with one word per line but with only a few English words, and then
    test that the list of words we read from the file matches the words that we put
    in the file. We’re finished with our `create_word_list` function, so we can mark
    it as complete as in figure 7.5.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/7-5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 Full functions diagram with `create_word_list` finished
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To save space, we won’t show the updated figure after we implement each function,
    but we’ll show it occasionally.
  prefs: []
  type: TYPE_NORMAL
- en: 7.7.2 add_letter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we’ll work on the functions that `all_possible_words` needs, starting with
    `add_letter`. The `add_letter` function takes a string as a parameter and returns
    the list of potential words that can be formed by adding one letter to that string.
    Let’s think briefly about what to expect from this function with a quick example.
    If we gave the function the string `cu` (as in table 7.2) it’s going to generate
    a list of words with every letter added to each possible position. This means
    it should include strings that have an `a` added before `cu` to make `acu`, a
    `b` added before `cu` to make `bcu`, and so forth for the character before `cu`
    stopping with `zcu`. The function should also include every letter in between
    `c` and `u` to form `cau`, `cbu`, `ccu`… . , `czu`. Lastly (as there are three
    possible positions to add a letter), we’d expect the function to add every possible
    letter after `cu` to form `cua`, `cub`, `cuc`,… . , `cuz`. Our prompt to Copilot
    and the code generated by Copilot is shown in listing 7.2.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 7.2 Function to add any possible letter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Loops through each index, from 0 to just past the final character'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Loops through each lowercase letter'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Forms a new word by placing character c at index i'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Adds this new word to our list of words'
  prefs: []
  type: TYPE_NORMAL
- en: The code here is quite subtle and deserves careful testing. For example, notice
    that the outer loop uses `len(word) + 1`, rather than the more standard `len(word)`.
    Without the `+ 1`, we would add characters at each existing index of the word
    string. But that would actually miss the fact that we also want to be able to
    add letters *past* the existing letters! The `+ 1` adds one extra iteration where
    we add a character to the end of the string.
  prefs: []
  type: TYPE_NORMAL
- en: For each index of the outer loop, we consider each possible lowercase letter
    in the inner loop. The line `new_word = word[:i] + c + word[i:]` uses string slicing,
    the technique of extracting letters out of a string using two indices, to add
    the current inner-loop character to the current outer-loop position.
  prefs: []
  type: TYPE_NORMAL
- en: Although we aren’t spending much time on testing in this chapter because the
    focus is problem decomposition, you would want to test this function by giving
    it a single misspelled word (i.e., *cu*) and then printing the returned words
    and ensuring it includes strings such as `acu` (add at the start), `cau` (add
    in the middle), and `cua` (add at the end), as well as possible real words such
    as *cup* and *cut*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we wouldn’t want to include exact tests in the docstring because
    the lists returned by this function are huge! For example, try typing this at
    the Python prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You’ll get a list with 78 strings in it! And that’s for our tiny `'cu'` string.
    The number of strings returned in the list grows significantly as we increase
    the number of characters in the parameter string.
  prefs: []
  type: TYPE_NORMAL
- en: 7.7.3 delete_letter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like `add_letter`, `delete_letter` takes a string as a parameter and returns
    a list of potential words. The difference is that rather than adding a letter,
    `delete_letter` deletes each possible letter from the string to arrive at new
    possible words. Let’s think about what we expect this function to do. If we give
    it the string “carf”, it should try deleting each letter to produce the strings
    “arf” by deleting “c”, “crf” by deleting “a”, “caf” by deleting “r”, and “car”
    by deleting “f”. Again, we gave the prompt to Copilot for this function, as shown
    in listing 7.3.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 7.3 Function to delete any letter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Loops through each index, from 0 to the final character'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Forms a new word by deleting character at index i'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Adds this new word to our list of words'
  prefs: []
  type: TYPE_NORMAL
- en: This code is similar to our code for `add_letter`. One difference is that we
    have only one loop this time, not two. The reason is that we don’t need an inner
    loop to loop through the letters *a*, *b*, *c*, *d*, and so on. That’s because
    we’re deleting letters that already exist in the word, rather than figuring out
    which letter to add.
  prefs: []
  type: TYPE_NORMAL
- en: 7.7.4 change_letter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, it’s time for our third and final subtask of `all_possible_words: change_letter`!
    This function is responsible for generating words where one letter in the string
    is changed to some other letter. In thinking about what we’d like to see happen
    here, let’s consider the string `cu` again (as in table 7.2). We want this function
    to replace the letter *c* with all possible letters to create the strings `au`,
    `bu`, `du`… . , `zu` and to replace the letter *u* with all possible letters to
    create the strings `ca`, `cb`, `cc`… . , `cz`. (Note that we omit trying `cu`
    as that’s the initial string, we only consider changes to letters.) See listing
    7.4 for our prompt and the code from Copilot.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 7.4 Function to change any letter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Loops through each index, from 0 to the final character'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Loops through each lowercase letter'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 If c is a different letter from the letter at index i'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Forms a new word by changing the character at index i to character c'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Adds this new word to our list of words'
  prefs: []
  type: TYPE_NORMAL
- en: This code is quite similar to our `add_letter` code! The main difference is
    that we use string slicing not to add a new character but to change an existing
    character.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we’ve completed the three functions we need to implement `all_possible_words`.
    Check out figure 7.6, where we’ve marked off the substantial progress that we’ve
    made! We’ll next tackle `all_possible_words`.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/7-6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 Full functions diagram with `all_possible_words` helper functions
    finished
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 7.7.5 all_possible_words
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reason we can now implement `all_possible_words` is that we’ve already implemented
    the three subtask functions that `all_possible_words` needs to do its job. When
    we ask Copilot to write this code, we’re expecting to see calls of `add_letter`,
    `delete_letter`, and `change_letter`. Take a look at listing 7.5, and you’ll see
    Copilot doing exactly this with the prompt we’ve given it.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 7.5 Function to generate all possible words
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Calls helper functions to add a letter and delete a letter'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Calls helper function to change a letter'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generating all possible words is no easy feat. Yet, we’ve managed to do it
    with a single line of Python code here! It just calls to three helper functions
    and that’s it. This is exactly why we’re doing top-down design: to make complex
    functions much easier to implement by offloading much of their complexity to helper
    functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.7.6 all_real_words
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re close to being able to implement `get_spelling_suggestions`, but not quite,
    because we first need to implement its subtask function `all_real_words`. The
    `all_ real_words` function takes two parameters. The first parameter is the English
    word list (this will come from an English word list file). The second parameter
    is the list of possible words (this will come from `all_possible_words`). The
    function returns the list of possible words that are real words. Let’s do this!
  prefs: []
  type: TYPE_NORMAL
- en: Listing 7.6 Function to generate all real words
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Loops through the possible words'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Is this word a real word?'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Yes: add the word to the list of real words that we’ll return'
  prefs: []
  type: TYPE_NORMAL
- en: The test in the docstring is a good example of how this function works. It’s
    using the `english_words` list for the first parameter and the `possible_words`
    list as the second parameter. The function will return those words from `possible_words`
    that are also in `english_words`. We’re using this very small test case, rather
    than using thousands of English words, because this makes it much easier for us
    to determine by hand what the correct return value should be!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s check how well we’re progressing in figure 7.7\. We’re getting close—just
    two functions to go!
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/7-7.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 Full functions diagram with `all_possible_words` and `all_real_words`
    finished
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 7.7.7 get_spelling_suggestions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve implemented `create_word_list`, `all_possible_words`, and `all_real_words`,
    and those are the only three subtask functions that `get_spelling_suggestions`
    needs. That means it’s time for us to implement `get_spelling_suggestions`!
  prefs: []
  type: TYPE_NORMAL
- en: 'This function takes two parameters: the name of a file that contains real words
    (one word per line) and the string that we want to provide suggestions for. It
    returns the list of the unique suggestions. As always, when scrutinizing Copilot
    code for a nonleaf function, you want to check that it’s calling the helper functions
    that you expect it to be calling, as shown in listing 7.7\. Before you move on,
    convince yourself that it’s calling all the helper functions that it should be
    calling.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 7.7 Function to return spelling suggestions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Gets the list of English words'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Gets the list of possible words'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Figures out which possible words are spelling suggestions'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Returns the unique list of spelling suggestions'
  prefs: []
  type: TYPE_NORMAL
- en: 'That last line there is tricky. Apparently, it’s ensuring that we return only
    unique words—but how? Let’s ask Copilot to explain! Here’s the explanation that
    we got when we used the `/explain` command to Copilot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![chatGpt](../Images/chatGpt.png)Copilot This line of Python code is performing
    two operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`set(real_words)`: This is creating a set from the `real_words` list. A set
    in Python is an unordered collection of unique elements. So, this operation is
    removing any duplicate elements from the `real_words` list.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`list(set(real_words))`: This is converting the set back into a list. The result
    is a list where all elements are unique.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, in summary, this line of code is removing any duplicate words from the `real_
    words` list.
  prefs: []
  type: TYPE_NORMAL
- en: 7.7.8 spell_check
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ve made it to our final function, `spell_check`! It takes one parameter:
    a string indicating the name of a word list file. It asks the user to type a string,
    and then shows the user all spelling corrections for that string.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 7.8 Our main function that interacts with the user
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Asks the user to type a string'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Gets the spelling suggestions for the user'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Loops through the spelling suggestions'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Prints each spelling suggestion on its own line'
  prefs: []
  type: TYPE_NORMAL
- en: Consult figure 7.8 to see that we have indeed implemented all of our functions!
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/7-8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 Full functions diagram with all functions complete!
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You need to add one line of code at the bottom of your Python program to actually
    call this function. Otherwise, your program won’t do anything because no function
    is being called! So, add this line at the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, assuming that you have the wordlist.txt file in your directory along with
    your Python program, you can run it! It will ask you to type a word. Try typing
    the misspelled word *sucessful* (the word that started it all!), and you should
    see the program provide the spelling suggestion of *successful*, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Try other misspelled words too, such as *thourough* and *acceptible*. With these
    misspelled words so far, our program is replying with only a single spelling suggestion
    because there is only one real word a single edit away from the words we’re trying.
    We encourage you to try entering the word *carf* to see that our program can provide
    many possible spelling suggestions.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You’ve completed your first real-world top-down design. Your
    program provides spelling suggestions for a word, much as a spellchecker does.
    We made the problem considerably easier to implement by doing some up-front design
    work to break down the original problem into smaller subproblems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many computer scientists view problem decomposition as *the* most critical
    skill needed to write good software [1]. We saw the value of problem decomposition
    in this chapter: it made a large problem solvable by breaking it into smaller
    steps until each step was easier to solve. We applied this skill in this chapter
    using top-down design (start with the large task and break it into smaller tasks)
    to put it in practice. This skill remains critical when working with tools such
    as Copilot and ChatGPT because they perform better when solving small, well-defined
    problems compared to large problems. As mentioned at the beginning of the chapter,
    problem decomposition is more of an art than a science, and it takes practice
    to get it right. We’ll do more problem decomposition in our upcoming chapters
    to help give you more intuition into how to approach it yourself.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.8 Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the examples of `get_strong_password` and `best_word` discussed previously,
    let’s apply the top-down design approach to a new problem. Suppose we want to
    write a function called `find_highest_scoring_word` that takes a list of sentences
    as its parameter and returns the word with the highest score from all the sentences.
    Each word’s score is calculated the same way as in the `best_word` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the subtasks needed to solve this problem. What are the individual
    functions you would design to break down the task into smaller, manageable pieces?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Draw a function diagram similar to figures 7.1 and 7.2, depicting how these
    functions would call each other to solve the overall problem.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We talked about how sometimes a task is simple enough to be kept as it is, that
    is, not broken down into smaller tasks. Given the following tasks, decide if you
    would divide them into smaller subtasks. If so, list the subtasks and explain
    why. If not, explain why the task is simple enough to remain a single function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reading a file and printing its contents
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculating the average grade for a class of students from a list of scores
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finding the maximum value in a list of numbers
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Processing an order for an online store, which includes verifying the order,
    calculating the total price, applying discounts, and generating an invoice
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Why did we choose to create the `create_word_list` function as a separate function?
    Could this task be kept as part of a larger function? Explain your reasoning.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Imagine you need to change the way the spell-checker works. Specifically, you
    want to modify the `add_letter` function to exclude certain letters (e.g., *q*,
    *x*, *z*) from being added. How would you modify the program we’ve written?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following function processes a list of orders, calculates the total price
    with tax, applies a discount if applicable, and generates a summary report.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Refactor (redesign) the `process_orders` function by breaking it down into smaller
    subproblems. Implement each subproblem as a separate function, and ensure the
    overall behavior remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: '6\. In this exercise, you’re given a code snippet already broken down into
    two functions: a main function and a helper function. When we call the function
    with Test Case 2 in the following code, we get a `ZeroDivisionError`. Your task
    is to identify and fix the error based on the provided error message.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to divide a big programming problem into smaller subproblems before
    we can effectively implement it. This is known as problem decomposition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Top-down design is a systematic technique for breaking a problem down into small
    subtask functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In top-down design, we seek small functions that solve well-defined tasks and
    that can be used by one or more other functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we’re ready to implement our functions that arose from top-down design,
    we implement them from the bottom up; that is, we implement the leaf functions
    first, then functions that depend on those leaf functions, and so on until we
    implement the topmost function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
