- en: Chapter 18\. The Web, Untangled
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Oh, what a tangled web we weave…
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Walter Scott, Marmion
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Straddling the French–Swiss border is CERN—a particle physics research institute
    that smashes atoms multiple times, just to make sure.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that smashing generates a mountain of data. In 1989, the English scientist
    Tim Berners-Lee first circulated a proposal within CERN to help disseminate information
    there and across the research community. He called it the *World Wide Web* and
    distilled its design into three simple ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP (Hypertext Transfer Protocol)
  prefs: []
  type: TYPE_NORMAL
- en: A protocol for web clients and servers to interchange requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: HTML (Hypertext Markup Language)
  prefs: []
  type: TYPE_NORMAL
- en: A presentation format for results.
  prefs: []
  type: TYPE_NORMAL
- en: URL (Uniform Resource Locator)
  prefs: []
  type: TYPE_NORMAL
- en: A way to uniquely represent a server and a *resource* on that server.
  prefs: []
  type: TYPE_NORMAL
- en: In its simplest usage, a web client (I think Berners-Lee was the first to use
    the term *browser*) connected to a web server with HTTP, requested a URL, and
    received HTML.
  prefs: []
  type: TYPE_NORMAL
- en: This was all built on the networking base from the *internet*, which at the
    time was noncommercial, and known only to a few universities and research organizations.
  prefs: []
  type: TYPE_NORMAL
- en: He wrote the first web browser and server on a NeXT^([1](ch18.html#idm45794970286888))
    computer. Web awareness really expanded in 1993, when a group of students at the
    University of Illinois released the Mosaic web browser (for Windows, the Macintosh,
    and Unix) and the NCSA *httpd* server. When I downloaded Mosaic that summer and
    started building sites, I had no idea that the web and the internet would soon
    become part of everyday life. The internet^([2](ch18.html#idm45794970285336))
    was still officially noncommercial then; there were about 500 known web servers
    [in the world](http://home.web.cern.ch/about/birth-web). By the end of 1994, the
    number of web servers had grown to 10,000. The internet was opened to commercial
    use, and the authors of Mosaic founded Netscape to write commercial web software.
    Netscape went public as part of the early internet frenzy, and the web’s explosive
    growth has never stopped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Almost every computer language has been used to write web clients and web servers.
    The dynamic languages Perl, PHP, and Ruby have been especially popular. In this
    chapter, I show why Python is a particularly good language for web work at every
    level:'
  prefs: []
  type: TYPE_NORMAL
- en: Clients, to access remote sites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Servers, to provide data for websites and web APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web APIs and services, to interchange data in other ways than viewable web pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And while we’re at it, we’ll build an actual interactive website in the exercises
    at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Web Clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The low-level network plumbing of the internet is called Transmission Control
    Protocol/Internet Protocol, or more commonly, simply TCP/IP ([“TCP/IP”](ch17.html#tcp_ip)
    goes into more detail about this). It moves bytes among computers, but doesn’t
    care about what those bytes mean. That’s the job of higher-level *protocols*—syntax
    definitions for specific purposes. HTTP is the standard protocol for web data
    interchange.
  prefs: []
  type: TYPE_NORMAL
- en: 'The web is a client-server system. The client makes a *request* to a server:
    it opens a TCP/IP connection, sends the URL and other information via HTTP, and
    receives a *response*.'
  prefs: []
  type: TYPE_NORMAL
- en: The format of the response is also defined by HTTP. It includes the status of
    the request, and (if the request succeeded) the response’s data and format.
  prefs: []
  type: TYPE_NORMAL
- en: The most well-known web client is a web *browser*. It can make HTTP requests
    in a number of ways. You might initiate a request manually by typing a URL into
    the location bar or clicking a link in a web page. Very often, the data returned
    is used to display a website —HTML documents, JavaScript files, CSS files, and
    images—but it can be any type of data, not just that intended for display.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important aspect of HTTP is that it’s *stateless*. Each HTTP connection
    that you make is independent of all the others. This simplifies basic web operations
    but complicates others. Here are just a few samples of the challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs: []
  type: TYPE_NORMAL
- en: Remote content that doesn’t change should be saved by the web client and used
    to avoid downloading from the server again.
  prefs: []
  type: TYPE_NORMAL
- en: Sessions
  prefs: []
  type: TYPE_NORMAL
- en: A shopping website should remember the contents of your shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs: []
  type: TYPE_NORMAL
- en: Sites that require your username and password should remember them while you’re
    logged in.
  prefs: []
  type: TYPE_NORMAL
- en: Solutions to statelessness include *cookies*, in which the server sends the
    client enough specific information to be able to identify it uniquely when the
    client sends the cookie back.
  prefs: []
  type: TYPE_NORMAL
- en: Test with telnet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTP is a text-based protocol, so you can actually type it yourself for web
    testing. The ancient `telnet` program lets you connect to any server and port,
    and type commands to any service that’s running there. For secure (encrypted)
    connections to other machines, it’s been replaced by `ssh`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s ask everyone’s favorite test site, Google, some basic information about
    its home page. Type this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is a web server on port 80 (this is where unencrypted `http` usually
    runs; encrypted `https` uses port 443) at *google.com* (I think that’s a safe
    bet), `telnet` will print some reassuring information, and then display a final
    blank line that’s your cue to type something else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, type an actual HTTP command for `telnet` to send to the Google web server.
    The most common HTTP command (the one your browser uses when you type a URL in
    its location bar) is `GET`. This retrieves the contents of the specified resource,
    such as an HTML file, and returns it to the client. For our first test, we’ll
    use the HTTP command `HEAD`, which just retrieves some basic information *about*
    the resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an extra carriage return to send a blank line so the remote server knows
    you’re all done and want a response. That `HEAD /` sends the HTTP `HEAD` *verb*
    (command) to get information about the home page (`/`). You’ll receive a response
    such as this (I trimmed some of the long lines using … so they wouldn’t stick
    out of the book):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These are HTTP response headers and their values. Some, like `Date` and `Content-Type`,
    are required. Others, such as `Set-Cookie`, are used to track your activity across
    multiple visits (we talk about *state management* a little later in this chapter).
    When you make an HTTP `HEAD` request, you get back only headers. If you had used
    the HTTP `GET` or `POST` commands, you would also receive data from the home page
    (a mixture of HTML, CSS, JavaScript, and whatever else Google decided to throw
    into its home page).
  prefs: []
  type: TYPE_NORMAL
- en: 'I don’t want to leave you stranded in `telnet`. To close `telnet`, type the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Test with curl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using `telnet` is simple, but is a completely manual process. The [`curl`](https://curl.haxx.se)
    program is probably the most popular command-line web client. Documentation includes
    the book [*Everything Curl*](https://curl.haxx.se/book.html), in HTML, PDF, and
    ebook formats. A [table](https://oreil.ly/dLR8b) compares `curl` with similar
    tools. The [download](https://curl.haxx.se/download.html) page includes all the
    major platforms, and many obscure ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest use of `curl` does an implicit `GET` (output truncated here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This uses `HEAD`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re passing arguments, you can include them in the command line or a
    data file. In these examples, I use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*url* for any website'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data.txt` as a text data file with these contents: `a=1&b=2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data.json` as a JSON data file with these contents: `{"a":1, "b": 2}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a=1&b=2` as two data arguments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using default (*form-encoded*) arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For JSON-encoded arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Test with httpie
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A more Pythonic alternative to curl is [`httpie`](https://httpie.org).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To make a form-encoded POST, similar to the methods for `curl` above (`-f`
    is a synonym for `--form`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The default encoding is JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`httpie` also handles HTTP headers, cookies, file uploads, authentication,
    redirects, SSL, and so on. As usual, see the [docs](https://httpie.org/doc)'
  prefs: []
  type: TYPE_NORMAL
- en: Test with httpbin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can test your web queries against the site [`httpbin`](https://httpbin.org),
    or download and run the site in a local Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Python’s Standard Web Libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Python 2, web client and server modules were a bit scattered. One of the
    Python 3 goals was to bundle these modules into two *packages* (remember from
    [Chapter 11](ch11.html#ch_modules) that a package is just a directory containing
    module files):'
  prefs: []
  type: TYPE_NORMAL
- en: '`http` manages all the client-server HTTP details:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`client` does the client-side stuff'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`server` helps you write Python web servers'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cookies` and `cookiejar` manage cookies, which save data between site visits'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`urllib` runs on top of `http`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`request` handles the client request'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`response` handles the server response'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parse` cracks the parts of a URL'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you’re trying to write code that’s compatible with both Python 2 and Python
    3, keep in mind that `urllib` changed [a lot](https://oreil.ly/ww5_R) between
    the two versions. For a better alternative, refer to [“Beyond the Standard Library:
    requests”](#requests).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the standard library to get something from a website. The URL in
    the following example returns information from a test website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This little chunk of Python opened a TCP/IP connection to the remote web server
    `www.example.com`, made an HTTP request, and received an HTTP response. The response
    contained more than just the page data. In [the official documentation](http://bit.ly/httpresponse-docs),
    we find that `conn` is an `HTTPResponse` object with a number of methods and attributes.
    One of the most important parts of the response is the HTTP *status code*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'A `200` means that everything was peachy. There are dozens of HTTP status codes,
    grouped into five ranges by their first (hundreds) digit:'
  prefs: []
  type: TYPE_NORMAL
- en: 1xx (information)
  prefs: []
  type: TYPE_NORMAL
- en: The server received the request but has some extra information for the client.
  prefs: []
  type: TYPE_NORMAL
- en: 2xx (success)
  prefs: []
  type: TYPE_NORMAL
- en: It worked; every success code other than 200 conveys extra details.
  prefs: []
  type: TYPE_NORMAL
- en: 3xx (redirection)
  prefs: []
  type: TYPE_NORMAL
- en: The resource moved, so the response returns the new URL to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 4xx (client error)
  prefs: []
  type: TYPE_NORMAL
- en: Some problem from the client side, such as the well-known 404 (not found). 418
    (*I’m a teapot*) was an April Fool’s joke.
  prefs: []
  type: TYPE_NORMAL
- en: 5xx (server error)
  prefs: []
  type: TYPE_NORMAL
- en: 500 is the generic whoops; you might see a 502 (bad gateway) if there’s some
    disconnect between a web server and a backend application server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the actual data contents from the web page, use the `read()` method
    of the `conn` variable. This returns a `bytes` value. Let’s get the data and print
    the first 50 bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can convert these bytes to a string and print its first 50 characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The rest is more HTML and CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Out of sheer curiosity, what HTTP headers were sent back to us?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Remember that `telnet` example a little earlier? Now, our Python library is
    parsing all those HTTP response headers and providing them in a dictionary. `Date`
    and `Server` seem straightforward; some of the others, less so. It’s helpful to
    know that HTTP has a set of standard headers such as `Content-Type`, and many
    optional ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond the Standard Library: requests'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the beginning of [Chapter 1](ch01.html#ch_intro), there was a program that
    accessed a Wayback Machine API by using the standard libraries `urllib.request`
    and `json`. Following that example is a version that uses the third-party module
    `requests`. The `requests` version is shorter and easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: For most purposes, I think web client development with `requests` is easier.
    You can browse the [documentation](https://oreil.ly/zF8cy) (which is pretty good)
    for full details. I’ll show the basics of `requests` in this section and use it
    throughout this book for web client tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install the `requests` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s redo our example.com query with `requests`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: To show a JSON query, here’s a minimal version of a program that appears at
    the end of this chapter. You provide a string, and it uses an Internet Archive
    search API to look through the titles of billions of multimedia items saved there.
    Notice that in the `requests.get()` call shown in [Example 18-1](#ex1801), you
    only need to pass a `params` dictionary, and `requests` handles all the query
    construction and character escaping.
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-1\. ia.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How’s their stock of wendigo items?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The first column (the *identifier*) can be used to actually view the item at
    the *archive.org* site. You’ll see how to do this at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Web Servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web developers have found Python to be an excellent language for writing web
    servers and server-side programs. This has led to such a variety of Python-based
    web *frameworks* that it can be hard to navigate among them and make choices—not
    to mention deciding what deserves to go into a book.
  prefs: []
  type: TYPE_NORMAL
- en: A web framework provides features with which you can build websites, so it does
    more than a simple web (HTTP) server. You’ll see features such as routing (URL
    to server function), templates (HTML with dynamic inclusions), debugging, and
    more.
  prefs: []
  type: TYPE_NORMAL
- en: I’m not going to cover all of the frameworks here—just those that I’ve found
    to be relatively simple to use and suitable for real websites. I’ll also show
    how to run the dynamic parts of a website with Python and other parts with a traditional
    web server.
  prefs: []
  type: TYPE_NORMAL
- en: The Simplest Python Web Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can run a simple web server by typing just one line of Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This implements a bare-bones Python HTTP server. If there are no problems,
    this will print an initial status message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: That `0.0.0.0` means *any TCP address*, so web clients can access it no matter
    what address the server has. There’s more low-level details on TCP and other network
    plumbing for you to read about in [Chapter 17](ch17.html#ch_networks).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now request files, with paths relative to your current directory, and
    they will be returned. If you type `http://localhost:8000` in your web browser,
    you should see a directory listing there, and the server will print access log
    lines such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`localhost` and `127.0.0.1` are TCP synonyms for *your local computer*, so
    this works regardless of whether you’re connected to the internet. You can interpret
    this line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`127.0.0.1` is the client’s IP address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first `-` is the remote username, if found
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second `-` is the login username, if required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[20/Feb/2013 22:02:37]` is the access date and time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"GET / HTTP/1.1"` is the command sent to the web server:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HTTP method (`GET`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The resource requested (`/`, the top)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The HTTP version (`HTTP/1.1`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The final `200` is the HTTP status code returned by the web server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Click any file. If your browser can recognize the format (HTML, PNG, GIF, JPEG,
    and so on) it should display it, and the server will log the request. For instance,
    if you have the file *oreilly.png* in your current directory, a request for *[*http://localhost:8000/oreilly.png*](http://localhost:8000/oreilly.png)*
    should return the image of the unsettling fellow in [Figure 20-2](ch20.html#tarsier_1),
    and the log should show something such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If you have other files in the same directory on your computer, they should
    show up in a listing on your display, and you can click any one to download it.
    If your browser is configured to display that file’s format, you’ll see the results
    on your screen; otherwise, your browser will ask you if you want to download and
    save the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default port number used is 8000, but you can specify another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This Python-only server is best suited for quick tests. You can stop it by killing
    its process; in most terminals, press Ctrl+C.
  prefs: []
  type: TYPE_NORMAL
- en: You should not use this basic server for a busy production website. Traditional
    web servers such as Apache and NGINX are much faster for serving static files.
    In addition, this simple server has no way to handle dynamic content, which more
    extensive servers can do by accepting parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Web Server Gateway Interface (WSGI)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All too soon, the allure of serving simple files wears off, and we want a web
    server that can also run programs dynamically. In the early days of the web, the
    *Common Gateway Interface* (CGI) was designed for clients to make web servers
    run external programs and return the results. CGI also handled getting input arguments
    from the client through the server to the external programs. However, the programs
    were started anew for *each* client access. This could not scale well, because
    even small programs have appreciable startup time.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this startup delay, people began merging the language interpreter into
    the web server. Apache ran PHP within its `mod_php` module, Perl in `mod_perl`,
    and Python in `mod_python`. Then, code in these dynamic languages could be executed
    within the long-running Apache process itself rather than in external programs.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative method was to run the dynamic language within a separate long-running
    program and have it communicate with the web server. FastCGI and SCGI are examples.
  prefs: []
  type: TYPE_NORMAL
- en: Python web development made a leap with the definition of the *Web Server Gateway
    Interface* (WSGI), a universal API between Python web applications and web servers.
    All of the Python web frameworks and web servers in the rest of this chapter use
    WSGI. You don’t normally need to know how WSGI works (there really isn’t much
    to it), but it helps to know what some of the parts under the hood are called.
    This is a *synchronous* connection—one step follows another.
  prefs: []
  type: TYPE_NORMAL
- en: ASGI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a few places so far, I’ve mentioned that Python has been introducing *asynchronous*
    language features like `async`, `await`, and `asyncio`. ASGI (Asynchronous Server
    Gateway Interface) is a counterpart of WSGI that uses these new features. In [Appendix C](app03.html#app_async),
    you’ll see more discussion, and examples of new web frameworks that use ASGI.
  prefs: []
  type: TYPE_NORMAL
- en: Apache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [`apache`](http://httpd.apache.org) web server’s best WSGI module is [`mod_wsgi`](https://code.google.com/p/modwsgi).
    This can run Python code within the Apache process or in separate processes that
    communicate with Apache.
  prefs: []
  type: TYPE_NORMAL
- en: You should already have `apache` if your system is Linux or macOS. For Windows,
    you’ll need to install [apache](http://bit.ly/apache-http).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, install your preferred WSGI-based Python web framework. Let’s try `bottle`
    here. Almost all of the work involves configuring Apache, which can be a dark
    art.
  prefs: []
  type: TYPE_NORMAL
- en: Create the test file shown in [Example 18-2](#ch18_ex01) and save it as */var/www/test/home.wsgi*.
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-2\. home.wsgi
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Do not call `run()` this time, because that starts the built-in Python web server.
    We need to assign to the variable `application` because that’s what `mod_wsgi`
    looks for to marry the web server and the Python code.
  prefs: []
  type: TYPE_NORMAL
- en: If `apache` and its `mod_wsgi` module are working correctly, we just need to
    connect them to our Python script. We want to add one line to the file that defines
    the default website for this `apache` server, but finding that file is a task
    itself. It could be */etc/apache2/httpd.conf*, or */etc/apache2/sites-available/default*,
    or the Latin name of someone’s pet salamander.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume for now that you understand `apache` and found that file. Add
    this line inside the `<VirtualHost>` section that governs the default website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'That section might then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Start `apache`, or restart it if it was running to make it use this new configuration.
    If you then browse to [*http://localhost/*](http://localhost/), you should see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This runs `mod_wsgi` in *embedded mode*, as part of `apache` itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also run it in *daemon mode*, as one or more processes, separate from
    `apache`. To do this, add two new directive lines to your `apache` config file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, *`user-name`* and *`group-name`* are the operating
    system user and group names, and the *`domain-name`* is the name of your internet
    domain. A minimal `apache` config might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: NGINX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [`NGINX`](http://nginx.org) web server does not have an embedded Python
    module. Instead, it’s a frontend to a separate WSGI server such as uWSGI or gUnicorn.
    Together they make a very fast and configurable platform for Python web development.
  prefs: []
  type: TYPE_NORMAL
- en: You can install `nginx` from its [website](http://wiki.nginx.org/Install). For
    examples of setting up Flask with NGINX and a WSGI server, see [this](https://oreil.ly/7FTPa).
  prefs: []
  type: TYPE_NORMAL
- en: Other Python Web Servers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following are some of the independent Python-based WSGI servers that work like
    `apache` or `nginx`, using multiple processes and/or threads (see [“Concurrency”](ch15.html#concurrency))
    to handle simultaneous requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`uwsgi`](http://projects.unbit.it/uwsgi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`cherrypy`](http://www.cherrypy.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`pylons`](http://www.pylonsproject.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some *event-based* servers, which use a single process but avoid blocking
    on any single request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`tornado`](http://www.tornadoweb.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`gevent`](http://gevent.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`gunicorn`](http://gunicorn.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I have more to say about events in the discussion about *concurrency* in [Chapter 15](ch15.html#ch_systems).
  prefs: []
  type: TYPE_NORMAL
- en: Web Server Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web servers handle the HTTP and WSGI details, but you use web *frameworks* to
    actually write the Python code that powers the site. So, let’s talk about frameworks
    for a while and then get back to alternative ways of actually serving sites that
    use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to write a website in Python, there are many (some say too many)
    Python web frameworks. A web framework handles, at a minimum, client requests
    and server responses. Most major web frameworks include these tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP protocol handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication (*authn*, or who are you?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization (*authz*, or what can you do?)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establish a session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validate parameters (required/optional, type, range)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle HTTP verbs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Route (functions/classes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serve static files (HTML, JS, CSS, images)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serve dynamic data (databases, services)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return values and HTTP status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional features include:'
  prefs: []
  type: TYPE_NORMAL
- en: Backend templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database connectivity, ORMs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rate limiting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the coming sections, we write example code for two frameworks (`bottle` and
    `flask`). These are *synchronous*. Later, I talk about alternatives, especially
    for database-backed websites. You can find a Python framework to power any site
    that you can think of.
  prefs: []
  type: TYPE_NORMAL
- en: Bottle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bottle consists of a single Python file, so it’s very easy to try out, and
    it’s easy to deploy later. Bottle isn’t part of standard Python, so to install
    it, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here’s code that will run a test web server and return a line of text when your
    browser accesses the URL *[*http://localhost:9999/*](http://localhost:9999/)*.
    Save it as *bottle1.py* ([Example 18-3](#ch18_ex02)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-3\. bottle1.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Bottle uses the `route` decorator to associate a URL with the following function;
    in this case, `/` (the home page) is handled by the `home()` function. Make Python
    run this server script by typing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see this on your browser when you access *[*http://localhost:9999/*](http://localhost:9999/)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `run()` function executes `bottle`’s built-in Python test web server. You
    don’t need to use this for `bottle` programs, but it’s useful for initial development
    and testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, instead of creating text for the home page in code, let’s make a separate
    HTML file called *index.html* that contains this line of text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Make `bottle` return the contents of this file when the home page is requested.
    Save this script as *bottle2.py* ([Example 18-4](#ch18_ex03)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-4\. bottle2.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the call to `static_file()`, we want the file `index.html` in the directory
    indicated by `root` (in this case, `''.''`, the current directory). If your previous
    server example code was still running, stop it. Now, run the new server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'When you ask your browser to get *http:/localhost:9999/*, you should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Let’s add one last example that shows how to pass arguments to a URL and use
    them. Of course, this will be *bottle3.py*, which you can see in [Example 18-5](#ch18_ex04).
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-5\. bottle3.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a new function called `echo()` and want to pass it a string argument
    in a URL. That’s what the line `@route(''/echo/<thing>'')` in the preceding example
    does. That `<thing>` in the route means that whatever was in the URL after `/echo/`
    is assigned to the string argument `thing`, which is then passed to the `echo`
    function. To see what happens, stop the old server if it’s still running and then
    start it with the new code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, access *[*http://localhost:9999/echo/Mothra*](http://localhost:9999/echo/Mothra)*
    in your web browser. You should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now, leave *bottle3.py* running for a minute so that we can try something else.
    You’ve been verifying that these examples work by typing URLs into your browser
    and looking at the displayed pages. You can also use client libraries such as
    `requests` to do your work for you. Save this as *bottle_test.py* ([Example 18-6](#ch18_ex05)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-6\. bottle_test.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Now, run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see this in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This is a little example of a *unit test*. [Chapter 19](ch19.html#ch_pythonista)
    provides more details on why tests are good and how to write them in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s more to Bottle than I’ve shown here. In particular, you can try adding
    these arguments when you call `run()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`debug=True` creates a debugging page if you get an HTTP error;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reloader=True` reloads the page in the browser if you change any of the Python
    code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s well documented at the [developer site](http://bottlepy.org/docs/dev).
  prefs: []
  type: TYPE_NORMAL
- en: Flask
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bottle is a good initial web framework. If you need a few more cowbells and
    whistles, try Flask. It started in 2010 as an April Fools’ joke, but enthusiastic
    response encouraged the author, Armin Ronacher, to make it a real framework. He
    named the result Flask as a wordplay on Bottle.
  prefs: []
  type: TYPE_NORMAL
- en: Flask is about as simple to use as Bottle, but it supports many extensions that
    are useful in professional web development, such as Facebook authentication and
    database integration. It’s my personal favorite among Python web frameworks because
    it balances ease of use with a rich feature set.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `flask` package includes the `werkzeug` WSGI library and the `jinja2` template
    library. You can install it from a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s replicate the final Bottle example code in Flask. First, though, we need
    to make a few changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Flask’s default directory home for static files is `static`, and URLs for files
    there also begin with `/static`. We change the folder to `'.'` (current directory)
    and the URL prefix to `''` (empty) to allow the URL `/` to map to the file *index.html*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `run()` function, setting `debug=True` also activates the automatic reloader;
    `bottle` used separate arguments for debugging and reloading.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save this file to *flask1.py* ([Example 18-7](#ch18_ex06)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-7\. flask1.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the server from a terminal or window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Test the home page by typing this URL into your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following (as you did for `bottle`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Try the `/echo` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: There’s another benefit to setting `debug` to `True` when calling `run`. If
    an exception occurs in the server code, Flask returns a specially formatted page
    with useful details about what went wrong, and where. Even better, you can type
    some commands to see the values of variables in the server program.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Do not set `debug = True` in production web servers. It exposes too much information
    about your server to potential intruders.
  prefs: []
  type: TYPE_NORMAL
- en: So far, the Flask example just replicates what we did with Bottle. What can
    Flask do that Bottle can’t? Flask includes `jinja2`, a more extensive templating
    system. Here’s a tiny example of how to use `jinja2` and Flask together.
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory called `templates` and a file within it called *flask2.html*
    ([Example 18-8](#ch18_ex07)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-8\. flask2.html
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Next, we write the server code to grab this template, fill in the value of *thing*
    that we passed it, and render it as HTML (I’m dropping the `home()` function here
    to save space). Save this as *flask2.py* ([Example 18-9](#ch18_ex08)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-9\. flask2.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: That `thing = thing` argument means to pass a variable named `thing` to the
    template, with the value of the string `thing`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that *flask1.py* isn’t still running and then start *flask2.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, type this URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s modify our template and save it in the *templates* directory as *flask3.html*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: You can pass this second argument to the `echo` URL in many ways.
  prefs: []
  type: TYPE_NORMAL
- en: Pass an argument as part of the URL path
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using this method, you simply extend the URL itself. Save the code shown in
    [Example 18-10](#ch18_ex10) as *flask3a.py*.
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-10\. flask3a.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, stop the previous test server script if it’s still running and then
    try this new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The URL would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'And you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Or, you can provide the arguments as `GET` parameters, as shown in [Example 18-11](#ch18_ex11);
    save this as *flask3b.py*.
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-11\. flask3b.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the new server script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, use this URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get back what you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: When a `GET` command is used for a URL, any arguments are passed in the form
    ``&*`key1`*=*`val1`*&*`key2`*=*`val2`*&...``
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the dictionary `**` operator to pass multiple arguments to
    a template from a single dictionary (call this *flask3c.py*), as shown in [Example 18-12](#ch18_ex12).
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-12\. flask3c.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: That `**kwargs` acts like `thing=thing, place=place`. It saves some typing if
    there are a lot of input arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The `jinja2` templating language does a lot more than this. If you’ve programmed
    in PHP, you’ll see many similarities.
  prefs: []
  type: TYPE_NORMAL
- en: Django
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`Django`](https://www.djangoproject.com) is a very popular Python web framework,
    especially for large sites. It’s worth learning for many reasons, including frequent
    requests for `django` experience in Python job ads. It includes ORM code (we talked
    about ORMs in [“The Object-Relational Mapper (ORM)”](ch16.html#orms)) to create
    automatic web pages for the typical database *CRUD* functions (create, replace,
    update, delete) that we looked at in [Chapter 16](ch16.html#ch_databases). It
    also includes some automatic admin pages for these, but they’re designed for internal
    use by programmers rather than public web page use. You don’t have to use `Django`’s
    ORM if you prefer another, such as SQLAlchemy, or direct SQL queries.'
  prefs: []
  type: TYPE_NORMAL
- en: Other Frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can compare the frameworks by viewing this [online table](http://bit.ly/web-frames):'
  prefs: []
  type: TYPE_NORMAL
- en: '[`fastapi`](https://fastapi.tiangelo.com) handles both synchronous (WSGI) and
    asynchronous (ASGI) calls, uses type hints, generates test pages, and is well
    documented. Recommended.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`web2py`](http://www.web2py.com) covers much the same ground as `django`,
    with a different style.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`pyramid`](https://trypyramid.com) grew from the earlier `pylons` project,
    and is similar to `django` in scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`turbogears`](http://turbogears.org) supports an ORM, many databases, and
    multiple template languages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`wheezy.web`](http://pythonhosted.org/wheezy.web) is a newer framework optimized
    for performance. It was [faster](http://bit.ly/wheezyweb) than the others in a
    recent test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`molten`](https://moltenframework.com) also uses type hints, but only supports
    WSGI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`apistar`](https://docs.apistar.com) is similar to fastapi, but is more of
    an API validation tool than a web framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`masonite`](https://docs.masoniteproject.com) is a Python version of Ruby
    on Rails, or PHP’s Laravel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The web and databases are the peanut butter and jelly of computing: where you
    find one, you’ll eventually find the other. In real-life Python applications,
    at some point you’ll probably need to provide a web interface (site and/or API)
    to a relational database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You could build your own with:'
  prefs: []
  type: TYPE_NORMAL
- en: A web framework like Bottle or Flask
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A database package, like db-api or SQLAlchemy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A database driver, like pymysql
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead, you could use a web/database package like one of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[connexion](https://connexion.readthedocs.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[datasette](https://datasette.readthedocs.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[sandman2](https://github.com/jeffknupp/sandman2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[flask-restless](https://flask-restless.readthedocs.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or, you could use a framework with built-in database support, like Django.
  prefs: []
  type: TYPE_NORMAL
- en: Your database may not be a relational one. If your data schema varies significantly—columns
    that differ markedly across rows—it might be worthwhile to consider a *schemaless*
    database, such as one of the *NoSQL* databases discussed in [Chapter 16](ch16.html#ch_databases).
    I once worked on a site that initially stored its data in a NoSQL database, switched
    to a relational one, on to another relational one, to a different NoSQL one, and
    then finally back to one of the relational ones.
  prefs: []
  type: TYPE_NORMAL
- en: Web Services and Automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve just looked at traditional web client and server applications, consuming
    and generating HTML pages. Yet the web has turned out to be a powerful way to
    glue applications and data in many more formats than HTML.
  prefs: []
  type: TYPE_NORMAL
- en: webbrowser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start begin a little surprise. Start a Python session in a terminal window
    and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This secretly calls the standard library’s `webbrowser` module and directs your
    browser to an enlightening Python link.^([3](ch18.html#idm45794968721928))
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use this module directly. This program loads the main Python site’s
    page in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This opens it in a new window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'And this opens it in a new tab, if your browser supports tabs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The `webbrowser` makes your browser do all the work.
  prefs: []
  type: TYPE_NORMAL
- en: webview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rather than calling your browser as `webbrowser` does, `webview` displays the
    page in its own window, using your machine’s native GUI. To install on Linux or
    macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'For Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: See the installation [notes](https://oreil.ly/NiYD7) if you have problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example in which I gave it the official US government current time
    site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 18-1](#fig1801) shows the result I got back.'
  prefs: []
  type: TYPE_NORMAL
- en: '![inp2 1801](assets/inp2_1801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18-1\. `webview` display window
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To stop the program, kill the display window.
  prefs: []
  type: TYPE_NORMAL
- en: Web APIs and REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, data is available only within web pages. If you want to access it, you
    need to access the pages through a web browser and read it. If the authors of
    the website made any changes since the last time you visited, the location and
    style of the data might have changed.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of publishing web pages, you can provide data through a web *application
    programming interface* (API). Clients access your service by making requests to
    URLs and getting back responses containing status and data. Instead of HTML pages,
    the data is in formats that are easier for programs to consume, such as JSON or
    XML (refer to [Chapter 16](ch16.html#ch_databases) for more about these formats).
  prefs: []
  type: TYPE_NORMAL
- en: '*Representational State Transfer* (REST) was defined by Roy Fielding in his
    doctoral thesis. Many products claim to have a *REST interface* or a *RESTful
    interface*. In practice, this often only means that they have a *web* interface—definitions
    of URLs to access a web service.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *RESTful* service uses the HTTP *verbs* in specific ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HEAD` gets information about the resource, but not its data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` retrieves the resource’s data from the server. This is the standard method
    used by your browser. `GET` should not be used to create, change, or delete data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST` creates a new resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT` replaces an existing resource, creating it if it doesn’t exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH` partially updates a resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE` deletes. Truth in advertising!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A RESTful client can also request one or more content types from the server
    by using HTTP request headers. For example, a complex service with a REST interface
    might prefer its input and output to be JSON strings.
  prefs: []
  type: TYPE_NORMAL
- en: Crawl and Scrape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you might want a little bit of information—a movie rating, stock
    price, or product availability—but what you need is available only in HTML pages,
    surrounded by ads and extraneous content.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could extract what you’re looking for manually by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Type the URL into your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the remote page to load.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look through the displayed page for the information you want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write it down somewhere.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Possibly repeat the process for related URLs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However, it’s much more satisfying to automate some or all of these steps. An
    automated web fetcher is called a *crawler* or *spider*.^([4](ch18.html#idm45794968478664))
    After the contents have been retrieved from the remote web servers, a *scraper*
    parses it to find the needle in the haystack.
  prefs: []
  type: TYPE_NORMAL
- en: Scrapy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need an industrial-strength combined crawler *and* scraper, [Scrapy](http://scrapy.org)
    is worth downloading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: This installs the module and a standalone command-line `scrapy` program.
  prefs: []
  type: TYPE_NORMAL
- en: Scrapy is a framework, not just a module such as `BeautifulSoup`. It does more,
    but it’s more complex to set up. To learn more about Scrapy, read [“Scrapy at
    a Glance”](https://oreil.ly/8IYoe) and the [tutorial](https://oreil.ly/4H_AW).
  prefs: []
  type: TYPE_NORMAL
- en: BeautifulSoup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you already have the HTML data from a website and just want to extract data
    from it, [`BeautifulSoup`](https://oreil.ly/c43mV) is a good choice. HTML parsing
    is harder than it sounds. This is because much of the HTML on public web pages
    is technically invalid: unclosed tags, incorrect nesting, and other complications.
    If you try to write your own HTML parser by using regular expressions (discussed
    in [“Text Strings: Regular Expressions”](ch12.html#regex)) you’ll soon encounter
    these messes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `BeautifulSoup`, type the following command (don’t forget the final
    `4`, or `pip` will try to install an older version and probably fail):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s use it to get all the links from a web page. The HTML `a` element
    represents a link, and `href` is its attribute representing the link destination.
    In [Example 18-13](#ch18_ex13), we’ll define the function `get_links()` to do
    the grunt work, and a main program to get one or more URLs as command-line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-13\. links.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'I saved this program as *links.py* and then ran this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the first few lines that it printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Requests-HTML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kenneth Reitz, the author of the popular web client package `requests`, has
    written a new scraping library called [requests-html](http://html.python-requests.org)
    (for Python 3.6 and newer versions).
  prefs: []
  type: TYPE_NORMAL
- en: It gets a page and processes its elements, so you can find, for example, all
    of its links, or all the contents or attributes of any HTML element.
  prefs: []
  type: TYPE_NORMAL
- en: It has a clean design, similar to `requests` and other packages by the same
    author. Overall, it may be easier to use than `beautifulsoup` or Scrapy.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s Watch a Movie
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s build a full program.
  prefs: []
  type: TYPE_NORMAL
- en: It searches for videos using an API at the Internet Archive.^([5](ch18.html#idm45794968341672))
    This is one of the few APIs that allows anonymous access *and* should still be
    around after this book is printed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Most web APIs require you to first get an *API key*, and provide it every time
    you access that API. Why? It’s the tragedy of the commons: free resources with
    anonymous access are often overused or abused. That’s why we can’t have nice things.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following program shown in [Example 18-14](#ch18_ex14) does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Prompts you for part of a movie or video title
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searches for it at the Internet Archive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns a list of identifiers, names, and descriptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists them and asks you to select one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displays that video in your web browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save this as *iamovies.py*.
  prefs: []
  type: TYPE_NORMAL
- en: The `search()` function uses `requests` to access the URL, get the results,
    and convert them to JSON. The other functions handle everything else. You’ll see
    usage of list comprehensions, string slices, and other things that you’ve seen
    in previous chapters. (The line numbers are not part of the source; they’ll be
    used in the exercises to locate code pieces.)
  prefs: []
  type: TYPE_NORMAL
- en: Example 18-14\. iamovies.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Here’s what I got when I ran this program and searched for **`eegah`**:^([6](ch18.html#idm45794968318712))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: It displayed the page in my browser, ready to run ([Figure 18-2](#fig1802)).
  prefs: []
  type: TYPE_NORMAL
- en: '![inp2 1802](assets/inp2_1802.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18-2\. Movie search result
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Coming Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next chapter is an extremely practical one, covering the nuts and bolts
    of modern Python development. Learn how to become a steely-eyed, card-carrying
    Pythonista.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Do
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 18.1 If you haven’t installed `flask` yet, do so now. This will also install
    `werkzeug`, `jinja2`, and possibly other packages.
  prefs: []
  type: TYPE_NORMAL
- en: 18.2 Build a skeleton website, using Flask’s debug/reload development web server.
    Ensure that the server starts up for hostname `localhost` on default port `5000`.
    If your computer is already using port 5000 for something else, use another port
    number.
  prefs: []
  type: TYPE_NORMAL
- en: 18.3 Add a `home()` function to handle requests for the home page. Set it up
    to return the string `It's alive!`.
  prefs: []
  type: TYPE_NORMAL
- en: '18.4 Create a Jinja2 template file called *home.html* with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '18.5 Modify your server’s `home()` function to use the *home.html* template.
    Provide it with three `GET` parameters: `thing`, `height`, and `color`.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch18.html#idm45794970286888-marker)) A company founded by Steve Jobs during
    his exile from Apple.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch18.html#idm45794970285336-marker)) Let’s kill a *zombie lie* here. Senator
    (and later, Vice President) Al Gore championed bipartisan legislation and cooperation
    that greatly advanced the early internet, including funding for the group that
    wrote Mosaic. He never claimed that he “invented the internet”; that phrase was
    falsely attributed to him by political rivals as he began running for president
    in 2000.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch18.html#idm45794968721928-marker)) If you don’t see it for some reason,
    visit [xkcd](http://xkcd.com/353).
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch18.html#idm45794968478664-marker)) Unappealing terms to arachnophobes.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch18.html#idm45794968341672-marker)) If you remember, I used another Archive
    API in the main example program we looked at in [Chapter 1](ch01.html#ch_intro).
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch18.html#idm45794968318712-marker)) With Richard Kiel as the caveman,
    years before he was Jaws in a Bond movie.
  prefs: []
  type: TYPE_NORMAL
