- en: Chapter 3\. Type Annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python is a dynamically typed language; types aren’t known until runtime. This
    is an obstacle when trying to write robust code. Since types are embedded in the
    value itself, developers have a very tough time knowing what type they are working
    with. Sure, that name looks likes a `str` today, but what happens if someone makes
    it `bytes`? Assumptions about types are built on shaky ground with dynamically
    typed languages. Hope is not lost, though. In Python 3.5, a brand-new feature
    was introduced: type annotations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type annotations bring your ability to write robust code to a whole new level.
    Guido van Rossum, creator of Python, says it best:'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve learned a painful lesson that for small programs dynamic typing is great.
    For large programs you have to have a more disciplined approach and it helps if
    the language actually gives you that discipline, rather than telling you “Well,
    you can do whatever you want.”^([1](part0006_split_008.html#idm45644756802936))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Type annotations are the more disciplined approach, the extra bit of care you
    need to wrangle larger codebases. In this chapter, you’ll learn how to use type
    annotations, why they are so important, and how to utilize a tool called a typechecker
    to enforce your intentions throughout your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: What Are Type Annotations?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](part0005_split_000.html#types), you got your first glance at
    a type annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](../images/00002.gif)](part0006_split_001.html#co_type_annotations_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The type annotation here is `: datetime.datetime`'
  prefs: []
  type: TYPE_NORMAL
- en: Type annotations are an additional syntax notifying the user of an expected
    type of your variables. These annotations serve as *type hints*; they provide
    hints to the reader, but they are not actually used by the Python language at
    runtime. In fact, you are completely free to ignore the hints. Consider the following
    snippet of code, along with a comment written by the developer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It should be a rare case where you go against a type hint. The author very clearly
    intended a specific use case. If you aren’t going to follow the type annotation,
    you are setting yourself up for problems if the original code changes in a way
    that is incompatible with the types that you are using (such as expecting a certain
    function to work with that type).
  prefs: []
  type: TYPE_NORMAL
- en: 'Python will not throw any error at runtime in this scenario. As a matter of
    fact, it won’t use the type annotations at all during runtime. There is no checking
    or cost for using these when Python executes. These type annotations still serve
    a crucial purpose: informing your readers of the expected type. Maintainers of
    code will know what types they are allowed to use when changing your implementation.
    Calling code will also benefit, as developers will know exactly what type to pass
    in. By implementing type annotations, you reduce friction.'
  prefs: []
  type: TYPE_NORMAL
- en: Put yourself in your future maintainer’s shoes. Wouldn’t it be nice to come
    across code that is intuitive to use? You wouldn’t have to dig through function
    after function to determine usage. You wouldn’t assume a wrong type and then need
    to deal with the fallout of exceptions and wrong behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider another piece of code that takes in employees’ availability and a
    restaurant’s opening time, and then schedules available workers for that day.
    You want to use this piece of code and you see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let’s ignore the implementation for a minute, because I want to focus on first
    impressions. What do you think can get passed into this? Stop, close your eyes,
    and ask yourself what are reasonable types that can be passed in before reading
    on. Is `open_time` a `datetime`, the number of seconds since epoch, or maybe a
    string containing an hour? Is `workers_needed` a list of names, a list of `Worker`
    objects, or something else? If you guess wrong, or aren’t sure, you need to go
    look at either the implementation or calling code, which I’ve established takes
    time and is frustrating.
  prefs: []
  type: TYPE_NORMAL
- en: Let me provide an implementation and you can see how close you were.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You probably guessed that `open_time` is a `datetime`, but did you consider
    that `workers_needed` could have been an `int`? As soon as you see the type annotations,
    you get a much better picture of what’s happening. This reduces cognitive overhead
    and reduces friction for maintainers.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is certainly a step in the right direction, but don’t stop here. If you
    see code like this, consider renaming the variable to `number_of_workers_needed`
    to reflect just what the integer means. In the next chapter, I’ll also explore
    type aliases, which provide an alternate way of expressing yourself.
  prefs: []
  type: TYPE_NORMAL
- en: So far, all the examples I’ve shown have focused on parameters, but you’re also
    allowed to annotate *return types*.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the `schedule_restaurant_open` function. In the middle of that snippet,
    I called `find_workers_available_for_time`. This returns to a variable named `workers`.
    Suppose you want to change the code to pick workers who have gone the longest
    without working, rather than random sampling? Do you have any indication what
    type `workers` is?
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to just look at the function signature, you would see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Nothing in here helps us do your job more quickly. You could guess and the tests
    would tell us, right? Maybe it’s a list of names? Instead of letting the tests
    fail, maybe you should go look through the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Oh no, there’s nothing in here that tells you what type you should be expecting.
    There are three different return statements throughout this code, and you hope
    that they all return the same type. (Surely every `if` statement is tested through
    unit tests to make sure they are consistent, right? Right?) You need to dig deeper.
    You need to look at `worker_database`. You need to look at `is_available` and
    `get_emergency_workers`. You need to look at the `OWNER` variable. Every one of
    these needs to be consistent, or else you’ll need to handle special cases in your
    original code.
  prefs: []
  type: TYPE_NORMAL
- en: And what if these functions also don’t tell you exactly what you need? What
    if you have to go deeper through multiple function calls? Every layer you have
    to go through is another layer of abstraction you need to keep in your brain.
    Every piece of information contributes to cognitive overload. The more cognitive
    overload you are burdened with, the more likely it is that a mistake will happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of this is avoided by annotating a return type. Return types are annotated
    by putting `-> <type>` at the end of the function declaration. Suppose you came
    across this function signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You now know that you should indeed treat workers as a list of strings. No digging
    through databases, function calls, or modules needed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In Python 3.8 and earlier, built-in collection types such as `list`, `dict`,
    and `set` did not allow bracket syntax such as `list[Cookbook]` or `dict[str,int]`.
    Instead, you needed to use type annotations from the typing module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also annotate variables when needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: While I will annotate all of my functions, I typically don’t bother annotating
    variables unless there is something specific I want to convey in my code (such
    as a type that is different than expected). I don’t want to get too into the realm
    of putting type annotations on literally everything—the lack of verbosity is what
    drew many developers to Python in the first place. The types can clutter your
    code, especially when it is blindingly obvious what the type is.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: None of these type annotations provide more value than what is already provided
    by Python itself. Readers of this code know that `"useless"` is a `str`. Remember,
    type annotations are used for type hinting; you are providing notes for the future
    to improve communication. You don’t need to state the obvious everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of Type Annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with every decision you make, you need to weigh the costs and benefits. Thinking
    about types up front helps your deliberate design process, but do type annotations
    provide other benefits? I’ll show you how type annotations really pull their weight
    through tooling.
  prefs: []
  type: TYPE_NORMAL
- en: Autocomplete
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’ve mainly talked about communication to other developers, but your Python
    environment benefits from type annotations as well. Since Python is dynamically
    typed, it is difficult to know what operations are available. With type annotations,
    many Python-aware code editors will autocomplete your variable’s operations.
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 3-1](part0006_split_003.html#figure_3_1), you’ll see a screenshot
    that illustrates a popular code editor, VS Code, detecting a `datetime` and offering
    to autocomplete my variables.
  prefs: []
  type: TYPE_NORMAL
- en: '![VS Code showing autocompletion](../images/00003.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. VS Code showing autocompletion
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Typecheckers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Throughout this book, I’ve been talking about how types communicate intent,
    but have been leaving out one key detail: no programmer has to honor these type
    annotations if they don’t want to. If your code contradicts a type annotation,
    it is probably an error and you’re still relying on humans to catch bugs. I want
    to do better. I want a computer to find these sorts of bugs for me.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I showed this snippet when talking about dynamic typing back in [Chapter 2](part0005_split_000.html#types):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Herein lies the challenge: how do type annotations make your codebase robust,
    when you can’t trust that developers will follow their guidance? In order to be
    robust, you want your code to stand the test of time. To do that, you need some
    sort of tool that can check all your type annotations and flag if anything is
    amiss. That tool is called a typechecker.'
  prefs: []
  type: TYPE_NORMAL
- en: Typecheckers are what allow the type annotations to transcend from communication
    method to a safety net. It is a form of static analysis. *Static analysis tools*
    are tools that run on your source code, and don’t impact your runtime at all.
    You’ll learn more about static analysis tools in [Chapter 20](part0026_split_000.html#static_analysis),
    but for now, I will just explain typecheckers.
  prefs: []
  type: TYPE_NORMAL
- en: First, I need to install one. I’ll use mypy, a very popular typechecker.
  prefs: []
  type: TYPE_NORMAL
- en: '`pip install mypy`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now I’ll create a file named *invalid_type.py* with incorrect behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If I run `mypy` on the command line against that file, I will get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: And just like that, my type annotations become a first line of defense against
    errors. Anytime you make a mistake and go against the author’s intent, a type
    checker will find out and alert you. In fact, in most development environments,
    it’s possible to get this analysis in real time, notifying you of errors as you
    type. (Without reading your mind, this is about as early as a tool can catch errors,
    which is pretty great.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise: Spot the Bug'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are some more examples of mypy catching errors in my code. I want you to
    look for the error in each code snippet and time how long it takes you to find
    the bug or give up, and then check the output listed below the snippet to see
    if you got it right.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the mypy output showing the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Whoops, I’m returning `bytes`, not a `str`. I made a call to encode instead
    of decode, and got my return type all mixed up. I can’t even tell you how many
    times I made this mistake moving Python 2.7 code to Python 3\. Thank goodness
    for typecheckers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The mypy error is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Another innocent mistake I made by calling `update` on a list instead of `extend`.
    These sorts of mistakes can happen quite easily when moving between collection
    types (in this case from a `set`, which does offer an `update` method, to a `list`,
    which doesn’t).
  prefs: []
  type: TYPE_NORMAL
- en: 'One more example to wrap it up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The mypy error is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This one is subtle. I’m returning `None` when a string value is expected. If
    all the code is just checking conditionally for the restaurant name to make decisions,
    like I do above, tests will pass, and nothing will be amiss. This is true even
    for the negative case, because `None` is absolutely fine to check for in `if`
    statements (it is false-y). This is an example of Python’s dynamic typing coming
    back to bite us.
  prefs: []
  type: TYPE_NORMAL
- en: However, a few months from now, some developer will start trying to use this
    return value as a string, and as soon as a new city needs to be added, the code
    starts trying to operate on `None` values, which causes exceptions to be raised.
    This is not very robust; there is a latent code bug just waiting to happen. But
    with typecheckers, you can stop worrying about this and catch these mistakes early.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'With typecheckers available, do you even need tests? You certainly do. Typecheckers
    catch a specific class of errors: those of incompatible types. There are plenty
    of other classes of errors that you still need to test for. Treat typecheckers
    as just one tool in your arsenal of bug identification.'
  prefs: []
  type: TYPE_NORMAL
- en: In all of these examples, typecheckers found a bug just waiting to happen. It
    doesn’t matter if the bug would have been caught by tests, or by code review,
    or by customers; typecheckers catch it earlier, which saves time and money. Typecheckers
    start giving us the benefit of a statically typed language, while still allowing
    the Python runtime to remain dynamically typed. This truly is the best of both
    worlds.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of the chapter, you’ll find a quote from Guido van Rossum.
    While working at Dropbox, he found that large codebases struggled without having
    a safety net. He became a huge proponent for driving type hinting into the language.
    If you want your code to communicate intent and catch errors, start adopting type
    annotations and typechecking today.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion Topic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Has your codebase had an error slip through that could have been caught by typecheckers?
    How much do those errors cost you? How many times has it been a code review or
    an integration test that caught the bug? How about bugs that made it to production?
  prefs: []
  type: TYPE_NORMAL
- en: When to Use Type Annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, before you go adding types to everything, I need to talk about the cost.
    Adding types is simple, but can be overdone. As users try to test and play around
    with code, they may start fighting the typechecker because they feel bogged down
    when writing all the type annotations. There is an adoption cost for users who
    are just getting started with type hinting. I also mentioned that I don’t type
    annotate everything. I won’t annotate all my variables, especially if the type
    is obvious. I also won’t typically type annotate parameters for every small private
    method in a class.
  prefs: []
  type: TYPE_NORMAL
- en: When should you use typecheckers?
  prefs: []
  type: TYPE_NORMAL
- en: With functions that you expect other modules or users to call (e.g., public
    APIs, library entry points, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you want to highlight where a type is complicated (e.g., a dictionary of
    strings mapped to lists of objects) or unintuitive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Areas where mypy complains that you need a type (typically when assigning to
    an empty collection—it’s easier to go along with the tool than against it)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A typechecker will infer types for any value that it can, so even if you don’t
    fill in all types, you still reap the benefits. I will cover configuring typecheckers
    in [Chapter 6](part0009_split_000.html#typechecker).
  prefs: []
  type: TYPE_NORMAL
- en: Closing Thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There was consternation in the Python community when type hinting was introduced.
    Developers were afraid that Python was becoming a statically typed language like
    Java or C++. They worried that adding types everywhere would slow them down and
    destroy the benefits of the dynamically typed language they fell in love with.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, type hints are just that: hints. They are completely optional. I don’t
    recommend them for small scripts, or any piece of code that isn’t going to live
    a very long time. But if your code needs to be maintainable for the long term,
    type hints are invaluable. They serve as a communication method, make your environment
    smarter, and detect errors when combined with typecheckers. They protect the original
    author’s intent. When annotating types, you decrease the burden a reader has in
    understanding your code. You reduce the need to read the implementation of a function
    to know what its doing. Code is complicated, and you should be minimizing how
    much code a developer needs to read. By using well-thought-out types, you reduce
    surprise and increase reading comprehension.'
  prefs: []
  type: TYPE_NORMAL
- en: The typechecker is also a confidence builder. Remember, in order for your code
    to be robust, it has to be easy to change, rewrite, and delete if needed. The
    typechecker can allow developers to do that with less trepidation. If something
    was relying on a type or field that got changed or deleted, the typechecker will
    flag the offending code as incompatible. Automated tooling makes you and your
    future collaborators’ jobs simpler; fewer bugs will make it to production and
    features will get delivered quicker.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’re going to go beyond basic type annotations and learn
    how to build a vocabulary of all new types. These types will help you constrain
    behavior in your codebase, limiting the ways things can go wrong. I’ve only scratched
    the surface of how useful type annotations can be.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](part0006_split_000.html#idm45644756802936-marker)) Guido van Rossum. “A
    Language Creators’ Conversation.” PuPPy (Puget Sound Programming Python) Annual
    Benefit 2019\. [*https://oreil.ly/1xf01*](https://oreil.ly/1xf01).
  prefs: []
  type: TYPE_NORMAL
