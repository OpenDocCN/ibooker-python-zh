- en: Chapter 3\. FastAPI Tour
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章 FastAPI 指南
- en: FastAPI is a modern, fast (high-performance) web framework for building APIs
    with Python 3.6+ based on standard Python type hints.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: FastAPI 是一个现代的、快速（高性能）的 Web 框架，用于使用 Python 3.6+ 标准的类型提示构建 API。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sebastián Ramírez, creator of FastAPI
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: FastAPI 的创始人 Sebastián Ramírez
- en: Preview
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预览
- en: '[FastAPI](https://fastapi.tiangolo.com) was announced in 2018 by [Sebastián
    Ramírez](https://tiangolo.com). It’s more modern in many senses than most Python
    web frameworks—taking advantage of features that have been added to Python 3 in
    the last few years. This chapter is a quick overview of FastAPI’s main features,
    with emphasis on the first things that you’ll want to know: how to handle web
    requests and responses.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[FastAPI](https://fastapi.tiangolo.com) 由 [Sebastián Ramírez](https://tiangolo.com)
    在 2018 年发布。在许多方面，它比大多数 Python Web 框架更现代化——利用了最近几年内添加到 Python 3 中的功能。本章是 FastAPI
    主要特性的快速概述，重点是你需要了解的首要内容：如何处理 Web 请求和响应。'
- en: What Is FastAPI?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FastAPI 是什么？
- en: Like any web framework, FastAPI helps you build web applications. Every framework
    is designed to make some operations easier—by features, omissions, and defaults.
    As the name implies, FastAPI targets development of web APIs, although you can
    use it for traditional web content applications as well.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何 Web 框架一样，FastAPI 帮助您构建 Web 应用程序。每个框架都设计了一些操作以使某些操作更加简便——通过功能、省略和默认设置。顾名思义，FastAPI
    的目标是开发 Web API，尽管您也可以将其用于传统的 Web 内容应用程序。
- en: 'The FastAPI website claims these advantages:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 网站声称具有以下优势：
- en: Performance
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 性能
- en: As fast as Node.js and Go in some cases, unusual for Python frameworks.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，速度与 Node.js 和 Go 一样快，这在 Python 框架中是不寻常的。
- en: Faster development
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 更快的开发速度
- en: No sharp edges or oddities.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 没有锋利的边缘或怪异行为。
- en: Better code quality
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的代码质量
- en: Type hinting and models help reduce bugs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示和模型有助于减少错误。
- en: Autogenerated documentation and test pages
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的文档和测试页面
- en: Much easier than hand-editing OpenAPI descriptions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 比手动编辑 OpenAPI 描述更容易。
- en: 'FastAPI uses the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 使用以下内容：
- en: Python type hints
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 类型提示
- en: Starlette for the web machinery, including async support
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Starlette 用于 Web 机制，包括异步支持
- en: Pydantic for data definitions and validation
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pydantic 用于数据定义和验证
- en: Special integration to leverage and extend the others
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊集成以利用和扩展其他功能
- en: This combination makes a pleasing development environment for web applications,
    especially RESTful web services.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种组合为 Web 应用程序，特别是 RESTful Web 服务，提供了令人愉悦的开发环境。
- en: A FastAPI Application
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个 FastAPI 应用程序
- en: 'Let’s write a teeny FastAPI application—a web service with a single endpoint.
    For now, we’re in what I’ve called the Web layer, handling only web requests and
    responses. First, install the basic Python packages that we’ll be using:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个微小的 FastAPI 应用——一个只有一个端点的 Web 服务。目前，我们处于我所谓的 Web 层，仅处理 Web 请求和响应。首先，安装我们将要使用的基本
    Python 包：
- en: 'The [FastAPI](https://fastapi.tiangolo.com) framework: `pip install fastapi`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[FastAPI](https://fastapi.tiangolo.com) 框架：`pip install fastapi`'
- en: 'The [Uvicorn](https://www.uvicorn.org) web server: `pip install uvicorn`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Uvicorn](https://www.uvicorn.org) Web 服务器：`pip install uvicorn`'
- en: 'The [HTTPie](https://httpie.io) text web client: `pip install httpie`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[HTTPie](https://httpie.io) 文本 Web 客户端：`pip install httpie`'
- en: 'The [Requests](https://requests.readthedocs.io) synchronous web client package:
    `pip install requests`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Requests](https://requests.readthedocs.io) 同步 Web 客户端包：`pip install requests`'
- en: 'The [HTTPX](https://www.python-httpx.org) synchronous/asynchronous web client
    package: `pip install httpx`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[HTTPX](https://www.python-httpx.org) 同步/异步 Web 客户端包：`pip install httpx`'
- en: Although [curl](https://curl.se) is the best known text web client, I think
    HTTPie is easier to use. Also, it defaults to JSON encoding and decoding, which
    is a better match for FastAPI. Later in this chapter, you’ll see a screenshot
    that includes the syntax of the curl command line needed to access a particular
    endpoint.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 [curl](https://curl.se) 是最著名的文本 Web 客户端，但我认为 HTTPie 更易于使用。此外，它默认使用 JSON 编码和解码，这与
    FastAPI 更匹配。本章后面，你将看到一个包含访问特定端点所需 curl 命令行语法的截图。
- en: Let’s shadow an introverted web developer in [Example 3-1](#ex-3-1) and save
    this code as the file *hello.py*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 [示例 3-1](#ex-3-1) 中跟随一个内向的 Web 开发者，并将此代码保存为文件 *hello.py*。
- en: Example 3-1\. A shy endpoint (hello.py)
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-1\. 一个害羞的端点（hello.py）
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here are some points to notice:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是需要注意的一些要点：
- en: '`app` is the top-level FastAPI object that represents the whole web application.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app` 是代表整个 Web 应用程序的顶级 FastAPI 对象。'
- en: '`@app.get("/hi")` is a *path decorator*. It tells FastAPI the following:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@app.get("/hi")` 是一个 *路径装饰器*。它告诉 FastAPI 如下内容：'
- en: A request for the URL `"/hi"` on this server should be directed to the following
    function.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于此服务器上的 `"/hi"` URL 的请求应该被指向以下函数。
- en: This decorator applies only to the HTTP `GET` verb. You can also respond to
    a `"/hi"` URL sent with the other HTTP verbs (`PUT`, `POST`, etc.), each with
    a separate function.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此装饰器仅适用于 HTTP 的 `GET` 动词。您还可以使用其他 HTTP 动词（`PUT`、`POST` 等）响应 `"/hi"` URL，每个对应一个单独的函数。
- en: '`def greet()` is a *path function*—the main point of contact with HTTP requests
    and responses. In this example, it has no arguments, but the following sections
    show that there’s much more under the FastAPI hood.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def greet()` 是一个 *path function*，它是 HTTP 请求和响应的主要接触点。在本例中，它没有参数，但后续章节将展示 FastAPI
    更多功能。'
- en: 'The next step is to run this web application in a web server. FastAPI itself
    does not include a web server but recommends Uvicorn. You can start Uvicorn and
    the FastAPI web application in two ways: externally or internally.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在 Web 服务器中运行此 Web 应用程序。FastAPI 本身不包含 Web 服务器，但推荐使用 Uvicorn。您可以以两种方式启动 Uvicorn
    和 FastAPI Web 应用程序：外部或内部。
- en: To start Uvicorn externally, via the command line, see [Example 3-2](#ex-3-2).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过命令行外部启动 Uvicorn，请参阅 [示例 3-2](#ex-3-2)。
- en: Example 3-2\. Start Uvicorn with the command line
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-2\. 使用命令行启动 Uvicorn
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `hello` refers to the *hello.py* file, and `app` is the FastAPI variable
    name within it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello` 指的是 *hello.py* 文件，而 `app` 是其中的 FastAPI 变量名。'
- en: Alternatively, you can start Uvicorn internally in the application itself, as
    in [Example 3-3](#ex-3-3).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在应用程序本身内部启动 Uvicorn，如 [示例 3-3](#ex-3-3)。
- en: Example 3-3\. Start Uvicorn internally
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-3\. 在内部启动 Uvicorn
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In either case, that `reload` tells Uvicorn to restart the web server if *hello.py*
    changes. In this chapter, we’re going to use this automatic reloading a lot.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在任一情况下，`reload` 告诉 Uvicorn 如果 *hello.py* 更改了，重新启动 Web 服务器。在本章中，我们将频繁使用此自动重新加载功能。
- en: Either case will use port 8000 on your machine (named `localhost`) by default.
    Both the external and internal methods have `host` and `port` arguments if you’d
    prefer something else.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用外部还是内部方法，默认情况下都将在您的计算机（名为 `localhost`）上使用端口 8000。如果您希望使用其他设置，两种方法都有 `host`
    和 `port` 参数。
- en: Now the server has a single endpoint (*/hi*) and is ready for requests.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务器有一个单一的端点（*/hi*），并准备接受请求。
- en: 'Let’s test with multiple web clients:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用多个 web 客户端测试：
- en: For the browser, type the URL in the top location bar.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于浏览器，在顶部地址栏输入 URL。
- en: For HTTPie, type the command shown (the `$` stands for whatever command prompt
    you have for your system shell).
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 HTTPie，请输入显示的命令（`$` 表示您系统 shell 的命令提示符）。
- en: For Requests or HTTPX, use Python in interactive mode, and type after the `>>>`
    prompt.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Requests 或 HTTPX，请在交互模式下使用 Python，并在 `>>>` 提示后输入。
- en: As mentioned in the Preface, what you type is in a
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如前言所述，您输入的内容位于一个
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: and the output is in a
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 并且输出在一个
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Examples [3-4](#ex-3-4) through [3-7](#ex-3-7) show different ways to test the
    web server’s brand-new */hi* endpoint.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 [3-4](#ex-3-4) 到 [3-7](#ex-3-7) 展示了测试 Web 服务器全新 */hi* 端点的不同方式。
- en: Example 3-4\. Test /hi in the browser
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-4\. 在浏览器中测试 /hi
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Example 3-5\. Test /hi with Requests
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-5\. 使用 Requests 测试 /hi
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Example 3-6\. Test /hi with HTTPX, which is almost identical to Requests
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-6\. 使用 HTTPX 测试 /hi，这几乎与 Requests 相同
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-66
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It doesn’t matter if you use Requests or HTTPX to test FastAPI routes. But [Chapter 13](ch13.html#ch13)
    shows cases where HTTPX is useful when making other asynchronous calls. So the
    rest of the examples in this chapter use Requests.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用 Requests 还是 HTTPX 来测试 FastAPI 路由都无所谓。但是 [第13章](ch13.html#ch13) 展示了在进行其他异步调用时使用
    HTTPX 的情况。因此，本章的其余示例使用 Requests。
- en: Example 3-7\. Test /hi with HTTPie
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-7\. 使用 HTTPie 测试 /hi
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Use the `-b` argument in [Example 3-8](#ex-3-8) to skip the response headers
    and print only the body.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-b` 参数在 [示例 3-8](#ex-3-8) 中跳过响应头，并只打印主体。
- en: Example 3-8\. Test /hi with HTTPie, printing only the response body
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-8\. 使用 HTTPie 测试 /hi，仅打印响应主体
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[Example 3-9](#ex-3-9) gets the full request headers as well as the response
    with `-v`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-9](#ex-3-9) 获取完整的请求头和响应，带有 `-v`。'
- en: Example 3-9\. Test /hi with HTTPie and get everything
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-9\. 使用 HTTPie 测试 /hi 并获取所有内容
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Some examples in this book show the default HTTPie output (response headers
    and body), and others show just the body.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的一些示例显示了默认的 HTTPie 输出（响应头和主体），而其他示例仅显示主体。
- en: HTTP Requests
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 请求
- en: '[Example 3-9](#ex-3-9) included only one specific request: a `GET` request
    for the */hi* URL on the server `localhost`, port `8000`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-9](#ex-3-9) 仅包含一个特定请求：对 `localhost` 服务器上端口 `8000` 的 `GET` 请求 */hi* URL。'
- en: Web requests squirrel data in different parts of an HTTP request, and FastAPI
    lets you access them smoothly. From the sample request in [Example 3-9](#ex-3-9),
    [Example 3-10](#ex-3-10) shows the HTTP request that the `http` command sent to
    the web server.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Web 请求在 HTTP 请求的不同部分中存储数据，而 FastAPI 允许您顺利访问它们。从 [示例 3-9](#ex-3-9) 中的示例请求开始，[示例 3-10](#ex-3-10)
    显示了 `http` 命令发送到 Web 服务器的 HTTP 请求。
- en: Example 3-10\. An HTTP request
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-10\. HTTP 请求
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This request contains the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本请求包含以下内容：
- en: The verb (`GET`) and path (`/hi`)
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动词 (`GET`) 和路径 (`/hi`)
- en: Any *query parameters* (text after any `?` in this case, none)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何*查询参数*（在此例中任何 `?` 后面的文本，无）
- en: Other HTTP headers
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他 HTTP 标头
- en: No request body content
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有请求体内容
- en: 'FastAPI unsquirrels these into handy definitions:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 将其解析为方便的定义：
- en: '`Header`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Header`'
- en: The HTTP headers
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 标头
- en: '`Path`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`'
- en: The URL
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: URL
- en: '`Query`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Query`'
- en: The query parameters (after the `?` at the end of the URL)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 查询参数（在 URL 结尾的 `?` 后面）
- en: '`Body`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Body`'
- en: The HTTP body
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP body
- en: Note
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The way that FastAPI provides data from various parts of the HTTP requests is
    one of its best features and an improvement on how most Python web frameworks
    do it. All the arguments that you need can be declared and provided directly inside
    the path function, using the definitions in the preceding list (`Path`, `Query`,
    etc.), and by functions that you write. This uses a technique called *dependency
    injection*, which will be discussed as we go along and expanded on in [Chapter 6](ch06.html#ch06).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 提供数据来自 HTTP 请求的各个部分的方式是其最佳特性之一，也是大多数 Python Web 框架改进的一部分。所有需要的参数可以在路径函数内声明和直接提供，使用之前列表中的定义
    (`Path`, `Query` 等)，以及你编写的函数。这使用了一种称为*依赖注入*的技术，我们将在接下来的内容中讨论，并在 [第六章](ch06.html#ch06)
    中详细展开。
- en: 'Let’s make our earlier application a little more personal by adding a parameter
    called `who` that addresses that plaintive `Hello?` to someone. We’ll try different
    ways to pass this new parameter:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加一个名为 `who` 的参数，让我们的早期应用程序变得更加个性化，以回应那个哀求般的 `Hello?`。我们将尝试不同的方法来传递这个新参数：
- en: In the URL *path*
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 URL *路径* 中
- en: As a *query* parameter, after the `?` in the URL
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为*查询*参数，在 URL 的 `?` 后面
- en: In the HTTP *body*
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 HTTP *body* 中
- en: As an HTTP *header*
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 HTTP *标头*
- en: URL Path
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: URL 路径
- en: Edit *hello.py* in [Example 3-11](#ex-3-11).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 3-11](#ex-3-11) 中编辑 *hello.py*。
- en: Example 3-11\. Return the greeting path
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-11\. 返回问候路径
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once you save this change from your editor, Uvicorn should restart. (Otherwise,
    we’d create *hello2.py*, etc. and rerun Uvicorn each time.) If you have a typo,
    keep trying until you fix it, and Uvicorn won’t give you a hard time.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦从编辑器保存此更改，Uvicorn 应该重新启动。（否则，我们将创建 *hello2.py* 等，并每次重新运行 Uvicorn。）如果有拼写错误，请不断尝试直到修复，Uvicorn
    不会对你造成困扰。
- en: Adding that `{who}` in the URL (after `@app.get`) tells FastAPI to expect a
    variable named `who` at that position in the URL. FastAPI then assigns it to the
    `who` argument in the following `greet()` function. This shows coordination between
    the path decorator and the path function.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 URL 中添加 `{who}`（在 `@app.get` 后面）告诉 FastAPI 在该位置期望一个名为 `who` 的变量。FastAPI 然后将其分配给下面
    `greet()` 函数中的 `who` 参数。这显示了路径装饰器和路径函数之间的协调。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Do not use a Python f-string for the amended URL string (`"/hi/{who}"`) here.
    The curly brackets are used by FastAPI itself to match URL pieces as path parameters.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此处不要使用 Python f-string 来修改 URL 字符串 (`"/hi/{who}"`)。大括号由 FastAPI 本身用于匹配作为路径参数的
    URL 片段。
- en: In Examples [3-12](#ex-3-12) through [3-14](#ex-3-14), test this modified endpoint
    with the various methods discussed earlier.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例 [3-12](#ex-3-12) 到 [3-14](#ex-3-14) 中，使用先前讨论的各种方法测试这个修改后的端点。
- en: Example 3-12\. Test /hi/Mom in the browser
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-12\. 在浏览器中测试 /hi/Mom
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Example 3-13\. Test /hi/Mom with HTTPie
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-13\. 使用 HTTPie 测试 /hi/Mom
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Example 3-14\. Test /hi/Mom with Requests
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-14\. 使用 Requests 测试 /hi/Mom
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In each case, the string `"Mom"` is passed as part of the URL, passed to the
    `greet()` path function as the `who` variable, and returned as part of the response.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，字符串 `"Mom"` 被作为 URL 的一部分传递，并作为 `greet()` 路径函数中的 `who` 变量传递，并作为响应的一部分返回。
- en: The response in each case is the JSON string (with single or double quotes,
    depending on which test client you used) `"Hello? Mom?"`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，响应都是 JSON 字符串（取决于使用的测试客户端是单引号还是双引号） `"Hello? Mom?"`。
- en: Query Parameters
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询参数
- en: '*Query parameters* are the `*name=value*` strings after the `?` in a URL, separated
    by `&` characters. Edit *hello.py* again in [Example 3-15](#ex-3-15).'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*查询参数*是在 URL 中 `*name=value*` 字符串之后的 `?` 后面，用 `&` 字符分隔。在 [示例 3-15](#ex-3-15)
    中再次编辑 *hello.py*。'
- en: Example 3-15\. Return the greeting query parameter
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-15\. 返回问候查询参数
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The endpoint function is defined as `greet(who)` again, but `{who}` isn’t in
    the URL on the previous decorator line this time, so FastAPI now assumes that
    `who` is a query parameter. Test with Examples [3-16](#ex-3-16) and [3-17](#ex-3-17).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 端点函数再次被定义为 `greet(who)`，但是这次在前一个装饰器行中 URL 上没有 `{who}`，所以 FastAPI 现在假设 `who`
    是一个查询参数。测试示例 [3-16](#ex-3-16) 和 [3-17](#ex-3-17)。
- en: Example 3-16\. Test [Example 3-15](#ex-3-15) with your browser
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-16\. 使用浏览器测试 [示例 3-15](#ex-3-15)
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Example 3-17\. Test [Example 3-15](#ex-3-15) with HTTPie
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-17\. 使用 HTTPie 测试 [示例 3-15](#ex-3-15)
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In [Example 3-18](#ex-3-18), you can call HTTPie with a query parameter argument
    (note the `==`).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 3-18](#ex-3-18) 中，您可以使用查询参数调用 HTTPie（注意 `==`）。
- en: Example 3-18\. Test [Example 3-15](#ex-3-15) with HTTPie and params
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-18\. 使用 HTTPie 和参数测试 [示例 3-15](#ex-3-15)
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can have more than one of these arguments for HTTPie, and it’s easier to
    type these as space-separated arguments.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 HTTPie 中使用多个这些参数，将它们作为空格分隔的参数更容易输入。
- en: Examples [3-19](#ex-3-19) and [3-20](#ex-3-20) show the same alternatives for
    Requests.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 [3-19](#ex-3-19) 和 [3-20](#ex-3-20) 展示了 Requests 的相同替代方案。
- en: Example 3-19\. Test [Example 3-15](#ex-3-15) with Requests
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-19\. 使用 Requests 测试 [示例 3-15](#ex-3-15)
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Example 3-20\. Test [Example 3-15](#ex-3-15) with Requests and params
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-20\. 使用 Requests 和参数测试 [示例 3-15](#ex-3-15)
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In each case, you provide the `"Mom"` string in a new way, and get it to the
    path function and through to the eventual response.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，您以一种新的方式提供字符串 `"Mom"`，并将其传递给路径函数并通过最终的响应。
- en: Body
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主体
- en: We can provide path or query parameters to a `GET` endpoint, but not values
    from the request body. In HTTP, `GET` is supposed to be *idempotent*—a computery
    term for *ask the same question, get the same answer*. HTTP `GET` is supposed
    to only return stuff. The request body is used to send stuff to the server when
    creating (`POST`) or updating (`PUT` or `PATCH`). [Chapter 9](ch09.html#ch09)
    shows a way around this.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向 `GET` 端点提供路径或查询参数，但不能从请求体中获取值。在 HTTP 中，`GET` 应该是 *幂等* 的——一个计算机术语，意思是 *询问相同的问题，得到相同的答案*。HTTP
    `GET` 应该只返回内容。请求体用于在创建（`POST`）或更新（`PUT` 或 `PATCH`）时将内容发送到服务器。[第 9 章](ch09.html#ch09)
    展示了绕过此限制的方法。
- en: So, in [Example 3-21](#ex-3-21), let’s change the endpoint from a `GET` to a
    `POST`. (Technically, we’re not creating anything, so a `POST` isn’t kosher, but
    if the RESTful Overlords sue us, then hey, check out the cool courthouse.)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 [示例 3-21](#ex-3-21) 中，让我们将端点从 `GET` 更改为 `POST`。（严格来说，我们没有创建任何内容，所以 `POST`
    不合适，但如果 RESTful 大师起诉我们，那么嘿，看看酷炫的法院。）
- en: Example 3-21\. Return the greeting body
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-21\. 返回问候主体
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'That `Body(embed=True)` is needed to tell FastAPI that, this time, we get the
    value of `who` from the JSON-formatted request body. The `embed` part means that
    it should look like `{"who": "Mom"}` rather than just `"Mom"`.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '这次需要 `Body(embed=True)` 告诉 FastAPI，我们这次从 JSON 格式的请求体中获取 `who` 的值。`embed` 部分意味着它应该像
    `{"who": "Mom"}` 这样看起来，而不只是 `"Mom"`。'
- en: Try testing with HTTPie in [Example 3-22](#ex-3-22), using `-v` to show the
    generated request body (and note the single `=` parameter to indicate JSON body
    data).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在 [示例 3-22](#ex-3-22) 中使用 HTTPie 进行测试，使用 `-v` 显示生成的请求体（注意单个 `=` 参数表示 JSON
    主体数据）。
- en: Example 3-22\. Test [Example 3-21](#ex-3-21) with HTTPie
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-22\. 使用 HTTPie 测试 [示例 3-21](#ex-3-21)
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: And finally, test with Requests in [Example 3-23](#ex-3-23), which uses its
    `json` argument to pass JSON-encoded data in the request body.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 [示例 3-23](#ex-3-23) 中使用 Requests 进行测试，其中使用其 `json` 参数将 JSON 编码数据传递到请求体中。
- en: Example 3-23\. Test [Example 3-21](#ex-3-21) with Requests
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-23\. 使用 Requests 测试 [示例 3-21](#ex-3-21)
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: HTTP Header
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP 头信息
- en: Finally, let’s try passing the greeting argument as an HTTP header in [Example 3-24](#ex-3-24).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 [示例 3-24](#ex-3-24) 中尝试将问候参数作为 HTTP 头信息传递。
- en: Example 3-24\. Return the greeting header
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-24\. 返回问候头信息
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let’s test this one just with HTTPie in [Example 3-25](#ex-3-25). It uses `*name:value*`
    to specify an HTTP header.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 [示例 3-25](#ex-3-25) 中只使用 HTTPie 进行测试。它使用 `*name:value*` 来指定 HTTP 头信息。
- en: Example 3-25\. Test [Example 3-24](#ex-3-24) with HTTPie
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-25\. 使用 HTTPie 测试 [示例 3-24](#ex-3-24)
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: FastAPI converts HTTP header keys to lowercase, and converts a hyphen (`-`)
    to an underscore (`_`). So you could print the value of the HTTP `User-Agent`
    header like this in Examples [3-26](#ex-3-26) and [3-27](#ex-3-27).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 将 HTTP 头键转换为小写，并将连字符 (`-`) 转换为下划线 (`_`)。因此，您可以在示例 [3-26](#ex-3-26) 和
    [3-27](#ex-3-27) 中像这样打印 HTTP `User-Agent` 头信息的值。
- en: Example 3-26\. Return the `User-Agent` header (hello.py)
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-26\. 返回 `User-Agent` 头信息（hello.py）
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Example 3-27\. Test the `User-Agent` header with HTTPie
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-27\. 使用 HTTPie 测试 `User-Agent` 头信息
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Multiple Request Data
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个请求数据
- en: You can use more than one of these methods in the same path function. That is,
    you can get data from the URL, query parameters, the HTTP body, HTTP headers,
    cookies, and so on. And you can write your own dependency functions that process
    and combine them in special ways, such as for pagination or authentication. You’ll
    see some of these in [Chapter 6](ch06.html#ch06) and in various chapters in [Part III](part03.html#part3).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在同一个路径函数中使用多个方法。也就是说，您可以从 URL、查询参数、HTTP 主体、HTTP 头部、cookie 等获取数据。并且您可以编写自己的依赖函数，以特殊方式处理和组合它们，例如用于分页或身份验证。您将在
    [第 6 章](ch06.html#ch06) 和 [第 III 部分](part03.html#part3) 的各个章节中看到其中的一些。
- en: Which Method Is Best?
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哪种方法最好？
- en: 'Here are a few recommendations:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些建议：
- en: When passing arguments in the URL, following RESTful guidelines is standard
    practice.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在传递 URL 中的参数时，遵循 RESTful 准则是标准做法。
- en: Query strings are usually used to provide optional arguments, like pagination.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询字符串通常用于提供可选参数，如分页。
- en: The body is usually used for larger inputs, like whole or partial models.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常用于更大输入的主体，例如整体或部分模型。
- en: In each case, if you provide type hints in your data definitions, your arguments
    will be automatically type-checked by Pydantic. This ensures that they’re both
    present and correct.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，如果您在数据定义中提供类型提示，您的参数将由 Pydantic 自动进行类型检查。这确保它们既存在又正确。
- en: HTTP Responses
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 响应
- en: 'By default, FastAPI converts whatever you return from your endpoint function
    to JSON; the HTTP response has a header line `Content-type: application/json`.
    So, although the `greet()` function initially returns the string `"Hello? World?"`,
    FastAPI converts it to JSON. This is one of the defaults chosen by FastAPI to
    streamline API development.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '默认情况下，FastAPI 将从端点函数返回的任何内容转换为 JSON；HTTP 响应具有标题行 `Content-type: application/json`。因此，虽然
    `greet()` 函数最初返回字符串 `"Hello? World?"`，但 FastAPI 将其转换为 JSON。这是 FastAPI 为简化 API
    开发选择的默认之一。'
- en: In this case, the Python string `"Hello? World?"` is converted to its equivalent
    JSON string `"Hello? World?"`, which is the same darn string. But anything that
    you return is converted to JSON, whether built-in Python types or Pydantic models.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Python 字符串 `"Hello? World?"` 被转换为其等效的 JSON 字符串 `"Hello? World?"`，它仍然是同样的字符串。但是无论您返回什么，FastAPI
    都会将其转换为 JSON，无论是内置的 Python 类型还是 Pydantic 模型。
- en: Status Code
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态码
- en: By default, FastAPI returns a `200` status code; exceptions raise `4*xx*` codes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，FastAPI 返回 `200` 状态码；异常会引发 `4*xx*` 代码。
- en: In the path decorator, specify the HTTP status code that should be returned
    if all goes well (exceptions will generate their own codes and override it). Add
    the code from [Example 3-28](#ex-3-28) somewhere in your *hello.py* (just to avoid
    showing the whole file again and again), and test it with [Example 3-29](#ex-3-29).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在路径装饰器中，指定应该在一切顺利时返回的 HTTP 状态码（异常将生成自己的代码并覆盖它）。将 [示例 3-28](#ex-3-28) 中的代码添加到您的
    *hello.py* 中的某个位置，并使用 [示例 3-29](#ex-3-29) 进行测试。
- en: Example 3-28\. Specify the HTTP status code (add to hello.py)
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-28\. 指定 HTTP 状态码（添加到 hello.py）
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Example 3-29\. Test the HTTP status code
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-29\. 测试 HTTP 状态码
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Headers
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 头部
- en: You can inject HTTP response headers, as in [Example 3-30](#ex-3-30) (you don’t
    need to return `response`).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像 [示例 3-30](#ex-3-30) 中那样注入 HTTP 响应头部（您不需要返回 `response`）。
- en: Example 3-30\. Set the HTTP headers (add to hello.py)
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-30\. 设置 HTTP 头部（添加到 hello.py）
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Let’s see if it worked ([Example 3-31](#ex-3-31)).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看是否成功（[示例 3-31](#ex-3-31)）。
- en: Example 3-31\. Test the response HTTP headers
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-31\. 测试响应的 HTTP 头部
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Response Types
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应类型
- en: 'Response types (import these classes from `fastapi.responses`) include the
    following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 响应类型（从 `fastapi.responses` 导入这些类）包括以下内容：
- en: '`JSONResponse` (the default)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`JSONResponse`（默认）'
- en: '`HTMLResponse`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTMLResponse`'
- en: '`PlainTextResponse`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlainTextResponse`'
- en: '`RedirectResponse`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RedirectResponse`'
- en: '`FileResponse`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileResponse`'
- en: '`StreamingResponse`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StreamingResponse`'
- en: I’ll say more about the last two in [Chapter 15](ch15.html#ch15).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在 [第 15 章](ch15.html#ch15) 中进一步讨论最后两点。
- en: 'For other output formats (also known as *MIME types*), you can use a generic
    `Response` class, which needs the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他输出格式（也称为 *MIME 类型*），您可以使用一个通用的 `Response` 类，需要以下内容：
- en: '`content`'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`content`'
- en: String or bytes
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串或字节
- en: '`media_type`'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`media_type`'
- en: The string MIME type
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串 MIME 类型
- en: '`status_code`'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`status_code`'
- en: HTTP integer status code
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 整数状态码
- en: '`headers`'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`headers`'
- en: A `dict` of strings
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字符串 `dict`
- en: Type Conversion
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型转换
- en: The path function can return anything, and by default (using `JSONResponse`),
    FastAPI will convert it to a JSON string and return it, with the matching HTTP
    response headers `Content-Length` and `Content-Type`. This includes any Pydantic
    model class.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 路径函数可以返回任何内容，默认情况下（使用`JSONResponse`），FastAPI 将其转换为 JSON 字符串并返回，包括任何 Pydantic
    模型类。
- en: But how does it do this? If you’ve used the Python json library, you’ve probably
    seen that it raises an exception when given some data types, such as `datetime`.
    FastAPI uses an internal function called `jsonable_encoder()` to convert any data
    structure to a “JSONable” Python data structure, then calls the usual `json.dumps()`
    to turn that into a JSON string. [Example 3-32](#ex-3-32) shows a test that you
    can run with pytest.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 但是它是如何做到的呢？如果你使用过 Python 的 json 库，可能已经看到它在给定某些数据类型（如`datetime`）时会引发异常。FastAPI
    使用名为`jsonable_encoder()`的内部函数将任何数据结构转换为“可 JSON 化”的 Python 数据结构，然后调用通常的`json.dumps()`将其转换为
    JSON 字符串。[示例 3-32](#ex-3-32) 展示了一个可以用 pytest 运行的测试。
- en: Example 3-32\. Use `jsonable_encoder()` to avoid JSON kabooms
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-32\. 使用`jsonable_encoder()`避免 JSON 爆炸
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Model Types and response_model
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型类型和`response_model`
- en: 'It’s possible to have different classes with many of the same fields, except
    one is specialized for user input, one for output, and one for internal use. Some
    reasons for these variants could include the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在具有许多相同字段但一个专门用于用户输入、一个用于输出和一个用于内部使用的不同类。这些变体的一些原因可能包括以下几点：
- en: Remove some sensitive information from the output—like *deidentifying* personal
    medical data, if you’ve encountered Health Insurance Portability and Accountability
    Act (HIPAA) requirements.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从输出中删除一些敏感信息，比如*去识别*个人医疗数据，如果你遇到了《健康保险可移植性和责任法案》（HIPAA）的要求。
- en: Add fields to the user input (like a creation date and time).
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向用户输入添加字段（例如创建日期和时间）。
- en: '[Example 3-33](#ex-3-33) shows three related classes for a contrived case:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-33](#ex-3-33) 展示了一个虚构案例的三个相关类：'
- en: '`TagIn` is the class that defines what the user needs to provide (in this case,
    just a string called `tag`).'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TagIn` 是定义用户需要提供的类（在本例中仅为名为`tag`的字符串）。'
- en: '`Tag` is made from a `TagIn` and adds two fields: `created` (when this `Tag`
    was created) and `secret` (an internal string, maybe stored in a database, but
    never supposed to be exposed to the world).'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tag` 是基于`TagIn`创建的，增加了两个字段：`created`（创建此`Tag`的时间）和`secret`（一个内部字符串，可能存储在数据库中，但不应该对外界公开）。'
- en: '`TagOut` is the class that defines what can be returned to a user (by a lookup
    or search endpoint). It contains the `tag` field from the original `TagIn` object
    and its derived `Tag` object, plus the `created` field generated for `Tag`, but
    not `secret`.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TagOut` 是定义可以返回给用户（通过查找或搜索端点）的类。它包含原始`TagIn`对象的`tag`字段及其派生的`Tag`对象，还有为`Tag`生成的`created`字段，但不包括`secret`。'
- en: Example 3-33\. Model variations (model/tag.py)
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-33\. 模型变体（model/tag.py）
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can return data types other than the default JSON from a FastAPI path function
    in different ways. One method is to use the `response_model` argument in the path
    decorator to goose FastAPI to return something else. FastAPI will drop any fields
    that were in the object that you returned but are not in the object specified
    by `response_model`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以不同的方式从 FastAPI 路径函数返回除默认 JSON 以外的数据类型。一种方法是在路径装饰器中使用`response_model`参数，让
    FastAPI 返回其他内容。FastAPI 将删除你返回的对象中出现但未在`response_model`指定对象中的任何字段。
- en: In [Example 3-34](#ex-3-34), pretend that you wrote a new service module called
    *service/tag.py* with the `create()` and `get()` functions that give this web
    module something to call. Those lower-stack details don’t matter here. The important
    point is the `get_one()` path function at the bottom, and the `response_model=TagOut`
    in its path decorator. That automatically changes an internal `Tag` object to
    a sanitized `TagOut` object.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 3-34](#ex-3-34)中，假设你编写了一个名为*service/tag.py*的新服务模块，其中包含 `create()` 和 `get()`
    函数，为这个 web 模块提供调用。这些低层次的细节在此不重要。重要的是底部的`get_one()`路径函数以及其路径装饰器中的`response_model=TagOut`。这会自动将内部的`Tag`对象转换为经过清理的`TagOut`对象。
- en: Example 3-34\. Return a different response type with `response_model` (web/tag.py)
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-34\. 使用`response_model`返回不同的响应类型（web/tag.py）
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Even though we returned a `Tag`, `response_model` will convert it to a `TagOut`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们返回了一个`Tag`，`response_model`将其转换为`TagOut`。
- en: Automated Documentation
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化文档
- en: This section assumes that you’re running the web application from [Example 3-21](#ex-3-21),
    the version that sends the `who` parameter in the HTTP body via a POST request
    to *http://localhost:8000/hi*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 本节假设您正在运行来自[示例 3-21](#ex-3-21)的 Web 应用程序版本，该版本通过`POST`请求将`who`参数发送到 *http://localhost:8000/hi*。
- en: Convince your browser to visit the URL **`http://localhost:8000/docs`**.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 说服你的浏览器访问 URL **`http://localhost:8000/docs`**。
- en: You’ll see something that starts like [Figure 3-1](#fig-03-1) (I’ve cropped
    the following screenshots to emphasize particular areas).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一些类似于[图 3-1](#fig-03-1)的东西（我裁剪了以下截图，以强调特定区域）。
- en: '![Docs Page](assets/fapi_0301.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![文档页面](assets/fapi_0301.png)'
- en: Figure 3-1\. Generated documentation page
  id: totrans-232
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-1\. 生成的文档页面
- en: Where did that come from?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 那是从哪里来的？
- en: FastAPI generates an OpenAPI specification from your code, and includes this
    page to display *and test* all your endpoints. This is just one ingredient of
    its secret sauce.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 从你的代码生成 OpenAPI 规范，并包括此页面来显示和测试所有你的端点。这只是它秘密酱料的一部分。
- en: Click the down arrow on the right side of the green box to open it for testing
    ([Figure 3-2](#fig-03-2)).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 点击绿色框右侧的下箭头以打开它以进行测试（[图 3-2](#fig-03-2)）。
- en: '![Docs Page](assets/fapi_0302.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![文档页面](assets/fapi_0302.png)'
- en: Figure 3-2\. Open documentation page
  id: totrans-237
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-2\. 打开文档页面
- en: Click that “Try it out” button on the right. Now you’ll see an area that will
    let you enter a value in the body section ([Figure 3-3](#fig-03-3)).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 点击右侧的“试一试”按钮。现在你会看到一个区域，让你在主体部分输入一个值（[图 3-3](#fig-03-3)）。
- en: '![Docs Page](assets/fapi_0303.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![文档页面](assets/fapi_0303.png)'
- en: Figure 3-3\. Data entry page
  id: totrans-240
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-3\. 数据输入页面
- en: Click that `"string"`. Change it to `**"Cousin Eddie"**` (keep the double quotes
    around it). Then click the bottom blue Execute button.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 点击那个`"string"`。将它改成`**"Cousin Eddie"**`（保持双引号）。然后点击底部的蓝色执行按钮。
- en: Now look at the Responses section below the Execute button ([Figure 3-4](#fig-03-4)).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看执行按钮下面的响应部分（[图 3-4](#fig-03-4)）。
- en: The “Response body” box shows that Cousin Eddie turned up.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: “响应主体”框显示了出现了 Cousin Eddie。
- en: So, this is yet another way to test the site (besides the earlier examples using
    the browser, HTTPie, and Requests).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这是测试网站的另一种方式（除了之前使用浏览器、HTTPie 和 Requests 的例子）。
- en: '![Docs Page](assets/fapi_0304.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![文档页面](assets/fapi_0304.png)'
- en: Figure 3-4\. Response page
  id: totrans-246
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-4\. 响应页面
- en: By the way, as you can see in the Curl box of the Responses display, using curl
    for command-line testing instead of HTTPie would have required more typing. HTTPie’s
    automatic JSON encoding helps here.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，在响应显示的 Curl 框中可以看到，与使用 HTTPie 相比，使用 curl 进行命令行测试需要更多的输入。HTTPie 的自动 JSON
    编码在这里非常有帮助。
- en: Tip
  id: totrans-248
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: This automated documentation is actually a big, furry deal. As your web service
    grows to hundreds of endpoints, a documentation and testing page that’s always
    up-to-date is helpful.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自动化文档实际上非常重要。随着您的 Web 服务增长到数百个端点，一个始终更新的文档和测试页面将非常有帮助。
- en: Complex Data
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂数据
- en: These examples showed only how to pass a single string to an endpoint. Many
    endpoints, especially `GET` or `DELETE` ones, may need no arguments at all, or
    only a few simple ones, like strings and numbers. But when creating (`POST`) or
    modifying (`PUT` or `PATCH`) a resource, we usually need more complex data structures.
    [Chapter 5](ch05.html#ch05) shows how FastAPI uses Pydantic and data models to
    implement these cleanly.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例仅展示了如何将一个字符串传递给端点。许多端点，特别是`GET`或`DELETE`端点，可能根本不需要参数，或者只需要一些简单的参数，如字符串和数字。但是，在创建（`POST`）或修改（`PUT`或`PATCH`）资源时，我们通常需要更复杂的数据结构。[第
    5 章](ch05.html#ch05)展示了 FastAPI 如何使用 Pydantic 和数据模型来实现这些操作的清洁方法。
- en: Review
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复习
- en: 'In this chapter, we used FastAPI to create a website with a single endpoint.
    Multiple web clients tested it: a web browser, the HTTPie text program, the Requests
    Python package, and the HTTPX Python package. Starting with a simple `GET` call,
    request arguments went to the server via the URL path, a query parameter, and
    an HTTP header. Then, the HTTP body was used to send data to a `POST` endpoint.
    Later, the chapter showed how to return various HTTP response types. Finally,
    an automatically generated form page provided both documentation and live forms
    for a fourth test client.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们使用了 FastAPI 来创建一个只有一个端点的网站。多个 Web 客户端进行了测试：一个是网页浏览器，另外还有 HTTPie 文本程序、Requests
    Python 包和 HTTPX Python 包。从一个简单的`GET`调用开始，请求参数通过 URL 路径、查询参数和 HTTP 头部发送到服务器。然后，HTTP
    主体用于向`POST`端点发送数据。接着，本章展示了如何返回不同类型的 HTTP 响应。最后，一个自动生成的表单页面为第四个测试客户端提供了文档和实时表单。
- en: This FastAPI overview will be expanded in [Chapter 8](ch08.html#ch08).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这份 FastAPI 概述将在 [第八章](ch08.html#ch08) 中进一步展开。
