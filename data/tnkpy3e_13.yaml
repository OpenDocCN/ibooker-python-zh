- en: 11\. Tuples#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11\. 元组#
- en: 原文：[https://allendowney.github.io/ThinkPython/chap11.html](https://allendowney.github.io/ThinkPython/chap11.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://allendowney.github.io/ThinkPython/chap11.html](https://allendowney.github.io/ThinkPython/chap11.html)
- en: 'This chapter introduces one more built-in type, the tuple, and then shows how
    lists, dictionaries, and tuples work together. It also presents tuple assignment
    and a useful feature for functions with variable-length argument lists: the packing
    and unpacking operators.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了另一个内建类型——元组，并展示了列表、字典和元组如何协同工作。它还介绍了元组赋值和一个对具有可变长度参数列表的函数非常有用的特性：打包和解包操作符。
- en: In the exercises, we’ll use tuples, along with lists and dictionaries, to solve
    more word puzzles and implement efficient algorithms.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在练习中，我们将使用元组以及列表和字典来解决更多的单词谜题，并实现高效的算法。
- en: 'One note: There are two ways to pronounce “tuple”. Some people say “tuh-ple”,
    which rhymes with “supple”. But in the context of programming, most people say
    “too-ple”, which rhymes with “quadruple”.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点需要注意：“tuple”有两种发音方式。有些人说“tuh-ple”，与“supple”押韵。但在编程的上下文中，大多数人说“too-ple”，与“quadruple”押韵。
- en: 11.1\. Tuples are like lists[#](#tuples-are-like-lists "Link to this heading")
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.1\. 元组像列表一样[#](#tuples-are-like-lists "Link to this heading")
- en: A tuple is a sequence of values. The values can be any type, and they are indexed
    by integers, so tuples are a lot like lists. The important difference is that
    tuples are immutable.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是一个值的序列。这些值可以是任何类型，并且按整数索引，因此元组与列表非常相似。重要的区别是元组是不可变的。
- en: To create a tuple, you can write a comma-separated list of values.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 创建元组时，可以编写一个由逗号分隔的值列表。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Although it is not necessary, it is common to enclose tuples in parentheses.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不是必须的，但通常会将元组括在圆括号中。
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To create a tuple with a single element, you have to include a final comma.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个包含单一元素的元组，必须包括一个结尾逗号。
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A single value in parentheses is not a tuple.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 括号中的单个值不是元组。
- en: '[PRE6]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Another way to create a tuple is the built-in function `tuple`. With no argument,
    it creates an empty tuple.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 创建元组的另一种方法是使用内建函数`tuple`。如果没有参数，它会创建一个空元组。
- en: '[PRE8]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If the argument is a sequence (string, list or tuple), the result is a tuple
    with the elements of the sequence.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数是一个序列（字符串、列表或元组），则结果是一个包含序列元素的元组。
- en: '[PRE10]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Because `tuple` is the name of a built-in function, you should avoid using it
    as a variable name.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`tuple`是一个内建函数的名称，所以应该避免将其用作变量名。
- en: Most list operators also work with tuples. For example, the bracket operator
    indexes an element.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数列表操作符也适用于元组。例如，方括号操作符可以索引一个元素。
- en: '[PRE12]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: And the slice operator selects a range of elements.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 而切片操作符用于选择一系列元素。
- en: '[PRE14]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `+` operator concatenates tuples.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`+`操作符用于连接元组。'
- en: '[PRE16]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: And the `*` operator duplicates a tuple a given number of times.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`操作符将元组重复给定次数。'
- en: '[PRE18]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `sorted` function works with tuples – but the result is a list, not a tuple.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted`函数也适用于元组——但结果是一个列表，而不是元组。'
- en: '[PRE20]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `reversed` function also works with tuples.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`reversed`函数也可以用于元组。'
- en: '[PRE22]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The result is a `reversed` object, which we can convert to a list or tuple.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个`reversed`对象，我们可以将其转换为列表或元组。
- en: '[PRE24]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Based on the examples so far, it might seem like tuples are the same as lists.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 根据目前的例子，元组看起来可能与列表相同。
- en: 11.2\. But tuples are immutable[#](#but-tuples-are-immutable "Link to this heading")
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.2\. 但是元组是不可变的[#](#but-tuples-are-immutable "Link to this heading")
- en: If you try to modify a tuple with the bracket operator, you get a `TypeError`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用方括号操作符修改元组，会得到一个`TypeError`。
- en: '[PRE26]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: And tuples don’t have any of the methods that modify lists, like `append` and
    `remove`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 而且元组没有修改列表的任何方法，例如`append`和`remove`。
- en: '[PRE28]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Recall that an “attribute” is a variable or method associated with an object
    – this error message means that tuples don’t have a method named `remove`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，“属性”是与对象相关联的变量或方法——这个错误信息意味着元组没有名为`remove`的方法。
- en: Because tuples are immutable, they are hashable, which means they can be used
    as keys in a dictionary. For example, the following dictionary contains two tuples
    as keys that map to integers.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于元组是不可变的，它们是可哈希的，这意味着它们可以用作字典中的键。例如，下面的字典包含两个作为键的元组，它们映射到整数值。
- en: '[PRE30]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can look up a tuple in a dictionary like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样在字典中查找元组：
- en: '[PRE31]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Or if we have a variable that refers to a tuple, we can use it as a key.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们有一个指向元组的变量，也可以将其作为键使用。
- en: '[PRE33]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Tuples can also appear as values in a dictionary.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 元组也可以作为字典中的值出现。
- en: '[PRE35]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 11.3\. Tuple assignment[#](#tuple-assignment "Link to this heading")
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.3\. 元组赋值[#](#tuple-assignment "Link to this heading")
- en: You can put a tuple of variables on the left side of an assignment, and a tuple
    of values on the right.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在赋值的左边放一个变量元组，在右边放一个值元组。
- en: '[PRE37]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The values are assigned to the variables from left to right – in this example,
    `a` gets the value `1` and `b` gets the value `2`. We can display the results
    like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 值会从左到右赋给变量——在这个例子中，`a`得到值`1`，`b`得到值`2`。我们可以这样展示结果：
- en: '[PRE38]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'More generally, if the left side of an assignment is a tuple, the right side
    can be any kind of sequence – string, list or tuple. For example, to split an
    email address into a user name and a domain, you could write:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地说，如果赋值的左边是一个元组，右边可以是任何类型的序列——字符串、列表或元组。例如，要将电子邮件地址拆分成用户名和域名，你可以这样写：
- en: '[PRE40]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The return value from `split` is a list with two elements – the first element
    is assigned to `username`, the second to `domain`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`split`的返回值是一个包含两个元素的列表——第一个元素赋给`username`，第二个赋给`domain`。'
- en: '[PRE41]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The number of variables on the left and the number of values on the right have
    to be the same – otherwise you get a `ValueError`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 左边的变量数量和右边的值数量必须相同——否则会引发`ValueError`。
- en: '[PRE43]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Tuple assignment is useful if you want to swap the values of two variables.
    With conventional assignments, you have to use a temporary variable, like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想交换两个变量的值，元组赋值非常有用。使用常规赋值时，你需要使用临时变量，像这样：
- en: '[PRE45]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: That works, but with tuple assignment we can do the same thing without a temporary
    variable.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这样是可行的，但使用元组赋值我们可以在不使用临时变量的情况下完成相同的操作。
- en: '[PRE46]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This works because all of the expressions on the right side are evaluated before
    any of the assignments.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以可行，是因为右边的所有表达式会在任何赋值操作之前计算。
- en: We can also use tuple assignment in a `for` statement. For example, to loop
    through the items in a dictionary, we can use the `items` method.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在`for`语句中使用元组赋值。例如，要遍历字典中的项，我们可以使用`items`方法。
- en: '[PRE47]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Each time through the loop, `item` is assigned a tuple that contains a key and
    the corresponding value.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 每次循环时，`item`会被赋值为一个包含键和对应值的元组。
- en: 'We can write this loop more concisely, like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样更简洁地写这个循环：
- en: '[PRE49]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Each time through the loop, a key and the corresponding value are assigned directly
    to `key` and `value`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每次循环时，一个键和值会直接赋给`key`和`value`。
- en: 11.4\. Tuples as return values[#](#tuples-as-return-values "Link to this heading")
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.4\. 元组作为返回值[#](#tuples-as-return-values "跳转到此标题")
- en: Strictly speaking, a function can only return one value, but if the value is
    a tuple, the effect is the same as returning multiple values. For example, if
    you want to divide two integers and compute the quotient and remainder, it is
    inefficient to compute `x//y` and then `x%y`. It is better to compute them both
    at the same time.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，一个函数只能返回一个值，但如果这个值是一个元组，效果上就和返回多个值相同。例如，如果你想除以两个整数并计算商和余数，计算`x//y`然后再计算`x%y`效率不高。最好同时计算它们。
- en: The built-in function `divmod` takes two arguments and returns a tuple of two
    values, the quotient and remainder.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 内置函数`divmod`接受两个参数，返回一个包含商和余数的元组。
- en: '[PRE51]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We can use tuple assignment to store the elements of the tuple in two variables.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用元组赋值将元组中的元素存储在两个变量中。
- en: '[PRE53]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here is an example of a function that returns a tuple.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个返回元组的函数示例。
- en: '[PRE57]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`max` and `min` are built-in functions that find the largest and smallest elements
    of a sequence. `min_max` computes both and returns a tuple of two values.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`max`和`min`是内置函数，用于找到序列中最大的和最小的元素。`min_max`同时计算并返回一个包含两个值的元组。'
- en: '[PRE58]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We can assign the results to variables like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样将结果赋给变量：
- en: '[PRE60]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '## 11.5\. Argument packing[#](#argument-packing "Link to this heading")'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '## 11.5\. 参数打包[#](#argument-packing "跳转到此标题")'
- en: Functions can take a variable number of arguments. A parameter name that begins
    with the `*` operator **packs** arguments into a tuple. For example, the following
    function takes any number of arguments and computes their arithmetic mean – that
    is, their sum divided by the number of arguments.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以接受可变数量的参数。以`*`操作符开头的参数名称**打包**参数为元组。例如，下面的函数接受任意数量的参数并计算它们的算术平均值——也就是它们的和除以参数的数量。
- en: '[PRE62]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The parameter can have any name you like, but `args` is conventional. We can
    call the function like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以有任何你喜欢的名字，但`args`是惯用的。我们可以像这样调用函数：
- en: '[PRE63]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If you have a sequence of values and you want to pass them to a function as
    multiple arguments, you can use the `*` operator to **unpack** the tuple. For
    example, `divmod` takes exactly two arguments – if you pass a tuple as a parameter,
    you get an error.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个值的序列，并且想将它们作为多个参数传递给一个函数，你可以使用`*`操作符来**解包**元组。例如，`divmod`函数需要两个精确的参数——如果你传递一个元组作为参数，就会报错。
- en: '[PRE65]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Even though the tuple contains two elements, it counts as a single argument.
    But if you unpack the tuple, it is treated as two arguments.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管元组包含两个元素，它仍然被视为一个单独的参数。但如果你解包元组，它会被当作两个参数来处理。
- en: '[PRE67]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Packing and unpacking can be useful if you want to adapt the behavior of an
    existing function. For example, this function takes any number of arguments, removes
    the lowest and highest, and computes the mean of the rest.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 打包和解包可以非常有用，特别是当你想调整一个现有函数的行为时。例如，这个函数接受任意数量的参数，去掉最低和最高的值，然后计算剩余部分的平均值。
- en: '[PRE69]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: First it uses `min_max` to find the lowest and highest elements. Then it converts
    `args` to a list so it can use the `remove` method. Finally it unpacks the list
    so the elements are passed to `mean` as separate arguments, rather than as a single
    list.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它使用`min_max`找到最低和最高的元素。然后，它将`args`转换为列表，这样就可以使用`remove`方法。最后，它解包这个列表，将元素作为单独的参数传递给`mean`，而不是作为一个列表。
- en: Here’s an example that shows the effect.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子展示了这种影响。
- en: '[PRE70]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This kind of “trimmed” mean is used in some sports with subjective judging –
    like diving and gymnastics – to reduce the effect of a judge whose score deviates
    from the others.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“修剪过的”平均值在一些主观评分的体育项目中使用——比如跳水和体操——用来减少评分偏离其他裁判的影响。
- en: 11.6\. Zip[#](#zip "Link to this heading")
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.6\. Zip[#](#zip "跳转到此标题")
- en: Tuples are useful for looping through the elements of two sequences and performing
    operations on corresponding elements. For example, suppose two teams play a series
    of seven games, and we record their scores in two lists, one for each team.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 元组在遍历两个序列的元素并对对应元素执行操作时非常有用。例如，假设两支队伍进行七场比赛，并且我们将它们的得分记录在两个列表中，每支队伍一个。
- en: '[PRE74]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Let’s see how many games each team won. We’ll use `zip`, which is a built-in
    function that takes two or more sequences and returns a **zip object**, so-called
    because it pairs up the elements of the sequences like the teeth of a zipper.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个队伍赢了多少场比赛。我们将使用`zip`，这是一个内置函数，它接受两个或多个序列并返回一个**zip对象**，因为它像拉链的齿一样将序列的元素配对在一起。
- en: '[PRE75]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We can use the zip object to loop through the values in the sequences pairwise.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用zip对象按对遍历序列中的值。
- en: '[PRE77]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Each time through the loop, `pair` gets assigned a tuple of scores. So we can
    assign the scores to variables, and count the victories for the first team, like
    this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 每次进入循环时，`pair`都会被赋值为一个包含分数的元组。因此，我们可以将分数赋值给变量，并统计第一支队伍的胜利场数，像这样：
- en: '[PRE79]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Sadly, the first team won only three games and lost the series.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜的是，第一支队伍只赢了三场比赛并输掉了系列赛。
- en: If you have two lists and you want a list of pairs, you can use `zip` and `list`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有两个列表，并且想要一个包含配对元素的列表，可以使用`zip`和`list`。
- en: '[PRE81]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The result is a list of tuples, so we can get the result of the last game like
    this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个元组列表，因此我们可以像这样获取最后一场比赛的结果：
- en: '[PRE83]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: If you have a list of keys and a list of values, you can use `zip` and `dict`
    to make a dictionary. For example, here’s how we can make a dictionary that maps
    from each letter to its position in the alphabet.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个键的列表和一个值的列表，可以使用`zip`和`dict`来创建一个字典。例如，下面是我们如何创建一个字典，将每个字母映射到它在字母表中的位置。
- en: '[PRE85]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Now we can look up a letter and get its index in the alphabet.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以查找一个字母并获取它在字母表中的索引。
- en: '[PRE86]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: In this mapping, the index of `'a'` is `0` and the index of `'z'` is `25`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个映射中，`'a'`的索引是`0`，而`'z'`的索引是`25`。
- en: If you need to loop through the elements of a sequence and their indices, you
    can use the built-in function `enumerate`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要遍历一个序列的元素及其索引，可以使用内置函数`enumerate`。
- en: '[PRE88]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The result is an **enumerate object** that loops through a sequence of pairs,
    where each pair contains an index (starting from 0) and an element from the given
    sequence.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个**enumerate对象**，它遍历一个由索引（从0开始）和给定序列中的元素组成的配对序列。
- en: '[PRE90]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 11.7\. Comparing and Sorting[#](#comparing-and-sorting "Link to this heading")
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.7\. 比较和排序[#](#comparing-and-sorting "跳转到此标题")
- en: The relational operators work with tuples and other sequences. For example,
    if you use the `<` operator with tuples, it starts by comparing the first element
    from each sequence. If they are equal, it goes on to the next pair of elements,
    and so on, until it finds a pair that differ.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 关系运算符适用于元组和其他序列。例如，如果你用`<`运算符比较元组，它会先比较每个序列中的第一个元素。如果它们相等，则继续比较第二对元素，以此类推，直到找到一对不同的元素。
- en: '[PRE92]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Subsequent elements are not considered – even if they are really big.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 后续的元素不会被考虑——即使它们真的很大。
- en: '[PRE94]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This way of comparing tuples is useful for sorting a list of tuples, or finding
    the minimum or maximum. As an example, let’s find the most common letter in a
    word. In the previous chapter, we wrote `value_counts`, which takes a string and
    returns a dictionary that maps from each letter to the number of times it appears.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这种比较元组的方式对于排序元组列表或找到最小值或最大值非常有用。作为示例，让我们找到一个单词中最常见的字母。在前一章中，我们编写了`value_counts`，它接受一个字符串并返回一个字典，该字典将每个字母映射到其出现的次数。
- en: '[PRE96]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Here is the result for the string `'banana'`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是字符串`'banana'`的结果。
- en: '[PRE97]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: With only three items, we can easily see that the most frequent letter is `'a'`,
    which appears three times. But if there were more items, it would be useful to
    sort them automatically.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 只有三个项时，我们可以很容易地看到最常见的字母是`'a'`，它出现了三次。但如果有更多项，自动排序将会非常有用。
- en: We can get the items from `counter` like this.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样从`counter`中获取项。
- en: '[PRE99]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The result is a `dict_items` object that behaves like a list of tuples, so we
    can sort it like this.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个`dict_items`对象，它表现得像一个元组列表，因此我们可以像这样对其进行排序。
- en: '[PRE101]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The default behavior is to use the first element from each tuple to sort the
    list, and use the second element to break ties.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 默认行为是使用每个元组的第一个元素来排序列表，并使用第二个元素来解决相同的情况。
- en: However, to find the items with the highest counts, we want to use the second
    element to sort the list. We can do that by writing a function that takes a tuple
    and returns the second element.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了找到出现次数最多的项，我们想要使用第二个元素对列表进行排序。我们可以通过编写一个函数来实现，该函数接受一个元组并返回第二个元素。
- en: '[PRE103]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Then we can pass that function to `sorted` as an optional argument called `key`,
    which indicates that this function should be used to compute the **sort key**
    for each item.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以将该函数作为可选参数`key`传递给`sorted`，该参数表示此函数应用于计算每个项的**排序关键字**。
- en: '[PRE104]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The sort key determines the order of the items in the list. The letter with
    the lowest count appears first, and the letter with the highest count appears
    last. So we can find the most common letter like this.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 排序关键字决定了列表中项的顺序。出现次数最少的字母排在前面，出现次数最多的字母排在最后。因此，我们可以像这样找到最常见的字母。
- en: '[PRE106]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: If we only want the maximum, we don’t have to sort the list. We can use `max`,
    which also takes `key` as an optional argument.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只需要最大值，我们就不必排序列表。我们可以使用`max`，它也接受`key`作为可选参数。
- en: '[PRE108]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: To find the letter with the lowest count, we could use `min` the same way.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到出现次数最少的字母，我们可以用`min`来进行相同的操作。
- en: 11.8\. Inverting a dictionary[#](#inverting-a-dictionary "Link to this heading")
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.8\. 反转字典[#](#inverting-a-dictionary "链接到此标题")
- en: Suppose you want to invert a dictionary so you can look up a value and get the
    corresponding key. For example, if you have a word counter that maps from each
    word to the number of times it appears, you could make a dictionary that maps
    from integers to the words that appear that number of times.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要反转一个字典，以便通过查找一个值来得到对应的键。例如，如果你有一个单词计数器，它将每个单词映射到该单词出现的次数，你可以创建一个字典，将整数映射到出现相应次数的单词。
- en: But there’s a problem – the keys in a dictionary have to be unique, but the
    values don’t. For example, in a word counter, there could be many words with the
    same count.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有一个问题——字典中的键必须是唯一的，但值不一定是唯一的。例如，在一个单词计数器中，可能有许多单词的出现次数相同。
- en: So one way to invert a dictionary is to create a new dictionary where the values
    are lists of keys from the original. As an example, let’s count the letters in
    `parrot`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 所以反转字典的一种方法是创建一个新字典，其中值是原字典中键的列表。作为示例，让我们统计`parrot`中字母的出现次数。
- en: '[PRE110]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'If we invert this dictionary, the result should be `{1: [''p'', ''a'', ''o'',
    ''t''], 2: [''r'']}`, which indicates that the letters that appear once are `''p''`,
    `''a''`, `''o''`, and `''t''`, and the letter than appears twice is `''r''`.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们反转这个字典，结果应该是`{1: [''p'', ''a'', ''o'', ''t''], 2: [''r'']}`，这表示出现一次的字母是`''p''`、`''a''`、`''o''`和`''t''`，出现两次的字母是`''r''`。'
- en: The following function takes a dictionary and returns its inverse as a new dictionary.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数接受一个字典并将其反转为一个新的字典。
- en: '[PRE112]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The `for` statement loops through the keys and values in `d`. If the value is
    not already in the new dictionary, it is added and associated with a list that
    contains a single element. Otherwise it is appended to the existing list.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句遍历`d`中的键和值。如果该值尚未在新字典中，则将其添加并与包含单个元素的列表相关联。否则，它将被追加到现有的列表中。'
- en: 'We can test it like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样测试它：
- en: '[PRE113]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: And we get the result we expected.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了预期的结果。
- en: This is the first example we’ve seen where the values in the dictionary are
    lists. We will see more!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们看到的第一个字典中的值是列表的例子。我们会看到更多类似的例子！
- en: '## 11.9\. Debugging[#](#debugging "Link to this heading")'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '## 11.9\. 调试[#](#debugging "跳转到此标题")'
- en: Lists, dictionaries and tuples are **data structures**. In this chapter we are
    starting to see compound data structures, like lists of tuples, or dictionaries
    that contain tuples as keys and lists as values. Compound data structures are
    useful, but they are prone to errors caused when a data structure has the wrong
    type, size, or structure. For example, if a function expects a list of integers
    and you give it a plain old integer (not in a list), it probably won’t work.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 列表、字典和元组是**数据结构**。在本章中，我们开始看到复合数据结构，例如元组的列表，或者包含元组作为键和列表作为值的字典。复合数据结构很有用，但容易因数据结构的类型、大小或结构错误而导致错误。例如，如果一个函数期望一个整数列表，而你给它一个普通的整数（不是列表），它可能无法正常工作。
- en: To help debug these kinds of errors, I wrote a module called `structshape` that
    provides a function, also called `structshape`, that takes any kind of data structure
    as an argument and returns a string that summarizes its structure. You can download
    it from [https://raw.githubusercontent.com/AllenDowney/ThinkPython/v3/structshape.py](https://raw.githubusercontent.com/AllenDowney/ThinkPython/v3/structshape.py).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助调试这些错误，我编写了一个名为`structshape`的模块，它提供了一个同名的函数，可以将任何类型的数据结构作为参数，并返回一个字符串来总结其结构。你可以从[https://raw.githubusercontent.com/AllenDowney/ThinkPython/v3/structshape.py](https://raw.githubusercontent.com/AllenDowney/ThinkPython/v3/structshape.py)下载它。
- en: We can import it like this.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样导入它。
- en: '[PRE115]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Here’s an example with a simple list.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单列表的例子。
- en: '[PRE116]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Here’s a list of lists.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个列表的列表。
- en: '[PRE118]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: If the elements of the list are not the same type, `structshape` groups them
    by type.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表中的元素类型不同，`structshape`会按类型将它们分组。
- en: '[PRE120]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Here’s a list of tuples.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个元组的列表。
- en: '[PRE122]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: And here’s a dictionary with three items that map integers to strings.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含三个项的字典，将整数映射到字符串。
- en: '[PRE124]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: If you are having trouble keeping track of your data structures, `structshape`
    can help.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在跟踪数据结构时遇到困难，`structshape`可以帮助你。
- en: 11.10\. Glossary[#](#glossary "Link to this heading")
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.10\. 术语表[#](#glossary "跳转到此标题")
- en: '**pack:** Collect multiple arguments into a tuple.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**打包：** 将多个参数收集到一个元组中。'
- en: '**unpack:** Treat a tuple (or other sequence) as multiple arguments.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**解包：** 将元组（或其他序列）视为多个参数。'
- en: '**zip object:** The result of calling the built-in function `zip`, can be used
    to loop through a sequence of tuples.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**zip对象：** 调用内置函数`zip`的结果，可以用来遍历一系列元组。'
- en: '**enumerate object:** The result of calling the built-in function `enumerate`,
    can be used to loop through a sequence of tuples.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**enumerate对象：** 调用内置函数`enumerate`的结果，可以用来遍历一系列元组。'
- en: '**sort key:** A value, or function that computes a value, used to sort the
    elements of a collection.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**排序键：** 用于排序集合元素的值或计算该值的函数。'
- en: '**data structure:** A collection of values, organized to perform certain operations
    efficiently.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据结构：** 一组有组织的值，用于高效地执行某些操作。'
- en: 11.11\. Exercises[#](#exercises "Link to this heading")
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 11.11\. 练习[#](#exercises "跳转到此标题")
- en: '[PRE126]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 11.11.1\. Ask a virtual assistant[#](#ask-a-virtual-assistant "Link to this
    heading")
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.11.1\. 向虚拟助手提问[#](#ask-a-virtual-assistant "跳转到此标题")
- en: The exercises in this chapter might be more difficult than exercises in previous
    chapters, so I encourage you to get help from a virtual assistant. When you pose
    more difficult questions, you might find that the answers are not correct on the
    first attempt, so this is a chance to practice crafting good prompts and following
    up with good refinements.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的练习可能比前几章的练习更难，因此我鼓励你向虚拟助手寻求帮助。当你提出更难的问题时，可能会发现答案第一次并不正确，这是一个练习编写良好提示并进行有效跟进的机会。
- en: One strategy you might consider is to break a big problems into pieces that
    can be solved with simple functions. Ask the virtual assistant to write the functions
    and test them. Then, once they are working, ask for a solution to the original
    problem.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以考虑的一种策略是将一个大问题拆解成可以通过简单函数解决的小问题。让虚拟助手编写这些函数并测试它们。然后，一旦它们工作正常，再请求解决原始问题。
- en: For some of the exercises below, I make suggestions about which data structures
    and algorithms to use. You might find these suggestions useful when you work on
    the problems, but they are also good prompts to pass along to a virtual assistant.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下面的一些练习，我会建议使用哪些数据结构和算法。你可能会发现这些建议在解决问题时有用，但它们也是传递给虚拟助手的良好提示。
- en: 11.11.2\. Exercise[#](#exercise "Link to this heading")
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.11.2\. 练习[#](#exercise "链接到该部分")
- en: In this chapter I said that tuples can be used as keys in dictionaries because
    they are hashable, and they are hashable because they are immutable. But that
    is not always true.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我提到过元组可以作为字典中的键，因为它们是可哈希的，而它们之所以可哈希，是因为它们是不可变的。但这并不总是正确的。
- en: If a tuple contains a mutable value, like a list or a dictionary, the tuple
    is no longer hashable because it contains elements that are not hashable. As an
    example, here’s a tuple that contains two lists of integers.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果元组包含可变值，例如列表或字典，则该元组不再是可哈希的，因为它包含了不可哈希的元素。举个例子，下面是一个包含两个整数列表的元组。
- en: '[PRE128]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Write a line of code that appends the value `6` to the end of the second list
    in `t`. If you display `t`, the result should be `([1, 2, 3], [4, 5, 6])`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一行代码，将值`6`附加到`t`中第二个列表的末尾。如果你显示`t`，结果应为`([1, 2, 3], [4, 5, 6])`。
- en: Try to create a dictionary that maps from `t` to a string, and confirm that
    you get a `TypeError`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试创建一个将`t`映射到字符串的字典，并确认你会遇到`TypeError`。
- en: '[PRE130]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: For more on this topic, ask a virtual assistant, “Are Python tuples always hashable?”
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于此主题的内容，可以向虚拟助手询问：“Python元组总是可哈希的吗？”
- en: '### 11.11.3\. Exercise[#](#section-exercise-11 "Link to this heading")'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '### 11.11.3\. 练习[#](#section-exercise-11 "链接到该部分")'
- en: In this chapter we made a dictionary that maps from each letter to its index
    in the alphabet.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个字典，将每个字母映射到它在字母表中的索引。
- en: '[PRE132]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: For example, the index of `'a'` is `0`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`'a'`的索引是`0`。
- en: '[PRE133]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: To go in the other direction, we can use list indexing. For example, the letter
    at index `1` is `'b'`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 要朝另一个方向移动，我们可以使用列表索引。例如，索引`1`处的字母是`'b'`。
- en: '[PRE135]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: We can use `letter_map` and `letters` to encode and decode words using a Caesar
    cipher.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`letter_map`和`letters`来使用凯撒密码对单词进行编码和解码。
- en: A Caesar cipher is a weak form of encryption that involves shifting each letter
    by a fixed number of places in the alphabet, wrapping around to the beginning
    if necessary. For example, `'a'` shifted by 2 is `'c'` and `'z'` shifted by 1
    is `'a'`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码是一种弱加密形式，它通过将每个字母按固定的位移数移动来加密，如果有需要，可以绕回字母表的开头。例如，`'a'`移动2位是`'c'`，而`'z'`移动1位是`'a'`。
- en: Write a function called `shift_word` that takes as parameters a string and an
    integer, and returns a new string that contains the letters from the string shifted
    by the given number of places.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为`shift_word`的函数，接受一个字符串和一个整数作为参数，并返回一个新的字符串，其中的字母按给定的位移数移动。
- en: To test your function, confirm that “cheer” shifted by 7 is “jolly” and “melon”
    shifted by 16 is “cubed”.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试你的函数，确认“cheer”移动7个位置后是“jolly”，而“melon”移动16个位置后是“cubed”。
- en: 'Hints: Use the modulus operator to wrap around from `''z''` back to `''a''`.
    Loop through the letters of the word, shift each one, and append the result to
    a list of letters. Then use `join` to concatenate the letters into a string.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：使用模运算符将字母从`'z'`回绕到`'a'`。循环遍历单词中的字母，移动每个字母，并将结果附加到字母列表中。然后使用`join`将字母连接成一个字符串。
- en: 11.11.4\. Exercise[#](#id2 "Link to this heading")
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.11.4\. 练习[#](#id2 "链接到该部分")
- en: Write a function called `most_frequent_letters` that takes a string and prints
    the letters in decreasing order of frequency.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为`most_frequent_letters`的函数，该函数接受一个字符串并按频率递减顺序打印字母。
- en: To get the items in decreasing order, you can use `reversed` along with `sorted`
    or you can pass `reverse=True` as a keyword parameter to `sorted`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要按递减顺序获取项目，你可以使用`reversed`与`sorted`一起，或者你可以将`reverse=True`作为关键字参数传递给`sorted`。
- en: 11.11.5\. Exercise[#](#id3 "Link to this heading")
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.11.5\. 练习[#](#id3 "链接到该部分")
- en: In a previous exercise, we tested whether two strings are anagrams by sorting
    the letters in both words and checking whether the sorted letters are the same.
    Now let’s make the problem a little more challenging.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的练习中，我们通过对两个单词的字母进行排序并检查排序后的字母是否相同，来判断这两个字符串是否是字谜词。现在让我们让这个问题更具挑战性。
- en: 'We’ll write a program that takes a list of words and prints all the sets of
    words that are anagrams. Here is an example of what the output might look like:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个程序，该程序接受一个单词列表并打印出所有字谜词组。以下是输出可能的示例：
- en: '[PRE137]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Hint: For each word in the word list, sort the letters and join them back into
    a string. Make a dictionary that maps from this sorted string to a list of words
    that are anagrams of it.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：对于单词列表中的每个单词，先将字母排序，再将其连接回一个字符串。创建一个字典，将这个排序后的字符串映射到与之为字谜词的单词列表。
- en: 11.11.6\. Exercise[#](#id4 "Link to this heading")
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.11.6\. 练习[#](#id4 "链接到此标题")
- en: Write a function called `word_distance` that takes two words with the same length
    and returns the number of places where the two words differ.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为`word_distance`的函数，该函数接受两个相同长度的单词，并返回两个单词在多少个位置上有所不同。
- en: 'Hint: Use `zip` to loop through the corresponding letters of the words.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：使用`zip`函数来遍历单词中字母的对应位置。
- en: 11.11.7\. Exercise[#](#id5 "Link to this heading")
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.11.7\. 练习[#](#id5 "链接到此标题")
- en: “Metathesis” is the transposition of letters in a word. Two words form a “metathesis
    pair” if you can transform one into the other by swapping two letters, like `converse`
    and `conserve`. Write a program that finds all of the metathesis pairs in the
    word list.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: “元音交换”（Metathesis）是指单词中字母的交换。如果你可以通过交换两个字母将一个单词转换成另一个单词，那么这两个单词就是“元音交换对”，例如`converse`和`conserve`。编写一个程序，找出单词列表中的所有元音交换对。
- en: 'Hint: The words in a metathesis pair must be anagrams of each other.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：互换对中的单词必须是彼此的字谜词。
- en: 'Credit: This exercise is inspired by an example at [http://puzzlers.org](http://puzzlers.org).'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 致谢：此练习的灵感来源于[http://puzzlers.org](http://puzzlers.org)上的一个示例。
- en: '[Think Python: 3rd Edition](https://allendowney.github.io/ThinkPython/index.html)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '[Think Python: 第三版](https://allendowney.github.io/ThinkPython/index.html)'
- en: Copyright 2024 [Allen B. Downey](https://allendowney.com)
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 版权 2024 [Allen B. Downey](https://allendowney.com)
- en: 'Code license: [MIT License](https://mit-license.org/)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 代码许可：[MIT 许可证](https://mit-license.org/)
- en: 'Text license: [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 文本许可：[知识共享署名-非商业性使用-相同方式共享 4.0 国际](https://creativecommons.org/licenses/by-nc-sa/4.0/)
