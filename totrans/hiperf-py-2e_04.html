<html><head></head><body><div id="sbo-rt-content" class="calibre2"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Dictionaries and Sets" class="calibre3"><div class="preface" id="section-dictionary-sets">
<h1 class="calibre23"><span class="publishername">Chapter 4. </span>Dictionaries and Sets</h1>

<aside data-type="sidebar" epub:type="sidebar" class="calibre40"><div class="sidebar" id="idm46122426088376">
<h5 class="calibre41">Questions You’ll Be Able to Answer After This Chapter</h5>
<ul class="printings">
<li class="calibre21">
<p class="calibre42">What are dictionaries and sets good for?</p>
</li>
<li class="calibre21">
<p class="calibre42">How are dictionaries and sets the same?</p>
</li>
<li class="calibre21">
<p class="calibre42">What is the overhead when using a dictionary?</p>
</li>
<li class="calibre21">
<p class="calibre42">How can I optimize the performance of a dictionary?</p>
</li>
<li class="calibre21">
<p class="calibre42">How does Python use dictionaries to keep track of namespaces?</p>
</li>
</ul>
</div></aside>

<p class="author1"><a data-type="indexterm" data-primary="dictionaries and sets" data-secondary="about" id="ds_ab" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="sets and dictionaries" data-secondary="about" id="sd_abt" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="dictionaries and sets" id="ds_ch" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="sets and dictionaries" id="sd_ch" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>Sets and dictionaries are ideal
data structures to be used when your data has no intrinsic order (except for
insertion order) but does have a unique object that can be used to reference it<a data-type="indexterm" data-primary="reference object" id="idm46122426077240" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>
(the reference object is normally a string, but it can be any <span class="publishername">hashable</span> type).  This
reference object is called the<a data-type="indexterm" data-primary="key" id="idm46122426075720" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <em class="hyperlink">key</em>, while the data is the<a data-type="indexterm" data-primary="value" id="idm46122426074472" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <em class="hyperlink">value</em>.
Dictionaries and sets are almost identical, except that sets do not actually
contain values: a set is simply a collection of unique keys. As the name
implies, sets are very useful for doing set operations.</p>
<div data-type="note" epub:type="note" id="note-hashable-type" class="calibre35"><h6 class="calibre36">Note</h6>
<p class="author1">A<a data-type="indexterm" data-primary="hashable type" id="idm46122426071592" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <em class="hyperlink">hashable</em> type is one that implements both the<a data-type="indexterm" data-primary="hash functions" data-secondary="hashable type and" id="idm46122426070312" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <code class="calibre26">__hash__</code> magic function and
either<a data-type="indexterm" data-primary="eq function" id="idm46122426068792" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="cmp function" id="idm46122426068088" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <code class="calibre26">__eq__</code> or <code class="calibre26">__cmp__</code>. All native types in Python already implement
these, and any user classes have default values. See
<a data-type="xref" href="#SEC-dict-set-hash-and-entropy" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">“Hash Functions and Entropy”</a> for more details.</p>
</div>

<p class="author1">While we saw in the previous chapter that we are restricted to, at best, <code class="calibre26">O(log
n)</code> lookup time on lists/tuples with no intrinsic order (through a search
operation), dictionaries and sets give us <code class="calibre26">O(1)</code> lookups based on the arbitrary
index. In addition, like lists/tuples, dictionaries and sets have <code class="calibre26">O(1)</code>
insertion time.<sup class="calibre44"><a data-type="noteref" id="idm46122426063384-marker" href="ch04.xhtml#idm46122426063384" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">1</a></sup> As we will see in <a data-type="xref" href="#dict_set_how_work" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">“How Do Dictionaries and Sets Work?”</a>, this <a data-type="indexterm" data-primary="hash functions" data-secondary="speed of" id="idm46122426060024" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>speed is
accomplished through the use of an open address hash table as the underlying
data structure.</p>

<p class="author1">However, there is a cost to using dictionaries and sets. First, they generally
take up a larger footprint in memory. Also, although the complexity for
insertions/lookups is <code class="calibre26">O(1)</code>, the actual speed depends greatly on the hashing
function that is in use. If the hash function is slow to evaluate, any
operations on dictionaries or sets will be similarly slow.</p>

<p class="author1">Let’s look at an example. Say we want to store contact information for everyone
in the phone book. We would like to store this in a form that will make it
simple to answer the question “What is John Doe’s phone number?” in the future.
With lists, we would store the phone numbers and names sequentially and scan
through the entire list to find the phone number we required, as shown in
<a data-type="xref" href="#dict_set_phonebook_list" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 4-1</a>.</p>
<div id="dict_set_phonebook_list" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 4-1. </span>Phone book lookup with a list</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="kn">def</code> <code class="nf">find_phonenumber</code><code class="p">(</code><code class="n">phonebook</code><code class="p">,</code> <code class="n">name</code><code class="p">):</code>
    <code class="kn">for</code> <code class="n">n</code><code class="p">,</code> <code class="n">p</code> <code class="ow">in</code> <code class="n">phonebook</code><code class="p">:</code>
        <code class="kn">if</code> <code class="n">n</code> <code class="o">==</code> <code class="n">name</code><code class="p">:</code>
            <code class="kn">return</code> <code class="n">p</code>
    <code class="kn">return</code> <code class="nb">None</code>

<code class="n">phonebook</code> <code class="o">=</code> <code class="p">[</code>
    <code class="p">(</code><code class="s">"John Doe"</code><code class="p">,</code> <code class="s">"555-555-5555"</code><code class="p">),</code>
    <code class="p">(</code><code class="s">"Albert Einstein"</code><code class="p">,</code> <code class="s">"212-555-5555"</code><code class="p">),</code>
<code class="p">]</code>
<code class="kn">print</code><code class="p">(</code><code class="n">f</code><code class="s">"John Doe's phone number is {find_phonenumber(phonebook, 'John Doe')}"</code><code class="p">)</code></pre></div>
<div data-type="note" epub:type="note" class="calibre35"><h6 class="calibre36">Note</h6>
<p class="author1">We could also do this by sorting the list and using the <code class="calibre26">bisect</code> module (from
<a data-type="xref" href="ch03.xhtml#list_bisect_example" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 3-4</a>) in order to get <code class="calibre26">O(log n)</code> performance.</p>
</div>

<p class="author1">With a dictionary, however, we can simply have the “index” be the names and the
“values” be the phone numbers, as shown in <a data-type="xref" href="#dict_set_phonebook_dict" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 4-2</a>. This
allows us to simply look up the value we need and get a direct reference to it,
instead of having to read every value in our dataset.</p>
<div id="dict_set_phonebook_dict" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 4-2. </span>Phone book lookup with a dictionary</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="n">phonebook</code> <code class="o">=</code> <code class="p">{</code>
    <code class="s">"John Doe"</code><code class="p">:</code> <code class="s">"555-555-5555"</code><code class="p">,</code>
    <code class="s">"Albert Einstein"</code> <code class="p">:</code> <code class="s">"212-555-5555"</code><code class="p">,</code>
<code class="p">}</code>
<code class="kn">print</code><code class="p">(</code><code class="n">f</code><code class="s">"John Doe's phone number is {phonebook['John Doe']}"</code><code class="p">)</code></pre></div>

<p class="author1">For large phone books, the difference between the <code class="calibre26">O(1)</code> lookup of the dictionary
and the <code class="calibre26">O(n)</code> time for linear search over the list (or, at best, the <code class="calibre26">O(log n)</code> complexity
with the bisect module) is quite substantial.</p>
<div data-type="tip" class="calibre35"><h6 class="calibre36">Tip</h6>
<p class="author1">Create a script that times the performance of the <a data-type="indexterm" data-primary="list-bisect method" id="idm46122425962264" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>list-<code class="calibre26">bisect</code> method versus a
dictionary for finding a number in a phone book. How does the timing scale as
the size of the phone book grows?</p>
</div>

<p class="author1">If, on the other hand, we wanted to answer the question “How many unique first
names are there in my phone book?” we could use the power of sets. Recall that
a set is simply a collection of<a data-type="indexterm" data-primary="unique keys" id="idm46122425960120" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <em class="hyperlink">unique</em> keys—this is the exact property we
would like to enforce in our data. This is in stark contrast to a list-based
approach, where that property needs to be enforced separately from the
data structure by comparing all names with all other names. <a data-type="xref" href="#alt_dup_layout" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 4-3</a> illustrates.</p>
<div id="alt_dup_layout" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 4-3. </span>Finding unique names with lists and sets</h5>
<pre data-type="programlisting" data-code-language="python" class="calibre59">
<code class="kn">def</code><code class="calibre26"> </code><code class="nf">list_unique_names</code><code class="p">(</code><code class="n">phonebook</code><code class="p">)</code><code class="p">:</code><code class="calibre26">
</code><code class="calibre26">    </code><code class="n">unique_names</code><code class="calibre26"> </code><code class="o">=</code><code class="calibre26"> </code><code class="p">[</code><code class="p">]</code><code class="calibre26">
</code><code class="calibre26">    </code><code class="kn">for</code><code class="calibre26"> </code><code class="n">name</code><code class="p">,</code><code class="calibre26"> </code><code class="n">phonenumber</code><code class="calibre26"> </code><code class="ow">in</code><code class="calibre26"> </code><code class="n">phonebook</code><code class="p">:</code><code class="calibre26"> </code><a class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6" id="co_dictionaries_and_sets_CO1-1_new" href="#callout_dictionaries_and_sets_CO1-1_new"><img src="Images/1.png" alt="1" class="calibre74"/></a><code class="calibre26">
</code><code class="calibre26">        </code><code class="n">first_name</code><code class="p">,</code><code class="calibre26"> </code><code class="n">last_name</code><code class="calibre26"> </code><code class="o">=</code><code class="calibre26"> </code><code class="n">name</code><code class="o">.</code><code class="n">split</code><code class="p">(</code><code class="s">"</code><code class="s"> </code><code class="s">"</code><code class="p">,</code><code class="calibre26"> </code><code class="mi">1</code><code class="p">)</code><code class="calibre26">
</code><code class="calibre26">        </code><code class="kn">for</code><code class="calibre26"> </code><code class="n">unique</code><code class="calibre26"> </code><code class="ow">in</code><code class="calibre26"> </code><code class="n">unique_names</code><code class="p">:</code><code class="calibre26"> </code><a class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6" id="co_dictionaries_and_sets_CO1-2" href="#callout_dictionaries_and_sets_CO1-2"><img src="Images/2.png" alt="2" class="calibre74"/></a><code class="calibre26">
</code><code class="calibre26">            </code><code class="kn">if</code><code class="calibre26"> </code><code class="n">unique</code><code class="calibre26"> </code><code class="o">==</code><code class="calibre26"> </code><code class="n">first_name</code><code class="p">:</code><code class="calibre26">
</code><code class="calibre26">                </code><code class="kn">break</code><code class="calibre26">
</code><code class="calibre26">        </code><code class="kn">else</code><code class="p">:</code><code class="calibre26">
</code><code class="calibre26">            </code><code class="n">unique_names</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">first_name</code><code class="p">)</code><code class="calibre26">
</code><code class="calibre26">    </code><code class="kn">return</code><code class="calibre26"> </code><code class="nb">len</code><code class="p">(</code><code class="n">unique_names</code><code class="p">)</code><code class="calibre26">
</code><code class="calibre26">
</code><code class="kn">def</code><code class="calibre26"> </code><code class="nf">set_unique_names</code><code class="p">(</code><code class="n">phonebook</code><code class="p">)</code><code class="p">:</code><code class="calibre26">
</code><code class="calibre26">    </code><code class="n">unique_names</code><code class="calibre26"> </code><code class="o">=</code><code class="calibre26"> </code><code class="nb">set</code><code class="p">(</code><code class="p">)</code><code class="calibre26">
</code><code class="calibre26">    </code><code class="kn">for</code><code class="calibre26"> </code><code class="n">name</code><code class="p">,</code><code class="calibre26"> </code><code class="n">phonenumber</code><code class="calibre26"> </code><code class="ow">in</code><code class="calibre26"> </code><code class="n">phonebook</code><code class="p">:</code><code class="calibre26"> </code><a class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6" id="co_dictionaries_and_sets_CO1-3" href="#callout_dictionaries_and_sets_CO1-3"><img src="Images/3.png" alt="3" class="calibre74"/></a><code class="calibre26">
</code><code class="calibre26">        </code><code class="n">first_name</code><code class="p">,</code><code class="calibre26"> </code><code class="n">last_name</code><code class="calibre26"> </code><code class="o">=</code><code class="calibre26"> </code><code class="n">name</code><code class="o">.</code><code class="n">split</code><code class="p">(</code><code class="s">"</code><code class="s"> </code><code class="s">"</code><code class="p">,</code><code class="calibre26"> </code><code class="mi">1</code><code class="p">)</code><code class="calibre26">
</code><code class="calibre26">        </code><code class="n">unique_names</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">first_name</code><code class="p">)</code><code class="calibre26"> </code><a class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6" id="co_dictionaries_and_sets_CO1-4" href="#callout_dictionaries_and_sets_CO1-4"><img src="Images/4.png" alt="4" class="calibre74"/></a><code class="calibre26">
</code><code class="calibre26">    </code><code class="kn">return</code><code class="calibre26"> </code><code class="nb">len</code><code class="p">(</code><code class="n">unique_names</code><code class="p">)</code><code class="calibre26">
</code><code class="calibre26">
</code><code class="n">phonebook</code><code class="calibre26"> </code><code class="o">=</code><code class="calibre26"> </code><code class="p">[</code><code class="calibre26">
</code><code class="calibre26">    </code><code class="p">(</code><code class="s">"</code><code class="s">John Doe</code><code class="s">"</code><code class="p">,</code><code class="calibre26"> </code><code class="s">"</code><code class="s">555-555-5555</code><code class="s">"</code><code class="p">)</code><code class="p">,</code><code class="calibre26">
</code><code class="calibre26">    </code><code class="p">(</code><code class="s">"</code><code class="s">Albert Einstein</code><code class="s">"</code><code class="p">,</code><code class="calibre26"> </code><code class="s">"</code><code class="s">212-555-5555</code><code class="s">"</code><code class="p">)</code><code class="p">,</code><code class="calibre26">
</code><code class="calibre26">    </code><code class="p">(</code><code class="s">"</code><code class="s">John Murphey</code><code class="s">"</code><code class="p">,</code><code class="calibre26"> </code><code class="s">"</code><code class="s">202-555-5555</code><code class="s">"</code><code class="p">)</code><code class="p">,</code><code class="calibre26">
</code><code class="calibre26">    </code><code class="p">(</code><code class="s">"</code><code class="s">Albert Rutherford</code><code class="s">"</code><code class="p">,</code><code class="calibre26"> </code><code class="s">"</code><code class="s">647-555-5555</code><code class="s">"</code><code class="p">)</code><code class="p">,</code><code class="calibre26">
</code><code class="calibre26">    </code><code class="p">(</code><code class="s">"</code><code class="s">Guido van Rossum</code><code class="s">"</code><code class="p">,</code><code class="calibre26"> </code><code class="s">"</code><code class="s">301-555-5555</code><code class="s">"</code><code class="p">)</code><code class="p">,</code><code class="calibre26">
</code><code class="p">]</code><code class="calibre26">
</code><code class="calibre26">
</code><code class="kn">print</code><code class="p">(</code><code class="s">"</code><code class="s">Number of unique names from set method:</code><code class="s">"</code><code class="p">,</code><code class="calibre26"> </code><code class="n">set_unique_names</code><code class="p">(</code><code class="n">phonebook</code><code class="p">)</code><code class="p">)</code><code class="calibre26">
</code><code class="kn">print</code><code class="p">(</code><code class="s">"</code><code class="s">Number of unique names from list method:</code><code class="s">"</code><code class="p">,</code><code class="calibre26"> </code><code class="n">list_unique_names</code><code class="p">(</code><code class="n">phonebook</code><code class="p">)</code><code class="p">)</code><code class="calibre26">
</code></pre>
</div>
<dl class="calibre28">
<dt class="calibre29"><a class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6" id="callout_dictionaries_and_sets_CO1-1_new" href="#co_dictionaries_and_sets_CO1-1_new"><img src="Images/1.png" alt="1" class="calibre74"/></a>, <a class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6" id="callout_dictionaries_and_sets_CO1-3" href="#co_dictionaries_and_sets_CO1-3"><img src="Images/3.png" alt="3" class="calibre74"/></a></dt>
<dd class="calibre75"><p class="calibre76">    We must go over all the items in our phone book, and thus this loop costs <code class="calibre26">O(n)</code>.</p></dd>
<dt class="calibre29"><a class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6" id="callout_dictionaries_and_sets_CO1-2" href="#co_dictionaries_and_sets_CO1-2"><img src="Images/2.png" alt="2" class="calibre74"/></a></dt>
<dd class="calibre75"><p class="calibre76">Here, we must check the current name against all the unique names we have already seen. If it is a new unique name, we add it to our list of unique names. We then continue through the list, performing this step for every item in the phone book.</p></dd>
<dt class="calibre29"><a class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6" id="callout_dictionaries_and_sets_CO1-4" href="#co_dictionaries_and_sets_CO1-4"><img src="Images/4.png" alt="4" class="calibre74"/></a></dt>
<dd class="calibre75"><p class="calibre76">For the set method, instead of iterating over all unique names we have already seen, we can simply add the current name to our set of unique names. Because sets guarantee the uniqueness of the keys they contain, if you try to add an item that is already in the set, that item simply won’t be added. Furthermore, this operation costs <code class="calibre26">O(1)</code>.</p></dd>
</dl>

<p class="author1">The list algorithm’s inner loop iterates over <code class="calibre26">unique_names</code>, which starts out
as empty and then grows, in the worst case, when all names are unique, to be the
size of <code class="calibre26">phonebook</code>. This can be seen as performing a<a data-type="indexterm" data-primary="linear search" id="idm46122425744504" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>
<a href="ch03.xhtml#list_linear_search" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">linear search</a> for each name in the phone book over a list
that is constantly growing. Thus, the complete algorithm performs as <code class="calibre26">O(n^2)</code>.</p>

<p class="author1">On the other hand, the set algorithm has no inner loop; the<a data-type="indexterm" data-primary="set method" id="idm46122425742232" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <code class="calibre26">set.add</code> operation
is an <code class="calibre26">O(1)</code> process that completes in a fixed number of operations regardless
of how large the phone book is (there are some minor caveats to this, which we
will cover while discussing the implementation of dictionaries and sets). Thus,
the only nonconstant contribution to the complexity of this algorithm is the
loop over the phone book, making this algorithm perform in <code class="calibre26">O(n)</code>.</p>

<p class="author1">When timing these two algorithms using a <code class="calibre26">phonebook</code> with 10,000 entries and
7,412 unique first names, we see how drastic the difference between <code class="calibre26">O(n)</code> and
<code class="calibre26">O(n^2)</code> can be:</p>

<pre data-type="programlisting" data-code-language="pycon" class="calibre50"><code class="gp">&gt;&gt;&gt; </code><code class="o">%</code><code class="n">timeit</code> <code class="n">list_unique_names</code><code class="p">(</code><code class="n">large_phonebook</code><code class="p">)</code>
<code class="go">1.13 s ± 26.8 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</code>

<code class="gp">&gt;&gt;&gt; </code><code class="o">%</code><code class="n">timeit</code> <code class="n">set_unique_names</code><code class="p">(</code><code class="n">large_phonebook</code><code class="p">)</code>
<code class="go">4.48 ms ± 177 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)</code></pre>

<p class="author1">In other words, the set algorithm gave us a 252× speedup!  In addition, as the
size of the <code class="calibre26">phonebook</code> grows, the speed gains increase (we get a 557× speedup
with a <code class="calibre26">phonebook</code> with 100,000 entries and 15,574 unique first names).<a data-type="indexterm" data-primary="" data-startref="ds_ab" id="idm46122425487960" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="sd_abt" id="idm46122425487080" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/></p>






<section data-type="sect1" data-pdf-bookmark="How Do Dictionaries and Sets Work?" class="calibre3"><div class="preface" id="dict_set_how_work">
<h1 class="calibre25">How Do Dictionaries and Sets Work?</h1>

<p class="author1">Dictionaries and sets use <em class="hyperlink">hash tables</em> to achieve their
<code class="calibre26">O(1)</code> lookups and insertions. This efficiency is the result of a very clever
usage of a<a data-type="indexterm" data-primary="hash functions" data-secondary="in dictionaries and sets" id="idm46122425658664" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <a href="#SEC-dict-set-hash-and-entropy" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">hash function</a> to turn an arbitrary
key (i.e., a string or object) into an <a data-type="indexterm" data-primary="index method" id="idm46122425656936" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>index for a list. The hash function and
list can later be used to determine where any particular piece of data is right
away, without a search. By turning the data’s key into something that can be
used like a list index, we can get the same performance as with a list. In
addition, instead of having to refer to data by a numerical index, which itself
implies some ordering to the data, we can refer to it by this arbitrary key.</p>








<section data-type="sect2" data-pdf-bookmark="Inserting and Retrieving" class="calibre3"><div class="preface" id="idm46122425644120">
<h2 class="calibre43">Inserting and Retrieving</h2>

<p class="author1"><a data-type="indexterm" data-primary="dictionaries and sets" data-secondary="hash tables" id="ds_ht" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="dictionaries and sets" data-secondary="performance optimization" id="ds_po" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="sets and dictionaries" data-secondary="hash tables" id="sd_ht" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="sets and dictionaries" data-secondary="performance optimization" id="sd_po" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="inserting data" id="ins_dat" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="retrieving data" id="ret_dat" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>To create a hash table from scratch, we start with some allocated
memory, similar to what we started with for arrays. For an array, if we want
to insert data, we simply find the smallest unused bucket and insert our data
there (and resize if necessary). For hash tables, we must first figure out the
placement of the data in this contiguous chunk of memory.</p>

<p class="author1">The placement of the new data is contingent on two properties of the data we are
inserting: the hashed value of the key and how the value compares to other
objects. This is because when we insert data, the key is first hashed and masked<a data-type="indexterm" data-primary="masks" id="idm46122425480856" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>
so that it turns into an effective index in an array.<sup class="calibre44"><a data-type="noteref" id="idm46122425480024-marker" href="ch04.xhtml#idm46122425480024" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">2</a></sup>  The mask makes sure that the hash value,
which can take the value of any integer, fits within the allocated number of
buckets. So if we have allocated 8 blocks of memory and our hash value is
<code class="calibre26">28975</code>, we consider the bucket at index <code class="calibre26">28975 &amp; 0b111 = 7</code>. If, however, our
dictionary has grown to require 512 blocks of memory, the mask becomes
<code class="calibre26">0b111111111</code> (and in this case, we would consider the bucket at index <code class="calibre26">28975 &amp;
0b11111111</code>).</p>

<p class="author1">Now we must check if this bucket is already in use. If it is
empty, we can insert the key and the value into this block of memory. We store
the key so that we can make sure we are retrieving the correct value on lookups.
If it is in use and the value of the bucket is equal to the value we wish to
insert (a comparison done with the <code class="calibre26">cmp</code> built-in), then the key/value pair is
already in the hash table and we can return. However, if the values don’t match,
we must find a new place to put the data.</p>

<p class="author1">As an extra optimization, Python first appends the key/value data into a
standard array and then stores only the <em class="hyperlink">index</em> into this array in the hash
table. This allows us to reduce the amount of memory used by
30–95%.<sup class="calibre44"><a data-type="noteref" id="idm46122425473400-marker" href="ch04.xhtml#idm46122425473400" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">3</a></sup>
In addition, this gives us the interesting property that we keep a record of the
order which new items were added into the dictionary (which, since Python 3.7, is
a guarantee that all dictionaries give).</p>

<p class="author1">To find the new index, we compute it using a simple
linear function, a method called <a data-type="indexterm" data-primary="dictionaries and sets" data-secondary="probing" id="idm46122425470984" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="sets and dictionaries" data-secondary="probing" id="idm46122425619768" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><em class="hyperlink">probing</em>. Python’s probing mechanism adds a
contribution from the higher-order bits of the original hash (recall that for a
table of length 8 we considered only the last three bits of the hash for the initial
index, through the use of a mask value of <code class="calibre26">mask = 0b111 = bin(8 - 1)</code>). Using
these higher-order bits gives each hash a different sequence of next possible
hashes, which helps to avoid future<a data-type="indexterm" data-primary="hash functions" data-secondary="collisions and" id="idm46122425617624" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> collisions.</p>

<p class="author1">There is a lot of freedom when
picking the algorithm to generate a new index; however, it is quite important
that the scheme visits every possible index in order to evenly distribute the
data in the table. How well distributed the data is throughout the hash table is
called the <a data-type="indexterm" data-primary="load factor" id="idm46122425615848" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><em class="hyperlink">load factor</em> and is related to the<a data-type="indexterm" data-primary="entropy" id="idm46122425614760" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>
<a href="#SEC-dict-set-hash-and-entropy" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">entropy</a> of the hash function. The pseudocode
in <a data-type="xref" href="#dict_set_index_sequence" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 4-4</a> illustrates the calculation of hash indices used
in CPython 3.7. This also shows an interesting
fact about hash tables: most of the storage space they have is empty!</p>
<div id="dict_set_index_sequence" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 4-4. </span>Dictionary lookup sequence</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="kn">def</code><code class="calibre26"> </code><code class="nf">index_sequence</code><code class="p">(</code><code class="n">key</code><code class="p">,</code><code class="calibre26"> </code><code class="n">mask</code><code class="o">=</code><code class="calibre26">0b111</code><code class="p">,</code><code class="calibre26"> </code><code class="n">PERTURB_SHIFT</code><code class="o">=</code><code class="mi">5</code><code class="p">)</code><code class="p">:</code><code class="calibre26">
</code><code class="calibre26">    </code><code class="n">perturb</code><code class="calibre26"> </code><code class="o">=</code><code class="calibre26"> </code><code class="nb">hash</code><code class="p">(</code><code class="n">key</code><code class="p">)</code><code class="calibre26"> </code><a class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6" id="co_dictionaries_and_sets_CO1-1" href="#callout_dictionaries_and_sets_CO1-1"><img src="Images/1.png" alt="1" class="calibre74"/></a><code class="calibre26">
</code><code class="calibre26">    </code><code class="n">i</code><code class="calibre26"> </code><code class="o">=</code><code class="calibre26"> </code><code class="n">perturb</code><code class="calibre26"> </code><code class="o">&amp;</code><code class="calibre26"> </code><code class="n">mask</code><code class="calibre26">
</code><code class="calibre26">    </code><code class="kn">yield</code><code class="calibre26"> </code><code class="n">i</code><code class="calibre26">
</code><code class="calibre26">    </code><code class="kn">while</code><code class="calibre26"> </code><code class="nb">True</code><code class="p">:</code><code class="calibre26">
</code><code class="calibre26">        </code><code class="n">perturb</code><code class="calibre26"> </code><code class="o">&gt;&gt;</code><code class="o">=</code><code class="calibre26"> </code><code class="n">PERTURB_SHIFT</code><code class="calibre26">
</code><code class="calibre26">        </code><code class="n">i</code><code class="calibre26"> </code><code class="o">=</code><code class="calibre26"> </code><code class="p">(</code><code class="n">i</code><code class="calibre26"> </code><code class="o">*</code><code class="calibre26"> </code><code class="mi">5</code><code class="calibre26"> </code><code class="o">+</code><code class="calibre26"> </code><code class="n">perturb</code><code class="calibre26"> </code><code class="o">+</code><code class="calibre26"> </code><code class="mi">1</code><code class="p">)</code><code class="calibre26"> </code><code class="o">&amp;</code><code class="calibre26"> </code><code class="n">mask</code><code class="calibre26">
</code><code class="calibre26">        </code><code class="kn">yield</code><code class="calibre26"> </code><code class="n">i</code></pre>
<dl class="calibre28">
<dt class="calibre29"><a class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6" id="callout_dictionaries_and_sets_CO1-1" href="#co_dictionaries_and_sets_CO1-1"><img src="Images/1.png" alt="1" class="calibre74"/></a></dt>
<dd class="calibre75"><p class="calibre76"><code class="calibre26">hash</code> returns an integer, while the actual C code in CPython uses an unsigned integer. Because of that, this pseudocode doesn’t replicate exactly the behavior in CPython; however, it is a good approximation.</p></dd>
</dl></div>

<p class="author1">This probing is a modification of the naive method of<a data-type="indexterm" data-primary="linear probing" id="idm46122425609096" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="probing" id="idm46122425608424" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>
<em class="hyperlink">linear probing</em>. In linear probing, we simply yield the values
<code class="calibre26">i = (i * 5 + perturb + 1) &amp; mask</code>, where <code class="calibre26">i</code> is initialized to the hash value of the
key.<sup class="calibre44"><a data-type="noteref" id="idm46122425606376-marker" href="ch04.xhtml#idm46122425606376" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">4</a></sup>  An
important thing to note is that linear probing deals only with the last several
bits of the hash and disregards the rest (i.e., for a dictionary with eight
elements, we look only at the last three bits since at that point the mask is
<code class="calibre26">0x111</code>). This means that if hashing two items gives the same last three
binary digits, we will not only have a collision, but also the sequence of probed
indices will be the same. The perturbed scheme that Python uses will start
taking into consideration more bits from the items’ hashes to resolve
this problem.</p>

<p class="author1">A similar procedure is done when we are performing lookups on a specific key:
the given key is transformed into an index, and that index is examined. If the
key in that index matches (recall that we also store the original key when doing
insert operations), then we can return that value. If it doesn’t, we keep
creating new indices using the same scheme, until we either find the
data or hit an empty bucket. If we hit an empty bucket, we can conclude that
the data does not exist in the table.</p>

<p class="author1"><a data-type="xref" href="#FIG-hash-set-theory-example1" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Figure 4-1</a> illustrates the process of adding data
into a hash table. Here, we chose to create a hash function that simply uses the
first letter of the input. We accomplish this by using Python’s<a data-type="indexterm" data-primary="ord function" id="idm46122425390104" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <code class="calibre26">ord</code> function
on the first letter of the input to get the integer representation of that
letter (recall that hash functions must return integers). As we’ll see in
<a data-type="xref" href="#SEC-dict-set-hash-and-entropy" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">“Hash Functions and Entropy”</a>, Python provides hashing functions for most of
its types, so typically you won’t have to provide one yourself except in extreme
<span class="publishername">situations</span>.<a data-type="indexterm" data-primary="" data-startref="ins_dat" id="idm46122425387064" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="ret_dat" id="idm46122425386056" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/></p>

<figure class="calibre46"><div id="FIG-hash-set-theory-example1" class="figure">
<img src="Images/hpp2_0401.png" alt="hpp2 0401" class="calibre80"/>
<h6 class="calibre47"><span class="publishername">Figure 4-1. </span>The resulting hash table from inserting with collisions</h6>
</div></figure>

<p class="author1">Insertion of the key <code class="calibre26">Barcelona</code> causes a collision, and a
new index is calculated using the scheme in
<a data-type="xref" href="#dict_set_index_sequence" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 4-4</a>. This dictionary can also be created in Python
using the code in <a data-type="xref" href="#dict_set_naive_dict" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 4-5</a>.</p>
<div id="dict_set_naive_dict" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 4-5. </span>Custom hashing function</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="kn">class</code> <code class="nc">City</code><code class="p">(</code><code class="nb">str</code><code class="p">):</code>
    <code class="kn">def</code> <code class="calibre26">__hash__</code><code class="p">(</code><code class="nb">self</code><code class="p">):</code>
        <code class="kn">return</code> <code class="nb">ord</code><code class="p">(</code><code class="nb">self</code><code class="p">[</code><code class="mi">0</code><code class="p">])</code>

<code class="c"># We create a dictionary where we assign arbitrary values to cities</code>
<code class="n">data</code> <code class="o">=</code>  <code class="p">{</code>
    <code class="n">City</code><code class="p">(</code><code class="s">"Rome"</code><code class="p">):</code> <code class="s">'Italy'</code><code class="p">,</code>
    <code class="n">City</code><code class="p">(</code><code class="s">"San Francisco"</code><code class="p">):</code> <code class="s">'USA'</code><code class="p">,</code>
    <code class="n">City</code><code class="p">(</code><code class="s">"New York"</code><code class="p">):</code> <code class="s">'USA'</code><code class="p">,</code>
    <code class="n">City</code><code class="p">(</code><code class="s">"Barcelona"</code><code class="p">):</code> <code class="s">'Spain'</code><code class="p">,</code>
<code class="p">}</code></pre></div>

<p class="author1">In this case, <code class="calibre26">Barcelona</code> and <code class="calibre26">Rome</code> cause the hash collision
(<a data-type="xref" href="#FIG-hash-set-theory-example1" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Figure 4-1</a> shows the outcome of this insertion). We see
this because, for a dictionary with four elements, we have a mask value of <code class="calibre26">0b111</code>.
As a result, <code class="calibre26">Barcelona</code> and <code class="calibre26">Rome</code> will try to use the same index:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre50"><code class="nb">hash</code><code class="p">(</code><code class="s">"Barcelona"</code><code class="p">)</code> <code class="o">=</code> <code class="nb">ord</code><code class="p">(</code><code class="s">"B"</code><code class="p">)</code> <code class="o">&amp;</code> <code class="calibre26">0b111</code>
                  <code class="o">=</code> <code class="mi">66</code> <code class="o">&amp;</code> <code class="calibre26">0b111</code>
                  <code class="o">=</code> <code class="calibre26">0b1000010</code> <code class="o">&amp;</code> <code class="calibre26">0b111</code>
                  <code class="o">=</code> <code class="calibre26">0b010</code> <code class="o">=</code> <code class="mi">2</code>

<code class="nb">hash</code><code class="p">(</code><code class="s">"Rome"</code><code class="p">)</code> <code class="o">=</code> <code class="nb">ord</code><code class="p">(</code><code class="s">"R"</code><code class="p">)</code> <code class="o">&amp;</code> <code class="calibre26">0b111</code>
             <code class="o">=</code> <code class="mi">82</code> <code class="o">&amp;</code> <code class="calibre26">0b111</code>
             <code class="o">=</code> <code class="calibre26">0b1010010</code> <code class="o">&amp;</code> <code class="calibre26">0b111</code>
             <code class="o">=</code> <code class="calibre26">0b010</code> <code class="o">=</code> <code class="mi">2</code></pre>
<aside data-type="sidebar" epub:type="sidebar" class="calibre40"><div class="sidebar" id="idm46122425279736">
<h5 class="calibre41">Exercise</h5>
<p class="calibre73"><a data-type="indexterm" data-primary="hash functions" data-secondary="collisions and" id="idm46122425225144" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>Work through the following problems. A discussion of hash collisions follows:</p>
<ol class="calibre4">
<li class="calibre5">
<p class="calibre42"><em class="hyperlink">Finding an element</em>—Using the dictionary created in <a data-type="xref" href="#dict_set_naive_dict" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 4-5</a>, what would a lookup
on the key <code class="calibre26">Johannesburg</code> look like?  What indices would be checked?</p>
</li>
<li class="calibre5">
<p class="calibre42"><em class="hyperlink">Deleting an element</em>—Using the dictionary created in <a data-type="xref" href="#dict_set_naive_dict" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 4-5</a>, how would you
handle the deletion of the key <code class="calibre26">Rome</code>?  How would subsequent lookups for the keys
<code class="calibre26">Rome</code> and <code class="calibre26">Barcelona</code> be handled?</p>
</li>
<li class="calibre5">
<p class="calibre42"><em class="hyperlink">Hash collisions</em>—Considering the dictionary created in <a data-type="xref" href="#dict_set_naive_dict" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 4-5</a>, how many hash
collisions could you expect if 500 cities, with names all starting with an uppercase
letter, were added into a hash table?  How about 1,000 cities?  Can you think of
a way of lowering the number of collisions?</p>
</li>

</ol>

<p class="calibre73">For 500 cities, there would be approximately 474 dictionary elements that
collided with a previous value (500 – 26), with each hash having 500 / 26 = 19.2
cities associated with it. For 1,000 cities, 974 elements would collide, and each
hash would have 1,000 / 26 = 38.4 cities <span class="publishername">associated</span> with it. This is because the
hash is based simply on the numerical value of the first letter, which can
take only a value from <code class="calibre26">A</code>–<code class="calibre26">Z</code>, allowing for only 26 independent hash values. This means
that a lookup in this table could require as many as 38 subsequent lookups to
find the correct value. To fix this, we must increase the number of
possible hash values by considering other aspects of the city in the hash. The
default hash function on a string considers every character in order to maximize
the number of possible values. See <a data-type="xref" href="#SEC-dict-set-hash-and-entropy" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">“Hash Functions and Entropy”</a> for more
explanation.</p>
</div></aside>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Deletion" class="calibre3"><div class="preface" id="idm46122425643528">
<h2 class="calibre43">Deletion</h2>

<p class="author1"><a data-type="indexterm" data-primary="deletion, of values" id="idm46122425210712" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>When a value is deleted from a hash table, we cannot simply write a <code class="calibre26">NULL</code> to
that bucket of memory. This is because we have used <code class="calibre26">NULL</code>s as a sentinel
value while probing for hash collisions. As a result, we must write a special
value that signifies that the bucket is empty, but there still may be values
after it to consider when resolving a hash collision. So if “Rome” was deleted
from the dictionary, subsequent lookups for “Barcelona” will first see this
sentinel value where “Rome” used to be and instead of stopping, continue
to check the next indices given by the <a data-type="indexterm" data-primary="index_sequence" id="idm46122425208616" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><code class="calibre26">index_sequence</code>. These empty slots can
be written to in the future and are removed when the hash table is resized.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Resizing" class="calibre3"><div class="preface" id="SEC-dict-resize">
<h2 class="calibre43">Resizing</h2>

<p class="author1"><a data-type="indexterm" data-primary="resizing hash tables" id="idm46122425205448" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="dictionaries and sets" data-secondary="resizing hash tables" id="idm46122425204744" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="sets and dictionaries" data-secondary="resizing hash tables" id="idm46122425203800" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>As more items are inserted into the hash table, the table itself must be resized
to accommodate them. It can be shown that a table that is no more than two-thirds
full will have optimal space savings while still having a good bound on the
number of collisions to expect. Thus, when a table reaches this critical point,
it is grown. To do this, a larger table is allocated (i.e., more
buckets in memory are reserved), the mask is adjusted to fit the new table, and
all elements of the old table are reinserted into the new one. This requires
recomputing indices, since the changed mask will change the resulting index. As
a result, resizing large hash tables can be quite expensive!  However, since we
do this resizing operation only when the table is too small, as opposed to doing it on
every insert, the amortized cost of an insert is still
<code class="calibre26">O(1)</code>.<sup class="calibre44"><a data-type="noteref" id="idm46122425201480-marker" href="ch04.xhtml#idm46122425201480" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">5</a></sup></p>

<p class="author1">By default, the smallest size of a dictionary or set is 8 (that is, if you are
storing only three values, Python will still allocate eight elements), and it
will resize by 3× if the dictionary is more than two-thirds full. So once the sixth
item is being inserted into the originally empty dictionary, it will be resized
to hold 18 elements. At this point, once the 13th element is inserted into the object,
it will be resized to 39, then 81, and so on, always increasing
the size by 3× (we will explain how to calculate a dictionary’s size in <a data-type="xref" href="#SEC-dict-set-hash-and-entropy" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">“Hash Functions and Entropy”</a>). This gives the following possible sizes:</p>

<pre data-type="programlisting" class="calibre50">8; 18; 39; 81; 165; 333; 669; 1,341; 2,685; 5,373; 10,749; 21,501; 43,005; ...</pre>

<p class="author1">It is important to note that resizing can happen to make a hash table larger <em class="hyperlink">or</em>
smaller. That is, if sufficiently many elements of a hash table are deleted,
the table can be scaled down in size. However, <em class="hyperlink">resizing happens only during an insert</em>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Hash Functions and Entropy" class="calibre3"><div class="preface" id="SEC-dict-set-hash-and-entropy">
<h2 class="calibre43">Hash Functions and Entropy</h2>

<p class="author1"><a data-type="indexterm" data-primary="entropy" id="ent_ab" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="hash functions" data-secondary="entropy and" id="hf_ent" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>Objects in Python are generally hashable, since they already have built-in
<a data-type="indexterm" data-primary="cmp function" id="idm46122425191752" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><code class="calibre26">__hash__</code> and <code class="calibre26">__cmp__</code> functions associated with them. For numerical types<a data-type="indexterm" data-primary="int type" id="idm46122425190184" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="float type" id="idm46122425189480" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>
(<code class="calibre26">int</code> and <code class="calibre26">float</code>), the hash is based simply on the bit value of the number
they represent. Tuples and strings have a hash value that is based on their
contents. Lists, on the other hand, do not support hashing because their values
can change. Since a list’s values can change, so could the hash that represents
the list, which would change the relative placement of that key in the hash
table.<sup class="calibre44"><a data-type="noteref" id="idm46122425187416-marker" href="ch04.xhtml#idm46122425187416" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">6</a></sup></p>

<p class="author1">User-defined classes also have default hash and comparison
functions. The default <code class="calibre26">__hash__</code> function simply returns the object’s placement
in memory as given by the built-in<a data-type="indexterm" data-primary="id function" id="idm46122425185000" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <code class="calibre26">id</code> function. Similarly, the <code class="calibre26">__cmp__</code>
operator compares the numerical value of the object’s placement in memory.</p>

<p class="author1">This is generally acceptable, since two instances of a class are generally
different and should not collide in a hash table. However, in some cases we
would like to use <code class="calibre26">set</code> or <code class="calibre26">dict</code> objects to disambiguate between items. Take
the following class definition:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre50"><code class="kn">class</code> <code class="nc">Point</code><code class="p">(</code><code class="nb">object</code><code class="p">):</code>
    <code class="kn">def</code> <code class="calibre26">__init__</code><code class="p">(</code><code class="nb">self</code><code class="p">,</code> <code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">):</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">x</code><code class="p">,</code> <code class="nb">self</code><code class="o">.</code><code class="n">y</code> <code class="o">=</code> <code class="n">x</code><code class="p">,</code> <code class="n">y</code></pre>

<p class="author1">If we were to instantiate multiple <a data-type="indexterm" data-primary="Point class" id="idm46122425135352" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><code class="calibre26">Point</code> objects with the same values for <code class="calibre26">x</code>
and <code class="calibre26">y</code>, they would all be independent objects in memory and thus have different
placements in memory, which would give them all different hash values. This
means that putting them all into a <code class="calibre26">set</code> would result in all of them having
individual entries:</p>

<pre data-type="programlisting" data-code-language="pycon" class="calibre50"><code class="gp">&gt;&gt;&gt; </code><code class="n">p1</code> <code class="o">=</code> <code class="n">Point</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">1</code><code class="p">)</code>
<code class="gp">&gt;&gt;&gt; </code><code class="n">p2</code> <code class="o">=</code> <code class="n">Point</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">1</code><code class="p">)</code>
<code class="gp">&gt;&gt;&gt; </code><code class="nb">set</code><code class="p">([</code><code class="n">p1</code><code class="p">,</code> <code class="n">p2</code><code class="p">])</code>
<code class="go">set([&lt;__main__.Point at 0x1099bfc90&gt;, &lt;__main__.Point at 0x1099bfbd0&gt;])</code>
<code class="gp">&gt;&gt;&gt; </code><code class="n">Point</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">1</code><code class="p">)</code> <code class="ow">in</code> <code class="nb">set</code><code class="p">([</code><code class="n">p1</code><code class="p">,</code> <code class="n">p2</code><code class="p">])</code>
<code class="go">False</code></pre>

<p class="author1">We can remedy this by forming a custom hash function that is based on the actual
contents of the object as opposed to the object’s placement in memory. The hash
function can be any function as long as it consistently gives the same result
for the same object (there are also considerations regarding the entropy of the
hashing function, which we will discuss later.)  The following redefinition of
the <code class="calibre26">Point</code> class will yield the results we expect:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre50"><code class="kn">class</code> <code class="nc">Point</code><code class="p">(</code><code class="nb">object</code><code class="p">):</code>
    <code class="kn">def</code> <code class="calibre26">__init__</code><code class="p">(</code><code class="nb">self</code><code class="p">,</code> <code class="n">x</code><code class="p">,</code> <code class="n">y</code><code class="p">):</code>
        <code class="nb">self</code><code class="o">.</code><code class="n">x</code><code class="p">,</code> <code class="nb">self</code><code class="o">.</code><code class="n">y</code> <code class="o">=</code> <code class="n">x</code><code class="p">,</code> <code class="n">y</code>

    <code class="kn">def</code> <code class="calibre26">__hash__</code><code class="p">(</code><code class="nb">self</code><code class="p">):</code>
        <code class="kn">return</code> <code class="nb">hash</code><code class="p">((</code><code class="nb">self</code><code class="o">.</code><code class="n">x</code><code class="p">,</code> <code class="nb">self</code><code class="o">.</code><code class="n">y</code><code class="p">))</code>

    <code class="kn">def</code> <code class="calibre26">__eq__</code><code class="p">(</code><code class="nb">self</code><code class="p">,</code> <code class="n">other</code><code class="p">):</code>
        <code class="kn">return</code> <code class="nb">self</code><code class="o">.</code><code class="n">x</code> <code class="o">==</code> <code class="n">other</code><code class="o">.</code><code class="n">x</code> <code class="ow">and</code> <code class="nb">self</code><code class="o">.</code><code class="n">y</code> <code class="o">==</code> <code class="n">other</code><code class="o">.</code><code class="n">y</code></pre>

<p class="author1">This allows us to create entries in a set or dictionary indexed by the
properties of the <code class="calibre26">Point</code> object rather than the memory address of the
instantiated object:</p>

<pre data-type="programlisting" data-code-language="pycon" class="calibre50"><code class="gp">&gt;&gt;&gt; </code><code class="n">p1</code> <code class="o">=</code> <code class="n">Point</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">1</code><code class="p">)</code>
<code class="gp">&gt;&gt;&gt; </code><code class="n">p2</code> <code class="o">=</code> <code class="n">Point</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">1</code><code class="p">)</code>
<code class="gp">&gt;&gt;&gt; </code><code class="nb">set</code><code class="p">([</code><code class="n">p1</code><code class="p">,</code> <code class="n">p2</code><code class="p">])</code>
<code class="go">set([&lt;__main__.Point at 0x109b95910&gt;])</code>
<code class="gp">&gt;&gt;&gt; </code><code class="n">Point</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">)</code> <code class="ow">in</code> <code class="nb">set</code><code class="p">([</code><code class="n">p1</code><code class="p">,</code> <code class="n">p2</code><code class="p">])</code>
<code class="go">True</code></pre>

<p class="author1">As alluded to when we discussed hash collisions, a custom-selected hash
function should be careful to evenly distribute hash values in order to avoid
collisions. Having many collisions will degrade the performance of a
hash table: if most keys have collisions, we need to constantly <a data-type="indexterm" data-primary="dictionaries and sets" data-secondary="probing" id="idm46122424951896" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="probing" id="idm46122424858856" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="sets and dictionaries" data-secondary="probing" id="idm46122424858216" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>“probe” the
other values, effectively walking a potentially large portion of the dictionary
to find the key in question. In the worst case, when all keys in a
dictionary collide, the performance of lookups in the dictionary is <code class="calibre26">O(n)</code> and
thus the same as if we were searching through a list.</p>

<p class="author1">If we know that we are storing 5,000 values in a dictionary and we need to
create a hashing function for the object we wish to use as a key, we must be
aware that the dictionary will be stored in a hash table of size
16,384<sup class="calibre44"><a data-type="noteref" id="idm46122424855864-marker" href="ch04.xhtml#idm46122424855864" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">7</a></sup> and thus only
the last 14 bits of our hash are being used to create an index (for a hash table
of this size, the mask is <code class="calibre26">bin(16_384 - 1) = 0b11111111111111</code>).</p>

<p class="author1">This idea of “how well distributed my hash function is” is called the <em class="hyperlink">entropy</em> of
the hash function. Entropy is defined as</p>
<div data-type="equation" class="calibre56">
<math display="block" alttext="upper S equals minus sigma-summation Underscript i Endscripts p left-parenthesis i right-parenthesis dot log left-parenthesis p left-parenthesis i right-parenthesis right-parenthesis">
  <mrow>
    <mi>S</mi>
    <mo>=</mo>
    <mo>–</mo>
    <munder><mo>∑</mo> <mi>i</mi> </munder>
    <mi>p</mi>
    <mrow>
      <mo>(</mo>
      <mi>i</mi>
      <mo>)</mo>
    </mrow>
    <mo>·</mo>
    <mo form="prefix">log</mo>
    <mfenced separators="" open="(" close=")">
      <mi>p</mi>
      <mo>(</mo>
      <mi>i</mi>
      <mo>)</mo>
    </mfenced>
  </mrow>
</math>
</div>

<p class="author1">where <code class="calibre26">p(i)</code> is the probability that the hash function
gives hash <code class="calibre26">i</code>. It is maximized when every hash value has equal probability of
being chosen. A hash function that maximizes entropy is called an<a data-type="indexterm" data-primary="hash functions" data-secondary="ideal" id="idm46122424840392" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <em class="hyperlink">ideal</em>
hash function since it guarantees the minimal number of collisions.</p>

<p class="author1">For an infinitely large dictionary, the hash function used for integers is
ideal. This is because the hash value for an integer is simply the integer
itself!  For an infinitely large dictionary, the mask value is infinite, and thus
we consider all bits in the hash value. Therefore, given any two numbers, we can
guarantee that their hash values will not be the same.</p>

<p class="author1">However, if we made this dictionary finite, we could no longer have this
guarantee. For example, for a dictionary with four elements, the mask we use is
<code class="calibre26">0b111</code>. Thus the hash value for the number <code class="calibre26">5</code> is <code class="calibre26">5 &amp; 0b111 = 5</code>, and the hash
value for <code class="calibre26">501</code> is <code class="calibre26">501 &amp; 0b111 = 5</code>, and so their entries will collide.</p>
<div data-type="note" epub:type="note" class="calibre35"><h6 class="calibre36">Note</h6>
<p class="author1">To find the mask for a dictionary with an arbitrary number of <span class="publishername">elements,</span> <code class="calibre26">N</code>, we first find the minimum number of buckets that dictionary must have to still be two-thirds full (<code class="calibre26">N * (2 / 3 + 1)</code>). Then we find the smallest dictionary size that will hold this number of elements (8; 32; 128; 512; 2,048; etc.) and find the number of bits necessary to hold this number. For example, if <code class="calibre26">N=1039</code>, then we must have at least 1,731 buckets, which means we need a dictionary with 2,048 buckets. Thus the mask is <code class="calibre26">bin(2048 - 1) = 0b11111111111</code>.</p>
</div>

<p class="author1">There is no single best hash function to use when using a finite dictionary.
However, knowing up front what range of values will be used and how large the
dictionary will be helps in making a good selection. For example, if we
are storing all 676 combinations of two lowercase letters as keys in a
dictionary (<em class="hyperlink">aa</em>, <em class="hyperlink">ab</em>, <em class="hyperlink">ac</em>, etc.), a good hashing function would be the one shown in <a data-type="xref" href="#example_dict_set_twoletter_hash_function" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 4-6</a>.</p>
<div id="example_dict_set_twoletter_hash_function" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 4-6. </span>Optimal two-letter hashing function</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="kn">def</code> <code class="nf">twoletter_hash</code><code class="p">(</code><code class="n">key</code><code class="p">):</code>
    <code class="n">offset</code> <code class="o">=</code> <code class="nb">ord</code><code class="p">(</code><code class="s">'a'</code><code class="p">)</code>
    <code class="n">k1</code><code class="p">,</code> <code class="n">k2</code> <code class="o">=</code> <code class="n">key</code>
    <code class="kn">return</code> <code class="p">(</code><code class="nb">ord</code><code class="p">(</code><code class="n">k2</code><code class="p">)</code> <code class="o">-</code> <code class="n">offset</code><code class="p">)</code> <code class="o">+</code> <code class="mi">26</code> <code class="o">*</code> <code class="p">(</code><code class="nb">ord</code><code class="p">(</code><code class="n">k1</code><code class="p">)</code> <code class="o">-</code> <code class="n">offset</code><code class="p">)</code></pre></div>

<p class="author1">This gives no <a data-type="indexterm" data-primary="hash functions" data-secondary="collisions and" id="idm46122424811880" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>hash collisions for any combination of two lowercase letters,
considering a <a data-type="indexterm" data-primary="masks" id="idm46122424789080" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>mask of <code class="calibre26">0b1111111111</code> (a dictionary of 676 values will be held
in a hash table of length 2,048, which has a mask of <code class="calibre26">bin(2048 - 1) =
0b11111111111</code>).</p>

<p class="author1"><a data-type="xref" href="#example_dict_set_twoletter_hash_objects" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 4-7</a> very explicitly shows the ramifications of having a bad hashing
function for a user-defined class—here, the cost of a bad hash function (in
fact, it is the worst possible hash function!) is a 41.8× slowdown of lookups.</p>
<div id="example_dict_set_twoletter_hash_objects" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 4-7. </span>Timing differences between good and bad hashing functions</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="kn">import</code> <code class="nn">string</code>
<code class="kn">import</code> <code class="nn">timeit</code>

<code class="kn">class</code> <code class="nc">BadHash</code><code class="p">(</code><code class="nb">str</code><code class="p">):</code>
    <code class="kn">def</code> <code class="calibre26">__hash__</code><code class="p">(</code><code class="nb">self</code><code class="p">):</code>
        <code class="kn">return</code> <code class="mi">42</code>

<code class="kn">class</code> <code class="nc">GoodHash</code><code class="p">(</code><code class="nb">str</code><code class="p">):</code>
    <code class="kn">def</code> <code class="calibre26">__hash__</code><code class="p">(</code><code class="nb">self</code><code class="p">):</code>
        <code class="sd">"""</code>
<code class="sd">        This is a slightly optimized version of twoletter_hash</code>
<code class="sd">        """</code>
        <code class="kn">return</code> <code class="nb">ord</code><code class="p">(</code><code class="nb">self</code><code class="p">[</code><code class="mi">1</code><code class="p">])</code> <code class="o">+</code> <code class="mi">26</code> <code class="o">*</code> <code class="nb">ord</code><code class="p">(</code><code class="nb">self</code><code class="p">[</code><code class="mi">0</code><code class="p">])</code> <code class="o">-</code> <code class="mi">2619</code>

<code class="n">baddict</code> <code class="o">=</code> <code class="nb">set</code><code class="p">()</code>
<code class="n">gooddict</code> <code class="o">=</code> <code class="nb">set</code><code class="p">()</code>
<code class="kn">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="n">string</code><code class="o">.</code><code class="n">ascii_lowercase</code><code class="p">:</code>
    <code class="kn">for</code> <code class="n">j</code> <code class="ow">in</code> <code class="n">string</code><code class="o">.</code><code class="n">ascii_lowercase</code><code class="p">:</code>
        <code class="n">key</code> <code class="o">=</code> <code class="n">i</code> <code class="o">+</code> <code class="n">j</code>
        <code class="n">baddict</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">BadHash</code><code class="p">(</code><code class="n">key</code><code class="p">))</code>
        <code class="n">gooddict</code><code class="o">.</code><code class="n">add</code><code class="p">(</code><code class="n">GoodHash</code><code class="p">(</code><code class="n">key</code><code class="p">))</code>

<code class="n">badtime</code> <code class="o">=</code> <code class="n">timeit</code><code class="o">.</code><code class="n">repeat</code><code class="p">(</code>
    <code class="s">"key in baddict"</code><code class="p">,</code>
    <code class="n">setup</code> <code class="o">=</code> <code class="s">"from __main__ import baddict, BadHash; key = BadHash('zz')"</code><code class="p">,</code>
    <code class="n">repeat</code> <code class="o">=</code> <code class="mi">3</code><code class="p">,</code>
    <code class="n">number</code> <code class="o">=</code> <code class="mi">1</code><code class="n">_000_000</code><code class="p">,</code>
<code class="p">)</code>
<code class="n">goodtime</code> <code class="o">=</code> <code class="n">timeit</code><code class="o">.</code><code class="n">repeat</code><code class="p">(</code>
    <code class="s">"key in gooddict"</code><code class="p">,</code>
    <code class="n">setup</code> <code class="o">=</code> <code class="s">"from __main__ import gooddict, GoodHash; key = GoodHash('zz')"</code><code class="p">,</code>
    <code class="n">repeat</code> <code class="o">=</code> <code class="mi">3</code><code class="p">,</code>
    <code class="n">number</code> <code class="o">=</code> <code class="mi">1</code><code class="n">_000_000</code><code class="p">,</code>
<code class="p">)</code>

<code class="kn">print</code><code class="p">(</code><code class="n">f</code><code class="s">"Min lookup time for baddict: {min(badtime)}"</code><code class="p">)</code>
<code class="kn">print</code><code class="p">(</code><code class="n">f</code><code class="s">"Min lookup time for gooddict: {min(goodtime)}"</code><code class="p">)</code>

<code class="c"># Results:</code>
<code class="c">#   Min lookup time for baddict: 17.719061855008476</code>
<code class="c">#   Min lookup time for gooddict: 0.42408075400453527</code></pre></div>
<aside data-type="sidebar" epub:type="sidebar" class="calibre40"><div class="sidebar" id="idm46122424782376">
<h5 class="calibre41">Exercise</h5><ol class="calibre4">
<li class="calibre5">
<p class="calibre42">Show that for an infinite dictionary (and thus an infinite mask), using an
integer’s value as its hash gives no collisions.</p>
</li>
<li class="calibre5">
<p class="calibre42">Show that the hashing function given in
<a data-type="xref" href="#example_dict_set_twoletter_hash_function" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 4-6</a> is ideal for a hash table of size
1,024. Why is it not ideal for smaller hash tables?<a data-type="indexterm" data-primary="" data-startref="ds_ht" id="idm46122424563048" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="ds_po" id="idm46122424562104" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="sd_ht" id="idm46122424561160" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="sd_po" id="idm46122424560216" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="ent_ab" id="idm46122424559272" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="hf_ent" id="idm46122424558328" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/></p>
</li>

</ol>
</div></aside>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Dictionaries and Namespaces" class="calibre3"><div class="preface" id="dict_namespace">
<h1 class="calibre25">Dictionaries and Namespaces</h1>

<p class="author1"><a data-type="indexterm" data-primary="dictionaries and sets" data-secondary="namespace management" id="ds_nm" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="namespace management" id="nm_ab" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="sets and dictionaries" data-secondary="namespace management" id="sd_nm" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>Doing a lookup on a dictionary is fast; however, doing it unnecessarily will slow
down your code, just as any extraneous lines will. One area where this surfaces
is in Python’s namespace management, which heavily uses dictionaries to do its
lookups.</p>

<p class="author1">Whenever a variable, function, or module is invoked in Python, there is a
hierarchy that determines where it looks for these objects. First, Python looks
inside the <a data-type="indexterm" data-primary="locals() array" id="idm46122424550904" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><code class="calibre26">locals()</code> array, which has entries for all local variables.
Python works hard to make local variable lookups fast, and this is the only part
of the chain that doesn’t require a dictionary lookup. If it doesn’t exist
there, the<a data-type="indexterm" data-primary="globals() directory" id="idm46122424549608" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <code class="calibre26">globals()</code> dictionary is searched. Finally, if the object isn’t
found there, the<a data-type="indexterm" data-primary="builtin object" id="idm46122424548360" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <code class="calibre26">__builtin__</code> object is searched. It is important to note that
while <code class="calibre26">locals()</code> and <code class="calibre26">globals()</code> are explicitly dictionaries and <code class="calibre26">__builtin__</code>
is technically a module object, when searching <code class="calibre26">__builtin__</code> for a given
property, we are just doing a dictionary lookup inside <em class="hyperlink">its</em> <code class="calibre26">locals()</code> map
(this is the case for all module objects and class objects!).</p>

<p class="author1">To make this clearer, let’s look at a simple example of calling functions that
are defined in different scopes (<a data-type="xref" href="#dict_set_namespace_code" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 4-8</a>). We can
disassemble the functions with the <code class="calibre26">dis</code> module (<a data-type="xref" href="#dict_set_namespace_dis" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 4-9</a>) to
get a better understanding of how these namespace lookups are happening
(see <a data-type="xref" href="ch02.xhtml#profiling-dis" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">“Using the dis Module to Examine CPython Bytecode”</a>).</p>
<div id="dict_set_namespace_code" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 4-8. </span>Namespace lookups</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="kn">import</code> <code class="nn">math</code>
<code class="kn">from</code> <code class="nn">math</code> <code class="kn">import</code> <code class="n">sin</code>

<code class="kn">def</code> <code class="nf">test1</code><code class="p">(</code><code class="n">x</code><code class="p">):</code>
    <code class="sd">"""</code>
<code class="sd">    &gt;&gt;&gt; %timeit test1(123_456)</code>
<code class="sd">    162 µs ± 3.82 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)</code>
<code class="sd">    """</code>
    <code class="n">res</code> <code class="o">=</code> <code class="mi">1</code>
    <code class="kn">for</code> <code class="n">_</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="mi">1000</code><code class="p">):</code>
        <code class="n">res</code> <code class="o">+=</code> <code class="n">math</code><code class="o">.</code><code class="n">sin</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>
    <code class="kn">return</code> <code class="n">res</code>

<code class="kn">def</code> <code class="nf">test2</code><code class="p">(</code><code class="n">x</code><code class="p">):</code>
    <code class="sd">"""</code>
<code class="sd">    &gt;&gt;&gt; %timeit test2(123_456)</code>
<code class="sd">    124 µs ± 6.77 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)</code>
<code class="sd">    """</code>
    <code class="n">res</code> <code class="o">=</code> <code class="mi">1</code>
    <code class="kn">for</code> <code class="n">_</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="mi">1000</code><code class="p">):</code>
        <code class="n">res</code> <code class="o">+=</code> <code class="n">sin</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>
    <code class="kn">return</code> <code class="n">res</code>

<code class="kn">def</code> <code class="nf">test3</code><code class="p">(</code><code class="n">x</code><code class="p">,</code> <code class="n">sin</code><code class="o">=</code><code class="n">math</code><code class="o">.</code><code class="n">sin</code><code class="p">):</code>
    <code class="sd">"""</code>
<code class="sd">    &gt;&gt;&gt; %timeit test3(123_456)</code>
<code class="sd">    105 µs ± 3.35 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)</code>
<code class="sd">    """</code>
    <code class="n">res</code> <code class="o">=</code> <code class="mi">1</code>
    <code class="kn">for</code> <code class="n">_</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="mi">1000</code><code class="p">):</code>
        <code class="n">res</code> <code class="o">+=</code> <code class="n">sin</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>
    <code class="kn">return</code> <code class="n">res</code></pre></div>
<div id="dict_set_namespace_dis" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 4-9. </span>Namespace lookups disassembled</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="o">&gt;&gt;&gt;</code> <code class="n">dis</code><code class="o">.</code><code class="n">dis</code><code class="p">(</code><code class="n">test1</code><code class="p">)</code>
    <code class="o">...</code><code class="n">cut</code><code class="o">..</code>
             <code class="mi">20</code> <code class="n">LOAD_GLOBAL</code>              <code class="mi">1</code> <code class="p">(</code><code class="n">math</code><code class="p">)</code>
             <code class="mi">22</code> <code class="n">LOAD_METHOD</code>              <code class="mi">2</code> <code class="p">(</code><code class="n">sin</code><code class="p">)</code>
             <code class="mi">24</code> <code class="n">LOAD_FAST</code>                <code class="mi">0</code> <code class="p">(</code><code class="n">x</code><code class="p">)</code>
             <code class="mi">26</code> <code class="n">CALL_METHOD</code>              <code class="mi">1</code>
    <code class="o">...</code><code class="n">cut</code><code class="o">..</code>

<code class="o">&gt;&gt;&gt;</code> <code class="n">dis</code><code class="o">.</code><code class="n">dis</code><code class="p">(</code><code class="n">test2</code><code class="p">)</code>
    <code class="o">...</code><code class="n">cut</code><code class="o">...</code>
             <code class="mi">20</code> <code class="n">LOAD_GLOBAL</code>              <code class="mi">1</code> <code class="p">(</code><code class="n">sin</code><code class="p">)</code>
             <code class="mi">22</code> <code class="n">LOAD_FAST</code>                <code class="mi">0</code> <code class="p">(</code><code class="n">x</code><code class="p">)</code>
             <code class="mi">24</code> <code class="n">CALL_FUNCTION</code>            <code class="mi">1</code>
    <code class="o">...</code><code class="n">cut</code><code class="o">...</code>

<code class="o">&gt;&gt;&gt;</code> <code class="n">dis</code><code class="o">.</code><code class="n">dis</code><code class="p">(</code><code class="n">test3</code><code class="p">)</code>
    <code class="o">...</code><code class="n">cut</code><code class="o">...</code>
             <code class="mi">20</code> <code class="n">LOAD_FAST</code>                <code class="mi">1</code> <code class="p">(</code><code class="n">sin</code><code class="p">)</code>
             <code class="mi">22</code> <code class="n">LOAD_FAST</code>                <code class="mi">0</code> <code class="p">(</code><code class="n">x</code><code class="p">)</code>
             <code class="mi">24</code> <code class="n">CALL_FUNCTION</code>            <code class="mi">1</code>
    <code class="o">...</code><code class="n">cut</code><code class="o">...</code></pre></div>

<p class="author1">The first function, <code class="calibre26">test1</code>, makes the call to <a data-type="indexterm" data-primary="sin function" id="idm46122424442728" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><code class="calibre26">sin</code> by explicitly looking at the
math library. This is also evident in the bytecode that is produced: first a
reference to the <a data-type="indexterm" data-primary="math module" id="idm46122424250568" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><code class="calibre26">math</code> module must be loaded, and then we do an attribute lookup on
this module until we finally have a reference to the <code class="calibre26">sin</code> function. This is done
through two dictionary lookups: one to find the <code class="calibre26">math</code> module and one to find the
<code class="calibre26">sin</code> function within the module.</p>

<p class="author1">On the other hand, <code class="calibre26">test2</code> explicitly imports the <code class="calibre26">sin</code> function from the <code class="calibre26">math</code>
module, and the function is then directly accessible within the global namespace.
This means we can avoid the lookup of the <code class="calibre26">math</code> module and the subsequent
attribute lookup. However, we still must find the <code class="calibre26">sin</code> function within the
global namespace. This is yet another reason to be explicit about what
functions you are importing from a module. This practice not only makes code
more readable, because the reader knows exactly what functionality is required
from external sources, but it also simplifies changing the implementation of
specific functions and generally speeds up code!</p>

<p class="author1">Finally, <code class="calibre26">test3</code> defines the <code class="calibre26">sin</code> function as a keyword argument, with its
default value being a reference to the <code class="calibre26">sin</code> function within the <code class="calibre26">math</code> module.
While we still do need to find a reference to this function within the module,
this is necessary only when the <code class="calibre26">test3</code> function is first defined. After this, the
reference to the <code class="calibre26">sin</code> function is stored within the function definition as a
local variable in the form of a default keyword argument. As mentioned previously,
local variables do not need a dictionary lookup to be found; they are stored in
a very slim array that has very fast lookup times. Because of this, finding
the function is quite fast!</p>

<p class="author1">While these effects are an interesting result of the way namespaces in Python
are managed, <code class="calibre26">test3</code> is definitely not “Pythonic.”  Luckily, these extra
dictionary lookups start to degrade performance only when they are called a lot
(i.e., in the innermost block of a very fast loop, such as in the Julia set
example).  With this in mind, a more readable solution would be to set a local
variable with the global reference before the loop is started. We’ll still have
to do the global lookup once whenever the function is called, but all the calls
to that function in the loop will be made faster. This speaks to the fact that
even minute slowdowns in code can be amplified if that code is being run
millions of times. Even though a dictionary lookup itself may take only several
hundred nanoseconds, if we are looping millions of times over this lookup, those nanoseconds can
quickly add up.</p>
<div data-type="note" epub:type="note" class="calibre35"><h6 class="calibre36">Note</h6>
<p class="author1"><a data-type="indexterm" data-primary="benchmarks" id="idm46122424238936" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="microbenchmarks" id="idm46122424238008" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>A message about microbenchmarks: it may seem confusing that in <a data-type="xref" href="#dict_set_namespace_code" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 4-8</a> we add in extra work
with the <code class="calibre26">for</code> loop and the modification to the <code class="calibre26">res</code> variable. Originally, each
of these functions simply had the relevant <code class="calibre26">return sin(x)</code> line and nothing
else. As a result, we were also getting nanosecond runtimes and results that
did not make any sense!</p>

<p class="author1">When we added a bigger workload within each function, as done through the loop
and the modification of the <code class="calibre26">res</code> variable, we started seeing the results we
expected. With a bigger workload inside the function, we can be more sure that
we are not measuring overhead from the benchmarking/timing process. In general,
when you are running benchmarks and have a difference in timing in the
nanoseconds, it’s important to sit back for a second and think through whether
the experiment you are running is valid or whether you are measuring noise or
unrelated timings as a result of instrumentation.<a data-type="indexterm" data-primary="" data-startref="ds_nm" id="idm46122424233768" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="nm_ab" id="idm46122424232792" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="sd_nm" id="idm46122424231848" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/></p>
</div>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Wrap-Up" class="calibre3"><div class="preface" id="idm46122424556744">
<h1 class="calibre25">Wrap-Up</h1>

<p class="author1">Dictionaries and sets provide a fantastic way to store data that can be indexed
by a key. The way this key is used, through the hashing function, can greatly
affect the resulting performance of the data structure. Furthermore,
understanding how dictionaries work gives you a better understanding not only of
how to organize your data but also of how to organize your code, since dictionaries
are an intrinsic part of Python’s internal <span class="publishername">functionality.</span></p>

<p class="author1">In the next chapter we will explore generators, which allow us to provide data
to code with more control over ordering and without having to store full datasets in
memory beforehand. This lets us sidestep many of the possible hurdles that we might encounter when
using any of Python’s intrinsic data structures.<a data-type="indexterm" data-primary="" data-startref="ds_ch" id="idm46122424227720" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="sd_ch" id="idm46122424226744" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/></p>
</div></section>







<div data-type="footnotes" class="calibre52"><p data-type="footnote" id="idm46122426063384" class="calibre53"><sup class="calibre54"><a href="ch04.xhtml#idm46122426063384-marker" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">1</a></sup> As we will discuss in <a data-type="xref" href="#SEC-dict-set-hash-and-entropy" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">“Hash Functions and Entropy”</a>, dictionaries and sets are very dependent on their hash functions. If the hash function for a particular datatype is not <code class="calibre26">O(1)</code>, any dictionary or set containing that type will no longer have its <code class="calibre26">O(1)</code> guarantee.</p><p data-type="footnote" id="idm46122425480024" class="calibre53"><sup class="calibre54"><a href="ch04.xhtml#idm46122425480024-marker" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">2</a></sup> A <em class="hyperlink">mask</em> is a binary number that truncates the value of a number. So <code class="calibre26">0b1111101 &amp; 0b111 =
0b101 = 5</code> represents the operation of <code class="calibre26">0b111</code> masking the number <code class="calibre26">0b1111101</code>. This operation can also be thought of as taking a certain number of the least-significant digits of a number.</p><p data-type="footnote" id="idm46122425473400" class="calibre53"><sup class="calibre54"><a href="ch04.xhtml#idm46122425473400-marker" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">3</a></sup> The discussion that led to this improvement can be found at <a href="https://oreil.ly/Pq7Lm" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"><em class="hyperlink">https://oreil.ly/Pq7Lm</em></a>.</p><p data-type="footnote" id="idm46122425606376" class="calibre53"><sup class="calibre54"><a href="ch04.xhtml#idm46122425606376-marker" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">4</a></sup> The value of <code class="calibre26">5</code> comes from the properties of a linear congruential generator (LCG), which is used in generating random numbers.</p><p data-type="footnote" id="idm46122425201480" class="calibre53"><sup class="calibre54"><a href="ch04.xhtml#idm46122425201480-marker" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">5</a></sup> Amortized analysis looks at the average complexity of an algorithm. This means that some inserts will be much more expensive, but on average, inserts will be <code class="calibre26">O(1)</code>.</p><p data-type="footnote" id="idm46122425187416" class="calibre53"><sup class="calibre54"><a href="ch04.xhtml#idm46122425187416-marker" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">6</a></sup> More information about this can be found at <a href="https://oreil.ly/g4I5-" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"><em class="hyperlink">https://oreil.ly/g4I5-</em></a>.</p><p data-type="footnote" id="idm46122424855864" class="calibre53"><sup class="calibre54"><a href="ch04.xhtml#idm46122424855864-marker" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">7</a></sup> 5,000 values need a dictionary that has at least 8,333 buckets. The first available size that can fit this many elements is 16,384.</p></div></div></section></div>



  </body></html>