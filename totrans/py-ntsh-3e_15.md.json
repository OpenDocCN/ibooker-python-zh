["```py\n>>> lock = threading.RLock()\n>>> print(lock)\n```", "```py\n<unlocked _thread.RLock object owner=0 count=0 at 0x102878e00>\n```", "```py\n>>> `with` lock:\n...     print(lock)\n...\n```", "```py\n<locked _thread.RLock object owner=4335175040 count=1 at 0x102878e00>\n```", "```py\n>>> print(lock)\n```", "```py\n<unlocked _thread.RLock object owner=0 count=0 at 0x102878e00>\n```", "```py\nlock = threading.RLock()\nglobal_state = []\n`def` recursive_function(some, args):\n    `with` lock:  *`# acquires lock, guarantees release at end`*\n        *`# ...modify global_state...`*\n        `if` more_changes_needed(global_state):\n            recursive_function(other, args)\n```", "```py\n`with` *`c`*:\n    `while` `not` is_ok_state(s):\n        *`c`*.wait()\n    do_some_work_using_state(s)\n```", "```py\n`with` *`c`*:\n    do_something_that_modifies_state(*`s`*)\n    *`c`*.notify()    *`# or, c.notify_all()`*\n*`# no need to call c.release(), exiting 'with' intrinsically does that`*\n```", "```py\n`import` datetime, random, threading, time\n\n`def` runner():\n    print('starting')\n    time.sleep(random.randint(1, 3))\n    print('waiting')\n    event.wait()\n    print(f'running at {datetime.datetime.now()}')\n\nnum_threads = 10\nevent = threading.Event()\n\nthreads = [threading.Thread(target=runner) `for` _ `in` range(num_threads)]\n`for` t `in` threads:\n    t.start()\n\nevent.set()\n\n`for` t `in` threads:\n    t.join()\n```", "```py\n`class` Periodic(threading.Timer):\n    `def` __init__(self, interval, callback, args=`None`, kwargs=`None`):\n        super().__init__(interval, self._f, args, kwargs)\n        self.callback = callback\n\n    `def` _f(self, *args, **kwargs):\n        p = type(self)(self.interval, self.callback, args, kwargs)\n        p.start()\n        `try`:\n            self.callback(*args, **kwargs)\n        `except` Exception:\n            p.cancel()\n```", "```py\n`import` datetime, random, threading, time\n\n`def` runner():\n    print('starting')\n    time.sleep(random.randint(1, 3))\n    print('waiting')\n    `try`:\n        my_number = barrier.wait()\n    `except` threading.BrokenBarrierError:\n        print('Barrier abort() or reset() called, thread exiting...')\n        return\n    print(f'running ({my_number}) at {datetime.datetime.now()}')\n\n`def` announce_release():\n    print('releasing')\n\nnum_threads = 10\nbarrier = threading.Barrier(num_threads, action=announce_release)\n\nthreads = [threading.Thread(target=runner) `for` _ `in` range(num_threads)]\n`for` t `in` threads:\n    t.start()\n\n`for` t `in` threads:\n    t.join()\n```", "```py\n`import` threading\n\nL = threading.local()\nprint('in main thread, setting zop to 42')\nL.zop = 42\n\n`def` targ():\n  print('in subthread, setting zop to 23')\n  L.zop = 23\n  print('in subthread, zop is now', L.zop)\n\nt = threading.Thread(target=targ)\nt.start()\nt.join()\nprint('in main thread, zop is now', L.zop)\n*`# prints:`*\n*`#`* *`in main thread, setting zop to 42`*\n*`#`* *`in subthread, setting zop to 23`*\n*`#`* *`in subthread, zop is now 23`*\n*`#`* *`in main thread, zop is now 42`*\n```", "```py\n`if` *`q`*.empty():\n    print('no work to perform')\n`else`:  # Some other thread may now have emptied the queue!\n    *`x`* = *`q`*.get_nowait()\n    work_on(*`x`*)\n```", "```py\n`try`:\n    *`x`* = *`q`*.get_nowait()\n`except` queue.Empty:  # Guarantees the queue was empty when accessed\n    print('no work to perform')\n`else`:\n    work_on(*`x`*)\n```", "```py\n`with` v.get_lock():\n    v.value += 1\n```", "```py\na = multiprocessing.Array('c', b'four score and seven')\na.value = b'five'\nprint(a.value)   *`# prints`* *`b'five'`*\nprint(a[:])      *`# prints`* *`b'five\\xOOscore and seven'`*\n```", "```py\nmanager = multiprocessing.Manager()\np = manager.list()\n\np[:] = [1, 2, 3]\nprint(p == [1, 2, 3])       *`# prints`* *`False`**`,`* * `it compares with p itself`*\nprint(list(p) == [1, 2, 3]) *`# prints`* *`True`**`,`* * `it compares with copy`*\n```", "```py\n`import` multiprocessing `as` mp\n`def` f(s):\n    *`\"\"\"Run a long time, and eventually return a result.\"\"\"`*\n `import` time`,` random\n    time.sleep(random.random()*2)  *`# simulate slowness`*\n    `return` s+s                     *`# some computation or other`*\n\n`def` runner(s, d):\n    print(os.getpid(), s)\n    d[s] = f(s)\n\n`def` make_dict(strings):\n    mgr = mp.Manager()\n    d = mgr.dict()\n    workers = []\n    `for` s `in` strings:\n        p = mp.Process(target=runner, args=(s, d))\n        p.start()\n        workers.append(p)\n    `for` p `in` workers:\n        p.join()\n    `return` {**d}\n```", "```py\n`import` os, multiprocessing `as` mp\n`def` f(s):\n    *`\"\"\"Run a long time, and eventually return a result.\"\"\"`*\n `import` time, random\n    time.sleep(random.random()*2)  *`# simulate slowness`*\n    `return` s+s                     *`# some computation or other`*\n\n`def` runner(s):\n    print(os.getpid(), s)\n    `return` s, f(s)\n\n`def` make_dict(strings):\n    `with` mp.Pool() `as` pool:\n        d = dict(pool.imap_unordered(runner, strings))\n        `return` d\n```", "```py\n`def` make_dict(strings):\n    num_workers=3\n    `with` mp.pool.ThreadPool(num_workers) `as` pool:\n        d = dict(pool.imap_unordered(runner, strings))\n        `return` d\n```", "```py\n`import` concurrent.futures `as` cf\n`def` f(s):\n    *`\"\"\"run a long time and eventually return a result\"\"\"`*\n    *`# ...`* *`like before!`*\n\n`def` runner(s):\n    `return` s, f(s)\n\n`def` make_dict(strings):\n    `with` cf.ProcessPoolExecutor() `as` e:\n        d = dict(e.map(runner, strings))\n    `return` d\n```", "```py\n`import` concurrent.futures `as` cf\n\n`def` make_dict(strings):\n    `with` cf.ProcessPoolExecutor() `as` e:\n        futures = [e.submit(runner, s) `for` s `in` strings]\n        d = dict(f.result() `for` f `in` cf.as_completed(futures))\n    `return` d\n```", "```py\n`import` threading, queue\n\n`class` ExternalInterfacing(threading.Thread):\n    `def` __init__(self, external_callable, **kwds):\n        super().__init__(**kwds)\n        self.daemon = `True`\n        self.external_callable = external_callable\n        self.request_queue = queue.Queue()\n        self.result_queue = queue.Queue()\n        self.start()\n\n    `def` request(self, *args, **kwds):\n        *`\"\"\"called by other threads as external_callable would be\"\"\"`*\n        self.request_queue.put((args, kwds))\n        `return` self.result_queue.get()\n\n    `def` run(self):\n        `while` `True`:\n            a, k = self.request_queue.get()\n            self.result_queue.put(self.external_callable(*a, **k))\n```", "```py\n`import` threading, queue\n\n`class` Serializer(threading.Thread):\n    def __init__(self, **kwds):\n        super().__init__(**kwds)\n        self.daemon = `True`\n        self.work_request_queue = queue.Queue()\n        self.result_queue = queue.Queue()\n        self.start()\n\n    `def` apply(self, callable, *args, **kwds):\n        *``\"\"\"called by other threads as `callable` would be\"\"\"``*\n        self.work_request_queue.put((callable, args, kwds))\n        `return` self.result_queue.get()\n\n    `def` run(self):\n        `while` `True`:\n            callable, args, kwds = self.work_request_queue.get()\n            self.result_queue.put(callable(*args, **kwds))\n```", "```py\n`import` threading\n\n`class` Worker(threading.Thread):\n    IDlock = threading.Lock()\n    request_ID = 0\n\n    `def` __init__(self, requests_queue, results_queue, **kwds):\n        super().__init__(**kwds)\n        self.daemon = `True`\n        self.request_queue = requests_queue\n        self.result_queue = results_queue\n        self.start()\n\n    `def` perform_work(self, callable, *args, **kwds):\n        *``\"\"\"called by main thread as `callable` would be, \t\t\t   but w/o return\"\"\"``*\n        `with` self.IDlock:\n            Worker.request_ID += 1\n            self.request_queue.put(\n                (Worker.request_ID, callable, args, kwds))\n            `return` Worker.request_ID\n\n    `def` run(self):\n        `while` `True`:\n            request_ID, callable, a, k = self.request_queue.get()\n            self.result_queue.put((request_ID, callable(*a, **k)))\n```", "```py\n`import` queue\nrequests_queue = queue.Queue()\nresults_queue = queue.Queue()\nnumber_of_workers = 5\n`for` i `in` range(number_of_workers):\n    worker = Worker(requests_queue, results_queue)\n```", "```py\n`import` random, time, queue, operator\n*`# copy here class Worker as defined earlier`*\n\nrequests_queue = queue.Queue()\nresults_queue = queue.Queue()\n\nnumber_of_workers = 3\nworkers = [Worker(requests_queue, results_queue)\n           `for` i `in` range(number_of_workers)]\nwork_requests = {}\n\noperations = {\n    '+': operator.add,\n    '-': operator.sub,\n    '*': operator.mul,\n    '/': operator.truediv,\n    '%': operator.mod,\n}\n\n`def` pick_a_worker():\n    return random.choice(workers)\n\n`def` make_work():\n    o1 = random.randrange(2, 10)\n    o2 = random.randrange(2, 10)\n    op = random.choice(list(operations))\n    `return` f'{o1} {op} {o2}'\n\n`def` slow_evaluate(expression_string):\n    time.sleep(random.randrange(1, 5))\n    op1, oper, op2 = expression_string.split()\n    arith_function = operations[oper]\n    `return` arith_function(int(op1), int(op2))\n\n`def` show_results():\n    `while` `True`:\n        `try`:\n            completed_id, results = results_queue.get_nowait()\n        `except` queue.Empty:\n            `return`\n        work_expression = work_requests.pop(completed_id)\n        print(f'Result {completed_id}: {work_expression} -> {results}')\n\n`for` i `in` range(10):\n    expression_string = make_work()\n    worker = pick_a_worker()\n    request_id = worker.perform_work(slow_evaluate, expression_string)\n    work_requests[request_id] = expression_string\n    print(f'Submitted request {request_id}: {expression_string}')\n    time.sleep(1.0)\n    show_results()\n\n`while` work_requests:\n    time.sleep(1.0)\n    show_results()\n```", "```py\n`import` os\nshell = os.environ.get('COMSPEC')\n`if` shell `is` `None`:\n    shell = os.environ.get('SHELL')\n`if` shell `is` `None`:\n    shell = 'an unknown command processor'\nprint('Running under ', shell)\n```", "```py\n`import` os\nos.spawnv(os.P_WAIT, editor, (editor, textfile))\n```", "```py\nfileob = open('xxx','wb')\n`while` `True`:\n    data = input('Enter some text:')\n    fileob.seek(0)\n    fileob.write(data.encode())\n    fileob.truncate()\n    fileob.flush()\n```", "```py\n`import` mmap, os, time\nmx = mmap.mmap(os.open('xxx', os.O_RDWR), 1)\nlast = `None`\n`while` `True`:\n    mx.resize(mx.size())\n    data = mx[:]\n    `if` data != last:\n        print(data)\n        last = data\n    time.sleep(1)\n```"]