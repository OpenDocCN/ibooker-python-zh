<html><head></head><body>
<div id="sbo-rt-content"><section data-nutshell-tab="Structured Text: XML" data-pdf-bookmark="Chapter 23. Structured Text: XML" data-type="chapter" epub:type="chapter"><div class="chapter" id="structured_text_xml">
<h1><span class="label">Chapter 23. </span>Structured Text: XML</h1>
<p>XML, the<a contenteditable="false" data-primary="XML (eXtensible Markup Language)" data-type="indexterm" id="idm44924481912240"/><a contenteditable="false" data-primary="eXtensible Markup Language (XML)" data-type="indexterm" id="idm44924481911264"/><a contenteditable="false" data-primary="structured text" data-secondary="eXtensible Markup Language (XML)" data-tertiary="working with XML" data-type="indexterm" id="idm44924481910288"/> <em>eXtensible Markup Language</em>, is a widely used data interchange format. On top of XML itself, the XML community (in good part within the World Wide Web Consortium, or W3C) has standardized many other technologies, such as schema languages, namespaces, XPath, XLink, XPointer, and XSLT.</p>
<p>Industry consortia have additionally defined industry-specific markup languages on top of XML for data exchange among applications in their respective fields. XML, XML-based markup languages, and other XML-related technologies are often used for inter-application, cross-language, cross-platform data interchange in specific fields.</p>
<p>Python’s standard library, for historical reasons, has multiple modules supporting XML under the <span class="code">xml</span> package, with overlapping functionality; this book does not cover them all, but interested readers can find details in the <a href="https://oreil.ly/nHs5w">online documentation</a>.</p>
<p>This book (and, specifically, this chapter) covers only the most Pythonic approach to XML processing: <span class="code">ElementTree</span>, created by the <a href="https://oreil.ly/FjHRs">deeply missed Fredrik Lundh</a>, best known as “the effbot.”<sup><a data-type="noteref" href="ch23.xhtml#ch01fn160" id="ch01fn160-marker">1</a></sup> Its elegance, speed, generality, multiple implementations, and Pythonic architecture make this the package of choice for Python XML applications. For tutorials and complete details on the <span class="code">xml.etree.ElementTree</span> module beyond what this chapter provides, see the <a href="https://oreil.ly/pPDh8">online docs</a>. This book takes for granted some elementary <span class="keep-together">knowledge</span> of XML itself; if you need to learn more about XML, we recommend <a class="orm:hideurl" href="http://shop.oreilly.com/product/9780596007645.do"><em>XML in a Nutshell</em></a> by Elliotte Rusty Harold and W. Scott Means (O’Reilly).</p>
<p>Parsing XML from untrusted sources puts your application at risk of many possible attacks. We do not cover this issue specifically, but the <a href="https://oreil.ly/jiWUx">online documentation</a> recommends third-party modules to help safeguard your application if you do have to parse XML from sources you can’t fully trust. In particular, if you need an <span class="code">ElementTree</span> implementation with safeguards against parsing untrusted sources, consider <a href="https://oreil.ly/dl21V"><span class="code">defusedxml.ElementTree</span></a>.</p>
<section data-pdf-bookmark="ElementTree" data-type="sect1"><div class="sect1" id="elementtree">
<h1>ElementTree</h1>
<p>Python<a contenteditable="false" data-primary="structured text" data-secondary="eXtensible Markup Language (XML)" data-tertiary="ElementTree" data-type="indexterm" id="STxmleltree23"/><a contenteditable="false" data-primary="ElementTree" data-secondary="packages implementing" data-type="indexterm" id="idm44924481891872"/> and third-party add-ons offer several alternative implementations of the <span class="code">ElementTree</span> functionality; the one you can always rely on in the<a contenteditable="false" data-primary="xml.etree.ElementTree module" data-type="indexterm" id="idm44924481889680"/><a contenteditable="false" data-primary="standard library modules" data-secondary="xml.etree.ElementTree" data-type="indexterm" id="idm44924481888608"/> standard library is the module <span class="code">xml.etree.ElementTree</span>. Just importing <span class="code">xml.etree.ElementTree</span> gets you the fastest implementation available in your Python installation’s standard library. The third-party package <span class="code">defusedxml</span>, mentioned in this chapter’s introduction, offers slightly slower but safer implementations if you ever need to parse XML from untrusted sources; another third-party package, <a href="http://lxml.de"><span class="code">lxml</span></a>, gets you faster performance, and some extra functionality, via <a href="http://lxml.de/api.xhtml"><span class="code">lxml.etree</span></a>.</p>
<p>Traditionally, you get whatever available implementation of <span class="code">ElementTree</span> you prefer using a <span class="code"><strong>from</strong></span><span class="code">...<strong>import</strong>...</span><span class="code"><strong>as</strong></span> statement such as this:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">from</code></strong><code> </code><code class="nn">xml</code><code class="nn">.</code><code class="nn">etree</code><code> </code><strong><code class="kn">import</code></strong><code> </code><code class="n">ElementTree</code><code> </code><strong><code class="k">as</code></strong><code> </code><code class="n">et</code></pre>
<p>Or this, which tries to import <span class="code">lxml</span> and, if unable, falls back to the version provided in the standard library:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">try</code></strong><code class="p">:</code><code>
</code><code>    </code><strong><code class="kn">from</code></strong><code> </code><code class="nn">lxml</code><code> </code><strong><code class="kn">import</code></strong><code> </code><code class="n">etree</code><code> </code><strong><code class="k">as</code></strong><code> </code><code class="n">et</code><code>
</code><strong><code class="k">except</code></strong><code> </code><code class="ne">ImportError</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="kn">from</code></strong><code> </code><code class="nn">xml</code><code class="nn">.</code><code class="nn">etree</code><code> </code><strong><code class="kn">import</code></strong><code> </code><code class="n">ElementTree</code><code> </code><strong><code class="k">as</code></strong><code> </code><code class="n">et</code></pre>
<p>Once you succeed in importing an implementation, use it as <span class="code">et</span> (some prefer the uppercase variant, <span class="code">ET</span>) in the rest of your code.</p>
<p><span class="code">ElementTree</span> supplies one fundamental class representing a <em>node</em> within the <em>tree</em> that naturally maps an XML document: the class <span class="code">Element</span>. <span class="code">ElementTree</span> also supplies other important classes, chiefly the one representing the whole tree, with methods for input and output and many convenience classes equivalent to ones on its <span class="code">Element</span> <em>root</em>—that’s the class <span class="code">ElementTree</span>. In addition, the <span class="code">ElementTree</span> module supplies several utility functions, and auxiliary classes of lesser importance.</p>
<section data-pdf-bookmark="The Element Class" data-type="sect2"><div class="sect2" id="the_element_class">
<h2>The Element Class</h2>
<p>The<a contenteditable="false" data-primary="ElementTree" data-secondary="Element class" data-type="indexterm" id="ETelclass23"/> <span class="code">Element</span> class represents a node in the tree that maps an XML document, and it’s the core of the whole <span class="code">ElementTree</span> ecosystem. Each element is a bit like a mapping, with <em>attributes</em> that map string keys to string values, and also a bit like a sequence, with <em>children</em> that are other elements (sometimes referred to as the element’s “subelements”). In addition, each element offers a few extra attributes and methods. Each <span class="code">Element</span> instance <span class="code"><em>e</em></span> has four data attributes or properties, detailed in <a data-type="xref" href="#attributes_of_an_element_instance_e">Table 23-1</a>.</p>
<table class="border" id="attributes_of_an_element_instance_e">
<caption><span class="label">Table 23-1. </span>Attributes of an <span class="code">Element</span> instance <span class="code">e</span></caption>
<tbody>
<tr>
<td><span class="code">attrib</span></td>
<td>A <span class="code">dict</span> containing all of the XML node’s attributes, with strings, the attributes’ names, as its keys (and, usually, strings as corresponding values as well). For example, parsing the XML fragment <span class="code">&lt;a x="y"&gt;b&lt;/a&gt;c</span>, you get an <span class="code"><em>e</em></span> whose <span class="code"><em>e</em></span><span class="code">.attrib</span> is <span class="code">{'x': 'y'}</span>.
			<div data-type="tip">
<h1>Avoid Accessing attrib on Element Instances</h1>
<p>It’s normally best to avoid accessing <span class="code"><em>e</em></span><span class="code">.attrib</span> when possible, because the implementation might need to build it on the fly when you access it. <span class="code"><em>e</em></span> itself offers some typical mapping methods (listed in <a data-type="xref" href="#mapping_like_methods_of_an_element_inst">Table 23-2</a>) that you might otherwise want to call on <span class="code"><em>e</em></span><span class="code">.attrib</span>; going through <span class="code"><em>e</em></span>’s own methods allows an implementation to optimize things for you, compared to the performance you’d get via the actual <span class="code">dict</span> <span class="code"><em>e</em></span><span class="code">.attrib</span>.</p>
</div>
</td>
</tr>
<tr>
<td><span class="code">tag</span></td>
<td>The XML tag of the node: a string, sometimes also known as the element’s <em>type</em>. For example, parsing the XML fragment <span class="code">&lt;a x="y"&gt;b&lt;/a&gt;c</span>, you get an <span class="code"><em>e</em></span> with <span class="code"><em>e</em></span><span class="code">.tag</span> set to <span class="code">'a'</span>.</td>
</tr>
<tr>
<td><span class="code">tail</span></td>
<td>Arbitrary data (a string) immediately “following” the element. For example, parsing the XML fragment <span class="code">&lt;a x="y"&gt;b&lt;/a&gt;c</span>, you get an <span class="code"><em>e</em></span> with <span class="code"><em>e</em></span><span class="code">.tail</span> set to <span class="code">'c'</span>.</td>
</tr>
<tr>
<td><span class="code">text</span></td>
<td>Arbitrary data (a string) directly “within” the element. For example, parsing the XML fragment <span class="code">&lt;a x="y"&gt;b&lt;/a&gt;c</span>, you get an <span class="code"><em>e</em></span> with <span class="code"><em>e</em></span><span class="code">.text</span> set to <span class="code">'b'</span>.</td>
</tr>
</tbody>
</table>
<p><span class="code"><em>e</em></span> has some methods that are mapping-like and avoid the need to explicitly ask for the <span class="code"><em>e</em></span><span class="code">.attrib dict</span>. These are listed in <a data-type="xref" href="#mapping_like_methods_of_an_element_inst">Table 23-2</a>.</p>
<table class="border" id="mapping_like_methods_of_an_element_inst">
<caption><span class="label">Table 23-2. </span>Mapping-like methods of an <span class="code">Element</span> instance <span class="code">e</span></caption>
<tbody>
<tr>
<td><span class="code">clear</span></td>
<td><span class="code"><em>e</em></span><span class="code">.clear()</span><br/>
			Leaves <span class="code"><em>e</em></span> “empty,” except for its <span class="code">tag</span>, removing all attributes and children, and setting <span class="code">text</span> and <span class="code">tail</span> to <span class="code"><strong>None</strong></span>.</td>
</tr>
<tr>
<td><span class="code">get</span></td>
<td><span class="code"><em>e</em></span><span class="code">.get(<em>key</em>, default=<strong>None</strong>)</span><br/>
			Like <span class="code"><em>e</em></span><span class="code">.attrib.get(<em>key</em>,</span> <span class="code"><em>default</em></span><span class="code">)</span>, but potentially much faster. You cannot use <span class="code"><em>e</em></span><span class="code">[<em>key</em>]</span>, since indexing on <span class="code"><em>e</em></span> is used to access children, not attributes.</td>
</tr>
<tr>
<td><span class="code">items</span></td>
<td><span class="code"><em>e</em></span><span class="code">.items()</span><br/>
			Returns the list of <span class="code">(<em>name</em>,</span> <span class="code"><em>value</em></span><span class="code">)</span> tuples for all attributes, in arbitrary order.</td>
</tr>
<tr>
<td><span class="code">keys</span></td>
<td><span class="code"><em>e</em></span><span class="code">.keys()</span><br/>
			Returns the list of all attribute names, in arbitrary order.</td>
</tr>
<tr>
<td><span class="code">set</span></td>
<td><span class="code"><em>e</em></span><span class="code">.set(<em>key</em>,</span> <span class="code"><em>value</em></span><span class="code">)</span><br/>
			Sets the value of the attribute named <span class="code"><em>key</em></span> to <span class="code"><em>value</em></span>.</td>
</tr>
</tbody>
</table>
<p>The other methods of <span class="code"><em>e</em></span> (including methods for indexing with the <span class="code"><em>e</em></span><span class="code">[i]</span> syntax and for getting the length, as in <span class="code">len(<em>e</em>)</span>) deal with all of <span class="code"><em>e</em></span>’s children as a sequence, or in some cases—indicated in the rest of this section—with all descendants (elements in the subtree rooted at <span class="code"><em>e</em></span>, also known as subelements of <span class="code"><em>e</em></span>).</p>
<div data-type="warning" epub:type="warning">
<h1>Don’t Rely on Implicit bool Conversion of an Element</h1>
<p>In all versions up through Python 3.11, an <span class="code">Element</span> instance <span class="code"><em>e</em></span> evaluates as false if <span class="code"><em>e</em></span> has no children, following the normal rule for Python containers’ implicit <span class="code">bool</span> conversion. However, it is documented that this behavior may change in some future version of Python. For future compatibility, if you want to check whether <span class="code"><em>e</em></span> has no children, explicitly check <span class="code"><strong>if</strong></span> <span class="code">len(<em>e</em>) == 0:</span> instead of using the normal Python idiom <span class="code"><strong>if</strong></span> <span class="code"><strong>not</strong></span> <span class="code"><em>e</em></span><span class="code">:</span>.</p>
</div>
<p>The named methods of <span class="code"><em>e</em></span> dealing with children or descendants are listed in <a data-type="xref" href="#methods_of_an_element_instance_e_dealin">Table 23-3</a> (we do not cover XPath in this book: see the <a href="https://oreil.ly/6E174">online docs</a> for information on that topic). Many of the following methods take an optional argument <span class="code">namespaces</span>, defaulting to <span class="code"><strong>None</strong></span>. When present, <span class="code">namespaces</span> is a mapping with XML namespace prefixes as keys and corresponding XML namespace full names as values.</p>
<table class="border" id="methods_of_an_element_instance_e_dealin">
<caption><span class="label">Table 23-3. </span>Methods of an <span class="code">Element</span> instance <span class="code">e</span> dealing with children or descendants</caption>
<tbody>
<tr>
<td class="width-15"><span class="code">append</span></td>
<td><span class="code"><em>e</em></span><span class="code">.append(<em>se</em>)</span><br/>
			Adds subelement <span class="code"><em>se</em></span> (which must be an <span class="code">Element</span>) at the end of <span class="code"><em>e</em></span>’s children.</td>
</tr>
<tr>
<td><span class="code">extend</span></td>
<td><span class="code"><em>e</em></span><span class="code">.extend(<em>ses</em>)</span><br/>
			Adds each item of iterable <span class="code"><em>ses</em></span> (every item must be an <span class="code">Element</span>) at the end of <span class="code"><em>e</em></span>’s children.</td>
</tr>
<tr>
<td><span class="code">find</span></td>
<td><span class="code"><em>e</em></span><span class="code">.find(<em>match</em>,</span> <span class="code">namespaces=<strong>None</strong>)</span><br/>
			Returns<a contenteditable="false" data-primary="find method" data-secondary="ElementTree.Element" data-type="indexterm" id="idm44924481659200"/> the first descendant matching <span class="code"><em>match</em></span>, which may be a tag name or an XPath expression within the subset supported by the current implementation of <span class="code">ElementTree</span>. Returns <span class="code"><strong>None</strong></span> if no descendant matches <span class="code"><em>match.</em></span></td>
</tr>
<tr>
<td><span class="code">findall</span></td>
<td><span class="code"><em>e</em></span><span class="code">.findall(<em>match</em>, namespaces=<strong>None</strong>)</span><br/>
			Returns the list of all descendants matching <span class="code"><em>match</em></span>, which may be a tag name or an XPath expression within the subset supported by the current implementation of <span class="code">ElementTree</span>. Returns <span class="code">[]</span> if no descendants match <span class="code"><em>match</em></span>.</td>
</tr>
<tr>
<td><span class="code">findtext</span></td>
<td><span class="code"><em>e</em></span><span class="code">.findtext(<em>match</em>, default=<strong>None</strong>, namespaces=<strong>None</strong>)</span><br/>
			Returns the <span class="code">text</span> of the first descendant matching <span class="code"><em>match</em></span>, which may be a tag name or an XPath expression within the subset supported by the current implementation of <span class="code">ElementTree</span>. The result may be an empty string, <span class="code">''</span>, if the first descendant matching <span class="code"><em>match</em></span> has no <span class="code">text</span>. Returns <span class="code">default</span> if no descendant matches <span class="code"><em>match</em></span>.</td>
</tr>
<tr>
<td><span class="code">insert</span></td>
<td><span class="code"><em>e</em></span><span class="code">.insert(<em>index</em>,</span> <span class="code"><em>se</em></span><span class="code">)</span><br/>
			Adds subelement <span class="code"><em>se</em></span> (which must be an <span class="code">Element</span>) at index <span class="code"><em>index</em></span> within the sequence of <span class="code"><em>e</em></span>’s children.</td>
</tr>
<tr>
<td><span class="code">iter</span></td>
<td><span class="code"><em>e</em></span><span class="code">.iter(<em>tag</em>='*')</span><br/>
			Returns an iterator walking in depth-first order over all of <span class="code"><em>e</em></span>’s descendants. When <span class="code"><em>tag</em></span> is not <span class="code">'*'</span>, only yields subelements whose <span class="code">tag</span> equals <span class="code"><em>tag.</em></span> Don’t modify the subtree rooted at <span class="code"><em>e</em></span> while you’re looping on <span class="code"><em>e</em></span><span class="code">.iter</span>.</td>
</tr>
<tr>
<td><span class="code">iterfind</span></td>
<td><span class="code"><em>e</em></span><span class="code">.iterfind(<em>match</em>, namespaces=<strong>None</strong>)</span><br/>
			Returns an iterator over all descendants, in depth-first order, matching <span class="code"><em>match</em></span>, which may be a tag name or an XPath expression within the subset supported by the current implementation of <span class="code">ElementTree</span>. The resulting iterator is empty when no descendants match <span class="code"><em>match</em></span>.</td>
</tr>
<tr>
<td><span class="code">itertext</span></td>
<td><span class="code"><em>e</em></span><span class="code">.itertext(<em>match</em>, namespaces=<strong>None</strong>)</span><br/>
			Returns an iterator over the <span class="code">text</span> (not the <span class="code">tail</span>) attribute of all descendants, in depth-first order, matching <span class="code"><em>match</em></span>, which may be a tag name or an XPath expression within the subset supported by the current implementation of <span class="code">ElementTree</span>. The resulting iterator is empty when no descendants match <span class="code"><em>match</em></span>.</td>
</tr>
<tr>
<td><span class="code">remove</span></td>
<td><span class="code"><em>e</em></span><span class="code">.remove(<em>se</em>)</span><br/>
			Removes the descendant that <span class="code"><strong>is</strong></span> element <span class="code"><em>se</em></span> (as covered in <a data-type="xref" href="ch03.xhtml#operator_precedence_in_expressions">Table 3-4</a>).<a contenteditable="false" data-primary="" data-startref="ETelclass23" data-type="indexterm" id="idm44924481597456"/></td>
</tr>
</tbody>
</table>
</div></section>
<section data-pdf-bookmark="The ElementTree Class" data-type="sect2"><div class="sect2" id="the_elementtree_class">
<h2>The ElementTree Class</h2>
<p>The<a contenteditable="false" data-primary="ElementTree" data-secondary="ElementTree class" data-type="indexterm" id="idm44924481594208"/> <span class="code">ElementTree</span> class represents a tree that maps an XML document. The core added value of an instance <span class="code"><em>et</em></span> of <span class="code">ElementTree</span> is to have methods for wholesale parsing (input) and writing (output) of a whole tree. These methods are described in <a data-type="xref" href="#elementtree_instance_parsing_and_writin">Table 23-4</a>.</p>
<table class="border" id="elementtree_instance_parsing_and_writin">
<caption><span class="label">Table 23-4. </span><span class="code">ElementTree</span> instance parsing and writing methods</caption>
<tbody>
<tr>
<td><span class="code">parse</span></td>
<td><span class="code"><em>et</em></span><span class="code">.parse(<em>source</em>, parser=<strong>None</strong>)</span><br/>
<span class="code"><em>source</em></span> can be a file open for reading, or the name of a file to open and read (to parse a string, wrap it in <span class="code">io.StringIO</span>, covered in <a data-type="xref" href="ch11.xhtml#in_memory_files_iodotstringio_and_iodot">“In-Memory Files: io.StringIO and io.BytesIO”</a>), containing XML text. <span class="code"><em>et</em></span><span class="code">.parse</span> parses that text, builds its tree of <span class="code">Element</span>s as the new content of <span class="code"><em>et</em></span> (discarding the previous content of <span class="code"><em>et</em></span>, if any), and returns the root element of the tree. <span class="code">parser</span> is an optional parser instance; by default, <span class="code"><em>et</em></span><span class="code">.parse</span> uses an instance of class <span class="code">XMLParser</span> supplied by the <span class="code">ElementTree</span> module (this book does not cover <span class="code">XMLParser</span>; see the <a href="https://oreil.ly/TXwf5">online docs</a>).</td>
</tr>
<tr>
<td><span class="code">write</span></td>
<td><span class="code"><em>et</em></span><span class="code">.write(<em>file</em>, encoding='us-ascii', xml_declaration=<strong>None</strong>, default_namespace=<strong>None</strong>, method='xml', short_empty_elements=True)</span><br/>
<span class="code"><em>file</em></span> can be a file open for writing, or the name of a file to open and write (to write into a string, pass as <span class="code"><em>file</em></span> an instance of <span class="code">io.StringIO</span>, covered in <a data-type="xref" href="ch11.xhtml#in_memory_files_iodotstringio_and_iodot">“In-Memory Files: io.StringIO and io.BytesIO”</a>). <span class="code"><em>et</em></span><span class="code">.write</span> writes into that file the text representing the XML document for the tree that is the content of <span class="code"><em>et</em></span>.</td>
</tr>
<tr>
<td><span class="code">write</span><br/>
<em>(cont.)</em></td>
<td><span class="code"><em>encoding</em></span> should be spelled according to the <a href="https://oreil.ly/Vlj0C">standard</a>, not by using common “nicknames”—for example, <span class="code">'iso-8859-1'</span>, not <span class="code">'latin-1'</span>, even though Python itself accepts both spellings for this encoding, and similarly <span class="code">'utf-8'</span>, with the dash, not <span class="code">'utf8'</span>, without it. The best choice often is to pass <span class="code">encoding</span> as <span class="code">'unicode'</span>. This outputs text (Unicode) strings, when <span class="code"><em>file</em></span><span class="code">.write</span> accepts such strings; otherwise, <span class="code"><em>file</em></span><span class="code">.write</span> must accept bytestrings, and that will be the type of strings that <span class="code"><em>et</em></span><span class="code">.write</span> outputs, using XML character references for characters not in the encoding—for example, with the default US-ASCII encoding, “e with an acute accent,” <span class="code">é</span>, is output as <span class="code">&amp;#233;</span>.<br/>
			You can pass <span class="code">xml_declaration</span> as <span class="code"><strong>False</strong></span> to not have the declaration in the resulting text, or as <span class="code"><strong>True</strong></span> to have it; the default is to have the declaration in the result only when <span class="code">encoding</span> is not one of <span class="code">'us-ascii'</span>, <span class="code">'utf-8'</span>, or <span class="code">'unicode'</span>.<br/>
			You can optionally pass <span class="code">default_namespace</span> to set the default namespace for <span class="code">xmlns</span> constructs.<br/>
			You can pass <span class="code">method</span> as <span class="code">'text'</span> to output only the <span class="code">text</span> and <span class="code">tail</span> of each node (no tags). You can pass <span class="code">method</span> as <span class="code">'html'</span> to output the document in HTML format (which, for example, omits end tags not needed in HTML, such as <span class="code">&lt;/br&gt;</span>). The default is <span class="code">'xml'</span>, to output in XML format.<br/>
			You can optionally (only by name, not positionally) pass <span class="code">short_empty_elements</span> as <span class="code"><strong>False</strong></span> to always use explicit start and end tags, even for elements that have no text or subelements; the default is to use the XML short form for such empty elements. For example, an empty element with tag <span class="code">a</span> is output as <span class="code">&lt;a/&gt;</span> by default, or as <span class="code">&lt;a&gt;&lt;/a&gt;</span> if you pass <span class="code">short_empty_elements</span> as <span class="code"><strong>False</strong></span>.</td>
</tr>
</tbody>
</table>
<p>In addition, an instance <span class="code"><em>et</em></span> of <span class="code">ElementTree</span> supplies the method <span class="code">getroot</span> (to return the root of the tree) and the convenience methods <span class="code">find</span>, <span class="code">findall</span>, <span class="code">findtext</span>, <span class="code">iter</span>, and <span class="code">iterfind</span>, each exactly equivalent to calling the same method on the root of the tree—that is, on the result of <span class="code"><em>et</em></span><span class="code">.getroot</span>.</p>
</div></section>
<section data-pdf-bookmark="Functions in the ElementTree Module" data-type="sect2"><div class="sect2" id="functions_in_the_elementtree_module">
<h2>Functions in the ElementTree Module</h2>
<p>The<a contenteditable="false" data-primary="ElementTree" data-secondary="functions in ElementTree module" data-type="indexterm" id="ETfunc23"/> <span class="code">ElementTree</span> module also supplies several functions, described in <a data-type="xref" href="#elementtree_functions">Table 23-5</a>.</p>
<table class="border" id="elementtree_functions">
<caption><span class="label">Table 23-5. </span><span class="code">ElementTree</span> functions</caption>
<tbody>
<tr>
<td class="width-15"><span class="code">Comment</span></td>
<td><span class="code">Comment(text=<strong>None</strong>)</span><br/>
			Returns an <span class="code">Element</span> that, once inserted as a node in an <span class="code">ElementTree</span>, will be output as an XML comment with the given <span class="code">text</span> string enclosed between <span class="code">'&lt;!--'</span> and <span class="code">'--&gt;'</span>. <span class="code">XMLParser</span> skips XML comments in any document it parses, so this function is the only way to insert comment nodes.</td>
</tr>
<tr>
<td><span class="code">dump</span></td>
<td><span class="code">dump(<em>e</em>)</span><br/>
			Writes <span class="code">e</span>, which can be an <span class="code">Element</span> or an <span class="code">ElementTree</span>, as XML to <span class="code">sys.stdout</span>. This function is meant only for debugging purposes.</td>
</tr>
<tr>
<td><span class="code">fromstring</span></td>
<td><span class="code">fromstring(<em>text</em>, parser=<strong>None</strong>)</span><br/>
			Parses XML from the <span class="code"><em>text</em></span> string and returns an <span class="code">Element</span>, just like the XML function just covered.</td>
</tr>
<tr>
<td><span class="code">fromstringlist</span></td>
<td><span class="code">fromstringlist(<em>sequence</em>, parser=<strong>None</strong>)</span><br/>
			Just like <span class="code">fromstring(''.join(<em>sequence</em>))</span>, but can be a bit faster by avoiding the <span class="code">join</span>.</td>
</tr>
<tr>
<td><span class="code">iselement</span></td>
<td><span class="code">iselement(<em>e</em>)</span><br/>
			Returns <span class="code"><strong>True</strong></span> if <span class="code"><em>e</em></span> is an <span class="code">Element</span>; otherwise, returns <span class="code"><strong>False</strong></span>.</td>
</tr>
<tr>
<td><span class="code">iterparse</span></td>
<td><span class="code">iterparse(<em>source</em>, events=['end'], parser=<strong>None</strong>)</span><br/>
			Parses an XML document and incrementally builds the corresponding <span class="code">ElementTree</span>. <span class="code"><em>source</em></span> can be a file open for reading, or the name of a file to open and read, containing an XML document as text. <span class="code">iterparse</span> returns an iterator yielding two-item tuples <span class="code">(<em>event</em>,</span> <span class="code"><em>element</em></span><span class="code">)</span>, where <span class="code"><em>event</em></span> is one of the strings listed in the argument <span class="code">events</span> (each string must be <span class="code">'start'</span>, <span class="code">'end'</span>, <span class="code">'start-ns'</span>, or <span class="code">'end-ns'</span>), as the parsing progresses. <span class="code"><em>element</em></span> is an <span class="code">Element</span> for events <span class="code">'start'</span> and <span class="code">'end'</span>, <span class="code"><strong>None</strong></span> for event <span class="code">'end-ns'</span>, and a tuple of two strings <span class="code">(<em>namespace_prefix</em>,</span> <span class="code"><em>namespace_uri</em></span><span class="code">)</span> for event <span class="code">'start-ns'</span>. <span class="code">parser</span> is an optional parser instance; by default, <span class="code">iterparse</span> uses an instance of the class <span class="code">XMLParser</span> supplied by the <span class="code">ElementTree</span> module (see the <a href="https://oreil.ly/wG429">online docs</a> for details on the <span class="code">XMLParser</span> class).<br/>
			The purpose of <span class="code">iterparse</span> is to let you iteratively parse a large XML document, without holding all of the resulting <span class="code">ElementTree</span> in memory at once, whenever feasible. We cover <span class="code">iterparse</span> in more detail in <a data-type="xref" href="#parsing_xml_iteratively">“Parsing XML Iteratively”</a>.</td>
</tr>
<tr>
<td><span class="code">parse</span></td>
<td><span class="code">parse(<em>source</em>, parser=<strong>None</strong>)</span><br/>
			Just like the <span class="code">parse</span> method of <span class="code">ElementTree</span>, covered in <a data-type="xref" href="#elementtree_instance_parsing_and_writin">Table 23-4</a>, except that it returns the <span class="code">ElementTree</span> instance it creates.</td>
</tr>
<tr>
<td><span class="code">P⁠r⁠o⁠c⁠e⁠s⁠s⁠i⁠n⁠g​I⁠n⁠s⁠t⁠r⁠u⁠c⁠t⁠i⁠o⁠n</span></td>
<td><span class="code">ProcessingInstruction(<em>target</em>, text=<strong>None</strong>)</span><br/>
			Returns an <span class="code">Element</span> that, once inserted as a node in an <span class="code">ElementTree</span>, will be output as an XML processing instruction with the given <span class="code"><em>target</em></span> and <span class="code">text</span> strings enclosed between <span class="code">'&lt;?'</span> and <span class="code">'?&gt;'</span>. <span class="code">XMLParser</span> skips XML processing instructions in any document it parses, so this function is the only way to insert processing instruction nodes.</td>
</tr>
<tr>
<td><span class="code">r⁠e⁠g⁠i⁠s⁠t⁠e⁠r⁠_​n⁠a⁠m⁠e⁠s⁠p⁠a⁠c⁠e</span></td>
<td><span class="code">register_namespace(<em>prefix</em>,</span> <span class="code"><em>uri</em></span><span class="code">)</span><br/>
			Registers the string <span class="code"><em>prefix</em></span> as the namespace prefix for the string <span class="code"><em>uri</em></span>; elements in the namespace get serialized with this prefix.</td>
</tr>
<tr>
<td><span class="code">SubElement</span></td>
<td><span class="code">SubElement(<em>parent</em>,</span> <span class="code"><em>tag</em></span><span class="code">, attrib={}, **<em>extra</em>)</span><br/>
			Creates an <span class="code">Element</span> with the given <span class="code"><em>tag</em></span>, attributes from <span class="code">dict</span> <span class="code">attrib</span>, and others passed as named arguments in <span class="code"><em>extra</em></span>, and appends it as the rightmost child of <span class="code">Element</span> <span class="code"><em>parent</em></span>; returns the <span class="code">Element</span> it has created.</td>
</tr>
<tr>
<td><span class="code">tostring</span></td>
<td><span class="code">tostring(<em>e</em>, encoding='us-ascii, method='xml', short_empty_elements=<strong>True</strong>)</span><br/>
			Returns a string with the XML representation of the subtree rooted at <span class="code">Element</span> <span class="code"><em>e</em></span>. Arguments have the same meaning as for the <span class="code">write</span> method of <span class="code">ElementTree</span>, covered in <a data-type="xref" href="#elementtree_instance_parsing_and_writin">Table 23-4</a>.</td>
</tr>
<tr>
<td><span class="code">tostringlist</span></td>
<td><span class="code">tostringlist(</span><span class="code"><em>e,</em></span> <span class="code">encoding='us-ascii', method='xml', short_empty_elements=<strong>True</strong>)</span><br/>
			Returns a list of strings with the XML representation of the subtree rooted at <span class="code">Element</span> <span class="code"><em>e</em></span>. Arguments have the same meaning as for the <span class="code">write</span> method of <span class="code">ElementTree</span>, covered in <a data-type="xref" href="#elementtree_instance_parsing_and_writin">Table 23-4</a>.</td>
</tr>
<tr>
<td><span class="code">XML</span></td>
<td><span class="code">XML(<em>text</em>, parser=<strong>None</strong>)</span><br/>
			Parses XML from the <span class="code"><em>text</em></span> string and returns an <span class="code">Element</span>. <span class="code">parser</span> is an optional parser instance; by default, <span class="code">XML</span> uses an instance of the class <span class="code">XMLParser</span> supplied by the <span class="code">ElementTree</span> module (this book does not cover the <span class="code">XMLParser</span> class; see the <a href="https://oreil.ly/wG429">online docs</a> for details).</td>
</tr>
<tr>
<td><span class="code">XMLID</span></td>
<td><span class="code">XMLID(<em>text</em>, parser=<strong>None</strong>)</span><br/>
			Parses XML from the <span class="code"><em>text</em></span> string and returns a tuple with two items: an <span class="code">Element</span> and a <span class="code">dict</span> mapping <span class="code">id</span> attributes to the only <span class="code">Element</span> having each (XML forbids duplicate <span class="code">id</span>s). <span class="code">parser</span> is an optional parser instance; by default, <span class="code">XMLID</span> uses an instance of the class <span class="code">XMLParser</span> supplied by the <span class="code">ElementTree</span> module (this book does not cover the <span class="code">XMLParser</span> class; see the <a href="https://oreil.ly/wG429">online docs</a> for details).</td>
</tr>
</tbody>
</table>
<p>The <span class="code">ElementTree</span> module also supplies the classes <span class="code">QName</span>, <span class="code">TreeBuilder</span>, and <span class="code">XMLParser</span>, which we do not cover in this book, and the class <span class="code">XMLPullParser</span>, covered in <a data-type="xref" href="#parsing_xml_iteratively">“Parsing XML Iteratively”</a>.<a contenteditable="false" data-primary="" data-startref="ETfunc23" data-type="indexterm" id="idm44924481378528"/><a contenteditable="false" data-primary="" data-startref="STxmleltree23" data-type="indexterm" id="idm44924481377152"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Parsing XML with ElementTree.parse" data-type="sect1"><div class="sect1" id="parsing_xml_with_elementtreedotparse">
<h1>Parsing XML with ElementTree.parse</h1>
<p>In<a contenteditable="false" data-primary="structured text" data-secondary="eXtensible Markup Language (XML)" data-tertiary="parsing XML with ElementTree.parse" data-type="indexterm" id="STxmlpars23"/><a contenteditable="false" data-primary="ElementTree" data-secondary="parsing XML with ElementTree.parse" data-type="indexterm" id="ETpars23"/> everyday use, the most common way to make an <span class="code">ElementTree</span> instance is by parsing it from a file or file-like object, usually with the module function <span class="code">parse</span> or with the method <span class="code">parse</span> of instances of the class <span class="code">ElementTree</span>.</p>
<p>For the examples in the remainder of this chapter, we use the simple XML file found at <a href="http://www.w3schools.com/xml/simple.xml"><em>http://www.w3schools.com/xml/simple.xml</em></a>; its root tag is <span class="code">'breakfast_menu'</span>, and the root’s children are elements with the tag <span class="code">'food'</span>. Each <span class="code">'food'</span> element has a child with the tag <span class="code">'name'</span>, whose text is the food’s name, and a child with the tag <span class="code">'calories'</span>, whose text is the string representation of the integer number of calories in a portion of that food. In other words, a simplified representation of that XML file’s content of interest to the examples is:</p>
<pre data-code-language="xml" data-type="programlisting">
<strong><code class="nt">&lt;breakfast_menu</code><code class="nt">&gt;</code></strong><code>
</code><strong><code>  </code><code class="nt">&lt;food</code><code class="nt">&gt;</code></strong><code>
    </code><strong><code class="nt">&lt;name</code><code class="nt">&gt;</code></strong><code>Belgian Waffles</code><strong><code class="nt">&lt;/name&gt;</code></strong><code>
    </code><strong><code class="nt">&lt;calories</code><code class="nt">&gt;</code></strong><code>650</code><strong><code class="nt">&lt;/calories&gt;</code></strong><code>
</code><strong><code>  </code><code class="nt">&lt;/food&gt;</code></strong><code>
</code><strong><code>  </code><code class="nt">&lt;food</code><code class="nt">&gt;</code></strong><code>
    </code><strong><code class="nt">&lt;name</code><code class="nt">&gt;</code></strong><code>Strawberry Belgian Waffles</code><strong><code class="nt">&lt;/name&gt;</code></strong><code>
    </code><strong><code class="nt">&lt;calories</code><code class="nt">&gt;</code></strong><code>900</code><strong><code class="nt">&lt;/calories&gt;</code></strong><code>
</code><strong><code>  </code><code class="nt">&lt;/food&gt;</code></strong><code>
</code><strong><code>  </code><code class="nt">&lt;food</code><code class="nt">&gt;</code></strong><code>
    </code><strong><code class="nt">&lt;name</code><code class="nt">&gt;</code></strong><code>Berry-Berry Belgian Waffles</code><strong><code class="nt">&lt;/name&gt;</code></strong><code>
    </code><strong><code class="nt">&lt;calories</code><code class="nt">&gt;</code></strong><code>900</code><strong><code class="nt">&lt;/calories&gt;</code></strong><code>
</code><strong><code>  </code><code class="nt">&lt;/food&gt;</code></strong><code>
</code><strong><code>  </code><code class="nt">&lt;food</code><code class="nt">&gt;</code></strong><code>
    </code><strong><code class="nt">&lt;name</code><code class="nt">&gt;</code></strong><code>French Toast</code><strong><code class="nt">&lt;/name&gt;</code></strong><code>
    </code><strong><code class="nt">&lt;calories</code><code class="nt">&gt;</code></strong><code>600</code><strong><code class="nt">&lt;/calories&gt;</code></strong><code>
</code><strong><code>  </code><code class="nt">&lt;/food&gt;</code></strong><code>
</code><strong><code>  </code><code class="nt">&lt;food</code><code class="nt">&gt;</code></strong><code>
    </code><strong><code class="nt">&lt;name</code><code class="nt">&gt;</code></strong><code>Homestyle Breakfast</code><strong><code class="nt">&lt;/name&gt;</code></strong><code>
    </code><strong><code class="nt">&lt;calories</code><code class="nt">&gt;</code></strong><code>950</code><strong><code class="nt">&lt;/calories&gt;</code></strong><code>
</code><strong><code>  </code><code class="nt">&lt;/food&gt;</code></strong><code>
</code><strong><code class="nt">&lt;/breakfast_menu&gt;</code></strong></pre>
<p>Since the XML document lives at a WWW URL, you start by obtaining a file-like object with that content, and passing it to <span class="code">parse</span>; the simplest way uses the <span class="code keep-together">urllib.request</span> module:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">from</code><code> </code><code class="nn">urllib</code><code> </code><code class="kn">import</code></strong><code> </code><code class="n">request</code><code>
</code><strong><code class="kn">from</code><code> </code><code class="nn">xml</code><code class="nn">.</code><code class="nn">etree</code><code> </code><code class="kn">import</code></strong><code> </code><code class="n">ElementTree</code><code> </code><strong><code class="k">as</code></strong><code> </code><code class="n">et</code><code>
</code><code class="n">content</code><code> </code><code class="o">=</code><code> </code><code class="n">request</code><code class="o">.</code><code class="n">urlopen</code><code class="p">(</code><code class="s1">'</code><code class="s1">http://www.w3schools.com/xml/simple.xml</code><code class="s1">'</code><code class="p">)</code><code>
</code><code class="n">tree</code><code> </code><code class="o">=</code><code> </code><code class="n">et</code><code class="o">.</code><code class="n">parse</code><code class="p">(</code><code class="n">content</code><code class="p">)</code></pre>
<section data-pdf-bookmark="Selecting Elements from an ElementTree" data-type="sect2"><div class="sect2" id="selecting_elements_from_an_elementtree">
<h2>Selecting Elements from an ElementTree</h2>
<p>Let’s say that we want to print on standard output the calories and names of the various foods, in order of increasing calories, with ties broken alphabetically. Here’s the code for this task:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">def</code></strong><code> </code><code class="nf">bycal_and_name</code><code class="p">(</code><code class="n">e</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">return</code></strong><code> </code><code class="nb">int</code><code class="p">(</code><code class="n">e</code><code class="o">.</code><code class="n">find</code><code class="p">(</code><code class="s1">'</code><code class="s1">calories</code><code class="s1">'</code><code class="p">)</code><code class="o">.</code><code class="n">text</code><code class="p">)</code><code class="p">,</code><code> </code><code class="n">e</code><code class="o">.</code><code class="n">find</code><code class="p">(</code><code class="s1">'</code><code class="s1">name</code><code class="s1">'</code><code class="p">)</code><code class="o">.</code><code class="n">text</code><code>
</code><code>
</code><strong><code class="k">for</code><code> </code><code class="n">e</code><code> </code><code class="ow">in</code></strong><code> </code><code class="nb">sorted</code><code class="p">(</code><code class="n">tree</code><code class="o">.</code><code class="n">findall</code><code class="p">(</code><code class="s1">'</code><code class="s1">food</code><code class="s1">'</code><code class="p">)</code><code class="p">,</code><code> </code><code class="n">key</code><code class="o">=</code><code class="n">bycal_and_name</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s2">"</code><code class="si">{</code><code class="n">e</code><code class="o">.</code><code class="n">find</code><code class="p">(</code><code class="s1">'</code><code class="s1">calories</code><code class="s1">'</code><code class="p">)</code><code class="o">.</code><code class="n">text</code><code class="si">}</code><code class="s2"> </code><code class="si">{</code><code class="n">e</code><code class="o">.</code><code class="n">find</code><code class="p">(</code><code class="s1">'</code><code class="s1">name</code><code class="s1">'</code><code class="p">)</code><code class="o">.</code><code class="n">text</code><code class="si">}</code><code class="s2">"</code><code class="p">)</code></pre>
<p>When run, this prints:</p>
<pre data-type="programlisting">
<strong>600 French Toast</strong>
<strong>650 Belgian Waffles</strong>
<strong>900 Berry-Berry Belgian Waffles</strong>
<strong>900 Strawberry Belgian Waffles</strong>
<strong>950 Homestyle Breakfast</strong></pre>
</div></section>
<section data-pdf-bookmark="Editing an ElementTree" data-type="sect2"><div class="sect2" id="editing_an_elementtree">
<h2>Editing an ElementTree</h2>
<p>Once an <span class="code">ElementTree</span> is built (be that via parsing, or otherwise), you can “edit” it—inserting, deleting, and/or altering nodes (elements)—via various methods of the <span class="code">ElementTree</span> and <span class="code">Element</span> classes, and module functions. For example, suppose our program is reliably informed that a new food has been added to the menu—buttered toast, two slices of white bread toasted and buttered, 180 calories—while any food whose name contains “berry,” case insensitive, has been removed. The “editing the tree” part for these specs can be coded as follows:</p>
<pre data-code-language="python" data-type="programlisting">
<em><code class="c1"># add Buttered Toast to the menu</code></em><code>
</code><code class="n">menu</code><code> </code><code class="o">=</code><code> </code><code class="n">tree</code><code class="o">.</code><code class="n">getroot</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="n">toast</code><code> </code><code class="o">=</code><code> </code><code class="n">et</code><code class="o">.</code><code class="n">SubElement</code><code class="p">(</code><code class="n">menu</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">food</code><code class="s1">'</code><code class="p">)</code><code>
</code><code class="n">tcals</code><code> </code><code class="o">=</code><code> </code><code class="n">et</code><code class="o">.</code><code class="n">SubElement</code><code class="p">(</code><code class="n">toast</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">calories</code><code class="s1">'</code><code class="p">)</code><code>
</code><code class="n">tcals</code><code class="o">.</code><code class="n">text</code><code> </code><code class="o">=</code><code> </code><code class="s1">'</code><code class="s1">180</code><code class="s1">'</code><code>
</code><code class="n">tname</code><code> </code><code class="o">=</code><code> </code><code class="n">et</code><code class="o">.</code><code class="n">SubElement</code><code class="p">(</code><code class="n">toast</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">name</code><code class="s1">'</code><code class="p">)</code><code>
</code><code class="n">tname</code><code class="o">.</code><code class="n">text</code><code> </code><code class="o">=</code><code> </code><code class="s1">'</code><code class="s1">Buttered Toast</code><code class="s1">'</code><code>
</code><em><code class="c1"># remove anything related to 'berry' from the menu</code></em><code>
</code><strong><code class="k">for</code><code> </code><code class="n">e</code><code> </code><code class="ow">in</code></strong><code> </code><code class="n">menu</code><code class="o">.</code><code class="n">findall</code><code class="p">(</code><code class="s1">'</code><code class="s1">food</code><code class="s1">'</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">name</code><code> </code><code class="o">=</code><code> </code><code class="n">e</code><code class="o">.</code><code class="n">find</code><code class="p">(</code><code class="s1">'</code><code class="s1">name</code><code class="s1">'</code><code class="p">)</code><code class="o">.</code><code class="n">text</code><code>
</code><code>    </code><strong><code class="k">if</code></strong><code> </code><code class="s1">'</code><code class="s1">berry</code><code class="s1">'</code><code> </code><strong><code class="ow">in</code></strong><code> </code><code class="n">name</code><code class="o">.</code><code class="n">lower</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="n">menu</code><code class="o">.</code><code class="n">remove</code><code class="p">(</code><code class="n">e</code><code class="p">)</code></pre>
<p>Once we insert these “editing” steps between the code parsing the tree and the code selectively printing from it, the latter prints:</p>
<pre data-type="programlisting">
<strong>180 Buttered Toast</strong>
<strong>600 French Toast</strong>
<strong>650 Belgian Waffles</strong>
<strong>950 Homestyle Breakfast</strong></pre>
<p>The ease of editing an <span class="code">ElementTree</span> can sometimes be a crucial consideration, making it worth your while to keep it all in memory.<a contenteditable="false" data-primary="" data-startref="ETpars23" data-type="indexterm" id="idm44924476355584"/><a contenteditable="false" data-primary="" data-startref="STxmlpars23" data-type="indexterm" id="idm44924476354368"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Building an ElementTree from Scratch" data-type="sect1"><div class="sect1" id="building_an_elementtree_from_scratch">
<h1>Building an ElementTree from Scratch</h1>
<p>Sometimes, your<a contenteditable="false" data-primary="structured text" data-secondary="eXtensible Markup Language (XML)" data-tertiary="building an ElementTree from scratch" data-type="indexterm" id="idm44924476351088"/><a contenteditable="false" data-primary="ElementTree" data-secondary="building an ElementTree from scratch" data-type="indexterm" id="idm44924476349472"/> task doesn’t start from an existing XML document: rather, you need to make an XML document from data your code gets from a different source, such as a CSV file or some kind of database.</p>
<p>The code for such tasks is similar to the code we showed for editing an existing <span class="code">ElementTree</span>—just add a little snippet to build an initially empty tree.</p>
<p>For example, suppose you have a CSV file, <em>menu.csv</em>, whose two comma-separated columns are the calories and names of various foods, one food per row. Your task is to build an XML file, <em>menu.xml</em>, similar to the one we parsed in the previous examples. Here’s one way you could do that:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="kn">import</code><code> </code><code class="nn">csv</code><code>
</code><strong><code class="kn">from</code><code> </code><code class="nn">xml</code><code class="nn">.</code><code class="nn">etree</code><code> </code><code class="kn">import</code></strong><code> </code><code class="n">ElementTree</code><code> </code><strong><code class="k">as</code></strong><code> </code><code class="n">et</code><code>
</code><code>
</code><code class="n">menu</code><code> </code><code class="o">=</code><code> </code><code class="n">et</code><code class="o">.</code><code class="n">Element</code><code class="p">(</code><code class="s1">'</code><code class="s1">menu</code><code class="s1">'</code><code class="p">)</code><code>
</code><code class="n">tree</code><code> </code><code class="o">=</code><code> </code><code class="n">et</code><code class="o">.</code><code class="n">ElementTree</code><code class="p">(</code><code class="n">menu</code><code class="p">)</code><code>
</code><strong><code class="k">with</code></strong><code> </code><code class="nb">open</code><code class="p">(</code><code class="s1">'</code><code class="s1">menu.csv</code><code class="s1">'</code><code class="p">)</code><code> </code><strong><code class="k">as</code></strong><code> </code><code class="n">f</code><code class="p">:</code><code>
</code><code>    </code><code class="n">r</code><code> </code><code class="o">=</code><code> </code><code class="n">csv</code><code class="o">.</code><code class="n">reader</code><code class="p">(</code><code class="n">f</code><code class="p">)</code><code>
</code><code>    </code><strong><code class="k">for</code></strong><code> </code><code class="n">calories</code><code class="p">,</code><code> </code><code class="n">namestr</code><code> </code><strong><code class="ow">in</code></strong><code> </code><code class="n">r</code><code class="p">:</code><code>
</code><code>        </code><code class="n">food</code><code> </code><code class="o">=</code><code> </code><code class="n">et</code><code class="o">.</code><code class="n">SubElement</code><code class="p">(</code><code class="n">menu</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">food</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>        </code><code class="n">cals</code><code> </code><code class="o">=</code><code> </code><code class="n">et</code><code class="o">.</code><code class="n">SubElement</code><code class="p">(</code><code class="n">food</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">calories</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>        </code><code class="n">cals</code><code class="o">.</code><code class="n">text</code><code> </code><code class="o">=</code><code> </code><code class="n">calories</code><code>
</code><code>        </code><code class="n">name</code><code> </code><code class="o">=</code><code> </code><code class="n">et</code><code class="o">.</code><code class="n">SubElement</code><code class="p">(</code><code class="n">food</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">name</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>        </code><code class="n">name</code><code class="o">.</code><code class="n">text</code><code> </code><code class="o">=</code><code> </code><code class="n">namestr</code><code>
</code><code>
</code><code class="n">tree</code><code class="o">.</code><code class="n">write</code><code class="p">(</code><code class="s1">'</code><code class="s1">menu.xml</code><code class="s1">'</code><code class="p">)</code></pre>
</div></section>
<section data-pdf-bookmark="Parsing XML Iteratively" data-type="sect1"><div class="sect1" id="parsing_xml_iteratively">
<h1>Parsing XML Iteratively</h1>
<p>For<a contenteditable="false" data-primary="structured text" data-secondary="eXtensible Markup Language (XML)" data-tertiary="parsing XML iteratively" data-type="indexterm" id="idm44924476153392"/> tasks focused on selecting elements from an existing XML document, sometimes you don’t need to build the whole <span class="code">ElementTree</span> in memory—a consideration that’s particularly important if the XML document is very large (not the case for the tiny example document we’ve been dealing with, but stretch your imagination and visualize a similar menu-focused document that lists millions of different foods).</p>
<p>Suppose we have such a large document, and we want to print on standard output the calories and names of the 10 lowest-calorie foods, in order of increasing calories, with ties broken alphabetically. Our <em>menu.xml</em> file, which for simplicity’s sake we’ll assume is now a local file, lists millions of foods, so we’d rather not keep it all in memory (obviously, we don’t need complete access to all of it at once).</p>
<p>The following code represents a naive attempt to parse without building the whole structure in memory:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="kn">import</code><code> </code><code class="nn">heapq</code><code>
</code><strong><code class="kn">from</code><code> </code><code class="nn">xml</code><code class="nn">.</code><code class="nn">etree</code><code> </code><code class="kn">import</code></strong><code> </code><code class="n">ElementTree</code><code> </code><strong><code class="k">as</code></strong><code> </code><code class="n">et</code><code>
</code><code>
</code><code class="k">def</code><code> </code><code class="nf">cals_and_name</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><em><code>    </code><code class="c1"># generator for (calories, name) pairs</code></em><code>
</code><strong><code>    </code><code class="k">for</code></strong><code> </code><code class="n">_</code><code class="p">,</code><code> </code><code class="n">elem</code><code> </code><strong><code class="ow">in</code></strong><code> </code><code class="n">et</code><code class="o">.</code><code class="n">iterparse</code><code class="p">(</code><code class="s1">'</code><code class="s1">menu.xml</code><code class="s1">'</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code>    </code><code class="k">if</code></strong><code> </code><code class="n">elem</code><code class="o">.</code><code class="n">tag</code><code> </code><code class="o">!=</code><code> </code><code class="s1">'</code><code class="s1">food</code><code class="s1">'</code><code class="p">:</code><code>
</code><code>        </code><strong><code>    </code><code class="k">continue</code></strong><code>
</code><strong><code>   </code></strong><code>     </code><em><code class="c1"># just finished parsing a food, get calories and name</code></em><code>
</code><strong><code>   </code></strong><code>     </code><code class="n">cals</code><code> </code><code class="o">=</code><code> </code><code class="nb">int</code><code class="p">(</code><code class="n">elem</code><code class="o">.</code><code class="n">find</code><code class="p">(</code><code class="s1">'</code><code class="s1">calories</code><code class="s1">'</code><code class="p">)</code><code class="o">.</code><code class="n">text</code><code class="p">)</code><code>
</code><code>    </code><strong><code>    </code></strong><code class="n">name</code><code> </code><code class="o">=</code><code> </code><code class="n">elem</code><code class="o">.</code><code class="n">find</code><code class="p">(</code><code class="s1">'</code><code class="s1">name</code><code class="s1">'</code><code class="p">)</code><code class="o">.</code><code class="n">text</code><code>
</code><code>        </code><strong><code class="k">yield</code></strong><code> </code><code class="p">(</code><code class="n">cals</code><code class="p">,</code><code> </code><code class="n">name</code><code class="p">)</code><code>
</code><code>
</code><code class="n">lowest10</code><code> </code><code class="o">=</code><code> </code><code class="n">heapq</code><code class="o">.</code><code class="n">nsmallest</code><code class="p">(</code><code class="mi">10</code><code class="p">,</code><code> </code><code class="n">cals_and_name</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>
</code><code>
</code><strong><code class="k">for</code></strong><code> </code><code class="n">cals</code><code class="p">,</code><code> </code><code class="n">name</code><code> </code><strong><code class="ow">in</code></strong><code> </code><code class="n">lowest10</code><code class="p">:</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="n">cals</code><code class="p">,</code><code> </code><code class="n">name</code><code class="p">)</code></pre>
<p>This approach does indeed work, but unfortunately it consumes just about as much memory as an approach based on a full <span class="code">et.parse</span> would! This is because <span class="code">iterparse</span> builds up a whole <span class="code">ElementTree</span> in memory, even though it only communicates back events such as (and by default only) <span class="code">'end'</span>, meaning “I just finished parsing this element.”</p>
<p>To actually save memory, we can at least toss all the contents of each element as soon as we’re done processing it—that is, right after the <span class="code"><strong>yield</strong></span>, we can add <span class="code">elem.clear()</span> to make the just-processed element empty.</p>
<p>This approach would indeed save some memory—but not all of it, because the tree’s root would still end up with a huge list of empty child nodes. To be really frugal in memory consumption, we need to get <span class="code">'start'</span> events as well, so we can get hold of the root of the <span class="code">ElementTree</span> being built and remove each element from it as it’s used, rather than just clearing the element. That is, we want to change the generator into:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="k">def</code><code> </code><code class="nf">cals_and_name</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><em><code>    </code><code class="c1"># memory-thrifty generator for (calories, name) pairs</code></em><code>
</code><code>    </code><code class="n">root</code><code> </code><code class="o">=</code><code> </code><strong><code class="kc">None</code></strong><code>
</code><code>    </code><strong><code class="k">for</code></strong><code> </code><code class="n">event</code><code class="p">,</code><code> </code><code class="n">elem</code><code> </code><strong><code class="ow">in</code></strong><code> </code><code class="n">et</code><code class="o">.</code><code class="n">iterparse</code><code class="p">(</code><code class="s1">'</code><code class="s1">menu.xml</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="p">[</code><code class="s1">'</code><code class="s1">start</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">end</code><code class="s1">'</code><code class="p">]</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><strong><code class="k">if</code></strong><code> </code><code class="n">event</code><code> </code><code class="o">==</code><code> </code><code class="s1">'</code><code class="s1">start</code><code class="s1">'</code><code class="p">:</code><code>
</code><code>            </code><strong><code class="k">if</code></strong><code> </code><code class="n">root</code><code> </code><strong><code class="ow">is</code><code> </code><code class="kc">None</code></strong><code class="p">:</code><code>
</code><code>                </code><code class="n">root</code><code> </code><code class="o">=</code><code> </code><code class="n">elem</code><code>
</code><code>    </code><strong><code>        </code></strong><strong><code class="k">continue</code></strong><code>
</code><code>        </code><strong><code class="k">if</code></strong><code> </code><code class="n">elem</code><code class="o">.</code><code class="n">tag</code><code> </code><code class="o">!=</code><code> </code><code class="s1">'</code><code class="s1">food</code><code class="s1">'</code><code class="p">:</code><code>
</code><code>            </code><strong><code class="k">continue</code></strong><code>
</code><code>        </code><em><code class="c1"># just finished parsing a food, get calories and name</code></em><code>
</code><code>        </code><code class="n">cals</code><code> </code><code class="o">=</code><code> </code><code class="nb">int</code><code class="p">(</code><code class="n">elem</code><code class="o">.</code><code class="n">find</code><code class="p">(</code><code class="s1">'</code><code class="s1">calories</code><code class="s1">'</code><code class="p">)</code><code class="o">.</code><code class="n">text</code><code class="p">)</code><code>
</code><code>        </code><code class="n">name</code><code> </code><code class="o">=</code><code> </code><code class="n">elem</code><code class="o">.</code><code class="n">find</code><code class="p">(</code><code class="s1">'</code><code class="s1">name</code><code class="s1">'</code><code class="p">)</code><code class="o">.</code><code class="n">text</code><code>
</code><code>        </code><strong><code class="k">yield</code></strong><code> </code><code class="p">(</code><code class="n">cals</code><code class="p">,</code><code> </code><code class="n">name</code><code class="p">)</code><code>
</code><code>        </code><code class="n">root</code><code class="o">.</code><code class="n">remove</code><code class="p">(</code><code class="n">elem</code><code class="p">)</code></pre>
<p>This approach saves as much memory as feasible, and still gets the task done!</p>
<div data-type="tip">
<h1>Parsing XML Within an Asynchronous Loop</h1>
<p>While <span class="code">iterparse</span>, used correctly, can save memory, it’s still not good enough to use within an asynchronous loop. That’s because <span class="code">iterparse</span> makes blocking <span class="code">read</span> calls to the file object passed as its first argument: such blocking calls are a no-no in async processing.</p>
<p><span class="code">ElementTree</span> offers the class <span class="code">XMLPullParser</span> to help with this issue; see the <a href="https://oreil.ly/WxMoH">online docs</a> for the class’s usage pattern.</p>
</div>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="ch01fn160"><sup><a href="ch23.xhtml#ch01fn160-marker">1</a></sup> Alex is far too modest to mention it, but from around 1995 to 2005 both he and Fredrik were, along with Tim Peters, <em>the</em> Python bots. Known as such for their encyclopedic and detailed knowledge of the language, the effbot, the martellibot, and the timbot have created software and documentation that are of immense value to millions of people.</p></div></div></section></div></body></html>