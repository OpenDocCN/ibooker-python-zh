- en: Chapter 2\. Python Environments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章\. Python 环境
- en: 'At its core, every Python installation consists of two things: an interpreter
    and modules. The modules, in turn, come from the standard library and from third-party
    packages, if you’ve installed any. Together, these provide the essential components
    you need to execute a Python program: a *Python environment* ([Figure 2-1](#figure_environment)).'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在核心层面，每个 Python 安装都包括两部分：一个解释器和模块。模块又来自标准库和第三方包（如果您已安装）。这些组成了执行 Python 程序所需的基本组件：一个*Python
    环境*（见图 2-1](#figure_environment)）。
- en: Python installations aren’t the only kind of Python environment. *Virtual environments*
    are stripped-down environments that share the interpreter and the standard library
    with a full installation. You use them to install third-party packages for a specific
    project or application while keeping the system-wide environment pristine.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python 安装并非唯一的 Python 环境。*虚拟环境*是简化的环境，与完整安装共享解释器和标准库。您可以在特定项目或应用程序中使用它们来安装第三方包，同时保持系统环境干净。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This book uses *Python environment* as an umbrella term that includes both system-wide
    installations and virtual environments. Beware that some people only use the term
    for project-specific environments, like virtual environments or Conda environments.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将*Python 环境*作为一个总称，包括系统范围的安装和虚拟环境。请注意，有些人仅将该术语用于特定项目的环境，如虚拟环境或 Conda 环境。
- en: '![Python environments consist of an interpreter and modules.](assets/hmpt_0201.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![Python 环境由解释器和模块组成。](assets/hmpt_0201.png)'
- en: Figure 2-1\. Python environments consist of an interpreter and modules. Virtual
    environments share the interpreter and the standard library with their parent
    environment.
  id: totrans-6
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. Python 环境由解释器和模块组成。虚拟环境与其父环境共享解释器和标准库。
- en: Managing environments is a crucial aspect of Python development. You’ll want
    to make sure your code works on your users’ systems, particularly across the language
    versions you support, and possibly across major versions of an important third-party
    package. A Python environment can only contain a single version of each third-party
    package—​if two projects require different versions of the same package, they
    can’t be installed side-by-side. That’s why it’s considered good practice to install
    every Python application, and every project you work on, in a dedicated virtual
    environment.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 管理环境是 Python 开发的重要方面。您需要确保您的代码在用户的系统上正常运行，特别是在支持的语言版本之间，可能还涉及到重要第三方包的主要版本。Python
    环境只能包含每个第三方包的单个版本——如果两个项目需要不同版本的同一包，则不能并存。这就是为什么将每个 Python 应用程序和每个项目都安装在专用虚拟环境中被视为良好实践的原因。
- en: 'In this chapter, you’ll build a deeper understanding of what Python environments
    are and how they work. The chapter has three parts:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将深入了解 Python 环境的概念及其工作原理。本章分为三部分：
- en: 'The first part introduces the three kinds of Python environments—​Python installations,
    the per-user environment, and virtual environments—​as well two fundamental tools:
    the Python package installer pip and the standard `venv` module.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一部分介绍了三种 Python 环境——Python 安装、每个用户环境和虚拟环境——以及两个基本工具：Python 包安装程序 pip 和标准 `venv`
    模块。
- en: 'The second part introduces two modern tools that let you manage environments
    more efficiently: pipx, an installer for Python applications, and uv, a drop-in
    replacement for Python packaging tools written in Rust.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二部分介绍了两个现代工具，可以更高效地管理环境：pipx，一个用于 Python 应用程序的安装器，以及 uv，一个用 Rust 编写的 Python
    打包工具的替代品。
- en: The final part of this chapter dives deep into how and where Python finds the
    modules you import—​feel free to skip it unless you’re curious how this works.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的最后一部分深入探讨了 Python 导入模块的方式和位置——如果您对此过程感到好奇，可以跳过。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This chapter uses the Python Launcher to invoke the interpreter (see [“The Python
    Launcher for Windows”](ch01.html#section_python_launcher_windows) and [“The Python
    Launcher for Unix”](ch01.html#section_python_launcher_unix)). If you don’t have
    it installed, replace `py` with `python3` when running the examples.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用 Python Launcher 来调用解释器（参见 [“Windows 下的 Python Launcher”](ch01.html#section_python_launcher_windows)
    和 [“Unix 下的 Python Launcher”](ch01.html#section_python_launcher_unix)）。如果您没有安装它，请在运行示例时用
    `py` 替换 `python3`。
- en: A Tour of Python Environments
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 环境之旅
- en: 'Every Python program runs “inside” a Python environment: the interpreter in
    the environment executes the program’s code, and `import` statements load modules
    from the environment. You select the environment by launching its interpreter.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Python 程序都在“内部”运行于一个 Python 环境中：环境中的解释器执行程序的代码，并且`import`语句从环境中加载模块。通过启动其解释器来选择环境。
- en: 'Python offers two mechanisms for running a program on an interpreter. You can
    pass a Python script as an argument:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了两种在解释器上运行程序的机制。您可以将一个 Python 脚本作为参数传递：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, you can pass a module with the `-m` option, provided that the
    interpreter can import the module:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以通过`-m`选项传递一个模块，前提是解释器可以导入该模块：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Most commonly, the interpreter imports *hello.py* from the environment—​but
    for the sake of this example, placing it in the current directory will also work.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，解释器从环境中导入*hello.py* —— 但为了本示例的目的，将其放置在当前目录中也可以。
- en: 'Additionally, many Python applications install an entry-point script in your
    `PATH` (see [“Entry-point scripts”](#section_environments_scripts)). This mechanism
    allows you to launch the application without specifying an interpreter. Entry-point
    scripts always use the interpreter from the environment in which they’re installed:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，许多 Python 应用程序在您的`PATH`中安装了一个入口脚本（参见[“入口脚本”](#section_environments_scripts)）。这个机制允许您在不指定解释器的情况下启动应用程序。入口脚本始终使用安装它们的环境中的解释器：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This method is convenient, but there’s also a drawback: If you’ve installed
    the program in multiple environments, the first environment on `PATH` “wins”.
    In such a scenario, the form `py -m hello` offers you more control.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法很方便，但也有一个缺点：如果您在多个环境中安装了该程序，则`PATH`中的第一个环境“胜出”。在这种情况下，`py -m hello`形式为您提供更多的控制。
- en: '“The interpreter determines the environment.” As mentioned above, this rule
    applies when you import modules. It also applies in the complementary situation:
    when you install a package into an environment. Pip, the Python package installer,
    installs packages into its own environment by default. In other words, you select
    the target environment for a package by running pip on the interpreter in that
    environment.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: “解释器决定环境。” 如上所述，这条规则适用于导入模块时。它也适用于互补情况：当您将一个包安装到一个环境中时。Python 包安装程序 Pip 默认将包安装到自己的环境中。换句话说，您通过在该环境中运行
    pip 来选择包的目标环境。
- en: 'For this reason, the canonical way to install a package with pip uses the `-m`
    form:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用`-m`形式安装包的规范方式是：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Alternatively, you can provide a virtual environment or interpreter to pip
    using its `--python` option:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用其`--python`选项为 pip 提供虚拟环境或解释器：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The second method has the advantage of not requiring pip in every environment.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法的优点是不需要在每个环境中都安装 pip。
- en: Python Installations
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 安装
- en: This section takes you on a tour of a Python installation. Feel free to follow
    along on your own system. [Table 2-1](#table_environments_roots) shows the most
    common locations—​replace 3.*x* and 3*x* with the Python feature version, such
    as `3.12` and `312`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本节带您了解 Python 安装的情况。随时跟随您自己系统上的操作。[表 2-1](#table_environments_roots) 显示了最常见的位置——将
    3.*x* 和 3*x* 替换为 Python 特性版本，如 `3.12` 和 `312`。
- en: Table 2-1\. Locations of Python installations
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-1\. Python 安装位置
- en: '| Platform | Python installation |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 平台 | Python 安装位置 |'
- en: '| --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Windows (single-user) | *%LocalAppData%\Programs\Python\Python3x* |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| Windows（单用户） | *%LocalAppData%\Programs\Python\Python3x* |'
- en: '| Windows (multi-user) | *%ProgramFiles%\Python3x* |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| Windows（多用户） | *%ProgramFiles%\Python3x* |'
- en: '| macOS (Homebrew) | */opt/homebrew/Frameworks/Python.framework/Versions/3.x*^([a](ch02.html#id249))
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| macOS（Homebrew） | */opt/homebrew/Frameworks/Python.framework/Versions/3.x*^([a](ch02.html#id249))
    |'
- en: '| macOS (python.org) | */Library/Frameworks/Python.framework/Versions/3.x*
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| macOS（python.org） | */Library/Frameworks/Python.framework/Versions/3.x* |'
- en: '| Linux (generic) | */usr/local* |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| Linux（通用） | */usr/local* |'
- en: '| Linux (package manager) | */usr* |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| Linux（包管理器） | */usr* |'
- en: '| ^([a](ch02.html#id249-marker)) Homebrew on macOS Intel uses */usr/local*
    instead of */opt/homebrew*. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch02.html#id249-marker)) macOS Intel 上的 Homebrew 使用 */usr/local* 而不是
    */opt/homebrew*。 |'
- en: An installation might be cleanly separated from the rest of your system, but
    not necessarily. On Linux, it goes into a shared location like */usr* or */usr/local*,
    with its files scattered across the filesystem. Windows systems, on the other
    hand, keep all files in a single place. Framework builds on macOS are similarly
    self-contained, although distributions may also install symbolic links into the
    traditional Unix locations.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 安装可能会与系统其余部分干净地分离，但并非一定如此。在Linux上，安装通常放在*/usr*或*/usr/local*等共享位置，其文件分布在整个文件系统中。相比之下，Windows系统将所有文件保存在一个单一位置。在macOS上，框架构建同样是自包含的，尽管分布也可能在传统的Unix位置安装符号链接。
- en: In the following sections, you’ll take a closer look at the core parts of Python
    installations—​the interpreter and the modules, as well as some other components
    such as entry-point scripts and shared libraries.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将更深入地了解Python安装的核心部分——解释器和模块，以及其他一些组件，比如入口脚本和共享库。
- en: The layout of Python installations varies quite a bit from system to system.
    The good news is, you rarely have to care—​a Python interpreter knows its environment.
    For reference, [Table 2-2](#table_environments_layouts) provides a baseline for
    installation layouts on the major platforms. All paths are relative to the installation
    root.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Python安装布局在不同系统上可能差异很大。好消息是，你很少需要关心——Python解释器知道它的环境。供参考的是，[Table 2-2](#table_environments_layouts)提供了主要平台上安装布局的基准。所有路径均相对于安装根目录。
- en: Table 2-2\. Layout of Python installations
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-2\. Python安装布局
- en: '| Files | Windows | Linux and macOS | Notes |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 文件 | Windows | Linux和macOS | 注释 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| interpreter | *python.exe* | *bin/python3.x* |  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 解释器 | *python.exe* | *bin/python3.x* |  |'
- en: '| standard library | *Lib* and *DLLs* | *lib/python3.x* | Extension modules
    are located under *DLLs* on Windows. Fedora places the standard library under
    *lib64* instead of *lib*. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 标准库 | *Lib*和*DLLs* | *lib/python3.x* | 在Windows上，扩展模块位于*DLLs*下。Fedora将标准库放在*lib64*而非*lib*下。
    |'
- en: '| third-party packages | *Lib\site-packages* | *lib/python3.x/site-packages*
    | Debian and Ubuntu put packages in *dist-packages*. Fedora places extension modules
    under *lib64* instead of *lib*. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 第三方包 | *Lib\site-packages* | *lib/python3.x/site-packages* | Debian和Ubuntu将包放置在*dist-packages*下。Fedora将扩展模块放在*lib64*而非*lib*下。
    |'
- en: '| entry-point scripts | *Scripts* | *bin* |  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 入口脚本 | *Scripts* | *bin* |  |'
- en: The interpreter
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释器
- en: The executable that runs Python programs is named *python.exe* on Windows and
    located at the root of a full installation.^([1](ch02.html#id250)) On Linux and
    macOS, the interpreter is named *python3.x* and stored in the *bin* directory
    with a *python3* symbolic link.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Python程序的可执行文件在Windows上名为*python.exe*，位于完整安装的根目录下^([1](ch02.html#id250))。在Linux和macOS上，解释器名为*python3.x*，存储在*bin*目录中，同时还有一个*python3*的符号链接。
- en: 'The Python interpreter ties the environment to three things:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Python解释器将环境与三个要素联系起来：
- en: a specific version of the Python language
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定版本的Python语言
- en: a specific implementation of Python
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python的特定实现
- en: a specific build of the interpreter
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定版本的解释器构建
- en: The implementation might be [CPython](https://github.com/python/cpython), the
    reference implementation of Python, but it could also be any of a number of alternative
    implementations—​such as [PyPy](https://www.pypy.org/), a fast interpreter with
    just-in-time compilation, written in Python itself, or [GraalPy](https://www.graalvm.org/python/),
    a highly performant implementation with Java interoperability, using the GraalVM
    development kit.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 实现可能是[CPython](https://github.com/python/cpython)，即Python的参考实现，但也可能是多种备选实现之一——比如[PyPy](https://www.pypy.org/)，一个快速的解释器，支持即时编译，用Python编写，或者[GraalPy](https://www.graalvm.org/python/)，一个高性能的实现，支持Java互操作性，使用GraalVM开发工具包。
- en: Builds differ in their CPU architecture—​for example, 32-bit versus 64-bit,
    or Intel versus Apple Silicon—​and their build configuration, which determines
    things like compile-time optimizations or the installation layout.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程中，CPU架构可能会有所不同——例如，32位与64位，或者Intel与Apple Silicon——以及它们的构建配置，这些配置会影响编译时的优化或安装布局。
- en: Python modules
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python模块
- en: Modules are containers of Python objects that you load via the `import` statement.
    They’re organized below *Lib* (Windows) or *lib/python3.x* (Linux and macOS) with
    some platform-dependent variations. Third-party packages go into a subdirectory
    named *site-packages*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是通过`import`语句加载的Python对象的容器。它们通常组织在*Lib*（Windows）或*lib/python3.x*（Linux和macOS）下，具体的平台相关变化不尽相同。第三方包被放置在名为*site-packages*的子目录中。
- en: 'Modules come in various forms and shapes. If you’ve worked with Python, you’ve
    likely used most of them already. Let’s go over the different kinds:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 模块以各种形式存在。如果您使用过Python，您可能已经使用了大多数形式。让我们来看看不同的类型：
- en: Simple modules
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 简单模块
- en: In the simplest case, a *module* is a single file containing Python source code.
    The statement `import string` executes the code in *string.py* and binds the result
    to the name `string` in the local scope.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，*module*是一个包含Python源代码的单个文件。语句`import string`执行*string.py*中的代码，并将结果绑定到本地范围中的名称`string`。
- en: Packages
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 包
- en: Directories with *__init__.py* files are known as *packages*—they allow you
    to organize modules in a hierarchy. The statement `import email.message` loads
    the `message` module from the `email` package.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 带有*__init__.py*文件的目录称为*packages*，它们允许您在层次结构中组织模块。语句`import email.message`加载`email`包中的`message`模块。
- en: Namespace packages
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间包
- en: Directories with modules but no *__init__.py* are known as *namespace packages*.
    You use them to organize modules in a common namespace such as a company name
    (say `acme.unicycle` and `acme.rocketsled`). Unlike with regular packages, you
    can distribute each module in a namespace package separately.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 没有*__init__.py*但包含模块的目录称为*namespace packages*。您可以使用它们来在共同的命名空间中组织模块，例如公司名称（比如`acme.unicycle`和`acme.rocketsled`）。与常规包不同，您可以单独分发命名空间包中的每个模块。
- en: Extension modules
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展模块
- en: Extension modules, such as the `math` module, contain native code compiled from
    low-level languages like C. They’re shared libraries^([2](ch02.html#id251)) with
    a special entry point that lets you import them as modules from Python. People
    write them for performance reasons or to make existing C libraries available as
    Python modules. Their names end in *.pyd* on Windows, *.dylib* on macOS, and *.so*
    on Linux.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展模块，例如`math`模块，包含从低级语言如C编译而来的本机代码。它们是共享库^([2](ch02.html#id251))，具有特殊的入口点，使您可以从Python中将它们作为模块导入。人们出于性能原因编写它们，或者将现有的C库作为Python模块提供。它们在Windows上以*.pyd*结尾，在macOS上以*.dylib*结尾，在Linux上以*.so*结尾。
- en: Built-in modules
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 内置模块
- en: Some modules from the standard library, such as the `sys` and `builtins` modules,
    are compiled into the interpreter. The variable `sys.builtin_module_names` lists
    all of these modules.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的一些模块，如`sys`和`builtins`模块，已编译到解释器中。变量`sys.builtin_module_names`列出了所有这些模块。
- en: Frozen modules
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 冻结模块
- en: Some modules from the standard library are written in Python but have their
    bytecode embedded in the interpreter. Originally, only core parts of `importlib`
    got this treatment. Recent versions of Python freeze every module that’s imported
    during interpreter startup, such as `os` and `io`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一些标准库中的模块是用Python编写的，但其字节码嵌入在解释器中。最初，只有`importlib`的核心部分得到了这种处理。Python的最新版本会在解释器启动期间冻结每个导入的模块，例如`os`和`io`。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The term *package* carries some ambiguity in the Python world. It refers both
    to modules and to the artifacts used for distributing modules, also known as *distributions*.
    Unless stated otherwise, this book uses *package* as a synonym for *distribution*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python世界中，术语*package*具有一些歧义。它既指模块，也指用于分发模块的工件，也称为*distributions*。除非另有说明，本书将*package*用作*distribution*的同义词。
- en: '*Bytecode* is an intermediate representation of Python code that is platform-independent
    and optimized for fast execution. The interpreter compiles pure Python modules
    to bytecode when it loads them for the first time. Bytecode modules are cached
    in the environment in *.pyc* files under *__pycache__* directories.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*Bytecode*是Python代码的中间表示，它是平台无关的，并且经过优化以实现快速执行。当解释器首次加载纯Python模块时，它将其编译为字节码。字节码模块被缓存在环境中的*.pyc*文件中，位于*__pycache__*目录下。'
- en: Entry-point scripts
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 入口点脚本
- en: 'An *entry-point script* is an executable file in *Scripts* (Windows) or *bin*
    (Linux and macOS) with a single purpose: it launches a Python application by importing
    the module with its entry-point function and calling that function.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*入口点脚本*是一个可执行文件，在*Scripts*（Windows）或*bin*（Linux和macOS）中，其单一目的是启动Python应用程序，通过导入具有其入口点函数的模块并调用该函数来实现。
- en: This mechanism has two key benefits. First, you can launch the application in
    a shell by running a simple command—​say, `pydoc3` for Python’s built-in documentation
    browser.^([3](ch02.html#id252)) Second, entry-point scripts use the interpreter
    and modules from their environment, sparing you surprises about wrong Python versions
    or missing third-party packages.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此机制有两个关键优点。首先，您可以通过运行一个简单的命令（例如 `pydoc3`）在 shell 中启动应用程序。^([3](ch02.html#id252))
    第二，入口脚本使用其环境中的解释器和模块，避免因 Python 版本错误或缺少第三方包而导致的意外。
- en: Package installers, like pip, can generate entry-point scripts for third-party
    packages they install. Package authors only need to designate the function that
    the script should invoke. This is a handy method to provide an executable for
    a Python application (see [“Entry-point Scripts”](ch03.html#section_packages_entrypoint_scripts)).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 类似 pip 这样的包安装程序可以为它们安装的第三方包生成入口脚本。包的作者只需指定脚本应调用的函数即可。这是为 Python 应用程序提供可执行文件的一种方便方法（参见
    [“入口脚本”](ch03.html#section_packages_entrypoint_scripts)）。
- en: Platforms differ in how they let you execute entry-point scripts directly. On
    Linux and macOS, they’re regular Python files with *execute* permission, such
    as the one shown in [Example 2-3](#example_environments_pydoc). Windows embeds
    the Python code in a binary file in the Portable Executable (PE) format—​more
    commonly known as a *.exe* file. The binary launches the interpreter with the
    embedded code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 各平台在直接执行入口脚本的方式上有所不同。在 Linux 和 macOS 上，它们是具有 *执行* 权限的常规 Python 文件，例如 [示例 2-3](#example_environments_pydoc)
    中所示的那个。Windows 将 Python 代码嵌入到 Portable Executable（PE）格式的二进制文件中，通常称为 *.exe* 文件。该二进制文件启动解释器并执行嵌入的代码。
- en: Example 2-3\. The entry-point script `pydoc3` from a Linux installation
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-3\. Linux 安装中的入口脚本 `pydoc3`
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_python_environments_CO1-1)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_python_environments_CO1-1)'
- en: Request the interpreter from the current environment.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从当前环境请求解释器。
- en: '[![2](assets/2.png)](#co_python_environments_CO1-2)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_python_environments_CO1-2)'
- en: Load the module containing the designated entry-point function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 加载包含指定入口点函数的模块。
- en: '[![3](assets/3.png)](#co_python_environments_CO1-3)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_python_environments_CO1-3)'
- en: Check that the script wasn’t imported from another module.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 检查脚本是否未从另一个模块导入。
- en: '[![4](assets/4.png)](#co_python_environments_CO1-4)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_python_environments_CO1-4)'
- en: Finally, call the entry-point function to start up the program.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用入口点函数启动程序。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `#!` line is known as a *shebang* on Unix-like operating systems. When you
    run the script, the program loader uses the line to locate and launch the interpreter.
    The *program loader* is the part of the operating system that loads a program
    into main memory.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`#!` 行在类 Unix 操作系统上被称为 *shebang*。当您运行脚本时，程序加载器使用该行来定位并启动解释器。*程序加载器* 是操作系统的一部分，用于将程序加载到主存中。'
- en: Other components
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他组件
- en: 'Besides the interpreter, modules, and scripts, Python environments can include
    some additional components:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 除了解释器、模块和脚本之外，Python 环境还可以包含一些额外的组件：
- en: Shared libraries
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库
- en: Python environments sometimes contain shared libraries that aren’t extension
    modules, named *.dll* on Windows, *.dylib* on macOS, and *.so* on Linux. Third-party
    packages may bundle shared libraries they use so you don’t need to install them
    separately. Python installations may also bundle shared libraries—​for example,
    the standard `ssl` module uses OpenSSL, an open source library for secure communication.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Python 环境有时会包含一些不是扩展模块的共享库，如 Windows 上的 *.dll*、macOS 上的 *.dylib* 和 Linux 上的
    *.so*。第三方包可能会捆绑它们使用的共享库，因此您无需单独安装它们。Python 安装可能还会捆绑共享库，例如标准的 `ssl` 模块使用 OpenSSL，这是一个用于安全通信的开源库。
- en: Header Files
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件
- en: Python installations contain header files for the *Python/C API*, an application
    programming interface for writing extension modules or embedding Python as a component
    in a larger application. They’re located under *Include* (Windows) or *include/python3.x*
    (Linux and macOS).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Python 安装包含用于 *Python/C API* 的头文件，这是一个用于编写扩展模块或将 Python 嵌入到较大应用程序中作为组件的应用程序编程接口。它们位于
    *Include*（Windows）或 *include/python3.x*（Linux 和 macOS）下。
- en: Static data
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 静态数据
- en: Python installations also contain static data in various locations. This includes
    configuration files, documentation, and any resource files shipped with third-party
    packages.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Python 安装还在各个位置包含各种静态数据。这包括配置文件、文档以及与第三方包一起提供的任何资源文件。
- en: Tcl/Tk
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Tcl/Tk
- en: By default, Python installations also include *Tcl/Tk*, a toolkit for creating
    graphical user interfaces (GUIs) written in Tcl. The standard `tkinter` module
    allows you to use this toolkit from Python.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Python 安装还包括 *Tcl/Tk*，用于使用 Tcl 编写的图形用户界面（GUI）的工具包。 标准的 `tkinter` 模块允许您从
    Python 使用此工具包。
- en: The Per-User Environment
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户环境
- en: 'The *per-user environment* allows you to install third-party packages for a
    single user. It offers two main benefits over installing packages system-wide:
    You don’t need administrative privileges to install packages, and you don’t affect
    other users on a multi-user system.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*用户环境* 允许您为单个用户安装第三方软件包。 它相对于系统范围内安装软件包有两个主要优点：您无需管理权限即可安装软件包，而且您不会影响多用户系统上的其他用户。'
- en: The per-user environment is located in the home directory on Linux and macOS
    and in the app data directory on Windows (see [Table 2-3](#table_environments_peruser)).
    It contains a *site-packages* directory for every Python version. Entry-point
    scripts are shared across Python versions, except on macOS, where the entire per-user
    installation is kept under a version-specific directory.^([4](ch02.html#id253))
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 用户环境位于 Linux 和 macOS 的主目录中，而在 Windows 的应用数据目录中（参见 [表 2-3](#table_environments_peruser)）。
    它包含每个 Python 版本的 *site-packages* 目录。 入口点脚本在 Python 版本之间共享，但在 macOS 上，整个用户环境安装保存在特定于版本的目录下。^([4](ch02.html#id253))
- en: Table 2-3\. Location of per-user directories
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-3\. 每个用户目录的位置
- en: '| Platform | Third-party packages | Entry-point scripts |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 平台 | 第三方软件包 | 入口点脚本 |'
- en: '| --- | --- | --- |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Windows | *%AppData%\Python\Python3x\site-packages* | *%AppData%\Python\Scripts*
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| Windows | *%AppData%\Python\Python3x\site-packages* | *%AppData%\Python\Scripts*
    |'
- en: '| macOS | *~/Library/Python/3.x/lib/python/site-packages* | *~/Library/Python/3.x/bin*
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| macOS | *~/Library/Python/3.x/lib/python/site-packages* | *~/Library/Python/3.x/bin*
    |'
- en: '| Linux | *~/.local/lib/python3.x/site-packages*^([a](ch02.html#id254)) | *~/.local/bin*
    |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| Linux | *~/.local/lib/python3.x/site-packages*^([a](ch02.html#id254)) | *~/.local/bin*
    |'
- en: '| ^([a](ch02.html#id254-marker)) Fedora places extension modules under *lib64*.
    |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch02.html#id254-marker)) Fedora 将扩展模块放在 *lib64* 下。 |'
- en: You install a package into the per-user environment using `py -m pip install
    --user *<package>*`. If you invoke `pip` outside of a virtual environment and
    pip finds that it can’t write to the system-wide installation, it will also default
    to this location. If the per-user environment doesn’t exist yet, pip creates it
    for you.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `py -m pip install --user *<package>*` 将软件包安装到用户环境中。 如果在虚拟环境之外调用 `pip`，并且
    pip 发现它无法写入到系统范围的安装位置，它也会默认使用此位置。 如果用户环境尚不存在，则 pip 会为您创建它。
- en: Tip
  id: totrans-116
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The per-user script directory may not be on `PATH` by default. If you install
    applications into the per-user environment, remember to edit your shell profile
    to update the search path. Pip issues a friendly reminder when it detects this
    situation.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，用户脚本目录可能不在 `PATH` 中。 如果将应用程序安装到用户环境中，请记住编辑您的 shell 配置文件以更新搜索路径。 当 Pip
    检测到此情况时，它会发出友好的提醒。
- en: 'Per-user environments have an important shortcoming: by design, they’re not
    isolated from the global environment. You can still import system-wide site packages
    if they’re not shadowed by per-user modules with the same name. Applications in
    the per-user environment also aren’t isolated from each other—​in particular,
    they can’t depend on incompatible versions of another package. Even applications
    in the system-wide environment can import modules from the per-user environment.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 用户环境有一个重要缺点：按设计，它们与全局环境不隔离。 如果全局环境中没有被用户环境中同名模块遮蔽，您仍然可以导入全局范围的站点软件包。 用户环境中的应用程序也不彼此隔离—​特别是，它们不能依赖于另一个软件包的不兼容版本。
    即使系统范围内的应用程序也可以从用户环境导入模块。
- en: 'And there’s another drawback: you can’t install packages into the per-user
    environment if the Python installation is marked as *externally managed*—for example,
    if you installed Python using the package manager of your distribution.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个缺点：如果 Python 安装标记为 *externally managed*（例如，如果使用发行版的软件包管理器安装了 Python），则无法将软件包安装到用户环境中。
- en: In [“Installing Applications with Pipx”](#section_environments_pipx), I’ll introduce
    pipx, which lets you install applications in isolated environments. It uses the
    per-user script directory to put applications onto your search path, but relies
    on virtual environments under the hood.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“使用 Pipx 安装应用程序”](#section_environments_pipx) 中，我将介绍 pipx，它允许您在隔离的环境中安装应用程序。
    它使用用户脚本目录将应用程序放到您的搜索路径上，但在幕后依赖于虚拟环境。
- en: Virtual Environments
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟环境
- en: When you’re working on a Python project that uses third-party packages, it’s
    usually a bad idea to install these packages into the system-wide or per-user
    environments. First, you’re polluting a global namespace. Testing and debugging
    your projects gets a lot easier when you run them in isolated and reproducible
    environments. Second, if two projects depend on conflicting versions of the same
    package, a single environment isn’t even an option. Third, as mentioned in the
    previous section, you can’t install packages into environments marked as *externally
    managed*.^([5](ch02.html#id255))
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在一个使用第三方包的Python项目上工作时，通常不建议将这些包安装到系统范围或每个用户环境中。首先，这样会污染全局命名空间。在隔离和可重现环境中运行测试和调试项目会变得更加容易。其次，如果两个项目依赖于相同包的冲突版本，单个环境甚至都不是一个选项。第三，正如前一节提到的，您不能将包安装到标记为*externally
    managed*的环境中。^([5](ch02.html#id255))
- en: Virtual environments were invented to solve these problems. They’re isolated
    from the system-wide installation and from each other. Under the hood, a virtual
    environment is a lightweight Python environment that stores third-party packages
    and delegates most other things to a full installation. Packages in virtual environments
    are only visible to the interpreter in the environment.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境的发明是为了解决这些问题。它们与系统范围的安装以及彼此之间隔离。在底层，虚拟环境是一个轻量级的Python环境，用于存储第三方包，并将大部分其他功能委托给完整安装。虚拟环境中的包仅对环境中的解释器可见。
- en: You create a virtual environment with the command `py -m venv *<directory>*`.
    The last argument is the location where you want the environment to exist—​its
    root directory—​and conventionally named *.venv*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令`py -m venv *<directory>*`创建虚拟环境。最后一个参数是您希望环境存在的位置—​它的根目录—​通常命名为*.venv*。
- en: The directory tree of a virtual environment looks much like a Python installation,
    except that some files are missing, most notably the entire standard library.
    [Table 2-4](#table_environments_venv) shows the standard locations within a virtual
    environment.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境的目录树看起来非常像Python安装，只是缺少一些文件，尤其是整个标准库。[Table 2-4](#table_environments_venv)显示了虚拟环境中的标准位置。
- en: Table 2-4\. Layout of a virtual environment
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-4\. 虚拟环境的布局
- en: '| Files | Windows | Linux and macOS |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 文件 | Windows | Linux和macOS |'
- en: '| --- | --- | --- |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| interpreter | *Scripts* | *bin* |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 解释器 | *Scripts* | *bin* |'
- en: '| entry-point scripts | *Scripts* | *bin* |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 入口点脚本 | *Scripts* | *bin* |'
- en: '| third-party packages | *Lib\site-packages* | *lib/python3.x/site-packages*^([a](ch02.html#id256))
    |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 第三方包 | *Lib\site-packages* | *lib/python3.x/site-packages*^([a](ch02.html#id256))
    |'
- en: '| environment configuration | *pyvenv.cfg* | *pyvenv.cfg* |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 环境配置 | *pyvenv.cfg* | *pyvenv.cfg* |'
- en: '| ^([a](ch02.html#id256-marker)) Fedora places third-party extension modules
    under *lib64* instead of *lib*. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch02.html#id256-marker)) Fedora将第三方扩展模块放置在*lib64*而不是*lib*下。'
- en: Virtual environments have their own `python` command, which is located next
    to the entry-point scripts. On Linux and macOS, the command is a symbolic link
    to the interpreter you used to create the environment. On Windows, it’s a small
    wrapper executable that launches the parent interpreter.^([6](ch02.html#id257))
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境有自己的`python`命令，该命令位于入口点脚本旁边。在Linux和macOS上，该命令是到您用于创建环境的解释器的符号链接。在Windows上，它是一个小的包装可执行文件，启动父解释器。^([6](ch02.html#id257))
- en: Installing packages
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装包
- en: Virtual environments include pip as a means to install packages into them.^([7](ch02.html#id258))
    Let’s create a virtual environment, install `httpx` (an HTTP client library),
    and launch an interactive session. On Windows, enter the commands below.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境包括pip作为将包安装到其中的手段。^([7](ch02.html#id258)) 让我们创建一个虚拟环境，安装`httpx`（一个HTTP客户端库），并启动一个交互式会话。在Windows上，输入以下命令。
- en: '[PRE6]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: On Linux and macOS, enter the commands below. There’s no need to spell out the
    path to the interpreter if the environment uses the well-known name *.venv*. The
    Python Launcher for Unix selects its interpreter by default.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux和macOS上，输入以下命令。如果环境使用已知名称*.venv*，则无需详细说明解释器的路径。Unix的Python Launcher会默认选择其解释器。
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the interactive session, use `httpx.get` to perform a `GET` request to a
    web host:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式会话中，使用`httpx.get`执行对Web主机的`GET`请求：
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Virtual environments come with the version of pip that was current when Python
    was released. This can be a problem when you’re working with an old Python release.
    Create the environment with the option `--upgrade-deps` to ensure you get the
    latest pip release from the Python Package Index.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境附带了 Python 发布时当前的 pip 版本。当你使用旧版 Python 时，这可能会成为问题。使用选项`--upgrade-deps`创建环境，以确保从
    Python Package Index 获取最新的 pip 发布。
- en: 'You can also create a virtual environment without pip using the option `--without-pip`
    and install packages with an external installer. If you have pip installed globally,
    you can pass the target environment using its `--python` option, like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用选项`--without-pip`创建没有 pip 的虚拟环境，并使用外部安装程序安装包。如果全局安装了 pip，可以通过其`--python`选项传递目标环境，像这样：
- en: '[PRE9]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It’s easy to install a package into the Python installation or per-user environment
    by accident—​especially if you’re used to invoking `pip` directly. If your Python
    installation isn’t marked as externally managed, you may not even notice. Fortunately,
    you can configure pip to always require a virtual environment when installing
    packages:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯直接调用`pip`，很容易在 Python 安装或每个用户的环境中意外安装一个包。如果你的 Python 安装未标记为外部管理，你甚至可能都不会注意到。幸运的是，你可以配置
    pip，在安装包时总是要求使用虚拟环境：
- en: '[PRE10]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Activation scripts
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 激活脚本
- en: 'Virtual environments come with *activation scripts* in the *bin* or *Scripts*
    directory—​these scripts make it more convenient to use a virtual environment
    from the command line, and they’re provided for a number of supported shells and
    command interpreters. Here’s the Windows example again, this time using the activation
    script:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境附带了在*bin*或*Scripts*目录中的*激活脚本*——这些脚本使得从命令行更方便地使用虚拟环境，并为多种支持的 shell 和命令解释器提供了支持。以下是
    Windows 的示例，这次使用激活脚本：
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Activation scripts bring three features to your shell session:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 激活脚本为你的 shell 会话带来了三个特性：
- en: They prepend the script directory to the `PATH` variable. This allows you to
    invoke `python`, `pip`, and entry-point scripts without prefixing them with the
    path to the environment.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们将脚本目录前置到`PATH`变量中。这使你可以在不用路径前缀的情况下调用`python`、`pip`和入口点脚本。
- en: They set the `VIRTUAL_ENV` environment variable to the location of the virtual
    environment. Tools like the Python Launcher use this variable to detect that the
    environment is active.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们将`VIRTUAL_ENV`环境变量设置为虚拟环境的位置。像 Python Launcher 这样的工具使用该变量来检测环境是否处于激活状态。
- en: They update your shell prompt to provide a visual reference which environment
    is active, if any. By default, the prompt uses the name of the directory where
    the environment is located.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，它们更新你的 shell 提示符，以提供可视化参考，显示哪个环境处于活动状态（如果有的话）。
- en: Tip
  id: totrans-154
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can provide a custom prompt using the option `--prompt` when creating the
    environment. The special value `.` designates the current directory; it’s particularly
    useful when you’re inside a project repository.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 创建环境时，可以使用选项`--prompt`提供自定义提示符。特殊值`.`表示当前目录；在项目仓库内时尤其有用。
- en: 'On macOS and Linux, you need to *source* the activation script to allow it
    to affect your current shell session. Here’s an example for Bash and similar shells:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 和 Linux 上，你需要*源*激活脚本，以使其影响当前的 shell 会话。以下是 Bash 和类似的 shell 的示例：
- en: '[PRE12]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Environments come with activation scripts for some other shells, as well. For
    example, if you use the Fish shell, source the supplied *activate.fish* script
    instead.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 环境还附带了一些其他 shell 的激活脚本。例如，如果你使用 Fish shell，可以源激活提供的*activate.fish*脚本。
- en: On Windows, you can invoke the activation script directly. There’s an *Activate.ps1*
    script for PowerShell and an *activate.bat* script for *cmd.exe*. You don’t need
    to provide the file extension; each shell selects the script appropriate for it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，你可以直接调用激活脚本。PowerShell 有一个*Activate.ps1*脚本，*cmd.exe* 有一个*activate.bat*脚本。你无需提供文件扩展名；每个
    shell 都会选择适合自己的脚本。
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'PowerShell on Windows doesn’t allow you to execute scripts by default, but
    you can change the execution policy to something more suited to development: The
    `RemoteSigned` policy allows scripts written on the local machine or signed by
    a trusted publisher. On Windows servers, this policy is already the default. You
    only need to do this once—​the setting is stored in the registry.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上的 PowerShell 默认情况下不允许执行脚本，但是你可以将执行策略更改为更适合开发的选项：`RemoteSigned` 策略允许在本地计算机上编写的或由受信任发布者签名的脚本。在
    Windows 服务器上，该策略已经是默认值。你只需要执行一次这个操作——设置将存储在注册表中。
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Activation scripts provide you with a `deactivate` command to revert the changes
    to your shell environment. It’s usually implemented as a shell function, and works
    the same on Windows, macOS, and Linux.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 激活脚本提供了一个 `deactivate` 命令，用于恢复对 shell 环境的更改。它通常作为一个 shell 函数实现，在 Windows、macOS
    和 Linux 上的工作方式相同。
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A look under the hood
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一探究竟
- en: How does Python know to import a third-party package like `httpx` from the virtual
    environment instead of the Python installation? The location can’t be hardcoded
    in the interpreter binary, given that virtual environments share the interpreter
    with the Python installation. Instead, Python looks at the location of the `python`
    command you used to launch the interpreter. If its parent directory contains a
    *pyvenv.cfg* file, Python treats that file as a *landmark* for a virtual environment
    and imports third-party modules from the *site-packages* directory beneath.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Python 如何知道要从虚拟环境而不是 Python 安装中导入第三方包，比如 `httpx` 这样的第三方包？由于虚拟环境与 Python 安装共享解释器，因此位置不能硬编码在解释器二进制文件中。相反，Python
    查看你用来启动解释器的 `python` 命令的位置。如果其父目录包含 *pyvenv.cfg* 文件，Python 将其视为虚拟环境的 *地标*，并从 *site-packages*
    目录下导入第三方模块。
- en: 'This explains how you import third-party modules from the virtual environment,
    but how does Python find modules from the standard library? After all, they’re
    neither copied nor linked into the virtual environment. Again, the answer lies
    in the *pyvenv.cfg* file: When you create a virtual environment, the interpreter
    records its own location under the `home` key in this file. If it later finds
    itself in a virtual environment, it looks for the standard library relative to
    that `home` directory.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 解释了如何从虚拟环境导入第三方模块，但是 Python 如何找到标准库的模块呢？毕竟它们既没有被复制也没有被链接到虚拟环境中。答案再次在 *pyvenv.cfg*
    文件中：当你创建一个虚拟环境时，解释器会记录自己的位置，并将其位置记录在此文件的 `home` 键下。如果后来它发现自己在一个虚拟环境中，它会相对于那个 `home`
    目录寻找标准库。
- en: Note
  id: totrans-168
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The name *pyvenv.cfg* is a remnant of the `pyvenv` script which used to ship
    with Python. The `py -m venv` form makes it clearer which interpreter you use
    to create the virtual environment—​and thus which interpreter the environment
    itself will use.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*pyvenv.cfg* 的名称是 `pyvenv` 脚本的遗留物，该脚本曾经随 Python 一起提供。使用 `py -m venv` 格式使得清楚知道你用来创建虚拟环境的解释器——因此环境本身将使用哪个解释器。'
- en: While the virtual environment has access to the standard library in the system-wide
    environment, it’s isolated from its third-party modules. (Although not recommended,
    you can give the environment access to those modules as well, using the `--system-site-packages`
    option when creating the environment.)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境虽然可以访问系统范围环境中的标准库，但与第三方模块隔离开来。（虽然不推荐，你可以在创建环境时使用 `--system-site-packages`
    选项来给予环境访问这些模块的权限。）
- en: How does pip know where to install packages? The short answer is that pip asks
    the interpreter it’s running on, and the interpreter derives the location from
    its own path—​just like when you import a module.^([8](ch02.html#id259)) This
    is why it’s best to run pip with an explicit interpreter using the `py -m pip`
    idiom. If you invoke `pip` directly, the system searches your `PATH` and may come
    up with the entry-point script from a different environment.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: pip 如何知道安装包的位置？简短的答案是 pip 会询问它正在运行的解释器，并且解释器会根据自己的路径推断出位置——就像当你导入一个模块时一样。这就是为什么最好使用
    `py -m pip` 习语来显式地运行 pip。如果直接调用 `pip`，系统将搜索你的 `PATH`，可能会找到来自不同环境的入口脚本。
- en: Installing Applications with Pipx
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Pipx 安装应用程序
- en: 'In [“Virtual Environments”](#section_environments_venv), you saw why it makes
    good sense to install your projects in separate virtual environments: unlike system-wide
    and per-user environments, virtual environments isolate your projects, avoiding
    dependency conflicts.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“虚拟环境”](#section_environments_venv) 中，你看到为什么将项目安装在单独的虚拟环境中是有道理的：与系统范围和每用户环境不同，虚拟环境将你的项目隔离开来，避免依赖冲突。
- en: The same reasoning applies when you install third-party Python applications—​say,
    a code formatter like Black or a packaging manager like Hatch. Applications tend
    to depend on more packages than libraries, and they can be quite picky about the
    versions of their dependencies.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当您安装第三方 Python 应用程序时，相同的推理也适用——比如，像 Black 这样的代码格式化器或像 Hatch 这样的包管理器。应用程序往往依赖于比库更多的软件包，并且它们对其依赖项的版本可能非常挑剔。
- en: Unfortunately, managing and activating a separate virtual environment for every
    application is cumbersome and confusing—​and it limits you to using only a single
    application at a time. Wouldn’t it be great if we could confine applications to
    virtual environments and still have them available globally?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，为每个应用程序管理和激活单独的虚拟环境非常繁琐和令人困惑——并且限制您一次只能使用一个应用程序。如果我们能将应用程序限制在虚拟环境中并仍然能够全局使用它们，那将是非常好的事情。
- en: 'That’s precisely what [pipx](https://pypa.github.io/pipx/) does, and it leverages
    a simple idea to make it possible: it copies or symlinks the entry-point script
    for the application from its virtual environment into a directory on your search
    path. Entry-point scripts contain the full path to the environment’s interpreter,
    so you can copy them anywhere you want, and they’ll still work.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是[pipx](https://pypa.github.io/pipx/)的功能，它利用了一个简单的思路使其成为可能：从其虚拟环境复制或创建符号链接到应用程序的入口脚本，并将其复制到搜索路径上的目录中。入口脚本包含环境解释器的完整路径，因此您可以将它们复制到任何位置，它们仍然可以正常工作。
- en: Pipx in a Nutshell
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pipx 简介
- en: 'Let me show you how this works in a nutshell—​the commands below are for Linux
    or macOS. First, you create a shared directory for the entry-point scripts of
    your applications and add it to your `PATH` environment variable:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我简要介绍一下这是如何工作的——下面的命令适用于 Linux 或 macOS。首先，您创建一个用于应用程序入口脚本的共享目录，并将其添加到您的`PATH`环境变量中：
- en: '[PRE16]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, you install an application in a dedicated virtual environment—​I’ve chosen
    the Black code formatter as an example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您在专用虚拟环境中安装一个应用程序——我选择了 Black 代码格式化器作为示例：
- en: '[PRE17]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, you copy the entry-point script into the directory you created in
    the first step—​that would be a script named `black` in the *bin* directory of
    the environment:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将入口脚本复制到您在第一步创建的目录中——这将是环境的 *bin* 目录中名为`black`的脚本：
- en: '[PRE18]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now you can invoke `black` even though the virtual environment is not active:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，即使虚拟环境未激活，您也可以调用`black`：
- en: '[PRE19]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: On top of this simple idea, the pipx project has built a cross-platform package
    manager for Python applications with a great developer experience.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的思路之上，pipx 项目构建了一个跨平台的 Python 应用程序包管理器，具有出色的开发者体验。
- en: Tip
  id: totrans-187
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If there’s a single Python application that you should install on a development
    machine, pipx is probably it. It lets you install, run, and manage all the other
    Python applications in a way that’s convenient and avoids trouble.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个单独的 Python 应用程序应该安装在开发机器上，那可能就是 pipx。它让您可以方便地安装、运行和管理所有其他 Python 应用程序，避免了麻烦。
- en: Installing Pipx
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Pipx
- en: 'If your system package manager distributes pipx as a package, I recommend using
    that as the preferred installation method, as it’s more likely to provide good
    integration out-of-the-box:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统包管理器作为软件包分发 pipx，我建议使用它作为首选的安装方法，因为它更可能提供良好的集成。
- en: '[PRE20]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As a post-installation step, update your `PATH` environment variable to include
    the shared script directory, using the `ensurepath` subcommand. (If you’ve modified
    your `PATH` variable when running the commands above, open a new terminal first.)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 作为安装后的步骤，更新您的`PATH`环境变量以包含共享脚本目录，使用`ensurepath`子命令。（如果在运行上述命令时修改了您的`PATH`变量，请先打开一个新的终端。）
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'On Windows, and if your system package manager doesn’t distribute pipx, I recommend
    installing pipx into the per-user environment, like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，如果您的系统包管理器不分发 pipx，我建议将 pipx 安装到每个用户的环境中，像这样：
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The second step also puts the `pipx` command itself on your search path.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步还将`pipx`命令本身放置在您的搜索路径上。
- en: 'If you don’t already have shell completion for pipx, activate it by following
    the instructions for your shell, which you can print with this command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未为 pipx 启用 shell 自动完成，请按照您的 shell 的说明操作，您可以使用以下命令打印这些说明：
- en: '[PRE23]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Managing Applications with Pipx
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Pipx 管理应用程序
- en: 'With pipx installed on your system, you can use it to install and manage applications
    from the Python Package Index (PyPI). For example, here’s how you would install
    Black with pipx:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的系统上安装了 pipx 后，您可以使用它从 Python 包索引（PyPI）安装和管理应用程序。例如，这是如何使用 pipx 安装 Black 的方法：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can also use pipx to upgrade an application to a new release, reinstall
    it, or uninstall it from your system:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用pipx来将应用程序升级到新版本、重新安装它，或从系统中卸载它：
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As a package manager, pipx keeps track of the applications it installs and lets
    you perform bulk operations across all of them. This is particularly useful to
    keep your development tools updated to the latest version and to reinstall them
    on a new version of Python.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个软件包管理器，pipx跟踪其安装的应用程序，并允许你在所有应用程序上执行批量操作。这对于保持开发工具更新到最新版本并在新版本的Python上重新安装它们特别有用。
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can also list the applications you’ve installed previously:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以列出之前安装过的应用程序：
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Some applications support plugins that extend their functionality. These plugins
    must be installed in the same environment as the application. For example, the
    packaging managers Hatch and Poetry both come with plugin systems. Here’s how
    you would install Hatch with a plugin that determines the package version from
    the version control system (see [“Single-sourcing the project version”](ch03.html#section_packages_single_sourcing_the_version)):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序支持插件，扩展其功能。这些插件必须安装在与应用程序相同的环境中。例如，打包管理器Hatch和Poetry都带有插件系统。以下是如何安装Hatch及其从版本控制系统获取包版本的插件（参见[“项目版本的单一来源”](ch03.html#section_packages_single_sourcing_the_version)）的方法：
- en: '[PRE28]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Running Applications with Pipx
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Pipx运行应用程序
- en: 'The commands above provide all the primitives to manage global developer tools
    efficiently, but it gets better. Most of the time, you just want to use recent
    versions of your developer tools. You don’t want the responsibility of keeping
    the tools updated, reinstalling them on new Python versions, or removing them
    when you no longer need them. Pipx allows you to run an application directly from
    PyPI without an explicit installation step. Let’s use the classic Cowsay app to
    try it:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令提供了管理全局开发工具的所有基本操作，但它更进一步。大多数情况下，你只想使用最新版本的开发工具。你不希望负责保持工具更新、在新的Python版本上重新安装它们，或者在不再需要时将其删除。Pipx允许你直接从PyPI运行应用程序，无需显式安装步骤。让我们使用经典的Cowsay应用程序来试试：
- en: '[PRE29]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Behind the scenes, pipx installs Cowsay in a temporary virtual environment and
    runs it with the arguments you’ve provided. It keeps the environment around for
    a while,^([9](ch02.html#id260)) so you don’t end up reinstalling applications
    on every run. Use the `--no-cache` option to force pipx to create a new environment
    and reinstall the latest version.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，pipx在一个临时虚拟环境中安装Cowsay，并使用你提供的参数运行它。它会保留环境一段时间^([9](ch02.html#id260))，因此你不会在每次运行时重新安装应用程序。使用`--no-cache`选项强制pipx创建新环境并重新安装最新版本。
- en: 'You may have noticed an implicit assumption in the `run` command: that the
    PyPI package must have the same name as the command it provides. This may seem
    a reasonable expectation—​but what if a Python package provides multiple commands?
    For example, the pip-tools package (see [“Compiling Requirements with pip-tools
    and uv”](ch04.html#section_dependencies_piptools)) provides commands named `pip-compile`
    and `pip-sync`.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到在`run`命令中有一个隐含的假设：即PyPI包必须与其提供的命令具有相同的名称。这似乎是一个合理的期望——但如果一个Python包提供了多个命令呢？例如，pip-tools包（参见[“使用pip-tools和uv编译依赖关系”](ch04.html#section_dependencies_piptools)）提供了命令`pip-compile`和`pip-sync`。
- en: 'If you find yourself in this situation, provide the PyPI name using the `--spec`
    option, like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己处于这种情况，请使用`--spec`选项提供PyPI名称，如下所示：
- en: '[PRE30]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Tip
  id: totrans-217
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Use `pipx run *<app>*` as the default method to install and run developer tools
    from PyPI. Use `pipx install *<app>*` if you need more control over application
    environments, for example if you need to install plugins. (Replace `*<app>*` with
    the name of the app.)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pipx run *<app>*`作为从PyPI安装和运行开发工具的默认方法。如果需要对应用程序环境进行更多控制，例如需要安装插件，则使用`pipx
    install *<app>*`。（将`*<app>*`替换为应用程序的名称。）
- en: Configuring Pipx
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Pipx
- en: By default, pipx installs applications on the same Python version that it runs
    on itself. This may not be the latest stable version, particularly if you installed
    pipx using a system package manager like APT. I recommend setting the environment
    variable `PIPX_DEFAULT_PYTHON` to the latest stable Python if that’s the case.
    Many developer tools you run with pipx create their own virtual environments;
    for example, virtualenv, Nox, tox, Poetry, and Hatch all do. It’s worthwhile to
    ensure that all downstream environments use a recent Python version by default.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，pipx将应用程序安装在其自身运行的相同Python版本上。这可能不是最新的稳定版本，特别是如果您使用APT等系统包管理器安装了pipx。如果是这种情况，我建议将环境变量`PIPX_DEFAULT_PYTHON`设置为最新的稳定Python版本。您使用pipx运行的许多开发工具都会创建自己的虚拟环境；例如，virtualenv、Nox、tox、Poetry和Hatch都会这样做。通过默认确保所有下游环境使用最新的Python版本，这是值得的。
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Under the hood, pipx uses pip as a package installer. This means that any configuration
    you have for pip also carries over to pipx. A common use case is installing Python
    packages from a private index instead of PyPI, such as a company-wide package
    repository.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，pipx使用pip作为包安装程序。这意味着您为pip设置的任何配置也适用于pipx。一个常见的用例是从私有索引而不是PyPI安装Python包，例如公司范围的包存储库。
- en: 'You can use `pip config` to set the URL of your preferred package index persistently:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`pip config`持久地设置您首选的包索引的URL：
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Alternatively, you can set the package index for the current shell session
    only. Most pip options are also available as environment variables:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以仅为当前shell会话设置包索引。大多数pip选项也可作为环境变量使用：
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Both methods cause pipx to install applications from the specified index.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法都会导致pipx从指定的索引安装应用程序。
- en: Managing Environments with uv
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用uv管理环境
- en: The tool `uv` is a drop-in replacement for core Python packaging tools, written
    in the Rust programming language. It offers order-of-magnitude performance improvements
    over the Python tools it replaces, in a single static binary without dependencies.
    While its `uv venv` and `uv pip` subcommands aim for compatibility with virtualenv
    and pip, uv also embraces evolving best practices, such as operating in a virtual
    environment by default.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 工具`uv`是Rust编程语言编写的核心Python打包工具的替代品。它在单个静态二进制文件中不依赖于任何依赖项，相比其替代的Python工具，性能提升数量级。虽然其`uv
    venv`和`uv pip`子命令旨在与virtualenv和pip兼容，但uv也积极接受不断发展的最佳实践，例如默认情况下在虚拟环境中运行。
- en: 'Install uv with pipx:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pipx安装uv：
- en: '[PRE34]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'By default, uv creates a virtual environment using the well-known name *.venv*
    (you can pass another location as an argument):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，uv使用众所周知的名称*.venv*创建虚拟环境（您可以将另一个位置作为参数传递）：
- en: '[PRE35]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Specify the interpreter for the virtual environment using the `--python` option
    with a specification like `3.12` or `python3.12`; a full path to an interpreter
    also works. Uv discovers available interpreters by scanning your `PATH`. On Windows,
    it also inspects the output of `py --list-paths`. If you don’t specify an interpreter,
    uv defaults to `python3` on Linux and macOS, and `python.exe` on Windows.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--python`选项指定虚拟环境的解释器，其规范如`3.12`或`python3.12`；也可以使用解释器的完整路径。uv通过扫描您的`PATH`发现可用的解释器。在Windows上，它还会检查`py
    --list-paths`的输出。如果不指定解释器，则uv在Linux和macOS上默认为`python3`，在Windows上默认为`python.exe`。
- en: Note
  id: totrans-235
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Despite its name, `uv venv` emulates the Python tool virtualenv, not the built-in
    `venv` module. Virtualenv creates environments with any Python interpreter on
    your system. It combines interpreter discovery with aggressive caching to make
    this fast and flawless.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管其名称为`uv venv`模拟了Python工具virtualenv，而不是内置的`venv`模块。Virtualenv在系统上使用任何Python解释器创建环境。它将解释器发现与积极缓存结合起来，使其快速且无瑕疵。
- en: 'By default, uv installs packages into the environment named *.venv* in the
    current directory or one of its parent directories (using the same logic as the
    Python Launcher for Unix):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，uv 将包安装到当前目录或其父目录中名为*.venv*的环境中（使用与Unix上Python启动器相同的逻辑）：
- en: '[PRE36]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can install packages into another environment by activating it—​this works
    for both virtual environments (`VIRTUAL_ENV`) and Conda environments (`CONDA_PREFIX`).
    If there’s neither an active environment nor a *.venv* directory, uv bails out
    with an error. It will never install or uninstall packages from your global environment,
    unless you explicitly ask it to do so using the `--system` option.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过激活它将包安装到另一个环境中—​这适用于虚拟环境（`VIRTUAL_ENV`）和Conda环境（`CONDA_PREFIX`）。如果既没有活动环境也没有*.venv*目录，则
    uv 将以错误退出。它永远不会从全局环境安装或卸载包，除非您使用`--system`选项明确要求它这样做。
- en: While uv’s initial development has focused on providing drop-in replacements
    for standard Python tooling, its ultimate goal is to grow into that one unified
    packaging tool that has eluded Python for so long—​with the kind of developer
    experience that Rust developers love about Cargo. Even at this early stage, uv
    gives you a unified and streamlined workflow, thanks to a cohesive feature set
    with good defaults. And it’s blazingly fast.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 uv 的初始开发主要专注于为标准 Python 工具提供替代品，但其最终目标是成为长期以来 Python 一直缺少的统一打包工具——具有 Rust
    开发者喜爱 Cargo 的开发者体验。即使在这个早期阶段，uv 也能够通过具有良好默认设置的统一和流畅的功能集提供统一和流畅的工作流程。而且它速度非常快。
- en: Finding Python Modules
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找 Python 模块
- en: 'Python environments consist, first and foremost, of a Python interpreter and
    Python modules. Consequently, there are two mechanisms that play a key role in
    linking a Python program to an environment: interpreter discovery and module import.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Python 环境首先由 Python 解释器和 Python 模块组成。因此，有两种机制在将 Python 程序链接到环境中起到关键作用：解释器发现和模块导入。
- en: '*Interpreter discovery* is the process of locating the Python interpreter to
    execute a program. You’ve already seen the most important methods for locating
    interpreters:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*解释器发现* 是定位 Python 解释器以执行程序的过程。你已经看到了定位解释器的最重要方法：'
- en: Entry-point scripts reference the interpreter in their environment directly,
    using a shebang or a wrapper executable (see [“Entry-point scripts”](#section_environments_scripts)).
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 入口点脚本直接在其环境中引用解释器，使用 shebang 或包装可执行文件（详见 [“入口点脚本”](#section_environments_scripts)）。
- en: Shells locate the interpreter by searching directories on `PATH` for commands
    like `python`, `python3`, or `python3.x` (see [“Locating Python Interpreters”](ch01.html#section_path)).
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shell 通过在 `PATH` 中搜索目录来定位解释器，例如 `python`、`python3` 或 `python3.x` 命令（详见 [“定位
    Python 解释器”](ch01.html#section_path)）。
- en: The Python Launcher locates interpreters using the Windows Registry, `PATH`
    (on Linux and macOS), and the `VIRTUAL_ENV` variable (see [“The Python Launcher
    for Windows”](ch01.html#section_python_launcher_windows) and [“The Python Launcher
    for Unix”](ch01.html#section_python_launcher_unix)).
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 启动器通过 Windows 注册表、`PATH`（在 Linux 和 macOS 上）、以及 `VIRTUAL_ENV` 变量来定位解释器（详见
    [“Python 启动器（Windows）”](ch01.html#section_python_launcher_windows) 和 [“Python
    启动器（Unix）”](ch01.html#section_python_launcher_unix)）。
- en: When you activate a virtual environment, the activation script puts its interpreter
    and entry-point scripts on `PATH`. It also sets the `VIRTUAL_ENV` variable for
    the Python Launcher and other tools (see [“Virtual Environments”](#section_environments_venv)).
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你激活一个虚拟环境时，激活脚本会将其解释器和入口点脚本放置在 `PATH` 上。它还为 Python 启动器和其他工具设置 `VIRTUAL_ENV`
    变量（详见 [“虚拟环境”](#section_environments_venv)）。
- en: 'This section takes a deep dive into the other mechanism that links programs
    to an environment: *module import*, which is the process of locating and loading
    Python modules for a program.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 本节深入探讨了将程序链接到环境的另一种机制：*模块导入*，即为程序定位和加载 Python 模块的过程。
- en: Tip
  id: totrans-249
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: In a nutshell, just like the shell searches `PATH` for executables, Python searches
    `sys.path` for modules. This variable holds a list of locations from where Python
    can load modules—​most commonly, directories on the local filesystem.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 简言之，就像 Shell 在 `PATH` 中搜索可执行文件一样，Python 在 `sys.path` 中搜索模块。这个变量包含 Python 可以加载模块的位置列表，通常是本地文件系统上的目录。
- en: The machinery behind the `import` statement lives in `importlib` from the standard
    library (see [“Inspecting modules and packages with importlib”](#sidebar_environments_importlib)).
    The interpreter translates every use of the `import` statement into an invocation
    of the `__import__` function from `importlib`. The `importlib` module also exposes
    an `import_module` function that allows you to import modules whose names are
    only known at runtime.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`import` 语句背后的机制存放在标准库的 `importlib` 中（详见 [“使用 importlib 检查模块和包”](#sidebar_environments_importlib)）。解释器将
    `import` 语句的每次使用都转换为对 `importlib` 中的 `__import__` 函数的调用。`importlib` 模块还暴露了一个 `import_module`
    函数，允许你在运行时导入只有名称已知的模块。'
- en: Having the import system in the standard library lets you inspect and customize
    the import mechanism from within Python. For example, the import system supports
    loading modules from directories and from zip archives out of the box. But entries
    on `sys.path` can be anything really—​say, a URL or a database query—​as long
    as you register a function in `sys.path_hooks` that knows how to find and load
    modules from these path entries.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 将导入系统放入标准库允许你从Python内部检查和定制导入机制。例如，导入系统支持直接从目录和zip归档文件加载模块。但是`sys.path`上的条目可以是任何东西——比如，一个URL或一个数据库查询——只要你在`sys.path_hooks`中注册一个函数，它知道如何从这些路径条目中找到并加载模块。
- en: Module Objects
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块对象
- en: When you import a module, the import system returns a *module object*, an object
    of type `types.ModuleType`. Any global variable defined by the imported module
    becomes an attribute of the module object. This allows you to access the module
    variable in dotted notation (`module.var`) from the importing code.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导入一个模块时，导入系统返回一个*module object*，这是一个`types.ModuleType`类型的对象。被导入模块定义的任何全局变量都成为模块对象的属性。这使得你可以从导入代码中使用点符号（`module.var`）访问模块变量。
- en: 'Under the hood, module variables are stored in a dictionary in the `__dict__`
    attribute of the module object. (This is the standard mechanism used to store
    attributes of any Python object.) When the import system loads a module, it creates
    a module object and executes the module’s code using `__dict__` as the global
    namespace. To simplify somewhat, it invokes the built-in `exec` function like
    this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，模块变量存储在模块对象的`__dict__`属性的字典中。（这是存储任何Python对象属性的标准机制。）当导入系统加载模块时，它创建一个模块对象，并使用`__dict__`作为全局命名空间执行模块的代码。稍微简化一下，它像这样调用内置的`exec`函数：
- en: '[PRE37]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Additionally, module objects have some special attributes. For instance, the
    `__name__` attribute holds the fully-qualified name of the module, like `email.message`.
    The `__spec__` module holds the *module spec*, which I’ll talk about shortly.
    Packages also have a `__path__` attribute, which contains locations to search
    for submodules.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，模块对象还有一些特殊的属性。例如，`__name__`属性保存模块的完全限定名称，如`email.message`。`__spec__`模块保存*module
    spec*，我稍后会讨论。包还有一个`__path__`属性，其中包含搜索子模块的位置。
- en: Note
  id: totrans-258
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Most commonly, the `__path__` attribute of a package contains a single entry:
    the directory holding its *__init__.py* file. Namespace packages, on the other
    hand, can be distributed across multiple directories.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的情况是，包的`__path__`属性包含一个条目：包含其*__init__.py*文件的目录。另一方面，命名空间包可以分布在多个目录中。
- en: The Module Cache
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块缓存
- en: 'When you first import a module, the import system stores the module object
    in the `sys.modules` dictionary, using its fully-qualified name as a key. Subsequent
    imports return the module object directly from `sys.modules`. This mechanism brings
    a number of benefits:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当你首次导入一个模块时，导入系统将模块对象存储在`sys.modules`字典中，使用其完全限定名称作为键。后续的导入直接从`sys.modules`返回模块对象。这种机制带来了许多好处：
- en: Performance
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 性能
- en: Imports are expensive because the import system loads most modules from disk.
    Importing a module also involves executing its code, which can further increase
    startup time. The `sys.modules` dictionary functions as a cache to speed things
    up.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 导入是昂贵的，因为导入系统从磁盘加载大多数模块。导入一个模块还涉及执行其代码，这可能会进一步增加启动时间。`sys.modules`字典作为一个缓存以加快速度。
- en: Idempotency
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 幂等性
- en: Importing modules can have side effects, for example when executing module-level
    statements. Caching modules in `sys.modules` ensures that these side effects happen
    only once. The import system also uses locks to ensure that multiple threads can
    safely import the same module.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 导入模块可能会产生副作用，例如在执行模块级语句时。将模块缓存在`sys.modules`中确保这些副作用只发生一次。导入系统还使用锁来确保多个线程可以安全地导入相同的模块。
- en: Recursion
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 递归
- en: Modules can end up importing themselves recursively. A common case is *circular
    imports*, where module `a` imports module `b`, and `b` imports `a`. The import
    system supports this by adding modules to `sys.modules` *before* they’re executed.
    When `b` imports `a`, the import system returns the (partially initialized) module
    `a` from the `sys.modules` dictionary, thereby preventing an infinite loop.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 模块可能会出现递归导入自身的情况。一个常见的情况是*circular imports*，即模块`a`导入模块`b`，而`b`又导入`a`。导入系统通过在执行前将模块添加到`sys.modules`中来支持此功能。当`b`导入`a`时，导入系统从`sys.modules`字典中返回（部分初始化的）模块`a`，从而防止无限循环。
- en: Module Specs
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块规格
- en: 'Conceptually, Python imports a module in two steps: *finding* and *loading*.
    First, given the fully-qualified name of a module, the import system locates the
    module and produces a module spec (`importlib.machinery.ModuleSpec`). Second,
    the import system creates a module object from the module spec and executes the
    module’s code.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在概念上，Python导入模块分为两个步骤：*查找*和*加载*。首先，给定模块的完全限定名称，导入系统会定位模块并生成模块规范（`importlib.machinery.ModuleSpec`）。其次，导入系统从模块规范创建一个模块对象并执行模块的代码。
- en: The module spec is the link between those two steps. A *module spec* contains
    metadata about a module such as its name and location, as well as an appropriate
    loader for the module ([Table 2-5](#table_environments_module_spec)). You can
    also access most of the metadata from the module spec using special attributes
    directly on the module object.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 模块规范是这两个步骤之间的链接。*模块规范*包含有关模块的元数据，例如其名称和位置，以及适当的加载器用于该模块（[表2-5](#table_environments_module_spec)）。您还可以直接从模块对象上的特殊属性访问大多数元数据。
- en: Table 2-5\. Attributes of Module Specs and Module Objects
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-5. 模块规范和模块对象的属性
- en: '| Spec Attribute | Module attribute | Description |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| 规范属性 | 模块属性 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `name` | `__name__` | The fully-qualified name of the module. |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `name` | `__name__` | 模块的完全限定名称。 |'
- en: '| `loader` | `__loader__` | A loader object that knows how to execute the module’s
    code. |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `loader` | `__loader__` | 一个知道如何执行模块代码的加载器对象。 |'
- en: '| `origin` | `__file__` | The location of the module. |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `origin` | `__file__` | 模块的位置。 |'
- en: '| `submodule_search_locations` | `__path__` | Where to search for submodules,
    if the module is a package. |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `submodule_search_locations` | `__path__` | 如果模块是一个包，那么在哪里搜索子模块。 |'
- en: '| `cached` | `__cached__` | The location of the compiled bytecode for the module.
    |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `cached` | `__cached__` | 模块的编译字节码的位置。 |'
- en: '| `parent` | `__package__` | The fully-qualified name of the containing package.
    |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `parent` | `__package__` | 包含包的完全限定名称。 |'
- en: The `__file__` attribute of a module typically holds the filename of the Python
    module. In special cases, it’s a fixed string, like `"builtin"` for built-in modules,
    or `None` for namespace packages (which don’t have a single location).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的`__file__`属性通常包含Python模块的文件名。在特殊情况下，它是一个固定的字符串，例如内置模块的`"builtin"`，或者对于命名空间包（没有单一位置）是`None`。
- en: Finders and Loaders
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找器和加载器
- en: The import system finds and loads modules using two kinds of objects. *Finders*
    (`importlib.abc.MetaPathFinder`) are responsible for locating modules given their
    fully-qualified names. When successful, their `find_spec` method returns a module
    spec with a loader; otherwise, it returns `None`. *Loaders* (`importlib.abc.Loader`)
    are objects with an `exec_module` function which load and execute the module’s
    code. The function takes a module object and uses it as a namespace when executing
    the module. The finder and loader can be the same object, which is then known
    as an *importer*.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 导入系统使用两种类型的对象查找和加载模块。*查找器*（`importlib.abc.MetaPathFinder`）负责根据其完全限定名称查找模块。成功时，它们的`find_spec`方法返回一个带有加载器的模块规范；否则，它返回`None`。*加载器*（`importlib.abc.Loader`）是具有`exec_module`函数的对象，该函数加载并执行模块的代码。该函数接受一个模块对象，并在执行模块时将其用作命名空间。查找器和加载器可以是相同的对象，然后称为*导入器*。
- en: Finders are registered in the `sys.meta_path` variable, and the import system
    tries each finder in turn. When a finder has returned a module spec with a loader,
    the import system creates and initializes a module object, then passes it to the
    loader for execution.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 查找器注册在`sys.meta_path`变量中，导入系统依次尝试每个查找器。当一个查找器返回了带有加载器的模块规范时，导入系统将创建并初始化一个模块对象，然后将其传递给加载器执行。
- en: 'By default, the `sys.meta_path` variable contains three finders, which handle
    different kinds of modules (see [“Python modules”](#section_environments_modules)):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`sys.meta_path`变量包含三个查找器，用于处理不同类型的模块（参见[“Python模块”](#section_environments_modules)）：
- en: '`importlib.machinery.BuiltinImporter` for built-in modules'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于内置模块，使用`importlib.machinery.BuiltinImporter`
- en: '`importlib.machinery.FrozenImporter` for frozen modules'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于冻结模块，使用`importlib.machinery.FrozenImporter`
- en: '`importlib.machinery.PathFinder` to search modules on `sys.path`'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`importlib.machinery.PathFinder`在`sys.path`上搜索模块
- en: 'The `PathFinder` is the central hub of the import machinery. It’s responsible
    for every module that’s not embedded into the interpreter, and searches `sys.path`
    to locate it.^([10](ch02.html#id261)) The path finder uses a second level of finder
    objects known as *path entry finders* (`importlib.abc.PathEntryFinder`), each
    of which finds modules under a specific location on `sys.path`. The standard library
    provides two types of path entry finders, registered under `sys.path_hooks`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`PathFinder` 是导入机制的中央枢纽。它负责所有未嵌入到解释器中的模块，并搜索 `sys.path` 来定位它。^([10](ch02.html#id261))
    路径查找器使用称为*路径条目查找器*（`importlib.abc.PathEntryFinder`）的第二级查找器对象，每个对象在 `sys.path`
    的特定位置下查找模块。标准库提供了两种类型的路径条目查找器，注册在 `sys.path_hooks` 下：'
- en: '`zipimport.zipimporter` to import modules from zip archives'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zipimport.zipimporter` 用于从 zip 存档中导入模块'
- en: '`importlib.machinery.FileFinder` to import modules from a directory'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`importlib.machinery.FileFinder` 用于从目录导入模块'
- en: 'Typically, modules are stored in directories on the filesystem, so `PathFinder`
    delegates its work to a `FileFinder`. The latter scans the directory for the module,
    and uses its file extension to determine the appropriate loader. There are three
    loaders for the different kinds of modules:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，模块存储在文件系统上的目录中，因此 `PathFinder` 将其工作委托给 `FileFinder`。后者扫描目录以查找模块，并根据其文件扩展名确定适当的加载器。有三种类型的加载器用于不同类型的模块：
- en: '`importlib.machinery.SourceFileLoader` for pure Python modules'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`importlib.machinery.SourceFileLoader` 用于纯 Python 模块'
- en: '`importlib.machinery.SourcelessFileLoader` for bytecode modules'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`importlib.machinery.SourcelessFileLoader` 用于字节码模块'
- en: '`importlib.machinery.ExtensionFileLoader` for binary extension modules'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`importlib.machinery.ExtensionFileLoader` 用于二进制扩展模块'
- en: The zip importer works similarly, except that it doesn’t support extension modules,
    because current operating systems don’t allow loading dynamic libraries from a
    zip archive.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Zip 导入器的工作原理类似，但不支持扩展模块，因为当前操作系统不允许从 zip 存档中加载动态库。
- en: The Module Path
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块路径
- en: When your program can’t find a specific module, or imports the wrong version
    of a module, it can help to take a look at `sys.path`, the module path. But where
    do the entries on `sys.path` come from in the first place? Let’s unravel some
    of the mysteries of the module path.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序无法找到特定模块或导入模块的错误版本时，查看 `sys.path`，即模块路径，可能会有所帮助。但首先， `sys.path` 上的条目来自哪里？让我们解开一些模块路径的奥秘。
- en: When the interpreter starts up, it constructs the module path in two steps.
    First, it builds an initial module path using some built-in logic. Most importantly,
    this initial path includes the standard library. Second, the interpreter imports
    the `site` module from the standard library. The `site` module extends the module
    path to include the site packages from the current environment.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当解释器启动时，它通过两个步骤构建模块路径。首先，它使用一些内置逻辑构建初始模块路径。最重要的是，此初始路径包括标准库。其次，解释器从标准库导入 `site`
    模块。 `site` 模块扩展模块路径以包括当前环境中的站点包。
- en: In this section, we’ll take a look at how the interpreter constructs the initial
    module path with the standard library. The next section explains how the `site`
    module appends directories with site packages.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看解释器如何使用标准库构建初始模块路径。下一节解释了 `site` 模块如何附加包含站点包的目录。
- en: Note
  id: totrans-300
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the built-in logic for constructing `sys.path` in *Modules/getpath.py*
    in the CPython source code. Despite appearances, this is not an ordinary module.
    When you build Python, its code is frozen to bytecode and embedded in the executable.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 CPython 源代码的 *Modules/getpath.py* 中找到构建 `sys.path` 的内置逻辑。尽管外表如此，但这并不是普通模块。在构建
    Python 时，其代码被冻结为字节码并嵌入到可执行文件中。
- en: 'The locations on the initial module path fall into three categories, and they
    occur in the order given below:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 初始模块路径上的位置可分为三类，并按以下顺序出现：
- en: The current directory or the directory containing the Python script (if any)
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前目录或包含 Python 脚本的目录（如果有）
- en: The locations in the `PYTHONPATH` environment variable (if set)
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PYTHONPATH` 环境变量中的位置（如果已设置）'
- en: The locations of the standard library
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标准库的位置
- en: Let’s look at each in more detail.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看一下每个。
- en: The current directory or the directory containing the script
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当前目录或包含脚本的目录
- en: 'The first item on `sys.path` can be any of the following:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys.path` 上的第一项可以是以下任何一种：'
- en: If you ran `py *<script>*`, the directory where the script is located
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您运行了 `py *<script>*`，则是脚本所在的目录
- en: If you ran `py -m *<module>*`, the current directory
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您运行了 `py -m *<module>*`，则是当前目录
- en: Otherwise, the empty string, which also denotes the current directory
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，空字符串，也表示当前目录
- en: 'Traditionally, this mechanism has long provided a convenient way to structure
    an application: Just put the main entry-point script and all application modules
    in the same directory. During development, launch the interpreter from within
    that directory for interactive debugging, and your imports will still work.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，这种机制长期以来一直是构建应用程序的便捷方式：只需将主入口脚本和所有应用程序模块放在同一个目录中。在开发过程中，从该目录启动解释器进行交互式调试，你的导入仍然有效。
- en: Unfortunately, having the working directory on `sys.path` is quite unsafe, as
    an attacker (or you, mistakenly) can override the standard library by placing
    Python files in the victim’s directory. To avoid this, starting with Python 3.11,
    you can use the `-P` interpreter option or the `PYTHONSAFEPATH` environment variable
    to omit the current directory from `sys.path`. If you invoke the interpreter with
    a script, this option also omits the directory where the script is located.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，将工作目录放在 `sys.path` 上非常不安全，因为攻击者（或者你误操作）可以通过将 Python 文件放置在受害者目录中来覆盖标准库。为了避免这种情况，在
    Python 3.11 开始，你可以使用 `-P` 解释器选项或 `PYTHONSAFEPATH` 环境变量来从 `sys.path` 中省略当前目录。如果你使用脚本调用解释器，此选项还会省略脚本所在的目录。
- en: Installing your application into a virtual environment is a safer and more flexible
    approach than putting its modules in the current directory. This requires packaging
    the application, which is the topic of [Chapter 3](ch03.html#chapter_packages).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序安装到虚拟环境中比将其模块放在当前目录中更安全且更灵活。这需要对应用程序进行打包，这是[第三章](ch03.html#chapter_packages)的主题。
- en: The PYTHONPATH variable
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PYTHONPATH 变量
- en: The `PYTHONPATH` environment variable provides another way to add locations
    before the standard library on `sys.path`. It uses the same syntax as the `PATH`
    variable. Avoid this mechanism for the same reasons as the current working directory
    and use a virtual environment instead.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`PYTHONPATH` 环境变量提供了另一种在 `sys.path` 上标准库之前添加位置的方式。它使用与 `PATH` 变量相同的语法。出于与当前工作目录相同的原因，避免使用此机制，而改用虚拟环境。'
- en: The standard library
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准库
- en: '[Table 2-6](#table_environments_stdlib_path) shows the remaining entries on
    the initial module path, which are dedicated to the standard library. Locations
    are prefixed with the path to the installation, and may differ in details on some
    platforms. Notably, Fedora places the standard library under *lib64* instead of
    *lib*.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-6](#table_environments_stdlib_path) 显示了初始模块路径上的其余条目，这些条目专用于标准库。位置以安装路径为前缀，并且在某些平台上可能有细微差别。值得注意的是，Fedora
    将标准库放在 *lib64* 而不是 *lib* 下。'
- en: Table 2-6\. The standard library on `sys.path`
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-6\. `sys.path` 上的标准库
- en: '| Windows | Linux and macOS | Description |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| Windows | Linux 和 macOS | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| *python3x.zip* | *lib/python3x.zip* | For compactness, the standard library
    can be installed as a zip archive. This entry is present even if the archive doesn’t
    exist (which it normally doesn’t). |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| *python3x.zip* | *lib/python3x.zip* | 为了紧凑性，标准库可以安装为 zip 存档。即使存档不存在（通常不会存在），此条目也会存在。
    |'
- en: '| *Lib* | *lib/python3.x* | Pure Python modules |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| *Lib* | *lib/python3.x* | 纯 Python 模块 |'
- en: '| *DLLs* | *lib/python3.x/lib-dynload* | Binary extension modules |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| *DLLs* | *lib/python3.x/lib-dynload* | 二进制扩展模块 |'
- en: 'The location of the standard library is not hardcoded in the interpreter (see
    [“Virtual Environments”](#section_environments_venv)). Rather, Python looks for
    landmark files on the path to its own executable, and uses them to locate the
    current environment (`sys.prefix`) and the Python installation (`sys.base_prefix`).
    One such landmark file is *pyvenv.cfg*, which marks a virtual environment and
    points to its parent installation via the `home` key. Another landmark is *os.py*,
    the file containing the standard `os` module: Python uses *os.py* to discover
    the prefix outside of a virtual environment, and to locate the standard library
    itself.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库的位置没有硬编码在解释器中（参见[“虚拟环境”](#section_environments_venv)）。相反，Python 在寻找自己可执行文件的路径上查找标志性文件，并使用它们来定位当前环境
    (`sys.prefix`) 和 Python 安装 (`sys.base_prefix`)。这样的标志性文件之一是 *pyvenv.cfg*，它标记了一个虚拟环境并通过
    `home` 键指向其父安装。另一个标志性文件是包含标准 `os` 模块的 *os.py* 文件：Python 使用 *os.py* 来发现虚拟环境外的前缀，并定位标准库本身。
- en: Site Packages
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 站点包
- en: The interpreter constructs the initial `sys.path` early on during initialization
    using a fairly fixed process. By contrast, the remaining locations on `sys.path`—known
    as *site packages*—are highly customizable and under the responsibility of a Python
    module named `site`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器在初始化过程中的早期构建初始 `sys.path` 使用一个相当固定的过程。相比之下，`sys.path` 上的其余位置，称为站点软件包，高度可定制并由名为
    `site` 的 Python 模块负责。
- en: 'The `site` module adds the following path entries if they exist on the filesystem:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`site` 模块在文件系统上存在时添加以下路径条目：'
- en: User site packages
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 用户站点软件包
- en: 'This directory holds third-party packages from the per-user environment. It’s
    in a fixed location that depends on the OS (see [“The Per-User Environment”](#section_environments_peruser)).
    On Fedora and some other systems, there are two path entries: for pure Python
    modules and extension modules, respectively.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 此目录保存来自每个用户环境的第三方软件包。它位于取决于操作系统的固定位置（参见[“每个用户环境”](#section_environments_peruser)）。在
    Fedora 和一些其他系统上，有两个路径条目：分别用于纯 Python 模块和扩展模块。
- en: Site packages
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 站点软件包
- en: This directory holds third-party packages from the current environment, which
    is either a virtual environment or a system-wide installation. On Fedora and some
    other systems, pure Python modules and extension modules are in separate directories.
    Many Linux systems also separate distribution-owned site packages under */usr*
    from local site packages under */usr/local*.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 此目录保存来自当前环境的第三方软件包，该环境可以是虚拟环境或系统范围的安装。在 Fedora 和一些其他系统上，纯 Python 模块和扩展模块位于不同的目录中。许多
    Linux 系统还将分发拥有的站点软件包与本地站点软件包分开，分别放在 */usr* 和 */usr/local* 下。
- en: In the general case, the site packages are in a subdirectory of the standard
    library named *site-packages*. If the `site` module finds a *pyvenv.cfg* file
    on the interpreter path, it uses the same relative path as in a system installation,
    but starts from the virtual environment marked by that file. The `site` module
    also modifies `sys.prefix` to point to the virtual environment.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，站点软件包位于名为 *site-packages* 的标准库的子目录中。如果 `site` 模块在解释器路径上找到 *pyvenv.cfg*
    文件，则它使用与系统安装中相同的相对路径，但是从该文件标记的虚拟环境开始。`site` 模块还修改 `sys.prefix` 以指向虚拟环境。
- en: 'The `site` module provides a few hooks for customization:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`site` 模块提供了一些用于定制的钩子：'
- en: '*.pth* files'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '*.pth* 文件'
- en: Within site packages directories, any file with a *.pth* extension can list
    additional directories for `sys.path`, one directory per line. This works similar
    to `PYTHONPATH`, except that modules in these directories will never shadow the
    standard library. Additionally, *.pth* files can import modules directly—​the
    `site` module executes any line starting with `import` as Python code. Third-party
    packages can ship *.pth* files to configure `sys.path` in an environment. Some
    packaging tools use *.pth* files behind the scenes to implement editable installs.
    An *editable install* places the source directory of your project on `sys.path`,
    making code changes instantly visible inside the environment.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在站点软件包目录中，任何具有 *.pth* 扩展名的文件都可以列出用于 `sys.path` 的额外目录，每行一个目录。这类似于 `PYTHONPATH`
    的工作方式，但是这些目录中的模块永远不会覆盖标准库。此外，*.pth* 文件还可以直接导入模块——`site` 模块会执行以 `import` 开头的任何行作为
    Python 代码。第三方软件包可以提供 *.pth* 文件以配置环境中的 `sys.path`。一些打包工具在后台使用 *.pth* 文件来实现可编辑安装。可编辑安装会将项目的源目录放置在
    `sys.path` 中，使代码更改立即在环境内可见。
- en: The `sitecustomize` module
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`sitecustomize` 模块'
- en: After setting up `sys.path` as described above, the `site` module attempts to
    import the `sitecustomize` module, typically located in the *site-packages* directory.
    This provides a hook for the system administrator to run site-specific customizations
    when the interpreter starts up.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置 `sys.path` 如上所述之后，`site` 模块会尝试导入 `sitecustomize` 模块，通常位于 *site-packages*
    目录中。这提供了一个钩子，允许系统管理员在解释器启动时运行站点特定的自定义。
- en: The `usercustomize` module
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`usercustomize` 模块'
- en: If there is a per-user environment, the `site` module also attempts to import
    the `usercustomize` module, typically located in the user *site-packages* directory.
    You can use this module to run user-specific customizations when the interpreter
    starts up. Contrast this with the `PYTHONSTARTUP` environment variable, which
    allows you to specify a Python script to run before interactive sessions, within
    the same namespace as the session.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在每个用户环境，则`site`模块还会尝试导入`usercustomize`模块，通常位于用户*site-packages*目录中。你可以使用这个模块在解释器启动时运行用户特定的自定义。与`PYTHONSTARTUP`环境变量相比，后者允许你指定一个Python脚本在交互会话之前运行，位于同一命名空间内。
- en: 'If you run the `site` module as a command, it prints out your current module
    path, as well as some information about the per-user environment:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`site`模块作为命令运行，它会打印出你当前的模块路径，以及一些关于每个用户环境的信息：
- en: '[PRE38]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Back to the Basics
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回到基础知识
- en: If you’ve read this far, the module path may almost seem a little—*byzantine*?
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你读到这里，模块路径可能看起来有点—*复杂*？
- en: 'Here’s a good, solid intuition of how Python locates a module: The interpreter
    searches the directories on `sys.path` for the module—​first the directories that
    contain the modules of the standard library, then the *site-packages* directory
    with third-party packages. An interpreter in a virtual environment uses the *site-packages*
    directory from that environment.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个对Python如何定位模块的良好、坚实的直觉：解释器在`sys.path`上搜索模块的目录—​首先是包含标准库模块的目录，然后是带有第三方包的*site-packages*目录。虚拟环境中的解释器使用该环境的*site-packages*目录。
- en: 'As you’ve seen in this section, the truth is far more complex than that simple
    story. But I’ve got good news for you: Python lets you *make* that story true.
    The `-P` interpreter option omits the directory containing your script from the
    module path (or the current directory, if you’re running your program with `py
    -m *<module>*`). The `-I` interpreter option omits the per-user environment from
    the module path, as well as any directories set with `PYTHONPATH`. Use both options
    when running your Python programs if you want a more predictable module path.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本节中所看到的，事实远比那个简单的故事复杂。但我有好消息告诉你：Python可以让你*实现*这个故事。`-P`解释器选项省略了包含你的脚本的目录（或者如果你用`py
    -m *<module>*`运行程序，则省略当前目录）在模块路径中。`-I`解释器选项省略了每个用户环境在模块路径中的位置，以及任何使用`PYTHONPATH`设置的目录。如果你想要更可预测的模块路径，运行Python程序时同时使用这两个选项。
- en: 'If you re-run the `site` module with the `-I` and `-P` options, the module
    path is cut down to just the standard library and site packages:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`-I`和`-P`选项重新运行`site`模块，模块路径将被缩减为仅包括标准库和站点包：
- en: '[PRE39]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The current directory no longer appears on the module path, and the per-user
    site packages are gone, too—​even though the directory exists on this system.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 当前目录不再出现在模块路径上，每个用户的站点包也消失了，即使该目录在此系统上存在。
- en: Summary
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you’ve learned what Python environments are, where to find
    them, and how they look on the inside. At the core, a Python environment consists
    of the Python interpreter and Python modules, as well as entry-point scripts to
    run Python applications. Environments are tied to a specific version of the Python
    language.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经了解了Python环境是什么，如何找到它们以及它们内部的样子。在核心，Python环境由Python解释器和Python模块组成，以及运行Python应用程序的入口点脚本。环境与特定版本的Python语言相关联。
- en: There are three kinds of Python environments. *Python installations* are complete,
    stand-alone environments with an interpreter and the full standard library. *Per-user
    environments* are annexes to an installation where you can install modules and
    scripts for a single user. *Virtual environments* are lightweight environments
    for project-specific modules and entry-point scripts, which reference their parent
    environment via a *pyvenv.cfg* file. They come with an interpreter, which is typically
    a symbolic link or small wrapper for the parent interpreter, and with activation
    scripts for shell integration. You create a virtual environment using the command
    `py -m venv`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种类型的Python环境。 *Python安装*是完整的、独立的环境，包括解释器和完整的标准库。 *每个用户环境* 是安装的附属环境，你可以在其中为单个用户安装模块和脚本。
    *虚拟环境*是轻量级的环境，用于项目特定模块和入口点脚本，它们通过一个*pyvenv.cfg*文件引用其父环境。它们带有一个解释器，通常是父解释器的符号链接或小包装器，并带有用于shell集成的激活脚本。你可以使用命令`py
    -m venv`创建一个虚拟环境。
- en: Install Python applications with pipx to make them available globally while
    keeping them in separate virtual environments. You can install and run an application
    using a single command, such as `pipx run black`. Set the `PIPX_DEFAULT_PYTHON`
    variable to ensure pipx installs tools on the current Python release.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pipx 安装 Python 应用程序，使它们在全局可用，同时将它们保留在单独的虚拟环境中。你可以使用类似 `pipx run black` 的单个命令安装和运行应用程序。设置
    `PIPX_DEFAULT_PYTHON` 变量以确保 pipx 在当前 Python 版本上安装工具。
- en: Uv is a blazingly fast drop-in replacement for virtualenv and pip with better
    defaults. Use `uv venv` to create a virtual environment, and `uv pip` to install
    packages into it. Both commands use the *.venv* directory by default, just like
    the `py` tool on Unix. The `--python` option lets you select the Python version
    for the environment.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Uv 是一个极其快速的 virtualenv 和 pip 的替代品，并且具有更好的默认设置。使用 `uv venv` 创建虚拟环境，以及 `uv pip`
    安装包到其中。这两个命令默认使用 *.venv* 目录，就像 Unix 上的 `py` 工具一样。`--python` 选项允许你选择环境的 Python
    版本。
- en: In the final section of this chapter, you’ve learned how Python uses `sys.path`
    to locate modules when you import them, and how the module path is constructed
    during interpreter startup. You’ve also learned how module import works under
    the hood, using finders and loaders as well as the module cache. Interpreter discovery
    and module import are the key mechanisms that link Python programs to an environment
    at runtime.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，你已经了解了 Python 在导入模块时如何使用 `sys.path` 定位模块，以及解释器启动期间如何构建模块路径。你还学习了模块导入在幕后的工作原理，使用查找器和加载器以及模块缓存。解释器发现和模块导入是将
    Python 程序与运行时环境链接起来的关键机制。
- en: ^([1](ch02.html#id250-marker)) There’s also a *pythonw.exe* executable that
    runs programs without a console window, like GUI applications.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.html#id250-marker)) 还有一个 *pythonw.exe* 可执行文件，用于运行没有控制台窗口的程序，比如 GUI
    应用程序。
- en: ^([2](ch02.html#id251-marker)) A *shared library* is a file with executable
    code that multiple programs can use at runtime. The operating system only keeps
    a single copy of the code in memory.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch02.html#id251-marker)) *共享库* 是一个具有可执行代码的文件，多个程序可以在运行时使用。操作系统只在内存中保留代码的单一副本。
- en: ^([3](ch02.html#id252-marker)) Windows installations don’t include an entry-point
    script for `pydoc`—launch it using `py -m pydoc` instead.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch02.html#id252-marker)) Windows 安装不包括 `pydoc` 的入口脚本 —— 可以使用 `py -m pydoc`
    来启动它。
- en: ^([4](ch02.html#id253-marker)) Historically, macOS framework builds pioneered
    per-user installation before it became a standard in 2008.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch02.html#id253-marker)) 在 2008 年成为标准之前，macOS 框架构建在用户安装方面具有先驱性。
- en: '^([5](ch02.html#id255-marker)) This is a good thing: installing and uninstalling
    Python packages behind your package manager’s back introduces a real chance of
    breaking your system.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch02.html#id255-marker)) 这是一件好事：在你的包管理器背后安装和卸载 Python 包会带来真正破坏系统的风险。
- en: ^([6](ch02.html#id257-marker)) You could force the use of symbolic links on
    Windows via the `--symlinks` option—​but don’t. There are subtle differences in
    the way these work on Windows. For example, the File Explorer resolves the symbolic
    link before it launches Python, which prevents the interpreter from detecting
    the virtual environment.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch02.html#id257-marker)) 你可以通过 `--symlinks` 选项强制在 Windows 上使用符号链接 —— 但是不建议这样做。这些在
    Windows 上的工作方式有微妙的差异。例如，文件资源管理器在启动 Python 之前解析符号链接，这会阻止解释器检测到虚拟环境。
- en: ^([7](ch02.html#id258-marker)) Before Python 3.12, the `venv` module also pre-installed
    `setuptools` for the benefit of legacy packages that don’t declare it as a build
    dependency.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch02.html#id258-marker)) 在 Python 3.12 之前，`venv` 模块还预先安装了 `setuptools`，以满足不声明它为构建依赖项的旧版包的需求。
- en: ^([8](ch02.html#id259-marker)) Internally, pip queries the `sysconfig` module
    for an appropriate *installation scheme*—a Python environment layout. This module
    constructs the installation scheme using the build configuration of Python and
    the location of the interpreter in the filesystem.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch02.html#id259-marker)) 在内部，pip 查询 `sysconfig` 模块以获得适当的 *安装方案* —— Python
    环境布局。该模块使用 Python 的构建配置和解释器在文件系统中的位置构建安装方案。
- en: ^([9](ch02.html#id260-marker)) At the time of writing in 2024, pipx caches temporary
    environments for 14 days.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch02.html#id260-marker)) 在撰写本文时的 2024 年，pipx 会缓存临时环境 14 天。
- en: ^([10](ch02.html#id261-marker)) For modules located within a package, the `__path__`
    attribute of the package takes the place of `sys.path`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch02.html#id261-marker)) 对于位于包内的模块，包的 `__path__` 属性代替了 `sys.path`。
