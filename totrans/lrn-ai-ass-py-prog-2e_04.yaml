- en: '5 Reading Python code: Part 2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Repeating code the required number of times using loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using indentation to tell Python which code goes together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building dictionaries to store pairs of associated values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up files to read and process data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using modules to work in new domains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In chapter 4, we explored five Python features that you’re going to see all
    the time as you continue in your programming journey: functions, variables, conditionals
    (`if` statements), strings, and lists. You need to know those features to read
    code, and we explained why being able to read code is important whether or not
    we’re using Copilot.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll continue in this chapter with five more Python features, which will round
    out our top 10\. As in chapter 4, we’ll do this through a combination of our own
    explanations, explanations from Copilot, and experimenting at the Python prompt.
  prefs: []
  type: TYPE_NORMAL
- en: '5.1 Top 10 programming features you need to know: Part 2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section details the next five of the top 10 programming features you need
    to know. Let’s continue where we left off in the previous chapter with feature
    number 6: loops.'
  prefs: []
  type: TYPE_NORMAL
- en: '5.1.1 #6\. Loops'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A loop allows the computer to repeat the same block of code as many times as
    needed. If a single one of our top 10 programming features exemplifies why computers
    are so useful for helping us get work done, it’s this one. Without the ability
    to loop, our programs would generally execute in order, line by line. Sure, they
    could still call functions and use `if` statements to make decisions, but the
    amount of work a program does would be proportional to the amount of code we write.
    Not so with loops: a single loop can process thousands or millions of values with
    ease.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of loops: `for` loops and `while` loops. Generally speaking,
    we use a `for` loop whenever we know how many times we need the loop to run, and
    we use a `while` loop when we don’t. For example, in chapter 3, our `best_word`
    function (reproduced as listing 5.1) used a `for` loop because we know how many
    times we want the loop to run: once for each word in `word_list`! But in `get_strong_password`,
    which we’ll see again in listing 5.4, we used a `while` loop, because we have
    no idea how many bad passwords the user is going to type before they type a strong
    one. We’ll start with `for` loops and then move on to `while` loops.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.1 `best_word` function from chapter 3
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**#1 This is an example of a for loop.**  **A `for` loop allows us to access
    each value in a string or list. Let’s try it with a string first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '#1 This repeats the indented code one time for each character of string s.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Because “vacation” has eight letters, this code will run eight times.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we don’t need an assignment statement for `char`. That’s because
    it’s a special variable called a loop variable that’s automatically managed by
    the `for` loop. `char` stands for character, and it’s an extremely popular name
    that people use for the loop variable. The `char` variable automatically gets
    assigned each character of the string. When talking about a loop, we often use
    the word *iteration* to refer to the code that executes each time through the
    loop. Here, for example, we would say that on the first iteration,`char` refers
    to `v`; on the second iteration, it refers to `a`; and so on. Notice also, just
    like for functions and `if` statements, we have indentation for the code that
    makes up the loop. We have only one line of code in the body of this loop, but
    just like for functions and `if` statements, we could have more.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see an example of a `for` loop on a list this time (listing 5.2), demonstrating
    that we can process each value of a list like we process each value of a string.
    We’ll also throw two lines of code into the loop instead of just one, to demonstrate
    how that works too.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.2 Example using a `for` loop
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**#1 1st is a list, so this is a for loop on a list.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 This code runs on each iteration.**  **The code in listing 5.2 is just one
    way to loop through a list. The approach of `for` `animal` `in` `lst` assigns
    the variable `animal` to the next value in the list each time through the loop.
    Alternatively, you could use an index to access each element of the list. To do
    that, we need to learn about the built-in `range` function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `range` function gives you numbers within a range. We can provide a starting
    number and an ending number, and it will produce the range that goes from the
    starting number up to, but not including, the ending number. To see the numbers
    that `range` produces, we need to put the `list` function around it. Here’s an
    example of using `range`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Produces the range from 3 to 8 (not 3 to 9!)'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that it starts with the value `3` and includes all values between `3`
    and `8`. That is, it includes all numbers from the starting value `3` up to, but
    not including, the ending value `9`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how is `range` going to help us write a loop? Well, rather than hard-coding
    numbers like 3 and 9 in the range, we can include the length of a string or list,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Start at 0 and go up to, but not including, the length of 1st.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the range values here are 0, 1, 2, 3, which are the valid indices
    of our `lst` list! We can therefore use `range` to control a `for` loop, and that
    will give us access to each valid index from the string or list.
  prefs: []
  type: TYPE_NORMAL
- en: We can use `range` to perform the same task in listing 5.2\. See listing 5.3
    for the new code.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.3 Loop example using for `loop` and `range`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**#1 for loop using the range function'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Indexing into the list using the index variable**  **We’ve used a variable
    named `index` here, but you’ll also often see people use just `i` for simplicity.
    That variable will be given the value `0` for the first iteration of the loop,
    `1` for the second, `2` for the third, and `3` for the last iteration. It stops
    at `3` because the length of the list is 4, and `range` stops one before that.
    Using indexing into the list, the code grabs the first element, then the second,
    then the third, and then the fourth, using the increasing indices. We could have
    also written the `for` loop without the `0`; `range` will assume we want the values
    between `0` and the value provided, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '#1 With one argument, range assumes that we want to start at 0.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll stop here with `for` loops. But we’re not done with loops yet because
    there’s another type of loop that we need to talk about: the `while` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: We use a `while` loop when we don’t know how many times to loop. A nice example
    of this situation is in our `get_strong_password` function from chapter 3\. We’ve
    reproduced that code here as listing 5.4.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.4 `get_strong_password` function from chapter 3
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Keeps looping while the password isn’t strong'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have no idea how many passwords the user is going to type until they type
    a strong one. Will it be on the 1st try, 2nd try, or 50th try? Who knows. That’s
    why we need a `while` loop: it ensures that the user is asked again and again
    until they provide a strong password.'
  prefs: []
  type: TYPE_NORMAL
- en: To write a `while` loop, we follow `while` with a Boolean condition. If it’s
    `True`, Python runs one iteration of the loop. If, after that iteration, that
    Boolean condition is still `True`, then it runs another iteration. It keeps doing
    that until the condition is `False`, at which point the loop terminates.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have enough information to make sense of the code for our `get_strong_`
    `password` function. By looking at the code, we can see that it begins by using
    the `input` function to ask the user for a password. Then, there’s a `while` loop.
    This loop continues as long as the password isn’t a strong password. The Boolean
    condition `not` `is_strong_password(password)` is equivalent to writing it as
    `is_strong_password` `(password)` `==` `False`. To avoid an infinite loop and
    to ask the user to try again, we have another use of `input` inside of the loop.
    We need the call of `input` above the loop to get the first try from the user.
    Without that, the `password` variable wouldn’t exist, and the `while` loop line
    would give an error because it wouldn’t have a `password` value to pass to the
    `is_strong_password` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t forget that we can ask Copilot for an explanation of this code, using
    what we learned in chapter 4, section 4.2\. This is useful whenever you’re feeling
    that you aren’t quite understanding what the code is doing or how it works. Here’s
    the explanation we received from Copilot:'
  prefs: []
  type: TYPE_NORMAL
- en: This Python code defines a function named `get_strong_password`. The purpose
    of this function is to interactively prompt the user to enter a password and keep
    asking until the user provides a password that is considered strong. The criteria
    for what constitutes a strong password is not defined in this function but is
    determined by another function named `is_strong_password`.
  prefs: []
  type: TYPE_NORMAL
- en: The function begins by asking the user to enter a password using Python’s built-in
    `input` function. The entered password is then stored in the variable `password`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the function enters a `while` loop. The condition for this loop is `not`
    `is_strong_` `password(password)`. This means that the loop will continue to execute
    as long as the `is_strong_password` function returns `False` when called with
    the current password. In other words, the loop will keep running until the user
    enters a password that is considered strong.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the loop, the function again prompts the user to enter a password. The
    new password replaces the previous one stored in the `password` variable. If this
    new password is still not strong, the loop will continue to prompt the user.
  prefs: []
  type: TYPE_NORMAL
- en: Once the user enters a password that is considered strong (i.e., `is_strong_password`
    `(password)` returns `True`), the `while` loop condition becomes `False` and the
    loop ends. The function then returns the strong password entered by the user.
  prefs: []
  type: TYPE_NORMAL
- en: This function is a good example of using a `while` loop to repeatedly prompt
    the user for input until the input meets certain criteria. However, the actual
    criteria for a strong password are not defined in this function and would need
    to be implemented in the `is_strong_password` function.
  prefs: []
  type: TYPE_NORMAL
- en: This explanation is a very good description of the function and matches the
    description that we just gave! It contains useful general Python information as
    well, including a reminder in the final paragraph of why exactly we’re using a
    `while` loop. The explanation also mentions that we need the `is_strong_password`
    function to tell us whether a password is strong or not; we didn’t highlight that
    function, which is why Copilot is telling us that we need to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: Copilot explanations can be wrong
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We chose the previous Copilot explanation because it was the best answer from
    Copilot after we asked it to explain the code three times. One of the answers
    it gave us sounded quite plausible, until it started talking about functions that
    didn’t exist. We believe the explanations can be helpful as a learning aid if
    you run it multiple times and look for common ideas, but a principal goal of this
    chapter is to give you the tools you need to understand when it makes mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: We encourage you to use Copilot explanations going forward and, if you’re interested,
    ask Copilot to explain any code from prior chapters that you’re still curious
    about. Again, these explanations can be wrong, so you should ask Copilot for several
    explanations to limit your reliance on a single erroneous explanation.
  prefs: []
  type: TYPE_NORMAL
- en: As with anything related to AI coding assistants right now, they’re going to
    mess up. But we’ve given the explanation here because we see this Copilot feature
    as a potentially powerful teaching resource now and that will become even more
    true as Copilot improves.
  prefs: []
  type: TYPE_NORMAL
- en: We’re supposed to use a `while` loop in these kinds of situations where we don’t
    know how many iterations there will be. But we *can* use a`while` loop even when
    we know how many iterations there are. For example, we can use a `while` loop
    to process the characters in a string or the values in a list. We sometimes see
    Copilot do this in the code that it generates, even though a `for` loop would
    have been a better choice. For example, we can use a `while` loop to process the
    animals in our earlier `animals` list, as in the following listing. It’s more
    work, though!
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.5 Loop example using a `while` loop
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '#1 len tells us the length of the string and is the number of iterations we
    want.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 It’s a common human error to leave this out!'
  prefs: []
  type: TYPE_NORMAL
- en: Without the `index` `+=` `1`, we would never increase the index through the
    string, and we’d print out the information for the first value over and over.
    That’s called an *infinite loop*. If you think back to how we wrote `for` loops,
    you’ll find that we didn’t have to manually increase any index variables. For
    such reasons, many programmers prefer to use `for` loops when they can. We don’t
    have to manually keep track of any index in a `for` loop, so we automatically
    avoid certain kinds of indexing problems and infinite loops.
  prefs: []
  type: TYPE_NORMAL
- en: '5.1.2 #7\. Indentation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Indentation is critical in Python code, because Python uses it to determine
    which lines of code go together. That’s why, for example, we always indent all
    the lines of code inside a function, the various portions of an `if` statement,
    and the code for a `for` or `while` loop. It’s not just nice formatting: if we
    get the indentation wrong, then we get the code wrong. For example, let’s say
    that we want to ask the user for the current hour and then output some text based
    on whether it’s morning, afternoon, or evening:'
  prefs: []
  type: TYPE_NORMAL
- en: If it’s morning, we want to output “Good morning!” and “Have a nice day.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it’s afternoon, we want to output “Good afternoon!”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it’s evening, we want to output “Good evening!” and “Have a good night.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following code we’ve written and try to spot the problem
    with the indentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '#1 This line is not indented.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is the last line: it’s not indented, but it should be! Because
    it’s not indented, we’ll output `Have` `a` `good` `night.` regardless of which
    hour the user types in. We need to indent it so that it’s part of the `else` portion
    of the `if` statement, ensuring that it only executes when it’s evening.'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we write code, we need to use multiple levels of indentation to express
    which pieces of code are associated with functions, `if` statements, loops, and
    so on. For example, when we write a function header, we need to indent all the
    code associated with that function below the function header. Some languages use
    brackets (e.g., {}) to show this, but Python just indents. If you’re already in
    the body of a function (one indent) and write a loop, then you’ll have to indent
    again (two indents) for the body of the loop, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: Looking back at our functions from chapter 3, we can see this in action. For
    example, in our `larger` function (reprinted as listing 5.6), the whole body of
    the function is indented, but there’s further indentation on the `if` portion
    and the `else` portion of the `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.6 Function to determine the larger of two values
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '#1 This shows a single indent for the body of the function.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 This shows a double indent for the body of the function and the body of
    the if statement.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 This shows a single indent for the body of the function.'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 This shows a double indent for the body of the function and the body of
    the else statement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, consider our `get_strong_password` function that we looked at in listing
    5.4 earlier: as usual, everything in the function is indented, but there’s further
    indentation for the body of the `while` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: There are even more levels of indentation in the first version of our `num_points`
    function (reproduced here from chapter 3 as listing 5.7). That’s because, inside
    of the `for` loop through each character of the word, we have an `if` statement.
    Each piece of the `if` statement, as we’ve learned, needs to be indented, leading
    to the extra level of indentation.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.7 `num_points` function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '#1 This is indented to be inside the function.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 This is indented again to be inside the for loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 This is indented yet again to be inside the if statement.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s additional indentation in `is_strong_password` too (reproduced from
    chapter 3 as listing 5.8), but that’s only to spread out one super-long line of
    code across multiple lines. Notice that the lines end with `\`, which is the character
    that allows us to continue a line of code on the next line.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.8 `is_strong_password` function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '#1 The line ends with a backslash to continue the statement.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 The indent isn’t required but is useful for visually laying out the single
    return statement.'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, there’s some further indentation in our second version of `num_points`
    (reproduced from chapter 3 as listing 5.9), but that’s just to spread the dictionary
    out over multiple lines to make it more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.9 `num_points` alternative solution
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '#1 We’re allowed to write a dictionary value over multiple lines.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 The indent isn’t required but is useful for visually laying out the dictionary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Indentation makes a huge difference on what our programs ultimately do. For
    example, let’s compare putting two consecutive loops versus nesting one in the
    other using indentation. Here are two loops in a row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '#1 This is the first loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 This is the second loop (happens after the first loop).'
  prefs: []
  type: TYPE_NORMAL
- en: 'That caused us to get the same output twice because we looped two separate
    times through the countries list. Now, if instead we nest the loops, this happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '#1 This is the first loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 This is the nested loop inside of the first loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 print is nested in the second loop, which is nested in the first loop.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve used different variable names, `country1` and `country2`, for each `for`
    loop, so that we can refer to both. On the first iteration of the `country1` loop,
    `country1` refers to `Canada`. On the first iteration of the `country2` loop,
    `country2` refers to `Canada` as well. That’s why the first line of output is
    `Canada` `Canada`. Did you expect the next line of output after that to be `USA`
    `USA`? That isn’t what happens! Instead, the `country2` loop moves on to its next
    iteration, but the `country1` loop doesn’t move yet. The `country1` loop only
    moves ahead when the `country2` loop is complete. That’s why we get `Canada` `USA`
    and `Canada` `Japan` before the `country1` loop finally moves on to its second
    iteration. When one loop is inside of another loop, this is called *nested loops.*
    In general, when there’s nesting, the inner loop (`for` `country2` `in` `countries`)
    will complete all of its steps before the outer loop (`for` `country1` `in` `countries`)
    moves on to its next step, which, in turn, will restart the inner loop.
  prefs: []
  type: TYPE_NORMAL
- en: If you see a loop nested inside another loop, chances are good that the loops
    are being used to process two-dimensional data. Two-dimensional data is organized
    into rows and columns, of the kind you might see in a table (e.g., table 5.1).
    This kind of data is really common in computing because it includes basic spreadsheet
    data such as CSV files, images such as photos or a single frame of video, or the
    computer screen.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, we can store two-dimensional data using a list where the values themselves
    are other lists. Each sublist in the overall list is one row of data, and each
    row has a value for each column. For example, say we had some data about the figure
    skating medals won at the 2018 Winter Olympics, as shown in table 5.1.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.1 Medals in the 2018 Winter Olympics
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Nation | Gold | Silver | Bronze |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Canada  | 2  | 0  | 2  |'
  prefs: []
  type: TYPE_TB
- en: '| OAR  | 1  | 2  | 0  |'
  prefs: []
  type: TYPE_TB
- en: '| Japan  | 1  | 1  | 0  |'
  prefs: []
  type: TYPE_TB
- en: '| China  | 0  | 1  | 0  |'
  prefs: []
  type: TYPE_TB
- en: '| Germany  | 1  | 0  | 0  |'
  prefs: []
  type: TYPE_TB
- en: 'We could store this as a list, with one country per row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that our list of lists is just storing the numeric values, and we can
    find a value in the list of lists by referring to its row and column (e.g., Japan’s
    gold medal corresponds to the row at index 2 and the column at index 0). We can
    use an index to get a complete row of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '****#1 This is row 0 (first row).'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 This is row 1 (second row).'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 This is the last row.****  ****If we do a `for` loop on this list, we get
    each complete row, one row at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '#1 The for loop gives us one value of the list at a time (i.e., one sublist
    at a time).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want just a specific value from the medals list (not a whole row), we
    have to index twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '#1 This is row 0, column 0.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 This is row 0, column 1.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 This is row 1, column 0.'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to loop through each value individually. To do that, we can
    use nested `for` loops. To help us keep track of exactly where we are, we’ll use
    `range` `for` loops so that we can print out the current row and column numbers
    in addition to the value stored there.
  prefs: []
  type: TYPE_NORMAL
- en: The outer loop will go through the rows, so we need to control it using `range`
    `(len(medals))`. The inner loop will go through the columns. How many columns
    are there? Well, the number of columns is the number of values in one of the rows,
    so we can use `range(len(medals[0]))` to control this loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each line of output will provide three numbers: the row coordinate, the column
    coordinate, and the value (number of medals) at that row and column. Here’s the
    code and output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Loops through the rows'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Loops through the columns for the current row'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the row stays constant for the first three lines of output, during
    which the column varies from 0 to 2\. That’s how we work our way through the first
    row. Only then does the row increase to 1, at which point we complete the work
    for columns 0 to 2 on this new row.
  prefs: []
  type: TYPE_NORMAL
- en: Nested loops give us a systematic way to loop through each value in a two-dimensional
    list. You’ll see them frequently when dealing with two-dimensional data in general,
    such as images, board games, and spreadsheets.
  prefs: []
  type: TYPE_NORMAL
- en: '5.1.3 #8\. Dictionaries'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that each value in Python has a specific type. There are a lot of different
    types because there are many kinds of values that we might want to use! We’ve
    talked about using numbers to work with numeric values, Booleans to work with
    `True`/`False` values, strings to work with text, and lists to work with a sequence
    of other values such as numbers or strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one more Python type that shows up often, and it’s called a *dictionary.*
    When we talk about a dictionary in Python, we don’t mean a list of words and their
    definitions. In Python, a dictionary is a useful way of storing data whenever
    you need to keep track of associations between data. For example, imagine that
    you wanted to know which words are used most often in your favorite book. You
    could use a dictionary to map each word to the number of times it’s used. That
    dictionary would probably be huge, but a small version of such a dictionary might
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Each entry in the dictionary maps a word to its frequency. For example, we can
    tell from this dictionary that the word *DNA* shows up 11 times and that the word
    *Taxxon* shows up 13 times. The words here (*DNA*, *acquire*, *Taxxon*, etc.)
    are referred to as *keys,* and the frequencies (11, 11, 13, etc.) are referred
    to as *values**.* So, a dictionary maps each key to its value. We’re not allowed
    to have duplicate keys, but as shown here with the two `11` values, having duplicate
    values is no problem.
  prefs: []
  type: TYPE_NORMAL
- en: We saw a dictionary in chapter 2 (listing 2.1) that stored each quarterback’s
    name and their associated number of passing yards. In chapter 3, we saw a dictionary
    again in our second solution for `num_points` (reproduced earlier in listing 5.9).
    There, the dictionary mapped each letter to the number of points awarded for using
    that letter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like for strings and lists, dictionaries have methods that you can use
    to interact with them. Here are some methods operating on our `freq` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '**#1 Gets all the keys'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Gets all the values'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Gets rid of key and associated value**  **You can also use the index notation
    to access the value for a given key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Gets values associated with the key “DNA”'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionaries, like lists, are mutable. This means that we can change the keys
    and values in a dictionary, which is useful for modeling data that changes over
    time. We can use indexing to change a value. The value associated with `''morph''`
    is currently `41`. Let’s change it to `6`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Changes value associated with key “morph” to 6'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `freq` dictionary allows us to start from whatever word we want and find
    its frequency. More generally, a dictionary allows us to go from *key to value.*
    However, it doesn’t allow us to easily go in the opposite direction, from value
    to key. If we wanted to do that, we’d need to produce the opposite dictionary—for
    example, one whose keys are frequencies and whose values are lists of words with
    those frequencies. That would enable us to answer questions such as the following:
    which words have a frequency of exactly 5? Which words have the minimum or maximum
    frequency of all?'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with strings and lists, we can use a loop to process the information in
    a dictionary as well. A `for` loop gives us the dictionary keys, and we can use
    indexing to get the associated value for each key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*#1 Loops through each key in the freq dictionary'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Uses the key (word) and associated value (freq[word])*  *### 5.1.4 #9\.
    Files'
  prefs: []
  type: TYPE_NORMAL
- en: It’s often the case that we’ll want to work with datasets that exist in files.
    For example, in chapter 2, we worked with a file of NFL stats to determine the
    most effective quarterbacks. Using files is common for other data science tasks
    as well. For example, if you’re plotting information about earthquakes around
    the world or determining whether two books are written by the same author, you’ll
    need to work with those datasets, and typically those datasets will be stored
    in files.
  prefs: []
  type: TYPE_NORMAL
- en: In chapter 2, we worked with a file called nfl_offensive_stats.csv. Make sure
    that this file is in your current program directory because we’ll use that file
    now to further understand some of the code we used in chapter 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in working with data from a file is to use Python’s `open` function
    to open the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll sometimes see Copilot add an `r` as a second argument here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: But we don’t need the `r`; the `r` just means that we want to read from the
    file, but that’s the default anyway if we don’t specify it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve used an assignment statement to assign that open file to a variable named
    `nfl_file`. Now, we can use `nfl_file` to access the contents of the file. An
    open file is a Python type, just like numbers and strings and all of the other
    types you’ve seen to this point. As such, there are methods that we can call to
    interact with the file. One method is `readline`, which gives us the next line
    of the file as a string. We’ll use it now to get the first line of our open file,
    but don’t worry about the line itself because it’s super long with tons of information
    about columns we won’t end up using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Reads the line from the file'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s not easy to pull individual values out of a messy string like that. So,
    one of the first things we tend to do with such a line is split it up into its
    individual column data. We can do that using the string `split` method. That method
    takes a separator as an argument and splits the string into a list by using that
    separator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Splits the string using a comma (,) as a separator'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can look at individual column names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '#1 The space at the end of the word is in the original dataset, but no other
    column headers have a space.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That first line of the file that we’re looking at isn’t a real data line—it’s
    just the header that tells us the name of each column. The next time we do `readline`,
    we get the first real line of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving one line at a time like this is fine for exploring what’s in a file,
    but eventually, we’ll probably want to process the whole thing. To do so, we can
    use a `for` loop on the file. It’ll give us back one line on each iteration, which
    we can process in any way we like. Once we’re finished with a file, we should
    call `close` on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: After closing, we aren’t allowed to use the file anymore. Now that we’ve discussed
    how to read, process, and close a file, let’s see a full example. In listing 5.10,
    we provide a new version of our program from chapter 2 that sorts quarterbacks
    by their total passing yards. In addition to showcasing files, we’re also using
    many of the Python features that we’ve seen in chapter 4 and the current chapter,
    including conditionals, strings, lists, loops, and dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.10 Alternative NFL statistics code without the csv module
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '#1 This dictionary maps quarterback names to their passing yards.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Loops through each line of the file'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Focuses only on the quarterbacks'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Quarterback is already in our dictionary.'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Add to quarterback’s total; int converts string like ''203'' to integer.'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Quarterback isn’t yet in our dictionary.'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Sets initial quarterback’s total'
  prefs: []
  type: TYPE_NORMAL
- en: '#8 Loops through quarterbacks from highest to lowest passing yards'
  prefs: []
  type: TYPE_NORMAL
- en: 'That loop at the bottom, `for` `player` `in` `sorted(passing_yards,` `key=passing_yards
    .get,` `reverse=True):`, has a lot going on. We explained this line in the annotations
    as looping through the quarterbacks from highest to lowest. The `reverse=True`
    makes us sort from highest to lowest rather than the default of lowest to highest.
    The `key=passing_yards.get` focuses the sort on the number of passing yards (rather
    than, e.g., the player’s names). If you’d like to break down this line of code
    further, feel free to ask Copilot for further explanation. This highlights the
    balancing act that we’re trying to maintain here: to know enough to be able to
    get the gist of code without necessarily needing to understand every nuance.'
  prefs: []
  type: TYPE_NORMAL
- en: This program works just fine; if you run it, you would see the same output as
    if you ran the code from chapter 2\. Sometimes, though, it’s possible to write
    a program more easily using modules (we cover modules in more depth in the next
    section), and that’s what the program from chapter 2 did. Because CSV files are
    so common, Python comes with a module to make it easier to process them. In chapter
    2, the solution that we were given used the csv module. So, let’s discuss the
    main differences between our code in listing 5.10 that doesn’t use the module
    and our code from chapter 2, reprinted here in the following listing (our prompts
    given to Copilot aren’t shown).
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5.11 NFL statistics code using the csv module
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Shows the alternate syntax for opening a file'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Uses a special csv module; reads all data from the file'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Loops through each line of data'
  prefs: []
  type: TYPE_NORMAL
- en: First, listing 5.11 uses the csv module to make dealing with CSV files easier.
    The csv module knows how to manipulate CSV files, so, for example, we don’t have
    to worry about breaking a line into its columns. Second, listing 5.11 uses the
    `with` keyword, which results in the file automatically being closed when the
    program is done with it. Third, listing 5.11 reads the entire file first before
    doing any processing. By contrast, in listing 5.10, we read and process each line
    as soon as we read it.
  prefs: []
  type: TYPE_NORMAL
- en: More than one way to solve a programming problem
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are always many different programs that can be written to solve the same
    task. Some may be easier to read than others. The most important criterion for
    code is that it does the correct thing. After that, we care most about readability
    and efficiency. So, if you find yourself struggling to understand how some code
    works, it may be worth some time looking at other code from Copilot in case there’s
    a simpler or more understandable solution available there.
  prefs: []
  type: TYPE_NORMAL
- en: Files are used commonly in computing tasks because they are a common source
    of data to be processed. This includes CSV files like the one from this section,
    log files that keep track of events on computers or websites, and files that store
    data for graphics you might see in video games, among others. Because files are
    so commonly used, it’s no surprise there are many modules that help us read various
    file formats. That leads us to the larger topic of modules.
  prefs: []
  type: TYPE_NORMAL
- en: '5.1.5 #10\. Modules'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: People use Python to make all kinds of things—games, websites, and apps for
    analyzing data, automating repetitive tasks, controlling robots, you name it.
    You might be wondering how Python can possibly let you create so many different
    types of programs. Surely, the creators of Python couldn’t have anticipated or
    created all the needed support!
  prefs: []
  type: TYPE_NORMAL
- en: The truth is that, by default, your Python program has access only to some core
    Python features (such as those we’ve showed you in the previous and current chapter).
    To get any more than that, we need to use modules. And, to use a module, you need
    to import it.
  prefs: []
  type: TYPE_NORMAL
- en: Modules in Python
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *module* is a collection of code designed for a specific purpose. Recall
    that we don’t need to know how a function works to use it. It’s the same with
    modules: we don’t need to know how modules work to be able to use them, much as
    we don’t need to know how a light switch works internally to use it. As users
    of modules, we just need to know what a module will help us do and how to write
    the code to correctly call its functions. Of course, Copilot can help us write
    that kind of code.'
  prefs: []
  type: TYPE_NORMAL
- en: Some modules come with Python when you install it, but we still need to import
    them. Other modules we first have to install before we can import them. Trust
    us, if there’s a specific kind of task you want to do with Python, someone’s probably
    already written a module to help you out.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering how to determine which Python modules you should use.
    How do you know which ones exist? A simple chat with Copilot or Google search
    is often helpful. For example, if we google “Python module to create a zip file,”
    the first result tells us that the module we need is part of the Python standard
    library, which means that it comes with Python. If we google “Python module for
    visualization,” we learn about modules named matplotlib, plotly, seaborn, and
    more. Searching for each of these should lead you to galleries of visualizations
    showing you their capabilities and what each is typically used for. Most modules
    are free to download and use, although your search results can help you confirm
    whether a module is free and its specific usage license. We’re going to hold off
    on installing and using newly installed modules until chapter 9, but, at that
    time, you’ll see this process of finding, installing, and using relevant modules
    to help us complete our tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.2 has a list of some of the commonly used Python modules and whether
    they are built-in or not. If a module is built-in, you can import the module and
    start using it right away; if not, you need to install it first.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.2 Summary of commonly used Python modules
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Module | Built-In | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| csv  | Yes  | Aids in the reading, writing, and analysis of CSV files  |'
  prefs: []
  type: TYPE_TB
- en: '| zipfile  | Yes  | Aids in the creation and extraction of compressed zip archive
    files  |'
  prefs: []
  type: TYPE_TB
- en: '| matplotlib  | No  | Graphics library for plotting that serves as the basis
    of other graphics libraries and can offer high levels of customization  |'
  prefs: []
  type: TYPE_TB
- en: '| plotly  | No  | A graphics library used for creating interactive plots for
    the web  |'
  prefs: []
  type: TYPE_TB
- en: '| seaborn  | No  | A graphics library built on top of matplotlib that aids
    in creating high- quality plots more easily than matplotlib  |'
  prefs: []
  type: TYPE_TB
- en: '| pandas  | No  | A data processing library that specializes in data frames,
    which are analogous to spreadsheets  |'
  prefs: []
  type: TYPE_TB
- en: '| scikit-learn  | No  | Contains basic tools for machine learning (i.e., helping
    to learn from data and make predictions)  |'
  prefs: []
  type: TYPE_TB
- en: '| numpy  | No  | Offers highly efficient data processing  |'
  prefs: []
  type: TYPE_TB
- en: '| pygame  | No  | A game programming library that helps to build interactive,
    graphical games in Python  |'
  prefs: []
  type: TYPE_TB
- en: '| django  | No  | Web development library that aids in designing websites and
    web applications  |'
  prefs: []
  type: TYPE_TB
- en: In chapter 2, our code used the csv module that comes with Python. Let’s continue
    here by learning about a different module that comes with Python.
  prefs: []
  type: TYPE_NORMAL
- en: When people want to organize their files, perhaps prior to backing them up or
    uploading them, they often archive them first into a .zip file. Then they can
    pass around that single .zip file, rather than potentially hundreds or thousands
    of individual files. Python comes with a module called zipfile that can help you
    create a .zip file.
  prefs: []
  type: TYPE_NORMAL
- en: To try this, create a few files in your programming directory, and make them
    all end with .csv. You could start with your nfl_offensive_stats.csv file and
    then add a few more. For example, you could add one called actors.csv with the
    names of a few actors and their ages, such as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'and you could add one called chores.csv with a list of chores and whether you’ve
    finished each one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The contents don’t matter as long as you have a few .csv files to test with.
    Now we can use the zipfile module to add them all to a new .zip file!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '**#1 Creates the new .zip file'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Adds the first file'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Adds the second file'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Adds the third file**  **If you run that code, you’ll find a new file called
    my_stuff.zip that contains your three .csv files. Working with .zip files directly
    used to be a very specialized, error-prone task with other earlier programming
    languages, but that’s not so with Python. Python comes with modules that are helpful
    for data science, making games, dealing with various file formats, and so on,
    but again, Python can’t come with everything. When we need more, we turn to downloadable
    modules as we’ll see in chapter 9.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we introduced you to the second half of our top 10 Python features,
    as summarized in table 5.3\. We’ve covered a lot about reading code in the previous
    chapter and this chapter. Although we haven’t covered everything you might see
    Copilot produce, you’re in a good position to spot-check Copilot code to determine
    whether it’s given a good attempt at producing the code you requested. We also
    showed more examples of using the Copilot explanation tool to help you understand
    new code. In the next chapters, we’ll see how to test the code from Copilot to
    determine whether it’s correct, and what you can do when it’s not.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5.3 Summary of Python code features from this chapter
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '| Code Element | Example | Brief Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Loops  | `for` loop: `for country in countries: print(country)` `while` loop:
    `index = 0 while index < 4: print(index) index = index + 1`  | Loops allow us
    to run the same code as many times as needed. We use a `for` loop when we know
    how many iterations there will be (e.g., number of characters in a string) and
    a `while` loop when we don’t (e.g., asking the user for a strong password).  |'
  prefs: []
  type: TYPE_TB
- en: '| Indentation  | `for country in countries: print(country)`  | Indentation
    tells Python when a piece of code belongs as part of another body of code (e.g.,
    that the `print` call is within the `for` loop).  |'
  prefs: []
  type: TYPE_TB
- en: '| Dictionaries  | `points = {''a'': 1, ''b'': 3}`  | Dictionaries allow us
    to associate a key with a value. For example, the key `''a''` is associated with
    the value `1`.  |'
  prefs: []
  type: TYPE_TB
- en: '| Files  | `file = open(''chores.csv'') first_line = file.readline()`  | Files
    contain data and are stored on your computer. Python can be used to open many
    types of files and read their contents, allowing you to process the data in the
    file.  |'
  prefs: []
  type: TYPE_TB
- en: '| Modules  | `import` `csv`  | Modules are already-existing libraries that
    provide additional functionality. Commonly used modules include csv, numpy, matplotlib,
    pandas, and scikit-learn. Some modules come with the standard Python distribution;
    others need to be installed separately.  |'
  prefs: []
  type: TYPE_TB
- en: 5.2 Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall the `for` loop code we looked at in listing 5.3 to print animals in a
    list. What does this modified code do differently compared to the original example
    in the chapter? Specifically, what additional output does it produce?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 2\. Consider the following `while` loop code that seeks to repeat what we did
    using a `for` loop in listing 5.3\. When we run the code, we notice that it runs
    indefinitely. Can you identify and fix the error that would cause it to run indefinitely?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 3\. Arrange the following lines of code to create a `while` loop that prints
    each number in the list until it encounters the number 7\. Be careful about indentation!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 4\. Think of a real-world scenario where a `while` loop would be more appropriate
    than a `for` loop. Describe the scenario and explain why a `while` loop is the
    better choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 5\. Modify the `get_strong_password` function (or the `is_strong_password` function
    that it calls) to provide specific feedback on why the entered password isn’t
    strong enough. For instance, if the password doesn’t have an uppercase character,
    print “Password must include an uppercase character,” and if it doesn’t contain
    a digit, print “Password must contain at least one digit.”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 6\. Given the following `print_quarterbacks` function, can you rewrite it to
    use the “with” statement to open and close the file? Why is it important to close
    the file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '7\. In this exercise, we’ll further practice working with the zipfile module
    to create a .zip file containing multiple CSV files. Follow these steps to complete
    the task and answer the questions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, create three CSV files in your current directory:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: nfl_offensive_stats.csv (you should already have this file)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'actors.csv with the following content:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'chores.csv with the following content:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Using Copilot (don’t type the code directly as we did in the chapter), write
    a Python script that uses the zipfile module to add these three CSV files to a
    .zip file named my_stuff.zip.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some of the other functions provided by the zipfile module that Copilot
    suggests? How can they be useful?
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A loop is used to repeat code as many times as needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use a `for` loop when we know how many iterations the loop will do; we use
    a `while` loop when we don’t know how many iterations a loop will do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python uses indentation to determine which lines of code go together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dictionary is a mapping from keys (e.g., words in a book) to values (e.g.,
    their frequencies).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to open a file before we can read from it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a file is open, we can use methods (e.g., readline) or a loop to read its
    lines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some modules, such as csv and zipfile, come with Python and can be used by importing
    them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other modules, such as matplotlib, need to be installed first before they can
    be imported and used.***************
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
