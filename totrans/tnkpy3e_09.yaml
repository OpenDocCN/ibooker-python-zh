- en: 7\. Iteration and Search#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://allendowney.github.io/ThinkPython/chap07.html](https://allendowney.github.io/ThinkPython/chap07.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In 1939 Ernest Vincent Wright published a 50,000 word novel called *Gadsby*
    that does not contain the letter “e”. Since “e” is the most common letter in English,
    writing even a few words without using it is difficult. To get a sense of how
    difficult, in this chapter we’ll compute the fraction of English words have at
    least one “e”.
  prefs: []
  type: TYPE_NORMAL
- en: For that, we’ll use `for` statements to loop through the letters in a string
    and the words in a file, and we’ll update variables in a loop to count the number
    of words that contain an “e”. We’ll use the `in` operator to check whether a letter
    appears in a word, and you’ll learn a programming pattern called a “linear search”.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, you’ll use these tools to solve a word puzzle called “Spelling
    Bee”.
  prefs: []
  type: TYPE_NORMAL
- en: 7.1\. Loops and strings[#](#loops-and-strings "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Chapter 3 we saw a `for` loop that uses the `range` function to display a
    sequence of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This version uses the keyword argument `end` so the `print` function puts a
    space after each number rather than a newline.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use a `for` loop to display the letters in a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice that I changed the name of the variable from `i` to `letter`, which provides
    more information about the value it refers to. The variable defined in a `for`
    loop is called the **loop variable**.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can loop through the letters in a word, we can check whether it
    contains the letter “e”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Before we go on, let’s encapsulate that loop in a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: And let’s make it a pure function that return `True` if the word contains an
    “e” and `False` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can generalize it to take the word as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can test it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 7.2\. Reading the word list[#](#reading-the-word-list "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To see how many words contain an “e”, we’ll need a word list. The one we’ll
    use is a list of about 114,000 official crosswords; that is, words that are considered
    valid in crossword puzzles and other word games.
  prefs: []
  type: TYPE_NORMAL
- en: The word list is in a file called `words.txt`, which is downloaded in the notebook
    for this chapter. To read it, we’ll use the built-in function `open`, which takes
    the name of the file as a parameter and returns a **file object** we can use to
    read the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The file object provides a function called `readline`, which reads characters
    from the file until it gets to a newline and returns the result as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the syntax for calling `readline` is different from functions we’ve
    seen so far. That’s because it is a **method**, which is a function associated
    with an object. In this case `readline` is associated with the file object, so
    we call it using the name of the object, the dot operator, and the name of the
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The first word in the list is “aa”, which is a kind of lava. The sequence `\n`
    represents the newline character that separates this word from the next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file object keeps track of where it is in the file, so if you call `readline`
    again, you get the next word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To remove the newline from the end of the word, we can use `strip`, which is
    a method associated with strings, so we can call it like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`strip` removes whitespace characters – including spaces, tabs, and newlines
    – from the beginning and end of the string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use a file object as part of a `for` loop. This program reads
    `words.txt` and prints each word, one per line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now that we can read the word list, the next step is to count them. For that,
    we will need the ability to update variables.
  prefs: []
  type: TYPE_NORMAL
- en: 7.3\. Updating variables[#](#updating-variables "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may have discovered, it is legal to make more than one assignment to
    the same variable. A new assignment makes an existing variable refer to a new
    value (and stop referring to the old value).
  prefs: []
  type: TYPE_NORMAL
- en: For example, here is an initial assignment that creates a variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: And here is an assignment that changes the value of a variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The following figure shows what these assignments looks like in a state diagram.
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/5f2c6acf2632453c84d4a58782db35679dedcd804dd1683fca0560ccb15d92ea.png](../Images/20c498abf4d329b6904ae1a2d4c15efa.png)'
  prefs: []
  type: TYPE_IMG
- en: The dotted arrow indicates that `x` no longer refers to `5`. The solid arrow
    indicates that it now refers to `7`.
  prefs: []
  type: TYPE_NORMAL
- en: A common kind of assignment is an **update**, where the new value of the variable
    depends on the old.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This statement means “get the current value of `x`, add one, and assign the
    result back to `x`.”
  prefs: []
  type: TYPE_NORMAL
- en: If you try to update a variable that doesn’t exist, you get an error, because
    Python evaluates the expression on the right before it assigns a value to the
    variable on the left.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Before you can update a variable, you have to **initialize** it, usually with
    a simple assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Increasing the value of a variable is called an **increment**; decreasing the
    value is called a **decrement**. Because these operations are so common, Python
    provides **augmented assignment operators** that update a variable more concisely.
    For example, the `+=` operator increments a variable by the given amount.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: There are augmented assignment operators for the other arithmetic operators,
    including `-=` and `*=`.
  prefs: []
  type: TYPE_NORMAL
- en: 7.4\. Looping and counting[#](#looping-and-counting "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following program counts the number of words in the word list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: It starts by initializing `total` to `0`. Each time through the loop, it increments
    `total` by `1`. So when the loop exits, `total` refers to the total number of
    words.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: A variable like this, used to count the number of times something happens, is
    called a **counter**.
  prefs: []
  type: TYPE_NORMAL
- en: We can add a second counter to the program to keep track of the number of words
    that contain an “e”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Let’s see how many words contain an “e”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As a percentage of `total`, about two-thirds of the words use the letter “e”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: So you can understand why it’s difficult to craft a book without using any such
    words.
  prefs: []
  type: TYPE_NORMAL
- en: 7.5\. The in operator[#](#the-in-operator "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The version of `has_e` we wrote in this chapter is more complicated than it
    needs to be. Python provides an operator, `in`, that checks whether a character
    appears in a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: So we can rewrite `has_e` like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: And because the conditional of the `if` statement has a boolean value, we can
    eliminate the `if` statement and return the boolean directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We can simplify this function even more using the method `lower`, which converts
    the letters in a string to lowercase. Here’s an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '`lower` makes a new string – it does not modify the existing string – so the
    value of `word` is unchanged.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Here’s how we can use `lower` in `has_e`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 7.6\. Search[#](#search "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Based on this simpler version of `has_e`, let’s write a more general function
    called `uses_any` that takes a second parameter that is a string of letters. It
    returns `True` if the word uses any of the letters and `False` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Here’s an example where the result is `True`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: And another where it is `False`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '`uses_any` converts `word` and `letters` to lowercase, so it works with any
    combination of cases.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The structure of `uses_any` is similar to `has_e`. It loops through the letters
    in `word` and checks them one at a time. If it finds one that appears in `letters`,
    it returns `True` immediately. If it gets all the way through the loop without
    finding any, it returns `False`.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is called a **linear search**. In the exercises at the end of this
    chapter, you’ll write more functions that use this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 7.7\. Doctest[#](#doctest "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 4](chap04.html#section-docstring) we used a docstring to document
    a function – that is, to explain what it does. It is also possible to use a docstring
    to *test* a function. Here’s a version of `uses_any` with a docstring that includes
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Each test begins with `>>>`, which is used as a prompt in some Python environments
    to indicate where the user can type code. In a doctest, the prompt is followed
    by an expression, usually a function call. The following line indicates the value
    the expression should have if the function works correctly.
  prefs: []
  type: TYPE_NORMAL
- en: In the first example, `'banana'` uses `'a'`, so the result should be `True`.
    In the second example, `'apple'` does not use any of `'xyz'`, so the result should
    be `False`.
  prefs: []
  type: TYPE_NORMAL
- en: To run these tests, we have to import the `doctest` module and run a function
    called `run_docstring_examples`. To make this function easier to use, I wrote
    the following function, which takes a function object as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We haven’t learned about `globals` and `__name__` yet – you can ignore them.
    Now we can test `uses_any` like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '`run_doctests` finds the expressions in the docstring and evaluates them. If
    the result is the expected value, the test **passes**. Otherwise it **fails**.'
  prefs: []
  type: TYPE_NORMAL
- en: If all tests pass, `run_doctests` displays no output – in that case, no news
    is good news. To see what happens when a test fails, here’s an incorrect version
    of `uses_any`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: And here’s what happens when we test it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The output includes the example that failed, the value the function was expected
    to produce, and the value the function actually produced.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not sure why this test failed, you’ll have a chance to debug it as
    an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 7.8\. Glossary[#](#glossary "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**loop variable:** A variable defined in the header of a `for` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '**file object:** An object that represents an open file and keeps track of
    which parts of the file have been read or written.'
  prefs: []
  type: TYPE_NORMAL
- en: '**method:** A function that is associated with an object and called using the
    dot operator.'
  prefs: []
  type: TYPE_NORMAL
- en: '**update:** An assignment statement that give a new value to a variable that
    already exists, rather than creating a new variables.'
  prefs: []
  type: TYPE_NORMAL
- en: '**initialize:** Create a new variable and give it a value.'
  prefs: []
  type: TYPE_NORMAL
- en: '**increment:** Increase the value of a variable.'
  prefs: []
  type: TYPE_NORMAL
- en: '**decrement:** Decrease the value of a variable.'
  prefs: []
  type: TYPE_NORMAL
- en: '**counter:** A variable used to count something, usually initialized to zero
    and then incremented.'
  prefs: []
  type: TYPE_NORMAL
- en: '**linear search:** A computational pattern that searches through a sequence
    of elements and stops when it finds what it is looking for.'
  prefs: []
  type: TYPE_NORMAL
- en: '**pass:** If a test runs and the result is as expected, the test passes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**fail:** If a test runs and the result is not as expected, the test fails.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.9\. Exercises[#](#exercises "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 7.9.1\. Ask a virtual assistant[#](#ask-a-virtual-assistant "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In `uses_any`, you might have noticed that the first `return` statement is inside
    the loop and the second is outside.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: When people first write functions like this, it is a common error to put both
    `return` statements inside the loop, like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Ask a virtual assistant what’s wrong with this version.
  prefs: []
  type: TYPE_NORMAL
- en: 7.9.2\. Exercise[#](#exercise "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Write a function named `uses_none` that takes a word and a string of forbidden
    letters, and returns `True` if the word does not use any of the forbidden letters.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an outline of the function that includes two doctests. Fill in the function
    so it passes these tests, and add at least one more doctest.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 7.9.3\. Exercise[#](#id1 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Write a function called `uses_only` that takes a word and a string of letters,
    and that returns `True` if the word contains only letters in the string.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an outline of the function that includes two doctests. Fill in the function
    so it passes these tests, and add at least one more doctest.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 7.9.4\. Exercise[#](#id2 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Write a function called `uses_all` that takes a word and a string of letters,
    and that returns `True` if the word contains all of the letters in the string
    at least once.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an outline of the function that includes two doctests. Fill in the function
    so it passes these tests, and add at least one more doctest.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 7.9.5\. Exercise[#](#id3 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The New York Times* publishes a daily puzzle called “Spelling Bee” that challenges
    readers to spell as many words as possible using only seven letters, where one
    of the letters is required. The words must have at least four letters.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, on the day I wrote this, the letters were `ACDLORT`, with `R` as
    the required letter. So “color” is an acceptable word, but “told” is not, because
    it does not use `R`, and “rat” is not because it has only three letters. Letters
    can be repeated, so “ratatat” is acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: Write a function called `check_word` that checks whether a given word is acceptable.
    It should take as parameters the word to check, a string of seven available letters,
    and a string containing the single required letter. You can use the functions
    you wrote in previous exercises.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an outline of the function that includes doctests. Fill in the function
    and then check that all tests pass.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: According to the “Spelling Bee” rules,
  prefs: []
  type: TYPE_NORMAL
- en: Four-letter words are worth 1 point each.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Longer words earn 1 point per letter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each puzzle includes at least one “pangram” which uses every letter. These are
    worth 7 extra points!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a function called `score_word` that takes a word and a string of available
    letters and returns its score. You can assume that the word is acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: Again, here’s an outline of the function with doctests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 7.9.6\. Exercise[#](#id4 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might have noticed that the functions you wrote in the previous exercises
    had a lot in common. In fact, they are so similar you can often use one function
    to write another.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if a word uses none of a set forbidden letters, that means it doesn’t
    use any. So we can write a version of `uses_none` like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: There is also a similarity between `uses_only` and `uses_all` that you can take
    advantage of. If you have a working version of `uses_only`, see if you can write
    a version of `uses_all` that calls `uses_only`.
  prefs: []
  type: TYPE_NORMAL
- en: 7.9.7\. Exercise[#](#id5 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you got stuck on the previous question, try asking a virtual assistant, “Given
    a function, `uses_only`, which takes two strings and checks that the first uses
    only the letters in the second, use it to write `uses_all`, which takes two strings
    and checks whether the first uses all the letters in the second, allowing repeats.”
  prefs: []
  type: TYPE_NORMAL
- en: Use `run_doctests` to check the answer.
  prefs: []
  type: TYPE_NORMAL
- en: 7.9.8\. Exercise[#](#id6 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s see if we can write `uses_all` based on `uses_any`.
  prefs: []
  type: TYPE_NORMAL
- en: Ask a virtual assistant, “Given a function, `uses_any`, which takes two strings
    and checks whether the first uses any of the letters in the second, can you use
    it to write `uses_all`, which takes two strings and checks whether the first uses
    all the letters in the second, allowing repeats.”
  prefs: []
  type: TYPE_NORMAL
- en: If it says it can, be sure to test the result!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[Think Python: 3rd Edition](https://allendowney.github.io/ThinkPython/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Copyright 2024 [Allen B. Downey](https://allendowney.com)
  prefs: []
  type: TYPE_NORMAL
- en: 'Code license: [MIT License](https://mit-license.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Text license: [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
  prefs: []
  type: TYPE_NORMAL
