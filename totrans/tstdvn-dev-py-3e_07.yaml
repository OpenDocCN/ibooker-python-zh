- en: Chapter 3\. Testing a Simple Home Page with Unit Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We finished the last chapter with a functional test failing, telling us that
    it wanted the home page for our site to have “To-Do” in its title. It’s time to
    start working on our application. In this chapter, we’ll build our first HTML
    page, find out about URL handling, and creating responses to HTTP requests with
    Django’s view functions.
  prefs: []
  type: TYPE_NORMAL
- en: Our First Django App, and Our First Unit Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Django encourages you to structure your code into *apps*: the theory is that
    one project can have many apps, you can use third-party apps developed by other
    people, and you might even reuse one of your own apps in a different project…​although
    I admit I’ve never actually managed it myself! Still, apps are a good way to keep
    your code organised.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start an app for our to-do lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'That will create a folder called *lists*, next to *manage.py* and the existing
    *superlists* folder, and within it a number of placeholder files for things like
    models, views, and, of immediate interest to us, tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Unit Tests, and How They Differ from Functional Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with so many of the labels we put on things, the line between unit tests
    and functional tests can become a little blurry at times. The basic distinction,
    though, is that functional tests test the application from the outside, from the
    user’s point of view. Unit tests test the application from the inside, from the
    programmer’s point of view.
  prefs: []
  type: TYPE_NORMAL
- en: 'The TDD approach I’m demonstrating uses both types of test to drive the development
    of our application, and ensure its correctness. Our workflow will look a bit like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by writing a *functional test*, describing a typical example of our
    new functionality from the user’s point of view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we have a functional test that fails, we start to think about how to write
    code that can get it to pass (or at least to get past its current failure). We
    now use one or more *unit tests* to define how we want our code to behave—​the
    idea is that each line of production code we write should be tested by (at least)
    one of our unit tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we have a failing unit test, we write the smallest amount of *application
    code* we can, just enough to get the unit test to pass. We may iterate between
    steps 2 and 3 a few times, until we think the functional test will get a little
    further.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we can rerun our functional tests and see if they pass, or get a little
    further. That may prompt us to write some new unit tests, and some new code, and
    so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we’re comfortable that the core functionality works end-to-end, we can
    extend out to cover more permutations and edge cases, using just unit tests now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can see that, all the way through, the functional tests are driving what
    development we do from a high level, while the unit tests drive what we do at
    a low level.
  prefs: []
  type: TYPE_NORMAL
- en: The functional tests don’t aim to cover every single tiny detail of our app’s
    behaviour, they are there to reassure us that everything is wired up correctly.
    The unit tests are there to exhaustively check all the lower level details and
    corner cases.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Functional tests should help you build an application that actually works, and
    guarantee you never accidentally break it. Unit tests should help you to write
    code that’s clean and bug free.
  prefs: []
  type: TYPE_NORMAL
- en: Enough theory for now—let’s see how it looks in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-1\. FTs vs Unit Tests
  prefs: []
  type: TYPE_NORMAL
- en: '| FTs | Unit Tests |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| One test per feature / user story | Many tests per feature |'
  prefs: []
  type: TYPE_TB
- en: '| Test from the user’s point of view | Test the code, ie the programmer’s point
    of view |'
  prefs: []
  type: TYPE_TB
- en: '| Can test that the UI “really” works | Tests the internals, individual functions
    or classes |'
  prefs: []
  type: TYPE_TB
- en: '| Provides confidence that everything is wired together correctly, works end-to-end
    | Can exhaustively check permutations, details, edge cases |'
  prefs: []
  type: TYPE_TB
- en: Unit Testing in Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s see how to write a unit test for our home page view. Open up the new
    file at *lists/tests.py*, and you’ll see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/tests.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Django has helpfully suggested we use a special version of `TestCase`, which
    it provides. It’s an augmented version of the standard `unittest.TestCase`, with
    some additional Django-specific features, which we’ll discover over the next few
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve already seen that the TDD cycle involves starting with a test that fails,
    then writing code to get it to pass. Well, before we can even get that far, we
    want to know that the unit test we’re writing will definitely be run by our automated
    test runner, whatever it is. In the case of *functional_tests.py*, we’re running
    it directly, but this file made by Django is a bit more like magic. So, just to
    make sure, let’s make a deliberately silly failing test:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/tests.py (ch03l002)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s invoke this mysterious Django test runner. As usual, it’s a *manage.py*
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Excellent. The machinery seems to be working. This is a good point for a commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you’ve no doubt guessed, the `-m` flag lets you pass in a commit message
    at the command line, so you don’t need to use an editor. It’s up to you to pick
    the way you like to use the Git command line; I’ll just show you the main ones
    I’ve seen used. For me the main big of VCS hygiene is: *make sure you always review
    what you’re about to commit before you do it*.'
  prefs: []
  type: TYPE_NORMAL
- en: Django’s MVC, URLs, and View Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django is structured along a classic *Model-View-Controller* (MVC) pattern.
    Well, *broadly*. It definitely does have models, but what Django calls views are
    really controllers, and the view part is actually provided by the templates, but
    you can see the general idea is there!
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested, you can look up the finer points of the discussion [in
    the Django FAQs](https://docs.djangoproject.com/en/4.2/faq/general/#django-appears-to-be-a-mvc-framework-but-you-call-the-controller-the-view-and-the-view-the-template-how-come-you-don-t-use-the-standard-names).
  prefs: []
  type: TYPE_NORMAL
- en: 'Irrespective of any of that, as with any web server, Django’s main job is to
    decide what to do when a user asks for a particular URL on our site. Django’s
    workflow goes something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: An HTTP *request* comes in for a particular *URL*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Django uses some rules to decide which *view* function should deal with the
    request (this is referred to as *resolving* the URL).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The view function processes the request and returns an HTTP *response*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, we want to test two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Can we make this view function return the HTML we need?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we tell Django to use this view function when we make a request for the
    root of the site (“/”)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start with the first.
  prefs: []
  type: TYPE_NORMAL
- en: Unit Testing a View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open up *lists/tests.py*, and change our silly test to something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/tests.py (ch03l003)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'What’s going on in this new test? Well, remember, a view function takes an
    HTTP request as input, and produces an HTTP response. So, to test that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We import the `HttpRequest` class so that we can then create a request object
    within our test. This is the kind of object that Django will create when a user’s
    browser asks for a page.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We pass the `HttpRequest` object to our `home_page` view, which gives us a response.
    You won’t be surprised to hear that the response is an instance of a class called
    `HttpResponse`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we extract the `.content` of the response. These are the raw bytes, the
    ones and zeros that would be sent down the wire to the user’s browser. We call
    `.decode()` to convert them into the string of HTML that’s being sent to the user.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can make some assertions: we know we want an html `<title>` tag somewhere
    in there, with the words “To-Do lists” in it—​because that’s what we specified
    in our functional test.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: And we can do a vague sanity check that it’s valid html, by checking that it
    starts with an `<html>` tag which gets closed at the end.
  prefs: []
  type: TYPE_NORMAL
- en: So, what do you think will happen when we run the tests?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s a very predictable and uninteresting error: we tried to import something
    we haven’t even written yet. But it’s still good news—​for the purposes of TDD,
    an exception which was predicted counts as an expected failure. Since we have
    both a failing functional test and a failing unit test, we have the Testing Goat’s
    full blessing to code away.'
  prefs: []
  type: TYPE_NORMAL
- en: At Last! We Actually Write Some Application Code!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is exciting, isn’t it? Be warned, TDD means that long periods of anticipation
    are only defused very gradually, and by tiny increments. Especially since we’re
    learning and only just starting out, we only allow ourselves to change (or add)
    one line of code at a time—​and each time, we make just the minimal change required
    to address the current test failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’m being deliberately extreme here, but what’s our current test failure? We
    can’t import `home_page` from `lists.views`? OK, let’s fix that—​and only that.
    In *lists/views.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/views.py (ch03l004)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*“You must be joking!”* I can hear you say.'
  prefs: []
  type: TYPE_NORMAL
- en: I can hear you because it’s what I used to say (with feeling) when my colleagues
    first demonstrated TDD to me. Well, bear with me, and we’ll talk about whether
    or not this is all taking it too far in a little while. But for now, let yourself
    follow along, even if it’s with some exasperation, and see if our tests can help
    us write the correct code, one tiny step at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the tests again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We still get an error, but it’s moved on a bit. Instead of an import error,
    our tests are telling us that our `home_page` “function” is not callable. That
    gives us a justification for changing it from being `None` to being an actual
    function. At the very smallest level of detail, every single code change can be
    driven by the tests!
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in *lists/views.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/views.py (ch03l005)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Again, we’re making the smallest, dumbest change we can possibly make, that
    addresses precisely the current test failure. Our tests wanted something callable,
    so we gave them the simplest possible callable thing, a function that takes no
    arguments and returns nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the tests again and see what they think:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Once more, our error message has changed slightly, and is guiding us towards
    fixing the next thing that’s wrong.
  prefs: []
  type: TYPE_NORMAL
- en: The Unit-Test/Code Cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can start to settle into the TDD *unit-test/code cycle* now:'
  prefs: []
  type: TYPE_NORMAL
- en: In the terminal, run the unit tests and see how they fail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the editor, make a minimal code change to address the current test failure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And repeat!
  prefs: []
  type: TYPE_NORMAL
- en: The more nervous we are about getting our code right, the smaller and more minimal
    we make each code change—​the idea is to be absolutely sure that each bit of code
    is justified by a test.
  prefs: []
  type: TYPE_NORMAL
- en: This may seem laborious, and at first, it will be. But once you get into the
    swing of things, you’ll find yourself coding quickly even if you take microscopic
    steps—​this is how we write all of our production code at work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how fast we can get this cycle going:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Minimal code change:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: lists/views.py (ch03l006)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Tests:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Code—​we use `django.http.HttpResponse`, as predicted:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: lists/views.py (ch03l007)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Tests again:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Code again:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: lists/views.py (ch03l008)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Tests yet again:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Code yet again:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: lists/views.py (ch03l009)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tests—​almost there?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Come on, one last effort:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: lists/views.py (ch03l010)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Surely?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Hooray! Our first ever unit test pass! That’s so momentous that I think it’s
    worthy of a commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: That was the last variation on `git commit` I’ll show, the `a` and `m` flags
    together, which adds all changes to tracked files and uses the commit message
    from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`git commit -am` is the quickest formulation, but also gives you the least
    feedback about what’s being committed, so make sure you’ve done a `git status`
    and a `git diff` beforehand, and are clear on what changes are about to go in.'
  prefs: []
  type: TYPE_NORMAL
- en: Our functional tests tell us we’re not quite done yet.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve got our unit test passing, so let’s go back to running our functional
    tests to see if we’ve made progress. Don’t forget to spin up the dev server again,
    if it’s not still running.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Looks like something isn’t quite right. This is the reason we have functional
    tests!
  prefs: []
  type: TYPE_NORMAL
- en: Do you remember at the beginning of the chapter, we said we needed to do two
    things, firstly create a view function to produce responses for requests, and
    secondly tell the server which functions should respond to which URLs? Thanks
    to our FT, we have been reminded that we still need to do the second thing.
  prefs: []
  type: TYPE_NORMAL
- en: How can we write a test for URL resolution? At the moment we just test the view
    function directly by importing it and calling it. But we want to test more layers
    of the Django stack. Django, like most web frameworks, supplies a tool for doing
    just that, called the [Django Test Client](https://docs.djangoproject.com/en/4.2/topics/testing/tools/#the-test-client).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to use it by adding a second, alternative test to our unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/tests.py (ch03l011)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We can access the tests client via `self.client`, which is available on any
    test that uses `django.test.TestCase`. It provides methods like `.get()` which
    simulate a browser making http requests, and take a URL as their first parameter.
    We use this instead of manually creating a request object and calling the view
    function directly
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Django also provides some assertion helpers like `assertContains` that save
    us from having to manually extract and decode response content, and have some
    other nice properties besides, as we’ll see.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how that works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Hmm, something about 404s? Let’s dig into it.
  prefs: []
  type: TYPE_NORMAL
- en: Reading Tracebacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s spend a moment talking about how to read tracebacks, since it’s something
    we have to do a lot in TDD. You soon learn to scan through them and pick up relevant
    clues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The first place you look is usually *the error itself*. Sometimes that’s all
    you need to see, and it will let you identify the problem immediately. But sometimes,
    like in this case, it’s not quite self-evident.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing to double-check is: *which test is failing?* Is it definitely
    the one we expected—​that is, the one we just wrote? In this case, the answer
    is yes.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Then we look for the place in *our test code* that kicked off the failure. We
    work our way down from the top of the traceback, looking for the filename of the
    tests file, to check which test function, and what line of code, the failure is
    coming from. In this case it’s the line where we call the `assertContains` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: In Python 3.11 and later, you can also look out for the string of carets, which
    try to tell you exactly where the exception came from. This is more useful for
    unexpected exceptions than for assertion failures like we have now.
  prefs: []
  type: TYPE_NORMAL
- en: There is ordinarily a fifth step, where we look further down for any of *our
    own application code* which was involved with the problem. In this case it’s all
    Django code, but we’ll see plenty of examples of this fifth step later in the
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Pulling it all together, we interpret the traceback as telling us that, when
    we tried to do our assertion on the content of the response, Django’s test helpers
    failed saying that they could not do that, because the response is an HTML 404
    “Not Found” error instead of a normal 200 OK response.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, Django isn’t yet configured to respond to requests for the root
    URL (“/”) of our site. Let’s make that happen now.
  prefs: []
  type: TYPE_NORMAL
- en: urls.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Django uses a file called *urls.py* to map URLs to view functions. This mapping
    is also called *routing*. There’s a main *urls.py* for the whole site in the *superlists*
    folder. Let’s go take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: superlists/urls.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If your *urls.py* looks different or if it mentions a function called `url()`
    instead of `path()`, it’s because you’ve got the wrong version of Django. This
    book is written for Django v4\. Take another look at the [Prerequisites and Assumptions](preface02.xhtml#pre-requisites)
    section and get the right version before you go any further.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, lots of helpful comments and default suggestions from Django. In fact,
    that very first example is pretty much exactly what we want! Let’s use that, with
    some minor changes.
  prefs: []
  type: TYPE_NORMAL
- en: superlists/urls.py (ch03l012)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: No need to import `admin` from `django.contrib`. Django’s admin site is amazing,
    but it’s a topic for another book.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: But we will import our home page view function.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_testing_a_simple_home_page_with___span_class__keep_together__unit_tests__span__CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: And we wire it up here, as a `path()` entry in the `urlpatterns` global. Django
    strips the leading slash from all urls, so `"/url/path/to"` becomes `"url/path/to"`
    and the base URL is just the empty string, `""`. So this config says, the “base
    url should point to our home page view”
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can run our unit tests again, with **`python manage.py test`**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for a little tidy-up. We don’t need two separate tests, let’s move everything
    out of our low-level test that calls the view function directly, into the test
    that uses the Django test client:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/tests.py (ch03l013)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: But now the moment of truth, will our functional tests pass?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Failed? What? Oh, it’s just our little reminder? Yes? Yes! We have a web page!
  prefs: []
  type: TYPE_NORMAL
- en: Ahem. Well, *I* thought it was a thrilling end to the chapter. You may still
    be a little baffled, perhaps keen to hear a justification for all these tests,
    and don’t worry, all that will come, but I hope you felt just a tinge of excitement
    near the end there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just a little commit to calm down, and reflect on what we’ve covered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'That was quite a chapter! Why not try typing `git log`, possibly using the
    `--oneline` flag, for a reminder of what we got up to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Not bad—​we covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting a Django app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Django unit test runner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between functional-, and unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django view functions, request and response objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Django URL resolving and *urls.py*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Django Test Client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And returning basic HTML from a view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
