- en: 'Chapter 10\. Oh Oh: Objects and Classes'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第十章。哦哦：对象和类
- en: No object is mysterious. The mystery is your eye.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 没有神秘的对象。神秘的是你的眼睛。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Elizabeth Bowen
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 伊丽莎白·鲍文
- en: Take an object. Do something to it. Do something else to it.
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 拿一个对象。对它做点什么。再对它做点别的事。
- en: ''
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Jasper Johns
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 贾斯珀·约翰斯
- en: As I’ve mentioned on various pages, everything in Python, from numbers to functions,
    is an object. However, Python hides most of the object machinery by means of special
    syntax. You can type `num = 7` to create an object of type integer with the value
    7, and assign an object reference to the name `num`. The only time you need to
    look inside objects is when you want to make your own or modify the behavior of
    existing objects. You’ll see how to do both in this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在各个页面中提到的，Python中的所有东西，从数字到函数，都是对象。但是，Python通过特殊语法隐藏了大部分对象机制。你可以输入`num =
    7`来创建一个类型为整数、值为7的对象，并将对象引用分配给名称`num`。只有当你想要创建自己的对象或修改现有对象的行为时，你才需要查看对象的内部。在本章中，你将看到如何执行这两个操作。
- en: What Are Objects?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是对象？
- en: An *object* is a custom data structure containing both data (variables, called
    *attributes*) and code (functions, called *methods*). It represents a unique instance
    of some concrete thing. Think of objects as nouns and their methods as verbs.
    An object represents an individual thing, and its methods define how it interacts
    with other things.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*对象*是一个自定义的数据结构，包含数据（变量，称为*属性*）和代码（函数，称为*方法*）。它代表某个具体事物的唯一实例。把对象看作名词，它的方法是动词。一个对象代表一个个体，它的方法定义了它与其他事物的交互方式。
- en: For example, the integer object with the value `7` is an object that facilitates
    methods such as addition and multiplication, as you saw in [Chapter 3](ch03.html#ch_numbers).
    `8` is a different object. This means there’s an integer class built in somewhere
    in Python, to which both `7` and `8` belong. The strings `'cat'` and `'duck'`
    are also objects in Python, and have string methods that you’ve seen in [Chapter 5](ch05.html#ch_strings),
    such as `capitalize()` and `replace()`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，值为`7`的整数对象是一个对象，可以执行加法和乘法等方法，就像你在[第三章](ch03.html#ch_numbers)中看到的那样。`8`是另一个对象。这意味着Python中某处内置了一个整数类，`7`和`8`都属于这个类。字符串`'cat'`和`'duck'`也是Python中的对象，具有你在[第五章](ch05.html#ch_strings)中看到的字符串方法，如`capitalize()`和`replace()`。
- en: Unlike modules, you can have multiple objects (often referred to as *instances*)
    at the same time, each with potentially different attributes. They’re like super
    data structures, with code thrown in.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与模块不同，你可以同时拥有多个对象（通常称为*实例*），每个对象可能具有不同的属性。它们就像是超级数据结构，内含代码。
- en: Simple Objects
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的对象
- en: Let’s start with basic object classes; we’ll save the discussion of inheritance
    for a few pages.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基本对象类开始；我们将在几页后讨论继承。
- en: Define a Class with class
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用class定义一个类
- en: To create a new object that no one has ever created before, you first define
    a *class* that indicates what it contains.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个以前从未创建过的新对象，首先需要定义一个*类*，指示它包含什么内容。
- en: In [Chapter 2](ch02.html#ch_names), I compared an object to a plastic box. A
    *class* is like the mold that makes that box. For instance, Python has a built-in
    class that makes string objects such as `'cat'` and `'duck'`, and the other standard
    data types—lists, dictionaries, and so on. To create your own custom object in
    Python, you first need to define a class by using the `class` keyword. Let’s walk
    through some simple examples.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](ch02.html#ch_names)中，我将对象比作一个塑料盒。一个*类*就像是制造那个盒子的模具。例如，Python有一个内置类，用来创建字符串对象如`'cat'`和`'duck'`，以及其他标准数据类型——列表、字典等等。要在Python中创建自定义对象，首先需要使用`class`关键字定义一个类。让我们通过一些简单的示例来详细了解。
- en: Suppose that you want to define objects to represent information about cats.^([1](ch10.html#idm45794999331256))
    Each object will represent one feline. You’ll first want to define a class called
    `Cat` as the mold. In the examples that follow, we try more than one version of
    this class as we build up from the simplest class to ones that actually do something
    useful.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想定义对象来表示关于猫的信息。^[1](ch10.html#idm45794999331256) 每个对象将代表一只猫。你首先需要定义一个名为`Cat`的类作为模板。在接下来的示例中，我们将尝试多个版本的这个类，从最简单的类逐步构建到真正有用的类。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We’re following the naming conventions of Python’s [PEP-8](https://oreil.ly/gAJOF).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循Python的命名约定[PEP-8](https://oreil.ly/gAJOF)。
- en: 'Our first try is the simplest possible class, an empty one:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个尝试是最简单的类，一个空类：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can also say:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以说：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Just as with functions, we needed to say `pass` to indicate that this class
    was empty. This definition is the bare minimum to create an object.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 就像函数一样，我们需要使用`pass`来指示这个类是空的。这个定义是创建对象的最低要求。
- en: 'You create an object from a class by calling the class name as though it were
    a function:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过像调用函数一样调用类名，你可以从类创建一个对象：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, calling `Cat()` creates two individual objects from the `Cat`
    class, and we assigned them to the names `a_cat` and `another_cat`. But our `Cat`
    class had no other code, so the objects that we created from it just sit there
    and can’t do much else.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，调用`Cat()`创建了两个来自`Cat`类的单独对象，并将它们分配给了名称`a_cat`和`another_cat`。但是我们的`Cat`类没有其他代码，所以我们从它创建的对象只是存在，不能做太多其他事情。
- en: Well, they can do a little.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，它们可以做一点点。
- en: Attributes
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: 'An *attribute* is a variable inside a class or object. During and after an
    object or class is created, you can assign attributes to it. An attribute can
    be any other object. Let’s make two cat objects again:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*属性*是类或对象内部的变量。在创建对象或类期间以及之后，你可以给它赋予属性。属性可以是任何其他对象。让我们再次创建两个猫对象：'
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When we defined the `Cat` class, we didn’t specify how to print an object from
    that class. Python jumps in and prints something like `<__main__.Cat object at
    0x100cd1da0>`. In [“Magic Methods”](#magic_methods), you’ll see how to change
    this default behavior.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义`Cat`类时，并没有指定如何打印来自该类的对象。Python则会打印类似 `<__main__.Cat object at 0x100cd1da0>`
    的东西。在[“魔术方法”](#magic_methods)中，你会看到如何改变这个默认行为。
- en: 'Now assign a few attributes to our first object:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在给我们的第一个对象分配一些属性：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Can we access these? We sure hope so:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能访问它们吗？我们当然希望如此：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Because `nemesis` was an attribute referring to another `Cat` object, we can
    use `a_cat.nemesis` to access it, but this other object doesn’t have a `name`
    attribute yet:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`nemesis`是指向另一个`Cat`对象的属性，我们可以使用`a_cat.nemesis`来访问它，但是这个其他对象还没有`name`属性：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let’s name our archfeline:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给我们的大猫起个名字：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Even the simplest object like this one can be used to store multiple attributes.
    So, you can use multiple objects to store different values, instead of using something
    like a list or dictionary.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是像这样的最简单的对象也可以用来存储多个属性。因此，你可以使用多个对象来存储不同的值，而不是使用类似列表或字典的东西。
- en: When you hear *attributes*, it usually means object attributes. There are also
    *class attributes*, and you’ll see the differences later in [“Class and Object
    Attributes”](#attribute_types).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当你听到*attributes*（属性）时，通常指的是对象的属性。还有*class attributes*（类属性），稍后你会在[“类和对象属性”](#attribute_types)中看到它们的区别。
- en: Methods
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法
- en: A *method* is a function in a class or object. A method looks like any other
    function, but can be used in special ways that you’ll see in [“Properties for
    Attribute Access”](#properties) and [“Method Types”](#method_types).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法*是类或对象中的函数。方法看起来像任何其他函数，但可以用特殊的方式使用，你将在[“属性访问的属性”](#properties)和[“方法类型”](#method_types)中看到。'
- en: Initialization
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化
- en: 'If you want to assign object attributes at creation time, you need the special
    Python object initialization method `__init__()`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在创建时分配对象属性，你需要使用特殊的Python对象初始化方法`__init__()`：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is what you’ll see in real Python class definitions. I admit that the `__init__()`
    and `self` look strange. `__init__()` is the special Python name for a method
    that initializes an individual object from its class definition.^([2](ch10.html#idm45794999026920))
    The `self` argument specifies that it refers to the individual object itself.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你在真实的Python类定义中会看到的内容。我承认`__init__()`和`self`看起来很奇怪。`__init__()`是Python中一个特殊的方法名，用于初始化一个类定义中的单个对象。^([2](ch10.html#idm45794999026920))
    `self`参数指定它是指向个体对象本身。
- en: When you define `__init__()` in a class definition, its first parameter should
    be named `self`. Although `self` is not a reserved word in Python, it’s common
    usage. No one reading your code later (including you!) will need to guess what
    you meant if you use `self`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在类定义中定义`__init__()`时，它的第一个参数应该命名为`self`。虽然`self`在Python中不是一个保留字，但它是常见的用法。如果你使用`self`，日后阅读你的代码的人（包括你自己！）不会猜测你的意图。
- en: 'But even this second `Cat` class definition didn’t create an object that really
    did anything. The third try is the charm that really shows how to create a simple
    object in Python and assign one of its attributes. This time, we add the parameter
    `name` to the initialization method:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 但是即使是这第二个`Cat`类定义也没有创建一个真正做任何事情的对象。第三次尝试是真正展示如何在Python中创建简单对象并分配其属性的方法。这次，我们将`name`参数添加到初始化方法中：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we can create an object from the `Cat` class by passing a string for the
    `name` parameter:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过为`name`参数传递一个字符串来从`Cat`类创建一个对象：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here’s what this line of code does:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这行代码的作用：
- en: Looks up the definition of the `Cat` class
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找`Cat`类的定义
- en: '*Instantiates* (creates) a new object in memory'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实例化*（创建）一个新的内存对象'
- en: Calls the object’s `__init__()` method, passing this newly created object as
    `self` and the other argument (`'Grumpy'`) as `name`
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用对象的`__init__()`方法，将这个新创建的对象作为`self`传递，并将另一个参数（`'Grumpy'`）作为`name`传递
- en: Stores the value of `name` in the object
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`name`的值存储在对象中
- en: Returns the new object
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回新对象
- en: Attaches the variable `furball` to the object
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将变量`furball`附加到对象上
- en: This new object is like any other object in Python. You can use it as an element
    of a list, tuple, dictionary, or set. You can pass it to a function as an argument,
    or return it as a result.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新对象像Python中的任何其他对象一样。你可以将它用作列表、元组、字典或集合的元素，可以将它作为参数传递给函数，或将它作为结果返回。
- en: 'What about the `name` value that we passed in? It was saved with the object
    as an attribute. You can read and write it directly:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们传入的`name`值呢？它以属性的形式保存在对象中。你可以直接读取和写入它：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Remember, *inside* the `Cat` class definition, you access the `name` attribute
    as `self.name`. When you create an actual object and assign it to a variable like
    `furball`, you refer to it as `furball.name`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在`Cat`类定义的内部，你通过`self.name`访问`name`属性。当你创建一个实际对象并将其赋给像`furball`这样的变量时，你可以使用`furball.name`来引用它。
- en: It is *not* necessary to have an `__init__()` method in every class definition;
    it’s used to do anything that’s needed to distinguish this object from others
    created from the same class. It’s not what some other languages would call a “constructor.”
    Python already constructed the object for you. Think of `__init__()` as an *initializer*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个类定义都必须有一个`__init__()`方法；它用于执行任何需要区分此对象与同类其他对象的操作。它并不是某些其他语言所称的“构造函数”。Python已经为你构造好了对象。将`__init__()`视为*初始化方法*。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can make many individual objects from a single class. But remember that
    Python implements data as objects, so the class itself is an object. However,
    there’s only one class object in your program. If you defined `class Cat` as we
    did here, it’s like the Highlander—there can be only one.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从一个类创建许多个体对象。但要记住，Python将数据实现为对象，因此类本身也是一个对象。但是，在你的程序中只有一个类对象。如果像我们这里定义了`class
    Cat`，它就像《猎魔人》一样——只能有一个。
- en: Inheritance
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: When you’re trying to solve some coding problem, often you’ll find an existing
    class that creates objects that do almost what you need. What can you do?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当你试图解决某个编程问题时，通常会发现一个现有的类可以创建几乎符合你需求的对象。你能做什么？
- en: You could modify this old class, but you’ll make it more complicated, and you
    might break something that used to work.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以修改这个旧类，但会使它变得更加复杂，并且可能会破坏一些曾经工作的功能。
- en: Or you could write a new class, cutting and pasting from the old one and merging
    your new code. But this means that you have more code to maintain, and the parts
    of the old and new classes that used to work the same might drift apart because
    they’re now in separate places.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以编写一个新类，从旧类中剪切和粘贴代码并合并新代码。但这意味着你需要维护更多的代码，并且原来和新类中曾经相同的部分可能会因为它们现在位于不同的位置而有所不同。
- en: 'One solution is *inheritance*: creating a new class *from* an existing class,
    but with some additions or changes. It’s a good way to reuse code. When you use
    inheritance, the new class can automatically use all the code from the old class
    but without you needing to copy any of it.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一个解决方案是*继承*：从现有类创建一个新类，并进行一些添加或更改。这是代码重用的一个很好的方式。使用继承时，新类可以自动使用旧类的所有代码，而不需要你复制任何代码。
- en: Inherit from a Parent Class
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承自父类
- en: You define only what you need to add or change in the new class, and this overrides
    the behavior of the old class. The original class is called a *parent*, *superclass*,
    or *base class*; the new class is called a *child*, *subclass*, or *derived class*.
    These terms are interchangeable in object-oriented programming.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需定义新类中需要添加或更改的内容，这样就可以覆盖旧类的行为。原始类称为*父类*、*超类*或*基类*；新类称为*子类*、*子类*或*派生类*。这些术语在面向对象编程中是可以互换使用的。
- en: 'So, let’s inherit something. In the next example, we define an empty class
    called `Car`. Next, we define a subclass of `Car` called `Yugo`.^([3](ch10.html#idm45794998829960))
    You define a subclass by using the same `class` keyword but with the parent class
    name inside the parentheses (`class Yugo(Car)` here):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们继承一些东西。在下一个例子中，我们定义一个空类称为 `Car`。接下来，我们定义 `Car` 的一个子类称为 `Yugo`。^([3](ch10.html#idm45794998829960))
    您可以使用相同的 `class` 关键字，但在括号中使用父类名称（这里是 `class Yugo(Car)`）来定义子类：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can check whether a class is derived from another class by using `issubclass()`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `issubclass()` 来检查一个类是否派生自另一个类：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, create an object from each class:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从每个类创建一个对象：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A child class is a specialization of a parent class; in object-oriented lingo,
    `Yugo` *is-a* `Car`. The object named `give_me_a_yugo` is an instance of class
    `Yugo`, but it also inherits whatever a `Car` can do. In this case, `Car` and
    `Yugo` are as useful as deckhands on a submarine, so let’s try new class definitions
    that actually do something:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 子类是父类的一种特殊化；在面向对象的术语中，`Yugo` *是一个* `Car`。名为 `give_me_a_yugo` 的对象是 `Yugo` 类的实例，但它也继承了
    `Car` 的所有功能。在这种情况下，`Car` 和 `Yugo` 就像潜水艇上的水手一样有用，因此让我们尝试实际做点事的新类定义：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, make one object from each class and call the `exclaim` method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，分别从每个类创建一个对象并调用 `exclaim` 方法：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Without doing anything special, `Yugo` inherited the `exclaim()` method from
    `Car`. In fact, `Yugo` says that it *is* a `Car`, which might lead to an identity
    crisis. Let’s see what we can do about that.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 不做任何特殊处理，`Yugo` 继承了 `Car` 的 `exclaim()` 方法。事实上，`Yugo` 表示它*是*一辆 `Car`，这可能导致身份危机。让我们看看我们能做些什么。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Inheritance is appealing, but can be overused. Years of object-oriented programming
    experience have shown that too much use of inheritance can make programs hard
    to manage. Instead, it’s often recommended to emphasize other techniques like
    aggregation and composition. We get to these alternatives in this chapter.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 继承很吸引人，但可能被滥用。多年的面向对象编程经验表明，过多使用继承会使程序难以管理。相反，通常建议强调其他技术，如聚合和组合。我们在本章中介绍这些替代方法。
- en: Override a Method
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖一个方法
- en: 'As you just saw, a new class initially inherits everything from its parent
    class. Moving forward, you’ll see how to replace or override a parent method.
    `Yugo` should probably be different from `Car` in some way; otherwise, what’s
    the point of defining a new class? Let’s change how the `exclaim()` method works
    for a `Yugo`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你刚才看到的，一个新类最初会从其父类继承所有东西。接下来，您将看到如何替换或覆盖父类方法。`Yugo` 可能在某种方式上应该与 `Car` 不同；否则，定义一个新类有什么意义？让我们改变
    `exclaim()` 方法在 `Yugo` 中的工作方式：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now make two objects from these classes:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从这些类中创建两个对象：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: What do they say?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 他们说什么？
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In these examples, we overrode the `exclaim()` method. We can override any
    methods, including `__init__()`. Here’s another example that uses a `Person` class.
    Let’s make subclasses that represent doctors (`MDPerson`) and lawyers (`JDPerson`):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，我们覆盖了 `exclaim()` 方法。我们可以覆盖任何方法，包括 `__init__()`。这里有另一个使用 `Person` 类的例子。让我们创建代表医生（`MDPerson`）和律师（`JDPerson`）的子类：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In these cases, the initialization method `__init__()` takes the same arguments
    as the parent `Person` class but stores the value of `name` differently inside
    the object instance:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，初始化方法 `__init__()` 接受与父类 `Person` 相同的参数，但在对象实例内部以不同的方式存储 `name` 的值：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Add a Method
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一个方法
- en: 'The child class can also *add* a method that was not present in its parent
    class. Going back to classes `Car` and `Yugo`, we’ll define the new method `need_a_push()`
    for class `Yugo` only:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 子类还可以*添加*在其父类中不存在的方法。回到 `Car` 和 `Yugo` 类，我们将为仅 `Yugo` 类定义新方法 `need_a_push()`：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, make a `Car` and a `Yugo`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个 `Car` 和一个 `Yugo`：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A `Yugo` object can react to a `need_a_push()` method call:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Yugo` 对象可以对 `need_a_push()` 方法调用做出反应：'
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'But a generic `Car` object cannot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 但是一个普通的 `Car` 对象不能：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: At this point, a `Yugo` can do something that a `Car` cannot, and the distinct
    personality of a `Yugo` can emerge.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，一个 `Yugo` 能做一些 `Car` 不能的事情，`Yugo` 的独特个性可以显现出来。
- en: Get Help from Your Parent with super()
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 `super()` 从父类获得帮助
- en: 'We saw how the child class could add or override a method from the parent.
    What if it wanted to call that parent method? “I’m glad you asked,” says `super()`.
    Here, we define a new class called `EmailPerson` that represents a `Person` with
    an email address. First, our familiar `Person` definition:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到子类如何添加或覆盖父类的方法。如果它想调用那个父类方法呢？“我很高兴你问”，`super()` 这里，我们定义了一个名为 `EmailPerson`
    的新类，代表一个带有电子邮件地址的 `Person`。首先是我们熟悉的 `Person` 定义：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Notice that the `__init__()` call in the following subclass has an additional
    `email` parameter:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以下子类中的`__init__()`调用具有额外的`email`参数：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When you define an `__init__()` method for your class, you’re replacing the
    `__init__()` method of its parent class, and the latter is not called automatically
    anymore. As a result, we need to call it explicitly. Here’s what’s happening:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当为类定义`__init__()`方法时，您正在替换其父类的`__init__()`方法，后者不再自动调用。因此，我们需要显式调用它。以下是发生的情况：
- en: The `super()` gets the definition of the parent class, `Person`.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`super()`获取父类`Person`的定义。'
- en: The `__init__()` method calls the `Person.__init__()` method. It takes care
    of passing the `self` argument to the superclass, so you just need to give it
    any optional arguments. In our case, the only other argument `Person()` accepts
    is `name`.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__()`方法调用了`Person.__init__()`方法。它负责将`self`参数传递给超类，因此您只需提供任何可选参数。在我们的情况下，`Person()`接受的唯一其他参数是`name`。'
- en: The `self.email = email` line is the new code that makes this `EmailPerson`
    different from a `Person`.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.email = email`行是使这个`EmailPerson`与`Person`不同的新代码。'
- en: 'Moving on, let’s make one of these creatures:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 继续，让我们制作其中的一个生物：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We should be able to access both the `name` and `email` attributes:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该能够访问`name`和`email`属性：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Why didn’t we just define our new class as follows?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不直接定义我们的新类如下？
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We could have done that, but it would have defeated our use of inheritance.
    We used `super()` to make `Person` do its work, the same as a plain `Person` object
    would. There’s another benefit: if the definition of `Person` changes in the future,
    using `super()` will ensure that the attributes and methods that `EmailPerson`
    inherits from `Person` will reflect the change.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以这样做，但那样会破坏我们对继承的使用。我们使用`super()`使`Person`执行其工作，就像一个普通的`Person`对象一样。还有另一个好处：如果将来`Person`的定义发生变化，使用`super()`将确保`EmailPerson`从`Person`继承的属性和方法将反映这些变化。
- en: Use `super()` when the child is doing something its own way but still needs
    something from the parent (as in real life).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当子类以自己的方式执行某些操作但仍需要来自父类的东西（就像现实生活中一样）时，请使用`super()`。
- en: Multiple Inheritance
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多重继承
- en: You’ve just seen some class examples with no parent class, and some with one.
    Actually, objects can inherit from multiple parent classes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚看到一些没有父类的经典示例，还有一些有一个父类的示例。实际上，对象可以从多个父类继承。
- en: If your class refers to a method or attribute that it doesn’t have, Python will
    look in all the parents. What if more than one of them has something with that
    name? Who wins?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的类引用其没有的方法或属性，Python将在所有父类中查找。如果其中有多个类具有相同名称的东西，谁会胜出？
- en: Unlike inheritance in people, where a dominant gene wins no matter who it came
    from, inheritance in Python depends on *method resolution order*. Each Python
    class has a special method called `mro()` that returns a list of the classes that
    would be visited to find a method or attribute for an object of that class. A
    similar attribute, called `__mro__`, is a tuple of those classes. Like a sudden-death
    playoff, the first one wins.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与人类的遗传不同，在那里无论来自谁的优势基因都会获胜，Python中的继承取决于*方法解析顺序*。每个Python类都有一个特殊的方法称为`mro()`，返回一个访问该类对象的方法或属性时要访问的类的列表。类似的属性称为`__mro__`，是这些类的元组。就像突然死亡的季后赛一样，第一个赢家胜出。
- en: Here, we define a top `Animal` class, two child classes (`Horse` and `Donkey`),
    and then two derived from these:^([4](ch10.html#idm45794997899784))
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个顶级`Animal`类，两个子类（`Horse`和`Donkey`），然后从这些类派生出两个：^([4](ch10.html#idm45794997899784))
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we look for a method or attribute of a `Mule`, Python will look at the following
    things, in this order:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查找`Mule`的方法或属性，Python将按照以下顺序查找：
- en: The object itself (of type `Mule`)
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象本身（类型为`Mule`）
- en: The object’s class (`Mule`)
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象的类（`Mule`）
- en: The class’s first parent class (`Donkey`)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类的第一个父类（`Donkey`）
- en: The class’s second parent class (`Horse`)
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类的第二个父类（`Horse`）
- en: The grandparent class (`Animal`) class
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 祖父类（`Animal`）类
- en: 'It’s much the same for a `Hinny`, but with `Horse` before `Donkey`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Hinny`来说，情况大致相同，但是`Horse`在`Donkey`之前：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: So what do these fine beasts say?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这些优雅的动物怎么说呢？
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We listed the parent classes in (father, mother) order, so they talk like their
    dads.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按（父亲，母亲）顺序列出了父类，所以它们说话像他们的爸爸一样。
- en: If the `Horse` and `Donkey` did not have a `says()` method, the mule or hinny
    would have used the grandparent `Animal` class’s `says()` method, and returned
    `'I speak!'`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Horse`和`Donkey`没有`says()`方法，那么骡或骡马将使用祖父类`Animal`类的`says()`方法，并返回`'I speak!'`。
- en: Mixins
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mixins
- en: You may include an extra parent class in your class definition, but as a helper
    only. That is, it doesn’t share any methods with the other parent classes, and
    avoids the method resolution ambiguity that I mentioned in the previous section.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在类定义中包含一个额外的父类，但仅作为助手使用。也就是说，它不与其他父类共享任何方法，并避免了我在上一节中提到的方法解析歧义。
- en: 'Such a parent class is sometimes called a *mixin* class. Uses might include
    “side” tasks like logging. Here’s a mixin that pretty-prints an object’s attributes:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的父类有时被称为*mixin*类。用途可能包括像日志记录这样的“副”任务。这里是一个漂亮打印对象属性的mixin：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In self Defense
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在自卫中
- en: One criticism of Python (besides the use of whitespace) is the need to include
    `self` as the first argument to instance methods (the kind of method you’ve seen
    in the previous examples). Python uses the `self` argument to find the right object’s
    attributes and methods. For an example, I’ll show how you would call an object’s
    method, and what Python actually does behind the scenes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用空格之外，Python的一个批评是需要将`self`作为实例方法的第一个参数（您在前面的示例中看到的方法类型）。Python使用`self`参数来查找正确的对象属性和方法。例如，我将展示如何调用对象的方法，以及Python在幕后实际做了什么。
- en: 'Remember class `Car` from earlier examples? Let’s call its `exclaim()` method
    again:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得之前例子中的`Car`类吗？让我们再次调用它的`exclaim()`方法：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here’s what Python actually does, under the hood:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是Python在幕后实际做的事情：
- en: Look up the class (`Car`) of the object `a_car`
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找对象`a_car`的类（`Car`）。
- en: Pass the object `a_car` to the `exclaim()` method of the `Car` class as the
    `self` parameter
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对象`a_car`作为`self`参数传递给`Car`类的`exclaim()`方法。
- en: 'Just for fun, you can even run it this way yourself and it will work the same
    as the normal (`a_car.exclaim()`) syntax:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了好玩，您甚至可以以这种方式自行运行它，它将与正常的（`a_car.exclaim()`）语法相同运行：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: However, there’s never a reason to use that lengthier style.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，永远没有理由使用那种更冗长的风格。
- en: Attribute Access
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性访问
- en: In Python, object attributes and methods are normally public, and you’re expected
    to behave yourself (this is sometimes called a “consenting adults” policy). Let’s
    compare the direct approach with some alternatives.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，对象的属性和方法通常是公开的，您被期望自律行事（这有时被称为“成年人同意”政策）。让我们比较直接方法与一些替代方法。
- en: Direct Access
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直接访问
- en: 'As you’ve seen, you can get and set attribute values directly:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，您可以直接获取和设置属性值：
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: But what if someone misbehaves?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果有人行为不端呢？
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The next two sections show ways to get some privacy for attributes that you
    don’t want anyone to stomp by accident.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个部分展示了如何为不希望被意外覆盖的属性获取一些隐私。
- en: Getters and Setters
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Getter和Setter
- en: Some object-oriented languages support private object attributes that can’t
    be accessed directly from the outside. Programmers then may need to write *getter*
    and *setter* methods to read and write the values of such private attributes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一些面向对象的语言支持私有对象属性，这些属性无法从外部直接访问。程序员可能需要编写*getter*和*setter*方法来读取和写入这些私有属性的值。
- en: Python doesn’t have private attributes, but you can write getters and setters
    with obfuscated attribute names to get a little privacy. (The best solution is
    to use *properties*, described in the next section.)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Python没有私有属性，但是您可以使用名称混淆的getter和setter来获得一些隐私。（最佳解决方案是使用下一节描述的*属性*。）
- en: 'In the following example, we define a `Duck` class with a single instance attribute
    called `hidden_name`. We don’t want people to access this directly, so we define
    two methods: a getter (`get_name()`) and a setter (`set_name()`). Each is accessed
    by a property called `name`. I’ve added a `print()` statement to each method to
    show when it’s being called:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们定义了一个名为`Duck`的类，具有一个名为`hidden_name`的单个实例属性。我们不希望直接访问这个属性，因此我们定义了两个方法：一个getter（`get_name()`）和一个setter（`set_name()`）。每个方法都通过名为`name`的属性访问。我在每个方法中添加了一个`print()`语句，以显示它何时被调用：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Properties for Attribute Access
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于属性访问的属性
- en: The Pythonic solution for attribute privacy is to use *properties*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于属性隐私的Python解决方案是使用*属性*。
- en: 'There are two ways to do this. The first way is to add `name = property(get_name,
    set_name)` as the final line of our previous `Duck` class definition:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以做到这一点。第一种方法是将`name = property(get_name, set_name)`添加为我们之前`Duck`类定义的最后一行：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The old getter and setter still work:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的getter和setter仍然有效：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'But now you can also use the property `name` to get and set the hidden name:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您还可以使用属性`name`来获取和设置隐藏的名称：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the second method, you add some decorators and replace the method names
    `get_name` and `set_name` with `name`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种方法中，您添加了一些装饰器，并用`name`替换了方法名`get_name`和`set_name`：
- en: '`@property`, which goes before the getter method'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@property`，放在getter方法之前'
- en: '`@*name*.setter`, which goes before the setter method'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@*name*.setter`，放在setter方法之前'
- en: 'Here’s how they actually look in the code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它们在代码中的实际表现：
- en: '[PRE44]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can still access `name` as though it were an attribute:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然可以像访问属性一样访问`name`：
- en: '[PRE45]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note
  id: totrans-187
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If anyone guessed that we called our attribute `hidden_name`, they could still
    read and write it directly as `fowl.hidden_name`. In [“Name Mangling for Privacy”](#name_mangling),
    you’ll see how Python provides a special way to hide attribute names.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人猜到我们称呼我们的属性为`hidden_name`，他们仍然可以直接作为`fowl.hidden_name`读取和写入它。在[“隐私的名称混淆”](#name_mangling)中，你将看到Python提供了一种特殊的方式来隐藏属性名称。
- en: Properties for Computed Values
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于计算值的属性
- en: In the previous examples, we used the `name` property to refer to a single attribute
    (`hidden_name`) stored within the object.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们使用`name`属性来引用存储在对象内部的单个属性(`hidden_name`)。
- en: 'A property can also return a *computed value*. Let’s define a `Circle` class
    that has a `radius` attribute and a computed `diameter` property:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 属性还可以返回一个*计算值*。让我们定义一个`Circle`类，它有一个`radius`属性和一个计算出的`diameter`属性：
- en: '[PRE46]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a `Circle` object with an initial value for its `radius`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个带有其`radius`初始值的`Circle`对象：
- en: '[PRE47]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can refer to `diameter` as if it were an attribute such as `radius`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`diameter`称为像`radius`这样的属性：
- en: '[PRE48]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here’s the fun part: we can change the `radius` attribute at any time, and
    the diameter property will be computed from the current value of `radius`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有趣的一部分：我们可以随时改变`radius`属性，并且`diameter`属性将从当前的`radius`值计算出来：
- en: '[PRE49]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you don’t specify a setter property for an attribute, you can’t set it from
    the outside. This is handy for read-only attributes:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有为属性指定一个setter属性，你不能从外部设置它。这对于只读属性很方便：
- en: '[PRE50]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'There’s one more advantage of using a property over direct attribute access:
    if you ever change the definition of the attribute, you need to fix only the code
    within the class definition, not in all the callers.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性而不是直接访问属性有另一个优点：如果你改变属性的定义，你只需要修复类定义内的代码，而不是所有的调用者。
- en: Name Mangling for Privacy
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于隐私的名称混淆
- en: 'In the `Duck` class example a little earlier, we called our (not completely)
    hidden attribute `hidden_name`. Python has a naming convention for attributes
    that should not be visible outside of their class definition: begin with two underscores
    (`__`).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在稍早的`Duck`类示例中，我们称呼我们的（不完全）隐藏属性为`hidden_name`。Python有一个属性命名约定，这些属性不应该在其类定义之外可见：以双下划线(`__`)开头。
- en: 'Let’s rename `hidden_name` to `__name`, as demonstrated here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`hidden_name`重命名为`__name`，如此所示：
- en: '[PRE51]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Take a moment to see whether everything still works:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 看一看是否一切仍在正常工作：
- en: '[PRE52]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Looks good. And you can’t access the `__name` attribute:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错。而且你不能访问`__name`属性：
- en: '[PRE53]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This naming convention doesn’t make it completely private, but Python does
    *mangle* the attribute name to make it unlikely for external code to stumble upon
    it. If you’re curious and promise not to tell everyone,^([5](ch10.html#idm45794996488440))
    here’s what it becomes:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这种命名约定并不完全使其私有，但Python确实*mangle*属性名称以使外部代码不太可能偶然发现它。如果你好奇并且承诺不告诉每个人，^([5](ch10.html#idm45794996488440))
    这里是它变成什么样子：
- en: '[PRE54]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Notice that it didn’t print `inside the getter`. Although this isn’t perfect
    protection, name mangling discourages accidental or intentional direct access
    to the attribute.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，它没有打印`inside the getter`。虽然这并不是完美的保护，但名称混淆阻止了对属性的意外或故意的直接访问。
- en: Class and Object Attributes
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和对象属性
- en: 'You can assign attributes to classes, and they’ll be inherited by their child
    objects:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将属性分配给类，并且它们将被其子对象继承：
- en: '[PRE55]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'But if you change the value of the attribute in the child object, it doesn’t
    affect the class attribute:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果您更改子对象中属性的值，则不会影响类属性：
- en: '[PRE56]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you change the class attribute later, it won’t affect existing child objects:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您稍后更改类属性，它不会影响现有的子对象：
- en: '[PRE57]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'But it will affect new ones:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 但这将影响到新的：
- en: '[PRE58]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Method Types
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法类型
- en: 'Some methods are part of the class itself, some are part of the objects that
    are created from that class, and some are none of the above:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一些方法是类本身的一部分，一些是从该类创建的对象的一部分，还有一些都不是：
- en: If there’s no preceding decorator, it’s an *instance method*, and its first
    argument should be `self` to refer to the individual object itself.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有前置装饰器，那么它是一个*实例方法*，其第一个参数应该是`self`，用于引用对象本身。
- en: If there’s a preceding `@classmethod` decorator, it’s a *class method*, and
    its first argument should be `cls` (or anything, just not the reserved word `class`),
    referring to the class itself.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有一个前置的`@classmethod`装饰器，那么它是一个*类方法*，其第一个参数应该是`cls`（或任何其他，只要不是保留字`class`），用于指代类本身。
- en: If there’s a preceding `@staticmethod` decorator, it’s a *static method*, and
    its first argument isn’t an object or class.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有一个前置的`@staticmethod`装饰器，那么它是一个*静态方法*，它的第一个参数不是对象或类。
- en: The following sections have some details.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节有一些详细信息。
- en: Instance Methods
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例方法
- en: When you see an initial `self` argument in methods within a class definition,
    it’s an *instance method*. These are the types of methods that you would normally
    write when creating your own classes. The first parameter of an instance method
    is `self`, and Python passes the object to the method when you call it. These
    are the ones that you’ve seen so far.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在类定义中的方法中看到初始的`self`参数时，它是一个*实例方法*。这些是您通常在创建自己的类时编写的方法类型。实例方法的第一个参数是`self`，当您调用它时，Python会将对象传递给方法。到目前为止，您已经看到了这些。
- en: Class Methods
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类方法
- en: 'In contrast, a *class method* affects the class as a whole. Any change you
    make to the class affects all of its objects. Within a class definition, a preceding
    `@classmethod` decorator indicates that that following function is a class method.
    Also, the first parameter to the method is the class itself. The Python tradition
    is to call the parameter `cls`, because `class` is a reserved word and can’t be
    used here. Let’s define a class method for `A` that counts how many object instances
    have been made from it:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，*类方法*影响整个类。对类进行的任何更改都会影响其所有对象。在类定义中，前置的`@classmethod`装饰器表示随后的函数是一个类方法。此方法的第一个参数也是类本身。Python的传统是将参数称为`cls`，因为`class`是一个保留字，不能在这里使用。让我们为`A`定义一个类方法来统计有多少个对象实例已经创建了：
- en: '[PRE59]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Notice that we referred to `A.count` (the class attribute) in `__init__()` rather
    than `self.count` (which would be an object instance attribute). In the `kids()`
    method, we used `cls.count`, but we could just as well have used `A.count`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`__init__()`中我们引用了`A.count`（类属性），而不是`self.count`（这将是一个对象实例属性）。在`kids()`方法中，我们使用了`cls.count`，但我们也可以使用`A.count`。
- en: Static Methods
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态方法
- en: 'A third type of method in a class definition affects neither the class nor
    its objects; it’s just in there for convenience instead of floating around on
    its own. It’s a *static method*, preceded by a `@staticmethod` decorator, with
    no initial `self` or `cls` parameter. Here’s an example that serves as a commercial
    for the class `CoyoteWeapon`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义中的第三种方法既不影响类也不影响其对象；它只是为了方便而存在，而不是漂浮在自己周围。它是一个*静态方法*，前面有一个`@staticmethod`装饰器，没有初始的`self`或`cls`参数。以下是作为`CoyoteWeapon`类的商业广告的示例：
- en: '[PRE60]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Notice that we didn’t need to create an object from class `CoyoteWeapon` to
    access this method. Very class-y.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要从`CoyoteWeapon`类创建对象来访问此方法。非常“class-y”。
- en: Duck Typing
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鸭子类型
- en: Python has a loose implementation of *polymorphism*; it applies the same operation
    to different objects, based on the method’s name and arguments, regardless of
    their class.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Python对*多态性*有着宽松的实现；它根据方法的名称和参数，无论它们的类如何，都将相同的操作应用于不同的对象。
- en: 'Let’s use the same `__init__()` initializer for all three `Quote` classes now,
    but add two new functions:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为所有三个`Quote`类使用相同的`__init__()`初始化程序，但添加两个新函数：
- en: '`who()` just returns the value of the saved `person` string'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`who()`只返回保存的`person`字符串的值'
- en: '`says()` returns the saved `words` string with the specific punctuation'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`says()`返回具有特定标点符号的保存的`words`字符串'
- en: 'And here they are in action:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看它们的运作方式：
- en: '[PRE61]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We didn’t change how `QuestionQuote` or `ExclamationQuote` were initialized,
    so we didn’t override their `__init__()` methods. Python then automatically calls
    the `__init__()` method of the parent class `Quote` to store the instance variables
    `person` and `words`. That’s why we can access `self.words` in objects created
    from the subclasses `QuestionQuote` and `ExclamationQuote`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有改变`QuestionQuote`或`ExclamationQuote`的初始化方式，因此我们没有重写它们的`__init__()`方法。然后Python会自动调用父类`Quote`的`__init__()`方法来存储实例变量`person`和`words`。这就是为什么我们可以在从子类`QuestionQuote`和`ExclamationQuote`创建的对象中访问`self.words`的原因。
- en: 'Next up, let’s make some objects:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一些对象：
- en: '[PRE62]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Three different versions of the `says()` method provide different behavior
    for the three classes. This is traditional polymorphism in object-oriented languages.
    Python goes a little further and lets you run the `who()` and `says()` methods
    of *any* objects that have them. Let’s define a class called `BabblingBrook` that
    has no relation to our previous woodsy hunter and huntees (descendants of the
    `Quote` class):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`says()` 方法的三个不同版本为三个类提供了不同的行为。这是面向对象语言中的传统多态性。Python 更进一步，让你运行具有这些方法的 *任何*
    对象的 `who()` 和 `says()` 方法。让我们定义一个名为 `BabblingBrook` 的类，它与我们之前的树林猎人和被猎物（`Quote`
    类的后代）没有关系：'
- en: '[PRE65]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now run the `who()` and `says()` methods of various objects, one (`brook`)
    completely unrelated to the others:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行各种对象的 `who()` 和 `says()` 方法，其中一个（`brook`）与其他对象完全无关：
- en: '[PRE66]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This behavior is sometimes called *duck typing*, after the old saying:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 有时这种行为被称为 *鸭子类型*，来自一句古老的谚语：
- en: If it walks like a duck and quacks like a duck, it’s a duck.
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果它走起来像鸭子，叫起来像鸭子，那它就是鸭子。
- en: ''
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A Wise Person
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个聪明人
- en: Who are we to argue with a wise saying about ducks?
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否对鸭子的一句智慧的话提出异议？
- en: '![inp2 1001](assets/inp2_1001.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![inp2 1001](assets/inp2_1001.png)'
- en: Figure 10-1\. Duck typing is not hunt-and-peck
  id: totrans-260
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-1\. 鸭子类型并非按字母顺序寻找
- en: Magic Methods
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 魔术方法
- en: You can now create and use basic objects. What you’ll learn in this section
    might surprise you—in a good way.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以创建并使用基本对象了。你将在本节中学到的内容可能会让你感到惊讶——是一种好的方式。
- en: When you type something such as `a = 3 + 8`, how do the integer objects with
    values `3` and `8` know how to implement `+`? Or, if you type `name = "Daffy"
    + " " + "Duck"`, how does Python know that `+` now means to concatenate these
    strings? And how do `a` and `name` know how to use `=` to get the result? You
    can get at these operators by using Python’s *special methods* (or, more dramatically,
    *magic methods*).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当你键入诸如 `a = 3 + 8` 这样的内容时，整数对象如何知道如何实现 `+` 呢？或者，如果你键入 `name = "Daffy" + " "
    + "Duck"`，Python 如何知道 `+` 现在意味着将这些字符串连接起来？`a` 和 `name` 如何知道如何使用 `=` 来得到结果？你可以通过使用
    Python 的 *特殊方法*（或者更戏剧化地说，*魔术方法*）来解决这些运算符。
- en: 'The names of these methods begin and end with double underscores (`__`). Why?
    They’re very unlikely to have been chosen by programmers as variable names. You’ve
    already seen one: `__init__()` initializes a newly created object from its class
    definition and any arguments that were passed in. You’ve also seen ([“Name Mangling
    for Privacy”](#name_mangling)) how “dunder” naming helps to mangle class attribute
    names as well as methods.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法的名称以双下划线 (`__`) 开头和结尾。为什么呢？它们极不可能被程序员选为变量名。你已经见过一个：`__init__()` 从其类定义和传入的任何参数中初始化一个新创建的对象。你还见过（[“用于隐私的名称混淆”](#name_mangling)）“dunder”命名如何帮助混淆类属性名称以及方法。
- en: Suppose that you have a simple `Word` class, and you want an `equals()` method
    that compares two words but ignores case. That is, a `Word` containing the value
    `'ha'` would be considered equal to one containing `'HA'`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个简单的 `Word` 类，并且你想要一个 `equals()` 方法来比较两个单词但忽略大小写。也就是说，包含值 `'ha'` 的 `Word`
    将被视为等于包含 `'HA'` 的一个。
- en: 'The example that follows is a first attempt, with a normal method we’re calling
    `equals()`. `self.text` is the text string that this `Word` object contains, and
    the `equals()` method compares it with the text string of `word2` (another `Word`
    object):'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的示例是一个首次尝试，使用一个我们称之为 `equals()` 的普通方法。`self.text` 是这个 `Word` 对象包含的文本字符串，`equals()`
    方法将其与 `word2` 的文本字符串（另一个 `Word` 对象）进行比较：
- en: '[PRE67]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, make three `Word` objects from three different text strings:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从三个不同的文本字符串创建三个 `Word` 对象：
- en: '[PRE68]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'When strings `''ha''` and `''HA''` are compared to lowercase, they should be
    equal:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当字符串 `'ha'` 和 `'HA'` 与小写比较时，它们应该相等：
- en: '[PRE69]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'But the string `''eh''` will not match `''ha''`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 但字符串 `'eh'` 将不匹配 `'ha'`：
- en: '[PRE70]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We defined the method `equals()` to do this lowercase conversion and comparison.
    It would be nice to just say `if first == second`, just like Python’s built-in
    types. So, let’s do that. We change the `equals()` method to the special name
    `__eq__()` (you’ll see why in a moment):'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了方法 `equals()` 来进行这个小写转换和比较。只需说 `if first == second` 就好了，就像 Python 的内置类型一样。那么，我们就这样做吧。我们将
    `equals()` 方法更改为特殊名称 `__eq__()`（一会儿你就会明白为什么）：
- en: '[PRE71]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Let’s see whether it works:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是否奏效：
- en: '[PRE72]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Magic! All we needed was the Python’s special method name for testing equality,
    `__eq__()`. Tables [10-1](#magic_comparison_table) and [10-2](#magic_math_table)
    list the names of the most useful magic methods.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 太神奇了！我们只需要 Python 的特殊方法名称来测试相等性，`__eq__()`。表 [10-1](#magic_comparison_table)
    和 [10-2](#magic_math_table) 列出了最有用的魔术方法的名称。
- en: Table 10-1\. Magic methods for comparison
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Table 10-1\. 比较的魔术方法
- en: '| Method | Description |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `__eq__(` *self*, *other* `)` | *self* `==` *other* |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `__eq__(` *self*, *other* `)` | *self* `==` *other* |'
- en: '| `__ne__(` *self*, *other* `)` | *self* `!=` *other* |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `__ne__(` *self*, *other* `)` | *self* `!=` *other* |'
- en: '| `__lt__(` *self*, *other* `)` | *self* `<` *other* |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `__lt__(` *self*, *other* `)` | *self* `<` *other* |'
- en: '| `__gt__(` *self*, *other* `)` | *self* `>` *other* |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `__gt__(` *self*, *other* `)` | *self* `>` *other* |'
- en: '| `__le__(` *self*, *other* `)` | *self* `<=` *other* |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `__le__(` *self*, *other* `)` | *self* `<=` *other* |'
- en: '| `__ge__(` *self*, *other* `)` | *self* `>=` *other* |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| `__ge__(` *self*, *other* `)` | *self* `>=` *other* |'
- en: Table 10-2\. Magic methods for math
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Table 10-2\. 数学运算的魔术方法
- en: '| Method | Description |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `__add__(` *self*, *other* `)` | *self* `+` *other* |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `__add__(` *self*, *other* `)` | *self* `+` *other* |'
- en: '| `__sub__(` *self*, *other* `)` | *self* `–` *other* |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `__sub__(` *self*, *other* `)` | *self* `–` *other* |'
- en: '| `__mul__(` *self*, *other* `)` | *self* `*` *other* |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `__mul__(` *self*, *other* `)` | *self* `*` *other* |'
- en: '| `__floordiv__(` *self*, *other* `)` | *self* `//` *other* |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `__floordiv__(` *self*, *other* `)` | *self* `//` *other* |'
- en: '| `__truediv__(` *self*, *other* `)` | *self* `/` *other* |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `__truediv__(` *self*, *other* `)` | *self* `/` *other* |'
- en: '| `__mod__(` *self*, *other* `)` | *self* `%` *other* |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| `__mod__(` *self*, *other* `)` | *self* `%` *other* |'
- en: '| `__pow__(` *self*, *other* `)` | *self* `**` *other* |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| `__pow__(` *self*, *other* `)` | *self* `**` *other* |'
- en: You aren’t restricted to use the math operators such as `+` (magic method `__add__()`)
    and `–` (magic method `__sub__()`) with numbers. For instance, Python string objects
    use `+` for concatenation and `*` for duplication. There are many more, documented
    online at [Special method names](http://bit.ly/pydocs-smn). The most common among
    them are presented in [Table 10-3](#magic_other_table).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 您并不受限于使用数学运算符，如`+`（魔术方法`__add__()`）和`–`（魔术方法`__sub__()`）与数字。例如，Python字符串对象使用`+`进行连接和`*`进行复制。还有许多其他方法，在[特殊方法名称](http://bit.ly/pydocs-smn)中有详细记录。其中最常见的方法在[表 10-3](#magic_other_table)中呈现。
- en: Table 10-3\. Other, miscellaneous magic methods
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Table 10-3\. 其他杂项魔术方法
- en: '| Method | Description |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `__str__(` *self* `)` | `str(` *self* `)` |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| `__str__(` *self* `)` | `str(` *self* `)` |'
- en: '| `__repr__(` *self* `)` | `repr(` *self* `)` |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| `__repr__(` *self* `)` | `repr(` *self* `)` |'
- en: '| `__len__(` *self* `)` | `len(` *self* `)` |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| `__len__(` *self* `)` | `len(` *self* `)` |'
- en: 'Besides `__init__()`, you might find yourself using `__str__()` the most in
    your own methods. It’s how you print your object. It’s used by `print()`, `str()`,
    and the string formatters, which you can read about in [Chapter 5](ch05.html#ch_strings).
    The interactive interpreter uses the `__repr__()` function to echo variables to
    output. If you fail to define either `__str__()` or `__repr__()`, you get Python’s
    default string version of your object:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`__init__()`之外，您可能会发现自己在自己的方法中最常使用`__str__()`。这是您打印对象的方式。它被`print()`、`str()`和字符串格式化器使用，您可以在[第5章](ch05.html#ch_strings)中了解更多。交互式解释器使用`__repr__()`函数将变量回显到输出。如果您未定义`__str__()`或`__repr__()`中的任何一个，您将获得Python对象的默认字符串版本：
- en: '[PRE73]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Let’s add both `__str__()` and `__repr__()` methods to the `Word` class to
    make it prettier:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`Word`类添加`__str__()`和`__repr__()`方法，使其更加美观：
- en: '[PRE74]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: To explore even more special methods, check out the [Python documentation](http://bit.ly/pydocs-smn).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解更多特殊方法，请查看[Python文档](http://bit.ly/pydocs-smn)。
- en: Aggregation and Composition
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合与组合
- en: 'Inheritance is a good technique to use when you want a child class to act like
    its parent class most of the time (when child *is-a* parent). It’s tempting to
    build elaborate inheritance hierarchies, but sometimes *composition* or *aggregation*
    make more sense. What’s the difference? In composition, one thing is part of another.
    A duck *is-a* bird (inheritance), but *has-a* tail (composition). A tail is not
    a kind of duck, but part of a duck. In this next example, let’s make `bill` and
    `tail` objects and provide them to a new `duck` object:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是一种很好的技术，当你希望子类在大多数情况下像其父类一样时使用（当子类 *是一个* 父类）。在构建精细的继承层次时很诱人，但有时*组合*或*聚合*更有意义。它们的区别是什么？在组合中，一个东西是另一个东西的一部分。一只鸭子
    *是一个* 鸟（继承），但 *有一个* 尾巴（组合）。尾巴不是鸭子的一种，而是鸭子的一部分。在下面的例子中，让我们创建`bill`和`tail`对象，并将它们提供给一个新的`duck`对象：
- en: '[PRE75]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Aggregation expresses relationships, but is a little looser: one thing *uses*
    another, but both exist independently. A duck *uses* a lake, but one is not a
    part of the other.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合表达了关系，但要松散一些：一个东西 *使用* 另一个东西，但两者都是独立存在的。一只鸭子 *使用* 一片湖水，但它们并非彼此的一部分。
- en: When to Use Objects or Something Else
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象或其他东西何时使用
- en: 'Here are some guidelines for deciding whether to put your code and data in
    a class, module (discussion coming in [Chapter 11](ch11.html#ch_modules)), or
    something entirely different:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些指南，帮助你决定是否将代码和数据放入类、模块（在[第11章](ch11.html#ch_modules)中讨论）或其他某些地方：
- en: Objects are most useful when you need a number of individual instances that
    have similar behavior (methods), but differ in their internal states (attributes).
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要许多具有相似行为（方法）但在内部状态（属性）上不同的个体实例时，对象是最有用的。
- en: Classes support inheritance, modules don’t.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类支持继承，而模块不支持。
- en: 'If you want only one of something, a module might be best. No matter how many
    times a Python module is referenced in a program, only one copy is loaded. (Java
    and C++ programmers: you can use a Python module as a *singleton*.)'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果只需要一个东西，模块可能是最好的选择。无论在程序中引用多少次Python模块，只加载一个副本。（Java和C++程序员：你可以将Python模块用作*单例*。）
- en: If you have a number of variables that contain multiple values and can be passed
    as arguments to multiple functions, it might be better to define them as classes.
    For example, you might use a dictionary with keys such as `size` and `color` to
    represent a color image. You could create a different dictionary for each image
    in your program, and pass them as arguments to functions such as `scale()` or
    `transform()`. This can get messy as you add keys and functions. It’s more coherent
    to define an `Image` class with attributes `size` or `color` and methods `scale()`
    and `transform()`. Then, all the data and methods for a color image are defined
    in one place.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有多个变量，其中包含多个值并且可以作为多个函数的参数传递，那么将它们定义为类可能更好。例如，你可以使用一个带有`size`和`color`等键的字典来表示彩色图像。你可以为程序中的每个图像创建一个不同的字典，并将它们作为参数传递给`scale()`或`transform()`等函数。随着键和函数的增加，这可能会变得混乱。定义一个`Image`类更加一致，包含`size`或`color`属性以及`scale()`和`transform()`方法会更好。这样，所有与彩色图像相关的数据和方法都定义在同一个地方。
- en: Use the simplest solution to the problem. A dictionary, list, or tuple is simpler,
    smaller, and faster than a module, which is usually simpler than a class.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用问题的最简解决方案。字典、列表或元组比模块更简单、更小、更快，通常比类更简单。
- en: 'Guido’s advice:'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Guido的建议：
- en: Avoid overengineering datastructures. Tuples are better than objects (try namedtuple,
    too, though). Prefer simple fields over getter/setter functions…Built-in datatypes
    are your friends. Use more numbers, strings, tuples, lists, sets, dicts. Also
    check out the collections library, especially deque.
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 避免过度工程化的数据结构。元组比对象更好（尝试使用命名元组也是如此）。优先选择简单字段而不是getter/setter函数……内置数据类型是你的朋友。使用更多的数字、字符串、元组、列表、集合、字典。还要查看collections库，特别是deque。
- en: ''
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Guido van Rossum
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Guido van Rossum
- en: A newer alternative is the *dataclass*, in [“Dataclasses”](#dataclasses_ref).
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个更新的替代方案是*数据类*，在[“数据类”](#dataclasses_ref)中。
- en: Named Tuples
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名元组
- en: Because Guido just mentioned them and I haven’t yet, this is a good place to
    talk about *named tuples*. A named tuple is a subclass of tuples with which you
    can access values by name (with *`.name`*) as well as by position (with `[` *`offset`*
    `]`).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Guido刚提到它们，而我还没有，这是谈论*命名元组*的好地方。命名元组是元组的一个子类，可以通过名称（使用*`.name`*）以及位置（使用*`[偏移]`*）访问值。
- en: 'Let’s take the example from the previous section and convert the `Duck` class
    to a named tuple, with `bill` and `tail` as simple string attributes. We’ll call
    the `namedtuple` function with two arguments:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从上一节的示例中获取示例，并将`Duck`类转换为一个命名元组，其中`bill`和`tail`是简单的字符串属性。我们将调用`namedtuple`函数并传入两个参数：
- en: The name
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称
- en: A string of the field names, separated by spaces
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段名称的字符串，用空格分隔
- en: 'Named tuples are not automatically supplied with Python, so you need to load
    a module before using them. We do that in the first line of the following example:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Python不会自动提供命名元组，因此在使用它们之前需要加载一个模块。我们在以下示例的第一行中执行了这样的操作：
- en: '[PRE76]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'You can also make a named tuple from a dictionary:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从一个字典中创建一个命名元组：
- en: '[PRE77]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In the preceding code, take a look at `**parts`. This is a *keyword argument*.
    It extracts the keys and values from the `parts` dictionary and supplies them
    as arguments to `Duck()`. It has the same effect as:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，看看`**parts`。这是一个*关键字参数*。它从`parts`字典中提取键和值，并将它们作为参数提供给`Duck()`。它与以下代码具有相同的效果：
- en: '[PRE78]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Named tuples are immutable, but you can replace one or more fields and return
    another named tuple:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 命名元组是不可变的，但可以替换一个或多个字段并返回另一个命名元组：
- en: '[PRE79]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We could have defined `duck` as a dictionary:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以将`duck`定义为一个字典：
- en: '[PRE80]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'You can add fields to a dictionary:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向字典添加字段：
- en: '[PRE81]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'But not to a named tuple:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 但不是一个命名元组：
- en: '[PRE82]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'To recap, here are some of the pros of a named tuple:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，以下是命名元组的一些优点：
- en: It looks and acts like an immutable object.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它看起来和表现得像一个不可变对象。
- en: It is more space and time efficient than objects.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它比对象更省空间和时间。
- en: You can access attributes by using dot notation instead of dictionary-style
    square brackets.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用点符号而不是类似字典风格的方括号来访问属性。
- en: You can use it as a dictionary key.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将其用作字典键。
- en: Dataclasses
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类
- en: Many people like to create objects mainly to store data (as object attributes),
    not so much behavior (methods). You just saw how named tuples can be an alternative
    data store. Python 3.7 introduced *dataclasses*.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人喜欢创建对象主要用于存储数据（作为对象属性），而不是行为（方法）。刚才你看到命名元组可以作为替代数据存储的一种选择。Python 3.7引入了*数据类*。
- en: 'Here’s a plain old object with a single `name` attribute:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个普通的对象，只有一个名为`name`的属性：
- en: '[PRE83]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Doing the same with a dataclass looks a little different:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据类做同样的事情看起来有些不同：
- en: '[PRE84]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Besides needing a `@dataclass` decorator, you define the class’s attributes
    using [*variable annotations*](https://oreil.ly/NyGfE) of the form `*name*: *type*`
    or `*name*: *type* = *val*`, like `color: str` or `color: str = "red"`. The `*type*`
    can be any Python object type, including classes you’ve created, not just the
    built-in ones like `str` or `int`.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '除了需要一个`@dataclass`装饰器外，你还需要使用[*变量注释*](https://oreil.ly/NyGfE)的形式定义类的属性，如`*name*:
    *type*`或`*name*: *type* = *val*`，比如`color: str`或`color: str = "red"`。`*type*`可以是任何Python对象类型，包括你创建的类，而不仅限于像`str`或`int`这样的内置类型。'
- en: 'When you’re creating the dataclass object, you provide the arguments in the
    order in which they were specified in the class, or use named arguments in any
    order:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建数据类对象时，可以按照类中指定的顺序提供参数，或者以任意顺序使用命名参数：
- en: '[PRE85]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '`AnimalClass` defined a default value for its `teeth` attribute, so we didn’t
    need to provide it when making a `duck`.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnimalClass`为其`teeth`属性定义了默认值，因此在创建`duck`时无需提供它。'
- en: 'You can refer to the object attributes like any other object’s:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像访问任何其他对象一样引用对象属性：
- en: '[PRE86]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: There’s a lot more to dataclasses. See this [guide](https://oreil.ly/czTf-)
    or the official (heavy) [docs](https://oreil.ly/J19Yl).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类还有很多功能。参见这篇[指南](https://oreil.ly/czTf-)或官方（详尽的）[文档](https://oreil.ly/J19Yl)。
- en: Attrs
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: You’ve seen how to create classes and add attributes, and how they can involve
    a lot of typing—things like defining `__init__()`, assigning its arguments to
    `self` counterparts, and creating all those dunder methods like `__str__()`. Named
    tuples and dataclasses are alternatives in the standard library that may be easier
    when you mainly want to create a data collection.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到如何创建类并添加属性，以及它们可能涉及大量打字的事情，比如定义`__init__()`，将其参数分配给`self`的对应项，并创建所有这些dunder方法，如`__str__()`。命名元组和数据类是标准库中的替代品，当你主要想创建数据集时可能更容易。
- en: '[The One Python Library Everyone Needs](https://oreil.ly/QbbI1) compares plain
    classes, named tuples, and dataclasses. It recommends the third-party package
    [`attrs`](https://oreil.ly/Rdwlx) for many reasons—less typing, data validation,
    and more. Take a look and see whether you prefer it to the built-in solutions.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '[每个人都需要的一个Python库](https://oreil.ly/QbbI1)比较了普通类、命名元组和数据类。它推荐第三方包[`attrs`](https://oreil.ly/Rdwlx)，原因很多——少打字、数据验证等等。看一看，看看你是否喜欢它胜过内置解决方案。'
- en: Coming Up
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即将到来
- en: In the next chapter, you’ll step up a level in code structures to Python *modules*
    and *packages*.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将在代码结构中进一步提升到Python的*模块*和*包*。
- en: Things to Do
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要做的事情
- en: 10.1 Make a class called `Thing` with no contents and print it. Then, create
    an object called `example` from this class and also print it. Are the printed
    values the same or different?
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 10.1 创建一个名为`Thing`的类，不包含内容并打印它。然后，从这个类创建一个名为`example`的对象并打印它。打印的值是相同的还是不同的？
- en: 10.2 Make a new class called `Thing2` and assign the value `'abc'` to a class
    attribute called `letters`. Print `letters`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 10.2 创建一个名为`Thing2`的新类，并将值`'abc'`赋给名为`letters`的类属性。打印`letters`。
- en: 10.3 Make yet another class called, of course, `Thing3`. This time, assign the
    value `'xyz'` to an instance (object) attribute called `letters`. Print `letters`.
    Do you need to make an object from the class to do this?
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 10.3 再次创建一个名为`Thing3`的类，这次将值`'xyz'`赋给名为`letters`的实例（对象）属性。打印`letters`。你需要从该类创建一个对象吗？
- en: 10.4 Make a class called `Element`, with instance attributes `name`, `symbol`,
    and `number`. Create an object of this class with the values `'Hydrogen'`, `'H'`,
    and `1`.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 10.4 创建一个名为`Element`的类，具有实例属性`name`、`symbol`和`number`。使用值`'Hydrogen'`、`'H'`和`1`创建该类的一个对象。
- en: '10.5 Make a dictionary with these keys and values: `''name'': ''Hydrogen'',
    ''symbol'': ''H'', ''number'': 1`. Then, create an object called `hydrogen` from
    class `Element` using this dictionary.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '10.5 使用这些键和值创建一个字典：`''name'': ''Hydrogen'', ''symbol'': ''H'', ''number'':
    1`。然后，使用这个字典从`Element`类创建一个名为`hydrogen`的对象。'
- en: 10.6 For the `Element` class, define a method called `dump()` that prints the
    values of the object’s attributes (`name`, `symbol`, and `number`). Create the
    `hydrogen` object from this new definition and use `dump()` to print its attributes.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 10.6 对于`Element`类，定义一个名为`dump()`的方法，打印对象属性（`name`、`symbol`和`number`）的值。使用这个新定义创建`hydrogen`对象，并使用`dump()`打印其属性。
- en: 10.7 Call `print(hydrogen)`. In the definition of `Element`, change the name
    of the method `dump` to `__str__`, create a new `hydrogen` object, and call `print(hydrogen)`
    again.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 10.7 调用`print(hydrogen)`。在`Element`的定义中，将方法`dump`的名称更改为`__str__`，创建一个新的`hydrogen`对象，并再次调用`print(hydrogen)`。
- en: 10.8 Modify `Element` to make the attributes `name`, `symbol`, and `number`
    private. Define a getter property for each to return its value.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 10.8 修改`Element`使属性`name`、`symbol`和`number`变为私有。为每个属性定义一个getter属性来返回其值。
- en: '10.9 Define three classes: `Bear`, `Rabbit`, and `Octothorpe`. For each, define
    only one method: `eats()`. This should return `''berries''` (`Bear`), `''clover''`
    (`Rabbit`), or `''campers''` (`Octothorpe`). Create one object from each and print
    what it eats.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 10.9 定义三个类：`Bear`、`Rabbit`和`Octothorpe`。对于每个类，只定义一个方法：`eats()`。这应该返回`'berries'`（`Bear`）、`'clover'`（`Rabbit`）或`'campers'`（`Octothorpe`）。分别创建一个对象并打印它们吃的是什么。
- en: '10.10 Define these classes: `Laser`, `Claw`, and `SmartPhone`. Each has only
    one method: `does()`. This returns `''disintegrate''` (`Laser`), `''crush''` (`Claw`),
    or `''ring''` (`SmartPhone`). Then, define the class `Robot` that has one instance
    (object) of each of these. Define a `does()` method for the `Robot` that prints
    what its component objects do.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 10.10 定义这些类：`Laser`、`Claw`和`SmartPhone`。每个类只有一个方法：`does()`。它返回`'disintegrate'`（`Laser`）、`'crush'`（`Claw`）或`'ring'`（`SmartPhone`）。然后，定义一个名为`Robot`的类，其中包含每个组件对象的一个实例。为`Robot`定义一个`does()`方法，打印其组件对象的功能。
- en: ^([1](ch10.html#idm45794999331256-marker)) Or even if you don’t want to.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch10.html#idm45794999331256-marker)) 即使你不想。
- en: ^([2](ch10.html#idm45794999026920-marker)) You’ll see many examples of double
    underscores in Python names; to save syllables, some people pronounce them as
    *dunder*.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch10.html#idm45794999026920-marker)) Python 中的命名经常会看到双下划线的例子；为了节省音节，有些人将其发音为*dunder*。
- en: ^([3](ch10.html#idm45794998829960-marker)) An inexpensive but not-so-good car
    from the ’80s.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch10.html#idm45794998829960-marker)) 一个80年代的便宜但不怎么样的汽车。
- en: ^([4](ch10.html#idm45794997899784-marker)) A mule has a father donkey and mother
    horse; a hinny has a father horse and mother donkey.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch10.html#idm45794997899784-marker)) 骡马的父亲是驴，母亲是马；小母驴的父亲是马，母亲是驴。
- en: ^([5](ch10.html#idm45794996488440-marker)) Can you keep a secret? Apparently,
    I can’t.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch10.html#idm45794996488440-marker)) 你能保守秘密吗？显然，我不能。
