- en: 'Chapter 10\. User-Defined Types: Classes'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 用户定义类型：类
- en: Classes will be the final user-defined type that I’ll cover in this book. Many
    developers learn classes early, and this is both a boon and a bane. Classes are
    used in many frameworks and codebases, so it pays off to be fluent in class design.
    However, when developers learn classes too early, they miss the nuance of when
    and, more importantly, when not to use them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 类将是本书中我将介绍的最终用户定义类型。许多开发者很早就学习了类，这既是一个利好又是一个诅咒。类被用在许多框架和代码库中，因此精通类设计是值得的。然而，当开发者过早学习类时，他们会错过何时以及更重要的是何时不应该使用它们的微妙之处。
- en: Think back to your use of classes. Could you represent that data as a `dataclass`
    instead? What about a set of free functions? I’ve seen too many codebases that
    use classes everywhere when they really shouldn’t, and maintainability suffers
    because of it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下你使用类的情况。你能把那些数据表示为一个`dataclass`吗？或者用一组自由函数？我见过太多到处都使用类的代码库，当然他们真的不应该这样做，因此可维护性因此受到影响。
- en: 'However, I’ve also come across codebases that swing the pendulum the other
    way: using no classes at all. This also affects maintainability; it is easy to
    break assumptions and have inconsistent data throughout. In Python, you should
    strive for a balance. Classes have a place in your codebase, but it is important
    to recognize their strengths and weaknesses. It’s time to really dig deep, cast
    aside your preconceptions, and learn how classes help you make more robust code.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我也遇到过完全不使用类的代码库。这也会影响可维护性；很容易打破假设，并且在整个代码中有不一致的数据。在Python中，你应该追求一种平衡。类在你的代码库中有其位置，但是认识到它们的优点和缺点是很重要的。是时候深入挖掘，抛开你的成见，学习类如何帮助你编写更加健壮的代码了。
- en: Class Anatomy
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类的解剖
- en: 'Classes are intended to be another way of grouping related data together. They
    have decades of history in the object-oriented paradigm and, at first glance,
    don’t differ that much from what you learned about data classes. In fact, you
    can write a class just like you wrote a `dataclass`:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 类被设计为另一种将相关数据组合在一起的方式。它们在面向对象范式中有几十年的历史，并且乍看之下与你对数据类学到的东西并没有太大的不同。事实上，你可以像写`dataclass`一样写一个类：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Looking at the code above, you could easily write it a different way with a
    `dict` or `dataclass`:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 看着上面的代码，你可能可以用一个`dict`或`dataclass`以不同的方式编写它：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In [Chapter 9](part0013_split_000.html#dataclasses), you learned the advantages
    of data classes over raw dictionaries, and classes offer many of the same benefits.
    But you might (rightly) wonder why you would ever use a class instead of a data
    class again?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](part0013_split_000.html#dataclasses)中，你了解了数据类相对于原始字典的优势，而类提供了许多相同的好处。但你可能会（理所当然地）想知道，为什么你会再次使用类而不是数据类呢？
- en: In fact, given the flexibility and convenvenience of data classes, classes might
    feel inferior. You don’t get the fancy features like `frozen` or `ordered`. You
    don’t get built-in string methods. Why, you can’t even instantiate a `Person`
    as nicely as with data classes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，考虑到数据类的灵活性和便利性，类可能会感觉不如其优。你得不到像`frozen`或`ordered`这样的高级特性。你得不到内置的字符串方法。为什么呢，你甚至不能像使用数据类那样优雅地实例化一个`Person`。
- en: 'Try to do something like:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试像这样做：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When trying this with a class, you’ll be immediately greeted with an error:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试使用类时，你会立即遇到错误：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That’s really frustrating, at first glance. However, this design decision is
    intentional. You need to explicitly define how a class gets constructed, which
    is done through a special method called a *constructor*. It may seem like a drawback
    compared to data classes, but it allows you to have more fine-grained control
    over the fields in your class. The next few sections will describe how you can
    use this control to your benefit. First, let’s look at what the constructor of
    a class actually provides you.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 乍看起来，这真的很令人沮丧。然而，这种设计决策是有意的。你需要明确地定义类如何被构建，这通过一个称为*构造函数*的特殊方法完成。与数据类相比，这可能看起来像是一个缺点，但它允许你对类中的字段有更精细的控制。接下来的几节将描述如何利用这种控制带来好处。首先，让我们看看类的构造函数实际上为你提供了什么。
- en: Constructors
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'A constructor describes how to initialize your class. You define a constructor
    with an `__init__` method:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数描述了如何初始化你的类。你使用一个`__init__`方法来定义构造函数：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that I tweaked the class a bit. Instead of defining the variables like
    I did in a `dataclass`, I am defining all the variables in a constructor. The
    constructor is a special method that gets called when class is instantiated. It
    takes arguments needed to define your user data type, as well as a special argument
    called `self`. The specific name for this parameter is arbitrary, but you’ll see
    most code use `self` as the convention. Each time you instantiate a class, the
    `self` argument refers to that specific instance; one instance’s attributes won’t
    conflict with another instance’s attributes, even though they are the same class.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我稍微调整了类。与我在`dataclass`中定义变量的方式不同，我在构造函数中定义了所有变量。构造函数是在实例化类时调用的特殊方法。它接受定义用户数据类型所需的参数，以及一个称为`self`的特殊参数。这个参数的具体名称是任意的，但你会看到大多数代码都使用`self`作为约定。每次实例化一个类时，`self`参数都指向该特定实例；一个实例的属性不会与另一个实例的属性冲突，即使它们是相同的类。
- en: 'So why would you ever write a class? Dictionaries or data classes are simpler
    to write and involve less ceremony. For something like the `Person` object listed
    earlier, I don’t disagree. However, a class can convey one key thing that a dictionary
    or data class can’t easily convey: *invariants*.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么您会编写一个类呢？字典或数据类更简单，涉及的仪式更少。对于之前列出的`Person`对象这样的东西，我并不反对。然而，类可以传达字典或数据类无法轻松传达的一个关键点：*不变量*。
- en: Invariants
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不变量
- en: 'An invariant is a property of an entity that remains unchanged throughout the
    lifetime of that entity. Invariants are the concepts that hold true about your
    code. Readers and writers of code will reason about your code and depend upon
    that reasoning to keep everything straight. Invariants are the building blocks
    for understanding your codebase. Here are some examples of invariants:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 不变量是实体的一个在其生命周期内保持不变的属性。不变量是关于您的代码的真实概念。代码的读者和编写者将推理您的代码，并依赖于这种推理来保持一切顺利。不变量是理解您的代码库的基础。以下是一些不变量的示例：
- en: Every employee has a unique ID; no two employee IDs are duplicated.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个员工都有一个唯一的ID；没有两个员工ID是重复的。
- en: Enemies in a game may only take actions if their health points are above zero.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏中的敌人只有在其健康点数高于零时才能采取行动。
- en: Circles may only have a positive radius.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圆形可能只有正半径。
- en: Pizzas will always have cheese on top of sauce.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个披萨上都会有酱料上面的奶酪。
- en: Invariants convey immutable properties of objects. They can reflect mathematical
    properties, business rules, coordination guarantees, or anything else you want
    to hold true. Invariants do not have to mirror the real world; they just have
    to be true for *your* system. For instance, Chicago-style deep-dish pizza aficionados
    may disagree with that last pizza-related bullet, but if your system only handles
    cheese-on-sauce pizzas, it’s OK to encode that as an invariant. The invariant
    only refers to a specific entity, too. You get to decide the scope of the invariant,
    whether it is true across your system, or whether it only applies to a specific
    program, module, or class. This chapter will focus on classes and their role in
    *preserving* invariants.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 不变量传达对象的不可变属性。它们可以反映数学属性、业务规则、协调保证或任何您希望保持真实的东西。不变量不必反映现实世界；它们只需要在*您的*系统中为真即可。例如，芝加哥风格的深盘披萨爱好者可能不同意最后一个与披萨有关的条款，但如果您的系统只处理奶酪-酱披萨，将其编码为不变量就可以了。不变量只涉及特定的实体。您可以决定不变量的范围，无论它是否适用于整个系统，或者它是否仅适用于特定的程序、模块或类。本章将重点介绍类及其在*保持*不变量方面的作用。
- en: So, how does a class help convey invariants? Let’s start with the constructor.
    You can put in safeguards and assertions to check that an invariant is satisfied,
    and from that point on, a user of that class should be able to depend on that
    invariant being true for the lifetime of the class. Let’s see how.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，类如何帮助传达不变量呢？让我们从构造函数开始。您可以添加保护和断言来检查不变量是否满足，并且从那时起，该类的用户应该能够依赖于该不变量在类的生命周期内始终为真。让我们看看如何做到这一点。
- en: Consider an imaginary automated pizza maker that makes a perfect pizza every
    time. It will take dough, roll it into a circle, apply sauce and toppings, and
    then bake the pizza. I will list out some invariants that I want to preserve in
    my system (these invariants are not universally true about all pizzas in the world,
    just true for the pizzas I want to create).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个想象中的自动披萨制造机，每次都能制作完美的披萨。它会拿面团，擀成圆形，涂抹酱料和配料，然后烤披萨。我将列出一些我希望在系统中保留的不变量（这些不变量并不适用于世界上所有披萨，仅适用于我想要创建的披萨）。
- en: 'I want the following to hold true for the lifetime of the pizza:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望以下内容在披萨的整个生命周期内都成立：
- en: Sauce will never be put on top of toppings (cheese is a topping in this scenario).
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 酱料永远不会被放在配料（在这种情况下，奶酪是一种配料）的上面。
- en: Toppings may go above or below cheese.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配料可以放在奶酪的上面或下面。
- en: Pizza will have at most only one sauce.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 披萨最多只会有一种酱料。
- en: Dough radius can be only whole numbers.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面团半径只能是整数。
- en: The radius of dough may be only between 6 and 12 inches, inclusive (between
    15 and 30 centimeters).
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面团的半径可能只能在6到12英寸之间，包括端点（15到30厘米之间）。
- en: Some of these might be for business reasons, some might be for health reasons,
    and some might be just limitations of machinery, but every one of these is intended
    to be true for the lifetime of that pizza. I’ll check for these invariants during
    construction of the pizza.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规定可能是出于业务原因，也可能是出于健康原因，还可能只是机器的限制，但每一个都意味着在其生命周期内都应该成立。我会在披萨构建过程中检查这些不变性。
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s break down this invariant checking:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来详细讨论一下这个不变性检查：
- en: '`dough_radius_in_inches` is an integer. This doesn’t stop callers from passing
    floats/strings/whatever into the constructor, but if used in conjunction with
    a typechecker (like those you used in [Part I](part0004.html#part_1)), you can
    detect when callers pass the wrong type. If you aren’t using a typechecker, you
    would have to do an `isinstance()` check (or something similar) instead.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dough_radius_in_inches` 是一个整数。这并不会阻止调用者将浮点数/字符串/其他内容传递给构造函数，但如果与类型检查器一起使用（就像你在[第一部分](part0004.html#part_1)中使用的那些），你可以检测到调用者传递错误类型的情况。如果你没有使用类型检查器，你将不得不使用`isinstance()`检查（或类似的东西）。'
- en: This code asserts that the dough radius is between 6 and 12 inches (inclusive).
    If this is not the case, an `AssertionError` is thrown (preventing construction
    of the class).
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此代码断言面团半径在6到12英寸（包括端点）之间。如果不是这样，将抛出`AssertionError`（阻止类的构造）。
- en: This code asserts that there is at most one sauce, throwing an `AssertionError`
    if that does not hold true.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码断言最多只有一种酱料，如果不成立，则抛出`AssertionError`。
- en: This code ensures that the sauce is at the beginning of our toppings list (presumably
    this will be used to tell the pizza maker in what order to lay toppings down).
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码确保酱料位于我们配料列表的开头（可以推断这将用于告诉披萨制作者应该以什么顺序放置配料）。
- en: Note that I don’t explicitly do anything to preserve that toppings can be above
    or below cheese. This is because the default behavior of the implementation satisfies
    the invariant. However, you may still choose to communicate the invariant to your
    callers through documentation.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，我并没有明确采取任何措施来保持配料可以放在奶酪的上面或下面。这是因为实现的默认行为满足了不变性。然而，你仍然可以通过文档向调用者传达这个不变性。
- en: Avoiding Broken Invariants
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免破坏不变性
- en: It is incredibly important that you never, ever construct this class if the
    invariants would be broken. You have two avenues that you can choose if the caller
    ever constructs an object in a way such that invariants would be broken.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果违反不变性，千万不要构造这个类。如果调用者以违反不变性的方式构造对象，你有两个选择。
- en: Throw an exception
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出异常
- en: This prevents the object from being constructed. This is what I did when making
    sure the dough radius was appropriate and that I had at most one sauce.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这阻止了对象的构造。这是我在确保面团半径合适并且最多只有一种酱料时所做的。
- en: Massage the data
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对数据进行调整
- en: Make the data conform to the invariant. I could have thrown an exception when
    I didn’t get toppings in the right order, but instead, I rearranged them to satisfy
    the invariant.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使数据符合不变性。当我没有按照正确的顺序获取配料时，我本可以抛出异常，但我选择重新排列它们以满足不变性。
- en: Why Are Invariants Beneficial?
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不变性有什么好处？
- en: 'It is a lot of work to write a class and come up with invariants. But I want
    you to consciously think about invariants every time you group some data together.
    Ask yourself:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 编写类和确定不变性是一项很大的工作。但我希望你在每次将一些数据组合在一起时都能有意识地思考不变性。问问自己：
- en: Should any of this data be restricted in any form that I can’t catch through
    the type system (such as the order of toppings)?
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有任何数据以任何我无法通过类型系统捕捉到的形式受限（比如配料的顺序）？
- en: Are some fields interdependent (i.e., changing one field may necessitate a change
    in another field)?
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些字段是否相互依赖（例如，改变一个字段可能需要改变另一个字段）？
- en: Are there guarantees I want to provide about the data?
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我是否有什么数据保证？
- en: 'If you answer yes to any of these questions, you have invariants you want to
    preserve and should write a class. When you choose to write a class and define
    a set of invariants, you’re doing a few things:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对以下任何问题回答“是”，你有想要保留的不变量，并且应该编写一个类。当你选择编写一个类并定义一组不变量时，你做了几件事：
- en: You’re adhering to the Don’t Repeat Yourself (DRY) principle.^([1](part0014_split_014.html#idm45644740381352))
    Instead of littering your code with checks before object construction, you put
    those checks in one place.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你遵循了不重复自己（DRY）的原则。^([1](part0014_split_014.html#idm45644740381352))而不是在对象构建之前在你的代码中散落检查，你把这些检查放在一个地方。
- en: You’re putting more work on the writer to ease the work of the reader/maintainer/caller.
    Your code will most likely live longer than you work on it. By providing an invariant
    (and communicating it well—see the next section), you lessen the burden of those
    who come after you.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你让编写者更费力，以减轻读者/维护者/调用者的工作。你的代码很可能会比你工作的时间更长。通过提供不变量（并且很好地沟通它们—参见下一节），你减轻了那些继你之后者的负担。
- en: You’re more effectively able to reason about code. There’s a reason why languages
    like [Ada](https://www.adacore.com/about-ada) and concepts like formal proofs
    are used in mission-critical environments. They provide developers with comfort;
    other coders can trust your code to a certain degree.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能更有效地推理代码。有一个原因，为什么像[Ada](https://www.adacore.com/about-ada)这样的语言和形式证明这样的概念被用于关键任务环境中。它们给开发人员提供了一定程度的信任；其他程序员可以在一定程度上信任你的代码。
- en: All of this leads to fewer bugs. You’re not running the risk of people misconstructing
    objects or missing a required check. You’re making an easier API for people to
    think about, and you reduce the risk of people using your objects incorrectly.
    You will also adhere closer to the Law of Least Surprise. You never want someone
    to be surprised when using your code (how many times have you heard the phrase,
    “Wait, *that’s* how the class works?”). By defining invariants and sticking to
    them, there is less chance for someone to be surprised.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都导致了更少的错误。你不会冒人们构建对象不正确或遗漏必需检查的风险。你正在为人们思考提供更简单的 API，并减少人们错误使用你的对象的风险。你还将更接近最小惊讶法则。你绝不希望在使用你的代码时让人感到惊讶（你听过多少次这样的说法：“等等，*这*就是类的工作方式？”）。通过定义不变量并坚持它们，减少了某人感到惊讶的机会。
- en: A dictionary simply cannot do that.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字典根本无法做到这一点。
- en: 'Consider a pizza specification represented by a dictionary:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个由字典表示的比萨规范：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There is no simple way for you to force a user to construct this dictionary
    correctly. You would have to rely on callers doing the right thing in every invocation
    (which will only become more difficult as the codebase grows). There is also no
    way to prevent users from modifying the dictionary freely and breaking invariants.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 没有简单的方法可以强制用户正确构建这个字典。你必须依赖调用者在每次调用中都做正确的事情（随着代码库的增长，这将变得更加困难）。也没有办法阻止用户自由修改字典并破坏不变量。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注：
- en: It’s true, you could define methods that construct dictionaries after checking
    invariants, and only mutate the dictionary through functions that also check invariants.
    Or, you could certainly write a constructor and invariant-checking methods on
    data classes. But if you go through all that trouble, why not write a class? Be
    mindful of what your choices communicate to future maintainers. You must be deliberate
    between your choice of dictionaries, data classes and classes. Each of these abstractions
    conveys a very specific meaning, and if you choose the wrong one, you’ll confuse
    maintainers.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在检查不变量后定义构造字典的方法，并且只通过同时检查不变量的函数改变字典。或者，你当然可以在数据类上编写构造函数和检查不变量的方法。但如果你为此付出了所有的努力，为什么不写一个类呢？要注意你的选择对未来的维护者意味着什么。你必须在字典、数据类和类之间做出明智的选择。每种抽象都传达了一种非常具体的含义，如果你选择错误，你将会使维护者困惑不解。
- en: 'There’s another benefit that I haven’t talked about, and it relates to the
    “S” in SOLID (see the next sidebar): the Single Responsibility Principle. The
    Single Responsibility Principle states that each object “should have one and only
    one reason to change.”^([2](part0014_split_014.html#idm45644740365960)) It sounds
    simple, but in practice it can be a struggle to know exactly how granular *one*
    reason to change is. My suggestion to you is to define a set of related invariants
    (such as your dough and toppings) and write a class per set of related invariants.
    If you ever find yourself writing attributes or methods that do not directly relate
    to one of those invariants, your class has low *cohesion*, which means it has
    too many responsibilities.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个好处，我还没有谈论过，它与“S”中的 SOLID 原则相关（请参见下一个侧栏）：单一职责原则。单一职责原则指出每个对象“应该有且仅有一个改变的理由。”^([2](part0014_split_014.html#idm45644740365960))
    这听起来很简单，但在实践中确切地知道什么是 *一个* 改变的理由可能会很困难。我建议你定义一组相关的不变量（例如你的面团和配料）并为每组相关的不变量编写一个类。如果你发现自己在编写与这些不变量无直接关系的属性或方法，那么你的类的
    *内聚性* 较低，这意味着它承担了太多的责任。
- en: Discussion Topic
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论话题
- en: Consider some of the most important parts of your codebase. What invariants
    are true about that system? How well are these invariants enforced, such that
    developers cannot break them?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑你代码库中最重要的部分。关于该系统有哪些不变量是真实的？这些不变量被多么有效地强制执行，以至于开发者无法打破它们？
- en: Communicating Invariants
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传达不变量
- en: 'Now, you can’t realize these benefits unless you can effectively communicate
    them. Nobody can reason about invariants that they don’t know about. So, how do
    you do that? Well, with any communication, you should consider your audience.
    You have two types of people with two different use cases:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，除非你能有效地传达这些好处，否则无法实现这些好处。没有人可以推理出他们不知道的不变量。那么，你该怎么做呢？嗯，对于任何沟通，你都应考虑你的观众。你有两种类型的人，有两种不同的用例：
- en: Consumers of the class
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 类的消费者
- en: These are people who are trying to solve their own problems and are looking
    for tools to help them. They may be trying to debug an issue or find a class in
    a codebase that helps them out.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些人试图解决自己的问题，并寻找帮助他们的工具。他们可能正在调试问题或查找代码库中能帮助他们的类。
- en: Future maintainers of the class
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 类的未来维护者
- en: People will add onto your class, and it’s important that they do not break invariants
    that all your callers have come to depend on.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 人们将会扩展你的类，重要的是他们不要破坏所有调用者都依赖的不变量。
- en: You will need to keep both in mind when desigining your classes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计你的类时，你需要同时考虑这两者。
- en: Consuming Your Class
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用你的类
- en: First, consumers of your class will typically look at your source code to see
    how it works and if it meets their needs. Putting assertion statements (or raising
    other exceptions) in the constructor is a great way to tell a user what is and
    isn’t possible with your class. A constructor is typically the first place a developer
    will look (after all, if they can’t instantiate your class, how can they use it?).
    For invariants that you cannot represent in code (yes, those exist), you want
    to document that in whatever your users use for API reference. The closer to the
    code your documentation is, the more likely a user will find it when looking at
    your code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你的类的消费者通常会查看你的源代码，以了解其工作原理及是否符合他们的需求。在构造函数中放置断言语句（或引发其他异常）是告诉用户关于你的类可做和不可做的好方法。通常开发者会首先查看构造函数（毕竟，如果他们不能实例化你的类，那么如何使用它呢？）。对于在代码中无法表示的不变量（是的，这些存在），你需要在用户用于
    API 参考的任何文档中记录它们。文档距离代码越近，用户在查看代码时找到它的可能性就越大。
- en: Knowledge in one’s head is not scalable or discoverable. Wikis and/or documentation
    portals are a decent step, but often are better suited for larger scale ideas
    that don’t go out of date as quickly. A README in the code repository is a better
    step, but the true best place is a comment or docstring with the class itself.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 头脑中的知识不具备可扩展性或可发现性。Wiki 和/或文档门户是一个不错的步骤，但通常更适合大规模的想法，不容易过时。代码库中的 README 是一个更好的步骤，但真正最佳的地方是与类本身的注释或文档字符串。
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: I’ve had a bit of a contentious relationship with comments throughout my career.
    In the beginning, I would comment everything, probably because my university professors
    required it. A few years later, the pendulum swung too far in the other direction,
    and I was one to espouse “code shall be self-documenting,” meaning that the code
    should be able to stand on its own. After all, comments could go out of date and,
    as the common saying goes, “a wrong comment is worse than no comment.” The pendulum
    has since shifted back and I’ve learned that code should absolutely self-document
    *what* it’s doing (this is just another spin on the Law of Least Surprise), but
    comments help the human nature of code. Most people simplify this to *why* the
    code behaves it does, but sometimes that is vague. In the snippet above, I go
    about it by documenting my invariants (including ones not apparent in code), and
    backing it up with business reasons. This way, a consumer can ascertain what the
    class is and isn’t used for, as well as whether the class fits into their intended
    use case.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的职业生涯中，我对注释有些争议。起初，我会注释一切，可能是因为我的大学教授要求如此。几年后，情况完全反转，我主张“代码应该自说明”，意味着代码应该能够自给自足。毕竟，注释可能会过时，俗话说得好，“错误的注释比没有注释还糟糕”。现在情况已经改变，我学到了代码绝对应该自我记录*做什么*（这只是最小惊讶法则的另一种体现），但注释有助于理解代码的人性化特征。大多数人简化为*为什么*代码行为如此，但有时这样说还是有些含糊。在上面的片段中，我通过记录我的不变量（包括代码中未显式的不变量），并用业务原因加以支持来进行注释。这样，消费者可以确定类的用途和不用途，以及该类是否适合他们的预期用例。
- en: What About Maintainers?
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于维护者怎么样？
- en: You will have to deal with the other group, the future maintainers of your code,
    differently. This is a tricky one. You have a comment that helps define your constraints,
    but that won’t prevent inadvertent changing of invariants. Changing invariants
    is a delicate thing. People will come to depend on these invariants, even if they
    aren’t reflected in function signatures or type systems. If somebody changes an
    invariant, every consumer of the class could be affected (sometimes this is inevitable,
    but be aware of the cost).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您将不得不与另一组人打交道，即您代码的未来维护者。这是一个棘手的问题。您有一个帮助定义约束的注释，但这不会阻止无意中更改不变量。更改不变量是一件微妙的事情。人们会依赖这些不变量，即使它们不反映在函数签名或类型系统中。如果有人更改了一个不变量，每个类的使用者都可能受到影响（有时这是不可避免的，但要意识到成本）。
- en: 'To help catch this, I’ll lean on an old friend as a safety net—unit tests.
    Unit tests are snippets of code that will automatically test your own classes
    and functions. (For more discussion on unit tests, check out [Chapter 21](part0027_split_000.html#testing_strategy).)
    You should absolutely write unit tests around your expectations and invariants,
    but there’s one additional facet I’d like you to consider: help future test writers
    know when invariants are broken as well. I like to do this with the help of a
    context manager—a construct in Python that forces code to run when a `with` block
    is exited (if you’re not familiar with context managers, you’ll learn more in
    [Chapter 11](part0015_split_000.html#api)):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助捕捉这一点，我将依靠一个老朋友作为安全网——单元测试。单元测试是一小段代码，将自动测试您自己的类和函数。（有关单元测试的更多讨论，请查看[第21章](part0027_split_000.html#testing_strategy)。）您绝对应该围绕您的期望和不变量编写单元测试，但我希望您考虑另一个方面：帮助未来的测试编写者知道何时破坏了不变量。我喜欢借助上下文管理器来做到这一点——这是Python中的一种结构，在退出`with`块时强制运行代码（如果您对上下文管理器不熟悉，您可以在[第11章](part0015_split_000.html#api)中了解更多）：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The beauty of using a context manager like this is that every invariant can
    be checked as a postcondition of the test. This feels like duplication and direct
    violation of the DRY principle, but in this case, it’s warranted. Unit tests are
    a form of double-entry bookkeeping, and you want them to find errors when one
    side erroneously changes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种上下文管理器的美妙之处在于，可以将每个不变量作为测试的后置条件进行检查。这感觉像是重复和直接违反了DRY原则，但在这种情况下，这是合理的。单元测试是一种双入账簿记，您希望它们在一方错误更改时发现错误。
- en: Encapsulation and Maintaining Invariants
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装和维护不变量
- en: I have a little secret for you. I wasn’t completely honest in the last section.
    I know, I know, shame on me, and I’m sure the eagle-eyed readers have already
    spotted my deception.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个小秘密告诉你。我在上一节中并不完全诚实。我知道，我知道，我真是羞愧，我相信眼尖的读者早已发现了我的欺骗。
- en: 'Consider this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Nothing at all is preventing a future developer from changing some invariants
    after the fact.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何东西可以阻止未来的开发者在事后改变一些不变量。
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'What was the point of talking about invariants if any developer can immediately
    invalidate them? Well, it turns out that I have another concept to discuss: *encapsulation*.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何开发者可以立即使它们失效，那谈论不变量的意义是什么呢？嗯，事实证明我有另一个概念要讨论：*封装*。
- en: Encapsul-what, Now?
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装是什么鬼？
- en: Encapsulation. Simply put, it’s the ability for an entity to hide properties
    and the actions that operate upon those properties. Practically speaking, it means
    that you decide what properties are visible to callers, and restrict how they
    can access them and/or change data. This is accomplished using an *application
    programming interface* (API).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 封装。简单来说，它是一个实体隐藏属性及其操作的能力。从实际角度来看，这意味着你决定哪些属性对调用者可见，并限制他们如何访问和/或更改数据。这是通过应用程序编程接口（API）来实现的。
- en: When most people think of an API, things like REST or SDKs (software development
    kits) come to mind. But every class has its own API. It’s the cornerstone of how
    you interact with classes. Every function call, every property access, every initialization
    is part of an object’s API.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当大多数人想到 API 时，他们会想到 REST 或 SDK（软件开发工具包）。但每个类都有自己的 API。这是你与类交互的基石。每个函数调用，每个属性访问，每个初始化都是对象
    API 的一部分。
- en: 'So far, I’ve covered two parts of the API in the `PizzaSpecification`: the
    initialization (constructor) and property access. I don’t have much more to say
    about the constructor; its done its job in verifying invariants. Now, I will address
    how to preserve those invariants as you flesh out the rest of an API (the operations
    that we wish to bundle with this class).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我在`PizzaSpecification`中已经涵盖了 API 的两个部分：初始化（构造函数）和属性访问。我对构造函数没有更多的话要说；它在验证不变量方面已经做了它的工作。现在，我将讨论如何在你拓展
    API 的其余部分时保持这些不变量。
- en: Protecting Data Access
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护数据访问
- en: 'That leads us back to the problem at the beginning of this section: how do
    we prevent users of our API (our class) from breaking invariants? By signaling
    that this data should be *private*.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这把我们带回到本节开头的问题：我们如何防止我们 API 的用户（我们的类）破坏不变量？通过表明这些数据应该是*私有*的。
- en: 'There are three types of access control in many programming languages:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言中有三种类型的访问控制：
- en: Public
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 公共
- en: Any other piece of code can access this part of the API.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 任何其他代码可以访问 API 的这部分。
- en: Protected
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的
- en: Only subclasses (we’ll see these more in [Chapter 12](part0016_split_000.html#subtyping))
    should access this part of the API.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 只有子类（我们将在[第12章](part0016_split_000.html#subtyping)中详细了解）应该访问 API 的这部分。
- en: Private
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 私有
- en: Only this class (and any other instances of this class) should access this part
    of the API.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 只有这个类（以及该类的任何其他实例）应该访问 API 的这部分。
- en: Public and protected attributes form your public API, and should be relatively
    stable before people depend on your class heavily. However, it is a general convention
    that people should leave your private API alone. This should leave you free to
    hide things that you feel need to be inaccessible. This is how you can preserve
    your invariants.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 公共和受保护的属性构成了你的公共 API，在人们大量依赖你的类之前应该是相对稳定的。然而，一般约定人们应该让你的私有 API 保持原样。这应该让你自由隐藏你认为需要不可访问的内容。这就是你可以保持你的不变量的方法。
- en: In Python, you signal to other developers that an attribute should be protected
    by prefixing it with an underscore (`_`). Private attributes and methods should
    be prefixed with two underscores (`__`). (Note that this is not the same as functions
    *surrounded* by two underscores—those denote special magic methods, which I’ll
    cover in [Chapter 11](part0015_split_000.html#api).) In Python, you don’t have
    a compiler that can catch when this access control is broken. There is nothing
    stopping a developer from reaching in and messing with your protected and private
    members. Enforcing this becomes an organizational challenge, part of the nature
    of the beast with a dynamically typed language like Python. Set up linting, enforce
    code styles, do thorough code reviews; you should treat your API as a core tenet
    of your class and not allow it to be broken lightly.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，通过在属性前加下划线（`_`）向其他开发者表明该属性应受保护。私有属性和方法应该用双下划线前缀（`__`）。 （请注意，这与被两个下划线包围的函数不同——那些表示特殊的魔术方法，我将在
    [第 11 章](part0015_split_000.html#api) 中介绍。）在 Python 中，你没有编译器能够在访问控制被打破时进行捕捉。没有什么能阻止开发者进入并操纵你的受保护和私有成员。强制执行这一点成为组织挑战的一部分，这是像
    Python 这样动态类型语言的本质。设置 linting，执行代码风格，进行彻底的代码审查；你应该把 API 视为类的核心原则，不允许它轻易被破坏。
- en: There are a few benefits to making your attributes protected/private. Protected
    and private attributes don’t show up in `help()` of a class. This will reduce
    the chance of somebody using these attributes inadvertently. Furthermore, private
    attributes aren’t as easily accessible.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使属性受保护/私有有几个好处。受保护和私有属性不会出现在类的 `help()` 中。这将减少无意中使用这些属性的机会。此外，私有属性不容易被访问。
- en: 'Consider the `PizzaSpecification` with private members:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑带有私有成员的 `PizzaSpecification`：
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](../images/00002.gif)](part0014_split_012.html#co_user_defined_types__classes_CO1-1)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](../images/00002.gif)](part0014_split_012.html#co_user_defined_types__classes_CO1-1)'
- en: Dough radius in inches is now a private member.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Dough radius 以英寸为单位是一个私有成员。
- en: '[![2](../images/00005.gif)](part0014_split_012.html#co_user_defined_types__classes_CO1-2)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](../images/00005.gif)](part0014_split_012.html#co_user_defined_types__classes_CO1-2)'
- en: Toppings is now a private member.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Toppings 是一个私有成员。
- en: 'Python does something called name mangling when you prefix attributes with
    two underscores. That is, Python changes the name out from underneath you, making
    it very obvious when users are abusing your API. I can find out what name mangling
    is by using the `__dict__` attribute of an object:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在你用双下划线前缀属性时会进行名称混淆。也就是说，Python 会在你眼皮底下改变属性名，使得用户滥用你的 API 时显得非常明显。我可以通过使用对象的
    `__dict__` 属性找出名称混淆的具体含义：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you see an attribute access like this, you should raise a red flag: developers
    are messing with class internals and this might break invariants. Fortunately,
    this is very easy to catch when linting code bases (you’ll learn more about linters
    in [Chapter 20](part0026_split_000.html#static_analysis)). Form a pact with your
    cocontributors and don’t touch anything that is private; otherwise, you’ll find
    yourself in an unmaintainable mess.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到像这样的属性访问，应该引起警觉：开发者正在操纵类内部，这可能会破坏不变式。幸运的是，当进行代码基础的检查时，很容易就能抓住这一点（你将在 [第
    20 章](part0026_split_000.html#static_analysis) 中学到更多关于 linter 的知识）。与你的合作者形成协议，不要触碰任何私有内容；否则，你会陷入一个难以维护的混乱中。
- en: Operations
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作
- en: 'So now I have a class whose invariants cannot be (easily) broken. I have a
    class that is constructible, but I’m not able to change or read any data from
    it. That’s because I’ve only touched upon one part of encapsulation thus far:
    the hiding of data. I still need to walk through how to bundle operations with
    data. Enter methods.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我有了一个类，它的不变式不容易被（轻易地）破坏。我有了一个可以构造的类，但我无法更改或读取其中任何数据。这是因为我目前只涉及了封装的一部分：数据的隐藏。我仍然需要介绍如何将操作与数据捆绑在一起。进入方法。
- en: I will trust that you have a good handle on functions that live outside of a
    class (also known as free functions). What I’ll focus on are functions that live
    inside the class, also known as methods.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你已经很好地掌握了在类外部存在的函数（也称为自由函数）。我将专注于存在于类内部的函数，也称为方法。
- en: Let’s say that for my pizza specification, I want to be able to add a topping
    while the pizza is queued to be made. After all, my pizzas are a huge success
    (it’s my imagination, let me have this one), and there is often a long line of
    pizzas to be made. But a family just placing their order realizes they missed
    their son’s favorite topping, and in order to prevent a toddler meltdown over
    melted cheese, they need to modify their order after they’ve submitted it. I’ll
    define a new function that adds a topping for their convenience.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 假设对于我的披萨规格，我希望在排队制作披萨时能够添加配料。毕竟，我的披萨非常成功（这是我的想象，请让我拥有这一点），通常有很长的披萨制作队列。但是一家刚刚下订单的家庭意识到他们忘记了儿子最喜欢的配料，为了防止因融化的奶酪引起的小孩崩溃，他们需要在提交订单后修改订单。我将定义一个新函数，为他们方便地添加配料。
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](../images/00002.gif)](part0014_split_013.html#co_user_defined_types__classes_CO2-1)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](../images/00002.gif)](part0014_split_013.html#co_user_defined_types__classes_CO2-1)'
- en: Use the new `add_topping` method.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的`add_topping`方法。
- en: '[![2](../images/00005.gif)](part0014_split_013.html#co_user_defined_types__classes_CO2-2)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](../images/00005.gif)](part0014_split_013.html#co_user_defined_types__classes_CO2-2)'
- en: The new `add_topping` method.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`add_topping`方法。
- en: It’d be easy to write a method that merely appends a topping to a list. But
    that wouldn’t be right. I have an invariant to uphold, and I’m not backing down
    now. The code makes sure that we don’t add a second sauce, and if the topping
    is a sauce, ensures that it is laid down first. Remember, an invariant needs to
    be true for the lifetime of an object, which extends far past initial construction.
    Every method you add should be continuing to preserve that invariant.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个仅将配料追加到列表的方法很容易。但那不对。我有一个不变量要维持，我现在不会退缩。代码确保我们不会添加第二种酱料，并且如果配料是酱料，则确保首先涂抹。请记住，不变量需要在对象的整个生命周期内保持为真，这远远超出了初始构建。您添加的每种方法都应继续保持该不变量。
- en: 'Methods are often separated into two categories: accessors and mutators. Some
    people simplify this to “getters” and “setters,” but I feel like that is a bit
    too narrow. “Getters” and “setters” often describe methods that just return a
    simple value or set a member variable. Many methods are much more complicated:
    setting multiple fields, performing complex calculations, or manipulating data
    structures.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 方法通常分为两类：访问器和变异器。有些人简化为“获取器”和“设置器”，但我觉得这有点狭隘。“获取器”和“设置器”通常描述的是仅返回简单值或设置成员变量的方法。许多方法要复杂得多：设置多个字段，执行复杂计算，或操作数据结构。
- en: Accessors are for retrieving information. If you have invariants that relate
    to how you represent data, these are the methods you care about. For example,
    the pizza specification might include a way to transform its internal data into
    machine operations (roll dough, apply sauce, apply toppings, bake). By nature
    of the invariants, you’d want to make sure you aren’t producing invalid machine
    operations.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 访问器用于检索信息。如果您有关于如何表示数据的不变量，这些就是您关心的方法。例如，披萨规格可能包括将其内部数据转换为机器操作的方法（擀面团，涂酱，加配料，烘烤）。根据不变量的性质，您希望确保不会产生无效的机器操作。
- en: Mutators are things that alter the state of your object. If you have mutators,
    you need to be extra careful that you are preserving any invariants as you change
    state. Adding new toppings to an existing pizza is a mutator.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 变异器是改变对象状态的东西。如果您有变异器，需要特别小心，在更改状态时保持所有不变量。向现有披萨添加新配料就是一种变异器。
- en: This is also a good way to measure whether a function should be inside your
    class or not. If you have functions that don’t concern themselves with invariants,
    or even worse, don’t concern themselves with members of the class, you probably
    have a free function instead. This class is better served by living at module
    scope and outside of your class. It may be appealing to jam just one more function
    into an already bloated class (it often is the easiest), but if you strive for
    maintainability, having unrelated functions in a class leads to a nightmare. (You
    set up all sorts of interesting dependency chains; if you’ve ever asked yourself
    why one file depends on another file, this is often the reason.) It also may happen
    that your class has no invariants at all, and you should instead just chain together
    free functions.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是衡量一个函数是否应该在类内部的好方法。如果你有一些不关心不变性的函数，或者更糟糕的是，不关心类成员的函数，你可能是在写自由函数。这种类最好存在于模块范围而不是类内部。也许在一个已经臃肿的类中再添加一个函数看起来很有吸引力（通常是最简单的方法），但是如果你追求可维护性，将无关的函数放在一个类中会导致噩梦般的结果。（你设置了各种有趣的依赖链；如果你曾经问过自己为什么一个文件依赖于另一个文件，这往往就是原因。）也可能发生的情况是你的类根本没有不变性，你应该考虑只是链式调用自由函数。
- en: And that’s invariants. It’s not something developers talk about enough, but
    once you start thinking in terms of invariants, you’ll see a major boost to class
    maintainability. Remember, you use invariants to allow users to reason about your
    objects and reduce cognitive load. It’s OK if you take extra time writing code
    if you will pay off the costs for however many readers after.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 而不变性是关键。开发者很少谈论这一点，但一旦你开始以不变性的术语思考，你将会看到类的可维护性显著提升。记住，你使用不变性来让用户推理你的对象并减少认知负荷。如果你需要为了读者的理解而付出额外的时间，编写代码时多花点时间也是值得的。
- en: Closing Thoughts
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结语
- en: I spent a fair amount of time on classes, especially compared to other user-defined
    data types such as enumerations and data classes. However, this was intentional.
    Classes are typically taught very early, and rarely revisited. I’ve found that
    most developers tend to overuse classes, without considering what they are meant
    for.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我在类上花了相当多的时间，特别是与其他用户定义数据类型如枚举和数据类相比。然而，这是有意为之的。类通常很早就开始教授，但很少回顾。我发现大多数开发者倾向于过度使用类，而不考虑它们的实际用途。
- en: 'As you decide how to create user-defined types, I offer the following guide
    for you:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当你决定如何创建用户定义类型时，我为你提供以下指南：
- en: Dictionaries
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 字典
- en: Dictionaries are meant for mappings from keys to values. If you are using dictionaries
    but rarely iterating over them or dynamically asking for keys, you aren’t using
    them like an associative mapping and probably need a different type. There is
    an exception when retrieving data from data sources at runtime (e.g., getting
    JSON, parsing YAML, retrieving database data, etc.), where a `TypedDict` is appropriate
    (see [Chapter 5](part0008_split_000.html#collections)). However, if you don’t
    need to use them as dictionaries elsewhere, you should strive to get these into
    user-defined classes after parsing the data.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是用来将键映射到值的。如果你使用字典却很少迭代它们或者动态地查询键，那么你没有像关联映射一样使用它们，可能需要使用不同的类型。有一个例外情况是在运行时从数据源中检索数据（例如获取
    JSON、解析 YAML、检索数据库数据等），这时候可以使用 `TypedDict`（见[第5章](part0008_split_000.html#collections)）。然而，如果你在其他地方不需要将它们用作字典，你应该在解析数据后将其转换为用户定义的类。
- en: Enumerations
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举类型
- en: Enumerations are great for representing a union of discrete scalar values. You
    don’t necessarily care about what the enumeration values are; you just need separate
    identifiers to differentiate cases in your code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举类型非常适合表示离散标量值的并集。你并不一定关心枚举值是什么；你只需要单独的标识符来区分代码中的不同情况。
- en: Data classes
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类
- en: Data classes are great for bundles of data that are mostly independent. You
    may have some restrictions on how individual fields can be set, but for the most
    part, users are free to get and set individual attributes to their heart’s content.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类非常适合用于大部分独立的数据集合。你可能对个别字段的设置有一些限制，但大多数情况下，用户可以自由获取和设置单个属性。
- en: Classes
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 类
- en: Classes are all about invariants. If you have an invariant you want to preserve,
    create a class, assert that the preconditions hold when constructing, and don’t
    let any method or user access break that invariant.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 类是关于不变性的。如果你想保持一个不变性，创建一个类，确保在构建时前提条件成立，并且不允许任何方法或用户访问破坏该不变性。
- en: '[Figure 10-1](part0014_split_014.html#class_flowchart) is a handy flowchart
    that describes these rules of thumb.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-1](part0014_split_014.html#class_flowchart) 是一个方便的流程图，描述了这些经验法则。'
- en: '![Picking the appropriate abstraction](../images/00014.gif)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![选择合适的抽象](../images/00014.gif)'
- en: Figure 10-1\. Picking the appropriate abstraction
  id: totrans-146
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 10-1。选择合适的抽象
- en: However, knowing which type to pick is only half the battle. Once you’ve picked
    the right type, you need to make it seamless to interact with from a consumer’s
    perspective. In the next chapter, you’re going to learn how to make your user-defined
    types more natural to work with by focusing on the type’s API.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，知道选择哪种类型只是战斗的一半。一旦你选择了正确的类型，你需要使其对消费者来说无缝交互。在下一章中，你将学习如何通过关注类型的API使您的用户定义类型更加自然易用。
- en: '^([1](part0014_split_005.html#idm45644740381352-marker)) Andrew Hunt and David
    Thomas. *The Pragmatic Programmer: From Journeyman to Master*. Reading, MA: Addison-Wesley,
    2000.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](part0014_split_005.html#idm45644740381352-marker)) 安德鲁·亨特和大卫·托马斯。《实用程序员：从新手到大师》。雷丁，MA：Addison-Wesley，2000年。
- en: ^([2](part0014_split_005.html#idm45644740365960-marker)) Robert C. Martin. “The
    Single Responsibility Principle.” *The Clean Code Blog* (blog), May 8, 2014\.
    [*https://oreil.ly/ZOMxb*](https://oreil.ly/ZOMxb).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](part0014_split_005.html#idm45644740365960-marker)) 罗伯特·C·马丁。《单一职责原则》。*干净代码博客*（博客），2014年5月8日。[*https://oreil.ly/ZOMxb*](https://oreil.ly/ZOMxb)。
