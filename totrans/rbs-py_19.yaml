- en: Chapter 16\. Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is difficult to write a program with no dependencies. Functions depend on
    other functions, modules depend on other modules, and programs depend on other
    programs. Architecture is fractal; no matter what level you’re looking at, your
    code can be represented as some sort of box-and-arrows diagram, like in [Figure 16-1](part0021_split_000.html#block_and_arrow).
    It doesn’t matter if it’s functions, classes, modules, programs, or systems, you
    can draw a similar diagram to [Figure 16-1](part0021_split_000.html#block_and_arrow)
    to represent the dependencies in your code.
  prefs: []
  type: TYPE_NORMAL
- en: '![Box-and-arrows diagram](../images/00020.gif)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-1\. Box-and-arrows diagram
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: However, if you don’t actively manage your dependencies, you soon get to what’s
    known as “spaghetti code,” making your box-and-arrows diagram look like [Figure 16-2](part0021_split_000.html#spaghetti_code).
  prefs: []
  type: TYPE_NORMAL
- en: '![A tangled mess of dependencies](../images/00021.gif)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-2\. A tangled mess of dependencies
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this chapter, you are going to learn all about dependencies and how to keep
    them under control. You’ll learn about different types of dependencies, all of
    which should be managed with different techniques. You’ll learn how to graph your
    dependencies, and how to interpret whether you have a healthy system. You’ll learn
    how to truly simplify your code architecture, which will help you manage complexity
    and increase the robustness of your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependencies are, in essence, relationships. When a piece of code requires another
    piece of code to behave in some specific way, we call that a *dependency*. You
    typically use a dependency to benefit from code reuse in some fashion. Functions
    call other functions to reuse behaviors. Modules import other modules to reuse
    the types and functions defined in that module. It doesn’t make sense in most
    codebases to write literally everything from scratch. Reusing other parts of the
    codebase, or even code from other organizations, can be immensely beneficial.
  prefs: []
  type: TYPE_NORMAL
- en: When you reuse code, you save time. You don’t need to waste effort writing code;
    you can just call or import the functionality that you need. Furthermore, any
    code you are depending on is presumably used in other places. This means that
    some layer of testing has already been done, which should reduce the number of
    bugs. Bonus points if the code is readily available to read. As *Linus’s Law*
    (as in Linus Torvalds, creator of Linux) states:^([1](part0021_split_012.html#idm45644732269304))
  prefs: []
  type: TYPE_NORMAL
- en: “Given enough eyeballs, all bugs are shallow.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Put another way, the likeliness of finding bugs is higher because so many people
    are looking at the code. This is another point in favor of readability leading
    to maintainability. If your code is readable, other developers will find and fix
    errors in it more easily, helping your robustness grow.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a catch, though. There is no such thing as a free lunch when talking
    about dependencies. Every dependency you create contributes to *coupling*, or
    tying two entities together. If a dependency changes in an incompatible way, your
    code needs to change as well. If this happens often, your robustness will suffer;
    you are constantly struggling to stay afloat as your dependencies change.
  prefs: []
  type: TYPE_NORMAL
- en: There’s also a human factor with dependencies. Every piece of code you depend
    on is maintained by a living, breathing human (maybe even a group of them). These
    maintainers have their own schedules, their own deadlines, and their own vision
    for the code they develop. Chances are those will not align with your schedules,
    deadlines, and vision. The more a piece of code is reused, the less likely it
    is that it meets all of the needs of every consumer. As your dependencies diverge
    from your implementation, you either live with the difficulties, choose an alternative
    dependency (possibly one you control), or fork it (and maintain it yourself).
    The choice you make depends on your specific scenario, but in each case, robustness
    takes a hit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any JavaScript developer who was working in 2016 can tell you how dependencies
    went wrong in “the left-pad debacle.” Due to a policy dispute, a developer removed
    a library named left-pad from the package repository and the next morning, thousands
    of projects were suddenly broken and unable to build. Many large projects (including
    React, a very popular library) depended on left-pad not directly, but transitively,
    through their own dependencies. That’s right, dependencies have their own dependencies
    and you get them too when you depend on other code. The moral of the story: don’t
    forget the human factor and the associated costs related to their workflows. Be
    prepared for any of your dependencies to change in the worst way, including being
    removed. Dependencies are liabilities. Necessary, but still liabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies also broaden the attack surface from a security perspective. Every
    dependency (and their own dependencies) has potential to compromise your system.
    There are entire websites dedicated to tracking security vulnerabilities, such
    as [*https://cve.mitre.org*](https://cve.mitre.org). A keyword search of “Python”
    shows you how many vulnerabilities exist today, and naturally, those websites
    can’t even count the not-yet-known vulnerabilities. This is even more perilous
    with dependencies maintained by your organization; unless you have security-minded
    individuals constantly looking at all of your code, unknown vulnerabilities may
    be ever-present in your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Carefully balance your use of dependencies. Your code will inherently have dependencies,
    and that is a good thing. The trick is to be smart with how you manage them. Being
    careless will lead to a sloppy, tangled mess. To learn how to handle dependencies,
    you first need to know how to identify the different types.
  prefs: []
  type: TYPE_NORMAL
- en: Types of Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I group dependencies into three classifications: physical, logical, and temporal.
    Each impacts your code’s robustness in different ways. You have to be able to
    spot them and know when they go awry. When wielded correctly, dependencies can
    keep your code extensible without bogging it down.'
  prefs: []
  type: TYPE_NORMAL
- en: Physical Dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When most developers think about dependencies, it’s the physical dependencies
    they think about. *Physical dependencies* are a relationship observed directly
    in code. Functions calling functions, types composed of other types, modules importing
    modules, classes inheriting from other classes…these are all examples of physical
    dependencies. They are static, meaning they aren’t changing at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Physical dependencies are the easiest to reason about; even tools can look at
    the codebase and map out physical dependencies (you’ll see this in just a few
    pages). They are easy to read and understand at first glance, which is a win for
    robustness. When future maintainers are reading or debugging the code, it becomes
    quite apparent how the dependency chain resolves; they can follow a trail of imports
    or function calls to get to the end of the chain.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 16-3](part0021_split_003.html#physical_dependencies) focuses on a completely
    automated pizza café named *PizzaMat*. Franchisees can purchase a PizzaMat as
    an entire module, and deploy it anywhere to get instant (and delicious) pizza.
    PizzaMat has a few different systems: the pizza-making system, a system to control
    payment and ordering, and a system to handle table management (seating, refills,
    and order delivery).'
  prefs: []
  type: TYPE_NORMAL
- en: '![An automated pizza café](../images/00022.gif)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-3\. An automated pizza café
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Each of these three systems interacts with the others (that’s what the arrows
    represent). The customer interacts with the payment/ordering system to order their
    pizza. Once they’re done, the pizza maker checks for any new orders and starts
    making the pizzas, and the table management system starts seating the customer.
    Once the table management service learns the pizza is done, it preps it for the
    table and serves it to the customer. If for any reason the customer is unhappy
    with the pizza, the table management system returns the pizza and the payment
    system issues a refund.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these dependencies is a relationship, and only with these systems working
    together do we have a working pizza shop. Physical dependencies are absolutely
    necessary to make sense of large systems; they allow you to break the problem
    down into smaller entities and define the interactions between each entity. I
    could take any one of these systems and break that down into modules, or take
    any module and break it down into functions. What I want to focus on is how those
    relationships impact maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose these three systems are maintained by three separate entities. You
    and your team maintain the pizza-making system. Another team in your company (but
    in a different building) owns the table management system, and an independent
    contractor has been providing the payment system. You’ve been part of a huge rollout
    to provide a new item in your pizza maker: stromboli. You’ve been working for
    weeks, carefully coordinating changes. Every system requires changes to handle
    the new menu item. After countless late nights (all pizza-fueled, of course),
    you are ready for the big update for your customers. However, as soon as the update
    rolls out, error reports start rolling in. An unfortunate set of events has introduced
    a bug, leading to pizza shops around the world breaking. As more and more systems
    come online, the problem becomes more dire. Management decides that you need to
    fix it as soon as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: Take a minute to ask how you would like your night to go. Do you want to spend
    it frantically trying to reach all of the other teams, attempting to hack in a
    fix across the three systems? You happen to know that the contractor has already
    turned off notifications for the night and the other team got a little too carried
    away with their launch celebration after work today. Or do you want to take a
    look at the code and realize that it’s incredibly easy to remove stromboli from
    all three systems by just messing with a few lines of code, with no input from
    the other teams?
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies are a one-way relationship. You are beholden to your dependencies.
    If they don’t do exactly what you want when you need it, you have little recourse.
    Remember, living, breathing humans are on the other side of your dependencies
    and they won’t necessarily jump when you ask them to jump. How you construct your
    dependencies will directly impact how you maintain a system.
  prefs: []
  type: TYPE_NORMAL
- en: In our stromboli example, the dependencies are a circle; any one change can
    potentially affect the other two systems. You need to think about every direction
    of your dependencies and how changes ripple through your system. With PizzaMat,
    the support of the pizza-making equipment is our single source of truth; there’s
    no use in setting up billing and table management for pizza products that don’t
    exist. However, in the example above, all three systems were written with their
    own copy of what menu items are available. Based on the direction of the dependencies,
    the pizza maker could take out the stromboli code, but stromboli would still show
    up in the payment system. How could you make this more extensible to avoid these
    dependency problems?
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The tricky thing about large architectural changes is that the right answer
    always depends on the context of your specific problem. If *you* were to build
    an automated pizza maker, you might draw your dependency tree differently, based
    on a variety of different factors and constraints. It’s important to focus on
    *why* you are drawing your dependencies the way you are, not making sure that
    they are always drawn the same way as someone else’s system.
  prefs: []
  type: TYPE_NORMAL
- en: To start, you can construct your system such that all the menu definitions live
    in the pizza-making system; after all, it is the system that knows what it can
    and cannot make. From there, the pricing system can query the pizza maker as to
    what items are actually available. That way, if you need to remove stromboli in
    an emergency, you can do it in the pizza-making system; the pricing system doesn’t
    control what is and is not available. By inverting, or reversing the direction
    of, the dependency, you restore control to the pizza-making system. If I were
    to invert this one dependency, the dependency graph looks like [Figure 16-4](part0021_split_003.html#organized_deps).
  prefs: []
  type: TYPE_NORMAL
- en: '![More sensible dependencies](../images/00023.gif)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-4\. More sensible dependencies
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now the pizza maker calls the shots for what can and cannot be ordered. This
    can go a long way toward limiting the amount of changes needed. If the pizza maker
    needs to stop supporting a type of ingredient in a dish, the payment system will
    pick up the changes automatically. Not only will this save your hide during an
    emergency, but it gives your business more flexibility in the future. You’ve added
    the ability to optionally display different dishes in the payment system depending
    on what the pizza maker can automatically make, all without needing to coordinate
    with an external payment team.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion Topic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Think through how you would add a feature that prevents the payment system from
    showing certain options if the pizza maker was out of ingredients. Consider the
    systems in Figures [16-3](part0021_split_003.html#physical_dependencies) and [16-4](part0021_split_003.html#organized_deps).
  prefs: []
  type: TYPE_NORMAL
- en: As an additional discussion topic, discuss the cycle between the table management
    system and payment system. How can you break that cycle? What are the pros and
    cons of each direction of dependencies?
  prefs: []
  type: TYPE_NORMAL
- en: Logical Dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *logical dependency* is when two entities have a relationship but no direct
    linkage in code. The dependency is abstracted; it contains a layer of indirection.
    It’s a dependency that is only present at runtime. In our pizza maker example,
    we have three subsystems interacting with one another. We represented the dependency
    with arrows in [Figure 16-3](part0021_split_003.html#physical_dependencies). If
    those arrows are imports or function calls, then they are physical dependencies.
    However, it’s possible to link these subsystems at runtime without function calls
    or imports.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose subsystems live on different computers and communicate over HTTP. If
    the pizza maker were to notify the table management service on when the pizza
    is made over HTTP using the requests library, it would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The physical dependency is no longer from the pizza maker to our table management
    system, but from the pizza maker to the requests library. As far as the pizza
    maker is concerned, it just needs an HTTP endpoint that it can post to an endpoint
    called “/pizza-done” from some web server named “table-management.” That endpoint
    needs to accept an ID and pizza data formatted as JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in reality, your pizza maker still needs a table management service to
    work. This is the logical dependency at play. Even though there is no direct dependency,
    there is still a relationship between the pizza maker and table management systems.
    This relationship doesn’t just disappear; it transforms from physical to logical.
  prefs: []
  type: TYPE_NORMAL
- en: The key benefit for introducing a logical dependency is substitutability. It
    is much easier to replace a component when nothing is physically depending on
    it. Take the example with the `on_pizza_done` over HTTP request. You could completely
    replace the table management service, as long as it upholds the same contract
    as the original service. If that sounds familiar, it should, as it’s the exact
    same idea you learned about in [Chapter 12](part0016_split_000.html#subtyping).
    Subtyping, whether through duck typing, inheritance, or something similar, introduces
    logical dependencies. Calling code physically depends on the base class, but the
    logical dependency of which child class is used isn’t determined until runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Improving substitutability improves maintainability. Remember, maintainable
    code is easy to change. If you can substitute entire swaths of functionality with
    minimal impact, you give your future maintainers immense flexibility in making
    decisions. If a specific function or class or subsystem isn’t growing to your
    needs, you can just replace it. Code that is easy to delete is inherently easy
    to change.
  prefs: []
  type: TYPE_NORMAL
- en: As with anything though, logical dependencies come with a cost. Every logical
    dependency is an indirect reference to some relationship. Because there is no
    physical linkage, tooling has a very hard time identifying logical dependencies.
    You won’t be able to create a nice box-and-arrows diagram of logical dependencies.
    Furthermore, as developers read your code, the logical dependencies won’t be immediately
    apparent. Often, a reader of code will see the physical dependency to some layer
    of abstraction, while the logical dependency isn’t noticed or resolved until runtime.
  prefs: []
  type: TYPE_NORMAL
- en: This is the trade-off of introducing a logical dependency. You increase maintainability
    by increasing substitutability and reducing coupling, but you also decrease maintainability
    by making your code harder to read and understand. Too many layers of abstraction
    create a tangled mess just as easily as too few layers of abstraction. There is
    no hard and fast rule for what the right number of layers of abstraction are;
    you need to use your best judgment for whether you need flexibility or readability
    for your specific scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Some logical dependencies create relationships that aren’t detectable through
    tooling, such as depending on the specific ordering of a collection or relying
    on specific fields to be present in a class. When found, these often surprise
    developers because there was little indication they existed without close inspection.
  prefs: []
  type: TYPE_NORMAL
- en: 'I once worked on a codebase that stored network interfaces. Two pieces of code
    depended on these interfaces: one system for performance statistics and one for
    setting up communication paths with other systems. The problem was they had different
    assumptions about the ordering of those interfaces. It worked for years, until
    new network interfaces were added. Due to how communication paths worked, new
    interfaces needed to be put in the front of the list. But the performance statistics
    would have only worked with those interfaces in the back. Due to a hidden logical
    dependency, these two parts of code were inextricably linked (I never would have
    thought that adding communication paths would break performance statistics).'
  prefs: []
  type: TYPE_NORMAL
- en: In hindsight, the fix was easy. I created a function that mapped the ordering
    from the communication path expectations to a reordered list. The performance
    statistics system then depended on this new function. However, that didn’t retroactively
    fix the bug (or give me back the hours of my time spent trying to figure out why
    performance statistics were broken). Whenever you create a dependency on something
    that is not directly apparent in code, find a way to make it apparent. Leave a
    trail of breadcrumbs, preferably with a separate codepath (like the intermediary
    function above) or types. If you can’t do that, leave a comment. Had one comment
    in the network interface list indicated a dependency upon a specific ordering,
    I never would have had such a headache with that code.
  prefs: []
  type: TYPE_NORMAL
- en: Temporal Dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last type of dependency is the temporal dependency. This is actually a type
    of logical dependency, but how you handle it is slightly different. A *temporal
    dependency* is a dependency that is linked by time. Anytime there is a concrete
    order of operations, such as “dough must be laid down before sauce and cheese”
    or “an order must be paid for before the pizza begins being made,” you have a
    temporal dependency. Most temporal dependencies are straightforward; they are
    a natural part of your business domain. (Where would you put pizza sauce and cheese
    without the dough, anyway?) These are not the temporal dependencies that will
    cause you problems. Instead, it’s the ones that aren’t always so apparent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Temporal dependencies bite you the most in situations where you must do certain
    operations in a specific order, but you have no indication that you need to do
    so. Imagine if your automated pizza maker could be configured in two modes: single-pizza
    (for high-quality pizzas) or mass-produce (for cheap and fast pizzas). Whenever
    a pizza maker goes from single-pizza to mass-produce, it needs an explicit reconfiguration.
    If that reconfiguration doesn’t happen, the machine’s failsafe kicks in and refuses
    to make pizzas until a manual operator override occurs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When this option is first introduced, developers take the utmost care in making
    sure that before any call to `mass_produce`, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There has to be a check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Developers diligently look for this code in code reviews and make sure that
    the proper checks are always made. However, as the years go by, and developers
    cycle in and out of the project, the team’s knowledge of mandatory checks starts
    to dwindle. Imagine a newer automated pizza maker model comes to market, which
    doesn’t need reconfiguration (calls to `configure_for_mass_production` result
    in no change to the system). Developers who are only familiar with this new model
    may never think to call `configure_for_mass_production` in these cases.
  prefs: []
  type: TYPE_NORMAL
- en: Now, put yourself in a developer’s shoes a few years in the future. Let’s say
    you are writing new functionality for the pizza maker, and the `mass_produce`
    function fits the exact use case you need. How would you know that you need to
    do explicit checking for mass production, especially for older models? Unit tests
    won’t help you, as they don’t exist yet for the new functionality. Do you really
    want to wait until integration tests fail (or a customer complains) to find out
    that you missed that check?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some strategies to mitigate missing such a check:'
  prefs: []
  type: TYPE_NORMAL
- en: Lean on your type system
  prefs: []
  type: TYPE_NORMAL
- en: By restricting certain operations to specific types, you can prevent confusion.
    Imagine if `mass_produce` was only callable from a `MassProductionPizzaMaker`
    object. You could write function calls to make sure that a `MassProductionPizzaMaker`
    was only created after reconfiguration. You are using the type system to make
    it impossible to a mistake (`NewType` does something very similar, as described
    in [Chapter 4](part0007_split_000.html#constraints)).
  prefs: []
  type: TYPE_NORMAL
- en: Embed preconditions deeper
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that the pizza maker has to be configured before use is a *precondition*.
    Consider making this precondition of the `mass_produce` function by moving the
    checks inside `mass_produce`. Think about how you will handle error conditions
    (such as throwing an exception). You’ll be able to prevent violating the temporal
    dependency, but you’ve introduced a different error at runtime. Your specific
    use case will dictate what you consider to be the lesser of two evils: violating
    the temporal dependency or dealing with a new error case.'
  prefs: []
  type: TYPE_NORMAL
- en: Leave breadcrumbs
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t necessarily a strategy to catch a violated temporal dependency. Instead
    it is more of a last-ditch effort to alert developers about temporal dependencies
    if all other efforts fail. Try to organize temporal dependencies in the same file
    (ideally within a few lines of each other). Leave comments and documentation to
    notify future developers of this linkage. With any luck, those future developers
    will see the clues and know that there is a temporal dependency.
  prefs: []
  type: TYPE_NORMAL
- en: In any linear program, most lines have a temporal dependency on the lines that
    precede them. This is normal, and you don’t need to apply mitigations for each
    of these cases. Instead, look for temporal dependencies that might only be applied
    in certain cases (such as machine reconfiguration on older models), or temporal
    dependencies that are catastrophic if missed (such as not sanitizing a user input
    string before passing it to a database). Weigh the cost of violating a temporal
    dependency against the effort to detect it and mitigate it. It will depend on
    your use case, but when you do mitigate a temporal dependency, it can save you
    immense headaches later on.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing Your Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It can be challenging to find these sorts of dependencies and understand where
    to look for potential problem points. Sometimes you need a more visual representation.
    Fortunately, tools exist to help you make sense of your dependencies visually.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For many of the following examples, I will be using the GraphViz library to
    display pictures. To install it, follow the instructions on the [GraphViz website](https://graphviz.org).
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing Packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chances are, your code uses other packages, installed by pip. It can be helpful
    to know all the packages that you depend on, their dependencies, the dependencies
    of those dependencies, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, I’m going to install two packages, `pipdeptree` and GraphViz. `pipdeptree`
    is a useful tool to tell you how packages interact with one another, and GraphViz
    does the actual visualization part. For this example, I’ll be using the mypy codebase.
    I’ve downloaded the mypy source code, created a virtual environment, and installed
    mypy from source.^([2](part0021_split_012.html#idm45644732007976))
  prefs: []
  type: TYPE_NORMAL
- en: 'From within that virtual environment, I’ve installed `pipdeptree` and GraphViz:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now I run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can see the results in [Figure 16-5](part0021_split_008.html#visualizing_packages).
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing packages](../images/00024.gif)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-5\. Visualizing packages
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I’m going to ignore wheel, setuptools, and pip packages, and focus on mypy.
    In this case, I see the exact version of mypy that is installed, as well as the
    direct dependencies (in this case typed_ast 1.4.2, typing-extensions 3.7.4.3,
    and mypy-extensions 0.4.3\. `pipdeptree` is also nice enough to specify what version
    constraints exist (such as only allowing mypy-extensions to be a version greater
    or equal to 0.4.3, but less than 0.5.0). With these tools, you can get a handy
    pictorial representation of your packaged dependencies. This is extremely useful
    for projects with a large number of dependencies, especially if you actively maintain
    a lot of the packages.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing Imports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visualizing packages is quite a high-level view, so it helps to go one step
    deeper. How can you find out what’s being imported at the module level? Another
    tool, called `pydeps`, is great for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install it, you can:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: I ran this for mypy and received a very complex and dense graph. Reproducing
    it in print would be a waste of paper, so I’ve decided to zoom into a specific
    section in [Figure 16-6](part0021_split_009.html#visualizing_imports).
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing imports](../images/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-6\. Visualizing imports
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There’s a mess of arrows going on even in this small section of the dependency
    graph. However, you can see that quite a few different areas of the codebase depend
    on `mypy.options`, as well as the `fastparse` and `errors` modules. Because of
    the size of these graphs, I recommend digging into smaller subsystems of your
    codebase one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing Function Calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want even *more* information than an import graph, you can see which
    functions call each other. This is known as a *call graph*. First, I’ll look at
    a *static* call graph generator. These generators look at your source code and
    see which functions call which; no code is executed. For this example, I’ll use
    the library pyan3, which can be installed with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To run pyan3, you execute the following on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When I run this on the *dmypy* folder inside of mypy (I picked a subfolder to
    limit the amount of information drawn), I receive an interactive HTML page that
    lets me explore the dependencies. [Figure 16-7](part0021_split_010.html#visualizing_static_functions)
    shows a snippet from the tool.
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing function calls statically](../images/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-7\. Visualizing function calls statically
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note that this only tracks physical dependencies, as logical dependencies aren’t
    known until runtime. If you’d like to see a call graph at runtime, you will need
    to execute your code in concert with a *dynamic* call graph generator. For this
    purpose, I like using the built-in Python profiler. A *profiler* audits all function
    calls you are making during the execution of a program and records performance
    data. As a side benefit, the entire function call history is preserved in the
    profile. Let’s try this out.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll first build the profile (I’m profiling a test file in mypy for size reasons):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then I’ll convert the profile into a file that GraphViz can understand: a dot
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Finally, I’ll use GraphViz to convert the *.dot* file to a *.png*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Again, this produces oodles of boxes and arrows, so [Figure 16-8](part0021_split_010.html#visualizing_dynamic_functions)
    is just a small screenshot illustrating part of the call graph.
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualizing function calls dynamically](../images/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-8\. Visualizing function calls dynamically
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can find out how many times the function gets called, as well as how much
    of the execution time was spent in the function. This can be a great way to find
    performance bottlenecks in addition to understanding your call graph.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreting Your Dependency Graph
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Alright, you’ve drawn all these pretty graphs; what can you do with them? When
    you see your dependencies graphed out in this fashion, you get a pretty good idea
    where your maintainability hotspots are. Remember, every dependency is a reason
    for code to change. Whenever anything changes in your codebase, it can ripple
    up through physical and logical dependencies, potentially impacting large swaths
    of code.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, you need to think about the relationships between what you’re
    changing and the things that depend upon them. Consider the amount of code depending
    on you, as well as the code that you yourself depend upon. If you have a lot of
    dependencies coming in, but not going out, you have what’s known as high *fan-in*.
    Conversely, if you don’t have a lot of dependencies coming in, but you depend
    on a large number of other entities, this is known as high *fan-out*. [Figure 16-9](part0021_split_011.html#fans)
    illustrates the difference between fan-in and fan-out.
  prefs: []
  type: TYPE_NORMAL
- en: '![The difference between fan-in and fan-out](../images/00028.gif)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-9\. The difference between fan-in and fan-out
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You want the entities in your system that have a high amount of fan-in to be
    leaves of your dependency graph, or at the bottom. Large parts of your codebase
    depend on these entities; every dependency you have is a dependency the rest of
    your codebase will have as well. You also want these entities to be stable, which
    means that they should be changing infrequently. Every time you introduce change,
    you potentially impact most of your codebase due to the large fan-in.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, fan-out entities should be toward the top of your dependency
    graph. This is where most of your business logic will likely live; it will change
    as the business evolves. These parts of your codebase can withstand a much higher
    rate of change; due to their relatively few upstream dependencies, their code
    won’t break as often when behaviors change.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Changing fan-out entities won’t impact as much of your codebase’s assumptions,
    but I can’t say whether or not it will break customer’s assumptions. How much
    you want external behavior to remain backward compatible is a UX concern and outside
    the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Closing Thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The presence of dependencies does not dictate how robust your code is. It’s
    about how you utilize and manage those dependencies. Dependencies are absolutely
    crucial to sane reuse in your system. You can break code into smaller chunks and
    reorganize your codebase appropriately. By giving your dependencies the right
    directionality, you can actually increase the robustness of your code. You can
    make your code more maintainable by increasing substitutability and extensibility.
  prefs: []
  type: TYPE_NORMAL
- en: But, as with anything in engineering, there is always a cost. Dependencies are
    a coupling; linking different parts of your codebase together and making changes
    can have a wider impact than you might be looking for. There are different types
    of dependencies that must be handled in different ways. Physical dependencies
    are easy to visualize through tooling, but are also rigid in the structure they
    impose. Logical dependencies provide an extensibility to your codebase, but their
    nature is hidden until runtime. Temporal dependencies are a necessary part of
    executing Python in a linear fashion, but when those dependencies become unintuitive,
    they incur a ton of future pain.
  prefs: []
  type: TYPE_NORMAL
- en: All of these lessons assume that you have pieces of code that you can depend
    upon. In the next chapter, you’ll explore *composable code*, or breaking code
    into smaller pieces for reuse. You’ll learn how to compose objects, looping patterns,
    and functions to reorganize your code into new use cases. When you think in terms
    of composable code, you’ll start building in new functionality with ease. Your
    future maintainers will thank you.
  prefs: []
  type: TYPE_NORMAL
- en: '^([1](part0021_split_001.html#idm45644732269304-marker)) Eric S. Raymond. *The
    Cathedral & the Bazaar*. Sebastopol, CA: O’Reilly Media, 2001.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](part0021_split_008.html#idm45644732007976-marker)) Creating a virtual
    environment is a great way to isolate your dependencies from your system’s Python
    installation.
  prefs: []
  type: TYPE_NORMAL
