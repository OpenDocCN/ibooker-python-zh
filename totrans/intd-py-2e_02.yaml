- en: Chapter 1\. A Taste of Py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Only ugly languages become popular. Python is the one exception.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Don Knuth
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Mysteries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s begin with two mini-mysteries and their solutions. What do you think the
    following two lines mean?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It looks technical, like some kind of computer program. Actually, it’s a *knitting
    pattern*; specifically, a fragment describing how to turn the heel of a sock,
    like the one in [Figure 1-1](#fig_socks).
  prefs: []
  type: TYPE_NORMAL
- en: '![socks](assets/inp2_0101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-1\. Knitted socks
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This makes as much sense to me as a Sudoku puzzle does to one of my cats, but
    my wife understands it perfectly. If you’re a knitter, you do, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try another mysterious text, found on an index card. You’ll figure out
    its purpose right away, although you might not know its final product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Even if you don’t cook, you probably recognized that it’s a *recipe*^([1](ch01.html#idm45795040338904)):
    a list of food ingredients followed by directions for preparation. But what does
    it make? It’s *lefse*, a Norwegian delicacy that resembles a tortilla ([Figure 1-2](#fig_lefse)).
    Slather on some butter and jam or whatever you like, roll it up, and enjoy.'
  prefs: []
  type: TYPE_NORMAL
- en: '![lefse](assets/inp2_0102.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-2\. Lefse
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The knitting pattern and the recipe share some features:'
  prefs: []
  type: TYPE_NORMAL
- en: A regular *vocabulary* of words, abbreviations, and symbols. Some might be familiar,
    others mystifying.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rules about what can be said, and where—*syntax*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *sequence of operations* to be performed in order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, a repetition of some operations (a *loop*), such as the method for
    frying each piece of lefse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, a reference to another sequence of operations (in computer terms,
    a *function*). In the recipe, you might need to refer to another recipe for ricing
    potatoes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assumed knowledge about the *context*. The recipe assumes you that know what
    water is and how to boil it. The knitting pattern assumes that you can knit and
    purl without stabbing yourself too often.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some *data* to be used, created, or modified—potatoes and yarn.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *tools* used to work with the data—pots, mixers, ovens, knitting sticks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An expected *result*. In our examples, something for your feet and something
    for your stomach. Just don’t mix them up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whatever you call them—idioms, jargon, little languages—you see examples of
    them everywhere. The lingo saves time for people who know it, while mystifying
    the rest of us. Try deciphering a newspaper column about bridge if you don’t play
    the game, or a scientific paper if you’re not a scientist (or even if you are,
    but in a different field).
  prefs: []
  type: TYPE_NORMAL
- en: Little Programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ll see all of these ideas in computer programs, which are themselves like
    little languages, specialized for humans to tell computers what to do. I used
    the knitting pattern and recipe to demonstrate that programming isn’t that mysterious.
    It’s largely a matter of learning the right words and the rules.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it helps greatly if there aren’t too many words and rules, and if you don’t
    need to learn too many of them at once. Our brains can hold only so much at one
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s finally see a real computer program ([Example 1-1](#ch01_ex1)). What do
    you think this does?
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-1\. countdown.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you guessed that it’s a Python program that prints the lines
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: then you know that Python can be easier to learn than a recipe or knitting pattern.
    And you can practice writing Python programs from the comfort and safety of your
    desk, far from the hazards of hot water and pointy sticks.
  prefs: []
  type: TYPE_NORMAL
- en: The Python program has some special words and symbols—`for`, `in`, `print`,
    commas, colons, parentheses, and so on—that are important parts of the language’s
    *syntax* (rules). The good news is that Python has a nicer syntax, and less of
    it to remember, than most computer languages. It seems more natural—almost like
    a recipe.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 1-2](#ch01_ex2) is another tiny Python program; it selects one Harry
    Potter spell from a Python *list* and prints it.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-2\. spells.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The individual spells are Python *strings* (sequences of text characters, enclosed
    in quotes). They’re separated by commas and enclosed in a Python *list* that’s
    defined by enclosing square brackets (`[` and `]`). The word `spells` is a *variable*
    that gives the list a name so that we can do things with it. In this case, the
    program would print the fourth spell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Why did we say `3` if we wanted the fourth? A Python list such as `spells` is
    a sequence of values, accessed by their *offset* from the beginning of the list.
    The first value is at offset `0`, and the fourth value is at offset `3`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: People count from 1, so it might seem weird to count from 0. It helps to think
    in terms of offsets instead of positions. Yes, this is an example of how computer
    programs sometimes differ from common language usage.
  prefs: []
  type: TYPE_NORMAL
- en: Lists are very common *data structures* in Python, and [Chapter 7](ch07.html#ch_lists)
    shows how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: The program in [Example 1-3](#ch01_ex3) prints a quote from one of the Three
    Stooges, but referenced by who said it rather than its position in a list.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-3\. quotes.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were to run this little program, it would print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`quotes` is a variable that names a Python *dictionary*—a collection of unique
    *keys* (in this example, the name of the Stooge) and associated *values* (here,
    a notable saying of that Stooge). Using a dictionary, you can store and look up
    things by name, which is often a useful alternative to a list.'
  prefs: []
  type: TYPE_NORMAL
- en: The `spells` example used square brackets (`[` and `]`) to make a Python list,
    and the `quotes` example uses curly brackets (`{` and `}`, which are no relation
    to Curly), to make a Python dictionary. Also, a colon (`:`) is used to associate
    each key in the dictionary with its value. You can read much more about dictionaries
    in [Chapter 8](ch08.html#ch_dicts).
  prefs: []
  type: TYPE_NORMAL
- en: That wasn’t too much syntax at once, I hope. In the next few chapters, you’ll
    encounter more of these little rules, a bit at a time.
  prefs: []
  type: TYPE_NORMAL
- en: A Bigger Program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'And now for something completely different: [Example 1-4](#ch01_ex4) presents
    a Python program performing a more complex series of tasks. Don’t expect to understand
    how the program works yet; that’s what this book is for! The intent is to introduce
    you to the look and feel of a typical nontrivial Python program. If you know other
    computer languages, evaluate how Python compares. Even without knowing Python
    yet, can you roughly figure out what each line does before reading the explanation
    after the program? You’ve already seen examples of a Python list and a dictionary,
    and this throws in a few more features.'
  prefs: []
  type: TYPE_NORMAL
- en: In earlier printings of this book, the sample program connected to a YouTube
    website and retrieved information on its most highly rated videos, like “Charlie
    Bit My Finger.” It worked well until shortly after the ink was dry on the second
    printing. That’s when Google dropped support for this service and the marquee
    sample program stopped working. Our new [Example 1-4](#ch01_ex4) goes to another
    site which should be around longer—the *Wayback Machine* at the [Internet Archive](http://archive.org),
    a free service that has saved billions of web pages (and movies, TV shows, music,
    games, and other digital artifacts) over 20 years. You’ll see more examples of
    such *web APIs* in [Chapter 18](ch18.html#ch_web).
  prefs: []
  type: TYPE_NORMAL
- en: The program will ask you to type a URL and a date. Then, it asks the Wayback
    Machine if it has a copy of that website around that date. If it found one, it
    returns the information to this Python program, which prints the URL and displays
    it in your web browser. The point is to show how Python handles a variety of tasks—get
    your typed input, communicate across the internet to a website, get back some
    content, extract a URL from it, and convince your web browser to display that
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: If we got back a normal web page full of HTML-formatted text, we would need
    to figure out how to display it, which is a lot of work that we happily entrust
    to web browsers. We could also try to extract the parts that we want (see more
    details about *web scraping* in [Chapter 18](ch18.html#ch_web)). Either choice
    would be more work and a larger program. Instead, the Wayback Machine returns
    data in *JSON* format. JSON (JavaScript Object Notation) is a human-readable text
    format that describes the types, values, and order of the data within it. It’s
    another little language, and it has become a popular way to exchange data among
    different computer languages and systems. You’ll read more about JSON in [Chapter 12](ch12.html#ch_munging).
  prefs: []
  type: TYPE_NORMAL
- en: Python programs can translate JSON text into Python *data structures*—the kind
    you’ll see in the next few chapters—as though you wrote a program to create them
    yourself. Our little program just selects one piece (the URL of the old page from
    the Internet Archive website). Again, this is a complete Python program that you
    can run yourself. We’ve included only a little error-checking, just to keep the
    example short. The line numbers are not part of the program; they are included
    to help you follow the description that we provide after the program.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-4\. archive.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This little Python program did a lot in a few fairly readable lines. You don’t
    know all these terms yet, but you will within the next few chapters. Here’s what’s
    going on in each line:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Import* (make available to this program) all the code from the Python *standard
    library* module called `webbrowser`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import all the code from the Python standard library module called `json`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import only the `urlopen` *function* from the standard library module `urllib.request`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A blank line, because we don’t want to feel crowded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print some initial text to your display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print a question about a URL, read what you type, and save it in a program *variable*
    called `site`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print another question, this time reading a year, month, and day, and then save
    it in a variable called `era`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Construct a string variable called `url` to make the Wayback Machine look up
    its copy of the site and date that you typed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect to the web server at that URL and request a particular *web service*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the response data and assign to the variable `contents`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Decode* `contents` to a text string in JSON format, and assign to the variable
    `text`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert `text` to `data`—Python data structures.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Error-checking: `try` to run the next four lines, and if any fail, run the
    last line of the program (after the `except`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we got back a match for this site and date, extract its value from a three-level
    Python *dictionary*. Notice that this line and the next two are indented. That’s
    how Python knows that they go with the preceding `try` line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the URL that we found.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print what will happen after the next line executes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the URL we found in your web browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If anything failed in the previous four lines, Python jumps down to here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it failed, print a message and the site that we were looking for. This is
    indented because it should be run only if the preceding `except` line runs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When I ran this in a terminal window, I typed a site URL and a date, and got
    this text output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: And [Figure 1-3](#img_archive) shows what appeared in my browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![inp2 0103](assets/inp2_0103.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-3\. From the Wayback Machine
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the previous example, we used some of Python’s *standard library* modules
    (programs that are included with Python when it’s installed), but there’s nothing
    sacred about them. Python has a trove of excellent third-party software. [Example 1-5](#ch01_ex5)
    is a rewrite that accesses the Internet Archive website with an external Python
    software package called `requests`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-5\. archive2.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The new version is shorter, and I’d guess it’s more readable for most people.
    You’ll read more about `requests` in [Chapter 18](ch18.html#ch_web), and externally
    authored Python software in general in [Chapter 11](ch11.html#ch_modules).
  prefs: []
  type: TYPE_NORMAL
- en: Python in the Real World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, is learning Python worth the time and effort? Python has been around since
    1991 (older than Java, younger than C), and is consistently in the top five most
    popular computing languages. People are paid to write Python programs—serious
    stuff that you use every day, such as Google, YouTube, Instagram, Netflix, and
    Hulu. I’ve used it for production applications in many areas. Python has a reputation
    for productivity that appeals to fast-moving organizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll find Python in many computing environments, including these:'
  prefs: []
  type: TYPE_NORMAL
- en: The command line in a monitor or terminal window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphical user interfaces (GUIs), including the web
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web, on the client and server sides
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backend servers supporting large popular sites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *cloud* (servers managed by third parties)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedded devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python programs range from one-off *scripts*—such as those you’ve seen so far
    in this chapter—to million-line systems.
  prefs: []
  type: TYPE_NORMAL
- en: '[The 2018 Python Developers’ Survey](https://oreil.ly/8vK7y) has numbers and
    graphs on Python’s current place in the computing world.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at its uses in websites, system administration, and data manipulation.
    In the final chapters, we’ll see specific uses of Python in the arts, science,
    and business.
  prefs: []
  type: TYPE_NORMAL
- en: Python Versus the Language from Planet X
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does Python compare against other languages? Where and when would you choose
    one over the other? In this section, I show code samples from other languages,
    just so you can see what the competition looks like. You are *not* expected to
    understand these if you haven’t worked with them. (By the time you get to the
    final Python sample, you might be relieved that you haven’t had to work with some
    of the others.)
  prefs: []
  type: TYPE_NORMAL
- en: Each program is supposed to print a number and say a little about the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use a terminal or terminal window, the program that reads what you type,
    runs it, and displays the results is called the *shell* program. The Windows shell
    is called [`cmd`](https://en.wikipedia.org/wiki/Cmd.exe); it runs *batch* files
    with the suffix `.bat`. Linux and other Unix-like systems (including macOS) have
    many shell programs. The most popular is called [`bash`](https://www.gnu.org/software/bash)
    or `sh`. The shell has simple abilities, such as simple logic and expanding wildcard
    symbols such as `*` into filenames. You can save commands in files called *shell
    scripts* and run them later. These might be the first programs you encountered
    as a programmer. The problem is that shell scripts don’t scale well beyond a few
    hundred lines, and they are much slower than the alternative languages. The next
    snippet shows a little shell program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you saved this in a file as `test.sh` and ran it with `sh test.sh`, you
    would see the following on your display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Old stalwarts [C](https://oreil.ly/7QKsf) and [C++](https://oreil.ly/iOJPN)
    are fairly low-level languages, used when speed is most important. Your operating
    system and many of its programs (including the `python` program on your computer)
    are probably written in C or C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two are harder to learn and maintain. You need to keep track of many
    details like *memory management*, which can lead to program crashes and problems
    that are difficult to diagnose. Here’s a little C program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'C++ has the C family resemblance but has evolved some distinctive features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[Java](https://www.java.com) and [C#](https://oreil.ly/1wo5A) are successors
    to C and C++ that avoid some of their forebears’ problems—especially memory management—but
    can be somewhat verbose. The example that follows shows some Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you haven’t written programs in any of these languages, you might wonder:
    what is all that *stuff*? We only wanted to print a simple line. Some languages
    carry substantial syntactic baggage. You’ll learn more about this in [Chapter 2](ch02.html#ch_names).'
  prefs: []
  type: TYPE_NORMAL
- en: C, C++, and Java are examples of *static languages*. They require you to specify
    some low-level details like data types for the computer. [Appendix A](app01.html#app_computers)
    shows how a data type like an integer has a specific number of bits in your computer,
    and can only do integer-ey things. In contrast, *dynamic languages* (also called
    *scripting languages*) do not force you to declare variable types before using
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The all-purpose dynamic language for many years was [Perl](http://www.perl.org).
    Perl is very powerful and has extensive libraries. Yet, its syntax can be awkward,
    and the language seems to have lost momentum in the past few years to Python and
    Ruby. This example regales you with a Perl bon mot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[Ruby](http://www.ruby-lang.org) is a more recent language. It borrows a little
    from Perl, and is popular mostly because of *Ruby on Rails*, a web development
    framework. It’s used in many of the same areas as Python, and the choice of one
    or the other might boil down to a matter of taste, or available libraries for
    your particular application. Here’s a Ruby snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PHP](http://www.php.net), which you can see in the example that follows, is
    very popular for web development because it makes it easy to combine HTML and
    code. However, the PHP language itself has a number of gotchas, and PHP has not
    caught on as a general language outside of the web. Here’s what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[Go](https://golang.org) (or *Golang*, if you’re trying to Google it) is a
    recent language that tries to be both efficient and friendly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Another modern alternative to C and C++ is [Rust](https://doc.rust-lang.org):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Who’s left? Oh yes, [Python](https://python.org):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Why Python?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One reason, not necessarily the most important, is popularity. By various measures,
    Python is:'
  prefs: []
  type: TYPE_NORMAL
- en: The [fastest-growing](https://oreil.ly/YHqqD) major programming language, as
    you can see in [Figure 1-4](#fig_1_4).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The editors of the June 2019 [TIOBE Index](https://www.tiobe.com/tiobe-index)
    say: “This month Python has reached again an all time high in TIOBE index of 8.5%.
    If Python can keep this pace, it will probably replace C and Java in 3 to 4 years
    time, thus becoming the most popular programming language of the world.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming language of the year for 2018 (TIOBE), and top ranking by [IEEE
    Spectrum](https://oreil.ly/saRgb) and [PyPL](http://pypl.github.io/PYPL.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most popular language for introductory computer science courses at the top
    [American colleges](http://bit.ly/popular-py).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The official teaching language for high schools in France.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![inp2 0104](assets/inp2_0104.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-4\. Python leads in major programming language growth
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: More recently, it’s become extremely popular in the data science and machine
    learning worlds. If you want to land a well-paying programming job in an interesting
    area, Python is a good choice now. And if you’re hiring, there’s a growing pool
    of experienced Python developers.
  prefs: []
  type: TYPE_NORMAL
- en: But *why* is it popular? Programming languages don’t exactly exude charisma.
    What are some underlying reasons?
  prefs: []
  type: TYPE_NORMAL
- en: Python is a good general-purpose, high-level language. Its design makes it very
    *readable*, which is more important than it sounds. Every computer program is
    written only once, but read and revised many times, often by many people. Being
    readable also makes it easier to learn and remember; hence, more *writable*. Compared
    with other popular languages, Python has a gentle learning curve that makes you
    productive sooner, yet it has depths that you can explore as you gain expertise.
  prefs: []
  type: TYPE_NORMAL
- en: Python’s relative terseness makes it possible for you to write programs that
    are smaller than their equivalents in a static language. Studies have shown that
    programmers tend to produce roughly the same number of lines of code per day—regardless
    of the language—so, halving the lines of code doubles your productivity, just
    like that. Python is the not-so-secret weapon of many companies that think this
    is important.
  prefs: []
  type: TYPE_NORMAL
- en: And of course, Python is free, as in beer (price) and speech (liberty). Write
    anything you want with Python, and use it anywhere, freely. No one can read your
    Python program and say, “That’s a nice little program you have there. It would
    be a shame if something happened to it.”
  prefs: []
  type: TYPE_NORMAL
- en: Python runs almost everywhere and has “batteries included”—a metric boatload
    of useful software in its standard library. This book presents many examples of
    the standard library and useful third-party Python code.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, maybe the best reason to use Python is an unexpected one: people generally
    *enjoy* programming with it rather than seeing it as a necessary evil to get stuff
    done. It doesn’t get in the way. A familiar quote is that it “fits your brain.”
    Often, developers will say that they miss some Python design when they need to
    work in another language. And that separates Python from most of its peers.'
  prefs: []
  type: TYPE_NORMAL
- en: Why Not Python?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python isn’t the best language for every situation.
  prefs: []
  type: TYPE_NORMAL
- en: It is not installed everywhere by default. [Appendix B](app02.html#app_install)
    shows you how to install Python if you don’t already have it on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: It’s fast enough for most applications, but it might not be fast enough for
    some of the more demanding ones. If your program spends most of its time calculating
    things (the technical term is *CPU-bound*), a program written in C, C++, C#, Java,
    Rust, or Go will generally run faster than its Python equivalent. But not always!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes a better *algorithm* (a stepwise solution) in Python beats an inefficient
    one in C. The greater speed of development in Python gives you more time to experiment
    with alternatives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In many applications (notably, the web), a program twiddles its gossamer thumbs
    while awaiting a response from some server across a network. The CPU (central
    processing unit, the computer’s *chip* that does all the calculating) is barely
    involved; consequently, end-to-end times between static and dynamic programs will
    be close.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The standard Python interpreter is written in C and can be extended with C code.
    I discuss this a little in [Chapter 19](ch19.html#ch_pythonista).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python interpreters are becoming faster. Java was terribly slow in its infancy,
    and a lot of research and money went into speeding it up. Python is not owned
    by a corporation, so its enhancements have been more gradual. In [“PyPy”](ch19.html#pypy),
    I talk about the *PyPy* project and its implications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might have an extremely demanding application, and no matter what you do,
    Python doesn’t meet your needs. The usual alternatives are C, C++, and Java. [Go](http://golang.org)
    (which feels like Python but performs like C) or Rust could also be worth a look.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 2 Versus Python 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One medium-sized complication is that there are two versions of Python out
    there. Python 2 has been around forever and is preinstalled on Linux and Apple
    computers. It has been an excellent language, but nothing’s perfect. In computer
    languages, as in many other areas, some mistakes are cosmetic and easy to fix,
    whereas others are hard. Hard fixes are *incompatible*: new programs written with
    them will not work on the old Python system, and old programs written before the
    fix will not work on the new system.'
  prefs: []
  type: TYPE_NORMAL
- en: Python’s creator ([Guido van Rossum](https://www.python.org/~guido)) and others
    decided to bundle the hard fixes together, and introduced them as Python 3 in
    2008. Python 2 is the past, and Python 3 is the future. The final version of Python
    2 is 2.7, and it will be around for while, but it’s the end of the line; there
    will be no Python 2.8. The end of Python 2 language support is in January of 2020.
    Security and other fixes will no longer be made, and many prominent Python packages
    will [drop support](https://python3statement.org) for Python 2 by then. Operating
    systems will soon either drop Python 2 or make 3 their new default. Conversion
    of popular Python software to Python 3 had been gradual, but we’re now well past
    the tipping point. All new development will be in Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: This book is about Python 3. It looks almost identical to Python 2. The most
    obvious change is that `print` is a function in Python 3, so you need to call
    it with parentheses surrounding its arguments. The most important change is the
    handling of *Unicode* characters, which is covered in [Chapter 12](ch12.html#ch_munging).
    I point out other significant differences as they come up.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rather than cluttering this chapter, you can find the details on how to install
    Python 3 in [Appendix B](app02.html#app_install). If you don’t have Python 3,
    or aren’t sure, go there and see what you need to do for your computer. Yes, this
    is a pain in the wazoo (specifically, the right-anterior wazoo), but you’ll need
    to do it only once.
  prefs: []
  type: TYPE_NORMAL
- en: Running Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After you have installed a working copy of Python 3, you can use it to run
    the Python programs in this book as well as your own Python code. How do you actually
    run a Python program? There are two main ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Python’s built-in *interactive interpreter* (also called its *shell*) is the
    easy way to experiment with small programs. You type commands line by line and
    see the results immediately. With the tight coupling between typing and seeing,
    you can experiment faster. I’ll use the interactive interpreter to demonstrate
    language features, and you can type the same commands in your own Python environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For everything else, store your Python programs in text files, normally with
    the *.py* extension, and run them by typing `python` followed by those filenames.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s try both methods now.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Interactive Interpreter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the code examples in this book use the built-in interactive interpreter.
    When you type the same commands as you see in the examples and get the same results,
    you’ll know you’re on the right track.
  prefs: []
  type: TYPE_NORMAL
- en: 'You start the interpreter by typing just the name of the main Python program
    on your computer: it should be `python`, `python3`, or something similar. For
    the rest of this book, we assume it’s called `python`; if yours has a different
    name, type that wherever you see `python` in a code example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The interactive interpreter works almost exactly the same as Python works on
    files, with one exception: when you type something that has a value, the interactive
    interpreter prints its value for you automatically. This isn’t a part of the Python
    language, just a feature of the interpreter to save you from typing `print()`
    all the time. For example, if you start Python and type the number `27` in the
    interpreter, it will be echoed to your terminal (if you have the line `27` in
    a file, Python won’t get upset, but you won’t see anything print when you run
    the program):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding example, `$` is a sample system *prompt* for you to type a
    command like `python` in the terminal window. We use it for the code examples
    in this book, although your prompt might be different.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, `print()` also works within the interpreter whenever you want to
    print something:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you tried these examples with the interactive interpreter and saw the same
    results, you just ran some real (though tiny) Python code. In the next few chapters,
    you’ll graduate from one-liners to longer Python programs.
  prefs: []
  type: TYPE_NORMAL
- en: Using Python Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you put `27` in a file by itself and run it through Python, it will run,
    but it won’t print anything. In normal noninteractive Python programs, you need
    to call the `print` function to print things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s make a Python program file and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type the line `print(27)`, as it appears here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save this to a file called *test.py*. Make sure you save it as plain text rather
    than a “rich” format such as RTF or Word. You don’t need to use the *.py* suffix
    for your Python program files, but it does help you remember what they are.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you’re using a GUI—that’s almost everyone—open a terminal window.^([2](ch01.html#idm45795033687224))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run your program by typing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a single line of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Did that work? If it did, congratulations on running your first standalone Python
    program.
  prefs: []
  type: TYPE_NORMAL
- en: What’s Next?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ll be typing commands to an actual Python system, and they need to follow
    legal Python syntax. Rather than dumping the syntax rules on you all at once,
    we stroll through them over the next few chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The basic way to develop Python programs is by using a plain-text editor and
    a terminal window. I use plain-text displays in this book, sometimes showing interactive
    terminal sessions and sometimes pieces of Python files. You should know that there
    are also many good *integrated development environments* (IDEs) for Python. These
    may feature GUIs with advanced text editing and help displays. You can learn about
    details for some of these in [Chapter 19](ch19.html#ch_pythonista).
  prefs: []
  type: TYPE_NORMAL
- en: Your Moment of Zen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each computing language has its own style. In the Preface, I mentioned that
    there is often a *Pythonic* way to express yourself. Embedded in Python is a bit
    of free verse that expresses the Python philosophy succinctly (as far as I know,
    Python is the only language to include such an Easter egg). Just type `import
    this` into your interactive interpreter and then press the Enter key whenever
    you need this moment of Zen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: I’ll bring up examples of these sentiments throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Coming Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next chapter talks about Python data types and variables. This will prepare
    you for the following chapters, which delve into Python’s data types and code
    structures in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Do
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was an introduction to the Python language—what it does, how it
    looks, and where it fits in the computing world. At the end of each chapter, I
    suggest some mini-projects to help you remember what you just read and prepare
    you for what’s to come.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1 If you don’t already have Python 3 installed on your computer, do it now.
    Read [Appendix B](app02.html#app_install) for the details for your computer system.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2 Start the Python 3 interactive interpreter. Again, details are in [Appendix B](app02.html#app_install).
    It should print a few lines about itself and then a single line starting with
    `>>>`. That’s your prompt to type Python commands.
  prefs: []
  type: TYPE_NORMAL
- en: '1.3 Play with the interpreter a little. Use it like a calculator and type this:
    `8 * 9`. Press the Enter key to see the result. Python should print `72`.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.4 Type the number `47` and press the Enter key. Did it print `47` for you
    on the next line?
  prefs: []
  type: TYPE_NORMAL
- en: 1.5 Now, type `print(47)` and press Enter. Did that also print `47` for you
    on the next line?
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch01.html#idm45795040338904-marker)) Usually only found in cookbooks and
    cozy mysteries.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch01.html#idm45795033687224-marker)) If you’re not sure what this means,
    see [Appendix B](app02.html#app_install) for details for different operating systems.
  prefs: []
  type: TYPE_NORMAL
