- en: Chapter 14\. Files and Directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have files, I have computer files and, you know, files on paper. But most
    of it is really in my head. So God help me if anything ever happens to my head!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: George R. R. Martin
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When you first start programming, you hear some words over and over but aren’t
    sure whether they have a specific technical meaning or are just handwaving. The
    terms *file* and *directory* are such words, and they do have actual technical
    meanings. A *file* is a sequence of bytes, stored in some *filesystem*, and accessed
    by a *filename*. A *directory* is a collection of files, and possibly other directories.
    The term *folder* is a synonym for directory. It turned up when computers gained
    graphical user interfaces, and mimicked office concepts to make things seem more
    familiar.
  prefs: []
  type: TYPE_NORMAL
- en: Many filesystems are hierarchical, and often referred to as being like a tree.
    Real offices don’t tend to have trees in them, and the folder analogy only works
    if you visualize subfolders all the way down.
  prefs: []
  type: TYPE_NORMAL
- en: File Input and Output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest kind of persistence is a plain old file, sometimes called a *flat
    file*. You *read* from a file into memory and *write* from memory to a file. Python
    makes these jobs easy. As with many languages, its file operations were largely
    modeled on the familiar and popular Unix equivalents.
  prefs: []
  type: TYPE_NORMAL
- en: Create or Open with open()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to call the `open` function before you do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Read an existing file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write to a new file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Append to an existing file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overwrite an existing file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a brief explanation of the pieces of this call:'
  prefs: []
  type: TYPE_NORMAL
- en: '*`fileobj`* is the file object returned by `open()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*`filename`* is the string name of the file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*`mode`* is a string indicating the file’s type and what you want to do with
    it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first letter of *`mode`* indicates the *operation*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`r` means read.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w` means write. If the file doesn’t exist, it’s created. If the file does
    exist, it’s overwritten.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x` means write, but only if the file does *not* already exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a` means append (write after the end) if the file exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second letter of *`mode`* is the file’s *type*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`t` (or nothing) means text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`b` means binary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After opening the file, you call functions to read or write data; these will
    be shown in the examples that follow.
  prefs: []
  type: TYPE_NORMAL
- en: Last, you need to *close* the file to ensure that any writes complete, and that
    memory is freed. Later, you’ll see how to use `with` to automate this for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'This program opens a file called *oops.txt* and closes it without writing anything.
    This would create an empty file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Write a Text File with print()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s re-create *oops.txt*, but now write a line to it and then close it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We created an empty *oops.txt* file in the previous section, so this just overwrites
    it.
  prefs: []
  type: TYPE_NORMAL
- en: We used the `file` argument to `print`. Without it, `print` writes to *standard
    output*, which is your terminal (unless you’ve told your shell program to redirect
    output to a file with `>` or piped it to another program with `|`).
  prefs: []
  type: TYPE_NORMAL
- en: Write a Text File with write()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just used `print` to write a line to a file. We can also use `write`.
  prefs: []
  type: TYPE_NORMAL
- en: For our multiline data source, let’s use this limerick about special relativity:^([1](ch14.html#idm45794985259544))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code writes the entire poem to the file `''relativity''` in one
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `write` function returns the number of bytes written. It does not add any
    spaces or newlines, as `print` does. As before, you can also `print` a multiline
    string to a text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'So, should you use `write` or `print`? As you’ve seen, by default `print` adds
    a space after each argument and a newline at the end. In the previous example,
    it appended a newline to the `relativity` file. To make `print` work like `write`,
    pass it the following two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sep` (separator, which defaults to a space, `'' ''`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`end` (end string, which defaults to a newline, `''\n''`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ll use empty strings to replace these defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a large source string, you can also write chunks (using slices)
    until the source is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This wrote 100 characters on the first try and the last 50 characters on the
    next. Slices allow you to “go over the end” without raising an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `relativity` file is precious to us, let’s see whether using mode `x`
    really protects us from overwriting it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use this with an exception handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Read a Text File with read(), readline(), or readlines()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can call `read()` with no arguments to slurp up the entire file at once,
    as shown in the example that follows (be careful when doing this with large files;
    a gigabyte file will consume a gigabyte of memory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can provide a maximum character count to limit how much `read()` returns
    at one time. Let’s read 100 characters at a time and append each chunk to a `poem`
    string to rebuild the original:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve read all the way to the end, further calls to `read()` will return
    an empty string (`''`), which is treated as `False` in `if not fragment`. This
    breaks out of the `while True` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also read the file a line at a time by using `readline()`. In this
    next example, we append each line to the `poem` string to rebuild the original:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For a text file, even a blank line has a length of one (the newline character),
    and is evaluated as `True`. When the file has been read, `readline()` (like `read()`)
    also returns an empty string, which is also evaluated as `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to read a text file is by using an *iterator*. This returns
    one line at a time. It’s similar to the previous example but with less code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the preceding examples eventually built the single string `poem`. The
    `readlines()` call reads a line at a time, and returns a list of one-line strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We told `print()` to suppress the automatic newlines because the first four
    lines already had them. The last line did not, causing the interactive prompt
    `>>>` to occur right after the last line.
  prefs: []
  type: TYPE_NORMAL
- en: Write a Binary File with write()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you include a `'b'` in the *mode* string, the file is opened in binary mode.
    In this case, you read and write `bytes` instead of a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don’t have a binary poem lying around, so we’ll just generate the 256 byte
    values from 0 to 255:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the file for writing in binary mode and write all the data at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Again, `write()` returns the number of bytes written.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with text, you can write binary data in chunks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Read a Binary File with read()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This one is simple; all you need to do is just open with `''rb''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Close Files Automatically by Using with
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you forget to close a file that you’ve opened, it will be closed by Python
    after it’s no longer referenced. This means that if you open a file within a function
    and don’t close it explicitly, it will be closed automatically when the function
    ends. But you might have opened the file in a long-running function or the main
    section of the program. The file should be closed to force any remaining writes
    to be completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python has *context managers* to clean up things such as open files. You use
    the form `with` *`expression`* `as` *`variable`*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: That’s it. After the block of code under the context manager (in this case,
    one line) completes (normally *or* by a raised exception), the file is closed
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Change Position with seek()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you read and write, Python keeps track of where you are in the file. The
    `tell()` function returns your current offset from the beginning of the file,
    in bytes. The `seek()` function lets you jump to another byte offset in the file.
    This means that you don’t have to read every byte in a file to read the last one;
    you can `seek()` to the last one and just read one byte.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, use the 256-byte binary file `''bfile''` that you wrote earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `seek()` to jump to one byte before the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Read until the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`seek()` also returns the current offset.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can call `seek()` with a second argument: ``seek(*`offset`*, *`origin`*)``:'
  prefs: []
  type: TYPE_NORMAL
- en: If `origin` is `0` (the default), go *`offset`* bytes from the start
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `origin` is `1`, go *`offset`* bytes from the current position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `origin` is `2`, go *`offset`* bytes relative to the end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These values are also defined in the standard `os` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we could have read the last byte in different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'One byte before the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Read until the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You don’t need to call `tell()` for `seek()` to work. I just wanted to show
    that they both report the same offset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of seeking from the current position in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This next example ends up two bytes before the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now go forward one byte:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, read until the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: These functions are most useful for binary files. You can use them with text
    files, but unless the file is ASCII (one byte per character), you would have a
    hard time calculating offsets. These would depend on the text encoding, and the
    most popular encoding (UTF-8) uses varying numbers of bytes per character.
  prefs: []
  type: TYPE_NORMAL
- en: Memory Mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An alternative to reading and writing a file is to *memory-map* it with the
    standard `mmap` module. This makes the contents of a file look like a `bytearray`
    in memory. See the [documentation](https://oreil.ly/GEzkf) and some [examples](https://oreil.ly/GUtdx)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: File Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python, like many other languages, patterned its file operations after Unix.
    Some functions, such as `chown()` and `chmod()`, have the same names, but there
    are a few new ones.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll first show how Python handles these tasks with functions from the `os.path`
    module and then with the newer `pathlib` module.
  prefs: []
  type: TYPE_NORMAL
- en: Check Existence with exists()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To verify whether the file or directory is really there or you just imagined
    it, you can provide `exists()`, with a relative or absolute pathname, as demonstrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Check Type with isfile()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The functions in this section check whether a name refers to a file, directory,
    or symbolic link (see the examples that follow for a discussion of links).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first function we’ll look at, `isfile`, asks a simple question: is it a
    plain old law-abiding file?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how you determine a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'A single dot (`.`) is shorthand for the current directory, and two dots (`..`)
    stands for the parent directory. These always exist, so a statement such as the
    following will always report `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `os` module contains many functions dealing with *pathnames* (fully qualified
    filenames, starting with `/` and including all parents). One such function, `isabs()`,
    determines whether its argument is an absolute pathname. The argument doesn’t
    need to be the name of a real file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Copy with copy()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `copy()` function comes from another module, `shutil`. This example copies
    the file *oops.txt* to the file *ohno.txt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `shutil.move()` function copies a file and then removes the original.
  prefs: []
  type: TYPE_NORMAL
- en: Change Name with rename()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This function does exactly what it says. In the example here, it renames *ohno.txt*
    to *ohwell.txt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Link with link() or symlink()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Unix, a file exists in one place, but it can have multiple names, called
    *links*. In low-level *hard links*, it’s not easy to find all the names for a
    given file. A *symbolic link* is an alternative method that stores the new name
    as its own file, making it possible for you to get both the original and new names
    at once. The `link()` call creates a hard link, and `symlink()` makes a symbolic
    link. The `islink()` function checks whether the file is a symbolic link.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to make a hard link to the existing file *oops.txt* from the new
    file *yikes.txt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a symbolic link to the existing file *oops.txt* from the new file
    *jeepers.txt*, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Change Permissions with chmod()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On a Unix system, `chmod()` changes file permissions. There are read, write,
    and execute permissions for the user (that’s usually you, if you created the file),
    the main group that the user is in, and the rest of the world. The command takes
    an intensely compressed octal (base 8) value that combines user, group, and other
    permissions. For instance, to make *oops.txt* readable only by its owner, type
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t want to deal with cryptic octal values and would rather deal with
    (slightly less) obscure cryptic symbols, you can import some constants from the
    `stat` module and use a statement such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Change Ownership with chown()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This function is also Unix/Linux/Mac–specific. You can change the owner and/or
    group ownership of a file by specifying the numeric user ID (*uid*) and group
    ID (*gid*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Delete a File with remove()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this snippet, we use the `remove()` function and say farewell to *oops.txt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Directory Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most operating systems, files exist in a hierarchy of *directories* (often
    called *folders*). The container of all of these files and directories is a *filesystem*
    (sometimes called a *volume*). The standard `os` module deals with operating specifics
    such as these and provides the following functions with which you can manipulate
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Create with mkdir()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example shows how to create a directory called `poems` to store that precious
    verse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Delete with rmdir()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Upon second thought,^([2](ch14.html#idm45794983042312)) you decide you don’t
    need that directory after all. Here’s how to delete it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: List Contents with listdir()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'OK, take two; let’s make `poems` again, with some contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now get a list of its contents (none so far):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, make a subdirectory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file in this subdirectory (don’t type all these lines unless you really
    feel poetic; just make sure you begin and end with matching quotes, either single
    or tripled):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let’s see what we have. It had better be there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Change Current Directory with chdir()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With this function, you can go from one directory to another. Let’s leave the
    current directory and spend a little time in `poems`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: List Matching Files with glob()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `glob()` function matches file or directory names by using Unix shell rules
    rather than the more complete regular expression syntax. Here are those rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*` matches everything (`re` would expect `.*`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`?` matches a single character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[abc]` matches character `a`, `b`, or `c`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[!abc]` matches any character *except* `a`, `b`, or `c`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Try getting all files or directories that begin with `m`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: How about any two-letter files or directories?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'I’m thinking of an eight-letter word that begins with `m` and ends with `e`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: What about anything that begins with a `k`, `l`, or `m`, and ends with `e`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Pathnames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Almost all of our computers use hierarchical filesystems, with directories
    (“folders”) containing files and other directories, down to various levels. When
    you want to refer to a specific file or directory, you need its *pathname*: the
    sequence of directories needed to get there, either *absolute* from the top (the
    *root*), or *relative* to your current directory.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll often hear people confusing a forward *slash* (`'/'`, not the Guns N’
    Roses guy) and *backslash* (`'\'`).^([3](ch14.html#idm45794982611688)) Unix and
    Macs (and web URLs) use slash as the *path separator*, and Windows uses backslash.^([4](ch14.html#idm45794982605768))
  prefs: []
  type: TYPE_NORMAL
- en: 'Python lets you use slash as the path separator when you’re specifying names.
    On Windows, you can use backslash, but you know that backslash is a ubiquitous
    escape character in Python, so you have to double it everywhere, or use Python’s
    raw strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'When you’re building a pathname, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the appropriate path separation character (`'/'` or `'\'`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a pathname (see [“Build a Pathname with os.path.join()”](#os_path_join))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use pathlib (see [“Use pathlib”](#pathlib))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a Pathname with abspath()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This function expands a relative name to an absolute one. If your current directory
    is */usr/gaberlunzie* and the file *oops.txt* is there, you can type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Get a symlink Pathname with realpath()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In one of the earlier sections, we made a symbolic link to *oops.txt* from
    the new file *jeepers.txt*. In circumstances such as this, you can get the name
    of *oops.txt* from *jeepers.txt* by using the `realpath()` function, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Build a Pathname with os.path.join()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you’re constructing a multipart pathname, you can call `os.path.join()`
    to combine them pairwise with the proper path separation character for your operating
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If I run this on a Mac or Linux box, I get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Running on Windows would produce this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: But if the same code produces different result depending on where it’s run,
    that could be a problem. The new `pathlib` module is a portable solution to this.
  prefs: []
  type: TYPE_NORMAL
- en: Use pathlib
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python added the `pathlib` module in version 3.4. It’s an alternative to the
    `os.path` modules that I just described. But why do we need another module?
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather that treating filesystem pathnames as strings, it introduces the `Path`
    object to treat them at a little higher level. Create a `Path` with the `Path()`
    class, and then knit your path together with bare slashes (not `''/''` characters):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This slash trick took advantage of Python’s [“Magic Methods”](ch10.html#magic_methods).
    A `Path` can tell you a bit about itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: You can feed `file_path` to `open()` as you would any filename or pathname string.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also see what would happen if you ran this program on another system
    or if you needed to generate foreign pathnames on your computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: See the [docs](https://oreil.ly/yN87f) for all the details.
  prefs: []
  type: TYPE_NORMAL
- en: BytesIO and StringIO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve seen how to modify data in memory and how to get data in and out of files.
    What do you do if you have in-memory data, but want to call a function that expects
    a file (or the reverse)? You’d want to modify the data and pass those bytes or
    characters around, without reading and writing temporary files.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `io.BytesIO` for binary data (`bytes`) and `io.StringIO` for text
    data (`str`). Using either of these wraps data as a *file-like object*, suitable
    to use with all the file functions you’ve seen in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: One use case for this is data format conversion. Let’s apply this to the PIL
    library (details coming in [“PIL and Pillow”](ch20.html#pil)), which reads and
    writes image data. The first argument to its `Image` object’s `open()` and `save()`
    methods is a filename *or a file-like object*. The code in [Example 14-1](#ex1401)
    uses `BytesIO` to read *and* write in-memory data. It reads one or more image
    files from the command line, converts its image data to three different formats,
    and prints the length and first 10 bytes of these outputs.
  prefs: []
  type: TYPE_NORMAL
- en: Example 14-1\. convert_image.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because it acts like a file, you can `seek()`, `read()`, and `write()` a `BytesIO`
    object just like a normal file; if you did a `seek()` followed by a `read()`,
    you would get only the bytes from that seek position to the end. That `getvalue()`
    returns all the bytes in the `BytesIO` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the output, using an input image file that you’ll see in [Chapter 20](ch20.html#ch_art):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Coming Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next chapter is a bit more complex. It deals with *concurrency* (ways of
    doing multiple things at about the same time) and *processes* (running programs).
  prefs: []
  type: TYPE_NORMAL
- en: Things to Do
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 14.1 List the files in your current directory.
  prefs: []
  type: TYPE_NORMAL
- en: 14.2 List the files in your parent directory.
  prefs: []
  type: TYPE_NORMAL
- en: 14.3 Assign the string `'This is a test of the emergency text system'` to the
    variable `test1`, and write `test1` to a file called *test.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: 14.4 Open the file *test.txt* and read its contents into the string `test2`.
    Are `test1` and `test2` the same?
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch14.html#idm45794985259544-marker)) In the first manuscript of this book,
    I said *general* relativity, and was kindly corrected by a physicist reviewer.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch14.html#idm45794983042312-marker)) Why is it never first?
  prefs: []
  type: TYPE_NORMAL
- en: '^([3](ch14.html#idm45794982611688-marker)) One way to remember: forward slash
    tilts *forward*, backslash tilts *back*.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch14.html#idm45794982605768-marker)) QDOS was the operating system that
    Bill Gates bought for $50,000 to have “MS-DOS” when IBM came calling about their
    first PC. It mimicked CP/M, which used slashes for command-line arguments. When
    MS-DOS later added folders, it had to use backslashes.
  prefs: []
  type: TYPE_NORMAL
