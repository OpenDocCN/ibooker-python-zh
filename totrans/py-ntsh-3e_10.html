<html><head></head><body>
<div id="sbo-rt-content"><section data-nutshell-tab="Regular Expressions" data-pdf-bookmark="Chapter 10. Regular Expressions" data-type="chapter" epub:type="chapter"><div class="chapter" id="regular_expressions">
<h1><span class="label">Chapter 10. </span>Regular Expressions</h1>
<p>Regular expressions (REs, aka regexps)<a contenteditable="false" data-primary="regexps" data-type="indexterm" id="idm44924521879312"/> let programmers specify pattern strings and perform searches and substitutions. Regular expressions are not easy to master, but they can be a powerful tool for processing text. Python offers rich regular expression functionality through the built-in <span class="code">re</span> module. In this chapter, we thoroughly present all about Python’s REs.</p>
<section data-pdf-bookmark="Regular Expressions and the re Module" data-type="sect1"><div class="sect1" id="regular_expressions_and_the_re_module">
<h1>Regular Expressions and the re Module</h1>
<p>A<a contenteditable="false" data-primary="re module" data-type="indexterm" id="remodule10"/><a contenteditable="false" data-primary="regular expressions (REs)" data-secondary="re module" data-type="indexterm" id="REremof10"/><a contenteditable="false" data-primary="standard library modules" data-secondary="re" data-type="indexterm" id="SLMre10"/> regular expression is built from a string that represents a pattern. With RE functionality, you can examine any string and check which parts of the string, if any, match the pattern.</p>
<p>The <span class="code">re</span> module supplies Python’s RE functionality. The <span class="code">compile</span> function builds an RE object from a pattern string and optional flags. The methods of an RE object look for matches of the RE in a string or perform substitutions. The <span class="code">re</span> module also exposes functions equivalent to an RE object’s methods, but with the RE’s pattern string as the first argument.</p>
<p>This chapter covers the use of REs in Python; it does not teach every minute detail about how to create RE patterns. For general coverage of REs, we recommend the book <em>Mastering Regular Expressions</em>, by Jeffrey Friedl (O’Reilly), offering thorough coverage of REs at both tutorial and advanced levels. Many tutorials and references on REs can also be found online, including an excellent, detailed tutorial in Python’s <a href="https://oreil.ly/tj7jh">online docs</a>. Sites like<a contenteditable="false" data-primary="Pythex site" data-type="indexterm" id="idm44924521846752"/> <a href="http://pythex.org">Pythex</a> and<a contenteditable="false" data-primary="regex101 site" data-type="indexterm" id="idm44924521844864"/> <a href="https://regex101.com">regex101</a> let you test your REs interactively. Alternatively, you can start IDLE, the Python REPL, or any other interactive interpreter, <span class="code"><strong>import</strong></span> <span class="code">re</span>, and experiment directly.</p>
<section data-pdf-bookmark="REs and bytes Versus str" data-type="sect2"><div class="sect2" id="res_and_bytes_versus_str">
<h2>REs and bytes Versus str</h2>
<p>REs in Python work in two ways, depending on the type of the object being matched: when applied to <span class="code">str</span> instances, an RE matches accordingly (e.g., a Unicode character <span class="code"><em>c</em></span> is deemed to be “a letter” if <span class="code">'LETTER'</span> <span class="code"><strong>in</strong></span> <span class="code">unicodedata.name(<em>c</em>)</span>); when applied to <span class="code">bytes</span> instances, an RE matches in terms of ASCII (e.g., a byte <span class="code"><em>c</em></span> is deemed to be “a letter” if <span class="code"><em>c</em></span> <span class="code"><strong>in</strong></span> <span class="code">string.ascii_letters</span>). For example:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">re</code><code>
</code><code class="nb">print</code><code class="p">(</code><code class="n">re</code><code class="o">.</code><code class="n">findall</code><code class="p">(</code><code class="sa">r</code><code class="s1">'</code><code class="s1">\</code><code class="s1">w+</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">cittá</code><code class="s1">'</code><code class="p">)</code><code class="p">)</code><code>            </code><em><code class="c1"># prints: ['cittá']</code></em><code>
</code><code class="nb">print</code><code class="p">(</code><code class="n">re</code><code class="o">.</code><code class="n">findall</code><code class="p">(</code><code class="sa">rb</code><code class="s1">'</code><code class="s1">\</code><code class="s1">w+</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">cittá</code><code class="s1">'</code><code class="o">.</code><code class="n">encode</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">)</code><em><code>  </code><code class="c1"># prints: [b'citt']</code></em></pre>
</div></section>
<section data-pdf-bookmark="Pattern String Syntax" data-type="sect2"><div class="sect2" id="pattern_string_syntax">
<h2>Pattern String Syntax</h2>
<p>The<a contenteditable="false" data-primary="pattern string syntax" data-type="indexterm" id="idm44924521790992"/><a contenteditable="false" data-primary="\ (backslash)" data-primary-sortas="{\(backslash)" data-secondary="re module" data-type="indexterm" id="idm44924521789888"/> pattern string representing a regular expression follows a specific syntax:</p>
<ul>
<li>
<p>Alphabetic and numeric characters stand for themselves. An RE whose pattern is a string of letters and digits matches the same string.</p>
</li>
<li>
<p>Many alphanumeric characters acquire special meaning in a pattern when they are preceded by a backslash (<span class="code">\</span>), or <em>escaped</em>.</p>
</li>
<li>
<p>Punctuation characters work the other way around: they stand for themselves when escaped but have special meaning when unescaped.</p>
</li>
<li>
<p>The backslash character is matched by a repeated backslash (<span class="code">\\</span>).</p>
</li>
</ul>
<p>An RE pattern is a string concatenating one or more pattern elements; each element in turn is itself an RE pattern. For example, <span class="code">r'a'</span> is a one-element RE pattern that matches the letter <span class="code">a</span>, and <span class="code">r'ax'</span> is a two-element RE pattern that matches an <span class="code">a</span> immediately followed by an <span class="code">x</span>.</p>
<p>Since RE patterns often contain backslashes, it’s best to always specify RE patterns in raw string literal form (covered in <a data-type="xref" href="ch03.xhtml#string">“Strings”</a>). Pattern elements (such as <span class="code">r'\t'</span>, equivalent to the string literal <span class="code">'\\t'</span>) do match the corresponding special characters (in this case, the tab character <span class="code">\t</span>), so you can use a raw string literal even when you need a literal match for such special characters.</p>
<p><a data-type="xref" href="#re_pattern_syntax">Table 10-1</a> lists the special elements in RE pattern syntax. The exact meanings of some pattern elements change when you use optional flags, together with the pattern string, to build the RE object. The optional flags are covered in <a data-type="xref" href="#optional_flags">“Optional Flags”</a>.</p>
<table class="border" id="re_pattern_syntax">
<caption><span class="label">Table 10-1. </span>RE pattern syntax</caption>
<thead>
<tr>
<th>Element</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="code">.</span></td>
<td>Matches any single character except <span class="code">\n</span> (if <span class="code">DOTALL</span>, also matches <span class="code">\n</span>)</td>
</tr>
<tr>
<td><span class="code">^</span></td>
<td>Matches start of string (if <span class="code">MULTILINE</span>, also matches right after <span class="code">\n</span>)</td>
</tr>
<tr>
<td><span class="code">$</span></td>
<td>Matches end of string (if <span class="code">MULTILINE</span>, also matches right before <span class="code">\n</span>)</td>
</tr>
<tr>
<td><span class="code">*</span></td>
<td>Matches zero or more cases of the previous RE; greedy (matches as many as possible)</td>
</tr>
<tr>
<td><span class="code">+</span></td>
<td>Matches one or more cases of the previous RE; greedy (matches as many as possible)</td>
</tr>
<tr>
<td><span class="code">?</span></td>
<td>Matches zero or one cases of the previous RE; greedy (matches one if possible)</td>
</tr>
<tr>
<td><span class="code">*?</span>, <span class="code">+?</span>, <span class="code">??</span></td>
<td>Nongreedy<a contenteditable="false" data-primary="? (question mark)" data-type="indexterm" id="idm44924521718096"/><a contenteditable="false" data-primary="question mark (?)" data-type="indexterm" id="idm44924521716960"/> versions of <span class="code">*</span>, <span class="code">+</span>, and <span class="code">?</span>, respectively (match as few as possible)</td>
</tr>
<tr>
<td><span class="code">{<em>m</em>}</span></td>
<td>Matches <span class="code"><em>m</em></span> cases of the previous RE</td>
</tr>
<tr>
<td><span class="code">{<em>m</em>,</span> <span class="code"><em>n</em></span><span class="code">}</span></td>
<td>Matches between <span class="code"><em>m</em></span> and <span class="code"><em>n</em></span> cases of the previous RE; <span class="code"><em>m</em></span> or <span class="code"><em>n</em></span> (or both) may be omitted, defaulting to <span class="code"><em>m</em></span><span class="code">=0</span> and <span class="code"><em>n</em></span><span class="code">=infinity</span> (greedy)</td>
</tr>
<tr>
<td><span class="code">{<em>m</em>,</span> <span class="code"><em>n</em></span><span class="code">}?</span></td>
<td>Matches between <span class="code"><em>m</em></span> and <span class="code"><em>n</em></span> cases of the previous RE (nongreedy)</td>
</tr>
<tr>
<td><span class="code">[...]</span></td>
<td>Matches any one of a set of characters contained within the brackets</td>
</tr>
<tr>
<td><span class="code">[^...]</span></td>
<td>Matches one character <em>not</em> contained within the brackets after the caret <span class="code">^</span></td>
</tr>
<tr>
<td><span class="code">|</span></td>
<td>Matches either the preceding RE or the following RE</td>
</tr>
<tr>
<td><span class="code">(...)</span></td>
<td>Matches the RE within the parentheses and indicates a <em>group</em></td>
</tr>
<tr>
<td><span class="code">(?aiLmsux)</span></td>
<td>Alternate way to set optional flags<sup><a data-type="noteref" href="ch10.xhtml#ch01fn97" id="ch01fn97-marker">a</a></sup></td>
</tr>
<tr>
<td><span class="code">(?:...)</span></td>
<td>Like <span class="code">(...)</span> but does not capture the matched characters in a group</td>
</tr>
<tr>
<td><span class="code">(?P<em>&lt;id&gt;</em>...)</span></td>
<td>Like <span class="code">(...)</span> but the group also gets the name <span class="code"><em>&lt;id&gt;</em></span></td>
</tr>
<tr>
<td><span class="code">(?P=<em>&lt;id&gt;</em>)</span></td>
<td>Matches whatever was previously matched by the group named <span class="code"><em>&lt;id&gt;</em></span></td>
</tr>
<tr>
<td><span class="code">(?#...)</span></td>
<td>Content of parentheses is just a comment; no effect on match</td>
</tr>
<tr>
<td><span class="code">(?=...)</span></td>
<td><em>Lookahead assertion</em>: matches if RE <span class="code">...</span> matches what comes next, but does not consume any part of the string</td>
</tr>
<tr>
<td><span class="code">(?!...)</span></td>
<td><em>Negative lookahead assertion</em>: matches if RE <span class="code">...</span> does <em>not</em> match what comes next, and does not consume any part of the string</td>
</tr>
<tr>
<td><span class="code">(?&lt;=...)</span></td>
<td><em>Lookbehind assertion</em>: matches if there is a match ending at the current position for RE <span class="code">...</span> (<span class="code">...</span> must match a fixed length)</td>
</tr>
<tr>
<td><span class="code">(?&lt;!...)</span></td>
<td><em>Negative lookbehind assertion</em>: matches if there is no match ending at the current position for RE <span class="code">...</span> (<span class="code">...</span> must match a fixed length)</td>
</tr>
<tr>
<td><span class="code">\</span> <span class="code"><em>number</em></span></td>
<td>Matches whatever was previously matched by the group numbered <span class="code"><em>number</em></span> (groups are automatically numbered left to right, from <span class="code">1</span> to <span class="code">99</span>)</td>
</tr>
<tr>
<td><span class="code">\A</span></td>
<td>Matches an empty string, but only at the start of the whole string</td>
</tr>
<tr>
<td><span class="code">\b</span></td>
<td>Matches an empty string, but only at the start or end of a <em>word</em> (a maximal sequence of alphanumeric characters; see also <span class="code">\w</span>)</td>
</tr>
<tr>
<td><span class="code">\B</span></td>
<td>Matches an empty string, but not at the start or end of a word</td>
</tr>
<tr>
<td><span class="code">\d</span></td>
<td>Matches one digit, like the set <span class="code">[0-9]</span> (in Unicode mode, many other Unicode characters also count as “digits” for <span class="code">\d</span>, but not for <span class="code">[0-9]</span>)</td>
</tr>
<tr>
<td><span class="code">\D</span></td>
<td>Matches one nondigit character, like the set <span class="code">[^0-9]</span> (in Unicode mode, many other Unicode characters also count as “digits” for <span class="code">\D</span>, but not for <span class="code">[^0-9]</span>)</td>
</tr>
<tr>
<td><span class="code">\N{<em>name</em>}</span></td>
<td><span class="version">3.8+</span> Matches the Unicode character corresponding to <em>name</em></td>
</tr>
<tr>
<td><span class="code">\s</span></td>
<td>Matches a whitespace character, like the set <span class="code">[\t\n\r\f\v]</span></td>
</tr>
<tr>
<td><span class="code">\S</span></td>
<td>Matches a nonwhitespace character, like the set <span class="code">[^\t\n\r\f\v]</span></td>
</tr>
<tr>
<td><span class="code">\w</span></td>
<td>Matches one alphanumeric character; unless in Unicode mode, or if <span class="code">LOCALE</span> or <span class="code">UNICODE</span> is set, <span class="code">\w</span> is like <span class="code">[a-zA-Z0-9_]</span></td>
</tr>
<tr>
<td><span class="code">\W</span></td>
<td>Matches one nonalphanumeric character, the reverse of <span class="code">\w</span></td>
</tr>
<tr>
<td><span class="code">\Z</span></td>
<td>Matches an empty string, but only at the end of the whole string</td>
</tr>
<tr>
<td><span class="code">\\</span></td>
<td>Matches one backslash character</td>
</tr>
</tbody>
<tbody><tr class="footnotes"><td colspan="2"><p data-type="footnote" id="ch01fn97"><sup><a href="ch10.xhtml#ch01fn97-marker">a</a></sup> Always place the <span class="code">(?...)</span> construct for setting flags, if any, at the start of the pattern, for readability; placing it elsewhere raises <span class="code">DeprecationWarning</span>.</p></td></tr></tbody></table>
<p>Using a <span class="code">\</span> character followed by an alphabetic character not listed here or in <a data-type="xref" href="ch03.xhtml#operator_precedence_in_expressions">Table 3-4</a> raises an <span class="code">re.error</span> exception.</p>
</div></section>
<section data-pdf-bookmark="Common Regular Expression Idioms" data-type="sect2"><div class="sect2" id="common_regular_expression_idioms">
<h2>Common Regular Expression Idioms</h2>
<div data-type="tip">
<h1>Always Use r’...’ Syntax for RE Pattern Literals</h1>
<p>Use raw string literals for all RE pattern literals, and only for them. This ensures you’ll never forget to escape a backslash (<span class="code">\</span>), and improves code readability since it makes your RE pattern literals stand out.</p>
</div>
<p><span class="code">.*</span> as a substring of a regular expression’s pattern string means “any number of repetitions (zero or more) of any character.” In other words, <span class="code">.*</span> matches any substring of a target string, including the empty substring. <span class="code">.+</span> is similar but matches only a nonempty substring. For example, this:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="sa">r</code><code class="s1">'pre.*post'</code></pre>
<p>matches a string containing a substring <span class="code">'pre'</span> followed by a later substring <span class="code">'post'</span>, even if the latter is adjacent to the former (e.g., it matches both <span class="code">'prepost'</span> and <span class="code">'pre23post'</span>). On the other hand, this:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="sa">r</code><code class="s1">'pre.+post'</code></pre>
<p>matches only if <span class="code">'pre'</span> and <span class="code">'post'</span> are not adjacent (e.g., it matches <span class="code">'pre23post'</span> but does not match <span class="code">'prepost'</span>). Both patterns also match strings that continue after the <span class="code">'post'</span>. To constrain a pattern to match only strings that <em>end</em> with <span class="code">'post'</span>, end the pattern with <span class="code">\Z</span>. For example, this:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="sa">r</code><code class="s1">'pre.*post\Z'</code></pre>
<p>matches <span class="code">'prepost'</span> but not <span class="code">'preposterous'</span>.</p>
<p>All of these examples are<a contenteditable="false" data-primary="greedy matching" data-type="indexterm" id="idm44924521572400"/> <em>greedy</em>, meaning that they match the substring beginning with the first occurrence of <span class="code">'pre'</span> all the way to the <em>last</em> occurrence of <span class="code">'post'</span>. When you care about what part of the string you match, you may often want to<a contenteditable="false" data-primary="nongreedy matching" data-type="indexterm" id="idm44924521547792"/> specify <em>nongreedy</em> matching, which in our example would match the substring beginning with the first occurrence of <span class="code">'pre'</span> but only up to the <em>first</em> following occurrence of <span class="code">'post'</span>.</p>
<p>For example, when the string is <span class="code">'preposterous and post facto'</span>, the greedy RE pattern <span class="code">r'pre.*post'</span> matches the substring <span class="code">'preposterous and post'</span>; the nongreedy variant <span class="code">r'pre.*?post'</span> matches just the substring <span class="code">'prepost'</span>.</p>
<p>Another frequently used element in RE patterns is <span class="code">\b</span>, which matches a word boundary. To match the word <span class="code">'his'</span> only as a whole word and not its occurrences as a substring in such words as <span class="code">'this'</span> and <span class="code">'history'</span>, the RE pattern is:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="sa">r</code><code class="s1">'\bhis\b'</code></pre>
<p>with word boundaries both before and after. To match the beginning of any word starting with <span class="code">'her'</span>, such as <span class="code">'her'</span> itself and <span class="code">'hermetic'</span>, but not words that just contain <span class="code">'her'</span> elsewhere, such as <span class="code">'ether'</span> or <span class="code">'there'</span>, use:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="sa">r</code><code class="s1">'\bher'</code></pre>
<p>with a word boundary before, but not after, the relevant string. To match the end of any word ending with <span class="code">'its'</span>, such as <span class="code">'its'</span> itself and <span class="code">'fits'</span>, but not words that contain <span class="code">'its'</span> elsewhere, such as <span class="code">'itsy'</span> or <span class="code">'jujitsu'</span>, use:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="sa">r</code><code class="s1">'its\b'</code></pre>
<p>with a word boundary after, but not before, the relevant string. To match whole words thus constrained, rather than just their beginning or end, add a pattern element <span class="code">\w*</span> to match zero or more word characters. To match any full word starting with <span class="code">'her'</span>, use:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="sa">r</code><code class="s1">'\bher\w*'</code></pre>
<p>To match just the first three letters of any word starting with <span class="code">'her'</span>, but not the word <span class="code">'her'</span> itself, use a negative word boundary <span class="code">\B</span>:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="sa">r</code><code class="s1">'\bher\B'</code></pre>
<p>To match any full word ending with <span class="code">'its'</span>, including <span class="code">'its'</span> itself, use:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="sa">r</code><code class="s1">'\w*its\b'</code></pre>
</div></section>
<section data-pdf-bookmark="Sets of Characters" data-type="sect2"><div class="sect2" id="sets_of_characters">
<h2>Sets of Characters</h2>
<p>You<a contenteditable="false" data-primary="sets of characters" data-type="indexterm" id="idm44924521453232"/><a contenteditable="false" data-primary="character sets" data-type="indexterm" id="idm44924521404720"/> denote sets of characters in a pattern by listing the characters within brackets (<span class="code">[]</span>). In addition to listing characters, you can denote a range by giving the first and last characters of the range separated by a hyphen (<span class="code">-</span>). The last character of the range is included in the set, differently from other Python ranges. Within a set, special characters stand for themselves, except <span class="code">\</span>, <span class="code">]</span>, and <span class="code">-</span>, which you must escape (by preceding them with a backslash) when their position is such that, if not escaped, they would form part of the set’s syntax. You can denote a class of characters within a set by escaped-letter notation, such as <span class="code">\d</span> or <span class="code">\S</span>. <span class="code">\b</span> in a set means a backspace character (<span class="code">chr(8)</span>), not a word boundary. If the first character in the set’s pattern, right after the <span class="code">[</span>, is a caret (<span class="code">^</span>), the set is <em>complemented</em>: such a set matches any character <em>except</em> those that follow <span class="code">^</span> in the set pattern notation.</p>
<p>A frequent use of character sets is to match a “word,” using a definition of which characters can make up a word that differs from <span class="code">\w</span>’s default (letters and digits). To match a word of one or more characters, each of which can be an ASCII letter, an apostrophe, or a hyphen, but not a digit (e.g., <span class="code">"Finnegan-O'Hara"</span>), use:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="sa">r</code><code class="s2">"[a-zA-Z'\-]+"</code></pre>
<div data-type="tip">
<h1>Always Escape Hyphens in Character Sets</h1>
<p>It’s not strictly necessary to escape the hyphen with a backslash in this case, since its position at the end of the set makes the situation syntactically unambiguous. However, using the backslash is advisable because it makes the pattern more readable, by visually distinguishing the hyphen that you want to have as a character in the set from those used to denote ranges. (When you want to include a backslash in the character set, of course, you denote that by escaping the backslash itself: write it as <span class="code">\\</span>.)</p>
</div>
</div></section>
<section data-pdf-bookmark="Alternatives" data-type="sect2"><div class="sect2" id="alternatives">
<h2>Alternatives</h2>
<p>A vertical bar (<span class="code">|</span>) in a regular expression pattern, used to specify alternatives, has low syntactic precedence. Unless parentheses change the grouping, <span class="code">|</span> applies to the whole pattern on either side, up to the start or end of the pattern, or to another <span class="code">|</span>. A pattern can be made up of any number of subpatterns joined by <span class="code">|</span>. It is important to note that an RE of subpatterns joined by <span class="code">|</span> will match the <em>first</em> matching subpattern, not the longest. A pattern like <span class="code">r'ab|abc'</span> will never match <span class="code">'abc'</span> because the <span class="code">'ab'</span> match gets evaluated first.</p>
<p>Given a list <span class="code"><em>L</em></span> of words, an RE pattern that matches any one of the words is:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="s1">'</code><code class="s1">|</code><code class="s1">'</code><code class="o">.</code><code class="n">join</code><code class="p">(</code><code class="sa">rf</code><code class="s1">'</code><code class="s1">\</code><code class="s1">b</code><code class="si">{</code><code class="n">word</code><code class="si">}</code><code class="s1">\</code><code class="s1">b</code><code class="s1">'</code><code> </code><strong><code class="k">for</code></strong><code> </code><code class="n">word</code><code> </code><strong><code class="ow">in</code></strong><code> </code><code class="n">L</code><code class="p">)</code></pre>
<div data-type="note" epub:type="note">
<h1>Escaping Strings</h1>
<p>If<a contenteditable="false" data-primary="escape sequences" data-type="indexterm" id="idm44924521306912"/> the items of <span class="code"><em>L</em></span> can be more general strings, not just words, you need to <em>escape</em> each of them with the function <span class="code">re.escape</span> (covered in <a data-type="xref" href="#additional_re_functions">Table 10-6</a>), and you may not want the <span class="code">\b</span> word boundary markers on either side. In this case, you could use the following RE pattern (sorting the list in reverse order by length to avoid accidentally “masking” a longer word by a shorter one):</p>
<pre data-code-language="python" data-type="programlisting">
<code class="s1">'</code><code class="s1">|</code><code class="s1">'</code><code class="o">.</code><code class="n">join</code><code class="p">(</code><code class="n">re</code><code class="o">.</code><code class="n">escape</code><code class="p">(</code><code class="n">s</code><code class="p">)</code><code> </code><strong><code class="k">for</code></strong><code> </code><code class="n">s</code><code> </code><strong><code class="ow">in</code></strong><code> </code><code class="nb">sorted</code><code class="p">(</code><code>
</code><code>         </code><code class="n">L</code><code class="p">,</code><code> </code><code class="n">key</code><code class="o">=</code><code class="nb">len</code><code class="p">,</code><code> </code><code class="n">reverse</code><code class="o">=</code><strong><code class="kc">True</code></strong><code class="p">)</code><code class="p">)</code></pre>
</div>
</div></section>
<section data-pdf-bookmark="Groups" data-type="sect2"><div class="sect2" id="groups">
<h2>Groups</h2>
<p>A regular expression can contain any number of<a contenteditable="false" data-primary="groups" data-type="indexterm" id="idm44924521247616"/> <em>groups</em>, from none to 99 (or even more, but only the first 99 groups are fully supported). Parentheses in a pattern string indicate a group. The element <span class="code">(?P&lt;<em>id</em>&gt;...)</span> also indicates a group and gives the group a name, <span class="code"><em>id</em></span>, that can be any Python identifier. All groups, named and unnamed, are numbered, left to right, 1 to 99; “group 0” means the string that the whole RE matches.</p>
<p>For any match of the RE with a string, each group matches a substring (possibly an empty one). When the RE uses <span class="code">|</span>, some groups may not match any substring, although the RE as a whole does match the string. When a group doesn’t match any substring, we say that the group does not <em>participate</em> in the match. An empty string (<span class="code">''</span>) is used as the matching substring for any group that does not participate in a match, except where otherwise indicated later in this chapter. For example, this:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="sa">r</code><code class="s1">'(.+)\1+\Z'</code></pre>
<p>matches a string made up of two or more repetitions of any nonempty substring. The <span class="code">(.+)</span> part of the pattern matches any nonempty substring (any character, one or more times) and defines a group, thanks to the parentheses. The <span class="code">\1+</span> part of the pattern matches one or more repetitions of the group, and <span class="code">\Z</span> anchors the match to the end of the string.<a contenteditable="false" data-primary="" data-startref="REremof10" data-type="indexterm" id="idm44924521211296"/><a contenteditable="false" data-primary="" data-startref="remodule10" data-type="indexterm" id="idm44924521209984"/><a contenteditable="false" data-primary="" data-startref="SLMre10" data-type="indexterm" id="idm44924521208608"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Optional Flags" data-type="sect1"><div class="sect1" id="optional_flags">
<h1>Optional Flags</h1>
<p>The<a contenteditable="false" data-primary="regular expressions (REs)" data-secondary="optional flags" data-type="indexterm" id="REflag10"/> optional <span class="code">flags</span> argument to the function <span class="code">compile</span> is a coded integer built by bitwise ORing (with Python’s bitwise OR operator, <span class="code">|</span>) one or more of the following attributes of the module <span class="code">re</span>. Each attribute has both a short name (one uppercase letter), for convenience, and a long name (an uppercase multiletter identifier), which is more readable and thus normally preferable:</p>
<dl>
<dt class="plain"><span class="code">A</span> <em>or</em> <span class="code">ASCII</span></dt>
<dd>Uses ASCII-only characters for <span class="code">\w</span>, <span class="code">\W</span>, <span class="code">\b</span>, <span class="code">\B</span>, <span class="code">\d</span>, and <span class="code">\D</span>; overrides the default <span class="code">UNICODE</span> flag</dd>
<dt class="plain"><span class="code">I</span> <em>or</em> <span class="code">IGNORECASE</span></dt>
<dd>Makes matching case-insensitive</dd>
<dt class="plain"><span class="code">L</span> <em>or</em> <span class="code">LOCALE</span></dt>
<dd>Uses the Python <span class="code">LOCALE</span> setting to determine characters for <span class="code">\w</span>, <span class="code">\W</span>, <span class="code">\b</span>, <span class="code">\B</span>, <span class="code">\d</span>, and <span class="code">\D</span> markers; you can only use this option with <span class="code">bytes</span> patterns</dd>
<dt class="plain"><span class="code">M</span> <em>or</em> <span class="code">MULTILINE</span></dt>
<dd>Makes the special characters <span class="code">^</span> and <span class="code">$</span> match at the start and end of each line (i.e., right after/before a newline), as well as at the start and end of the whole string (<span class="code">\A</span> and <span class="code">\Z</span> always match only the start and end of the whole string)</dd>
<dt class="plain"><span class="code">S</span> <em>or</em> <span class="code">DOTALL</span></dt>
<dd>Causes the special character <span class="code">.</span> to match any character, including a newline</dd>
<dt class="plain"><span class="code">U</span> <em>or</em> <span class="code">UNICODE</span></dt>
<dd>Uses full Unicode to determine characters for <span class="code">\w</span>, <span class="code">\W</span>, <span class="code">\b</span>, <span class="code">\B</span>, <span class="code">\d</span>, and <span class="code">\D</span> markers; although retained for backward compatibility, this flag is now the default</dd>
<dt class="plain"><span class="code">X</span> <em>or</em> <span class="code">VERBOSE</span></dt>
<dd>Causes whitespace in the pattern to be ignored, except when escaped or in a character set, and makes a nonescaped <span class="code">#</span> character in the pattern begin a comment that lasts until the end of the line</dd>
</dl>
<p>Flags can also be specified by inserting a pattern element with one or more of the letters <span class="code">aiLmsux</span> between <span class="code">(?</span> and <span class="code">)</span>, rather than by the <span class="code">flags</span> argument to the <span class="code">compile</span> function of the <span class="code">re</span> module (the letters correspond to the uppercase flags given in the preceding list). Options should always be placed at the start of the pattern; not doing this produces a deprecation warning. In particular, placement at the start is mandatory if <span class="code">x</span> (the inline flag character for verbose RE parsing) is among the options, since <span class="code">x</span> changes the way Python parses the pattern. Options apply to the whole RE, except that the <span class="code">aLu</span> options can be applied locally within a group.</p>
<p>Using the explicit <span class="code">flags</span> argument is more readable than placing an options element within the pattern. For example, here are three ways to define equivalent REs with the <span class="code">compile</span> function. Each of these REs matches the word “hello” in any mix of upper- and lowercase letters:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">re</code><code>
</code><code class="n">r1</code><code> </code><code class="o">=</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">compile</code><code class="p">(</code><code class="sa">r</code><code class="s1">'</code><code class="s1">(?i)hello</code><code class="s1">'</code><code class="p">)</code><code>
</code><code class="n">r2</code><code> </code><code class="o">=</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">compile</code><code class="p">(</code><code class="sa">r</code><code class="s1">'</code><code class="s1">hello</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">I</code><code class="p">)</code><code>
</code><code class="n">r3</code><code> </code><code class="o">=</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">compile</code><code class="p">(</code><code class="sa">r</code><code class="s1">'</code><code class="s1">hello</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">IGNORECASE</code><code class="p">)</code></pre>
<p>The third approach is clearly the most readable, and thus the most maintainable, though slightly more verbose. The raw string form is not strictly necessary here, since the patterns do not include backslashes. However, using raw string literals does no harm, and we recommend you always use them for RE patterns to improve clarity and readability.</p>
<p>The option <span class="code">re.VERBOSE</span> (or <span class="code">re.X</span>) lets you make patterns more readable and understandable through appropriate use of whitespace and comments. Complicated and verbose RE patterns are generally best represented by strings that take up more than one line, and therefore you normally want to use a triple-quoted raw string literal for such pattern strings. For example, to match a string representing an integer that may be in octal, hex, or decimal format, you could use use either of the following:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">repat_num1</code><code> </code><code class="o">=</code><code> </code><code class="sa">r</code><code class="s1">'</code><code class="s1">(0o[0-7]*|0x[</code><code class="s1">\</code><code class="s1">da-fA-F]+|[1-9]</code><code class="s1">\</code><code class="s1">d*)</code><code class="s1">\</code><code class="s1">Z</code><code class="s1">'</code><code>
</code><code class="n">repat_num2</code><code> </code><code class="o">=</code><code> </code><code class="sa">r</code><code class="s1">'''</code><code class="s1">(?x)   </code><em><code class="s1"># (re.VERBOSE) pattern matching int literals</code></em><code class="s1">
</code><code class="s1">              (  0o [0-7]*       </code><em><code class="s1"># octal: leading 0o, 0+ octal digits</code></em><code class="s1">
</code><code class="s1">               | 0x [</code><code class="s1">\</code><code class="s1">da-fA-F]+  </code><em><code class="s1"># hex: 0x, then 1+ hex digits</code></em><code class="s1">
</code><code class="s1">               | [1-9] </code><code class="s1">\</code><code class="s1">d*       </code><em><code class="s1"># decimal: leading non-0, 0+ digits</code></em><code class="s1">
</code><code class="s1">              )</code><code class="s1">\</code><code class="s1">Z                </code><em><code class="s1"># end of string</code></em><code class="s1">
</code><code class="s1">              </code><code class="s1">'''</code></pre>
<p>The two patterns defined in this example are equivalent, but the second one is made more readable and understandable by the comments and the free use of whitespace to visually group portions of the pattern in logical ways.<a contenteditable="false" data-primary="" data-startref="REflag10" data-type="indexterm" id="idm44924521010768"/></p>
</div></section>
<section data-pdf-bookmark="Match Versus Search" data-type="sect1"><div class="sect1" id="match_versus_search">
<h1>Match Versus Search</h1>
<p>So<a contenteditable="false" data-primary="regular expressions (REs)" data-secondary="match versus search" data-type="indexterm" id="idm44924521019312"/> far, we’ve been using regular expressions to <em>match</em> strings. For example, the RE with pattern <span class="code">r'box'</span> matches strings such as <span class="code">'box'</span> and <span class="code">'boxes'</span>, but not <span class="code">'inbox'</span>. In other words, an RE <em>match</em> is implicitly anchored at the start of the target string, as if the RE’s pattern started with <span class="code">\A</span>.</p>
<p>Often you’ll be interested in locating possible matches for an RE anywhere in the string, without anchoring (e.g., find the <span class="code">r'box'</span> match within such strings as <span class="code">'inbox'</span>, as well as in <span class="code">'box'</span> and <span class="code">'boxes'</span>). In this case, the Python term for the operation is a <em>search</em>, as opposed to a match. For such searches, use the <span class="code">search</span> method of an RE object instead of the <span class="code">match</span> method, which matches only from the beginning of the string. For example:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">re</code><code>
</code><code class="n">r1</code><code> </code><code class="o">=</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">compile</code><code class="p">(</code><code class="sa">r</code><code class="s1">'</code><code class="s1">box</code><code class="s1">'</code><code class="p">)</code><code>
</code><strong><code class="k">if</code></strong><code> </code><code class="n">r1</code><code class="o">.</code><code class="n">match</code><code class="p">(</code><code class="s1">'</code><code class="s1">inbox</code><code class="s1">'</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">match succeeds</code><code class="s1">'</code><code class="p">)</code><code>
</code><strong><code class="k">else</code></strong><code class="p">:</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">match fails</code><code class="s1">'</code><code class="p">)</code><code>          </code><em><code class="c1"># prints: match fails</code></em><code>
</code><code>
</code><strong><code class="k">if</code></strong><code> </code><code class="n">r1</code><code class="o">.</code><code class="n">search</code><code class="p">(</code><code class="s1">'</code><code class="s1">inbox</code><code class="s1">'</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">search succeeds</code><code class="s1">'</code><code class="p">)</code><code>      </code><em><code class="c1"># prints: search succeeds</code></em><code>
</code><strong><code class="k">else</code></strong><code class="p">:</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">search fails</code><code class="s1">'</code><code class="p">)</code></pre>
<p>If you want to check that the <em>whole</em> string matches, not just its beginning, you can instead use the method <span class="code">fullmatch</span>. All of these methods are covered in <a data-type="xref" href="#methods_of_re_objects">Table 10-3</a>.</p>
</div></section>
<section data-pdf-bookmark="Anchoring at String Start and End" data-type="sect1"><div class="sect1" id="anchoring_at_string_start_and_end">
<h1>Anchoring at String Start and End</h1>
<p><span class="code">\A</span> and <span class="code">\Z</span> are the<a contenteditable="false" data-primary="regular expressions (REs)" data-secondary="anchoring at string start and end" data-type="indexterm" id="idm44924520907792"/><a contenteditable="false" data-primary="anchoring" data-type="indexterm" id="idm44924520906448"/> pattern elements ensuring that a regular expression match is <em>anchored</em> at the string’s start or end. The elements <span class="code">^</span> for start and <span class="code">$</span> for end are also used in similar roles. For RE objects that are not flagged as <span class="code">MULTILINE</span>, <span class="code">^</span> is the same as <span class="code">\A</span>, and <span class="code">$</span> is the same as <span class="code">\Z</span>. For a multiline RE, however, <span class="code">^</span> can anchor at the start of the string <em>or</em> the start of any line (where “lines” are determined based on <span class="code">\n</span> separator characters). Similarly, with a multiline RE, <span class="code">$</span> can anchor at the end of the string <em>or</em> the end of any line. <span class="code">\A</span> and <span class="code">\Z</span> always anchor exclusively at the start and end of the string, whether the RE object is multiline or not.</p>
<p class="pagebreak-before">For example, here’s a way to check whether a file has any lines that end with digits:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">re</code><code>
</code><code class="n">digatend</code><code> </code><code class="o">=</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">compile</code><code class="p">(</code><code class="sa">r</code><code class="s1">'</code><code class="s1">\</code><code class="s1">d$</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">MULTILINE</code><code class="p">)</code><code>
</code><strong><code class="k">with</code></strong><code> </code><code class="nb">open</code><code class="p">(</code><code class="s1">'</code><code class="s1">afile.txt</code><code class="s1">'</code><code class="p">)</code><code> </code><strong><code class="k">as</code></strong><code> </code><code class="n">f</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">if</code></strong><code> </code><code class="n">digatend</code><code class="o">.</code><code class="n">search</code><code class="p">(</code><code class="n">f</code><code class="o">.</code><code class="n">read</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">some lines end with digits</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>    </code><strong><code class="k">else</code></strong><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">no line ends with digits</code><code class="s1">'</code><code class="p">)</code></pre>
<p>A pattern of <span class="code">r'\d\n'</span> is almost equivalent, but in that case, the search fails if the very last character of the file is a digit not followed by an end-of-line character. With the preceding example, the search succeeds if a digit is at the very end of the file’s contents, as well as in the more usual case where a digit is followed by an end-of-line character.</p>
</div></section>
<section data-pdf-bookmark="Regular Expression Objects" data-type="sect1"><div class="sect1" id="regular_expression_objects">
<h1>Regular Expression Objects</h1>
<p><a data-type="xref" href="#attributes_of_re_objects">Table 10-2</a> covers<a contenteditable="false" data-primary="regular expressions (REs)" data-secondary="regular expression objects" data-type="indexterm" id="REobject10"/> the read-only attributes of a regular expression object <span class="code"><em>r</em></span> that detail how <span class="code"><em>r</em></span> was built (by the function <span class="code">compile</span> of the module <span class="code">re</span>, covered in <a data-type="xref" href="#additional_re_functions">Table 10-6</a>).</p>
<table class="border" id="attributes_of_re_objects">
<caption><span class="label">Table 10-2. </span>Attributes of RE objects</caption>
<tbody>
<tr>
<td class="width-15"><span class="code">flags</span></td>
<td>The <span class="code">flags</span> argument passed to <span class="code">compile</span>, or <span class="code">re.UNICODE</span> when <span class="code">flags</span> is omitted; also includes any flags specified in the pattern itself using a leading <span class="code">(?...)</span> element</td>
</tr>
<tr>
<td><span class="code">groupindex</span></td>
<td>A dictionary whose keys are group names as defined by elements <span class="code">(?P&lt;<em>id</em>&gt;...)</span>; the corresponding values are the named groups’ numbers</td>
</tr>
<tr>
<td><span class="code">pattern</span></td>
<td>The pattern string from which <span class="code"><em>r</em></span> is compiled</td>
</tr>
</tbody>
</table>
<p>These attributes make it easy to retrieve from a compiled RE object its original pattern string and flags, so you never have to store those separately.</p>
<p>An RE object <span class="code"><em>r</em></span> also supplies methods to find matches for <span class="code"><em>r</em></span> in a string, as well as to perform substitutions on such matches (see <a data-type="xref" href="#methods_of_re_objects">Table 10-3</a>). Matches are represented by special objects, covered in the following section.</p>
<table class="border" id="methods_of_re_objects">
<caption><span class="label">Table 10-3. </span>Methods of RE objects</caption>
<tbody>
<tr>
<td class="width-15"><span class="code">findall</span></td>
<td><span class="code"><em>r</em></span><span class="code">.findall(<em>s</em>)</span><br/>
<span class="code">When r has no groups,</span> <span class="code">findall</span> returns a list of strings, each a substring of <span class="code"><em>s</em></span> that is a nonoverlapping match with <span class="code"><em>r</em></span>. For example, to print out all words in a file, one per line:
			<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">re</code><code>
</code><code class="n">reword</code><code> </code><code class="o">=</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">compile</code><code class="p">(</code><code class="sa">r</code><code class="s1">'</code><code class="s1">\</code><code class="s1">w+</code><code class="s1">'</code><code class="p">)</code><code>
</code><strong><code class="k">with</code></strong><code> </code><code class="nb">open</code><code class="p">(</code><code class="s1">'</code><code class="s1">afile.txt</code><code class="s1">'</code><code class="p">)</code><code> </code><strong><code class="k">as</code></strong><code> </code><code class="n">f</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">for</code></strong><code> </code><code class="n">aword</code><code> </code><strong><code class="ow">in</code></strong><code> </code><code class="n">reword</code><code class="o">.</code><code class="n">findall</code><code class="p">(</code><code class="n">f</code><code class="o">.</code><code class="n">read</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="n">aword</code><code class="p">)</code></pre>
</td>
</tr>
<tr>
<td class="width-15"><span class="code">findall</span><br/>
<em>(cont.)</em></td>
<td>When <span class="code"><em>r</em></span> has exactly one group, <span class="code">findall</span> also returns a list of strings, but each is the substring of <span class="code"><em>s</em></span> that matches <span class="code"><em>r</em></span>’s group. For example, to print only words that are followed by whitespace (not words followed by punctuation or the word at end of the string), you need to change only one statement in the preceding example:
			<pre data-code-language="python" data-type="programlisting">
<code class="n">reword</code> <code class="o">=</code> <code class="n">re</code><code class="o">.</code><code class="n">compile</code><code class="p">(</code><code class="s1">'(\w+)\s'</code><code class="p">)</code></pre>
			When <span class="code"><em>r</em></span> has <span class="code"><em>n</em></span> <span class="code">groups</span> (with <span class="code"><em>n</em></span> <span class="code">&gt; 1</span>), <span class="code">findall</span> returns a list of tuples, one per nonoverlapping match with <span class="code"><em>r</em></span>. Each tuple has <span class="code"><em>n</em></span> items, one per group of <span class="code"><em>r</em></span>, the substring of <span class="code"><em>s</em></span> matching the group. For example, to print the first and last word of each line that has at least two words:

			<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">re</code><code>
</code><code class="n">first_last</code><code> </code><code class="o">=</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">compile</code><code class="p">(</code><code class="sa">r</code><code class="s1">'</code><code class="s1">^</code><code class="s1">\</code><code class="s1">W*(</code><code class="s1">\</code><code class="s1">w+)</code><code class="s1">\</code><code class="s1">b.*</code><code class="s1">\</code><code class="s1">b(</code><code class="s1">\</code><code class="s1">w+)</code><code class="s1">\</code><code class="s1">W*$</code><code class="s1">'</code><code class="p">,</code><code> </code><code>
</code><code>                        </code><code class="n">re</code><code class="o">.</code><code class="n">MULTILINE</code><code class="p">)</code><code>
</code><strong><code class="k">with</code></strong><code> </code><code class="nb">open</code><code class="p">(</code><code class="s1">'</code><code class="s1">afile.txt</code><code class="s1">'</code><code class="p">)</code><code> </code><strong><code class="k">as</code></strong><code> </code><code class="n">f</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">for</code></strong><code> </code><code class="n">first</code><code class="p">,</code><code> </code><code class="n">last</code><code> </code><strong><code class="ow">in</code></strong><code> </code><code class="n">first_last</code><code class="o">.</code><code class="n">findall</code><code class="p">(</code><code class="n">f</code><code class="o">.</code><code class="n">read</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="n">first</code><code class="p">,</code><code> </code><code class="n">last</code><code class="p">)</code></pre>
</td>
</tr>
<tr>
<td><span class="code">finditer</span></td>
<td><span class="code"><em>r</em></span><span class="code">.finditer(<em>s</em>)</span><br/>
<span class="code">finditer</span> is like <span class="code">findall</span>, except that, instead of a list of strings or tuples, it returns an iterator whose items are match objects (discussed in the following section). In most cases, therefore, <span class="code">finditer</span> is more flexible, and usually performs better, than <span class="code">findall</span>.</td>
</tr>
<tr>
<td><span class="code">fullmatch</span></td>
<td><span class="code"><em>r</em></span><span class="code">.fullmatch(<em>s</em>, start=0, end=sys.maxsize)</span><br/>
			Returns a match object when the complete substring <span class="code"><em>s</em></span>, starting at index <span class="code">start</span> and ending just short of index <span class="code">end</span>, matches <span class="code"><em>r.</em></span> Otherwise, <span class="code">fullmatch</span> returns <span class="code"><strong>None</strong></span>.</td>
</tr>
<tr>
<td><span class="code">match</span></td>
<td><span class="code"><em>r</em></span><span class="code">.match(<em>s</em>, start=0, end=sys.maxsize)</span><br/>
			Returns<a contenteditable="false" data-primary="match" data-secondary="in regular expressions" data-secondary-sortas="regular expressions" data-type="indexterm" id="idm44924520506384"/> an appropriate match object when a substring of <span class="code"><em>s</em></span>, starting at index <span class="code">start</span> and not reaching as far as index <span class="code">end</span>, matches <span class="code"><em>r</em></span>. Otherwise, <span class="code">match</span> returns <span class="code"><strong>None</strong></span>. <span class="code">match</span> is implicitly anchored at the starting position <span class="code">start</span> in <span class="code"><em>s</em></span>. To search for a match with <span class="code"><em>r</em></span> at any point in <span class="code"><em>s</em></span> from <span class="code">start</span> onward, call <span class="code"><em>r</em></span><span class="code">.search</span>, not <span class="code"><em>r</em></span><span class="code">.match</span>. For example, here is one way to print all lines in a file that start with digits:
			<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">re</code><code>
</code><code class="n">digs</code><code> </code><code class="o">=</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">compile</code><code class="p">(</code><code class="sa">r</code><code class="s1">'</code><code class="s1">\</code><code class="s1">d</code><code class="s1">'</code><code class="p">)</code><code>
</code><strong><code class="k">with</code></strong><code> </code><code class="nb">open</code><code class="p">(</code><code class="s1">'</code><code class="s1">afile.txt</code><code class="s1">'</code><code class="p">)</code><code> </code><strong><code class="k">as</code></strong><code> </code><code class="n">f</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">for</code></strong><code> </code><code class="n">line</code><code> </code><strong><code class="ow">in</code></strong><code> </code><code class="n">f</code><code class="p">:</code><code>
</code><code>        </code><strong><code class="k">if</code></strong><code> </code><code class="n">digs</code><code class="o">.</code><code class="n">match</code><code class="p">(</code><code class="n">line</code><code class="p">)</code><code class="p">:</code><code>
</code><code>            </code><code class="nb">print</code><code class="p">(</code><code class="n">line</code><code class="p">,</code><code> </code><code class="n">end</code><code class="o">=</code><code class="s1">'</code><code class="s1">'</code><code class="p">)</code></pre>
</td>
</tr>
<tr>
<td><span class="code">search</span></td>
<td><span class="code"><em>r</em></span><span class="code">.search(<em>s</em>, start=0, end=sys.maxsize)</span><br/>
			Returns<a contenteditable="false" data-primary="search (re instance methods)" data-type="indexterm" id="idm44924520440928"/> an appropriate match object for the leftmost substring of <span class="code"><em>s</em></span>, starting not before index <span class="code">start</span> and not reaching as far as index <span class="code">end</span>, that matches <span class="code"><em>r</em></span>. When no such substring exists, <span class="code">search</span> returns <span class="code"><strong>None</strong></span>. For example, to print all lines containing digits, one simple approach is as follows:
			<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">re</code><code>
</code><code class="n">digs</code><code> </code><code class="o">=</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">compile</code><code class="p">(</code><code class="sa">r</code><code class="s1">'</code><code class="s1">\</code><code class="s1">d</code><code class="s1">'</code><code class="p">)</code><code>
</code><strong><code class="k">with</code></strong><code> </code><code class="nb">open</code><code class="p">(</code><code class="s1">'</code><code class="s1">afile.txt</code><code class="s1">'</code><code class="p">)</code><code> </code><strong><code class="k">as</code></strong><code> </code><code class="n">f</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">for</code></strong><code> </code><code class="n">line</code><code> </code><code class="ow">in</code><code> </code><code class="n">f</code><code class="p">:</code><code>
</code><code>        </code><strong><code class="k">if</code></strong><code> </code><code class="n">digs</code><code class="o">.</code><code class="n">search</code><code class="p">(</code><code class="n">line</code><code class="p">)</code><code class="p">:</code><code>
</code><code>            </code><code class="nb">print</code><code class="p">(</code><code class="n">line</code><code class="p">,</code><code> </code><code class="n">end</code><code class="o">=</code><code class="s1">'</code><code class="s1">'</code><code class="p">)</code></pre>
</td>
</tr>
<tr>
<td><span class="code">split</span></td>
<td><span class="code"><em>r</em></span><span class="code">.split(<em>s</em>, maxsplit=0)</span><br/>
			Returns a list <span class="code"><em>L</em></span> of the <em>splits</em> of <span class="code"><em>s</em></span> by <span class="code"><em>r</em></span> (i.e., the substrings of <span class="code"><em>s</em></span> separated by nonoverlapping, nonempty matches with <span class="code"><em>r</em></span>). For example, here’s a way to eliminate all occurrences of <span class="code">'hello'</span> (in any mix of lowercase and uppercase) from a string:
			<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">re</code><code>
</code><code class="n">rehello</code><code> </code><code class="o">=</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">compile</code><code class="p">(</code><code class="sa">r</code><code class="s1">'</code><code class="s1">hello</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">IGNORECASE</code><code class="p">)</code><code>
</code><code class="n">astring</code><code> </code><code class="o">=</code><code> </code><code class="s1">'</code><code class="s1">'</code><code class="o">.</code><code class="n">join</code><code class="p">(</code><code class="n">rehello</code><code class="o">.</code><code class="n">split</code><code class="p">(</code><code class="n">astring</code><code class="p">)</code><code class="p">)</code></pre>
			When <span class="code"><em>r</em></span> has <span class="code"><em>n</em></span> groups, <span class="code"><em>n</em></span> more items are interleaved in <span class="code"><em>L</em></span> between each pair of splits. Each of the <span class="code"><em>n</em></span> extra items is the substring of <span class="code"><em>s</em></span> that matches <span class="code"><em>r</em></span>’s corresponding group in that match, or <span class="code"><strong>None</strong></span> if that group did not participate in the match. For example, here’s one way to remove whitespace only when it occurs between a colon and a digit:

			<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">re</code><code>
</code><code class="n">re_col_ws_dig</code><code> </code><code class="o">=</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">compile</code><code class="p">(</code><code class="sa">r</code><code class="s1">'</code><code class="s1">(:)</code><code class="s1">\</code><code class="s1">s+(</code><code class="s1">\</code><code class="s1">d)</code><code class="s1">'</code><code class="p">)</code><code>
</code><code class="n">astring</code><code> </code><code class="o">=</code><code> </code><code class="s1">'</code><code class="s1">'</code><code class="o">.</code><code class="n">join</code><code class="p">(</code><code class="n">re_col_ws_dig</code><code class="o">.</code><code class="n">split</code><code class="p">(</code><code class="n">astring</code><code class="p">)</code><code class="p">)</code></pre>
			If <span class="code">maxsplit</span> is greater than <span class="code">0</span>, at most <span class="code">maxsplit</span> splits are in <span class="code"><em>L</em></span>, each followed by <span class="code"><em>n</em></span> items, while the trailing substring of <span class="code"><em>s</em></span> after <span class="code">maxsplit</span> matches of <span class="code"><em>r</em></span>, if any, is <span class="code"><em>L</em></span>’s last item. For example, to remove only the <em>first</em> occurrence of substring <span class="code">'hello'</span> rather than <em>all</em> of them, change the last statement in the first example here to:

			<pre data-code-language="python" data-type="programlisting">
<code class="n">astring</code><code class="o">=</code><code class="s1">''</code><code class="o">.</code><code class="n">join</code><code class="p">(</code><code class="n">rehello</code><code class="o">.</code><code class="n">split</code><code class="p">(</code><code class="n">astring</code><code class="p">,</code> <code class="mi">1</code><code class="p">))</code></pre>
</td>
</tr>
<tr>
<td><span class="code">sub</span></td>
<td><span class="code"><em>r</em></span><span class="code">.sub(<em>repl</em>,</span> <span class="code"><em>s</em></span><span class="code">, count=0)</span><br/>
			Returns<a contenteditable="false" data-primary="sub (re instance methods)" data-type="indexterm" id="idm44924520157968"/> a copy of <span class="code"><em>s</em></span> where nonoverlapping matches with <span class="code"><em>r</em></span> are replaced by <span class="code"><em>repl</em></span>, which can be either a string or a callable object, such as a function. An empty match is replaced only when not adjacent to the previous match. When <span class="code">count</span> is greater than <span class="code">0</span>, only the first <span class="code">count</span> matches of <span class="code"><em>r</em></span> within <span class="code"><em>s</em></span> are replaced. When <span class="code">count</span> equals <span class="code">0</span>, all matches of <span class="code"><em>r</em></span> within <span class="code"><em>s</em></span> are replaced. For example, here’s another, more natural way to remove only the first occurrence of substring <span class="code">'hello'</span> in any mix of cases:
			<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">re</code><code>
</code><code class="n">rehello</code><code> </code><code class="o">=</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">compile</code><code class="p">(</code><code class="sa">r</code><code class="s1">'</code><code class="s1">hello</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">IGNORECASE</code><code class="p">)</code><code>
</code><code class="n">astring</code><code> </code><code class="o">=</code><code> </code><code class="n">rehello</code><code class="o">.</code><code class="n">sub</code><code class="p">(</code><code class="s1">'</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">astring</code><code class="p">,</code><code> </code><code class="mi">1</code><code class="p">)</code></pre>
			Without the final <span class="code">1</span> (one) argument to <span class="code">sub</span>, the example removes all occurrences of <span class="code">'hello'</span>.<br/>
			When <span class="code"><em>repl</em></span> is a callable object, <span class="code"><em>repl</em></span> must accept one argument (a match object) and return a string (or <span class="code"><strong>None</strong></span>, which is equivalent to returning the empty string <span class="code">''</span>) to use as the replacement for the match. In this case, <span class="code">sub</span> calls <span class="code"><em>repl</em></span>, with a suitable match object argument, for each match with <span class="code"><em>r</em></span> that <span class="code">sub</span> is replacing. For example, here’s one way to uppercase all occurrences of words starting with <span class="code">'h'</span> and ending with <span class="code">'o'</span> in any mix of cases:

			<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">re</code><code>
</code><code class="n">h_word</code><code> </code><code class="o">=</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">compile</code><code class="p">(</code><code class="sa">r</code><code class="s1">'</code><code class="s1">\</code><code class="s1">bh</code><code class="s1">\</code><code class="s1">w*o</code><code class="s1">\</code><code class="s1">b</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">IGNORECASE</code><code class="p">)</code><code>
</code><strong><code class="k">def</code></strong><code> </code><code class="nf">up</code><code class="p">(</code><code class="n">mo</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><strong><code class="k">return</code></strong><code> </code><code class="n">mo</code><code class="o">.</code><code class="n">group</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code><code class="o">.</code><code class="n">upper</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="n">astring</code><code> </code><code class="o">=</code><code> </code><code class="n">h_word</code><code class="o">.</code><code class="n">sub</code><code class="p">(</code><code class="n">up</code><code class="p">,</code><code> </code><code class="n">astring</code><code class="p">)</code></pre>
</td>
</tr>
<tr>
<td><span class="code">sub</span><br/>
<em>(cont.)</em></td>
<td>When <span class="code"><em>repl</em></span> is a string, <span class="code">sub</span> uses <span class="code"><em>repl</em></span> itself as the replacement, except that it expands backreferences. A <em>backreference</em> is a substring of <span class="code"><em>repl</em></span> of the form <span class="code">\g&lt;<em>id</em>&gt;</span>, where <span class="code"><em>id</em></span> is the name of a group in <span class="code"><em>r</em></span> (established by the syntax <span class="code">(?P&lt;<em>id</em>&gt;...)</span> in <span class="code"><em>r</em></span>’s pattern string) or <span class="code">\dd</span>, where <span class="code"><em>dd</em></span> is one or two digits taken as a group number. Each back reference, named or numbered, is replaced with the substring of <span class="code"><em>s</em></span> that matches the group of <span class="code"><em>r</em></span> that the back reference indicates. For example, here’s a way to enclose every word in braces:
			<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">re</code><code>
</code><code class="n">grouped_word</code><code> </code><code class="o">=</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">compile</code><code class="p">(</code><code class="s1">'</code><code class="s1">(</code><code class="s1">\</code><code class="s1">w+)</code><code class="s1">'</code><code class="p">)</code><code>
</code><code class="n">astring</code><code> </code><code class="o">=</code><code> </code><code class="n">grouped_word</code><code class="o">.</code><code class="n">sub</code><code class="p">(</code><code class="sa">r</code><code class="s1">'</code><code class="s1">{</code><code class="s1">\</code><code class="s1">1}</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">astring</code><code class="p">)</code></pre>
</td>
</tr>
<tr>
<td><span class="code">subn</span></td>
<td><span class="code"><em>r</em></span><span class="code">.subn(<em>repl</em>,</span> <span class="code"><em>s</em></span><span class="code">, count=0)</span><br/>
<span class="code">subn</span> is the same as <span class="code">sub</span>, except that <span class="code">subn</span> returns a pair <span class="code">(<em>new_string</em>,</span> <span class="code"><em>n</em></span><span class="code">)</span>, where <span class="code"><em>n</em></span> is the number of substitutions that <span class="code">subn</span> has performed. For example, here’s one way to count the number of occurrences of substring <span class="code">'hello'</span> in any mix of cases:
			<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">re</code><code>
</code><code class="n">rehello</code><code> </code><code class="o">=</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">compile</code><code class="p">(</code><code class="sa">r</code><code class="s1">'</code><code class="s1">hello</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">IGNORECASE</code><code class="p">)</code><code>
</code><code class="n">_</code><code class="p">,</code><code> </code><code class="n">count</code><code> </code><code class="o">=</code><code> </code><code class="n">rehello</code><code class="o">.</code><code class="n">subn</code><code class="p">(</code><code class="s1">'</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">astring</code><code class="p">)</code><code>
</code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="s1">Found </code><code class="si">{</code><code class="n">count</code><code class="si">}</code><code class="s1"> occurrences of </code><code class="s1">"</code><code class="s1">hello</code><code class="s1">"</code><code class="s1">'</code><code class="p">)</code><a contenteditable="false" data-primary="" data-startref="REobject10" data-type="indexterm" id="idm44924519905120"><code> </code></a></pre>
</td>
</tr>
</tbody>
</table>
</div></section>
<section data-pdf-bookmark="Match Objects" data-type="sect1"><div class="sect1" id="match_objects">
<h1>Match Objects</h1>
<p><em>Match objects</em> are<a contenteditable="false" data-primary="regular expressions (REs)" data-secondary="match objects" data-type="indexterm" id="REmatcho10"/><a contenteditable="false" data-primary="match objects" data-type="indexterm" id="mobj10"/> created and returned by the methods <span class="code">fullmatch</span>, <span class="code">match</span>, and <span class="code">search</span> of a regular expression object, and are the items of the iterator returned by the method <span class="code">finditer</span>. They are also implicitly created by the methods <span class="code">sub</span> and <span class="code">subn</span> when the argument <span class="code"><em>repl</em></span> is callable, since in that case the appropriate match object is passed as the only argument on each call to <span class="code"><em>repl</em></span>. A match object <span class="code"><em>m</em></span> supplies the following read-only attributes that detail how <span class="code">search</span> or <span class="code">match</span> created <span class="code"><em>m</em></span>, listed in <a data-type="xref" href="#attributes_of_match_objects">Table 10-4</a>.</p>
<table class="border" id="attributes_of_match_objects">
<caption><span class="label">Table 10-4. </span>Attributes of match objects</caption>
<tbody>
<tr>
<td><span class="code">pos</span></td>
<td>The <span class="code"><em>start</em></span> argument that was passed to <span class="code">search</span> or <span class="code">match</span> (i.e., the index into <span class="code"><em>s</em></span> where the search for a match began)</td>
</tr>
<tr>
<td><span class="code">endpos</span></td>
<td>The <span class="code"><em>end</em></span> argument that was passed to <span class="code">search</span> or <span class="code">match</span> (i.e., the index into <span class="code"><em>s</em></span> before which the matching substring of <span class="code"><em>s</em></span> had to end)</td>
</tr>
<tr>
<td><span class="code">lastgroup</span></td>
<td>The name of the last-matched group (<span class="code"><strong>None</strong></span> if the last-matched group has no name, or if no group participated in the match)</td>
</tr>
<tr>
<td><span class="code">lastindex</span></td>
<td>The integer index (<span class="code">1</span> and up) of the last-matched group (<span class="code"><strong>None</strong></span> if no group participated in the match)</td>
</tr>
<tr>
<td><span class="code">re</span></td>
<td>The RE object <span class="code"><em>r</em></span> whose method created <span class="code"><em>m</em></span></td>
</tr>
<tr>
<td><span class="code">string</span></td>
<td>The string <span class="code"><em>s</em></span> passed to <span class="code">finditer</span>, <span class="code">fullmatch</span>, <span class="code">match</span>, <span class="code">search</span>, <span class="code">sub</span>, or <span class="code">subn</span></td>
</tr>
</tbody>
</table>
<p class="pagebreak-before">In addition, match objects supply the methods detailed in <a data-type="xref" href="#methods_of_match_objects">Table 10-5</a>.</p>
<table class="border" id="methods_of_match_objects">
<caption><span class="label">Table 10-5. </span>Methods of match objects</caption>
<tbody>
<tr>
<td class="width-15"><span class="code">end</span>,<br/>
<span class="code">span</span>,<br/>
<span class="code">start</span></td>
<td><span class="code"><em>m</em></span><span class="code">.end(groupid=0)</span>,<br/>
<span class="code"><em>m</em></span><span class="code">.span(groupid=0)</span>,<br/>
<span class="code"><em>m</em></span><span class="code">.start(groupid=0)</span><br/>
			These methods return indices within <span class="code"><em>m</em></span><span class="code">.string</span> of the substring that matches the group identified by <span class="code"><em>groupid</em></span> (a group number or name; <span class="code">0</span>, the default value for <span class="code">groupid</span>, means “the whole RE”). When the matching substring is <span class="code"><em>m</em></span><span class="code">.string[<em>i</em>:<em>j</em>]</span>, <span class="code"><em>m</em></span><span class="code">.start</span> returns <span class="code"><em>i</em></span>, <span class="code"><em>m</em></span><span class="code">.end</span> returns <span class="code"><em>j</em></span>, and <span class="code"><em>m</em></span><span class="code">.span</span> returns <span class="code">(<em>i</em>,</span> <span class="code"><em>j</em></span><span class="code">)</span>. If the group did not participate in the match, <span class="code"><em>i</em></span> and <span class="code"><em>j</em></span> are <span class="code">-1</span>.</td>
</tr>
<tr>
<td><span class="code">expand</span></td>
<td><span class="code"><em>m</em></span><span class="code">.expand(<em>s</em>)</span><br/>
			Returns a copy of <span class="code"><em>s</em></span> where escape sequences and backreferences are replaced in the same way as for the method <span class="code"><em>r</em></span><span class="code">.sub</span>, covered in <a data-type="xref" href="#methods_of_re_objects">Table 10-3</a>.</td>
</tr>
<tr>
<td><span class="code">group</span></td>
<td><span class="code"><em>m</em></span><span class="code">.group(groupid=0,</span> <span class="code"><em>*groupids</em></span><span class="code">)</span><br/>
			Called with a single argument <span class="code">groupid</span> (a group number or name), <span class="code"><em>m</em></span><span class="code">.group</span> returns the substring matching the group identified by <span class="code">groupid</span>, or <span class="code"><strong>None</strong></span> when that group did not participate in the match. <span class="code"><em>m</em></span><span class="code">.group()</span>—or <span class="code"><em>m</em></span><span class="code">.group(0</span>)—returns the whole matched substring (group <span class="code">0</span> means the whole RE). Groups can also be accessed using <span class="code"><em>m</em></span><span class="code">[<em>index</em>]</span> notation, as if called using <span class="code"><em>m</em></span><span class="code">.group(<em>index</em>)</span> (in either case, <span class="code"><em>index</em></span> may be an <span class="code">int</span> or a <span class="code">str</span>).<br/>
			When <span class="code">group</span> is called with multiple arguments, each argument must be a group number or name. <span class="code">group</span> then returns a tuple with one item per argument, the substring matching the corresponding group, or <span class="code"><strong>None</strong></span> when that group did not participate in the match.</td>
</tr>
<tr>
<td><span class="code">groupdict</span></td>
<td><span class="code"><em>m</em></span><span class="code">.groupdict(default=<strong>None</strong>)</span><br/>
			Returns a dictionary whose keys are the names of all named groups in <span class="code"><em>r</em></span>. The value for each name is the substring that matches the corresponding group, or <span class="code">default</span> if that group did not participate in the match.<a contenteditable="false" data-primary="" data-startref="mobj10" data-type="indexterm" id="idm44924519729152"/><a contenteditable="false" data-primary="" data-startref="REmatcho10" data-type="indexterm" id="idm44924519727776"/></td>
</tr>
<tr>
<td><span class="code">groups</span></td>
<td><span class="code"><em>m</em></span><span class="code">.groups(default=<strong>None</strong>)</span><br/>
			Returns a tuple with one item per group in <span class="code"><em>r</em></span>. Each item is the substring matching the corresponding group, or <span class="code">default</span> if that group did not participate in the match. The tuple does not include the <span class="code">0</span> group representing the full pattern match.</td>
</tr>
</tbody>
</table>
</div></section>
<section data-pdf-bookmark="Functions of the re Module" data-type="sect1"><div class="sect1" id="functions_of_the_re_module">
<h1>Functions of the re Module</h1>
<p>In<a contenteditable="false" data-primary="regular expressions (REs)" data-secondary="functions of re module" data-type="indexterm" id="idm44924519718272"/> addition to the attributes listed in <a data-type="xref" href="#optional_flags">“Optional Flags”</a>, the <span class="code">re</span> module provides one function for each method of a regular expression object (<span class="code">findall</span>, <span class="code">finditer</span>, <span class="code">fullmatch</span>, <span class="code">match</span>, <span class="code">search</span>, <span class="code">split</span>, <span class="code">sub</span>, and <span class="code">subn</span>, described in <a data-type="xref" href="#methods_of_re_objects">Table 10-3</a>), each with an additional first argument, a pattern string that the function implicitly compiles into an RE object. It is usually better to compile pattern strings into RE objects explicitly and call the RE object’s methods, but sometimes, for a one-off use of an RE pattern, calling functions of the module <span class="code">re</span> can be handier. For example, to count the number of occurrences of <span class="code">'hello'</span> in any mix of cases, one concise, function-based way is:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">re</code><code>
</code><code class="n">_</code><code class="p">,</code><code> </code><code class="n">count</code><code> </code><code class="o">=</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">subn</code><code class="p">(</code><code class="sa">r</code><code class="s1">'</code><code class="s1">hello</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">astring</code><code class="p">,</code><code> </code><code class="n">flags</code><code class="o">=</code><code class="n">re</code><code class="o">.</code><code class="n">I</code><code class="p">)</code><code>
</code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="s1">Found </code><code class="si">{</code><code class="n">count</code><code class="si">}</code><code class="s1"> occurrences of </code><code class="s1">"</code><code class="s1">hello</code><code class="s1">"</code><code class="s1">'</code><code class="p">)</code></pre>
<p>The <span class="code">re</span> module internally caches RE objects it creates from the patterns passed to functions; to purge the cache and reclaim some memory, call <span class="code">re.purge</span>.</p>
<p>The <span class="code">re</span> module also supplies <span class="code">error</span>, the class of exceptions raised upon errors (generally, errors in the syntax of a pattern string), and two more functions, listed in <a data-type="xref" href="#additional_re_functions">Table 10-6</a>.</p>
<table class="border" id="additional_re_functions">
<caption><span class="label">Table 10-6. </span>Additional <span class="code">re</span> functions</caption>
<tbody>
<tr>
<td><span class="code">compile</span></td>
<td><span class="code">compile(<em>pattern</em>, flags=0)</span><br/>
			Creates<a contenteditable="false" data-primary="compile (re module)" data-type="indexterm" id="idm44924519627824"/> and returns an RE object, parsing the string <span class="code"><em>pattern</em></span>, as per the syntax covered in <a data-type="xref" href="#pattern_string_syntax">“Pattern String Syntax”</a>, and using integer <span class="code">flags</span>, as described in <a data-type="xref" href="#optional_flags">“Optional Flags”</a></td>
</tr>
<tr>
<td><span class="code">escape</span></td>
<td><span class="code">escape(<em>s</em>)</span><br/>
			Returns a copy of string <span class="code"><em>s</em></span> with each nonalphanumeric character escaped (i.e., preceded by a backslash, <span class="code">\</span>); useful to match string <span class="code"><em>s</em></span> literally as part of an RE pattern string</td>
</tr>
</tbody>
</table>
</div></section>
<section data-pdf-bookmark="REs and the := Operator" data-type="sect1"><div class="sect1" id="res_and_the_equals_operator">
<h1>REs and the := Operator</h1>
<p>The<a contenteditable="false" data-primary=":= (assignment operator)" data-secondary="regular expressions and" data-type="indexterm" id="idm44924519615952"/><a contenteditable="false" data-primary="walrus operator (:=)" data-secondary="regular expressions and" data-type="indexterm" id="idm44924519614608"/><a contenteditable="false" data-primary="assignment operator (:=)" data-secondary="regular expressions and" data-type="indexterm" id="idm44924519613200"/><a contenteditable="false" data-primary="regular expressions (REs)" data-secondary=":= operator" data-type="indexterm" id="idm44924519611856"/> introduction of the <span class="code">:=</span> operator in Python 3.8 established support for a successive-match idiom in Python similar to the one that’s common in Perl. In this idiom, a series of <span class="code"><strong>if</strong></span><span class="code">/</span><span class="code"><strong>elsif</strong></span> branches tests a string against different regular expressions. In Perl, the <span class="code"><strong>if</strong></span> <span class="code">($var =~ /regExpr/)</span> statement both evaluates the regular expression and saves the successful match in the variable <span class="code">var</span>:<sup><a data-type="noteref" href="ch10.xhtml#ch01fn98" id="ch01fn98-marker">1</a></sup></p>
<pre data-code-language="python" data-type="programlisting">
<code class="k">if</code>    <code class="p">(</code><code class="err">$</code><code class="n">statement</code> <code class="o">=~</code> <code class="o">/</code><code class="n">I</code> <code class="n">love</code> <code class="p">(</code>\<code class="n">w</code><code class="o">+</code><code class="p">)</code><code class="o">/</code><code class="p">)</code> <code class="p">{</code>
  <code class="nb">print</code> <code class="s2">"He loves $1</code><code class="se">\n</code><code class="s2">"</code><code class="p">;</code>
<code class="p">}</code>
<code class="n">elsif</code> <code class="p">(</code><code class="err">$</code><code class="n">statement</code> <code class="o">=~</code> <code class="o">/</code><code class="n">Ich</code> <code class="n">liebe</code> <code class="p">(</code>\<code class="n">w</code><code class="o">+</code><code class="p">)</code><code class="o">/</code><code class="p">)</code> <code class="p">{</code>
  <code class="nb">print</code> <code class="s2">"Er liebt $1</code><code class="se">\n</code><code class="s2">"</code><code class="p">;</code>
<code class="p">}</code>
<code class="n">elsif</code> <code class="p">(</code><code class="err">$</code><code class="n">statement</code> <code class="o">=~</code> <code class="o">/</code><code class="n">Je</code> <code class="n">t</code>\<code class="s1">'aime (\w+)/) {</code>
  <code class="nb">print</code> <code class="s2">"Il aime $1</code><code class="se">\n</code><code class="s2">"</code><code class="p">;</code>
<code class="p">}</code></pre>
<p>Prior to Python 3.8, this evaluate-and-store behavior was not possible in a single <span class="code"><strong>if</strong></span><span class="code">/<strong>elif</strong></span> statement; developers had to use a cumbersome cascade of nested <span class="code"><strong>if</strong>/</span><span class="code"><strong>else</strong></span> statements:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">m</code><code> </code><code class="o">=</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">match</code><code class="p">(</code><code class="s1">'</code><code class="s1">I love (</code><code class="s1">\</code><code class="s1">w+)</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">statement</code><code class="p">)</code><code>
</code><strong><code class="k">if</code></strong><code> </code><code class="n">m</code><code class="p">:</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="s1">He loves </code><code class="si">{</code><code class="n">m</code><code class="o">.</code><code class="n">group</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code class="si">}</code><code class="s1">'</code><code class="p">)</code><code>
</code><strong><code class="k">else</code></strong><code class="p">:</code><code>
</code><code>    </code><code class="n">m</code><code> </code><code class="o">=</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">match</code><code class="p">(</code><code class="s1">'</code><code class="s1">Ich liebe (</code><code class="s1">\</code><code class="s1">w+)</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">statement</code><code class="p">)</code><code>
</code><code>    </code><strong><code class="k">if</code></strong><code> </code><code class="n">m</code><code class="p">:</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="s1">Er liebt </code><code class="si">{</code><code class="n">m</code><code class="o">.</code><code class="n">group</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code class="si">}</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>    </code><strong><code class="k">else</code></strong><code class="p">:</code><code>
</code><code>         </code><code class="n">m</code><code> </code><code class="o">=</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">match</code><code class="p">(</code><code class="s1">'</code><code class="s1">J</code><code class="s1">'</code><code class="n">aime</code><code> </code><code class="p">(</code><code>\</code><code class="n">w</code><code class="o">+</code><code class="p">)</code><code class="s1">'</code><code class="s1">, statement)</code><code>
</code><code>        </code><strong><code class="k">if</code></strong><code> </code><code class="n">m</code><code class="p">:</code><code>
</code><code>            </code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="s1">Il aime </code><code class="si">{</code><code class="n">m</code><code class="o">.</code><code class="n">group</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code class="si">}</code><code class="s1">'</code><code class="p">)</code></pre>
<p>Using the <span class="code">:=</span> operator, this code simplifies to:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="k">if</code></strong><code> </code><code class="n">m</code><code> </code><code class="o">:=</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">match</code><code class="p">(</code><code class="sa">r</code><code class="s1">'</code><code class="s1">I love (</code><code class="s1">\</code><code class="s1">w+)</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">statement</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="s1">He loves </code><code class="si">{</code><code class="n">m</code><code class="o">.</code><code class="n">group</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code class="si">}</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>
</code><strong><code class="k">elif</code></strong><code> </code><code class="n">m</code><code> </code><code class="o">:=</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">match</code><code class="p">(</code><code class="sa">r</code><code class="s1">'</code><code class="s1">Ich liebe (</code><code class="s1">\</code><code class="s1">w+)</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">statement</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="s1">Er liebt </code><code class="si">{</code><code class="n">m</code><code class="o">.</code><code class="n">group</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code class="si">}</code><code class="s1">'</code><code class="p">)</code><code> </code><code>
</code><code>
</code><strong><code class="k">elif</code></strong><code> </code><code class="n">m</code><code> </code><code class="o">:=</code><code> </code><code class="n">re</code><code class="o">.</code><code class="n">match</code><code class="p">(</code><code class="sa">r</code><code class="s1">'</code><code class="s1">J</code><code class="s1">'</code><code class="n">aime</code><code> </code><code class="p">(</code><code>\</code><code class="n">w</code><code class="o">+</code><code class="p">)</code><code class="s1">'</code><code class="s1">, statement):</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="s1">Il aime </code><code class="si">{</code><code class="n">m</code><code class="o">.</code><code class="n">group</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code class="si">}</code><code class="s1">'</code><code class="p">)</code></pre>
</div></section>
<section data-pdf-bookmark="The Third-Party regex Module" data-type="sect1"><div class="sect1" id="the_third_party_regex_module">
<h1>The Third-Party regex Module</h1>
<p>As<a contenteditable="false" data-primary="regular expressions (REs)" data-secondary="regex module" data-type="indexterm" id="idm44924519246928"/><a contenteditable="false" data-primary="regex module" data-type="indexterm" id="idm44924519245712"/> an alternative to the Python standard library’s <span class="code">re</span> module, a popular package for regular expressions is the third-party <a href="https://oreil.ly/2wV-d"><span class="code">regex</span> module</a>, by Matthew Barnett. <span class="code">regex</span> has an API that’s compatible with the <span class="code">re</span> module and adds a number of extended features, including:</p>
<ul>
<li>
<p>Recursive expressions</p>
</li>
<li>
<p>Defining character sets by Unicode property/value</p>
</li>
<li>
<p>Overlapping matches</p>
</li>
<li>
<p>Fuzzy matching</p>
</li>
<li>
<p>Multithreading support (releases GIL during matching)</p>
</li>
<li>
<p>Matching timeout</p>
</li>
<li>
<p>Unicode case folding in case-insensitive matches</p>
</li>
<li>
<p>Nested sets</p>
</li>
</ul>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="ch01fn98"><sup><a href="ch10.xhtml#ch01fn98-marker">1</a></sup> This example is taken from regex; see <a href="https://oreil.ly/czLsu">“Match groups in Python” on Stack Overflow</a>.</p></div></div></section></div></body></html>