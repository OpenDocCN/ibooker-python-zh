- en: Chapter 3\. Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That action is best which procures the greatest happiness for the greatest numbers.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Francis Hutcheson
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter we begin by looking at Python’s simplest built-in data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Booleans* (which have the value `True` or `False`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Integers* (whole numbers such as `42` and `100000000`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Floats* (numbers with decimal points such as `3.14159`, or sometimes exponents
    like `1.0e8`, which means *one times ten to the eighth power*, or `100000000.0`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a way, they’re like atoms. We use them individually in this chapter, and
    in later chapters you’ll see how to combine them into larger “molecules” like
    lists and dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: Each type has specific rules for its usage and is handled differently by the
    computer. I also show how to use *literal* values like `97` and `3.1416`, and
    the *variables* that I mentioned in [Chapter 2](ch02.html#ch_names).
  prefs: []
  type: TYPE_NORMAL
- en: The code examples in this chapter are all valid Python, but they’re snippets.
    We’ll be using the Python interactive interpreter, typing these snippets and seeing
    the results immediately. Try running them yourself with the version of Python
    on your computer. You’ll recognize these examples by the `>>>` prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Booleans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Python, the only values for the boolean data type are `True` and `False`.
    Sometimes, you’ll use these directly; other times you’ll evaluate the “truthiness”
    of other types from their values. The special Python function `bool()` can convert
    any Python data type to a boolean.
  prefs: []
  type: TYPE_NORMAL
- en: Functions get their own chapter in [Chapter 9](ch09.html#ch_functions), but
    for now you just need to know that a function has a name, zero or more comma-separated
    input *arguments* surrounded by parentheses, and zero or more *return values*.
    The `bool()` function takes any value as its argument and returns the boolean
    equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nonzero numbers are considered `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And zero-valued ones are considered `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You’ll see the usefulness of booleans in [Chapter 4](ch04.html#ch_if). In later
    chapters, you’ll see how lists, dictionaries, and other types can be considered
    `True` or `False`.
  prefs: []
  type: TYPE_NORMAL
- en: Integers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integers are whole numbers—no fractions, no decimal points, nothing fancy. Well,
    aside from a possible initial sign. And bases, if you want to express numbers
    in other ways than the usual decimal (base 10).
  prefs: []
  type: TYPE_NORMAL
- en: Literal Integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any sequence of digits in Python represents a *literal integer*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A plain zero (`0`) is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'But you can’t have an initial `0` followed by a digit between `1` and `9`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This Python *exception* warns that you typed something that breaks Python’s
    rules. I explain what this means in [“Bases”](#bases). You’ll see many more examples
    of exceptions in this book because they’re Python’s main error handling mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: You can start an integer with `0b`, `0o`, or `0x`. See [“Bases”](#bases).
  prefs: []
  type: TYPE_NORMAL
- en: 'A sequence of digits specifies a positive integer. If you put a `+` sign before
    the digits, the number stays the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To specify a negative integer, insert a – before the digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can’t have any commas in the integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Instead of a million, you’d get a *tuple* (see [Chapter 7](ch07.html#ch_lists)
    for more information on tuples) with three values. But you *can* use the underscore
    (`_`) character as a digit separator:^([1](ch03.html#idm45795032481464))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, you can put underscores anywhere after the first digit; they’re just
    ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Integer Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the next few pages, I show examples of Python acting as a simple calculator.
    You can do normal arithmetic with Python by using the math *operators* in this
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Description | Example | Result |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | Addition | `5 + 8` | `13` |'
  prefs: []
  type: TYPE_TB
- en: '| `-` | Subtraction | `90 - 10` | `80` |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | Multiplication | `4 * 7` | `28` |'
  prefs: []
  type: TYPE_TB
- en: '| `/` | Floating-point division | `7 / 2` | `3.5` |'
  prefs: []
  type: TYPE_TB
- en: '| `//` | Integer (truncating) division | `7 // 2` | `3` |'
  prefs: []
  type: TYPE_TB
- en: '| `%` | Modulus (remainder) | `7 % 3` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `**` | Exponentiation | `3 ** 4` | `81` |'
  prefs: []
  type: TYPE_TB
- en: 'Addition and subtraction work as you’d expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can include as many numbers and operators as you’d like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you’re not required to have a space between each number and operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It just looks better stylewise and is easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiplication is also straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Division is a little more interesting because it comes in two flavors:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/` carries out *floating-point* (decimal) division'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`//` performs *integer* (truncating) division'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Even if you’re dividing an integer by an integer, using a `/` will give you
    a floating-point result (*floats* are coming later in this chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Truncating integer division returns an integer answer, throwing away any remainder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of tearing a hole in the space-time continuum, dividing by zero with
    either kind of division causes a Python exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Integers and Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All of the preceding examples used literal integers. You can mix literal integers
    and variables that have been assigned integer values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll remember from [Chapter 2](ch02.html#ch_names) that `a` is a name that
    points to an integer object. When I said `a - 3`, I didn’t assign the result back
    to `a`, so the value of `a` did not change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wanted to change `a`, you would do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Again, this would not be a legal math equation, but it’s how you reassign a
    value to a variable in Python. In Python, the expression on the right side of
    the `=` is calculated first, and then assigned to the variable on the left side.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it helps, think of it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: Subtract `3` from `a`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign the result of that subtraction to a temporary variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assign the value of the temporary variable to `a`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: So, when you say
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Python is calculating the subtraction on the righthand side, remembering the
    result, and then assigning it to `a` on the left side of the `+` sign. It’s faster
    and neater than using a temporary variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can combine the arithmetic operators with assignment by putting the operator
    before the `=`. Here, `a -= 3` is like saying `a = a - 3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is like `a = a + 8`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is like `a = a * 2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a floating-point division example, like `a = a / 3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s try the shorthand for `a = a // 4` (truncating integer division):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `%` character has multiple uses in Python. When it’s between two numbers,
    it produces the remainder when the first number is divided by the second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how to get both the (truncated) quotient and remainder at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, you could have calculated them separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You just saw some new things here: a *function* named `divmod` is given the
    integers `9` and `5` and returns a two-item *tuple*. As I mentioned earlier, tuples
    will take a bow in [Chapter 7](ch07.html#ch_lists); functions debut in [Chapter 9](ch09.html#ch_functions).'
  prefs: []
  type: TYPE_NORMAL
- en: 'One last math feature is exponentiation with `**`, which also lets you mix
    integers and floats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Precedence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What would you get if you typed the following?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do the addition first, `2 + 3` is `5`, and `5 * 4` is `20`. But if you
    do the multiplication first, `3 * 4` is `12`, and `2 + 12` is `14`. In Python,
    as in most languages, multiplication has higher *precedence* than addition, so
    the second version is what you’d see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'How do you know the precedence rules? There’s a big table in [Appendix E](app05.html#app_cheatsheets)
    that lists them all, but I’ve found that in practice I never look up these rules.
    It’s much easier to just add parentheses to group your code as you intend the
    calculation to be carried out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This example with exponents
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: is the same as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'and probably not what you wanted. Parentheses make it clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This way, anyone reading the code doesn’t need to guess its intent or look up
    precedence rules.
  prefs: []
  type: TYPE_NORMAL
- en: Bases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integers are assumed to be decimal (base 10) unless you use a prefix to specify
    another *base*. You might never need to use these other bases, but you’ll probably
    see them in Python code somewhere, sometime.
  prefs: []
  type: TYPE_NORMAL
- en: 'We generally have 10 fingers and 10 toes, so we count `0`, `1`, `2`, `3`, `4`,
    `5`, `6`, `7`, `8`, `9`. Next, we run out of single digits and carry the one to
    the “ten’s place” and put a `0` in the one’s place: `10` means “1 ten and 0 ones.”
    Unlike Roman numerals, Arabic numbers don’t have a single character that represents
    “10” Then, it’s `11`, `12`, up to `19`, carry the one to make `20` (2 tens and
    0 ones), and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: A base is how many digits you can use until you need to “carry the one.” In
    base 2 (`binary`), the only digits are `0` and `1`. This is the famous *bit*.
    `0` is the same as a plain old decimal 0, and `1` is the same as a decimal 1.
    However, in base 2, if you add a `1` to a `1`, you get `10` (1 decimal two plus
    0 decimal ones).
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, you can express literal integers in three bases besides decimal
    with these integer prefixes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0b` or `0B` for *binary* (base 2).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0o` or `0O` for *octal* (base 8).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0x` or `0X` for *hex* (base 16).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These bases are all powers of two, and are handy in some cases, although you
    may never need to use anything other than good old decimal integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interpreter prints these for you as decimal integers. Let’s try each of
    these bases. First, a plain old decimal `10`, which means *1 ten and 0 ones*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, a binary (base two) `0b10`, which means *1 (decimal) two and 0 ones*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Octal (base 8) `0o10` stands for *1 (decimal) eight and 0 ones*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Hexadecimal (base 16) `0x10` means *1 (decimal) sixteen and 0 ones*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You can go the other direction, converting an integer to a string with any
    of these bases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `chr()` function converts an integer to its single-character string equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'And `ord()` goes the other way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In case you’re wondering what “digits” base 16 uses, they are: `0`, `1`, `2`,
    `3`, `4`, `5`, `6`, `7`, `8`, `9`, `a`, `b`, `c`, `d`, `e`, and `f`. `0xa` is
    a decimal `10`, and `0xf` is a decimal `15`. Add 1 to `0xf` and you get `0x10`
    (decimal 16).'
  prefs: []
  type: TYPE_NORMAL
- en: Why use different bases from 10? They’re useful in *bit-level* operations, which
    are described in [Chapter 12](ch12.html#ch_munging), along with more details about
    converting numbers from one base to another.
  prefs: []
  type: TYPE_NORMAL
- en: Cats normally have five digits on each forepaw and four on each hindpaw, for
    a total of 18. If you ever encounter cat scientists in their lab coats, they’re
    often discussing base-18 arithmetic. My cat Chester, seen lounging about in [Figure 3-1](#img_chester),
    is a *polydactyl*, giving him a total of 22 or so (they’re hard to distinguish)
    toes. If he wanted to use all of them to count food fragments surrounding his
    bowl, he would likely use a base-22 system (hereafter, the *chesterdigital* system),
    using `0` through `9` and `a` through `l`.
  prefs: []
  type: TYPE_NORMAL
- en: '![chester](assets/inp2_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. Chester—a fine furry fellow, and inventor of the chesterdigital
    system
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Type Conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To change other Python data types to an integer, use the `int()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `int()` function takes one input argument and returns one value, the integer-ized
    equivalent of the input argument. This will keep the whole number and discard
    any fractional part.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you saw at the start of this chapter, Python’s simplest data type is the
    *boolean*, which has only the values `True` and `False`. When converted to integers,
    they represent the values `1` and `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Turning this around, the `bool()` function returns the boolean equivalent of
    an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting a floating-point number to an integer just lops off everything after
    the decimal point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting a float to a boolean is no surprise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here’s an example of getting the integer value from a text string
    ([Chapter 5](ch05.html#ch_strings)) that contains only digits, possibly with `_`
    digit separators or an initial `+` or `-` sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If the string represents a nondecimal integer, you can include the base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting an integer to an integer doesn’t change anything, but doesn’t hurt
    either:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to convert something that doesn’t look like a number, you’ll get
    an *exception*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The preceding text string started with valid digit characters (`99`), but it
    kept on going with others that the `int()` function just wouldn’t stand for.
  prefs: []
  type: TYPE_NORMAL
- en: '`int()` will make integers from floats or strings of digits, but it won’t handle
    strings containing decimal points or exponents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'If you mix numeric types, Python will sometimes try to automatically convert
    them for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The boolean value `False` is treated as `0` or `0.0` when mixed with integers
    or floats, and `True` is treated as `1` or `1.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: How Big Is an int?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Python 2, the size of an `int` could be limited to 32 or 64 bits, depending
    on your CPU; 32 bits can store store any integer from –2,147,483,648 to 2,147,483,647.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `long` had 64 bits, allowing values from –9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.
    In Python 3, the `long` type is long gone, and an `int` can be *any* size—even
    greater than 64 bits. You can play with big numbers like a *googol* (one followed
    by a hundred zeroes, [named](https://oreil.ly/6ibo_) in 1920 by a nine-year-old
    boy):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: A *googolplex* is `10**googol` (a thousand zeroes, if you want to try it yourself).
    This was a suggested name for [Google](https://oreil.ly/IQfer) before they decided
    on *googol*, but didn’t check its spelling before registering the domain name
    `google.com`.
  prefs: []
  type: TYPE_NORMAL
- en: In many languages, trying this would cause something called *integer overflow*,
    where the number would need more space than the computer allowed for it, with
    various bad effects. Python handles googoly integers with no problem.
  prefs: []
  type: TYPE_NORMAL
- en: Floats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Integers are whole numbers, but *floating-point* numbers (called *floats* in
    Python) have decimal points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Floats can include a decimal integer exponent after the letter `e`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use underscore (`_`) to separate digits for clarity, as you can for
    integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Floats are handled similarly to integers: you can use the operators (`+`, `–`,
    `*`, `/`, `//`, `**`, and `%`) and the `divmod()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert other types to floats, you use the `float()` function. As before,
    booleans act like tiny integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting an integer to a float just makes it the proud possessor of a decimal
    point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can convert a string containing characters that would be a valid float
    (digits, signs, decimal point, or an `e` followed by an exponent) to a real float:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'When you mix integers and floats, Python automatically *promotes* the integer
    values to float values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Python also promotes booleans to integers or floats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Math Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python supports complex numbers and has the usual math functions such as square
    roots, cosines, and so on. Let’s save them for [Chapter 22](ch22.html#ch_science),
    in which we also discuss using Python in science contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Coming Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next chapter, you finally graduate from one-line Python examples. With
    the `if` statement, you’ll learn how to make decisions with code.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Do
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter introduced the atoms of Python: numbers, booleans, and variables.
    Let’s try a few small exercises with them in the interactive interpreter.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 How many seconds are in an hour? Use the interactive interpreter as a calculator
    and multiply the number of seconds in a minute (`60`) by the number of minutes
    in an hour (also `60`).
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 Assign the result from the previous task (seconds in an hour) to a variable
    called `seconds_per_hour`.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 How many seconds are in a day? Use your `seconds_per_hour` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 3.4 Calculate seconds per day again, but this time save the result in a variable
    called `seconds_per_day`.
  prefs: []
  type: TYPE_NORMAL
- en: 3.5 Divide `seconds_per_day` by `seconds_per_hour`. Use floating-point (`/`)
    division.
  prefs: []
  type: TYPE_NORMAL
- en: 3.6 Divide `seconds_per_day` by `seconds_per_hour`, using integer (`//`) division.
    Did this number agree with the floating-point value from the previous question,
    aside from the final `.0`?
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch03.html#idm45795032481464-marker)) For Python 3.6 and newer.
  prefs: []
  type: TYPE_NORMAL
