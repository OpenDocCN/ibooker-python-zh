- en: Chapter 8\. Dictionaries and Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a word in the dictionary were misspelled, how would we know?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Steven Wright
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A *dictionary* is similar to a list, but the order of items doesn’t matter,
    and they aren’t selected by an offset such as 0 or 1. Instead, you specify a unique
    *key* to associate with each *value*. This key is often a string, but it can actually
    be any of Python’s immutable types: boolean, integer, float, tuple, string, and
    others that you’ll see in later chapters. Dictionaries are mutable, so you can
    add, delete, and change their key-value elements. If you’ve worked with languages
    that support only arrays or lists, you’ll love dictionaries.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In other languages, dictionaries might be called *associative arrays*, *hashes*,
    or *hashmaps*. In Python, a dictionary is also called a *dict* to save syllables
    and make teenage boys snicker.
  prefs: []
  type: TYPE_NORMAL
- en: Create with {}
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a dictionary, you place curly brackets (`{}`) around comma-separated
    *`key`* `:` *`value`* pairs. The simplest dictionary is an empty one, containing
    no keys or values at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s make a small dictionary with quotes from Ambrose Bierce’s *The Devil’s*
    *Dictionary*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Typing the dictionary’s name in the interactive interpreter will print its
    keys and values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In Python, it’s okay to leave a comma after the last item of a list, tuple,
    or dictionary. Also, you don’t need to indent, as I did in the preceding example,
    when you’re typing keys and values within the curly braces. It just helps readability.
  prefs: []
  type: TYPE_NORMAL
- en: Create with dict()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some people don’t like typing so many curly brackets and quotes. You can also
    create a dictionary by passing named arguments and values to the `dict()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The traditional way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `dict()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'One limitation of the second way is that the argument names need to be legal
    variable names (no spaces, no reserved words):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Convert with dict()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also use the `dict()` function to convert two-value sequences into a
    dictionary. You might run into such key-value sequences at times, such as “Strontium,
    90, Carbon, 14.”^([1](ch08.html#idm45795008873832)) The first item in each sequence
    is used as the key and the second as the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, here’s a small example using `lol` (a list of two-item lists):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We could have used any sequence containing two-item sequences. Here are other
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'A list of two-item tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A tuple of two-item lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A list of two-character strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A tuple of two-character strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The section [“Iterate Multiple Sequences with zip()”](ch07.html#list_zip) introduces
    you to the `zip()` function, which makes it easy to create these two-item sequences.
  prefs: []
  type: TYPE_NORMAL
- en: Add or Change an Item by [ *key* ]
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding an item to a dictionary is easy. Just refer to the item by its key and
    assign a value. If the key was already present in the dictionary, the existing
    value is replaced by the new one. If the key is new, it’s added to the dictionary
    with its value. Unlike lists, you don’t need to worry about Python throwing an
    exception during assignment by specifying an index that’s out of range.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make a dictionary of most of the members of Monty Python, using their
    last names as keys, and first names as values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re missing one member: the one born in America, Terry Gilliam. Here’s an
    attempt by an anonymous programmer to add him, but he’s botched the first name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s some repair code by another programmer who is Pythonic in more than
    one way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: By using the same key (`'Gilliam'`), we replaced the original value `'Gerry'`
    with `'Terry'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that dictionary keys must be *unique*. That’s why we used last names
    for keys instead of first names here—two members of Monty Python have the first
    name `''Terry''`! If you use a key more than once, the last value wins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We first assigned the value `'Gilliam'` to the key `'Terry'` and then replaced
    it with the value `'Jones'`.
  prefs: []
  type: TYPE_NORMAL
- en: Get an Item by [key] or with get()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the most common use of a dictionary. You specify the dictionary and
    key to get the corresponding value: Using `some_pythons` from the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If the key is not present in the dictionary, you’ll get an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two good ways to avoid this. The first is to test for the key at
    the outset by using `in`, as you saw in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The second is to use the special dictionary `get()` function. You provide the
    dictionary, key, and an optional value. If the key exists, you get its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, you get the optional value, if you specified one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, you get `None` (which displays nothing in the interactive interpreter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Get All Keys with keys()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use `keys()` to get all of the keys in a dictionary. We’ll use a different
    sample dictionary for the next few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In Python 2, `keys()` just returns a list. Python 3 returns `dict_keys()`, which
    is an iterable view of the keys. This is handy with large dictionaries because
    it doesn’t use the time and memory to create and store a list that you might not
    use. But often you actually *do* want a list. In Python 3, you need to call `list()`
    to convert a `dict_keys` object to a list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In Python 3, you also need to use the `list()` function to turn the results
    of `values()` and `items()` into normal Python lists. I use that in these examples.
  prefs: []
  type: TYPE_NORMAL
- en: Get All Values with values()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To obtain all the values in a dictionary, use `values()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Get All Key-Value Pairs with items()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you want to get all the key-value pairs from a dictionary, use the `items()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Each key and value is returned as a tuple, such as `('green', 'go')`.
  prefs: []
  type: TYPE_NORMAL
- en: Get Length with len()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Count your key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Combine Dictionaries with {**a, **b}
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting with Python 3.5, there’s a new way to merge dictionaries, using the
    `**` unicorn glitter, which has a very different use in [Chapter 9](ch09.html#ch_functions):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, you can pass more than two dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: These are *shallow* copies. See the discussion of `deepcopy()` ([“Copy Everything
    with deepcopy()”](#dict_deepcopy)) if you want full copies of the keys and values,
    with no connection to their origin dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: Combine Dictionaries with update()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use the `update()` function to copy the keys and values of one dictionary
    into another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define the `pythons` dictionary, with all members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have a dictionary of other humorous persons called `others`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, along comes another anonymous programmer who decides that the members
    of `others` should be members of Monty Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens if the second dictionary has the same key as the dictionary into
    which it’s being merged? The value from the second dictionary wins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Delete an Item by Key with del
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous `pythons.update(others)` code from our anonymous programmer was
    technically correct, but factually wrong. The members of `others`, although funny
    and famous, were not in Monty Python. Let’s undo those last two additions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Get an Item by Key and Delete It with pop()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This combines `get()` and `del`. If you give `pop()` a key and it exists in
    the dictionary, it returns the matching value and deletes the key-value pair.
    If it doesn’t exist, it raises an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'But if you give `pop()` a second default argument (as with `get()`), all is
    well and the dictionary is not changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Delete All Items with clear()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To delete all keys and values from a dictionary, use `clear()` or just reassign
    an empty dictionary (`{}`) to the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Test for a Key with in
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to know whether a key exists in a dictionary, use `in`. Let’s redefine
    the `pythons` dictionary again, this time omitting a name or two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s see who’s in there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Did we remember to add Terry Gilliam this time?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Drat.
  prefs: []
  type: TYPE_NORMAL
- en: Assign with =
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with lists, if you make a change to a dictionary, it will be reflected in
    all the names that refer to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Copy with copy()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To actually copy keys and values from a dictionary to another dictionary and
    avoid this, you can use `copy()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This is a *shallow* copy, and works if the dictionary values are immutable (as
    they are in this case). If they aren’t, you need `deepcopy()`.
  prefs: []
  type: TYPE_NORMAL
- en: Copy Everything with deepcopy()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose that the value for `red` in the previous example was a list instead
    of a single string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s change one of the values in the `red` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: You get the usual change-by-either-name behavior. The `copy()` method copied
    the values as-is, meaning `signal_copy` got the same list value for `'red'` that
    `signals` had.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is `deepcopy()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Compare Dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Much like lists and tuples in the previous chapter, dictionaries can be compared
    with the simple comparison operators `==` and `!=`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Other operators won’t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Python compares the keys and values one by one. The order in which they were
    originally created doesn’t matter. In this example, `a` and `b` are equal, except
    key `1` has the list value `[1, 2]` in `a` and the list value `[1, 1]` in `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Iterate with for and in
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Iterating over a dictionary (or its `keys()` function) returns the keys. In
    this example, the keys are the types of cards in the board game Clue (Cluedo outside
    of North America):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To iterate over the values rather than the keys, you use the dictionary’s `values()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To return both the key and value as a tuple, you can use the `items()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You can assign to a tuple in one step. For each tuple returned by `items()`,
    assign the first value (the key) to `card`, and the second (the value) to `contents`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Dictionary Comprehensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Not to be outdone by those bourgeois lists, dictionaries also have comprehensions.
    The simplest form looks familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re running a loop over each of the seven letters in the string `''letters''`
    and counting how many times that letter appears. Two uses of `word.count(letter)`
    are a waste of time because we have to count all the `e`’s twice and all the `t`’s
    twice. But when we count the `e`’s the second time, we do no harm because we just
    replace the entry in the dictionary that was already there; the same goes for
    counting the `t`’s. So, the following would have been a teeny bit more Pythonic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The dictionary’s keys are in a different order than the previous example because
    iterating `set(word)` returns letters in a different order than iterating the
    string `word`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to list comprehensions, dictionary comprehensions can also have `if`
    tests and multiple `for` clauses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: See [PEP-274](https://oreil.ly/6udkb) for more examples of dictionary comprehensions.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *set* is like a dictionary with its values thrown away, leaving only the keys.
    As with a dictionary, each key must be unique. You use a set when you only want
    to know that something exists, and nothing else about it. It’s a bag of keys.
    Use a dictionary if you want to attach some information to the key as a value.
  prefs: []
  type: TYPE_NORMAL
- en: At some bygone time, in some places, set theory was taught in elementary school
    along with basic mathematics. If your school skipped it (or you were staring out
    the window), [Figure 8-1](#fig_set_ops) shows the ideas of set union and intersection.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that you take the union of two sets that have some keys in common. Because
    a set must contain only one of each item, the union of two sets will contain only
    one of each key. The *null* or *empty* set is a set with zero elements. In [Figure 8-1](#fig_set_ops),
    an example of a null set would be female names beginning with `X`.
  prefs: []
  type: TYPE_NORMAL
- en: '![inp2 0801](assets/inp2_0801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1\. Common things to do with sets
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Create with set()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a set, you use the `set()` function or enclose one or more comma-separated
    values in curly brackets, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Sets are unordered.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because `[]` creates an empty list, you might expect `{}` to create an empty
    set. Instead, `{}` creates an empty dictionary. That’s also why the interpreter
    prints an empty set as `set()` instead of `{}`. Why? Dictionaries were in Python
    first and took possession of the curly brackets. And possession is nine-tenths
    of the law.^([2](ch08.html#idm45795006303816))
  prefs: []
  type: TYPE_NORMAL
- en: Convert with set()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create a set from a list, string, tuple, or dictionary, discarding any
    duplicate values.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s take a look at a string with more than one occurrence of some
    letters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the set contains only one `'e'` or `'t'`, even though `'letters'`
    contained two of each.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s make a set from a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, a set from a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'When you give `set()` a dictionary, it uses only the keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Get Length with len()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s count our reindeer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Add an Item with add()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Throw another item into a set with the set `add()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Delete an Item with remove()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can delete a value from a set by value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Iterate with for and in
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like dictionaries, you can iterate over all items in a set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Test for a Value with in
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the most common use of a set. We’ll make a dictionary called `drinks`.
    Each key is the name of a mixed drink, and the corresponding value is a set of
    that drink’s ingredients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though both are enclosed by curly braces (`{` and `}`), a set is just
    a bunch of values, and a dictionary contains *key* : *value* pairs.'
  prefs: []
  type: TYPE_NORMAL
- en: Which drinks contain vodka?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We want something with vodka but are lactose intolerant, and think vermouth
    tastes like kerosene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We’ll rewrite this a bit more succinctly in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Combinations and Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What if you want to check for combinations of set values? Suppose that you
    want to find any drink that has orange juice or vermouth? Let’s use the *set intersection
    operator*, which is an ampersand (`&`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The result of the `&` operator is a set that contains all of the items that
    appear in both lists that you compare. If neither of those ingredients were in
    `contents`, the `&` returns an empty set, which is considered `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s rewrite the example from the previous section, in which we wanted
    vodka but neither cream nor vermouth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s save the ingredient sets for these two drinks in variables, just to save
    our delicate fingers some typing in the coming examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are examples of all the set operators. Some have special punctuation,
    some have special functions, and some have both. Let’s use test sets `a` (contains
    `1` and `2`) and `b` (contains `2` and `3`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'As you saw earlier, you get the *intersection* (members common to both sets)
    with the special punctuation symbol `&`. The set `intersection()` function does
    the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This snippet uses our saved drink variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, get the *union* (members of either set) by using `|` or the
    set `union()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s the alcoholic version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The *difference* (members of the first set but not the second) is obtained
    by using the character `-` or the `difference()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: By far, the most common set operations are union, intersection, and difference.
    I’ve included the others for completeness in the examples that follow, but you
    might never use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *exclusive or* (items in one set or the other, but not both) uses `^` or
    `symmetric_difference()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'This finds the exclusive ingredient in our two russian drinks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check whether one set is a *subset* of another (all members of the
    first set are also in the second set) by using `<=` or `issubset()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding cream to a black russian makes a white russian, so `wruss` is a superset
    of `bruss`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Is any set a subset of itself? Yup.^([3](ch08.html#idm45795005210776))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'To be a *proper subset*, the second set needs to have all the members of the
    first and more. Calculate it by using `<`, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'A *superset* is the opposite of a subset (all members of the second set are
    also members of the first). This uses `>=` or `issuperset()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Any set is a superset of itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, you can find a *proper superset* (the first set has all members
    of the second, and more) by using `>`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'You can’t be a proper superset of yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Set Comprehensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'No one wants to be left out, so even sets have comprehensions. The simplest
    version looks like the list and dictionary comprehensions that you’ve just seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{` *`expression`* `for` *`expression`* `in` *`iterable`* `}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'And it can have the optional condition tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{` *`expression`* `for` *`expression`* `in` *`iterable`* `if` *`condition`*
    `}`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Create an Immutable Set with frozenset()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to create a set that can’t be changed, call the `frozenset()` function
    with any iterable argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Is it really frozen?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Yes, pretty frosty.
  prefs: []
  type: TYPE_NORMAL
- en: Data Structures So Far
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To review, you *make*:'
  prefs: []
  type: TYPE_NORMAL
- en: A list by using square brackets (`[]`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tuple by using commas and optional parentheses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dictionary or set by using curly brackets (`{}`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For all but sets, you *access* a single element with square brackets. For the
    list and tuple, the value between the square brackets is an integer offset. For
    the dictionary, it’s a key. For all three, the result is a value. For the set,
    it’s either there or it’s not; there’s no index or key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Make Bigger Data Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We worked up from simple booleans, numbers, and strings to lists, tuples, sets,
    and dictionaries. You can combine these built-in data structures into bigger,
    more complex structures of your own. Let’s start with three different lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make a tuple that contains each list as an element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can make a list that contains the three lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let’s create a dictionary of lists. In this example, let’s use the
    name of the comedy group as the key and the list of members as the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Your only limitations are those in the data types themselves. For example,
    dictionary keys need to be immutable, so a list, dictionary, or set can’t be a
    key for another dictionary. But a tuple can be. For example, you could index sites
    of interest by GPS coordinates (latitude, longitude, and altitude; see [Chapter 21](ch21.html#ch_business)
    for more mapping examples):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Coming Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back to code structures. You’ll learn how to wrap code in *functions*, and how
    to deal with *exceptions* when things go awry.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Do
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '8.1 Make an English-to-French dictionary called `e2f` and print it. Here are
    your starter words: `dog` is `chien`, `cat` is `chat`, and `walrus` is `morse`.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.2 Using your three-word dictionary `e2f`, print the French word for `walrus`.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3 Make a French-to-English dictionary called `f2e` from `e2f`. Use the `items`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4 Print the English equivalent of the French word `chien`.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5 Print the set of English words from `e2f`.
  prefs: []
  type: TYPE_NORMAL
- en: '8.6 Make a multilevel dictionary called `life`. Use these strings for the topmost
    keys: `''animals''`, `''plants''`, and `''other''`. Make the `''animals''` key
    refer to another dictionary with the keys `''cats''`, `''octopi''`, and `''emus''`.
    Make the `''cats''` key refer to a list of strings with the values `''Henri''`,
    `''Grumpy''`, and `''Lucy''`. Make all the other keys refer to empty dictionaries.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.7 Print the top-level keys of `life`.
  prefs: []
  type: TYPE_NORMAL
- en: 8.8 Print the keys for `life['animals']`.
  prefs: []
  type: TYPE_NORMAL
- en: 8.9 Print the values for `life['animals']['cats']`.
  prefs: []
  type: TYPE_NORMAL
- en: 8.10 Use a dictionary comprehension to create the dictionary `squares`. Use
    `range(10)` to return the keys, and use the square of each key as its value.
  prefs: []
  type: TYPE_NORMAL
- en: 8.11 Use a set comprehension to create the set `odd` from the odd numbers in
    `range(10)`.
  prefs: []
  type: TYPE_NORMAL
- en: 8.12 Use a generator comprehension to return the string `'Got '` and a number
    for the numbers in `range(10)`. Iterate through this by using a `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 8.13 Use `zip()` to make a dictionary from the key tuple `('optimist', 'pessimist',
    'troll')` and the values tuple `('The glass is half full',` `'The glass is half
    empty',` `'How did you get a glass?')`.
  prefs: []
  type: TYPE_NORMAL
- en: '8.14 Use `zip()` to make a dictionary called `movies` that pairs these lists:
    `titles =` `[''Creature of Habit'',` `''Crewel Fate'',` `''Sharks On a Plane'']`
    and `plots =` `[''A nun turns into a monster'',` `''A haunted yarn shop'',` `''Check
    your exits'']`'
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch08.html#idm45795008873832-marker)) Also, the final score in the Strontium-Carbon
    game.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch08.html#idm45795006303816-marker)) According to lawyers and exorcists.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch08.html#idm45795005210776-marker)) Although, paraphrasing Groucho Marx,
    “I wouldn’t want to belong to a club that would have someone like me as a member.”
  prefs: []
  type: TYPE_NORMAL
