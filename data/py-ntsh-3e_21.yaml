- en: Chapter 21\. Email, MIME, and Other Network Encodings
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 21 章\. 电子邮件、MIME 和其他网络编码
- en: What travels on a network are streams of bytes, also known in networking jargon
    as *octets.* Bytes can, of course, represent text, via any of several possible
    encodings. However, what you want to send over the network often has more structure
    than just a stream of text or bytes. The Multipurpose Internet Mail Extensions
    ([MIME](https://oreil.ly/dwyZi)) and other encoding standards bridge the gap,
    by specifying how to represent structured data as bytes or text. While often originally
    designed for email, such encodings are also used on the web and in many other
    networked systems. Python supports such encodings through various library modules,
    such as base64, quopri, and uu (covered in [“Encoding Binary Data as ASCII Text”](#encoding_binary_data_as_ascii_text)),
    and the modules of the email package (covered in the following section). These
    encodings allow us, for example, to seamlessly create messages in one encoding
    containing attachments in another, avoiding many awkward tasks along the way.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上传输的是字节流，也被网络行话称为*八位字节*。字节当然可以表示文本，通过多种可能的编码方式之一。然而，你希望通过网络发送的内容往往比单纯的文本或字节流有更复杂的结构。多用途互联网邮件扩展（[MIME](https://oreil.ly/dwyZi)）和其他编码标准填补了这一差距，它们规定了如何将结构化数据表示为字节或文本。虽然这些编码通常最初是为电子邮件设计的，但也被用于网络和许多其他网络系统。Python
    通过各种库模块支持这些编码，如 base64、quopri 和 uu（在[“将二进制数据编码为 ASCII 文本”](#encoding_binary_data_as_ascii_text)中介绍），以及
    email 包的模块（在下一节中介绍）。这些编码允许我们无缝地创建一个编码中包含附件的消息，避免了许多麻烦的任务。
- en: MIME and Email Format Handling
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MIME 和电子邮件格式处理
- en: The email package handles parsing, generation, and manipulation of MIME files
    such as email messages, Network News Transfer Protocol (NNTP) posts, HTTP interactions,
    and so on. The Python standard library also contains other modules that handle
    some parts of these jobs. However, the email package offers a complete and systematic
    approach to these important tasks. We suggest you use email, not the older modules
    that partially overlap with parts of email’s functionality. email, despite its
    name, need have nothing to do with receiving or sending email; for such tasks,
    see the modules imaplib, poplib, and smtplib, covered in [“Email Protocols”](ch19.xhtml#email_protocols).
    Rather, email deals with handling MIME messages (which may or may not be mail)
    after you receive them, or constructing them properly before you send them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: email 包处理 MIME 文件（如电子邮件消息）、网络新闻传输协议（NNTP）帖子、HTTP 交互等的解析、生成和操作。Python 标准库还包含其他处理这些工作部分的模块。然而，email
    包提供了一种完整和系统的方法来处理这些重要任务。我们建议您使用 email，而不是部分重叠 email 功能的旧模块。尽管名为 email，但它与接收或发送电子邮件无关；对于这些任务，请参见
    imaplib、poplib 和 smtplib 模块（在[“电子邮件协议”](ch19.xhtml#email_protocols)中介绍）。相反，email
    处理的是在接收到 MIME 消息之后或在发送之前正确构造它们的任务。
- en: Functions in the email Package
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: email 包中的函数
- en: The email package supplies four factory functions that return an instance *m*
    of the class email.message.Message from a string or file (see [Table 21-1](#email_factory_functions_that_build_mess)).
    These functions rely on the class email.parser.Parser, but the factory functions
    are handier and simpler. Therefore, we do not cover the email.parser module further
    in this book.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: email 包提供了四个工厂函数，从字符串或文件中返回一个类 email.message.Message 的实例 *m*（参见[表 21-1](#email_factory_functions_that_build_mess)）。这些函数依赖于类
    email.parser.Parser，但工厂函数更方便、更简单。因此，本书不再深入介绍 email.parser 模块。
- en: Table 21-1\. email factory functions that build message objects from strings
    or files
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 表 21-1\. 构建来自字符串或文件的消息对象的电子邮件工厂函数
- en: '| m⁠e⁠s⁠s⁠a⁠g⁠e⁠_⁠f⁠r⁠o⁠m⁠_⁠b⁠i⁠n⁠a⁠r⁠y⁠_​f⁠i⁠l⁠e | message_from_binary_file(*f*)
    Builds *m* by parsing the contents of binary file-like object *f*, which must
    be open for reading |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| m⁠e⁠s⁠s⁠a⁠g⁠e⁠_⁠f⁠r⁠o⁠m⁠_⁠b⁠i⁠n⁠a⁠r⁠y⁠_​f⁠i⁠l⁠e | 使用二进制文件对象 *f*（必须已打开以供读取）的内容解析构建
    *m* |'
- en: '| message_from_bytes | message_from_bytes(*s*) Builds *m* by parsing bytestring
    *s* |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| message_from_bytes | 使用字节串 *s* 解析构建 *m* |'
- en: '| message_from_file | message_from_file(*f*) Builds *m* by parsing the contents
    of text file-like object *f*, which must be open for reading |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| message_from_file | 使用文本文件对象 *f*（必须已打开以供读取）的内容解析构建 *m* |'
- en: '| message_from_string | message_from_string(*s*) Builds *m* by parsing string
    *s* |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| message_from_string | 使用字符串 *s* 解析构建 *m* |'
- en: The email.message Module
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: email.message 模块
- en: The email.message module supplies the class Message. All parts of the email
    package make, modify, or use instances of Message. An instance *m* of Message
    models a MIME message, including *headers* and a *payload* (data content). *m*
    is a mapping, with header names as keys, and header value strings as values.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: email.message 模块提供了 Message 类。电子邮件包的所有部分都创建、修改或使用 Message 实例。 Message 的一个实例
    *m* 模拟了 MIME 消息，包括 *headers* 和 *payload*（数据内容）。 *m* 是一个映射，以头部名称为键，以头部值字符串为值。
- en: To create an initially empty *m*, call Message with no arguments. More often,
    you create *m* by parsing via one of the factory functions in [Table 21-1](#email_factory_functions_that_build_mess),
    or other indirect means such as the classes covered in [“Creating Messages”](#creating_messages).
    *m*’s payload can be a string, a single other instance of Message, or a *multipart
    message* (a recursively nested list of other Message instances).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个最初为空的 *m*，请不带参数调用 Message。更常见的情况是，通过 [Table 21-1](#email_factory_functions_that_build_mess)
    中的工厂函数之一解析来创建 *m*，或者通过 [“创建消息”](#creating_messages) 中涵盖的其他间接方式。 *m* 的有效载荷可以是字符串、另一个
    Message 实例或者 *多部分消息*（一组递归嵌套的其他 Message 实例）。
- en: You can set arbitrary headers on email messages you’re building. Several internet
    RFCs specify headers for a wide variety of purposes. The main applicable RFC is
    [RFC 2822](https://oreil.ly/xyfF_); you can find a summary of many other RFCs
    about headers in nonnormative [RFC 2076](https://oreil.ly/IpSCO).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在构建的电子邮件消息上设置任意头部。几个互联网 RFC（请求评论）指定了各种目的的头部。主要适用的 RFC 是 [RFC 2822](https://oreil.ly/xyfF_)；你可以在非规范性的
    [RFC 2076](https://oreil.ly/IpSCO) 中找到关于头部的许多其他 RFC 的摘要。
- en: 'To make *m* more convenient, its semantics as a mapping are different from
    those of a dict. *m*’s keys are case insensitive. *m* keeps headers in the order
    in which you add them, and the methods keys, values, and items return lists (not
    views!) of headers in that order. *m* can have more than one header named *key*:
    *m*[*key*] returns an arbitrary such header (or **None** when the header is missing),
    and **del** *m*[*key*] deletes all of them (it’s not an error if the header is
    missing).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 *m* 更方便，作为映射的语义与字典的语义不同。 *m* 的键大小写不敏感。 *m* 保持您添加的顺序的头部，方法 keys、values 和
    items 返回按照该顺序排列的头部列表（而不是视图！）。 *m* 可以有多个名为 *key* 的头部：*m*[*key*] 返回任意一个这样的头部（或者头部缺失时返回
    **None**），**del** *m*[*key*] 删除所有这样的头部（如果头部缺失则不会报错）。
- en: 'To get a list of all headers with a certain name, call *m*.get_all(*key*).
    len(*m*) returns the total number of headers, counting duplicates, not just the
    number of distinct header names. When there is no header named *key**,* *m*[*key*]
    returns **None** and does not raise KeyError (i.e., it behaves like *m*.get(*key*)):
    **del** *m*[*key*] does nothing in this case, and *m*.get_all(*key*) returns **None**.
    You can loop directly on *m*: it’s just like looping on *m*.keys() instead.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '要获取所有具有特定名称的头部的列表，请调用 *m*.get_all(*key*)。 len(*m*) 返回总头部数，计算重复项，而不仅仅是不同头部名称的数量。当没有名为
    *key** 的头部时，*m*[*key*] 返回 **None** 并且不会引发 KeyError（即它的行为类似于 *m*.get(*key*): **del**
    *m*[*key*] 在这种情况下不起作用，而 *m*.get_all(*key*) 返回 **None**）。您可以直接在 *m* 上循环：这就像在 *m*.keys()
    上循环一样。'
- en: An instance *m* of Message supplies various attributes and methods that deal
    with *m*’s headers and payload, listed in [Table 21-2](#attributes_and_methods_of_an_instance_m).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Message 的一个实例 *m* 提供了各种处理 *m* 的头部和有效载荷的属性和方法，列在 [Table 21-2](#attributes_and_methods_of_an_instance_m)
    中。
- en: Table 21-2\. Attributes and methods of an instance *m* of Message
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 表 21-2\. Message 实例 *m* 的属性和方法
- en: '| add_header | *m*.add_header(_*name*, *_value*, ***_params*) Like *m*[_*name*]=_*value*,
    but you can also supply header parameters as named arguments. For each named argument
    *pname*=*pvalue*, add_header changes any underscores in *pname* to dashes, then
    appends to the header’s value a string of the form:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '| add_header | *m*.add_header(_*name*, *_value*, ***_params*) 类似于 *m*[_*name*]=_*value*，但您还可以作为命名参数提供头部参数。对于每个命名参数
    *pname*=*pvalue*，add_header 将 *pname* 中的任何下划线更改为破折号，然后将一个形式为的字符串附加到头部的值：'
- en: ; *pname*="*pvalue*"
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ; *pname*="*pvalue*"
- en: 'When *pvalue* is **None**, add_header appends only a string of the form:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *pvalue* 为 **None** 时，add_header 仅附加形式为的字符串：
- en: ; *pname*
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ; *pname*
- en: When a parameter’s value contains non-ASCII characters, specify it as a tuple
    with three items, (*CHARSET*, *LANGUAGE*, *VALUE*). *CHARSET* names the encoding
    to use for the value. *LANGUAGE* is usually **None** or '' but can be set any
    language value per [RFC 2231](https://oreil.ly/FKtQA); *VALUE* is the string value
    containing non-ASCII characters. |
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当参数的值包含非 ASCII 字符时，将其指定为一个三项元组，(*CHARSET*, *LANGUAGE*, *VALUE*)。*CHARSET* 指定用于值的编码。*LANGUAGE*
    通常为 **None** 或 ''，但可以根据 [RFC 2231](https://oreil.ly/FKtQA) 设置任何语言值。*VALUE* 是包含非
    ASCII 字符的字符串值。
- en: '| as_string | *m*.as_string(unixfrom=**False**) Returns the entire message
    as a string. When unixfrom is true, also includes a first line, normally starting
    with ''From '', known as the *envelope header* of the message. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| as_string | *m*.as_string(unixfrom=**False**) 返回整个消息作为字符串。当 unixfrom 为 true
    时，还包括第一行，通常以 ''From '' 开头，称为消息的 *envelope header*。 |'
- en: '| attach | *m*.attach(*payload*) Adds *payload*, a message, to *m*’s payload.
    When *m*’s payload is **None**, *m*’s payload is now the single-item list [*payload*].
    When *m*’s payload is a list of messages, appends *payload* to the list. When
    *m*’s payload is anything else, *m*.attach(*payload*) raises MultipartConversionError.
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| attach | *m*.attach(*payload*) 将 *payload*，即消息，添加到 *m* 的载荷中。当 *m* 的载荷为 **None**
    时，*m* 的载荷现在是单个项目列表 [*payload*]。当 *m* 的载荷为消息列表时，将 *payload* 追加到列表中。当 *m* 的载荷为其他任何内容时，*m*.attach(*payload*)
    引发 MultipartConversionError。 |'
- en: '| epilogue | The attribute *m*.epilogue can be **None**, or a string that becomes
    part of the message’s string form after the last boundary line. Mail programs
    normally don’t display this text. epilogue is a normal attribute of *m*: your
    program can access it when you’re handling any *m*, and bind it when you’re building
    or modifying *m*. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| epilogue | 属性 *m*.epilogue 可以是 **None**，或者是一个字符串，在最后一个边界线之后成为消息字符串形式的一部分。邮件程序通常不显示此文本。epilogue
    是 *m* 的正常属性：在处理任何 *m* 时，您的程序可以访问它，并在构建或修改 *m* 时将其绑定。 |'
- en: '| get_all | *m*.get_all(*name*, default=**None**) Returns a list with all values
    of headers named *name* in the order in which the headers are added to *m*. When
    *m* has no header named *name*, get_all returns default. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| get_all | *m*.get_all(*name*, default=**None**) 返回一个列表，其中包含按照添加到 *m* 的顺序命名为
    *name* 的所有头部的所有值。当 *m* 没有名为 *name* 的头部时，get_all 返回 default。 |'
- en: '| get_boundary | *m*.get_boundary(default=**None**) Returns the string value
    of the boundary parameter of *m*’s Content-Type header. When *m* has no Content-Type
    header, or the header has no boundary parameter, get_boundary returns default.
    |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| get_boundary | *m*.get_boundary(default=**None**) 返回 *m* 的 Content-Type 头部的
    boundary 参数的字符串值。当 *m* 没有 Content-Type 头部或头部没有 boundary 参数时，get_boundary 返回 default。
    |'
- en: '| get_charsets | *m*.get_charsets(default=**None**) Returns the list *L* of
    string values of parameter charset of *m*’s Content-Type header. When *m* is multipart,
    *L* has one item per part; otherwise, *L* has length 1. For parts that have no
    Content-Type header, no charset parameter, or a main type different from ''text'',
    the corresponding item in *L* is default. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| get_charsets | *m*.get_charsets(default=**None**) 返回参数 charset 在 *m* 的 Content-Type
    头部中的字符串值列表 *L*。当 *m* 是多部分时，*L* 每个部分有一项；否则，*L* 的长度为 1。对于没有 Content-Type 头部、没有 charset
    参数或者主类型与 ''text'' 不同的部分，*L* 中对应的项目是 default。 |'
- en: '| g⁠e⁠t⁠_⁠c⁠o⁠n⁠t⁠e⁠n⁠t⁠_​m⁠a⁠i⁠n⁠t⁠y⁠p⁠e | *m*.get_content_maintype(default=**None**)
    Returns *m*’s main content type: a lowercase string ''*maintype*'' taken from
    header Content-Type. For example, when Content-Type is ''Text/Html'', get_content_maintype
    returns ''text''. When *m* has no Content-Type header, get_content_maintype returns
    default. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| g⁠e⁠t⁠_⁠c⁠o⁠n⁠t⁠e⁠n⁠t⁠_​m⁠a⁠i⁠n⁠t⁠y⁠p⁠e | *m*.get_content_maintype(default=**None**)
    返回 *m* 的主内容类型：从头部 Content-Type 中取出的小写字符串 ''*maintype*''。例如，当 Content-Type 是 ''Text/Html''
    时，get_content_maintype 返回 ''text''。当 *m* 没有 Content-Type 头部时，get_content_maintype
    返回 default。 |'
- en: '| g⁠e⁠t⁠_⁠c⁠o⁠n⁠t⁠e⁠n⁠t⁠_​s⁠u⁠b⁠t⁠y⁠p⁠e | *m*.get_content_subtype(default=**None**)
    Returns *m*’s content subtype: a lowercase string ''*subtype*'' taken from header
    Content-Type. For example, when Content-Type is ''Text/Html'', get_content_subtype
    returns ''html''. When *m* has no Content-Type header, get_content_subtype returns
    default. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| g⁠e⁠t⁠_⁠c⁠o⁠n⁠t⁠e⁠n⁠t⁠_​s⁠u⁠b⁠t⁠y⁠p⁠e | *m*.get_content_subtype(default=**None**)
    返回 *m* 的内容子类型：从头部 Content-Type 中取出的小写字符串 ''*subtype*''。例如，当 Content-Type 是 ''Text/Html''
    时，get_content_subtype 返回 ''html''。当 *m* 没有 Content-Type 头部时，get_content_subtype
    返回 default。 |'
- en: '| g⁠e⁠t⁠_⁠c⁠o⁠n⁠t⁠e⁠n⁠t⁠_​t⁠y⁠p⁠e | *m*.get_content_type(default=**None**)
    Returns *m*’s content type: a lowercase string ''*maintype/subtype*'' taken from
    header Content-Type. For example, when Content-Type is ''Text/Html'', get_content_type
    returns ''text/html''. When *m* has no Content-Type header, get_content_type returns
    default. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| g⁠e⁠t⁠_⁠c⁠o⁠n⁠t⁠e⁠n⁠t⁠_​t⁠y⁠p⁠e | *m*.get_content_type(default=**None**)
    返回 *m* 的内容类型：从头部 Content-Type 中取得一个小写字符串 ''*maintype/subtype*''。例如，当 Content-Type
    为 ''Text/Html'' 时，get_content_type 返回 ''text/html''。当 *m* 没有 Content-Type 头部时，get_content_type
    返回 default。 |'
- en: '| get_filename | *m*.get_filename(default=**None**) Returns the string value
    of the filename parameter of *m*’s Content-Disposition header. When *m* has no
    Content-Disposition header, or the header has no filename parameter, get_filename
    returns default. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| get_filename | *m*.get_filename(default=**None**) 返回 *m* 的 Content-Disposition
    头部的 filename 参数的字符串值。当 *m* 没有 Content-Disposition 头部，或头部没有 filename 参数时，get_filename
    返回 default。 |'
- en: '| get_param | *m*.get_param(*param*, *d*efault=**None**, header=''Content-Type'')
    Returns the string value of parameter *param* of *m*’s header header. Returns
    '''' for a parameter specified just by name (without a value). When *m* has no
    header header, or the header has no parameter named *param*, get_param returns
    default. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| get_param | *m*.get_param(*param*, *d*efault=**None**, header=''Content-Type'')
    返回 *m* 的头部 header 中参数 *param* 的字符串值。对于仅由名称指定（没有值）的参数，返回 ''''。当 *m* 没有头部 header，或头部没有名为
    *param* 的参数时，get_param 返回 default。 |'
- en: '| get_params | *m*.get_params(default=**None**, header=''Content-Type'') Returns
    the parameters of *m*’s header header, a list of pairs of strings that give each
    parameter’s name and value. Uses '''' as the value for parameters specified just
    by name (without a value). When *m* has no header header, get_params returns default.
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| get_params | *m*.get_params(default=**None**, header=''Content-Type'') 返回
    *m* 的头部 header 的参数，一个由字符串对组成的列表，每个参数给出其名称和值。对于仅由名称指定（没有值）的参数，使用 '''' 作为值。当 *m*
    没有头部 header 时，get_params 返回 default。 |'
- en: '| get_payload | *m*.get_payload(i=**None**, decode=**False**) Returns *m*’s
    payload. When *m*.is_multipart is **False**, i must be **None**, and *m*.get_payload
    returns *m*’s entire payload, a string or Message instance. If decode is true
    and the value of header Content-Transfer-Encoding is either ''quoted-printable''
    or ''base64'', *m*.get_payload also decodes the payload. If decode is false, or
    header Content-Transfer-Encoding is missing or has other values, *m*.get_payload
    returns the payload unchanged.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '| get_payload | *m*.get_payload(i=**None**, decode=**False**) 返回 *m* 的载荷。当
    *m*.is_multipart 为 **False** 时，i 必须为 **None**，*m*.get_payload 返回 *m* 的整个载荷，一个字符串或消息实例。如果
    decode 为 true，并且头部 Content-Transfer-Encoding 的值为 ''quoted-printable'' 或 ''base64''，*m*.get_payload
    还会对载荷进行解码。如果 decode 为 false，或头部 Content-Transfer-Encoding 缺失或具有其他值，*m*.get_payload
    返回未更改的载荷。'
- en: When *m*.is_multipart is **True**, decode must be false. When i is **None**,
    *m*.get_payload returns *m*’s payload as a list. Otherwise, *m*.get_payload(*i*)
    returns the *i*th item of the payload, or raises TypeError if *i* < 0 or i is
    too large. |
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *m*.is_multipart 为 **True** 时，decode 必须为 false。当 i 为 **None** 时，*m*.get_payload
    返回 *m* 的载荷作为列表。否则，*m*.get_payload(*i*) 返回载荷的第 i 项，如果 *i* < 0 或 i 太大，则引发 TypeError。
- en: '| get_unixfrom | *m*.get_unixfrom() Returns the envelope header string for
    *m*, or **None** when *m* has no envelope header. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| get_unixfrom | *m*.get_unixfrom() 返回 *m* 的信封头字符串，当 *m* 没有信封头时返回 **None**。
    |'
- en: '| is_multipart | *m*.is_multipart() Returns **True** when *m*’s payload is
    a list; otherwise, returns **False**. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| is_multipart | *m*.is_multipart() 当 *m* 的载荷为列表时返回 **True**；否则返回 **False**。
    |'
- en: '| preamble | Attribute *m*.preamble can be **None**, or a string that becomes
    part of the message’s string form before the first boundary line. A mail program
    shows this text only if it doesn’t support multipart messages, so you can use
    this attribute to alert the user that your message is multipart and a different
    mail program is needed to view it. preamble is a normal attribute of *m*: your
    program can access it when you’re handling an *m* that is built by whatever means,
    and bind, rebind, or unbind it when you’re building or modifying *m*. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| preamble | 属性 *m*.preamble 可以是 **None**，或成为消息的字符串形式的一部分，出现在第一个边界线之前。邮件程序仅在不支持多部分消息时显示此文本，因此您可以使用此属性来提醒用户需要使用其他邮件程序来查看。preamble
    是 *m* 的普通属性：在处理由任何手段构建的 *m* 时，您的程序可以访问它，并在构建或修改 *m* 时绑定、重新绑定或解绑它。 |'
- en: '| set_boundary | *m*.set_boundary(*boundary*) Sets the boundary parameter of
    *m*’s Content-Type header to *boundary**.* When *m* has no Content-Type header,
    raises HeaderParseError. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| set_boundary | *m*.set_boundary(*boundary*) 将 *m* 的 Content-Type 头部的 boundary
    参数设置为 *boundary**.*。当 *m* 没有 Content-Type 头部时，引发 HeaderParseError。 |'
- en: '| set_payload | *m*.set_payload(*payload*) Sets *m*’s payload to *payload*,
    which must be a string, or a list of Message instances, as appropriate to *m*’s
    Content-Type. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| set_payload | *m*.set_payload(*payload*) 将 *m* 的 payload 设置为 *payload*，它必须是字符串或适合
    *m* 的 Content-Type 的 Message 实例列表。 |'
- en: '| set_unixfrom | *m*.set_unixfrom(*unixfrom*) Sets the envelope header string
    for *m**.* *unixfrom* is the entire envelope header line, including the leading
    ''From '' but *not* including the trailing ''\n''. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| set_unixfrom | *m*.set_unixfrom(*unixfrom*) 设置 *m* 的信封头字符串为 *unixfrom*。*unixfrom*
    是整个信封头行，包括前导的 ''From '' 但不包括尾部的 ''\n''。 |'
- en: '| walk | *m*.walk() Returns an iterator on all parts and subparts of *m* to
    walk the tree of parts, depth-first (see [“Recursion”](ch03.xhtml#recursion)).
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| walk | *m*.walk() 返回一个迭代器，用于遍历 *m* 的所有部分和子部分，深度优先（参见 [“递归”](ch03.xhtml#recursion)）。
    |'
- en: The email.Generator Module
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: email.Generator 模块
- en: 'The email.Generator module supplies the class Generator, which you can use
    to generate the textual form of a message *m**.* *m*.as_string() and str(*m*)
    may be enough, but Generator gives more flexibility. Instantiate the Generator
    class with a mandatory argument, *outfp*, and two optional arguments:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: email.Generator 模块提供了 Generator 类，您可以使用它来生成消息 *m* 的文本形式。*m*.as_string() 和 str(*m*)
    或许已经足够，但 Generator 提供了更多的灵活性。使用必需参数 *outfp* 和两个可选参数实例化 Generator 类：
- en: '| Generator | **class** Generator(*outfp*, mangle_from_=**False**, maxheaderlen=78)
    *outfp* is a file or file-like object that supplies the method write. When mangle_from_
    is true, *g* prepends a greater-than sign (>) to any line in the payload that
    starts with ''From '', to make the message’s textual form easier to parse. *g*
    wraps each header line, at semicolons, into physical lines of no more than maxheaderlen
    characters. To use *g*, call *g*.flatten; for example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '| Generator | **class** Generator(*outfp*, mangle_from_=**False**, maxheaderlen=78)
    *outfp* 是一个文件或类文件对象，供应写入方法。当 mangle_from_ 为真时，*g* 会在 payload 中以 ''From '' 开头的任何行前添加大于号
    (>)，以便更容易解析消息的文本形式。*g* 将每个标题行在分号处包装成不超过 maxheaderlen 字符的物理行。要使用 *g*，调用 *g*.flatten；例如：'
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This emits *m* as text to *outfp*, like (but consuming less memory than):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 *m* 以文本形式发射到 *outfp*，类似于（但比以下代码消耗更少的内存）：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: . |
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: . |
- en: Creating Messages
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建消息
- en: The subpackage email.mime supplies various modules, each with a subclass of
    Message named like the module. The modules’ names are lowercase (e.g., email.mime.text),
    while the class names are in mixed case. These classes, listed in [Table 21-3](#classes_supplied_by_emaildotmime),
    help you create Message instances of different MIME types.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: email.mime 子包提供各种模块，每个模块都有一个名为模块的 Message 子类。模块的名称为小写（例如，email.mime.text），而类名为混合大小写。这些类列在
    [Table 21-3](#classes_supplied_by_emaildotmime) 中，帮助您创建不同 MIME 类型的 Message 实例。
- en: Table 21-3\. Classes supplied by email.mime
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Table 21-3\. email.mime 提供的类
- en: '| MIMEAudio | **class** MIMEAudio(_*audiodata*, _subtype=**None**, _encoder=**None**,
    **_*params*) Creates MIME message objects of major type ‘audio’. *_audiodata*
    is a bytestring of audio data to pack in a message of MIME type ''audio/_subtype''.
    When _subtype is **None**, *_audiodata* must be parsable by standard Python library
    module sndhdr to determine the subtype; otherwise, MIMEAudio raises TypeError.
    3.11+ Since sndhdr is deprecated, you should always specify the _subtype. When
    _encoder is **None**, MIMEAudio encodes data as Base64, which is usually optimal.
    Otherwise, _encoder must be callable with one parameter, *m*, which is the message
    being constructed; _encoder must then call *m*.get_payload to get the payload,
    encode the payload, put the encoded form back by calling *m*.set_payload, and
    set *m*’s Content-Transfer-Encoding header. MIMEAudio passes the *_params* dictionary
    of named argument names and values to *m*.add_header to construct *m*’s Content-Type
    header. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| MIMEAudio | **class** MIMEAudio(_*audiodata*, _subtype=**None**, _encoder=**None**,
    **_*params*) 创建主类型为 ''audio'' 的 MIME 消息对象。*_audiodata* 是音频数据的字节串，用于打包为 ''audio/_subtype''
    MIME 类型的消息。当 _subtype 为 **None** 时，*_audiodata* 必须可被标准 Python 库模块 sndhdr 解析以确定子类型；否则，MIMEAudio
    会引发 TypeError。3.11+ 由于 sndhdr 已被弃用，您应该始终指定 _subtype。当 _encoder 为 **None** 时，MIMEAudio
    会将数据编码为 Base64，这通常是最佳的。否则，_encoder 必须是可调用的，带有一个参数 *m*，即正在构建的消息；_encoder 必须调用 *m*.get_payload
    获取载荷，对载荷进行编码，通过调用 *m*.set_payload 将编码形式放回，并设置 *m* 的 Content-Transfer-Encoding
    头。MIMEAudio 将 *_params* 字典的命名参数名和值传递给 *m*.add_header 以构造 *m* 的 Content-Type 头。
    |'
- en: '| MIMEBase | **class** MIMEBase(_*maintype*, *_subtype*, **_*params*) Base
    class of all MIME classes; extends Message. Instantiating:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '| MIMEBase | **class** MIMEBase(_*maintype*, _*subtype*, **_*params*) MIME
    类的基类，扩展自 Message。实例化：'
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'is equivalent to the longer and slightly less convenient idiom:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于更长且稍微不太方便的习语：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| MIMEImage | **class** MIMEImage(_*imagedata*, _subtype=**None**, _encoder=**None**,
    ***_params*) Like MIMEAudio, but with main type ''image''; uses standard Python
    module imghdr to determine the subtype, if needed. 3.11+ Since imghdr is deprecated,
    you should always specify the _subtype. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| MIMEImage | **class** MIMEImage(_*imagedata*, _subtype=**None**, _encoder=**None**,
    ***_params*) 类似于 MIMEAudio，但主类型为 ''image''；使用标准 Python 模块 imghdr 来确定子类型（如果需要）。3.11+
    由于 imghdr 已被弃用，因此应始终指定 _subtype。 |'
- en: '| MIMEMessage | **class** MIMEMessage(*msg*, _subtype=''rfc822'') Packs *msg*,
    which must be an instance of Message (or a subclass), as the payload of a message
    of MIME type ''message/_subtype''. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| MIMEMessage | **class** MIMEMessage(*msg*, _subtype=''rfc822'') 将 *msg*（必须是
    Message 的一个实例（或子类））打包为 MIME 类型为 ''message/_subtype'' 的消息的有效载荷。 |'
- en: '| MIMEText | **class** MIMEText(_*text*, _subtype=''plain'', _charset=''us-ascii'',
    _encoder=**None**) Packs text string *_text* as the payload of a message of MIME
    type ''text/_subtype'' with the given _charset. When _encoder is **None**, MIMEText
    does not encode the text, which is generally the best choice. Otherwise, _encoder
    must be callable with one parameter, *m*, which is the message being constructed;
    _encoder must then call *m*.get_payload to get the payload, encode the payload,
    put the encoded form back by calling *m*.set_payload, and set *m*’s Content-Transfer-Encoding
    header appropriately. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| MIMEText | **class** MIMEText(_*text*, _subtype=''plain'', _charset=''us-ascii'',
    _encoder=**None**) 将文本字符串 *_text* 打包为 MIME 类型为 ''text/_subtype'' 的消息的有效载荷，并使用给定的
    _charset。当 _encoder 为 **None** 时，MIMEText 不对文本进行编码，这通常是最佳选择。否则，_encoder 必须是可调用的，带有一个参数
    *m*，即正在构造的消息；然后，_encoder 必须调用 *m*.get_payload 获取有效载荷，对有效载荷进行编码，通过调用 *m*.set_payload
    将编码形式放回，然后适当设置 *m* 的 Content-Transfer-Encoding 标题。 |'
- en: The email.encoders Module
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: email.encoders 模块
- en: The email.encoders module supplies functions that take a *nonmultipart* message
    *m* as their only argument, encode *m*’s payload, and set *m*’s headers appropriately.
    These functions are listed in [Table 21-4](#functions_of_the_emaildotencoders_modul).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: email.encoders 模块提供了一些函数，这些函数以一个 *nonmultipart* 消息 *m* 作为它们唯一的参数，对 *m* 的有效载荷进行编码，并适当设置
    *m* 的标题。这些函数列在[表 21-4](#functions_of_the_emaildotencoders_modul)中。
- en: Table 21-4\. Functions of the email.encoders module
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 表 21-4\. email.encoders 模块的函数
- en: '| encode_base64 | encode_base64(*m*) Uses Base64 encoding, usually optimal
    for arbitrary binary data (see [“The base64 Module”](#the_basesixfour_module)).
    |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| encode_base64 | encode_base64(*m*) 使用 Base64 编码，通常对任意二进制数据最优（参见[“The base64
    Module”](#the_basesixfour_module)）。 |'
- en: '| encode_noop | encode_noop(*m*) Does nothing to *m*’s payload and headers.
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| encode_noop | encode_noop(*m*) 不对 *m* 的有效载荷和标题进行任何操作。 |'
- en: '| encode_quopri | encode_quopri(*m*) Uses Quoted Printable encoding, usually
    optimal for text that is almost but not fully ASCII (see [“The quopri Module”](#the_quopri_module)).
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| encode_quopri | encode_quopri(*m*) 使用 Quoted Printable 编码，通常对几乎但不完全是 ASCII
    的文本最优（参见[“The quopri Module”](#the_quopri_module)）。 |'
- en: '| encode_7or8bit | encode_7or8bit(*m*) Does nothing to *m*’s payload, but sets
    the header Content-Transfer-Encoding to ''8bit'' when any byte of *m*’s payload
    has the high bit set; otherwise, sets it to ''7bit''. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| encode_7or8bit | encode_7or8bit(*m*) 不对 *m* 的有效载荷进行任何操作，但在 *m* 的有效载荷的任何字节具有高位设置时，将标题
    Content-Transfer-Encoding 设置为 ''8bit''；否则，将其设置为 ''7bit''。 |'
- en: The email.utils Module
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: email.utils 模块
- en: The email.utils module supplies several functions for email processing, listed
    in [Table 21-5](#functions_of_the_emaildotutils_module).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: email.utils 模块提供了几个用于电子邮件处理的函数，这些函数在[表 21-5](#functions_of_the_emaildotutils_module)中列出。
- en: Table 21-5\. Functions of the email.utils module
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 表 21-5\. email.utils 模块的函数
- en: '| formataddr | formataddr(*pair*) Takes a pair of strings (*realname*, *email_address*)
    and returns a string *s* with the address to insert in header fields such as To
    and Cc. When *realname* is false (e.g., the empty string, ''''), formataddr returns
    *email_address*. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| formataddr | formataddr(*pair*) 接受一对字符串（*realname*, *email_address*），并返回一个字符串
    *s*，该字符串可插入到标题字段（如 To 和 Cc）中。当 *realname* 为假（例如空字符串 ''''）时，formataddr 返回 *email_address*。
    |'
- en: '| formatdate | formatdate(timeval=**None**, localtime=**False**) Returns a
    string with the time instant formatted as specified by RFC 2822\. timeval is a
    number of seconds since the epoch. When timeval is **None**, formatdate uses the
    current time. When localtime is **True**, formatdate uses the local time zone;
    otherwise, it uses UTC. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| formatdate | formatdate(timeval=**None**, localtime=**False**) 返回一个按照 RFC
    2822 指定格式的时间瞬间的字符串。timeval 是自纪元以来的秒数。当 timeval 为 **None** 时，formatdate 使用当前时间。当
    localtime 为 **True** 时，formatdate 使用本地时区；否则，它使用 UTC。 |'
- en: '| getaddresses | getaddresses(*L*) Parses each item of *L*, a list of address
    strings as used in header fields such as To and Cc, and returns a list of pairs
    of strings (*name*, *address*). When getaddresses cannot parse an item of *L*
    as an email address, it sets ('''', '''') as the corresponding item in the list.
    |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| getaddresses | getaddresses(*L*) 解析 *L* 的每个项目，*L* 是地址字符串的列表，如标题字段 To 和 Cc
    中使用的，返回字符串对的列表 (*name*, *address*)。当 getaddresses 无法将 *L* 的项目解析为电子邮件地址时，它将 ('''',
    '''') 设置为列表中相应的项目。'
- en: '| mktime_tz | mktime_tz(*t*) Returns a float representing the number of seconds
    since the epoch, in UTC, corresponding to the instant that *t* denotes. *t* is
    a tuple with 10 items. The first nine items of *t* are in the same format used
    in the module time, covered in [“The time Module”](ch13.xhtml#the_time_module).
    *t*[-1] is a time zone as an offset in seconds from UTC (with the opposite sign
    from time.timezone, as specified by RFC 2822). When *t*[-1] is **None**, mktime_tz
    uses the local time zone. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| mktime_tz | mktime_tz(*t*) 返回一个浮点数，表示自纪元以来的秒数（UTC 时间），对应于 *t* 所指示的时刻。*t*
    是一个包含 10 项的元组。*t* 的前九项与模块 time 中使用的格式相同，详见[“时间模块”](ch13.xhtml#the_time_module)。*t*[-1]
    是一个时间偏移量，单位为秒，相对于 UTC（与 time.timezone 的相反符号，由 RFC 2822 指定）。当 *t*[-1] 为 **None**
    时，mktime_tz 使用本地时区。'
- en: '| parseaddr | parseaddr(*s*) Parses string *s*, which contains an address as
    typically specified in header fields such as To and Cc, and returns a pair of
    strings (*realname*, *address*). When parseaddr cannot parse *s* as an address,
    it returns ('''', ''''). |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| parseaddr | parseaddr(*s*) 解析字符串 *s*，其中包含像 To 和 Cc 这样的标题字段中通常指定的地址，并返回一个字符串对
    (*realname*, *address*)。当 parseaddr 无法将 *s* 解析为地址时，它返回 ('''', '''')。'
- en: '| parsedate | parsedate(*s*) Parses string *s* as per the rules in RFC 2822
    and returns a tuple *t* with nine items, as used in the module time, covered in
    [“The time Module”](ch13.xhtml#the_time_module) (the items *t*[-3:] are not meaningful).
    parsedate also attempts to parse some erroneous variations on RFC 2822 that commonly
    encountered mailers use. When parsedate cannot parse *s*, it returns None. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| parsedate | parsedate(*s*) 根据 RFC 2822 中的规则解析字符串 *s*，并返回一个包含九项的元组 *t*，如模块
    time 中使用的（项 *t*[-3:] 无意义）。parsedate 还尝试解析一些通常遇到的邮件客户端使用的 RFC 2822 的错误变体。当 parsedate
    无法解析 *s* 时，它返回 None。'
- en: '| parsed⁠a⁠t⁠e⁠_​t⁠z | parsedate_tz(*s*) Like parsedate, but returns a tuple
    *t* with 10 items, where *t*[-1] is *s*’s time zone as an offset in seconds from
    UTC (with the opposite sign from time.timezone, as specified by RFC 2822), like
    in the argument that mktime_tz accepts. Items *t*[-4:-1] are not meaningful. When
    *s* has no time zone, *t*[-1] is **None**. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| parsedate_tz | parsedate_tz(*s*) 类似于 parsedate，但返回一个包含 10 项的元组 *t*，其中 *t*[-1]
    是 *s* 的时区，单位为秒，与 mktime_tz 接受的参数一样，但符号与 time.timezone 相反，如 RFC 2822 所指定。*t*[-4:-1]
    项无意义。当 *s* 没有时区时，*t*[-1] 为 **None**。'
- en: '| quote | quote(*s*) Returns a copy of string *s*, where each double quote
    (") becomes ''\"'', and each existing backslash is repeated. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| quote | quote(*s*) 返回字符串 *s* 的副本，其中每个双引号 (") 都变为 ''\"''，每个现有的反斜杠都重复。'
- en: '| unquote | unquote(*s*) Returns a copy of string *s* where leading and trailing
    double-quote characters (") and angle brackets (<>) are removed if they surround
    the rest of *s*. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| unquote | unquote(*s*) 返回字符串 *s* 的副本，其中移除了前导和尾随的双引号 (") 和尖括号 (<>)，如果它们包围着
    *s* 的其余部分。'
- en: Example Uses of the email Package
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 邮件包的示例用法
- en: 'The email package helps you both in reading and composing email and email-like
    messages (but it’s not involved in receiving and transmitting such messages: those
    tasks belong to separate modules covered in [Chapter 19](ch19.xhtml#client_side_network_protocol_modules)).
    Here is an example of how to use email to read a possibly multipart message and
    unpack each part into a file in a given directory:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 邮件包不仅帮助您阅读和撰写邮件和类似邮件的消息（但不涉及接收和传输此类消息：这些任务属于单独的模块，在[第 19 章](ch19.xhtml#client_side_network_protocol_modules)中涵盖）。以下是如何使用邮件来读取可能是多部分消息并将每个部分解包到给定目录中的文件的示例：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And here is an example that performs roughly the reverse task, packaging all
    files that are directly under a given source directory into a single file suitable
    for mailing:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个执行大致相反任务的示例，将直接位于给定源目录下的所有文件打包成一个适合邮件发送的单个文件：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Encoding Binary Data as ASCII Text
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将二进制数据编码为 ASCII 文本
- en: Several kinds of media (e.g., email messages) can contain only ASCII text. When
    you want to transmit arbitrary binary data via such media, you need to encode
    the data as ASCII text strings. The Python standard library supplies modules that
    support the standard encodings known as Base64, Quoted Printable, and Unix-to-Unix,
    described in the following sections.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 几种媒体（例如电子邮件消息）只能包含 ASCII 文本。当您想通过这些媒体传输任意二进制数据时，需要将数据编码为 ASCII 文本字符串。Python
    标准库提供支持名为 Base64、Quoted Printable 和 Unix-to-Unix 的标准编码的模块，下面将对这些进行描述。
- en: The base64 Module
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块 base64
- en: 'The base64 module supports the encodings specified in [RFC 3548](https://oreil.ly/Cbhkl)
    as Base16, Base32, and Base64\. Each of these encodings is a compact way to represent
    arbitrary binary data as ASCII text, without any attempt to produce human-readable
    results. base64 supplies 10 functions: 6 for Base64, plus 2 each for Base32 and
    Base16\. The six Base64 functions are listed in [Table 21-6](#basesixfour_functions_of_the_basesixfou).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: base64 模块支持 [RFC 3548](https://oreil.ly/Cbhkl) 中指定的编码，包括 Base16、Base32 和 Base64。这些编码是一种将任意二进制数据表示为
    ASCII 文本的紧凑方式，没有尝试生成可读的结果。base64 提供 10 个函数：6 个用于 Base64，以及 2 个用于 Base32 和 Base16。六个
    Base64 函数列在 [表 21-6](#basesixfour_functions_of_the_basesixfou) 中。
- en: Table 21-6\. Base64 functions of the base64 module
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 表 21-6\. base64 模块的 Base64 函数
- en: '| b64decode | b64decode(*s*, altchars=**None**, validate=**False**) Decodes
    B64-encoded bytestring *s*, and returns the decoded bytestring. altchars, if not
    **None**, must be a bytestring of at least two characters (extra characters are
    ignored) specifying the two nonstandard characters to use instead of + and / (potentially
    useful to decode URL-safe or filesystem-safe B64-encoded strings). When validate
    is **True**, the call raises an exception if *s* contains any bytes that are not
    valid in B64-encoded strings (by default, such bytes are just ignored and skipped).
    Also raises an exception when *s* is improperly padded according to the Base64
    standard. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| b64decode | b64decode(*s*, altchars=**None**, validate=**False**) 解码 B64
    编码的字节串 *s*，并返回解码后的字节串。altchars，如果不为 **None**，必须是至少两个字符的字节串（多余字符将被忽略），指定要使用的两个非标准字符，而不是
    + 和 /（可能对解码 URL 安全或文件系统安全的 B64 编码字符串有用）。当 validate 为 **True** 时，如果 *s* 包含任何无效的
    B64 编码字符串（默认情况下，这些字节只是被忽略和跳过），则调用会引发异常。如果 *s* 没有按照 Base64 标准正确填充，则调用会引发异常。 |'
- en: '| b64encode | b64encode(*s*, altchars=**None**) Encodes bytestring *s* and
    returns the bytestring with the corresponding B64-encoded data. altchars, if not
    **None**, must be a bytestring of at least two characters (extra characters are
    ignored) specifying the two nonstandard characters to use instead of + and / (potentially
    useful to make URL-safe or filesystem-safe B64-encoded strings). |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| b64encode | b64encode(*s*, altchars=**None**) 编码字节串 *s*，并返回具有相应 B64 编码数据的字节串。altchars，如果不为
    **None**，必须是至少两个字符的字节串（多余字符将被忽略），指定要使用的两个非标准字符，而不是 + 和 /（可能对制作 URL 安全或文件系统安全的
    B64 编码字符串有用）。 |'
- en: '| standa⁠r⁠d⁠_​b⁠6⁠4⁠decode | standard_b64decode(*s*) Like b64decode(*s*).
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| standa⁠r⁠d⁠_​b⁠6⁠4⁠decode | standard_b64decode(*s*) 类似于 b64decode(*s*)。 |'
- en: '| standa⁠r⁠d⁠_​b⁠6⁠4⁠encode | standard_b64encode(*s*) Like b64encode(*s*).
    |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| standa⁠r⁠d⁠_​b⁠6⁠4⁠encode | standard_b64encode(*s*) 类似于 b64encode(*s*)。 |'
- en: '| urlsa⁠f⁠e⁠_​b⁠6⁠4⁠decode | urlsafe_b64decode(*s*) Like b64decode(*s*, ''-_'').
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| urlsa⁠f⁠e⁠_​b⁠6⁠4⁠decode | urlsafe_b64decode(*s*) 类似于 b64decode(*s*, ''-_'')。
    |'
- en: '| urlsa⁠f⁠e⁠_​b⁠6⁠4⁠encode | urlsafe_b64encode(*s*) Like b64encode(*s*, ''-_'').
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| urlsa⁠f⁠e⁠_​b⁠6⁠4⁠encode | urlsafe_b64encode(*s*) 类似于 b64encode(*s*, ''-_'')。
    |'
- en: The four Base16 and Base32 functions are listed in [Table 21-7](#baseonesix_and_basethreetwo_functions_o).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 四个 Base16 和 Base32 函数列在 [表 21-7](#baseonesix_and_basethreetwo_functions_o) 中。
- en: Table 21-7\. Base16 and Base32 functions of the base64 module
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 表 21-7\. base64 模块的 Base16 和 Base32 函数
- en: '| b16decode | b16decode(*s*, casefold=**False**) Decodes B16-encoded bytestring
    *s*, and returns the decoded bytestring. When casefold is **True**, lowercase
    characters in *s* are treated like their uppercase equivalents; by default, when
    lowercase characters are present, the call raises an exception. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| b16decode | b16decode(*s*, casefold=**False**) 解码 B16 编码的字节串 *s*，并返回解码后的字节串。当
    casefold 为 **True** 时，*s* 中的小写字符将被视为其大写等价字符；默认情况下，如果存在小写字符，调用会引发异常。 |'
- en: '| b16encode | b16encode(*s*) Encodes bytestring *s*, and returns the bytestring
    with the corresponding B16-encoded data. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| b16encode | b16encode(*s*) 编码字节串 *s*，并返回具有相应 B16 编码数据的字节串。 |'
- en: '| b32decode | b32decode(*s*, casefold=**False**, map01=**None**) Decodes B32-encoded
    bytestring *s*, and returns the decoded bytestring. When casefold is **True**,
    lowercase characters in *s* are treated like their uppercase equivalents; by default,
    when lowercase characters are present, the call raises an exception. When map01
    is **None**, characters 0 and 1 are not allowed in the input; when not **None**,
    it must be a single-character bytestring specifying what 1 is mapped to (lowercase
    ''l'' or uppercase ''L''); 0 is then always mapped to uppercase ''O''. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| b32decode | b32decode(*s*, casefold=**False**, map01=**None**) 解码 B32 编码的字节串
    *s*，返回解码后的字节串。当 casefold 为 **True** 时，将 *s* 中的小写字符视为它们的大写形式；默认情况下，如果 *s* 中存在小写字符，调用将引发异常。当
    map01 为 **None** 时，输入中不允许字符 0 和 1；当 map01 不为 **None** 时，必须是一个指定 1 映射到的单字符字节串，即小写
    ''l'' 或大写 ''L''；0 总是映射到大写 ''O''。|'
- en: '| b32encode | b32encode(*s*) Encodes bytestring *s* and returns the bytestring
    with the corresponding B32-encoded data. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| b32encode | b32encode(*s*) 编码字节串 *s*，返回相应的 B32 编码数据的字节串。|'
- en: The module also supplies functions to encode and decode the nonstandard but
    popular encodings Base85 and Ascii85, which, while not codified in RFCs or compatible
    with each other, can offer space savings of 15% by using larger alphabets for
    encoded bytestrings. See the [online docs](https://oreil.ly/rndpn) for details
    on those functions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块还提供了用于编码和解码非标准但流行的编码 Base85 和 Ascii85 的函数，这些编码虽然未在 RFC 中规范，也不互通，但使用更大的字母表对编码的字节串进行了空间节省，节省率达
    15%。详细信息请参阅[在线文档](https://oreil.ly/rndpn)中的相关函数。
- en: The quopri Module
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: quopri 模块
- en: The quopri module supports the encoding specified in RFC 1521 as *Quoted Printable*
    (QP). QP can represent any binary data as ASCII text, but it’s mainly intended
    for data that is mostly text, with a small amount of characters with the high
    bit set (i.e., characters outside the ASCII range). For such data, QP produces
    results that are both compact and human-readable. The quopri module supplies four
    functions, listed in [Table 21-8](#functions_of_the_quopri_module).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: quopri 模块支持 RFC 1521 指定的 *Quoted Printable*（QP）编码。QP 可将任何二进制数据表示为 ASCII 文本，但主要用于大部分为文本且带有高位设置（即
    ASCII 范围之外的字符）的数据。对于这样的数据，QP 生成的结果既紧凑又易读。quopri 模块提供了四个函数，列在[表 21-8](#functions_of_the_quopri_module)中。
- en: Table 21-8\. Functions of the quopri module
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 表 21-8\. quopri 模块的功能
- en: '| decode | decode(*infile*, *outfile*, header=**False**) Reads the binary file-like
    object *infile* by calling *infile*.readline until end-of-file (i.e., until a
    call to *infile*.readline returns an empty string), decodes the QP-encoded ASCII
    text thus read, and writes the results to binary file-like object *outfile**.*
    When header is true, decode also turns _ (underscores) into spaces (per RFC 1522).
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| decode | decode(*infile*, *outfile*, header=**False**) 通过调用 *infile*.readline
    读取类似文件的二进制对象 *infile*，直到文件末尾（即直到 *infile*.readline 返回空字符串），解码读取的 QP 编码的 ASCII
    文本，并将结果写入类似文件的二进制对象 *outfile**.* 当 header 为 true 时，decode 也会将 _（下划线）转换为空格（根据 RFC
    1522）。|'
- en: '| decodestring | decodestring(*s*, header=**False**) Decodes bytestring *s*,
    QP-encoded ASCII text, and returns the bytestring with the decoded data. When
    header is true, decodestring also turns _ (underscores) into spaces. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| decodestring | decodestring(*s*, header=**False**) 解码 QP 编码的 ASCII 文本字节串
    *s*，返回解码后的字节串。当 header 为 true 时，decodestring 也会将 _（下划线）转换为空格。|'
- en: '| encode | encode(*infile*, *outfile*, *quotetabs*, header=**False**) Reads
    binary file-like object *infile* by calling *infile*.readline until end-of-file
    (i.e., until a call to *infile*.readline returns an empty string), encodes the
    data thus read in QP, and writes the encoded ASCII text to binary file-like object
    *outfile**.* When *quotetabs* is true, encode also encodes spaces and tabs. When
    header is true, encode encodes spaces as _ (underscores). |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| encode | encode(*infile*, *outfile*, *quotetabs*, header=**False**) 通过调用
    *infile*.readline 读取类似文件的二进制对象 *infile*，直到文件末尾（即直到 *infile*.readline 返回空字符串），使用
    QP 编码读取的数据，并将编码的 ASCII 文本写入类似文件的二进制对象 *outfile**.* 当 *quotetabs* 为 true 时，encode
    也会编码空格和制表符。当 header 为 true 时，encode 将空格编码为 _（下划线）。|'
- en: '| encodestring | encodestring(*s*, quotetabs=**False**, header=**False**) Encodes
    bytestring *s*, which contains arbitrary bytes, and returns a bytestring with
    QP-encoded ASCII text. When quotetabs is true, encodestring also encodes spaces
    and tabs. When header is true, encodestring encodes spaces as _ (underscores).
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| encodestring | encodestring(*s*, quotetabs=**False**, header=**False**) 编码包含任意字节的字节串
    *s*，返回包含 QP 编码的 ASCII 文本的字节串。当 quotetabs 为 true 时，encodestring 也会编码空格和制表符。当 header
    为 true 时，encodestring 将空格编码为 _（下划线）。|'
- en: The uu Module
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: uu 模块
- en: The uu module^([1](ch21.xhtml#ch01fn157)) supports the classic *Unix-to-Unix*
    (UU) encoding, as implemented by the Unix programs *uuencode* and *uudecode*.
    UU starts encoded data with a begin line, which includes the filename and permissions
    of the file being encoded, and ends it with an end line. Therefore, UU encoding
    lets you embed encoded data in otherwise unstructured text, while Base64 encoding
    (discussed in [“The base64 Module”](#the_basesixfour_module)) relies on the existence
    of other indications of where the encoded data starts and finishes. The uu module
    supplies two functions, listed in [Table 21-9](#functions_of_the_uu_module).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 支持经典*Unix-to-Unix*（UU）编码的**uu**模块^([1](ch21.xhtml#ch01fn157))受到Unix程序*uuencode*和*uudecode*的启发。
    UU将编码数据以开始行开头，包括正在编码的文件的文件名和权限，并以结束行结尾。 因此，UU编码允许您将编码数据嵌入其他非结构化文本中，而Base64编码（在[“base64模块”](#the_basesixfour_module)中讨论）依赖于其他指示编码数据开始和结束的存在。
    uu模块提供了两个函数，列在[表21-9](#functions_of_the_uu_module)中。
- en: Table 21-9\. Functions of the uu module
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 表 21-9\. uu模块的函数
- en: '| decode | decode(*infile*, outfile=**None**, mode=**None**) Reads the file-like
    object *infile* by calling *infile*.readline until end-of-file (i.e., until a
    call to *infile*.readline returns an empty string) or until a terminator line
    (the string ''end'' surrounded by any amount of whitespace). decode decodes the
    UU-encoded text thus read and writes the decoded data to the file-like object
    outfile. When outfile is **None**, decode creates the file specified in the UU-format
    begin line, with the permission bits given by mode (the permission bits specified
    in the begin line, when mode is **None**). In this case, decode raises an exception
    if the file already exists. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| decode | decode(*infile*, outfile=**None**, mode=**None**) 通过调用*infile*.readline读取类文件对象*infile*，直到文件末尾（即，直到调用*infile*.readline返回空字符串）或终止行（由任意数量的空白包围的字符串''end''）。
    decode解码读取的UU编码文本，并将解码后的数据写入类文件对象outfile。 当outfile为**None**时，decode会根据UU格式的开始行创建文件，并使用mode指定的权限位（当mode为**None**时，在开始行中指定的权限位）。
    在这种情况下，如果文件已经存在，decode会引发异常。 |'
- en: '| encode | encode(*infile*, *outfile*, name=''-'', mode=0o666) Reads the file-like
    object *infile* by calling *infile*.read (45 bytes at a time, which is the amount
    of data that UU encodes into 60 characters in each output line) until end-of-file
    (i.e., until a call to *infile*.read returns an empty string). It encodes the
    data thus read in UU and writes the encoded text to file-like object *outfile*.
    encode also writes a UU-format begin line before the text and a UU-format end
    line after the text. In the begin line, encode specifies the filename as name
    and the mode as mode. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| encode | encode(*infile*, *outfile*, name=''-'', mode=0o666) 通过调用*infile*.read（每次读取45字节数据，这是UU编码后每行60个字符数据的量）读取类文件对象*infile*，直到文件末尾（即，直到调用*infile*.read返回空字符串）。
    它将读取的数据以UU编码方式编码，并将编码文本写入类文件对象*outfile*。 encode还在文本之前写入一个UU格式的开始行，并在文本之后写入UU格式的结束行。
    在开始行中，encode指定文件名为name，并指定mode为mode。 |'
- en: ^([1](ch21.xhtml#ch01fn157-marker)) Deprecated in Python 3.11, to be removed
    in Python 3.13; the online docs direct users to update existing code to use the
    base64 module for data content and MIME headers for metadata.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch21.xhtml#ch01fn157-marker)) 在Python 3.11中已弃用，将在Python 3.13中删除；在线文档建议用户更新现有代码，使用base64模块处理数据内容，并使用MIME头处理元数据。
