- en: Chapter 9\. Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章. 函数
- en: The smaller the function, the greater the management.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 函数越小，管理越大。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: C. Northcote Parkinson
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: C. 北科特·帕金森
- en: So far, all of our Python code examples have been little fragments. These are
    good for small tasks, but no one wants to retype fragments all the time. We need
    some way of organizing larger code into manageable pieces.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的Python代码示例都是小片段。这些对于小任务很好，但没人想一直重复输入片段。我们需要一种方法将更大的代码组织成可管理的片段。
- en: 'The first step to code reuse is the *function*: a named piece of code, separate
    from all others. A function can take any number and type of input *parameters*
    and return any number and type of output *results*.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重用的第一步是*函数*：一个命名的代码片段，独立于所有其他代码。函数可以接受任意数量和类型的输入*参数*，并返回任意数量和类型的输出*结果*。
- en: 'You can do two things with a function:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用一个函数做两件事情：
- en: '*Define* it, with zero or more parameters'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*定义*它，带有零个或多个参数'
- en: '*Call* it, and get zero or more results'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调用*它，然后得到零个或多个结果'
- en: Define a Function with def
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用def定义一个函数
- en: To define a Python function, you type `def`, the function name, parentheses
    enclosing any input *parameters* to the function, and then finally, a colon (`:`).
    Function names have the same rules as variable names (they must start with a letter
    or `_` and contain only letters, numbers, or `_`).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个Python函数，你需要输入`def`，函数名，括号包围任何输入*参数*到函数中，然后最后是一个冒号(`:`)。函数名的规则与变量名相同（必须以字母或`_`开头，只能包含字母、数字或`_`）。
- en: 'Let’s take things one step at a time, and first define and call a function
    that has no parameters. Here’s the simplest Python function:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步来，首先定义并调用一个没有参数的函数。这是最简单的Python函数：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Even for a function with no parameters like this one, you still need the parentheses
    and the colon in its definition. The next line needs to be indented, just as you
    would indent code under an `if` statement. Python requires the `pass` statement
    to show that this function does nothing. It’s the equivalent of *This page intentionally
    left blank* (even though it isn’t anymore).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 即使对于像这样没有参数的函数，你仍然需要在其定义中使用括号和冒号。下一行需要缩进，就像你在`if`语句下缩进代码一样。Python需要`pass`语句来表明这个函数什么也不做。这相当于*本页有意留白*（尽管它不再是空白的）。
- en: Call a Function with Parentheses
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用括号调用一个函数
- en: 'You call this function just by typing its name and parentheses. It works as
    advertised, doing nothing, but doing it very well:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需输入函数名和括号就可以调用这个函数。它像广告一样运行，什么也不做，但做得非常好：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now let’s define and call another function that has no parameters but prints
    a single word:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义并调用另一个没有参数但打印单词的函数：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you called the `make_a_sound()` function, Python ran the code inside its
    definition. In this case, it printed a single word and returned to the main program.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`make_a_sound()`函数时，Python会执行其定义内的代码。在这种情况下，它打印了一个单词并返回到主程序。
- en: 'Let’s try a function that has no parameters but *returns* a value:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试一个没有参数但*返回*值的函数：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can call this function and test its returned value by using `if`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以调用这个函数并使用`if`测试其返回值：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You’ve just made a big step. The combination of functions with tests such as
    `if` and loops such as `while` make it possible for you to do things that you
    could not do before.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚迈出了一个大步。函数与诸如`if`这样的测试以及诸如`while`这样的循环的结合，使你能够做一些以前无法做到的事情。
- en: Arguments and Parameters
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数和参数
- en: 'At this point, it’s time to put something between those parentheses. Let’s
    define the function `echo()` with one parameter called `anything`. It uses the
    `return` statement to send the value of `anything` back to its caller twice, with
    a space between:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，是时候在括号里放些东西了。让我们定义一个名为`echo()`的函数，其中有一个名为`anything`的参数。它使用`return`语句两次将`anything`的值发送回调用者，之间用空格隔开：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now let’s call `echo()` with the string `''Rumplestiltskin''`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用字符串`'Rumplestiltskin'`调用`echo()`：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The values you pass into the function when you call it are known as *arguments*.
    When you call a function with arguments, the values of those arguments are copied
    to their corresponding *parameters* inside the function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用带有参数的函数时，你传递的这些值称为*参数*。当你带有参数调用函数时，这些参数的值被复制到函数内部的对应*参数*中。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Saying it another way: they’re called *arguments* outside of the function,
    but *parameters* inside.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说：它们在函数外被称为*参数*，但在函数内部称为*参数*。
- en: In the previous example, the function `echo()` was called with the argument
    string `'Rumplestiltskin'`. This value was copied within `echo()` to the parameter
    `anything`, and then returned (in this case doubled, with a space) to the caller.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，函数`echo()`被调用时带有参数字符串`'Rumplestiltskin'`。此值在`echo()`内部复制到参数`anything`中，然后（在本例中加倍，并带有一个空格）返回给调用者。
- en: 'These function examples were pretty basic. Let’s write a function that takes
    an input argument and actually does something with it. We’ll adapt the earlier
    code fragment that comments on a color. Call it `commentary` and have it take
    an input string parameter called `color`. Make it return the string description
    to its caller, which can decide what to do with it:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数示例非常基本。让我们编写一个函数，它接受一个输入参数并实际处理它。我们将调整早期评论颜色的代码片段。称之为`commentary`，并使其接受名为`color`的输入字符串参数。使其返回字符串描述给它的调用者，调用者可以决定如何处理它：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Call the function `commentary()` with the string argument `'blue'`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串参数`'blue'`调用函数`commentary()`。
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The function does the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 函数执行以下操作：
- en: Assigns the value `'blue'` to the function’s internal `color` parameter
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将值`'blue'`分配给函数内部的`color`参数
- en: Runs through the `if`-`elif`-`else` logic chain
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`if`-`elif`-`else`逻辑链运行
- en: Returns a string
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个字符串
- en: The caller then assigns the string to the variable `comment`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用者将字符串赋给变量`comment`。
- en: What did we get back?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了什么？
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A function can take any number of input arguments (including zero) of any type.
    It can return any number of output results (also including zero) of any type.
    If a function doesn’t call `return` explicitly, the caller gets the result `None`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以接受任意数量（包括零个）任意类型的输入参数。它可以返回任意数量（包括零个）任意类型的输出结果。如果函数没有显式调用`return`，调用者将得到`None`的结果。
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: None Is Useful
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: None很有用
- en: '`None` is a special Python value that holds a place when there is nothing to
    say. It is not the same as the boolean value `False`, although it looks false
    when evaluated as a boolean. Here’s an example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`None`是Python中的特殊值，表示当没有内容时占据的位置。它与布尔值`False`不同，尽管在布尔值评估时看起来是假的。以下是一个例子：'
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To distinguish `None` from a boolean `False` value, use Python’s `is` operator:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要区分`None`和布尔值`False`，请使用Python的`is`运算符：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This seems like a subtle distinction, but it’s important in Python. You’ll need
    `None` to distinguish a missing value from an empty value. Remember that zero-valued
    integers or floats, empty strings (`''`), lists (`[]`), tuples (`(,)`), dictionaries
    (`{}`), and sets (`set()`) are all `False`, but are not the same as `None`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是一个微妙的区别，但在Python中很重要。您将需要`None`来区分缺失值和空值。请记住，零值整数或浮点数，空字符串（`''`），列表（`[]`），元组（`(,)`），字典（`{}`）和集合（`set()`）都为`False`，但与`None`不同。
- en: 'Let’s write a quick function that prints whether its argument is `None`, `True`,
    or `False`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个快速函数，打印其参数是`None`，`True`还是`False`：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s run some sanity tests:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行一些健全性测试：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How about some real values?
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一些真实的值如何？
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Positional Arguments
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位置参数
- en: Python handles function arguments in a manner that’s very flexible, when compared
    to many languages. The most familiar types of arguments are *positional arguments*,
    whose values are copied to their corresponding parameters in order.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多语言相比，Python处理函数参数的方式非常灵活。最熟悉的类型是*位置参数*，其值按顺序复制到相应的参数中。
- en: 'This function builds a dictionary from its positional input arguments and returns
    it:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数从其位置输入参数构建字典并返回它：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Although very common, a downside of positional arguments is that you need to
    remember the meaning of each position. If we forgot and called `menu()` with wine
    as the last argument instead of the first, the meal would be very different:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管非常普遍，位置参数的缺点是您需要记住每个位置的含义。如果我们忘记并将`menu()`以葡萄酒作为最后一个参数而不是第一个参数进行调用，那么餐点会非常不同：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Keyword Arguments
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键字参数
- en: 'To avoid positional argument confusion, you can specify arguments by the names
    of their corresponding parameters, even in a different order from their definition
    in the function:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免位置参数混淆，您可以按照与函数定义中不同顺序的参数名称指定参数：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can mix positional and keyword arguments. Let’s specify the wine first,
    but use keyword arguments for the entree and dessert:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以混合位置和关键字参数。让我们首先指定葡萄酒，但使用关键字参数为主菜和甜点：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you call a function with both positional and keyword arguments, the positional
    arguments need to come first.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您同时使用位置和关键字参数调用函数，则位置参数需要首先出现。
- en: Specify Default Parameter Values
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定默认参数值
- en: 'You can specify default values for parameters. The default is used if the caller
    does not provide a corresponding argument. This bland-sounding feature can actually
    be quite useful. Using the previous example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为参数指定默认值。如果调用者未提供相应的参数，则使用默认值。这个听起来平淡无奇的特性实际上非常有用。使用前面的例子：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This time, try calling `menu()` without the `dessert` argument:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，尝试调用`menu()`而不带`dessert`参数：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you do provide an argument, it’s used instead of the default:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了参数，则使用该参数而不是默认值：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-79
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Default parameter values are calculated when the function is *defined*, not
    when it is run. A common error with new (and sometimes not-so-new) Python programmers
    is to use a mutable data type such as a list or dictionary as a default parameter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 默认参数值在函数*定义*时计算，而不是在运行时。对于新手（有时甚至不太新的）Python程序员来说，常见的错误是使用可变数据类型（如列表或字典）作为默认参数。
- en: 'In the following test, the `buggy()` function is expected to run each time
    with a fresh empty `result` list, add the `arg` argument to it, and then print
    a single-item list. However, there’s a bug: it’s empty only the first time it’s
    called. The second time, `result` still has one item from the previous call:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下测试中，`buggy()`函数预计每次都将使用一个新的空`result`列表运行，并将`arg`参数添加到其中，然后打印一个单项列表。然而，这里有一个错误：它只有在第一次调用时为空。第二次调用时，`result`仍然保留了上一次调用的一个项目：
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It would have worked if it had been written like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果写成这样，它会起作用：
- en: '[PRE25]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The fix is to pass in something else to indicate the first call:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法是传递其他内容以指示第一次调用：
- en: '[PRE26]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is sometimes a Python job interview question. You’ve been warned.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这有时是Python工作面试的问题。你已经被警告了。
- en: Explode/Gather Positional Arguments with *
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用*爆炸/聚合位置参数
- en: If you’ve programmed in C or C++, you might assume that an asterisk (`*`) in
    a Python program has something to do with a *pointer*. Nope, Python doesn’t have
    pointers.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在C或C++中编程过，你可能会认为Python程序中的星号（`*`）与*指针*有关。不，Python没有指针。
- en: 'When used inside the function with a parameter, an asterisk groups a variable
    number of positional arguments into a single tuple of parameter values. In the
    following example, `args` is the parameter tuple that resulted from zero or more
    arguments that were passed to the function `print_args()`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当在函数中与参数一起使用时，星号将可变数量的位置参数组合成单个参数值元组。在下面的例子中，`args`是由传递给函数`print_args()`的零个或多个参数组成的参数元组：
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you call the function with no arguments, you get nothing in `*args`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有参数调用函数，则在`*args`中什么都得不到：
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Whatever you give it will be printed as the `args` tuple:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您给它什么，它都将被打印为`args`元组：
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is useful for writing functions such as `print()` that accept a variable
    number of arguments. If your function has *required* positional arguments, as
    well, put them first; `*args` goes at the end and grabs all the rest:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这对编写像`print()`这样接受可变数量参数的函数非常有用。如果您的函数还有*必需*的位置参数，将它们放在第一位；`*args`放在最后并获取其余所有参数：
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-98
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When using `*`, you don’t need to call the tuple argument `*args`, but it’s
    a common idiom in Python. It’s also common to use `*args` inside the function,
    as in the preceding example, although technically it’s called a parameter and
    could be referred to as `*params`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`*`时，您不需要将元组参数称为`*args`，但在Python中这是一种常见的习惯用法。在函数内部使用`*args`也很常见，就像前面的例子中描述的那样，尽管严格来说它被称为参数，可以称为`*params`。
- en: 'Summarizing:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 总结：
- en: You can pass positional argument to a function, which will match them inside
    to positional parameters. This is what you’ve seen so far in this book.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将位置参数传递给函数，它们将在内部与位置参数匹配。这是你在本书中到目前为止看到的内容。
- en: You can pass a tuple argument to a function, and inside it will be a tuple parameter.
    This is a simple case of the preceding one.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将元组参数传递给函数，其中它将成为元组参数的一部分。这是前面一个示例的简单情况。
- en: You can pass positional arguments to a function, and gather them inside as the
    parameter `*args`, which resolves to the tuple `args`. This was described in this
    section.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将位置参数传递给函数，并将它们聚合在参数`*args`中，该参数解析为元组`args`。这在本节中已经描述过。
- en: 'You can also “explode” a tuple argument called `args` to positional parameters
    `*args` inside the function, which will be regathered inside into the tuple parameter
    `args`:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以将名为`args`的元组参数“爆炸”为函数内部的位置参数`*args`，然后将其重新聚合到元组参数`args`中：
- en: '[PRE31]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can only use the `*` syntax in a function call or definition:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您只能在函数调用或定义中使用`*`语法：
- en: '[PRE32]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'So:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 所以：
- en: Outside the function, `*args` explodes the tuple `args` into comma-separated
    positional parameters.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数外部，`*args` 将元组 `args` 展开为逗号分隔的位置参数。
- en: Inside the function, `*args` gathers all of the positional arguments into a
    single `args` tuple. You could use the names `*params` and `params`, but it’s
    common practice to use `*args` for both the outside argument and inside parameter.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数内部，`*args` 将所有位置参数收集到一个名为 `args` 的元组中。你可以使用名称 `*params` 和 `params`，但通常在外部参数和内部参数中都使用
    `*args` 是常见的做法。
- en: Readers with synesthesia might also faintly hear `*args` as *puff-args* on the
    outside and *inhale-args* on the inside, as values are either exploded or gathered.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有音感共鸣的读者也可能会在外部听到 `*args` 声称为 *puff-args*，在内部听到 *inhale-args*，因为值要么被展开要么被汇集。
- en: Explode/Gather Keyword Arguments with **
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用 ** 扩展/汇集关键字参数
- en: 'You can use two asterisks (`**`) to group keyword arguments into a dictionary,
    where the argument names are the keys, and their values are the corresponding
    dictionary values. The following example defines the function `print_kwargs()`
    to print its keyword arguments:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用两个星号 (`**`) 将关键字参数组合成一个字典，其中参数名是键，它们的值是对应的字典值。下面的示例定义了函数 `print_kwargs()`
    来打印它的关键字参数：
- en: '[PRE33]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now try calling it with some keyword arguments:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试着使用一些关键字参数调用它：
- en: '[PRE34]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Inside the function, `kwargs` is a dictionary parameter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，`kwargs` 是一个字典参数。
- en: 'Argument order is:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 参数顺序是：
- en: Required positional arguments
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必需的位置参数
- en: Optional positional arguments (`*args`)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的位置参数 (`*args`)
- en: Optional keyword arguments (`**kwargs`)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的关键字参数 (`**kwargs`)
- en: As with `args`, you don’t need to call this keyword argument `kwargs`, but it’s
    common usage.^([1](ch09.html#idm45795002646440))
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `args` 一样，你不需要将这个关键字参数称为 `kwargs`，但这是常见用法：^([1](ch09.html#idm45795002646440))
- en: The `**` syntax is valid only in a function call or definition:^([2](ch09.html#idm45795002644024))
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`**` 语法仅在函数调用或定义中有效：^([2](ch09.html#idm45795002644024))'
- en: '[PRE35]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Summarizing:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 总结：
- en: You can pass keyword arguments to a function, which will match them inside to
    keyword parameters. This is what you’ve seen so far.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以向函数传递关键字参数，函数内部将它们与关键字参数匹配。这就是你迄今为止看到的内容。
- en: You can pass a dictionary argument to a function, and inside it will be dictionary
    parameters. This is a simple case of the preceding one.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将字典参数传递给一个函数，函数内部会解析这些字典参数。这是前面讨论的一个简单情况。
- en: You can pass one or more keyword arguments (*name=value*) to a function, and
    gather them inside as `**kwargs`, which resolves to the dictionary parameter called
    `kwargs`. This was described in this section.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以向函数传递一个或多个关键字参数 (*name=value*)，并在函数内部作为 `**kwargs` 收集它们，这已经在本节中讨论过了。
- en: Outside a function, `**kwargs` *explodes* a dictionary `kwargs` into *name=value*
    arguments.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数外部，`**kwargs` *展开* 字典 `kwargs` 为 *name=value* 参数。
- en: Inside a function, `**kwargs` *gathers* `name=value` arguments into the single
    dictionary parameter `kwargs`.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数内部，`**kwargs` *收集* `name=value` 参数到单个字典参数 `kwargs` 中。
- en: If auditory hallucinations help, imagine a puff for each asterisk exploding
    outside the function, and a little inhaling sound for each one gathering inside.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果听觉幻觉有所帮助，想象每个星号都在函数外面爆炸一下，而每个星号聚集在里面时会有一点吸气的声音。
- en: Keyword-Only Arguments
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅关键字参数
- en: 'It’s possible to pass in a keyword argument that has the same name as a positional
    parameter, probably not resulting in what you want. Python 3 lets you specify
    *keyword-only arguments*. As the name says, they must be provided as *name=value*,
    not positionally as *value*. The single `*` in the function definition means that
    the following parameters `start` and `end` must be provided as named arguments
    if we don’t want their default values:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 可以传入一个与位置参数同名的关键字参数，这可能不会得到你想要的结果。Python 3 允许你指定 *仅关键字参数*。顾名思义，它们必须作为 *name=value*
    而不是作为位置参数 *value* 提供。函数定义中的单个 `*` 意味着接下来的参数 `start` 和 `end` 如果我们不想使用它们的默认值，必须作为命名参数提供：
- en: '[PRE36]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Mutable and Immutable Arguments
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变与不可变参数
- en: Remember that if you assigned the same list to two variables, you could change
    it by using either one? And that you could not if the variables both referred
    to something like an integer or a string? That was because the list was mutable
    and the integer and string were immutable.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果你将同一个列表分配给两个变量，你可以通过任何一个变量来修改它？而如果这两个变量都引用像整数或字符串之类的不可变对象时就不行了？那是因为列表是可变的，而整数和字符串是不可变的。
- en: You need to watch for the same behavior when passing arguments to functions.
    If an argument is mutable, its value can be changed *from inside the function*
    via its corresponding parameter:^([3](ch09.html#idm45795002479608))
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在将参数传递给函数时，需要注意相同的行为。如果一个参数是可变的，它的值可以通过相应的参数*在函数内部*被改变：^([3](ch09.html#idm45795002479608))
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It’s good practice to, uh, not do this.^([4](ch09.html#idm45795002478344)) Either
    document that an argument may be changed, or `return` the new value.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的做法是，呃，不要这样做。^([4](ch09.html#idm45795002478344)) 要么记录参数可能被更改，要么通过`return`返回新值。
- en: Docstrings
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档字符串
- en: '*Readability counts*, the Zen of Python verily saith. You can attach documentation
    to a function definition by including a string at the beginning of the function
    body. This is the function’s *docstring*:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*可读性很重要*，Python禅宗确实如此。你可以通过在函数体的开头包含一个字符串来附加文档到函数定义中。这就是函数的*文档字符串*：'
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can make a docstring quite long, and even add rich formatting if you want:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使文档字符串相当长，并且如果你愿意，甚至可以添加丰富的格式：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To print a function’s docstring, call the Python `help()` function. Pass the
    function’s name to get a listing of arguments along with the nicely formatted
    docstring:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印函数的文档字符串，请调用Python的`help()`函数。传递函数的名称以获取带有精美格式的参数列表和文档字符串：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If you want to see just the raw docstring, without the formatting:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想看到原始的文档字符串，而没有格式：
- en: '[PRE41]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: That odd-looking `__doc__` is the internal name of the docstring as a variable
    within the function. Double underscores (aka *dunder* in Python-speak) are used
    in many places to name Python internal variables, because programmers are unlikely
    to use them in their own variable names.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 那个看起来奇怪的`__doc__`是函数内部文档字符串作为变量的内部名称。双下划线（Python术语中称为*dunder*）在许多地方用于命名Python内部变量，因为程序员不太可能在自己的变量名中使用它们。
- en: Functions Are First-Class Citizens
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数是一等公民
- en: I’ve mentioned the Python mantra, *everything is an object*. This includes numbers,
    strings, tuples, lists, dictionaries—and functions, as well. Functions are first-class
    citizens in Python. You can assign them to variables, use them as arguments to
    other functions, and return them from functions. This gives you the capability
    to do some things in Python that are difficult-to-impossible to carry out in many
    other languages.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到了Python的口头禅，*一切皆为对象*。这包括数字、字符串、元组、列表、字典——还有函数。在Python中，函数是一等公民。你可以将它们赋值给变量，将它们用作其他函数的参数，并从函数中返回它们。这使得你能够在Python中做一些在许多其他语言中难以或不可能实现的事情。
- en: 'To test this, let’s define a simple function called `answer()` that doesn’t
    have any arguments; it just prints the number `42`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个，让我们定义一个简单的函数叫做`answer()`，它没有任何参数；它只是打印数字`42`：
- en: '[PRE42]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If you run this function, you know what you’ll get:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个函数，你知道会得到什么：
- en: '[PRE43]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now let’s define another function named `run_something`. It has one argument
    called `func`, a function to run. Once inside, it just calls the function:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义另一个名为`run_something`的函数。它有一个名为`func`的参数，一个要运行的函数。进入函数后，它只是调用这个函数：
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If we pass `answer` to `run_something()`, we’re using a function as data, just
    as with anything else:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`answer`传递给`run_something()`，我们正在使用函数作为数据，就像其他任何东西一样：
- en: '[PRE45]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Notice that you passed `answer`, not `answer()`. In Python, those parentheses
    mean *call this function*. With no parentheses, Python just treats the function
    like any other object. That’s because, like everything else in Python, it *is*
    an object:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你传递的是`answer`，而不是`answer()`。在Python中，那些括号意味着*调用这个函数*。没有括号，Python只是将函数视为任何其他对象一样对待。这是因为，像Python中的一切其他东西一样，它*是*一个对象：
- en: '[PRE46]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let’s try running a function with arguments. Define a function `add_args()`
    that prints the sum of its two numeric arguments, `arg1` and `arg2`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试运行一个带有参数的函数。定义一个名为`add_args()`的函数，打印其两个数值参数`arg1`和`arg2`的和：
- en: '[PRE47]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: And what is `add_args()`?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_args()`是什么？'
- en: '[PRE48]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'At this point, let’s define a function called `run_something_with_args()` that
    takes three arguments:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，让我们定义一个名为`run_something_with_args()`的函数，它接受三个参数：
- en: '`func`'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`func`'
- en: The function to run
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行的函数
- en: '`arg1`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`arg1`'
- en: The first argument for `func`
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`func`的第一个参数'
- en: '`arg2`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`arg2`'
- en: The second argument for `func`
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`func`的第二个参数'
- en: '[PRE49]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: When you call `run_something_with_args()`, the function passed by the caller
    is assigned to the `func` parameter, whereas `arg1` and `arg2` get the values
    that follow in the argument list. Then, running `func(arg1, arg2)` executes that
    function with those arguments because the parentheses told Python to do so.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用`run_something_with_args()`时，调用者传递的函数被赋给`func`参数，而`arg1`和`arg2`得到了在参数列表中跟随的值。然后，运行`func(arg1,
    arg2)`使用这些参数执行该函数，因为括号告诉Python这样做。
- en: 'Let’s test it by passing the function name `add_args` and the arguments `5`
    and `9` to `run_something_with_args()`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向函数名`add_args`和参数`5`及`9`传递给`run_something_with_args()`来测试它：
- en: '[PRE50]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Within the function `run_something_with_args()`, the function name argument
    `add_args` was assigned to the parameter `func`, `5` to `arg1`, and `9` to `arg2`.
    This ended up running:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数`run_something_with_args()`中，函数名参数`add_args`被赋给了参数`func`，`5`被赋给了参数`arg1`，`9`被赋给了参数`arg2`。这最终执行了：
- en: '[PRE51]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You can combine this with the `*args` and `**kwargs` techniques.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此与`*args`和`**kwargs`技术结合使用。
- en: 'Let’s define a test function that takes any number of positional arguments,
    calculates their sum by using the `sum()` function, and then returns that sum:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个测试函数，它接受任意数量的位置参数，通过使用`sum()`函数计算它们的总和，然后返回该总和：
- en: '[PRE52]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: I haven’t mentioned `sum()` before. It’s a built-in Python function that calculates
    the sum of the values in its iterable numeric (int or float) argument.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前没有提到`sum()`。它是一个内置的Python函数，用于计算其可迭代数值（int或float）参数中值的总和。
- en: 'Let’s define the new function `run_with_positional_args()`, which takes a function
    and any number of positional arguments to pass to it:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义新函数`run_with_positional_args()`，它接受一个函数和任意数量的位置参数以传递给它：
- en: '[PRE53]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now go ahead and call it:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在继续调用它：
- en: '[PRE54]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You can use functions as elements of lists, tuples, sets, and dictionaries.
    Functions are immutable, so you can also use them as dictionary keys.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将函数用作列表、元组、集合和字典的元素。函数是不可变的，因此您也可以将它们用作字典键。
- en: Inner Functions
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部函数
- en: 'You can define a function within another function:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在一个函数内定义另一个函数：
- en: '[PRE55]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'An inner function can be useful when performing some complex task more than
    once within another function, to avoid loops or code duplication. For a string
    example, this inner function adds some text to its argument:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当在另一个函数内部执行某个复杂任务超过一次时，内部函数可以很有用，以避免循环或代码重复。例如，对于字符串示例，此内部函数向其参数添加一些文本：
- en: '[PRE56]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Closures
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: An inner function can act as a *closure*. This is a function that is dynamically
    generated by another function and can both change and remember the values of variables
    that were created outside the function.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 内部函数可以充当*闭包*。这是由另一个函数动态生成的函数，可以改变并记住在函数外部创建的变量的值。
- en: 'The following example builds on the previous `knights()` example. Let’s call
    the new one `knights2()`, because we have no imagination, and turn the `inner()`
    function into a closure called `inner2()`. Here are the differences:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是基于先前的`knights()`示例构建的。让我们称其为`knights2()`，因为我们没有想象力，并将`inner()`函数转变为称为`inner2()`的闭包。以下是它们之间的区别：
- en: '`inner2()` uses the outer `saying` parameter directly instead of getting it
    as an argument.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inner2()`直接使用外部的`saying`参数，而不是作为参数获取它。'
- en: '`knights2()` returns the `inner2` function name instead of calling it:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`knights2()`返回了`inner2`函数名而不是调用它：'
- en: '[PRE57]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `inner2()` function knows the value of `saying` that was passed in and
    remembers it. The line `return inner2` returns this specialized copy of the `inner2`
    function (but doesn’t call it). That’s a kind of closure: a dynamically created
    function that remembers where it came from.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`inner2()`函数知道传入的`saying`值，并记住它。`return inner2`这一行返回了这个专门的`inner2`函数副本（但没有调用它）。这是一种闭包：一个动态创建的函数，记住了它来自何处。'
- en: 'Let’s call `knights2()` twice, with different arguments:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们两次调用`knights2()`，使用不同的参数：
- en: '[PRE58]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Okay, so what are `a` and `b`?
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么`a`和`b`是什么？
- en: '[PRE59]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'They’re functions, but they’re also closures:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是函数，但它们也是闭包：
- en: '[PRE60]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If we call them, they remember the `saying` that was used when they were created
    by `knights2`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用它们，它们会记住由`knights2`创建时使用的`saying`：
- en: '[PRE61]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Anonymous Functions: lambda'
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名函数：lambda
- en: A Python *lambda function* is an anonymous function expressed as a single statement.
    You can use it instead of a normal tiny function.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Python *lambda函数* 是作为单个语句表示的匿名函数。您可以使用它来代替普通的小函数。
- en: 'To illustrate it, let’s first make an example that uses normal functions. To
    begin, let’s define the function `edit_story()`. Its arguments are the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们首先做一个使用普通函数的示例。首先，让我们定义函数 `edit_story()`。它的参数如下：
- en: '`words`—a list of words'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`words`—一个单词列表'
- en: '`func`—a function to apply to each word in `words`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func`—应用于 `words` 中每个单词的函数'
- en: '[PRE62]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now we need a list of words and a function to apply to each word. For the words,
    here’s a list of (hypothetical) sounds made by my cat if he (hypothetically) missed
    one of the stairs:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个单词列表和一个应用到每个单词的函数。对于单词，这里是我家猫（假设的情况下）如果（假设的情况下）错过了其中一个楼梯可能发出的一系列（假设的）声音：
- en: '[PRE63]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'And for the function, this will capitalize each word and append an exclamation
    point, perfect for feline tabloid newspaper headlines:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 而对于函数，这将使每个单词大写并追加一个感叹号，非常适合猫类小报的头条新闻：
- en: '[PRE64]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Mixing our ingredients:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 混合我们的成分：
- en: '[PRE65]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Finally, we get to the lambda. The `enliven()` function was so brief that we
    could replace it with a lambda:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到 lambda。`enliven()` 函数如此简短，以至于我们可以用 lambda 替换它：
- en: '[PRE66]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: A lambda has zero or more comma-separated arguments, followed by a colon (`:`),
    and then the definition of the function. We’re giving this lambda one argument,
    `word`. You don’t use parentheses with `lambda` as you would when calling a function
    created with `def`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 函数有零个或多个逗号分隔的参数，后跟一个冒号（`:`），然后是函数的定义。我们给这个 lambda 一个参数 `word`。你不像调用 `def`
    创建的函数那样在 lambda 函数中使用括号。
- en: Often, using real functions such as `enliven()` is much clearer than using lambdas.
    Lambdas are mostly useful for cases in which you would otherwise need to define
    many tiny functions and remember what you called them all. In particular, you
    can use lambdas in graphical user interfaces to define *callback functions*; see
    [Chapter 20](ch20.html#ch_art) for examples.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用真正的函数如 `enliven()` 要比使用 lambda 函数更清晰。Lambda 函数主要用于在否则需要定义许多小函数并记住它们名称的情况下非常有用。特别是在图形用户界面中，你可以用
    lambda 来定义 *回调函数*；详见[第 20 章](ch20.html#ch_art)的示例。
- en: Generators
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器
- en: 'A *generator* is a Python sequence creation object. With it, you can iterate
    through potentially huge sequences without creating and storing the entire sequence
    in memory at once. Generators are often the source of data for iterators. If you
    recall, we already used one of them, `range()`, in earlier code examples to generate
    a series of integers. In Python 2, `range()` returns a list, which limits it to
    fit in memory. Python 2 also has the generator `xrange()`, which became the normal
    `range()` in Python 3. This example adds all the integers from 1 to 100:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *生成器* 是 Python 的序列创建对象。利用它，你可以在不一次性创建和存储整个序列于内存中的情况下遍历可能非常庞大的序列。生成器通常是迭代器的数据源。如果你还记得，在之前的代码示例中我们已经使用了其中一个，`range()`，来生成一系列整数。在
    Python 2 中，`range()` 返回一个列表，这限制了它的内存使用。Python 2 还有生成器 `xrange()`，在 Python 3 中变成了普通的
    `range()`。这个示例将所有的整数从 1 加到 100：
- en: '[PRE67]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Every time you iterate through a generator, it keeps track of where it was the
    last time it was called and returns the next value. This is different from a normal
    function, which has no memory of previous calls and always starts at its first
    line with the same state.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你遍历一个生成器时，它都会记住上次被调用时的位置，并返回下一个值。这与普通函数不同，普通函数没有记忆先前调用的状态，每次都从第一行开始执行。
- en: Generator Functions
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器函数
- en: 'If you want to create a potentially large sequence, you can write a *generator
    function*. It’s a normal function, but it returns its value with a `yield` statement
    rather than `return`. Let’s write our own version of `range()`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想创建一个可能很大的序列，可以编写一个 *生成器函数*。它是一个普通函数，但它通过 `yield` 语句而不是 `return` 返回它的值。让我们来写我们自己的
    `range()` 版本：
- en: '[PRE68]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'It’s a normal function:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个普通函数：
- en: '[PRE69]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'And it returns a generator object:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 并返回一个生成器对象：
- en: '[PRE70]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We can iterate over this generator object:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以遍历这个生成器对象：
- en: '[PRE71]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note
  id: totrans-237
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A generator can be run only once. Lists, sets, strings, and dictionaries exist
    in memory, but a generator creates its values on the fly and hands them out one
    at a time through an iterator. It doesn’t remember them, so you can’t restart
    or back up a generator.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器只能运行一次。列表、集合、字符串和字典存在于内存中，但生成器会即时创建其值，并逐个通过迭代器分发它们。它不记住它们，因此你无法重新启动或备份生成器。
- en: 'If you try to iterate this generator again, you’ll find that it’s tapped out:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试再次迭代这个生成器，你会发现它已经耗尽了：
- en: '[PRE72]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Generator Comprehensions
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器推导式
- en: 'You’ve seen comprehensions for lists, dictionaries, and sets. A *generator
    comprehension* looks like those, but is surrounded by parentheses instead of square
    or curly brackets. It’s like a shorthand version of a generator function, doing
    the `yield` invisibly, and also returns a generator object:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了用于列表、字典和集合的理解。*生成器理解* 看起来像那些，但是用圆括号而不是方括号或花括号括起来。这就像是生成器函数的简写版本，隐式地执行
    `yield` 并返回生成器对象：
- en: '[PRE73]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Decorators
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器
- en: Sometimes, you want to modify an existing function without changing its source
    code. A common example is adding a debugging statement to see what arguments were
    passed in.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您希望修改现有函数而不更改其源代码。一个常见的例子是添加调试语句以查看传递的参数是什么。
- en: 'A *decorator* is a function that takes one function as input and returns another
    function. Let’s dig into our bag of Python tricks and use the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*装饰器* 是一个接受一个函数作为输入并返回另一个函数的函数。让我们深入探讨一下我们的 Python 技巧，并使用以下内容：'
- en: '`*args` and `**kwargs`'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*args` 和 `**kwargs`'
- en: Inner functions
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部函数
- en: Functions as arguments
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作为参数
- en: 'The function `document_it()` defines a decorator that will do the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `document_it()` 定义了一个装饰器，该装饰器将执行以下操作：
- en: Print the function’s name and the values of its arguments
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印函数的名称和其参数的值
- en: Run the function with the arguments
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用参数运行函数
- en: Print the result
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印结果
- en: Return the modified function for use
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回修改后的函数以供使用
- en: 'Here’s what the code looks like:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码的样子：
- en: '[PRE74]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Whatever `func` you pass to `document_it()`, you get a new function that includes
    the extra statements that `document_it()` adds. A decorator doesn’t actually have
    to run any code from `func`, but `document_it()` calls `func` partway through
    so that you get the results of `func` as well as all the extras.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您传递给 `document_it()` 的 `func` 是什么，您都会得到一个包含 `document_it()` 添加的额外语句的新函数。装饰器实际上不必从
    `func` 运行任何代码，但 `document_it()` 在执行过程中调用 `func`，以便您既可以获得 `func` 的结果，又可以获得所有额外的内容。
- en: 'So, how do you use this? You can apply the decorator manually:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，您如何使用它呢？您可以手动应用装饰器：
- en: '[PRE75]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'As an alternative to the manual decorator assignment we just looked at, you
    can add @*`decorator_name`* before the function that you want to decorate:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 作为手动装饰器分配的替代方案，您可以在您想要装饰的函数之前添加 *@*`decorator_name`* ：
- en: '[PRE76]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'You can have more than one decorator for a function. Let’s write another decorator
    called `square_it()` that squares the result:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数可以有多个装饰器。让我们再写一个名为 `square_it()` 的装饰器，用于对结果进行平方：
- en: '[PRE77]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The decorator that’s used closest to the function (just above the `def`) runs
    first and then the one above it. Either order gives the same end result, but you
    can see how the intermediate steps change:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最接近函数的装饰器（就在 `def` 的上方）首先运行，然后是它上面的装饰器。无论顺序如何，最终结果都相同，但您可以看到中间步骤如何改变：
- en: '[PRE78]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Let’s try reversing the decorator order:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试颠倒装饰器的顺序：
- en: '[PRE79]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Namespaces and Scope
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间和作用域
- en: Desiring this man’s art and that man’s scope
  id: totrans-269
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 渴望这个人的艺术和那个人的视野
- en: ''
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: William Shakespeare
  id: totrans-271
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 威廉·莎士比亚
- en: A name can refer to different things, depending on where it’s used. Python programs
    have various *namespaces*—sections within which a particular name is unique and
    unrelated to the same name in other namespaces.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名称可以根据其使用的位置引用不同的事物。Python 程序有各种*命名空间* —— 某个名称在其中是唯一的，并且与其他命名空间中相同名称无关。
- en: 'Each function defines its own namespace. If you define a variable called `x`
    in a main program and another variable called `x` in a function, they refer to
    different things. But the walls can be breached: if you need to, you can access
    names in other namespaces in various ways.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数定义其自己的命名空间。如果您在主程序中定义了一个名为 `x` 的变量，并在函数中定义了另一个名为 `x` 的变量，它们将指代不同的事物。但是，墙壁是可以打破的：如果需要，可以通过各种方式访问其他命名空间中的名称。
- en: The main part of a program defines the *global* namespace; thus, the variables
    in that namespace are *global variables*.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的主要部分定义了*全局*命名空间；因此，在该命名空间中的变量是*全局变量*。
- en: 'You can get the value of a global variable from within a function:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从函数内部获取全局变量的值：
- en: '[PRE80]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'But if you try to get the value of the global variable *and* change it within
    the function, you get an error:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您尝试在函数内获取全局变量的值*并且*更改它，您将会得到一个错误：
- en: '[PRE81]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'If you just change it, it changes a different variable also named `animal`,
    but this variable is inside the function:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只是更改它，则还会更改另一个名为 `animal` 的变量，但此变量位于函数内部：
- en: '[PRE82]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: What happened here? The first line assigned the string `'fruitbat'` to a global
    variable named `animal`. The `change_local()` function also has a variable named
    `animal`, but that’s in its local namespace.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？第一行将字符串 `'fruitbat'` 分配给名为 `animal` 的全局变量。`change_local()` 函数中也有一个名为 `animal`
    的变量，但它在其局部命名空间中。
- en: I used the Python function `id()` here to print the unique value for each object
    and prove that the variable `animal` inside `change_local()` is not the same as
    `animal` at the main level of the program.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用了 Python 函数 `id()` 来打印每个对象的唯一值，并证明 `change_local()` 内部的变量 `animal` 不同于程序主层级的
    `animal`。
- en: 'To access the global variable rather than the local one within a function,
    you need to be explicit and use the `global` keyword (you knew this was coming:
    *explicit is better than implicit*):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部访问全局变量而不是局部变量，你需要显式使用 `global` 关键字（你知道这是必须的：*显式优于隐式*）：
- en: '[PRE83]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: If you don’t say `global` within a function, Python uses the local namespace
    and the variable is local. It goes away after the function completes.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在函数内部不使用 `global`，Python 使用局部命名空间，变量是局部的。函数执行完成后，它就消失了。
- en: 'Python provides two functions to access the contents of your namespaces:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了两个函数来访问你的命名空间的内容：
- en: '`locals()` returns a dictionary of the contents of the local namespace.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`locals()` 返回本地命名空间内容的字典。'
- en: '`globals()` returns a dictionary of the contents of the global namespace.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`globals()` 返回全局命名空间内容的字典。'
- en: 'And here they are in use:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 并且它们在使用中：
- en: '[PRE84]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The local namespace within `change_local()` contained only the local variable
    `animal`. The global namespace contained the separate global variable `animal`
    and a number of other things.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`change_local()` 内的局部命名空间仅包含局部变量 `animal`。全局命名空间包含独立的全局变量 `animal` 和许多其他内容。'
- en: Uses of _ and __ in Names
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在名称中使用 _ 和 __
- en: Names that begin and end with two underscores (`__`) are reserved for use within
    Python, so you should not use them with your own variables. This naming pattern
    was chosen because it seemed unlikely to be selected by application developers
    for their own variables.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 以两个下划线 (`__`) 开头和结尾的名称保留供 Python 使用，因此你不应该将它们用于自己的变量。选择这种命名模式是因为看起来不太可能被应用开发人员选为其自己的变量名。
- en: 'For instance, the name of a function is in the system variable *`function`*`.__name__`,
    and its documentation string is *`function`*`.__doc__`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，函数的名称在系统变量 *`function`*`.__name__` 中，其文档字符串在 *`function`*`.__doc__` 中：
- en: '[PRE85]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: As you saw in the earlier `globals` printout, the main program is assigned the
    special name `__main__`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的 `globals` 打印中看到的那样，主程序被赋予特殊名称 `__main__`。
- en: Recursion
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归
- en: So far, we’ve called functions that do some things directly, and maybe call
    other functions. But what if a function calls itself?^([5](ch09.html#idm45795000110936))
    This is called *recursion*. Like an unbroken infinite loop with `while` or `for`,
    you don’t want infinite recursion. Do we still need to worry about cracks in the
    space-time continuum?
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经调用了一些直接执行某些操作的函数，并可能调用其他函数。但如果一个函数调用自身呢？^([5](ch09.html#idm45795000110936))
    这就是*递归*。就像使用 `while` 或 `for` 的无限循环一样，你不希望出现无限递归。我们仍然需要担心时空连续性的裂缝吗？
- en: 'Python saves the universe again by raising an exception if you get too deep:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Python 再次拯救了宇宙，如果你深入太多，它会引发异常：
- en: '[PRE86]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Recursion is useful when you’re dealing with “uneven” data, like lists of lists
    of lists. Suppose that you want to “flatten” all sublists of a list,^([6](ch09.html#idm45795000106696))
    no matter how deeply nested. A generator function is just the thing:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理像列表的列表的列表这样的“不均匀”数据时，递归非常有用。假设你想要“展平”列表的所有子列表，^([6](ch09.html#idm45795000106696))
    无论嵌套多深，生成器函数正是你需要的：
- en: '[PRE87]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Python 3.3 added the `yield from` expression, which lets a generator hand off
    some work to another generator. We can use it to simplify `flatten()`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.3 添加了 `yield from` 表达式，允许生成器将一些工作交给另一个生成器。我们可以用它来简化 `flatten()`：
- en: '[PRE88]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Async Functions
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步函数
- en: 'The keywords `async` and `await` were added to Python 3.5 to define and run
    *asynchronous functions*. They’re:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 `async` 和 `await` 被添加到 Python 3.5 中，用于定义和运行*异步函数*。它们是：
- en: Relatively new
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对较新
- en: Different enough to be harder to understand
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 足够不同，以至于更难理解
- en: Will become more important and better known over time
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着时间的推移，它会变得更重要且更为人熟知
- en: For these reasons, I’ve moved discussion of these and other async topics to
    [Appendix C](app03.html#app_async).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这些原因，我已将这些及其他异步主题的讨论移到了附录 C 中的 [Appendix C](app03.html#app_async)。
- en: For now, you need to know that if you see `async` before the `def` line for
    a function, it’s an asynchronous function. Likewise, if you see `await` before
    a function call, that function is asynchronous.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要知道，如果在函数的`def`行之前看到`async`，那么这是一个异步函数。同样，如果在函数调用之前看到`await`，那么该函数是异步的。
- en: The main difference between asynchronous and normal functions is that async
    ones can “give up control” rather than running to completion.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 异步函数和普通函数的主要区别在于异步函数可以“放弃控制”，而不是一直运行到完成。
- en: Exceptions
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常
- en: 'In some languages, errors are indicated by special function return values.
    When things go south,^([7](ch09.html#idm45794999807944)) Python uses *exceptions*:
    code that is executed when an associated error occurs.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些语言中，错误通过特殊的函数返回值来指示。当事情出错时，Python使用*异常*：当关联的错误发生时执行的代码。
- en: You’ve seen some of these already, such as accessing a list or tuple with an
    out-of-range position, or a dictionary with a nonexistent key. When you run code
    that might fail under some circumstances, you also need appropriate *exception
    handlers* to intercept any potential errors.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了一些例子，比如访问列表或元组时使用超出范围的位置，或者使用不存在的键访问字典。当你运行在某些情况下可能失败的代码时，还需要适当的*异常处理程序*来拦截任何潜在的错误。
- en: 'It’s good practice to add exception handling anywhere an exception might occur
    to let the user know what is happening. You might not be able to fix the problem,
    but at least you can note the circumstances and shut your program down gracefully.
    If an exception occurs in some function and is not caught there, it *bubbles up*
    until it is caught by a matching handler in some calling function. If you don’t
    provide your own exception handler, Python prints an error message and some information
    about where the error occurred and then terminates the program, as demonstrated
    in the following snippet:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何可能发生异常的地方添加异常处理是一个好习惯，以便让用户知道发生了什么。你可能无法修复问题，但至少可以记录情况并优雅地关闭程序。如果异常发生在某个函数中并且没有在那里捕获，它会*冒泡*直到在某个调用函数中找到匹配的处理程序。如果不提供自己的异常处理程序，Python会打印错误消息和关于错误发生位置的一些信息，然后终止程序，如以下代码片段所示：
- en: '[PRE89]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Handle Errors with try and except
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用try和except处理错误
- en: Do, or do not. There is no try.
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 做，或者不做。没有尝试。
- en: ''
  id: totrans-320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Yoda
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尤达
- en: 'Rather than leaving things to chance, use `try` to wrap your code, and `except`
    to provide the error handling:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 不要留事情交给机会，使用`try`包装你的代码，并使用`except`提供错误处理：
- en: '[PRE90]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The code inside the `try` block is run. If there is an error, an exception is
    raised and the code inside the `except` block runs. If there are no errors, the
    `except` block is skipped.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`try`块内的代码。如果出现错误，将引发异常并执行`except`块内的代码。如果没有错误，则跳过`except`块。
- en: Specifying a plain `except` with no arguments, as we did here, is a catchall
    for any exception type. If more than one type of exception could occur, it’s best
    to provide a separate exception handler for each. No one forces you to do this;
    you can use a bare `except` to catch all exceptions, but your treatment of them
    would probably be generic (something akin to printing *Some error occurred*).
    You can use any number of specific exception handlers.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用没有参数的纯`except`来指定是一个通用的异常捕获。如果可能会出现多种类型的异常，最好为每种类型提供单独的异常处理程序。没有人强迫你这样做；你可以使用裸露的`except`来捕获所有异常，但你对它们的处理可能是通用的（类似于打印*发生了一些错误*）。你可以使用任意数量的特定异常处理程序。
- en: 'Sometimes, you want exception details beyond the type. You get the full exception
    object in the variable *name* if you use the form:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你希望除了类型以外的异常详情。如果使用以下形式，你会在变量*name*中得到完整的异常对象：
- en: '[PRE91]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The example that follows looks for an `IndexError` first, because that’s the
    exception type raised when you provide an illegal position to a sequence. It saves
    an `IndexError` exception in the variable `err`, and any other exception in the
    variable `other`. The example prints everything stored in `other` to show what
    you get in that object:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例首先查找`IndexError`，因为当你向序列提供非法位置时，会引发该异常类型。它将`IndexError`异常保存在变量`err`中，将其他任何异常保存在变量`other`中。示例打印`other`中存储的所有内容，以展示你在该对象中得到的内容：
- en: '[PRE92]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Inputting position `3` raised an `IndexError` as expected. Entering `two` annoyed
    the `int()` function, which we handled in our second, catchall `except` code.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 输入位置`3`引发了预期的`IndexError`。输入`two`使`int()`函数感到恼火，我们在第二个通用的`except`代码中处理了它。
- en: Make Your Own Exceptions
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义异常
- en: The previous section discussed handling exceptions, but all of the exceptions
    (such as `IndexError`) were predefined in Python or its standard library. You
    can use any of these for your own purposes. You can also define your own exception
    types to handle special situations that might arise in your own programs.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节讨论了处理异常，但所有的异常（如`IndexError`）都是在Python或其标准库中预定义的。你可以为自己的程序使用其中任何一个。你也可以定义自己的异常类型来处理可能在你自己的程序中出现的特殊情况。
- en: Note
  id: totrans-333
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This requires defining a new object type with a *class*—something we don’t get
    into until [Chapter 10](ch10.html#ch_objects). So, if you’re unfamiliar with classes,
    you might want to return to this section later.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要定义一个新的对象类型，使用一个*类*——这是我们直到[第10章](ch10.html#ch_objects)才会详细讨论的内容。所以，如果你对类不熟悉，可能需要稍后再回到本节。
- en: 'An exception is a class. It is a child of the class `Exception`. Let’s make
    an exception called `UppercaseException` and raise it when we encounter an uppercase
    word in a string:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是一个类。它是类`Exception`的子类。让我们创建一个叫做`UppercaseException`的异常，在字符串中遇到大写字母时引发它：
- en: '[PRE93]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: We didn’t even define any behavior for `UppercaseException` (notice we just
    used `pass`), letting its parent class `Exception` figure out what to print when
    the exception was raised.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至没有为`UppercaseException`定义任何行为（注意我们只是使用了`pass`），让它的父类`Exception`来决定在引发异常时打印什么。
- en: 'You can access the exception object itself and print it:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以访问异常对象本身并打印它：
- en: '[PRE94]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Coming Up
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即将出现
- en: Objects! We had to get to them sometime in a book about an object-oriented language.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 对象！在一本关于面向对象语言的书中，我们必须介绍它们。
- en: Things to Do
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要做的事情
- en: '9.1 Define a function called `good()` that returns the following list: `[''Harry'',
    ''Ron'', ''Hermione'']`.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 9.1 定义一个名为`good()`的函数，返回以下列表：`['Harry', 'Ron', 'Hermione']`。
- en: 9.2 Define a generator function called `get_odds()` that returns the odd numbers
    from `range(10)`. Use a `for` loop to find and print the third value returned.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 9.2 定义一个名为`get_odds()`的生成器函数，返回`range(10)`中的奇数。使用`for`循环找到并打印第三个返回的值。
- en: 9.3 Define a decorator called `test` that prints `'start'` when a function is
    called, and `'end'` when it finishes.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 9.3 定义一个名为`test`的装饰器，在调用函数时打印`'start'`，在函数结束时打印`'end'`。
- en: 9.4 Define an exception called `OopsException`. Raise this exception to see
    what happens. Then, write the code to catch this exception and print `'Caught
    an oops'`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 9.4 定义一个名为`OopsException`的异常。引发这个异常看看会发生什么。然后，编写代码捕捉这个异常并打印`'Caught an oops'`。
- en: ^([1](ch09.html#idm45795002646440-marker)) Although *Args* and *Kwargs* sound
    like the names of pirate parrots.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch09.html#idm45795002646440-marker)) 虽然*Args*和*Kwargs*听起来像海盗鹦鹉的名字。
- en: ^([2](ch09.html#idm45795002644024-marker)) Or, as of Python 3.5, a dictionary
    merge of the form `{**a, **b}`, as you saw in [Chapter 8](ch08.html#ch_dicts).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch09.html#idm45795002644024-marker)) 或者，如Python 3.5中的字典合并形式`{**a, **b}`，就像你在[第8章](ch08.html#ch_dicts)看到的那样。
- en: ^([3](ch09.html#idm45795002479608-marker)) Like the teens-in-peril movies where
    they learn “The call’s coming from inside the house!”
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch09.html#idm45795002479608-marker)) 就像那些青少年陷入危险的电影中他们学会了“电话是从房子里打来的！”
- en: '^([4](ch09.html#idm45795002478344-marker)) Like the old doctor joke: “It hurts
    when I do this.” “Well, then don’t do that.”'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch09.html#idm45795002478344-marker)) 就像那个老医生笑话：“当我这样做时很痛。” “那么，就别这样做。”
- en: ^([5](ch09.html#idm45795000110936-marker)) It’s like saying, “I wish I had a
    dollar for every time I wished I had a dollar.”
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch09.html#idm45795000110936-marker)) 这就像说，“如果我每次希望有一美元，我就能有一美元。”
- en: ^([6](ch09.html#idm45795000106696-marker)) Another Python interview question.
    Collect the whole set!
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch09.html#idm45795000106696-marker)) 又是一个Python面试问题。收集整套吧！
- en: ^([7](ch09.html#idm45794999807944-marker)) Is this northern hemispherism? Do
    Aussies and Kiwis say that things go “north” when they mess up?
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch09.html#idm45794999807944-marker)) 这是北半球主义吗？澳大利亚人和新西兰人说东西乱了会说“north”吗？
