- en: Chapter 5\. Text Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I always liked strange characters.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Tim Burton
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Computer books often give the impression that programming is all about math.
    Actually, most programmers work with *strings* of text more often than numbers.
    Logical (and creative!) thinking is often more important than math skills.
  prefs: []
  type: TYPE_NORMAL
- en: Strings are our first example of a Python *sequence*. In this case, they’re
    a sequence of *characters*. But what’s a character? It’s the smallest unit in
    a writing system, and includes letters, digits, symbols, punctuation, and even
    white space or directives like linefeeds. A character is defined by its meaning
    (how it’s used), not how it looks. It can have more than one visual representation
    (in different *fonts*), and more than one character can have the same appearance
    (such as the visual `H`, which means the `H` sound in the Latin alphabet but the
    Latin `N` sound in Cyrillic).
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter concentrates on how to make and format simple text strings, using
    ASCII (basic character set) examples. Two important text topics are deferred to
    [Chapter 12](ch12.html#ch_munging): *Unicode* characters (like the `H` and `N`
    issue I just mentioned) and *regular expressions* (pattern matching).'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike other languages, strings in Python are *immutable*. You can’t change
    a string in place, but you can copy parts of strings to another string to get
    the same effect. We look at how to do this shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Create with Quotes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You make a Python string by enclosing characters in matching single or double
    quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The interactive interpreter echoes strings with a single quote, but all are
    treated exactly the same by Python.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Python has a few special types of strings, indicated by a letter before the
    first quote. `f` or `F` starts an *f string*, used for formatting, and described
    near the end of this chapter. `r` or `R` starts a *raw string*, used to prevent
    *escape sequences* in the string (see [“Escape with \”](#escape) and [Chapter 12](ch12.html#ch_munging)
    for its use in string pattern matching). Then, there’s the combination `fr` (or
    `FR`, `Fr`, or `fR`) that starts a raw f-string. A `u` starts a Unicode string,
    which is the same as a plain string. And a `b` starts a value of type `bytes`
    ([Chapter 12](ch12.html#ch_munging)). Unless I mention one of these special types,
    I’m always talking about plain old Python Unicode text strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why have two kinds of quote characters? The main purpose is to create strings
    containing quote characters. You can have single quotes inside double-quoted strings,
    or double quotes inside single-quoted strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use three single quotes (`''''''`) or three double quotes (`"""`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Triple quotes aren’t very useful for short strings like these. Their most common
    use is to create *multiline strings*, like this classic poem from Edward Lear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: (This was entered in the interactive interpreter, which prompted us with `>>>`
    for the first line and continuation prompts `...` until we entered the final triple
    quotes and went to the next line.)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you tried to create that poem without triple quotes, Python would make a
    fuss when you went to the second line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have multiple lines within triple quotes, the line ending characters
    will be preserved in the string. If you have leading or trailing spaces, they’ll
    also be kept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'By the way, there’s a difference between the output of `print()` and the automatic
    echoing done by the interactive interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`print()` strips quotes from strings and prints their contents. It’s meant
    for human output. It helpfully adds a space between each of the things it prints,
    and a newline at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t want the space or newline, [Chapter 14](ch14.html#ch_files) explains
    how to avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: The interactive interpreter prints the string with individual quotes and *escape
    characters* such as `\n`, which are explained in [“Escape with \”](#escape).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, there is the *empty string*, which has no characters at all but is
    perfectly valid. You can create an empty string with any of the aforementioned
    quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Create with str()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can make a string from another data type by using the `str()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Python uses the `str()` function internally when you call `print()` with objects
    that are not strings and when doing *string formatting*, which you’ll see later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Escape with \
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python lets you *escape* the meaning of some characters within strings to achieve
    effects that would otherwise be difficult to express. By preceding a character
    with a backslash (`\`), you give it a special meaning. The most common escape
    sequence is `\n`, which means to begin a new line. With this you can create multiline
    strings from a one-line string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the escape sequence `\t` (tab) used to align text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: (The final string has a terminating tab which, of course, you can’t see.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You might also need `\''` or `\"` to specify a literal single or double quote
    inside a string that’s quoted by the same character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you need a literal backslash, type two of them (the first escapes the
    second):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As I mentioned early in this chapter, a *raw string* negates these escapes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: (The extra backslash in the first `info` output was added by the interactive
    interpreter.)
  prefs: []
  type: TYPE_NORMAL
- en: 'A raw string does not undo any real (not `''\n''`) newlines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Combine by Using `+`
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can combine literal strings or string variables in Python by using the
    `+` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also combine *literal strings* (not string variables) just by having
    one after the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a lot of these, you can avoid escaping the line endings by surrounding
    them with parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Python does *not* add spaces for you when concatenating strings, so in some
    earlier examples, we needed to include spaces explicitly. Python *does* add a
    space between each argument to a `print()` statement and a newline at the end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Duplicate with *
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You use the `*` operator to duplicate a string. Try typing these lines into
    your interactive interpreter and see what they print:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `*` has higher precedence than `+`, so the string is duplicated
    before the line feed is tacked on.
  prefs: []
  type: TYPE_NORMAL
- en: Get a Character with []
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get a single character from a string, specify its *offset* inside square
    brackets after the string’s name. The first (leftmost) offset is 0, the next is
    1, and so on. The last (rightmost) offset can be specified with –1, so you don’t
    have to count; going to the left are –2, –3, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you specify an offset that is the length of the string or longer (remember,
    offsets go from 0 to length–1), you’ll get an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Indexing works the same with the other sequence types (lists and tuples), which
    I cover in [Chapter 7](ch07.html#ch_lists).
  prefs: []
  type: TYPE_NORMAL
- en: 'Because strings are immutable, you can’t insert a character directly into one
    or change the character at a specific index. Let’s try to change `''Henny''` to
    `''Penny''` and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead you need to use some combination of string functions such as `replace()`
    or a *slice* (which we look at in a moment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We didn’t change the value of `name`. The interactive interpreter just printed
    the result of the replacement.
  prefs: []
  type: TYPE_NORMAL
- en: Get a Substring with a Slice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can extract a *substring* (a part of a string) from a string by using a
    *slice*. You define a slice by using square brackets, a *`start`* offset, an *`end`*
    offset, and an optional *`step`* count between them. You can omit some of these.
    The slice will include characters from offset *`start`* to one before *`end`*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[:]` extracts the entire sequence from start to end.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[` *`start`* `:]` specifies from the *`start`* offset to the end.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[:` *`end`* `]` specifies from the beginning to the *`end`* offset minus 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[` *`start`* `:` *`end`* `]` indicates from the *`start`* offset to the *`end`*
    offset minus 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[` *`start`* `:` *`end`* `:` *`step`* `]` extracts from the *`start`* offset
    to the *`end`* offset minus 1, skipping characters by *`step`*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As before, offsets go 0, 1, and so on from the start to the right, and –1,–2,
    and so forth from the end to the left. If you don’t specify *`start`*, the slice
    uses 0 (the beginning). If you don’t specify *`end`*, it uses the end of the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make a string of the lowercase English letters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a plain `:` is the same as `0:` (the entire string):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example from offset 20 to the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, from offset 10 to the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And another, offset 12 through 14. Python does not include the end offset in
    the slice. The start offset is *inclusive*, and the end offset is *exclusive*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The three last characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In this next example, we go from offset 18 to the fourth before the end; notice
    the difference from the previous example, in which starting at –3 gets the `x`,
    but ending at –3 actually stops at –4, the `w`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following, we extract from 6 before the end to 3 before the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If you want a step size other than 1, specify it after a second colon, as shown
    in the next series of examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the start to the end, in steps of 7 characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'From offset 4 to 19, by 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'From offset 19 to the end, by 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'From the start to offset 20 by 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: (Again, the *end* needs to be one more than the actual offset.)
  prefs: []
  type: TYPE_NORMAL
- en: 'And that’s not all! Given a negative step size, this handy Python slicer can
    also step backward. This starts at the end and ends at the start, skipping nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'It turns out that you can get the same result by using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Slices are more forgiving of bad offsets than are single-index lookups with
    `[]`. A slice offset earlier than the beginning of a string is treated as `0`,
    and one after the end is treated as `-1`, as is demonstrated in this next series
    of examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'From 50 before the end to the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'From 51 before the end to 50 before the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'From the start to 69 after the start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'From 70 after the start to 70 after the start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Get Length with len()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we’ve used special punctuation characters such as `+` to manipulate
    strings. But there are only so many of these. Now let’s begin to use some of Python’s
    built-in *functions*: named pieces of code that perform certain operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `len()` function counts characters in a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You can use `len()` with other sequence types, too, as you’ll see in [Chapter 7](ch07.html#ch_lists).
  prefs: []
  type: TYPE_NORMAL
- en: Split with split()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike `len()`, some functions are specific to strings. To use a string function,
    type the name of the string, a dot, the name of the function, and any *arguments*
    that the function needs: `*string*.*function*(*arguments*)`. There’s a longer
    discussion of functions in [Chapter 9](ch09.html#ch_functions).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the built-in string `split()` function to break a string into a
    *list* of smaller strings based on some *separator*. We look at lists in [Chapter 7](ch07.html#ch_lists).
    A list is a sequence of values, separated by commas and surrounded by square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the string was called `tasks` and the string function
    was called `split()`, with the single separator argument `'',''`. If you don’t
    specify a separator, `split()` uses any sequence of white space characters—newlines,
    spaces, and tabs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: You still need the parentheses when calling `split` with no arguments—that’s
    how Python knows you’re calling a function.
  prefs: []
  type: TYPE_NORMAL
- en: Combine by Using join()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Not too surprisingly, the `join()` function is the opposite of `split()`: it
    collapses a list of strings into a single string. It looks a bit backward because
    you specify the string that glues everything together first, and then the list
    of strings to glue: *`string`* `.join(` *`list`* `)`. So, to join the list `lines`
    with separating newlines, you would say `''\n''.join(lines)`. In the following
    example, let’s join some names in a list with a comma and a space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Substitute by Using replace()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You use `replace()` for simple substring substitution. Give it the old substring,
    the new one, and how many instances of the old substring to replace. It returns
    the changed string but does not modify the original string. If you omit this final
    count argument, it replaces all instances. In this example, only one string (`''duck''`)
    is matched and replaced in the returned string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Change up to 100 of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'When you know the exact substring(s) you want to change, `replace()` is a good
    choice. But watch out. In the second example, if we had substituted for the single
    character string `''a''` rather than the two character string `''a ''` (`a` followed
    by a space), we would have also changed `a` in the middle of other words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, you want to ensure that the substring is a whole word, or the beginning
    of a word, and so on. In those cases, you need *regular expressions*, which are
    described in numbing detail in [Chapter 12](ch12.html#ch_munging).
  prefs: []
  type: TYPE_NORMAL
- en: Strip with strip()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It’s very common to strip leading or trailing “padding” characters from a string,
    especially spaces. The `strip()` functions shown here assume that you want to
    get rid of whitespace characters (`'' ''`, `''\t''`, `''\n''`) if you don’t give
    them an argument. `strip()` strips both ends, `lstrip()` only from the left, and
    `rstrip()` only from the right. Let’s say the string variable `world` contains
    the string `"earth"` floating in spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'If the character were not there, nothing happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides no argument (meaning whitespace characters) or a single character,
    you can also tell `strip()` to remove any character in a multicharacter string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[Appendix E](app05.html#app_cheatsheets) shows some definitions of character
    groups that are useful with `strip()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Search and Select
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python has a large set of string functions. Let’s explore how the most common
    of them work. Our test subject is the following string containing the text of
    the immortal poem “What Is Liquid?” by Margaret Cavendish, Duchess of Newcastle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Inspiring!
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, get the first 13 characters (offsets 0 to 12):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: How many characters are in this poem? (Spaces and newlines are included in the
    count.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Does it start with the letters `All`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Does it end with `That's all, folks!`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Python has two methods (`find()` and `index()`) for finding the offset of a
    substring, and has two versions of each (starting from the beginning or the end).
    They work the same if the substring is found. If it isn’t, `find()` returns `-1`,
    and `index()` raises an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s find the offset of the first occurrence of the word `the` in the poem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'And the offset of the last `the`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'But if the substring isn’t in there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: How many times does the three-letter sequence `the` occur?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Are all of the characters in the poem either letters or numbers?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Nope, there were some punctuation characters.
  prefs: []
  type: TYPE_NORMAL
- en: Case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we look at some more uses of the built-in string functions.
    Our test string is again the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove `.` sequences from both ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because strings are immutable, none of these examples actually changes the `setup`
    string. Each example just takes the value of `setup`, does something to it, and
    returns the result as a new string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Capitalize the first word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Capitalize all the words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert all characters to uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert all characters to lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Swap uppercase and lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Alignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let’s work with some layout alignment functions. The string is aligned
    within the specified total number of spaces (`30` here).
  prefs: []
  type: TYPE_NORMAL
- en: 'Center the string within 30 spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Left justify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Right justify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Next, we look at more ways to align a string.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve seen that you can *concatenate* strings by using `+`. Let’s look at how
    to *interpolate* data values into strings using various formats. You can use this
    to produce reports, forms, and other outputs where appearances need to be just
    so.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the functions in the previous section, Python has three ways of formatting
    strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '*old style* (supported in Python 2 and 3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*new style* (Python 2.6 and up)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*f-strings* (Python 3.6 and up)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Old style: %'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The old style of string formatting has the form *`format_string`* `%` *`data`*.
    Inside the format string are interpolation sequences. [Table 5-1](#conversion_types_table)
    illustrates that the very simplest sequence is a `%` followed by a letter indicating
    the data type to be formatted.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-1\. Conversion types
  prefs: []
  type: TYPE_NORMAL
- en: '| `%s` | string |'
  prefs: []
  type: TYPE_TB
- en: '| `%d` | decimal integer |'
  prefs: []
  type: TYPE_TB
- en: '| `%x` | hex integer |'
  prefs: []
  type: TYPE_TB
- en: '| `%o` | octal integer |'
  prefs: []
  type: TYPE_TB
- en: '| `%f` | decimal float |'
  prefs: []
  type: TYPE_TB
- en: '| `%e` | exponential float |'
  prefs: []
  type: TYPE_TB
- en: '| `%g` | decimal or exponential float |'
  prefs: []
  type: TYPE_TB
- en: '| `%%` | a literal `%` |'
  prefs: []
  type: TYPE_TB
- en: You can use a `%s` for any data type, and Python will format it as a string
    with no extra spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are some simple examples. First, an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'A float:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'An integer and a literal `%`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try some string and integer interpolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: That `%s` inside the string means to interpolate a string. The number of `%`
    appearances in the string needs to match the number of data items after the `%`
    that follows the string. A single data item such as `actor` goes right after that
    final `%`. Multiple data must be grouped into a *tuple* (details in [Chapter 7](ch07.html#ch_lists);
    it’s bounded by parentheses, separated by commas) such as `(cat, weight)`.
  prefs: []
  type: TYPE_NORMAL
- en: Even though `weight` is an integer, the `%s` inside the string converted it
    to a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add other values in the format string between the `%` and the type
    specifier to designate minimum and maximum widths, alignment, and character filling.
    This is a little language in its own right, and more limited than the one in the
    next two sections. Let’s take a quick look at these values:'
  prefs: []
  type: TYPE_NORMAL
- en: An initial `'%'` character.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An optional *alignment* character: nothing or `''+''` means right-align, and
    `''-''` means left-align.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional *minwidth* field width to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional `'.'` character to separate *minwidth* and *maxchars*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional *maxchars* (if conversion type is `s`) saying how many characters
    to print from the data value. If the conversion type is `f`, this specifies *precision*
    (how many digits to print after the decimal point).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *conversion type* character from the earlier table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is confusing, so here are some examples for a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Once more with feeling, and a float with `%f` variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'And an integer with `%d`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: For an integer, the `%+12d` just forces the sign to be printed, and the format
    strings with `.3` in them have no effect as they do for a float.
  prefs: []
  type: TYPE_NORMAL
- en: 'New style: {} and format()'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Old style formatting is still supported. In Python 2, which will freeze at
    version 2.7, it will be supported forever. For Python 3, use the “new style” formatting
    described in this section. If you have Python 3.6 or newer, *f-strings* ([“Newest
    Style: f-strings”](#f_strings)) are even better.'
  prefs: []
  type: TYPE_NORMAL
- en: “New style” formatting has the form `*format_string*.format(*data*)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The format string is not exactly the same as the one in the previous section.
    The simplest usage is demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The arguments to the `format()` function need to be in the order as the `{}`
    placeholders in the format string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'With new-style formatting, you can also specify the arguments by position like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The value `0` referred to the first argument, `place`, and `1` referred to `thing`.
  prefs: []
  type: TYPE_NORMAL
- en: The arguments to `format()` can also be named arguments
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'or a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, `{0}` is the first argument to `format()` (the dictionary
    `d`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'These examples all printed their arguments with default formats. New-style
    formatting has a slightly different format string definition from the old-style
    one (examples follow):'
  prefs: []
  type: TYPE_NORMAL
- en: An initial colon (`':'`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional *fill* character (default `' '`) to pad the value string if it’s
    shorter than *minwidth*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional *alignment* character. This time, left alignment is the default.
    `'<'` also means left, `'>'` means right, and `'^'` means center.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional *sign* for numbers. Nothing means only prepend a minus sign (`'-'`)
    for negative numbers. `' '` means prepend a minus sign for negative numbers, and
    a space (`' '`) for positive ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional *minwidth*. An optional period (`'.'`) to separate *minwidth* and
    *maxchars*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional *maxchars*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *conversion type*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Newest Style: f-strings'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*f-strings* appeared in Python 3.6, and are now the recommended way of formatting
    strings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make an f-string:'
  prefs: []
  type: TYPE_NORMAL
- en: Type the letter `f` or `F` directly before the initial quote.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include variable names or expressions within curly brackets (`{}`) to get their
    values into the string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s like the previous section’s “new-style” formatting, but without the `format()`
    function, and without empty brackets (`{}`) or positional ones (`{1}`) in the
    format string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'As I already mentioned, expressions are also allowed inside the curly brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: This means that the things that you could do inside `format()` in the previous
    section, you can now do inside a `{}` in your main string. This seems easier to
    read.
  prefs: []
  type: TYPE_NORMAL
- en: f-strings use the same formatting language (width, padding, alignment) as new-style
    formatting, after a `':'`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting in Python 3.8, f-strings gain a new shortcut that’s helpful when you
    want to print variable names as well as their values. This is handy when debugging.
    The trick is to have a single `=` after the name in the `{}`-enclosed part of
    the f-string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The name can actually be an expression, and it will be printed literally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `=` can be followed by a `:` and the formatting arguments like
    width and alignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: More String Things
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has many more string functions than I’ve shown here. Some will turn up
    in later chapters (especially [Chapter 12](ch12.html#ch_munging)), but you can
    find all the details at the [standard documentation link](http://bit.ly/py-docs-strings).
  prefs: []
  type: TYPE_NORMAL
- en: Coming Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ll find Froot Loops at the grocery store, but Python loops are at the first
    counter in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Do
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '5.1 Capitalize the word starting with `m`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '5.2 Print each list question with its correctly matching answer, in the form:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Q: *question*'
  prefs: []
  type: TYPE_NORMAL
- en: 'A: *answer*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '5.3 Write the following poem by using old-style formatting. Substitute the
    strings `''roast beef''`, `''ham''`, `''head''`, and `''clam''` into this string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '5.4 Write a form letter by using new-style formatting. Save the following string
    as `letter` (you’ll use it in the next exercise):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 5.5 Assign values to variable strings named `'salutation'`, `'name'`, `'product'`,
    `'verbed'` (past tense verb), `'room'`, `'animals'`, `'percent'`, `'spokesman'`,
    and `'job_title'`. Print `letter` with these values, using `letter.format()`.
  prefs: []
  type: TYPE_NORMAL
- en: '5.6 After public polls to name things, a pattern emerged: an English submarine
    (Boaty McBoatface), an Australian racehorse (Horsey McHorseface), and a Swedish
    train (Trainy McTrainface). Use `%` formatting to print the winning name at the
    state fair for a prize duck, gourd, and spitz.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.7 Do the same, with `format()` formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 5.8 Once more, with feeling, and *f strings*.
  prefs: []
  type: TYPE_NORMAL
