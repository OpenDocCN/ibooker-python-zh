- en: Chapter 5\. Package Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。包管理
- en: Often, small scripts grow in usefulness and importance, which creates a need
    to share and distribute their contents. Python libraries, as well as other code
    projects, require packaging. Without packaging, distributing code becomes problematic
    and brittle.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 常常，小脚本在有用性和重要性上不断增长，这造成了需要分享和分发其内容的需求。Python库以及其他代码项目都需要打包。没有打包，分发代码将变得困难且脆弱。
- en: Once past the proof of concept stage, it is helpful to keep track of changes,
    advertise the type of change (for example, when introducing a backward-incompatible
    update), and provide a way for users to depend on a specific version. Even in
    the most straightforward use cases, it is beneficial to follow a few (packaging)
    guidelines. This, at the very least, should mean keeping track of a changelog
    and determining a version.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 过了概念验证阶段后，跟踪变更是很有帮助的，广告化变更类型（例如，在引入不兼容更新时），并提供一种让用户依赖特定版本的方式。即使在最简单的使用情况下，遵循一些（打包）指南也是有益的。至少，这应该包括跟踪变更日志和确定版本。
- en: There are several strategies to follow for package management, and knowing a
    few of the ones most commonly used allows you to adopt the best option to solve
    a problem. For example, it might be easier to distribute a Python library through
    the Python Package Index (PyPI) instead of making it a system package like Debian
    and RPM. If a Python script needs to run at specific intervals or if it is a long-running
    process, then system packaging working together with `systemd` might work better.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种跟随的包管理策略，了解其中一些最常用的可以让您采用最佳选项来解决问题。例如，通过Python包索引（PyPI）分发Python库可能比将其制作为Debian和RPM的系统包更容易。如果Python脚本需要在特定间隔运行，或者它是长时间运行的进程，那么与`systemd`一起工作的系统打包可能更好。
- en: Although `systemd` is not a packaging tool, it does play well on systems that
    depend on it to manage processes and the server startup sequence. Learning how
    to handle processes with a few `systemd` configuration settings and some packaging
    is a great way to increase the capabilities of a Python project further.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`systemd`不是一个打包工具，但在依赖它管理进程和服务器启动顺序的系统上表现良好。学习如何通过几个`systemd`配置设置和一些打包处理来处理进程，是进一步增强Python项目能力的好方法。
- en: The native Python packaging tools have a public hosting instance for packages
    (PyPI). However, for Debian and RPM packages, it requires some effort to provide
    a local repository. This chapter covers a few tools that make it easier to create
    and manage a package repository, including a local alternative to PyPI.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 原生Python打包工具在包公共托管实例（PyPI）上有一个。然而，对于Debian和RPM包，需要一些努力提供本地仓库。本章涵盖了几个工具，这些工具使创建和管理包仓库更加容易，包括PyPI的本地替代方案。
- en: Having a good understanding of the different packaging strategies, and healthy
    practices like proper versioning and keeping a changelog, provide a stable, consistent
    experience when distributing software.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 充分了解不同的打包策略以及健康实践，如适当的版本化和保持变更日志，可以在分发软件时提供稳定一致的体验。
- en: Why Is Packaging Important?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包为什么重要？
- en: Several factors make packaging software an essential feature of a project (regardless
    of size!). Keeping track of versions and changes (via a changelog) is an excellent
    way to provide some insight into new features and bug fixes. Versioning allows
    others to determine better what might work within a project.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 几个因素使软件打包成为项目中的重要特性（无论大小如何！）。通过变更日志跟踪版本和变更是提供新功能和错误修复洞察的好方法。版本化允许其他人更好地确定在项目内可能有效的工作内容。
- en: When trying to identify issues and bugs, a changelog with an accurate description
    of changes is an invaluable tool to help identify potential causes of system breakage.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试识别问题和错误时，一个准确描述变更的变更日志是帮助确定系统故障潜在原因的无价工具。
- en: It takes discipline and hard work to version a project, describe changes in
    a changelog, and provide a way for others to install and use a project. However,
    the benefits when distributing, debugging, upgrading, or even uninstalling are
    significant.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 版本化项目，描述变更在变更日志中，提供其他人安装和使用项目的方式，需要纪律和辛勤工作。然而，在分发、调试、升级甚至卸载时，好处显著。
- en: When Packaging Might Not Be Needed
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当不需要打包时
- en: Sometimes you don’t need to distribute a project to other systems at all. Ansible
    playbooks are usually run from one server to manage other systems in the network.
    In cases like Ansible, it might be enough to follow versioning and keep a changelog.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候根本不需要将项目分发给其他系统。Ansible Playbooks通常从一个服务器运行，以管理网络中的其他系统。在像Ansible这样的情况下，遵循版本控制并保持变更日志可能就足够了。
- en: Version control systems like Git make this easy with the use of tags. Tagging
    in Git would still be useful if a project does need to get packaged, since most
    tooling can consume the tag (as long as a tag represents a version) to produce
    a package.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 像Git这样的版本控制系统通过使用标签使这一切变得容易。在Git中标记仍然是有用的，如果项目确实需要进行打包，因为大多数工具可以使用标签（只要标签表示一个版本）来生成包。
- en: Recently, there was a long debug session to determine why an installer for a
    large software project had stopped working. Suddenly, all the functional tests
    for a small Python tool that depended on the installer completing its deployment
    were failing. The installer did have versions and kept those versions synchronized
    with version control, but there was no changelog whatsoever that would have explained
    that recent changes were going to break an existing API. To find the issue, we
    had to go through all the recent commits to determine what could be the problem.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，进行了一个长时间的调试会话，以确定为什么一个大型软件项目的安装程序停止工作。突然间，依赖于安装程序完成部署的一个小Python工具的所有功能测试都失败了。安装程序确实有版本，并且保持这些版本与版本控制同步，但却完全没有任何变更日志来解释最近的更改将会破坏现有的API。为了找出问题，我们不得不浏览所有最近的提交，以确定可能的问题所在。
- en: 'Going through a few commits shouldn’t be difficult, but try doing so on a project
    with more than four thousand commits! After finding the cause, two tickets were
    opened: one that explained the bug and another one to ask for a changelog.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览几个提交应该不难，但尝试在有四千多个提交的项目中做到这一点！找到问题后，开了两个票：一个解释了错误，另一个要求变更日志。
- en: Packaging Guidelines
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包指南
- en: Before packaging, a few things are worth considering so that the process is
    as smooth as possible. Even when you don’t plan to package a product, these guidelines
    help to improve a project overall.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在打包之前，有几件事情是值得考虑的，以使整个过程尽可能顺利。即使你不打算打包产品，这些指南也有助于改进项目的整体情况。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Projects in version control are always ready to be packaged.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制系统始终准备好进行打包。
- en: Descriptive Versioning
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述性版本控制
- en: There are many ways to version software, but it is a good idea to follow a well-known
    schema. The Python developer’s guide [has a clear definition](https://oreil.ly/C3YKO)
    for acceptable forms of versioning.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多版本软件的方法，但遵循一个知名模式是一个好主意。Python开发者指南对版本控制有一个清晰的定义。
- en: 'The versioning schema is meant to be extremely flexible, while keeping an eye
    on consistency so that installer tooling can make sense and prioritize accordingly
    (for example, a stable version over a beta one). In its purest form, and most
    commonly in Python packages, the following two variants are used: `major.minor`
    or `major.minor.micro`.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制模式应该非常灵活，同时要保持一致性，以便安装工具可以理解并相应地优先考虑（例如，稳定版本优于测试版本）。在其最纯粹的形式下，以及大多数Python包中，通常使用以下两种变体：`major.minor`
    或 `major.minor.micro`。
- en: 'Valid versions would then look like:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的版本看起来像：
- en: '`0.0.1`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0.0.1`'
- en: '`1.0`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1.0`'
- en: '`2.1.1`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2.1.1`'
- en: Note
  id: totrans-27
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Although there are many variations described by the excellent Python developer’s
    guide, concentrate on the simpler forms (listed above). They are good enough to
    produce packages, while adhering to most guidelines for both system and native
    Python packages.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Python开发者指南描述了许多变体，但集中在较简单的形式上（如上所列）。它们足以生成包，同时也遵循大多数系统和本地Python包的指南。
- en: 'A commonly accepted format for releases is `major.minor.micro` (and also used
    by the [Semantic Versioning scheme](https://semver.org)):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 发布的一个通常被接受的格式是 `major.minor.micro`（也被 [语义化版本控制](https://semver.org) 方案使用）：
- en: '`major` for backward-incompatible changes'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`major` 用于不兼容的更改。'
- en: '`minor` adds features that are also backward compatible'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minor` 添加了向后兼容的功能。'
- en: '`micro` adds backward-compatible bug fixes'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`micro` 添加了向后兼容的错误修复。'
- en: Following the listed versions above, you can deduce that a dependency on an
    application with version `1.0.0` might break with version `2.0.0`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上述列出的版本，您可以推断出对版本为 `1.0.0` 的应用程序的依赖性可能会在版本 `2.0.0` 中中断。
- en: 'Once the decision for a release occurs, then it is easy to determine the version
    number. Assuming the current released version of the project under development
    is `1.0.0`, it means the following outcomes are possible:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦做出发布决定，确定版本号就变得很容易。假设当前开发中项目的已发布版本为 `1.0.0`，这意味着可能出现以下结果：
- en: 'If the release has backward-incompatible changes, the version is: `2.0.0`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果发布具有向后不兼容的更改，则版本号为：`2.0.0`
- en: If the release has added features that do not break compatibility, the version
    is `1.1.0`
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果发布添加的功能不会破坏兼容性，则版本号为 `1.1.0`
- en: If the release is to fix issues that also do not break compatibility, the version
    is `1.0.1`
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果发布用于修复不会破坏兼容性的问题，则版本号为 `1.0.1`
- en: 'Once a schema is being followed, then a release process is immediately descriptive.
    Although it would be nice for all software to follow a similar pattern, some projects
    have a completely different schema of their own. For example, the [Ceph](https://ceph.com)
    project uses the following: `major.[0|1|2].minor`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦遵循了某个模式，发布过程立即变得清晰明了。尽管希望所有软件都遵循类似的模式，但一些项目有完全不同的自己的模式。例如，[Ceph](https://ceph.com)
    项目使用以下模式：`major.[0|1|2].minor`
- en: '`major` indicates a major release, while not necessarily breaking backward-compatibility.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`major` 表示一个主要发布版本，尽管不一定会破坏向后兼容性。'
- en: '`0`, `1`, or `2` mean (in order) development release, release candidate, or
    stable version.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`、`1` 或 `2` 分别表示开发版本、发布候选版或稳定版本。'
- en: '`minor` is used only for bug fixes and never for features.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minor` 仅用于修复错误，永远不用于功能添加。'
- en: That schema would mean that `14.0.0` is a development release, while `14.2.1`
    is a bug fix release for the stable version of the major release (`14` in this
    case).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式意味着 `14.0.0` 是一个开发版本，而 `14.2.1` 是主要发布版本（本例中为 `14`）的稳定版本修复版本。
- en: The changelog
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变更日志
- en: As we have mentioned already, it is important to keep track of releases and
    what they mean in the context of a version number. Keeping a changelog is not
    that difficult, once a versioning schema is chosen. Although it can be a single
    file, large projects tend to break it down into smaller files in a directory.
    Best practice is using a simple format that is descriptive and easy to maintain.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，重要的是要跟踪发布和它们在版本号上的含义。一旦选择了版本控制方案，保持变更日志并不难。虽然它可以是一个单一的文件，但大型项目倾向于将其拆分为一个目录中的多个小文件。最佳实践是使用简单且描述性强、易于维护的格式。
- en: 'The following example is an actual portion of a *changelog* file in a production
    Python tool:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子是生产中一个Python工具的*变更日志*文件的一个实际部分：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The example provides four essential pieces of information:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例提供了四个重要的信息：
- en: The latest version number released
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最新发布的版本号
- en: Whether the latest release is backward compatible
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最新版本是否向后兼容
- en: The release date of the last version
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上一个版本的发布日期
- en: Changes included in the release
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含在发布中的变更
- en: 'The file doesn’t need to be of a specific format, as long as it is consistent
    and informative. A proper changelog can provide several pieces of information
    with little effort. It is tempting to try and automate the task of writing a changelog
    with every release, but we would advise against a fully automated process: nothing
    beats a well-written, thoughtful entry about a bug fix or a feature added.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件不需要特定的格式，只要保持一致性和信息性即可。一个合适的变更日志可以在很少的工作量下提供多个信息。尝试自动化写每个发布的变更日志的任务虽然诱人，但我们建议不要完全自动化处理：没有什么能比一个精心编写的关于修复错误或添加功能的条目更好。
- en: A poorly automated changelog is one that uses all the version control commits
    included in the release. This is not a good practice, since you can get the same
    information by listing the commits.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个质量不佳的自动化变更日志是使用所有版本控制提交的变更。这不是一个好的做法，因为你可以通过列出提交来获得相同的信息。
- en: Choosing a Strategy
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择策略
- en: Understanding the type of distribution needed and what infrastructure services
    are available helps determine what type of packaging to use. Pure Python libraries
    that extend functionality for other Python projects are suitable as a native Python
    package, hosted on the Python Package Index (PyPI) or a local index.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 理解所需的分发类型和可用的基础设施服务有助于确定使用何种类型的打包。为其他Python项目扩展功能的纯Python库适合作为本地Python包，托管在Python软件包索引（PyPI）或本地索引上。
- en: Standalone scripts and long-running processes are good candidates for system
    packages like RPM or Debian, but ultimately, it depends on what type of systems
    are available and if it is at all possible to host (and manage) a repository.
    In the case of long-running processes, the packaging can have rules to configure
    a `systemd` unit that makes it available as a controllable process. `systemd`
    allows for the graceful handling of start, stop, or restart operations. These
    are things that aren’t possible with native Python packaging.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 独立脚本和长时间运行的进程是系统软件包（如RPM或Debian）的良好候选者，但最终取决于可用的系统类型以及是否可能托管（和管理）存储库。对于长时间运行的进程，打包可以有规则来配置`systemd`单元，使其作为可控制的进程可用。`systemd`允许优雅地处理启动、停止或重启操作。这些是使用本地Python打包无法实现的功能。
- en: In general, the more a script or process needs to interact with a system, the
    better it is suited to a system package or a container. When writing a Python-only
    script, conventional Python packaging is the right choice.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，脚本或进程需要与系统交互得越多，就越适合系统软件包或容器。在编写仅限Python的脚本时，传统的Python打包是正确的选择。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There aren’t hard requirements on what strategy to choose. It depends! Pick
    the best environment available for distribution (RPM if the servers are CentOS,
    for example). Different types of packaging are not mutually exclusive; one project
    can offer multiple packaging formats at the same time.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 没有硬性要求选择哪种策略。这取决于情况！选择最适合分发的环境（例如，如果服务器是CentOS，则选择RPM）。不同类型的打包并不是互斥的；一个项目可以同时提供多种打包格式。
- en: Packaging Solutions
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包解决方案
- en: In this section, the details on how to create a package and host it are covered.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍如何创建软件包并进行托管的详细信息。
- en: 'To simplify the code examples, assume a small Python project called `hello-world`
    with the following structure:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为简化代码示例，假设一个名为`hello-world`的小型Python项目具有以下结构：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The project has a top-level directory called `hello-world` and a subdirectory
    (`hello_world`) with two files in it. Depending on the packaging choice, different
    files are needed to create a package.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 项目有一个名为`hello-world`的顶层目录和一个子目录（`hello_world`），其中包含两个文件。根据打包选择的不同，需要不同的文件来创建软件包。
- en: Native Python Packaging
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地Python打包
- en: By far the simplest solution is using the native Python packaging tooling and
    hosting (via PyPI). Like the rest of the other packaging strategies, the project
    requires some files used by `setuptools`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，使用本地Python打包工具和托管（通过PyPI）是最简单的解决方案。与其他打包策略一样，该项目需要一些`setuptools`使用的文件。
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'One easy way to source a virtual environment is to create a `bash` or `zsh`
    alias that both cd’s into the directory and sources the environment, like this:
    `alias sugar="source ~/.sugar/bin/activate && cd ~/src/sugar"`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的方法来获取虚拟环境是创建一个`bash`或`zsh`的别名，它会cd到目录并激活环境，就像这样：`alias sugar="source ~/.sugar/bin/activate
    && cd ~/src/sugar"`
- en: 'To continue, create a new virtual environment and then activate:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要继续，请创建一个新的虚拟环境，然后激活：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-71
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`setuptools` is a requirement to produce a native Python package. It is a collection
    of tools and helpers to create and distribute Python packages.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`setuptools`是生成本地Python软件包的要求。它是一组工具和助手，用于创建和分发Python软件包。'
- en: 'Once the virtual environment is active, the following dependencies exist:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦虚拟环境激活，存在以下依赖关系：
- en: '`setuptools`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`setuptools`'
- en: A set of utilities for packaging
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一组用于打包的实用工具
- en: '`twine`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`twine`'
- en: A tool for registering and uploading packages
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于注册和上传软件包的工具
- en: 'Install them by running the following command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令来安装它们：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'A very easy way to figure out what is installed is to use `IPython` and this
    snippet to list all of the Python packages as a `JSON` data structure:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找已安装内容的一个非常简单的方法是使用`IPython`和以下代码片段，将所有Python软件包列出为`JSON`数据结构：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Package files
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 软件包文件
- en: 'To produce the native Python package, we have to add a few files. To keep things
    simple, focus on the minimum amount of files needed to produce the package. The
    file that describes the package to `setuptools` is named *setup.py*. It exists
    at the top-level directory. For the example project, this is how that file looks:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成本地Python软件包，我们必须添加一些文件。为了保持简单，专注于生成软件包所需的最少文件。描述软件包给`setuptools`的文件名为*setup.py*，位于顶层目录。对于示例项目，文件看起来是这样的：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The *setup.py* file will import two helpers from the `setuptools` module: `setup`
    and `find_packages`. The `setup` function is what requires the rich description
    about the package. The `find_packages` function is a utility to automatically
    detect where the Python files are. Additionally, the file imports `classifiers`
    that describe certain aspects of the package, such as the license, operating systems
    supported, and Python versions. These *classifiers* are called *trove classifiers*,
    and the [Python Package Index](https://pypi.org/classifiers) has a detailed description
    of other classifiers available. Detailed descriptions make a package get discovered
    when uploaded to PyPI.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*setup.py*文件将从`setuptools`模块导入两个助手：`setup`和`find_packages`。`setup`函数需要关于软件包的详细描述。`find_packages`函数是一个实用工具，用于自动检测Python文件的位置。此外，该文件导入了描述软件包特定方面的*classifiers*，如许可证、支持的操作系统和Python版本。这些*classifiers*称为*trove
    classifiers*，在[Python包索引](https://pypi.org/classifiers)上有关于其他可用分类器的详细描述。详细描述有助于软件包上传到PyPI后被发现。'
- en: 'With just the addition of this one file, we can already produce a package,
    in this case, a *source distribution* package. Without a *README* file, a warning
    appears when running the commands. To prevent this, add an empty one in the top-level
    directory with the command: `touch README`.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 只需添加这一个文件，我们就能够生成一个软件包，这种情况下是*源分发*软件包。如果没有*README*文件，在运行命令时会出现警告。为了防止这种情况，请使用以下命令在顶级目录中添加一个空的*README*文件：`touch
    README`。
- en: 'The contents of the project directory should look like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 项目目录的内容应该如下所示：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To produce the *source distribution* from it, run the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要从中生成*源分发*，请运行以下命令：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output should look similar to the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At the top-level directory of the project, a new directory called *dist* is
    there; it contains the *source distribution*: a file *hello-world-0.0.1.tar.gz*.
    If we check the contents of the directory, it has changed once again:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的顶级目录，有一个名为*dist*的新目录；它包含*源分发*：一个名为*hello-world-0.0.1.tar.gz*的文件。如果我们检查目录的内容，它已经再次改变：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The newly created *tar.gz* file is an installable package! This package can
    now be uploaded to PyPI for others to install directly from it. By following the
    version schema, it allows installers to ask for a specific version (`0.0.1` in
    this case), and the extra metadata passed into the `setup()` function enables
    other tools to discover it and show information about it, such as the author,
    description, and version.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的*tar.gz*文件是一个可安装的软件包！现在可以将此软件包上传到PyPI，以便其他人直接从中安装。通过遵循版本模式，安装程序可以请求特定版本（在本例中为`0.0.1`），并且通过传递给`setup()`函数的额外元数据，其他工具可以发现它并显示关于它的信息，如作者、描述和版本。
- en: 'The Python installer tool `pip` can be used to install the *tar.gz* file directly.
    To try it out, use the path to the file as an argument:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Python安装工具`pip`可以直接用于安装*tar.gz*文件。要试试，请使用文件路径作为参数：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The Python Package Index
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python包索引
- en: The Python Package Index (PyPI) is a repository of Python software that allows
    users to host Python packages and also install from it. It is maintained by and
    for the community with the help of sponsors and donations as part of the [Python
    Software Foundation](https://www.python.org/psf).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Python包索引（PyPI）是一个Python软件的仓库，允许用户托管Python软件包并从中安装。它由社区维护，并在[Python软件基金会](https://www.python.org/psf)的赞助和捐款下运行。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This section requires registration for the *test instance* of PyPI. Make sure
    you have an account already or [register online](https://oreil.ly/lyVVx). You
    need your username and password for the account to upload packages.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分需要为PyPI的*测试实例*注册。确保您已经有了账户或者[在线注册](https://oreil.ly/lyVVx)。您需要账户的用户名和密码来上传软件包。
- en: In the sample *setup.py* file, an example email address contains a placeholder.
    If the package is going to get published to the index, this needs to be updated
    to reflect the same email address that owns the project at PyPI. Update any other
    fields, like the `author`, `url`, and `description`, to more accurately reflect
    the project being built.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例的*setup.py*文件中，示例电子邮件地址包含一个占位符。如果要将软件包发布到索引，需要更新为与PyPI项目所有者相同的电子邮件地址。更新其他字段，如`author`，`url`和`description`，以更准确地反映正在构建的项目。
- en: To make sure things work correctly, and to avoid *pushing to production*, the
    package is tested by uploading it to the test instance of PyPI. This test instance
    behaves the same as production and verifies that a package works correctly.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保一切正常运作，并且避免*推向生产*，通过将包上传到 PyPI 的测试实例来测试包。这个测试实例的行为与生产环境相同，并验证包的正确功能。
- en: The `setuptools` and the *setup.py* file is the traditional method of uploading
    a package to PyPI. A new approach, called `twine`, can simplify things.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`setuptools` 和 *setup.py* 文件是将包上传到 PyPI 的传统方法。一种新方法叫做 `twine`，可以简化操作。'
- en: 'At the beginning of this section, `twine` got installed in the virtual environment.
    Next, it can be used to upload the package to the test instance of PyPI. The following
    command uploads the *tar.gz* file and prompts for the username and password:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节开始时，`twine` 已安装在虚拟环境中。接下来，可以使用它将包上传到 PyPI 的测试实例。以下命令上传 *tar.gz* 文件，并提示输入用户名和密码：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To test out whether the package made it, we can try and install it with `pip`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试包是否安装成功，我们可以尝试使用 `pip` 安装它：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The command looks like it has a space in the PyPI URL, but the index URL ends
    in `/simple/`, and `hello-world` is another argument that indicates the name of
    the Python package to be installed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 命令看起来在 PyPI URL 中有一个空格，但索引 URL 以 `/simple/` 结尾，并且 `hello-world` 是另一个参数，指示要安装的
    Python 包的名称。
- en: For an actual production release, an account would need to exist or be [created](https://pypi.org/account/register).
    The same steps that are taken to upload to the test instance, including the validation,
    would also work for the *real* PyPI.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实际的生产发布，需要存在一个帐户或[创建](https://pypi.org/account/register)一个帐户。与上传到测试实例相同的步骤，包括验证，也适用于*真实*的
    PyPI。
- en: 'Older Python packaging guides may reference commands such as:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 较旧的 Python 打包指南可能会提到如下命令：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These may still work and are part of the `setuptools` set of utilities to package
    and upload projects to a package index. However, `twine` offers secure authentication
    over HTTPS, and allows signing with `gpg`. Twine works regardless if `python setup.py
    upload` doesn’t, and finally, it provides a way to test a package before uploading
    to the index.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法仍然有效，并且是 `setuptools` 一套工具中的一部分，用于打包并上传项目到包索引中。然而，`twine` 提供了通过 HTTPS 进行安全认证，并支持使用
    `gpg` 签名。Twine 可以工作，即使 `python setup.py upload` 无法工作，并最终提供了在上传到索引之前测试包的方法。
- en: 'A final item to point out is that it may be helpful to create a `Makefile`
    and put a `make` command in it that automatically deploys your project and builds
    the documentation for you. Here is an example of how that could work:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要指出的一点是，创建一个 `Makefile` 并在其中放入一个 `make` 命令可能会有所帮助，自动部署项目并为您构建文档。以下是一个示例：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Hosting an internal package index
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 托管内部包索引
- en: In some situations, it might be preferable to host an internal PyPI.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，托管内部 PyPI 可能更可取。
- en: A company where Alfredo used to work had private libraries that were not supposed
    to be public at all, so it was a requirement to host an instance of PyPI. Hosting
    has its caveats, though. All dependencies and versions of those dependencies have
    to exist in the instance; otherwise, installs can fail. An installer can’t fetch
    dependencies from different sources at the same time! On more than one occasion,
    a new version had a missing component, so that package had to be uploaded for
    the install to complete correctly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Alfredo 曾经工作的公司拥有不应公开的私有库，因此必须托管一个 PyPI 实例是一个要求。然而，托管也有其注意事项。所有依赖项及其版本都必须存在于实例中；否则，安装可能会失败。安装程序无法同时从不同来源获取依赖项！不止一次，新版本缺少组件，因此必须上传该包以完成正确的安装。
- en: If package *A* is hosted internally and has requirements on packages *B* and
    *C*, all three need to exist (along with their required versions) in the same
    instance.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果包 *A* 托管在内部，并且依赖于包 *B* 和 *C*，那么所有这三个包（及其所需版本）都需要在同一个实例中存在。
- en: An internal PyPI makes installations go faster, can keep packages private, and
    at its core, isn’t challenging to accomplish.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 内部 PyPI 可以加快安装速度，可以保持包的私密性，并且从本质上来说，并不难实现。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A highly recommended full-featured tool for hosting an internal PyPI is `devpi`.
    It has features like mirroring, staging, replication, and Jenkins integration.
    The [project documentation](http://doc.devpi.net) has great examples and detailed
    information.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个强烈推荐的用于托管内部 PyPI 的功能全面的工具是 `devpi`。它具有镜像、分段、复制和 Jenkins 集成等功能。[项目文档](http://doc.devpi.net)提供了很好的示例和详细信息。
- en: 'First, create a new directory called `pypi` so that you can create a proper
    structure for hosting packages, and then create a subdirectory with the name of
    our example package (`hello-world`). The names of subdirectories are the names
    of the packages themselves:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`pypi`的新目录，以便可以创建一个适合托管包的正确结构，然后创建一个名为我们示例包（`hello-world`）的子目录。子目录的名称即是包的名称：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now copy the *tar.gz* file into the *hello-world* directory. The final version
    of this directory structure should look like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将*tar.gz*文件复制到*hello-world*目录中。该目录结构的最终版本应如下所示：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The next step is to create a web server with auto indexing enabled. Python
    comes with a built-in web server that is good enough to try this out, and it even
    has the auto indexing enabled by default! Change directories to the *pypi* directory
    containing the `hello-world` package and start the built-in web server:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个启用了自动索引的Web服务器。Python自带一个内置的Web服务器，足以尝试这一功能，并且默认情况下已启用自动索引！切换到包含`hello-world`包的*pypi*目录，并启动内置的Web服务器：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In a new terminal session, create a temporary virtual environment to try out
    installing the `hello-world` package from the local PyPI instance. Activate it,
    and finally, try installing it by pointing `pip` to the custom local URL:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的终端会话中，创建一个临时虚拟环境，以尝试从本地PyPI实例安装`hello-world`包。激活它，最后通过将`pip`指向自定义本地URL来尝试安装它：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the session where the `http.server` module is running, there should be some
    logs demonstrating all the requests the installer made to retrieve the `hello-world`
    package:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`http.server`模块的会话中，应该有一些日志，展示安装程序为检索`hello-world`包所做的所有请求：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A production environment needs a better-performing web server. The `http.server`
    module is used in this example for simplicity, but it isn’t meant to handle simultaneous
    multiple requests or scaling out.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 生产环境需要一个性能更好的Web服务器。在这个例子中，为了简单起见，使用`http.server`模块，但它不能处理同时的多个请求或扩展。
- en: Tip
  id: totrans-135
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: When building a local index without a tool like `devpi`, there is a defined
    specification that includes descriptions of normalized names for the directory
    structure. This specification can be found in [PEP 503](https://oreil.ly/sRcAe).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有像`devpi`这样的工具的情况下构建本地索引时，有一个定义明确的规范，其中包括规范化名称的目录结构描述。此规范可以在[PEP 503](https://oreil.ly/sRcAe)中找到。
- en: Debian Packaging
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Debian打包
- en: If targetting Debian (or a Debian-based distribution such as Ubuntu) for distributing
    a project, additional files are required. Understanding what these files are and
    how the Debian packaging tools use them improves the process of producing an installable
    `.deb` package and troubleshooting issues.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标是Debian（或基于Debian的发行版，如Ubuntu）来分发项目，则需要额外的文件。了解这些文件是什么，以及Debian打包工具如何使用它们，可以改善生成可安装的`.deb`软件包和解决问题的过程。
- en: Some of these plain-text files require a *very* strict formatting, and if the
    format is even slightly incorrect, the packaging cannot install.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一些这些纯文本文件需要非常严格的格式，如果格式稍有不正确，打包将无法安装。
- en: Note
  id: totrans-140
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This section assumes the packaging is in a Debian or Debian-based distro, so
    that it is easier to install and use the required packaging tools.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本节假设打包是在Debian或基于Debian的发行版中进行的，因此更容易安装和使用所需的打包工具。
- en: Package files
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包文件
- en: Debian packaging needs a *debian* directory with a few files in it. To narrow
    the scope of what is needed to produce a package, most of the available options
    are skipped, such as running a test suite before completing a build or declaring
    multiple Python versions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Debian打包需要一个包含几个文件的*debian*目录。为了缩小生成软件包所需内容的范围，大部分可用选项被跳过，例如在完成构建之前运行测试套件或声明多个Python版本。
- en: 'Create the *debian* directory where all required files exist. In the end, the
    `hello-world` project structure should look like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 创建*debian*目录，其中包含所有必需的文件。最终，`hello-world`项目结构应如下所示：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-146
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the directory includes the *setup.py* and *README* file from the native
    Python packaging section. It is required because Debian tooling uses these to
    produce the `.deb` package.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意该目录包括本地Python打包部分的*setup.py*和*README*文件。这是必需的，因为Debian工具使用它们来生成`.deb`软件包。
- en: The changelog file
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 变更日志文件
- en: This file can be complicated to get right if done by hand. The errors produced
    when this file is not formatted correctly are not easy to debug. Most Debian packaging
    workflows rely on the `dch` tool to enhance debuggability.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果手动操作这个文件会很复杂。当文件格式不正确时产生的错误不容易调试。大多数 Debian 打包工作流依赖于`dch`工具来增强调试能力。
- en: 'I’ve ignored my advice before and have tried to manually create this file.
    In the end I wasted time because error reporting is not very good, and spotting
    issues is very difficult. Below is an example of an entry in the *changelog* file
    that caused a problem:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前忽略了我的建议，试图手动创建这个文件。最后我浪费了时间，因为错误报告不是很好，而且很难发现问题。以下是在 *changelog* 文件中导致问题的条目示例：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'That entry produced the following error:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 出现以下错误：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Can you spot the fix?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你能找到解决方法吗？
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A *space* between the dashes and my name was the cause. Save yourself the heartache
    and use `dch`. The tool is part of the `devscripts` package:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在破折号和我的名字之间有一个空格是问题的根源。避免自己的麻烦，使用`dch`。该工具是`devscripts`软件包的一部分：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `dch` command-line tool has many options, and it is useful to go through
    its documentation (the main page is comprehensive). We are going to run it to
    create the changelog for the first time (this requires the one-time use of the
    `--create` flag). Before running it, export your full name and email so that they
    get into the generated file:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`dch`命令行工具有很多选项，通过阅读其文档（主页内容详尽）会很有帮助。我们将运行它来首次创建变更日志（这需要一次性使用`--create`标志）。在运行之前，请导出您的全名和电子邮件，以便它们出现在生成的文件中：'
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now run `dch` to produce the changelog:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行`dch`以生成变更日志：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The newly created file should look similar to this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的文件应该类似于这样：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The Debian changelog is specific to Debian packaging. It is fine to have a separate
    changelog for the project when the format doesn’t fit or if other information
    needs updating. Lots of projects keep the Debian *changelog* file as a separate
    Debian-only file.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Debian 变更日志是专用于 Debian 打包的。当格式不符或需要更新其他信息时，项目可以单独保留一个变更日志。许多项目将 Debian 的 *changelog*
    文件作为单独的 Debian 专用文件。
- en: The control file
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 控制文件
- en: This is the file that defines the package name, its description, and any dependencies
    needed for building and running the project. It also has a strict format, but
    it doesn’t need to change much (unlike the *changelog*). The file ensures that
    Python 3 is required and that it follows Debian’s Python naming guidelines.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件定义了软件包的名称、描述以及构建和运行项目所需的任何依赖项。它也有严格的格式，但不需要经常更改（不像 *changelog*）。该文件确保需要
    Python 3 并遵循 Debian 的 Python 命名指南。
- en: Note
  id: totrans-168
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'In the transition from Python 2 to Python 3, most distributions settled on
    using the following schema for Python 3 packages: `python3-{package name}`.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在从 Python 2 迁移到 Python 3 的过渡中，大多数发行版都采用了以下用于 Python 3 软件包的模式：`python3-{package
    name}`。
- en: 'After adding the dependencies, naming conventions, and a short description,
    this is how the file should look:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 添加依赖项、命名约定和简短描述后，文件应如下所示：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Other required files
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他必需的文件
- en: There are a few other files needed to produce a Debian package. Most of them
    are just a couple of lines long and change infrequently.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要一些其他文件来生成 Debian 软件包。它们大多数只有几行，并且不经常更改。
- en: 'The *rules* file is an executable file that tells Debian what to run to produce
    the package; in this case it should look like the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*rules*文件是一个可执行文件，告诉 Debian 如何运行以生成软件包；在这种情况下，应如下所示：'
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The *compat* file sets the corresponding `debhelper` (another packaging tool)
    compatibility, recommended to be set to `10` here. You might check to see whether
    a higher value is required if an error message complains about it:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*compat* 文件设置对应的 `debhelper`（另一个打包工具）兼容性，推荐在这里设置为 `10`。如果出现错误消息指出需要更高的值，您可能需要检查是否需要更高版本：'
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Without a license, the build process might not work, and it is a good idea
    to state the license explicitly. This particular example uses the MIT license,
    and this is how it should look in *debian/copyright*:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少许可证可能会导致构建过程无法工作，明确声明许可证是个好主意。此特定示例使用 MIT 许可证，应在 *debian/copyright* 中如下所示：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, after adding all these new files to the `debian` directory, the `hello-world`
    project looks like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在将所有这些新文件添加到`debian`目录之后，`hello-world`项目如下所示：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Producing the binary
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成二进制文件
- en: 'To produce the binary, use the `debuild` command-line tool. For this example
    project, the package remains unsigned (the signing process requires a GPG key),
    and the `debuild` documentation uses an example that allows skipping the signing.
    The script is run from inside the source tree to build only the binary package.
    This command works for the `hello-world` project (truncated version shown here):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成二进制文件，请使用 `debuild` 命令行工具。对于此示例项目，包仍未签名（签名过程需要 GPG 密钥），并且 `debuild` 文档使用的示例允许跳过签名。从源代码树内部运行该脚本以仅构建二进制包。此命令适用于
    `hello-world` 项目（此处显示了截断版本）：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: A *python3-hello-world_0.0.1_all.deb* should now exist in the upper directory.
    The lintian call (a Debian packaging linter) complains at the very end that the
    *changelog* file has an invalid distribution, which is fine because we aren’t
    targeting a single distribution in particular (for example, Debian Buster). Rather,
    we are building a package that will most likely install in any Debian-base distro
    that complies with the dependencies (only Python 3, in this case).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在上层目录应该存在一个名为 *python3-hello-world_0.0.1_all.deb* 的文件。lintian 调用（一个 Debian
    打包工具）在最后报告 *changelog* 文件的发行版本无效，这没关系，因为我们不是针对特定的单个发行版（例如 Debian Buster）。相反，我们正在构建一个包，它很可能在任何符合依赖关系（仅
    Python 3，在本例中）的 Debian 基础发行版上安装。
- en: Debian repositories
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Debian 仓库
- en: 'There are many tools to automate Debian repositories, but it is useful to understand
    how to go about creating one (Alfredo even helped [develop one](https://oreil.ly/hJMgY)
    for both RPM and Debian!). To continue, ensure that the binary package created
    previously is available at a known location:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可以自动化管理 Debian 仓库，但了解如何创建一个是很有用的（阿尔弗雷多甚至帮助[开发了一个](https://oreil.ly/hJMgY)，适用于
    RPM 和 Debian！）。继续之前，请确保之前创建的二进制包在已知位置可用：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'For this section, the `reprepro` tool needs to be installed:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一部分，需要安装 `reprepro` 工具：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create a new directory somewhere in the system to hold packages. This example
    uses */opt/repo*. The basic configuration for a repository needs a file, called
    `distributions`, that describes the contents and looks like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统的某个位置创建一个新目录以保存包。此示例使用 */opt/repo*。仓库的基本配置需要一个名为 `distributions` 的文件，描述其内容并如下所示：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Save this file at */opt/repo/conf/distributions*. Create another directory
    to hold the actual repo:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存在 */opt/repo/conf/distributions*。创建另一个目录来保存实际的仓库：
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To create the repository, instruct `reprepro` to use the *distributions* file
    created, and that the base directory is */opt/repo/debian/sid*. Finally, add the
    binary previously created as a target for the Debian sid distribution:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建仓库，请指示 `reprepro` 使用先前创建的 *distributions* 文件，并指定基本目录为 */opt/repo/debian/sid*。最后，将之前创建的二进制文件添加为
    Debian sid 发行版的目标：
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This command creates the repo for the Debian sid distribution! This command
    can be adapted for a different Debian-based distribution such as Ubuntu Bionic,
    for example. To do so would only require replacing `sid` with `bionic`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令为 Debian sid 发行版创建了仓库！这个命令可以用于不同的基于 Debian 的发行版，如 Ubuntu Bionic。要做到这一点，只需将
    `sid` 替换为 `bionic`。
- en: 'Now that the repo exists, the next step is to ensure that it works as expected.
    For a production environment, a robust web server like Apache or Nginx would be
    a good choice, but to test this, use Python’s `http.server` module. Change directories
    to the directory containing the repository, and start the server:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在仓库已创建，下一步是确保其按预期工作。在生产环境中，像 Apache 或 Nginx 这样的稳健 Web 服务器是一个不错的选择，但为了测试，请使用
    Python 的 `http.server` 模块。切换到包含仓库的目录，并启动服务器：
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Aptitude (or `apt`, the Debian package manager) needs some configuration to
    be aware of this new location for packages. This configuration is a simple file
    with a single line in it pointing to the URL and components of our repo. Create
    a file at */etc/apt/sources.lists.d/hello-world.list*. It should look like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Aptitude（或 `apt`，Debian 包管理器）需要一些配置来知道包的新位置。这个配置是一个简单的文件，其中只有一行指向我们仓库的 URL 和组件。在
    */etc/apt/sources.lists.d/hello-world.list* 创建一个文件，应如下所示：
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `[trusted=yes]` configuration tells `apt` not to enforce signed packages.
    On repositories that are properly signed, this step is not necessary.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`[trusted=yes]` 配置告诉 `apt` 不强制要求已签名的包。在正确签名的仓库上，这一步骤是不必要的。'
- en: 'After adding the file, update `apt` so that it recognizes the new location,
    and look for (and install) the `hello-world` package:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 添加文件后，请更新 `apt` 以使其识别新位置，并查找（并安装）`hello-world` 包：
- en: '[PRE41]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Searching for the `python3-hello-world` package provides the description added
    in the *distributions* file when configuring `reprepro`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索 `python3-hello-world` 软件包提供在配置 `reprepro` 时添加到 *distributions* 文件的描述：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Installing and removing the package should work without a problem:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 安装和删除软件包应该没有问题：
- en: '[PRE43]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: RPM Packaging
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RPM 打包
- en: 'Just as with Debian packaging, when working in RPM, it is necessary to have
    the native Python packaging done already. It should be possible to produce a Python
    package with a *setup.py* file. However, very unlike Debian, in which many files
    are needed, RPM packaging can work with just one: the *spec* file. If targeting
    a distribution like CentOS or Fedora, the RPM Package Manager (formerly known
    as Red Hat Package Manager) is the way to go.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 Debian 打包时一样，在 RPM 中工作时，必须已经完成本地 Python 打包。应该可以使用 *setup.py* 文件生成 Python
    软件包。然而，与 Debian 不同的是，RPM 打包只需一个文件即可：*spec* 文件。如果目标是像 CentOS 或 Fedora 这样的发行版，那么
    RPM 软件包管理器（前身是 Red Hat 软件包管理器）是最佳选择。
- en: The spec file
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规范文件
- en: 'In its simplest form, the *spec* file (named *hello-world.spec* for this example)
    is not difficult to understand, and most sections are self-explanatory. It can
    even be generated by using `setuptools`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，*spec* 文件（本示例中命名为 *hello-world.spec*）并不难理解，大多数部分都是不言自明的。甚至可以通过使用 `setuptools`
    来生成它：
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output file in *dist/hello-world.spec* should look similar to this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*dist/hello-world.spec* 输出文件应该类似于这样：'
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Although it looks simple, it is already creating a potential issue: the version
    is input and requires updating every time. This process is similar to Debian’s
    *changelog* file, which needs to have the version *bumped* on each release.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管看起来很简单，但已经存在潜在问题：版本是
- en: The `setuptools` integration is advantageous, allows further modification to
    this file if needed, and copies to the root directory of the project for a permanent
    location. Some projects use a base template that gets populated to generate the
    spec file as part of the build process. This process is useful if following a
    rigorous release workflow. In the case of the [Ceph project](https://ceph.com),
    the release is tagged via version control (Git), and the release scripts use that
    tag to apply it to the template via a `Makefile`. It is worth noting that additional
    methods exist to automate this process further.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`set   `setuptools` 的集成非常有利，允许进一步修改该文件（如果需要），并将其复制到项目的根目录以便永久存放。一些项目使用基础模板，在构建过程中用填充方式生成规范文件。如果遵循严格的发布工作流程，这个过程非常有用。在
    [Ceph 项目](https://ceph.com) 的情况下，通过版本控制（Git）标记发布，并使用标签在 `Makefile` 中应用于模板。值得注意的是，还存在其他方法可以进一步自动化这个过程。'
- en: Tip
  id: totrans-218
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Generating a *spec* file is not always useful, because certain sections might
    need to be hardcoded to follow some distribution rule or a specific dependency
    that is not part of the generated file. In such cases, it is best to generate
    it once and configure it further to finally save it and make the *spec* file a
    formal part of the project.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 生成 *spec* 文件并不总是有用，因为某些部分可能需要硬编码以遵循某些发行规则或特定依赖项，这些依赖项不在生成的文件中。在这种情况下，最好生成一次，进一步配置并最终保存它，使
    *spec* 文件成为项目的正式一部分。
- en: Producing the binary
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成二进制文件
- en: 'There are a few different tools to produce RPM binaries; one in particular
    is the `rpmbuild` command-line tool:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种不同的工具可以生成 RPM 二进制文件；其中一种特别的工具是 `rpmbuild` 命令行工具：
- en: '[PRE46]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-223
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The command-line tool is `rpmbuild` but the package is called `rpm-build`, so
    make sure that `rpmbuild` (the command-line tool) is available in the terminal.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行工具是 `rpmbuild`，但软件包名是 `rpm-build`，因此请确保在终端中可用 `rpmbuild`（命令行工具）。
- en: 'A directory structure is required by `rpmbuild` to create the binary. After
    the directories are created, the *source* file (the *tar.gz* file generated by
    `setuptools`) needs to be present in the *SOURCES* directory. This is how the
    structure should be created and how it will look once it is done:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`rpmbuild` 需要一个目录结构来创建二进制文件。在创建这些目录之后，*source* 文件（由 `setuptools` 生成的 *tar.gz*
    文件）需要存在于 *SOURCES* 目录中。这就是应该创建的结构以及完成后的样子：'
- en: '[PRE47]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The directory structure is always needed, and by default, `rpmbuild` requires
    it in the home directory. To keep things isolated, a different location (in */opt/repo/centos*)
    is used. This process means configure `rpmbuild` uses this directory instead.
    This process produces both a binary and a *source* package with the `-ba` flag
    (output is abbreviated):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 目录结构始终是必需的，默认情况下，`rpmbuild`需要在主目录中。为了保持隔离，使用不同位置（在*/opt/repo/centos*中）。这个过程意味着配置`rpmbuild`使用此目录代替。此过程使用`-ba`标志生成二进制和*源*软件包（输出已缩写）：
- en: '[PRE48]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The directory structure at */opt/repo/centos* will have lots of new files,
    but we are only interested in the one that has the `noarch` RPM:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在*/opt/repo/centos*的目录结构将有许多新文件，但我们只对具有`noarch` RPM的文件感兴趣：
- en: '[PRE49]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `noarch` RPM is an installable RPM package! The tool produced other useful
    packages that can be published as well (look at */opt/repo/centos/SRPMS*, for
    example).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`noarch` RPM是一个可安装的RPM包！该工具还生成了其他有用的可以发布的软件包（例如查看*/opt/repo/centos/SRPMS*）。'
- en: RPM repositories
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RPM存储库
- en: 'To create an RPM repository, use the `createrepo` command-line tool. It handles
    the creation of the repository metadata (XML-based RPM metadata) from the binaries
    it finds in a given directory. In this section, create (and host) the `noarch`
    binary:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建RPM存储库，请使用`createrepo`命令行工具。它从给定目录中找到的二进制文件生成存储库元数据（基于XML的RPM元数据）。在此部分中，创建（并托管）`noarch`二进制文件：
- en: '[PRE50]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can create the repository in the same location used to produce the `noarch`
    package, or use a new (clean) directory. Create new binaries if needed. Once that
    is completed, the package copies:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成`noarch`包的相同位置创建存储库，或者使用新的（干净的）目录。如有必要，创建新的二进制文件。一旦完成，包括如下内容：
- en: '[PRE51]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To create the metadata, run the `createrepo` tool:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建元数据，请运行`createrepo`工具：
- en: '[PRE52]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Although an `x86_64` package does not exist, repeat the `createrepo` call for
    this new directory so that `yum` doesn’t complain about it later:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不存在`x86_64`包，但为了避免`yum`后续投诉，重复对此新目录调用`createrepo`：
- en: '[PRE53]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We are going to use the `http.server` module to serve this directory over HTTP:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`http.server`模块通过HTTP提供此目录的服务：
- en: '[PRE54]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To access this repository, `yum` needs to be configured with a *repo file*.
    Create one at */etc/yum.repos.d/hello-world.repo*. It should look like this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此存储库，`yum`需要配置*repo文件*。在*/etc/yum.repos.d/hello-world.repo*创建一个。它应该如下所示：
- en: '[PRE55]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Note how the `gpgcheck` value is `0`. This means we haven’t signed any packages
    and `yum` should not try to verify a signature, preventing a failure in this example.
    Searching for the package should now be possible, giving us the description as
    part of the output:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`gpgcheck`值为`0`。这表示我们尚未签署任何软件包，`yum`不应尝试验证签名，以防止此示例中的故障。现在应该可以搜索软件包，并在输出的一部分中获取描述：
- en: '[PRE56]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The search function works correctly; installing the package should work as
    well:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索功能正常工作；安装软件包也应正常工作：
- en: '[PRE57]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Removing has to work as well:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 移除也必须正常工作：
- en: '[PRE58]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `http.server` module should display some activity, demonstrating that `yum`
    was reaching out to get the `hello-world` package:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.server`模块应显示一些活动，证明`yum`正在获取`hello-world`包：'
- en: '[PRE59]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Management with systemd
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用systemd进行管理
- en: '`systemd` is a *system and service manager* for Linux (also known as *init
    system*). It is the default init system for many distributions, such as Debian
    and Red Hat. Here are some of the many features `systemd` provides:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemd`是Linux的*系统和服务管理器*（也称为*init系统*）。它是许多发行版的默认init系统，如Debian和Red Hat。以下是`systemd`提供的众多功能之一：'
- en: Easy parallelization
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单并行化
- en: Hooks and triggers for on-demand behavior
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 钩子和触发器用于按需行为
- en: Logging integration
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志集成
- en: Ability to depend on other units for orchestrating complicated startups
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够依赖于其他单元以编排复杂的启动
- en: There are plenty of other exciting aspects of `systemd`, such as network, DNS,
    and even mounting for devices. The idea of handling processes with ease in Python
    has always been challenging; at one point there were a few *init-like* projects
    in Python to choose from, all with their configuration and handling APIs. Using
    `systemd` allows portability and makes it easy to collaborate with others since
    it is widely available.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他激动人心的`systemd`功能，例如网络、DNS，甚至是设备挂载。在Python中轻松处理进程的想法一直是具有挑战性的；曾经有几个类似*init*的Python项目供选择，都有各自的配置和处理API。使用`systemd`允许可移植性，并使与他人协作变得容易，因为它广泛可用。
- en: Tip
  id: totrans-260
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Two well-known process handlers in Python are [`supervisord`](http://supervisord.org)
    and [`circus`](https://oreil.ly/adGEj).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中两个知名的进程处理程序是 [`supervisord`](http://supervisord.org) 和 [`circus`](https://oreil.ly/adGEj)。
- en: Not long ago, Alfredo wrote a small Python HTTP API that needed to go into production.
    The project had transitioned from `supervisord` to `circus`, and things were working
    fine. Unfortunately, production constraints meant the integration of `systemd`
    with the OS. The transition was rough because `systemd` was reasonably new, but
    once things were in place, we benefited from having the same production-like handling
    for development and catching integration issues earlier in the development cycle.
    When the API went into the release, we already felt comfortable with `systemd`
    to troubleshoot problems and even fine-tune the configuration to cope with external
    issues. (Have you ever seen an `init` script fail because the network was not
    operational?)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 不久前，Alfredo 写了一个小的 Python HTTP API，需要投入生产使用。该项目已从 `supervisord` 迁移到 `circus`，一切都运行正常。不幸的是，生产环境的限制意味着需要将
    `systemd` 与操作系统集成。由于 `systemd` 相对较新，过渡过程很粗糙，但一旦一切就绪，我们就从中受益，可以在开发周期的早期阶段进行类似生产环境的处理，并更早地捕获集成问题。当
    API 进入发布时，我们已经对 `systemd` 感到满意，可以排除问题，甚至调整配置以应对外部问题。（你有没有见过由于网络未运行而导致 `init` 脚本失败的情况？）
- en: In this section we build a small HTTP service that needs to be available when
    the system boots and can restart at any moment. The unit configuration handles
    logging and ensures that specific system resources are available before attempting
    to start.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们构建了一个小型 HTTP 服务，它在系统启动时需要可用，并且可以在任何时刻重新启动。单元配置处理日志记录，并确保在尝试启动之前可用特定的系统资源。
- en: Long-Running Processes
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长期运行的进程
- en: Processes that are meant to be running all the time are excellent candidates
    to be handled with `systemd`. Consider how a DNS or mail server works; these are
    *always on* programs, and they need some handling to capture logging or restart
    when configuration changes.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 那些应该一直运行的进程非常适合使用 `systemd` 进行处理。想想 DNS 或邮件服务器的工作原理；这些都是*一直在运行*的程序，它们需要一些处理来捕获日志或在配置更改时重新启动。
- en: We are going to use a small HTTP API server, based on the [Pecan web framework](https://www.pecanpy.org).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个基于 [Pecan web framework](https://www.pecanpy.org) 的小型 HTTP API 服务器。
- en: Note
  id: totrans-267
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There is nothing specific in this section as to how Pecan works, so that the
    examples can be used for other frameworks or long-running services.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 本节对 Pecan 的工作方式没有特别说明，因此示例可以用于其他框架或长期运行的服务。
- en: Setting It Up
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置
- en: 'Pick a permanent location for the project to create a directory at */opt/http*,
    and then create a new virtual environment and install the Pecan framework:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个永久位置用于项目，在 */opt/http* 创建一个目录，然后创建一个新的虚拟环境并安装 Pecan 框架：
- en: '[PRE60]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Pecan has some built-in helpers that can create the necessary files and directories
    for an example project. Pecan can be used to create a basic “vanilla” HTTP API
    project that hooks up to `systemd`. Version `1.3.3` has two options: the `base`
    and the `rest-api` flavors:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Pecan 有一些内置的辅助工具，可以为示例项目创建必要的文件和目录。Pecan 可以用于创建一个基本的“香草”HTTP API 项目，将其连接到 `systemd`。版本`1.3.3`
    有两个选项：`base` 和 `rest-api`。
- en: '[PRE61]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Tip
  id: totrans-274
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is important to use a consistent path, because it is used later when configuring
    the service with `systemd`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一致的路径非常重要，因为稍后在使用 `systemd` 配置服务时会用到它。
- en: 'By including the project scaffolding, we now have a fully functional project
    with no effort. It even has a *setup.py* file with everything in it, ready to
    become a native Python package! Let’s install the project so that we can run it:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 通过包含项目脚手架，我们现在可以毫不费力地拥有一个完全功能的项目。它甚至有一个*setup.py*文件，里面包含了所有内容，可以立即成为一个原生的 Python
    包！让我们安装该项目，以便运行它：
- en: '[PRE62]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `pecan` command-line tool requires a configuration file. The configuration
    file has already been created for you by the scaffolding, and it lives in the
    top directory. Start the server with the *config.py* file:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`pecan` 命令行工具需要一个配置文件。配置文件已经由脚手架为您创建，并保存在顶级目录中。使用 *config.py* 文件启动服务器：'
- en: '[PRE63]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Testing it out on the browser should produce a plain-text message. This is
    how it shows with the `curl` command:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器上进行测试应该会产生一个纯文本消息。这是使用 `curl` 命令显示的方式：
- en: '[PRE64]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: A long-running process starts with `pecan serve config.py`. The only way to
    stop this process is to send a `KeyboardInterrupt` with `Control-C`. Starting
    it again requires the virtual environment to be activated, and the same `pecan
    serve` command runs again.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 长时间运行的进程从 `pecan serve config.py` 开始。唯一停止此进程的方法是使用 `Control-C` 发送 `KeyboardInterrupt`。重新启动需要激活虚拟环境，再次运行相同的
    `pecan serve` 命令。
- en: The systemd Unit File
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: systemd 单元文件
- en: 'Unlike older init systems that work with executable scripts, `systemd` works
    with plain text files. The final version of the unit file looks like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 与旧的初始化系统不同，它使用可执行脚本，`systemd` 使用纯文本文件。单元文件的最终版本如下所示：
- en: '[PRE65]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Save this file as `hello-world.service`. It will be copied into its final destination
    later in this section.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为 `hello-world.service`。稍后会将其复制到最终目标位置。
- en: 'It is essential to get all the section names and the configuration directives
    correct, as all are case-sensitive. If names don’t match exactly, things won’t
    work. Let’s go into detail for each section of the HTTP service:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 确保获取所有部分名称和配置指令的准确性非常重要，因为它们都区分大小写。如果名称不完全匹配，事情将无法正常工作。让我们详细讨论HTTP服务的每个部分：
- en: Unit
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 单元
- en: Provides a description and includes an `After` directive that tells `systemd`
    that this service unit needs to have an operational network environment before
    being started. Other units may have more complex requirements, not only to start
    the service but even *after* it starts! `Condition` and `Wants` are other directives
    that are very useful.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了描述并包括一个 `After` 指令，告诉 `systemd` 此服务单元在启动之前需要具备操作网络环境。其他单元可能有更复杂的要求，不仅仅是启动服务，甚至是*启动后*！
    `Condition` 和 `Wants` 是其他非常有用的指令。
- en: Service
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 服务
- en: This section is only needed when configuring a *service* unit. It defaults to
    `Type=simple`. Services of this type should not fork—they have to stay in the
    foreground so that `systemd` can handle their operation. The `ExecStart` line
    explains what the command should run to start the service. It is *crucial* to
    use absolute paths to avoid problems finding the right files.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置 *service* 单元时才需要此部分。默认为 `Type=simple`。此类服务不应分叉，它们必须保持在前台，以便 `systemd` 可以处理它们的操作。
    `ExecStart` 行解释了命令应如何运行以启动服务。使用绝对路径是*至关重要*的，以避免找不到正确文件的问题。
- en: Although not required, I’ve included the `WorkingDirectory` directive to ensure
    that the process is in the same directory where the application lives. If anything
    updates later, it might benefit from already being in a position relative to the
    application.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是必需的，我已包含 `WorkingDirectory` 指令，以确保进程在应用程序所在的相同目录中。如果以后有任何更新，它可能会因为已经处于与应用程序相关的位置而受益。
- en: Both the `StandardOutput` and `StandardError` directives are great to work with,
    and show how much `systemd` has to offer here. It will handle all the logging
    emitted via `stdout` and `stderr` through `systemd` machinery. We will demonstrate
    this further when explaining how to interact with the service.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`StandardOutput` 和 `StandardError` 指令非常好用，并展示了 `systemd` 在这方面的强大功能。它会通过 `systemd`
    机制处理所有通过 `stdout` 和 `stderr` 发出的日志。在我们解释如何与服务交互时，我们将进一步演示这一点。'
- en: Install
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 安装
- en: The `WantedBy` directive explains how this unit handles once it is enabled.
    The `multi-user.target` is equivalent to `runlevel 3` (the normal run level for
    a server that boots into a terminal). This type of configuration allows the system
    to determine how it behaves once enabled. Once enabled, a symlink is created in
    the *multi-user.target.wants* directory.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`WantedBy` 指令解释了一旦启用，此单元如何处理。 `multi-user.target` 相当于 `runlevel 3`（服务器启动到终端的正常运行级别）。这种类型的配置允许系统确定启用后的行为方式。一旦启用，会在
    *multi-user.target.wants* 目录中创建一个符号链接。'
- en: Installing the Unit
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装单元
- en: The configuration file itself has to go to a specific location so that `systemd`
    can pick it up and *load it*. Various locations are supported, but */etc/systemd/system*
    is for units that are created or managed by an administrator.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件本身必须放置在特定位置，以便 `systemd` 能够找到并*加载*它。支持多种位置，但 */etc/systemd/system* 是由管理员创建或管理的单元所用的位置。
- en: Tip
  id: totrans-298
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'It is useful to make sure that the `ExecStart` directive works with those paths.
    Using absolute paths increases the chance of introducing a typo. To verify, run
    the whole line in the terminal and look for output similar to this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 确保 `ExecStart` 指令与这些路径配合正常非常有用。使用绝对路径可以减少引入拼写错误的机会。要验证，请在终端中运行整行命令，并查找类似于以下输出：
- en: '[PRE66]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'After verifying that the command works, copy the unit file into this directory
    using `hello-world.service` as the name:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 验证命令是否有效后，使用`hello-world.service`作为名称将单元文件复制到此目录：
- en: '[PRE67]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Once in place, `systemd` needs to be reloaded to make it aware of this new
    unit:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 放置后，需要重新加载`systemd`以使其意识到这个新单元：
- en: '[PRE68]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The service is now fully functional and can be started and stopped. This process
    is verified by using the `status` subcommand. Let’s go through the different commands
    you can use to interact with the service. First, let’s see if `systemd` recognizes
    it. This is how it should behave and what the output looks like:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 服务现在完全可用并可以启动和停止。通过使用`status`子命令进行验证。让我们看看`systemd`是否识别它。这是其应有的行为以及输出的样子：
- en: '[PRE69]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Since the service is not running, it is not surprising to see it reported as
    `dead`. Start the service next and check the status once again (`curl` should
    report nothing is running on port `8080`):'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务未运行，看到它被报告为`dead`并不奇怪。接下来启动服务，并再次检查状态（`curl`应该报告端口`8080`上没有运行任何内容）：
- en: '[PRE70]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The service is running and fully operational. Verify it once again on port
    `8080` to make sure that the framework is up and running and responding to requests:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 服务正在运行且完全可操作。再次验证端口`8080`上的服务，确保框架正在运行并响应请求：
- en: '[PRE71]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: If you stop the service with `systemctl stop hello-world`, the `curl` command
    will report a connection failure once again.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`systemctl stop hello-world`停止服务，那么`curl`命令将再次报告连接失败。
- en: 'So far, we have created and installed the unit, verified it works by starting
    and stopping the service, and checked if the Pecan framework is responding to
    requests on its default port. You want this service up and running if the server
    reboots at any time, and this is where the `Install` section helps. Let’s `enable`
    the service:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建并安装了该单元，通过启动和停止服务验证了其工作，并检查了Pecan框架是否在其默认端口上响应请求。如果服务器在任何时候重新启动，您希望此服务处于运行状态，这就是`Install`部分发挥作用的地方。让我们`enable`该服务：
- en: '[PRE72]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: When the server restarts, the small HTTP API service is up and running.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器重新启动时，小型HTTP API服务将会启动并运行。
- en: Log Handling
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志处理
- en: Since this is a configured service with logging configuration (all `stdout`
    and `stderr` is going directly into `systemd`), the handling works *for free*.
    No need to configure file-based logging, rotation, or even expiration. There are
    a few interesting and very nice features provided by `systemd` that allow you
    to interact with logs, such as limiting the time range and filtering by unit or
    process ID.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个配置了日志记录配置（所有`stdout`和`stderr`都直接进入`systemd`）的服务，处理工作是*免费*的。无需配置基于文件的日志记录、旋转或甚至过期。`systemd`提供了一些有趣且非常好用的功能，允许您与日志交互，例如限制时间范围和按单元或进程ID过滤。
- en: Note
  id: totrans-317
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The command to interact with logs from a unit is done through the `journalctl`
    command-line tool. This process might be a surprise if expecting another subcommand
    from `systemd` to provide the logging helpers.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 与单元日志交互的命令通过`journalctl`命令行工具完成。如果期望`systemd`提供另一个子命令来提供日志助手，则这个过程可能会有所不同。
- en: 'Since we started the service and sent some requests to it via `curl` in the
    previous section, let’s see what the logs say:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在前一节中启动了服务并通过`curl`发送了一些请求给它，让我们看看日志显示了什么：
- en: '[PRE73]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `-u` flag specifies the *unit*, which in this case is `hello-world`, but
    you can also use a pattern or even specify multiple units.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`-u`标志指定了*单元*，在本例中是`hello-world`，但您也可以使用模式或甚至指定多个单元。'
- en: 'A common way to *follow* a log as it produces entries is to use the `tail`
    command. Specifically, this looks like:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪生成条目的日志的常见方法是使用`tail`命令。具体来说，如下所示：
- en: '[PRE74]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The command to accomplish the same thing with `journalctl` looks slightly different,
    but it *works in the same way*:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`journalctl`执行相同操作的命令看起来略有不同，但它的*工作方式相同*：
- en: '[PRE75]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Tip
  id: totrans-326
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If the `systemd` package is available with the `pcre2` engine, it allows you
    to use `--grep`. This further filters out log entries based on a pattern.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`systemd`包使用了`pcre2`引擎可用，它允许您使用`--grep`。这进一步基于模式过滤日志条目。
- en: 'The `-f` flag means to *follow* the log, and it starts from the most recent
    entries and continues to show the entries as they happen, just like `tail -f`
    would. In production, the number of logs may be too many, and errors might have
    been showing up *today*. In those cases, you can use a combination of `--since`
    and `--until`. Both these flags accept a few different types of parameters:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f` 标志意味着 *跟随* 日志，并从最近的条目开始，并继续显示它们的进展，就像 `tail -f` 一样。在生产环境中，日志可能太多，并且可能已经出现了错误
    *today*。在这些情况下，您可以结合使用 `--since` 和 `--until`。这两个标志都接受几种不同类型的参数：'
- en: '`today`'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`today`'
- en: '`yesterday`'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yesterday`'
- en: '`"3 hours ago"`'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"3 hours ago"`'
- en: '`-1h`'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-1h`'
- en: '`-15min`'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-15min`'
- en: '`-1h35min`'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-1h35min`'
- en: 'In our small example, `journalctl` is unable to find anything for the last
    15 minutes. At the beginning of the output, it informs us of the range and produces
    the entries, if any:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的小例子中，`journalctl` 在过去的 15 分钟内无法找到任何内容。在输出的开头，它通知我们范围，并生成条目（如果有的话）：
- en: '[PRE76]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Exercises
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Use three different commands to get log output from `systemd` using `journalctl`.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用三个不同的命令通过 `journalctl` 获取 `systemd` 的日志输出。
- en: Explain what the `WorkinDirectory` configuration option is for `systemd` units.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释 `systemd` 单元的 `WorkingDirectory` 配置选项是用来做什么的。
- en: Why is a changelog important?
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么 changelog 很重要？
- en: What is a *setup.py* file for?
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*setup.py* 文件的作用是什么？'
- en: Name three differences between Debian and RPM packages.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出 Debian 和 RPM 包之间的三个不同之处。
- en: Case Study Question
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究问题
- en: Create a local instance of PyPI using `devpi`, upload a Python package, and
    then try to install that Python package from the local `devpi` instance.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `devpi` 创建 PyPI 的本地实例，上传一个 Python 包，然后尝试从本地的 `devpi` 实例安装该 Python 包。
