# 第三章\. 数字

> 行动是最大程度地为最大数量的人带来最大幸福的行动。
> 
> 弗朗西斯·哈切森

在本章中，我们首先看一下 Python 最简单的内置数据类型：

+   *布尔值*（其值为`True`或`False`）

+   *整数*（如`42`和`100000000`）

+   *浮点数*（带有小数点的数字，如`3.14159`，或者有时指数形式如`1.0e8`，表示*10 的 8 次方*，或者`100000000.0`）

从某种意义上说，它们就像原子一样。本章中我们单独使用它们，而在后续章节中，您将看到如何将它们组合成像列表和字典这样更大的“分子”。

每种类型都有其使用的特定规则，并由计算机以不同方式处理。我还展示了如何使用像`97`和`3.1416`这样的*字面值*值，以及我在第二章中提到的*变量*。

本章的代码示例都是有效的 Python 代码，但它们只是片段。我们将使用 Python 交互解释器，键入这些片段并立即查看结果。尝试在您的计算机上使用所安装的 Python 版本来运行它们。您可以通过`>>>`提示符识别这些示例。

# 布尔值

在 Python 中，布尔数据类型的唯一值为`True`和`False`。有时直接使用它们，其他时候从它们的值评估“真假性”。特殊的 Python 函数`bool()`可以将任何 Python 数据类型转换为布尔值。

函数在第九章中有专门的章节，但现在您只需要知道函数有一个名称，零个或多个用逗号分隔的*参数*，用括号括起来，以及零个或多个*返回值*。`bool()`函数接受任何值作为其参数，并返回布尔等价值。

非零数字被视为`True`：

```py
>>> bool(True)
True
>>> bool(1)
True
>>> bool(45)
True
>>> bool(-45)
True
```

零值也被视为`False`：

```py
>>> bool(False)
False
>>> bool(0)
False
>>> bool(0.0)
False
```

您将在第四章中看到布尔值的实用性。在后续章节中，您将看到如何将列表、字典和其他类型视为`True`或`False`。

# 整数

整数是整数——没有分数，没有小数点，没有花哨的东西。嗯，除了可能的初始符号。如果您希望以除了通常的十进制（10 进制）以外的其他方式表示数字，还有基数。

## 整数字面值

在 Python 中，任何数字序列都表示一个*整数字面值*：

```py
>>> 5
5
```

纯零（`0`）是有效的：

```py
>>> 0
0
```

但是您不能以`0`开头，后面跟着介于`1`到`9`之间的数字：

```py
>>> 05
  File "<stdin>", line 1
    05
     ^
SyntaxError: invalid token
```

###### 注意

此 Python *异常*警告您输入了违反 Python 规则的内容。我在“基数”中解释了这意味着什么。在本书中，您将看到更多异常的示例，因为它们是 Python 的主要错误处理机制。

您可以以`0b`、`0o`或`0x`开头一个整数。参见“基数”。

数字序列指定一个正整数。如果在数字前面加上`+`号，则数字保持不变：

```py
>>> 123
123
>>> +123
123
```

要指定负整数，在数字前面插入一个`-`：

```py
>>> -123
-123
```

整数中不能有逗号：

```py
>>> 1,000,000
(1, 0, 0)
```

与百万不同，你会得到一个*元组*（参见第七章了解更多关于元组的信息），包含三个值。但是你*可以*使用下划线（`_`）作为数字分隔符：¹

```py
>>> million = 1_000_000
>>> million
1000000
```

实际上，你可以在第一个数字后的任何位置放置下划线；它们会被忽略：

```py
>>> 1_2_3
123
```

## 整数运算

在接下来的几页中，我展示了 Python 作为一个简单计算器的示例。你可以通过使用表格中的数学*操作符*在 Python 中进行常规算术运算：

| 操作符 | 描述 | 示例 | 结果 |
| --- | --- | --- | --- |
| `+` | 加法 | `5 + 8` | `13` |
| `-` | 减法 | `90 - 10` | `80` |
| `*` | 乘法 | `4 * 7` | `28` |
| `/` | 浮点数除法 | `7 / 2` | `3.5` |
| `//` | 整数（截断）除法 | `7 // 2` | `3` |
| `%` | 取模（余数） | `7 % 3` | `1` |
| `**` | 指数运算 | `3 ** 4` | `81` |

加法和减法的工作方式与你期望的一样：

```py
>>> 5 + 9
14
>>> 100 - 7
93
>>> 4 - 10
-6
```

你可以包含任意数量的数字和操作符：

```py
>>> 5 + 9 + 3
17
>>> 4 + 3 - 2 - 1 + 6
10
```

请注意，每个数字和操作符之间不需要有空格：

```py
>>> 5+9   +      3
17
```

在风格上看起来更好，而且更容易阅读。

乘法也很简单：

```py
>>> 6 * 7
42
>>> 7 * 6
42
>>> 6 * 7 * 2 * 3
252
```

除法更有趣一些，因为它有两种形式：

+   `/` 执行*浮点数*（十进制）除法

+   `//` 执行*整数*（截断）除法

即使你将整数除以整数，使用 `/` 也会给你一个浮点结果（*浮点数*稍后在本章讨论）：

```py
>>> 9 / 5
1.8
```

截断整数除法返回一个整数答案，丢弃任何余数：

```py
>>> 9 // 5
1
```

无论使用哪种除法，将整数除以零都会引发 Python 异常，而不是撕开时空维度：

```py
>>> 5 / 0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: division by zero
>>> 7 // 0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: integer division or modulo by z
```

## 整数和变量

所有前面的例子都使用了文字整数。你可以混合使用文字整数和已经赋予整数值的变量：

```py
>>> a = 95
>>> a
95
>>> a - 3
92
```

你会记得从第二章中，`a` 是一个指向整数对象的名称。当我说 `a - 3` 时，我没有将结果再赋给 `a`，因此 `a` 的值没有改变：

```py
>>> a
95
```

如果想要改变 `a`，你需要这样做：

```py
>>> a = a - 3
>>> a
92
```

再次强调，这不是一个合法的数学方程，而是在 Python 中重新分配变量值的方式。在 Python 中，等号右侧的表达式先计算，然后再赋给左侧的变量。

如果有帮助，可以这样考虑：

+   从 `a` 减去 `3`

+   将减法的结果赋给一个临时变量

+   将临时变量的值赋给 `a`：

```py
>>> a = 95
>>> temp = a - 3
>>> a = temp
```

因此，当你说

```py
>>> a = a - 3
```

Python 在等号右侧计算减法，记住结果，然后将其分配给 `a` 在加号左侧。这比使用临时变量更快、更整洁。

你可以通过在等号前放置操作符将算术运算符与赋值结合起来。例如，`a -= 3` 相当于 `a = a - 3`：

```py
>>> a = 95
>>> a -= 3
>>> a
92
```

这就像 `a = a + 8` 一样：

```py
>>> a = 92
>>> a += 8
>>> a
100
```

这就像 `a = a * 2` 一样：

```py
>>> a = 100
>>> a *= 2
>>> a
200
```

这是一个浮点除法的例子，例如 `a = a / 3`：

```py
>>> a = 200
>>> a /= 3
>>> a
66.66666666666667
```

现在让我们试试 `a = a // 4` 的缩写（截断整数除法）：

```py
>>> a = 13
>>> a //= 4
>>> a
3
```

`%` 字符在 Python 中有多种用法。当它在两个数字之间时，它产生第一个数除以第二个数的余数：

```py
>>> 9 % 5
4
```

这里是如何同时获得截断的商和余数：

```py
>>> divmod(9,5)
(1, 4)
```

否则，你可以分别计算它们：

```py
>>> 9 // 5
1
>>> 9 % 5
4
```

你刚刚在这里看到了一些新东西：一个名为 `divmod` 的*函数*被给定整数 `9` 和 `5`，并返回一个两项的*元组*。正如我之前提到的，元组将在第七章亮相；函数则在第九章首次登场。

最后一个数学特性是指数运算符 `**`，它还允许你混合整数和浮点数：

```py
>>> 2**3
8
>>> 2.0 ** 3
8.0
>>> 2 ** 3.0
8.0
>>> 0 ** 3
0
```

## 优先级

如果你输入以下内容，会得到什么？

```py
>>> 2 + 3 * 4
```

如果你先做加法，`2 + 3` 是 `5`，然后 `5 * 4` 是 `20`。但如果你先做乘法，`3 * 4` 是 `12`，然后 `2 + 12` 是 `14`。在 Python 中，与大多数语言一样，乘法比加法具有更高的*优先级*，所以第二个版本是你会看到的：

```py
>>> 2 + 3 * 4
14
```

你如何知道运算符的优先级规则？在附录 E 中有一张大表列出了所有规则，但实际上我从不查看这些规则。只需通过添加括号来组合代码以执行你意图的计算，会更容易得多：

```py
>>> 2 + (3 * 4)
14
```

这个带有指数的例子

```py
>>> -5 ** 2
-25
```

是相同的

```py
>>> - (5 ** 2)
-25
```

而且可能不是你想要的。括号可以明确表达：

```py
>>> (-5) ** 2
25
```

这样，任何阅读代码的人都不需要猜测它的意图或查阅优先级规则。

## 基数

假设整数默认为十进制（十进制），除非你使用前缀来指定另一个*基数*。你可能永远不需要使用这些其他基数，但在某个时候你可能会在 Python 代码中见到它们。

通常我们有 10 个手指和 10 个脚趾，所以我们数 `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`。然后，我们用完了个位数，并把一个`1`进位到“十位”，在个位数放一个`0`：`10`表示“1 十和 0 个”。不像罗马数字，阿拉伯数字没有单独表示`10`的字符。然后是`11`、`12`，一直到`19`，进位成`20`（2 十和 0 个），以此类推。

基数是你可以使用多少位数，直到需要“进位为一”的数。在二进制（*binary*）中，唯一的位数是`0`和`1`。这就是著名的*比特位*。`0`与普通的十进制 0 相同，而`1`与十进制 1 相同。然而，在二进制中，如果你将`1`加到`1`上，你会得到`10`（1 十进制二加 0 十进制一）。

在 Python 中，除了十进制以外，你可以用这些整数前缀表示字面整数的三种基数：

+   `0b` 或 `0B` 代表*二进制*（基数 2）。

+   `0o` 或 `0O` 代表*八进制*（基数 8）。

+   `0x` 或 `0X` 代表*十六进制*（基数 16）。

这些基数都是二的幂，某些情况下很方便，尽管你可能永远不需要使用除了好旧的十进制整数之外的任何东西。

解释器将这些打印出来作为十进制整数。让我们尝试每一个基数。首先是一个普通的十进制 `10`，这意味着*1 十和 0 个一*：

```py
>>> 10
10
```

现在，二进制（基数 2） `0b10` 表示*1（十进制）二和 0 个一*：

```py
>>> 0b10
2
```

八进制（基数 8） `0o10` 代表*1（十进制）八和 0 个一*：

```py
>>> 0o10
8
```

十六进制（基数 16） `0x10` 表示*1（十进制）十六和 0 个一*：

```py
>>> 0x10
16
```

你可以反向操作，使用任何这些基数将整数转换为字符串：

```py
>>> value = 65
>>> bin(value)
'0b1000001'
>>> oct(value)
'0o101'
>>> hex(value)
'0x41'
```

`chr()` 函数将一个整数转换为其单字符字符串等效物：

```py
>>> chr(65)
'A'
```

而 `ord()` 反向操作：

```py
>>> ord('A')
65
```

如果你想知道十六进制中所使用的“数字”，它们是：`0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `a`, `b`, `c`, `d`, `e`, 和 `f`。 `0xa` 是十进制 `10`，而 `0xf` 是十进制 `15`。在 `0xf` 上加 1，你得到 `0x10`（十进制 16）。

为什么要使用不同于十进制的基数？它们在*位级*操作中非常有用，详见第十二章，以及有关从一种进制转换到另一种进制的更多细节。

猫通常每只前爪有五个趾，每只后爪有四个趾，总共有 18 个。如果你曾经在他们穿着实验服的猫科学家们之间，他们经常讨论十八进制算术。我的猫切斯特，看到他在图 3-1 中悠闲地躺着，是一只*多趾*，给了他大约 22 或更多（很难分辨）的脚趾。如果他想要用它们来计算围绕碗的食物碎片，他可能会使用一个基数 22 的系统（这里称为*切斯特数字*系统），使用 `0` 到 `9` 和 `a` 到 `l`。

![chester](img/inp2_0301.png)

###### 图 3-1\. 切斯特——一只出色的毛茸茸小伙子，切斯特数字系统的发明者

## 类型转换

要将其他 Python 数据类型转换为整数，请使用 `int()` 函数。

`int()` 函数接受一个输入参数并返回一个值，即输入参数的整数化等效物。这将保留整数部分并丢弃任何小数部分。

正如你在本章开头所见，Python 最简单的数据类型是*布尔值*，它只有 `True` 和 `False` 两个值。当转换为整数时，它们分别表示 `1` 和 `0`：

```py
>>> int(True)
1
>>> int(False)
0
```

相反地，`bool()` 函数返回一个整数的布尔等效物：

```py
>>> bool(1)
True
>>> bool(0)
False
```

将浮点数转换为整数只需去掉小数点后的所有内容：

```py
>>> int(98.6)
98
>>> int(1.0e4)
10000
```

将浮点数转换为布尔值并不奇怪：

```py
>>> bool(1.0)
True
>>> bool(0.0)
False
```

最后，这里有一个示例，从一个只包含数字的文本字符串中获取整数值（第五章）可能包含 `_` 数字分隔符或初始 `+` 或 `-` 号：

```py
>>> int('99')
99
>>> int('-23')
-23
>>> int('+12')
12
>>> int('1_000_000')
1000000
```

如果字符串代表一个非十进制整数，你可以包括基数：

```py
>>> int('10', 2) # binary
2
>>> int('10', 8) # octal
8
>>> int('10', 16) # hexadecimal
16
>>> int('10', 22) # chesterdigital
22
```

将整数转换为整数不会改变任何内容，但也不会造成伤害：

```py
>>> int(12345)
12345
```

如果你试图转换一个看起来不像是数字的东西，你会得到一个*异常*：

```py
>>> int('99 bottles of beer on the wall')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: invalid literal for int() with base 10: '99 bottles of beer on the wall'
>>> int('')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: invalid literal for int() with base 10: ''
```

之前的文本字符串以有效的数字字符（`99`）开头，但随后出现了其他字符，这些字符使得`int()`函数无法处理。

`int()`可以从浮点数或数字字符串创建整数，但不能处理包含小数点或指数的字符串：

```py
>>> int('98.6')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: invalid literal for int() with base 10: '98.6'
>>> int('1.0e4')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: invalid literal for int() with base 10: '1.0e4'
```

如果你混合使用数值类型，Python 有时会尝试自动进行类型转换：

```py
>>> 4 + 7.0
11.0
```

布尔值`False`在与整数或浮点数混合时被视为`0`或`0.0`，而`True`则被视为`1`或`1.0`：

```py
>>> True + 2
3
>>> False + 5.0
5.0
```

## 一个整数有多大？

在 Python 2 中，`int`的大小可以限制为 32 位或 64 位，具体取决于你的 CPU；32 位可以存储任何从–2,147,483,648 到 2,147,483,647 的整数。

64 位的`long`类型允许存储范围从–9,223,372,036,854,775,808 到 9,223,372,036,854,775,807。在 Python 3 中，`long`类型已经消失，而`int`可以是*任意*大小，甚至可以比 64 位还大。你可以处理像*谷歌*（一个后面跟着一百个零的数，[在 1920 年](https://oreil.ly/6ibo_)被一个九岁的男孩命名）这样的大数：

```py
>>>
>>> googol = 10**100
>>> googol
100000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000
>>> googol * googol
100000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000
```

*谷歌宇宙*是`10**googol`（如果你想自己尝试的话，有一千个零）。这是谷歌在决定用*谷歌*之前的一个建议名称，但他们在注册域名`google.com`之前没有检查其拼写。

在许多语言中，尝试这样做会导致称为*整数溢出*的问题，其中数字需要比计算机允许的空间更多，会产生各种不良影响。Python 处理谷歌般大的整数毫无问题。

# 浮点数

整数是整数，但 Python 中的*浮点数*（称为*floats*）带有小数点：

```py
>>> 5.
5.0
>>> 5.0
5.0
>>> 05.0
5.0
```

浮点数可以在字母`e`后包含一个十进制整数指数：

```py
>>> 5e0
5.0
>>> 5e1
50.0
>>> 5.0e1
50.0
>>> 5.0 * (10 ** 1)
50.0
```

你可以使用下划线（`_`）分隔数字以增加清晰度，就像你可以用于整数一样：

```py
>>> million = 1_000_000.0
>>> million
1000000.0
>>> 1.0_0_1
1.001
```

浮点数的处理方式与整数类似：你可以使用操作符（`+`、`–`、`*`、`/`、`//`、`**`和`%`）以及`divmod()`函数。

要将其他类型转换为浮点数，你可以使用`float()`函数。和以前一样，布尔值表现得像小整数一样：

```py
>>> float(True)
1.0
>>> float(False)
0.0
```

将整数转换为浮点数只会使其成为一个带有小数点的自豪所有者：

```py
>>> float(98)
98.0
>>> float('99')
99.0
```

你可以将包含字符的字符串转换为有效的浮点数（数字、符号、小数点或`e`后跟一个指数）：

```py
>>> float('98.6')
98.6
>>> float('-1.5')
-1.5
>>> float('1.0e4')
10000.0
```

当你混合整数和浮点数时，Python 会自动将整数值提升为浮点数值：

```py
>>> 43 + 2.
45.0
```

Python 还会将布尔值提升为整数或浮点数：

```py
>>> False + 0
0
>>> False + 0.
0.0
>>> True + 0
1
>>> True + 0.
1.0
```

# 数学函数

Python 支持复数，并且具有常见的数学函数，如平方根、余弦等等。我们将它们留到第二十二章中，在那里我们还将讨论在科学环境中使用 Python。

# 即将发生

在下一章中，你将终于从单行的 Python 示例中毕业。通过`if`语句，你将学会如何使用代码做出决策。

# 要做的事情

本章介绍了 Python 的基本组成部分：数字、布尔值和变量。让我们在交互式解释器中尝试一些与它们相关的小练习。

3.1 一个小时有多少秒？使用交互式解释器作为计算器，将每分钟的秒数（`60`）乘以每小时的分钟数（同样是`60`）。

3.2 将前一个任务（每小时的秒数）的结果赋给名为`seconds_per_hour`的变量。

3.3 一天有多少秒？使用你的`seconds_per_hour`变量。

3.4 再次计算每天的秒数，但这次将结果保存在名为`seconds_per_day`的变量中。

3.5 将`seconds_per_day`除以`seconds_per_hour`。使用浮点数（`/`）除法。

3.6 将`seconds_per_day`除以`seconds_per_hour`，使用整数（`//`）除法。除了最后的`.0`，这个数字是否与前一个问题中的浮点值一致？

¹ 适用于 Python 3.6 及更新版本。
