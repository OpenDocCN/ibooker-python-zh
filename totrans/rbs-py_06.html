<html><head></head><body>
<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. Collection Types" class="preface"><div class="preface" id="collections">
<h1 class="calibre10" id="calibre_pb_0"><span class="calibre">Chapter 5. </span>Collection Types</h1>


<p class="author1">You can’t go very far<a data-type="indexterm" data-primary="collections" id="ix_coll" class="calibre5"/> in Python without encountering <em class="calibre6">collection types</em>. Collection types store a grouping of data, such as a list of users or a lookup between restaurant or address. Whereas other types (e.g., <code class="calibre17">int</code>, <code class="calibre17">float</code>, <code class="calibre17">bool</code>, etc.) may focus on a single value, collections may store any arbitrary amount of data. In Python, you will encounter common collection types such as dictionaries, lists, and sets (oh, my!). Even a string is a type of collection; it contains a sequence of characters. However, collections can be difficult to reason about when reading new code. Different collection types have different behaviors.</p>

<p class="author1">Back in <a data-type="xref" href="part0003_split_000.html#intro" class="calibre5">Chapter 1</a>, I went over some of the differences between the collections, where I talked about mutability, iterability, and indexing requirements. However, picking the right collection is just the first step. You must understand the implications of your collection and ensure that users can reason about it. You also need to recognize when the standard collection types aren’t cutting it and you need to roll your own. But the first step is knowing how to communicate your collection choices to the future. For that, we’ll turn to an old friend: type annotations.</p>






</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. Collection Types" class="preface">
<div class="preface" id="collections">
<section data-type="sect1" data-pdf-bookmark="Annotating Collections" class="preface"><div class="preface" id="idm45644748857464">
<h1 class="calibre12" id="calibre_pb_1">Annotating Collections</h1>

<p class="author1">I’ve covered type annotations for non–collection types, and now you need to know how to annotate collection types.<a data-type="indexterm" data-primary="type annotations" data-secondary="annotating collections" id="idm45644748855640" class="calibre5"/><a data-type="indexterm" data-primary="collections" data-secondary="annotating" id="idm45644748854664" class="calibre5"/> Fortunately, these annotations don’t differ too much from the annotations you’ve already learned.</p>

<p class="author1">To illustrate this, suppose I’m building a digital cookbook app. I want to organize all my cookbooks digitally so I can search them by cuisine, ingredient, or author. One of the questions I might have about a cookbook collection is how many books from each author I have:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">create_author_count_mapping</code><code class="calibre17">(</code><code class="n">cookbooks</code><code class="calibre17">:</code> <code class="nb">list</code><code class="calibre17">)</code> <code class="calibre17">-&gt;</code> <code class="nb">dict</code><code class="calibre17">:</code>
    <code class="n">counter</code> <code class="calibre17">=</code> <code class="n">defaultdict</code><code class="calibre17">(</code><code class="k">lambda</code><code class="calibre17">:</code> <code class="mi">0</code><code class="calibre17">)</code>
    <code class="k">for</code> <code class="n">book</code> <code class="calibre19">in</code> <code class="n">cookbooks</code><code class="calibre17">:</code>
        <code class="n">counter</code><code class="calibre17">[</code><code class="n">book</code><code class="calibre17">.</code><code class="n">author</code><code class="calibre17">]</code> <code class="calibre17">+=</code> <code class="mi">1</code>
    <code class="k">return</code> <code class="n">counter</code></pre>

<p class="author1">This function has been annotated; it takes in a list of cookbooks and will return a dictionary. Unfortunately, while this tells me what collections to expect, it doesn’t tell me how to use the collections at all. There is nothing telling me what the elements inside the collection are. For instance, how do I know what type the cookbook is? If you were reviewing this code, how do you know that the use of <code class="calibre17">book.author</code> is legitimate? Even if you do the digging to make sure <code class="calibre17">book.author</code> is right, this code is not future-proof. If the underlying type changes, such as removing the <code class="calibre17">author</code> field, this code will break. I need a way to catch this with my typechecker.</p>

<p class="author1">I’ll do this by encoding more information with my types by using bracket syntax to indicate <a data-type="indexterm" data-primary="[] bracket syntax, using for types within collections" id="idm45644748794312" class="calibre5"/>information about the types <em class="calibre6">inside</em> the collection:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">AuthorToCountMapping</code> <code class="calibre17">=</code> <code class="nb">dict</code><code class="calibre17">[</code><code class="nb">str</code><code class="calibre17">,</code> <code class="nb">int</code><code class="calibre17">]</code>
<code class="k">def</code> <code class="nf">create_author_count_mapping</code><code class="calibre17">(</code>
				<code class="n">cookbooks</code><code class="calibre17">:</code> <code class="nb">list</code><code class="calibre17">[</code><code class="n">Cookbook</code><code class="calibre17">]</code>
                               <code class="calibre17">)</code> <code class="calibre17">-&gt;</code> <code class="n">AuthorToCountMapping</code><code class="calibre17">:</code>
    <code class="n">counter</code> <code class="calibre17">=</code> <code class="n">defaultdict</code><code class="calibre17">(</code><code class="k">lambda</code><code class="calibre17">:</code> <code class="mi">0</code><code class="calibre17">)</code>
    <code class="k">for</code> <code class="n">book</code> <code class="calibre19">in</code> <code class="n">cookbooks</code><code class="calibre17">:</code>
        <code class="n">counter</code><code class="calibre17">[</code><code class="n">book</code><code class="calibre17">.</code><code class="n">author</code><code class="calibre17">]</code> <code class="calibre17">+=</code> <code class="mi">1</code>
    <code class="k">return</code> <code class="n">counter</code></pre>
<div data-type="note" epub:type="note" class="calibre21"><h6 class="calibre22">Note</h6>
<p class="author1">I used an alias, <code class="calibre17">AuthorToCountMapping</code>, to represent a <code class="calibre17">dict[str, int]</code>. I do this because I find it difficult sometimes to remember what the <code class="calibre17">str</code> and the <code class="calibre17">int</code> are supposed to represent.<a data-type="indexterm" data-primary="aliases" data-seealso="type aliases" id="idm45644748761384" class="calibre5"/><a data-type="indexterm" data-primary="type aliases" id="idm45644748760408" class="calibre5"/> However, I do concede that this loses some information (readers of the code will have to find out what <code class="calibre17">AuthorToCountMapping</code> is an alias to). Ideally, your code editor can display what the underlying type is without you needing to look it up.</p>
</div>

<p class="author1">I can indicate the exact types expected in the collection. <a data-type="indexterm" data-primary="types" data-secondary="indicating types expected in collections" id="idm45644748725368" class="calibre5"/>The cookbooks list contains <code class="calibre17">Cookbook</code> objects, and the return value of the function is returning a dictionary mapping strings (keys) to integers (values). Note that I’m using a type alias to give more meaning to my return value. Mapping from a <code class="calibre17">str</code> to an <code class="calibre17">int</code> does not tell the user the context of the type. Instead, I create a type alias named <code class="calibre17">AuthorToCountMapping</code> to make it clear how this dictionary relates to the problem domain.</p>

<p class="author1">You need to think through what types are contained in the collection in order to be effective in type-hinting it. In order to do that, you need to think about homogeneous and heterogeneous collections.</p>
</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. Collection Types" class="preface">
<div class="preface" id="collections">
<section data-type="sect1" data-pdf-bookmark="Homogeneous Versus Heterogeneous Collections" class="preface"><div class="preface" id="idm45644748856872">
<h1 class="calibre12" id="calibre_pb_2">Homogeneous Versus Heterogeneous Collections</h1>

<p class="author1"><em class="calibre6">Homogeneous collections</em> are collections in which every value has the same type. <a data-type="indexterm" data-primary="homogeneous collections" data-seealso="heterogeneous versus homogeneous collections" id="idm45644748719272" class="calibre5"/><a data-type="indexterm" data-primary="collections" data-secondary="homogeneous versus heterogeneous" id="ix_collHvH" class="calibre5"/>In contrast, values in <em class="calibre6">heterogeneous collections</em> may have different types within them.<a data-type="indexterm" data-primary="heterogeneous versus homogeneous collections" id="ix_hevho" class="calibre5"/> From a usability standpoint, your lists, sets, and dictionaries should nearly always be homogenous.<a data-type="indexterm" data-primary="dictionaries" id="idm45644748715272" class="calibre5"/><a data-type="indexterm" data-primary="lists" id="idm45644748714600" class="calibre5"/><a data-type="indexterm" data-primary="sets" id="idm45644748713928" class="calibre5"/> Users need a way to reason about your collections, and they can’t if they don’t have the guarantee that every value is the same type. If you make a list, set, or dictionary a heterogeneous collection, you are indicating to the user that they need to take care to handle special cases. Suppose I want to resurrect an example from <a data-type="xref" href="part0003_split_000.html#intro" class="calibre5">Chapter 1</a> for adjusting recipes for my cookbook app:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">adjust_recipe</code><code class="calibre17">(</code><code class="n">recipe</code><code class="calibre17">,</code> <code class="n">servings</code><code class="calibre17">):</code>
    <code class="sd">"""</code>
<code class="sd">    Take a meal recipe and change the number of servings</code>
<code class="sd">    :param recipe: A list, where the first element is the number of servings,</code>
<code class="sd">                   and the remainder of elements follow the (name, amount, unit)</code>
<code class="sd">                   format, such as ("flour", 1.5, "cup")</code>
<code class="sd">    :param servings: the number of servings</code>
<code class="sd">    :return list: a new list of ingredients, where the first element is the</code>
<code class="sd">                  number of servings</code>
<code class="sd">    """</code>
    <code class="n">new_recipe</code> <code class="calibre17">=</code> <code class="calibre17">[</code><code class="n">servings</code><code class="calibre17">]</code>
    <code class="n">old_servings</code> <code class="calibre17">=</code> <code class="n">recipe</code><code class="calibre17">[</code><code class="mi">0</code><code class="calibre17">]</code>
    <code class="n">factor</code> <code class="calibre17">=</code> <code class="n">servings</code> <code class="calibre17">/</code> <code class="n">old_servings</code>
    <code class="n">recipe</code><code class="calibre17">.</code><code class="n">pop</code><code class="calibre17">(</code><code class="mi">0</code><code class="calibre17">)</code>
    <code class="k">while</code> <code class="n">recipe</code><code class="calibre17">:</code>
            <code class="n">ingredient</code><code class="calibre17">,</code> <code class="n">amount</code><code class="calibre17">,</code> <code class="n">unit</code> <code class="calibre17">=</code> <code class="n">recipe</code><code class="calibre17">.</code><code class="n">pop</code><code class="calibre17">(</code><code class="mi">0</code><code class="calibre17">)</code>
            <code class="c"># please only use numbers that will be easily measurable</code>
            <code class="n">new_recipe</code><code class="calibre17">.</code><code class="n">append</code><code class="calibre17">((</code><code class="n">ingredient</code><code class="calibre17">,</code> <code class="n">amount</code> <code class="calibre17">*</code> <code class="n">factor</code><code class="calibre17">,</code> <code class="n">unit</code><code class="calibre17">))</code>
    <code class="k">return</code> <code class="n">new_recipe</code></pre>

<p class="author1">At the time, I mentioned how parts of this code were ugly; one confounding factor was the fact that the first element of the recipe list was a special case: an integer representing the servings. This contrasts with the rest of the list elements, which are tuples representing actual ingredients, such as <code class="calibre17">("flour", 1.5, "cup")</code>. This highlights the troubles of a heterogeneous collection. For every use of your collection, the user needs to remember to handle the special case. This is predicated on the assumption that the developer even knew about the special case in the first place. There’s no way as it stands to represent that a specific element needs to be handled differently. Therefore, a typechecker will not catch when a developer forgets. This leads to brittle code down the road.</p>

<p class="author1">When talking about homogeneity, it’s important to talk about what a <em class="calibre6">single type</em> means.<a data-type="indexterm" data-primary="heterogeneous versus homogeneous collections" data-secondary="single type in homogeneous collections" id="idm45644748565560" class="calibre5"/> When I mention a single type, I’m not necessarily referring to a concrete type in Python; rather, I’m referring to a set of behaviors that define that type. A single type indicates that a consumer must operate on every value of that type in the exact same way. For the cookbook list, the single type is a <code class="calibre17">Cookbook</code>. For the dictionary example, the key’s single type is a string and the value’s single type is an integer. For heterogeneous collections, this will not always be the case. What do you do if you must have different types in your collection and there is no relation between them?</p>

<p class="author1">Consider what my ugly code from <a data-type="xref" href="part0003_split_000.html#intro" class="calibre5">Chapter 1</a> communicates:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">adjust_recipe</code><code class="calibre17">(</code><code class="n">recipe</code><code class="calibre17">,</code> <code class="n">servings</code><code class="calibre17">):</code>
    <code class="sd">"""</code>
<code class="sd">    Take a meal recipe and change the number of servings</code>
<code class="sd">    :param recipe: A list, where the first element is the number of servings,</code>
<code class="sd">                   and the remainder of elements follow the (name, amount, unit)</code>
<code class="sd">                   format, such as ("flour", 1.5, "cup")</code>
<code class="sd">    :param servings: the number of servings</code>
<code class="sd">    :return list: a new list of ingredients, where the first element is the</code>
<code class="sd">                  number of servings</code>
<code class="sd">    """</code>
    <code class="c"># ...</code></pre>

<p class="author1">There is a lot of information in the docstring, but docstrings have no guarantee of being correct. They also won’t protect developers if they accidentally break assumptions. This code does not communicate intention adequately to future collaborators. Those future collaborators won’t be able to reason about your code. The last thing you want to burden them with is having to go through the codebase, looking for invocations and implementations to work out how to use your collection. Ultimately, you need a way to reconcile the first element (an integer) with the remaining elements in the list (which are tuples). <a data-type="indexterm" data-primary="Union types" data-secondary="use with heterogeneous collection" id="idm45644748547912" class="calibre5"/>To solve this, I’ll use a <code class="calibre17">Union</code> (and some type aliases to make the code more readable):</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">Ingredient</code> <code class="calibre17">=</code> <code class="nb">tuple</code><code class="calibre17">[</code><code class="nb">str</code><code class="calibre17">,</code> <code class="nb">int</code><code class="calibre17">,</code> <code class="nb">str</code><code class="calibre17">]</code> <code class="c"># (name, quantity, units)</code>
<code class="n">Recipe</code> <code class="calibre17">=</code> <code class="nb">list</code><code class="calibre17">[</code><code class="n">Union</code><code class="calibre17">[</code><code class="nb">int</code><code class="calibre17">,</code> <code class="n">Ingredient</code><code class="calibre17">]]</code> <code class="c"># the list can be servings or ingredients</code>
<code class="k">def</code> <code class="nf">adjust_recipe</code><code class="calibre17">(</code><code class="n">recipe</code><code class="calibre17">:</code> <code class="n">Recipe</code><code class="calibre17">,</code> <code class="n">servings</code><code class="calibre17">):</code>
    <code class="c"># ...</code></pre>

<p class="author1">This takes a heterogeneous collection (items could be an integer or an ingredient) and allows developers to reason about the collection as if it were homogeneous. The developer needs to treat every single value as the same—it is either an integer or an <code class="calibre17">Ingredient</code>—before operating on it. While more code is needed to handle the typechecks, you can rest easier knowing that your typechecker will catch users not checking for special cases. Bear in mind, this is not perfect by any means; it’d be better if there was no special case in the first place and <code class="calibre17">servings</code> was passed to the function another way. But for the cases where you absolutely must handle special cases, represent them as a type so that the typechecker benefits you.</p>
<div data-type="tip" class="calibre21"><h6 class="calibre22">Tip</h6>
<p class="author1">When heterogeneous collections are complex enough that they involve lots of validation logic strewn about your codebase, consider making them a user-defined type, such as a data class or class. Consult <a data-type="xref" href="part0011.html#part_2" class="calibre5">Part II</a> for more information on creating user-defined types.<a data-type="indexterm" data-primary="heterogeneous versus homogeneous collections" data-secondary="making heterogeneous collection user-defined type" id="idm45644748462792" class="calibre5"/><a data-type="indexterm" data-primary="user-defined types" id="idm45644748461720" class="calibre5"/></p>
</div>

<p class="author1">You can add too many types in a <code class="calibre17">Union</code>, though. The more special cases of types you handle, the more code a developer has to write every time they use that type, and the more unwieldy the codebase becomes.</p>

<p class="author1">At the far end of the spectrum lies the <code class="calibre17">Any</code> type. <code class="calibre17">Any</code> can be used to indicate that all types are valid in this context. This sounds appealing to get around special cases, but it also means that the consumers of your collection have no clue what to do with the values in the collection, defeating the purpose of type annotations in the first place.</p>
<div data-type="warning" epub:type="warning" class="calibre23"><h6 class="calibre24">Warning</h6>
<p class="author1">Developers working in a statically typed language don’t need to put in as much care to ensure collections are homogeneous; the static type system does that for them already. The challenge in Python is due to Python’s dynamically typed nature. It is much easier for a developer to create a heterogeneous collection without any warnings from the language itself.</p>
</div>

<p class="author1">Heterogeneous collection types still have a lot of uses; don’t assume that you should<a data-type="indexterm" data-primary="heterogeneous versus homogeneous collections" data-secondary="uses of heterogeneous collections" id="idm45644748456424" class="calibre5"/> use homogeneity for every collection type because it is easier to reason about.<a data-type="indexterm" data-primary="tuples" data-secondary="heterogeneous" id="idm45644748455256" class="calibre5"/>  Tuples, for example, are often heterogeneous.</p>

<p class="author1">Suppose a tuple containing a name and page count represents a <code class="calibre17">Cookbook</code>:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">Cookbook</code> <code class="calibre17">=</code> <code class="nb">tuple</code><code class="calibre17">[</code><code class="nb">str</code><code class="calibre17">,</code> <code class="nb">int</code><code class="calibre17">]</code> <code class="c"># name, page count</code></pre>

<p class="author1">I am describing specific fields for this tuple: name and page count. This is a prime example of an heterogeneous collection:</p>

<ul class="printings">
<li class="calibre9">
<p class="author1">Each field (name and page count) will always be in the same order.</p>
</li>
<li class="calibre9">
<p class="author1">All names are strings; all page counts are integers.</p>
</li>
<li class="calibre9">
<p class="author1">Iterating over the tuple is rare, since I won’t treat both types the same.</p>
</li>
<li class="calibre9">
<p class="author1">Name and page count are fundamentally different types, and should not be treated as equivalent.</p>
</li>
</ul>

<p class="author1">When accessing a tuple, you will typically index to the specific field you want:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">food_lab</code><code class="calibre17">:</code> <code class="n">Cookbook</code> <code class="calibre17">=</code> <code class="calibre17">(</code><code class="s">"The Food Lab"</code><code class="calibre17">,</code> <code class="mi">958</code><code class="calibre17">)</code>
<code class="n">odd_bits</code><code class="calibre17">:</code> <code class="n">Cookbook</code> <code class="calibre17">=</code> <code class="calibre17">(</code><code class="s">"Odd Bits"</code><code class="calibre17">,</code> <code class="mi">248</code><code class="calibre17">)</code>

<code class="k">print</code><code class="calibre17">(</code><code class="n">food_lab</code><code class="calibre17">[</code><code class="mi">0</code><code class="calibre17">])</code>
<code class="calibre17">&gt;&gt;&gt;</code> <code class="s">"The Food Lab"</code>

<code class="k">print</code><code class="calibre17">(</code><code class="n">odd_bits</code><code class="calibre17">[</code><code class="mi">1</code><code class="calibre17">])</code>
<code class="calibre17">&gt;&gt;&gt;</code> <code class="mi">248</code></pre>

<p class="author1">However, in many codebases, tuples like these soon become burdensome. Developers tire of writing <code class="calibre17">cookbook[0]</code> whenever they want a name. A better thing to do would be to find some way to name these fields. A first choice might be a dictionary:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">food_lab</code> <code class="calibre17">=</code> <code class="calibre17">{</code>
    <code class="s">"name"</code><code class="calibre17">:</code> <code class="s">"The Food Lab"</code><code class="calibre17">,</code>
    <code class="s">"page_count"</code><code class="calibre17">:</code> <code class="mi">958</code>
<code class="calibre17">}</code></pre>

<p class="author1">Now, they can refer to fields as <code class="calibre17">food_lab['name']</code> and <code class="calibre17">food_lab['page_count']</code>. The problem is, dictionaries are typically meant to be a homogeneous mapping from a key to a value.<a data-type="indexterm" data-primary="dictionaries" data-secondary="used to represent heterogeneous data" id="idm45644748341528" class="calibre5"/> However, when dictionaries are used to represent data that is heterogeneous, you run into similar problems as above when writing a valid type annotation. If I want to try to use a type system to represent this dictionary, I end up with the following:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">print_cookbook</code><code class="calibre17">(</code><code class="n">cookbook</code><code class="calibre17">:</code> <code class="nb">dict</code><code class="calibre17">[</code><code class="nb">str</code><code class="calibre17">,</code> <code class="n">Union</code><code class="calibre17">[</code><code class="nb">str</code><code class="calibre17">,</code><code class="nb">int</code><code class="calibre17">]])</code>
    <code class="c"># ...</code></pre>

<p class="author1">This approach has the following problems:</p>

<ul class="printings">
<li class="calibre9">
<p class="author1">Large dictionaries may have many different types of values. Writing a <code class="calibre17">Union</code> is quite cumbersome.</p>
</li>
<li class="calibre9">
<p class="author1">It is tedious for a user to handle every case for every dictionary access. (Since I indicate that the dictionary is homogeneous, I convey to developers that they need to treat every value as the same type, meaning typechecks for every value access. <em class="calibre6">I</em> know that the <code class="calibre17">name</code> is always a <code class="calibre17">str</code> and the <code class="calibre17">page_count</code> is always an <code class="calibre17">int</code>, but a consumer of this type would not know that.)</p>
</li>
<li class="calibre9">
<p class="author1">Developers do not have any indication what keys are available in the dictionary. They must search all the code from dictionary creation time to the current access to see what fields have been added.</p>
</li>
<li class="calibre9">
<p class="author1">As the dictionary grows, developers have a tendency to use <code class="calibre17">Any</code> as the type of the value.<a data-type="indexterm" data-primary="Any type" id="idm45644748268408" class="calibre5"/> Using <code class="calibre17">Any</code> defeats the purpose of the typechecker in this case.</p>
</li>
</ul>
<div data-type="note" epub:type="note" class="calibre21"><h6 class="calibre22">Note</h6>
<p class="author1"><code class="calibre17">Any</code> can be used for valid type annotations; it merely indicates that you are making zero assumptions about what the type is. For instance, if you wanted to copy a list, the type signature would be <code class="calibre17">def copy(coll: list[Any]) -&gt; list[Any]</code>. Of course, you could also do <code class="calibre17">def copy(coll: list) -&gt; list</code>, and it would mean the same thing.</p>
</div>

<p class="author1">These problems all stem from heterogeneous data in homogeneous data collections. You either pass the burden onto the caller or abandon type annotations completely. In some cases, you want the caller to explicitly check each type on each value access, but in other cases, this is overcomplicated and tedious. So, how can you explain your reasoning with heterogeneous types, especially in cases where keeping data in a <span class="calibre">dictionary</span> is natural, such as API interactions or user-configurable data?<a data-type="indexterm" data-primary="heterogeneous versus homogeneous collections" data-startref="ix_hevho" id="idm45644748262904" class="calibre5"/><a data-type="indexterm" data-primary="collections" data-secondary="homogeneous versus heterogeneous" data-startref="ix_collHvH" id="idm45644748261832" class="calibre5"/> For these cases, you should use a <code class="calibre17">TypedDict</code>.</p>
</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. Collection Types" class="preface">
<div class="preface" id="collections">
<section data-type="sect1" data-pdf-bookmark="TypedDict" class="preface"><div class="preface" id="idm45644748720856">
<h1 class="calibre12" id="calibre_pb_3">TypedDict</h1>

<p class="author1"><code class="calibre17">TypedDict</code>, introduced in Python 3.8, is for the scenarios where you absolutely must store heterogeneous data in a dictionary.<a data-type="indexterm" data-primary="dictionaries" data-secondary="TypedDict, using to store heterogeneous data" id="idm45644748258264" class="calibre5"/><a data-type="indexterm" data-primary="TypedDict" id="idm45644748257320" class="calibre5"/><a data-type="indexterm" data-primary="collections" data-secondary="TypedDict, using to store heterogeneous data" id="idm45644748256648" class="calibre5"/><a data-type="indexterm" data-primary="heterogeneous versus homogeneous collections" data-secondary="TypedDict, using to store heterogeneous data in a dictionary" id="idm45644748255672" class="calibre5"/> These are typically situations where you can’t avoid heterogeneous data. JSON APIs, YAML, TOML, XML, and CSVs all have easy-to-use Python modules that convert these data formats into a dictionary and are naturally hetereogeneous. This means the data that gets returned has all the same problems as listed in the previous section. Your typechecker won’t help out much and users won’t know what keys and values are available.</p>
<div data-type="tip" class="calibre21"><h6 class="calibre22">Tip</h6>
<p class="author1">If you have full control of the dictionary, meaning you create it in code you own and handle it in code you own, you should consider using a <code class="calibre17">dataclass</code> (see <a data-type="xref" href="part0013_split_000.html#dataclasses" class="calibre5">Chapter 9</a>) or a <code class="calibre17">class</code> (see <a data-type="xref" href="part0014_split_000.html#classes" class="calibre5">Chapter 10</a>) instead.</p>
</div>

<p class="author1">For example, suppose I want to augment my digital cookbook app to provide nutritional information for the recipes listed.<a data-type="indexterm" data-primary="APIs" data-secondary="returning heterogeneous dictionaries, TypedDict and" id="idm45644748232296" class="calibre5"/> I decide to use the <a href="https://oreil.ly/joTNh" class="calibre5">Spoonacular API</a> and write some code to get nutritional information:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">nutrition_information</code> <code class="calibre17">=</code> <code class="n">get_nutrition_from_spoonacular</code><code class="calibre17">(</code><code class="n">recipe_name</code><code class="calibre17">)</code>
<code class="c"># print grams of fat in recipe</code>
<code class="k">print</code><code class="calibre17">(</code><code class="n">nutrition_information</code><code class="calibre17">[</code><code class="s">"fat"</code><code class="calibre17">][</code><code class="s">"value"</code><code class="calibre17">])</code></pre>

<p class="author1">If you were reviewing the code, how would you know that this code is right? If you wanted to also print out the calories, how do you access the data? What guarantees do you have about the fields inside of this dictionary? To answer these questions, you have two options:</p>

<ul class="printings">
<li class="calibre9">
<p class="author1">Look up the API documentation (if any) and confirm that the right fields are being used. In this scenario, you hope that the documentation is actually complete and correct.</p>
</li>
<li class="calibre9">
<p class="author1">Run the code and print out the returned dictionary. In this situation, you hope that test responses are pretty identical to production responses.</p>
</li>
</ul>

<p class="author1">The problem is that you are requiring every reader, reviewer, and maintainer to do one of these two steps in order to understand the code. If they don’t, you will not get good code review feedback and developers will run the risk of using the response incorrectly. This leads to incorrect assumptions and brittle code. <code class="calibre17">TypedDict</code> allows you to encode what you’ve learned about that API directly into your type system.</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">typing</code> <code class="k">import</code> <code class="n">TypedDict</code>
<code class="k">class</code> <code class="nc">Range</code><code class="calibre17">(</code><code class="n">TypedDict</code><code class="calibre17">):</code>
    <code class="nb">min</code><code class="calibre17">:</code> <code class="nb">float</code>
    <code class="nb">max</code><code class="calibre17">:</code> <code class="nb">float</code>

<code class="k">class</code> <code class="nc">NutritionInformation</code><code class="calibre17">(</code><code class="n">TypedDict</code><code class="calibre17">):</code>
    <code class="n">value</code><code class="calibre17">:</code> <code class="nb">int</code>
    <code class="n">unit</code><code class="calibre17">:</code> <code class="nb">str</code>
    <code class="n">confidenceRange95Percent</code><code class="calibre17">:</code> <code class="n">Range</code>
    <code class="n">standardDeviation</code><code class="calibre17">:</code> <code class="nb">float</code>

<code class="k">class</code> <code class="nc">RecipeNutritionInformation</code><code class="calibre17">(</code><code class="n">TypedDict</code><code class="calibre17">):</code>
    <code class="n">recipes_used</code><code class="calibre17">:</code> <code class="nb">int</code>
    <code class="n">calories</code><code class="calibre17">:</code> <code class="n">NutritionInformation</code>
    <code class="n">fat</code><code class="calibre17">:</code> <code class="n">NutritionInformation</code>
    <code class="n">protein</code><code class="calibre17">:</code> <code class="n">NutritionInformation</code>
    <code class="n">carbs</code><code class="calibre17">:</code> <code class="n">NutritionInformation</code>

<code class="n">nutrition_information</code><code class="calibre17">:</code><code class="n">RecipeNutritionInformation</code> <code class="calibre17">=</code> \
	<code class="n">get_nutrition_from_spoonacular</code><code class="calibre17">(</code><code class="n">recipe_name</code><code class="calibre17">)</code></pre>

<p class="author1">Now it is incredibly apparent exactly what data types you can rely upon. If the API ever changes, a developer can update all the <code class="calibre17">TypedDict</code> classes and let the typechecker catch any incongruities. Your typechecker now completely understands your dictionary, and readers of your code can reason about responses without having to do any external searching.</p>

<p class="author1">Even better, these <code class="calibre17">TypedDict</code> collections can be as arbitrarily complex as you need them to be. You’ll see that I nested <code class="calibre17">TypedDict</code> instances for reusability purposes, but you can also embed your own custom types, <code class="calibre17">Unions</code>, and <code class="calibre17">Optionals</code> to reflect the possibilities that an API can return. And while I’ve mostly been talking about API, remember that these benefits apply to any heterogeneous dictionary, such as when reading JSON or YAML.</p>
<div data-type="note" epub:type="note" class="calibre21"><h6 class="calibre22">Note</h6>
<p class="author1"><code class="calibre17">TypedDict</code> is only for the typechecker’s benefit. There is no runtime validation at all; the runtime type is just a dictionary.</p>
</div>

<p class="author1">So far, I’ve been teaching you how to deal with built-in collection types: lists/sets/dictionaries for homogeneous collections and tuples/<code class="calibre17">TypedDict</code> for heterogenous collections. What if these types don’t do <em class="calibre6">everything</em> that you want? What if you want to create new collections that are easy to use? To do that, you’ll need a new set of tools.</p>
</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. Collection Types" class="preface">
<div class="preface" id="collections">
<section data-type="sect1" data-pdf-bookmark="Creating New Collections" class="preface"><div class="preface" id="idm45644748259784">
<h1 class="calibre12" id="calibre_pb_4">Creating New Collections</h1>

<p class="author1">When writing a new collection, you should ask yourself: am I trying to write a new collection that isn’t representable by another <a data-type="indexterm" data-primary="collections" data-secondary="creating new" id="idm45644748098872" class="calibre5"/>collection type, or am I trying to modify an existing collection to provide some new behavior? Depending on the answer, you may need to employ different techniques to achieve your goal.</p>

<p class="author1">If you write a collection type that isn’t representable by another collection type, you are bound to come across <em class="calibre6">generics</em> at some point.</p>








</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. Collection Types" class="preface">
<div class="preface" id="collections">
<section data-type="sect1" data-pdf-bookmark="Creating New Collections" class="preface">
<div class="preface" id="idm45644748259784">
<section data-type="sect2" data-pdf-bookmark="Generics" class="preface"><div class="preface" id="idm45644748096504">
<h2 class="calibre34" id="calibre_pb_5">Generics</h2>

<p class="author1">A generic type indicates that you don’t care what type you are using.<a data-type="indexterm" data-primary="generics" data-secondary="collections" id="ix_gencoll" class="calibre5"/><a data-type="indexterm" data-primary="collections" data-secondary="creating new" data-tertiary="generics" id="idm45644748093496" class="calibre5"/> However, it helps restrict users from mixing types where inappropriate.</p>

<p class="author1">Consider the innocuous reverse list function:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">reverse</code><code class="calibre17">(</code><code class="n">coll</code><code class="calibre17">:</code> <code class="nb">list</code><code class="calibre17">)</code> <code class="calibre17">-&gt;</code> <code class="nb">list</code><code class="calibre17">:</code>
    <code class="k">return</code> <code class="n">coll</code><code class="calibre17">[::</code><code class="calibre17">-</code><code class="mi">1</code><code class="calibre17">]</code></pre>

<p class="author1">How do I indicate that the returned list should contain the same type as the passed-in list? To achieve this, I use a generic, which is done with a <code class="calibre17">TypeVar</code> in Python:<a data-type="indexterm" data-primary="TypeVar" id="idm45644748081272" class="calibre5"/><a data-type="indexterm" data-primary="lists" data-secondary="generic" id="idm45644748080664" class="calibre5"/></p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">typing</code> <code class="k">import</code> <code class="n">TypeVar</code>
<code class="n">T</code> <code class="calibre17">=</code> <code class="n">TypeVar</code><code class="calibre17">(</code><code class="s">'T'</code><code class="calibre17">)</code>
<code class="k">def</code> <code class="nf">reverse</code><code class="calibre17">(</code><code class="n">coll</code><code class="calibre17">:</code> <code class="nb">list</code><code class="calibre17">[</code><code class="n">T</code><code class="calibre17">])</code> <code class="calibre17">-&gt;</code> <code class="nb">list</code><code class="calibre17">[</code><code class="n">T</code><code class="calibre17">]:</code>
    <code class="k">return</code> <code class="n">coll</code><code class="calibre17">[::</code><code class="calibre17">-</code><code class="mi">1</code><code class="calibre17">]</code></pre>

<p class="author1">This says that for a type <code class="calibre17">T</code>, reverse takes in a list of elements of type <code class="calibre17">T</code> and returns a list of elements of type <code class="calibre17">T</code>. I can’t mix types: a list of integers will never be able to become a list of strings if those lists aren’t using the same <code class="calibre17">TypeVar</code>.</p>

<p class="author1">I can use this sort of pattern to define entire classes. Suppose I want to integrate a cookbook recommender service into the cookbook collection app. I want to be able to recommend cookbooks or recipes based on a customer’s ratings. To do this, I want to store each of these pieces of rating information in a <em class="calibre6">graph</em>. <a data-type="indexterm" data-primary="graphs" id="idm45644748002120" class="calibre5"/>A graph is a data structure that contains a series of entities known as <em class="calibre6">nodes</em> and that tracks <em class="calibre6">edges</em> (relationships between those nodes).<a data-type="indexterm" data-primary="nodes" id="idm45644748000536" class="calibre5"/><a data-type="indexterm" data-primary="edges" id="idm45644747999832" class="calibre5"/> However, I don’t want to write separate code for a cookbook graph and a recipe graph. So I define a <code class="calibre17">Graph</code> class that can be used for generic types:<a data-type="indexterm" data-primary="graphs" data-secondary="defining Graph class to use for generic types" id="idm45644747998472" class="calibre5"/></p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">collections</code> <code class="k">import</code> <code class="n">defaultdict</code>
<code class="k">from</code> <code class="nn">typing</code> <code class="k">import</code> <code class="n">Generic</code><code class="calibre17">,</code> <code class="n">TypeVar</code>

<code class="n">Node</code> <code class="calibre17">=</code> <code class="n">TypeVar</code><code class="calibre17">(</code><code class="s">"Node"</code><code class="calibre17">)</code>
<code class="n">Edge</code> <code class="calibre17">=</code> <code class="n">TypeVar</code><code class="calibre17">(</code><code class="s">"Edge"</code><code class="calibre17">)</code>

<code class="c"># directed graph</code>
<code class="k">class</code> <code class="nc">Graph</code><code class="calibre17">(</code><code class="n">Generic</code><code class="calibre17">[</code><code class="n">Node</code><code class="calibre17">,</code> <code class="n">Edge</code><code class="calibre17">]):</code>
    <code class="k">def</code> <code class="calibre17">__init__</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">):</code>
        <code class="nb">self</code><code class="calibre17">.</code><code class="n">edges</code><code class="calibre17">:</code> <code class="nb">dict</code><code class="calibre17">[</code><code class="n">Node</code><code class="calibre17">,</code> <code class="nb">list</code><code class="calibre17">[</code><code class="n">Edge</code><code class="calibre17">]]</code> <code class="calibre17">=</code> <code class="n">defaultdict</code><code class="calibre17">(</code><code class="nb">list</code><code class="calibre17">)</code>

    <code class="k">def</code> <code class="nf">add_relation</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code> <code class="n">node</code><code class="calibre17">:</code> <code class="n">Node</code><code class="calibre17">,</code> <code class="n">to</code><code class="calibre17">:</code> <code class="n">Edge</code><code class="calibre17">):</code>
        <code class="nb">self</code><code class="calibre17">.</code><code class="n">edges</code><code class="calibre17">[</code><code class="n">node</code><code class="calibre17">]</code><code class="calibre17">.</code><code class="n">append</code><code class="calibre17">(</code><code class="n">to</code><code class="calibre17">)</code>

    <code class="k">def</code> <code class="nf">get_relations</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code> <code class="n">node</code><code class="calibre17">:</code> <code class="n">Node</code><code class="calibre17">)</code> <code class="calibre17">-&gt;</code> <code class="nb">list</code><code class="calibre17">[</code><code class="n">Edge</code><code class="calibre17">]:</code>
        <code class="k">return</code> <code class="nb">self</code><code class="calibre17">.</code><code class="n">edges</code><code class="calibre17">[</code><code class="n">node</code><code class="calibre17">]</code></pre>

<p class="author1">With this code, I can define all sorts of graphs and still have them typecheck <span class="calibre">successfully</span>:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">cookbooks</code><code class="calibre17">:</code> <code class="n">Graph</code><code class="calibre17">[</code><code class="n">Cookbook</code><code class="calibre17">,</code> <code class="n">Cookbook</code><code class="calibre17">]</code> <code class="calibre17">=</code> <code class="n">Graph</code><code class="calibre17">()</code>
<code class="n">recipes</code><code class="calibre17">:</code> <code class="n">Graph</code><code class="calibre17">[</code><code class="n">Recipe</code><code class="calibre17">,</code> <code class="n">Recipe</code><code class="calibre17">]</code> <code class="calibre17">=</code> <code class="n">Graph</code><code class="calibre17">()</code>

<code class="n">cookbook_recipes</code><code class="calibre17">:</code> <code class="n">Graph</code><code class="calibre17">[</code><code class="n">Cookbook</code><code class="calibre17">,</code> <code class="n">Recipe</code><code class="calibre17">]</code> <code class="calibre17">=</code> <code class="n">Graph</code><code class="calibre17">()</code>

<code class="n">recipes</code><code class="calibre17">.</code><code class="n">add_relation</code><code class="calibre17">(</code><code class="n">Recipe</code><code class="calibre17">(</code><code class="s">'Pasta Bolognese'</code><code class="calibre17">),</code>
                     <code class="n">Recipe</code><code class="calibre17">(</code><code class="s">'Pasta with Sausage and Basil'</code><code class="calibre17">))</code>

<code class="n">cookbook_recipes</code><code class="calibre17">.</code><code class="n">add_relation</code><code class="calibre17">(</code><code class="n">Cookbook</code><code class="calibre17">(</code><code class="s">'The Food Lab'</code><code class="calibre17">),</code>
                              <code class="n">Recipe</code><code class="calibre17">(</code><code class="s">'Pasta Bolognese'</code><code class="calibre17">))</code></pre>

<p class="author1">Whereas this code does not typecheck:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">cookbooks</code><code class="calibre17">.</code><code class="n">add_relation</code><code class="calibre17">(</code><code class="n">Recipe</code><code class="calibre17">(</code><code class="s">'Cheeseburger'</code><code class="calibre17">),</code> <code class="n">Recipe</code><code class="calibre17">(</code><code class="s">'Hamburger'</code><code class="calibre17">))</code></pre>
<pre class="calibre35">code_examples/chapter5/invalid/graph.py:25:
    error: Argument 1 to "add_relation" of "Graph" has
           incompatible type "Recipe"; expected "Cookbook"</pre>

<p class="author1">Using generics can help you write collections that use types consistently throughout their lifetime. This reduces the amount of duplication in your codebase, which minimizes<a data-type="indexterm" data-primary="generics" data-secondary="collections" data-startref="ix_gencoll" id="idm45644747794104" class="calibre5"/> the chances of bugs and reduces cognitive burden.</p>
<aside data-type="sidebar" epub:type="sidebar" class="calibre32"><div class="sidebar" id="idm45644747792840">
<h5 class="calibre33">Other Uses for Generics</h5>
<p class="author1">While generics are often used for collections, you can technically use them for any type.<a data-type="indexterm" data-primary="generics" data-secondary="using for types other than collections" id="idm45644747791192" class="calibre5"/> For example, suppose you want to simplify your API error handling.<a data-type="indexterm" data-primary="errors" data-secondary="simplifying API error handling" id="idm45644747790120" class="calibre5"/> You’ve already forced your code to return a <code class="calibre17">Union</code> of the response type and an error type like so:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">get_nutrition_info</code><code class="o">(</code><code class="n">recipe</code><code class="o">:</code> <code class="nb">str</code><code class="o">)</code> <code class="o">-&gt;</code> <code class="n">Union</code><code class="o">[</code><code class="n">NutritionInfo</code><code class="o">,</code> <code class="n">APIError</code><code class="o">]:</code>
    <code class="c"># ...</code>

<code class="k">def</code> <code class="nf">get_ingredients</code><code class="o">(</code><code class="n">recipe</code><code class="o">:</code> <code class="nb">str</code><code class="o">)</code> <code class="o">-&gt;</code> <code class="n">Union</code><code class="o">[</code><code class="nb">list</code><code class="o">[</code><code class="n">Ingredient</code><code class="o">],</code> <code class="n">APIError</code><code class="o">]:</code>
    <code class="c">#...</code>

<code class="k">def</code> <code class="nf">get_restaurants_serving</code><code class="o">(</code><code class="n">recipe</code><code class="o">:</code> <code class="nb">str</code><code class="o">)</code> <code class="o">-&gt;</code> <code class="n">Union</code><code class="o">[</code><code class="nb">list</code><code class="o">[</code><code class="n">Restaurant</code><code class="o">],</code> <code class="n">APIError</code><code class="o">]:</code>
    <code class="c"># ...</code></pre>

<p class="author1">But this is unneccessarily duplicated code. You have to specify a <code class="calibre17">Union[X, APIError]</code> each time, where only <code class="calibre17">X</code> changes.<a data-type="indexterm" data-primary="Union types" id="idm45644747617736" class="calibre5"/> What if you wanted to change the error response class, or force users to handle different types of errors separately? Generics can help with deduplicating these types:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">T</code> <code class="o">=</code> <code class="n">TypeVar</code><code class="o">(</code><code class="s">"T"</code><code class="o">)</code>
<code class="n">APIResponse</code> <code class="o">=</code> <code class="n">Union</code><code class="o">[</code><code class="n">T</code><code class="o">,</code> <code class="n">APIError</code><code class="o">]</code>

<code class="k">def</code> <code class="nf">get_nutrition_info</code><code class="o">(</code><code class="n">recipe</code><code class="o">:</code> <code class="nb">str</code><code class="o">)</code> <code class="o">-&gt;</code> <code class="n">APIResponse</code><code class="o">[</code><code class="n">NutritionInfo</code><code class="o">]:</code>
    <code class="c"># ...</code>

<code class="k">def</code> <code class="nf">get_ingredients</code><code class="o">(</code><code class="n">recipe</code><code class="o">:</code> <code class="nb">str</code><code class="o">)</code> <code class="o">-&gt;</code> <code class="n">APIResponse</code><code class="o">[</code><code class="nb">list</code><code class="o">[</code><code class="n">Ingredient</code><code class="o">]]:</code>
    <code class="c">#...</code>

<code class="k">def</code> <code class="nf">get_restaurants_serving</code><code class="o">(</code><code class="n">recipe</code><code class="o">:</code> <code class="nb">str</code><code class="o">)</code> <code class="o">-&gt;</code> <code class="n">APIResponse</code><code class="o">[</code><code class="nb">list</code><code class="o">[</code><code class="n">Restaurant</code><code class="o">]]:</code>
    <code class="c"># ...</code></pre>

<p class="author1">Now you have a single place to control all of your API error handling. If you were to change it, you can rely on your typechecker to catch all the places needing changes.</p>
</div></aside>
</div></section>













</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. Collection Types" class="preface">
<div class="preface" id="collections">
<section data-type="sect1" data-pdf-bookmark="Creating New Collections" class="preface">
<div class="preface" id="idm45644748259784">
<section data-type="sect2" data-pdf-bookmark="Modifying Existing Types" class="preface"><div class="preface" id="idm45644748095848">
<h2 class="calibre34" id="calibre_pb_6">Modifying Existing Types</h2>

<p class="author1">Generics are nice for creating your own collection types, but what if you just want to tweak some behavior of an existing collection type, such as a list or dictionary?<a data-type="indexterm" data-primary="collections" data-secondary="creating new" data-tertiary="modifying existing types" id="idm45644747548776" class="calibre5"/> Having to completely rewrite all the semantics of a collection would be tedious and error-prone. Thankfully, methods exist to make this a snap. Let’s go back to our cookbook app. I’ve written code earlier that grabs nutrition information, but now I want to store all that nutrition information in a dictionary.</p>

<p class="author1">However, I hit a problem: the same ingredient has very different names depending on where you’re from. Take a dark leafy green, common in salads. While an American chef might call it “arugula,” a European might call it “rocket.” This doesn’t even begin to cover the names in languages other than English. To combat this, I want to create a dictionary-like object that automatically handles these aliases:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="calibre17">&gt;&gt;&gt;</code> <code class="n">nutrition</code> <code class="calibre17">=</code> <code class="n">NutritionalInformation</code><code class="calibre17">()</code>
<code class="calibre17">&gt;&gt;&gt;</code> <code class="n">nutrition</code><code class="calibre17">[</code><code class="s">"arugula"</code><code class="calibre17">]</code> <code class="calibre17">=</code> <code class="n">get_nutrition_information</code><code class="calibre17">(</code><code class="s">"arugula"</code><code class="calibre17">)</code>
<code class="calibre17">&gt;&gt;&gt;</code> <code class="k">print</code><code class="calibre17">(</code><code class="n">nutrition</code><code class="calibre17">[</code><code class="s">"rocket"</code><code class="calibre17">])</code> <code class="c"># arugula is the same as rocket</code>
<code class="calibre17">{</code>
    <code class="s">"name"</code><code class="calibre17">:</code> <code class="s">"arugula"</code><code class="calibre17">,</code>
    <code class="s">"calories_per_serving"</code><code class="calibre17">:</code> <code class="mi">5</code><code class="calibre17">,</code>
    <code class="c"># ... snip ...</code>
<code class="calibre17">}</code></pre>

<p class="author1">So how can I write <code class="calibre17">NutritionalInformation</code> to act like a dict?</p>

<p class="author1">A lot of a developer’s first instinct is to subclass dictionaries.<a data-type="indexterm" data-primary="dictionaries" data-secondary="subclassing and overriding methods" id="idm45644747531192" class="calibre5"/> No worries if you aren’t awesome at subclassing; I’ll be going much more in depth in <a data-type="xref" href="part0016_split_000.html#subtyping" class="calibre5">Chapter 12</a>. For now, just treat subclassing as a way of saying, “I want my subclass to behave exactly like the parent class.” However, you’ll learn that subclassing a dictionary may not always be what you want. Consider the following code:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">class</code><code class="calibre17"> </code><code class="nc">NutritionalInformation</code><code class="calibre17">(</code><code class="nb">dict</code><code class="calibre17">)</code><code class="calibre17">:</code><code class="calibre17"> </code><a class="calibre5" id="co_collection_types_CO1-1" href="part0008_split_006.html#callout_collection_types_CO1-1"><img src="../images/00002.gif" alt="1" class="calibre40"/></a><code class="calibre17">
</code><code class="calibre17">    </code><code class="k">def</code><code class="calibre17"> </code><code class="calibre17">__getitem__</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code><code class="calibre17"> </code><code class="n">key</code><code class="calibre17">)</code><code class="calibre17">:</code><code class="calibre17"> </code><a class="calibre5" id="co_collection_types_CO1-2" href="part0008_split_006.html#callout_collection_types_CO1-2"><img src="../images/00005.gif" alt="2" class="calibre40"/></a><code class="calibre17">
</code><code class="calibre17">        </code><code class="k">try</code><code class="calibre17">:</code><code class="calibre17">
</code><code class="calibre17">            </code><code class="k">return</code><code class="calibre17"> </code><code class="nb">super</code><code class="calibre17">(</code><code class="calibre17">)</code><code class="calibre17">.</code><code class="calibre17">__getitem__</code><code class="calibre17">(</code><code class="n">key</code><code class="calibre17">)</code><code class="calibre17"> </code><a class="calibre5" id="co_collection_types_CO1-3" href="part0008_split_006.html#callout_collection_types_CO1-3"><img src="../images/00006.gif" alt="3" class="calibre40"/></a><code class="calibre17">
</code><code class="calibre17">        </code><code class="k">except</code><code class="calibre17"> </code><code class="ne">KeyError</code><code class="calibre17">:</code><code class="calibre17">
</code><code class="calibre17">            </code><code class="k">pass</code><code class="calibre17">
</code><code class="calibre17">        </code><code class="k">for</code><code class="calibre17"> </code><code class="n">alias</code><code class="calibre17"> </code><code class="calibre19">in</code><code class="calibre17"> </code><code class="n">get_aliases</code><code class="calibre17">(</code><code class="n">key</code><code class="calibre17">)</code><code class="calibre17">:</code><code class="calibre17">
</code><code class="calibre17">            </code><code class="k">try</code><code class="calibre17">:</code><code class="calibre17"> </code><a class="calibre5" id="co_collection_types_CO1-4" href="part0008_split_006.html#callout_collection_types_CO1-4"><img src="../images/00007.gif" alt="4" class="calibre40"/></a><code class="calibre17">
</code><code class="calibre17">                </code><code class="k">return</code><code class="calibre17"> </code><code class="nb">super</code><code class="calibre17">(</code><code class="calibre17">)</code><code class="calibre17">.</code><code class="calibre17">__getitem__</code><code class="calibre17">(</code><code class="n">alias</code><code class="calibre17">)</code><code class="calibre17">
</code><code class="calibre17">            </code><code class="k">except</code><code class="calibre17"> </code><code class="ne">KeyError</code><code class="calibre17">:</code><code class="calibre17">
</code><code class="calibre17">                </code><code class="k">pass</code><code class="calibre17">
</code><code class="calibre17">        </code><code class="k">raise</code><code class="calibre17"> </code><code class="ne">KeyError</code><code class="calibre17">(</code><code class="n">f</code><code class="s">"</code><code class="s">Could not find {key} or any of its aliases</code><code class="s">"</code><code class="calibre17">)</code><code class="calibre17"> </code><a class="calibre5" id="co_collection_types_CO1-5" href="part0008_split_006.html#callout_collection_types_CO1-5"><img src="../images/00008.gif" alt="5" class="calibre40"/></a></pre>
<dl class="calibre13">
<dt class="calibre14"><a class="calibre5" id="callout_collection_types_CO1-1" href="part0008_split_006.html#co_collection_types_CO1-1"><img src="../images/00002.gif" alt="1" class="calibre40"/></a></dt>
<dd class="calibre41"><p class="calibre42">The <code class="calibre17">(dict)</code> syntax indicates that we are subclassing from dictionaries.</p></dd>
<dt class="calibre14"><a class="calibre5" id="callout_collection_types_CO1-2" href="part0008_split_006.html#co_collection_types_CO1-2"><img src="../images/00005.gif" alt="2" class="calibre40"/></a></dt>
<dd class="calibre41"><p class="calibre42"><code class="calibre17">__getitem__</code> is what gets called when you use brackets to check a key in a dictionary: (<code class="calibre17">nutrition["rocket"]</code>) calls <code class="calibre17">__getitem__(nutrition, "rocket")</code>.</p></dd>
<dt class="calibre14"><a class="calibre5" id="callout_collection_types_CO1-3" href="part0008_split_006.html#co_collection_types_CO1-3"><img src="../images/00006.gif" alt="3" class="calibre40"/></a></dt>
<dd class="calibre41"><p class="calibre42">If a key is found, use the parent dictionary’s key check.</p></dd>
<dt class="calibre14"><a class="calibre5" id="callout_collection_types_CO1-4" href="part0008_split_006.html#co_collection_types_CO1-4"><img src="../images/00007.gif" alt="4" class="calibre40"/></a></dt>
<dd class="calibre41"><p class="calibre42">For every alias, check if it is in the dictionary.</p></dd>
<dt class="calibre14"><a class="calibre5" id="callout_collection_types_CO1-5" href="part0008_split_006.html#co_collection_types_CO1-5"><img src="../images/00008.gif" alt="5" class="calibre40"/></a></dt>
<dd class="calibre41"><p class="calibre42">Throw a <code class="calibre17">KeyError</code> if no key is found, either with what’s passed in or any of its aliases.</p></dd>
</dl>

<p class="author1">We are <a data-type="indexterm" data-primary="overriding methods on collections" id="idm45644747301560" class="calibre5"/>overriding the <code class="calibre17">__getitem__</code> function, and this works!</p>

<p class="author1">If I try to access <code class="calibre17">nutrition["rocket"]</code> in that snippet above, I get the same nutritional information as <code class="calibre17">nutrition["arugula"]</code>. Huzzah! So you deploy it in production and call it a day.</p>

<p class="author1">But (and there’s always a but), as time goes on, a developer comes to you and complains that sometimes the dictionary doesn’t work. You spend some time debugging, and it always works for you. You look for race conditions, threading, API tomfoolery, or any other nondeterminism, and come up with absolutely zero potential bugs. Finally, you get some time where you can sit with the other developer and see what they are doing.</p>

<p class="author1">And sitting at their terminal are the following lines:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="c"># arugula is the same as rocket</code>
<code class="calibre17">&gt;&gt;&gt;</code> <code class="n">nutrition</code> <code class="calibre17">=</code> <code class="n">NutritionalInformation</code><code class="calibre17">()</code>
<code class="calibre17">&gt;&gt;&gt;</code> <code class="n">nutrition</code><code class="calibre17">[</code><code class="s">"arugula"</code><code class="calibre17">]</code> <code class="calibre17">=</code> <code class="n">get_nutrition_information</code><code class="calibre17">(</code><code class="s">"arugula"</code><code class="calibre17">)</code>
<code class="calibre17">&gt;&gt;&gt;</code> <code class="k">print</code><code class="calibre17">(</code><code class="n">nutrition</code><code class="calibre17">.</code><code class="n">get</code><code class="calibre17">(</code><code class="s">"rocket"</code><code class="calibre17">,</code> <code class="s">"No Ingredient Found"</code><code class="calibre17">))</code>
<code class="s">"No Ingredient Found"</code></pre>

<p class="author1">The <code class="calibre17">get</code> function on a dictionary tries to get the key, and if not found, will return the second argument (in this case “No Ingredient Found”). Herein lies the problem: when <a data-type="indexterm" data-primary="dictionaries" data-secondary="subclassing and overriding methods" data-tertiary="problems with" id="idm45644747275064" class="calibre5"/>subclassing from a dictionary and overriding methods, you have no guarantee that those methods are called from every other method in the dictionary. Built-in collection types are built with performance in mind; many methods use inlined code to go fast. This means that overriding one method, such as <code class="calibre17">__getitem__</code>, will not be used in most dictionary methods. This certainly violates the Law of Least Surprise, which we talked about in <a data-type="xref" href="part0003_split_000.html#intro" class="calibre5">Chapter 1</a>.</p>
<div data-type="note" epub:type="note" class="calibre21"><h6 class="calibre22">Note</h6>
<p class="author1">It is OK to subclass from the built-in collection if you are only adding methods, but because future modifications may make this same mistake, I still prefer to use one of the other methods of building custom collections.</p>
</div>

<p class="author1">So overriding <code class="calibre17">dict</code> is out. Instead I’ll use types from the <code class="calibre17">collections</code> module. For this case, there <a data-type="indexterm" data-primary="UserDict type" id="idm45644747269192" class="calibre5"/>is a handy type called <code class="calibre17">collections.UserDict</code>. <code class="calibre17">UserDict</code> fits the exact use case that I need: I can subclass from <code class="calibre17">UserDict</code>, override key methods, and get the behavior I expect.</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">collections</code> <code class="k">import</code> <code class="n">UserDict</code>
<code class="k">class</code> <code class="nc">NutritionalInformation</code><code class="calibre17">(</code><code class="n">UserDict</code><code class="calibre17">):</code>
    <code class="k">def</code> <code class="calibre17">__getitem__</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code> <code class="n">key</code><code class="calibre17">):</code>
        <code class="k">try</code><code class="calibre17">:</code>
            <code class="k">return</code> <code class="nb">self</code><code class="calibre17">.</code><code class="n">data</code><code class="calibre17">[</code><code class="n">key</code><code class="calibre17">]</code>
        <code class="k">except</code> <code class="ne">KeyError</code><code class="calibre17">:</code>
            <code class="k">pass</code>
        <code class="k">for</code> <code class="n">alias</code> <code class="calibre19">in</code> <code class="n">get_aliases</code><code class="calibre17">(</code><code class="n">key</code><code class="calibre17">):</code>
            <code class="k">try</code><code class="calibre17">:</code>
                <code class="k">return</code> <code class="nb">self</code><code class="calibre17">.</code><code class="n">data</code><code class="calibre17">[</code><code class="n">alias</code><code class="calibre17">]</code>
            <code class="k">except</code> <code class="ne">KeyError</code><code class="calibre17">:</code>
                <code class="k">pass</code>
        <code class="k">raise</code> <code class="ne">KeyError</code><code class="calibre17">(</code><code class="n">f</code><code class="s">"Could not find {key} or any of its aliases"</code><code class="calibre17">)</code></pre>

<p class="author1">This fits your use case exactly.<a data-type="indexterm" data-primary="self.data, using with user collection classes" id="idm45644747265512" class="calibre5"/> You subclass from <code class="calibre17">UserDict</code> instead of <code class="calibre17">dict</code>, and then use <code class="calibre17">self.data</code> to access the underlying dictionary.</p>

<p class="author1">You go run your teammate’s code again:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="c"># arugula is the same as rocket</code>
<code class="calibre17">&gt;&gt;&gt;</code> <code class="k">print</code><code class="calibre17">(</code><code class="n">nutrition</code><code class="calibre17">.</code><code class="n">get</code><code class="calibre17">(</code><code class="s">"rocket"</code><code class="calibre17">,</code> <code class="s">"No Ingredient Found"</code><code class="calibre17">))</code>
<code class="calibre17">{</code>
    <code class="s">"name"</code><code class="calibre17">:</code> <code class="s">"arugula"</code><code class="calibre17">,</code>
    <code class="s">"calories_per_serving"</code><code class="calibre17">:</code> <code class="mi">5</code><code class="calibre17">,</code>
    <code class="c"># ... snip ...</code>
<code class="calibre17">}</code></pre>

<p class="author1">And you get the nutrition information for arugula.</p>

<p class="author1"><code class="calibre17">UserDict</code> isn’t the only collection type that you can override in this case. There also is a <code class="calibre17">UserString</code> and a <code class="calibre17">UserList</code> in the collections model.<a data-type="indexterm" data-primary="UserString type" id="idm45644747139928" class="calibre5"/><a data-type="indexterm" data-primary="UserList type" id="idm45644747139224" class="calibre5"/> Anytime you want to tweak a dictionary, string, or list, these are the collections you want to use.</p>
<div data-type="warning" epub:type="warning" class="calibre23"><h6 class="calibre24">Warning</h6>
<p class="author1">Inheriting from these classes does incur a performance cost. Built-in collections make some assumptions in order to achieve performance. With <code class="calibre17">UserDict</code>, <code class="calibre17">UserString</code>, and <code class="calibre17">UserList</code>, methods can’t be inlined, since you might override them. If you need to use these constructs in performance-critical code, make sure you benchmark and measure your code to find potential problems.</p>
</div>

<p class="author1">You’ll notice that I talked about dictionaries, lists, and strings above, but left out one big built-in: sets.  There exists no <code class="calibre17">UserSet</code> in the <code class="calibre17">collections</code> module. I’ll have to select a different abstraction from the <code class="calibre17">collections</code> module. More specifically, I need abstract base classes, which are found in <code class="calibre17">collections.abc</code>.</p>
</div></section>













</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. Collection Types" class="preface">
<div class="preface" id="collections">
<section data-type="sect1" data-pdf-bookmark="Creating New Collections" class="preface">
<div class="preface" id="idm45644748259784">
<section data-type="sect2" data-pdf-bookmark="As Easy as ABC" class="preface"><div class="preface" id="idm45644747549880">
<h2 class="calibre34" id="calibre_pb_7">As Easy as ABC</h2>

<p class="author1">Abstract base classes (ABCs) in the <code class="calibre17">collections.abc</code> module provide another grouping of classes that you can override to create your own collections.<a data-type="indexterm" data-primary="ABCs (abstract base classes)" id="idm45644747131144" class="calibre5"/><a data-type="indexterm" data-primary="collections" data-secondary="creating new" data-tertiary="ABCs" id="idm45644747130472" class="calibre5"/> ABCs are classes intended to be subclassed, and require the subclass to implement very specific functions. For the <code class="calibre17">collections.abc</code>, these ABCs are all centered on custom collections. In order to create a custom collection, you must override specific functions, depending on the type you want to emulate. Once you implement these required functions, though, the ABC fills in other functions automatically. You can find a <span class="calibre">full list</span> of required functions to implement at the <code class="calibre17">collections.abc's</code> <a href="https://oreil.ly/kb8j3" class="calibre5">module documentation</a>.</p>
<div data-type="note" epub:type="note" class="calibre21"><h6 class="calibre22">Note</h6>
<p class="author1">In contrast to the <code class="calibre17">User*</code> classes,  there is no built-in storage, such as <code class="calibre17">self.data</code>, inside the <code class="calibre17">collections.abc</code> classes. You must provide your own storage.</p>
</div>

<p class="author1">Let’s look at a <code class="calibre17">collections.abc.Set</code>, since there is no <code class="calibre17">UserSet</code> elsewhere in collections.<a data-type="indexterm" data-primary="sets" data-secondary="collections.abc.Set" id="idm45644747122696" class="calibre5"/> I want to create a custom set that automatically handles aliases of ingredients (such as rocket and arugula). In order to create this custom set, I need to implement three methods, as required by <code class="calibre17">collections.abc.Set</code>:</p>
<dl class="calibre13">
<dt class="calibre14"><code class="calibre17">__contains__</code></dt>
<dd class="calibre15">
<p class="calibre16">This is for membership checks: <code class="calibre17">"arugula" in ingredients</code>.</p>
</dd>
<dt class="calibre14"><code class="calibre17">__iter__</code></dt>
<dd class="calibre15">
<p class="calibre16">This is for iterating: <code class="calibre17">for ingredient in ingredients</code>.</p>
</dd>
<dt class="calibre14"><code class="calibre17">__len__</code></dt>
<dd class="calibre15">
<p class="calibre16">This is for checking the length: <code class="calibre17">len(ingredients)</code>.</p>
</dd>
</dl>

<p class="author1">Once these three methods are defined, methods like relational operations, equality operations, and set operations (union, intersection, difference, disjoint) will just work. That’s the beauty of <code class="calibre17">collections.abc</code>. Once you define a select few methods, the rest come for free. Here it is in action:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">import</code> <code class="nn">collections</code>
<code class="k">class</code> <code class="nc">AliasedIngredients</code><code class="calibre17">(</code><code class="n">collections</code><code class="calibre17">.</code><code class="n">abc</code><code class="calibre17">.</code><code class="n">Set</code><code class="calibre17">):</code>
    <code class="k">def</code> <code class="calibre17">__init__</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code> <code class="n">ingredients</code><code class="calibre17">:</code> <code class="nb">set</code><code class="calibre17">[</code><code class="nb">str</code><code class="calibre17">]):</code>
        <code class="nb">self</code><code class="calibre17">.</code><code class="n">ingredients</code> <code class="calibre17">=</code> <code class="n">ingredients</code>

    <code class="k">def</code> <code class="calibre17">__contains__</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">,</code> <code class="n">value</code><code class="calibre17">:</code> <code class="nb">str</code><code class="calibre17">):</code>
        <code class="k">return</code> <code class="n">value</code> <code class="calibre19">in</code> <code class="nb">self</code><code class="calibre17">.</code><code class="n">ingredients</code> <code class="calibre19">or</code> <code class="nb">any</code><code class="calibre17">(</code><code class="n">alias</code> <code class="calibre19">in</code> <code class="nb">self</code><code class="calibre17">.</code><code class="n">ingredients</code>
                                                <code class="k">for</code> <code class="n">alias</code> <code class="calibre19">in</code> <code class="n">get_aliases</code><code class="calibre17">(</code><code class="n">value</code><code class="calibre17">))</code>

    <code class="k">def</code> <code class="calibre17">__iter__</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">):</code>
        <code class="k">return</code> <code class="nb">iter</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">.</code><code class="n">ingredients</code><code class="calibre17">)</code>

    <code class="k">def</code> <code class="calibre17">__len__</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">):</code>
        <code class="k">return</code> <code class="nb">len</code><code class="calibre17">(</code><code class="nb">self</code><code class="calibre17">.</code><code class="n">ingredients</code><code class="calibre17">)</code>

<code class="calibre17">&gt;&gt;&gt;</code> <code class="n">ingredients</code> <code class="calibre17">=</code> <code class="n">AliasedIngredients</code><code class="calibre17">({</code><code class="s">'arugula'</code><code class="calibre17">,</code> <code class="s">'eggplant'</code><code class="calibre17">,</code> <code class="s">'pepper'</code><code class="calibre17">})</code>
<code class="calibre17">&gt;&gt;&gt;</code> <code class="k">for</code> <code class="n">ingredient</code> <code class="calibre19">in</code> <code class="n">ingredients</code><code class="calibre17">:</code>
<code class="calibre17">&gt;&gt;&gt;</code>    <code class="k">print</code><code class="calibre17">(</code><code class="n">ingredient</code><code class="calibre17">)</code>
<code class="s">'arugula'</code>
<code class="s">'eggplant'</code>
<code class="s">'pepper'</code>

<code class="calibre17">&gt;&gt;&gt;</code> <code class="k">print</code><code class="calibre17">(</code><code class="nb">len</code><code class="calibre17">(</code><code class="n">ingredients</code><code class="calibre17">))</code>
<code class="mi">3</code>

<code class="calibre17">&gt;&gt;&gt;</code> <code class="k">print</code><code class="calibre17">(</code><code class="s">'arugula'</code> <code class="calibre19">in</code> <code class="n">ingredients</code><code class="calibre17">)</code>
<code class="nb">True</code>

<code class="calibre17">&gt;&gt;&gt;</code> <code class="k">print</code><code class="calibre17">(</code><code class="s">'rocket'</code> <code class="calibre19">in</code> <code class="n">ingredients</code><code class="calibre17">)</code>
<code class="nb">True</code>

<code class="calibre17">&gt;&gt;&gt;</code> <code class="nb">list</code><code class="calibre17">(</code><code class="n">ingredients</code> <code class="calibre17">|</code> <code class="n">AliasedIngredients</code><code class="calibre17">({</code><code class="s">'garlic'</code><code class="calibre17">}))</code>
<code class="calibre17">[</code><code class="s">'pepper'</code><code class="calibre17">,</code> <code class="s">'arugula'</code><code class="calibre17">,</code> <code class="s">'eggplant'</code><code class="calibre17">,</code> <code class="s">'garlic'</code><code class="calibre17">]</code></pre>

<p class="author1">That’s not the only cool thing about <code class="calibre17">collections.abc</code>, though. Using it in type annotations can help you write more generic code.<a data-type="indexterm" data-primary="type annotations" data-secondary="using collections.abc in" id="idm45644747057256" class="calibre5"/> Take this code from all the way back in <a data-type="xref" href="part0005_split_000.html#types" class="calibre5">Chapter 2</a>:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">print_items</code><code class="calibre17">(</code><code class="n">items</code><code class="calibre17">):</code>
    <code class="k">for</code> <code class="n">item</code> <code class="calibre19">in</code> <code class="n">items</code><code class="calibre17">:</code>
        <code class="k">print</code><code class="calibre17">(</code><code class="n">item</code><code class="calibre17">)</code>

<code class="n">print_items</code><code class="calibre17">([</code><code class="mi">1</code><code class="calibre17">,</code><code class="mi">2</code><code class="calibre17">,</code><code class="mi">3</code><code class="calibre17">])</code>
<code class="n">print_items</code><code class="calibre17">({</code><code class="mi">4</code><code class="calibre17">,</code> <code class="mi">5</code><code class="calibre17">,</code> <code class="mi">6</code><code class="calibre17">})</code>
<code class="n">print_items</code><code class="calibre17">({</code><code class="s">"A"</code><code class="calibre17">:</code> <code class="mi">1</code><code class="calibre17">,</code> <code class="s">"B"</code><code class="calibre17">:</code> <code class="mi">2</code><code class="calibre17">,</code> <code class="s">"C"</code><code class="calibre17">:</code> <code class="mi">3</code><code class="calibre17">})</code></pre>

<p class="author1">I talked about <a data-type="indexterm" data-primary="duck typing" id="idm45644746792664" class="calibre5"/>how duck typing can be both a boon and a curse for robst code. It’s great that I can write a single function that can take so many different types, but communicating intent through type annotations becomes challenging. Fortunately, I can use the <code class="calibre17">collections.abc</code> classes to provide type hints:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">print_items</code><code class="calibre17">(</code><code class="n">items</code><code class="calibre17">:</code> <code class="n">collections</code><code class="calibre17">.</code><code class="n">abc</code><code class="calibre17">.</code><code class="n">Iterable</code><code class="calibre17">):</code>
    <code class="k">for</code> <code class="n">item</code> <code class="calibre19">in</code> <code class="n">items</code><code class="calibre17">:</code>
        <code class="k">print</code><code class="calibre17">(</code><code class="n">item</code><code class="calibre17">)</code></pre>

<p class="author1">In this case, I am indicating that items are simply iterable through the <code class="calibre17">Iterable</code> ABC. As long as the parameter supports an <code class="calibre17">__iter__</code> method (and most collections do), this code will typecheck.<a data-type="indexterm" data-primary="Iterable ABC" id="idm45644746867640" class="calibre5"/></p>

<p class="author1">As of Python 3.9, there are 25 different ABCs for you to use. Check them all out in the <a href="https://oreil.ly/lDeak" class="calibre5">Python documentation</a>.</p>
</div></section>





</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. Collection Types" class="preface">
<div class="preface" id="collections">
<section data-type="sect1" data-pdf-bookmark="Closing Thoughts" class="preface"><div class="preface" id="idm45644747133000">
<h1 class="calibre12" id="calibre_pb_8">Closing Thoughts</h1>

<p class="author1">You can’t go far without running into collections in Python. Lists, dictionaries, and sets are commonplace, and it’s imperative that you provide hints to the future about what collection types you’re working with. Consider whether your collections are homogeneous or heterogeneous and what that tells future readers. For the cases where you do use heterogeneous collections, provide enough information for other developers to reason about them, such as a <code class="calibre17">TypedDict</code>. Once you learn the techniques to allow other developers to reason about your collections, your codebase becomes so much more understandable.</p>

<p class="author1">Always think through your options when creating new collections:</p>

<ul class="printings">
<li class="calibre9">
<p class="author1">If you are just extending a type, such as adding new methods, you can subclass directly from collections such as a list or dictionary. However, beware the rough edges, as there is some surprising Python behavior if a user ever overrides a built-in method.</p>
</li>
<li class="calibre9">
<p class="author1">If you are looking to change out a small part of a list, dictionary or string, use <code class="calibre17">collections.UserList</code>, <code class="calibre17">collections.UserDict</code>, or <code class="calibre17">collections.UserString</code>, respectively. Remember to reference <code class="calibre17">self.data</code> to access the storage of the respective type.</p>
</li>
<li class="calibre9">
<p class="author1">If you need to write a more complicated class with the interface of another collection type, use <code class="calibre17">collections.abc</code>. You will need to provide your own storage for the data inside the class and implement all required methods, but once you do, you can customize that collection to your heart’s content.</p>
</li>
</ul>
</div></section>







</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. Collection Types" class="preface">
<div class="preface" id="collections">
<section data-type="sect1" data-pdf-bookmark="Closing Thoughts" class="preface">
<div class="preface" id="idm45644747133000">
<div data-type="note" epub:type="note" class="calibre21"><h1 class="calibre38" id="calibre_pb_9">Discussion Topic</h1>
<p class="author1">Look through the uses of collections and generics in your codebase, and assess how much information is conveyed to future developers. How many custom collection types are in your codebase? What can a new developer tell about the collection types by just looking at type signatures and names? Are there collections you could be defining more generically? What about other types using generics?</p>
</div>

<p class="author1">Now, type annotations don’t reach their full potential without the aid of a typechecker. In the next chapter, I’m going to focus on the typechecker itself. You’ll learn how to effectively configure a typechecker, generate reports, and evaluate different checkers. The more you know about a tool, the more effectively you can wield it. This is especially true for your typechecker.<a data-type="indexterm" data-primary="collections" data-startref="ix_coll" id="idm45644746854280" class="calibre5"/></p>
</div></section>







</div></section></body></html>