<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. Automation with Nox"><div class="chapter" id="chapter_nox">
<h1><span class="label">Chapter 8. </span>Automation with Nox</h1>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id303">
<h1>A Note for Early Release Readers</h1>
<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>

<p>This will be the eighth chapter of the final book. Please note that the GitHub repo will be made active later on.</p>

<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the author at <a href="mailto:mail@claudiojolowicz.com">mail@claudiojolowicz.com</a>.</p>
</div></aside>

<p>When you maintain a Python project, you’re faced with many chores. Running
checks on your code is an important part:</p>

<ul>
<li>
<p>Testing helps you reduce the defect rate of your code (<a data-type="xref" href="ch06.html#chapter_testing">Chapter 6</a>).</p>
</li>
<li>
<p>Coverage reporting pinpoints untested parts of your code (<a data-type="xref" href="ch07.html#chapter_coverage">Chapter 7</a>).</p>
</li>
<li>
<p>Linters analyze your source code to find ways to improve it
(<a data-type="xref" href="ch09.html#chapter_linting">Chapter 9</a>).</p>
</li>
<li>
<p>Code formatters lay out the source code in a readable way
(<a data-type="xref" href="ch09.html#chapter_linting">Chapter 9</a>).</p>
</li>
<li>
<p>Type checkers verify the type correctness of your code (<a data-type="xref" href="ch10.html#chapter_typing">Chapter 10</a>).</p>
</li>
</ul>

<p>Other chores include:</p>

<ul>
<li>
<p>You need to build and publish packages for distribution
(<a data-type="xref" href="ch03.html#chapter_packages">Chapter 3</a>).</p>
</li>
<li>
<p>You need to update the dependencies of your project
(<a data-type="xref" href="ch04.html#chapter_dependencies">Chapter 4</a>).</p>
</li>
<li>
<p>You need to deploy your service (see <a data-type="xref" href="ch05.html#example_docker_poetry_bundle">Example 5-7</a> in
<a data-type="xref" href="ch05.html#chapter_poetry">Chapter 5</a>).</p>
</li>
<li>
<p>You need to build the documentation for your project.</p>
</li>
</ul>

<p>Automating these tasks has many benefits. You focus on coding while the check
suite covers your back. You gain confidence in the steps that take your code
from development to production. You remove human error and encode each process,
so others can review and improve it.</p>

<p>Automation gives you leverage to make each step as repeatable, each result as
reproducible, as possible. Checks and tasks run in the same way on developer
machines and in continuous integration (CI). They run across different Python
versions, operating systems, and platforms.</p>

<p>In this chapter, you’ll learn about Nox, a Python automation framework. Nox
serves as a single entry point to your checks and tasks—​for your team, external
contributors, and automated systems like CI runners.</p>

<p>You write Nox sessions in plain Python: each Nox session is a Python function
that executes commands in a dedicated, isolated environment. Using Python as the
automation language gives Nox great simplicity, portability, and expressivity.</p>






<section data-type="sect1" data-pdf-bookmark="First Steps with Nox"><div class="sect1" id="section_nox_first_steps">
<h1>First Steps with Nox</h1>

<p>Install Nox globally using pipx:</p>
<pre data-type="programlisting">$ <strong>pipx install --python=3.12 nox</strong>
</pre>

<p>Specify the latest stable version of Python—​Nox defaults to that version when
creating environments. Pipx makes the command <code>nox</code> available globally, while
keeping its dependencies isolated from your global Python installation (see
<a data-type="xref" href="ch02.html#section_environments_pipx">“Installing Applications with Pipx”</a>).</p>

<p>Configure Nox in a Python file named <em>noxfile.py</em> in your project, next to
<em>pyproject.toml</em>. <a data-type="xref" href="#example_nox_simple">Example 8-1</a> shows a <em>noxfile.py</em> for running the
test suite. It’s meant for a simple Python project with no test dependencies
besides pytest.</p>
<div id="example_nox_simple" data-type="example">
<h5><span class="label">Example 8-1. </span>A session for running the test suite</h5>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code> <code class="nn">nox</code>

<code class="nd">@nox</code><code class="o">.</code><code class="n">session</code>
<code class="k">def</code> <code class="nf">tests</code><code class="p">(</code><code class="n">session</code><code class="p">):</code>
    <code class="n">session</code><code class="o">.</code><code class="n">install</code><code class="p">(</code><code class="s2">"."</code><code class="p">,</code> <code class="s2">"pytest"</code><code class="p">)</code>
    <code class="n">session</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="s2">"pytest"</code><code class="p">)</code></pre></div>

<p><em>Sessions</em> are the central concept in Nox: each session comprises an environment
and some commands to run within it. You define a session by writing a Python
function decorated with <code>@nox.session</code>. The function receives a session object
as an argument, which you can use to install packages (<code>session.install</code>) and
run commands (<code>session.run</code>) in the session environment.</p>

<p>You can try the session with the example project from previous chapters. For
now, add your test dependencies to the <code>session.install</code> arguments:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">session</code><code class="o">.</code><code class="n">install</code><code class="p">(</code><code class="s2">"."</code><code class="p">,</code> <code class="s2">"pytest"</code><code class="p">,</code> <code class="s2">"pytest-httpserver"</code><code class="p">,</code> <code class="s2">"factory-boy"</code><code class="p">)</code></pre>

<p>Invoke <code>nox</code> without arguments to run all sessions in the <em>noxfile.py</em>:</p>
<pre data-type="programlisting">$ <strong>nox</strong>
nox &gt; Running session tests
nox &gt; Creating virtual environment (virtualenv) using python in .nox/tests
nox &gt; python -m pip install . pytest
nox &gt; pytest
========================= tests session starts =========================
...
========================== 21 passed in 0.94s ==========================
nox &gt; Session tests was successful.
</pre>

<p>As you can see from the output, Nox starts by creating a virtual environment for
the <code>tests</code> session using <code>virtualenv</code>. If you’re curious, you can find this
environment under the <em>.nox</em> directory in your project.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>By default, environments use the same interpreter as Nox itself. In
<a data-type="xref" href="#section_nox_pythons">“Working with Multiple Python Interpreters”</a>, you’ll learn how to run sessions on another
interpreter, and even across multiple ones.</p>
</div>

<p>First, the session installs the project and pytest into its environment. The
function <code>session.install</code> is just <code>pip install</code> underneath. You can pass any
appropriate options and arguments to pip. For example, you can install your
dependencies from a requirements file:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">session</code><code class="o">.</code><code class="n">install</code><code class="p">(</code><code class="s2">"-r"</code><code class="p">,</code> <code class="s2">"dev-requirements.txt"</code><code class="p">)</code>
<code class="n">session</code><code class="o">.</code><code class="n">install</code><code class="p">(</code><code class="s2">"."</code><code class="p">,</code> <code class="s2">"--no-deps"</code><code class="p">)</code></pre>

<p>If you keep your development dependencies in an extra, use the following:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">session</code><code class="o">.</code><code class="n">install</code><code class="p">(</code><code class="s2">".[tests]"</code><code class="p">)</code></pre>

<p>Above, you’ve used <code>session.install(".")</code> to install your project. Behind the
scenes, pip builds a wheel using the build backend you’ve specified in
<em>pyproject.toml</em>. Nox runs in the directory containing <em>noxfile.py</em>, so this
command assumes both files are in the same directory.</p>

<p>Nox lets you use <code>uv</code> instead of virtualenv and pip for creating environments
and installing packages. You can switch the backend to <code>uv</code> by setting an
environment variable:</p>
<pre data-type="programlisting">$ <strong>export NOX_DEFAULT_VENV_BACKEND=uv</strong></pre>

<p>Second, the session runs the <code>pytest</code> command you just installed. If a command
fails, the session is marked as failed. By default, Nox continues with the next
session, but it will exit with a non-zero status at the end if any session
failed. In the run above, the test suite passes and Nox reports success.</p>

<p><a data-type="xref" href="#example_nox_build">Example 8-2</a> adds a session to build packages for the project (see
<a data-type="xref" href="ch03.html#chapter_packages">Chapter 3</a>). The session also validates the packages using Twine’s
<code>check</code> command.</p>
<div id="example_nox_build" data-type="example">
<h5><span class="label">Example 8-2. </span>A session for building packages</h5>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code> <code class="nn">shutil</code>
<code class="kn">from</code> <code class="nn">pathlib</code> <code class="kn">import</code> <code class="n">Path</code>

<code class="nd">@nox</code><code class="o">.</code><code class="n">session</code>
<code class="k">def</code> <code class="nf">build</code><code class="p">(</code><code class="n">session</code><code class="p">):</code>
    <code class="n">session</code><code class="o">.</code><code class="n">install</code><code class="p">(</code><code class="s2">"build"</code><code class="p">,</code> <code class="s2">"twine"</code><code class="p">)</code>

    <code class="n">distdir</code> <code class="o">=</code> <code class="n">Path</code><code class="p">(</code><code class="s2">"dist"</code><code class="p">)</code>
    <code class="k">if</code> <code class="n">distdir</code><code class="o">.</code><code class="n">exists</code><code class="p">():</code>
        <code class="n">shutil</code><code class="o">.</code><code class="n">rmtree</code><code class="p">(</code><code class="n">distdir</code><code class="p">)</code>

    <code class="n">session</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="s2">"python"</code><code class="p">,</code> <code class="s2">"-m"</code><code class="p">,</code> <code class="s2">"build"</code><code class="p">)</code>
    <code class="n">session</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="s2">"twine"</code><code class="p">,</code> <code class="s2">"check"</code><code class="p">,</code> <code class="o">*</code><code class="n">distdir</code><code class="o">.</code><code class="n">glob</code><code class="p">(</code><code class="s2">"*"</code><code class="p">))</code></pre></div>

<p><a data-type="xref" href="#example_nox_build">Example 8-2</a> relies on the standard library for clearing out stale
packages and locating the freshly built ones: <code>Path.glob</code> matches files against
wildcards, and <code>shutil.rmtree</code> removes a directory and its contents.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Nox doesn’t implicitly run commands in a shell, unlike tools such as <code>make</code>.
Shells differ widely between platforms, so they’d make Nox sessions less
portable. For the same reason, avoid Unix utilities like <code>rm</code> or <code>find</code> in your
sessions—use Python’s standard library instead!</p>
</div>

<p>The programs you invoke with <code>session.run</code> should be available inside the
environment. If they’re not, Nox prints a friendly warning and falls back to the
system-wide environment. In the Python world, running programs outside their
intended environment is a mistake that’s easy to make and hard to diagnose. Turn
the warning into an error! <a data-type="xref" href="#example_nox_external_error">Example 8-3</a> shows how.</p>
<div id="example_nox_external_error" data-type="example">
<h5><span class="label">Example 8-3. </span>Preventing external commands in Nox sessions</h5>

<pre data-type="programlisting" data-code-language="python"><code class="n">nox</code><code class="o">.</code><code class="n">options</code><code class="o">.</code><code class="n">error_on_external_run</code><code> </code><code class="o">=</code><code> </code><code class="kc">True</code><code> </code><a class="co" id="co_automation_with_nox_CO1-1" href="#callout_automation_with_nox_CO1-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></pre></div>
<dl class="calloutlist">
<dt><a class="co" id="callout_automation_with_nox_CO1-1" href="#co_automation_with_nox_CO1-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Modify <code>nox.options</code> at the top of your <em>noxfile.py</em>, outside of sessions.</p></dd>
</dl>

<p>At times, you do need to run external commands, such as non-Python build tools.
You can allow external commands by passing the <code>external</code> flag to <code>session.run</code>.
<a data-type="xref" href="#example_nox_external">Example 8-4</a> shows how to build packages using an existing Poetry
installation on your system.</p>
<div id="example_nox_external" data-type="example">
<h5><span class="label">Example 8-4. </span>Using an external command to build the packages</h5>

<pre data-type="programlisting" data-code-language="python"><code class="nd">@nox</code><code class="o">.</code><code class="n">session</code>
<code class="k">def</code> <code class="nf">build</code><code class="p">(</code><code class="n">session</code><code class="p">):</code>
    <code class="n">session</code><code class="o">.</code><code class="n">install</code><code class="p">(</code><code class="s2">"twine"</code><code class="p">)</code>
    <code class="n">session</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="s2">"poetry"</code><code class="p">,</code> <code class="s2">"build"</code><code class="p">,</code> <code class="n">external</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code>
    <code class="n">session</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="s2">"twine"</code><code class="p">,</code> <code class="s2">"check"</code><code class="p">,</code> <code class="o">*</code><code class="n">Path</code><code class="p">()</code><code class="o">.</code><code class="n">glob</code><code class="p">(</code><code class="s2">"dist/*"</code><code class="p">))</code></pre></div>

<p>You’re trading off reliability for speed here. <a data-type="xref" href="#example_nox_build">Example 8-2</a> works with
any build backend declared in <em>pyproject.toml</em> and installs it in an isolated
environment on each run. <a data-type="xref" href="#example_nox_external">Example 8-4</a> assumes that contributors have
a recent version of Poetry on their system and breaks if they don’t. Prefer the
first method unless every developer environment has a well-known Poetry version.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Working with Sessions"><div class="sect1" id="section_nox_sessions">
<h1>Working with Sessions</h1>

<p>Over time, <em>noxfile.py</em> may accumulate a number of sessions. The <code>--list</code> option
gives you a quick overview of them. If you add module and function docstrings
with helpful descriptions, Nox includes them in the listing as well.</p>
<pre data-type="programlisting">$ <strong>nox --list</strong>
Run the checks and tasks for this project.

Sessions defined in /path/to/noxfile.py:

* tests -&gt; Run the test suite.
* build -&gt; Build the package.

sessions marked with * are selected, sessions marked with - are skipped.
</pre>

<p>Running Nox with the <code>--session</code> option lets you select individual sessions by
name:</p>
<pre data-type="programlisting">$ <strong>nox --session tests</strong>
</pre>

<p>During development, running <code>nox</code> repeatedly lets you catch errors early. On the
other hand, you don’t need to validate your packages each time. Fortunately, you
can change which sessions run by default by setting <code>nox.options.sessions</code>:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">nox</code><code class="o">.</code><code class="n">options</code><code class="o">.</code><code class="n">sessions</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"tests"</code><code class="p">]</code></pre>

<p>Now, when you run <code>nox</code> without arguments, only the <code>tests</code> session runs. You
can still select the <code>build</code> session using the <code>--session</code> option. Command-line
options override values specified in <code>nox.options</code> in <em>noxfile.py</em>.<sup><a data-type="noteref" id="id304-marker" href="ch08.html#id304">1</a></sup></p>
<div data-type="tip"><h6>Tip</h6>
<p>Keep your default sessions aligned with the mandatory checks for your project.
Contributors should be able to run <code>nox</code> without arguments to check if their
code changes are acceptable.</p>
</div>

<p>Every time a session runs, Nox creates a fresh virtual environment and installs
the dependencies. This is a good default, because it makes the checks strict,
deterministic, and repeatable. You won’t miss problems with your code due to
stale packages in the session environment.</p>

<p>However, Nox gives you a choice. Setting up environments each time might be a
tad slow if you re-run your tests in quick succession while coding. You can
reuse environments with the option <code>-r</code> or <code>--reuse-existing-virtualenvs</code>.
Additionally, you can skip installation commands by specifying <code>--no-install</code>,
or combine these options using the shorthand <code>-R</code>.</p>
<pre data-type="programlisting">$ <strong>nox -R</strong>
nox &gt; Running session tests
nox &gt; Re-using existing virtual environment at .nox/tests.
nox &gt; pytest
...
nox &gt; Session tests was successful.
</pre>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Working with Multiple Python Interpreters"><div class="sect1" id="section_nox_pythons">
<h1>Working with Multiple Python Interpreters</h1>

<p>If your project supports more than a single version of Python, you should run
your tests on all of them. Nox really shines when it comes to running sessions
on multiple interpreters. When you define the session with <code>@nox.session</code>, use
the <code>python</code> keyword to request one or more specific Python versions, as shown
in <a data-type="xref" href="#example_nox_python">Example 8-5</a>.</p>
<div id="example_nox_python" data-type="example">
<h5><span class="label">Example 8-5. </span>Running tests across multiple Python versions</h5>

<pre data-type="programlisting" data-code-language="python"><code class="nd">@nox</code><code class="o">.</code><code class="n">session</code><code class="p">(</code><code class="n">python</code><code class="o">=</code><code class="p">[</code><code class="s2">"3.12"</code><code class="p">,</code> <code class="s2">"3.11"</code><code class="p">,</code> <code class="s2">"3.10"</code><code class="p">])</code>
<code class="k">def</code> <code class="nf">tests</code><code class="p">(</code><code class="n">session</code><code class="p">):</code>
    <code class="n">session</code><code class="o">.</code><code class="n">install</code><code class="p">(</code><code class="s2">".[tests]"</code><code class="p">)</code>
    <code class="n">session</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="s2">"pytest"</code><code class="p">)</code></pre></div>

<p>Nox creates an environment for each version and runs the commands in those
environments in turn:</p>
<pre data-type="programlisting">$ <strong>nox</strong>
nox &gt; Running session tests-3.12
nox &gt; Creating virtual environment (virtualenv) using python3.12 in .nox/tests-3-12
nox &gt; python -m pip install . pytest
nox &gt; pytest
...
nox &gt; Session tests-3.12 was successful.
nox &gt; Running session tests-3.11
...
nox &gt; Running session tests-3.10
...
nox &gt; Ran multiple sessions:
nox &gt; * tests-3.12: success
nox &gt; * tests-3.11: success
nox &gt; * tests-3.10: success
</pre>
<div data-type="tip"><h6>Tip</h6>
<p>Did you get errors from pip when you ran Nox just now? Don’t use the same
compiled requirements file for every Python version. You need to lock
dependencies separately for each environment (see <a data-type="xref" href="#section_nox_dependencies">“Session Dependencies”</a>).</p>
</div>

<p>You can narrow down sessions by Python version using the option <code>--python</code>:</p>
<pre data-type="programlisting">$ <strong>nox --python 3.12</strong>
nox &gt; Running session tests-3.12
...
</pre>

<p>During development, the <code>--python</code> option comes in handy, as it lets you save
time by running tests on the latest version only.</p>

<p>Nox discovers interpreters by searching <code>PATH</code> for commands like <code>python3.12</code>,
<code>python3.11</code>, and so on. You can also specify a string like <code>"pypy3.10"</code> to
request the PyPy interpreter—​any command that can be resolved against <code>PATH</code>
will work. On Windows, Nox also queries the Python Launcher to find available
interpreters.</p>

<p>Suppose you’ve installed a prerelease of Python and want to test your project
on it. The <code>--python</code> option would require that the session lists the
prerelease. Instead, you can specify <code>--force-python</code>: it overrides the
interpreter for a single run. For example, the following invocation runs the
<code>tests</code> session on Python 3.13:</p>
<pre data-type="programlisting">$ <strong>nox --session tests --force-python 3.13</strong>
</pre>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Session Arguments"><div class="sect1" id="section_nox_session_arguments">
<h1>Session Arguments</h1>

<p>So far, the <code>tests</code> session runs pytest without arguments:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">session</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="s2">"pytest"</code><code class="p">)</code></pre>

<p>You <em>could</em> pass additional options—​such as <code>--verbose</code>, which lists every
individual test separately in the output:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">session</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="s2">"pytest"</code><code class="p">,</code> <code class="s2">"--verbose"</code><code class="p">)</code></pre>

<p>But you don’t always want the same options for pytest. For example, the <code>--pdb</code>
option launches the Python debugger on test failures. The debug prompt can be a
life saver when you investigate a mysterious bug. But it’s worse than useless in
a CI context: it would hang forever since there’s nobody to enter commands.
Similarly, when you work on a feature, the <code>-k</code> option lets you run tests with a
specific keyword in their name—​but you wouldn’t want to hardcode it in
<em>noxfile.py</em> either.</p>

<p>Fortunately, Nox lets you pass additional command-line arguments for a session.
The session can forward the session arguments to a command or evaluate them for
its own purposes. Session arguments are available in the session as
<code>session.posargs</code>. <a data-type="xref" href="#example_nox_posargs">Example 8-6</a> shows how you forward them to a
command like pytest.</p>
<div id="example_nox_posargs" data-type="example">
<h5><span class="label">Example 8-6. </span>Forwarding session arguments to pytest</h5>

<pre data-type="programlisting" data-code-language="python"><code class="nd">@nox</code><code class="o">.</code><code class="n">session</code><code class="p">(</code><code class="n">python</code><code class="o">=</code><code class="p">[</code><code class="s2">"3.12"</code><code class="p">,</code> <code class="s2">"3.11"</code><code class="p">,</code> <code class="s2">"3.10"</code><code class="p">])</code>
<code class="k">def</code> <code class="nf">tests</code><code class="p">(</code><code class="n">session</code><code class="p">):</code>
    <code class="n">session</code><code class="o">.</code><code class="n">install</code><code class="p">(</code><code class="s2">".[tests]"</code><code class="p">)</code>
    <code class="n">session</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="s2">"pytest"</code><code class="p">,</code> <code class="o">*</code><code class="n">session</code><code class="o">.</code><code class="n">posargs</code><code class="p">)</code></pre></div>

<p>You must separate session arguments from Nox’s own command-line arguments with
the <code>--</code> delimiter:</p>
<pre data-type="programlisting">$ <strong>nox --session tests -- --verbose</strong>
</pre>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Automating Coverage"><div class="sect1" id="section_nox_coverage">
<h1>Automating Coverage</h1>

<p>Coverage tools give you a sense of how much your tests exercise the codebase
(see <a data-type="xref" href="ch07.html#chapter_coverage">Chapter 7</a>). In a nutshell, you install the <code>coverage</code> package
and invoke pytest via <code>coverage run</code>. <a data-type="xref" href="#example_nox_coverage_run">Example 8-7</a> shows how to
automate this process with Nox:</p>
<div id="example_nox_coverage_run" data-type="example">
<h5><span class="label">Example 8-7. </span>Running tests with code coverage</h5>

<pre data-type="programlisting" data-code-language="python"><code class="nd">@nox</code><code class="o">.</code><code class="n">session</code><code class="p">(</code><code class="n">python</code><code class="o">=</code><code class="p">[</code><code class="s2">"3.12"</code><code class="p">,</code> <code class="s2">"3.11"</code><code class="p">,</code> <code class="s2">"3.10"</code><code class="p">])</code>
<code class="k">def</code> <code class="nf">tests</code><code class="p">(</code><code class="n">session</code><code class="p">):</code>
    <code class="n">session</code><code class="o">.</code><code class="n">install</code><code class="p">(</code><code class="s2">".[tests]"</code><code class="p">)</code>
    <code class="n">session</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="s2">"coverage"</code><code class="p">,</code> <code class="s2">"run"</code><code class="p">,</code> <code class="s2">"-m"</code><code class="p">,</code> <code class="s2">"pytest"</code><code class="p">,</code> <code class="o">*</code><code class="n">session</code><code class="o">.</code><code class="n">posargs</code><code class="p">)</code></pre></div>

<p>When you’re testing in multiple environments, you need to store the coverage
data from each environment in a separate file (see
<a data-type="xref" href="ch07.html#section_coverage_parallel">“Parallel Coverage”</a>). Add the following lines to <em>pyproject.toml</em> to
enable this mode:</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[tool.coverage.run]</code><code class="w"/>
<code class="n">parallel</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="kc">true</code><code class="w"/></pre>

<p>In <a data-type="xref" href="ch07.html#chapter_coverage">Chapter 7</a>, you installed your project in editable mode. The Nox
session builds and installs a wheel of your project instead. This ensures that
you’re testing the final artifact you’re distributing to users. But it also
means that Coverage.py needs to map the installed files back to your source
tree. Configure the mapping in <em>pyproject.toml</em>:</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[</code><code class="k">tool</code><code class="k">.</code><code class="k">coverage</code><code class="k">.</code><code class="k">paths</code><code class="k">]</code><code class="w">
</code><code class="n">source</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"</code><code class="s2">src</code><code class="s2">"</code><code class="p">,</code><code class="w"> </code><code class="s2">"</code><code class="s2">*/site-packages</code><code class="s2">"</code><code class="p">]</code><code class="w"> </code><a class="co" id="co_automation_with_nox_CO2-1" href="#callout_automation_with_nox_CO2-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_automation_with_nox_CO2-1" href="#co_automation_with_nox_CO2-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>This maps files installed in the <em>site-packages</em> directory in an environment
to files in your <em>src</em> directory. The key <code>source</code> is an arbitrary identifier;
it’s needed because you can have multiple mappings in this section.</p></dd>
</dl>

<p><a data-type="xref" href="#example_nox_coverage_report">Example 8-8</a> aggregates the coverage files and displays the
coverage report:</p>
<div id="example_nox_coverage_report" data-type="example">
<h5><span class="label">Example 8-8. </span>Reporting the code coverage</h5>

<pre data-type="programlisting" data-code-language="python"><code class="nd">@nox</code><code class="o">.</code><code class="n">session</code>
<code class="k">def</code> <code class="nf">coverage</code><code class="p">(</code><code class="n">session</code><code class="p">):</code>
    <code class="n">session</code><code class="o">.</code><code class="n">install</code><code class="p">(</code><code class="s2">"coverage[toml]"</code><code class="p">)</code>
    <code class="k">if</code> <code class="nb">any</code><code class="p">(</code><code class="n">Path</code><code class="p">()</code><code class="o">.</code><code class="n">glob</code><code class="p">(</code><code class="s2">".coverage.*"</code><code class="p">)):</code>
        <code class="n">session</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="s2">"coverage"</code><code class="p">,</code> <code class="s2">"combine"</code><code class="p">)</code>
    <code class="n">session</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="s2">"coverage"</code><code class="p">,</code> <code class="s2">"report"</code><code class="p">)</code></pre></div>

<p>The session only invokes <code>coverage combine</code> if there are any coverage data
files—​the command would fail with an error otherwise. As a result, you can
safely use <code>nox -s coverage</code> to inspect your test coverage without having to
re-run the tests first.</p>

<p>Unlike <a data-type="xref" href="#example_nox_coverage_run">Example 8-7</a>, this session runs on the default Python
version and installs only Coverage.py. You don’t need to install your project to
generate the coverage report.</p>

<p>If you run these sessions on the example project, make sure to configure
Coverage.py as shown in <a data-type="xref" href="ch07.html#chapter_coverage">Chapter 7</a>. Include Python 3.7 in the <code>tests</code>
session if your project uses the conditional import for <code>importlib-metadata</code>.</p>
<pre data-type="programlisting">$ <strong>nox --session coverage</strong>
nox &gt; Running session coverage
nox &gt; Creating virtual environment (uv) using python in .nox/coverage
nox &gt; uv pip install 'coverage[toml]'
nox &gt; coverage combine
nox &gt; coverage report
Name                  Stmts   Miss Branch BrPart  Cover   Missing
-----------------------------------------------------------------
src/.../__init__.py      29      2      8      0    95%   42-43
src/.../__main__.py       2      2      0      0     0%   1-3
tests/__init__.py         0      0      0      0   100%
tests/test_main.py       36      0      6      0   100%
-----------------------------------------------------------------
TOTAL                    67      4     14      0    95%
Coverage failure: total of 95 is less than fail-under=100
nox &gt; Command coverage report failed with exit code 2
nox &gt; Session coverage failed.
</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>coverage</code> session still reports missing coverage for the <code>main</code> function
and the <code>__main__</code> module. You’ll take care of that in
<a data-type="xref" href="#section_nox_subprocess_coverage">“Automating Coverage in Subprocesses”</a>.</p>
</div>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Session Notification"><div class="sect1" id="section_nox_notify">
<h1>Session Notification</h1>

<p>As it stands, this <em>noxfile.py</em> has a subtle problem. Until you run the
<code>coverage</code> session, your project will be littered with data files waiting to be
processed. And if you haven’t run the <code>tests</code> session recently, the data in
those files may be stale—​so your coverage report won’t reflect the latest state
of the codebase.</p>

<p><a data-type="xref" href="#example_nox_coverage_notify">Example 8-9</a> triggers the <code>coverage</code> session to run
automatically after the test suite. Nox supports this with the <code>session.notify</code>
method. If the notified session isn’t already selected, it runs after the other
sessions have completed.</p>
<div id="example_nox_coverage_notify" data-type="example">
<h5><span class="label">Example 8-9. </span>Triggering coverage reports from the tests</h5>

<pre data-type="programlisting" data-code-language="python"><code class="nd">@nox</code><code class="o">.</code><code class="n">session</code><code class="p">(</code><code class="n">python</code><code class="o">=</code><code class="p">[</code><code class="s2">"3.12"</code><code class="p">,</code> <code class="s2">"3.11"</code><code class="p">,</code> <code class="s2">"3.10"</code><code class="p">])</code>
<code class="k">def</code> <code class="nf">tests</code><code class="p">(</code><code class="n">session</code><code class="p">):</code>
    <code class="n">session</code><code class="o">.</code><code class="n">install</code><code class="p">(</code><code class="s2">".[tests]"</code><code class="p">)</code>
    <code class="k">try</code><code class="p">:</code>
        <code class="n">session</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="s2">"coverage"</code><code class="p">,</code> <code class="s2">"run"</code><code class="p">,</code> <code class="s2">"-m"</code><code class="p">,</code> <code class="s2">"pytest"</code><code class="p">,</code> <code class="o">*</code><code class="n">session</code><code class="o">.</code><code class="n">posargs</code><code class="p">)</code>
    <code class="k">finally</code><code class="p">:</code>
        <code class="n">session</code><code class="o">.</code><code class="n">notify</code><code class="p">(</code><code class="s2">"coverage"</code><code class="p">)</code></pre></div>

<p>The <code>try...finally</code> block ensures you get a coverage report even when a test
fails. That’s helpful when you start development with a failing test: you want
to be sure the test exercises the code you’re writing to make it pass.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Automating Coverage in Subprocesses"><div class="sect1" id="section_nox_subprocess_coverage">
<h1>Automating Coverage in Subprocesses</h1>

<p>Alan Kay, a pioneer in object-oriented programming and graphical user interface
design, once said, “Simple things should be simple; complex things should be
possible.”<sup><a data-type="noteref" id="id305-marker" href="ch08.html#id305">2</a></sup> Many Nox sessions will be
two-liners: a line to install dependencies and a line to run a command. Yet some
automations require more complex logic, and Nox excels at those, too—​primarily
by staying out of your way and deferring to Python as a general-purpose
programming language.</p>

<p>Let’s iterate on the <code>tests</code> session and measure coverage in subprocesses. As
you saw in <a data-type="xref" href="ch07.html#chapter_coverage">Chapter 7</a>, setting this up requires a little dance. First,
you install a <em>.pth</em> file into the environment; this gives <code>coverage</code> a chance
to initialize when the subprocess starts up. Second, you set an environment
variable to point <code>coverage</code> to its configuration file. It’s tedious and a bit
tricky to get right. Let’s “automate it away”!</p>

<p>First, you need to determine the location for the <em>.pth</em> file. The directory is
named <em>site-packages</em>, but the exact path depends on your platform and the
Python version. Instead of taking a guess, you can query the <code>sysconfig</code> module
for it:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">sysconfig</code><code class="o">.</code><code class="n">get_path</code><code class="p">(</code><code class="s2">"purelib"</code><code class="p">)</code></pre>

<p>If you called the function directly in your session, it would return a location
in the environment where you’ve installed Nox. Instead, you need to query the
interpreter <em>in the session environment</em>. You can do this by running <code>python</code>
with <code>session.run</code>:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">output</code> <code class="o">=</code> <code class="n">session</code><code class="o">.</code><code class="n">run</code><code class="p">(</code>
    <code class="s2">"python"</code><code class="p">,</code>
    <code class="s2">"-c"</code><code class="p">,</code>
    <code class="s2">"import sysconfig; print(sysconfig.get_path('purelib'))"</code><code class="p">,</code>
    <code class="n">silent</code><code class="o">=</code><code class="kc">True</code><code class="p">,</code>
<code class="p">)</code></pre>

<p>The <code>silent</code> keyword lets you capture the output instead of echoing it to the
terminal. Thanks to <code>pathlib</code> from the standard library, writing the <em>.pth</em> file
now only takes a couple of statements:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">purelib</code> <code class="o">=</code> <code class="n">Path</code><code class="p">(</code><code class="n">output</code><code class="o">.</code><code class="n">strip</code><code class="p">())</code>
<code class="p">(</code><code class="n">purelib</code> <code class="o">/</code> <code class="s2">"_coverage.pth"</code><code class="p">)</code><code class="o">.</code><code class="n">write_text</code><code class="p">(</code>
    <code class="s2">"import coverage; coverage.process_startup()"</code>
<code class="p">)</code></pre>

<p><a data-type="xref" href="#example_nox_coverage_pth">Example 8-10</a> extracts these statements into a helper function.
The function takes a <code>session</code> argument, but it isn’t a Nox session—​it lacks
the <code>@nox.session</code> decorator. In other words, the function won’t run unless you
call it from a session.</p>
<div id="example_nox_coverage_pth" data-type="example">
<h5><span class="label">Example 8-10. </span>Installing <em>coverage.pth</em> into the environment</h5>

<pre data-type="programlisting" data-code-language="python"><code class="k">def</code> <code class="nf">install_coverage_pth</code><code class="p">(</code><code class="n">session</code><code class="p">):</code>
    <code class="n">output</code> <code class="o">=</code> <code class="n">session</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="o">...</code><code class="p">)</code>  <code class="c1"># see above</code>
    <code class="n">purelib</code> <code class="o">=</code> <code class="n">Path</code><code class="p">(</code><code class="n">output</code><code class="o">.</code><code class="n">strip</code><code class="p">())</code>
    <code class="p">(</code><code class="n">purelib</code> <code class="o">/</code> <code class="s2">"_coverage.pth"</code><code class="p">)</code><code class="o">.</code><code class="n">write_text</code><code class="p">(</code><code class="o">...</code><code class="p">)</code>  <code class="c1"># see above</code></pre></div>

<p>You’re almost done. What’s left is invoking the helper function from the <code>tests</code>
session and passing the environment variable to <code>coverage</code>.
<a data-type="xref" href="#example_nox_coverage_subprocess">Example 8-11</a> shows the final session.</p>
<div id="example_nox_coverage_subprocess" data-type="example">
<h5><span class="label">Example 8-11. </span>The <code>tests</code> session with subprocess coverage enabled</h5>

<pre data-type="programlisting" data-code-language="python"><code class="nd">@nox</code><code class="o">.</code><code class="n">session</code><code class="p">(</code><code class="n">python</code><code class="o">=</code><code class="p">[</code><code class="s2">"</code><code class="s2">3.12</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="s2">"</code><code class="s2">3.11</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="s2">"</code><code class="s2">3.10</code><code class="s2">"</code><code class="p">]</code><code class="p">)</code><code>
</code><code class="k">def</code><code> </code><code class="nf">tests</code><code class="p">(</code><code class="n">session</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">session</code><code class="o">.</code><code class="n">install</code><code class="p">(</code><code class="s2">"</code><code class="s2">.[tests]</code><code class="s2">"</code><code class="p">)</code><code> </code><a class="co" id="co_automation_with_nox_CO3-1" href="#callout_automation_with_nox_CO3-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>    </code><code class="n">install_coverage_pth</code><code class="p">(</code><code class="n">session</code><code class="p">)</code><code>
</code><code>
</code><code>    </code><code class="k">try</code><code class="p">:</code><code>
</code><code>        </code><code class="n">args</code><code> </code><code class="o">=</code><code> </code><code class="p">[</code><code class="s2">"</code><code class="s2">coverage</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="s2">"</code><code class="s2">run</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="s2">"</code><code class="s2">-m</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="s2">"</code><code class="s2">pytest</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="o">*</code><code class="n">session</code><code class="o">.</code><code class="n">posargs</code><code class="p">]</code><code>
</code><code>        </code><code class="n">session</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="o">*</code><code class="n">args</code><code class="p">,</code><code> </code><code class="n">env</code><code class="o">=</code><code class="p">{</code><code class="s2">"</code><code class="s2">COVERAGE_PROCESS_START</code><code class="s2">"</code><code class="p">:</code><code> </code><code class="s2">"</code><code class="s2">pyproject.toml</code><code class="s2">"</code><code class="p">}</code><code class="p">)</code><code>
</code><code>    </code><code class="k">finally</code><code class="p">:</code><code>
</code><code>        </code><code class="n">session</code><code class="o">.</code><code class="n">notify</code><code class="p">(</code><code class="s2">"</code><code class="s2">coverage</code><code class="s2">"</code><code class="p">)</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" id="callout_automation_with_nox_CO3-1" href="#co_automation_with_nox_CO3-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Install the dependencies before the <em>.pth</em> file. The order matters because
the <em>.pth</em> file imports the <code>coverage</code> package.</p></dd>
</dl>

<p>With subprocess coverage enabled, the end-to-end test produces the missing
coverage data for the <code>main</code> function and the <code>__main__</code> module. Invoke <code>nox</code>
and watch it run your tests and generate a coverage report. Here’s what the
report should look like:</p>
<pre data-type="programlisting">$ <strong>nox --session coverage</strong>
nox &gt; coverage report
Name                  Stmts   Miss Branch BrPart  Cover   Missing
-----------------------------------------------------------------
src/.../__init__.py      29      0      8      0   100%
src/.../__main__.py       2      0      0      0   100%
tests/__init__.py         0      0      0      0   100%
tests/test_main.py       36      0      6      0   100%
-----------------------------------------------------------------
TOTAL                    67      0     14      0   100%
nox &gt; Session coverage was successful.
</pre>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Parameterizing Sessions"><div class="sect1" id="id181">
<h1>Parameterizing Sessions</h1>

<p>The phrase “works for me” describes a common story: a user reports an issue with
your code, but you can’t reproduce the bug in your environment. Runtime
environments in the real world differ in a myriad of ways. Testing across Python
versions covers one important variable. Another common cause of surprise is the
packages that your project uses directly or indirectly—​its dependency tree.</p>

<p>Nox offers a powerful technique for testing your project against different
versions of a dependency. <em>Parameterization</em> allows you to add parameters to
your session functions and supply predefined values for them; Nox runs the
session with each of these values.</p>

<p>You declare the parameter and its values in a decorator named
<code>@nox.parametrize</code>.<sup><a data-type="noteref" id="id306-marker" href="ch08.html#id306">3</a></sup>
<a data-type="xref" href="#example_nox_parametrize">Example 8-12</a> demonstrates this feature and how it allows you to
test against different versions of the Django web framework.</p>
<div id="example_nox_parametrize" data-type="example">
<h5><span class="label">Example 8-12. </span>Testing the project with multiple Django versions</h5>

<pre data-type="programlisting" data-code-language="python"><code class="nd">@nox</code><code class="o">.</code><code class="n">session</code>
<code class="nd">@nox</code><code class="o">.</code><code class="n">parametrize</code><code class="p">(</code><code class="s2">"django"</code><code class="p">,</code> <code class="p">[</code><code class="s2">"5.*"</code><code class="p">,</code> <code class="s2">"4.*"</code><code class="p">,</code> <code class="s2">"3.*"</code><code class="p">])</code>
<code class="k">def</code> <code class="nf">tests</code><code class="p">(</code><code class="n">session</code><code class="p">,</code> <code class="n">django</code><code class="p">):</code>
    <code class="n">session</code><code class="o">.</code><code class="n">install</code><code class="p">(</code><code class="s2">"."</code><code class="p">,</code> <code class="s2">"pytest-django"</code><code class="p">,</code> <code class="sa">f</code><code class="s2">"django==</code><code class="si">{</code><code class="n">django</code><code class="si">}</code><code class="s2">"</code><code class="p">)</code>
    <code class="n">session</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="s2">"pytest"</code><code class="p">)</code></pre></div>

<p>Parameterized sessions are similar to parameterized tests in pytest (see
<a data-type="xref" href="ch06.html#chapter_testing">Chapter 6</a>), which is where Nox borrowed the concept from. You can
stack <code>@nox.parametrize</code> decorators to run sessions against all combinations of
parameters:</p>

<pre data-type="programlisting" data-code-language="python"><code class="nd">@nox</code><code class="o">.</code><code class="n">session</code>
<code class="nd">@nox</code><code class="o">.</code><code class="n">parametrize</code><code class="p">(</code><code class="s2">"a"</code><code class="p">,</code> <code class="p">[</code><code class="s2">"1.0"</code><code class="p">,</code> <code class="s2">"0.9"</code><code class="p">])</code>
<code class="nd">@nox</code><code class="o">.</code><code class="n">parametrize</code><code class="p">(</code><code class="s2">"b"</code><code class="p">,</code> <code class="p">[</code><code class="s2">"2.2"</code><code class="p">,</code> <code class="s2">"2.1"</code><code class="p">])</code>
<code class="k">def</code> <code class="nf">tests</code><code class="p">(</code><code class="n">session</code><code class="p">,</code> <code class="n">a</code><code class="p">,</code> <code class="n">b</code><code class="p">):</code>
    <code class="nb">print</code><code class="p">(</code><code class="n">a</code><code class="p">,</code> <code class="n">b</code><code class="p">)</code>  <code class="c1"># all combinations of a and b</code></pre>

<p>If you only want to check for certain combinations, you can combine parameters
in a single <code>@nox.parametrize</code> decorator:</p>

<pre data-type="programlisting" data-code-language="python"><code class="nd">@nox</code><code class="o">.</code><code class="n">session</code>
<code class="nd">@nox</code><code class="o">.</code><code class="n">parametrize</code><code class="p">([</code><code class="s2">"a"</code><code class="p">,</code> <code class="s2">"b"</code><code class="p">],</code> <code class="p">[(</code><code class="s2">"1.0"</code><code class="p">,</code> <code class="s2">"2.2"</code><code class="p">),</code> <code class="p">(</code><code class="s2">"0.9"</code><code class="p">,</code> <code class="s2">"2.1"</code><code class="p">)])</code>
<code class="k">def</code> <code class="nf">tests</code><code class="p">(</code><code class="n">session</code><code class="p">,</code> <code class="n">a</code><code class="p">,</code> <code class="n">b</code><code class="p">):</code>
    <code class="nb">print</code><code class="p">(</code><code class="n">a</code><code class="p">,</code> <code class="n">b</code><code class="p">)</code>  <code class="c1"># only the combinations listed above</code></pre>

<p>When running a session across Python versions, you’re effectively parameterizing
the session by the interpreter. In fact, Nox let’s you write the following
instead of passing the versions to <code>@nox.session</code>:<sup><a data-type="noteref" id="id307-marker" href="ch08.html#id307">4</a></sup></p>

<pre data-type="programlisting" data-code-language="python"><code class="nd">@nox</code><code class="o">.</code><code class="n">session</code>
<code class="nd">@nox</code><code class="o">.</code><code class="n">parametrize</code><code class="p">(</code><code class="s2">"python"</code><code class="p">,</code> <code class="p">[</code><code class="s2">"3.12"</code><code class="p">,</code> <code class="s2">"3.11"</code><code class="p">,</code> <code class="s2">"3.10"</code><code class="p">])</code>
<code class="k">def</code> <code class="nf">tests</code><code class="p">(</code><code class="n">session</code><code class="p">):</code>
    <code class="o">...</code></pre>

<p>This syntax is useful when you want specific combinations of Python and the
dependency. Here’s an example: As of this writing, Django 3.2 (LTE) doesn’t
officially support Python versions newer than 3.10. Consequently, you need to
exclude these combinations from the test matrix.
<a data-type="xref" href="#example_nox_parametrize_python">Example 8-13</a> shows how.</p>
<div id="example_nox_parametrize_python" data-type="example">
<h5><span class="label">Example 8-13. </span>Parameterizing by valid Python and Django combinations</h5>

<pre data-type="programlisting" data-code-language="python"><code class="nd">@nox</code><code class="o">.</code><code class="n">session</code>
<code class="nd">@nox</code><code class="o">.</code><code class="n">parametrize</code><code class="p">(</code>
    <code class="p">[</code><code class="s2">"python"</code><code class="p">,</code> <code class="s2">"django"</code><code class="p">],</code>
    <code class="p">[</code>
        <code class="p">(</code><code class="n">python</code><code class="p">,</code> <code class="n">django</code><code class="p">)</code>
        <code class="k">for</code> <code class="n">python</code> <code class="ow">in</code> <code class="p">[</code><code class="s2">"3.12"</code><code class="p">,</code> <code class="s2">"3.11"</code><code class="p">,</code> <code class="s2">"3.10"</code><code class="p">]</code>
        <code class="k">for</code> <code class="n">django</code> <code class="ow">in</code> <code class="p">[</code><code class="s2">"3.2.*"</code><code class="p">,</code> <code class="s2">"4.2.*"</code><code class="p">]</code>
        <code class="k">if</code> <code class="p">(</code><code class="n">python</code><code class="p">,</code> <code class="n">django</code><code class="p">)</code> <code class="ow">not</code> <code class="ow">in</code> <code class="p">[(</code><code class="s2">"3.12"</code><code class="p">,</code> <code class="s2">"3.2"</code><code class="p">),</code> <code class="p">(</code><code class="s2">"3.11"</code><code class="p">,</code> <code class="s2">"3.2"</code><code class="p">)]</code>
    <code class="p">]</code>
<code class="p">)</code>
<code class="k">def</code> <code class="nf">tests</code><code class="p">(</code><code class="n">session</code><code class="p">,</code> <code class="n">django</code><code class="p">):</code>
    <code class="o">...</code></pre></div>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Session Dependencies"><div class="sect1" id="section_nox_dependencies">
<h1>Session Dependencies</h1>

<p>If you’ve followed <a data-type="xref" href="ch04.html#chapter_dependencies">Chapter 4</a> closely, you may see some problems
with the way <a data-type="xref" href="#example_nox_coverage_report">Example 8-8</a> and
<a data-type="xref" href="#example_nox_coverage_subprocess">Example 8-11</a> install packages. Here are the relevant
parts again:</p>

<pre data-type="programlisting" data-code-language="python"><code class="nd">@nox</code><code class="o">.</code><code class="n">session</code>
<code class="k">def</code> <code class="nf">tests</code><code class="p">(</code><code class="n">session</code><code class="p">):</code>
    <code class="n">session</code><code class="o">.</code><code class="n">install</code><code class="p">(</code><code class="s2">".[tests]"</code><code class="p">)</code>
    <code class="o">...</code>

<code class="nd">@nox</code><code class="o">.</code><code class="n">session</code>
<code class="k">def</code> <code class="nf">coverage</code><code class="p">(</code><code class="n">session</code><code class="p">):</code>
    <code class="n">session</code><code class="o">.</code><code class="n">install</code><code class="p">(</code><code class="s2">"coverage[toml]"</code><code class="p">)</code>
    <code class="o">...</code></pre>

<p>For one, the <code>coverage</code> session doesn’t specify which version of <code>coverage</code> the
project requires. The <code>tests</code> session does this right: it references the <code>tests</code>
extra in <em>pyproject.toml</em>, which includes the appropriate version specifiers
(see <a data-type="xref" href="ch06.html#section_testing_dependencies">“Managing Test Dependencies”</a>).</p>

<p>The <code>coverage</code> session doesn’t need the project, though, so an extra seems like
a bad fit. But before I get to this, let me point out another problem with the
sessions above: They don’t lock their dependencies.</p>

<p>Running checks without locking dependencies has two drawbacks. First, the checks
aren’t deterministic: subsequent runs of the same session may install different
packages. Second, if a dependency breaks your project, checks fail until you
exclude the release or another release fixes the problem.<sup><a data-type="noteref" id="id308-marker" href="ch08.html#id308">5</a></sup> In other words, any project you depend on, even
indirectly, has the power to block your entire CI pipeline.</p>

<p>On the other hand, lock file updates are a constant churn, and they clutter your
Git history. Reducing their frequency comes at the price of running checks with
stale dependencies. If you don’t require locking for other reasons, such as
secure deployments—​and you’re happy to quickly fix a build when an incompatible
release wreaks havoc on your CI—​you may prefer to keep your dependencies
unlocked. There ain’t no such thing as a free lunch.</p>

<p>In <a data-type="xref" href="ch04.html#section_dependencies_development">“Development Dependencies”</a>, you grouped dependencies in extras and
compiled requirements files from each. In this section, I’ll show you a
lighter-weight method for locking: <em>constraints files</em>. You only need a single
extra for it. It also doesn’t require installing the project itself, as extras
usually do—​which helps with the <code>coverage</code> session.</p>

<p>Constraints files look similar to requirements files: Each line lists a package
with a version specifier. Unlike requirements files, however, constraints files
don’t cause pip to install a package—​they only control which version pip
selects <em>if</em> it needs to install the package.</p>

<p>A constraints file works great for locking session dependencies. You can share
it across sessions while only installing the packages each session needs. Its
only drawback, compared to using a set of requirements files, is that you need
to resolve all dependencies together, so there’s a higher chance of dependency
conflicts.</p>

<p>You can generate constraints files using pip-tools or uv (see
<a data-type="xref" href="ch04.html#section_dependencies_piptools">“Compiling Requirements with pip-tools and uv”</a>). Nox can automate this part, too, as shown in
<a data-type="xref" href="#example_nox_constraints">Example 8-14</a>.</p>
<div id="example_nox_constraints" data-type="example">
<h5><span class="label">Example 8-14. </span>Locking the dependencies with uv</h5>

<pre data-type="programlisting" data-code-language="python"><code class="nd">@nox</code><code class="o">.</code><code class="n">session</code><code class="p">(</code><code class="n">venv_backend</code><code class="o">=</code><code class="s2">"</code><code class="s2">uv</code><code class="s2">"</code><code class="p">)</code><code> </code><a class="co" id="co_automation_with_nox_CO4-1" href="#callout_automation_with_nox_CO4-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a><code>
</code><code class="k">def</code><code> </code><code class="nf">lock</code><code class="p">(</code><code class="n">session</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">session</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code>
</code><code>        </code><code class="s2">"</code><code class="s2">uv</code><code class="s2">"</code><code class="p">,</code><code>
</code><code>        </code><code class="s2">"</code><code class="s2">pip</code><code class="s2">"</code><code class="p">,</code><code>
</code><code>        </code><code class="s2">"</code><code class="s2">compile</code><code class="s2">"</code><code class="p">,</code><code>
</code><code>        </code><code class="s2">"</code><code class="s2">pyproject.toml</code><code class="s2">"</code><code class="p">,</code><code>
</code><code>        </code><code class="s2">"</code><code class="s2">--upgrade</code><code class="s2">"</code><code class="p">,</code><code>
</code><code>        </code><code class="s2">"</code><code class="s2">--quiet</code><code class="s2">"</code><code class="p">,</code><code>
</code><code>        </code><code class="s2">"</code><code class="s2">--all-extras</code><code class="s2">"</code><code class="p">,</code><code>
</code><code>        </code><code class="s2">"</code><code class="s2">--output-file=constraints.txt</code><code class="s2">"</code><code class="p">,</code><code>
</code><code>    </code><code class="p">)</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" id="callout_automation_with_nox_CO4-1" href="#co_automation_with_nox_CO4-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Explicitly require uv as the environment backend. (You could also install uv
into the session with <code>session.install("uv")</code>, but uv supports a broader range
of Python versions than you can use to install its PyPI package.)</p></dd>
</dl>

<p>The <code>--output-file</code> option specifies the conventional name for a constraints
file, <em>constraints.txt</em>. The <code>--upgrade</code> option ensures that you get up-to-date
dependencies whenever you run the session. The <code>--all-extras</code> option includes
all the optional dependencies of the project.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Don’t forget to commit the constraints file to source control. You need to share
this file with every contributor, and it needs to be available in CI.</p>
</div>

<p>Pass the constraints file to <code>session.install</code> using the <code>--constraint</code> or <code>-c</code>
option. <a data-type="xref" href="#example_nox_single_constraints">Example 8-15</a> shows the <code>tests</code> and <code>coverage</code>
sessions with locked dependencies.</p>
<div id="example_nox_single_constraints" data-type="example">
<h5><span class="label">Example 8-15. </span>Using a constraints file to lock session dependencies</h5>

<pre data-type="programlisting" data-code-language="python"><code class="nd">@nox</code><code class="o">.</code><code class="n">session</code><code class="p">(</code><code class="n">python</code><code class="o">=</code><code class="p">[</code><code class="s2">"3.12"</code><code class="p">,</code> <code class="s2">"3.11"</code><code class="p">,</code> <code class="s2">"3.10"</code><code class="p">])</code>
<code class="k">def</code> <code class="nf">tests</code><code class="p">(</code><code class="n">session</code><code class="p">):</code>
    <code class="n">session</code><code class="o">.</code><code class="n">install</code><code class="p">(</code><code class="s2">"-c"</code><code class="p">,</code> <code class="s2">"constraints.txt"</code><code class="p">,</code> <code class="s2">".[tests]"</code><code class="p">)</code>
    <code class="o">...</code>

<code class="nd">@nox</code><code class="o">.</code><code class="n">session</code>
<code class="k">def</code> <code class="nf">coverage</code><code class="p">(</code><code class="n">session</code><code class="p">):</code>
    <code class="n">session</code><code class="o">.</code><code class="n">install</code><code class="p">(</code><code class="s2">"-c"</code><code class="p">,</code> <code class="s2">"constraints.txt"</code><code class="p">,</code> <code class="s2">"coverage[toml]"</code><code class="p">)</code>
    <code class="o">...</code></pre></div>

<p>Using a single constraints file requires that you target a well-known
interpreter and platform. You can’t use the same constraints file for different
environments because each environment may require different packages.</p>

<p>If you support multiple Python versions, operating systems, or processor
architectures, compile a separate constraints file for each environment. Keep
the constraints files in a subdirectory to avoid clutter.
<a data-type="xref" href="#example_nox_constraints_helper">Example 8-16</a> shows a helper function that constructs
filenames like <em>constraints/python3.12-linux-arm64.txt</em>.</p>
<div id="example_nox_constraints_helper" data-type="example">
<h5><span class="label">Example 8-16. </span>Constructing paths for a constraints file</h5>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code> <code class="nn">platform</code><code class="o">,</code> <code class="nn">sys</code>
<code class="kn">from</code> <code class="nn">pathlib</code> <code class="kn">import</code> <code class="n">Path</code>

<code class="k">def</code> <code class="nf">constraints</code><code class="p">(</code><code class="n">session</code><code class="p">):</code>
    <code class="n">filename</code> <code class="o">=</code> <code class="sa">f</code><code class="s2">"python</code><code class="si">{</code><code class="n">session</code><code class="o">.</code><code class="n">python</code><code class="si">}</code><code class="s2">-</code><code class="si">{</code><code class="n">sys</code><code class="o">.</code><code class="n">platform</code><code class="si">}</code><code class="s2">-</code><code class="si">{</code><code class="n">platform</code><code class="o">.</code><code class="n">machine</code><code class="p">()</code><code class="si">}</code><code class="s2">.txt"</code>
    <code class="k">return</code> <code class="n">Path</code><code class="p">(</code><code class="s2">"constraints"</code><code class="p">)</code> <code class="o">/</code> <code class="n">filename</code></pre></div>

<p><a data-type="xref" href="#example_nox_constraints_multipython">Example 8-17</a> updates the <code>lock</code> session to generate
the constraints files. The session now runs on every Python version. It uses the
helper function to build the path for the constraints file, ensures that the
target directory exists, and passes the filename to uv.</p>
<div id="example_nox_constraints_multipython" data-type="example">
<h5><span class="label">Example 8-17. </span>Locking dependencies on multiple Python versions</h5>

<pre data-type="programlisting" data-code-language="python"><code class="nd">@nox</code><code class="o">.</code><code class="n">session</code><code class="p">(</code><code class="n">python</code><code class="o">=</code><code class="p">[</code><code class="s2">"3.12"</code><code class="p">,</code> <code class="s2">"3.11"</code><code class="p">,</code> <code class="s2">"3.10"</code><code class="p">],</code> <code class="n">venv_backend</code><code class="o">=</code><code class="s2">"uv"</code><code class="p">)</code>
<code class="k">def</code> <code class="nf">lock</code><code class="p">(</code><code class="n">session</code><code class="p">):</code>
    <code class="n">filename</code> <code class="o">=</code> <code class="n">constraints</code><code class="p">(</code><code class="n">session</code><code class="p">)</code>
    <code class="n">filename</code><code class="o">.</code><code class="n">parent</code><code class="o">.</code><code class="n">mkdir</code><code class="p">(</code><code class="n">exist_ok</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code>
    <code class="n">session</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="s2">"uv"</code><code class="p">,</code> <code class="s2">"pip"</code><code class="p">,</code> <code class="s2">"compile"</code><code class="p">,</code> <code class="o">...</code><code class="p">,</code> <code class="sa">f</code><code class="s2">"--output-file=</code><code class="si">{</code><code class="n">filename</code><code class="si">}</code><code class="s2">"</code><code class="p">)</code></pre></div>

<p>The <code>tests</code> and <code>coverage</code> sessions can now reference the appropriate
constraints file for each Python version. For this to work, you have to declare
a Python version for the <code>coverage</code> session as well.</p>
<div id="example_nox_constraints_multipython_clients" data-type="example">
<h5><span class="label">Example 8-18. </span>The <code>tests</code> and <code>coverage</code> session with multi-Python constraints</h5>

<pre data-type="programlisting" data-code-language="python"><code class="nd">@nox</code><code class="o">.</code><code class="n">session</code><code class="p">(</code><code class="n">python</code><code class="o">=</code><code class="p">[</code><code class="s2">"3.12"</code><code class="p">,</code> <code class="s2">"3.11"</code><code class="p">,</code> <code class="s2">"3.10"</code><code class="p">])</code>
<code class="k">def</code> <code class="nf">tests</code><code class="p">(</code><code class="n">session</code><code class="p">):</code>
    <code class="n">session</code><code class="o">.</code><code class="n">install</code><code class="p">(</code><code class="s2">"-c"</code><code class="p">,</code> <code class="n">constraints</code><code class="p">(</code><code class="n">session</code><code class="p">),</code> <code class="s2">"."</code><code class="p">,</code> <code class="s2">"pytest"</code><code class="p">,</code> <code class="s2">"coverage[toml]"</code><code class="p">)</code>
    <code class="o">...</code>

<code class="nd">@nox</code><code class="o">.</code><code class="n">session</code><code class="p">(</code><code class="n">python</code><code class="o">=</code><code class="s2">"3.12"</code><code class="p">)</code>
<code class="k">def</code> <code class="nf">coverage</code><code class="p">(</code><code class="n">session</code><code class="p">):</code>
    <code class="n">session</code><code class="o">.</code><code class="n">install</code><code class="p">(</code><code class="s2">"-c"</code><code class="p">,</code> <code class="n">constraints</code><code class="p">(</code><code class="n">session</code><code class="p">),</code> <code class="s2">"coverage[toml]"</code><code class="p">)</code>
    <code class="o">...</code></pre></div>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Using Nox with Poetry Projects"><div class="sect1" id="id183">
<h1>Using Nox with Poetry Projects</h1>

<p>If you manage your project with Poetry, you organize dependencies in dependency
groups (see <a data-type="xref" href="ch05.html#section_poetry_development_dependencies">“Dependency Groups”</a>). Dependency groups
align naturally with Nox sessions: packages for the <code>tests</code> session go into a
<code>tests</code> group, those for a <code>docs</code> session into a <code>docs</code> group, and so on. Using
Poetry as the installer means you get locked dependencies for free—​all
installations honor the lock file.</p>

<p>Before I show you how to use Poetry in Nox sessions, let me call out a couple of
differences between Poetry environments and Nox environments.</p>

<p>First, the Poetry environment is comprehensive: by default, it includes the
project, its main dependencies, and every non-optional dependency group. Nox
environments only install packages required for the task they automate.</p>

<p>Second, the Poetry environment uses editable installs for the project so you
don’t need to reinstall after every code change. Nox environments build and
install a wheel so automated checks see the project the same way an end user
would.</p>

<p>There’s no right and wrong here. Poetry environments are perfect for ad-hoc
interactions with your project during development, with every tool just a
<code>poetry run</code> away. Nox environments, on the other hand, are optimized for
reliable and repeatable checks; they aim to be as isolated and deterministic as
possible.</p>

<p>When you use Poetry in a Nox session, it’s good to be mindful of these
differences. I recommend these guidelines for invoking <code>poetry install</code> with
Nox:</p>

<ul>
<li>
<p>Use the option <code>--no-root</code> to avoid an editable install of the project. If the
session needs the project to be installed (not every session does), follow the
command with <code>session.install(".")</code> to build and install a wheel.</p>
</li>
<li>
<p>Use the option <code>--only=<em>&lt;group&gt;</em></code> to install
the appropriate dependency group for the session. If the session needs the
project to be installed, list the special group <code>main</code> as well—​this ensures
that every package is pinned using <em>poetry.lock</em>.</p>
</li>
<li>
<p>Use the option <code>--sync</code> to remove packages from a reused session environment
when your project no longer depends on them.</p>
</li>
</ul>

<p><a data-type="xref" href="#example_nox_poetry_install">Example 8-19</a> puts this logic into a helper function that you
can share across your session functions.</p>
<div id="example_nox_poetry_install" data-type="example">
<h5><span class="label">Example 8-19. </span>Installing session dependencies with Poetry</h5>

<pre data-type="programlisting" data-code-language="python"><code class="k">def</code> <code class="nf">install</code><code class="p">(</code><code class="n">session</code><code class="p">,</code> <code class="n">groups</code><code class="p">,</code> <code class="n">root</code><code class="o">=</code><code class="kc">True</code><code class="p">):</code>
    <code class="k">if</code> <code class="n">root</code><code class="p">:</code>
        <code class="n">groups</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"main"</code><code class="p">,</code> <code class="o">*</code><code class="n">groups</code><code class="p">]</code>

    <code class="n">session</code><code class="o">.</code><code class="n">run_install</code><code class="p">(</code>
        <code class="s2">"poetry"</code><code class="p">,</code>
        <code class="s2">"install"</code><code class="p">,</code>
        <code class="s2">"--no-root"</code><code class="p">,</code>
        <code class="s2">"--sync"</code><code class="p">,</code>
        <code class="sa">f</code><code class="s2">"--only=</code><code class="si">{</code><code class="s1">','</code><code class="o">.</code><code class="n">join</code><code class="p">(</code><code class="n">groups</code><code class="p">)</code><code class="si">}</code><code class="s2">"</code><code class="p">,</code>
        <code class="n">external</code><code class="o">=</code><code class="kc">True</code><code class="p">,</code>
    <code class="p">)</code>
    <code class="k">if</code> <code class="n">root</code><code class="p">:</code>
        <code class="n">session</code><code class="o">.</code><code class="n">install</code><code class="p">(</code><code class="s2">"."</code><code class="p">)</code></pre></div>

<p>The helper function uses <code>session.run_install</code> instead of <code>session.run</code>. The two
functions work exactly alike, but <code>session.run_install</code> marks the command as an
installation. This avoids package installations when you reuse environments with
<code>--no-install</code> or <code>-R</code>.</p>

<p>If you’ve followed along using Poetry in <a data-type="xref" href="ch06.html#chapter_testing">Chapter 6</a> and
<a data-type="xref" href="ch07.html#chapter_coverage">Chapter 7</a>, your <em>pyproject.toml</em> should have a dependency group named
<code>tests</code> containing pytest and coverage. Let’s split the <code>coverage</code> dependency
off into a separate group, since you don’t need the test dependencies for the
<code>coverage</code> session:<sup><a data-type="noteref" id="id309-marker" href="ch08.html#id309">6</a></sup></p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[tool.poetry.group.coverage.dependencies]</code><code class="w"/>
<code class="n">coverage</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="n">extras</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"toml"</code><code class="p">],</code><code class="w"> </code><code class="n">version</code><code class="w"> </code><code class="p">=</code><code class="w"> </code><code class="s2">"&gt;=7.4.4"</code><code class="p">}</code><code class="w"/>

<code class="k">[tool.poetry.group.tests.dependencies]</code><code class="w"/>
<code class="n">pytest</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"&gt;=8.1.1"</code><code class="w"/></pre>

<p>Here’s how you’d install the dependencies in the <code>tests</code> session:</p>

<pre data-type="programlisting" data-code-language="python"><code class="nd">@nox</code><code class="o">.</code><code class="n">session</code><code class="p">(</code><code class="n">python</code><code class="o">=</code><code class="p">[</code><code class="s2">"3.12"</code><code class="p">,</code> <code class="s2">"3.11"</code><code class="p">,</code> <code class="s2">"3.10"</code><code class="p">])</code>
<code class="k">def</code> <code class="nf">tests</code><code class="p">(</code><code class="n">session</code><code class="p">):</code>
    <code class="n">install</code><code class="p">(</code><code class="n">session</code><code class="p">,</code> <code class="n">groups</code><code class="o">=</code><code class="p">[</code><code class="s2">"coverage"</code><code class="p">,</code> <code class="s2">"tests"</code><code class="p">])</code>
    <code class="o">...</code></pre>

<p>And here’s what the <code>coverage</code> session looks like with the helper function:</p>

<pre data-type="programlisting" data-code-language="python"><code class="nd">@nox</code><code class="o">.</code><code class="n">session</code>
<code class="k">def</code> <code class="nf">coverage</code><code class="p">(</code><code class="n">session</code><code class="p">):</code>
    <code class="n">install</code><code class="p">(</code><code class="n">session</code><code class="p">,</code> <code class="n">groups</code><code class="o">=</code><code class="p">[</code><code class="s2">"coverage"</code><code class="p">],</code> <code class="n">root</code><code class="o">=</code><code class="kc">False</code><code class="p">)</code>
    <code class="o">...</code></pre>
<div data-type="tip"><h6>Tip</h6>
<p>How does Poetry know to use a Nox environment instead of the Poetry environment?
Poetry installs packages into the active environment, if one exists. When Nox
runs Poetry, it activates the session environment by exporting the <code>VIRTUAL_ENV</code>
environment variable (see <a data-type="xref" href="ch02.html#section_environments_venv">“Virtual Environments”</a>).</p>
</div>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Locking Dependencies with nox-poetry"><div class="sect1" id="id184">
<h1>Locking Dependencies with nox-poetry</h1>

<p>There’s an alternative approach to using Nox with Poetry projects. The
<code>nox-poetry</code> package is an unofficial plugin for Nox that lets you write
sessions without worrying about locking, using plain <code>session.install</code>. Behind
the scenes, <code>nox-poetry</code> exports a constraints file for pip using <code>poetry export</code>.</p>

<p>Install <code>nox-poetry</code> into the same environment as Nox:</p>
<pre data-type="programlisting">$ <strong>pipx inject nox nox-poetry</strong>
</pre>

<p>Decorate your sessions with <code>@session</code> from the <code>nox-poetry</code> package, which is a
drop-in replacement for <code>@nox.session</code>:</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">from</code> <code class="nn">nox_poetry</code> <code class="kn">import</code> <code class="n">session</code>

<code class="nd">@session</code>
<code class="k">def</code> <code class="nf">tests</code><code class="p">(</code><code class="n">session</code><code class="p">):</code>
    <code class="n">session</code><code class="o">.</code><code class="n">install</code><code class="p">(</code><code class="s2">"."</code><code class="p">,</code> <code class="s2">"coverage[toml]"</code><code class="p">,</code> <code class="s2">"pytest"</code><code class="p">)</code>
    <code class="o">...</code></pre>

<p>When you install packages with <code>session.install</code>, the constraints file keeps
their versions in sync with <code>poetry.lock</code>. You can manage dependencies in
separate dependency groups or put them into a single <code>dev</code> group.</p>

<p>While this approach is convenient and simplifies the resulting <em>noxfile.py</em>, it
doesn’t come for free. Translating Poetry’s dependency information into a
constraints file isn’t lossless—​for example, it doesn’t include package hashes
or the URLs of private package repositories. Another drawback is that
contributors have another global dependency to worry about. When I wrote
<code>nox-poetry</code> in 2020, dependency groups didn’t exist. As of this writing, I
recommend using Poetry directly, as described in the previous section.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="id185">
<h1>Summary</h1>

<p>Nox lets you automate checks and tasks for a project. Its Python configuration
file <em>noxfile.py</em> organizes them into one or more sessions. Sessions are
functions decorated with <code>@nox.session</code>. They receive a single argument
<code>session</code> providing the session API (<a data-type="xref" href="#table_nox_session">Table 8-1</a>). Every session runs
in an isolated virtual environment. If you pass a list of Python versions to
<code>@nox.session</code>, Nox runs the session across all of them.</p>
<table id="table_nox_session">
<caption><span class="label">Table 8-1. </span>The session object</caption>
<thead>
<tr>
<th>Attribute</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>run()</code></p></td>
<td><p>Run a command</p></td>
<td><p><code>session.run("coverage", "report")</code></p></td>
</tr>
<tr>
<td><p><code>install()</code></p></td>
<td><p>Install packages with pip</p></td>
<td><p><code>session.install(".", "pytest")</code></p></td>
</tr>
<tr>
<td><p><code>run_install()</code></p></td>
<td><p>Run an installation command</p></td>
<td><p><code>session.run_install("poetry", "install")</code></p></td>
</tr>
<tr>
<td><p><code>notify()</code></p></td>
<td><p>Enqueue another session</p></td>
<td><p><code>session.notify("coverage")</code></p></td>
</tr>
<tr>
<td><p><code>python</code></p></td>
<td><p>The interpreter for this session</p></td>
<td><p><code>"3.12"</code></p></td>
</tr>
<tr>
<td><p><code>posargs</code></p></td>
<td><p>Extra command-line arguments</p></td>
<td><p><code>nox -- --verbose --pdb</code></p></td>
</tr>
</tbody>
</table>

<p>The command <code>nox</code> (<a data-type="xref" href="#table_nox_options">Table 8-2</a>) provides a single entry point to your
suite of checks. Without arguments, it runs every session defined in
<em>noxfile.py</em> (or those you’ve listed in <code>nox.options.sessions</code>). The earlier you
identify issues with your code, the cheaper it is to fix them—​so use Nox to run
the same checks locally as in continuous integration (CI). Besides checks, you
can automate many other chores, such as building packages or documentation.</p>
<table id="table_nox_options">
<caption><span class="label">Table 8-2. </span>Command-line options for <code>nox</code></caption>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>--list</code></p></td>
<td><p>List the available sessions</p></td>
<td><p><code>nox -l</code></p></td>
</tr>
<tr>
<td><p><code>--session</code></p></td>
<td><p>Select sessions by name</p></td>
<td><p><code>nox -s tests</code></p></td>
</tr>
<tr>
<td><p><code>--python</code></p></td>
<td><p>Select sessions by interpreter</p></td>
<td><p><code>nox -p 3.12</code></p></td>
</tr>
<tr>
<td><p><code>--force-python</code></p></td>
<td><p>Override the interpreter for a session</p></td>
<td><p><code>nox --force-python 3.13</code></p></td>
</tr>
<tr>
<td><p><code>--reuse-existing-virtualenvs</code></p></td>
<td><p>Reuse existing virtual environments</p></td>
<td><p><code>nox -rs tests</code></p></td>
</tr>
<tr>
<td><p><code>--no-install</code></p></td>
<td><p>Skip installation commands</p></td>
<td><p><code>nox -Rs tests</code></p></td>
</tr>
</tbody>
</table>

<p>There’s a lot more to Nox that this chapter didn’t cover. For example, you can
use Conda or Mamba to create environments and install packages. You can organize
sessions using keywords and tags, and assign friendly identifiers using
<code>nox.param</code>. Last but not least, Nox comes with a GitHub Action that makes it
easy to run Nox sessions in CI. Take a look at the
<a href="https://nox.thea.codes">official documentation</a> to learn more.</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="id304"><sup><a href="ch08.html#id304-marker">1</a></sup> In case you’re wondering, always use the plural form <code>nox.options.sessions</code> in <em>noxfile.py</em>. On the command line, both <code>--session</code> and <code>--sessions</code> work. You can specify any number of sessions with these options.</p><p data-type="footnote" id="id305"><sup><a href="ch08.html#id305-marker">2</a></sup> Alan Kay, <a href="https://qr.ae/pyjKrs">“What is the story behind Alan Kay’s adage <em>Simple things should be simple, complex things should be possible</em>?”</a>, <em>Quora Answer</em>, June 19, 2020.</p><p data-type="footnote" id="id306"><sup><a href="ch08.html#id306-marker">3</a></sup> Like pytest, Nox uses the alternate spelling “parametrize” to protect your “E” keycap from excessive wear.</p><p data-type="footnote" id="id307"><sup><a href="ch08.html#id307-marker">4</a></sup> The eagle-eyed reader may notice that <code>python</code> is not a function parameter here. If you do need it in the session function, use <code>session.python</code> instead.</p><p data-type="footnote" id="id308"><sup><a href="ch08.html#id308-marker">5</a></sup> Semantic Versioning constraints do more harm here than they help. Bugs occur in all releases, and your upstream’s definition of a breaking change may be narrower than you like. See Hynek Schlawack: <a href="https://hynek.me/articles/semver-will-not-save-you/">“Semantic Versioning Will Not Save You,”</a> March 2, 2021.</p><p data-type="footnote" id="id309"><sup><a href="ch08.html#id309-marker">6</a></sup> Run <code>poetry lock --no-update</code> after editing <em>pyproject.toml</em> to update the <em>poetry.lock</em> file.</p></div></div></section></div>
</div>
</body></html>