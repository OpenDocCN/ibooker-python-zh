- en: 'Chapter 12\. Container Orchestration: Kubernetes'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。容器编排：Kubernetes
- en: If you are experimenting with Docker, or if running a set of Docker containers
    on a single machine is all you need, then Docker and Docker Compose would be sufficient
    for your needs. However, as soon as you move from the number `1` (single machine)
    to the number `2` (multiple machines), you need to start worrying about orchestrating
    the containers across the network. For production scenarios, this is a given.
    You need at least two machines to achieve fault tolerance/high availability.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在尝试使用Docker，或者在单台机器上运行一组Docker容器就是您的全部需求，那么Docker和Docker Compose就足够满足您的需求。然而，一旦您从数字`1`（单台机器）转移到数字`2`（多台机器），您就需要开始考虑如何在网络中编排这些容器。对于生产场景来说，这是必须的。您至少需要两台机器来实现容错和高可用性。
- en: 'In our age of cloud computing, the recommended way of scaling an infrastructure
    is “out” (also referred to as “horizontal scalability”), by adding more instances
    to your overall system, as opposed to the older way of scaling “up” (or “vertical
    scalability”), by adding more CPUs and memory to a single instance. A Docker orchestration
    platform uses these many instances or nodes as sources of raw resources (CPU,
    memory, network) that it then allocates to individual containers running within
    the platform. This ties into what we mentioned in [Chapter 11](ch11.html#containers-docker)
    in regards to the advantages of using containers over classic virtual machines
    (VMs): the raw resources at your disposal will be better utilized because containers
    can get these resources allocated to them on a much more granular basis than VMs,
    and you will get more bang for your infrastructure buck.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这个云计算时代，扩展基础设施的推荐方法是“外部”（也称为“水平扩展”），通过向整个系统添加更多实例来实现，而不是通过“上升”（或“垂直扩展”）的旧方法，即向单个实例添加更多CPU和内存。一个Docker编排平台使用这些许多实例或节点作为原始资源（CPU、内存、网络），然后将这些资源分配给平台内运行的各个容器。这与我们在[第11章](ch11.html#containers-docker)中提到的使用容器而不是经典虚拟机（VMs）的优势相关联：您可以更精细地为容器分配这些资源，因此您的基础设施投入将得到更好的利用率。
- en: There has also been a shift from provisioning servers for specific purposes
    and running specific software packages on each instance (such as web server software,
    cache software, database software) to provisioning them as generic units of resource
    allocation and running Docker containers on them, coordinated by a Docker orchestration
    platform. You may be familiar with the distinction between looking at servers
    as “pets” versus looking at them as “cattle.” In the early days of infrastructure
    design, each server had a definite function (such as the mail server), and many
    times there was only one server for each specific function. There were naming
    schemes for such servers (Grig remembers using a planetary system naming scheme
    in the dot-com days), and a lot of time was spent on their care and feeding, hence
    the pet designation. When configuration management tools such as Puppet, Chef,
    and Ansible burst onto the scene, it became easier to provision multiple servers
    of the same type (for example, a web server farm) at the same time, by using an
    identical installation procedure on each server. This coincided with the rise
    of cloud computing, with the concept of horizontal scalability mentioned previously,
    and also with more concern for fault tolerance and high availability as critical
    properties of well-designed system infrastructure. The servers or cloud instances
    were considered cattle, disposable units that have value in their aggregate.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在为特定目的配置服务器并在每个实例上运行特定软件包（如Web服务器软件、缓存软件、数据库软件）的模式已经发生了转变，现在将它们配置为资源分配的通用单元，并在其上运行Docker容器，由Docker编排平台协调管理。您可能熟悉将服务器视为“宠物”与将它们视为“牲畜”的区别。在基础架构设计的早期阶段，每个服务器都有明确的功能（如邮件服务器），许多时候每个特定功能仅有一个服务器。这些服务器有命名方案（格里格还记得在点博时代使用行星系统的命名方案），花费大量时间进行管理和维护，因此被称为“宠物”。当Puppet、Chef和Ansible等配置管理工具出现时，通过在每台服务器上使用相同的安装程序，同时轻松配置多个相同类型的服务器（例如Web服务器农场）变得更加容易。这与云计算的兴起同时发生，前面提到的水平扩展的概念以及对容错和高可用性的更多关注，这些都是良好设计的系统基础设施的关键属性。这些服务器或云实例被视为牲畜，是可以丢弃的单位，它们在集合中有价值。
- en: The age of containers and serverless computing also brought about another designation,
    “insects.” Indeed, one can look at the coming and going of containers as a potentially
    short existence, like an ephemeral insect. Functions-as-a-service are even more
    fleeting than Docker containers, with a short but intense life coinciding with
    the duration of their call.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 容器和无服务器计算时代也带来了另一个称谓，“昆虫”。确实，人们可以将容器的出现和消失视为一种短暂存在，就像是一个短暂的昆虫一样。函数即服务比 Docker
    容器更短暂，其存在期间短暂而强烈，与其调用的持续时间相一致。
- en: In the case of containers, their ephemerality makes their orchestration and
    interoperability hard to achieve at a large scale. This is exactly the need that
    has been filled by container orchestration platforms. There used to be multiple
    Docker orchestration platforms to choose from, such as Mesosphere and Docker Swarm,
    but these days we can safely say that Kubernetes has won that game. The rest of
    the chapter is dedicated to a short overview of Kubernetes, followed by an example
    of running the same application described in [Chapter 11](ch11.html#containers-docker)
    and porting it from `docker-compose` to Kubernetes. We will also show how to use
    Helm, a Kubernetes package manager, to install packages called charts for the
    monitoring and dashboarding tools Prometheus and Grafana, and how to customize
    these charts.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器的情况下，它们的短暂性使得在大规模上实现它们的编排和互操作性变得困难。这正是容器编排平台填补的需求。以前有多个 Docker 编排平台可供选择，如
    Mesosphere 和 Docker Swarm，但如今我们可以安全地说 Kubernetes 已经赢得了这场比赛。本章剩余部分将简要概述 Kubernetes，并示例演示如何在
    Kubernetes 中运行相同的应用程序，从`docker-compose`迁移到 Kubernetes。我们还将展示如何使用 Helm，一个 Kubernetes
    包管理器，来安装名为 charts 的包，用于监控和仪表盘工具 Prometheus 和 Grafana，并如何自定义这些 charts。
- en: Short Overview of Kubernetes Concepts
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 概念简介
- en: The best starting point for understanding the many parts comprising a Kubernetes
    cluster is [the official Kubernetes documentation](https://oreil.ly/TYpdE).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 理解构成 Kubernetes 集群的许多部分的最佳起点是[官方 Kubernetes 文档](https://oreil.ly/TYpdE)。
- en: At a high level, a Kubernetes cluster consists of nodes that can be equated
    to servers, be they bare-metal or virtual machines running in a cloud. Nodes run
    pods, which are collections of Docker containers. A pod is the unit of deployment
    in Kubernetes. All containers in a pod share the same network and can refer to
    each other as if they were running on the same host. There are many situations
    in which it is advantageous to run more than one container in a pod. Typically,
    your application container runs as the main container in the pod, and if needed
    you will run one or more so-called “sidecar” containers for functionality, such
    as logging or monitoring. One particular case of sidecar containers is an “init
    container,” which is guaranteed to run first and can be used for housekeeping
    tasks, such as running database migrations. We’ll explore this later in this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，Kubernetes 集群由节点组成，可以等同于运行在云中的裸金属或虚拟机的服务器。节点运行 pod，即 Docker 容器的集合。Pod
    是 Kubernetes 中的部署单位。一个 pod 中的所有容器共享同一网络，并且可以像在同一主机上运行一样互相引用。有许多情况下，运行多个容器在一个 pod
    中是有利的。通常情况下，您的应用程序容器作为 pod 中的主容器运行，如果需要，您可以运行一个或多个所谓的“sidecar”容器，用于功能，例如日志记录或监视。一个特殊的
    sidecar 容器案例是“init 容器”，它保证首先运行，并可用于诸如运行数据库迁移等的日常管理任务。我们将在本章后面进一步探讨这个问题。
- en: An application will typically use more than one pod for fault tolerance and
    performance purposes. The Kubernetes object responsible for launching and maintaining
    the desired number of pods is called a deployment. For pods to communicate with
    other pods, Kubernetes provides another kind of object called a service. Services
    are tied to deployments through selectors. Services are also exposed to external
    clients, either by exposing a NodePort as a static port on each Kubernetes node,
    or by creating a LoadBalancer object that corresponds to an actual load balancer,
    if it is supported by the cloud provider running the Kubernetes cluster.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通常会为了容错性和性能而使用多个 pod。负责启动和维护所需 pod 数量的 Kubernetes 对象称为部署（deployment）。为了让
    pod 能够与其他 pod 通信，Kubernetes 提供了另一种对象，称为服务（service）。服务通过选择器（selectors）与部署绑定。服务也可以向外部客户端暴露，可以通过在每个
    Kubernetes 节点上暴露一个 NodePort 作为静态端口，或者创建对应实际负载均衡器的 LoadBalancer 对象来实现，如果云提供商支持的话。
- en: For managing sensitive information such as passwords, API keys, and other credentials,
    Kubernetes offers the Secret object. We will see an example of using a Secret
    for storing a database password.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于管理诸如密码、API 密钥和其他凭据等敏感信息，Kubernetes 提供了 Secret 对象。我们将看到一个示例，使用 Secret 存储数据库密码。
- en: Using Kompose to Create Kubernetes Manifests from docker-compose.yaml
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Kompose 从 docker-compose.yaml 创建 Kubernetes Manifests
- en: 'Let’s take another look at the *docker_compose.yaml* file for the Flask example
    application discussed in [Chapter 11](ch11.html#containers-docker):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次查看讨论 [第 11 章](ch11.html#containers-docker) 中的 Flask 示例应用程序的 *docker_compose.yaml*
    文件：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will use a tool called `Kompose` to translate this YAML file into a set of
    Kubernetes manifests.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为 `Kompose` 的工具来将此 YAML 文件翻译成一组 Kubernetes Manifests。
- en: To get a new version of `Kompose` on a macOS machine, first download it from
    [the Git repository](https://oreil.ly/GUqaq), then move it to */usr/local/bin/kompose*,
    and make it executable. Note that if you rely on your operating system’s package
    management system (for example, `apt` on Ubuntu systems or `yum` on Red Hat systems)
    for installing `Kompose`, you may get a much older version that may not be compatible
    to these instructions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 macOS 机器上获取新版本的 `Kompose`，首先从 [Git 仓库](https://oreil.ly/GUqaq) 下载它，然后将其移动到
    */usr/local/bin/kompose*，并使其可执行。请注意，如果您依赖操作系统的软件包管理系统（例如 Ubuntu 系统上的 `apt` 或 Red
    Hat 系统上的 `yum`）来安装 `Kompose`，可能会获得一个较旧且不兼容这些说明的版本。
- en: 'Run the `kompose convert` command to create the Kubernetes manifest files from
    the existing *docker-compose.yaml* file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `kompose convert` 命令从现有的 *docker-compose.yaml* 文件创建 Kubernetes manifest 文件：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'At this point, remove the *docker-compose.yaml* file:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，请删除 *docker-compose.yaml* 文件：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Deploying Kubernetes Manifests to a Local Kubernetes Cluster Based on minikube
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Kubernetes Manifests 部署到基于 minikube 的本地 Kubernetes 集群
- en: Our next step is to deploy the Kubernetes manifests to a local Kubernetes cluster
    based on `minikube`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一步是将 Kubernetes Manifests 部署到基于 `minikube` 的本地 Kubernetes 集群。
- en: 'A prerequisite to running `minikube` on macOS is to install *VirtualBox*. Download
    the VirtualBox package for macOS from its [download page](https://oreil.ly/BewRq),
    install it, and then move it to */usr/local/bin/minikube* to make it executable.
    Note that at the time of this writing, `minikube` installed a Kubernetes cluster
    with version 1.15\. If you want to follow along with these examples, specify the
    version of Kubernetes you want to install with `minikube`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上运行 `minikube` 的先决条件是安装 *VirtualBox*。从其 [下载页面](https://oreil.ly/BewRq)
    下载 macOS 版本的 VirtualBox 包，并安装它，然后将其移动到 */usr/local/bin/minikube* 以使其可执行。请注意，此时写作本文时，`minikube`
    安装了 Kubernetes 版本为 1.15\. 如果要按照这些示例进行操作，请指定要使用 `minikube` 安装的 Kubernetes 版本：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The main command for interacting with a Kubernetes cluster is `kubectl`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Kubernetes 集群交互的主要命令是 `kubectl`。
- en: Install `kubectl` on a macOS machine by downloading it from [the release page](https://oreil.ly/f9Wv0),
    then moving it to */usr/local/bin/kubectl* and making it executable.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从 [发布页面](https://oreil.ly/f9Wv0) 下载并移动到 */usr/local/bin/kubectl* 并使其可执行，来在
    macOS 机器上安装 `kubectl`。
- en: 'One of the main concepts you will use when running `kubectl` commands is *context*,
    which signifies a Kubernetes cluster that you want to interact with. The installation
    process for `minikube` already created a context for us called *minikube*. One
    way to point `kubectl` to a specific context is with the following command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 `kubectl` 命令时，您将使用的一个主要概念是 *context*，它表示您希望与之交互的 Kubernetes 集群。`minikube`
    的安装过程已经为我们创建了一个称为 *minikube* 的上下文。指定 `kubectl` 指向特定上下文的一种方法是使用以下命令：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A different, and more handy, way is to install the `kubectx` utility from [the
    Git repository](https://oreil.ly/SIf1U), then run:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种更方便的方法是从 [Git 仓库](https://oreil.ly/SIf1U) 安装 `kubectx` 实用程序，然后运行：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'Another handy client utility for your Kubernetes work is [kube-ps1](https://oreil.ly/AcE32).
    For a macOS setup based on Zsh, add this snippet to the file *~/.zshrc*:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在 Kubernetes 工作中很实用的客户端实用程序是 [kube-ps1](https://oreil.ly/AcE32)。对于基于 Zsh
    的 macOS 设置，请将以下片段添加到文件 *~/.zshrc* 中：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These lines change the shell prompt to show the current Kubernetes context and
    namespace. As you start interacting with multiple Kubernetes clusters, this will
    be a lifesaver for distinguishing between a production and a staging cluster.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行将 shell 提示符更改为显示当前 Kubernetes 上下文和命名空间。当您开始与多个 Kubernetes 集群进行交互时，这将帮助您区分生产环境和暂存环境。
- en: 'Now run `kubectl` commands against the local `minikube` cluster. For example,
    the `kubectl get nodes` command shows the nodes that are part of the cluster.
    In this case, there is only one node with the role of `master`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在本地 `minikube` 集群上运行 `kubectl` 命令。例如，`kubectl get nodes` 命令显示集群中的节点。在本例中，只有一个带有
    `master` 角色的节点：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Start by creating the Persistent Volume Claim (PVC) object from the file *dbdata-persistentvolumeclaim.yaml*
    that was created by `Kompose`, and which corresponds to the local volume allocated
    for the PostgreSQL database container, when running it with `docker-compose`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从 *dbdata-persistentvolumeclaim.yaml* 文件创建持久卷声明（PVC）对象，该文件由 `Kompose` 创建，对应于在使用
    `docker-compose` 运行时为 PostgreSQL 数据库容器分配的本地卷：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To create this object in Kubernetes, use the `kubectl create` command and specify
    the file name of the manifest with the `-f` flag:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Kubernetes 中创建此对象，请使用 `kubectl create` 命令，并使用 `-f` 标志指定清单文件名：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'List all the PVCs with the `kubectl get pvc` command to verify that our PVC
    is there:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `kubectl get pvc` 命令列出所有 PVC，验证我们的 PVC 是否存在：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next step is to create the Deployment object for PostgreSQL. Use the manifest
    file *db-deployment.yaml* created previously by the `Kompose` utility:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为 PostgreSQL 创建 Deployment 对象。使用之前由 `Kompose` 工具创建的清单文件 *db-deployment.yaml*：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To create the deployment, use the `kubectl create -f` command and point it
    to the manifest file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建部署，请使用 `kubectl create -f` 命令，并指向清单文件：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To verify that the deployment was created, list all deployments in the cluster
    and list the pods that were created as part of the deployment:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证是否已创建部署，请列出集群中的所有部署，并列出作为部署一部分创建的 pod：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, create the database for the example Flask application. Use a similar
    command to `docker exec` to run the `psql` command inside a running Docker container.
    The form of the command in the case of a Kubernetes cluster is `kubectl exec`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为示例 Flask 应用程序创建数据库。使用类似于 `docker exec` 的命令在运行中的 Docker 容器内运行 `psql` 命令。在
    Kubernetes 集群中，命令的形式是 `kubectl exec`：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The next step is to create the Service object corresponding to the `db` deployment,
    that will expose the deployment to the other services running inside the cluster,
    such as the Redis worker service and the main application service. Here is the
    manifest file for the `db` service:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建与 `db` 部署相对应的 Service 对象，将部署暴露给运行在集群内的其他服务，例如 Redis worker 服务和主应用程序服务。这是
    `db` 服务的清单文件：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'One thing to note is the following section:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是以下部分：
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This section appears in both the deployment manifest and the service manifest
    and is indeed the way to tie the two together. A service will be associated with
    any deployment that has the same label.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分同时出现在部署清单和服务清单中，并确实是将两者联系在一起的方法。服务将与具有相同标签的任何部署关联。
- en: 'Create the Service object with the `kubectl create -f` command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `kubectl create -f` 命令创建 Service 对象：
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'List all services and notice that the `db` service was created:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 列出所有服务，并注意已创建的 `db` 服务：
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The next service to deploy is Redis. Create the Deployment and Service objects
    based on the manifest files generated by `Kompose`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要部署的服务是 Redis。基于由 `Kompose` 生成的清单文件创建 Deployment 和 Service 对象：
- en: '[PRE19]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So far, the two services that have been deployed, `db` and `redis`, are independent
    of each other. The next part of the application is the worker process, which needs
    to talk to both PostgreSQL and Redis. This is where the advantage of using Kubernetes
    services comes into play. The worker deployment can refer to the endpoints for
    PostgreSQL and Redis by using the service names. Kubernetes knows how to route
    the requests from the client (the containers running as part of the pods in the
    worker deployment) to the servers (the PostgreSQL and Redis containers running
    as part of the pods in the `db` and `redis` deployments, respectively).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，已部署的两个服务，`db` 和 `redis`，互不影响。应用程序的下一部分是工作进程，需要与 PostgreSQL 和 Redis 进行通信。这就是使用
    Kubernetes 服务的优势所在。工作部署可以通过服务名称引用 PostgreSQL 和 Redis 的端点。Kubernetes 知道如何将来自客户端（作为工作部署中的
    pod 的一部分运行的容器）的请求路由到服务器（作为 `db` 和 `redis` 部署中的 pod 的一部分运行的 PostgreSQL 和 Redis
    容器）。
- en: One of the environment variables used in the worker deployment is `DATABASE_URL`.
    It contains the database password used by the application. The password should
    not be exposed in clear text in the deployment manifest file, because this file
    needs to be checked into version control. Instead, create a Kubernetes Secret
    object.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 工作节点部署中使用的环境变量之一是`DATABASE_URL`。 它包含应用程序使用的数据库密码。 不应在部署清单文件中明文显示密码，因为该文件需要检入版本控制。
    取而代之，创建一个 Kubernetes Secret 对象。
- en: 'First, encode the password string in `base64`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将密码字符串编码为`base64`：
- en: '[PRE20]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, create a manifest file describing the Kubernetes Secret object that you
    want to create. Since the `base64` encoding of the password is not secure, use
    `sops` to edit and save an encrypted manifest file *secrets.yaml.enc*:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个描述要创建的 Kubernetes Secret 对象的清单文件。 由于密码的`base64`编码不安全，请使用`sops`来编辑和保存加密的清单文件*secrets.yaml.enc*：
- en: '[PRE21]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Inside the editor, add these lines:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑器中添加这些行：
- en: '[PRE22]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The *secrets.yaml.enc* file can now be checked in because it contains the encrypted
    version of the `base64` value of the password.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*secrets.yaml.enc* 文件现在可以检入，因为它包含密码的`base64`值的加密版本。'
- en: 'To decrypt the encrypted file, use the `sops -d` command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要解密加密文件，请使用`sops -d`命令：
- en: '[PRE23]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Pipe the output of `sops -d` to `kubectl create -f` to create the Kubernetes
    Secret object:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 将`sops -d`的输出导向`kubectl create -f`以创建 Kubernetes Secret 对象：
- en: '[PRE24]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Inspect the Kubernetes Secrets and describe the Secret that was created:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 Kubernetes Secrets 并描述已创建的 Secret：
- en: '[PRE25]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To get the `base64`-encoded Secret back, use:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取`base64`编码的 Secret，请使用：
- en: '[PRE26]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To get the plain-text password back, use the following command on a macOS machine:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 macOS 机器上获取纯文本密码，请使用以下命令：
- en: '[PRE27]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'On a Linux machine, the proper flag for `base64` decoding is `-d`, so the correct
    command would be:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 机器上，`base64`解码的正确标志是`-d`，因此正确的命令将是：
- en: '[PRE28]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The secret can now be used in the deployment manifest of the worker. Modify
    the *worker-deployment.yaml* file generated by the `Kompose` utility and add two
    environment variables:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以在工作节点的部署清单中使用该秘密。 修改由`Kompose`实用程序生成的*worker-deployment.yaml*文件，并添加两个环境变量：
- en: '`DBPASS` is the database password that will be retrieved from the fbe-secret
    Secret object.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DBPASS`是从`fbe-secret` Secret 对象中检索的数据库密码。'
- en: '`DATABASE_URL` is the full database connection string for PostgreSQL, which
    includes the database password and references it as `${DBPASS}`.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DATABASE_URL`是 PostgreSQL 的完整数据库连接字符串，包括数据库密码，并将其引用为`${DBPASS}`。'
- en: 'This is the modified version of *worker-deployment.yaml*:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是修改后的*worker-deployment.yaml*的版本：
- en: '[PRE29]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create the worker Deployment object in the same way as for the other deployments,
    by calling `kubectl create -f`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`kubectl create -f`创建工作节点部署对象的方式与其他部署相同：
- en: '[PRE30]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'List the pods:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列出 pods：
- en: '[PRE31]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Note that the worker pod is shown with status `Init:ErrImagePull`. To see details
    about this status, run `kubectl describe`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，工作节点显示为状态`Init:ErrImagePull`。 要查看有关此状态的详细信息，请运行`kubectl describe`：
- en: '[PRE32]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The deployment tried to pull the `griggheo/flask-by-example:v1` private Docker
    image from Docker Hub, and it lacked the appropriate credentials to access the
    private Docker registry. Kubernetes includes a special type of object for this
    very scenario, called an *imagePullSecret*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 部署尝试从 Docker Hub 拉取`griggheo/flask-by-example:v1`私有 Docker 镜像，并且缺少访问私有 Docker
    注册表所需的适当凭据。 Kubernetes 包括一种特殊类型的对象，用于处理这种情况，称为*imagePullSecret*。
- en: 'Create an encrypted file with `sops` containing the Docker Hub credentials
    and the call to `kubectl create secret`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sops`创建包含 Docker Hub 凭据和`kubectl create secret`调用的加密文件：
- en: '[PRE33]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The contents of the file are:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的内容是：
- en: '[PRE34]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Decode the encrypted file with `sops` and run it through `bash`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sops`解密加密文件并通过`bash`运行它：
- en: '[PRE35]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Inspect the Secret:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 检查秘密：
- en: '[PRE36]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The only change to the worker deployment manifest is to add these lines:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对工作节点部署清单的唯一更改是添加这些行：
- en: '[PRE37]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Include it right after this line:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在此行后包含它：
- en: '[PRE38]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Delete the worker deployment and recreate it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 删除工作节点部署并重新创建：
- en: '[PRE39]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now the worker pod is in a Running state, with no errors:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在工作节点处于运行状态，并且没有错误：
- en: '[PRE40]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Inspect the worker pod’s logs with the `kubectl logs` command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl logs`命令检查工作节点的日志：
- en: '[PRE41]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The next step is to tackle the application deployment. When the application
    was deployed in a `docker-compose` setup in [Chapter 11](ch11.html#containers-docker),
    a separate Docker container was employed to run the migrations necessary to update
    the Flask database. This type of task is a good candidate for running as a sidecar
    container in the same pod as the main application container. The sidecar will
    be defined as a Kubernetes [`initContainer`](https://oreil.ly/80L5L) inside the
    application deployment manifest. This type of container is guaranteed to run inside
    the pod it belongs to before the start of the other containers included in the
    pod.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是解决应用程序部署的步骤。当应用程序在[第11章](ch11.html#containers-docker)中以`docker-compose`设置部署时，使用单独的Docker容器来运行更新Flask数据库所需的迁移。这种任务很适合作为同一Pod中主应用程序容器的侧车容器运行。侧车容器将在应用程序部署清单中定义为Kubernetes的[`initContainer`](https://oreil.ly/80L5L)。此类容器保证在属于其所属的Pod内的其他容器启动之前运行。
- en: 'Add this section to the *app-deployment.yaml* manifest file that was generated
    by the `Kompose` utility, and delete the *migrations-deployment.yaml* file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将此部分添加到由`Kompose`实用程序生成的*app-deployment.yaml*清单文件中，并删除*migrations-deployment.yaml*文件：
- en: '[PRE42]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Reuse the `fbe-secret` Secret object created for the worker deployment in the
    application deployment manifest:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序部署清单中复用为工作程序部署创建的`fbe-secret` Secret对象：
- en: '[PRE43]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create the application deployment with `kubectl create -f`, then list the pods
    and describe the application pod:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl create -f`创建应用程序部署，然后列出Pod并描述应用程序Pod：
- en: '[PRE44]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The last piece in the deployment of the application to `minikube` is to ensure
    that a Kubernetes service is created for the application and that it is declared
    as type `LoadBalancer`, so it can be accessed from outside the cluster:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序部署到`minikube`的最后一步是确保为应用程序创建Kubernetes服务，并将其声明为类型`LoadBalancer`，以便从集群外访问：
- en: '[PRE45]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Similar to the `db` service, the `app` service is tied to the `app` deployment
    through a label declaration that exists in both the deployment and the service
    manifest for the application:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与`db`服务类似，`app`服务通过在应用程序部署和服务清单中存在的标签声明与`app`部署关联：
- en: '[PRE46]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create the service with `kubectl create`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl create`创建服务：
- en: '[PRE47]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, run:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来运行：
- en: '[PRE48]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This command opens the default browser with the URL [*http://192.168.99.100:30097/*](http://192.168.99.100:30097/)
    and shows the home page of the Flask site.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将使用URL[*http://192.168.99.100:30097/*](http://192.168.99.100:30097/)打开默认浏览器，并显示Flask站点的主页。
- en: In our next section, we will take the same Kubernetes manifest files for our
    application and deploy them to a Kubernetes cluster that will be provisioned with
    Pulumi in the Google Cloud Platform (GCP).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用相同的Kubernetes清单文件部署我们的应用程序到一个将由Pulumi在Google Cloud Platform（GCP）中配置的Kubernetes集群中。
- en: Launching a GKE Kubernetes Cluster in GCP with Pulumi
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Pulumi在Google Cloud Platform（GCP）中启动GKE Kubernetes集群
- en: In this section, we’ll make use of the [Pulumi GKE example](https://oreil.ly/VGBfF)
    and also of the [GCP setup documentation](https://oreil.ly/kRsFA), so use these
    links to obtain the necessary documents before proceeding.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用[Pulumi GKE示例](https://oreil.ly/VGBfF)以及[GCP设置文档](https://oreil.ly/kRsFA)，因此在继续之前，请使用这些链接获取所需的文档。
- en: 'Start by creating a new directory:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个新目录：
- en: '[PRE49]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Set up the Google Cloud SDK using the [macOS instructions](https://oreil.ly/f4pPs).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[macOS说明](https://oreil.ly/f4pPs)设置Google Cloud SDK。
- en: 'Initialize the GCP environment using the `gcloud init` command. Create a new
    configuration and a new project named *pythonfordevops-gke-pulumi*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`gcloud init`命令初始化GCP环境。创建一个新的配置和一个名为*pythonfordevops-gke-pulumi*的新项目：
- en: '[PRE50]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Log in to the GCP account:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到GCP帐户：
- en: '[PRE51]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Log in to the default application, which is `pythonfordevops-gke-pulumi`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到默认应用程序`pythonfordevops-gke-pulumi`：
- en: '[PRE52]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create a new Pulumi project by running the `pulumi new` command, specifying
    *gcp-python* as your template and *pythonfordevops-gke-pulumi* as the name of
    the project:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`pulumi new`命令创建一个新的Pulumi项目，指定*gcp-python*作为模板，*pythonfordevops-gke-pulumi*作为项目名称：
- en: '[PRE53]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The following files were created by the `pulumi new` command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文件由`pulumi new`命令创建：
- en: '[PRE54]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We are going to make use of the `gcp-py-gke` example from the [Pulumi examples](https://oreil.ly/SIT-v)
    GitHub repository.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用[Pulumi示例](https://oreil.ly/SIT-v)GitHub存储库中的`gcp-py-gke`示例。
- en: 'Copy **.py* and *requirements.txt* from *examples/gcp-py-gke* to our current
    directory:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从*examples/gcp-py-gke*复制**.py*和*requirements.txt*到当前目录：
- en: '[PRE55]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Configure GCP-related variables needed for Pulumi to operate in GCP:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 配置与Pulumi在GCP中操作所需的与GCP相关的变量：
- en: '[PRE56]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create and use a Python `virtualenv`, install the dependencies declared in
    *requirements.txt*, and then bring up the GKE cluster defined in *mainpy* by running
    the `pulumi up` command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并使用Python `virtualenv`，安装*requirements.txt*中声明的依赖项，然后通过运行`pulumi up`命令启动在*mainpy*中定义的GKE集群：
- en: '[PRE57]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Tip
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Make sure you enable the Kubernetes Engine API by associating it with a Google
    billing account in the GCP web console.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 确保通过在GCP Web控制台中将其与Google计费账户关联来启用Kubernetes Engine API。
- en: The GKE cluster can now be seen in the [GCP console](https://oreil.ly/Su5FZ).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[GCP控制台](https://oreil.ly/Su5FZ)中看到GKE集群。
- en: 'To interact with the newly provisioned GKE cluster, generate the proper `kubectl`
    configuration and use it. Handily, the `kubectl` configuration is being exported
    as `output` by the Pulumi program:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 生成适当的`kubectl`配置以及使用它与新配置的GKE集群进行交互。通过Pulumi程序将`kubectl`配置方便地导出为`output`：
- en: '[PRE58]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'List the nodes comprising the GKE cluster:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 列出组成GKE集群的节点：
- en: '[PRE59]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Deploying the Flask Example Application to GKE
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Flask示例应用程序部署到GKE
- en: 'Take the same Kubernetes manifests used in the `minikube` example and deploy
    them to the Kubernetes cluster in GKE, via the `kubectl` command. Start by creating
    the `redis` deployment and service:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的Kubernetes清单文件在GKE集群中部署`minikube`示例，通过`kubectl`命令。首先创建`redis`部署和服务：
- en: '[PRE60]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Create a PersistentVolumeClaim to be used as the data volume for the PostgreSQL
    database:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个PersistentVolumeClaim，用作PostgreSQL数据库的数据卷：
- en: '[PRE61]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Create the `db` deployment:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`db`部署：
- en: '[PRE62]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We hit a snag when trying to create the `db` deployment. GKE provisioned a persistent
    volume that was mounted as */var/lib/postgresql/data*, and according to the error
    message above, was not empty.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试创建`db`部署时遇到了问题。GKE提供了一个已挂载为*/var/lib/postgresql/data*的持久卷，并且根据上述错误消息，该目录并非空。
- en: 'Delete the failed `db` deployment:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 删除失败的`db`部署：
- en: '[PRE63]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Create a new temporary pod used to mount the same `dbdata` PersistentVolumeClaim
    as */data* inside the pod, so its filesystem can be inspected. Launching this
    type of temporary pod for troubleshooting purposes is a useful technique to know
    about:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的临时Pod，用于挂载与Pod内部的*/data*中相同的`dbdata` PersistentVolumeClaim，以便检查其文件系统。为了故障排除目的，启动这种类型的临时Pod是一个有用的技术手段：
- en: '[PRE64]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Use `kubectl exec` to open a shell inside the pod so */data* can be inspected:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl exec`打开Pod内部的shell，以便检查*/data*：
- en: '[PRE65]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note how */data* contained a directory called *lost+found* that needed to be
    removed.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意*/data*中包含一个需要移除的名为*lost+found*的目录。
- en: 'Delete the temporary pod:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 删除临时Pod：
- en: '[PRE66]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Create the `db` deployment again, which completes successfully this time:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 再次创建`db`部署，在这次操作中成功完成：
- en: '[PRE67]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Create `wordcount` database and role:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`wordcount`数据库和角色：
- en: '[PRE68]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Create the `db` service:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`db`服务：
- en: '[PRE69]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Create the Secret object based on the `base64` value of the database password.
    The plain-text value for the password is stored in a file encrypted with `sops`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数据库密码的`base64`值创建Secret对象。密码的明文值存储在使用`sops`加密的文件中：
- en: '[PRE71]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Create another Secret object representing the Docker Hub credentials:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 创建另一个表示Docker Hub凭据的Secret对象：
- en: '[PRE72]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Since the scenario under consideration is a production-type deployment of the
    appication to GKE, set `replicas` to `3` in *worker-deployment.yaml* to ensure
    that three worker pods are running at all times:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到正在考虑的情景是将应用程序部署到GKE的生产类型部署，将*worker-deployment.yaml*中的`replicas`设置为`3`以确保始终运行三个worker
    Pod：
- en: '[PRE73]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Make sure that three worker pods are running:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 确保有三个worker Pod正在运行：
- en: '[PRE74]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Similarly, set `replicas` to two in *app-deployment.yaml*:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在*app-deployment.yaml*中将`replicas`设置为两个：
- en: '[PRE75]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Make sure that two app pods are running:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 确保有两个应用程序Pod正在运行：
- en: '[PRE76]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Create the `app` service:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`app`服务：
- en: '[PRE77]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Note that a service of type LoadBalancer was created:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到创建了一个类型为LoadBalancer的服务：
- en: '[PRE78]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Test the application by accessing the endpoint URL based on the IP address
    corresponding to `LoadBalancer Ingress`: [*http://34.83.242.171:5000*](http://34.83.242.171:5000).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应用程序，访问基于`LoadBalancer Ingress`对应的IP地址的端点URL：[*http://34.83.242.171:5000*](http://34.83.242.171:5000)。
- en: We have demonstrated how to create Kubernetes objects such as Deployments, Services,
    and Secrets from raw Kubernetes manifest files. As your application becomes more
    complicated, this approach will start showing its limitations, because it will
    get harder to customize these files per environment (for example, for staging
    versus integration versus production). Each environment will have its own set
    of environment values and secrets that you will need to keep track of. In general,
    it will become more and more complicated to keep track of which manifests have
    been installed at a given time. Many solutions to this problem exist in the Kubernetes
    ecosystem, and one of the most common ones is to use the [Helm](https://oreil.ly/duKVw)
    package manager. Think of Helm as the Kubernetes equivalent of the `yum` and `apt`
    package managers.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们演示了如何从原始 Kubernetes 清单文件创建 Kubernetes 对象（如 Deployments、Services 和 Secrets）。随着应用程序变得更加复杂，此方法的局限性开始显现，因为定制这些文件以适应不同环境（例如，分阶段、集成和生产环境）将变得更加困难。每个环境都将有其自己的环境值和秘密，您需要跟踪这些内容。一般而言，跟踪在特定时间安装了哪些清单将变得越来越复杂。Kubernetes
    生态系统中存在许多解决此问题的方案，其中最常见的之一是使用[Helm](https://oreil.ly/duKVw)包管理器。把 Helm 视为 `yum`
    和 `apt` 包管理器的 Kubernetes 等价物。
- en: The next section shows how to use Helm to install and customize Prometheus and
    Grafana inside the GKE cluster.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将展示如何使用 Helm 在 GKE 集群内安装和自定义 Prometheus 和 Grafana。
- en: Installing Prometheus and Grafana Helm Charts
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Prometheus 和 Grafana Helm Charts
- en: In its current version (v2 as of this writing), Helm has a server-side component
    called Tiller that needs certain permissions inside the Kubernetes cluster.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前版本（截至本文撰写时为 v2），Helm 具有一个名为 Tiller 的服务器端组件，需要在 Kubernetes 集群内具有特定权限。
- en: 'Create a new Kubernetes Service Account for Tiller and give it the proper permissions:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为 Tiller 创建一个新的 Kubernetes Service Account，并赋予适当的权限：
- en: '[PRE79]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Download and install the Helm binary for your operating system from the official
    [Helm release](https://oreil.ly/sPwDO) page, and then install Tiller with the
    `helm init` command:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 从官方[Helm发布](https://oreil.ly/sPwDO)页面下载并安装适用于您操作系统的Helm二进制文件，然后使用`helm init`命令安装
    Tiller：
- en: '[PRE80]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Create a namespace called `monitoring`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `monitoring` 的命名空间：
- en: '[PRE81]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Install the Prometheus [Helm chart](https://oreil.ly/CSaSo) in the `monitoring`
    namespace:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `monitoring` 命名空间中安装 Prometheus [Helm chart](https://oreil.ly/CSaSo)：
- en: '[PRE82]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'List pods, services, and configmaps in the `monitoring` namespace:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 列出 `monitoring` 命名空间中的 pods、services 和 configmaps：
- en: '[PRE83]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Connect to Prometheus UI via the `kubectl port-forward` command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`kubectl port-forward`命令连接到 Prometheus UI：
- en: '[PRE84]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Go to localhost:9090 in a browser and see the Prometheus UI.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中转到 localhost:9090 并查看 Prometheus UI。
- en: 'Install the Grafana [Helm chart](https://oreil.ly/--wEN) in the `monitoring`
    namespace:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `monitoring` 命名空间中安装 Grafana [Helm chart](https://oreil.ly/--wEN)：
- en: '[PRE85]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'List Grafana-related pods, services, configmaps, and secrets in the `monitoring`
    namespace:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 列出 `monitoring` 命名空间中与 Grafana 相关的 pods、services、configmaps 和 secrets：
- en: '[PRE86]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Retrieve the password for the `admin` user for the Grafana web UI:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 检索 Grafana Web UI 中 `admin` 用户的密码：
- en: '[PRE87]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Connect to the Grafana UI using the `kubectl port-forward` command:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`kubectl port-forward`命令连接到 Grafana UI：
- en: '[PRE88]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Go to localhost:3000 in a browser and see the Grafana UI. Log in as user admin
    with the password retrieved above.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中转到 localhost:3000 并查看 Grafana UI。使用上述检索到的密码以 admin 用户身份登录。
- en: 'List the charts currently installed with `helm list`. When a chart is installed,
    the current installation is called a “Helm release”:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `helm list` 列出当前已安装的 charts。安装 chart 后，当前的安装称为 “Helm release”：
- en: '[PRE89]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Most of the time you will need to customize a Helm chart. It is easier to do
    that if you download the chart and install it from the local filesystem with `helm`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，您需要自定义一个 Helm chart。如果您从本地文件系统下载 chart 并使用 `helm` 安装，则会更容易进行此操作。
- en: 'Get the latest stable Prometheus and Grafana Helm charts with the `helm fetch`
    command, which will download `tgz` archives of the charts:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `helm fetch` 命令获取最新稳定版本的 Prometheus 和 Grafana Helm charts，该命令将下载这些 chart
    的 `tgz` 归档文件：
- en: '[PRE90]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Unarchive the `tgz` files, then remove them:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 解压 `tgz` 文件，然后删除它们：
- en: '[PRE91]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The templatized Kubernetes manifests are stored by default in a directory called
    *templates* under the chart directory, so in this case these locations would be
    *prometheus/templates* and *grafana/templates*. The configuration values for a
    given chart are declared in the *values.yaml* file in the chart directory.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，模板化的 Kubernetes 清单存储在 chart 目录下名为 *templates* 的目录中，因此在此例中，这些位置将分别是 *prometheus/templates*
    和 *grafana/templates*。给定 chart 的配置值在 chart 目录下的 *values.yaml* 文件中声明。
- en: As an example of a Helm chart customization, let’s add a persistent volume to
    Grafana, so we don’t lose the data when we restart the Grafana pods.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Helm 图表定制的示例，让我们向 Grafana 添加一个持久卷，这样当重启 Grafana pods 时就不会丢失数据。
- en: 'Modify the file *grafana/values.yaml* and set the the value of the `enabled`
    subkey under the `persistence` parent key to `true` (by default it is `false`)
    in this section:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 修改文件 *grafana/values.yaml*，并在该部分将 `persistence` 父键下的 `enabled` 子键的值设置为 `true`（默认为
    `false`）。
- en: '[PRE92]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Upgrade the existing `grafana` Helm release with the `helm upgrade` command.
    The last argument of the command is the name of the local directory containing
    the chart. Run this command in the parent directory of the *grafana* chart directory:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `helm upgrade` 命令来升级现有的 `grafana` Helm 发布。命令的最后一个参数是包含图表的本地目录的名称。在 *grafana*
    图表目录的父目录中运行此命令：
- en: '[PRE93]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Verify that a PVC has been created for Grafana in the `monitoring` namespace:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 验证在 `monitoring` 命名空间中为 Grafana 创建了 PVC：
- en: '[PRE94]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Another example of a Helm chart customization, this time for Prometheus, is
    modifying the default retention period of 15 days for the data stored in Prometheus.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 Helm 图表定制的示例是修改 Prometheus 中存储数据的默认保留期，从 15 天改为其他。
- en: 'Change the `retention` value in *prometheus/values.yaml* to 30 days:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *prometheus/values.yaml* 文件中将 `retention` 值更改为 30 天：
- en: '[PRE95]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Upgrade the existing Prometheus Helm release by running `helm upgrade`. Run
    this command in the parent directory of the *prometheus* chart directory:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 `helm upgrade` 命令来升级现有的 Prometheus Helm 发布。在 *prometheus* 图表目录的父目录中运行此命令：
- en: '[PRE96]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Verify that the retention period was changed to 30 days. Run `kubectl describe`
    against the running Prometheus pod in the `monitoring` namespace and look at the
    `Args` section of the output:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 验证保留期已更改为 30 天。运行 `kubectl describe` 命令针对 `monitoring` 命名空间中运行的 Prometheus pod，并查看输出的
    `Args` 部分：
- en: '[PRE97]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Destroying the GKE Cluster
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 销毁 GKE 集群
- en: It pays (literally) to remember to delete any cloud resources you’ve been using
    for testing purposes if you do not need them anymore. Otherwise, you may have
    an unpleasant surprise when you receive the billing statement from your cloud
    provider at the end of the month.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不再需要，记得删除用于测试目的的任何云资源，因为这真的很“贵”。否则，月底收到云服务提供商的账单时，可能会有不愉快的惊喜。
- en: 'Destroy the GKE cluster via `pulumi destroy`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `pulumi destroy` 销毁 GKE 集群：
- en: '[PRE98]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Exercises
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Use Google Cloud SQL for PostgreSQL, instead of running PostgreSQL in a Docker
    container in GKE.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 GKE 中不再运行 PostgreSQL 的 Docker 容器，而是使用 Google Cloud SQL for PostgreSQL。
- en: Use the [AWS Cloud Development Kit](https://aws.amazon.com/cdk) to launch an
    Amazon EKS cluster, and deploy the example application to that cluster.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 [AWS 云开发工具包](https://aws.amazon.com/cdk) 来启动 Amazon EKS 集群，并将示例应用部署到该集群中。
- en: Use Amazon RDS PostgreSQL instead of running PostgreSQL in a Docker container
    in EKS.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 EKS 中不再运行 PostgreSQL 的 Docker 容器，而是使用 Amazon RDS PostgreSQL。
- en: Experiment with [Kustomize](https://oreil.ly/ie9n6) as an alternative to Helm
    for managing Kubernetes manifest YAML files.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用 [Kustomize](https://oreil.ly/ie9n6) 作为管理 Kubernetes 清单 YAML 文件的 Helm 替代方案。
