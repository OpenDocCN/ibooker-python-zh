- en: Chapter 4\. Remote Actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about Ray remote functions, which are useful
    for the parallel execution of stateless functions. But what if you need to maintain
    a state between invocations? Examples of such situations span from a simple counter
    to a neural network during training to a simulator environment.
  prefs: []
  type: TYPE_NORMAL
- en: One option for maintaining state in these situations is to return the state
    along with the result and pass it to the next call. Although technically this
    will work, this is not the best solution, because of the large amount of data
    that has to be passed around (especially as the size of the state starts to grow).
    Ray uses actors, which we will cover in this chapter, to manage state.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Much like Ray’s remote functions, all Ray actors are remote actors, even when
    running on the same machine.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, an *actor* is a computer process with an address (handle). This
    means that an actor can also store things in memory, private to the actor process.
    Before delving into the details of implementing and scaling Ray actors, let’s
    take a look at the concepts behind them. Actors come from the actor model design
    pattern. Understanding the actor model is key to effectively managing state and
    concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Actor Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The [actor model](https://oreil.ly/aTwGY) was introduced by Carl Hewitt in 1973
    to deal with concurrent computation. The heart of this conceptual model is an
    actor, a universal primitive of concurrent computation with its state.
  prefs: []
  type: TYPE_NORMAL
- en: 'An actor has a simple job:'
  prefs: []
  type: TYPE_NORMAL
- en: Store data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receive messages from other actors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass messages to other actors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create additional child actors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data that an actor stores is private to the actor and isn’t visible from
    outside; it can be accessed and modified only by the actor itself. Changing the
    actor’s state requires sending messages to the actor that will modify the state.
    (Compare this to using method calls in object-oriented programming.)
  prefs: []
  type: TYPE_NORMAL
- en: To ensure an actor’s state consistency, actors process one request at a time.
    All actor method invocations are globally serialized for a given actor. To improve
    throughput, people often create a pool of actors (assuming they can shard or replicate
    the actor’s state).
  prefs: []
  type: TYPE_NORMAL
- en: 'The actor model is a good fit for many distributed system scenarios. Here are
    some typical use cases where the actor model can be advantageous:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to deal with a large distributed state that is hard to synchronize
    between invocations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to work with single-threaded objects that do not require significant
    interaction from external components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both situations, you would implement the standalone parts of the work inside
    an actor. You can put each piece of independent state inside its own actor, and
    then any changes to the state come in through the actor. Most actor system implementations
    avoid concurrency issues by using only single-threaded actors.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know the general principles of the actor model, let’s take a closer
    look at Ray’s remote actors.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Basic Ray Remote Actor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ray implements remote actors as stateful workers. When you create a new remote
    actor, Ray creates a new worker and schedules the actor’s methods on that worker.
  prefs: []
  type: TYPE_NORMAL
- en: A common example of an actor is a bank account. Let’s take a look at how to
    implement an account by using Ray remote actors. Creating a Ray remote actor is
    as simple as decorating a Python class with the `@ray.remote` decorator ([Example 4-1](#simple_remote_actor_creation)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-1\. [Implementing a Ray remote actor](https://oreil.ly/Dpskz)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Account` actor class itself is fairly simple and has four methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor
  prefs: []
  type: TYPE_NORMAL
- en: Creates an account based on the starting and minimum balance. It also makes
    sure that the current balance is larger than the minimal one and throws an exception
    otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '`balance`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the current balance of the account. Because an actor’s state is private
    to the actor, access to it is available only through the actor’s method.
  prefs: []
  type: TYPE_NORMAL
- en: '`deposit`'
  prefs: []
  type: TYPE_NORMAL
- en: Deposits an amount to the account and returns a new balance.
  prefs: []
  type: TYPE_NORMAL
- en: '`withdraw`'
  prefs: []
  type: TYPE_NORMAL
- en: Withdraws an amount from the account and returns a new balance. It also ensures
    that the remaining balance is greater than the predefined minimum balance and
    throws an exception otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have defined the class, you need to use `.remote` to create an
    instance of this actor ([Example 4-2](#make_actor)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-2\. [Creating an instance of your Ray remote actor](https://oreil.ly/Dpskz)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, `account_actor` represents an actor handle. These handles play an important
    role in the actor’s lifecycle. Actor processes are terminated automatically when
    the initial actor handle goes out of scope in Python (note that in this case,
    the actor’s state is lost).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can create multiple distinct actors from the same class. Each will have
    its own independent state.
  prefs: []
  type: TYPE_NORMAL
- en: As with an `ObjectRef`, you can pass an actor handle as a parameter to another
    actor or Ray remote function or Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Note that [Example 4-1](#simple_remote_actor_creation) uses the `@ray.remote`
    annotation to define an ordinary Python class as a Ray remote actor. Alternatively,
    instead of using an annotation, you can use [Example 4-3](#make_actor_2) to convert
    a Python class into a remote actor.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-3\. [Creating an instance of a Ray remote actor without the decorator](https://oreil.ly/Dpskz)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once you have a remote actor in place, you can invoke it by using [Example 4-4](#invoke_actor).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-4\. [Invoking a remote actor](https://oreil.ly/Dpskz)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'It’s important to handle exceptions, which in the example can occur in both
    the the deposit and withdrawal method’s code. To handle the exceptions, you should
    augment [Example 4-4](#invoke_actor) with `try`/`except` clauses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the code will intercept all the exceptions thrown by the actor’s
    code and implement all the necessary actions.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create named actors by using [Example 4-5](#make_named_actor).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-5\. [Creating a named actor](https://oreil.ly/Dpskz)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the actor has a name, you can use it to obtain the actor’s handle from
    any place in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As defined previously, the default actor’s lifecycle is linked to the actor’s
    handle being in scope.
  prefs: []
  type: TYPE_NORMAL
- en: An actor’s lifetime can be decoupled from its handle being in scope, allowing
    an actor to persist even after the driver process exits. You can create a detached
    actor by specifying the lifetime parameter as `detached` ([Example 4-6](#make_detached_named_actor)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-6\. [Making a detached actor](https://oreil.ly/Dpskz)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In theory, you can make an actor detached without specifying its name, but since
    `ray.get_actor` operates by name, detached actors make the most sense with a name.
    You should name your detached actors so you can access them, even after the actor’s
    handle is out of scope. The detached actor itself can own any other tasks and
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you can manually delete actors from inside an actor, using `ray.actor.exit_actor`,
    or by using an actor’s handle `ray.kill(account_actor)`. This can be useful if
    you know that you do not need specific actors anymore and want to reclaim the
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown here, creating a basic Ray actor and managing its lifecycle is fairly
    easy, but what happens if the Ray node on which the actor is running goes down
    for some reason?^([1](ch04.html#idm45354785265712)) The `@ray.remote` annotation
    allows you to specify two [parameters](https://oreil.ly/VAHBm) that control behavior
    in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '`max_restarts`'
  prefs: []
  type: TYPE_NORMAL
- en: Specify the maximum number of times that the actor should be restarted when
    it dies unexpectedly. The minimum valid value is `0` (default), which indicates
    that the actor doesn’t need to be restarted. A value of `-1` indicates that an
    actor should be restarted indefinitely.
  prefs: []
  type: TYPE_NORMAL
- en: '`max_task_retries`'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies the number of times to retry an actor’s task if the task fails because
    of a system error. If set to `-1`, the system will retry the failed task until
    the task succeeds, or the actor has reached its `max_restarts` limit. If set to
    `n > 0`, the system will retry the failed task up to *n* times, after which the
    task will throw a `RayActorError` exception upon [`ray.get`](https://oreil.ly/li5RX).
  prefs: []
  type: TYPE_NORMAL
- en: As further explained in the next chapter and in the [Ray fault-tolerance documentation](https://oreil.ly/S64hX),
    when an actor is restarted, Ray will re-create its state by rerunning its constructor.
    Therefore, if a state was changed during the actor’s execution, it will be lost.
    To preserve such a state, an actor has to implement its custom persistence.
  prefs: []
  type: TYPE_NORMAL
- en: In our example case, the actor’s state is lost on failure since we haven’t used
    actor persistence. This might be OK for some use cases but is not acceptable for
    others—​see also the [Ray documentation on design patterns](https://oreil.ly/tezP2).
    In the next section, you will learn how to programmatically implement custom actor
    persistence.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Actor’s Persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this implementation, the state is saved as a whole, which works well enough
    if the size of the state is relatively small and the state changes are relatively
    rare. Also, to keep our example simple, we use local disk persistence. In reality,
    for a distributed Ray case, you should consider using Network File System (NFS),
    Amazon Simple Storage Service (S3), or a database to enable access to the actor’s
    data from any node in the Ray cluster.
  prefs: []
  type: TYPE_NORMAL
- en: A persistent `Account` actor is presented in [Example 4-7](#persistent_actor).^([2](ch04.html#idm45354785245664))
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-7\. [Defining a persistent actor, using filesystem persistence](https://oreil.ly/qHSfR)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compare this implementation with the original in [Example 4-1](#simple_remote_actor_creation),
    we will notice several important changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here the constructor has two additional parameters: `account_key` and `basedir`.
    The account key is a unique identifier for the account that is also used as the
    name of the persistence file. The `basedir` parameter indicates a base directory
    used for storing persistence files. When the constructor is invoked, we first
    check whether a persistent state for this account is saved, and if there is one,
    we ignore the passed-in balance and minimum balance and restore them from the
    persistence state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two additional methods are added to the class: `store_state` and `restore_state`.
    The `store_states` is a method that stores an actor state into a file. State information
    is represented as a dictionary with keys as names of the state elements and values
    as the state elements, values. We are using Ray’s implementation of cloud pickling
    to convert this dictionary to the byte string and then write this byte string
    to the file, defined by the account key and base directory. ([Chapter 5](ch05.html#ch05)
    provides a detailed discussion of cloud pickling.) The `restore_states` method
    restores the state from a file defined by an account key and base directory. The
    method reads a binary string from the file and uses Ray’s implementation of cloud
    pickling to convert it to the dictionary. Then it uses the content of the dictionary
    to populate the state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, both `deposit` and `withdraw` methods, which are changing the state,
    use the `store_state` method to update persistence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation shown in [Example 4-7](#persistent_actor) works fine, but
    our account actor implementation now contains too much persistence-specific code
    and is tightly coupled to file persistence. A better solution is to separate persistence-specific
    code into a separate class.
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating an abstract class defining methods that have to be implemented
    by any persistence class ([Example 4-8](#persistent_actor_class_base)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-8\. [Defining a base persistence class](https://oreil.ly/sI7Me)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This class defines all the methods that have to be implemented by a concrete
    persistence implementation. With this in place, a file persistence class implementing
    base persistence can be defined as shown in [Example 4-9](#persistent_actor_class_file).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-9\. [Defining a file persistence class](https://oreil.ly/sI7Me)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This implementation factors out most of the persistence-specific code from our
    original implementation in [Example 4-7](#persistent_actor). Now it is possible
    to simplify and generalize an account implementation; see [Example 4-10](#persistent_actor_class_actor).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-10\. [Implementing a persistent actor with pluggable persistence](https://oreil.ly/sI7Me)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Only the code changes from our original persistent actor implementation ([Example 4-7](#persistent_actor))
    are shown here. Note that the constructor is now taking the `Base​Per⁠sis⁠tence`
    class, which allows for easily changing the persistence implementation without
    changing the actor’s code. Additionally, the `restore_state` and `savestate` methods
    are generalized to move all the persistence-specific code to the persistence class.
  prefs: []
  type: TYPE_NORMAL
- en: This implementation is flexible enough to support different persistence implementations,
    but if a persistence implementation requires permanent connections to a persistence
    source (for example, a database connection), it can become unscalable by simultaneously
    maintaining too many connections. In this case, we can implement persistence as
    an [additional actor](https://oreil.ly/gz7wp). But this requires scaling of this
    actor. Let’s take a look at the options that Ray provides for scaling actors.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling Ray Remote Actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The original actor model described earlier in this chapter typically assumes
    that actors are lightweight (e.g., contain a single piece of state) and do not
    require scaling or parallelization. In Ray and similar systems (including Akka),
    actors are often used for coarser-grained implementations and can require scaling.^([3](ch04.html#idm45354778437024))
  prefs: []
  type: TYPE_NORMAL
- en: As with Ray remote functions, you can scale actors both *horizontally* (across
    processes/machines) with pools, or *vertically* (with more resources). [“Resources
    / Vertical Scaling”](ch05.html#ray_resources) covers how to request more resources,
    but for now, let’s focus on horizontal scaling.
  prefs: []
  type: TYPE_NORMAL
- en: You can add more processes for horizontal scaling with Ray’s actor pool, provided
    by the `ray.util` module. This class is similar to a multiprocessing pool and
    lets you schedule your tasks over a fixed pool of actors.
  prefs: []
  type: TYPE_NORMAL
- en: The actor pool effectively uses a fixed set of actors as a single entity and
    manages which actor in the pool gets the next request. Note that actors in the
    pool are still individual actors and their state is not merged. So this scaling
    option works only when an actor’s state is created in the constructor and does
    not change during the actor’s execution.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at how to use an actor’s pool to improve the scalability of
    our account class by adding an [actor’s pool](https://oreil.ly/hSXsd) in [Example 4-11](#persistent_actor_class_pool).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-11\. [Using an actor’s pool for implementing persistence](https://oreil.ly/UsjXG)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Only the code changes from our original implementation are shown here. The code
    starts by creating a pool of three identical file persistence actors, and then
    this pool is passed to an account implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of a pool-based execution is a lambda function that takes two parameters:
    an actor reference and a value to be submitted to the function. The limitation
    here is that the value is a single object. One of the solutions for functions
    with multiple parameters is to use a tuple that can contain an arbitrary number
    of components. The function itself is defined as a remote function on the required
    actor’s method.'
  prefs: []
  type: TYPE_NORMAL
- en: An execution on the pool is asynchronous (it routes requests to one of the remote
    actors internally). This allows faster execution of the `store_state` method,
    which does not need the results from data storage. Here implementation is not
    waiting for the result’s state storage to complete; it just starts the execution.
    The `restore_state` method, on another hand, needs the result of pool invocation
    to proceed. A pool implementation internally manages the process of waiting for
    execution results to become ready and exposes this functionality through the `get_next`
    function (note that this is a blocking call). The pool’s implementation manages
    a queue of execution results (in the same order as the requests). Whenever we
    need to get a result from the pool, we therefore must first clear out the pool
    results queue to ensure that we get the right result.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the multiprocessing-based scaling provided by the actor’s pool,
    Ray supports scaling of the actor’s execution through concurrency. Ray offers
    two types of concurrency within an actor: threading and async execution.'
  prefs: []
  type: TYPE_NORMAL
- en: When using concurrency inside actors, keep in mind that Python’s [global interpreter
    lock (GIL)](https://oreil.ly/l7Ytt) will allow only one thread of Python code
    running at once. Pure Python will not provide true parallelism. On another hand,
    if you invoke NumPy, Cython, TensorFlow, or PyTorch code, these libraries will
    release the GIL when calling into C/C++ functions. By overlapping the time waiting
    for I/O or working in native libraries, both threading and async actor execution
    can achieve some parallelism.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [asyncio library](https://oreil.ly/PXo8G) can be thought of as cooperative
    multitasking: your code or library needs to explicitly signal that it is waiting
    on a result, and Python can go ahead and execute another task by explicitly switching
    execution context. asyncio works by having a single process running through an
    event loop and changing which task it is executing when a task yields/awaits.
    asyncio tends to have lower overhead than multithreaded execution and can be a
    little easier to reason about. Ray actors, but not remote functions, integrate
    with asyncio, allowing you to write asynchronous actor methods.'
  prefs: []
  type: TYPE_NORMAL
- en: You should use threaded execution when your code spends a lot of time blocking
    but not yielding control by calling `await`. Threads are managed by the operating
    system deciding when to run which thread. Using threaded execution can involve
    fewer code changes, as you do not need to explicitly indicate where your code
    is yielding. This can also make threaded execution more difficult to reason about.
  prefs: []
  type: TYPE_NORMAL
- en: You need to be careful and selectively use locks when accessing or modifying
    objects with both threads and asyncio. In both approaches, your objects share
    the same memory. By using locks, you ensure that only one thread or task can access
    the specific memory. Locks have some overhead (which increases as more processes
    or threads are waiting on a lock). As a result, an actor’s concurrency is mostly
    applicable for use cases when a state is populated in a constructor and never
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: To create an actor that uses asyncio, you need to define at least one async
    method. In this case, Ray will create an asyncio event loop for executing the
    actor’s methods. Submitting tasks to these actors is the same from the caller’s
    perspective as submitting tasks to a regular actor. The only difference is that
    when the task is run on the actor, it is posted to an asyncio event loop running
    in a background thread or thread pool instead of running directly on the main
    thread. (Note that using blocking `ray.get` or `ray.wait` calls inside an async
    actor method is not allowed, because they will block the execution of the event
    loop.)
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 4-12](#simple_async_actor) presents an example of a simple async actor.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-12\. [Creating a simple async actor](https://oreil.ly/q3WFs)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the method `computation` is defined as `async`, Ray will create an
    async actor. Note that unlike ordinary `async` methods, which require `await`
    to invoke them, using Ray async actors does not require any special invocation
    semantics. Additionally, Ray allows you to specify the max concurrency for the
    async actor’s execution during the actor’s creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To create a threaded actor, you need to specify `max_concurrency` during actor
    creation ([Example 4-13](#simple-threaded-actor)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-13\. [Creating a simple threaded actor](https://oreil.ly/EjTM4)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because both async and threaded actors are use `max_concurrency`, the type of
    actor created might be a little confusing. The thing to remember is that if `max_concurrency`
    is used, the actor can be either async or threaded. If at least one of the actor’s
    methods is async, the actor is async; otherwise, it is a threaded one.
  prefs: []
  type: TYPE_NORMAL
- en: So, which scaling approach should we use for our implementation? [“Multiprocessing
    vs. Threading vs. AsyncIO in Python”](https://oreil.ly/UF26H) by Lei Mao provides
    a good summary of features for various approaches ([Table 4-1](#table-4-1)).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1\. Comparing scaling approaches for actors
  prefs: []
  type: TYPE_NORMAL
- en: '| Scaling approach | Feature | Usage criteria |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Actor pool | Multiple processes, high CPU utilization | CPU bound |'
  prefs: []
  type: TYPE_TB
- en: '| Async actor | Single process, single thread, cooperative multitasking, tasks
    cooperatively decide on switching | Slow I/O bound |'
  prefs: []
  type: TYPE_TB
- en: '| Threaded actor | Single process, multiple threads, preemptive multitasking,
    OS decides on task switching |'
  prefs: []
  type: TYPE_TB
- en: Fast I/O bound and nonasync libraries you do not control
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Ray Remote Actors Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because Ray remote actors are effectively remote functions, all the Ray remote
    best practices described in the previous chapter are applicable. In addition,
    Ray has some actor-specific best practices.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, Ray offers support for actors’ fault tolerance. Specifically
    for actors, you can specify `max_restarts` to automatically enable restarting
    for Ray actors. When your actor or the node hosting that actor crashes, the actor
    will be automatically reconstructed. However, this doesn’t provide ways for you
    to restore application-level states in your actor. Consider actor persistence
    approaches, described in this chapter to ensure restoration of execution-level
    states as well.
  prefs: []
  type: TYPE_NORMAL
- en: If your applications have global variables that you have to change, do not change
    them in remote functions. Instead, use actors to encapsulate them and access them
    through the actor’s methods. This is because remote functions are running in different
    processes and do not share the same address space. As a result, these changes
    are not reflected across Ray driver and remote functions.
  prefs: []
  type: TYPE_NORMAL
- en: One of the common application use cases is the execution of the same remote
    function many times for different datasets. Using the remote functions directly
    can cause delays because of the creation of new processes for function. This approach
    can also overwhelm the Ray cluster with a large number of processes. A more controlled
    option is to use the actor’s pool. In this case, a pool provides a controlled
    set of workers that are readily available (with no process creation delay) for
    execution. As the pool is maintaining its requests queue, the programming model
    for this option is identical to starting independent remote functions but provides
    a better-controlled execution environment.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use Ray remote actors to implement stateful
    execution in Ray. You learned about the actor model and how to implement Ray remote
    actors. Note that Ray internally heavily relies on using actors—for example, for
    [multinode synchronization](https://oreil.ly/vYdTi), streaming (see [Chapter 6](ch06.html#ch06)),
    and microservices implementation (see [Chapter 7](ch07.html#ch07)). It is also
    widely used for ML implementations; see, for example, use of actors for implementing
    a [parameter server](https://oreil.ly/q33OW).
  prefs: []
  type: TYPE_NORMAL
- en: You also learned how to improve an actor’s reliability by implementing an actor’s
    persistence and saw a simple example of persistence implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you learned about the options that Ray provides for scaling actors,
    their implementation, and trade-offs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss additional Ray design details.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch04.html#idm45354785265712-marker)) Python exceptions are not considered
    system errors and will not trigger restarts. Instead, the exception will be saved
    as the result of the call, and the actor will continue to run as normal.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch04.html#idm45354785245664-marker)) In this implementation, we are using
    filesystem persistence, but you can use the same approach with other types of
    persistence, such as S3 or databases.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch04.html#idm45354778437024-marker)) A *coarse-grained* actor is a single
    actor that may contain multiple pieces of state. In contrast, in a fine-grained
    approach, each piece of state would be represented as a separate actor. This is
    similar to the concept of [coarse-grained locking](https://oreil.ly/WwBrd).
  prefs: []
  type: TYPE_NORMAL
