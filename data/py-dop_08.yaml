- en: Chapter 8\. Pytest for DevOps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章。DevOps 的 Pytest
- en: Continuous integration, continuous delivery, deployments, and any pipeline workflow
    in general with some thought put into it will be filled with validation. This
    *validation* can happen at every step of the way and when achieving important
    objectives.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成、持续交付、部署以及一般的管道工作流，只要稍加思考，就会充满验证。这种*验证*可以在每一步和达到重要目标时发生。
- en: 'For example, if in the middle of a long list of steps to produce a deployment,
    a `curl` command is called to get an all-important file, do you think the build
    should continue if it fails? Probably not! `curl` has a flag that can be used
    to produce a nonzero exit status (`--fail`) if an HTTP error happens. That simple
    flag usage is a form of validation: ensure that the request succeeded, otherwise
    fail the build step. The *key word* is to *ensure* that something succeeded, and
    that is at the core of this chapter: validation and testing strategies that can
    help you build better infrastructure.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在生成部署的一长串步骤中，如果调用 `curl` 命令获取一个非常重要的文件，如果失败了，你认为构建应该继续吗？可能不应该！`curl` 有一个标志可以用来产生非零的退出状态（`--fail`），如果发生
    HTTP 错误。这个简单的标志用法是一种验证：确保请求成功，否则失败构建步骤。*关键词*是*确保*某事成功，这正是本章的核心：可以帮助您构建更好基础设施的验证和测试策略。
- en: Thinking about validation becomes all the more satisfying when Python gets in
    the mix, harnessing testing frameworks like `pytest` to handle the verification
    of systems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 Python 混合其中时，思考验证变得更加令人满意，利用像 `pytest` 这样的测试框架来处理系统的验证。
- en: This chapter reviews some of the basics associated with testing in Python using
    the phenomenal `pytest` framework, then dives into some advanced features of the
    framework, and finally goes into detail about the *TestInfra* project, a plug-in
    to `pytest` that can do system verification.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章回顾了使用出色的 `pytest` 框架进行 Python 测试的一些基础知识，然后深入探讨了框架的一些高级特性，最后详细介绍了 *TestInfra*
    项目，这是 `pytest` 的一个插件，可进行系统验证。
- en: Testing Superpowers with pytest
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 pytest 进行测试超能力
- en: We can’t say enough good things about the `pytest` framework. Created by Holger
    Krekel, it is now maintained by quite a few people that do an incredible job at
    producing a high-quality piece of software that is usually part of our everyday
    work. As a full-featured framework, it is tough to narrow down the scope enough
    to provide a useful introduction without repeating the project’s complete documentation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `pytest` 框架赞不绝口。由 Holger Krekel 创建，现在由一些人维护，他们出色地生产出一个高质量的软件，通常是我们日常工作的一部分。作为一个功能齐全的框架，很难将范围缩小到足以提供有用的介绍，而不重复项目的完整文档。
- en: Tip
  id: totrans-7
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `pytest` project has lots of information, examples, and feature details
    [in its documentation](https://oreil.ly/PSAu2) that are worth reviewing. There
    are always new things to learn as the project continues to provide new releases
    and different ways to improve testing.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest` 项目在其[文档中](https://oreil.ly/PSAu2)有大量信息、示例和特性细节值得查看。随着项目持续提供新版本和改进测试的不同方法，总是有新东西可以学习。'
- en: When Alfredo was first introduced to the framework, he was struggling to write
    tests, and found it cumbersome to adhere to Python’s built-in way of testing with
    `unittest` (this chapter goes through the differences later). It took him a couple
    of minutes to get hooked into `pytest`’s magical reporting. It wasn’t forcing
    him to move away from how he had written his tests, and it worked right out of
    the box with no modifications! This flexibility shows throughout the project,
    and even when things might not be possible today, you can extend its functionality
    via plug-ins or its configuration files.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Alfredo 首次接触这个框架时，他在尝试编写测试时遇到了困难，并发现要遵循 Python 的内置测试方式与 `unittest` 相比有些麻烦（本章稍后将详细讨论这些差异）。他花了几分钟时间就迷上了
    `pytest` 的神奇报告功能。它不强迫他改变他编写测试的方式，而且可以立即使用，无需修改！这种灵活性贯穿整个项目，即使今天可能无法做到的事情，也可以通过插件或配置文件扩展其功能。
- en: By understanding how to write more straightforward test cases, and by taking
    advantage of the command-line tool, reporting engine, plug-in extensibility, and
    framework utilities, you will want to write more tests that will undoubtedly be
    better all around.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解如何编写更简单的测试用例，并利用命令行工具、报告引擎、插件可扩展性和框架实用程序，您将希望编写更多无疑更好的测试。
- en: Getting Started with pytest
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 pytest
- en: In its simplest form, `pytest` is a command-line tool that discovers Python
    tests and executes them. It doesn’t force a user to understand its internals,
    which makes it easy to get started with. This section demonstrates some of the
    most basic features, from writing tests to laying out files (so that they get
    automatically discovered), and finally, looking at the main differences between
    it and Python’s built-in testing framework, `unittest`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，`pytest`是一个命令行工具，用于发现Python测试并执行它们。它不强迫用户理解其内部机制，这使得入门变得容易。本节演示了一些最基本的功能，从编写测试到布置文件（以便它们被自动发现），最后看看它与Python内置测试框架`unittest`的主要区别。
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Most *Integrated Development Environments* (IDEs), such as PyCharm and Visual
    Studio Code, have built-in support for running `pytest`. If using a text editor
    like Vim, there is support via the [`pytest.vim`](https://oreil.ly/HowKu) plug-in.
    Using `pytest` from the editor saves time and makes debugging failures easier,
    but be aware that not every option or plug-in is supported.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数集成开发环境（IDE），如PyCharm和Visual Studio Code，都内置了对运行`pytest`的支持。如果使用像Vim这样的文本编辑器，则可以通过[`pytest.vim`](https://oreil.ly/HowKu)插件进行支持。从编辑器中使用`pytest`可以节省时间，使调试失败变得更容易，但要注意，并非每个选项或插件都受支持。
- en: Testing with pytest
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用pytest进行测试
- en: 'Make sure that you have `pytest` installed and available in the command line:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已安装并可以在命令行中使用`pytest`：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a file called *test_basic.py*; it should look like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为*test_basic.py*的文件；它应该看起来像这样：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If `pytest` runs without any arguments, it should show a pass and a failure:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`pytest`在没有任何参数的情况下运行，它应该显示一个通过和一个失败：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The output is beneficial from the start; it displays how many tests were collected,
    how many passed, and which one failed—including its line number.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 输出从一开始就非常有益；它显示了收集了多少个测试、通过了多少个测试以及失败了哪一个测试（包括其行号）。
- en: Tip
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The default output from `pytest` is handy, but it might be too verbose. You
    can control the amount of output with configuration, reducing it with the `-q`
    flag.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest`的默认输出非常方便，但可能过于冗长。您可以通过配置控制输出量，使用`-q`标志来减少输出量。'
- en: There was no need to create a class to include the tests; functions were discovered
    and ran correctly. A test suite can have a mix of both, and the framework works
    fine in such an environment.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要创建一个包含测试的类；函数被发现并正确运行。测试套件可以同时包含两者的混合，而框架在这种环境下也能正常工作。
- en: Layouts and conventions
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布局和约定
- en: 'When testing in Python, there are a few conventions that `pytest` follows implicitly.
    Most of these conventions are about naming and structure. For example, try renaming
    the *test_basic.py* file to *basic.py* and run `pytest` to see what happens:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中进行测试时，`pytest`隐含遵循一些约定。这些约定大多数是关于命名和结构的。例如，尝试将*test_basic.py*文件重命名为*basic.py*，然后运行`pytest`看看会发生什么：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: No tests ran because of the convention of prefixing test files with *test_*.
    If you rename the file back to *test_basic.py*, it should be automatically discovered
    and tests should run.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于将测试文件前缀为*test_*的约定，没有运行任何测试。如果将文件重命名回*test_basic.py*，它应该能够被自动发现并运行测试。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Layouts and conventions are helpful for automatic test discovery. It is possible
    to configure the framework to use other naming conventions or to directly test
    a file that has a unique name. However, it is useful to follow through with basic
    expectations to avoid confusion when tests don’t run.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 布局和约定对于自动发现测试非常有帮助。可以配置框架以使用其他命名约定或直接测试具有唯一名称的文件。但是，遵循基本预期有助于避免测试不运行时的混淆。
- en: 'These are conventions that will allow the tool to discover tests:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是将工具用于发现测试的约定：
- en: The testing directory needs to be named *tests*.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试目录需要命名为*tests*。
- en: Test files need to be prefixed with *test*; for example, *test_basic.py*, or
    suffixed with *test.py*.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试文件需要以*test*作为前缀；例如，*test_basic.py*，或者以*test.py*作为后缀。
- en: Test functions need to be prefixed with `test_`; for example, `def test``simple():`.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试函数需要以`test_`作为前缀；例如，`def test_simple():`。
- en: Test classes need to be prefixed with `Test`; for example, `class TestSimple`.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试类需要以`Test`作为前缀；例如，`class TestSimple`。
- en: Test methods follow the same conventions as functions, prefixed with `test_`;
    for example, `def test_method(self):`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试方法遵循与函数相同的约定，以`test_`作为前缀；例如，`def test_method(self):`。
- en: Because prefixing with `test_` is a requirement for automatic discovery and
    execution of tests, it allows introducing helper functions and other nontest code
    with different names, so that they get excluded automatically.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在自动发现和执行测试时需要前缀`test_`，所以可以引入带有不同名称的帮助函数和其他非测试代码，以便自动排除它们。
- en: Differences with unittest
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与unittest的差异
- en: Python already comes with a set of utilities and helpers for testing, and they
    are part of the `unittest` module. It is useful to understand how `pytest` is
    different and why it is highly recommended.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Python已经提供了一套用于测试的实用工具和辅助程序，它们是`unittest`模块的一部分。了解`pytest`与其不同之处以及为什么强烈推荐使用它是很有用的。
- en: The `unittest` module forces the use of classes and class inheritance. For an
    experienced developer who understands object-oriented programming and class inheritance,
    this shouldn’t be a problem, but for beginners, *it is an obstacle*. Using classes
    and inheritance shouldn’t be a requisite for writing basic tests!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest`模块强制使用类和类继承。对于了解面向对象编程和类继承的经验丰富的开发人员，这不应该是一个问题，但对于初学者来说，*这是一个障碍*。写基本测试不应该要求使用类和继承！'
- en: 'Part of forcing users to inherit from `unittest.TestCase` is that you are required
    to understand (and remember) most of the assertion methods that are used to verify
    results. With `pytest`, there is a single assertion helper that can do it all:
    `assert`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 强制用户从`unittest.TestCase`继承的部分是，您必须理解（并记住）用于验证结果的大多数断言方法。使用`pytest`时，有一个可以完成所有工作的单一断言助手：`assert`。
- en: 'These are a few of the assert methods that can be used when writing tests with
    `unittest`. Some of them are easy to grasp, while others are very confusing:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在使用`unittest`编写测试时可以使用的几个断言方法。其中一些很容易理解，而另一些则非常令人困惑：
- en: '`self.assertEqual(a, b)`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertEqual(a, b)`'
- en: '`self.assertNotEqual(a, b)`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertNotEqual(a, b)`'
- en: '`self.assertTrue(x)`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertTrue(x)`'
- en: '`self.assertFalse(x)`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertFalse(x)`'
- en: '`self.assertIs(a, b)`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertIs(a, b)`'
- en: '`self.assertIsNot(a, b)`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertIsNot(a, b)`'
- en: '`self.assertIsNone(x)`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertIsNone(x)`'
- en: '`self.assertIsNotNone(x)`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertIsNotNone(x)`'
- en: '`self.assertIn(a, b)`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertIn(a, b)`'
- en: '`self.assertNotIn(a, b)`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertNotIn(a, b)`'
- en: '`self.assertIsInstance(a, b)`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertIsInstance(a, b)`'
- en: '`self.assertNotIsInstance(a, b)`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertNotIsInstance(a, b)`'
- en: '`self.assertRaises(exc, fun, *args, **kwds)`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertRaises(exc, fun, *args, **kwds)`'
- en: '`self.assertRaisesRegex(exc, r, fun, *args, **kwds)`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertRaisesRegex(exc, r, fun, *args, **kwds)`'
- en: '`self.assertWarns(warn, fun, *args, **kwds)`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertWarns(warn, fun, *args, **kwds)`'
- en: '`self.assertWarnsRegex(warn, r, fun, *args, **kwds)`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertWarnsRegex(warn, r, fun, *args, **kwds)`'
- en: '`self.assertLogs(logger, level)`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertLogs(logger, level)`'
- en: '`self.assertMultiLineEqual(a, b)`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertMultiLineEqual(a, b)`'
- en: '`self.assertSequenceEqual(a, b)`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertSequenceEqual(a, b)`'
- en: '`self.assertListEqual(a, b)`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertListEqual(a, b)`'
- en: '`self.assertTupleEqual(a, b)`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertTupleEqual(a, b)`'
- en: '`self.assertSetEqual(a, b)`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertSetEqual(a, b)`'
- en: '`self.assertDictEqual(a, b)`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertDictEqual(a, b)`'
- en: '`self.assertAlmostEqual(a, b)`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertAlmostEqual(a, b)`'
- en: '`self.assertNotAlmostEqual(a, b)`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertNotAlmostEqual(a, b)`'
- en: '`self.assertGreater(a, b)`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertGreater(a, b)`'
- en: '`self.assertGreaterEqual(a, b)`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertGreaterEqual(a, b)`'
- en: '`self.assertLess(a, b)`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertLess(a, b)`'
- en: '`self.assertLessEqual(a, b)`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertLessEqual(a, b)`'
- en: '`self.assertRegex(s, r)`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertRegex(s, r)`'
- en: '`self.assertNotRegex(s, r)`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertNotRegex(s, r)`'
- en: '`self.assertCountEqual(a, b)`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.assertCountEqual(a, b)`'
- en: '`pytest` allows you to use `assert` exclusively and does not force you to use
    any of the above. Moreover, it *does allow* you to write tests using `unittest`,
    and it even executes them. We strongly advise against doing that and suggest you
    concentrate on just using plain asserts.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest`允许您专门使用`assert`，并且不强制您使用上述任何一种方法。此外，它*确实允许*您使用`unittest`编写测试，并且甚至执行这些测试。我们强烈建议不要这样做，并建议您专注于只使用普通的assert语句。'
- en: Not only is it easier to use plain asserts, but `pytest` also provides a rich
    comparison engine on failures (more on this in the next section).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅使用普通的assert更容易，而且`pytest`在失败时还提供了丰富的比较引擎（下一节将详细介绍）。
- en: pytest Features
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pytest功能
- en: Aside from making it easier to write tests and execute them, the framework provides
    lots of extensible options, such as hooks. Hooks allow you to interact with the
    framework internals at different points in the runtime. If you want to alter the
    collection of tests, for example, a hook for the collection engine can be added.
    Another useful example is if you want to implement a nicer report when a test
    fails.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使编写测试和执行测试更容易外，该框架还提供了许多可扩展的选项，例如钩子。钩子允许您在运行时的不同点与框架内部进行交互。例如，如果要修改测试的收集，可以添加一个收集引擎的钩子。另一个有用的示例是，如果要在测试失败时实现更好的报告。
- en: 'While developing an HTTP API, we found that sometimes the failures in the tests
    that used HTTP requests against the application weren’t beneficial: an assertion
    failure would be reported because the expected response (an HTTP 200) was an HTTP
    500 error. We wanted to know more about the request: to what URL endpoint? If
    it was a POST request, did it have data? What did it look like? These are things
    that were already available in the HTTP response object, so we wrote a hook to
    poke inside this object and include all these items as part of the failure report.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发HTTP API时，我们发现有时测试中使用HTTP请求针对应用程序的失败并不有益：断言失败会被报告，因为预期的响应（HTTP 200）是HTTP
    500错误。我们想要了解更多关于请求的信息：到哪个URL端点？如果是POST请求，是否有数据？它是什么样子的？这些信息已经包含在HTTP响应对象中，因此我们编写了一个钩子来查看这个对象，并将所有这些项目包含在失败报告中。
- en: Hooks are an advanced feature of `pytest` that you might not need at all, but
    it is useful to understand that the framework can be flexible enough to accommodate
    different requirements. The next sections cover how to extend the framework, why
    using `assert` is so valuable, how to parametrize tests to reduce repetition,
    how to make helpers with `fixtures`, and how to use the built-in ones.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子是`pytest`的高级功能，您可能根本不需要，但了解框架可以灵活适应不同需求是有用的。接下来的章节涵盖如何扩展框架，为什么使用`assert`如此宝贵，如何参数化测试以减少重复，如何使用`fixtures`制作帮助工具，以及如何使用内置工具。
- en: conftest.py
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: conftest.py
- en: 'Most software lets you extend functionality via plug-ins (web browsers call
    them *extensions*, for example); similarly, `pytest` has a rich API for developing
    plug-ins. The complete API is not covered here, but its simpler approach is: the
    *conftest.py* file. In this file, the tool can be extended *just like a plug-in
    can*. There is no need to fully understand how to create a separate plug-in, package
    it, and install it. If a *conftest.py* file is present, the framework will load
    it and consume any specific directives in it. It all happens automatically!'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数软件都允许您通过插件扩展功能（例如，Web浏览器称其为*扩展*）；同样地，`pytest`有一个丰富的API用于开发插件。这里没有涵盖完整的API，但其更简单的方法是：*conftest.py*文件。在这个文件中，工具可以像插件一样扩展。无需完全理解如何创建单独的插件、打包它并安装它。如果存在*conftest.py*文件，框架将加载它并消费其中的任何特定指令。这一切都是自动进行的！
- en: Usually, you will find that a *conftest.py* file is used to hold hooks, fixtures,
    and helpers for those fixtures. Those *fixtures* can then be used within tests
    if declared as arguments (that process is described later in the fixture section).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会发现*conftest.py*文件用于保存钩子、fixtures和这些fixtures的helpers。如果声明为参数，这些*fixtures*可以在测试中使用（该过程稍后在fixture部分描述）。
- en: It makes sense to add fixtures and helpers to this file when more than one test
    module will use it. If there is only a single test file, or if only one file is
    going to make use of a fixture or hook, there is no need to create or use a *conftest.py*
    file. Fixtures and helpers can be defined within the same file as the test and
    behave the same.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个测试模块将使用它时，将fixtures和helpers添加到此文件是有意义的。如果只有一个单独的测试文件，或者只有一个文件将使用fixture或hook，那么无需创建或使用*conftest.py*文件。Fixtures和helpers可以在与测试相同的文件中定义并表现相同的行为。
- en: The only condition for loading a *conftest.py* file is to be present in the
    *tests* directory and match the name correctly. Also, although this name is configurable,
    we advise against changing it and encourage you to follow the default naming conventions
    to avoid potential issues.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 加载*conftest.py*文件的唯一条件是存在于*tests*目录中并正确匹配名称。此外，尽管此名称是可配置的，但我们建议不要更改它，并鼓励您遵循默认命名约定以避免潜在问题。
- en: The Amazing assert
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 令人惊叹的**assert**
- en: 'When we have to describe how great the `pytest` tooling is, we start by describing
    the important uses of the `assert` statement. Behind the scenes, the framework
    is inspecting objects and providing a rich comparison engine to better describe
    errors. This is usually met with resistance because a bare `assert` in Python
    is terrible at describing errors. Compare two long strings as an example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不得不描述`pytest`工具的强大之处时，我们首先描述`assert`语句的重要用途。幕后，框架检查对象并提供丰富的比较引擎以更好地描述错误。通常会遇到抵制，因为Python中的裸`assert`很糟糕地描述错误。以比较两个长字符串为例：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Where is the difference? It is hard to tell without spending some time looking
    at those two long lines closely. This will cause people to recommend against it.
    A small test shows how `pytest` augments when reporting the failure:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 差异在哪里？如果不花时间仔细查看这两行长字符串，很难说清楚。这会导致人们建议不要这样做。一个小测试展示了`pytest`在报告失败时如何增强：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Can you tell where the error is? This is *tremendously easier*. Not only does
    it tell you it fails, but it points to exactly *where* the failure is. The example
    is a simple assert with a long string, but the framework handles other data structures
    like lists and dictionaries without a problem. Have you ever compared very long
    lists in tests? It is impossible to easily tell what items are different. Here
    is a small snippet with long lists:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你能说出错误在哪里吗？这*极大地简化了*。它不仅告诉你失败了，还指出*失败发生的确切位置*。例如，一个简单的断言与一个长字符串，但是这个框架可以处理其他数据结构，如列表和字典，毫无问题。你有没有在测试中比较过非常长的列表？很难轻松地分辨出哪些项目不同。这里是一个有长列表的小片段：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After informing the user that the test failed, it points exactly to the index
    number (index four or fifth item), and finally, it says that one list has one
    extra item. Without this level of introspection, debugging failures would take
    a very long time. The bonus in reporting is that, by default, it omits very long
    items when making comparisons, so that only the relevant portion shows in the
    output. After all, what you want is to know not only that the lists (or any other
    data structure) are different but *exactly where they* are different.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在通知用户测试失败后，它精确指向索引号（第四个或第五个项目），最后说一个列表有一个额外的项目。没有这种深入的反思，调试失败将需要很长时间。报告中的额外奖励是，默认情况下，在进行比较时省略非常长的项目，因此输出中只显示相关部分。毕竟，你想知道的不仅是列表（或任何其他数据结构）不同之处，而且*确切地在哪里*不同。
- en: Parametrization
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数化
- en: 'Parametrization is one of the features that can take a while to understand
    because it doesn’t exist in the `unittest` module and is a feature unique to the
    pytest framework. It can be clear once you find yourself writing very similar
    tests that had minor changes in the inputs but are testing the same thing. Take,
    for example, this class that is testing a function that returns `True` if a string
    is implying a truthful value. The `string_to_bool` is the function under test:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化是一个需要一些时间来理解的特性，因为它在`unittest`模块中不存在，是pytest框架独有的特性。一旦你发现自己编写非常相似的测试，只是输入稍有不同，但测试的是同一个东西时，它就会变得很清晰。举个例子，这个类正在测试一个函数，如果一个字符串暗示一个真实的值，则返回`True`。`string_to_bool`是测试的函数：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'See how all these tests are evaluating the same result from similar inputs?
    This is where parametrization shines because it can group all these values and
    pass them to the test; it can effectively reduce them to a single test:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 看看所有这些测试如何从相似的输入评估相同的结果？这就是参数化发挥作用的地方，因为它可以将所有这些值分组并传递给测试；它可以有效地将它们减少到单个测试中：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There are a couple of things happening here. First `pytest` is imported (the
    framework) to use the `pytest.mark.parametrize` module, then `true_values` is
    defined as a (list) variable of all the values to use that should evaluate the
    same, and finally, it replaces all the test methods to a single one. The test
    method uses the `parametrize` decorator, which defines two arguments. The first
    is a string, `*value*`, and the second is the name of the list defined previously.
    This can look a bit odd, but it is telling the framework that `*value*` is the
    name to use for the argument in the test method. That is where the `value` argument
    comes from!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了几件事情。首先导入了`pytest`（框架）以使用`pytest.mark.parametrize`模块，然后将`true_values`定义为应评估相同的所有值的（列表）变量，并最后将所有测试方法替换为单一方法。测试方法使用`parametrize`装饰器，定义了两个参数。第一个是字符串`*value*`，第二个是先前定义的列表的名称。这可能看起来有点奇怪，但它告诉框架`*value*`是在测试方法中使用的参数名称。这就是`value`参数的来源！
- en: 'If the verbosity is increased when running, the output will show exactly what
    value was passed in. It almost looks like the single test got cloned into every
    single iteration passed in:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在运行时增加了详细输出，输出将显示确切传入的值。它几乎看起来像单个测试被复制到每次迭代中传入的值中：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The output includes the values used in each iteration of the *single test* in
    brackets. It is reducing the very verbose test class into a single test method,
    thanks to `parametrize`. The next time you find yourself writing tests that seem
    very similar and that assert the same outcome with different inputs, you will
    know that you can make it simpler with the `parametrize` decorator.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 输出包括 *单个测试* 中每次迭代中使用的值，用方括号括起来。它将非常冗长的测试类简化为单个测试方法，多亏了 `parametrize`。下次您发现自己编写非常相似的测试并且使用不同的输入来断言相同的结果时，您将知道可以通过
    `parametrize` 装饰器简化它。
- en: Fixtures
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*Fixture*'
- en: We think of [`pytest` fixtures](https://oreil.ly/gPoM5) like little helpers
    that can get injected into a test. Regardless of whether you are writing a single
    test function or a bunch of test methods, fixtures can be used in the same way.
    If they aren’t going to be shared among other test files, it is fine to define
    them in the same test file; otherwise they can go into the *conftest.py* file.
    Fixtures, just like helper functions, can be almost anything you need for a test,
    from simple data structures that get pre-created to more complex ones like setting
    a database for a web application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们把 [`pytest` *Fixture*](https://oreil.ly/gPoM5) 想象成可以注入到测试中的小助手。无论您是编写单个测试函数还是一堆测试方法，*Fixture*
    都可以以相同的方式使用。如果它们不会被其他测试文件共享，那么可以在同一个测试文件中定义它们；否则它们可以放在 *conftest.py* 文件中。*Fixture*
    就像帮助函数一样，可以是任何您需要的测试用例，从预创建的简单数据结构到为 Web 应用程序设置数据库等更复杂的功能。
- en: These helpers can also have a defined *scope*. They can have specific code that
    cleans up for every test method, class, and module, or even allows setting them
    up once for the whole test session. By defining them in a test method (or test
    function), you are effectively getting the fixture injected at runtime. If this
    sounds a bit confusing, it will become clear through examples in the next few
    sections.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些助手还可以有定义的 *scope*。它们可以有特定的代码，为每个测试方法、类和模块进行清理，或者甚至允许为整个测试会话设置它们一次。通过在测试方法（或测试函数）中定义它们，您实际上是在运行时获取
    *Fixture* 的注入。如果这听起来有点混乱，通过下几节中的示例将变得清晰起来。
- en: Getting Started
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**入门**'
- en: Fixtures are so easy to define and use that they are often abused. We know we’ve
    created a few that could have been simple helper methods! As we’ve mentioned already,
    there are many different use cases for fixtures—from simple data structures to
    more complex ones, such as setting up whole databases for a single test.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 用来定义和使用的 *Fixture* 如此简单，以至于它们经常被滥用。我们知道我们创建了一些本来可以简化为简单帮助方法的 *Fixture*！正如我们已经提到的，*Fixture*
    有许多不同的用例——从简单的数据结构到更复杂的用例，例如为单个测试设置整个数据库。
- en: 'Recently, Alfredo had to test a small application that parses the contents
    of a particular file called a *keyring file*. It has some structure similar to
    an INI file, with some values that have to be unique and follow a specific format.
    The file structure can be very tedious to recreate on every test, so a fixture
    was created to help. This is how the keyring file looks:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，Alfredo 不得不测试一个解析特定文件内容的小应用程序，该文件称为 *keyring file*。它具有类似 INI 文件的结构，某些值必须是唯一的，并且遵循特定的格式。在每次测试中重新创建文件结构可能非常繁琐，因此创建了一个
    *Fixture* 来帮助。这就是 *keyring file* 的外观：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The fixture is a function that returns the contents of the keyring file. Let’s
    create a new file called test_keyring.py with the contents of the fixture, and
    a small test function that verifies the default key:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*Fixture* 是一个返回 *keyring file* 内容的函数。让我们创建一个名为 test_keyring.py 的新文件，其中包含 *Fixture*
    的内容，以及验证默认键的小测试函数：'
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The fixture is using a nested function that does the heavy lifting, allows using
    a *default* key value, and returns the nested function in case the caller wants
    to have a randomized key. Inside the test, it receives the fixture by declaring
    it part of the argument of the test function (`mon_keyring` in this case), and
    is calling the fixture with `default=True` so that the default key is used, and
    then verifying it is generated as expected.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*Fixture* 使用一个执行繁重工作的嵌套函数，允许使用一个 *default* 键值，并在调用者希望有随机键时返回嵌套函数。在测试中，它通过声明为测试函数的参数的一部分接收
    *Fixture*（在本例中为 `mon_keyring`），并使用 `default=True` 调用 *Fixture*，以便使用默认键，然后验证它是否按预期生成。'
- en: Note
  id: totrans-114
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '**注意**'
- en: In a real-world scenario, the generated contents would be passed to the parser,
    ensuring expected behavior after parsing and that no errors happen.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在真实场景中，生成的内容将被传递给解析器，确保解析后的行为符合预期，并且没有错误发生。
- en: The production code that used this fixture eventually grew to do other kinds
    of testing, and at some point, the test wanted to verify that the parser could
    handle files in different conditions. The fixture was returning a string, so it
    needed extending. Existing tests already made use of the `mon_keyring` fixture,
    so to extend the functionality without altering the current fixture, a new one
    was created that used a feature from the framework. Fixtures can *request* other
    fixtures! You define the required fixture as an argument (like a test function
    or test method would), so the framework injects it when it gets executed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此固件的生产代码最终发展到执行其他类型的测试，并且在某些时候，测试希望验证解析器能够处理不同条件下的文件。该固件返回一个字符串，因此需要扩展它。现有测试已经使用了
    `mon_keyring` 固件，因此为了在不更改当前固件的情况下扩展功能，创建了一个新的固件，该固件使用了框架的一个特性。固件可以 *请求* 其他固件！您将所需的固件定义为参数（就像测试函数或测试方法一样），因此在执行时框架会注入它。
- en: 'This is how the new fixture that creates (and returns) the file looks:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建（并返回）文件的新固件的方式：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Going line by line, the `pytest.fixture` decorator tells the framework that
    this function is a fixture, then the fixture is defined, asking for *two fixtures*
    as arguments: `mon_keyring` and `tmpdir`. The first is the one created previously
    in the *test_keyring.py* file earlier, and the second one is a built-in fixture
    from the framework (more on built-in fixtures in the next section). The `tmpdir`
    fixture allows you to use a temporary directory that gets removed after the test
    completes, then the *keyring* file is created, and the text generated by the `mon_keyring`
    fixture is written, passing the `default` argument. Finally, it returns the absolute
    path of the new file created so that the test can use it.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 按行解释，`pytest.fixture`装饰器告诉框架这个函数是一个固件，然后定义了固件，请求 *两个固件* 作为参数：`mon_keyring` 和
    `tmpdir`。第一个是前面在 *test_keyring.py* 文件中创建的，第二个是框架提供的内置固件（关于内置固件的更多内容将在下一节讨论）。`tmpdir`
    固件允许您使用一个临时目录，在测试完成后将其删除，然后创建 *keyring* 文件，并写入由 `mon_keyring` 固件生成的文本，传递 `default`
    参数。最后，它返回新创建文件的绝对路径，以便测试可以使用它。
- en: 'This is how the test function would use it:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是测试函数如何使用它的方式：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You should now have a good idea of what fixtures are, where can you define them,
    and how to consume them in tests. The next section goes through a few of the most
    useful built-in fixtures that are part of the framework.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该对固件是什么，您可以在哪里定义它们以及如何在测试中使用它们有了一个很好的理解。下一部分将介绍一些最有用的内置固件，这些固件是框架的一部分。
- en: Built-in Fixtures
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置固件
- en: 'The previous section briefly touched on one of the many built-in fixtures that
    `pytest` has to offer: the `tmpdir` fixture. The framework provides a few more
    fixtures. To verify the full list of available fixtures, run the following command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节简要介绍了 `pytest` 提供的众多内置固件之一：`tmpdir` 固件。框架提供了更多固件。要验证可用固件的完整列表，请运行以下命令：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'There are two fixtures that we use a lot: `monkeypatch` and `capsys`, and they
    are in the list produced when the above command is run. This is the brief description
    you will see in the terminal:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常使用的两个固件是 `monkeypatch` 和 `capsys`，当运行上述命令时，它们都在生成的列表中。这是您将在终端看到的简要描述：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`capsys` captures any `stdout` or `stderr` produced in a test. Have you ever
    tried to verify some command output or logging in a unit test? It is challenging
    to get right and is something that requires a separate plug-in or library to *patch*
    Python’s internals and then inspect its contents.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`capsys` 捕获测试中产生的任何 `stdout` 或 `stderr`。您是否尝试过验证某些命令输出或日志记录在单元测试中的输出？这很难做到，并且需要一个单独的插件或库来
    *patch* Python 的内部，然后检查其内容。'
- en: 'These are two test functions that verify the output produced on `stderr` and
    `stdout`, respectively:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是验证分别在 `stderr` 和 `stdout` 上产生的输出的两个测试函数：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `capsys` fixture handles all the patching, setup, and helpers to retrieve
    the `stderr` and `stdout` produced in the test. The content is reset for every
    test, which ensures that the variables populate with the correct output.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`capsys` 固件处理所有补丁，设置和助手，以检索测试中生成的 `stderr` 和 `stdout`。每次测试都会重置内容，这确保变量填充了正确的输出。'
- en: '`monkeypatch` is probably the fixture that we use the most. When testing, there
    are situations where the code under test is out of our control, and *patching*
    needs to happen to override a module or function to have a specific behavior.
    There are quite a few *patching* and *mocking* libraries (*mocks* are helpers
    to set behavior on patched objects) available for Python, but `monkeypatch` is
    good enough that you might not need to install a separate library to help out.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`monkeypatch`可能是我们最常使用的装置。在测试时，有些情况下测试的代码不在我们的控制之下，*修补*就需要发生来覆盖模块或函数以具有特定的行为。Python中有相当多的*修补*和*模拟*库（*模拟*是帮助设置修补对象行为的助手），但`monkeypatch`足够好，你可能不需要安装额外的库来帮忙。'
- en: 'The following function runs a system command to capture details from a device,
    then parses the output, and returns a property (the `ID_PART_ENTRY_TYPE` as reported
    by `blkid`):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数运行系统命令以捕获设备的详细信息，然后解析输出，并返回一个属性（由`blkid`报告的`ID_PART_ENTRY_TYPE`）：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To test it, set the desired behavior on the `check_output` attribute of the
    `subprocess` module. This is how the test function looks using the `monkeypatch`
    fixture:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行测试，设置所需的行为在`subprocess`模块的`check_output`属性上。这是使用`monkeypatch`装置的测试函数的外观：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `setattr` call *sets the attribute* on the patched callable (`check_output`
    in this case). It *patches* it with a lambda function that returns the one interesting
    line. Since the `subprocess.check_output` function is not under our direct control,
    and the `get_part_entry_type` function doesn’t allow any other way to inject the
    values, patching is the only way.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`setattr`调用*设置*修补过的可调用对象（在本例中为`check_output`）。*补丁*它的是一个返回感兴趣行的lambda函数。由于`subprocess.check_output`函数不在我们的直接控制之下，并且`get_part_entry_type`函数不允许任何其他方式来注入值，修补是唯一的方法。'
- en: We tend to favor using other techniques like injecting values (known as *dependency
    injection*) before attempting to patch, but sometimes there is no other way. Providing
    a library that can patch and handle all the cleanup on testing is one more reason
    `pytest` is a joy to work with.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们倾向于使用其他技术，如在尝试修补之前注入值（称为*依赖注入*），但有时没有其他方法。提供一个可以修补和处理所有测试清理工作的库，这是`pytest`是一种愉悦的工作方式的更多原因之一。
- en: Infrastructure Testing
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施测试
- en: This section explains how to do infrastructure testing and validation with the
    [Testinfra project](https://oreil.ly/e7Afx). It is a `pytest` plug-in for infrastructure
    that relies heavily on fixtures and allows you to write Python tests as if testing
    code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了如何使用[Testinfra项目](https://oreil.ly/e7Afx)进行基础设施测试和验证。这是一个依赖于装置的`pytest`插件，允许您编写Python测试，就像测试代码一样。
- en: 'The previous sections went into some detail on `pytest` usage and examples,
    and this chapter started with the idea of verification at a system level. The
    way we explain infrastructure testing is by asking a question: *How can you tell
    that the deployment was successful?* Most of the time, this means some manual
    checks, such as loading a website or looking at processes, which is insufficient;
    it is error-prone and can get tedious if the system is significant.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 前几节详细讨论了`pytest`的使用和示例，本章以系统级验证的概念开始。我们解释基础设施测试的方式是通过问一个问题：*如何确定部署成功？*大多数情况下，这意味着一些手动检查，如加载网站或查看进程，这是不够的；这是错误的，并且如果系统很重要的话可能会变得乏味。
- en: 'Although you can initially get introduced to `pytest` as a tool to write and
    run Python unit tests, it can be advantageous to repurpose it for infrastructure
    testing. A few years ago Alfredo was tasked to produce an installer that exposed
    its features over an HTTP API. This installer was to create a [Ceph cluster](https://ceph.com),
    involving many machines. During the QA portion of launching the API, it was common
    to get reports where the cluster wouldn’t work as expected, so he would get the
    credentials to log in to these machines and inspect them. There is a multiplier
    effect once you have to debug a distributed system comprising several machines:
    multiple configuration files, different hard drives, network setups, anything
    and everything can be different even if they appear to be similar.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然最初可以将`pytest`视为编写和运行 Python 单元测试的工具，但将其重新用于基础设施测试可能是有利的。几年前，阿尔弗雷多被委托制作一个安装程序，通过
    HTTP API 公开其功能。该安装程序旨在创建一个 [Ceph 集群](https://ceph.com)，涉及多台机器。在启动 API 的质量保证阶段，常常会收到集群未按预期工作的报告，因此他会获取凭据以登录这些机器并进行检查。一旦必须调试包含多台机器的分布式系统时，就会产生乘数效应：多个配置文件、不同的硬盘、网络设置，任何和所有的东西都可能不同，即使它们看起来很相似。
- en: Every time Alfredo had to debug these systems, he had an ever-growing list of
    things to check. Is the configuration the same on all servers? Are the permissions
    as expected? Does a specific user exist? He would eventually forget something
    and spend time trying to figure out what he was missing. It was an unsustainable
    process. *What if I could write simple test cases against the cluster?* Alfredo
    wrote a few simple tests to verify the items on the list to execute them against
    the machines making up the cluster. Before he knew it, he had a good set of tests
    that took a few seconds to run that would identify all kinds of issues.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 每当阿尔弗雷多需要调试这些系统时，他都会有一个日益增长的检查清单。服务器上的配置是否相同？权限是否符合预期？特定用户是否存在？最终他会忘记某些事情，并花时间试图弄清楚自己漏掉了什么。这是一个不可持续的过程。*如果我能写一些简单的测试用例来针对集群？*
    阿尔弗雷多编写了几个简单的测试来验证清单上的项目，并执行它们以检查构成集群的机器。在他意识到之前，他已经拥有了一套很好的测试，只需几秒钟即可运行，可以识别各种问题。
- en: 'That was an incredible eye-opener for improving the delivery process. He could
    even execute these (functional) tests while developing the installer and catch
    things that weren’t quite right. If the QA team caught any issues, he could run
    the same tests against their setup. Sometimes tests caught environmental issues:
    a drive was *dirty* and caused the deployment to fail; a configuration file from
    a different cluster was left behind and caused issues. Automation, granular tests,
    and the ability to run them often made the work better and alleviated the amount
    of work the QA team had to put up with.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于改进交付流程是一个令人难以置信的启示。他甚至可以在开发安装程序时执行这些（功能）测试，并发现不正确的地方。如果 QA 团队发现任何问题，他可以针对其设置运行相同的测试。有时测试会捕捉到环境问题：一个硬盘*脏了*并导致部署失败；来自不同集群的配置文件遗留下来并引发问题。自动化、精细化测试以及频繁运行它们使工作变得更好，并减轻了
    QA 团队需要处理的工作量。
- en: 'The TestInfra project has all kinds of fixtures to test a system efficiently,
    and it includes a complete set of backends to connect to servers; regardless of
    their deployment type: Ansible, Docker, SSH, and Kubernetes are some of the supported
    connections. By supporting many different connection backends, you can execute
    the same set of tests regardless of infrastructure changes.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: TestInfra 项目具有各种夹具，可高效测试系统，并包含一整套用于连接服务器的后端，无论其部署类型如何：Ansible、Docker、SSH 和 Kubernetes
    是一些支持的连接方式。通过支持多种不同的连接后端，可以执行相同的一组测试，而不受基础设施更改的影响。
- en: The next sections go through different backends and get into examples of a production
    project.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节将介绍不同的后端，并展示一个生产项目的示例。
- en: What Is System Validation?
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是系统验证？
- en: 'System validation can happen at different levels (with monitoring and alert
    systems) and at different stages in the life cycle of an application, such as
    during pre-deployment, at runtime, or during deployment. An application that Alfredo
    recently put into production needed to handle client connections gracefully without
    any disruption, even when restarted. To sustain traffic, the application is load
    balanced: when the system is under heavy loads, new connections get sent to other
    servers with a lighter load.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 系统验证可以在不同级别（使用监控和警报系统）和应用程序生命周期的不同阶段进行，例如在预部署阶段、运行时或部署期间。最近由Alfredo投入生产的应用程序需要在重新启动时优雅地处理客户端连接，即使有任何中断也不受影响。为了维持流量，应用程序进行了负载均衡：在系统负载较重时，新的连接会被发送到负载较轻的其他服务器。
- en: When a new release gets deployed, the application *has to be restarted*. Restarting
    means that clients experience an odd behavior at best, or a very broken experience
    at the worst. To avoid this, the restart process waits for all client connections
    to terminate, the system refuses new connections, allowing it to finish work from
    existing clients, and the rest of the system picks up the work. When no connections
    are active, the deployment continues and stops services to get the newer code
    in.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当部署新版本时，应用程序*必须重新启动*。重新启动意味着客户端在最佳情况下会遇到奇怪的行为，最坏的情况下会导致非常糟糕的体验。为了避免这种情况，重新启动过程等待所有客户端连接终止，系统拒绝新的连接，允许其完成来自现有客户端的工作，其余系统继续工作。当没有活动连接时，部署继续并停止服务以获取更新的代码。
- en: 'There is validation at every step of the way: before the deployment to tell
    the balancer to stop sending new clients and later, verifying that no new clients
    are active. If that workflow converts to a test, the title could be something
    like: `make sure that no clients are currently running`. Once the new code is
    in, another validation step checks whether the balancer has acknowledged that
    the server is ready to produce work once again. Another test here could be: `balancer
    has server as active`. Finally, it makes sure that the server is receiving new
    client connections—yet another test to write!'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 沿途的每一步都进行了验证：在部署之前通知负载均衡器停止发送新的客户端，并且后来验证没有新的客户端处于活动状态。如果该工作流程转换为测试，标题可能类似于：`确保当前没有客户端在运行`。一旦新代码就位，另一个验证步骤检查负载均衡器是否已确认服务器再次准备好生成工作。这里的另一个测试可能是：`负载均衡器已将服务器标记为活动`。最后，确保服务器正在接收新的客户端连接——又一个要编写的测试！
- en: Throughout these steps, verification is in place, and tests can be written to
    verify this type of workflow.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些步骤中，验证已经到位，可以编写测试来验证这种类型的工作流程。
- en: System validation can also be tied to monitoring the overall health of a server
    (or servers in a clustered environment) or be part of the continuous integration
    while developing the application and testing functionally. The basics of validation
    apply to these situations and anything else that might benefit from status verification.
    It shouldn’t be used exclusively for testing, although that is a good start!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 系统验证也可以与监控服务器的整体健康状况（或集群环境中的多个服务器）相关联，或者作为开发应用程序和功能测试的持续集成的一部分。验证的基础知识适用于这些情况以及可能从状态验证中受益的任何其他情况。它不应仅用于测试，尽管这是一个很好的开始！
- en: Introduction to Testinfra
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Testinfra简介
- en: Writing unit tests against infrastructure is a powerful concept, and having
    used Testinfra for over a year, we can say that it has improved the quality of
    production applications we’ve had to deliver. The following sections go into specifics,
    such as connecting to different nodes and executing validation tests, and explore
    what type of fixtures are available.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 针对基础设施编写单元测试是一个强大的概念，使用Testinfra一年多以来，我们可以说它提高了我们必须交付的生产应用程序的质量。以下部分详细介绍了如何连接到不同节点并执行验证测试，并探讨了可用的固定装置类型。
- en: 'To create a new virtual environment, install `pytest`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新的虚拟环境，请安装`pytest`：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Install `testinfra`, ensuring that version `2.1.0` is used:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`testinfra`，确保使用版本`2.1.0`：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-159
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`pytest` fixtures provide all the test functionality offered by the Testinfra
    project. To take advantage of this section, you will need to know how they work.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest`固定装置提供了Testinfra项目提供的所有测试功能。要利用本节，您需要了解它们是如何工作的。'
- en: Connecting to Remote Nodes
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到远程节点
- en: Because different backend connection types exist, when the connection is not
    specified directly, Testinfra defaults to certain ones. It is better to be explicit
    about the connection type and define it in the command line.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因为存在不同的后端连接类型，当未直接指定连接时，Testinfra 默认到某些类型。最好明确指定连接类型并在命令行中定义它。
- en: 'These are all the connection types that Testinfra supports:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 Testinfra 支持的所有连接类型：
- en: local
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地
- en: Paramiko (an SSH implementation in Python)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Paramiko（Python 中的 SSH 实现）
- en: Docker
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: SSH
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSH
- en: Salt
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Salt
- en: Ansible
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible
- en: Kubernetes (via kubectl)
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes（通过 kubectl）
- en: WinRM
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WinRM
- en: LXC
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LXC
- en: 'A `testinfra` section appears in the help menu with some context on the flags
    that are provided. This is a neat feature from `pytest` and its integration with
    Testinfra. The help for both projects comes from the same command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在帮助菜单中会出现一个 `testinfra` 部分，提供一些关于提供的标志的上下文。这是来自 `pytest` 与其与 Testinfra 集成的一个不错的特性。这两个项目的帮助来自相同的命令：
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There are two servers up and running. To demonstrate the connection options,
    let’s check if they are running CentOS 7 by poking inside the */etc/os-release*
    file. This is how the test function looks (saved as `test_remote.py`):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 有两台服务器正在运行。为了演示连接选项，让我们检查它们是否在运行 CentOS 7，查看 */etc/os-release* 文件的内容。这是测试函数的外观（保存为
    `test_remote.py`）：
- en: '[PRE22]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It is a single test function that accepts the `host` fixture, which runs against
    all the nodes specified.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个单一的测试函数，接受 `host` fixture，并针对所有指定的节点运行。
- en: 'The `--hosts` flag accepts a list of hosts with a connection scheme (SSH would
    use `*ssh://hostname*` for example), and some other variations using globbing
    are allowed. If testing against more than a couple of remote servers at a time,
    passing them on the command line becomes cumbersome. This is how it would look
    to test against two servers using SSH:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`--hosts` 标志接受一个主机列表，并使用连接方案（例如 SSH 将使用 `*ssh://hostname*`），还允许使用通配符进行一些其他变体。如果一次测试多个远程服务器，则在命令行中传递它们变得很麻烦。以下是使用
    SSH 测试两台服务器的方式：'
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The increased verbosity (with the `-v` flag) shows that Testinfra is executing
    the one test function in the two remote servers specified in the invocation.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用增加冗余信息（使用 `-v` 标志）显示 Testinfra 在调用中指定的两台远程服务器中执行一个测试函数。
- en: Note
  id: totrans-181
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When setting up the hosts, it is important to have a passwordless connection.
    There shouldn’t be any password prompts, and if using SSH, a key-based configuration
    should be used.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置主机时，具有无密码连接是重要的。不应该有任何密码提示，如果使用 SSH，则应该使用基于密钥的配置。
- en: 'When automating these types of tests (as part of a job in a CI system, for
    example), you can benefit from generating the hosts, determining how they connect,
    and any other special directives. Testinfra can consume an SSH configuration file
    to determine what hosts to connect to. For the previous test run, [Vagrant](https://www.vagrantup.com)
    was used, which created these servers with special keys and connection settings.
    Vagrant can generate an ad-hoc SSH config file for the servers it has created:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当自动化这些类型的测试（例如作为 CI 系统中的作业的一部分）时，您可以从生成主机、确定它们如何连接以及任何其他特殊指令中受益。Testinfra 可以使用
    SSH 配置文件确定要连接的主机。在上一次测试运行中，使用了 [Vagrant](https://www.vagrantup.com)，它创建了具有特殊密钥和连接设置的这些服务器。Vagrant
    可以为其创建的服务器生成临时 SSH 配置文件：
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Exporting the contents of the output to a file and then passing that to Testinfra
    offers greater flexibility if using more than one host:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出内容导出到文件，然后传递给 Testinfra 可以提供更大的灵活性，特别是在使用多个主机时：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Using `--hosts=default` avoids having to specify them directly in the command
    line, and the engine feeds from the SSH configuration. Even without Vagrant, the
    SSH configuration tip is still useful if connecting to many hosts with specific
    directives.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `--hosts=default` 避免在命令行中直接指定它们，并且引擎从 SSH 配置中获取。即使没有 Vagrant，SSH 配置提示仍然对连接到具有特定指令的多个主机有用。
- en: '[Ansible](https://www.ansible.com) is another option if the nodes are local,
    SSH, or Docker containers. The test setup can benefit from using an inventory
    of hosts (much like the SSH config), which can group the hosts into different
    sections. The host groups can also be specified so that you can single out hosts
    to test against, instead of executing against all.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[Ansible](https://www.ansible.com) 是另一种选择，如果节点是本地、SSH 或 Docker 容器。测试设置可以从使用主机清单（类似于
    SSH 配置）中受益，它可以将主机分组到不同的部分。主机组也可以指定，以便您可以单独针对主机进行测试，而不是针对所有主机执行。'
- en: 'For `node1` and `node2` used in the previous example, this is how the inventory
    file is defined (and saved as `hosts`):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在先前示例中使用的 `node1` 和 `node2`，清单文件的定义如下（保存为 `hosts`）：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If executing against all of them, the command changes to:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对所有这些执行，命令将更改为：
- en: '[PRE27]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If defining other hosts in the inventory that need an exclusion, a group can
    be specified as well. Assuming that both nodes are web servers and are in the
    `nginx` group, this command would run the tests on only that one group:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在清单中定义了需要排除的其他主机，则还可以指定一个组。假设两个节点都是 Web 服务器，并且属于 `nginx` 组，则此命令将仅在该组上运行测试：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Tip
  id: totrans-195
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: A lot of system commands require superuser privileges. To allow escalation of
    privileges, Testinfra allows specifying `--sudo` or `--sudo-user`. The `--sudo`
    flag makes the engine use `sudo` when executing the commands, while the `--sudo-user`
    command allows running with higher privileges as a different user.The fixture
    can be used directly as well.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 许多系统命令需要超级用户权限。为了允许特权升级，Testinfra 允许指定 `--sudo` 或 `--sudo-user`。`--sudo` 标志使引擎在执行命令时使用
    `sudo`，而 `--sudo-user` 命令允许以不同用户的更高权限运行。这个 fixture 也可以直接使用。
- en: Features and Special Fixtures
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能和特殊的 fixtures。
- en: 'So far, the `host` fixture is the only one used in examples to check for a
    file and its contents. However, this is deceptive. The `host` fixture is an *all-included*
    fixture; it contains all the other powerful fixtures that Testinfra provides.
    This means that the example has already used the `host.file`, which has lots of
    extras packed in it. It is also possible to use the fixture directly:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在示例中，仅使用 `host` fixture 来检查文件及其内容。然而，这是具有误导性的。`host` fixture 是一个 *全包含*
    的 fixture；它包含了 Testinfra 提供的所有其他强大 fixtures。这意味着示例已经使用了 `host.file`，其中包含了大量额外的功能。也可以直接使用该
    fixture：
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The all-in-one `host` fixture makes use of the extensive API from Testinfra,
    which loads everything for each host it connects to. The idea is to write a single
    test that gets executed against different nodes, all accessible from the same
    `host` fixture.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 全功能的 `host` fixture 利用了 Testinfra 的广泛 API，它为连接到的每个主机加载了所有内容。其想法是编写单个测试，针对从同一
    `host` fixture 访问的不同节点执行。
- en: 'These are a [couple dozen](https://oreil.ly/2_J-o) attributes available. These
    are some of the most used ones:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些可用的 [几十个](https://oreil.ly/2_J-o) 属性。以下是其中一些最常用的：
- en: '`host.ansible`'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`host.ansible`'
- en: Provides full access to any of the Ansible properties at runtime, such as hosts,
    inventory, and vars
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时提供对任何 Ansible 属性的完全访问，例如主机、清单和变量。
- en: '`host.addr`'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`host.addr`'
- en: Network utilities, like checks for IPV4 and IPV6, is host reachable, is host
    resolvable
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 网络工具，如检查 IPV4 和 IPV6，主机是否可达，主机是否可解析。
- en: '`host.docker`'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`host.docker`'
- en: Proxy to the Docker API, allows interacting with containers, and checks if they
    are running
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 代理到 Docker API，允许与容器交互，并检查它们是否在运行。
- en: '`host.interface`'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`host.interface`'
- en: Helpers for inspecting addresses from a given interface
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 用于检查给定接口地址的辅助工具。
- en: '`host.iptables`'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`host.iptables`'
- en: Helpers for verifying firewall rules as seen by `host.iptables`
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 用于验证防火墙规则（如 `host.iptables` 所见）的辅助工具。
- en: '`host.mount_point`'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`host.mount_point`'
- en: Check mounts, filesystem types as they exist in paths, and mount options
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 检查挂载点、文件系统类型在路径中的存在以及挂载选项。
- en: '`host.package`'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`host.package`'
- en: '*Very useful* to query if a package is installed and at what version'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*非常有用* 以查询包是否已安装及其版本。'
- en: '`host.process`'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`host.process`'
- en: Check for running processes
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 检查运行中的进程。
- en: '`host.sudo`'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`host.sudo`'
- en: Allows you to execute commands with `host.sudo` or as a different user
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 允许您使用 `host.sudo` 执行命令，或作为不同用户执行。
- en: '`host.system_info`'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`host.system_info`'
- en: All kinds of system metadata, such as distribution version, release, and codename
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 各种系统元数据，如发行版版本、发布和代号。
- en: '`host.check_output`'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`host.check_output`'
- en: Runs a system command, checks its output if runs successfully, and can be used
    in combination with `host.sudo`
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 运行系统命令，检查其输出（如果成功运行），可以与 `host.sudo` 结合使用。
- en: '`host.run`'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`host.run`'
- en: Runs a command, allows you to check the return code, `host.stderr`, and `host.stdout`
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令，允许检查返回代码，`host.stderr` 和 `host.stdout`。
- en: '`host.run_expect`'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`host.run_expect`'
- en: Verifies that the return code is as expected
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 验证返回代码是否符合预期。
- en: Examples
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例
- en: A frictionless way to start developing system validation tests is to do so while
    creating the actual deployment. Somewhat similar to *Test Driven Development*
    (TDD), any progress warrants a new test. In this section, a web server needs to
    be installed and configured to run on port 80 to serve a static landing page.
    While making progress, tests will be added. Part of writing tests is understanding
    failures, so a few problems will be introduced to help us figure out what to fix.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 无摩擦地开始开发系统验证测试的方法是在创建实际部署时执行。与*测试驱动开发*（TDD）有些类似，任何进展都需要一个新的测试。在本节中，需要安装并配置Web
    服务器在端口80上运行以提供静态着陆页面。在取得进展的同时，将添加测试。编写测试的一部分是理解失败，因此将引入一些问题来帮助我们确定要修复的内容。
- en: 'With a *vanilla* Ubuntu server, start by installing the Nginx package:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在*干净的* Ubuntu 服务器上，首先安装Nginx包：
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a new test file called *test_webserver.py* for adding new tests after
    making progress. After Nginx installs, let’s create another test:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在取得进展后创建一个名为*test_webserver.py*的新测试文件。Nginx安装后，让我们再创建一个测试：
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Reduce the verbosity in `pytest` output with the `-q` flag to concentrate on
    failures. The remote server is called `node4` and SSH is used to connect to it.
    This is the command to run the first test:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-q`标志减少`pytest`输出的冗长以集中处理失败。远程服务器称为`node4`，使用SSH连接到它。这是运行第一个测试的命令：
- en: '[PRE32]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Progress! The web server needs to be up and running, so a new test is added
    to verify that behavior:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 进展！Web 服务器需要运行，因此添加了一个新的测试来验证其行为：
- en: '[PRE33]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Running again *should* work once again:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行*应该*再次成功：
- en: '[PRE34]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Some Linux distributions do not allow packages to start the services when they
    get installed. Moreover, the test has caught the Nginx service not running, as
    reported by `systemd` (the default unit service). Starting Nginx manually and
    running the test should make everything pass once again:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Linux发行版不允许在安装时启动包服务。此外，测试捕获到`systemd`（默认单元服务）报告Nginx服务未运行。手动启动Nginx并运行测试应该再次使一切顺利通过：
- en: '[PRE35]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As mentioned at the beginning of this section, the web server should be serving
    a static landing page on port 80\. Adding another test (in *test_webserver.py*)
    to verify the port is the next step:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节开头所述，Web 服务器应在端口80上提供静态着陆页面。添加另一个测试（在*test_webserver.py*中）以验证端口是下一步：
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This test is more involved and needs attention to some details. It opts to
    check for TCP connections on port `80` on *any IP in the server*. While this is
    fine for this test, if the server has multiple interfaces and is configured to
    bind to a specific address, then a new test would have to be added. Adding another
    test that checks if port `80` is listening on a given address might seem like
    overkill, but if you think about the reporting, it helps explain what is going
    on:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试更为复杂，需要关注一些细节。它选择检查*服务器中任何IP上*端口`80`的TCP连接。虽然对于此测试来说这没问题，但如果服务器有多个接口并配置为绑定到特定地址，则必须添加新的测试。添加另一个检查端口`80`是否在给定地址上监听的测试可能看起来有些多余，但如果考虑到报告，它有助于解释发生了什么：
- en: 'Test `nginx` listens on port `80` : PASS'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试`nginx`是否在端口`80`上监听：PASS
- en: 'Test `nginx` listens on address `192.168.0.2` and port `80`: FAIL'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试`nginx`是否在地址`192.168.0.2`和端口`80`上监听：FAIL
- en: The above tells us that Nginx is binding to port `80`, *just not to the right
    interface*. An extra test is an excellent way to provide granularity (at the expense
    of extra verbosity).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以上告诉我们Nginx绑定到端口`80`，*只是没有绑定到正确的接口*。额外的测试是提供细粒度的好方法（以牺牲额外的冗长）。
- en: 'Run the newly added test again:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行新添加的测试：
- en: '[PRE37]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'No address has anything listening on port `80`. Looking at the configuration
    for Nginx reveals that it is set to listen on port `8080` using a directive in
    the default site that configures the port:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何地址在端口`80`上有监听。查看Nginx的配置发现，它设置为使用默认站点中的指令在端口`8080`上进行监听：
- en: '[PRE38]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After changing it back to port `80` and restarting the `nginx` service, the
    tests pass again:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 将其改回到端口`80`并重新启动`nginx`服务，测试再次通过：
- en: '[PRE39]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Since there isn’t a built-in fixture to handle HTTP requests to an address,
    the final test uses the `wget` utility to retrieve the contents of the running
    website and make assertions on the output to ensure that the static site renders:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有内置的夹具来处理向地址的HTTP请求，最后一个测试使用`wget`实用程序检索正在运行的网站的内容，并对输出进行断言以确保静态站点渲染：
- en: '[PRE40]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Running *test_webserver.py* once more verifies that all our assumptions are
    correct:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行*test_webserver.py*以验证所有我们的假设是正确的：
- en: '[PRE41]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Understanding the concepts of testing in Python, and repurposing those for system
    validation, is incredibly powerful. Automating test runs while developing applications
    or even writing and running tests on existing infrastructure are both excellent
    ways to simplify day-to-day operations that can become error-prone. pytest and
    Testinfra are great projects that can help you get started, and make it easy when
    extending is needed. Testing is a *level up* on skills.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 理解Python中测试概念，并将其重新用于系统验证，具有非常强大的功能。在开发应用程序时自动化测试运行，甚至在现有基础设施上编写和运行测试，都是简化日常操作的极佳方式，因为这些操作往往容易出错。pytest和Testinfra是可以帮助你入门的优秀项目，并且在需要扩展时使用起来非常方便。测试是技能的*升级*。
- en: Testing Jupyter Notebooks with pytest
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pytest测试Jupyter Notebooks
- en: 'One easy way to introduce big problems into your company is to forget about
    applying software engineering best practices when it comes to data science and
    machine learning. One way to fix this is to use the `nbval` plug-in for pytest
    that allows you to test your notebooks. Take a look at this `Makefile`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据科学和机器学习中，如果忘记应用软件工程最佳实践，很容易在公司引入大问题。解决这个问题的一种方法是使用pytest的`nbval`插件，它允许你测试你的笔记本。看看这个`Makefile`：
- en: '[PRE42]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The key item is the `--nbval` flag that also allows the notebook in the repo
    to be tested by the build server.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 关键项目是`--nbval`标志，它还允许建立服务器测试仓库中的笔记本。
- en: Exercises
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Name at least three conventions needed so that `pytest` can discover a test.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少列出三个约定，以便`pytest`可以发现测试。
- en: What is the *conftest.py* file for?
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*conftest.py*文件的作用是什么？'
- en: Explain parametrization of tests.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释测试参数化。
- en: What is a fixture and how can it be used in tests? Is it convenient? Why?
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是fixture，如何在测试中使用它？它方便吗？为什么？
- en: Explain how to use the `monkeypatch` fixture.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释如何使用`monkeypatch` fixture。
- en: Case Study Question
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究问题
- en: Create a test module to use `testinfra` to connect to a remote server. Test
    that Nginx is installed, is running with `systemd`, and the server is binding
    to port 80\. When all tests pass, try to make them fail by configuring Nginx to
    listen on a different port.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个测试模块，使用`testinfra`连接到远程服务器。测试Nginx是否安装，在`systemd`下运行，并且服务器是否绑定到端口80。当所有测试通过时，尝试通过配置Nginx监听不同的端口来使它们失败。
