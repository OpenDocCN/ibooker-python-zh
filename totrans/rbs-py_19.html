<html><head></head><body>
<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 16. Dependencies" class="preface"><div class="preface" id="dependencies">
<h1 class="calibre10" id="calibre_pb_0"><span class="calibre">Chapter 16. </span>Dependencies</h1>


<p class="author1">It is difficult to write a program with no dependencies.<a data-type="indexterm" data-primary="dependencies" id="ix_dpnd" class="calibre5"/> Functions depend on other functions, modules depend on other modules, and programs depend on other programs.<a data-type="indexterm" data-primary="box-and-arrows diagrams of dependencies" id="idm45644732286616" class="calibre5"/> Architecture is fractal; no matter what level you’re looking at, your code can be represented as some sort of box-and-arrows diagram, like in <a data-type="xref" href="part0021_split_000.html#block_and_arrow" class="calibre5">Figure 16-1</a>. It doesn’t matter if it’s functions, classes, modules, programs, or systems, you can draw a similar diagram to <a data-type="xref" href="part0021_split_000.html#block_and_arrow" class="calibre5">Figure 16-1</a> to represent the dependencies in your code.</p>

<figure class="calibre36"><div id="block_and_arrow" class="figure">
<img src="../images/00020.gif" alt="Box-and-arrows diagram" class="calibre40"/>
<h6 class="calibre37"><span class="calibre">Figure 16-1. </span>Box-and-arrows diagram</h6>
</div></figure>

<p class="author1">However, if you don’t actively manage your dependencies, you soon <a data-type="indexterm" data-primary="“spaghetti code”" data-primary-sortas="spaghetti" id="idm45644732281512" class="calibre5"/>get to what’s known as “spaghetti code,” making your box-and-arrows diagram look like <a data-type="xref" href="part0021_split_000.html#spaghetti_code" class="calibre5">Figure 16-2</a>.</p>

<figure class="calibre36"><div id="spaghetti_code" class="figure">
<img src="../images/00021.gif" alt="A tangled mess of dependencies" class="calibre40"/>
<h6 class="calibre37"><span class="calibre">Figure 16-2. </span>A tangled mess of dependencies</h6>
</div></figure>

<p class="author1">In this chapter, you are going to learn all about dependencies and how to keep them under control. You’ll learn about different types of dependencies, all of which should be managed with different techniques. You’ll learn how to graph your dependencies, and how to interpret whether you have a healthy system. You’ll learn how to truly simplify your code architecture, which will help you manage complexity and increase the robustness of your codebase.</p>






</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 16. Dependencies" class="preface">
<div class="preface" id="dependencies">
<section data-type="sect1" data-pdf-bookmark="Relationships" class="preface"><div class="preface" id="idm45644732276536">
<h1 class="calibre12" id="calibre_pb_1">Relationships</h1>

<p class="author1">Dependencies are, in essence, relationships.<a data-type="indexterm" data-primary="dependencies" data-secondary="relationships" id="ix_dpndrel" class="calibre5"/> When a piece of code requires another piece of code to behave in some specific way, we call that a <em class="calibre6">dependency</em>. You typically use a dependency to benefit from code reuse in some fashion. Functions call other functions to reuse behaviors. Modules import other modules to reuse the types and functions defined in that module. It doesn’t make sense in most codebases to write literally everything from scratch. Reusing other parts of the codebase, or even code from other organizations, can be immensely beneficial.</p>

<p class="author1">When you reuse code, you save time. You don’t need to waste effort writing code; you can just call or import the functionality that you need. Furthermore, any code you are depending on is presumably used in other places. <a data-type="indexterm" data-primary="testing" data-secondary="code dependencies and" id="idm45644732271864" class="calibre5"/>This means that some layer of testing has already been done, which should reduce the number of bugs. Bonus points if the code is readily available to read.<a data-type="indexterm" data-primary="Linus' Law" id="idm45644732270584" class="calibre5"/> As <em class="calibre6">Linus’s Law</em> (as in Linus Torvalds, creator of Linux) states:<sup class="calibre11"><a data-type="noteref" id="idm45644732269304-marker" href="part0021_split_012.html#idm45644732269304" class="calibre5">1</a></sup></p>
<blockquote class="pcalibre2 calibre28 pcalibre1">
<p class="calibre29">“Given enough eyeballs, all bugs are shallow.”</p></blockquote>

<p class="author1">Put another way, the likeliness of finding bugs is higher because so many people are looking at the code. This is another point in favor of readability leading to maintainability. If your code is readable, other developers will find and fix errors in it more easily, helping your robustness grow.</p>

<p class="author1">There’s a catch, though. There is no such thing as a free lunch when talking about dependencies.<a data-type="indexterm" data-primary="coupling" data-secondary="dependencies contributing to" id="idm45644732266216" class="calibre5"/> Every dependency you create contributes to <em class="calibre6">coupling</em>, or tying two entities together. If a dependency changes in an incompatible way, your code needs to change as well. If this happens often, your robustness will suffer; you are constantly struggling to stay afloat as your dependencies change.</p>

<p class="author1">There’s also a human factor with dependencies.<a data-type="indexterm" data-primary="maintainable code" data-secondary="dependencies and" id="idm45644732263864" class="calibre5"/> Every piece of code you depend on is maintained by a living, breathing human (maybe even a group of them). These maintainers have their own schedules, their own deadlines, and their own vision for the code they develop. Chances are those will not align with your schedules, deadlines, and vision. The more a piece of code is reused, the less likely it is that it meets all of the needs of every consumer. As your dependencies diverge from your implementation, you either live with the difficulties, choose an alternative dependency (possibly one you control), or fork it (and maintain it yourself). The choice you make depends on your specific scenario, but in each case, robustness takes a hit.</p>

<p class="author1">Any JavaScript developer who was working in 2016 can tell you how dependencies went<a data-type="indexterm" data-primary="left-pad debacle" id="idm45644732261656" class="calibre5"/> wrong in “the left-pad debacle.” Due to a policy dispute, a developer removed a library named left-pad from the package repository and the next morning, thousands of projects were suddenly broken and unable to build. Many large projects (including React, a very popular library) depended on left-pad not directly, but transitively, through their own dependencies. That’s right, dependencies have their own dependencies and you get them too when you depend on other code. The moral of the story: don’t forget the human factor and the associated costs related to their workflows. Be prepared for any of your dependencies to change in the worst way, including being removed. Dependencies are liabilities. Necessary, but still liabilities.</p>

<p class="author1">Dependencies also broaden the attack surface from a security perspective.<a data-type="indexterm" data-primary="security" data-secondary="dependencies broadening attack surface" id="idm45644732259672" class="calibre5"/> Every dependency (and their own dependencies) has potential to compromise your system. There are entire websites dedicated to tracking security vulnerabilities, such as <a href="https://cve.mitre.org" class="calibre5"><em class="calibre6">https://cve.mitre.org</em></a>. A keyword search of “Python” shows you how many vulnerabilities exist today, and naturally, those websites can’t even count the not-yet-known vulnerabilities. This is even more perilous with dependencies maintained by your organization; unless you have security-minded individuals constantly looking at all of your code, unknown vulnerabilities may be ever-present in your codebase.</p>
<aside data-type="sidebar" epub:type="sidebar" class="calibre32"><div class="sidebar" id="idm45644732256648">
<h5 class="calibre33">To Pin or Not to Pin</h5>
<p class="author1">Some developers tend to pin their dependencies, which means those dependencies are frozen at a specific point in time.<a data-type="indexterm" data-primary="dependencies" data-secondary="pinning or not pinning" id="idm45644732255048" class="calibre5"/> That way, you don’t run the risk of breaking code because of an updated dependency; projects keep chugging along using an old version. For a very mature project that isn’t updated often, this isn’t too bad of a setup to minimize risk, but you need to be wary of a few things.</p>

<p class="author1">For this to work, you need to be diligent about what you pin. If any dependencies are unpinned, they shouldn’t depend on any other pinned dependency. Otherwise, when the unpinned dependencies change, they are liable to have a conflict with the pinned dependencies.</p>

<p class="author1">Secondly, in order to pin dependencies, those dependencies actually need to be pinnable. The dependencies need to be represented as a specific commit or version number to reference. You cannot pin dependencies that are solely inside your codebase, such as an individual function or class.</p>

<p class="author1">Lastly, you need to evaluate the likelihood of actually needing to update the pin at any time. Think about new features, security updates, or bug fixes that might happen. Any one of these will inevitably cause a pin to get updated. The longer you wait on updating a pin, the more changes that may have been introduced, incompatible with your codebase’s assumptions. This can make for a painful integration.</p>

<p class="author1">If you foresee the need to change the pinning of a dependency, you need a strategy for updating those dependencies.<a data-type="indexterm" data-primary="continuous integration" data-secondary="dependencies and" id="idm45644732250856" class="calibre5"/> I recommend keeping the dependencies pinned, but lean on a continuous integration workflow and dependency managers such as <code class="calibre17">poetry</code> to update those dependencies. With continuous integration, you are constantly scanning for new dependencies. When dependencies change, the tools will update the dependencies, run tests, and if tests pass, check in the new pins for the updated dependencies. This way, dependencies stay up to date, but you always maintain a checked-in set of pins for reproducibility. The downside here is that you need to have the discipline and supporting culture to fix the failed integrations as they appear. Tackling failures piecemeal is much less effort in the long run than delaying the <span class="calibre">integration</span>.</p>
</div></aside>

<p class="author1">Carefully balance your use of dependencies. Your code will inherently have dependencies, and that is a good thing. The trick is to be smart with how you manage them. Being careless will lead to a sloppy, tangled mess. To learn how to handle dependencies, you first need to know how to identify the different types.<a data-type="indexterm" data-primary="dependencies" data-secondary="relationships" data-startref="ix_dpndrel" id="idm45644732247192" class="calibre5"/></p>
</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 16. Dependencies" class="preface">
<div class="preface" id="dependencies">
<section data-type="sect1" data-pdf-bookmark="Types of Dependencies" class="preface"><div class="preface" id="idm45644732275912">
<h1 class="calibre12" id="calibre_pb_2">Types of Dependencies</h1>

<p class="author1">I group dependencies into three classifications: physical, logical, and temporal.<a data-type="indexterm" data-primary="dependencies" data-secondary="types of" id="idm45644732244504" class="calibre5"/> Each impacts your code’s robustness in different ways. You have to be able to spot them and know when they go awry. When wielded correctly, dependencies can keep your code extensible without bogging it down.</p>








</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 16. Dependencies" class="preface">
<div class="preface" id="dependencies">
<section data-type="sect1" data-pdf-bookmark="Types of Dependencies" class="preface">
<div class="preface" id="idm45644732275912">
<section data-type="sect2" data-pdf-bookmark="Physical Dependencies" class="preface"><div class="preface" id="idm45644732243048">
<h2 class="calibre34" id="calibre_pb_3">Physical Dependencies</h2>

<p class="author1">When most developers think about dependencies, it’s the physical dependencies they think about. <em class="calibre6">Physical dependencies</em> are a relationship observed directly in code.<a data-type="indexterm" data-primary="physical dependencies" id="ix_phydpnd" class="calibre5"/><a data-type="indexterm" data-primary="dependencies" data-secondary="physical" id="ix_dpndphy" class="calibre5"/> Functions calling functions, types composed of other types, modules importing modules, classes inheriting from other classes…these are all examples of physical dependencies. They are static, meaning they aren’t changing at runtime.</p>

<p class="author1">Physical dependencies are the easiest to reason about; even tools can look at the codebase and map out physical dependencies (you’ll see this in just a few pages). They are easy to read and understand at first glance, which is a win for robustness. When future maintainers are reading or debugging the code, it becomes quite apparent how the dependency chain resolves; they can follow a trail of imports or function calls to get to the end of the chain.</p>

<p class="author1"><a data-type="xref" href="part0021_split_003.html#physical_dependencies" class="calibre5">Figure 16-3</a> focuses on a completely automated pizza café named <em class="calibre6">PizzaMat</em>. Franchisees can purchase a PizzaMat as an entire module, and deploy it anywhere to get instant (and delicious) pizza. PizzaMat has a few different systems: the pizza-making system, a system to control payment and ordering, and a system to handle table management (seating, refills, and order delivery).</p>

<figure class="calibre36"><div id="physical_dependencies" class="figure">
<img src="../images/00022.gif" alt="An automated pizza café" class="calibre40"/>
<h6 class="calibre37"><span class="calibre">Figure 16-3. </span>An automated pizza café</h6>
</div></figure>

<p class="author1">Each of these three systems interacts with the others (that’s what the arrows represent). The customer interacts with the payment/ordering system to order their pizza. Once they’re done, the pizza maker checks for any new orders and starts making the pizzas, and the table management system starts seating the customer. Once the table management service learns the pizza is done, it preps it for the table and serves it to the customer. If for any reason the customer is unhappy with the pizza, the table management system returns the pizza and the payment system issues a refund.</p>

<p class="author1">Each of these dependencies is a relationship, and only with these systems working together do we have a working pizza shop. Physical dependencies are absolutely necessary to make sense of large systems; they allow you to break the problem down into smaller entities and define the interactions between each entity. I could take any one of these systems and break that down into modules, or take any module and break it down into functions. What I want to focus on is how those relationships impact maintainability.<a data-type="indexterm" data-primary="maintainability" data-secondary="physical dependencies' effects on" id="idm45644732231736" class="calibre5"/></p>

<p class="author1">Suppose these three systems are maintained by three separate entities. You and your team maintain the pizza-making system. Another team in your company (but in a different building) owns the table management system, and an independent contractor has been providing the payment system. You’ve been part of a huge rollout to provide a new item in your pizza maker: stromboli. You’ve been working for weeks, carefully coordinating changes. Every system requires changes to handle the new menu item. After countless late nights (all pizza-fueled, of course), you are ready for the big update for your customers. However, as soon as the update rolls out, error reports start rolling in. An unfortunate set of events has introduced a bug, leading to pizza shops around the world breaking. As more and more systems come online, the problem becomes more dire. Management decides that you need to fix it as soon as possible.</p>

<p class="author1">Take a minute to ask how you would like your night to go. Do you want to spend it frantically trying to reach all of the other teams, attempting to hack in a fix across the three systems? You happen to know that the contractor has already turned off notifications for the night and the other team got a little too carried away with their launch celebration after work today. Or do you want to take a look at the code and realize that it’s incredibly easy to remove stromboli from all three systems by just messing with a few lines of code, with no input from the other teams?</p>

<p class="author1">Dependencies are a one-way relationship. You are beholden to your dependencies. If they don’t do exactly what you want when you need it, you have little recourse. Remember, living, breathing humans are on the other side of your dependencies and they won’t necessarily jump when you ask them to jump. How you construct your dependencies will directly impact how you maintain a system.</p>

<p class="author1">In our stromboli example, the dependencies are a circle; any one change can potentially affect the other two systems. You need to think about every direction of your dependencies and how changes ripple through your system. With PizzaMat, the support of the pizza-making equipment is our single source of truth; there’s no use in setting up billing and table management for pizza products that don’t exist. However, in the example above, all three systems were written with their own copy of what menu items are available. Based on the direction of the dependencies, the pizza maker could take out the stromboli code,  but stromboli would still show up in the payment system. How could you make this more extensible to avoid these dependency problems?</p>
<div data-type="warning" epub:type="warning" class="calibre23"><h6 class="calibre24">Warning</h6>
<p class="author1">The tricky thing about large architectural changes is that the right answer always depends on the context of your specific problem. If <em class="calibre6">you</em> were to build an automated pizza maker, you might draw your dependency tree differently, based on a variety of different factors and constraints. It’s important to focus on <em class="calibre6">why</em> you are drawing your dependencies the way you are, not making sure that they are always drawn the same way as someone else’s system.</p>
</div>

<p class="author1">To start, you can construct your system such that all the menu definitions live in the pizza-making system; after all, it is the system that knows what it can and cannot make. From there, the pricing system can query the pizza maker as to what items are actually available. That way, if you need to remove stromboli in an emergency, you can do it in the pizza-making system; the pricing system doesn’t control what is and is not available. By inverting, or reversing the direction of, the dependency, you restore control to the pizza-making system. If I were to invert this one dependency, the dependency graph looks like <a data-type="xref" href="part0021_split_003.html#organized_deps" class="calibre5">Figure 16-4</a>.</p>

<figure class="calibre36"><div id="organized_deps" class="figure">
<img src="../images/00023.gif" alt="More sensible dependencies" class="calibre40"/>
<h6 class="calibre37"><span class="calibre">Figure 16-4. </span>More sensible dependencies</h6>
</div></figure>

<p class="author1">Now the pizza maker calls the shots for what can and cannot be ordered. This can go a long way toward limiting the amount of changes needed. If the pizza maker needs to stop supporting a type of ingredient in a dish, the payment system will pick up the changes automatically. Not only will this save your hide during an emergency, but it gives your business more flexibility in the future. You’ve added the ability to optionally display different dishes in the payment system depending on what the pizza maker can automatically make, all without needing to coordinate with an external payment team.</p>
</div></section>













</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 16. Dependencies" class="preface">
<div class="preface" id="dependencies">
<section data-type="sect1" data-pdf-bookmark="Types of Dependencies" class="preface">
<div class="preface" id="idm45644732275912">
<section data-type="sect2" data-pdf-bookmark="Physical Dependencies" class="preface">
<div class="preface" id="idm45644732243048">
<div data-type="note" epub:type="note" class="calibre21"><h1 class="calibre38" id="calibre_pb_4">Discussion Topic</h1>
<p class="author1">Think through how you would add a feature that prevents the payment system from showing certain options if the pizza maker was out of ingredients. Consider the systems in Figures <a data-type="xref" data-xrefstyle="select:labelnumber" href="part0021_split_003.html#physical_dependencies" class="calibre5">16-3</a> and
<a data-type="xref" data-xrefstyle="select:labelnumber" href="part0021_split_003.html#organized_deps" class="calibre5">16-4</a>.</p>

<p class="author1">As an additional discussion topic, discuss the cycle between the table management system and payment system. How can you break that cycle? What are the pros and cons of each direction of <span class="calibre">dependencies</span>?</p>
</div>
<aside data-type="sidebar" epub:type="sidebar" class="calibre32"><div class="sidebar" id="idm45644732213336">
<h5 class="calibre33">When Code Gets Too DRY</h5>
<p class="author1">The <a data-type="indexterm" data-primary="Don't Repeat Yourself (DRY) principle" data-secondary="when code is too DRY" id="idm45644732211464" class="calibre5"/>DRY principle (Don’t Repeat Yourself—see <a data-type="xref" href="part0014_split_000.html#classes" class="calibre5">Chapter 10</a> for more detail) is ingrained in most developers’ heads. Anytime you see very similar code in your codebase, you are required to shout “DUPLICATION!” to warn other developers, and dutifully refactor that code so that it lives in one place. After all, you don’t want to fix the same bug in multiple places.</p>

<p class="author1">It’s possible for the DRY principle to go too far, though. <a data-type="indexterm" data-primary="physical dependencies" data-secondary="DRY principle and" id="idm45644732208728" class="calibre5"/>Every time you refactor code, you are introducing a physical dependency to the refactored code. If other parts of your codebase depend on this piece of code, you are coupling them together. If that refactored central piece of code needs to change, it can affect a large amount of code.</p>

<p class="author1">When applying the DRY principle, don’t deduplicate code just because it looks the same; deduplicate it only if that code has the same <em class="calibre6">reasons</em> to change. Otherwise, you’ll start getting into cases where the refactored code needs to change for one reason, but that reason is incompatible with other parts of code that depend on the refactored code. You need to start putting special logic into the deduplicated code to handle special cases. Any time you increase complexity like this, you start to reduce maintainability and make code harder to reuse for general purposes.<a data-type="indexterm" data-primary="physical dependencies" data-startref="ix_phydpnd" id="idm45644732205832" class="calibre5"/><a data-type="indexterm" data-primary="dependencies" data-secondary="physical" data-startref="ix_dpndphy" id="idm45644732204856" class="calibre5"/></p>
</div></aside>
</div></section>













</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 16. Dependencies" class="preface">
<div class="preface" id="dependencies">
<section data-type="sect1" data-pdf-bookmark="Types of Dependencies" class="preface">
<div class="preface" id="idm45644732275912">
<section data-type="sect2" data-pdf-bookmark="Logical Dependencies" class="preface"><div class="preface" id="idm45644732242456">
<h2 class="calibre34" id="calibre_pb_5">Logical Dependencies</h2>

<p class="author1">A <em class="calibre6">logical dependency</em> is when two entities have a relationship but no direct linkage in code.<a data-type="indexterm" data-primary="dependencies" data-secondary="logical" id="ix_dpndlog" class="calibre5"/><a data-type="indexterm" data-primary="logical dependencies" id="ix_logidpnd" class="calibre5"/> The dependency is abstracted; it contains a layer of indirection. It’s a dependency that is only present at runtime. In our pizza maker example, we have three subsystems interacting with one another. We represented the dependency with arrows in <a data-type="xref" href="part0021_split_003.html#physical_dependencies" class="calibre5">Figure 16-3</a>. If those arrows are imports or function calls, then they are physical dependencies. However, it’s possible to link these subsystems at runtime without function calls or imports.</p>

<p class="author1">Suppose subsystems live on different computers and communicate over HTTP. If the pizza maker were to notify the table management service on when the pizza is made over HTTP using the requests library, it would look something like this:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">on_pizza_made</code><code class="calibre17">(</code><code class="n">order</code><code class="calibre17">:</code> <code class="nb">int</code><code class="calibre17">,</code> <code class="n">pizza</code><code class="calibre17">:</code> <code class="n">Pizza</code><code class="calibre17">):</code>

    <code class="n">requests</code><code class="calibre17">.</code><code class="n">post</code><code class="calibre17">(</code><code class="s">"table-management/pizza-made"</code><code class="calibre17">,</code> <code class="calibre17">{</code>
        <code class="s">"id"</code><code class="calibre17">:</code> <code class="n">order</code><code class="calibre17">,</code>
        <code class="s">"pizza"</code><code class="calibre17">:</code> <code class="n">pizza</code><code class="calibre17">.</code><code class="n">to_json</code><code class="calibre17">()</code>
    <code class="calibre17">})</code></pre>

<p class="author1">The physical dependency is no longer from the pizza maker to our table management system, but from the pizza maker to the requests library. As far as the pizza maker is concerned, it just needs an HTTP endpoint that it can post to an endpoint called <span class="calibre">“/pizza-done”</span> from some web server named “table-management.” That endpoint needs to accept an ID and pizza data formatted as JSON.</p>

<p class="author1">Now, in reality, your pizza maker still needs a table management service to work. This is the logical dependency at play. Even though there is no direct dependency, there is still a relationship between the pizza maker and table management systems. This relationship doesn’t just disappear; it transforms from physical to logical.</p>

<p class="author1">The key benefit for introducing a logical dependency is substitutability.<a data-type="indexterm" data-primary="logical dependencies" data-secondary="substitutability as benefit of" id="idm45644732170904" class="calibre5"/><a data-type="indexterm" data-primary="substitutability" data-secondary="logical dependency introducing" id="idm45644732169960" class="calibre5"/> It is much easier to replace a component when nothing is physically depending on it. Take the example with the <code class="calibre17">on_pizza_done</code> over HTTP request. You could completely replace the table management service, as long as it upholds the same contract as the original service. If that sounds familiar, it should, as it’s the exact same idea you learned about in <a data-type="xref" href="part0016_split_000.html#subtyping" class="calibre5">Chapter 12</a>. Subtyping, whether through duck typing, inheritance, or something similar, introduces logical dependencies. Calling code physically depends on the base class, but the logical dependency of which child class is used isn’t determined until runtime.</p>

<p class="author1">Improving substitutability improves maintainability.<a data-type="indexterm" data-primary="maintainability" data-secondary="improvement with substitutability" id="idm45644732166616" class="calibre5"/> Remember, maintainable code is easy to change. If you can substitute entire swaths of functionality with minimal impact, you give your future maintainers immense flexibility in making decisions. If a specific function or class or subsystem isn’t growing to your needs, you can just replace it. Code that is easy to delete is inherently easy to change.</p>

<p class="author1">As with anything though, logical dependencies come with a cost. Every logical dependency is an indirect reference to some relationship. Because there is no physical linkage, tooling has a very hard time identifying logical dependencies. You won’t be able to create a nice box-and-arrows diagram of logical dependencies. Furthermore, as developers read your code, the logical dependencies won’t be immediately apparent. Often, a reader of code will see the physical dependency to some layer of abstraction, while the logical dependency isn’t noticed or resolved until runtime.</p>

<p class="author1">This is the trade-off of introducing a logical dependency.<a data-type="indexterm" data-primary="logical dependencies" data-secondary="trade-offs with use of" id="idm45644732163784" class="calibre5"/> You increase maintainability by increasing substitutability and reducing coupling, but you also decrease maintainability by making your code harder to read and understand. Too many layers of abstraction create a tangled mess just as easily as too few layers of abstraction. There is no hard and fast rule for what the right number of layers of abstraction are; you need to use your best judgment for whether you need flexibility or readability for your specific scenario.</p>

<p class="author1">Some logical dependencies create relationships that aren’t detectable through tooling, such as depending on the specific ordering of a collection or relying on specific fields to be present in a class. When found, these often surprise developers because there was little indication they existed without close inspection.</p>

<p class="author1">I once worked on a codebase that stored network interfaces. Two pieces of code depended on these interfaces: one system for performance statistics and one for setting up communication paths with other systems. The problem was they had different assumptions about the ordering of those interfaces. It worked for years, until new network interfaces were added. Due to how communication paths worked, new interfaces needed to be put in the front of the list. But the performance statistics would have only worked with those interfaces in the back. Due to a hidden logical dependency, these two parts of code were inextricably linked (I never would have thought that adding communication paths would break performance statistics).</p>

<p class="author1">In hindsight, the fix was easy. I created a function that mapped the ordering from the communication path expectations to a reordered list. The performance statistics system then depended on this new function. However, that didn’t retroactively fix the bug (or give me back the hours of my time spent trying to figure out why performance statistics were broken). Whenever you create a dependency on something that is not directly apparent in code, find a way to make it apparent. Leave a trail of breadcrumbs, preferably with a separate codepath (like the intermediary function above) or types. If you can’t do that, leave a comment. Had one comment in the network interface list indicated a dependency upon a specific ordering, I never would have had such a headache with that code.<a data-type="indexterm" data-primary="dependencies" data-secondary="logical" data-startref="ix_dpndlog" id="idm45644732159096" class="calibre5"/><a data-type="indexterm" data-primary="logical dependencies" data-startref="ix_logidpnd" id="idm45644732157848" class="calibre5"/></p>
</div></section>













</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 16. Dependencies" class="preface">
<div class="preface" id="dependencies">
<section data-type="sect1" data-pdf-bookmark="Types of Dependencies" class="preface">
<div class="preface" id="idm45644732275912">
<section data-type="sect2" data-pdf-bookmark="Temporal Dependencies" class="preface"><div class="preface" id="idm45644732203048">
<h2 class="calibre34" id="calibre_pb_6">Temporal Dependencies</h2>

<p class="author1">The last type of dependency is the temporal dependency.<a data-type="indexterm" data-primary="dependencies" data-secondary="temporal" id="ix_dpndtmp" class="calibre5"/><a data-type="indexterm" data-primary="temporal dependencies" id="ix_tmpdpnd" class="calibre5"/> This is actually a type of logical dependency, but how you handle it is slightly different. A <em class="calibre6">temporal dependency</em> is a dependency that is linked by time. Anytime there is a concrete order of operations, such as “dough must be laid down before sauce and cheese” or “an order must be paid for before the pizza begins being made,” you have a temporal dependency. Most temporal dependencies are straightforward; they are a natural part of your business domain. (Where would you put pizza sauce and cheese without the dough, anyway?) These are not the temporal dependencies that will cause you problems. Instead, it’s the ones that aren’t always so apparent.</p>

<p class="author1">Temporal dependencies bite you the most in situations where you must do certain operations in a specific order, but you have no indication that you need to do so. Imagine if your automated pizza maker could be configured in two modes: single-pizza (for high-quality pizzas) or mass-produce (for cheap and fast pizzas). Whenever a pizza maker goes from single-pizza to mass-produce, it needs an explicit reconfiguration. If that reconfiguration doesn’t happen, the machine’s failsafe kicks in and refuses to make pizzas until a manual operator override occurs.</p>

<p class="author1">When this option is first introduced, developers take the utmost care in making sure that before any call to <code class="calibre17">mass_produce</code>, such as:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">pizza_maker</code><code class="calibre17">.</code><code class="n">mass_produce</code><code class="calibre17">(</code><code class="n">number_of_pizzas</code><code class="calibre17">=</code><code class="mi">50</code><code class="calibre17">,</code> <code class="nb">type</code><code class="calibre17">=</code><code class="n">PizzaType</code><code class="calibre17">.</code><code class="n">CHEESE</code><code class="calibre17">)</code></pre>

<p class="author1">There has to be a check:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">if</code> <code class="calibre19">not</code> <code class="n">pizza_maker</code><code class="calibre17">.</code><code class="n">is_configured</code><code class="calibre17">(</code><code class="n">ProductionType</code><code class="calibre17">.</code><code class="n">MASS_PRODUCE</code><code class="calibre17">):</code>
    <code class="n">pizza_maker</code><code class="calibre17">.</code><code class="n">configure_for_mass_production</code><code class="calibre17">()</code>
    <code class="n">pizza</code><code class="calibre17">.</code><code class="n">maker</code><code class="calibre17">.</code><code class="n">wait_for_reconfiguration</code><code class="calibre17">()</code></pre>

<p class="author1">Developers diligently look for this code in code reviews and make sure that the proper checks are always made. However, as the years go by, and developers cycle in and out of the project, the team’s knowledge of mandatory checks starts to dwindle. Imagine a newer automated pizza maker model comes to market, which doesn’t need reconfiguration (calls to <code class="calibre17">configure_for_mass_production</code> result in no change to the system). Developers who are only familiar with this new model may never think to call <code class="calibre17">configure_for_mass_production</code> in these cases.</p>

<p class="author1">Now, put yourself in a developer’s shoes a few years in the future. Let’s say you are writing new functionality for the pizza maker, and the <code class="calibre17">mass_produce</code> function fits the exact use case you need. How would you know that you need to do explicit checking for mass production, especially for older models? Unit tests won’t help you, as they don’t exist yet for the new functionality. Do you really want to wait until integration tests fail (or a customer complains) to find out that you missed that check?</p>

<p class="author1">Here are some strategies to mitigate missing such a check:</p>
<dl class="calibre13">
<dt class="calibre14">Lean on your type system</dt>
<dd class="calibre15">
<p class="calibre16">By restricting certain operations to specific types, you can prevent confusion. Imagine if <code class="calibre17">mass_produce</code> was only callable from a <code class="calibre17">MassProductionPizzaMaker</code> object. You could write function calls to make sure that a <code class="calibre17">MassProductionPizzaMaker</code> was only created after reconfiguration. You are using the type system to make it impossible to a mistake (<code class="calibre17">NewType</code> does something very similar, as described in <a data-type="xref" href="part0007_split_000.html#constraints" class="calibre5">Chapter 4</a>).</p>
</dd>
<dt class="calibre14">Embed preconditions deeper</dt>
<dd class="calibre15">
<p class="calibre16">The fact that the pizza maker <a data-type="indexterm" data-primary="preconditions" data-secondary="embedding deeper" id="idm45644732050968" class="calibre5"/>has to be configured before use is a <em class="calibre6">precondition</em>. Consider making this precondition of the <code class="calibre17">mass_produce</code> function by moving the checks inside <code class="calibre17">mass_produce</code>. Think about how you will handle error conditions (such as throwing an exception). You’ll be able to prevent violating the temporal dependency, but you’ve introduced a different error at runtime. Your specific use case will dictate what you consider to be the lesser of two evils: violating the temporal dependency or dealing with a new error case.</p>
</dd>
<dt class="calibre14">Leave breadcrumbs</dt>
<dd class="calibre15">
<p class="calibre16">This isn’t necessarily a strategy to catch a violated temporal dependency. Instead it is more of a last-ditch effort to alert developers about temporal dependencies if all other efforts fail. Try to organize temporal dependencies in the same file (ideally within a few lines of each other). Leave comments and documentation to notify future developers of this linkage. With any luck, those future developers will see the clues and know that there is a temporal dependency.</p>
</dd>
</dl>

<p class="author1">In any linear program, most lines have a temporal dependency on the lines that precede them. This is normal, and you don’t need to apply mitigations for each of these cases. Instead, look for temporal dependencies that might only be applied in certain cases (such as machine reconfiguration on older models), or temporal dependencies that are catastrophic if missed (such as not sanitizing a user input string before passing it to a database). Weigh the cost of violating a temporal dependency against the effort to detect it and mitigate it. It will depend on your use case, but when you do mitigate a temporal dependency, it can save you immense headaches later on.<a data-type="indexterm" data-primary="dependencies" data-secondary="temporal" data-startref="ix_dpndtmp" id="idm45644732045144" class="calibre5"/><a data-type="indexterm" data-primary="temporal dependencies" data-startref="ix_tmpdpnd" id="idm45644732043896" class="calibre5"/></p>
</div></section>





</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 16. Dependencies" class="preface">
<div class="preface" id="dependencies">
<section data-type="sect1" data-pdf-bookmark="Visualizing Your Dependencies" class="preface"><div class="preface" id="idm45644732156312">
<h1 class="calibre12" id="calibre_pb_7">Visualizing Your Dependencies</h1>

<p class="author1">It can be challenging to find these sorts of dependencies and understand where to look for potential problem points.<a data-type="indexterm" data-primary="dependencies" data-secondary="visualizing" id="ix_dpndvis" class="calibre5"/> Sometimes you need a more visual representation. Fortunately, tools exist to help you make sense of your dependencies visually.</p>
<div data-type="note" epub:type="note" class="calibre21"><h6 class="calibre22">Note</h6>
<p class="author1">For many of the following examples, I will be using the GraphViz library to display pictures.<a data-type="indexterm" data-primary="GraphViz library" id="idm45644732038712" class="calibre5"/> To install it, follow the instructions on the <a href="https://graphviz.org" class="calibre5">GraphViz website</a>.</p>
</div>








</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 16. Dependencies" class="preface">
<div class="preface" id="dependencies">
<section data-type="sect1" data-pdf-bookmark="Visualizing Your Dependencies" class="preface">
<div class="preface" id="idm45644732156312">
<section data-type="sect2" data-pdf-bookmark="Visualizing Packages" class="preface"><div class="preface" id="idm45644732036968">
<h2 class="calibre34" id="calibre_pb_8">Visualizing Packages</h2>

<p class="author1">Chances are, your code uses other packages, installed by pip.<a data-type="indexterm" data-primary="dependencies" data-secondary="visualizing" data-tertiary="packages" id="idm45644732035208" class="calibre5"/><a data-type="indexterm" data-primary="packages, visualizing" id="idm45644732033960" class="calibre5"/> It can be helpful to know all the packages that you depend on, their dependencies, the dependencies of those dependencies, and so on.</p>

<p class="author1">To do so, I’m going to install two packages, <code class="calibre17">pipdeptree</code> and GraphViz. <code class="calibre17">pipdeptree</code> is a useful tool to tell you how packages interact with one another, and GraphViz does the actual visualization part.<a data-type="indexterm" data-primary="pipdeptree" id="idm45644732009624" class="calibre5"/> For this example, I’ll be using the mypy codebase.<a data-type="indexterm" data-primary="virtual environment, creating" id="idm45644732008888" class="calibre5"/> I’ve downloaded the mypy source code, created a virtual environment, and installed mypy from source.<sup class="calibre11"><a data-type="noteref" id="idm45644732007976-marker" href="part0021_split_012.html#idm45644732007976" class="calibre5">2</a></sup></p>

<p class="author1">From within that virtual environment, I’ve installed <code class="calibre17">pipdeptree</code> and GraphViz:</p>

<pre data-type="programlisting" class="calibre35">pip install pipdeptree graphviz</pre>

<p class="author1">Now I run the following command:</p>

<pre data-type="programlisting" class="calibre35">pipdeptree --graph-output png --exclude pipdeptree,graphviz &gt; deps.png</pre>

<p class="author1">You can see the results in <a data-type="xref" href="part0021_split_008.html#visualizing_packages" class="calibre5">Figure 16-5</a>.</p>

<figure class="calibre36"><div id="visualizing_packages" class="figure">
<img src="../images/00024.gif" alt="Visualizing packages" class="calibre40"/>
<h6 class="calibre37"><span class="calibre">Figure 16-5. </span>Visualizing packages</h6>
</div></figure>

<p class="author1">I’m going to ignore wheel, setuptools, and pip packages, and focus on mypy. In this case, I see the exact version of mypy that is installed, as well as the direct dependencies (in this case typed_ast 1.4.2, typing-extensions 3.7.4.3, and mypy-extensions 0.4.3. <code class="calibre17">pipdeptree</code> is also nice enough to specify what version constraints exist (such as only allowing mypy-extensions to be a version greater or equal to 0.4.3, but less than 0.5.0). With these tools, you can get a handy pictorial representation of your packaged dependencies. This is extremely useful for projects with a large number of dependencies, especially if you actively maintain a lot of the packages.</p>
</div></section>













</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 16. Dependencies" class="preface">
<div class="preface" id="dependencies">
<section data-type="sect1" data-pdf-bookmark="Visualizing Your Dependencies" class="preface">
<div class="preface" id="idm45644732156312">
<section data-type="sect2" data-pdf-bookmark="Visualizing Imports" class="preface"><div class="preface" id="idm45644732036312">
<h2 class="calibre34" id="calibre_pb_9">Visualizing Imports</h2>

<p class="author1">Visualizing packages is quite a high-level view, so it helps to go one step deeper.<a data-type="indexterm" data-primary="imports, visualizing" id="idm45644731997672" class="calibre5"/><a data-type="indexterm" data-primary="dependencies" data-secondary="visualizing" data-tertiary="imports" id="idm45644731996968" class="calibre5"/> How can you find out what’s being imported at the module level? Another tool, called <code class="calibre17">pydeps</code>, is great for this.<a data-type="indexterm" data-primary="pydeps" id="idm45644731995128" class="calibre5"/></p>

<p class="author1">To install it, you can:</p>

<pre data-type="programlisting" class="calibre35">pip install pydeps</pre>

<p class="author1">Once installed, you can run:</p>

<pre data-type="programlisting" class="calibre35">pydeps --show-deps &lt;source code location&gt; -T png -o deps.png</pre>

<p class="author1">I ran this for mypy and received a very complex and dense graph. Reproducing it in print would be a waste of paper, so I’ve decided to zoom into a specific section in <a data-type="xref" href="part0021_split_009.html#visualizing_imports" class="calibre5">Figure 16-6</a>.</p>

<figure class="calibre36"><div id="visualizing_imports" class="figure">
<img src="../images/00025.jpeg" alt="Visualizing imports" class="calibre40"/>
<h6 class="calibre37"><span class="calibre">Figure 16-6. </span>Visualizing imports</h6>
</div></figure>

<p class="author1">There’s a mess of arrows going on even in this small section of the dependency graph. However, you can see that quite a few different areas of the codebase depend on <code class="calibre17">mypy.options</code>, as well as the <code class="calibre17">fastparse</code> and <code class="calibre17">errors</code> modules. Because of the size of these graphs, I recommend digging into smaller subsystems of your codebase one at a time.</p>
</div></section>













</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 16. Dependencies" class="preface">
<div class="preface" id="dependencies">
<section data-type="sect1" data-pdf-bookmark="Visualizing Your Dependencies" class="preface">
<div class="preface" id="idm45644732156312">
<section data-type="sect2" data-pdf-bookmark="Visualizing Function Calls" class="preface"><div class="preface" id="idm45644731986472">
<h2 class="calibre34" id="calibre_pb_10">Visualizing Function Calls</h2>

<p class="author1">If you want even <em class="calibre6">more</em> information than an import graph, you can see which functions call each other.<a data-type="indexterm" data-primary="dependencies" data-secondary="visualizing" data-tertiary="function calls" id="idm45644731984200" class="calibre5"/><a data-type="indexterm" data-primary="functions" data-secondary="visualizing function calls" id="idm45644731982920" class="calibre5"/> This is known as a <em class="calibre6">call graph</em>. First, I’ll look at a <em class="calibre6">static</em> call graph generator.<a data-type="indexterm" data-primary="call graphs" id="idm45644731981000" class="calibre5"/><a data-type="indexterm" data-primary="static call graph generators" id="idm45644731980264" class="calibre5"/> These generators look at your source code and see which functions call which; no code is executed. For this example, I’ll use <a data-type="indexterm" data-primary="pyan3" id="idm45644731979256" class="calibre5"/>the library pyan3, which can be installed with:</p>

<pre data-type="programlisting" class="calibre35">pip install pyan3</pre>

<p class="author1">To run pyan3, you execute the following on the command line:</p>

<pre data-type="programlisting" class="calibre35">pyan3 &lt;Python files&gt; --grouped --annotated --html &gt; deps.html</pre>

<p class="author1">When I run this on the <em class="calibre6">dmypy</em> folder inside of mypy (I picked a subfolder to limit the amount of information drawn), I receive an interactive HTML page that lets me explore the dependencies. <a data-type="xref" href="part0021_split_010.html#visualizing_static_functions" class="calibre5">Figure 16-7</a> shows a snippet from the tool.</p>

<figure class="calibre36"><div id="visualizing_static_functions" class="figure">
<img src="../images/00026.jpeg" alt="Visualizing function calls statically" class="calibre40"/>
<h6 class="calibre37"><span class="calibre">Figure 16-7. </span>Visualizing function calls statically</h6>
</div></figure>

<p class="author1">Note that this only tracks physical dependencies, as logical dependencies aren’t known until runtime. If you’d like to see a call graph at runtime, you will need to execute your code in concert with a <em class="calibre6">dynamic</em> call graph generator.<a data-type="indexterm" data-primary="dynamic call graph generators" id="idm45644731971800" class="calibre5"/> For this purpose, I like using the built-in Python profiler.<a data-type="indexterm" data-primary="profilers" id="idm45644731971032" class="calibre5"/> A <em class="calibre6">profiler</em> audits all function calls you are making during the execution of a program and records performance data. As a side benefit, the entire function call history is preserved in the profile. Let’s try this out.</p>

<p class="author1">I’ll first build the profile (I’m profiling a test file in mypy for size reasons):</p>

<pre data-type="programlisting" class="calibre35">python -m cProfile -o deps.profile mypy/test/testutil.py</pre>

<p class="author1">Then I’ll convert the profile into a file that GraphViz can understand: a dot file.</p>

<pre data-type="programlisting" class="calibre35">pip install gprof2dot
gprof2dot --format=pstats deps.profile -o deps.dot</pre>

<p class="author1">Finally, I’ll<a data-type="indexterm" data-primary="GraphViz library" data-secondary="converting .dot file to .png" id="idm45644731966520" class="calibre5"/> use GraphViz to convert the <em class="calibre6">.dot</em> file to a <em class="calibre6">.png</em>.</p>

<pre data-type="programlisting" class="calibre35">dot deps.dot -Tpng &gt; deps.png</pre>

<p class="author1">Again, this produces oodles of boxes and arrows, so <a data-type="xref" href="part0021_split_010.html#visualizing_dynamic_functions" class="calibre5">Figure 16-8</a> is just a small screenshot illustrating part of the call graph.</p>

<figure class="calibre36"><div id="visualizing_dynamic_functions" class="figure">
<img src="../images/00027.jpeg" alt="Visualizing function calls dynamically" class="calibre40"/>
<h6 class="calibre37"><span class="calibre">Figure 16-8. </span>Visualizing function calls dynamically</h6>
</div></figure>

<p class="author1">You can find out how many times the function gets called, as well as how much of the execution time was spent in the function. This can be a great way to find performance bottlenecks in addition to understanding your call graph.</p>
</div></section>













</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 16. Dependencies" class="preface">
<div class="preface" id="dependencies">
<section data-type="sect1" data-pdf-bookmark="Visualizing Your Dependencies" class="preface">
<div class="preface" id="idm45644732156312">
<section data-type="sect2" data-pdf-bookmark="Interpreting Your Dependency Graph" class="preface"><div class="preface" id="idm45644731985880">
<h2 class="calibre34" id="calibre_pb_11">Interpreting Your Dependency Graph</h2>

<p class="author1">Alright, you’ve drawn all these pretty graphs; what can you do with them? When you see your dependencies graphed out<a data-type="indexterm" data-primary="dependencies" data-secondary="visualizing" data-tertiary="interpreting your dependency graph" id="idm45644731958008" class="calibre5"/> in this fashion, you get a pretty good idea where your maintainability hotspots are. Remember, every dependency is a reason for code to change. Whenever anything changes in your codebase, it can ripple up through physical and logical dependencies, potentially impacting large swaths of code.</p>

<p class="author1">With this in mind, you need to think about the relationships between what you’re changing and the things that depend upon them. Consider the amount of code depending on you, as well as the code that you yourself depend upon. If you have a lot of dependencies coming in, but not going out, you have what’s known as high <em class="calibre6">fan-in</em>. <a data-type="indexterm" data-primary="fan-in and fan-out" id="idm45644731955128" class="calibre5"/>Conversely, if you don’t have a lot of dependencies coming in, but you depend on a large number of other entities, this is known as high <em class="calibre6">fan-out</em>. <a data-type="xref" href="part0021_split_011.html#fans" class="calibre5">Figure 16-9</a> illustrates the difference between fan-in and fan-out.</p>

<figure class="calibre36"><div id="fans" class="figure">
<img src="../images/00028.gif" alt="The difference between fan-in and fan-out" class="calibre40"/>
<h6 class="calibre37"><span class="calibre">Figure 16-9. </span>The difference between fan-in and fan-out</h6>
</div></figure>

<p class="author1">You want the entities in your system that have a high amount of fan-in to be leaves of your dependency graph, or at the bottom. Large parts of your codebase depend on these entities; every dependency you have is a dependency the rest of your codebase will have as well. You also want these entities to be stable, which means that they should be changing infrequently. Every time you introduce change, you potentially impact most of your codebase due to the large fan-in.</p>

<p class="author1">On the other hand, fan-out entities should be toward the top of your dependency graph. This is where most of your business logic will likely live; it will change as the business evolves. These parts of your codebase can withstand a much higher rate of change; due to their relatively few upstream dependencies, their code won’t break as often when behaviors change.</p>
<div data-type="warning" epub:type="warning" class="calibre23"><h6 class="calibre24">Warning</h6>
<p class="author1">Changing fan-out entities won’t impact as much of your codebase’s assumptions, but I can’t say whether or not it will break customer’s assumptions. How much you want external behavior to remain backward compatible is a UX concern and outside the scope of this book.<a data-type="indexterm" data-primary="dependencies" data-secondary="visualizing" data-startref="ix_dpndvis" id="idm45644731947768" class="calibre5"/></p>
</div>
</div></section>





</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 16. Dependencies" class="preface">
<div class="preface" id="dependencies">
<section data-type="sect1" data-pdf-bookmark="Closing Thoughts" class="preface"><div class="preface" id="idm45644731946264">
<h1 class="calibre12" id="calibre_pb_12">Closing Thoughts</h1>

<p class="author1">The presence of dependencies does not dictate how robust your code is. It’s about how you utilize and manage those dependencies.<a data-type="indexterm" data-primary="robustness" data-secondary="dependencies and" id="idm45644731944856" class="calibre5"/> Dependencies are absolutely crucial to sane reuse in your system. You can break code into smaller chunks and reorganize your codebase appropriately. By giving your dependencies the right directionality, you can actually increase the robustness of your code. You can make your code more maintainable by increasing substitutability and extensibility.</p>

<p class="author1">But, as with anything in engineering, there is always a cost. Dependencies are a <span class="calibre">coupling</span>; linking different parts of your codebase together and making changes can <span class="calibre">have a wider</span> impact than you might be looking for. There are different types of <span class="calibre">dependencies</span> that must be handled in different ways. Physical dependencies are easy to visualize through tooling, but are also rigid in the structure they impose. Logical dependencies provide an extensibility to your codebase, but their nature is hidden until runtime. Temporal dependencies are a necessary part of executing Python in a linear fashion, but when those dependencies become unintuitive, they incur a ton of future pain.</p>

<p class="author1">All of these lessons assume that you have pieces of code that you can depend upon. In the next chapter, you’ll explore <em class="calibre6">composable code</em>, or breaking code into smaller pieces for reuse. You’ll learn how to compose objects, looping patterns, and functions to reorganize your code into new use cases. When you think in terms of composable code, you’ll start building in new functionality with ease. Your future maintainers will thank you.<a data-type="indexterm" data-primary="dependencies" data-startref="ix_dpnd" id="idm45644731938840" class="calibre5"/></p>
</div></section>







<div data-type="footnotes" class="calibre25"><p data-type="footnote" id="idm45644732269304" class="calibre26"><sup class="calibre27"><a href="part0021_split_001.html#idm45644732269304-marker" class="calibre5">1</a></sup> Eric S. Raymond. <em class="calibre6">The Cathedral &amp; the Bazaar</em>. Sebastopol, CA: O’Reilly Media, 2001.</p><p data-type="footnote" id="idm45644732007976" class="calibre26"><sup class="calibre27"><a href="part0021_split_008.html#idm45644732007976-marker" class="calibre5">2</a></sup> Creating a virtual environment is a great way to isolate your dependencies from your system’s Python <span class="calibre">installation</span>.</p></div></div></section></body></html>