- en: Chapter 21\. Asynchronous Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第21章。异步编程
- en: The problem with normal approaches to asynchronous programming is that they’re
    all-or-nothing propositions. You rewrite all your code so none of it blocks or
    you’re just wasting your time.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 异步编程的常规方法的问题在于它们是全有或全无的命题。你要么重写所有代码以便没有阻塞，要么你只是在浪费时间。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Alvaro Videla and Jason J. W. Williams, *RabbitMQ in Action*^([1](ch21.html#idm46582386210816))
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Alvaro Videla和Jason J. W. Williams，《RabbitMQ实战》^([1](ch21.html#idm46582386210816))
- en: 'This chapter addresses three major topics that are closely related:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涉及三个密切相关的主题：
- en: Python’s `async def`, `await`, `async with`, and `async for` constructs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python的`async def`，`await`，`async with`和`async for`构造
- en: 'Objects supporting those constructs: native coroutines and asynchronous variants
    of context managers, iterables, generators, and comprehensions'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持这些构造的对象：原生协程和异步上下文管理器、可迭代对象、生成器和推导式的异步变体
- en: '*asyncio* and other asynchronous libraries'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*asyncio*和其他异步库'
- en: This chapter builds on the ideas of iterables and generators ([Chapter 17](ch17.html#iterables2generators),
    in particular [“Classic Coroutines”](ch17.html#classic_coroutines_sec)), context
    managers ([Chapter 18](ch18.html#with_match_ch)), and general concepts of concurrent
    programming ([Chapter 19](ch19.html#concurrency_models_ch)).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章建立在可迭代对象和生成器的思想上（[第17章](ch17.html#iterables2generators)，特别是[“经典协程”](ch17.html#classic_coroutines_sec)），上下文管理器（[第18章](ch18.html#with_match_ch)），以及并发编程的一般概念（[第19章](ch19.html#concurrency_models_ch)）。
- en: We’ll study concurrent HTTP clients similar to the ones we saw in [Chapter 20](ch20.html#futures_ch),
    rewritten with native coroutines and asynchronous context managers, using the
    same *HTTPX* library as before, but now through its asynchronous API. We’ll also
    see how to avoid blocking the event loop by delegating slow operations to a thread
    or process executor.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究类似于我们在[第20章](ch20.html#futures_ch)中看到的并发HTTP客户端，使用原生协程和异步上下文管理器进行重写，使用与之前相同的*HTTPX*库，但现在通过其异步API。我们还将看到如何通过将慢速操作委托给线程或进程执行器来避免阻塞事件循环。
- en: 'After the HTTP client examples, we’ll see two simple asynchronous server-side
    applications, one of them using the increasingly popular *FastAPI* framework.
    Then we’ll cover other language constructs enabled by the `async/await` keywords:
    asynchronous generator functions, asynchronous comprehensions, and asynchronous
    generator expressions. To emphasize the fact that those language features are
    not tied to *asyncio*, we’ll see one example rewritten to use *Curio*—the elegant
    and innovative asynchronous framework invented by David Beazley.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTTP客户端示例之后，我们将看到两个简单的异步服务器端应用程序，其中一个使用越来越受欢迎的*FastAPI*框架。然后我们将介绍由`async/await`关键字启用的其他语言构造：异步生成器函数，异步推导式和异步生成器表达式。为了强调这些语言特性与*asyncio*无关的事实，我们将看到一个示例被重写以使用*Curio*——由David
    Beazley发明的优雅而创新的异步框架。
- en: To wrap up the chapter, I wrote a brief section on the advantages and pitfalls
    of asynchronous programming.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我写了一个简短的部分来总结异步编程的优势和陷阱。
- en: That’s a lot of ground to cover. We only have space for basic examples, but
    they will illustrate the most important features of each idea.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很多内容要涵盖的。我们只有空间来展示基本示例，但它们将说明每个想法的最重要特点。
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The [*asyncio* documentation](https://fpy.li/21-1) is much better after Yury
    Selivanov^([2](ch21.html#idm46582386189120)) reorganized it, separating the few
    functions useful to application developers from the low-level API for creators
    of packages like web frameworks and database drivers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[*asyncio*文档](https://fpy.li/21-1)在Yury Selivanov^([2](ch21.html#idm46582386189120))重新组织后要好得多，将对应用程序开发者有用的少数函数与用于创建诸如Web框架和数据库驱动程序的低级API分开。'
- en: 'For book-length coverage of *asyncio*, I recommend [*Using Asyncio in Python*](https://fpy.li/hattingh)
    by Caleb Hattingh (O’Reilly). Full disclosure: Caleb is one of the tech reviewers
    of this book.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*asyncio*的书籍长度覆盖，我推荐Caleb Hattingh（O’Reilly）的[*在Python中使用Asyncio*](https://fpy.li/hattingh)。完全透明：Caleb是本书的技术审阅者之一。
- en: What’s New in This Chapter
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章的新内容
- en: 'When I wrote the first edition of *Fluent Python*, the *asyncio* library was
    provisional and the `async/await` keywords did not exist. Therefore, I had to
    update all examples in this chapter. I also created new examples: domain probing
    scripts, a *FastAPI* web service, and experiments with Python’s new asynchronous
    console mode.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我写第一版*流畅的Python*时，*asyncio*库是临时的，`async/await`关键字不存在。因此，我不得不更新本章中的所有示例。我还创建了新的示例：域探测脚本，*FastAPI*网络服务以及与Python的新异步控制台模式的实验。
- en: New sections cover language features that did not exist at the time, such as
    native coroutines, `async with`, `async for`, and the objects that support those
    constructs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 新的章节涵盖了当时不存在的语言特性，如原生协程、`async with`、`async for`以及支持这些构造的对象。
- en: The ideas in [“How Async Works and How It Doesn’t”](#how_async_works_and_does_not_sec)
    reflect hard-earned lessons that I consider essential reading for anyone using
    asynchronous programming. They may save you a lot of trouble—whether you’re using
    Python or Node.js.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[“异步工作原理及其不足之处”](#how_async_works_and_does_not_sec)中的思想反映了我认为对于任何使用异步编程的人来说都是必读的艰辛经验。它们可能会为你节省很多麻烦——无论你是使用Python还是Node.js。'
- en: Finally, I removed several paragraphs about `asyncio.Futures`, which is now
    considered part of the low-level *asyncio* APIs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我删除了关于`asyncio.Futures`的几段内容，这现在被认为是低级*asyncio*API的一部分。
- en: A Few Definitions
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些定义
- en: 'At the start of [“Classic Coroutines”](ch17.html#classic_coroutines_sec), we
    saw that Python 3.5 and later offer three kinds of coroutines:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“经典协程”](ch17.html#classic_coroutines_sec)的开头，我们看到Python 3.5及更高版本提供了三种协程类型：
- en: Native coroutine
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 原生协程
- en: A coroutine function defined with `async def`. You can delegate from a native
    coroutine to another native coroutine using the `await` keyword, similar to how
    classic coroutines use `yield from`. The `async def` statement always defines
    a native coroutine, even if the `await` keyword is not used in its body. The `await`
    keyword cannot be used outside of a native coroutine.^([3](ch21.html#idm46582386163264))
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`async def`定义的协程函数。您可以使用`await`关键字从一个本机协程委托到另一个本机协程，类似于经典协程使用`yield from`。`async
    def`语句始终定义一个本机协程，即使在其主体中未使用`await`关键字。`await`关键字不能在本机协程之外使用。^([3](ch21.html#idm46582386163264))
- en: Classic coroutine
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 经典协程
- en: A generator function that consumes data sent to it via `my_coro.send(data)`
    calls, and reads that data by using `yield` in an expression. Classic coroutines
    can delegate to other classic coroutines using `yield from`. Classic coroutines
    cannot be driven by `await`, and are no longer supported by *asyncio*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个生成器函数，通过`my_coro.send(data)`调用接收发送给它的数据，并通过在表达式中使用`yield`来读取该数据。经典协程可以使用`yield
    from`委托给其他经典协程。经典协程不能由`await`驱动，并且不再受*asyncio*支持。
- en: Generator-based coroutine
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 基于生成器的协程
- en: A generator function decorated with `@types.coroutine`—introduced in Python
    3.5. That decorator makes the generator compatible with the new `await` keyword.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@types.coroutine`装饰的生成器函数—在Python 3.5中引入。该装饰器使生成器与新的`await`关键字兼容。
- en: 'In this chapter, we focus on native coroutines as well as *asynchronous generators*:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于本机协程以及*异步生成器*：
- en: Asynchronous generator
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 异步生成器
- en: A generator function defined with `async def` and using `yield` in its body.
    It returns an asynchronous generator object that provides `__anext__`, a coroutine
    method to retrieve the next item.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`async def`定义的生成器函数，在其主体中使用`yield`。它返回一个提供`__anext__`的异步生成器对象，这是一个用于检索下一个项目的协程方法。
- en: '@asyncio.coroutine has No Future^([4](ch21.html#idm46582386145744))'
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@asyncio.coroutine没有未来^([4](ch21.html#idm46582386145744))'
- en: The `@asyncio.coroutine` decorator for classic coroutines and generator-based
    coroutines was deprecated in Python 3.8 and is scheduled for removal in Python
    3.11, according to [Issue 43216](https://fpy.li/21-2). In contrast, `@types.coroutine`
    should remain, per [Issue 36921](https://fpy.li/21-3). It is no longer supported
    by *asyncio*, but is used in low-level code in the *Curio* and *Trio* asynchronous
    frameworks.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于经典协程和基于生成器的协程，`@asyncio.coroutine`装饰器在Python 3.8中已被弃用，并计划在Python 3.11中删除，根据[Issue
    43216](https://fpy.li/21-2)。相反，根据[Issue 36921](https://fpy.li/21-3)，`@types.coroutine`应该保留。它不再受*asyncio*支持，但在*Curio*和*Trio*异步框架的低级代码中使用。
- en: 'An asyncio Example: Probing Domains'
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个异步示例：探测域名
- en: 'Imagine you are about to start a new blog on Python, and you plan to register
    a domain using a Python keyword and the *.DEV* suffix—for example: *AWAIT.DEV.*
    [Example 21-1](#blogdom_ex) is a script using *asyncio* to check several domains
    concurrently. This is the output it produces:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你即将在Python上开始一个新博客，并计划注册一个使用Python关键字和*.DEV*后缀的域名，例如：*AWAIT.DEV.* [示例21-1](#blogdom_ex)
    是一个使用*asyncio*检查多个域名的脚本。这是它产生的输出：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that the domains appear unordered. If you run the script, you’ll see them
    displayed one after the other, with varying delays. The `+` sign indicates your
    machine was able to resolve the domain via DNS. Otherwise, the domain did not
    resolve and may be available.^([5](ch21.html#idm46582386094176))
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，域名是无序的。如果运行脚本，您将看到它们一个接一个地显示，延迟不同。`+`符号表示您的计算机能够通过DNS解析域名。否则，该域名未解析，可能可用。^([5](ch21.html#idm46582386094176))
- en: In *blogdom.py*, the DNS probing is done via native coroutine objects. Because
    the asynchronous operations are interleaved, the time needed to check the 18 domains
    is much less than checking them sequentially. In fact, the total time is practically
    the same as the time for the single slowest DNS response, instead of the sum of
    the times of all responses.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在*blogdom.py*中，DNS探测通过本机协程对象完成。由于异步操作是交错进行的，检查这18个域名所需的时间远远少于按顺序检查它们所需的时间。实际上，总时间几乎与单个最慢的DNS响应的时间相同，而不是所有响应时间的总和。
- en: '[Example 21-1](#blogdom_ex) shows the code for *blogdom.py*.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例21-1](#blogdom_ex)显示了*blogdom.py*的代码。'
- en: 'Example 21-1\. blogdom.py: search for domains for a Python blog'
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例21-1\. blogdom.py：搜索Python博客的域名
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_asynchronous_programming_CO1-1)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_programming_CO1-1)'
- en: Set maximum length of keyword for domains, because shorter is better.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 设置域名关键字的最大长度，因为长度较短更好。
- en: '[![2](assets/2.png)](#co_asynchronous_programming_CO1-2)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_programming_CO1-2)'
- en: '`probe` returns a tuple with the domain name and a boolean; `True` means the
    domain resolved. Returning the domain name will make it easier to display the
    results.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`probe`返回一个包含域名和布尔值的元组；`True`表示域名已解析。返回域名将使显示结果更容易。'
- en: '[![3](assets/3.png)](#co_asynchronous_programming_CO1-3)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_programming_CO1-3)'
- en: Get a reference to the `asyncio` event loop, so we can use it next.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 获取对`asyncio`事件循环的引用，以便我们可以在下一步中使用它。
- en: '[![4](assets/4.png)](#co_asynchronous_programming_CO1-4)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asynchronous_programming_CO1-4)'
- en: The [`loop.getaddrinfo(…)`](https://fpy.li/21-4) coroutine-method returns a
    [five-part tuple of parameters](https://fpy.li/21-5) to connect to the given address
    using a socket. In this example, we don’t need the result. If we got it, the domain
    resolves; otherwise, it doesn’t.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[`loop.getaddrinfo(…)`](https://fpy.li/21-4)协程方法返回一个[五部分参数元组](https://fpy.li/21-5)，以使用套接字连接到给定地址。在这个例子中，我们不需要结果。如果我们得到了结果，域名就解析了；否则，它没有解析。'
- en: '[![5](assets/5.png)](#co_asynchronous_programming_CO1-5)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asynchronous_programming_CO1-5)'
- en: '`main` must be a coroutine, so that we can use `await` in it.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`必须是一个协程，这样我们就可以在其中使用`await`。'
- en: '[![6](assets/6.png)](#co_asynchronous_programming_CO1-6)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_asynchronous_programming_CO1-6)'
- en: Generator to yield Python keywords with length up to `MAX_KEYWORD_LEN`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器以不超过`MAX_KEYWORD_LEN`长度的Python关键字。
- en: '[![7](assets/7.png)](#co_asynchronous_programming_CO1-7)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_asynchronous_programming_CO1-7)'
- en: Generator to yield domain names with the `.dev` suffix.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器以`.dev`后缀的域名为结果。
- en: '[![8](assets/8.png)](#co_asynchronous_programming_CO1-8)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_asynchronous_programming_CO1-8)'
- en: Build a list of coroutine objects by invoking the `probe` coroutine with each
    `domain` argument.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`probe`协程调用每个`domain`参数来构建协程对象列表。
- en: '[![9](assets/9.png)](#co_asynchronous_programming_CO1-9)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_asynchronous_programming_CO1-9)'
- en: '`asyncio.as_completed` is a generator that yields coroutines that return the
    results of the coroutines passed to it in the order they are completed—not the
    order they were submitted. It’s similar to `futures.as_completed`, which we saw
    in [Chapter 20](ch20.html#futures_ch), [Example 20-4](ch20.html#flags_threadpool_futures_ex).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio.as_completed`是一个生成器，按照完成的顺序而不是提交的顺序，产生传递给它的协程的结果。它类似于我们在[第20章](ch20.html#futures_ch)中看到的`futures.as_completed`，[示例20-4](ch20.html#flags_threadpool_futures_ex)。'
- en: '[![10](assets/10.png)](#co_asynchronous_programming_CO1-10)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](assets/10.png)](#co_asynchronous_programming_CO1-10)'
- en: At this point, we know the coroutine is done because that’s how `as_completed`
    works. Therefore, the `await` expression will not block but we need it to get
    the result from `coro`. If `coro` raised an unhandled exception, it would be re-raised
    here.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一步，我们知道协程已经完成，因为这就是`as_completed`的工作原理。因此，`await`表达式不会阻塞，但我们需要它来获取`coro`的结果。如果`coro`引发了未处理的异常，它将在这里重新引发。
- en: '[![11](assets/11.png)](#co_asynchronous_programming_CO1-11)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[![11](assets/11.png)](#co_asynchronous_programming_CO1-11)'
- en: '`asyncio.run` starts the event loop and returns only when the event loop exits.
    This is a common pattern for scripts that use `asyncio`: implement `main` as a
    coroutine, and drive it with `asyncio.run` inside the `if __name__ == ''__main__'':`
    block.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio.run`启动事件循环，并仅在事件循环退出时返回。这是使用`asyncio`的脚本的常见模式：将`main`实现为协程，并在`if __name__
    == ''__main__'':`块中使用`asyncio.run`来驱动它。'
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The `asyncio.get_running_loop` function was added in Python 3.7 for use inside
    coroutines, as shown in `probe`. If there’s no running loop, `asyncio.get_running_loop`
    raises `RuntimeError`. Its implementation is simpler and faster than `asyncio.get_event_loop`,
    which may start an event loop if necessary. Since Python 3.10, `asyncio.get_event_loop`
    is [deprecated](https://fpy.li/21-6) and will eventually become an alias to `asyncio.get_running_loop`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio.get_running_loop`函数在Python 3.7中添加，用于在协程内部使用，如`probe`所示。如果没有运行的循环，`asyncio.get_running_loop`会引发`RuntimeError`。它的实现比`asyncio.get_event_loop`更简单更快，后者可能在必要时启动事件循环。自Python
    3.10起，`asyncio.get_event_loop`已被[弃用](https://fpy.li/21-6)，最终将成为`asyncio.get_running_loop`的别名。'
- en: Guido’s Trick to Read Asynchronous Code
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Guido的阅读异步代码的技巧
- en: 'There are a lot of new concepts to grasp in *asyncio*, but the overall logic
    of [Example 21-1](#blogdom_ex) is easy to follow if you employ a trick suggested
    by Guido van Rossum himself: squint and pretend the `async` and `await` keywords
    are not there. If you do that, you’ll realize that coroutines read like plain
    old sequential functions.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在*asyncio*中有很多新概念需要掌握，但如果你采用Guido van Rossum本人建议的技巧：眯起眼睛，假装`async`和`await`关键字不存在，那么你会意识到协程读起来就像普通的顺序函数。
- en: For example, imagine that the body of this coroutine…
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下这个协程的主体…
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '…works like the following function, except that it magically never blocks:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: …的工作方式类似于以下函数，只是它神奇地永远不会阻塞：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using the syntax `await loop.getaddrinfo(...)` avoids blocking because `await`
    suspends the current coroutine object. For example, during the execution of the
    `probe('if.dev')` coroutine, a new coroutine object is created by `getaddrinfo('if.dev',
    None)`. Awaiting it starts the low-level `addrinfo` query and yields control back
    to the event loop, not to the `probe(‘if.dev’)` coroutine, which is suspended.
    The event loop can then drive other pending coroutine objects, such as `probe('or.dev')`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用语法`await loop.getaddrinfo(...)`避免阻塞，因为`await`挂起当前协程对象。例如，在执行`probe('if.dev')`协程期间，`getaddrinfo('if.dev',
    None)`创建了一个新的协程对象。等待它会启动低级`addrinfo`查询，并将控制权返回给事件循环，而不是`suspend`的`probe(‘if.dev’)`协程。事件循环然后可以驱动其他待处理的协程对象，比如`probe('or.dev')`。
- en: When the event loop gets a response for the `getaddrinfo('if.dev', None)` query,
    that specific coroutine object resumes and returns control back to the `probe('if.dev')`—which
    was suspended at `await`—and can now handle a possible exception and return the
    result tuple.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件循环收到`getaddrinfo('if.dev', None)`查询的响应时，特定的协程对象恢复并将控制返回给`suspend`在`await`处的`probe('if.dev')`，现在可以处理可能的异常并返回结果元组。
- en: So far, we’ve only seen `asyncio.as_completed` and `await` applied to coroutines.
    But they handle any *awaitable* object. That concept is explained next.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到`asyncio.as_completed`和`await`应用于协程。但它们处理任何*可等待对象*。下面将解释这个概念。
- en: 'New Concept: Awaitable'
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新概念：可等待对象
- en: The `for` keyword works with *iterables*. The `await` keyword works with *awaitables*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 关键字与*可迭代对象*一起使用。`await` 关键字与*可等待对象*一起使用。'
- en: 'As an end user of *asyncio*, these are the awaitables you will see on a daily
    basis:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 作为*asyncio*的最终用���，这些是你每天会看到的可等待对象：
- en: A *native coroutine object*, which you get by calling a *native coroutine function*
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*本机协程对象*，通过调用*本机协程函数*来获得
- en: An `asyncio.Task`, which you usually get by passing a coroutine object to `asyncio.create_task()`
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`asyncio.Task`，通常通过将协程对象传递给`asyncio.create_task()`来获得
- en: However, end-user code does not always need to `await` on a `Task`. We use `asyncio.create_task(one_coro())`
    to schedule `one_coro` for concurrent execution, without waiting for its return.
    That’s what we did with the `spinner` coroutine in *spinner_async.py* ([Example 19-4](ch19.html#spinner_async_start_ex)).
    If you don’t expect to cancel the task or wait for it, there is no need to keep
    the `Task` object returned from `create_task`. Creating the task is enough to
    schedule the coroutine to run.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最终用户代码并不总是需要在`Task`上`await`。我们使用`asyncio.create_task(one_coro())`来安排`one_coro`以并发执行，而无需等待其返回。这就是我们在*spinner_async.py*中对`spinner`协程所做的事情（[示例19-4](ch19.html#spinner_async_start_ex)）。如果你不打算取消任务或等待它，就没有必要保留从`create_task`返回的`Task`对象。创建任务足以安排协程运行。
- en: In contrast, we use `await other_coro()` to run `other_coro` right now and wait
    for its completion because we need its result before we can proceed. In *spinner_async.py*,
    the `supervisor` coroutine did `res = await slow()` to execute `slow` and get
    its result.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，我们使用`await other_coro()`来立即运行`other_coro`并等待其完成，因为我们需要它的结果才能继续。在*spinner_async.py*中，`supervisor`协程执行了`res
    = await slow()`来执行`slow`并获取其结果。
- en: 'When implementing asynchronous libraries or contributing to *asyncio* itself,
    you may also deal with these lower-level awaitables:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现异步库或为*asyncio*本身做贡献时，您可能还会处理这些更低级别的可等待对象：
- en: An object with an `__await__` method that returns an iterator; for example,
    an `asyncio.Future` instance (`asyncio.Task` is a subclass of `asyncio.Future`)
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有返回迭代器的`__await__`方法的对象；例如，一个`asyncio.Future`实例（`asyncio.Task`是`asyncio.Future`的子类）
- en: Objects written in other languages using the Python/C API with a `tp_as_async.am_await`
    function, returning an iterator (similar to `__await__` method)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python/C API编写的对象具有`tp_as_async.am_await`函数，返回一个迭代器（类似于`__await__`方法）
- en: 'Existing codebases may also have one additional kind of awaitable: *generator-based
    coroutine objects*—which are in the process of being deprecated.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的代码库可能还有一种额外的可等待对象：*基于生成器的协程对象*—正在被弃用中。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: PEP 492 [states](https://fpy.li/21-7) that the `await` expression “uses the
    `yield from` implementation with an extra step of validating its argument” and
    “`await` only accepts an awaitable.” The PEP does not explain that implementation
    in detail, but refers to [PEP 380](https://fpy.li/pep380), which introduced `yield
    from`. I posted a detailed explanation in [“Classic Coroutines”](https://fpy.li/oldcoro),
    section [“The Meaning of yield from”](https://fpy.li/21-8), at [*fluentpython.com*](http://fluentpython.com).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 492 [指出](https://fpy.li/21-7)，`await`表达式“使用`yield from`实现，并增加了验证其参数的额外步骤”，“`await`只接受可等待对象”。PEP没有详细解释该实现，但参考了[PEP
    380](https://fpy.li/pep380)，该PEP引入了`yield from`。我在[*fluentpython.com*](http://fluentpython.com)的[“经典协程”](https://fpy.li/oldcoro)部分的[“yield
    from的含义”](https://fpy.li/21-8)中发布了详细解释。
- en: Now let’s study the *asyncio* version of a script that downloads a fixed set
    of flag images.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来学习一个下载固定一组国旗图像的脚本的*asyncio*版本。
- en: Downloading with asyncio and HTTPX
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用asyncio和HTTPX进行下载
- en: The *flags_asyncio.py* script downloads a fixed set of 20 flags from *fluentpython.com*.
    We first mentioned it in [“Concurrent Web Downloads”](ch20.html#ex_web_downloads_sec),
    but now we’ll study it in detail, applying the concepts we just saw.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*flags_asyncio.py*脚本从*fluentpython.com*下载了一组固定的20个国旗。我们在[“并发网络下载”](ch20.html#ex_web_downloads_sec)中首次提到它，但现在我们将详细研究它，应用我们刚刚看到的概念。'
- en: As of Python 3.10, *asyncio* only supports TCP and UDP directly, and there are
    no asynchronous HTTP client or server packages in the standard library. I am using
    [*HTTPX*](https://fpy.li/httpx) in all the HTTP client examples.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 截至Python 3.10，*asyncio*仅直接支持TCP和UDP，标准库中没有异步HTTP客户端或服务器包。我在所有HTTP客户端示例中使用[*HTTPX*](https://fpy.li/httpx)。
- en: We’ll explore *flags_asyncio.py* from the bottom up—that is, looking first at
    the functions that set up the action in [Example 21-2](#flags_asyncio_start_ex).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从底向上探索*flags_asyncio.py*，即首先查看在[示例21-2](#flags_asyncio_start_ex)中设置操作的函数。
- en: Warning
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: To make the code easier to read, *flags_asyncio.py* has no error handling. As
    we introduce `async/await`, it’s useful to focus on the “happy path” initially,
    to understand how regular functions and coroutines are arranged in a program.
    Starting with [“Enhancing the asyncio Downloader”](#flags2_asyncio_sec), the examples
    include error handling and more features.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码更易于阅读，*flags_asyncio.py*没有错误处理。随着我们引入`async/await`，最初专注于“快乐路径”是有用的，以了解如何在程序中安排常规函数和协程。从[“增强asyncio下载器”](#flags2_asyncio_sec)开始，示例包括错误处理和更多功能。
- en: The *flags_.py* examples from this chapter and [Chapter 20](ch20.html#futures_ch)
    share code and data, so I put them together in the [*example-code-2e/20-executors/getflags*](https://fpy.li/21-9)
    directory.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和[第20章](ch20.html#futures_ch)中的*flags_.py*示例共享代码和数据，因此我将它们放在[*example-code-2e/20-executors/getflags*](https://fpy.li/21-9)目录中。
- en: 'Example 21-2\. flags_asyncio.py: startup functions'
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 21-2\. flags_asyncio.py：启动函数
- en: '[PRE4]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_asynchronous_programming_CO2-1)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_programming_CO2-1)'
- en: This needs to be a plain function—not a coroutine—so it can be passed to and
    called by the `main` function from the *flags.py* module ([Example 20-2](ch20.html#flags_module_ex)).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要是一个普通函数—而不是协程—这样它就可以被*flags.py*模块的`main`函数传递和调用（[示例20-2](ch20.html#flags_module_ex)）。
- en: '[![2](assets/2.png)](#co_asynchronous_programming_CO2-2)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_programming_CO2-2)'
- en: Execute the event loop driving the `supervisor(cc_list)` coroutine object until
    it returns. This will block while the event loop runs. The result of this line
    is whatever `supervisor` returns.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 执行驱动`supervisor(cc_list)`协程对象的事件循环，直到其返回。这将在事件循环运行时阻塞。此行的结果是`supervisor`的返回值。
- en: '[![3](assets/3.png)](#co_asynchronous_programming_CO2-3)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_programming_CO2-3)'
- en: 'Asynchronous HTTP client operations in `httpx` are methods of `AsyncClient`,
    which is also an asynchronous context manager: a context manager with asynchronous
    setup and teardown methods (more about this in [“Asynchronous Context Managers”](#async_context_manager_sec)).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`httpx`中的异步HTTP客户端操作是`AsyncClient`的方法，它也是一个异步上下文管理器：具有异步设置和拆卸方法的上下文管理器（有关更多信息，请参阅[“异步上下文管理器”](#async_context_manager_sec)）。'
- en: '[![4](assets/4.png)](#co_asynchronous_programming_CO2-4)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asynchronous_programming_CO2-4)'
- en: Build a list of coroutine objects by calling the `download_one` coroutine once
    for each flag to be retrieved.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为每个要检索的国旗调用一次`download_one`协程来构建协程对象列表。
- en: '[![5](assets/5.png)](#co_asynchronous_programming_CO2-5)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asynchronous_programming_CO2-5)'
- en: Wait for the `asyncio.gather` coroutine, which accepts one or more awaitable
    arguments and waits for all of them to complete, returning a list of results for
    the given awaitables in the order they were submitted.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 等待`asyncio.gather`协程，它接受一个或多个可等待参数，并等待它们全部完成，按照提交的可等待对象的顺序返回结果列表。
- en: '[![6](assets/6.png)](#co_asynchronous_programming_CO2-6)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_asynchronous_programming_CO2-6)'
- en: '`supervisor` returns the length of the list returned by `asyncio.gather`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`supervisor`返回`asyncio.gather`返回的列表的长度。'
- en: Now let’s review the top of *flags_asyncio.py* ([Example 21-3](#flags_asyncio_ex)).
    I reorganized the coroutines so we can read them in the order they are started
    by the event loop.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回顾*flags_asyncio.py*的顶部（[示例 21-3](#flags_asyncio_ex)）。我重新组织了协程，以便我们可以按照它们被事件循环启动的顺序来阅读它们。
- en: 'Example 21-3\. flags_asyncio.py: imports and download functions'
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 21-3\. flags_asyncio.py：导入和下载函数
- en: '[PRE5]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_asynchronous_programming_CO3-1)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_programming_CO3-1)'
- en: '`httpx` must be installed—it’s not in the standard library.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 必须安装`httpx`——它不在标准库中。
- en: '[![2](assets/2.png)](#co_asynchronous_programming_CO3-2)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_programming_CO3-2)'
- en: Reuse code from *flags.py* ([Example 20-2](ch20.html#flags_module_ex)).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从*flags.py*（[示例 20-2](ch20.html#flags_module_ex)）中重用代码。
- en: '[![3](assets/3.png)](#co_asynchronous_programming_CO3-3)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_programming_CO3-3)'
- en: '`download_one` must be a native coroutine, so it can `await` on `get_flag`—which
    does the HTTP request. Then it displays the code of the downloaded flag, and saves
    the image.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`download_one`必须是一个原生协程，这样它就可以`await`在`get_flag`上——后者执行HTTP请求。然后显示下载标志的代码，并保存图像。'
- en: '[![4](assets/4.png)](#co_asynchronous_programming_CO3-4)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asynchronous_programming_CO3-4)'
- en: '`get_flag` needs to receive the `AsyncClient` to make the request.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_flag`需要接收`AsyncClient`来发起请求。'
- en: '[![5](assets/5.png)](#co_asynchronous_programming_CO3-5)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asynchronous_programming_CO3-5)'
- en: The `get` method of an `httpx.AsyncClient` instance returns a `ClientResponse`
    object that is also an asynchronous context manager.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`httpx.AsyncClient`实例的`get`方法返回一个`ClientResponse`对象，也是一个异步上下文管理器。'
- en: '[![6](assets/6.png)](#co_asynchronous_programming_CO3-6)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_asynchronous_programming_CO3-6)'
- en: Network I/O operations are implemented as coroutine methods, so they are driven
    asynchronously by the `asyncio` event loop.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 网络I/O操作被实现为协程方法，因此它们由`asyncio`事件循环异步驱动。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For better performance, the `save_flag` call inside `get_flag` should be asynchronous,
    to avoid blocking the event loop. However, *asyncio* does not provide an asynchronous
    filesystem API at this time—as Node.js does.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高性能，`get_flag`内部的`save_flag`调用应该是异步的，以避免阻塞事件循环。然而，*asyncio*目前并没有像Node.js那样提供异步文件系统API。
- en: '[“Using asyncio.as_completed and a Thread”](#using_as_completed_sec) will show
    how to delegate `save_flag` to a thread.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[“使用asyncio.as_completed和线程”](#using_as_completed_sec)将展示如何将`save_flag`委托给一个线程。'
- en: Your code delegates to the `httpx` coroutines explicitly through `await` or
    implicitly through the special methods of the asynchronous context managers, such
    as `Async​Client` and `ClientResponse`—as we’ll see in [“Asynchronous Context
    Managers”](#async_context_manager_sec).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码通过`await`显式委托给`httpx`协程，或通过异步上下文管理器的特殊方法（如`Async​Client`和`ClientResponse`）隐式委托，正如我们将在[“异步上下文管理器”](#async_context_manager_sec)中看到的那样。
- en: 'The Secret of Native Coroutines: Humble Generators'
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地协程的秘密：谦逊的生成器
- en: A key difference between the classic coroutine examples we saw in [“Classic
    Coroutines”](ch17.html#classic_coroutines_sec) and *flags_asyncio.py* is that
    there are no visible `.send()` calls or `yield` expressions in the latter. Your
    code sits between the *asyncio* library and the asynchronous libraries you are
    using, such as *HTTPX*. This is illustrated in [Figure 21-1](#await_channel_fig).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[“经典协程”](ch17.html#classic_coroutines_sec)中看到的经典协程示例与*flags_asyncio.py*之间的一个关键区别是后者中没有可见的`.send()`调用或`yield`表达式。您的代码位于*asyncio*库和您正在使用的异步库（如*HTTPX*）之间，这在[图
    21-1](#await_channel_fig)中有所说明。
- en: '![Await channel diagram](assets/flpy_2101.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![等待通道图示](assets/flpy_2101.png)'
- en: Figure 21-1\. In an asynchronous program, a user’s function starts the event
    loop, scheduling an initial coroutine with `asyncio.run`. Each user’s coroutine
    drives the next with an `await` expression, forming a channel that enables communication
    between a library like *HTTPX* and the event loop.
  id: totrans-132
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 21-1\. 在异步程序中，用户的函数启动事件循环，使用`asyncio.run`调度初始协程。每个用户的协程通过`await`表达式驱动下一个协程，形成一个通道，使得像*HTTPX*这样的库与事件循环之间能够进行通信。
- en: Under the hood, the `asyncio` event loop makes the `.send` calls that drive
    your coroutines, and your coroutines `await` on other coroutines, including library
    coroutines. As mentioned, `await` borrows most of its implementation from `yield
    from`, which also makes `.send` calls to drive coroutines.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`asyncio`事件循环进行`.send`调用来驱动您的协程，您的协程`await`其他协程，包括库协程。正如前面提到的，`await`大部分实现来自`yield
    from`，后者也进行`.send`调用来驱动协程。
- en: The `await` chain eventually reaches a low-level awaitable, which returns a
    generator that the event loop can drive in response to events such as timers or
    network I/O. The low-level awaitables and generators at the end of these `await`
    chains are implemented deep into the libraries, are not part of their APIs, and
    may be Python/C extensions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`await`链最终会到达一个低级可等待对象，它返回一个生成器，事件循环可以响应诸如计时器或网络I/O之类的事件来驱动它。这些`await`链末端的低级可等待对象和生成器深入到库中实现，不是其API的一部分，可能是Python/C扩展。'
- en: Using functions like `asyncio.gather` and `asyncio.create_task`, you can start
    multiple concurrent `await` channels, enabling concurrent execution of multiple
    I/O operations driven by a single event loop, in a single thread.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`asyncio.gather`和`asyncio.create_task`等函数，您可以启动多个并发的`await`通道，实现由单个事件循环在单个线程驱动的多个I/O操作的并发执行。
- en: The All-or-Nothing Problem
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一切或无事可做问题
- en: Note that in [Example 21-3](#flags_asyncio_ex), I could not reuse the `get_flag`
    function from *flags.py* ([Example 20-2](ch20.html#flags_module_ex)). I had to
    rewrite it as a coroutine to use the asynchronous API of *HTTPX*. For peak performance
    with *asyncio*, we must replace every function that does I/O with an asynchronous
    version that is activated with `await` or `asyncio.create_task`, so that control
    is given back to the event loop while the function waits for I/O. If you can’t
    rewrite a blocking function as a coroutine, you should run it in a separate thread
    or process, as we’ll see in [“Delegating Tasks to Executors”](#delegating_to_executors_sec).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 [示例 21-3](#flags_asyncio_ex) 中，我无法重用 *flags.py* 中的 `get_flag` 函数（[示例 20-2](ch20.html#flags_module_ex)）。我必须将其重写为一个协程，以使用
    *HTTPX* 的异步 API。为了在 *asyncio* 中获得最佳性能，我们必须用 `await` 或 `asyncio.create_task` 替换每个执行
    I/O 操作的函数，以便在函数等待 I/O 时将控制返回给事件循环。如果无法将阻塞函数重写为协程，应该在单独的线程或进程中运行它，正如我们将在 [“委托任务给执行器”](#delegating_to_executors_sec)
    中看到的。
- en: 'That’s why I chose the epigraph for this chapter, which includes this advice:
    “You rewrite all your code so none of it blocks or you’re just wasting your time.”'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我选择本章的引语的原因，其中包括这样的建议：“你需要重写所有的代码，以便没有任何阻塞，否则你只是在浪费时间。”
- en: For the same reason, I could not reuse the `download_one` function from *flags_threadpool.py*
    ([Example 20-3](ch20.html#flags_threadpool_ex)) either. The code in [Example 21-3](#flags_asyncio_ex)
    drives `get_flag` with `await`, so `download_one` must also be a coroutine. For
    each request, a `download_one` coroutine object is created in `supervisor`, and
    they are all driven by the `asyncio.gather` coroutine.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 出于同样的原因，我也无法重用 *flags_threadpool.py* 中的 `download_one` 函数（[示例 20-3](ch20.html#flags_threadpool_ex)）。[示例 21-3](#flags_asyncio_ex)
    中的代码使用 `await` 驱动 `get_flag`，因此 `download_one` 也必须是一个协程。对于每个请求，在 `supervisor`
    中创建一个 `download_one` 协程对象，并且它们都由 `asyncio.gather` 协程驱动。
- en: Now let’s study the `async with` statement that appeared in `supervisor` ([Example 21-2](#flags_asyncio_start_ex))
    and `get_flag` ([Example 21-3](#flags_asyncio_ex)).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们研究出现在 `supervisor`（[示例 21-2](#flags_asyncio_start_ex)）和 `get_flag`（[示例 21-3](#flags_asyncio_ex)）中的
    `async with` 语句。
- en: Asynchronous Context Managers
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步上下文管理器
- en: In [“Context Managers and with Blocks”](ch18.html#context_managers_sec), we
    saw how an object can be used to run code before and after the body of a `with`
    block, if its class provides the `__enter__` and `__exit__` methods.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“上下文管理器和 with 语句”](ch18.html#context_managers_sec) 中，我们看到一个对象如何在其类提供 `__enter__`
    和 `__exit__` 方法的情况下用于在 `with` 块的主体之前和之后运行代码。
- en: Now, consider [Example 21-4](#asyncpg_transaction_no_context_ex), from the [*asyncpg*](https://fpy.li/21-10)
    *asyncio*-compatible PostgreSQL driver [documentation on transactions](https://fpy.li/21-11).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑来自 [*asyncpg*](https://fpy.li/21-10) *asyncio* 兼容的 PostgreSQL 驱动器[事务文档](https://fpy.li/21-11)中的
    [示例 21-4](#asyncpg_transaction_no_context_ex)。
- en: Example 21-4\. Sample code from the documentation of the *asyncpg* PostgreSQL
    driver
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 21-4\. *asyncpg* PostgreSQL 驱动器文档中的示例代码
- en: '[PRE6]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A database transaction is a natural fit for the context manager protocol: the
    transaction has to be started, data is changed with `connection.execute`, and
    then a rollback or commit must happen, depending on the outcome of the changes.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库事务是上下文管理器协议的自然适用对象：事务必须启动，使用 `connection.execute` 更改数据，然后根据更改的结果进行回滚或提交。
- en: In an asynchronous driver like *asyncpg*, the setup and wrap-up need to be coroutines
    so that other operations can happen concurrently. However, the implementation
    of the classic `with` statement doesn’t support coroutines doing the work of `__enter__`
    or `__exit__`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 *asyncpg* 这样的异步驱动器中，设置和收尾需要是协程，以便其他操作可以同时进行。然而，经典 `with` 语句的实现不支持协程来执行 `__enter__`
    或 `__exit__` 的工作。
- en: 'That’s why [PEP 492—Coroutines with async and await syntax](https://fpy.li/pep492)
    introduced the `async with` statement, which works with asynchronous context managers:
    objects implementing the `__aenter__` and `__aexit__` methods as coroutines.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么 [PEP 492—使用 async 和 await 语法的协程](https://fpy.li/pep492) 引入了 `async with`
    语句，它与实现了 `__aenter__` 和 `__aexit__` 方法的异步上下文管理器一起工作。
- en: 'With `async with`, [Example 21-4](#asyncpg_transaction_no_context_ex) can be
    written like this other snippet from the [*asyncpg* documentation](https://fpy.li/21-11):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `async with`，[示例 21-4](#asyncpg_transaction_no_context_ex) 可以像下面这样从 [*asyncpg*
    文档](https://fpy.li/21-11) 中的另一个片段中编写：
- en: '[PRE7]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the [`asyncpg.Transaction` class](https://fpy.li/21-13), the `__aenter__`
    coroutine method does `await self.start()`, and the `__aexit__` coroutine awaits
    on private `__rollback` or `__commit` coroutine methods, depending on whether
    an exception occurred or not. Using coroutines to implement `Transaction` as an
    asynchronous context manager allows *asyncpg* to handle many transactions concurrently.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [`asyncpg.Transaction` 类](https://fpy.li/21-13)中，`__aenter__` 协程方法执行 `await
    self.start()`，而 `__aexit__` 协程则等待私有的 `__rollback` 或 `__commit` 协程方法，取决于是否发生异常。使用协程来实现
    `Transaction` 作为异步上下文管理器，使 *asyncpg* 能够同时处理许多事务。
- en: Caleb Hattingh on asyncpg
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Caleb Hattingh 关于 asyncpg
- en: Another really great thing about *asyncpg* is that it also works around PostgreSQL’s
    lack of high-concurrency support (it uses one server-side process per connection)
    by implementing a connection pool for internal connections to Postgres itself.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*asyncpg* 的另一个非常棒的地方是，它还解决了 PostgreSQL 缺乏高并发支持的问题（它为每个连接使用一个服务器端进程），通过为内部连接到
    Postgres 本身实现了一个连接池。'
- en: This means you don’t need additional tools like *pgbouncer* as explained in
    the *asyncpg* [documentation](https://fpy.li/21-14).^([6](ch21.html#idm46582384952208))
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你不需要像在 *asyncpg* [文档](https://fpy.li/21-14) 中解释的那样额外使用 *pgbouncer* 这样的工具。^([6](ch21.html#idm46582384952208))
- en: Back to *flags_asyncio.py*, the `AsyncClient` class of `httpx` is an asynchronous
    context manager, so it can use awaitables in its `__aenter__` and `__aexit__`
    special coroutine methods.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 *flags_asyncio.py*，`httpx` 的 `AsyncClient` 类是一个异步上下文管理器，因此它可以在其 `__aenter__`
    和 `__aexit__` 特殊协程方法中使用可等待对象。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '[“Asynchronous generators as context managers”](#async_gen_context_mngr_sec)
    shows how to use Python’s `contextlib` to create an asynchronous context manager
    without having to write a class. That explanation comes later in this chapter
    because of a prerequisite topic: [“Asynchronous Generator Functions”](#async_gen_func_sec).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[“异步生成器作为上下文管理器”](#async_gen_context_mngr_sec)展示了如何使用Python的`contextlib`创建一个异步上下文管理器，而无需编写类。���于先决主题：“异步生成器函数”，这个解释稍后在本章中提供。'
- en: We’ll now enhance the *asyncio* flag download example with a progress bar, which
    will lead us to explore a bit more of the *asyncio* API.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将通过一个进度条增强*asyncio*标志下载示例，这将使我们更深入地探索*asyncio* API。
- en: Enhancing the asyncio Downloader
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加强asyncio下载器
- en: Recall from [“Downloads with Progress Display and Error Handling”](ch20.html#flags2_sec)
    that the `flags2` set of examples share the same command-line interface, and they
    display a progress bar while the downloads are happening. They also include error
    handling.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请回顾一下[“带进度显示和错误处理的下载”](ch20.html#flags2_sec)，`flags2`示例集共享相同的命令行界面，并在下载进行时显示进度条。它们还包括错误处理。
- en: Tip
  id: totrans-161
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: I encourage you to play with the `flags2` examples to develop an intuition of
    how concurrent HTTP clients perform. Use the `-h` option to see the help screen
    in [Example 20-10](ch20.html#flags2_help_demo). Use the `-a`, `-e`, and `-l` command-line
    options to control the number of downloads, and the `-m` option to set the number
    of concurrent downloads. Run tests against the `LOCAL`, `REMOTE`, `DELAY`, and
    `ERROR` servers. Discover the optimum number of concurrent downloads to maximize
    throughput against each server. Tweak the options for the test servers, as described
    in [“Setting Up Test Servers”](ch20.html#setting_up_servers_box).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励您尝试使用`flags2`示例来培养对并发HTTP客户端性能的直觉。使用`-h`选项查看[示例20-10](ch20.html#flags2_help_demo)中的帮助屏幕。使用`-a`、`-e`和`-l`命令行选项来控制下载数量，使用`-m`选项来设置并发下载数量。针对`LOCAL`、`REMOTE`、`DELAY`和`ERROR`服务器运行测试。发现最大化各服务器吞吐量所需的最佳并发下载数量。根据[“设置测试服务器”](ch20.html#setting_up_servers_box)中的描述调整测试服务器的选项。
- en: For instance, [Example 21-5](#flags2_asyncio_run_repeat) shows an attempt to
    get 100 flags (`-al 100`) from the `ERROR` server, using 100 concurrent requests
    (`-m 100`). The 48 errors in the result are either HTTP 418 or time-out errors—the
    expected (mis)behavior of the *slow_server.py*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[示例21-5](#flags2_asyncio_run_repeat)展示了尝试从`ERROR`服务器获取100个标志（`-al 100`），使用100个并发请求（`-m
    100`）。结果中的48个错误要么是HTTP 418错误，要么是超时错误——*slow_server.py*的预期（误）行为。
- en: Example 21-5\. Running flags2_asyncio.py
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例21-5。运行flags2_asyncio.py
- en: '[PRE8]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Act Responsibly When Testing Concurrent Clients
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在测试并发客户端时要负责任
- en: Even if the overall download time is not much different between the threaded
    and *asyncio* HTTP clients, *asyncio* can send requests faster, so it’s more likely
    that the server will suspect a DoS attack. To really exercise these concurrent
    clients at full throttle, please use local HTTP servers for testing, as explained
    in [“Setting Up Test Servers”](ch20.html#setting_up_servers_box).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 即使线程和*asyncio* HTTP客户端之间的整体下载时间没有太大差异，*asyncio*可以更快地发送请求，因此服务器更有可能怀疑遭受到DoS攻击。为了真正全力运行这些并发客户端，请使用本地HTTP服务器进行测试，如[“设置测试服务器”](ch20.html#setting_up_servers_box)中所述。
- en: Now let’s see how *flags2_asyncio.py* is implemented.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看*flags2_asyncio.py*是如何实现的。
- en: Using asyncio.as_completed and a Thread
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`asyncio.as_completed`和一个线程
- en: In [Example 21-3](#flags_asyncio_ex), we passed several coroutines to `asyncio.gather`,
    which returns a list with results of the coroutines in the order they were submitted.
    This means that `asyncio.gather` can only return when all the awaitables are done.
    However, to update a progress bar, we need to get results as they are done.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例21-3](#flags_asyncio_ex)中，我们将几个协程传递给`asyncio.gather`，它返回一个列表，其中包含按提交顺序排列的协程的结果。这意味着`asyncio.gather`只有在所有等待完成时才能返回。然而，为了更新进度条，我们需要在完成时获取结果。
- en: Fortunately, there is an `asyncio` equivalent of the `as_completed` generator
    function we used in the thread pool example with the progress bar ([Example 20-16](ch20.html#flags2_threadpool_full)).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`asyncio`中有一个与我们在线程池示例中使用的`as_completed`生成器函数等效的函数。
- en: '[Example 21-6](#flags2_asyncio_top) shows the top of the *flags2_asyncio.py*
    script where the `get_flag` and `download_one` coroutines are defined. [Example 21-7](#flags2_asyncio_rest)
    lists the rest of the source, with `supervisor` and `download_many`. This script
    is longer than *flags_asyncio.py* because of error handling.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例21-6](#flags2_asyncio_top)显示了*flags2_asyncio.py*脚本的顶部，其中定义了`get_flag`和`download_one`协程。[示例21-7](#flags2_asyncio_rest)列出了源代码的其余部分，包括`supervisor`和`download_many`。由于错误处理，此脚本比*flags_asyncio.py*更长。'
- en: 'Example 21-6\. flags2_asyncio.py: top portion of the script; remaining code
    is in [Example 21-7](#flags2_asyncio_rest)'
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例21-6。flags2_asyncio.py：脚本的顶部部分；其余代码在[示例21-7](#flags2_asyncio_rest)中
- en: '[PRE9]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](assets/1.png)](#co_asynchronous_programming_CO4-1)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_programming_CO4-1)'
- en: '`get_flag` is very similar to the sequential version in [Example 20-14](ch20.html#flags2_basic_http_ex).
    First difference: it requires the `client` parameter.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_flag`与[示例20-14](ch20.html#flags2_basic_http_ex)中的顺序版本非常相似。第一个区别：它需要`client`参数。'
- en: '[![2](assets/2.png)](#co_asynchronous_programming_CO4-2)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_programming_CO4-2)'
- en: 'Second and third differences: `.get` is an `AsyncClient` method, and it’s a
    coroutine, so we need to `await` it.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 第二和第三个区别：`.get`是`AsyncClient`的方法，它是一个协程，因此我们需要`await`它。
- en: '[![3](assets/3.png)](#co_asynchronous_programming_CO4-3)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_programming_CO4-3)'
- en: Use the `semaphore` as an asynchronous context manager so that the program as
    a whole is not blocked; only this coroutine is suspended when the semaphore counter
    is zero. More about this in [“Python’s Semaphores”](#about_semaphores_box).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`semaphore`作为异步上下文管理器，以便整个程序不被阻塞；只有当信号量计数为零时，此协程才会被挂起。有关更多信息，请参阅[“Python的信号量”](#about_semaphores_box)。
- en: '[![4](assets/4.png)](#co_asynchronous_programming_CO4-4)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asynchronous_programming_CO4-4)'
- en: The error handling logic is the same as in `download_one`, from [Example 20-14](ch20.html#flags2_basic_http_ex).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理逻辑与`download_one`中的相同，来自[示例 20-14](ch20.html#flags2_basic_http_ex)。
- en: '[![5](assets/5.png)](#co_asynchronous_programming_CO4-5)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asynchronous_programming_CO4-5)'
- en: Saving the image is an I/O operation. To avoid blocking the event loop, run
    `save_flag` in a thread.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 保存图像是一个I/O操作。为了避免阻塞事件循环，在一个线程中运行`save_flag`。
- en: All network I/O is done with coroutines in *asyncio*, but not file I/O. However,
    file I/O is also “blocking”—in the sense that reading/writing files takes [thousands
    of times longer](https://fpy.li/21-15) than reading/writing to RAM. If you’re
    using [Network-Attached Storage](https://fpy.li/21-16), it may even involve network
    I/O under the covers.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 所有网络I/O都是通过*asyncio*中的协程完成的，但文件I/O不是。然而，文件I/O也是“阻塞的”——因为读取/写入文件比读取/写入RAM要花费[数千倍的时间](https://fpy.li/21-15)。如果使用[网络附加存储](https://fpy.li/21-16)，甚至可能涉及网络I/O。
- en: Since Python 3.9, the `asyncio.to_thread` coroutine makes it easy to delegate
    file I/O to a thread pool provided by *asyncio*. If you need to support Python
    3.7 or 3.8, [“Delegating Tasks to Executors”](#delegating_to_executors_sec) shows
    how to add a couple of lines to do it. But first, let’s finish our study of the
    HTTP client code.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 自Python 3.9起，`asyncio.to_thread`协程使得将文件I/O委托给*asyncio*提供的线程池变得容易。如果需要支持Python
    3.7或3.8，[“委托任务给执行器”](#delegating_to_executors_sec)展示了如何添加几行代码来实现。但首先，让我们完成对HTTP客户端代码的研究。
- en: Throttling Requests with a Semaphore
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用信号量限制请求
- en: Network clients like the ones we are studying should be *throttled* (i.e., limited)
    to avoid pounding the server with too many concurrent requests.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在研究的网络客户端应该被*限制*（即，限制）以避免向服务器发送过多并发请求。
- en: A [*semaphore*](https://fpy.li/21-17) is a synchronization primitive, more flexible
    than a lock. A semaphore can be held by multiple coroutines, with a configurable
    maximum number. This makes it ideal to throttle the number of active concurrent
    coroutines. [“Python’s Semaphores”](#about_semaphores_box) has more information.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[*信号量*](https://fpy.li/21-17)是一种同步原语，比锁更灵活。信号量可以被多个协程持有，最大数量可配置。这使其成为限制活动并发协程数量的理想选择。[“Python的信号量”](#about_semaphores_box)有更多信息。'
- en: In *flags2_threadpool.py* ([Example 20-16](ch20.html#flags2_threadpool_full)),
    the throttling was done by instantiating the `ThreadPoolExecutor` with the required
    `max_workers` argument set to `concur_req` in the `download_many` function. In
    *flags2_asyncio.py*, an `asyncio.Semaphore` is created by the `supervisor` function
    (shown in [Example 21-7](#flags2_asyncio_rest)) and passed as the `semaphore`
    argument to `download_one` in [Example 21-6](#flags2_asyncio_top).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在*flags2_threadpool.py*（[示例 20-16](ch20.html#flags2_threadpool_full)）中，通过在`download_many`函数中将所需的`max_workers`参数设置为`concur_req`来完成限流。在*flags2_asyncio.py*中，通过`supervisor`函数创建一个`asyncio.Semaphore`（在[示例 21-7](#flags2_asyncio_rest)中显示），并将其作为`semaphore`参数传递给[示例 21-6](#flags2_asyncio_top)中的`download_one`。
- en: Now let’s take a look at the rest of the script in [Example 21-7](#flags2_asyncio_rest).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下[示例 21-7](#flags2_asyncio_rest)中剩下的脚本。
- en: 'Example 21-7\. flags2_asyncio.py: script continued from [Example 21-6](#flags2_asyncio_top)'
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 21-7\. flags2_asyncio.py：脚本从[示例 21-6](#flags2_asyncio_top)继续
- en: '[PRE10]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_asynchronous_programming_CO5-1)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_programming_CO5-1)'
- en: '`supervisor` takes the same arguments as the `download_many` function, but
    it cannot be invoked directly from `main` because it’s a coroutine and not a plain
    function like `download_many`.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`supervisor`接受与`download_many`函数相同的参数，但不能直接从`main`中调用，因为它是一个协程，不像`download_many`那样是一个普通函数。'
- en: '[![2](assets/2.png)](#co_asynchronous_programming_CO5-2)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_programming_CO5-2)'
- en: Create an `asyncio.Semaphore` that will not allow more than `concur_req` active
    coroutines among those using this semaphore. The value of `concur_req` is computed
    by the `main` function from *flags2_common.py*, based on command-line options
    and constants set in each example.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`asyncio.Semaphore`，不允许使用此信号量的协程中有超过`concur_req`个活动协程。`concur_req`的值由*flags2_common.py*中的`main`函数根据命令行选项和每个示例中设置的常量计算得出。
- en: '[![3](assets/3.png)](#co_asynchronous_programming_CO5-3)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_programming_CO5-3)'
- en: Create a list of coroutine objects, one per call to the `download_one` coroutine.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个协程对象列表，每个调用`download_one`协程对应一个。
- en: '[![4](assets/4.png)](#co_asynchronous_programming_CO5-4)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asynchronous_programming_CO5-4)'
- en: Get an iterator that will return coroutine objects as they are done. I did not
    place this call to `as_completed` directly in the `for` loop below because I may
    need to wrap it with the `tqdm` iterator for the progress bar, depending on the
    user’s choice for verbosity.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 获取一个迭代器，将会在完成时返回协程对象。我没有直接将这个`as_completed`调用放在下面的`for`循环中，因为根据用户对详细程度的选择，我可能需要用`tqdm`迭代器包装它以显示进度条。
- en: '[![5](assets/5.png)](#co_asynchronous_programming_CO5-5)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asynchronous_programming_CO5-5)'
- en: Wrap the `as_completed` iterator with the `tqdm` generator function to display
    progress.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`tqdm`生成器函数包装`as_completed`迭代器以显示进度。
- en: '[![6](assets/6.png)](#co_asynchronous_programming_CO5-6)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_asynchronous_programming_CO5-6)'
- en: Declare and initialize `error` with `None`; this variable will be used to hold
    an exception beyond the `try/except` statement, if one is raised.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`None`声明和初始化`error`；如果在`try/except`语句之外引发异常，将使用此变量来保存异常。
- en: '[![7](assets/7.png)](#co_asynchronous_programming_CO5-7)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_asynchronous_programming_CO5-7)'
- en: Iterate over the completed coroutine objects; this loop is similar to the one
    in `download_many` in [Example 20-16](ch20.html#flags2_threadpool_full).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代完成的协程对象；此循环类似于[示例 20-16](ch20.html#flags2_threadpool_full)中的`download_many`中的循环。
- en: '[![8](assets/8.png)](#co_asynchronous_programming_CO5-8)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_asynchronous_programming_CO5-8)'
- en: '`await` on the coroutine to get its result. This will not block because `as_completed`
    only produces coroutines that are done.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`await`协程以获取其结果。这不会阻塞，因为`as_completed`只会产生已完成的协程。'
- en: '[![9](assets/9.png)](#co_asynchronous_programming_CO5-9)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_asynchronous_programming_CO5-9)'
- en: This assignment is necessary because the `exc` variable scope is limited to
    this `except` clause, but I need to preserve its value for later.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个赋值是必要的，因为`exc`变量的作用域仅限于这个`except`子句，但我需要保留其值以供以后使用。
- en: '[![10](assets/10.png)](#co_asynchronous_programming_CO5-10)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](assets/10.png)](#co_asynchronous_programming_CO5-10)'
- en: Same as before.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前相同。
- en: '[![11](assets/11.png)](#co_asynchronous_programming_CO5-11)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[![11](assets/11.png)](#co_asynchronous_programming_CO5-11)'
- en: If there was an error, set the `status`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现错误，设置`status`。
- en: '[![12](assets/12.png)](#co_asynchronous_programming_CO5-12)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[![12](assets/12.png)](#co_asynchronous_programming_CO5-12)'
- en: In verbose mode, extract the URL from the exception that was raised…
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细模式下，从引发的异常中提取URL…
- en: '[![13](assets/13.png)](#co_asynchronous_programming_CO5-13)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[![13](assets/13.png)](#co_asynchronous_programming_CO5-13)'
- en: …and extract the name of the file to display the country code next.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: …并提取文件名以显示国家代码。
- en: '[![14](assets/14.png)](#co_asynchronous_programming_CO5-14)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[![14](assets/14.png)](#co_asynchronous_programming_CO5-14)'
- en: '`download_many` instantiates the `supervisor` coroutine object and passes it
    to the event loop with `asyncio.run`, collecting the counter `supervisor` returns
    when the event loop ends.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`download_many`实例化`supervisor`协程对象，并将其传递给事件循环以使用`asyncio.run`，在事件循环结束时收集`supervisor`返回的计数器。'
- en: In [Example 21-7](#flags2_asyncio_rest), we could not use the mapping of futures
    to country codes we saw in [Example 20-16](ch20.html#flags2_threadpool_full),
    because the awaitables returned by `asyncio.as_completed` are the same awaitables
    we pass into the `as_completed` call. Internally, the *asyncio* machinery may
    replace the awaitables we provide with others that will, in the end, produce the
    same results.^([8](ch21.html#idm46582383884976))
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 21-7](#flags2_asyncio_rest)中，我们��法使用我们在[示例 20-16](ch20.html#flags2_threadpool_full)中看到的将未来映射到国家代码的映射，因为`asyncio.as_completed`返回的可等待对象与我们传递给`as_completed`调用的可等待对象相同。在内部，*asyncio*机制可能会用最终产生相同结果的其他可等待对象替换我们提供的可等待对象。^([8](ch21.html#idm46582383884976))
- en: Tip
  id: totrans-223
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'Because I could not use the awaitables as keys to retrieve the country code
    from a `dict` in case of failure, I had to extract the country code from the exception.
    To do that, I kept the exception in the `error` variable to retrieve outside of
    the `try/except` statement. Python is not a block-scoped language: statements
    such as loops and `try/except` don’t create a local scope in the blocks they manage.
    But if an `except` clause binds an exception to a variable, like the `exc` variables
    we just saw—that binding only exists within the block inside that particular `except`
    clause.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在失败的情况下无法使用可等待对象作为键从`dict`中检索国家代码，我不得不从异常中提取国家代码。为此，我将异常保留在`error`变量中，以便在`try/except`语句之外检索。Python不是块作用域语言：诸如循环和`try/except`之类的语句不会在其管理的块中创建局部作用域。但是，如果`except`子句将异常绑定到变量，就像我们刚刚看到的`exc`变量一样，那个绑定仅存在于该特定`except`子句内部的块中。
- en: This wraps up the discussion of an *asyncio* example functionally equivalent
    to the *flags2_threadpool.py* we saw earlier.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这里结束了对与*flags2_threadpool.py*在功能上等效的*asyncio*示例的讨论。
- en: The next example demonstrates the simple pattern of executing one asynchronous
    task after another using coroutines. This deserves our attention because anyone
    with previous experience with JavaScript knows that running one asynchronous function
    after the other was the reason for the nested coding pattern known as [*pyramid
    of doom*](https://fpy.li/21-20). The `await` keyword makes that curse go away.
    That’s why `await` is now part of Python and JavaScript.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例演示了使用协程依次执行一个异步任务的简单模式。这值得我们关注，因为有经验的JavaScript用户都知道，依次运行一个异步函数是导致嵌套编码模式（称为*doom金字塔*）的原因。`await`关键字让这个问题消失了。这就是为什么`await`现在成为Python和JavaScript的一部分。
- en: Making Multiple Requests for Each Download
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为每个下载进行多个请求
- en: 'Suppose you want to save each country flag with the name of the country and
    the country code, instead of just the country code. Now you need to make two HTTP
    requests per flag: one to get the flag image itself, the other to get the *metadata.json*
    file in the same directory as the image—that’s where the name of the country is
    recorded.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要保存每个国家的国旗与国家名称和国家代码一起，而不仅仅是国家代码。现在您需要为每个旗帜进行两个HTTP请求：一个用于获取国旗图像本身，另一个用于获取与图像相同目录中的*metadata.json*文件，其中记录了国家的名称。
- en: 'Coordinating multiple requests in the same task is easy in the threaded script:
    just make one request then the other, blocking the thread twice, and keeping both
    pieces of data (country code and name) in local variables, ready to use when saving
    the files. If you needed to do the same in an asynchronous script with callbacks,
    you needed nested functions so that the country code and name were available in
    their closures until you could save the file, because each callback runs in a
    different local scope. The `await` keyword provides relief from that, allowing
    you to drive the asynchronous requests one after the other, sharing the local
    scope of the driving coroutine.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在线程脚本中协调多个请求很容易：只需依次发出一个请求，然后另一个请求，两次阻塞线程，并将两个数据（国家代码和名称）保存在本地变量中，以便在保存文件时使用。如果您需要在具有回调的异步脚本中执行相同操作，则需要嵌套函数，以便在闭包中可用国家代码和名称，直到可以保存文件，因为每个回调在不同的局部作用域中运行。`await`关键字可以解决这个问题，允许您依次驱动异步请求，共享驱动协程的局部作用域。
- en: Tip
  id: totrans-230
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you are doing asynchronous application programming in modern Python with
    lots of callbacks, you are probably applying old patterns that don’t make sense
    in modern Python. That is justified if you are writing a library that interfaces
    with legacy or low-level code that does not support coroutines. Anyway, the StackOverflow
    Q&A, [“What is the use case for future.add_done_callback()?”](https://fpy.li/21-21)
    explains why callbacks are needed in low-level code, but are not very useful in
    Python application-level code these days.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用现代Python进行异步应用程序编程，并且有很多回调，那么你可能正在应用在现代Python中没有意义的旧模式。如果你正在编写一个与不支持协程的遗留或低级代码进行交互的库，这是合理的。无论如何，StackOverflow的问答[“future.add_done_callback()的用例是什么？”](https://fpy.li/21-21)解释了为什么在低级代码中需要回调，但在现代Python应用级代码中并不是很有用。
- en: 'The third variation of the `asyncio` flag downloading script has a few changes:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio`标志下载脚本的第三个变体有一些变化：'
- en: '`get_country`'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_country`'
- en: This new coroutine fetches the *metadata.json* file for the country code, and
    gets the name of the country from it.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新协程为国家代码获取*metadata.json*文件，并从中获取国家名称。
- en: '`download_one`'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`download_one`'
- en: This coroutine now uses `await` to delegate to `get_flag` and the new `get_country`
    coroutine, using the result of the latter to build the name of the file to save.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个协程现在使用`await`委托给`get_flag`和新的`get_country`协程，使用后者的结果构建要保存的文件名。
- en: Let’s start with the code for `get_country` ([Example 21-8](#flags3_asyncio_get_country)).
    Note that it is very similar to `get_flag` from [Example 21-6](#flags2_asyncio_top).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`get_country`的代码开始（[示例 21-8](#flags3_asyncio_get_country)）。请注意，它与[示例 21-6](#flags2_asyncio_top)中的`get_flag`非常相似。
- en: 'Example 21-8\. flags3_asyncio.py: `get_country` coroutine'
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 21-8\. flags3_asyncio.py：`get_country`协程
- en: '[PRE11]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_asynchronous_programming_CO6-1)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_programming_CO6-1)'
- en: This coroutine returns a string with the country name—if all goes well.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个协程返回一个包含国家名称的字符串——如果一切顺利的话。
- en: '[![2](assets/2.png)](#co_asynchronous_programming_CO6-2)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_programming_CO6-2)'
- en: '`metadata` will get a Python `dict` built from the JSON contents of the response.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`metadata`将从响应的JSON内容构建一个Python `dict`。'
- en: '[![3](assets/3.png)](#co_asynchronous_programming_CO6-3)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_programming_CO6-3)'
- en: Return the country name.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 返回国家名称。
- en: Now let’s see the modified `download_one` in [Example 21-9](#flags3_asyncio),
    which has only a few lines changed from the same coroutine in [Example 21-6](#flags2_asyncio_top).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看修改后的`download_one`在[示例 21-9](#flags3_asyncio)中，与[示例 21-6](#flags2_asyncio_top)中的相同协程相比，只有几行代码发生了变化。
- en: 'Example 21-9\. flags3_asyncio.py: `download_one` coroutine'
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 21-9\. flags3_asyncio.py：`download_one`协程
- en: '[PRE12]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_asynchronous_programming_CO7-1)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_programming_CO7-1)'
- en: Hold the `semaphore` to `await` for `get_flag`…
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 持有`semaphore`以`await`获取`get_flag`…
- en: '[![2](assets/2.png)](#co_asynchronous_programming_CO7-2)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_programming_CO7-2)'
- en: …and again for `get_country`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: …再次为`get_country`。
- en: '[![3](assets/3.png)](#co_asynchronous_programming_CO7-3)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_programming_CO7-3)'
- en: Use the country name to create a filename. As a command-line user, I don’t like
    to see spaces in filenames.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用国家名称创建文件名。作为一个命令行用户，我不喜欢在文件名中看到空格。
- en: Much better than nested callbacks!
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 比嵌套回调好多了！
- en: I put the calls to `get_flag` and `get_country` in separate `with` blocks controlled
    by the `semaphore` because it’s good practice to hold semaphores and locks for
    the shortest possible time.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我将对`get_flag`和`get_country`的调用放在由`semaphore`控制的独立`with`块中，因为尽可能短暂地持有信号量和锁是一个良好的实践。
- en: I could schedule both `get_flag` and `get_country` in parallel using `asyncio.gather`,
    but if `get_flag` raises an exception, there is no image to save, so it’s pointless
    to run `get_country`. But there are cases where it makes sense to use `asyncio.gather`
    to hit several APIs at the same time instead of waiting for one response before
    making the next request.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用`asyncio.gather`并行调度`get_flag`和`get_country`，但如果`get_flag`引发异常，则没有图像可保存，因此运行`get_country`是没有意义的。但有些情况下，使用`asyncio.gather`同时命中几个API而不是等待一个响应再发出下一个请求是有意义的。
- en: 'In *flags3_asyncio.py*, the `await` syntax appears six times, and `async with`
    three times. Hopefully, you should be getting the hang of asynchronous programming
    in Python. One challenge is to know when you have to use `await` and when you
    can’t use it. The answer in principle is easy: you `await` coroutines and other
    awaitables, such as `asyncio.Task` instances. But some APIs are tricky, mixing
    coroutines and plain functions in seemingly arbitrary ways, like the `StreamWriter`
    class we’ll use in [Example 21-14](#tcp_mojifinder_top).'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在*flags3_asyncio.py*中，`await`语法出现了六次，`async with`出现了三次。希望你能掌握Python中的异步编程。一个挑战是要知道何时必须使用`await`以及何时不能使用它。原则上答案很简单：你`await`协程和其他可等待对象，比如`asyncio.Task`实例。但有些API很棘手，以看似任意的方式混合协程和普通函数，就像我们将在[示例
    21-14](#tcp_mojifinder_top)中使用的`StreamWriter`类一样。
- en: '[Example 21-9](#flags3_asyncio) wrapped up the *flags* set of examples. Now
    let’s discuss the use of thread or process executors in asynchronous programming.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21-9](#flags3_asyncio)总结了*flags*示例集。现在让我们讨论在异步编程中使用线程或进程执行者。'
- en: Delegating Tasks to Executors
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将任务委托给执行者
- en: One important advantage of Node.js over Python for asynchronous programming
    is the Node.js standard library, which provides async APIs for all I/O—not just
    for network I/O. In Python, if you’re not careful, file I/O can seriously degrade
    the performance of asynchronous applications, because reading and writing to storage
    in the main thread blocks the event loop.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js相对于Python在异步编程方面的一个重要优势是Node.js标准库，它为所有I/O提供了异步API，而不仅仅是网络I/O。在Python中，如果不小心，文件I/O可能会严重降低异步应用程序的性能，因为在主线程中读取和写入存储会阻塞事件循环。
- en: 'In the `download_one` coroutine of [Example 21-6](#flags2_asyncio_top), I used
    this line to save the downloaded image to disk:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 21-6](#flags2_asyncio_top)的`download_one`协程中，我使用了这行代码将下载的图像保存到磁盘上：
- en: '[PRE13]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As mentioned before, the `asyncio.to_thread` was added in Python 3.9. If you
    need to support 3.7 or 3.8, then replace that single line with the lines in [Example 21-10](#flags2_asyncio_executor_fragment).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`asyncio.to_thread`是在 Python 3.9 中添加的。如果需要支持 3.7 或 3.8，则用[示例 21-10](#flags2_asyncio_executor_fragment)中的行替换那一行。
- en: Example 21-10\. Lines to use instead of `await asyncio.to_thread`
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 21-10. 替代`await asyncio.to_thread`的行
- en: '[PRE14]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](assets/1.png)](#co_asynchronous_programming_CO8-1)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_programming_CO8-1)'
- en: Get a reference to the event loop.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 获取事件循环的引用。
- en: '[![2](assets/2.png)](#co_asynchronous_programming_CO8-2)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_programming_CO8-2)'
- en: The first argument is the executor to use; passing `None` selects the default
    `ThreadPoolExecutor` that is always available in the `asyncio` event loop.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '第一个参数是要使用的执行器；传递`None`会选择`asyncio`事件循环中始终可用的默认`ThreadPoolExecutor`。 '
- en: '[![3](assets/3.png)](#co_asynchronous_programming_CO8-3)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_programming_CO8-3)'
- en: You can pass positional arguments to the function to run, but if you need to
    pass keyword arguments, then you need to resort to `functool.partial`, as described
    in the [`run_in_executor` documentation](https://fpy.li/21-22).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向要运行的函数传递位置参数，但如果需要传递关键字参数，则需要使用`functool.partial`，如[`run_in_executor`文档](https://fpy.li/21-22)中所述。
- en: The newer `asyncio.to_thread` function is easier to use and more flexible, as
    it also accepts keyword arguments.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`asyncio.to_thread`函数更易于使用，更灵活，因为它还接受关键字参数。
- en: The implementation of `asyncio` itself uses `run_in_executor` under the hood
    in a few places. For example, the `loop.getaddrinfo(…)` coroutine we saw in [Example 21-1](#blogdom_ex)
    is implemented by calling the `getaddrinfo` function from the `socket` module—which
    is a blocking function that may take seconds to return, as it depends on DNS resolution.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio`本身的实现在一些地方使用`run_in_executor`。例如，我们在[示例 21-1](#blogdom_ex)中看到的`loop.getaddrinfo(…)`协程是通过调用`socket`模块中的`getaddrinfo`函数来实现的——这是一个可能需要几秒钟才能返回的阻塞函数，因为它依赖于
    DNS 解析。'
- en: 'A common pattern in asynchronous APIs is to wrap blocking calls that are implementation
    details in coroutines using `run_in_executor` internally. That way, you provide
    a consistent interface of coroutines to be driven with `await`, and hide the threads
    you need to use for pragmatic reasons. The [Motor](https://fpy.li/21-23) asynchronous
    driver for MongoDB has an API compatible with `async/await` that is really a façade
    around a threaded core that talks to the database server. A. Jesse Jiryu Davis,
    the lead developer of Motor, explains his reasoning in [“Response to ‘Asynchronous
    Python and Databases’”](https://fpy.li/21-24). Spoiler: Davis discovered that
    a thread pool was more performant in the particular use case of a database driver—despite
    the myth that asynchronous approaches are always faster than threads for network
    I/O.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 异步 API 中的常见模式是使用`run_in_executor`在协程中包装作为实现细节的阻塞调用。这样，您提供了一个一致的协程接口供`await`驱动，并隐藏了出于实用原因需要使用的线程。用于
    MongoDB 的[Motor](https://fpy.li/21-23)异步驱动程序具有与`async/await`兼容的 API，实际上是一个围绕与数据库服务器通信的线程核心的外观。Motor
    的首席开发人员 A. Jesse Jiryu Davis 在[“异步 Python 和数据库的响应”](https://fpy.li/21-24)中解释了他的理由。剧透：Davis
    发现在线程池在数据库驱动程序的特定用例中更高效——尽管有一个关于异步方法总是比网络 I/O 的线程更快的神话。
- en: The main reason to pass an explict `Executor` to `loop.run_in_executor` is to
    employ a `ProcessPoolExecutor` if the function to execute is CPU intensive, so
    that it runs in a different Python process, avoiding contention for the GIL. Because
    of the high start-up cost, it would be better to start the `ProcessPoolExecutor`
    in the `supervisor`, and pass it to the coroutines that need to use it.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 将显式`Executor`传递���`loop.run_in_executor`的主要原因是，如果要执行的函数对 CPU 密集型，则可以使用`ProcessPoolExecutor`，以便在不同的
    Python 进程中运行，避免争用 GIL。由于高启动成本，最好在`supervisor`中启动`ProcessPoolExecutor`，并将其传递给需要使用它的协程。
- en: Caleb Hattingh—the author of [*Using Asyncio in Python*](https://fpy.li/hattingh)
    (O’ Reilly)—is one of the tech reviewers of this book and suggested I add the
    following warning about executors and *asyncio*.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[《Python 异步编程》](https://fpy.li/hattingh)的作者 Caleb Hattingh（O’Reilly）是本书的技术审阅者之一，并建议我添加关于执行器和*asyncio*的以下警告。'
- en: Caleb’s Warning about run_in_executors
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Caleb 关于 run_in_executors 的警告
- en: 'Using `run_in_executor` can produce hard-to-debug problems since cancellation
    doesn’t work the way one might expect. Coroutines that use executors give merely
    the pretense of cancellation: the underlying thread (if it’s a `ThreadPoolExecutor`)
    has no cancellation mechanism. For example, a long-lived thread that is created
    inside a `run_in_executor` call may prevent your *asyncio* program from shutting
    down cleanly: `asyncio.run` will wait for the executor to fully shut down before
    returning, and it will wait forever if the executor jobs don’t stop somehow on
    their own. My greybeard inclination is to want that function to be named `run_in_executor_uncancellable`.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`run_in_executor`可能会产生难以调试的问题，因为取消操作的工作方式可能不如预期。使用执行器的协程仅仅给出了取消的假象：底层线程（如果是`ThreadPoolExecutor`）没有取消机制。例如，在`run_in_executor`调用内创建的长时间运行的线程可能会阻止您的*asyncio*程序干净地关闭：`asyncio.run`将等待执行器完全关闭才返回，并且如果执行器的作业没有以某种方式停止，它将永远等待。我倾向于希望该函数被命名为`run_in_executor_uncancellable`。
- en: We’ll now go from client scripts to writing servers with `asyncio`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将从客户端脚本转向使用`asyncio`编写服务器。
- en: Writing asyncio Servers
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 asyncio 服务器
- en: 'The classic toy example of a TCP server is an [echo server](https://fpy.li/21-25).
    We’ll build slightly more interesting toys: server-side Unicode character search
    utilities, first using HTTP with *FastAPI*, then using plain TCP with `asyncio`
    only.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 服务器的经典玩具示例是[回显服务器](https://fpy.li/21-25)。我们将构建稍微有趣的玩具：首先使用*FastAPI*和 HTTP，然后仅使用`asyncio`和纯
    TCP 实现服务器端 Unicode 字符搜索实用程序。
- en: These servers let users query for Unicode characters based on words in their
    standard names from the `unicodedata` module we discussed in [“The Unicode Database”](ch04.html#unicodedata_sec).
    [Figure 21-2](#web_mojifinder_result) shows a session with *web_mojifinder.py*,
    the first server we’ll build.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务器允许用户根据我们在[“Unicode数据库”](ch04.html#unicodedata_sec)中讨论的`unicodedata`模块中的标准名称中的单词查询Unicode字符。[图
    21-2](#web_mojifinder_result)展示了与*web_mojifinder.py*进行的会话，这是我们将构建的第一个服务器。
- en: '![Screenshot of Firefox connection to web_mojifinder.py](assets/flpy_2102.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![Firefox连接到web_mojifinder.py的屏幕截图](assets/flpy_2102.png)'
- en: Figure 21-2\. Browser window displaying search results for “mountain” from the
    web_mojifinder.py service.
  id: totrans-285
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 21-2\. 浏览器窗口显示来自web_mojifinder.py服务的“mountain”搜索结果。
- en: The Unicode search logic in these examples is in the `InvertedIndex` class in
    the *charindex.py* module in the [*Fluent Python* code repository](https://fpy.li/code).
    There’s nothing concurrent in that small module, so I’ll only give a brief overview
    in the optional box that follows. You can skip to the HTTP server implementation
    in [“A FastAPI Web Service”](#fastapi_web_service_sec).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例中的Unicode搜索逻辑在[*Fluent Python*代码存储库](https://fpy.li/code)中的*charindex.py*模块中的`InvertedIndex`类中。在那个小模块中没有并发，所以我将在接下来的可选框中简要概述。您可以跳到[“一个FastAPI
    Web服务”](#fastapi_web_service_sec)中的HTTP服务器实现。
- en: A FastAPI Web Service
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个FastAPI Web服务
- en: 'I wrote the next example—*web_mojifinder.py*—using [*FastAPI*](https://fpy.li/21-28):
    one of the Python ASGI Web frameworks mentioned in [“ASGI—Asynchronous Server
    Gateway Interface”](ch19.html#asgi_note). [Figure 21-2](#web_mojifinder_result)
    is a screenshot of the frontend. It’s a super simple SPA (Single Page Application):
    after the initial HTML download, the UI is updated by client-side JavaScript communicating
    with the server.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我编写了下一个示例—*web_mojifinder.py*—使用[*FastAPI*](https://fpy.li/21-28)：这是[“ASGI—异步服务器网关接口”](ch19.html#asgi_note)中提到的Python
    ASGI Web框架之一。[图 21-2](#web_mojifinder_result)是前端的屏幕截图。这是一个超级简单的SPA（单页应用程序）：在初始HTML下载后，UI通过客户端JavaScript与服务器通信来更新。
- en: '*FastAPI* is designed to implement backends for SPA and mobile apps, which
    mostly consist of web API end points returning JSON responses instead of server-rendered
    HTML. *FastAPI* leverages decorators, type hints, and code introspection to eliminate
    a lot of the boilerplate code for web APIs, and also automatically publishes interactive
    OpenAPI—a.k.a. [Swagger](https://fpy.li/21-29)—documentation for the APIs we create.
    [Figure 21-4](#web_mojifinder_schema) shows the autogenerated `/docs` page for
    *web_mojifinder.py*.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '*FastAPI*旨在为SPA和移动应用程序实现后端，这些应用程序主要由返回JSON响应的Web API端点组成，而不是服务器呈现的HTML。 *FastAPI*利用装饰器、类型提示和代码内省来消除大量用于Web
    API的样板代码，并自动发布交互式OpenAPI（又名[Swagger](https://fpy.li/21-29)）文档，用于我们创建的API。[图 21-4](#web_mojifinder_schema)展示了*web_mojifinder.py*的自动生成的`/docs`页面。'
- en: '![Screenshot of Firefox showing OpenAPI schema for `/search` endpoint](assets/flpy_2104.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![Firefox显示`/search`端点的OpenAPI模式的屏幕截图](assets/flpy_2104.png)'
- en: Figure 21-4\. Autogenerated OpenAPI schema for the `/search` endpoint.
  id: totrans-291
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 21-4\. `/search`端点的自动生成OpenAPI模式。
- en: '[Example 21-11](#web_mojifinder_ex) is the code for *web_mojifinder.py*, but
    that’s just the backend code. When you hit the root URL `/`, the server sends
    the *form.html* file, which has 81 lines of code, including 54 lines of JavaScript
    to communicate with the server and fill a table with the results. If you’re interested
    in reading plain framework-less JavaScript, please find *21-async/mojifinder/static/form.html*
    in the [*Fluent Python* code repository](https://fpy.li/code).'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21-11](#web_mojifinder_ex)是*web_mojifinder.py*的代码，但那只是后端代码。当您访问根URL`/`时，服务器会发送*form.html*文件，其中包括81行代码，其中包括54行JavaScript代码，用于与服务器通信并将结果填充到表中。如果您有兴趣阅读纯粹的无框架JavaScript，请在[*Fluent
    Python*代码存储库](https://fpy.li/code)中找到*21-async/mojifinder/static/form.html*。'
- en: 'To run *web_mojifinder.py*, you need to install two packages and their dependencies:
    *FastAPI* and *uvicorn*.^([10](ch21.html#idm46582383270064)) This is the command
    to run [Example 21-11](#web_mojifinder_ex) with *uvicorn* in development mode:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行*web_mojifinder.py*，您需要安装两个包及其依赖项：*FastAPI*和*uvicorn*。^([10](ch21.html#idm46582383270064))
    这是在开发模式下使用*uvicorn*运行[示例 21-11](#web_mojifinder_ex)的命令：
- en: '[PRE15]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The parameters are:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 参数为：
- en: '`web_mojifinder:app`'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`web_mojifinder:app`'
- en: The package name, a colon, and the name of the ASGI application defined in it—`app`
    is the conventional name.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 包名称、冒号和其中定义的ASGI应用程序的名称——`app`是常规名称。
- en: '`--reload`'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`--reload`'
- en: Make *uvicorn* monitor changes to application source files and automatically
    reload them. Useful only during development.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使*uvicorn*监视应用程序源文件的更改并自动重新加载它们。仅在开发过程中有用。
- en: Now let’s study the source code for *web_mojifinder.py*.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们研究*web_mojifinder.py*的源代码。
- en: 'Example 21-11\. web_mojifinder.py: complete source'
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 21-11\. web_mojifinder.py：完整源码
- en: '[PRE16]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](assets/1.png)](#co_asynchronous_programming_CO9-1)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_programming_CO9-1)'
- en: 'Unrelated to the theme of this chapter, but worth noting: the elegant use of
    the overloaded `/` operator by `pathlib`.^([11](ch21.html#idm46582382999680))'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章主题无关，但值得注意的是`pathlib`通过重载的`/`运算符的优雅使用。^([11](ch21.html#idm46582382999680))
- en: '[![2](assets/2.png)](#co_asynchronous_programming_CO9-2)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_programming_CO9-2)'
- en: This line defines the ASGI app. It could be as simple as `app = FastAPI()`.
    The parameters shown are metadata for the autogenerated documentation.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 此行定义了ASGI应用程序。它可以简单到`app = FastAPI()`。所示的参数是自动生成文档的元数据。
- en: '[![3](assets/3.png)](#co_asynchronous_programming_CO9-3)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_programming_CO9-3)'
- en: A *pydantic* schema for a JSON response with `char` and `name` fields.^([12](ch21.html#idm46582382964064))
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 一个带有`char`和`name`字段的JSON响应的*pydantic*模式。^([12](ch21.html#idm46582382964064))
- en: '[![4](assets/4.png)](#co_asynchronous_programming_CO9-4)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asynchronous_programming_CO9-4)'
- en: Build the `index` and load the static HTML form, attaching both to the `app.state`
    for later use.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 构建`index`并加载静态HTML表单，将两者附加到`app.state`以供以后使用。
- en: '[![5](assets/5.png)](#co_asynchronous_programming_CO9-5)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asynchronous_programming_CO9-5)'
- en: Run `init` when this module is loaded by the ASGI server.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当此模块由ASGI服务器加载时运行`init`。
- en: '[![6](assets/6.png)](#co_asynchronous_programming_CO9-6)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_asynchronous_programming_CO9-6)'
- en: Route for the `/search` endpoint; `response_model` uses that `CharName` *pydantic*
    model to describe the response format.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`/search`端点的路由；`response_model`使用`CharName` *pydantic*模型描述响应格式。'
- en: '[![7](assets/7.png)](#co_asynchronous_programming_CO9-7)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_asynchronous_programming_CO9-7)'
- en: '*FastAPI* assumes that any parameters that appear in the function or coroutine
    signature that are not in the route path will be passed in the HTTP query string,
    e.g., `/search?q=cat`. Since `q` has no default, *FastAPI* will return a 422 (Unprocessable
    Entity) status if `q` is missing from the query string.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '*FastAPI*假设在函数或协程签名中出现的任何参数，而不在路由路径中的参数将传递到HTTP查询字符串中，例如，`/search?q=cat`。由于`q`没有默认值，如果查询字符串中缺少`q`，*FastAPI*将返回422（无法处理的实体）状态。'
- en: '[![8](assets/8.png)](#co_asynchronous_programming_CO9-8)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_asynchronous_programming_CO9-8)'
- en: Returning an iterable of `dicts` compatible with the `response_model` schema
    allows *FastAPI* to build the JSON response according to the `response_model`
    in the `@app.get` decorator.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 返回与`response_model`模式兼容的`dicts`的可迭代对象允许*FastAPI*根据`@app.get`装饰器中的`response_model`构建JSON响应。
- en: '[![9](assets/9.png)](#co_asynchronous_programming_CO9-9)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_asynchronous_programming_CO9-9)'
- en: Regular functions (i.e., non-async) can also be used to produce responses.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 常规函数（即非异步函数）也可以用于生成响应。
- en: '[![10](assets/10.png)](#co_asynchronous_programming_CO9-10)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](assets/10.png)](#co_asynchronous_programming_CO9-10)'
- en: This module has no main function. It is loaded and driven by the ASGI server—*uvicorn*
    in this example.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块没有主函数。在这个示例中，它由ASGI服务器—*uvicorn*加载和驱动。
- en: '[Example 21-11](#web_mojifinder_ex) has no direct calls to `asyncio`. *FastAPI*
    is built on the *Starlette* ASGI toolkit, which in turn uses `asyncio`.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例21-11](#web_mojifinder_ex)没有直接调用`asyncio`。*FastAPI*是建立在*Starlette* ASGI工具包之上的，而*Starlette*又使用`asyncio`。'
- en: Also note that the body of `search` doesn’t use `await`, `async with`, or `async
    for`, therefore it could be a plain function. I defined `search` as a coroutine
    just to show that *FastAPI* knows how to handle it. In a real app, most endpoints
    will query databases or hit other remote servers, so it is a critical advantage
    of *FastAPI*—and ASGI frameworks in general—to support coroutines that can take
    advantage of asynchronous libraries for network I/O.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`search`的主体不使用`await`、`async with`或`async for`，因此它可以是一个普通函数。我将`search`定义为协程只是为了展示*FastAPI*知道如何处理它。在真实的应用程序中，大多数端点将查询数据库或访问其他远程服务器，因此*FastAPI*支持可以利用异步库进行网络I/O的协程是*FastAPI*和ASGI框架的关键优势。
- en: Tip
  id: totrans-325
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The `init` and `form` functions I wrote to load and serve the static HTML form
    are a hack to make the example short and easy to run. The recommended best practice
    is to have a proxy/load-balancer in front of the ASGI server to handle all static
    assets, and also use a CDN (Content Delivery Network) when possible. One such
    proxy/load-balancer is [*Traefik*](https://fpy.li/21-32), a self-described “edge
    router” that “receives requests on behalf of your system and finds out which components
    are responsible for handling them.” *FastAPI* has [project generation](https://fpy.li/21-33)
    scripts that prepare your code to do that.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我编写的`init`和`form`函数用于加载和提供静态HTML表单，这是为了让示例变得简短且易于运行。推荐的最佳实践是在ASGI服务器前面放置一个代理/负载均衡器来处理所有静态资产，并在可能的情况下使用CDN（内容交付网络）。其中一个这样的代理/负载均衡器是[*Traefik*](https://fpy.li/21-32)，一个自称为“边缘路由器”的工具，“代表您的系统接收请求并找出哪些组件负责处理它们”。*FastAPI*有[项目生成](https://fpy.li/21-33)脚本，可以准备您的代码来实现这一点。
- en: 'The typing enthusiast may have noticed that there are no return type hints
    in `search` and `form`. Instead, *FastAPI* relies on the `response_model=` keyword
    argument in the route decorators. The [“Response Model”](https://fpy.li/21-34)
    page in the *FastAPI* documentation explains:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 爱好类型提示的人可能已经注意到`search`和`form`中没有返回类型提示。相反，*FastAPI*依赖于路由装饰器中的`response_model=`关键字参数。*FastAPI*文档中的[“响应模型”](https://fpy.li/21-34)页面解释了：
- en: The response model is declared in this parameter instead of as a function return
    type annotation, because the path function may not actually return that response
    model but rather return a dict, database object or some other model, and then
    use the `response_model` to perform the field limiting and serialization.
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 响应模型在此参数中声明，而不是作为函数返回类型注释，因为路径函数实际上可能不返回该响应模型，而是返回一个dict、数据库对象或其他模型，然后使用`response_model`执行字段限制和序列化。
- en: For example, in `search`, I returned a generator of `dict` items, not a list
    of `CharName` objects, but that’s good enough for *FastAPI* and *pydantic* to
    validate my data and build the appropriate JSON response compatible with `response_model=list[CharName]`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在`search`中，我返回了一个`dict`项的生成器，而不是`CharName`对象的列表，但这对于*FastAPI*和*pydantic*来说已经足够验证我的数据并构建与`response_model=list[CharName]`兼容的适当JSON响应。
- en: We’ll now focus on the *tcp_mojifinder.py* script that is answering the queries
    in [Figure 21-5](#tcp_mojifinder_demo).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将专注于*tcp_mojifinder.py*脚本，该脚本正在回答[图21-5](#tcp_mojifinder_demo)中的查询。
- en: An asyncio TCP Server
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个asyncio TCP服务器
- en: The *tcp_mojifinder.py* program uses plain TCP to communicate with a client
    like Telnet or Netcat, so I could write it using `asyncio` without external dependencies—and
    without reinventing HTTP. [Figure 21-5](#tcp_mojifinder_demo) shows text-based
    UI.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '*tcp_mojifinder.py*程序使用普通TCP与像Telnet或Netcat这样的客户端通信，因此我可以使用`asyncio`编写它而无需外部依赖项—也无需重新发明HTTP。[图21-5](#tcp_mojifinder_demo)展示了基于文本的用户界面。'
- en: '![Screenshot of Telnet connection to tcp_mojifinder.py](assets/flpy_2105.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![Telnet连接到tcp_mojifinder.py的屏幕截图](assets/flpy_2105.png)'
- en: 'Figure 21-5\. Telnet session with the tcp_mojifinder.py server: querying for
    “fire.”'
  id: totrans-334
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图21-5\. 使用tcp_mojifinder.py服务器进行Telnet会话：查询“fire”。
- en: 'This program is twice as long as *web_mojifinder.py*, so I split the presentation
    into three parts: [Example 21-12](#tcp_mojifinder_main), [Example 21-14](#tcp_mojifinder_top),
    and [Example 21-15](#tcp_mojifinder_search). The top of *tcp_mojifinder.py*—including
    the `import` statements—is in [Example 21-14](#tcp_mojifinder_top), but I will
    start by describing the `supervisor` coroutine and the `main` function that drives
    the program.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序比*web_mojifinder.py*长一倍，所以我将演示分为三部分：[示例 21-12](#tcp_mojifinder_main)、[示例
    21-14](#tcp_mojifinder_top)和[示例 21-15](#tcp_mojifinder_search)。*tcp_mojifinder.py*的顶部—包括`import`语句—在[示例
    21-14](#tcp_mojifinder_top)中，但我将从描述`supervisor`协程和驱动程序的`main`函数开始。
- en: 'Example 21-12\. tcp_mojifinder.py: a simple TCP server; continues in [Example 21-14](#tcp_mojifinder_top)'
  id: totrans-336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 21-12\. tcp_mojifinder.py：一个简单的TCP服务器；继续查看[示例 21-14](#tcp_mojifinder_top)
- en: '[PRE17]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](assets/1.png)](#co_asynchronous_programming_CO10-1)'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_programming_CO10-1)'
- en: This `await` quickly gets an instance of `asyncio.Server`, a TCP socket server.
    By default, `start_server` creates and starts the server, so it’s ready to receive
    connections.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`await`快速获取了一个`asyncio.Server`实例，一个TCP套接字服务器。默认情况下，`start_server`创建并启动服务器，因此它已准备好接收连接。
- en: '[![2](assets/2.png)](#co_asynchronous_programming_CO10-2)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_programming_CO10-2)'
- en: 'The first argument to `start_server` is `client_connected_cb`, a callback to
    run when a new client connection starts. The callback can be a function or a coroutine,
    but it must accept exactly two arguments: an `asyncio.StreamReader` and an `asyncio.StreamWriter`.
    However, my `finder` coroutine also needs to get an `index`, so I used `functools.partial`
    to bind that parameter and obtain a callable that takes the reader and writer.
    Adapting user functions to callback APIs is the most common use case for `functools.partial`.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`start_server`的第一个参数是`client_connected_cb`，一个在新客户端连接开始时运行的回调函数。回调函数可以是一个函数或一个协程，但必须接受两个参数：一个`asyncio.StreamReader`和一个`asyncio.StreamWriter`。然而，我的`finder`协程还需要获取一个`index`，所以我使用`functools.partial`来绑定该参数并获得一个接受读取器和写入器的可调用对象。将用户函数适配为回调API是`functools.partial`的最常见用例。'
- en: '[![3](assets/3.png)](#co_asynchronous_programming_CO10-3)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_programming_CO10-3)'
- en: '`host` and `port` are the second and third arguments to `start_server`. See
    the full signature in the [`asyncio` documentation](https://fpy.li/21-35).'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`host`和`port`是`start_server`的第二个和第三个参数。在[`asyncio`文档](https://fpy.li/21-35)中查看完整的签名。'
- en: '[![4](assets/4.png)](#co_asynchronous_programming_CO10-4)'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asynchronous_programming_CO10-4)'
- en: 'This `cast` is needed because *typeshed* has an outdated type hint for the
    `sockets` property of the `Server` class—as of May 2021\. See [Issue #5535 on
    *typeshed*](https://fpy.li/21-36).^([13](ch21.html#idm46582382561568))'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '这个`cast`是必需的，因为*typeshed*对`Server`类的`sockets`属性的类型提示已过时—截至2021年5月。参见*typeshed*上的[Issue
    #5535](https://fpy.li/21-36)。^([13](ch21.html#idm46582382561568))'
- en: '[![5](assets/5.png)](#co_asynchronous_programming_CO10-5)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asynchronous_programming_CO10-5)'
- en: Display the address and port of the first socket of the server.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 显示服务器的第一个套接字的地址和端口。
- en: '[![6](assets/6.png)](#co_asynchronous_programming_CO10-6)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_asynchronous_programming_CO10-6)'
- en: 'Although `start_server` already started the server as a concurrent task, I
    need to `await` on the `server_forever` method so that my `supervisor` is suspended
    here. Without this line, `supervisor` would return immediately, ending the loop
    started with `asyncio.run(supervisor(…))`, and exiting the program. The [documentation
    for `Server.serve_forever`](https://fpy.li/21-37) says: “This method can be called
    if the server is already accepting connections.”'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`start_server`已经将服务器作为并发任务启动，但我需要在`server_forever`方法上`await`，以便我的`supervisor`在此处暂停。如果没有这行，`supervisor`将立即返回，结束由`asyncio.run(supervisor(…))`启动的循环，并退出程序。[`Server.serve_forever`的文档](https://fpy.li/21-37)中说：“如果服务器已经接受连接，则可以调用此方法。”
- en: '[![7](assets/7.png)](#co_asynchronous_programming_CO10-7)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_asynchronous_programming_CO10-7)'
- en: Build the inverted index.^([14](ch21.html#idm46582382550512))
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 构建倒排索引。^([14](ch21.html#idm46582382550512))
- en: '[![8](assets/8.png)](#co_asynchronous_programming_CO10-8)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_asynchronous_programming_CO10-8)'
- en: Start the event loop running `supervisor`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 启动运行`supervisor`的事件循环。
- en: '[![9](assets/9.png)](#co_asynchronous_programming_CO10-9)'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_asynchronous_programming_CO10-9)'
- en: Catch the `KeyboardInterrupt` to avoid a distracting traceback when I stop the
    server with Ctrl-C on the terminal running it.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获`KeyboardInterrupt`以避免在终止运行它的终端上使用Ctrl-C停止服务器时出现令人分心的回溯。
- en: You may find it easier to understand how control flows in *tcp_mojifinder.py*
    if you study the output it generates on the server console, listed in [Example 21-13](#tcp_mojifinder_server_demo).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您研究服务器控制台上生成的输出，可以更容易地理解*tcp_mojifinder.py*中的控制流程，在[示例 21-13](#tcp_mojifinder_server_demo)中列出。
- en: 'Example 21-13\. tcp_mojifinder.py: this is the server side of the session depicted
    in [Figure 21-5](#tcp_mojifinder_demo)'
  id: totrans-357
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 21-13\. tcp_mojifinder.py：这是[图 21-5](#tcp_mojifinder_demo)中描述的会话的服务器端
- en: '[PRE18]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](assets/1.png)](#co_asynchronous_programming_CO11-1)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_programming_CO11-1)'
- en: Output by `main`. Before the next line appears, I see a 0.6s delay on my machine
    while the index is built.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`输出。在下一行出现之前，我在我的机器上看到了0.6秒的延迟，因为正在构建索引。'
- en: '[![2](assets/2.png)](#co_asynchronous_programming_CO11-2)'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_programming_CO11-2)'
- en: Output by `supervisor`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`supervisor`输出。'
- en: '[![3](assets/3.png)](#co_asynchronous_programming_CO11-3)'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_programming_CO11-3)'
- en: First iteration of a `while` loop in `finder`. The TCP/IP stack assigned port
    58192 to my Telnet client. If you connect several clients to the server, you’ll
    see their various ports in the output.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`finder`中`while`循环的第一次迭代。TCP/IP堆栈将端口58192分配给了我的Telnet客户端。如果将多个客户端连接到服务器，您将在输出中看到它们的各种端口。'
- en: '[![4](assets/4.png)](#co_asynchronous_programming_CO11-4)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asynchronous_programming_CO11-4)'
- en: Second iteration of the `while` loop in `finder`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`finder`中`while`循环的第二次迭代。'
- en: '[![5](assets/5.png)](#co_asynchronous_programming_CO11-5)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asynchronous_programming_CO11-5)'
- en: I hit Ctrl-C on the client terminal; the `while` loop in `finder` exits.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我在客户端终端上按下了Ctrl-C；`finder`中的`while`循环退出。
- en: '[![6](assets/6.png)](#co_asynchronous_programming_CO11-6)'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_asynchronous_programming_CO11-6)'
- en: The `finder` coroutine displays this message then exits. Meanwhile the server
    is still running, ready to service another client.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`finder`协程显示此消息然后退出。与此同时，服务器仍在运行，准备为另一个客户端提供服务。'
- en: '[![7](assets/7.png)](#co_asynchronous_programming_CO11-7)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_asynchronous_programming_CO11-7)'
- en: I hit Ctrl-C on the server terminal; `server.serve_forever` is cancelled, ending
    `supervisor` and the event loop.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我在服务器终端上按下了Ctrl-C；`server.serve_forever`被取消，结束了`supervisor`和事件循环。
- en: '[![8](assets/8.png)](#co_asynchronous_programming_CO11-8)'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_asynchronous_programming_CO11-8)'
- en: Output by `main`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 由`main`输出。
- en: After `main` builds the index and starts the event loop, `supervisor` quickly
    displays the `Serving on…` message and is suspended at the `await server.serve_forever()`
    line. At that point, control flows into the event loop and stays there, occasionally
    coming back to the `finder` coroutine, which yields control back to the event
    loop whenever it needs to wait for the network to send or receive data.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`构建索引并启动事件循环后，`supervisor`快速显示`Serving on…`消息，并在`await server.serve_forever()`行处暂停。此时，控制流进入事件循环并留在那里，偶尔返回到`finder`协程，每当需要等待网络发送或接收数据时，它将控制权交还给事件循环。
- en: While the event loop is alive, a new instance of the `finder` coroutine will
    be started for each client that connects to the server. In this way, many clients
    can be handled concurrently by this simple server. This continues until a `KeyboardInterrupt`
    occurs on the server or its process is killed by the OS.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件循环处于活动状态时，将为连接到服务器的每个客户端启动一个新的`finder`协程实例。通过这种方式，这个简单的服务器可以同时处理许多客户端。直到服务器上发生`KeyboardInterrupt`或其进程被操作系统终止。
- en: Now let’s see the top of *tcp_mojifinder.py*, with the `finder` coroutine.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看*tcp_mojifinder.py*的顶部，其中包含`finder`协程。
- en: 'Example 21-14\. tcp_mojifinder.py: continued from [Example 21-12](#tcp_mojifinder_main)'
  id: totrans-378
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 21-14\. tcp_mojifinder.py：续自[示例 21-12](#tcp_mojifinder_main)
- en: '[PRE19]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](assets/1.png)](#co_asynchronous_programming_CO12-1)'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_programming_CO12-1)'
- en: '`format_results` is useful to display the results of `InvertedIndex.search`
    in a text-based UI such as the command line or a Telnet session.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`format_results`对`InvertedIndex.search`的结果进行显示，在文本界面（如命令行或Telnet会话）中非常有用。'
- en: '[![2](assets/2.png)](#co_asynchronous_programming_CO12-2)'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_programming_CO12-2)'
- en: To pass `finder` to `asyncio.start_server`, I wrapped it with `functools.partial`,
    because the server expects a coroutine or function that takes only the `reader`
    and `writer` arguments.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将`finder`传递给`asyncio.start_server`，我使用`functools.partial`对其进行了包装，因为服务器期望一个只接受`reader`和`writer`参数的协程或函数。
- en: '[![3](assets/3.png)](#co_asynchronous_programming_CO12-3)'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_programming_CO12-3)'
- en: Get the remote client address to which the socket is connected.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 获取与套接字连接的远程客户端地址。
- en: '[![4](assets/4.png)](#co_asynchronous_programming_CO12-4)'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asynchronous_programming_CO12-4)'
- en: This loop handles a dialog that lasts until a control character is received
    from the client.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 此循环处理一个对话，直到从客户端接收到控制字符为止。
- en: '[![5](assets/5.png)](#co_asynchronous_programming_CO12-5)'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asynchronous_programming_CO12-5)'
- en: The `StreamWriter.write` method is not a coroutine, just a plain function; this
    line sends the `?>` prompt.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`StreamWriter.write`方法不是一个协程，只是一个普通函数；这一行发送`?>`提示符。'
- en: '[![6](assets/6.png)](#co_asynchronous_programming_CO12-6)'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_asynchronous_programming_CO12-6)'
- en: '`StreamWriter.drain` flushes the `writer` buffer; it is a coroutine, so it
    must be driven with `await`.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`StreamWriter.drain`刷新`writer`缓冲区；它是一个协程，因此必须使用`await`来驱动它。'
- en: '[![7](assets/7.png)](#co_asynchronous_programming_CO12-7)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_asynchronous_programming_CO12-7)'
- en: '`StreamWriter.readline` is a coroutine that returns `bytes`.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`StreamWriter.readline`是一个返回`bytes`的协程。'
- en: '[![8](assets/8.png)](#co_asynchronous_programming_CO12-8)'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_asynchronous_programming_CO12-8)'
- en: If no bytes were received, the client closed the connection, so exit the loop.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有接收到任何字节，则客户端关闭了连接，因此退出循环。
- en: '[![9](assets/9.png)](#co_asynchronous_programming_CO12-9)'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_asynchronous_programming_CO12-9)'
- en: Decode the `bytes` to `str`, using the default UTF-8 encoding.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 将`bytes`解码为`str`，使用默认的UTF-8编码。
- en: '[![10](assets/10.png)](#co_asynchronous_programming_CO12-10)'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](assets/10.png)](#co_asynchronous_programming_CO12-10)'
- en: A `UnicodeDecodeError` may happen when the user hits Ctrl-C and the Telnet client
    sends control bytes; if that happens, replace the query with a null character,
    for simplicity.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下Ctrl-C并且Telnet客户端发送控制字节时，可能会发生`UnicodeDecodeError`；如果发生这种情况，为简单起见，用空字符替换查询。
- en: '[![11](assets/11.png)](#co_asynchronous_programming_CO12-11)'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '[![11](assets/11.png)](#co_asynchronous_programming_CO12-11)'
- en: Log the query to the server console.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 将查询记录到服务器控制台。
- en: '[![12](assets/12.png)](#co_asynchronous_programming_CO12-12)'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '[![12](assets/12.png)](#co_asynchronous_programming_CO12-12)'
- en: Exit the loop if a control or null character was received.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果接收到控制字符或空字符，则退出循环。
- en: '[![13](assets/13.png)](#co_asynchronous_programming_CO12-13)'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '[![13](assets/13.png)](#co_asynchronous_programming_CO12-13)'
- en: Do the actual `search`; code is presented next.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 执行实际的`search`；代码将在下面呈现。
- en: '[![14](assets/14.png)](#co_asynchronous_programming_CO12-14)'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '[![14](assets/14.png)](#co_asynchronous_programming_CO12-14)'
- en: Log the response to the server console.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 将响应记录到服务器控制台。
- en: '[![15](assets/15.png)](#co_asynchronous_programming_CO12-15)'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '[![15](assets/15.png)](#co_asynchronous_programming_CO12-15)'
- en: Close the `StreamWriter`.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭`StreamWriter`。
- en: '[![16](assets/16.png)](#co_asynchronous_programming_CO12-16)'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '[![16](assets/16.png)](#co_asynchronous_programming_CO12-16)'
- en: Wait for the `StreamWriter` to close. This is recommended in the [`.close()`
    method documentation](https://fpy.li/21-38).
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 等待`StreamWriter`关闭。这在[`.close()`方法文档](https://fpy.li/21-38)中推荐。
- en: '[![17](assets/17.png)](#co_asynchronous_programming_CO12-17)'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '[![17](assets/17.png)](#co_asynchronous_programming_CO12-17)'
- en: Log the end of this client’s session to the server console.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 将此客户端会话的结束记录到服务器控制台。
- en: The last piece of this example is the `search` coroutine, shown in [Example 21-15](#tcp_mojifinder_search).
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的最后一部分是`search`协程，如[示例 21-15](#tcp_mojifinder_search)所示。
- en: 'Example 21-15\. tcp_mojifinder.py: `search` coroutine'
  id: totrans-415
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 21-15\. tcp_mojifinder.py：`search`协程
- en: '[PRE20]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](assets/1.png)](#co_asynchronous_programming_CO13-1)'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_programming_CO13-1)'
- en: '`search` must be a coroutine because it writes to a `StreamWriter` and must
    use its `.drain()` coroutine method.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`search`必须是一个协程，因为它写入一个`StreamWriter`并必须使用它的`.drain()`协程方法。'
- en: '[![2](assets/2.png)](#co_asynchronous_programming_CO13-2)'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_programming_CO13-2)'
- en: Query the inverted index.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 查询反向索引。
- en: '[![3](assets/3.png)](#co_asynchronous_programming_CO13-3)'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_programming_CO13-3)'
- en: This generator expression will yield byte strings encoded in UTF-8 with the
    Unicode codepoint, the actual character, its name, and a `CRLF` sequence—e.g.,
    `b'U+0039\t9\tDIGIT NINE\r\n'`).
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生成器表达式将产生用UTF-8编码的字节字符串，包含Unicode代码点、实际字符、其名称和一个`CRLF`序列，例如，`b'U+0039\t9\tDIGIT
    NINE\r\n'`。
- en: '[![4](assets/4.png)](#co_asynchronous_programming_CO13-4)'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asynchronous_programming_CO13-4)'
- en: Send the `lines`. Surprisingly, `writer.writelines` is not a coroutine.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 发送`lines`。令人惊讶的是，`writer.writelines`不是一个协程。
- en: '[![5](assets/5.png)](#co_asynchronous_programming_CO13-5)'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asynchronous_programming_CO13-5)'
- en: But `writer.drain()` is a coroutine. Don’t forget the `await`!
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 但`writer.drain()`是一个协程。不要忘记`await`！
- en: '[![6](assets/6.png)](#co_asynchronous_programming_CO13-6)'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_asynchronous_programming_CO13-6)'
- en: Build a status line, then send it.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个状态行，然后发送它。
- en: Note that all network I/O in *tcp_mojifinder.py* is in `bytes`; we need to decode
    the `bytes` received from the network, and encode strings before sending them
    out. In Python 3, the default encoding is UTF-8, and that’s what I used implicitly
    in all `encode` and `decode` calls in this example.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*tcp_mojifinder.py*中的所有网络I/O都是以`bytes`形式；我们需要解码从网络接收的`bytes`，并在发送之前对字符串进行编码。在Python
    3中，默认编码是UTF-8，这就是我在本示例中所有`encode`和`decode`调用中隐式使用的编码。
- en: Warning
  id: totrans-430
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Note that some of the I/O methods are coroutines and must be driven with `await`,
    while others are simple functions. For example, `StreamWriter.write` is a plain
    function, because it writes to a buffer. On the other hand, `StreamWriter.drain`—which
    flushes the buffer and performs the network I/O—is a coroutine, as is `StreamReader.readline`—but
    not `StreamWriter.writelines`! While I was writing the first edition of this book,
    the `asyncio` API docs were improved by [clearly labeling coroutines as such](https://fpy.li/21-39).
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一些I/O方法是协程，必须使用`await`来驱动，而其他一些是简单的函数。例如，`StreamWriter.write`是一个普通函数，因为它写入缓冲区。另一方面，`StreamWriter.drain`——用于刷新缓冲区并执行网络I/O的协程，以及`StreamReader.readline`——但不是`StreamWriter.writelines`！在我写这本书的第一版时，`asyncio`
    API文档通过[清晰标记协程](https://fpy.li/21-39)得到了改进。
- en: The *tcp_mojifinder.py* code leverages the high-level `asyncio` [Streams API](https://fpy.li/21-40)
    that provides a ready-to-use server so you only need to implement a handler function,
    which can be a plain callback or a coroutine. There is also a lower-level [Transports
    and Protocols API](https://fpy.li/21-41), inspired by the transport and protocols
    abstractions in the *Twisted* framework. Refer to the `asyncio` documentation
    for more information, including [TCP and UDP echo servers and clients](https://fpy.li/21-42)
    implemented with that lower-level API.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '*tcp_mojifinder.py*代码利用了高级别的`asyncio` [Streams API](https://fpy.li/21-40)，提供了一个可直接使用的服务器，因此你只需要实现一个处理函数，可以是一个普通回调函数或一个协程。还有一个更低级别的[Transports
    and Protocols API](https://fpy.li/21-41)，受到*Twisted*框架中传输和协议抽象的启发。请参考`asyncio`文档以获取更多信息��包括使用该低级别API实现的[TCP和UDP回显服务器和客户端](https://fpy.li/21-42)。'
- en: Our next topic is `async for` and the objects that make it work.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个主题是`async for`和使其工作的对象。
- en: Asynchronous Iteration and Asynchronous Iterables
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步迭代和异步可迭代对象
- en: We saw in [“Asynchronous Context Managers”](#async_context_manager_sec) how
    `async with` works with objects implementing the `__aenter__` and `__aexit__`
    methods returning awaitables—usually in the form of coroutine objects.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[“异步上下文管理器”](#async_context_manager_sec)中看到了`async with`如何与实现`__aenter__`和`__aexit__`方法返回可等待对象的对象一起工作——通常是协程对象的形式。
- en: 'Similarly, `async for` works with *asynchronous iterables*: objects that implement
    `__aiter__`. However, `__aiter__` must be a regular method—not a coroutine method—and
    it must return an *asynchronous iterator*.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`async for`适用于*异步可迭代对象*：实现了`__aiter__`的对象。然而，`__aiter__`必须是一个常规方法——不是一个协程方法——并且必须返回一个*异步迭代器*。
- en: An asynchronous iterator provides an `__anext__` coroutine method that returns
    an awaitable—often a coroutine object. They are also expected to implement `__aiter__`,
    which usually returns `self`. This mirrors the important distinction of iterables
    and iterators we discussed in [“Don’t Make the Iterable an Iterator for Itself”](ch17.html#iterable_not_self_iterator_sec).
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 异步迭代器提供了一个`__anext__`协程方法，返回一个可等待对象——通常是一个协程对象。它们还应该实现`__aiter__`，通常返回`self`。这反映了我们在[“不要让可迭代对象成为自身的迭代器”](ch17.html#iterable_not_self_iterator_sec)中讨论的可迭代对象和迭代器的重要区别。
- en: 'The *aiopg* asynchronous PostgreSQL driver [documentation](https://fpy.li/21-43)
    has an example that illustrates the use of `async for` to iterate over the rows
    of a database cursor:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '*aiopg*异步PostgreSQL驱动程序[文档](https://fpy.li/21-43)中有一个示例，演示了使用`async for`来迭代数据库游标的行：'
- en: '[PRE21]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example the query will return a single row, but in a realistic scenario
    you may have thousands of rows in response to a `SELECT` query. For large responses,
    the cursor will not be loaded with all the rows in a single batch. Therefore it
    is important that `async for row in cur:` does not block the event loop while
    the cursor may be waiting for additional rows. By implementing the cursor as an
    asynchronous iterator, *aiopg* may yield to the event loop at each `__anext__`
    call, and resume later when more rows arrive from PostgreSQL.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，查询将返回一行，但在实际情况下，你可能会对`SELECT`查询的响应有成千上万行。对于大量响应，游标不会一次性加载所有行。因此，很重要的是`async
    for row in cur:`不会阻塞事件循环，而游标可能正在等待更多行。通过将游标实现为异步迭代器，*aiopg*可以在每次`__anext__`调用时让出事件循环，并在后来从PostgreSQL接收更多行时恢复。
- en: Asynchronous Generator Functions
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步生成器函数
- en: 'You can implement an asynchronous iterator by writing a class with `__anext__`
    and `__aiter__`, but there is a simpler way: write a function declared with `async
    def` and use `yield` in its body. This parallels how generator functions simplify
    the classic Iterator pattern.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过编写一个带有`__anext__`和`__aiter__`的类来实现异步迭代器，但有一种更简单的方法：编写一个使用`async def`声明的函数，并在其体内使用`yield`。这与生成器函数简化经典的迭代器模式的方式相似。
- en: Let’s study a simple example using `async for` and implementing an asynchronous
    generator. In [Example 21-1](#blogdom_ex) we saw *blogdom.py*, a script that probed
    domain names. Now suppose we find other uses for the `probe` coroutine we defined
    there, and decide to put it into a new module—*domainlib.py*—together with a new
    `multi_probe` asynchronous generator that takes a list of domain names and yields
    results as they are probed.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们研究一个简单的例子，使用`async for`并实现一个异步生成器。在[示例21-1](#blogdom_ex)中，我们看到了*blogdom.py*，一个探测域名的脚本。现在假设我们找到了我们在那里定义的`probe`协程的其他用途，并决定将其放入一个新模块—*domainlib.py*—与一个新的`multi_probe`异步生成器一起，该生成器接受一个域名列表，并在探测时产生结果。
- en: We’ll look at the implementation of *domainlib.py* soon, but first let’s see
    how it is used with Python’s new asynchronous console.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快将看到*domainlib.py*的实现，但首先让我们看看它如何与Python的新异步控制台一起使用。
- en: Experimenting with Python’s async console
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尝试使用Python的异步控制台
- en: '[Since Python 3.8](https://fpy.li/21-44), you can run the interpreter with
    the `-m asyncio` command-line option to get an “async REPL”: a Python console
    that imports `asyncio`, provides a running event loop, and accepts `await`, `async
    for`, and `async with` at the top-level prompt—which otherwise are syntax errors
    when used outside of native coroutines.^([15](ch21.html#idm46582381736688))'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '[自Python 3.8起](https://fpy.li/21-44)，你可以使用`-m asyncio`命令行选项运行解释器，以获得一个“异步REPL”：一个导入`asyncio`，提供运行事件循环，并在顶级提示符接受`await`、`async
    for`和`async with`的Python控制台——否则在外部协程之外使用时会产生语法错误。^([15](ch21.html#idm46582381736688))'
- en: 'To experiment with *domainlib.py*, go to the *21-async/domains/asyncio/* directory
    in your local copy of the [*Fluent Python* code repository](https://fpy.li/code).
    Then run:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试*domainlib.py*，请转到你本地[*Fluent Python*代码库](https://fpy.li/code)中的*21-async/domains/asyncio/*目录。然后运行：
- en: '[PRE22]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You’ll see the console start, similar to this:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到控制台启动，类似于这样：
- en: '[PRE23]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note how the header says you can use `await` instead of `asyncio.run()`—to
    drive coroutines and other awaitables. Also: I did not type `import asyncio`.
    The `asyncio` module is automatically imported and that line makes that fact clear
    to the user.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 注意标题中说你可以使用`await`而不是`asyncio.run()`来驱动协程和其他可等待对象。另外：我没有输入`import asyncio`。`asyncio`模块会自动导入，并且该行使用户清楚地了解这一事实。
- en: 'Now let’s import *domainlib.py* and play with its two coroutines: `probe` and
    `multi_probe` ([Example 21-16](#domainlib_demo_repl)).'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们导入*domainlib.py*并尝试其两个协程：`probe`和`multi_probe`（[示例21-16](#domainlib_demo_repl)）。
- en: Example 21-16\. Experimenting with *domainlib.py* after running `python3 -m
    asyncio`
  id: totrans-453
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 21-16\. 在运行`python3 -m asyncio`后尝试*domainlib.py*
- en: '[PRE24]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[![1](assets/1.png)](#co_asynchronous_programming_CO14-1)'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_programming_CO14-1)'
- en: 'Try a simple `await` to see the asynchronous console in action. Tip: `asyncio.sleep()`
    takes an optional second argument that is returned when you `await` it.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一个简单的`await`来看看异步控制台的运行情况。提示：`asyncio.sleep()`接受一个可选的第二个参数，在你`await`它时返回。
- en: '[![2](assets/2.png)](#co_asynchronous_programming_CO14-2)'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_programming_CO14-2)'
- en: Drive the `probe` coroutine.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动`probe`协程。
- en: '[![3](assets/3.png)](#co_asynchronous_programming_CO14-3)'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_programming_CO14-3)'
- en: The `domainlib` version of `probe` returns a `Result` named tuple.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '`probe`的`domainlib`版本返回一个名为`Result`的命名元组。'
- en: '[![4](assets/4.png)](#co_asynchronous_programming_CO14-4)'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asynchronous_programming_CO14-4)'
- en: Make a list of domains. The `.invalid` top-level domain is reserved for testing.
    DNS queries for such domains always get an NXDOMAIN response from DNS servers,
    meaning “that domain does not exist.”^([16](ch21.html#idm46582381523904))
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 制作一个域名列表。`.invalid`顶级域名保留用于测试。对于这些域的DNS查询总是从DNS服务器获得NXDOMAIN响应，意味着“该��名不存在”。^([16](ch21.html#idm46582381523904))
- en: '[![5](assets/5.png)](#co_asynchronous_programming_CO14-5)'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asynchronous_programming_CO14-5)'
- en: Iterate with `async for` over the `multi_probe` asynchronous generator to display
    the results.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`async for`迭代`multi_probe`异步生成器以显示结果。
- en: '[![6](assets/6.png)](#co_asynchronous_programming_CO14-6)'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_asynchronous_programming_CO14-6)'
- en: Note that the results are not in the order the domains were given to `multiprobe`.
    They appear as each DNS response comes back.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 注意结果不是按照传递给`multiprobe`的域的顺序出现的。它们会在每个DNS响应返回时出现。
- en: '[Example 21-16](#domainlib_demo_repl) shows that `multi_probe` is an asynchronous
    generator because it is compatible with `async for`. Now let’s do a few more experiments,
    continuing from that example with [Example 21-17](#domainlib_more_exp_repl).'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例21-16](#domainlib_demo_repl)表明`multi_probe`是一个异步生成器，因为它与`async for`兼容。现在让我们进行一些更多的实验，从那个示例继续，使用[示例21-17](#domainlib_more_exp_repl)。'
- en: Example 21-17\. More experiments, continuing from [Example 21-16](#domainlib_demo_repl)
  id: totrans-468
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例21-17\. 更多实验，从[示例21-16](#domainlib_demo_repl)继续
- en: '[PRE25]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[![1](assets/1.png)](#co_asynchronous_programming_CO15-1)'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_programming_CO15-1)'
- en: Calling a native coroutine gives you a coroutine object.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 调用一个原生协程会给你一个协程对象。
- en: '[![2](assets/2.png)](#co_asynchronous_programming_CO15-2)'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_programming_CO15-2)'
- en: Calling an asynchronous generator gives you an `async_generator` object.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 调用异步生成器会给你一个`async_generator`对象。
- en: '[![3](assets/3.png)](#co_asynchronous_programming_CO15-3)'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_programming_CO15-3)'
- en: We can’t use a regular `for` loop with asynchronous generators because they
    implement `__aiter__` instead of `__iter__`.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用常规的`for`循环与异步生成器，因为它们实现了`__aiter__`而不是`__iter__`。
- en: Asynchronous generators are driven by `async for`, which can be a block statement
    (as seen in [Example 21-16](#domainlib_demo_repl)), and it also appears in asynchronous
    comprehensions, which we’ll cover soon.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 异步生成器由`async for`驱动，它可以是一个块语句（如[示例21-16](#domainlib_demo_repl)中所见），它还出现在异步推导式中，我们很快会介绍。
- en: Implementing an asynchronous generator
  id: totrans-477
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现异步生成器
- en: Now let’s study the code for *domainlib.py*, with the `multi_probe` asynchronous
    generator ([Example 21-18](#domainlib_ex)).
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们研究*domainlib.py*中的代码，使用`multi_probe`异步生成器（[示例21-18](#domainlib_ex)）。
- en: 'Example 21-18\. domainlib.py: functions for probing domains'
  id: totrans-479
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例21-18\. domainlib.py：用于探测域的函数
- en: '[PRE26]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[![1](assets/1.png)](#co_asynchronous_programming_CO16-1)'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_programming_CO16-1)'
- en: '`NamedTuple` makes the result from `probe` easier to read and debug.'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '`NamedTuple`使得从`probe`得到的结果更易于阅读和调试。'
- en: '[![2](assets/2.png)](#co_asynchronous_programming_CO16-2)'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_programming_CO16-2)'
- en: This type alias is to avoid making the next line too long for a book listing.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类型别名是为了避免书中列表过长。
- en: '[![3](assets/3.png)](#co_asynchronous_programming_CO16-3)'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_programming_CO16-3)'
- en: '`probe` now gets an optional `loop` argument, to avoid repeated calls to `get_running_loop`
    when this coroutine is driven by `multi_probe`.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '`probe`现在获得了一个可选的`loop`参数，以避免在此协程由`multi_probe`驱动时重复调用`get_running_loop`。'
- en: '[![4](assets/4.png)](#co_asynchronous_programming_CO16-4)'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asynchronous_programming_CO16-4)'
- en: An asynchronous generator function produces an asynchronous generator object,
    which can be annotated as `AsyncIterator[SomeType]`.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 异步生成器函数产生一个异步生成器对象，可以注释为`AsyncIterator[SomeType]`。
- en: '[![5](assets/5.png)](#co_asynchronous_programming_CO16-5)'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asynchronous_programming_CO16-5)'
- en: Build list of `probe` coroutine objects, each with a different `domain`.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 构建包含不同`domain`的`probe`协程对象列表。
- en: '[![6](assets/6.png)](#co_asynchronous_programming_CO16-6)'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_asynchronous_programming_CO16-6)'
- en: This is not `async for` because `asyncio.as_completed` is a classic generator.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是`async for`，因为`asyncio.as_completed`是一个经典生成器。
- en: '[![7](assets/7.png)](#co_asynchronous_programming_CO16-7)'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_asynchronous_programming_CO16-7)'
- en: Await on the coroutine object to retrieve the result.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 等待协程对象以检索结果。
- en: '[![8](assets/8.png)](#co_asynchronous_programming_CO16-8)'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_asynchronous_programming_CO16-8)'
- en: Yield `result`. This line makes `multi_probe` an asynchronous generator.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`result`。这一行使`multi_probe`成为一个异步生成器。
- en: Note
  id: totrans-497
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `for` loop in [Example 21-18](#domainlib_ex) could be more concise:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例21-18](#domainlib_ex)中的`for`循环可以更简洁：'
- en: '[PRE27]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Python parses that as `yield (await coro)`, so it works.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: Python将其解析为`yield (await coro)`，所以它有效。
- en: I thought it could be confusing to use that shortcut in the first asynchronous
    generator example in the book, so I split it into two lines.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为在书中第一个异步生成器示例中使用该快捷方式可能会让人困惑，所以我将其拆分为两行。
- en: 'Given *domainlib.py*, we can demonstrate the use of the `multi_probe` asynchronous
    generator in *domaincheck.py*: a script that takes a domain suffix and searches
    for domains made from short Python keywords.'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 给定*domainlib.py*，我们可以演示在*domaincheck.py*中使用`multi_probe`异步生成器的方法：一个脚本，接受一个域后缀并搜索由短Python关键字组成的域。
- en: 'Here is a sample output of *domaincheck.py*:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 这是*domaincheck.py*的一个示例输出：
- en: '[PRE28]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Thanks to *domainlib*, the code for *domaincheck.py* is straightforward, as
    seen in [Example 21-19](#domaincheck_ex).
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了*domainlib*，*domaincheck.py*的代码非常简单，如[示例21-19](#domaincheck_ex)所示。
- en: 'Example 21-19\. domaincheck.py: utility for probing domains using domainlib'
  id: totrans-506
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例21-19\. domaincheck.py：使用domainlib探测域的实用程序
- en: '[PRE29]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[![1](assets/1.png)](#co_asynchronous_programming_CO17-1)'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_programming_CO17-1)'
- en: Generate keywords with length up to `4`.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 生成长度最多为`4`的关键字。
- en: '[![2](assets/2.png)](#co_asynchronous_programming_CO17-2)'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_programming_CO17-2)'
- en: Generate domain names with the given suffix as TLD.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 生成具有给定后缀作为TLD的域名。
- en: '[![3](assets/3.png)](#co_asynchronous_programming_CO17-3)'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_programming_CO17-3)'
- en: Format a header for the tabular output.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 为表格输出格式化标题。
- en: '[![4](assets/4.png)](#co_asynchronous_programming_CO17-4)'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asynchronous_programming_CO17-4)'
- en: Asynchronously iterate over `multi_probe(domains)`.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 在`multi_probe(domains)`上异步迭代。
- en: '[![5](assets/5.png)](#co_asynchronous_programming_CO17-5)'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asynchronous_programming_CO17-5)'
- en: Set `indent` to zero or two tabs to put the result in the proper column.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 将`indent`设置为零或两个制表符，以将结果放在正确的列中。
- en: '[![6](assets/6.png)](#co_asynchronous_programming_CO17-6)'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_asynchronous_programming_CO17-6)'
- en: Run the `main` coroutine with the given command-line argument.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 使用给定的命令行参数运行`main`协程。
- en: 'Generators have one extra use unrelated to iteration: they can be made into
    context managers. This also applies to asynchronous generators.'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器有一个与迭代无关的额外用途：它们可以转换为上下文管理器。这也适用于异步生成器。
- en: Asynchronous generators as context managers
  id: totrans-521
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步生成器作为上下文管理器
- en: Writing our own asynchronous context managers is not a frequent programming
    task, but if you need to write one, consider using the [`@asynccontextmanager`](https://fpy.li/21-46)
    decorator added to the `contextlib` module in Python 3.7. That’s very similar
    to the `@contextmanager` decorator we studied in [“Using @contextmanager”](ch18.html#using_cm_decorator_sec).
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 编写我们自己的异步上下文管理器并不是一个经常出现的编程任务，但如果您需要编写一个，考虑使用Python 3.7中添加到`contextlib`模块的[`@asynccontextmanager`](https://fpy.li/21-46)装饰器。这与我们在[“使用@contextmanager”](ch18.html#using_cm_decorator_sec)中学习的`@contextmanager`装饰器非常相似。
- en: An interesting example combining `@asynccontextmanager` with `loop.run_in_executor`
    appears in Caleb Hattingh’s book [*Using Asyncio in Python*](https://fpy.li/hattingh).
    [Example 21-20](#asynccontextmanager_ex) is Caleb’s code—with a single change
    and added callouts.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的示例结合了`@asynccontextmanager`和`loop.run_in_executor`，出现在Caleb Hattingh的书[*Using
    Asyncio in Python*](https://fpy.li/hattingh)中。[示例21-20](#asynccontextmanager_ex)是Caleb的代码，只有一个变化和添加的标注。
- en: Example 21-20\. Example using `@asynccontextmanager` and `loop.run_in_executor`
  id: totrans-524
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例21-20\. 使用`@asynccontextmanager`和`loop.run_in_executor`的示例
- en: '[PRE30]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[![1](assets/1.png)](#co_asynchronous_programming_CO18-1)'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_programming_CO18-1)'
- en: The decorated function must be an asynchronous generator.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 被修饰的函数必须是一个异步生成器。
- en: '[![2](assets/2.png)](#co_asynchronous_programming_CO18-2)'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_programming_CO18-2)'
- en: 'Minor update to Caleb’s code: use the lightweight `get_running_loop` instead
    of `get_event_loop`.'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 对Caleb的代码进行了小更新：使用轻量级的`get_running_loop`代替`get_event_loop`。
- en: '[![3](assets/3.png)](#co_asynchronous_programming_CO18-3)'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_programming_CO18-3)'
- en: Suppose `download_webpage` is a blocking function using the *requests* library;
    we run it in a separate thread to avoid blocking the event loop.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`download_webpage`是使用*requests*库的阻塞函数；我们在单独的线程中运行它以避免阻塞事件循环。
- en: '[![4](assets/4.png)](#co_asynchronous_programming_CO18-4)'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asynchronous_programming_CO18-4)'
- en: All lines before this `yield` expression will become the `__aenter__` coroutine-method
    of the asynchronous context manager built by the decorator. The value of `data`
    will be bound to the `data` variable after the `as` clause in the `async with`
    statement below.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 在此`yield`表达式之前的所有行将成为装饰器构建的异步上下文管理器的`__aenter__`协程方法。`data`的值将在下面的`async with`语句中的`as`子句后绑定到`data`变量。
- en: '[![5](assets/5.png)](#co_asynchronous_programming_CO18-5)'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asynchronous_programming_CO18-5)'
- en: Lines after the `yield` will become the `__aexit__` coroutine method. Here,
    another blocking call is delegated to the thread executor.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield`之后的行将成为`__aexit__`协程方法。在这里，另一个阻塞调用被委托给线程执行器。'
- en: '[![6](assets/6.png)](#co_asynchronous_programming_CO18-6)'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_asynchronous_programming_CO18-6)'
- en: Use `web_page` with `async with`.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`web_page`和`async with`。
- en: This is very similar to the sequential `@contextmanager` decorator. Please see
    [“Using @contextmanager”](ch18.html#using_cm_decorator_sec) for more details,
    including error handling at the `yield` line. For another example of `@asynccontextmanager`,
    see the [`contextlib` documentation](https://fpy.li/21-46).
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 这与顺序的`@contextmanager`装饰器非常相似。请参阅[“使用 @contextmanager”](ch18.html#using_cm_decorator_sec)以获取更多详细信息，包括在`yield`行处的错误处理。有关`@asynccontextmanager`的另一个示例，请参阅[`contextlib`文档](https://fpy.li/21-46)。
- en: Now let’s wrap up our coverage of asynchronous generator functions by contrasting
    them with native coroutines.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过将它们与本地协程进行对比来结束异步生成器函数的覆盖范围。
- en: Asynchronous generators versus native coroutines
  id: totrans-540
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步生成器与本地协程
- en: 'Here are some key similarities and differences between a native coroutine and
    an asynchronous generator function:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本地协程和异步生成器函数之间的一些关键相似性和差异：
- en: Both are declared with `async def`.
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两者都使用`async def`声明。
- en: An asynchronous generator always has a `yield` expression in its body—that’s
    what makes it a generator. A native coroutine never contains `yield`.
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步生成器的主体中始终包含一个`yield`表达式—这就是使其成为生成器的原因。本地协程永远不包含`yield`。
- en: A native coroutine may `return` some value other than `None`. An asynchronous
    generator can only use empty `return` statements.
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地协程可能会`return`除`None`之外的某个值。异步生成器只能使用空的`return`语句。
- en: 'Native coroutines are awaitable: they can be driven by `await` expressions
    or passed to one of the many `asyncio` functions that take awaitable arguments,
    such as `create_task`. Asynchronous generators are not awaitable. They are asynchronous
    iterables, driven by `async for` or by asynchronous comprehensions.'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地协程是可等待的：它们可以被`await`表达式驱动或传递给许多接受可等待参数的`asyncio`函数，例如`create_task`。异步生成器不可等待。它们是异步可迭代对象，由`async
    for`或异步推导驱动。
- en: Time to talk about asynchronous comprehensions.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候谈谈异步推导了。
- en: Async Comprehensions and Async Generator Expressions
  id: totrans-547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步推导和异步生成器表达式
- en: '[PEP 530—Asynchronous Comprehensions](https://fpy.li/pep530) introduced the
    use of `async for` and `await` in the syntax of comprehensions and generator expressions,
    starting with Python 3.6.'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '[PEP 530—异步推导](https://fpy.li/pep530)引入了在Python 3.6中开始使用`async for`和`await`语法的推导和生成器表达式。'
- en: The only construct defined by PEP 530 that can appear outside an `async def`
    body is an asynchronous generator expression.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 530定义的唯一可以出现在`async def`体外的构造是异步生成器表达式。
- en: Defining and using an asynchronous generator expression
  id: totrans-550
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义和使用异步生成器表达式
- en: 'Given the `multi_probe` asynchronous generator from [Example 21-18](#domainlib_ex),
    we could write another asynchronous generator returning only the names of the
    domains found. Here is how—again using the asynchronous console launched with
    `-m asyncio`:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 给定来自[示例 21-18](#domainlib_ex)的`multi_probe`异步生成器，我们可以编写另一个异步生成器，仅返回找到的域的名称。下面是如何实现的——再次使用启动了`-m
    asyncio`的异步控制台：
- en: '[PRE31]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[![1](assets/1.png)](#co_asynchronous_programming_CO19-1)'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_programming_CO19-1)'
- en: The use of `async for` makes this an asynchronous generator expression. It can
    be defined anywhere in a Python module.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`async for`使其成为异步生成器表达式。它可以在Python模块的任何地方定义。
- en: '[![2](assets/2.png)](#co_asynchronous_programming_CO19-2)'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_programming_CO19-2)'
- en: The asynchronous generator expression builds an `async_generator` object—exactly
    the same type of object returned by an asynchronous generator function like `multi_probe`.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 异步生成器表达式构建了一个`async_generator`对象——与`multi_probe`等异步生成器函数返回的对象完全相同。
- en: '[![3](assets/3.png)](#co_asynchronous_programming_CO19-3)'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_programming_CO19-3)'
- en: The asynchronous generator object is driven by the `async for` statement, which
    in turn can only appear inside an `async def` body or in the magic asynchronous
    console I used in this example.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 异步生成器对象由`async for`语句驱动，而`async for`语句只能出现在`async def`体内或我在此示例中使用的魔术异步控制台中。
- en: 'To summarize: an asynchronous generator expression can be defined anywhere
    in your program, but it can only be consumed inside a native coroutine or asynchronous
    generator function.'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下：异步生成器表达式可以在程序的任何地方定义，但只能在本地协程或异步生成器函数内消耗。
- en: The remaining constructs introduced by PEP 530 can only be defined and used
    inside native coroutines or asynchronous generator functions.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 530引入的其余构造只能在本地协程或异步生成器函数内定义和使用。
- en: Asynchronous comprehensions
  id: totrans-561
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步推导
- en: Yury Selivanov—the author of PEP 530—justifies the need for asynchronous comprehensions
    with three short code snippets reproduced next.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 530的作者Yury Selivanov通过下面重现的三个简短代码片段证明了异步推导的必要性。
- en: 'We can all agree that we should be able to rewrite this code:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都同意我们应该能够重写这段代码：
- en: '[PRE32]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'like this:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 就像这样：
- en: '[PRE33]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In addition, given a native coroutine `fun`, we should be able to write this:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，给定一个原生协程 `fun`，我们应该能够编写这样的代码：
- en: '[PRE34]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Tip
  id: totrans-569
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Using `await` in a list comprehension is similar to using `asyncio.gather`.
    But `gather` gives you more control over exception handling, thanks to its optional
    `return_exceptions` argument. Caleb Hattingh recommends always setting `return_exceptions=True`
    (the default is `False`). Please see the [`asyncio.gather` documentation](https://fpy.li/21-48)
    for more.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表推导式中使用 `await` 类似于使用 `asyncio.gather`。但是 `gather` 通过其可选的 `return_exceptions`
    参数使您对异常处理有更多控制。Caleb Hattingh 建议始终设置 `return_exceptions=True`（默认为 `False`）。请查看
    [`asyncio.gather` 文档](https://fpy.li/21-48) 了解更多信息。
- en: 'Back to the magic asynchronous console:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 回到神奇的异步控制台：
- en: '[PRE35]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that I sorted the list of names to show that the results come out in the
    order they were submitted, in both cases.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我对名称列表进行了排序，以显示结果按提交顺序输出。
- en: 'PEP 530 allows the use of `async for` and `await` in list comprehensions as
    well as in `dict` and `set` comprehensions. For example, here is a `dict` comprehension
    to store the results of `multi_probe` in the asynchronous console:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 530 允许在列表推导式以及 `dict` 和 `set` 推导式中使用 `async for` 和 `await`。例如，这里是一个在异步控制台中存储
    `multi_probe` 结果的 `dict` 推导式：
- en: '[PRE36]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can use the `await` keyword in the expression before the `for` or `async
    for` clause, and also in the expression after the `if` clause. Here is a set comprehension
    in the asynchronous console, collecting only the domains that were found:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `for` 或 `async for` 子句之前的表达式中使用 `await` 关键字，也可以在 `if` 子句之后的表达式中使用。这里是在异步控制台中的一个集合推导式，仅收集找到的域：
- en: '[PRE37]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: I had to put extra parentheses around the `await` expression due to the higher
    precedence of the `__getattr__` operator `.` (dot).
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `__getattr__` 运算符 `.`（点）的优先级较高，我不得不在 `await` 表达式周围加上额外的括号。
- en: Again, all of these comprehensions can only appear inside an `async def` body
    or in the enchanted asynchronous console.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，所有这些推导式只能出现在 `async def` 主体内或在增强的异步控制台中。
- en: Now let’s talk about a very important feature of the `async` statements, `async`
    expressions, and the objects they create. Those constructs are often used with
    *asyncio* but, they are actually library independent.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们谈谈 `async` 语句、`async` 表达式以及它们创建的对象的一个非常重要的特性。这些构造经常与 *asyncio* 一起使用，但实际上它们是独立于库的。
- en: 'async Beyond asyncio: Curio'
  id: totrans-581
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步超越 asyncio：Curio
- en: Python’s `async/await` language constructs are not tied to any specific event
    loop or library.^([17](ch21.html#idm46582380179328)) Thanks to the extensible
    API provided by special methods, anyone sufficiently motivated can write their
    own asynchronous runtime environment and framework to drive native coroutines,
    asynchronous generators, etc.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `async/await` 语言构造与任何特定的事件循环或库无关。^([17](ch21.html#idm46582380179328))
    由于特殊方法提供的可扩展 API，任何足够有动力的人都可以编写自己的异步运行时环境和框架，以驱动原生协程、异步生成器等。
- en: That’s what David Beazley did in his [*Curio*](https://fpy.li/21-49) project.
    He was interested in rethinking how these new language features could be used
    in a framework built from scratch. Recall that `asyncio` was released in Python
    3.4, and it used `yield from` instead of `await`, so its API could not leverage
    asynchronous context managers, asynchronous iterators, and everything else that
    the `async/await` keywords made possible. As a result, *Curio* has a cleaner API
    and a simpler implementation, compared to `asyncio`.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是大卫·比兹利在他的 [*Curio*](https://fpy.li/21-49) 项目中所做的。他对重新思考如何利用这些新语言特性构建一个从头开始的框架很感兴趣。回想一下，`asyncio`
    是在 Python 3.4 中发布的，它使用 `yield from` 而不是 `await`，因此其 API 无法利用异步上下文管理器、异步迭代器以及 `async/await`
    关键字所可能实现的一切。因此，与 `asyncio` 相比，*Curio* 具有更清晰的 API 和更简单的实现。
- en: '[Example 21-21](#blogdom_curio_ex) shows the *blogdom.py* script ([Example 21-1](#blogdom_ex))
    rewritten to use *Curio*.'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 21-21](#blogdom_curio_ex) 展示了重新使用 *Curio* 编写的 *blogdom.py* 脚本（[示例 21-1](#blogdom_ex)）。'
- en: 'Example 21-21\. blogdom.py: [Example 21-1](#blogdom_ex), now using *Curio*'
  id: totrans-585
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 21-21\. blogdom.py：[示例 21-1](#blogdom_ex)，现在使用 *Curio*
- en: '[PRE38]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[![1](assets/1.png)](#co_asynchronous_programming_CO20-1)'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_programming_CO20-1)'
- en: '`probe` doesn’t need to get the event loop, because…'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '`probe` 不需要获取事件循环，因为…'
- en: '[![2](assets/2.png)](#co_asynchronous_programming_CO20-2)'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_programming_CO20-2)'
- en: …`getaddrinfo` is a top-level function of `curio.socket`, not a method of a
    `loop` object—as it is in `asyncio`.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: …`getaddrinfo` 是 `curio.socket` 的顶级函数，而不是 `loop` 对象的方法—就像在 `asyncio` 中一样。
- en: '[![3](assets/3.png)](#co_asynchronous_programming_CO20-3)'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_programming_CO20-3)'
- en: A `TaskGroup` is a core concept in *Curio*, to monitor and control several coroutines,
    and to make sure they are all executed and cleaned up.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskGroup` 是 *Curio* 中的一个核心概念，用于监视和控制多个协程，并确保它们都被执行和清理。'
- en: '[![4](assets/4.png)](#co_asynchronous_programming_CO20-4)'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asynchronous_programming_CO20-4)'
- en: '`TaskGroup.spawn` is how you start a coroutine, managed by a specific `TaskGroup`
    instance. The coroutine is wrapped by a `Task`.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskGroup.spawn` 是启动由特定 `TaskGroup` 实例管理的协程的方法。该协程由一个 `Task` 包装。'
- en: '[![5](assets/5.png)](#co_asynchronous_programming_CO20-5)'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asynchronous_programming_CO20-5)'
- en: Iterating with `async for` over a `TaskGroup` yields `Task` instances as each
    is completed. This corresponds to the line in [Example 21-1](#blogdom_ex) using
    `for … as_completed(…):`.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `async for` 在 `TaskGroup` 上迭代会在每个完成时产生 `Task` 实例。这对应于 [示例 21-1](#blogdom_ex)
    中使用 `for … as_completed(…):` 的行。
- en: '[![6](assets/6.png)](#co_asynchronous_programming_CO20-6)'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_asynchronous_programming_CO20-6)'
- en: '*Curio* pioneered this sensible way to start an asynchronous program in Python.'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '*Curio* 开创了这种在 Python 中启动异步程序的明智方式。'
- en: 'To expand on the last point: if you look at the `asyncio` code examples for
    the first edition of *Fluent Python*, you’ll see lines like these, repeated over
    and over:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步扩展上述观点：如果您查看第一版 *Fluent Python* 中关于 `asyncio` 的代码示例，您会看到反复出现这样的代码行：
- en: '[PRE39]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'A *Curio* `TaskGroup` is an asynchronous context manager that replaces several
    ad hoc APIs and coding patterns in `asyncio`. We just saw how iterating over a
    `TaskGroup` makes the `asyncio.as_completed(…)` function unnecessary. Another
    example: instead of a special `gather` function, this snippet from the [“Task
    Groups” docs](https://fpy.li/21-50) collects the results of all tasks in the group:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '*Curio*的`TaskGroup`是一个异步上下文管理器，替代了`asyncio`中的几个临时API和编码模式。我们刚刚看到如何遍历`TaskGroup`使得`asyncio.as_completed(…)`函数变得不再必要。另一个例子：这段来自[“任务组”文档](https://fpy.li/21-50)的代码收集了组中所有任务的结果：'
- en: '[PRE40]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Task groups support [*structured concurrency*](https://fpy.li/21-51): a form
    of concurrent programming that constrains all the activity of a group of asynchronous
    tasks to a single entry and exit point. This is analogous to structured programming,
    which eschewed the `GOTO` command and introduced block statements to limit the
    entry and exit points of loops and subroutines. When used as an asynchronous context
    manager, a `TaskGroup` ensures that all tasks spawned inside are completed or
    cancelled, and any exceptions raised, upon exiting the enclosed block.'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 任务组支持[*结构化并发*](https://fpy.li/21-51)：一种并发编程形式，将一组异步任务的所有活动限制在单个入口和出口点。这类似于结构化编程，它避免了`GOTO`命令，并引入了块语句来限制循环和子程序的入口和出口点。当作为异步上下文管理器使用时，`TaskGroup`确保所有在内部生成的任务在退出封闭块时完成或取消，并处理引发的任何异常。
- en: Note
  id: totrans-604
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Structured concurrency will probably be adopted by `asyncio` in upcoming Python
    releases. A strong indication appears in [PEP 654–Exception Groups and except*](https://fpy.li/pep654),
    which was [approved for Python 3.11](https://fpy.li/21-52). The [“Motivation”
    section](https://fpy.li/21-53) mentions *Trio’s* “nurseries,” their name for task
    groups: “Implementing a better task spawning API in *asyncio*, inspired by Trio
    nurseries, was the main motivation for this PEP.”'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化并发可能会在即将发布的Python版本中被`asyncio`采用。在[PEP 654–异常组和except*](https://fpy.li/pep654)中出现了强烈迹象，该PEP已经[获得了Python
    3.11的批准](https://fpy.li/21-52)。[“动机”部分](https://fpy.li/21-53)提到了*Trio*的“nurseries”，他们对任务组的命名方式：“受Trio
    nurseries启发，在*asyncio*中实现更好的任务生成API是这个PEP的主要动机。”
- en: Another important feature of *Curio* is better support for programming with
    coroutines and threads in the same codebase—a necessity in most nontrivial asynchronous
    programs. Starting a thread with `await spawn_thread(func, …)` returns an `AsyncThread`
    object with a `Task`-like interface. Threads can call coroutines thanks to a special
    [`AWAIT(coro)`](https://fpy.li/21-54) function—named in all caps because `await`
    is now a keyword.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '*Curio*的另一个重要特性是更好地支持在同一代码库中使用协程和线程进行编程——这在大多数复杂的异步程序中是必需的。使用`await spawn_thread(func,
    …)`启动线程会返回一个具有类似`Task`接口的`AsyncThread`对象。线程可以调用协程，这要归功于一个特殊的[`AWAIT(coro)`](https://fpy.li/21-54)函数——因为`await`现在是一个关键字，所以用全大写命名。'
- en: '*Curio* also provides a `UniversalQueue` that can be used to coordinate the
    work among threads, *Curio* coroutines, and `asyncio` coroutines. That’s right,
    *Curio* has features that allow it to run in a thread along with `asyncio` in
    another thread, in the same process, communicating via `UniversalQueue` and `UniversalEvent`.
    The API for these “universal” classes is the same inside and outside of coroutines,
    but in a coroutine, you need to prefix calls with `await`.'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '*Curio*还提供了一个`UniversalQueue`，可用于协调线程、*Curio*协程和`asyncio`协程之间的工作。没错，*Curio*具有允许其在一个线程中与另一个线程中的`asyncio`一起运行的功能，在同一进程中通过`UniversalQueue`和`UniversalEvent`进行通信。这些“通用”类的API在协程内外是相同的，但在协程中，您需要在调用前加上`await`前缀。'
- en: As I write this in October 2021, *HTTPX* is the first HTTP client library [compatible
    with *Curio*](https://fpy.li/21-55), but I don’t know of any asynchronous database
    libraries that support it yet. In the *Curio* repository there is an impressive
    set of [network programming examples](https://fpy.li/21-56), including one using
    *WebSocket*, and another implementing the [RFC 8305—Happy Eyeballs](https://fpy.li/21-57)
    concurrent algorithm for connecting to IPv6 endpoints with fast fallback to IPv4
    if needed.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在2021年10月写这篇文章时，*HTTPX*是第一个与*Curio*兼容的HTTP客户端库，但我还不知道有哪些异步数据库库支持它。在*Curio*存储库中有一组令人印象深刻的[网络编程示例](https://fpy.li/21-56)，包括一个使用*WebSocket*的示例，以及实现[RFC
    8305—Happy Eyeballs](https://fpy.li/21-57)并发算法的另一个示例，用于连接到IPv6端点，如果需要的话快速回退到IPv4。
- en: The design of *Curio* has been influential. The [*Trio*](https://fpy.li/21-58)
    framework started by Nathaniel J. Smith was heavily inspired by *Curio*. *Curio*
    may also have prompted Python contributors to improve the usability of the `asyncio`
    API. For example, in its earliest releases, `asyncio` users very often had to
    get and pass around a `loop` object because some essential functions were either
    `loop` methods or required a `loop` argument. In recent versions of Python, direct
    access to the loop is not needed as often, and in fact several functions that
    accepted an optional `loop` are now deprecating that argument.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '*Curio*的设计具有影响力。由Nathaniel J. Smith创建的[*Trio*](https://fpy.li/21-58)框架受*Curio*的启发很深。*Curio*可能也促使Python贡献者改进了`asyncio`
    API的可用性。例如，在最早的版本中，`asyncio`用户经常需要获取并传递`loop`对象，因为一些基本函数要么是`loop`方法，要么需要一个`loop`参数。在Python的最新版本中，不再经常需要直接访问循环，实际上，几个接受可选`loop`参数的函数现在正在弃用该参数。'
- en: Type annotations for asynchronous types are our next topic.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 异步类型的类型注释是我们下一个讨论的主题。
- en: Type Hinting Asynchronous Objects
  id: totrans-611
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步对象的类型提示
- en: The return type of a native coroutine describes what you get when you `await`
    on that coroutine, which is the type of the object that appears in the `return`
    statements in the body of the native coroutine function.^([18](ch21.html#idm46582379688400))
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 本机协程的返回类型描述了在该协程上`await`时会得到什么，这是出现在本机协程函数体中`return`语句的对象类型。^([18](ch21.html#idm46582379688400))
- en: 'This chapter provided many examples of annotated native coroutines, including
    `probe` from [Example 21-21](#blogdom_curio_ex):'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了许多带注释的本机协程示例，包括来自[示例 21-21](#blogdom_curio_ex)的`probe`：
- en: '[PRE41]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If you need to annotate a parameter that takes a coroutine object, then the
    generic type is:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要注释一个接受协程对象的参数，则通用类型是：
- en: '[PRE42]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'That type, and the following types were introduced in Python 3.5 and 3.6 to
    annotate asynchronous objects:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型以及以下类型是在Python 3.5和3.6中引入的，用于注释异步对象：
- en: '[PRE43]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: With Python ≥ 3.9, use the `collections.abc` equivalents of these.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python ≥ 3.9，使用这些的`collections.abc`等价物。
- en: I want to highlight three aspects of those generic types.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 我想强调这些通用类型的三个方面。
- en: 'First: they are all covariant on the first type parameter, which is the type
    of the items yielded from these objects. Recall rule #1 of [“Variance rules of
    thumb”](ch15.html#variance_rules_sec):'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点：它们在第一个类型参数上都是协变的，这是从这些对象中产生的项目的类型。回想一下[“协变法则”](ch15.html#variance_rules_sec)的规则#1：
- en: If a formal type parameter defines a type for data that comes out of the object,
    it can be covariant.
  id: totrans-622
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果一个正式类型参数定义了对象初始构造后传入对象的数据类型，那么它可以是逆变的。
- en: 'Second: `AsyncGenerator` and `Coroutine` are contravariant on the second to
    last parameter. That’s the type of the argument of the low-level `.send()` method
    that the event loop calls to drive asynchronous generators and coroutines. As
    such, it is an “input” type. Therefore, it can be contravariant, per Variance
    Rule of Thumb #2:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点：`AsyncGenerator`和`Coroutine`在倒数第二个参数上是逆变的。这是事件循环调用以驱动异步生成器和协程的低级`.send()`方法的参数类型。因此，它是一个“输入”类型。因此，它可以是逆变的，根据“逆变法则”#2：
- en: If a formal type parameter defines a type for data that goes into the object
    after its initial construction, it can be contravariant.
  id: totrans-624
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果一个正式类型参数定义了对象初始构造后进入对象的数据类型，那么它可以是逆变的。
- en: 'Third: `AsyncGenerator` has no return type, in contrast with `typing.Generator`,
    which we saw in [“Generic Type Hints for Classic Coroutines”](ch17.html#generic_classic_coroutine_types_sec).
    Returning a value by raising `StopIteration(value)` was one of the hacks that
    enabled generators to operate as coroutines and support `yield from`, as we saw
    in [“Classic Coroutines”](ch17.html#classic_coroutines_sec). There is no such
    overlap among the asynchronous objects: `AsyncGenerator` objects don’t return
    values, and are completely separate from native coroutine objects, which are annotated
    with `typing.Coroutine`.'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 第三点：`AsyncGenerator`没有返回类型，与我们在[“经典协程的通用类型提示”](ch17.html#generic_classic_coroutine_types_sec)中看到的`typing.Generator`形成对比。通过引发`StopIteration(value)`来返回值是使生成器能够作为协程运行并支持`yield
    from`的一种技巧，正如我们在[“经典协程”](ch17.html#classic_coroutines_sec)中看到的那样。在异步对象之间没有这种重叠：`AsyncGenerator`对象不返回值，并且与用`typing.Coroutine`注释的本机协程对象完全分开。
- en: Finally, let’s briefly discuss the advantages and challenges of asynchronous
    programming.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们简要讨论异步编程的优势和挑战。
- en: How Async Works and How It Doesn’t
  id: totrans-627
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步工作原理及其不足之处
- en: The sections closing this chapter discuss high-level ideas around asynchronous
    programming, regardless of the language or library you are using.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束部分讨论了关于异步编程的高层思想，无论您使用的是哪种语言或库。
- en: 'Let’s begin by explaining the #1 reason why asynchronous programming is appealing,
    followed by a popular myth, and how to deal with it.'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先解释为什么异步编程如此吸引人的第一个原因，接着是一个流行的神话，以及如何处理它。
- en: Running Circles Around Blocking Calls
  id: totrans-630
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绕过阻塞调用
- en: Ryan Dahl, the inventor of Node.js, introduces the philosophy of his project
    by saying “We’re doing I/O completely wrong.”^([19](ch21.html#idm46582379458256))
    He defines a *blocking function* as one that does file or network I/O, and argues
    that we can’t treat them as we treat nonblocking functions. To explain why, he
    presents the numbers in the second column of [Table 21-1](#latency_tbl).
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的发明者Ryan Dahl通过说“我们完全错误地进行I/O”来介绍他的项目的理念。他将*阻塞函数*定义为执行文件或网络I/O的函数，并认为我们不能像对待非阻塞函数那样对待它们。为了解释原因，他展示了[表21-1](#latency_tbl)的第二列中的数字。
- en: Table 21-1\. Modern computer latency for reading data from different devices;
    third column shows proportional times in a scale easier to understand for us slow
    humans
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 表21-1。从不同设备读取数据的现代计算机延迟；第三列显示了按比例的时间，这样我们这些慢人类更容易理解
- en: '| Device | CPU cycles | Proportional “human” scale |'
  id: totrans-633
  prefs: []
  type: TYPE_TB
  zh: '| 设备 | CPU周期 | 比例“人类”尺度 |'
- en: '| --- | --- | --- |'
  id: totrans-634
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| L1 cache | 3 | 3 seconds |'
  id: totrans-635
  prefs: []
  type: TYPE_TB
  zh: '| L1缓存 | 3 | 3秒 |'
- en: '| L2 cache | 14 | 14 seconds |'
  id: totrans-636
  prefs: []
  type: TYPE_TB
  zh: '| L2缓存 | 14 | 14秒 |'
- en: '| RAM | 250 | 250 seconds |'
  id: totrans-637
  prefs: []
  type: TYPE_TB
  zh: '| RAM | 250 | 250秒 |'
- en: '| disk | 41,000,000 | 1.3 years |'
  id: totrans-638
  prefs: []
  type: TYPE_TB
  zh: '| 磁盘 | 41,000,000 | 1.3年 |'
- en: '| network | 240,000,000 | 7.6 years |'
  id: totrans-639
  prefs: []
  type: TYPE_TB
  zh: '| 网络 | 240,000,000 | 7.6年 |'
- en: To make sense of [Table 21-1](#latency_tbl), bear in mind that modern CPUs with
    GHz clocks run billions of cycles per second. Let’s say that a CPU runs exactly
    1 billion cycles per second. That CPU can make more than 333 million L1 cache
    reads in 1 second, or 4 (four!) network reads in the same time. The third column
    of [Table 21-1](#latency_tbl) puts those numbers in perspective by multiplying
    the second column by a constant factor. So, in an alternate universe, if one read
    from L1 cache took 3 seconds, then a network read would take 7.6 years!
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解[表21-1](#latency_tbl)的意义，请记住具有GHz时钟的现代CPU每秒运行数十亿个周期。假设一个CPU每秒运行恰好10亿个周期。该CPU可以在1秒内进行超过3.33亿次L1缓存读取，或者在同一时间内进行4次（四次！）网络读取。[表21-1](#latency_tbl)的第三列通过将第二列乘以一个常数因子来将这些数字放入透视中。因此，在另一个宇宙中，如果从L1缓存读取需要3秒，那么从网络读取将需要7.6年！
- en: '[Table 21-1](#latency_tbl) explains why a disciplined approach to asynchronous
    programming can lead to high-performance servers. The challenge is achieving that
    discipline. The first step is to recognize that “I/O bound system” is a fantasy.'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '[表21-1](#latency_tbl)解释了为什么对异步编程采取纪律性方法可以导致高性能服务器。挑战在于实现这种纪律。第一步是认识到“I/O绑定系统”是一个幻想。'
- en: The Myth of I/O-Bound Systems
  id: totrans-642
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I/O绑定系统的神话
- en: A commonly repeated meme is that asynchronous programming is good for “I/O bound
    systems.” I learned the hard way that there are no “I/O-bound systems.” You may
    have I/O-bound *functions*. Perhaps the vast majority of the functions in your
    system are I/O bound; i.e., they spend more time waiting for I/O than crunching
    data. While waiting, they cede control to the event loop, which can then drive
    some other pending task. But inevitably, any nontrivial system will have some
    parts that are CPU bound. Even trivial systems reveal that, under stress. In [“Soapbox”](#async_soapbox),
    I tell the story of two asynchronous programs that struggled with CPU-bound functions
    slowing down the event loop with severe impact on performance.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的重复的梗是异步编程对“I/O 绑定系统”有好处。我以艰难的方式学到，没有“I/O 绑定系统”。你可能有 I/O 绑定*函数*。也许你系统中绝大多数函数都是
    I/O 绑定的；即它们花费更多时间等待 I/O 而不是处理数据。在等待时，它们将控制权让给事件循环，然后事件循环可以驱动其他挂起的任务。但不可避免地，任何非平凡系统都会有一些部分是
    CPU 绑定的。即使是微不足道的系统在压力下也会显露出来。在[“讲台”](#async_soapbox)中，我讲述了两个异步程序的故事，它们因 CPU 绑定函数减慢事件循环而严重影响性能。
- en: Given that any nontrivial system will have CPU-bound functions, dealing with
    them is the key to success in asynchronous programming.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于任何非平凡系统都会有 CPU 绑定函数，处理它们是异步编程成功的关键。
- en: Avoiding CPU-Bound Traps
  id: totrans-645
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免 CPU 绑定陷阱
- en: If you’re using Python at scale, you should have some automated tests designed
    specifically to detect performance regressions as soon as they appear. This is
    critically important with asynchronous code, but also relevant to threaded Python
    code—because of the GIL. If you wait until the slowdown starts bothering the development
    team, it’s too late. The fix will probably require some major makeover.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在规模上使用 Python，你应该有一些专门设计用于检测性能回归的自动化测试，一旦它们出现就立即检测到。这在异步代码中至关重要，但也与线程化的 Python
    代码相关—因为 GIL。如果你等到减速开始困扰开发团队，那就太晚了。修复可能需要一些重大改变。
- en: 'Here are some options for when you identify a CPU-hogging bottleneck:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 当你确定存在 CPU 占用瓶颈时，以下是一些选项：
- en: Delegate the task to a Python process pool.
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将任务委托给 Python 进程池。
- en: Delegate the task to an external task queue.
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将任务委托给外部任务队列。
- en: Rewrite the relevant code in Cython, C, Rust, or some other language that compiles
    to machine code and interfaces with the Python/C API, preferably releasing the
    GIL.
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用 Cython、C、Rust 或其他编译为机器码并与 Python/C API 接口的语言重写相关代码，最好释放 GIL。
- en: Decide that you can afford the performance hit and do nothing—but record the
    decision to make it easier to revert to it later.
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定你可以承受性能损失并且什么都不做—但记录这个决定以便以后更容易恢复。
- en: The external task queue should be chosen and integrated as soon as possible
    at the start of the project, so that nobody in the team hesitates to use it when
    needed.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 外部任务队列应该在项目开始时尽快选择和集成，这样团队中的任何人在需要时都不会犹豫使用它。
- en: The last option—do nothing—falls in the category of [technical debt](https://fpy.li/21-60).
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选项—什么都不做—属于[技术债务](https://fpy.li/21-60)类别。
- en: Concurrent programming is a fascinating topic, and I would like to write a lot
    more about it. But it is not the main focus of this book, and this is already
    one of the longest chapters, so let’s wrap it up.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程是一个迷人的话题，我很想写更多关于它的内容。但这不是本书的主要焦点，而且这已经是最长的章节之一，所以让我们结束吧。
- en: Chapter Summary
  id: totrans-655
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节总结
- en: The problem with normal approaches to asynchronous programming is that they’re
    all-or-nothing propositions. You rewrite all your code so none of it blocks or
    you’re just wasting your time.
  id: totrans-656
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于常规的异步编程方法的问题在于它们都是全有或全无的命题。你要重写所有代码，以便没有任何阻塞，否则你只是在浪费时间。
- en: ''
  id: totrans-657
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Alvaro Videla and Jason J. W. Williams, *RabbitMQ in Action*
  id: totrans-658
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Alvaro Videla 和 Jason J. W. Williams，《RabbitMQ 实战》
- en: 'I chose that epigraph for this chapter for two reasons. At a high level, it
    reminds us to avoid blocking the event loop by delegating slow tasks to a different
    processing unit, from a simple thread all the way to a distributed task queue.
    At a lower level, it is also a warning: once you write your first `async def`,
    your program is inevitably going to have more and more `async def`, `await`, `async
    with`, and `async for`. And using non-asynchronous libraries suddenly becomes
    a challenge.'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择这个章节的引语有两个原因。在高层次上，它提醒我们通过将慢任务委托给不同的处理单元来避免阻塞事件循环，从简单的线程到分布式任务队列。在较低层次上，它也是一个警告：一旦你写下第一个`async
    def`，你的程序不可避免地会有越来越多的`async def`、`await`、`async with`和`async for`。并且使用非异步库突然变得具有挑战性。
- en: After the simple *spinner* examples in [Chapter 19](ch19.html#concurrency_models_ch),
    here our main focus was asynchronous programming with native coroutines, starting
    with the *blogdom.py* DNS probing example, followed by the concept of *awaitables*.
    While reading the source code of *flags_asyncio.py*, we found the first example
    of an *asynchronous context manager*.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第19章](ch19.html#concurrency_models_ch)中简单的*spinner*示例之后，我们的主要重点是使用本机协程进行异步编程，从*blogdom.py*
    DNS 探测示例开始，接着是*awaitables*的概念。在阅读*flags_asyncio.py*的源代码时，我们发现了第一个*异步上下文管理器*的示例。
- en: 'The more advanced variations of the flag downloading program introduced two
    powerful functions: the `asyncio.as_completed` generator and the `loop.run_in_executor`
    coroutine. We also saw the concept and application of a semaphore to limit the
    number of concurrent downloads—as expected from well-behaved HTTP clients.'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: flag 下载程序的更高级变体引入了两个强大的函数：`asyncio.as_completed` 生成器和`loop.run_in_executor`
    协程。我们还看到了使用信号量限制并发下载数量的概念和应用—这是对表现良好的 HTTP 客户端的预期。
- en: 'Server-side asynchronous programming was presented through the *mojifinder*
    examples: a *FastAPI* web service and *tcp_mojifinder.py*—the latter using just
    `asyncio` and the TCP protocol.'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端异步编程通过*mojifinder*示例进行展示：一个*FastAPI* web 服务和*tcp_mojifinder.py*—后者仅使用`asyncio`和
    TCP 协议。
- en: Asynchronous iteration and asynchronous iterables were the next major topic,
    with sections on `async for`, Python’s async console, asynchronous generators,
    asynchronous generator expressions, and asynchronous comprehensions.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 异步迭代和异步可迭代是接下来的主要话题，包括`async for`、Python 的异步控制台、异步生成器、异步生成器表达式和异步推导式。
- en: The last example in the chapter was *blogdom.py* rewritten with the *Curio*
    framework, to demonstrate how Python’s asynchronous features are not tied to the
    `asyncio` package. *Curio* also showcases the concept of *structured concurrency*,
    which may have an industry-wide impact, bringing more clarity to concurrent code.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一个示例是使用*Curio*框架重写的*blogdom.py*，以演示 Python 的异步特性并不局限于`asyncio`包。*Curio*还展示了*结构化并发*的概念，这可能对整个行业产生影响，为并发代码带来更多的清晰度。
- en: Finally, the sections under [“How Async Works and How It Doesn’t”](#how_async_works_and_does_not_sec)
    discuss the main appeal of asynchronous programming, the misconception of “I/O-bound
    systems,” and dealing with the inevitable CPU-bound parts of your program.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在[“异步工作原理及其不足之处”](#how_async_works_and_does_not_sec)下的章节中讨论了异步编程的主要吸引力，对“I/O-bound
    系统”的误解，以及如何处理程序中不可避免的 CPU-bound 部分。
- en: Further Reading
  id: totrans-666
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: David Beazley’s PyOhio 2016 keynote [“Fear and Awaiting in Async”](https://fpy.li/21-61)
    is a fantastic, live-coded introduction to the potential of the language features
    made possible by Yury Selivanov’s contribution of the `async/await` keywords in
    Python 3.5. At one point, Beazley complains that `await` can’t be used in list
    comprehensions, but that was fixed by Selivanov in [PEP 530—Asynchronous Comprehensions](https://fpy.li/pep530),
    implemented in Python 3.6 later in that same year. Apart from that, everything
    else in Beazley’s keynote is timeless, as he demonstrates how the asynchronous
    objects we saw in this chapter work, without the help of any framework—just a
    simple `run` function using `.send(None)` to drive coroutines. Only at the very
    end Beazley shows [*Curio*](https://fpy.li/21-62), which he started that year
    as an experiment to see how far can you go doing asynchronous programming without
    a foundation of callbacks or futures, just coroutines. As it turns out, you can
    go very far—as demonstrated by the evolution of *Curio* and the later creation
    of [*Trio*](https://fpy.li/21-58) by Nathaniel J. Smith. *Curio’s* documentation
    has [links](https://fpy.li/21-64) to more talks by Beazley on the subject.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 大卫·比兹利在 PyOhio 2016 年的主题演讲[“异步中的恐惧和期待”](https://fpy.li/21-61)是一个精彩的、现场编码的介绍，展示了由尤里·谢利万诺夫在
    Python 3.5 中贡献的`async/await`关键字所可能带来的语言特性的潜力。在演讲中，比兹利曾抱怨`await`不能在列表推导式中使用，但谢利万诺夫在同年稍后实现了[PEP
    530—异步推导式](https://fpy.li/pep530)，并在 Python 3.6 中修复了这个问题。除此之外，比兹利演讲中的其他内容都是永恒的，他演示了本章中我们看到的异步对象是如何工作的，而无需任何框架的帮助——只需一个简单的`run`函数，使用`.send(None)`来驱动协程。仅在最后，比兹利展示了[*Curio*](https://fpy.li/21-62)，这是他在那一年开始的一个实验，看看在没有回调或未来基础的情况下，只使用协程能走多远。事实证明，你可以走得很远——正如*Curio*的演变和后来由纳撒尼尔·J·史密斯创建的[*Trio*](https://fpy.li/21-58)所证明的那样。*Curio*的文档中有[链接](https://fpy.li/21-64)指向比兹利在该主题上的更多讲话。
- en: 'Besides starting *Trio*, Nathaniel J. Smith wrote two deep blog posts that
    I highly recommend: [“Some thoughts on asynchronous API design in a post-async/await
    world”](https://fpy.li/21-65), contrasting the design of *Curio* with that of
    *asyncio*,and [“Notes on structured concurrency, or: Go statement considered harmful”](https://fpy.li/21-66),
    about structured concurrency. Smith also gave a long and informative answer to
    the question: [“What is the core difference between asyncio and trio?”](https://fpy.li/21-67)
    on StackOverflow.'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建*Trio*，纳撒尼尔·J·史密斯还撰写了两篇深度博客文章，我强烈推荐：[“在后 async/await 世界中对异步 API 设计的一些思考”](https://fpy.li/21-65)，对比了*Curio*的设计与*asyncio*的设计，以及[“关于结构化并发的笔记，或者：Go
    语句为何有害”](https://fpy.li/21-66)，关于结构化并发。史密斯还在 StackOverflow 上对问题[“asyncio 和 trio
    之间的核心区别是什么？”](https://fpy.li/21-67)给出了一篇长而富有信息量的回答。
- en: 'To learn more about the *asyncio* package, I’ve mentioned the best written
    resources I know at the start of this chapter: the [official documentation](https://fpy.li/21-1)
    after the outstanding [overhaul](https://fpy.li/21-69) started by Yury Selivanov
    in 2018, and Caleb Hattingh’s book [*Using Asyncio in Python*](https://fpy.li/hattingh)
    (O’Reilly). In the official documentation, make sure to read [“Developing with
    asyncio”](https://fpy.li/21-70): documenting the *asyncio* debug mode, and also
    discussing common mistakes and traps and how to avoid them.'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于*asyncio*包的信息，我在本章开头提到了我所知道的最好的书面资源：由尤里·谢利万诺夫在 2018 年开始的[官方文档](https://fpy.li/21-1)以及卡勒布·哈廷的书籍[*Using
    Asyncio in Python*](https://fpy.li/hattingh)（O’Reilly）。在官方文档中，请务必阅读[“使用 asyncio
    进行开发”](https://fpy.li/21-70)：记录了*asyncio*调试模式，并讨论了常见的错误和陷阱以及如何避免它们。
- en: For a very accessible, 30-minute introduction to asynchronous programming in
    general and also *asyncio*, watch Miguel Grinberg’s [“Asynchronous Python for
    the Complete Beginner”](https://fpy.li/21-71), presented at PyCon 2017. Another
    great introduction is [“Demystifying Python’s Async and Await Keywords”](https://fpy.li/21-72),
    presented by Michael Kennedy, where among other things I learned about the [*unsync*](https://fpy.li/21-73)
    library that provides a decorator to delegate the execution of coroutines, I/O-bound
    functions, and CPU-bound functions to `asyncio`, `threading`, or `multiprocessing`
    as needed.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 对于异步编程的一个非常易懂的、30分钟的介绍，以及*asyncio*，可以观看米格尔·格林伯格在 PyCon 2017 上的[“面向完全初学者的异步 Python”](https://fpy.li/21-71)。另一个很好的介绍是迈克尔·肯尼迪的[“揭秘
    Python 的 Async 和 Await 关键字”](https://fpy.li/21-72)，其中我了解到了[*unsync*](https://fpy.li/21-73)库，提供了一个装饰器来将协程、I/O-bound
    函数和 CPU-bound 函数的执行委托给`asyncio`、`threading`或`multiprocessing`。
- en: 'At EuroPython 2019, Lynn Root—a global leader of [*PyLadies*](https://fpy.li/21-74)—presented
    the excellent [“Advanced asyncio: Solving Real-world Production Problems”](https://fpy.li/21-75),
    informed by her experience using Python as a staff engineer at Spotify.'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 在 EuroPython 2019 上，Lynn Root —— [*PyLadies*](https://fpy.li/21-74) 的全球领导者 ——
    呈现了优秀的 [“高级 asyncio：解决实际生产问题”](https://fpy.li/21-75)，这是她在 Spotify 担任工程师的经验所得。
- en: 'In 2020, Łukasz Langa recorded a series of great videos about *asyncio*, starting
    with [“Learn Python’s AsyncIO #1—The Async Ecosystem”](https://fpy.li/21-76).
    Langa also made the super cool video [“AsyncIO + Music”](https://fpy.li/21-77)
    for PyCon 2020 that not only shows *asyncio* applied in a very concrete event-oriented
    domain, but also explains it from the ground up.'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '在 2020 年，Łukasz Langa 制作了一系列关于 *asyncio* 的优秀视频，从 [“学习 Python 的 AsyncIO #1—异步生态系统”](https://fpy.li/21-76)
    开始。Langa 还制作了非常酷的视频 [“AsyncIO + 音乐”](https://fpy.li/21-77) 为 2020 年的 PyCon，不仅展示了
    *asyncio* 在一个非常具体的事件驱动领域中的应用，还从基础开始解释了它。'
- en: Another area dominated by event-oriented programming is embedded systems. That’s
    why Damien George added support for `async/await` in his [*MicroPython*](https://fpy.li/21-78)
    interpreter for microcontrollers. At PyCon Australia 2018, Matt Trentini demonstrated
    the [*uasyncio*](https://fpy.li/21-79) library, a subset of *asyncio* that is
    part of MicroPython’s standard library.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个被事件驱动编程主导的领域是嵌入式系统。这就是为什么 Damien George 在他的 [*MicroPython*](https://fpy.li/21-78)
    解释器中为微控制器添加了对 `async/await` 的支持。在 2018 年的澳大利亚 PyCon 上，Matt Trentini 展示了 [*uasyncio*](https://fpy.li/21-79)
    库，这是 MicroPython 标准库中 *asyncio* 的一个子集。
- en: For higher-level thinking about async programming in Python, read the blog post
    [“Python async frameworks—Beyond developer tribalism”](https://fpy.li/21-80) by
    Tom Christie.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 想要更深入地思考 Python 中的异步编程，请阅读 Tom Christie 的博文 [“Python 异步框架—超越开发者部落主义”](https://fpy.li/21-80)。
- en: 'Finally, I recommend [“What Color Is Your Function?”](https://fpy.li/21-81)
    by Bob Nystrom, discussing the incompatible execution models of plain functions
    versus async functions—a.k.a. coroutines—in JavaScript, Python, C#, and other
    languages. Spoiler alert: Nystrom’s conclusion is that the language that got this
    right is Go, where all functions are the same color. I like that about Go. But
    I also think Nathaniel J. Smith has a point when he wrote [“Go statement considered
    harmful”](https://fpy.li/21-66). Nothing is perfect, and concurrent programming
    is always hard.'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我推荐阅读 Bob Nystrom 的 [“你的函数是什么颜色？”](https://fpy.li/21-81)，讨论了普通函数与异步函数（即协程）在
    JavaScript、Python、C# 和其他语言中不兼容的执行模型。剧透警告：Nystrom 的结论是，做对了的语言是 Go，那里所有函数都是同一颜色。我喜欢
    Go 的这一点。但我也认为 Nathaniel J. Smith 在他写的 [“Go 语句有害”](https://fpy.li/21-66) 中有一定道理。没有什么是完美的，而并发编程总是困难的。
- en: '^([1](ch21.html#idm46582386210816-marker)) Videla & Williams, *RabbitMQ in
    Action* (Manning), Chapter 4, “Solving Problems with Rabbit: coding and patterns,”
    p. 61.'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch21.html#idm46582386210816-marker)) Videla & Williams 的 *RabbitMQ 实战*（Manning），第
    4 章，“用 Rabbit 解决问题：编码和模式”，第 61 页。
- en: ^([2](ch21.html#idm46582386189120-marker)) Selivanov implemented `async/await`
    in Python, and wrote the related PEPs [492](https://fpy.li/pep492), [525](https://fpy.li/pep525),
    and [530](https://fpy.li/pep530).
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch21.html#idm46582386189120-marker)) Selivanov 在 Python 中实现了 `async/await`，并撰写了相关的
    PEPs [492](https://fpy.li/pep492)、[525](https://fpy.li/pep525) 和 [530](https://fpy.li/pep530)。
- en: '^([3](ch21.html#idm46582386163264-marker)) There is one exception to this rule:
    if you run Python with the `-m asyncio` option, you can use `await` directly at
    the `>>>` prompt to drive a native coroutine. This is explained in [“Experimenting
    with Python’s async console”](#python_async_console_sec).'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch21.html#idm46582386163264-marker)) 有一个例外：如果你使用 `-m asyncio` 选项运行 Python，你可以直接在
    `>>>` 提示符下使用 `await` 驱动本机协程。这在 [“使用 Python 的异步控制台进行实验”](#python_async_console_sec)
    中有解释。
- en: ^([4](ch21.html#idm46582386145744-marker)) Sorry, I could not resist it.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch21.html#idm46582386145744-marker)) 对不起，我忍不住了。
- en: ^([5](ch21.html#idm46582386094176-marker)) `true.dev` is available for USD 360/year
    as I write this. I see that `for.dev` is registered, but has no DNS configured.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch21.html#idm46582386094176-marker)) 我写这篇文章时，`true.dev` 的年费为 360 美元。我看到
    `for.dev` 已注册，但未配置 DNS。
- en: ^([6](ch21.html#idm46582384952208-marker)) This tip is quoted verbatim from
    a comment by tech reviewer Caleb Hattingh. Thanks, Caleb!
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch21.html#idm46582384952208-marker)) 这个提示是由技术审阅员 Caleb Hattingh 的评论原文引用。谢谢，Caleb！
- en: ^([7](ch21.html#idm46582384449712-marker)) Thanks to Guto Maia who noted that
    the concept of a semaphore was not explained when he read the first edition draft
    for this chapter.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch21.html#idm46582384449712-marker)) 感谢 Guto Maia 指出，在他阅读本章第一版草稿时，信号量的概念没有得到解释。
- en: ^([8](ch21.html#idm46582383884976-marker)) A detailed discussion about this
    can be found in a thread I started in the python-tulip group, titled [“Which other
    futures may come out of asyncio.as_completed?”](https://fpy.li/21-19). Guido responds,
    and gives insight on the implementation of `as_completed`, as well as the close
    relationship between futures and coroutines in *asyncio*.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch21.html#idm46582383884976-marker)) 关于这个问题的详细讨论可以在我在 python-tulip 群组中发起的一个主题中找到，标题为
    [“asyncio.as_completed 还可能产生哪些其他 futures？”](https://fpy.li/21-19)。Guido 回应，并就
    `as_completed` 的实现以及 *asyncio* 中 futures 和协程之间的密切关系提供了见解。
- en: ^([9](ch21.html#idm46582383296240-marker)) The boxed question mark in the screen
    shot is not a defect of the book or ebook you are reading. It’s the U+101EC—PHAISTOS
    DISC SIGN CAT character, which is missing from the font in the terminal I used.
    The [Phaistos disc](https://fpy.li/21-26) is an ancient artifact inscribed with
    pictograms, discovered in the island of Crete.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch21.html#idm46582383296240-marker)) 屏幕截图中的带框问号不是你正在阅读的书籍或电子书的缺陷。这是 U+101EC—PHAISTOS
    DISC SIGN CAT 字符，这个字符在我使用的终端字体中缺失。[Phaistos 圆盘](https://fpy.li/21-26) 是一件古代文物，上面刻有象形文字，发现于克里特岛。
- en: ^([10](ch21.html#idm46582383270064-marker)) Instead of *uvicorn*, you may use
    another ASGI server, such as *hypercorn* or *Daphne*. See the official ASGI documentation
    [page about implementations](https://fpy.li/21-30) for more information.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch21.html#idm46582383270064-marker)) 你可以使用另一个 ASGI 服务器，如 *hypercorn*
    或 *Daphne*，而不是 *uvicorn*。查看官方 ASGI 文档中关于 [实现](https://fpy.li/21-30) 的页面获取更多信息。
- en: ^([11](ch21.html#idm46582382999680-marker)) Thanks to tech reviewer Miroslav
    Šedivý for highlighting good places to use `pathlib` in code examples.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch21.html#idm46582382999680-marker)) 感谢技术审阅员Miroslav Šedivý指出在代码示例中使用`pathlib`的好地方。
- en: ^([12](ch21.html#idm46582382964064-marker)) As mentioned in [Chapter 8](ch08.html#type_hints_in_def_ch),
    [*pydantic*](https://fpy.li/21-31) enforces type hints at runtime, for data validation.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: ^([12](ch21.html#idm46582382964064-marker)) 如[第8章](ch08.html#type_hints_in_def_ch)中所述，[*pydantic*](https://fpy.li/21-31)在运行时强制执行类型提示，用于数据验证。
- en: '^([13](ch21.html#idm46582382561568-marker)) Issue #5535 is closed as of October
    2021, but Mypy did not have a new release since then, so the error persists.'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: ^([13](ch21.html#idm46582382561568-marker)) 截至2021年10月，问题＃5535已关闭，但自那时起Mypy并没有发布新版本，因此错误仍然存在。
- en: ^([14](ch21.html#idm46582382550512-marker)) Tech reviewer Leonardo Rochael pointed
    out that building the index could be delegated to another thread using `loop.run_with_executor()`
    in the `supervisor` coroutine, so the server would be ready to take requests immediately
    while the index is built. That’s true, but querying the index is the only thing
    this server does, so it would not be a big win in this example.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: ^([14](ch21.html#idm46582382550512-marker)) 技术审阅员Leonardo Rochael指出，可以使用`loop.run_with_executor()`在`supervisor`协程中将构建索引的工作委托给另一个线程，因此服务器在构建索引的同时即可立即接受请求。这是正确的，但在这个示例中，查询索引是这个服务器唯一要做的事情，所以这并不会带来很大的收益。
- en: ^([15](ch21.html#idm46582381736688-marker)) This is great for experimentation,
    like the Node.js console. Thanks to Yury Selivanov for yet another excellent contribution
    to asynchronous Python.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: ^([15](ch21.html#idm46582381736688-marker)) 这对于像Node.js控制台这样的实验非常有用。感谢Yury Selivanov为异步Python做出的又一次出色贡献。
- en: ^([16](ch21.html#idm46582381523904-marker)) See [RFC 6761—Special-Use Domain
    Names](https://fpy.li/21-45).
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: ^([16](ch21.html#idm46582381523904-marker)) 请参阅[RFC 6761—特殊用途域名](https://fpy.li/21-45)。
- en: ^([17](ch21.html#idm46582380179328-marker)) That’s in contrast with JavaScript,
    where `async/await` is hardwired to the built-in event loop and runtime environment,
    i.e., a browser, Node.js, or Deno.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: ^([17](ch21.html#idm46582380179328-marker)) 这与 JavaScript 相反，其中`async/await`被硬编码到内置事件循环和运行时环境中，即浏览器、Node.js
    或 Deno。
- en: ^([18](ch21.html#idm46582379688400-marker)) This differs from the annotations
    of classic coroutines, as discussed in [“Generic Type Hints for Classic Coroutines”](ch17.html#generic_classic_coroutine_types_sec).
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: ^([18](ch21.html#idm46582379688400-marker)) 这与经典协程的注解不同，如[“经典协程的通用类型提示”](ch17.html#generic_classic_coroutine_types_sec)中所讨论的。
- en: '^([19](ch21.html#idm46582379458256-marker)) Video: [“Introduction to Node.js”](https://fpy.li/21-59)
    at 4:55.'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: ^([19](ch21.html#idm46582379458256-marker)) 视频：[“Node.js简介”](https://fpy.li/21-59)在4:55处。
- en: ^([20](ch21.html#idm46582379354736-marker)) Using a single thread was the default
    setting until Go 1.5 was released. Years before, Go had already earned a well-deserved
    reputation for enabling highly concurrent networked systems. One more evidence
    that concurrency doesn’t require multiple threads or CPU cores.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: ^([20](ch21.html#idm46582379354736-marker)) 直到 Go 1.5 发布之前，使用单个线程是默认设置。多年前，Go
    已经因为能够实现高度并发的网络系统而赢得了当之无愧的声誉。这是另一个证据，表明并发不需要多个线程或 CPU 核心。
- en: '^([21](ch21.html#idm46582379338768-marker)) Regardless of technical choices,
    this was probably the biggest mistake in this project: the stakeholders did not
    go for an MVP approach—delivering a Minimum Viable Product as soon as possible,
    and then adding features at a steady pace.'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: ^([21](ch21.html#idm46582379338768-marker)) 不管技术选择如何，这可能是这个项目中最大的错误：利益相关者没有采用MVP方法——尽快交付一个最小可行产品，然后以稳定的步伐添加功能。
