<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 9. Linting with Ruff and pre-commit"><div class="chapter" id="chapter_linting">
<h1><span class="label">Chapter 9. </span>Linting with Ruff and pre-commit</h1>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id310">
<h1>A Note for Early Release Readers</h1>
<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>

<p>This will be the ninth chapter of the final book. Please note that the GitHub repo will be made active later on.</p>

<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the author at <a href="mailto:mail@claudiojolowicz.com">mail@claudiojolowicz.com</a>.</p>
</div></aside>

<p>In 1978, Stephen C. Johnson, a researcher at Bell Labs, wrote a program that
could detect a number of bugs and obscurities in C code. He named the program
after the fluff on your pullover when you take it out of the washing machine:
Lint. It was to become the first in a long line of <em>linters</em>, programs that
analyze source code and point out problematic constructs.</p>

<p>Linters don’t <em>run</em> a program to discover issues with it; they read and analyze
its source code. This process is known as <em>static analysis</em>, as opposed to
<em>runtime</em> (or <em>dynamic</em>) <em>analysis</em>. It makes linters both fast and safe—​you
needn’t worry about side effects, such as requests to production systems. Static
checks can be smart and also fairly complete—​you needn’t hit the right
combination of edge cases to dig up a latent bug.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Static analysis is powerful, but you should still write tests for your programs.
Where static checks use deduction, tests use observation. Linters verify a
limited set of generic code properties, while tests can validate that a program
satisfies its requirements.</p>
</div>

<p>Linters are also great at enforcing a readable and consistent style, with a
preference for idiomatic and modern constructs over obscure and deprecated
syntax. Organizations have adopted style guides for years, such as the
recommendations in <a href="https://peps.python.org/pep-0008/">PEP 8</a> or the
<a href="https://google.github.io/styleguide/pyguide.html">Google Style Guide for Python</a>.
Linters can function as <em>executable</em> style guides: by flagging offending
constructs automatically, they keep code review focused on the meaning of a
change, rather than stylistic nitpicks.</p>

<p>This chapter has three parts:</p>

<ul>
<li>
<p>The first part introduces the Ruff linter, a Rust implementation of Python
linters that automatically fixes many of the issues it detects.</p>
</li>
<li>
<p>The second part describes pre-commit, a linter framework with Git integration.</p>
</li>
<li>
<p>The third part presents the Ruff code formatter, a Rust implementation of the
Black code style.</p>
</li>
</ul>

<p>But first, let’s look at a typical problem that linters help you solve.</p>






<section data-type="sect1" data-pdf-bookmark="Linting Basics"><div class="sect1" id="section_linting_basics">
<h1>Linting Basics</h1>

<p>The constructs flagged by linters may not be outright illegal. More often, they
just trigger your spider sense that something might be wrong. Consider the
Python code in <a data-type="xref" href="#example_linting_mutable_default">Example 9-1</a>.</p>
<div id="example_linting_mutable_default" data-type="example">
<h5><span class="label">Example 9-1. </span>Can you spot the problem?</h5>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code> <code class="nn">subprocess</code>

<code class="k">def</code> <code class="nf">run</code><code class="p">(</code><code class="n">command</code><code class="p">,</code> <code class="n">args</code><code class="o">=</code><code class="p">[],</code> <code class="n">force</code><code class="o">=</code><code class="kc">False</code><code class="p">):</code>
    <code class="k">if</code> <code class="n">force</code><code class="p">:</code>
        <code class="n">args</code><code class="o">.</code><code class="n">insert</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="s2">"--force"</code><code class="p">)</code>
    <code class="n">subprocess</code><code class="o">.</code><code class="n">run</code><code class="p">([</code><code class="n">command</code><code class="p">,</code> <code class="o">*</code><code class="n">args</code><code class="p">])</code></pre></div>

<p>If you haven’t been bitten by this bug before, you may be surprised to find that
the function sometimes passes <code>--force</code> to the command when it shouldn’t:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <strong>subprocess.run = print</strong>  # print commands instead of running them
&gt;&gt;&gt; <strong>run("myscript.py", force=True)</strong>
['myscript.py', '--force']
&gt;&gt;&gt; <strong>run("myscript.py")</strong>
['myscript.py', '--force']
</pre>

<p>The bug is known as a <em>mutable argument default</em>. Python evaluates argument
defaults when a function is defined, not when you call it. In other words, both
of your calls used the same list as the default for <code>args</code>. The first call
appended the item <code>"--force"</code>, so that item got passed to the second call, as
well.</p>

<p>Linters can detect pitfalls like this, warn you about them, and even fix them
for you. Let’s use a linter named Ruff on the function—​you’ll hear a lot more
about it in this chapter. For now, just take note of its error message, which
identifies the bug:<sup><a data-type="noteref" id="id311-marker" href="ch09.html#id311">1</a></sup></p>
<pre data-type="programlisting">$ <strong>pipx run ruff check --extend-select B</strong>
bad.py:3:23: B006 Do not use mutable data structures for argument defaults
Found 1 error.
No fixes available (1 hidden fix can be enabled with the `--unsafe-fixes` option)
</pre>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_linting_history">
<h1>A Short History of Python Linters</h1>
<p>Two tools have dominated linting for much of Python’s history: Pylint and Flake8.</p>

<p><a href="https://pylint.readthedocs.io/">Pylint</a> (2001) is the <em>grande dame</em> of Python
linting. It takes an all-encompassing approach, with hundreds of checks. It
requires a certain amount of upfront configuration, but it’s famous for its
thoroughness.</p>

<p>In 2010, a simpler tool with an out-of-the-box experience saw the light of day:
<a href="https://flake8.pycqa.org/">Flake8</a>. It doesn’t define any checks of its
own—​instead, it exposes a plugin system for other linters. It runs two
fundamental linters by default: Pyflakes detects syntax errors and potential
bugs, while Pycodestyle enforces the PEP 8 style guide. (A third linter, Mccabe,
limits code complexity; it’s disabled by default.) Flake8 laid the groundwork
for a vast and growing ecosystem of linter plugins.</p>

<p>In recent years, the Python code quality ecosystem has seen significant changes,
spearheaded by three tools: Black, mypy, and Ruff.</p>

<ul>
<li>
<p>The rise of the code formatter <a href="https://black.readthedocs.io/">Black</a> has made
countless stylistic checks unnecessary. It’s named after Henry Ford’s adage,
“any color the customer wants, as long as it’s black.” Black uncompromisingly
applies the same code style to every project that adopts it.</p>
</li>
<li>
<p>Type checkers like <a href="https://mypy.readthedocs.io/">mypy</a> have taken over the
large realm of type-related linter checks—​for example, detecting function
calls with the wrong type of argument. I’ll discuss type checking in
<a data-type="xref" href="ch10.html#chapter_typing">Chapter 10</a>.</p>
</li>
<li>
<p><a href="https://docs.astral.sh/ruff/">Ruff</a> re-implements an entire ecosystem of Python
code-quality tooling in Rust, including Flake8, Pylint, and Black. Besides
offering a unified experience, Ruff speeds up checks by up to two orders of
magnitude.<sup><a data-type="noteref" id="id312-marker" href="ch09.html#id312">2</a></sup></p>
</li>
</ul>

<p>Historically, linters only emitted warnings about offending code, leaving the
thankless task of improving it to humans. Modern linters can fix many violations
automatically, including sophisticated tasks such as refactoring a Python
codebase to use modern language features.</p>
</div></aside>
</div></section>






<section data-type="sect1" data-pdf-bookmark="The Ruff Linter"><div class="sect1" id="section_linting_ruff">
<h1>The Ruff Linter</h1>

<p>Ruff is a blazingly fast open-source Python linter and code formatter, written
in the Rust programming language. Ruff’s linter re-implements dozens of Python
linters—​including many Flake8 plugins, Pylint, Pyupgrade, Bandit, Isort, and
more.</p>

<p>Astral, the company behind Ruff, also created the Python packaging tool uv (see
<a data-type="xref" href="ch02.html#section_environments_uv">“Managing Environments with uv”</a>), and they’ve assumed the stewardship of Rye, a
Python project manager (see <a data-type="xref" href="ch03.html#section_packages_rye">“Managing Packages with Rye”</a>). All of these tools are
implemented in Rust.</p>
<div data-type="tip"><h6>Tip</h6>
<p>If you manage your project with Rye, the Ruff linter and code formatter is
available under the commands <code>rye lint</code> and <code>rye fmt</code>, respectively.</p>
</div>

<p>Install Ruff globally with pipx:</p>
<pre data-type="programlisting">$ <strong>pipx install ruff</strong></pre>

<p>But wait—​how can pipx install a Rust program? The Ruff binary is available as a
wheel on PyPI, so Python folks like you and me can install it with good old pip
and pipx. You could even run it with <code>py -m ruff</code>.</p>

<p>Let’s look at another example of working with Ruff. Consider this refactoring of
HTTP headers, which replaces a list with a dictionary:</p>
<div id="example_linting_fstring" data-type="example">
<h5><span class="label">Example 9-2. </span>Converting a list of HTTP headers to a dictionary</h5>

<pre data-type="programlisting" data-code-language="python"><code class="n">headers</code> <code class="o">=</code> <code class="p">[</code><code class="sa">f</code><code class="s2">"User-Agent: </code><code class="si">{</code><code class="n">USER_AGENT</code><code class="si">}</code><code class="s2">"</code><code class="p">]</code> <code class="c1"># version 1</code>
<code class="n">headers</code> <code class="o">=</code> <code class="p">{</code><code class="sa">f</code><code class="s2">"User-Agent"</code><code class="p">:</code> <code class="n">USER_AGENT</code><code class="p">}</code>   <code class="c1"># version 2</code></pre></div>

<p>When you refactor f-strings, it’s easy to leave the <code>f</code> prefix behind after
removing placeholders. Ruff flags f-strings without placeholders—​they’re noisy,
they confuse readers, and somebody might have forgotten to include a
placeholder.</p>

<p>Run the command <code>ruff check</code>—the front-end for Ruff’s linter. Without arguments,
the command lints every Python file under your current directory, unless it’s
listed in a <em>.gitignore</em> file:</p>
<pre data-type="programlisting">$ <strong>ruff check</strong>
example.py:2:12: F541 [*] f-string without any placeholders
Found 1 error.
[*] 1 fixable with the `--fix` option.
</pre>

<p><a data-type="xref" href="#figure_ruff_codes">Figure 9-1</a> takes a closer look at Ruff’s diagnostic message.</p>

<figure><div id="figure_ruff_codes" class="figure">
<img src="assets/hmpt_0901.png" alt="The diagram shows an example warning from Ruff and identifies its parts. The first part is the location 'example.py:1:7:', which consists of a filename, line, and column. The second part is the rule code 'F541', which is composed of the linter prefix 'F' and the numeric code '541' for a specific rule of that linter. The third part is the sign '[*]', which informs you that a fix is available. The fourth and last part is the summary 'f-string without any placeholders'." width="2831" height="721"/>
<h6><span class="label">Figure 9-1. </span>A diagnostic message from Ruff</h6>
</div></figure>

<p>Ruff tells you where the violation occurred—​the file, line, and line
offset—​and gives you a short summary of what went wrong: <em>f-string without any
placeholders</em>. Two interesting bits are sandwiched between the location and the
summary: An alphanumeric code (<code>F541</code>) identifies the linter rule, and the sign
<code>[*]</code> indicates that Ruff can automatically fix the issue.</p>

<p>If you’re ever confused why you’re getting a warning, you can ask Ruff to
explain it using the command <code>ruff rule</code>:</p>
<pre data-type="programlisting">$ <strong>ruff rule F541</strong>
<b><u>f-string-missing-placeholders (F541)</u></b>

Derived from the <b>Pyflakes</b> linter.

Fix is always available.

<b><u>What it does</u></b>
Checks for f-strings that do not contain any placeholder expressions.

<b><u>Why is this bad?</u></b>
f-strings are a convenient way to format strings, but they are not
necessary if there are no placeholder expressions to format. In this
...</pre>

<p>Rule codes have a prefix of one or more letters, followed by three or more
digits. The prefix identifies a specific linter—​for example, the <code>F</code> in <code>F541</code>
stands for the Pyflakes linter. Ruff re-implements many more Python code-quality
tools—​as of this writing, it ships over 50 built-in plugins modeled after
existing tools. You can find out which linters are available using the command
<code>ruff linter</code>:</p>
<pre data-type="programlisting">$ <strong>ruff linter</strong>
   F Pyflakes
 E/W pycodestyle
 C90 mccabe
   I isort
   N pep8-naming
   D pydocstyle
  UP pyupgrade
... (50+ more lines)</pre>

<p>You can activate linters and individual rules for your project in its
<em>pyproject.toml</em> file. The setting <code>tool.ruff.lint.select</code> enables any rules
whose code starts with one of the given prefixes. Out of the box, Ruff enables
some basic all-around checks from Pyflakes and Pycodestyle:</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[tool.ruff.lint]</code><code class="w"/>
<code class="n">select</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"E4"</code><code class="p">,</code><code class="w"> </code><code class="s2">"E7"</code><code class="p">,</code><code class="w"> </code><code class="s2">"E9"</code><code class="p">,</code><code class="w"> </code><code class="s2">"F"</code><code class="p">]</code><code class="w"/></pre>








<section data-type="sect2" data-pdf-bookmark="Pyflakes and Pycodestyle"><div class="sect2" id="id188">
<h2>Pyflakes and Pycodestyle</h2>

<p>Pyflakes (<code>F</code>) flags constructs that are almost certainly mistakes, such as
unused imports or the pointless f-strings you’ve seen above. It steers clear of
any questions of style. Pycodestyle (whose rules use the prefixes <code>E</code> and <code>W</code>),
detects violations of PEP 8, the style guide originally written by Python’s
inventor, Guido van Rossum, together with Barry Warsaw and Alyssa Coghlan.</p>

<p>Ruff enables only a subset of Pycodestyle by default, because code formatters
have obviated many of its checks. Still, PEP 8 makes style recommendations that
go beyond mere code formatting. Would you agree that <code>x is not None</code> sounds more
natural than <code>not x is None</code>? The default rules detect and fix a number of such
issues, leading to code that’s easier to read and understand.</p>
<div data-type="tip"><h6>Tip</h6>
<p>If you aren’t using an opinionated code formatter, consider enabling the entire
<code>E</code> and <code>W</code> blocks. Their automatic fixes help ensure minimal PEP 8 compliance.
They’re similar to, but not yet as feature-complete as, the Autopep8 formatter
(see <a data-type="xref" href="#section_linting_autopep8">“Approaches to Code Formatting: Autopep8”</a>).<sup><a data-type="noteref" id="id313-marker" href="ch09.html#id313">3</a></sup></p>
</div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Fantastic Linters and Where to Find Them"><div class="sect2" id="id189">
<h2>Fantastic Linters and Where to Find Them</h2>

<p>Ruff has too many rules to describe in this book, and more are being added all
the time. How do you find the good ones for your project? Try them out!
Depending on your project, you may want to enable individual rules (<code>"B006"</code>),
groups of rules (<code>"E4"</code>), entire plugins (<code>"B"</code>), or even every existing plugin
at the same time (<code>"ALL"</code>).</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Reserve the special <code>ALL</code> code for experimentation: it will implicitly enable
new linters whenever you upgrade Ruff. Beware: some plugins require
configuration to produce useful results, and some rules conflict with other
rules.<sup><a data-type="noteref" id="id314-marker" href="ch09.html#id314">4</a></sup></p>
</div>

<p>Besides <code>select</code>, Ruff has an <code>extend-select</code> directive which selects rules in
addition to the default set (see <a data-type="xref" href="#section_linting_basics">“Linting Basics”</a>). Generally, you
should prefer the <code>select</code> directive, because it keeps your configuration
self-contained and explicit:</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[tool.ruff.lint]</code><code class="w"/>
<code class="n">select</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"E"</code><code class="p">,</code><code class="w"> </code><code class="s2">"W"</code><code class="p">,</code><code class="w"> </code><code class="s2">"F"</code><code class="p">,</code><code class="w"> </code><code class="s2">"B006"</code><code class="p">]</code><code class="w"/></pre>

<p>If you’re unsure where to start, <a data-type="xref" href="#table_linting_ruff_plugins">Table 9-1</a> describes a
dozen built-in plugins to try.</p>
<table id="table_linting_ruff_plugins">
<caption><span class="label">Table 9-1. </span>A dozen widely useful Ruff plugins</caption>
<thead>
<tr>
<th>Prefix</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>RUF</code></p></td>
<td><p>Ruff-specific rules</p></td>
<td><p>A collection of lints native to Ruff</p></td>
</tr>
<tr>
<td><p><code>I</code></p></td>
<td><p><code>isort</code></p></td>
<td><p>Group and sort import statements</p></td>
</tr>
<tr>
<td><p><code>UP</code></p></td>
<td><p><code>pyupgrade</code></p></td>
<td><p>Use modern language features compatible with your target Python version</p></td>
</tr>
<tr>
<td><p><code>SIM</code></p></td>
<td><p><code>flake8-simplify</code></p></td>
<td><p>Use idiomatic constructs to simplify code</p></td>
</tr>
<tr>
<td><p><code>FURB</code></p></td>
<td><p><code>refurb</code></p></td>
<td><p>Use idiomatic constructs to make good code even better</p></td>
</tr>
<tr>
<td><p><code>PIE</code></p></td>
<td><p><code>flake8-pie</code></p></td>
<td><p>A collection of miscellaneous lints</p></td>
</tr>
<tr>
<td><p><code>PERF</code></p></td>
<td><p><code>Perflint</code></p></td>
<td><p>Avoid performance antipatterns</p></td>
</tr>
<tr>
<td><p><code>C4</code></p></td>
<td><p><code>flake8-comprehensions</code></p></td>
<td><p>Use <code>list</code>, <code>set</code>, and <code>dict</code> comprehensions</p></td>
</tr>
<tr>
<td><p><code>B</code></p></td>
<td><p><code>flake8-bugbear</code></p></td>
<td><p>Eliminate likely bugs and design problems</p></td>
</tr>
<tr>
<td><p><code>PL</code></p></td>
<td><p><code>Pylint</code></p></td>
<td><p>A large collection of rules from the mother of all Python linters</p></td>
</tr>
<tr>
<td><p><code>D</code></p></td>
<td><p><code>pydocstyle</code></p></td>
<td><p>Require well-formed docstrings for your functions, classes, and modules</p></td>
</tr>
<tr>
<td><p><code>S</code></p></td>
<td><p><code>flake8-bandit</code></p></td>
<td><p>Detect potential security vulnerabilities</p></td>
</tr>
</tbody>
</table>

<p>When onboarding legacy projects to Ruff, your first task will be to decide which
linters provide the most useful feedback. At this stage, individual diagnostics
can be quite overwhelming. It helps to zoom out using the <code>--statistics</code> option:</p>
<pre data-type="programlisting">$ <strong>ruff check --statistics --select ALL</strong>
123	I001   	[*] Import block is un-sorted or un-formatted
 45	ARG001 	[ ] Unused function argument: `bindings`
 39	UP007  	[*] Use `X | Y` for type annotations
 32	TRY003 	[ ] Avoid specifying long messages outside the exception class
 28	SIM117 	[ ] Use a single `with` statement with multiple contexts
 23	SLF001 	[ ] Private member accessed: `_blob`
 17	FBT001 	[ ] Boolean-typed positional argument in function definition
 10	PLR0913	[ ] Too many arguments in function definition (6 &gt; 5)
...
</pre>

<p>At this point, you have two options. First, if a linter is particularly noisy,
hide it from the output using the <code>--ignore</code> option. For example, if you’re not
ready to add type annotations and docstrings, exclude <code>flake8-annotations</code> and
<code>pydocstyle</code> with <code>--ignore ANN,D</code>. Second, if you see a linter with interesting
findings, enable it permanently in <em>pyproject.toml</em> and fix its warnings. Rinse
and repeat.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Work towards enforcing the same set of linters for all your projects, with the
same configurations, and prefer default configurations over customizations. This
will make your codebase more consistent and accessible across the entire
organization.</p>
</div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Disabling Rules and Warnings"><div class="sect2" id="section_linting_ruff_ignore">
<h2>Disabling Rules and Warnings</h2>

<p>The <code>select</code> setting is flexible, but purely additive: it lets you opt into
rules whose code starts with a given prefix. The <code>ignore</code> setting lets you
fine-tune in the other direction: it disables individual rules and rule groups.
Like <code>select</code>, it matches rule codes by their prefixes.</p>

<p>The subtractive method is handy when you need most, but not all, of a linter’s
rules, and when you’re adopting a linter gradually. The <code>pydocstyle</code> plugin
(<code>D</code>) checks that every module, class, and function has a well-formed docstring.
Your project may be <em>almost</em> there, with the exception of module docstrings
(<code>D100</code>). Use the <code>ignore</code> setting to disable all warnings about missing module
docstrings until you’ve fully onboarded your project:</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[tool.ruff.lint]</code><code class="w"/>
<code class="n">select</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"D"</code><code class="p">,</code><code class="w"> </code><code class="s2">"E"</code><code class="p">,</code><code class="w"> </code><code class="s2">"F"</code><code class="p">]</code><code class="w"/>
<code class="n">ignore</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"D100"</code><code class="p">]</code><code class="w">  </code><code class="c1"># Don't require module docstrings for now.</code><code class="w"/></pre>

<p>The <code>per-file-ignore</code> setting lets you disable rules for a part of your
codebase. Here’s another example: The <code>bandit</code> plugin (<code>S</code>) has a rich inventory
of checks to help you detect security vulnerabilities in your code. Its rule
<code>S101</code> flags every use of the <code>assert</code> keyword.<sup><a data-type="noteref" id="id315-marker" href="ch09.html#id315">5</a></sup> But you still need <code>assert</code> to express
expectations in pytest (see <a data-type="xref" href="ch06.html#chapter_testing">Chapter 6</a>). If your test suite lives in a
<em>tests</em> directory, disable <code>S101</code> for its files like this:</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[tool.ruff.lint.per-file-ignores]</code><code class="w"/>
<code class="s2">"tests/*"</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"S101"</code><code class="p">]</code><code class="w">  </code><code class="c1"># Tests can use assertions.</code><code class="w"/></pre>

<p>Disabling rules should be a last resort. It’s usually better to suppress
individual warnings by adding a special comment to offending lines. This comment
has the form <code># noqa:</code> followed by one or more rule codes.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Always include rule codes in your <code>noqa</code> comments. Blanket <code>noqa</code> comments can
hide unrelated issues. Marking violations also makes them easier to find when
you’re ready to fix them. Use the rule <code>PGH004</code> from the <code>pygrep-hooks</code> linter
to require rule codes.</p>
</div>

<p>The <code>noqa</code> system lets you silence false positives as well as legitimate
warnings that you choose not to prioritize at this point in time. For example,
the MD5 message-digest algorithm is generally agreed to be insecure, and
Bandit’s <code>S324</code> flags its uses. But if your code interacts with a legacy system
that requires you to compute an MD5 hash, you may not have much of a choice.
Disable the warning with a <code>noqa</code> comment:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">md5</code> <code class="o">=</code> <code class="n">hashlib</code><code class="o">.</code><code class="n">md5</code><code class="p">(</code><code class="n">text</code><code class="o">.</code><code class="n">encode</code><code class="p">())</code><code class="o">.</code><code class="n">hexdigest</code><code class="p">()</code>  <code class="c1"># noqa: S324</code></pre>

<p>Bandit’s checks often flag constructs that deserve close scrutiny, without
meaning to outright ban them. The idea is that you will vet the offending lines
one by one and suppress the warning if you determine the specific usage to be
innocuous.</p>

<p>It can be reasonable to enable a rule and suppress <em>all</em> of its warnings. This
lets you enforce a rule going forward only—​that is, only when you touch a
region of code. Ruff supports this workflow with the <code>--add-noqa</code> option, which
inserts <code>noqa</code> comments to all offending lines on your behalf:</p>
<pre data-type="programlisting">$ <strong>ruff check --add-noqa</strong></pre>

<p>Like every comment, <code>noqa</code> comments can become outdated—​for example, a
refactoring may have inadvertently fixed the suppressed warning. Stale <code>noqa</code>
comments are noisy and create friction when you’re out to squash linter
violations. Luckily, Ruff is in an excellent position to remediate this. Its
rule <code>RUF100</code> automatically removes <code>noqa</code> comments that no longer apply.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Automation with Nox"><div class="sect2" id="id191">
<h2>Automation with Nox</h2>

<p>Without corrective measures, the code quality of large projects degrades over
time. Linting, as an automated, mandatory check, helps to counteract that
natural entropy. Nox (see <a data-type="xref" href="ch08.html#chapter_nox">Chapter 8</a>) is an automation framework that lets
you run linters as a part of your mandatory checks.</p>

<p>Here’s a Nox session that runs Ruff on every Python file in the current
directory:</p>

<pre data-type="programlisting" data-code-language="python"><code class="nd">@nox</code><code class="o">.</code><code class="n">session</code>
<code class="k">def</code> <code class="nf">lint</code><code class="p">(</code><code class="n">session</code><code class="p">):</code>
    <code class="n">session</code><code class="o">.</code><code class="n">install</code><code class="p">(</code><code class="s2">"ruff"</code><code class="p">)</code>
    <code class="n">session</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="s2">"ruff"</code><code class="p">,</code> <code class="s2">"check"</code><code class="p">)</code></pre>

<p>Nox is a valid choice here, but when it comes to linting, there’s a more
convenient and powerful alternative: pre-commit, a cross-language linter
framework with Git integration.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="The pre-commit Framework"><div class="sect1" id="section_linting_pre_commit">
<h1>The pre-commit Framework</h1>

<p>Pre-commit is a tool and framework that lets you add third-party linters to a
project with minimal boilerplate. Linters in various languages come with
ready-to-use integrations for pre-commit, called <em>hooks</em>. You can run these
hooks explicitly from the command line, or you can configure your local
repository to run them whenever you commit changes (and on some other events).</p>

<p>Install pre-commit globally using pipx:</p>
<pre data-type="programlisting">$ <strong>pipx install pre-commit</strong></pre>








<section data-type="sect2" data-pdf-bookmark="First Steps with pre-commit"><div class="sect2" id="id193">
<h2>First Steps with pre-commit</h2>

<p>Let’s add a pre-commit hook for Ruff to your project. Create a file named
<em>.pre-commit-config.yaml</em> in the top-level directory, with contents as in
<a data-type="xref" href="#example_linting_pre_commit_config">Example 9-3</a>. You’ll find a short YAML fragment like
this in the public documentation of most linters that support pre-commit.</p>
<div id="example_linting_pre_commit_config" data-type="example">
<h5><span class="label">Example 9-3. </span>A <em>.pre-commit-config.yaml</em> file with a hook for Ruff</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">repos</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">repo</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">https://github.com/astral-sh/ruff-pre-commit</code><code class="w"/>
<code class="w">    </code><code class="nt">rev</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v0.3.4</code><code class="w"/>
<code class="w">    </code><code class="nt">hooks</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">id</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ruff</code><code class="w"/></pre></div>

<p>Authors distribute their pre-commit hooks via Git repositories. In the
<em>.pre-commit-config.yaml</em> file, you specify the URL, revision, and hooks for
each repository you want to use. The URL can be any location Git can clone from.
The revision is most commonly a Git tag pointing to the latest release of the
linter. A repository can have more than one hook—​for example, Ruff provides
<code>ruff</code> and <code>ruff-format</code> hooks for its linter and code formatter, respectively.</p>

<p>Pre-commit is intimately tied to Git, and you must invoke it from within a Git
repository. Let’s establish a baseline by linting every file in the repository,
using the command <code>pre-commit run</code> with the <code>--all-files</code> option:</p>
<pre data-type="programlisting">$ <strong>pre-commit run --all-files</strong>
[INFO] Initializing environment for https://github.com/astral-sh/ruff-pre-commit.
[INFO] Installing environment for https://github.com/astral-sh/ruff-pre-commit.
[INFO] Once installed this environment will be reused.
[INFO] This may take a few minutes...
ruff.....................................................................Passed
</pre>

<p>When you run a hook for the first time, pre-commit clones the hook repository
and installs the linter into an isolated environment. This can take some time,
but you don’t have to do it often: Pre-commit caches the linter environments
across multiple projects.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="A Hook Up Close"><div class="sect2" id="id194">
<h2>A Hook Up Close</h2>

<p>If you’re curious how a pre-commit hook works under the hood, take a peek at
Ruff’s <a href="https://github.com/astral-sh/ruff-pre-commit">hook repository</a>. The file
<em>.pre-commit-hooks.yaml</em> in the repository defines the hooks.
<a data-type="xref" href="#example_linting_hook_definition">Example 9-4</a> shows an excerpt from the file.</p>
<div id="example_linting_hook_definition" data-type="example">
<h5><span class="label">Example 9-4. </span>An excerpt from the .pre-commit-hooks.yaml file for Ruff</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">id</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ruff</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ruff</code><code class="w"/>
<code class="w">  </code><code class="nt">language</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">python</code><code class="w"/>
<code class="w">  </code><code class="nt">entry</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ruff check --force-exclude</code><code class="w"/>
<code class="w">  </code><code class="nt">args</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[]</code><code class="w"/>
<code class="w">  </code><code class="nt">types_or</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="nv">python</code><code class="p-Indicator">,</code><code class="w"> </code><code class="nv">pyi</code><code class="p-Indicator">]</code><code class="w"/></pre></div>

<p>Every hook comes with a unique identifier and a friendly name (<code>id</code> and <code>name</code>).
Refer to hooks by their unique identifier when you interact with pre-commit.
Their names only appear in console messages from the tool.</p>

<p>The hook definition tells pre-commit how to install and run the linter by
specifying its implementation language (<code>language</code>) and its command and
command-line arguments (<code>entry</code> and <code>args</code>). The Ruff hook is a Python package,
so it specifies Python as the language. The <code>--force-exclude</code> option ensures
that you can exclude files from linting. It tells Ruff to honor its <code>exclude</code>
setting even when pre-commit passes excluded source files explicitly.</p>
<div data-type="tip"><h6>Tip</h6>
<p>You can override the <code>args</code> key in your <em>.pre-commit-config.yaml</em> file to pass
custom command-line options to a hook. By contrast, command-line arguments in
the <code>entry</code> key are mandatory—​you can’t override them.</p>
</div>

<p>Finally, the hook declares which file types the linter understands (<code>types_or</code>).
The <code>python</code> file type matches files with <em>.py</em> or related extensions and
executable scripts with a Python shebang. The <code>pyi</code> file type refers to
stub files with type annotations (see <a data-type="xref" href="ch10.html#section_typing_distributing">“Distributing Types with Python Packages”</a>).</p>

<p>For a Python hook, pre-commit creates a virtual environment in its cache
directory. It installs the hook by running, essentially, <code>pip install .</code> inside
the hook repository. When it’s time to run the hook, pre-commit activates the
virtual environment and invokes the command with any selected source files.</p>

<p><a data-type="xref" href="#figure_pre_commit">Figure 9-2</a> shows a developer machine with three Python projects using
pre-commit hooks. Pre-commit clones the hook repositories into its cache
directory and installs the hooks into isolated environments. Hook repositories
define hooks in <em>.pre-commit-hooks.yaml</em> files, while projects reference the
hooks in <em>.pre-commit-config.yaml</em> files.</p>

<figure><div id="figure_pre_commit" class="figure">
<img src="assets/hmpt_0902.png" alt="The diagram shows repositories with pre-commit hooks for Ruff, Flake8, and Black, as well as a developer machine with three projects referencing these hooks. At the bottom, the diagram shows the pre-commit cache with cloned repositories and environments with installed hooks." width="2440" height="1514"/>
<h6><span class="label">Figure 9-2. </span>Three projects with pre-commit hooks for Ruff, Black, and Flake8.</h6>
</div></figure>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Automatic Fixes"><div class="sect2" id="section_linting_fixes">
<h2>Automatic Fixes</h2>

<p>Modern linters can fix many violations by modifying the offending source files
in place. Linters with automatic fixes eliminate entire classes of bugs and code
smells<sup><a data-type="noteref" id="id316-marker" href="ch09.html#id316">6</a></sup> at nearly zero cost. Like
code formatters, they have caused a paradigm shift in software development,
letting you focus on higher-level concerns without compromising on code quality.</p>

<p>By convention, most pre-commit hooks enable automatic fixes by default. Thanks
to Git, they can apply fixes with relative safety, without risk of overwriting
your work irreversibly. That said, they work best if you commit early and often.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Automatic fixes bring tremendous benefits, but they assume some basic Git
hygiene: Don’t pile up uncommitted changes in your repository (or stash them
before linting). Pre-commit saves and restores your local modifications in some
contexts, but not all.</p>
</div>

<p>Let’s try this out. When Ruff detects the mutable argument default, it indicates
that you can enable a “hidden” fix. (Ruff asks you to opt into the fix because
people might conceivably depend on mutable defaults, say, for caching.) First,
enable the linter rule and the fix in <em>pyproject.toml</em>:</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[tool.ruff.lint]</code><code class="w"/>
<code class="n">extend-select</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"B006"</code><code class="p">]</code><code class="w"/>
<code class="n">extend-safe-fixes</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"B006"</code><code class="p">]</code><code class="w"/></pre>

<p>Ruff’s pre-commit hook requires you to opt in with the <code>--fix</code> option, as shown
in <a data-type="xref" href="#example_linting_ruff_fix">Example 9-5</a>. The options <code>--show-fixes</code> and
<code>--exit-non-zero-on-fix</code> ensure that all violations are displayed in the
terminal and result in a non-zero exit status, even if Ruff was able to fix
them.</p>
<div id="example_linting_ruff_fix" data-type="example">
<h5><span class="label">Example 9-5. </span>Enabling automatic fixes for the Ruff hook</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">repos</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">repo</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">https://github.com/astral-sh/ruff-pre-commit</code><code class="w"/>
<code class="w">    </code><code class="nt">rev</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v0.3.4</code><code class="w"/>
<code class="w">    </code><code class="nt">hooks</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">id</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ruff</code><code class="w"/>
<code class="w">        </code><code class="nt">args</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"--fix"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"--show-fixes"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"--exit-non-zero-on-fix"</code><code class="p-Indicator">]</code><code class="w"/></pre></div>

<p>Save <a data-type="xref" href="#example_linting_mutable_default">Example 9-1</a> in a file called <em>bad.py</em>, commit the
file, and run pre-commit:</p>
<pre data-type="programlisting">$ <strong>pre-commit run --all-files</strong>
ruff.....................................................................Failed
- hook id: ruff
- exit code: 1
- files were modified by this hook

Fixed 1 error:
- bad.py:
    1 × B006 (mutable-argument-default)

Found 1 error (1 fixed, 0 remaining).
</pre>

<p>If you inspect the modified file, you’ll see that Ruff has replaced the argument
default with <code>None</code>. The empty list is now assigned inside the function, giving
every call its own instance of <code>args</code>.</p>

<pre data-type="programlisting" data-code-language="python"><code class="k">def</code> <code class="nf">run</code><code class="p">(</code><code class="n">command</code><code class="p">,</code> <code class="n">args</code><code class="o">=</code><code class="kc">None</code><code class="p">,</code> <code class="n">force</code><code class="o">=</code><code class="kc">False</code><code class="p">):</code>
    <code class="k">if</code> <code class="n">args</code> <code class="ow">is</code> <code class="kc">None</code><code class="p">:</code>
        <code class="n">args</code> <code class="o">=</code> <code class="p">[]</code>
    <code class="k">if</code> <code class="n">force</code><code class="p">:</code>
        <code class="n">args</code><code class="o">.</code><code class="n">insert</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="s2">"--force"</code><code class="p">)</code>
    <code class="n">subprocess</code><code class="o">.</code><code class="n">run</code><code class="p">([</code><code class="n">command</code><code class="p">,</code> <code class="o">*</code><code class="n">args</code><code class="p">])</code></pre>

<p>Instead of inspecting the modified files, you can also run <code>git diff</code> to see the
changes applied to your code. Alternatively, you can tell pre-commit to show you
a diff of the fixes right away, using the option <code>--show-diff-on-fail</code>.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Running pre-commit from Nox"><div class="sect2" id="id196">
<h2>Running pre-commit from Nox</h2>

<p>Pre-commit gives you access to production-ready integrations for linters in many
languages. For this reason alone, I recommend running linters from pre-commit
instead of Nox. (If you still need convincing, bear with me for the next section,
which presents another compelling reason to use pre-commit.)</p>

<p>That said, you should still include a Nox session for pre-commit itself. This
ensures that you can run all the checks for your project with a single command,
<code>nox</code>. <a data-type="xref" href="#example_linting_nox">Example 9-6</a> shows how to define the session. If your
<em>noxfile.py</em> sets <code>nox.options.sessions</code>, add the session to that list, as well.</p>
<div id="example_linting_nox" data-type="example">
<h5><span class="label">Example 9-6. </span>A Nox session for linting with pre-commit</h5>

<pre data-type="programlisting" data-code-language="python"><code class="n">nox</code><code class="o">.</code><code class="n">options</code><code class="o">.</code><code class="n">sessions</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"tests"</code><code class="p">,</code> <code class="s2">"lint"</code><code class="p">]</code>

<code class="nd">@nox</code><code class="o">.</code><code class="n">session</code>
<code class="k">def</code> <code class="nf">lint</code><code class="p">(</code><code class="n">session</code><code class="p">):</code>
    <code class="n">options</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"--all-files"</code><code class="p">,</code> <code class="s2">"--show-diff-on-fail"</code><code class="p">]</code>
    <code class="n">session</code><code class="o">.</code><code class="n">install</code><code class="p">(</code><code class="s2">"pre-commit"</code><code class="p">)</code>
    <code class="n">session</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="s2">"pre-commit"</code><code class="p">,</code> <code class="s2">"run"</code><code class="p">,</code> <code class="o">*</code><code class="n">options</code><code class="p">,</code> <code class="o">*</code><code class="n">session</code><code class="o">.</code><code class="n">posargs</code><code class="p">)</code></pre></div>

<p>By default, pre-commit runs every hook you’ve configured for your project. You
can run specific hooks by passing them as additional command-line arguments.
This comes in handy when addressing complaints from a specific linter. Thanks to
<code>session.posargs</code> (see <a data-type="xref" href="ch08.html#section_nox_session_arguments">“Session Arguments”</a>), this also works from
Nox:</p>
<pre data-type="programlisting">$ <strong>nox --session=lint -- ruff</strong>
</pre>

<p>Having a single entry point to checks and tasks, including linters, greatly
reduces friction for everybody working on a project. But you shouldn’t stop
there. Pre-commit was designed to be triggered from Git on every commit. The
next section explains how to set up projects to lint changes as you commit them
(and why it’s great).</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Running pre-commit from Git"><div class="sect2" id="id197">
<h2>Running pre-commit from Git</h2>

<p>Running linters on each commit is a game changer, for three reasons:</p>

<ul>
<li>
<p>You remove the overhead and distraction of invoking checks manually. Linters
run in the background, alerting you only if a violation is found.</p>
</li>
<li>
<p>You run checks as early as possible. As a general rule, the earlier you spot
an issue, the cheaper it is to fix. (Say goodbye to CI failures due to
stylistic nitpicks.)</p>
</li>
<li>
<p>It’s fast: You only lint files staged for a commit, instead of the entire
codebase.<sup><a data-type="noteref" id="id317-marker" href="ch09.html#id317">7</a></sup></p>
</li>
</ul>

<p>Set up Git to invoke pre-commit on every commit by running the following command
inside your project:</p>
<pre data-type="programlisting">$ <strong>pre-commit install</strong>
pre-commit installed at .git/hooks/pre-commit
</pre>

<p>This command installs a short wrapper script into the <em>.git/hooks</em> directory
that transfers control to pre-commit (<a data-type="xref" href="#figure_pre_commit_git">Figure 9-3</a>). Programs in
the <em>.git/hooks</em> directory are known as <em>Git hooks</em>. When you run <code>git commit</code>,
Git invokes the <em>pre-commit</em> Git hook. The hook, in turn, invokes pre-commit,
which runs Ruff and any other pre-commit hooks you have.</p>

<figure><div id="figure_pre_commit_git" class="figure">
<img src="assets/hmpt_0903.png" alt="The diagram shows how Git hooks invoke pre-commit hooks, using pre-commit as a switch board." width="2039" height="593"/>
<h6><span class="label">Figure 9-3. </span>Git hooks and pre-commit hooks</h6>
</div></figure>

<p>Git hooks let you trigger actions at predefined points during Git’s execution.
For example, the <em>pre-commit</em> and <em>post-commit</em> Git hooks run before and after
Git creates a commit. You’ve probably guessed by now which of these Git hooks
pre-commit installs by default—​but it supports the other Git hooks as well, if
you need them.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_linting_commitlint">
<h1>Pre-commit hooks that aren’t pre-commit hooks</h1>
<p>Most pre-commit hooks plug into the <em>pre-commit</em> Git hook—​but not all. Linters
for commit messages like <code>commitlint</code> and <code>gitlint</code> use the <em>commit-msg</em> Git
hook. Git calls this hook after you’ve composed a commit message. You can
install it using the <code>--hook-type</code> or <code>-t</code> option:</p>
<pre data-type="programlisting">$ <strong>pre-commit install -t commit-msg</strong>
pre-commit installed at .git/hooks/commit-msg
</pre>

<p>But passing this option is easy to forget. If you use Git hooks other than
<em>pre-commit</em>, list them in the <em>.pre-commit-config.yaml</em> file instead:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">default_install_hook_types</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="nv">pre-commit</code><code class="p-Indicator">,</code><code class="w"> </code><code class="nv">commit-msg</code><code class="p-Indicator">]</code><code class="w"/></pre>

<p>Place this directive at the top level of your pre-commit configuration.</p>
</div></aside>

<p><a data-type="xref" href="#figure_pre_commit_flow">Figure 9-4</a> depicts a typical workflow with pre-commit. On the
left, there’s a file you’re editing in your project (<em>worktree</em>); the center
represents the staging area for the next commit (<em>index</em>); and the current
commit is on the right (<code>HEAD</code>).</p>

<figure><div id="figure_pre_commit_flow" class="figure">
<img src="assets/hmpt_0904.png" alt="The diagram shows how pre-commit rejects a commit." width="2614" height="1150"/>
<h6><span class="label">Figure 9-4. </span>Workflow with pre-commit</h6>
</div></figure>

<p>Initially, the three areas are in sync. Suppose you remove the placeholder from
the f-string, but forget to remove the <code>f</code> prefix from the string literal
(marked as <em>1</em> in <a data-type="xref" href="#figure_pre_commit_flow">Figure 9-4</a>). You stage your edit using <code>git
add</code> <em>(2)</em> and run <code>git commit</code> to create a commit <em>(3a)</em>. Before your editor
can pop up for the commit message, Git transfers control to pre-commit. Ruff
promptly catches your mistake and fixes the string literal in your worktree
<em>(3b)</em>.</p>

<p>At this point, all three areas have different contents. Your worktree contains
your change with Ruff’s fix, the staging area has your change without the fix,
and <code>HEAD</code> still points to the commit before your change. This lets you audit
the fix by comparing the worktree to the staging area, using <code>git diff</code>. If
you’re happy with what you see, you can stage the fix with <code>git add</code> <em>(4)</em> and
retry the commit with <code>git commit</code> <em>(5)</em>.</p>

<p>With automatic fixes, this workflow reduces the interference of linters to a
minimum, rerunning the commit. But sometimes you don’t want to be distracted by
linters at all—​for example, you may want to record some work in progress. Git
and pre-commit give you two options to get your commit past a stubborn linter.
First, you can skip Git hooks entirely using the <code>--no-verify</code> or <code>-n</code> option:</p>
<pre data-type="programlisting">$ <strong>git commit -n</strong></pre>

<p>Alternatively, you can skip a specific pre-commit hook using the <code>SKIP</code>
environment variable (which also takes a comma-separated list, if you need to
skip more than one hook):</p>
<pre data-type="programlisting">$ <strong>SKIP=ruff git commit</strong></pre>

<p>Git hooks control which changes enter your local repository, but they’re
voluntary—​they don’t replace CI checks as a gatekeeper for the default branch
in your shared repository. If you already run Nox in CI, the session in
<a data-type="xref" href="#example_linting_nox">Example 9-6</a> takes care of that.</p>

<p>Skipping hooks doesn’t help with false positives or when you want to deploy a
critical fix despite minor nits: your mandatory checks would still fail in CI.
In these cases, you’ll need to advise the linter to ignore the specific
violation (see <a data-type="xref" href="#section_linting_ruff_ignore">“Disabling Rules and Warnings”</a>).</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="The Ruff Formatter"><div class="sect1" id="id198">
<h1>The Ruff Formatter</h1>

<p>Over the course of months, Ruff reimplemented a plethora of Python linters
behind the <code>ruff check</code> command and saw wide adoption in the Python world. A bit
over a year in, Ruff acquired the <code>ruff format</code> command.<sup><a data-type="noteref" id="id318-marker" href="ch09.html#id318">8</a></sup> The Ruff formatter reimplements the de-facto standard of Python code
formatting, Black, in Rust. It provides yet another building block for the
integrated and highly performant toolchain that Ruff has become for Python.</p>

<p>But let’s start at the beginning.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_linting_clang_format">
<h1>A Tale from Another Time</h1>
<p>Many years ago, I was working in a small team on a C++ codebase. Our processes
were simple: everybody committed directly to the main branch. There was no CI
pipeline—​just nightly builds and a dashboard showing compiler errors, warnings,
and test failures. Every now and then, one of us went over recent changes with
refactorings and style cleanups. It may sound surprising, but the codebase was
in good shape. Nothing beats mutual understanding in a close-knit team.</p>

<p>A few years down the road, cracks appeared in our workflow. The company had
grown—​new engineers were unfamiliar with the coding conventions, senior
engineers struggled to communicate them. On top of this, the team had inherited
a legacy codebase that didn’t adhere to any discernible rules at all.</p>

<p>We started to look at automation. Maybe tooling could take over the common chore
of identifying code-quality issues and fixing them across the codebase. In 2013,
a code formatter named <code>clang-format</code> had been released as part of the LLVM
compiler toolkit, and it looked promising.</p>

<p>After a brief evaluation, I decided against it.</p>

<p>By design, <code>clang-format</code> completely rewrote each source file according to the
configured style. I was worried about its all-or-nothing approach for a few
reasons. First, despite dozens of configuration settings, it would erase many of
our style conventions. Second, it would be hard to review the resulting large
patch. Third, since reformatting would touch a large part of the codebase, it
would become hard to establish the historical context of a line of code using
the version control system.</p>

<p>In hindsight, I was wrong—​all of these concerns can be addressed.</p>

<p>The evolution of code formatters in Python eventually changed my
mind—​specifically the meteoric rise of Black. But before addressing the
concerns above, let’s take a step back and look at the situation in Python as it
was when Black entered the scene.</p>
</div></aside>








<section data-type="sect2" data-pdf-bookmark="Approaches to Code Formatting: Autopep8"><div class="sect2" id="section_linting_autopep8">
<h2>Approaches to Code Formatting: Autopep8</h2>

<p>Consider the following gem of Python code:</p>

<pre data-type="programlisting" data-code-language="python"><code class="k">def</code> <code class="nf">create_frobnicator_factory</code><code class="p">(</code><code class="n">the_factory_name</code><code class="p">,</code>
                                  <code class="n">interval_in_secs</code><code class="o">=</code><code class="mi">100</code><code class="p">,</code>  <code class="n">dbg</code><code class="o">=</code><code class="kc">False</code><code class="p">,</code>
                                <code class="n">use_singleton</code><code class="o">=</code><code class="kc">None</code><code class="p">,</code><code class="n">frobnicate_factor</code><code class="o">=</code><code class="mf">4.5</code><code class="p">):</code>
  <code class="k">if</code> <code class="n">dbg</code><code class="p">:</code><code class="nb">print</code><code class="p">(</code><code class="s1">'creating frobnication factory '</code><code class="o">+</code><code class="n">the_factory_name</code><code class="o">+</code><code class="s2">"..."</code><code class="p">)</code>
  <code class="k">if</code><code class="p">(</code><code class="n">use_singleton</code><code class="p">):</code>   <code class="k">return</code> <code class="n">_frob_sngltn</code>      <code class="c1">#we're done</code>
  <code class="k">return</code> <code class="n">FrobnicationFactory</code><code class="p">(</code> <code class="n">the_factory_name</code><code class="p">,</code>

    <code class="n">intrvl</code> <code class="o">=</code> <code class="n">interval_in_secs</code>             <code class="p">,</code><code class="n">f</code><code class="o">=</code><code class="n">frobnicate_factor</code>     <code class="p">)</code></pre>

<p>The function showcases various formatting issues, such as inconsistent
alignment, lack or excess of whitespace, and single-line <code>if</code> constructs. Some
of these clearly hurt readability. Others, such as two-space indentation,
deviate from a widely accepted practice codified in PEP 8.</p>

<p>A minimal approach for dealing with stylistic issues of this sort is Autopep8,
an early pioneer of automatic linter fixes and still in use. Building on
Pycodestyle, it surgically corrects offenses while preserving the code layout
otherwise.</p>

<p>Let’s run Autopep8 on the code example with default settings:</p>
<pre data-type="programlisting">$ <strong>pipx run autopep8 example.py</strong></pre>

<p>Here’s the function as formatted by Autopep8:</p>

<pre data-type="programlisting" data-code-language="python"><code class="k">def</code> <code class="nf">create_frobnicator_factory</code><code class="p">(</code><code class="n">the_factory_name</code><code class="p">,</code>
                               <code class="n">interval_in_secs</code><code class="o">=</code><code class="mi">100</code><code class="p">,</code>  <code class="n">dbg</code><code class="o">=</code><code class="kc">False</code><code class="p">,</code>
                               <code class="n">use_singleton</code><code class="o">=</code><code class="kc">None</code><code class="p">,</code> <code class="n">frobnicate_factor</code><code class="o">=</code><code class="mf">4.5</code><code class="p">):</code>
    <code class="k">if</code> <code class="n">dbg</code><code class="p">:</code>
        <code class="nb">print</code><code class="p">(</code><code class="s1">'creating frobnication factory '</code><code class="o">+</code><code class="n">the_factory_name</code><code class="o">+</code><code class="s2">"..."</code><code class="p">)</code>
    <code class="k">if</code> <code class="p">(</code><code class="n">use_singleton</code><code class="p">):</code>
        <code class="k">return</code> <code class="n">_frob_sngltn</code>  <code class="c1"># we're done</code>
    <code class="k">return</code> <code class="n">FrobnicationFactory</code><code class="p">(</code><code class="n">the_factory_name</code><code class="p">,</code>

                               <code class="n">intrvl</code><code class="o">=</code><code class="n">interval_in_secs</code><code class="p">,</code> <code class="n">f</code><code class="o">=</code><code class="n">frobnicate_factor</code><code class="p">)</code></pre>

<p>You’ll likely find this easier on the eye. For better or worse, Autopep8 didn’t
touch some other questionable stylistic choices, such as the rogue blank line in
the <code>return</code> statement and the inconsistent quote characters. Autopep8 uses
Pycodestyle to detect issues, and Pycodestyle had no complaint here.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Unlike most code formatters, Autopep8 lets you apply selected fixes by passing
<code>--select</code> with appropriate rule codes. For example, you can run <code>autopep8
--select=E111</code> to enforce four-space indentation.</p>
</div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Approaches to Code Formatting: YAPF"><div class="sect2" id="id200">
<h2>Approaches to Code Formatting: YAPF</h2>

<p>Developed at Google in 2015, the YAPF formatter borrows its design and
sophisticated formatting algorithm from <code>clang-format</code>. The name YAPF stands for
“Yet Another Python Formatter.”<sup><a data-type="noteref" id="id319-marker" href="ch09.html#id319">9</a></sup> YAPF reformats a codebase
according to a wealth of configuration options.</p>

<p>Run it like this:</p>
<pre data-type="programlisting">$ <strong>pipx run yapf example.py</strong></pre>

<p>Here’s YAPF’s version of the code, using default settings:</p>

<pre data-type="programlisting" data-code-language="python"><code class="k">def</code> <code class="nf">create_frobnicator_factory</code><code class="p">(</code><code class="n">the_factory_name</code><code class="p">,</code>
                               <code class="n">interval_in_secs</code><code class="o">=</code><code class="mi">100</code><code class="p">,</code>
                               <code class="n">dbg</code><code class="o">=</code><code class="kc">False</code><code class="p">,</code>
                               <code class="n">use_singleton</code><code class="o">=</code><code class="kc">None</code><code class="p">,</code>
                               <code class="n">frobnicate_factor</code><code class="o">=</code><code class="mf">4.5</code><code class="p">):</code>
    <code class="k">if</code> <code class="n">dbg</code><code class="p">:</code> <code class="nb">print</code><code class="p">(</code><code class="s1">'creating frobnication factory '</code> <code class="o">+</code> <code class="n">the_factory_name</code> <code class="o">+</code> <code class="s2">"..."</code><code class="p">)</code>
    <code class="k">if</code> <code class="p">(</code><code class="n">use_singleton</code><code class="p">):</code> <code class="k">return</code> <code class="n">_frob_sngltn</code>  <code class="c1">#we're done</code>
    <code class="k">return</code> <code class="n">FrobnicationFactory</code><code class="p">(</code><code class="n">the_factory_name</code><code class="p">,</code>
                               <code class="n">intrvl</code><code class="o">=</code><code class="n">interval_in_secs</code><code class="p">,</code>
                               <code class="n">f</code><code class="o">=</code><code class="n">frobnicate_factor</code><code class="p">)</code></pre>

<p>YAPF’s formatting rules touch more ground than Autopep8—​for example, it
arranges the function parameters in a consistent way and removes the bogus empty
line. YAPF respects existing formatting choices as long as they’re compatible
with your configuration. For example, it didn’t split the single-line <code>if</code>
statements or eliminate parentheses around <code>if</code> conditions.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="An Uncompromising Code Formatter"><div class="sect2" id="id201">
<h2>An Uncompromising Code Formatter</h2>

<p>In 2018, a new code formatter named Black entered the scene. Its core principle:
minimal configurability!</p>

<p>Let’s try Black on the code example:</p>
<pre data-type="programlisting">$ <strong>pipx run black example.py</strong></pre>

<p>Black formats the function as follows:</p>

<pre data-type="programlisting" data-code-language="python"><code class="k">def</code> <code class="nf">create_frobnicator_factory</code><code class="p">(</code>
    <code class="n">the_factory_name</code><code class="p">,</code>
    <code class="n">interval_in_secs</code><code class="o">=</code><code class="mi">100</code><code class="p">,</code>
    <code class="n">dbg</code><code class="o">=</code><code class="kc">False</code><code class="p">,</code>
    <code class="n">use_singleton</code><code class="o">=</code><code class="kc">None</code><code class="p">,</code>
    <code class="n">frobnicate_factor</code><code class="o">=</code><code class="mf">4.5</code><code class="p">,</code>
<code class="p">):</code>
    <code class="k">if</code> <code class="n">dbg</code><code class="p">:</code>
        <code class="nb">print</code><code class="p">(</code><code class="s2">"creating frobnication factory "</code> <code class="o">+</code> <code class="n">the_factory_name</code> <code class="o">+</code> <code class="s2">"..."</code><code class="p">)</code>
    <code class="k">if</code> <code class="n">use_singleton</code><code class="p">:</code>
        <code class="k">return</code> <code class="n">_frob_sngltn</code>  <code class="c1"># we're done</code>
    <code class="k">return</code> <code class="n">FrobnicationFactory</code><code class="p">(</code>
        <code class="n">the_factory_name</code><code class="p">,</code> <code class="n">intrvl</code><code class="o">=</code><code class="n">interval_in_secs</code><code class="p">,</code> <code class="n">f</code><code class="o">=</code><code class="n">frobnicate_factor</code>
    <code class="p">)</code></pre>

<p>Black doesn’t fix individual style offenses like Autopep8, nor does it enforce
your style preferences like YAPF. Rather, Black reduces the source code into a
canonical form, using a deterministic algorithm—​mostly without taking existing
formatting into account. In a certain sense, Black makes code style “disappear.”
This normalization massively reduces the cognitive overhead of working with
Python code.</p>

<p>Black promotes a form of universal readability across the Python ecosystem. Code
is read more often than it’s being written—​a transparent style helps. At the
same time, Black makes code more “writable,” too. When you’re contributing to
other people’s code, there’s no need to conform to a bespoke and manual code
style. Even in a solo project, Black boosts your productivity: if you configure
your editor to reformat on save, you can reduce your keystrokes to a minimum
while coding.</p>

<p>Black took the Python world by storm, with project after project deciding to
“blacken” their source files.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_linting_black_onboarding">
<h1>Onboarding a Codebase to Black</h1>
<p>When you onboard a large codebase to an opinionated code formatter like Black,
the resulting diff can present a headache.</p>

<p>First, why give up conscious style choices and carefully handcrafted code?
You’ll have to make this decision yourself—​but consider the following points:
What’s the ongoing cost of enforcing your style without the help of automated
tools? Do your code reviews focus on the meaning of a change rather than coding
style? How long does it take new engineers to get up to speed?</p>

<p>Second, are the changes safe? Black guarantees that the <em>abstract syntax tree</em>
(AST) of the source code—​that is, the parsed representation of the program, as
seen by the interpreter—​doesn’t change, except for some well-known divergences
that preserve semantic
equivalence.<sup><a data-type="noteref" id="id320-marker" href="ch09.html#id320">10</a></sup></p>

<p>Third, when you commit the changes, how do you prevent them from cluttering up
the output of <code>git blame</code>? It turns out that you can configure Git to ignore the
commit when annotating files. Store the full 40-character commit hash in a file
named <em>.git-blame-ignore-revs</em> in the root of the repository. Then run the
following command:</p>
<pre data-type="programlisting">$ <strong>git config blame.ignoreRevsFile .git-blame-ignore-revs</strong></pre>

<p>Code hosting services like GitHub increasingly support the
<em>.git-blame-ignore-revs</em> file, as well.</p>
</div></aside>
</div></section>








<section data-type="sect2" data-pdf-bookmark="The Black Code style"><div class="sect2" id="id202">
<h2>The Black Code style</h2>

<p>Black’s code style becomes invisible once you’ve worked with it for a while.
Inevitably, though, some of its choices have led to controversy, even forks. To
understand its formatting rules, it helps to look at Black’s goal of producing
readable and consistent source code in a predictable and repeatable way.</p>

<p>Take the default of double quotes for string literals, for example. According to
the style recommendations of PEP 257 and PEP 8, both docstrings and English text
with apostrophes already require double quotes. Choosing double quotes over
single quotes therefore results in a more consistent style overall.</p>

<p>Sometimes Black places a lone <code>):</code> after the parameters of a function. Nicknamed
the “sad face,” it clearly demarcates the function signature from the body
without indenting parameters beyond the standard four spaces. This layout also
treats parameter lists like any other bracketed constructs, such as tuples,
lists, and set literals.</p>

<p>Black also caps lines at 88 characters (one of its few configurable settings).
This tradeoff between lateral eye movement and vertical scrolling is based on a
data-driven approach, tested on millions of lines of Python code at Meta.</p>

<p>Another goal of Black is to avoid <em>merge conflicts</em>, when concurrent changes to
the same region of code cannot be combined without human intervention. The
trailing comma—​placing a comma behind the last item in a sequence—​serves this
purpose: it lets you insert before and after the last item without conflict.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Reducing dependencies between edits helps different people work on the same
code. But it also lets you separate or reorder drive-by bugfixes or refactorings
and back out tentative commits before submitting your changes for code review.</p>
</div>

<p>As mentioned above, Black’s algorithm is deterministic, and existing layouts
hardly affect it. A “blackened” file may look as if it was generated straight
from the AST.<sup><a data-type="noteref" id="id321-marker" href="ch09.html#id321">11</a></sup> In reality, this can’t be
the case, though. For one thing, the AST doesn’t include comments, since they
don’t affect program execution.</p>

<p>Black takes some cues from the formatted source code besides comments. One
example is the blank lines that divide a function body into logical partitions.
Likely the most powerful way of affecting Black’s output, however, is the <em>magic
trailing comma</em>: if a sequence contains a trailing comma, Black splits its
elements across multiple lines, even if they would fit on a single line.</p>

<p>Black provides an escape hatch to let you disable formatting for a region of
code (<a data-type="xref" href="#example_linting_black_fmt_off">Example 9-7</a>).</p>
<div id="example_linting_black_fmt_off" data-type="example">
<h5><span class="label">Example 9-7. </span>Disabling formatting for a region of code</h5>

<pre data-type="programlisting" data-code-language="python"><code class="nd">@pytest</code><code class="o">.</code><code class="n">mark</code><code class="o">.</code><code class="n">parametrize</code><code class="p">(</code>
    <code class="p">(</code><code class="s2">"value"</code><code class="p">,</code> <code class="s2">"expected"</code><code class="p">),</code>
    <code class="c1"># fmt: off</code>
    <code class="p">[</code>
        <code class="p">(</code><code class="s2">"first test value"</code><code class="p">,</code>       <code class="s2">"61df19525cf97aa3855b5aeb1b2bcb89"</code><code class="p">),</code>
        <code class="p">(</code><code class="s2">"another test value"</code><code class="p">,</code>     <code class="s2">"5768979c48c30998c46fb21a91a5b266"</code><code class="p">),</code>
        <code class="p">(</code><code class="s2">"and here's another one"</code><code class="p">,</code> <code class="s2">"e766977069039d83f01b4e3544a6a54c"</code><code class="p">),</code>
    <code class="p">]</code>
    <code class="c1"># fmt: on</code>
<code class="p">)</code>
<code class="k">def</code> <code class="nf">test_frobnicate</code><code class="p">(</code><code class="n">value</code><code class="p">,</code> <code class="n">expected</code><code class="p">):</code>
    <code class="k">assert</code> <code class="n">expected</code> <code class="o">==</code> <code class="n">frobnicate</code><code class="p">(</code><code class="n">value</code><code class="p">)</code></pre></div>

<p>Hand-formatting can be useful for program data, such as large tables with
properly aligned columns.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Formatting Code with Ruff"><div class="sect2" id="id203">
<h2>Formatting Code with Ruff</h2>

<p>Code formatters can process millions of lines of code in a batch, or run in
quick succession when triggered from your editor or on a busy CI server. Being
fast was an explicit goal of Black from the start—​it ships binary wheels with
native code generated by <code>mypyc</code>, a compiler for type-annotated Python. While
Black is fast, the Ruff formatter further improves performance thirtyfold,
thanks to its efficient Rust implementation.</p>

<p>Ruff aims for full compatibility with the Black code style. Unlike Black, Ruff
lets you opt into single quotes and indentation using tabs. However, I’d
recommend adhering to Black’s widely adopted style nonetheless.</p>

<p>When run without arguments, <code>ruff format</code> processes any Python files beneath the
current directory. Instead of invoking Ruff manually, add it to your pre-commit
hooks, as shown in <a data-type="xref" href="#example_linting_ruff_format">Example 9-8</a>.</p>
<div id="example_linting_ruff_format" data-type="example">
<h5><span class="label">Example 9-8. </span>Running Ruff from pre-commit as a linter and code formatter</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">repos</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">repo</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">https://github.com/astral-sh/ruff-pre-commit</code><code class="w"/>
<code class="w">    </code><code class="nt">rev</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v0.3.4</code><code class="w"/>
<code class="w">    </code><code class="nt">hooks</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">id</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ruff</code><code class="w"/>
<code class="w">        </code><code class="nt">args</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"--fix"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"--show-fixes"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"--exit-non-zero-on-fix"</code><code class="p-Indicator">]</code><code class="w"/>
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">id</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ruff-format</code><code class="w"/></pre></div>

<p>The pre-commit hook for the code formatter comes last. This gives it an
opportunity to reformat any automatic fixes made by linters.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="id204">
<h1>Summary</h1>

<p>In this chapter, you’ve seen how to improve and preserve the code quality in
your projects using linters and code formatters. Ruff is an efficient
reimplementation of many Python code-quality tools in Rust, including Flake8 and
Black. While it’s possible to run Ruff and other tools manually, you should
automate this process and include it as a mandatory check in CI. One of the best
options is pre-commit, a cross-language linter framework with Git integration.
Invoke pre-commit from a Nox session to keep a single entry point to your suite
of checks.</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="id311"><sup><a href="ch09.html#id311-marker">1</a></sup> The <code>B</code> short code activates a group of checks pioneered by <code>flake8-bugbear</code>, a plugin for the Flake8 linter.</p><p data-type="footnote" id="id312"><sup><a href="ch09.html#id312-marker">2</a></sup> Charlie Marsh: <a href="https://notes.crmarsh.com/python-tooling-could-be-much-much-faster">“Python tooling could be much, much faster”</a>, August 30, 2022.</p><p data-type="footnote" id="id313"><sup><a href="ch09.html#id313-marker">3</a></sup> As of this writing, you’ll also need to enable Ruff’s preview mode. Set <code>tool.ruff.lint.preview</code> to <code>true</code>.</p><p data-type="footnote" id="id314"><sup><a href="ch09.html#id314-marker">4</a></sup> My reviewer Hynek disagrees. He sets his projects to <code>ALL</code> and opts out of rules that don’t apply to him. “Otherwise, you’ll miss new rules. If something starts failing after an update, you can take action.”</p><p data-type="footnote" id="id315"><sup><a href="ch09.html#id315-marker">5</a></sup> What’s wrong with assertions? Nothing, but Python skips them when run with <code>-O</code> for optimizations—a common way to speed up production environments. So don’t use <code>assert</code> to validate untrusted input!</p><p data-type="footnote" id="id316"><sup><a href="ch09.html#id316-marker">6</a></sup> Kent Beck and Martin Fowler describe <em>code smells</em> as “certain structures in the code that suggest—​sometimes, scream for—​the possibility of refactoring.” Martin Fowler: <em>Refactoring: Improving the Design of Existing Code</em>, Second Edition, Boston: Addison-Wesley, 2019.</p><p data-type="footnote" id="id317"><sup><a href="ch09.html#id317-marker">7</a></sup> Running pre-commit from Git is the safest way to run linters with automatic fixes: Pre-commit saves and restores any changes you haven’t staged, and it rolls back the fixes if they conflict with your changes.</p><p data-type="footnote" id="id318"><sup><a href="ch09.html#id318-marker">8</a></sup> Charlie Marsh: <a href="https://astral.sh/blog/the-ruff-formatter">“The Ruff Formatter”</a>, October 24, 2023.</p><p data-type="footnote" id="id319"><sup><a href="ch09.html#id319-marker">9</a></sup> Stephen C. Johnson, the author of Lint, also established this infamous naming convention by writing Yacc (Yet Another Compiler-Compiler) in the early 1970s at Bell Labs.</p><p data-type="footnote" id="id320"><sup><a href="ch09.html#id320-marker">10</a></sup> <a href="https://black.readthedocs.io/en/stable/the_black_code_style/current_style.html#labels-ast-changes">“AST before and after formatting,”</a> <em>Black documentation</em>. Last accessed: March 22, 2024.</p><p data-type="footnote" id="id321"><sup><a href="ch09.html#id321-marker">11</a></sup> You can inspect the AST of a source file with the standard <code>ast</code> module, using <code>py -m ast example.py</code>.</p></div></div></section></div>
</div>
</body></html>