- en: Chapter 11\. Modules, Packages, and Goodies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During your bottom-up climb, you’ve progressed from built-in data types to constructing
    ever-larger data and code structures. In this chapter, you finally learn how to
    write realistic whole programs in Python. You’ll write your own *modules* and
    learn how to use others from Python’s *standard library* and other sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The text of this book is organized in a hierarchy: words, sentences, paragraphs,
    and chapters. Otherwise, it would be unreadable pretty quickly.^([1](ch11.html#idm45794994198296))
    Code has a roughly similar bottom-up organization: data types are like words;
    expressions and statements are like sentences; functions are like paragraphs;
    and modules are like chapters. To continue the analogy, in this book, when I say
    that something will be explained in [Chapter 8](ch08.html#ch_dicts), in programming
    that’s like referring to code in another module.'
  prefs: []
  type: TYPE_NORMAL
- en: Modules and the import Statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll create and use Python code in more than one file. A *module* is just a
    file of any Python code. You don’t need to do anything special—any Python code
    can be used as a module by others.
  prefs: []
  type: TYPE_NORMAL
- en: We refer to code of other modules by using the Python `import` statement. This
    makes the code and variables in the imported module available to your program.
  prefs: []
  type: TYPE_NORMAL
- en: Import a Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest use of the `import` statement is `import` *`module`*, where *`module`*
    is the name of another Python file, without the *.py* extension.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say you and a few others want something fast for lunch, but don’t want
    a long discussion, and you always end up picking what the loudest person wants
    anyhow. Let the computer decide! Let’s write a module with a single function that
    returns a random fast-food choice, and a main program that calls it and prints
    the choice.
  prefs: []
  type: TYPE_NORMAL
- en: The module (*fast.py*) is shown in [Example 11-1](#ch11_ex1).
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-1\. fast.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: And [Example 11-2](#ch11_ex2) shows the main program that imports it (call it
    *lunch.py*).
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-2\. lunch.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have these two files in the same directory and instruct Python to run
    *lunch.py* as the main program, it will access the `fast` module and run its `pick()`
    function. We wrote this version of `pick()` to return a random result from a list
    of strings, so that’s what the main program will get back and print:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We used imports in two different places:'
  prefs: []
  type: TYPE_NORMAL
- en: The main program *lunch.py* imported our new module `fast`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The module file *fast.py* imported the `choice` function from Python’s standard
    library module named `random`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also used imports in two different ways in our main program and our module:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first case, we imported the entire `fast` module but needed to use `fast`
    as a prefix to `pick()`. After this `import` statement, everything in *fast.py*
    is available to the main program, as long as we tack `fast.` before its name.
    By *qualifying* the contents of a module with the module’s name, we avoid any
    nasty naming conflicts. There could be a `pick()` function in some other module,
    and we would not call it by mistake.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second case, we’re within a module and know that nothing else named `choice`
    is here, so we imported the `choice()` function from the `random` module directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could have written *fast.py*, as shown in [Example 11-3](#ch11_ex3), importing
    `random` within the `pick()` function instead of at the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-3\. fast2.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Like many aspects of programming, use the style that seems the most clear to
    you. The module-qualified name (`random.choice`) is safer but requires a little
    more typing.
  prefs: []
  type: TYPE_NORMAL
- en: Consider importing from outside the function if the imported code might be used
    in more than one place, and from inside if you know its use will be limited. Some
    people prefer to put all their imports at the top of the file, just to make all
    the dependencies of their code explicit. Either way works.
  prefs: []
  type: TYPE_NORMAL
- en: Import a Module with Another Name
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our main *lunch.py* program, we called `import fast`. But what if you:'
  prefs: []
  type: TYPE_NORMAL
- en: Have another module named `fast` somewhere?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Want to use a name that is more mnemonic?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caught your fingers in a door and want to minimize typing?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In these cases, you can import using an *alias*, as shown in [Example 11-4](#ch11_ex4).
    Let’s use the alias `f`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-4\. fast3.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Import Only What You Want from a Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can import a whole module or just parts of it. You just saw the latter:
    we only wanted the `choice()` function from the `random` module.'
  prefs: []
  type: TYPE_NORMAL
- en: Like the module itself, you can use an alias for each thing that you import.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s redo *lunch.py* a few more times. First, import `pick()` from the `fast`
    module with its original name ([Example 11-5](#ch11_ex5)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-5\. fast4.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now import it as `who_cares`([Example 11-6](#ch11_ex6)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-6\. fast5.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We went from single lines of code, to multiline functions, to standalone programs,
    to multiple modules in the same directory. If you don’t have many modules, the
    same directory works fine.
  prefs: []
  type: TYPE_NORMAL
- en: To allow Python applications to scale even more, you can organize modules into
    file and module hierarchies called *packages*. A package is just a subdirectory
    that contains *.py* files. And you can go more than one level deep, with directories
    inside those.
  prefs: []
  type: TYPE_NORMAL
- en: We just wrote a module that chooses a fast-food place. Let’s add a similar module
    to dispense life advice. We’ll make one new main program called *questions.py*
    in our current directory. Now make a subdirectory named *choices* and put two
    modules in it—*fast.py* and *advice.py*. Each module has a function that returns
    a string.
  prefs: []
  type: TYPE_NORMAL
- en: The main program (*questions.py*) has an extra import and line ([Example 11-7](#ch11_ex7)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-7\. questions.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: That `from sources` makes Python look for a directory named *sources*, starting
    under your current directory. Inside *sources* it looks for the files *fast.py*
    and *advice.py*.
  prefs: []
  type: TYPE_NORMAL
- en: The first module (*choices/fast.py*) is the same code as before, just moved
    into the *choices* directory ([Example 11-8](#ch11_ex8)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-8\. choices/fast.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The second module (*choices/advice.py*) is new, but it works a lot like its
    fast-food relative ([Example 11-9](#ch11_ex9)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-9\. choices/advice.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If your version of Python is earlier than 3.3, you’ll need one more thing in
    the *sources* subdirectory to make it a Python package: a file named *__init__.py*.
    This can be an empty file, but pre-3.3 Python needs it to treat the directory
    containing it as a package. (This is another common Python interview question.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the main *questions.py* program (from your current directory, not in *sources*)
    to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The Module Search Path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I just said that Python looks under your current directory for the subdirectory
    *choices* and its modules. Actually, it looks in other places, as well, and you
    can control this.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, we imported the function `choice()` from the standard library’s `random`
    module. That wasn’t in your current directory, so Python needed to look elsewhere
    also.
  prefs: []
  type: TYPE_NORMAL
- en: To see all the places that your Python interpreter looks, import the standard
    `sys` module and use its `path` list. This is a list of directory names and ZIP
    archive files that Python searches in order to find modules to import.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access and modify this list. Here’s the value of `sys.path` for Python
    3.7 on my Mac:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'That initial blank output line is the empty string `''''`, which stands for
    the current directory. If `''''` is first in `sys.path`, Python looks in the current
    directory first when you try to import something: `import fast` looks for *fast.py*.
    This is Python’s usual setup. Also, when we made that subdirectory called *sources*
    and put Python files in it, they could be imported with `import sources` or `from
    sources import fast`.'
  prefs: []
  type: TYPE_NORMAL
- en: The first match will be used. This means that if you define a module named `random`
    and it’s in the search path before the standard library, you won’t be able to
    access the standard library’s `random` now.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can modify the search path within your code. Let’s say you want Python
    to look in the */my/modules* directory before any other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Relative and Absolute Imports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our examples so far, we imported our own modules from:'
  prefs: []
  type: TYPE_NORMAL
- en: The current directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The subdirectory *choices*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python standard library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This works well until you have a local module with the same name as a standard
    one. Which do you want?
  prefs: []
  type: TYPE_NORMAL
- en: Python supports *absolute* or *relative* imports. The examples that you’ve seen
    so far are absolute imports. If you typed `import rougarou`, for each directory
    in the search path, Python will look for a file named *rougarou.py* (a module)
    or a directory named *rougarou* (a package).
  prefs: []
  type: TYPE_NORMAL
- en: If *rougarou.py* is in the same directory as your calling problem, you can import
    it *relative* to your location with `from . import rougarou`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If it’s in the directory above you: `from .. import rougarou`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If it’s under a sibling directory called `creatures`: `from ..creatures import`
    `rougarou`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `.` and `..` notation was borrowed from Unix’s shorthand for *current directory*
    and *parent directory*.
  prefs: []
  type: TYPE_NORMAL
- en: For a good discussion of Python import problems that you may run into, see [Traps
    for the Unwary in Python’s Import System](https://oreil.ly/QMWHY).
  prefs: []
  type: TYPE_NORMAL
- en: Namespace Packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’ve seen that you can package Python modules as:'
  prefs: []
  type: TYPE_NORMAL
- en: A single *module* (*.py* file)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *package* (directory containing modules, and possibly other packages)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also split a package across directories with *namespace packages*.
    Say you want a package called *critters* that will contain a Python module for
    each dangerous creature (real or imagined, supposedly with background info and
    protective hints). This might get large over time, and you’d like to subdivide
    these by geographic location. One option is to add location subpackages under
    *critters* and move the existing *.py* module files under them, but this would
    break things for other modules that import them. Instead, we can go *up* and do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Make new location directories above *critters*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make cousin *critters* directories under these new parents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move existing modules to their respective directories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This needs some illustration. Say we started with this file layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Normal imports of these modules would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we decided on US locations *north* and *south*, the files and directories
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If both *north* and *south* are in your module search path, you can import
    the modules as though they were still cohabiting a single-directory package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Modules Versus Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When should you put your code into a module, and when into an object?
  prefs: []
  type: TYPE_NORMAL
- en: They look similar in many ways. An object or module called `thing` with an internal
    data value called `stuff` would let you access the value as `thing.stuff`. `stuff`
    may have been defined when the module or class was created, or it may have been
    assigned later.
  prefs: []
  type: TYPE_NORMAL
- en: All the classes, functions, and global variables in a module are available to
    the outside. Objects can use properties and “dunder” (`__` …) naming to hide or
    control access to their data attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means you can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Did you just ruin calculations for everyone on this computer? Yes! No, I’m kidding.^([2](ch11.html#idm45794993539736))
    This did not affect the Python `math` module. You only changed the value of `pi`
    for the copy of the `math` module code imported by your calling program, and all
    evidence of your crimes will disappear when it finishes.
  prefs: []
  type: TYPE_NORMAL
- en: There’s only one copy of any module imported by your program, even if you import
    it more than once. You can use it to save global things, of interest to any code
    that imports it. This is similar to a class, which also has only one copy, although
    you can have many objects created from it.
  prefs: []
  type: TYPE_NORMAL
- en: Goodies in the Python Standard Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of Python’s prominent claims is that it has “batteries included”—a large
    standard library of modules that perform many useful tasks. They are kept separate
    to avoid bloating the core language. When you’re about to write some Python code,
    it’s often worthwhile to first check whether there’s a standard module that already
    does what you want. It’s surprising how often you encounter little gems in the
    standard library. Python also provides authoritative [documentation](http://docs.python.org/3/library)
    for the modules, along with a [tutorial](http://bit.ly/library-tour). Doug Hellmann’s
    website [Python Module of the Week](http://bit.ly/py-motw) and book [*The Python
    Standard Library by Example*](http://bit.ly/py-libex) (Addison-Wesley Professional)
    are also very useful guides.
  prefs: []
  type: TYPE_NORMAL
- en: Upcoming chapters in this book feature many of the standard modules that are
    specific to the web, systems, databases, and so on. In this section, I talk about
    some standard modules that have generic uses.
  prefs: []
  type: TYPE_NORMAL
- en: Handle Missing Keys with setdefault() and defaultdict()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’ve seen that trying to access a dictionary with a nonexistent key raises
    an exception. Using the dictionary `get()` function to return a default value
    avoids an exception. The `setdefault()` function is like `get()`, but also assigns
    an item to the dictionary if the key is missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If the key was *not* already in the dictionary, the new value is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to assign a different default value to an *existing* key, the original
    value is returned and nothing is changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`defaultdict()` is similar, but specifies the default value for any new key
    up front, when the dictionary is created. Its argument is a function. In this
    example, we pass the function `int`, which will be called as `int()` and return
    the integer `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now any missing value will be an integer (`int`), with the value `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The argument to `defaultdict()` is a function that returns the value to be
    assigned to a missing key. In the following example, `no_idea()` is executed to
    return a value when needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the functions `int()`, `list()`, or `dict()` to return default
    empty values for those types: `int()` returns `0`, `list()` returns an empty list
    (`[]`), and `dict()` returns an empty dictionary (`{}`). If you omit the argument,
    the initial value of a new key will be set to `None`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, you can use `lambda` to define your default-making function right
    inside the call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `int` is one way to make your own counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, if `food_counter` had been a normal dictionary instead
    of a `defaultdict`, Python would have raised an exception every time we tried
    to increment the dictionary element `food_counter[food]` because it would not
    have been initialized. We would have needed to do some extra work, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Count Items with Counter()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Speaking of counters, the standard library has one that does the work of the
    previous example and more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `most_common()` function returns all elements in descending order, or just
    the top `count` elements if given a count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You can combine counters. First, let’s see again what’s in `breakfast_counter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we make a new list called `lunch`, and a counter called `lunch_counter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The first way we combine the two counters is by addition, using `+`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you might expect, you subtract one counter from another by using `-`. What’s
    for breakfast but not for lunch?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Okay, now what can we have for lunch that we can’t have for breakfast?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to sets in [Chapter 8](ch08.html#ch_dicts), you can get common items
    by using the intersection operator `&`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The intersection chose the common element (`''eggs''`) with the lower count.
    This makes sense: breakfast offered only one egg, so that’s the common count.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can get all items by using the union operator `|`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The item `'eggs'` was again common to both. Unlike addition, union didn’t add
    their counts, but selected the one with the larger count.
  prefs: []
  type: TYPE_NORMAL
- en: Order by Key with OrderedDict()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is an example run with the Python 2 interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Starting with Python 3.7, dictionaries retain keys in the order in which they
    were added. `OrderedDict` is useful for earlier versions, which have an unpredictable
    order. The examples in this section are relevant only if you’re a version of Python
    earlier than 3.7.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `OrderedDict()` remembers the order of key addition and returns them in
    the same order from an iterator. Try creating an `OrderedDict` from a sequence
    of (*key*, *value*) tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Stack + Queue == deque
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `deque` (pronounced *deck*) is a double-ended queue, which has features of
    both a stack and a queue. It’s useful when you want to add and delete items from
    either end of a sequence. Here, we work from both ends of a word to the middle
    to see whether it’s a palindrome. The function `popleft()` removes the leftmost
    item from the deque and returns it; `pop()` removes the rightmost item and returns
    it. Together, they work from the ends toward the middle. As long as the end characters
    match, it keeps popping until it reaches the middle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'I used this as a simple illustration of deques. If you really wanted a quick
    palindrome checker, it would be a lot simpler to just compare a string with its
    reverse. Python doesn’t have a `reverse()` function for strings, but it does have
    a way to reverse a string with a slice, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Iterate over Code Structures with itertools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`itertools`](http://bit.ly/py-itertools) contains special-purpose iterator
    functions. Each returns one item at a time when called within a `for` … `in` loop,
    and remembers its state between calls.'
  prefs: []
  type: TYPE_NORMAL
- en: '`chain()` runs through its arguments as though they were a single iterable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`cycle()` is an infinite iterator, cycling through its arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: And, so on.
  prefs: []
  type: TYPE_NORMAL
- en: '`accumulate()` calculates accumulated values. By default, it calculates the
    sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You can provide a function as the second argument to `accumulate()`, and it
    will be used instead of addition. The function should take two arguments and return
    a single result. This example calculates an accumulated product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `itertools` module has many more functions, notably some for combinations
    and permutations that can be time savers when the need arises.
  prefs: []
  type: TYPE_NORMAL
- en: Print Nicely with pprint()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All of our examples have used `print()` (or just the variable name, in the
    interactive interpreter) to print things. Sometimes, the results are hard to read.
    We need a *pretty printer* such as `pprint()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Plain old `print()` just dumps things out there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `pprint()` tries to align elements for better readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Get Random
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We played with `random.choice()` at the beginning of this chapter. That returns
    a value from the sequence (list, tuple, dictionary, string) argument that it’s
    given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `sample()` function to get more than one value at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To get a random integer from any range, you can use `choice()` or `sample()`
    with `range()`, or use `randint()` or `randrange()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`randrange()`, like `range()`, has arguments for the start (inclusive) and
    end (exclusive) integers, and an optional integer step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, get a random real number (a float) between 0.0 and 1.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'More Batteries: Get Other Python Code'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, the standard library doesn’t have what you need, or doesn’t do it
    in quite the right way. There’s an entire world of open source, third-party Python
    software. Good resources include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PyPi](http://pypi.python.org) (also known as the Cheese Shop, after an old
    Monty Python skit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[GitHub](https://github.com/Python)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[readthedocs](https://readthedocs.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find many smaller code examples at [activestate](https://oreil.ly/clMAi).
  prefs: []
  type: TYPE_NORMAL
- en: 'Almost all of the Python code in this book uses the standard Python installation
    on your computer, which includes all the built-ins and the standard library. External
    packages are featured in some places: I mentioned `requests` in [Chapter 1](ch01.html#ch_intro);
    I have more details in [Chapter 18](ch18.html#ch_web). [Appendix B](app02.html#app_install)
    shows how to install third-party Python software, along with many other nuts-and-bolts
    development details.'
  prefs: []
  type: TYPE_NORMAL
- en: Coming Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next chapter is a practical one, covering many aspects of data manipulation
    in Python. You’ll encounter the binary *bytes* and *bytearray* data types, handle
    Unicode characters in text strings, and search text strings with regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Do
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 11.1 Create a file called *zoo.py*. In it, define a function called `hours()`
    that prints the string `'Open 9-5 daily'`. Then, use the interactive interpreter
    to import the `zoo` module and call its `hours()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 11.2 In the interactive interpreter, import the `zoo` module as `menagerie`
    and call its `hours()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 11.3 Staying in the interpreter, import the `hours()` function from `zoo` directly
    and call it.
  prefs: []
  type: TYPE_NORMAL
- en: 11.4 Import the `hours()` function as `info` and call it.
  prefs: []
  type: TYPE_NORMAL
- en: '11.5 Make a dictionary called `plain` with the key-value pairs `''a'': 1`,
    `''b'': 2`, and `''c'': 3`, and then print it.'
  prefs: []
  type: TYPE_NORMAL
- en: 11.6 Make an `OrderedDict` called `fancy` from the same pairs listed in the
    previous question and print it. Did it print in the same order as `plain`?
  prefs: []
  type: TYPE_NORMAL
- en: 11.7 Make a `defaultdict` called `dict_of_lists` and pass it the argument `list`.
    Make the list `dict_of_lists['a']` and append the value `'something for a'` to
    it in one assignment. Print `dict_of_lists['a']`.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch11.html#idm45794994198296-marker)) At least, a little less readable
    than it already is.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch11.html#idm45794993539736-marker)) Or am I? Bwa ha ha.
  prefs: []
  type: TYPE_NORMAL
