["```py\nclass BankAccount:\n    \"\"\" A bank account actor (similar to counter but with + and -)\"\"\"\n\n    # 42 is a good start\n    def __init__(self, balance=42.0):\n        self._balance = balance\n\n    def deposit(self, amount):\n        if amount < 0:\n            raise Exception(\"Cannot deposit negative amount\")\n        self._balance += amount\n        return self._balance\n\n    def withdrawal(self, amount):\n        if amount > self._balance:\n            raise Exception(\"Please deposit more money first.\")\n        self._balance -= amount\n        return self._balance\n\n    def balance(self):\n        return self._balance\n\n# Create a BankAccount on a worker\naccount_future = client.submit(BankAccount, actor=True)\naccount = account_future.result()\n```", "```py\n# Non-blocking\nbalance_future = account.balance()\n# Blocks\nbalance = balance_future.result()\ntry:\n    f = account.withdrawal(100)\n    f.result() # throws an exception\nexcept Exception as e:\n    print(e)\n```", "```py\ndef inc(x):\n    import time\n    time.sleep(x)\n    f = counter.add(x)\n    # Note: the actor (in this case `counter`) is serializable; \n    # however, the future we get back from it is not.\n    # This is likely because the future contains a network connection \n    # to the actor, so need to get its concrete value here. If we don't\n    # need the value, you can avoid blocking and it will still execute.\n    return f.result()\n```", "```py\nclass SketchyBank:\n    \"\"\" A sketchy bank (handles multiple accounts in one actor).\"\"\"\n\n    # 42 is a good start\n    def __init__(self, accounts={}):\n        self._accounts = accounts\n\n    def create_account(self, key):\n        if key in self._accounts:\n            raise Exception(f\"{key} is already an account.\")\n        self._accounts[key] = 0.0\n\n    def deposit(self, key, amount):\n        if amount < 0:\n            raise Exception(\"Cannot deposit negative amount\")\n        if key not in self._accounts:\n            raise Exception(f\"Could not find account {key}\")\n        self._accounts[key] += amount\n        return self._accounts[key]\n\n    def withdrawal(self, key, amount):\n        if key not in self._accounts:\n            raise Exception(f\"Could not find account {key}\")\n        if amount > self._accounts[key]:\n            raise Exception(\"Please deposit more money first.\")\n        self._accounts[key] -= amount\n        return self._accounts[key]\n\n    def balance(self, key):\n        if key not in self._accounts:\n            raise Exception(f\"Could not find account {key}\")\n        return self._accounts[key]\n\nclass HashActorPool:\n    \"\"\"A basic deterministic actor pool.\"\"\"\n\n    def __init__(self, actorClass, num):\n        self._num = num\n        # Make the request number of actors\n        self._actors = list(\n            map(lambda x: client.submit(SketchyBank, actor=True).result(),\n                range(0, num)))\n\n    def actor_for_key(self, key):\n        return self._actors[hash(key) % self._num]\n\nholdens_questionable_bank = HashActorPool(SketchyBank, 10)\nholdens_questionable_bank.actor_for_key(\"timbit\").create_account(\"timbit\")\nholdens_questionable_bank.actor_for_key(\n    \"timbit\").deposit(\"timbit\", 42.0).result()\n```"]