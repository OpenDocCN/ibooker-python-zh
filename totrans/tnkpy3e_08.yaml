- en: 6\. Return Values#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 返回值#
- en: 原文：[https://allendowney.github.io/ThinkPython/chap06.html](https://allendowney.github.io/ThinkPython/chap06.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://allendowney.github.io/ThinkPython/chap06.html](https://allendowney.github.io/ThinkPython/chap06.html)
- en: In previous chapters, we’ve used built-in functions – like `abs` and `round`
    – and functions in the math module – like `sqrt` and `pow`. When you call one
    of these functions, it returns a value you can assign to a variable or use as
    part of an expression.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用了内置函数——如`abs`和`round`——以及数学模块中的函数——如`sqrt`和`pow`。当你调用这些函数中的一个时，它返回一个值，你可以将其赋值给一个变量或作为表达式的一部分使用。
- en: The functions we have written so far are different. Some use the `print` function
    to display values, and some use turtle functions to draw figures. But they don’t
    return values we assign to variables or use in expressions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止我们编写的函数是不同的。有些使用`print`函数显示值，有些使用turtle函数绘制图形。但它们没有返回我们赋值给变量或在表达式中使用的值。
- en: In this chapter, we’ll see how to write functions that return values.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何编写返回值的函数。
- en: 6.1\. Some functions have return values[#](#some-functions-have-return-values
    "Link to this heading")
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1. 有些函数有返回值[#](#some-functions-have-return-values "Link to this heading")
- en: When you call a function like `math.sqrt`, the result is called a **return value**.
    If the function call appears at the end of a cell, Jupyter displays the return
    value immediately.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当你像调用`math.sqrt`这样的函数时，结果被称为**返回值**。如果函数调用出现在单元格的末尾，Jupyter会立即显示返回值。
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you assign the return value to a variable, it doesn’t get displayed.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将返回值赋值给一个变量，它不会被显示。
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: But you can display it later.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可以稍后显示它。
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Or you can use the return value as part of an expression.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以将返回值作为表达式的一部分使用。
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here’s an example of a function that returns a value.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个返回值的函数示例。
- en: '[PRE7]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`circle_area` takes `radius` as a parameter and computes the area of a circle
    with that radius.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`circle_area`将`radius`作为参数，计算该半径的圆的面积。'
- en: The last line is a `return` statement that returns the value of `area`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行是一个`return`语句，它返回`area`的值。
- en: If we call the function like this, Jupyter displays the return value.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像这样调用函数，Jupyter会显示返回值。
- en: '[PRE8]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can assign the return value to a variable.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将返回值赋值给一个变量。
- en: '[PRE10]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Or use it as part of an expression.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 或者将其作为表达式的一部分使用。
- en: '[PRE11]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Later we can display the value of the variable we assigned the result to.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 后面我们可以显示赋值给结果的变量的值。
- en: '[PRE13]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: But we can’t access `area`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们无法访问`area`。
- en: '[PRE15]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`area` is a local variable in a function, so we can’t access it from outside
    the function.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`area`是函数中的局部变量，因此我们无法从函数外部访问它。'
- en: 6.2\. And some have None[#](#and-some-have-none "Link to this heading")
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2. 有些函数返回None[#](#and-some-have-none "Link to this heading")
- en: If a function doesn’t have a `return` statement, it returns `None`, which is
    a special value like `True` and `False`. For example, here’s the `repeat` function
    from Chapter 3.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数没有`return`语句，它会返回`None`，这是一个特殊的值，类似于`True`和`False`。例如，这里是第3章中的`repeat`函数。
- en: '[PRE17]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If we call it like this, it displays the first line of the Monty Python song
    “Finland”.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像这样调用它，它会显示蒙提·派森歌曲《芬兰》的第一行。
- en: '[PRE18]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This function uses the `print` function to display a string, but it does not
    use a `return` statement to return a value. If we assign the result to a variable,
    it displays the string anyway.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用`print`函数来显示一个字符串，但它没有使用`return`语句返回值。如果我们将结果赋值给一个变量，它仍然会显示这个字符串。
- en: '[PRE20]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: And if we display the value of the variable, we get nothing.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们显示变量的值，我们什么也得不到。
- en: '[PRE22]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`result` actually has a value, but Jupyter doesn’t show it. However, we can
    display it like this.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`result`实际上有一个值，但Jupyter不会显示它。不过我们可以像这样显示它。'
- en: '[PRE23]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The return value from `repeat` is `None`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat`的返回值是`None`。'
- en: Now here’s a function similar to `repeat` except that has a return value.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这里有一个类似`repeat`的函数，不同之处在于它有一个返回值。
- en: '[PRE25]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that we can use an expression in a `return` statement, not just a variable.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以在`return`语句中使用一个表达式，而不仅仅是一个变量。
- en: With this version, we can assign the result to a variable. When the function
    runs, it doesn’t display anything.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个版本，我们可以将结果赋值给一个变量。当函数运行时，它不会显示任何内容。
- en: '[PRE26]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: But later we can display the value assigned to `line`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 但之后我们可以显示赋值给`line`的值。
- en: '[PRE27]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: A function like this is called a **pure function** because it doesn’t display
    anything or have any other effect – other than returning a value.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的函数被称为**纯函数**，因为它不会显示任何内容或产生任何其他效果——除了返回一个值。
- en: 6.3\. Return values and conditionals[#](#return-values-and-conditionals "Link
    to this heading")
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3. 返回值与条件语句[#](#return-values-and-conditionals "Link to this heading")
- en: If Python did not provide `abs`, we could write it like this.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Python没有提供`abs`，我们可以像这样编写它。
- en: '[PRE29]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If `x` is negative, the first `return` statement returns `-x` and the function
    ends immediately. Otherwise, the second `return` statement returns `x` and the
    function ends. So this function is correct.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`x`为负，第一条`return`语句返回`-x`，函数立即结束。否则，第二条`return`语句返回`x`，函数结束。因此，这个函数是正确的。
- en: However, if you put `return` statements in a conditional, you have to make sure
    that every possible path through the program hits a `return` statement. For example,
    here’s an incorrect version of `absolute_value`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你将`return`语句放在条件语句中，你必须确保程序的每一条路径都能到达一个`return`语句。例如，这是一个错误版本的`absolute_value`。
- en: '[PRE30]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here’s what happens if we call this function with `0` as an argument.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以`0`作为参数调用这个函数，会发生什么呢？
- en: '[PRE31]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We get nothing! Here’s the problem: when `x` is `0`, neither condition is true,
    and the function ends without hitting a `return` statement, which means that the
    return value is `None`, so Jupyter displays nothing.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 什么都没有得到！问题在于：当`x`为`0`时，两个条件都不成立，函数结束而没有执行`return`语句，这意味着返回值是`None`，因此Jupyter不会显示任何内容。
- en: As another example, here’s a version of `absolute_value` with an extra `return`
    statement at the end.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子，这是一个带有额外`return`语句的`absolute_value`版本。
- en: '[PRE32]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If `x` is negative, the first `return` statement runs and the function ends.
    Otherwise the second `return` statement runs and the function ends. Either way,
    we never get to the third `return` statement – so it can never run.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`x`为负，第一条`return`语句执行，函数结束。否则，第二条`return`语句执行，函数结束。无论哪种情况，我们都不会到达第三条`return`语句——因此它永远不会执行。
- en: Code that can never run is called **dead code**. In general, dead code doesn’t
    do any harm, but it often indicates a misunderstanding, and it might be confusing
    to someone trying to understand the program.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 不能运行的代码叫做**死代码**。通常情况下，死代码不会造成任何危害，但它通常表明存在误解，并且可能会让试图理解程序的人感到困惑。
- en: '## 6.4\. Incremental development[#](#incremental-development "Link to this
    heading")'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '## 6.4\. 增量开发[#](#incremental-development "Link to this heading")'
- en: As you write larger functions, you might find yourself spending more time debugging.
    To deal with increasingly complex programs, you might want to try **incremental
    development**, which is a way of adding and testing only a small amount of code
    at a time.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写更大的函数时，可能会发现你花费更多时间在调试上。为了应对越来越复杂的程序，你可能会想尝试**增量开发**，这是一种每次只添加和测试少量代码的方式。
- en: 'As an example, suppose you want to find the distance between two points represented
    by the coordinates \((x_1, y_1)\) and \((x_2, y_2)\). By the Pythagorean theorem,
    the distance is:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设你想找出由坐标\((x_1, y_1)\)和\((x_2, y_2)\)表示的两点之间的距离。根据毕达哥拉斯定理，距离是：
- en: \[\mathrm{distance} = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\]
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: \[\mathrm{distance} = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}\]
- en: The first step is to consider what a `distance` function should look like in
    Python – that is, what are the inputs (parameters) and what is the output (return
    value)?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是考虑一个`distance`函数在Python中应该是什么样子的——也就是说，输入（参数）是什么，输出（返回值）是什么？
- en: 'For this function, the inputs are the coordinates of the points. The return
    value is the distance. Immediately you can write an outline of the function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个函数，输入是点的坐标。返回值是距离。你可以立即写出函数的大纲：
- en: '[PRE33]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This version doesn’t compute distances yet – it always returns zero. But it
    is a complete function with a return value, which means that you can test it before
    you make it more complicated.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本尚未计算距离——它总是返回零。但它是一个完整的函数，具有返回值，这意味着你可以在使其更复杂之前进行测试。
- en: 'To test the new function, we’ll call it with sample arguments:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个新函数，我们将用样本参数调用它：
- en: '[PRE34]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: I chose these values so that the horizontal distance is `3` and the vertical
    distance is `4`. That way, the result is `5`, the hypotenuse of a `3-4-5` right
    triangle. When testing a function, it is useful to know the right answer.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择这些值是为了让水平距离为`3`，垂直距离为`4`。这样，结果就是`5`，这是一个`3-4-5`直角三角形的斜边长度。测试一个函数时，知道正确的答案是非常有用的。
- en: At this point we have confirmed that the function runs and returns a value,
    and we can start adding code to the body. A good next step is to find the differences
    `x2 - x1` and `y2 - y1`. Here’s a version that stores those values in temporary
    variables and displays them.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经确认函数可以运行并返回一个值，我们可以开始向函数体中添加代码。一个好的下一步是找出`x2 - x1`和`y2 - y1`的差值。这是一个将这些值存储在临时变量中的版本，并显示它们。
- en: '[PRE36]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If the function is working, it should display `dx is 3` and `dy is 4`. If so,
    we know that the function is getting the right arguments and performing the first
    computation correctly. If not, there are only a few lines to check.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数正常工作，它应该显示`dx is 3`和`dy is 4`。如果是这样，我们就知道函数已经得到了正确的参数并且正确地进行了第一次计算。如果不是，检查的代码行就很少。
- en: '[PRE37]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Good so far. Next we compute the sum of squares of `dx` and `dy`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止很好。接下来我们计算`dx`和`dy`的平方和：
- en: '[PRE40]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Again, we can run the function and check the output, which should be `25`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行函数并检查输出，应该是`25`。
- en: '[PRE41]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, we can use `math.sqrt` to compute the distance:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`math.sqrt`来计算距离：
- en: '[PRE44]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: And test it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后进行测试。
- en: '[PRE45]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The result is correct, but this version of the function displays the result
    rather than returning it, so the return value is `None`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是正确的，但这个版本的函数显示了结果，而不是返回它，因此返回值是`None`。
- en: We can fix that by replacing the `print` function with a `return` statement.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过用`return`语句替换`print`函数来修复这个问题。
- en: '[PRE47]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This version of `distance` is a pure function. If we call it like this, only
    the result is displayed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的`distance`是一个纯函数。如果我们这样调用它，只有结果会被显示。
- en: '[PRE48]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: And if we assign the result to a variable, nothing is displayed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将结果赋值给一个变量，什么也不会显示。
- en: '[PRE50]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `print` statements we wrote are useful for debugging, but once the function
    is working, we can remove them. Code like that is called **scaffolding** because
    it is helpful for building the program but is not part of the final product.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的`print`语句对于调试很有用，但一旦函数正常工作，就可以将它们移除。这样的代码称为**临时代码**，它在构建程序时很有帮助，但不是最终产品的一部分。
- en: 'This example demonstrates incremental development. The key aspects of this
    process are:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了渐进式开发。这个过程的关键方面包括：
- en: Start with a working program, make small changes, and test after every change.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个可运行的程序开始，进行小的修改，并在每次修改后进行测试。
- en: Use variables to hold intermediate values so you can display and check them.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用变量来保存中间值，以便你可以显示和检查它们。
- en: Once the program is working, remove the scaffolding.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦程序工作正常，就可以移除临时代码。
- en: At any point, if there is an error, you should have a good idea where it is.
    Incremental development can save you a lot of debugging time.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候，如果出现错误，你应该有一个清晰的方向去找出问题。渐进式开发可以节省大量的调试时间。
- en: 6.5\. Boolean functions[#](#boolean-functions "Link to this heading")
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5\. 布尔函数[#](#boolean-functions "Link to this heading")
- en: Functions can return the boolean values `True` and `False`, which is often convenient
    for encapsulating a complex test in a function. For example, `is_divisible` checks
    whether `x` is divisible by `y` with no remainder.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以返回布尔值`True`和`False`，这通常方便将复杂的测试封装在函数中。例如，`is_divisible`检查`x`是否能被`y`整除且没有余数。
- en: '[PRE51]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here’s how we use it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何使用它的方式。
- en: '[PRE52]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Inside the function, the result of the `==` operator is a boolean, so we can
    write the function more concisely by returning it directly.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，`==`运算符的结果是一个布尔值，因此我们可以通过直接返回它来更简洁地编写这个函数。
- en: '[PRE56]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Boolean functions are often used in conditional statements.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔函数通常用于条件语句中。
- en: '[PRE57]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'It might be tempting to write something like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会想写成这样：
- en: '[PRE59]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: But the comparison is unnecessary.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 但是比较是没有必要的。
- en: 6.6\. Recursion with return values[#](#recursion-with-return-values "Link to
    this heading")
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6\. 带返回值的递归[#](#recursion-with-return-values "Link to this heading")
- en: Now that we can write functions with return values, we can write recursive functions
    with return values, and with that capability, we have passed an important threshold
    – the subset of Python we have is now **Turing complete**, which means that we
    can perform any computation that can be described by an algorithm.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写具有返回值的函数，我们也可以编写具有返回值的递归函数，有了这个能力，我们已经跨越了一个重要的门槛——我们现在拥有的 Python 子集是**图灵完备**的，这意味着我们可以执行任何可以通过算法描述的计算。
- en: 'To demonstrate recursion with return values, we’ll evaluate a few recursively
    defined mathematical functions. A recursive definition is similar to a circular
    definition, in the sense that the definition refers to the thing being defined.
    A truly circular definition is not very useful:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示带返回值的递归，我们将评估几个递归定义的数学函数。递归定义类似于循环定义，定义中会引用正在定义的事物。真正的循环定义并不十分有用：
- en: 'vorpal: An adjective used to describe something that is vorpal.'
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: vorpal：用于描述某物是vorpal的形容词。
- en: 'If you saw that definition in the dictionary, you might be annoyed. On the
    other hand, if you looked up the definition of the factorial function, denoted
    with the symbol \(!\), you might get something like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在字典里看到了这个定义，可能会觉得很烦恼。另一方面，如果你查阅阶乘函数的定义，用符号\(!\)表示，可能会得到如下内容：
- en: \[\begin{split}\begin{aligned} 0! &= 1 \\ n! &= n~(n-1)! \end{aligned}\end{split}\]
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}\begin{aligned} 0! &= 1 \\ n! &= n~(n-1)! \end{aligned}\end{split}\]
- en: This definition says that the factorial of \(0\) is \(1\), and the factorial
    of any other value, \(n\), is \(n\) multiplied by the factorial of \(n-1\).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义表示，\(0\)的阶乘是\(1\)，而任何其他值\(n\)的阶乘是\(n\)与\(n-1\)的阶乘相乘。
- en: If you can write a recursive definition of something, you can write a Python
    program to evaluate it. Following an incremental development process, we’ll start
    with a function that take `n` as a parameter and always returns `0`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能写出某个东西的递归定义，你就能写一个Python程序来计算它。按照增量开发的过程，我们首先从一个接受`n`作为参数并总是返回`0`的函数开始。
- en: '[PRE61]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now let’s add the first part of the definition – if the argument happens to
    be `0`, all we have to do is return `1`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加定义的第一部分——如果参数恰好是`0`，我们只需要返回`1`：
- en: '[PRE62]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now let’s fill in the second part – if `n` is not `0`, we have to make a recursive
    call to find the factorial of `n-1` and then multiply the result by `n`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们填写第二部分——如果`n`不为`0`，我们必须进行递归调用，找到`n-1`的阶乘，然后将结果与`n`相乘：
- en: '[PRE63]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The flow of execution for this program is similar to the flow of `countdown`
    in Chapter 5. If we call `factorial` with the value `3`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的执行流程类似于第5章中的`countdown`流程。如果我们用值`3`调用`factorial`：
- en: Since `3` is not `0`, we take the second branch and calculate the factorial
    of `n-1`.…
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`3`不等于`0`，我们采取第二个分支并计算`n-1`的阶乘。…
- en: Since `2` is not `0`, we take the second branch and calculate the factorial
    of `n-1`.…
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于`2`不等于`0`，我们采取第二个分支并计算`n-1`的阶乘。…
- en: ''
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Since `1` is not `0`, we take the second branch and calculate the factorial
    of `n-1`.…
  id: totrans-150
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于`1`不等于`0`，我们采取第二个分支并计算`n-1`的阶乘。…
- en: ''
  id: totrans-151
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Since `0` equals `0`, we take the first branch and return `1` without making
    any more recursive calls.
  id: totrans-152
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于`0`等于`0`，我们采取第一个分支并返回`1`，不再进行递归调用。
- en: ''
  id: totrans-153
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: The return value, `1`, is multiplied by `n`, which is `1`, and the result is
    returned.
  id: totrans-154
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回值`1`与`n`（即`1`）相乘，结果被返回。
- en: ''
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The return value, `1`, is multiplied by `n`, which is `2`, and the result is
    returned.
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回值`1`与`n`（即`2`）相乘，结果被返回。
- en: The return value `2` is multiplied by `n`, which is `3`, and the result, `6`,
    becomes the return value of the function call that started the whole process.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值`2`与`n`（即`3`）相乘，结果`6`成为整个过程启动时函数调用的返回值。
- en: The following figure shows the stack diagram for this sequence of function calls.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了这个函数调用序列的栈图。
- en: '![_images/726efd741b2b10a7e5f8789b876a18d14f2818ebbdfc92ab4c41430c6422fcfc.png](../Images/b37eb9da251407831430919397bc7f9a.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![_images/726efd741b2b10a7e5f8789b876a18d14f2818ebbdfc92ab4c41430c6422fcfc.png](../Images/b37eb9da251407831430919397bc7f9a.png)'
- en: The return values are shown being passed back up the stack. In each frame, the
    return value is the product of `n` and `recurse`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值被显示为从栈中返回。在每一帧中，返回值是`n`与`recurse`的乘积。
- en: In the last frame, the local variable `recurse` does not exist because the branch
    that creates it does not run.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一帧中，本地变量`recurse`不存在，因为创建它的分支没有执行。
- en: 6.7\. Leap of faith[#](#leap-of-faith "Link to this heading")
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7\. 信念的飞跃[#](#leap-of-faith "Link to this heading")
- en: Following the flow of execution is one way to read programs, but it can quickly
    become overwhelming. An alternative is what I call the “leap of faith”. When you
    come to a function call, instead of following the flow of execution, you *assume*
    that the function works correctly and returns the right result.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪执行流程是阅读程序的一种方式，但它很快就会变得让人不堪重负。另一种方法是我所称的“信念的飞跃”。当你遇到一个函数调用时，与你跟踪执行流程不同，你可以*假设*该函数正确工作并返回正确的结果。
- en: In fact, you are already practicing this leap of faith when you use built-in
    functions. When you call `abs` or `math.sqrt`, you don’t examine the bodies of
    those functions – you just assume that they work.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当你使用内置函数时，你已经在实践这种“信念的飞跃”。当你调用`abs`或`math.sqrt`时，你并没有检查这些函数的内部实现——你只是认为它们是有效的。
- en: The same is true when you call one of your own functions. For example, earlier
    we wrote a function called `is_divisible` that determines whether one number is
    divisible by another. Once we convince ourselves that this function is correct,
    we can use it without looking at the body again.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用自己的函数时，也是如此。例如，之前我们写了一个名为`is_divisible`的函数，用来判断一个数是否能被另一个数整除。一旦我们确信这个函数是正确的，就可以在不再查看函数体的情况下使用它。
- en: The same is true of recursive programs. When you get to the recursive call,
    instead of following the flow of execution, you should assume that the recursive
    call works and then ask yourself, “Assuming that I can compute the factorial of
    \(n-1\), can I compute the factorial of \(n\)?” The recursive definition of factorial
    implies that you can, by multiplying by \(n\).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 递归程序也是如此。当你到达递归调用时，应该假设递归调用是正确的，而不是跟随执行流程。然后你应该问自己，“假设我可以计算\(n-1\)的阶乘，我能计算\(n\)的阶乘吗？”阶乘的递归定义意味着你可以通过乘以\(n\)来计算。
- en: Of course, it’s a bit strange to assume that the function works correctly when
    you haven’t finished writing it, but that’s why it’s called a leap of faith!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，假设一个函数在你还没写完的时候就能正确工作，这有点奇怪，但这就是为什么它被称为信任的跳跃！
- en: '## 6.8\. Fibonacci[#](#fibonacci "Link to this heading")'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '## 6.8\. 斐波那契[#](#fibonacci "Link to this heading")'
- en: 'After `factorial`, the most common example of a recursive function is `fibonacci`,
    which has the following definition:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在`factorial`之后，最常见的递归函数示例是`fibonacci`，它有如下定义：
- en: \[\begin{split}\begin{aligned} \mathrm{fibonacci}(0) &= 0 \\ \mathrm{fibonacci}(1)
    &= 1 \\ \mathrm{fibonacci}(n) &= \mathrm{fibonacci}(n-1) + \mathrm{fibonacci}(n-2)
    \end{aligned}\end{split}\]
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}\begin{aligned} \mathrm{fibonacci}(0) &= 0 \\ \mathrm{fibonacci}(1)
    &= 1 \\ \mathrm{fibonacci}(n) &= \mathrm{fibonacci}(n-1) + \mathrm{fibonacci}(n-2)
    \end{aligned}\end{split}\]
- en: 'Translated into Python, it looks like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将其翻译为Python代码，像这样：
- en: '[PRE64]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If you try to follow the flow of execution here, even for small values of \(n\),
    your head explodes. But according to the leap of faith, if you assume that the
    two recursive calls work correctly, you can be confident that the last `return`
    statement is correct.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试跟踪这里的执行流程，即使是对于较小的\(n\)值，你也会感到头晕目眩。但根据信任的跳跃法则，如果你假设两个递归调用是正确的，你就可以确信最后的`return`语句是正确的。
- en: As an aside, this way of computing Fibonacci numbers is very inefficient. In
    [Chapter 10](chap10.html#section-memos) I’ll explain why and suggest a way to
    improve it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，这种计算斐波那契数的方法效率非常低。在[第10章](chap10.html#section-memos)中，我会解释为什么，并提出一种改进方法。
- en: 6.9\. Checking types[#](#checking-types "Link to this heading")
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.9\. 检查类型[#](#checking-types "Link to this heading")
- en: What happens if we call `factorial` and give it `1.5` as an argument?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用`factorial`并将`1.5`作为参数传递，会发生什么呢？
- en: '[PRE65]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: It looks like an infinite recursion. How can that be? The function has base
    cases when `n == 1` or `n == 0`. But if `n` is not an integer, we can *miss* the
    base case and recurse forever.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来像是无限递归。这怎么可能呢？函数在`n == 1`或`n == 0`时有基本情况。但如果`n`不是整数，我们可能会*错过*基本情况并进行无限递归。
- en: In this example, the initial value of `n` is `1.5`. In the first recursive call,
    the value of `n` is `0.5`. In the next, it is `-0.5`. From there, it gets smaller
    (more negative), but it will never be `0`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`n`的初始值为`1.5`。在第一次递归调用中，`n`的值是`0.5`。接下来是`-0.5`，然后它变得更小（更负），但永远不会是`0`。
- en: To avoid infinite recursion we can use the built-in function `isinstance` to
    check the type of the argument. Here’s how we check whether a value is an integer.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免无限递归，我们可以使用内置函数`isinstance`来检查参数的类型。下面是我们检查一个值是否为整数的方法。
- en: '[PRE67]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Now here’s a version of `factorial` with error-checking.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是一个带有错误检查的`factorial`版本。
- en: '[PRE71]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: First it checks whether `n` is an integer. If not, it displays an error message
    and returns `None`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它检查`n`是否为整数。如果不是，它会显示一个错误消息并返回`None`。
- en: '[PRE72]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Then it checks whether `n` is negative. If so, it displays an error message
    and returns `None.`
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它检查`n`是否为负数。如果是，它会显示一个错误消息并返回`None`。
- en: '[PRE74]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: If we get past both checks, we know that `n` is a non-negative integer, so we
    can be confident the recursion will terminate. Checking the parameters of a function
    to make sure they have the correct types and values is called **input validation**.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过了两个检查，我们就知道`n`是一个非负整数，因此可以确信递归会终止。检查函数的参数以确保它们具有正确的类型和值，称为**输入验证**。
- en: '## 6.10\. Debugging[#](#debugging "Link to this heading")'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '## 6.10\. 调试[#](#debugging "Link to this heading")'
- en: 'Breaking a large program into smaller functions creates natural checkpoints
    for debugging. If a function is not working, there are three possibilities to
    consider:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个大型程序分解成更小的函数会创建自然的调试检查点。如果某个函数无法正常工作，可以考虑三种可能性：
- en: There is something wrong with the arguments the function is getting – that is,
    a precondition is violated.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数获取的参数有问题——也就是说，前置条件被违反了。
- en: There is something wrong with the function – that is, a postcondition is violated.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数有问题——也就是说，后置条件被违反了。
- en: The caller is doing something wrong with the return value.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用者在返回值的使用上出现了问题。
- en: To rule out the first possibility, you can add a `print` statement at the beginning
    of the function that displays the values of the parameters (and maybe their types).
    Or you can write code that checks the preconditions explicitly.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了排除第一种可能性，可以在函数的开始处添加`print`语句，显示参数的值（可能还包括它们的类型）。或者你可以写代码显式检查前置条件。
- en: If the parameters look good, you can add a `print` statement before each `return`
    statement and display the return value. If possible, call the function with arguments
    that make it easy check the result.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数看起来没问题，可以在每个`return`语句之前添加`print`语句，显示返回值。如果可能，使用有助于检查结果的参数调用函数。
- en: If the function seems to be working, look at the function call to make sure
    the return value is being used correctly – or used at all!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数似乎在工作，检查函数调用，确保返回值被正确使用——或者至少被使用！
- en: 'Adding `print` statements at the beginning and end of a function can help make
    the flow of execution more visible. For example, here is a version of `factorial`
    with print statements:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的开始和结束处添加`print`语句可以帮助使执行流程更加可见。例如，以下是带有`print`语句的`factorial`函数版本：
- en: '[PRE76]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '`space` is a string of space characters that controls the indentation of the
    output. Here is the result of `factorial(3)` :'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`space` 是一个由空格字符组成的字符串，用来控制输出的缩进。以下是`factorial(3)`的结果：'
- en: '[PRE77]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: If you are confused about the flow of execution, this kind of output can be
    helpful. It takes some time to develop effective scaffolding, but a little bit
    of scaffolding can save a lot of debugging.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对执行流程感到困惑，这种输出可能会很有帮助。开发有效的脚手架代码需要一些时间，但少量的脚手架代码可以节省大量调试时间。
- en: 6.11\. Glossary[#](#glossary "Link to this heading")
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.11\. 术语表[#](#glossary "Link to this heading")
- en: '**return value:** The result of a function. If a function call is used as an
    expression, the return value is the value of the expression.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回值：** 函数的结果。如果函数调用作为表达式使用，则返回值是该表达式的值。'
- en: '**pure function:** A function that does not display anything or have any other
    effect, other than returning a return value.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**纯函数：** 一个不会显示任何内容或产生任何其他副作用的函数，除了返回返回值之外。'
- en: '**dead code:** Part of a program that can never run, often because it appears
    after a `return` statement.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**死代码：** 程序中无法运行的部分，通常是因为它出现在`return`语句之后。'
- en: '**incremental development:** A program development plan intended to avoid debugging
    by adding and testing only a small amount of code at a time.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**增量开发：** 一种程序开发计划，旨在通过一次只添加和测试少量代码来避免调试。'
- en: '**scaffolding:** Code that is used during program development but is not part
    of the final version.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**脚手架代码：** 在程序开发过程中使用的代码，但不是最终版本的一部分。'
- en: '**Turing complete:** A language, or subset of a language, is Turing complete
    if it can perform any computation that can be described by an algorithm.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**图灵完备：** 如果一个语言或语言的子集能够执行任何可以通过算法描述的计算，那么它是图灵完备的。'
- en: '**input validation:** Checking the parameters of a function to make sure they
    have the correct types and values'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入验证：** 检查函数的参数，确保它们具有正确的类型和值。'
- en: 6.12\. Exercises[#](#exercises "Link to this heading")
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.12\. 练习[#](#exercises "Link to this heading")
- en: '[PRE80]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 6.12.1\. Ask a virtual assistant[#](#ask-a-virtual-assistant "Link to this heading")
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.12.1\. 向虚拟助手询问[#](#ask-a-virtual-assistant "Link to this heading")
- en: In this chapter, we saw an incorrect function that can end without returning
    a value.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到一个不正确的函数，它可能在没有返回值的情况下结束。
- en: '[PRE82]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: And a version of the same function that has dead code at the end.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是同一个函数的一个版本，它在末尾有死代码。
- en: '[PRE83]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: And we saw the following example, which is correct but not idiomatic.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了以下示例，这虽然是正确的，但不够地道。
- en: '[PRE84]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Ask a virtual assistant what’s wrong with each of these functions and see if
    it can spot the errors or improve the style.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 向虚拟助手询问这些函数的错误，并看看它是否能发现错误或改进风格。
- en: Then ask “Write a function that takes coordinates of two points and computes
    the distance between them.” See if the result resembles the version of `distance`
    we wrote in this chapter.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后问：“编写一个函数，接受两点的坐标并计算它们之间的距离。”看看结果是否与我们在本章中编写的`distance`函数类似。
- en: 6.12.2\. Exercise[#](#exercise "Link to this heading")
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.12.2\. 练习[#](#exercise "链接到此标题")
- en: Use incremental development to write a function called `hypot` that returns
    the length of the hypotenuse of a right triangle given the lengths of the other
    two legs as arguments.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用增量开发编写一个名为`hypot`的函数，给定直角三角形的其他两个边的长度作为参数，返回斜边的长度。
- en: 'Note: There’s a function in the math module called `hypot` that does the same
    thing, but you should not use it for this exercise!'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在数学模块中有一个叫做`hypot`的函数，执行相同的操作，但你不应该在这个练习中使用它！
- en: Even if you can write the function correctly on the first try, start with a
    function that always returns `0` and practice making small changes, testing as
    you go. When you are done, the function should only return a value – it should
    not display anything.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你第一次就能正确编写该函数，还是从一个始终返回`0`的函数开始，并练习逐步修改，边修改边测试。完成后，该函数应仅返回一个值——不应输出任何内容。
- en: 6.12.3\. Exercise[#](#id1 "Link to this heading")
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.12.3\. 练习[#](#id1 "链接到此标题")
- en: Write a boolean function, `is_between(x, y, z)`, that returns `True` if \(x
    < y < z\) or if \(z < y < x\), and`False` otherwise.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个布尔函数`is_between(x, y, z)`，如果\(x < y < z\)或者\(z < y < x\)，则返回`True`，否则返回`False`。
- en: 6.12.4\. Exercise[#](#id2 "Link to this heading")
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.12.4\. 练习[#](#id2 "链接到此标题")
- en: 'The Ackermann function, \(A(m, n)\), is defined:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 阿克曼函数\(A(m, n)\)定义如下：
- en: \[\begin{split}\begin{aligned} A(m, n) = \begin{cases} n+1 & \mbox{if } m =
    0 \\ A(m-1, 1) & \mbox{if } m > 0 \mbox{ and } n = 0 \\ A(m-1, A(m, n-1)) & \mbox{if
    } m > 0 \mbox{ and } n > 0. \end{cases} \end{aligned}\end{split}\]
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}\begin{aligned} A(m, n) = \begin{cases} n+1 & \mbox{如果} m = 0
    \\ A(m-1, 1) & \mbox{如果} m > 0 \mbox{ 且 } n = 0 \\ A(m-1, A(m, n-1)) & \mbox{如果}
    m > 0 \mbox{ 且 } n > 0. \end{cases} \end{aligned}\end{split}\]
- en: Write a function named `ackermann` that evaluates the Ackermann function. What
    happens if you call `ackermann(5, 5)`?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为`ackermann`的函数来计算阿克曼函数。当你调用`ackermann(5, 5)`时，会发生什么？
- en: 6.12.5\. Exercise[#](#id3 "Link to this heading")
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.12.5\. 练习[#](#id3 "链接到此标题")
- en: The greatest common divisor (GCD) of \(a\) and \(b\) is the largest number that
    divides both of them with no remainder.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: \(a\)和\(b\)的最大公约数（GCD）是能够整除它们两者且没有余数的最大数。
- en: One way to find the GCD of two numbers is based on the observation that if \(r\)
    is the remainder when \(a\) is divided by \(b\), then \(gcd(a, b) = gcd(b, r)\).
    As a base case, we can use \(gcd(a, 0) = a\).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 找到两个数的GCD的一种方法是基于以下观察：如果\(r\)是将\(a\)除以\(b\)后的余数，那么\(gcd(a, b) = gcd(b, r)\)。作为基础情况，我们可以使用\(gcd(a,
    0) = a\)。
- en: Write a function called `gcd` that takes parameters `a` and `b` and returns
    their greatest common divisor.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为`gcd`的函数，接受参数`a`和`b`，并返回它们的最大公约数。
- en: '[Think Python: 3rd Edition](https://allendowney.github.io/ThinkPython/index.html)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[Think Python: 第3版](https://allendowney.github.io/ThinkPython/index.html)'
- en: Copyright 2024 [Allen B. Downey](https://allendowney.com)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 版权 2024 [Allen B. Downey](https://allendowney.com)
- en: 'Code license: [MIT License](https://mit-license.org/)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 代码许可证：[MIT许可证](https://mit-license.org/)
- en: 'Text license: [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 文本许可证：[创意共享署名-非商业性使用-相同方式共享 4.0 国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/)
