["```py\napiVersion: traefik.containo.us/v1alpha1\nkind: Middleware\nmetadata:\n  name: basicauth\n  namespace: ray-cluster\nspec:\n  basicAuth:\n    secret: basic-auth\n-\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: longhorn-ingress\n  namespace: longhorn-system\nannotations:\n  traefik.ingress.kubernetes.io/router.entrypoints: websecure\n  traefik.ingress.kubernetes.io/router.tls.certresolver: le\n  traefik.ingress.kubernetes.io/router.tls: \"true\"\n  kubernetes.io/ingress.class: traefik\n  traefik.ingress.kubernetes.io/router.middlewares: ba-ray-cluster@kubernetescrd\n        spec:\n          rules:\n            - host: \"mymagicendpoints.pigscanfly.ca\"\n              http:\n                paths:\n                - pathType: Prefix\n                  path: \"/\"\n                  backend:\n                    service:\n                      name: ray-head-svc\n                      port:\n                        number: 8265\n```", "```py\nray.init(\n                runtime_env={\n                    \"env_vars\": {\n                        \"AWS_ACCESS_KEY_ID\": \"key\",\n                        \"AWS_SECRET_ACCESS_KEY\": \"secret\",\n                    }\n                }\n            )\n```", "```py\n# Singleton for reporting a Ray metric\n\n@ray.remote\nclass MySpecialActor(object):\n    def __init__(self, name):\n        self.total = 0\n        from ray.util.metrics import Counter, Gauge\n        self.failed_withdrawls = Counter(\n            \"failed_withdrawls\", description=\"Number of failed withdrawls.\",\n            tag_keys=(\"actor_name\",), # Useful if you end up sharding actors\n        )\n        self.failed_withdrawls.set_default_tags({\"actor_name\": name})\n        self.total_guage = Gauge(\n            \"money\",\n            description=\"How much money we have in total. Goes up and down.\",\n            tag_keys=(\"actor_name\",), # Useful if you end up sharding actors\n        )\n        self.total_guage.set_default_tags({\"actor_name\": name})\n        self.accounts = {}\n\n    def deposit(self, account, amount):\n        if account not in self.accounts:\n            self.accounts[account] = 0\n        self.accounts[account] += amount\n        self.total += amount\n        self.total_guage.set(self.total)\n\n    def withdrawl(self, account, amount):\n        if account not in self.accounts:\n            self.failed_withdrawls.inc()\n            raise Exception(\"No account\")\n        if self.accounts[account] < amount:\n            self.failed_withdrawls.inc()\n            raise Exception(\"Not enough money\")\n        self.accounts[account] -= amount\n        self.total -= amount\n        self.total_guage.set(self.total)\n```", "```py\n# Singleton for reporting a Ray metric\n\nclass FailureCounter(object):\n    _instance = None\n\n    def __new__(cls):\n        if cls._instance is None:\n            print('Creating the object')\n            cls._instance = super(FailureCounter, cls).__new__(cls)\n            from ray.util.metrics import Counter\n            cls._instance.counter = Counter(\n                \"failure\",\n                description=\"Number of failures (goes up only).\")\n        return cls._instance\n\n# This will fail with every zero because divide by zero\n@ray.remote\ndef remote_fun(x):\n    try:\n        return 10 / x\n    except:\n        FailureCounter().counter.inc()\n        return None\n```", "```py\nray.init(address='ray://<*`your IP`*>:10001')\n\n@ray.remote(num_cpus=6)\ndef runDocker(cmd):\n   with open(\"result.txt\", \"w\") as output:\n       result = subprocess.run(\n           cmd,\n           shell=True,  # Pass single string to shell, let it handle.\n           stdout=output,\n           stderr=output\n       )\n\n   print(f\"return code {result.returncode}\")\n   with open(\"result.txt\", \"r\") as output:\n       log = output.read()\n   return log\n\ncmd='docker run --rm busybox echo \"Hello world\"'\n\nresult=runDocker.remote(cmd)\nprint(f\"result: {ray.get(result)}\")\n```"]