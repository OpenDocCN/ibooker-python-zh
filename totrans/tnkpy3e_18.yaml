- en: 16\. Classes and Objects#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://allendowney.github.io/ThinkPython/chap16.html](https://allendowney.github.io/ThinkPython/chap16.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: At this point we have defined classes and created objects that represent the
    time of day and the day of the year. And we’ve defined methods that create, modify,
    and perform computations with these objects.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we’ll continue our tour of object-oriented programming (OOP)
    by defining classes that represent geometric objects, including points, lines,
    rectangles, and circles. We’ll write methods that create and modify these objects,
    and we’ll use the `jupyturtle` module to draw them.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll use these classes to demonstrate OOP topics including object identity and
    equivalence, shallow and deep copying, and polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: '## 16.1\. Creating a Point[#](#creating-a-point "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: In computer graphics a location on the screen is often represented using a pair
    of coordinates in an `x`-`y` plane. By convention, the point `(0, 0)` usually
    represents the upper-left corner of the screen, and `(x, y)` represents the point
    `x` units to the right and `y` units down from the origin. Compared to the Cartesian
    coordinate system you might have seen in a math class, the `y` axis is upside-down.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways we might represent a point in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: We can store the coordinates separately in two variables, `x` and `y`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can store the coordinates as elements in a list or tuple.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can create a new type to represent points as objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In object-oriented programming, it would be most idiomatic to create a new type.
    To do that, we’ll start with a class definition for `Point`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `__init__` method takes the coordinates as parameters and assigns them to
    attributes `x` and `y`. The `__str__` method returns a string representation of
    the `Point`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can instantiate and display a `Point` object like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The following diagram shows the state of the new object.
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/6e851969c74483fc4efb36d87b6fcdd9ee1479e2274f2efebc840e7f3520ce6f.png](../Images/48dbb9e8e1d723217cd7f02dafdf41bb.png)'
  prefs: []
  type: TYPE_IMG
- en: As usual, a programmer-defined type is represented by a box with the name of
    the type outside and the attributes inside.
  prefs: []
  type: TYPE_NORMAL
- en: In general, programmer-defined types are mutable, so we can write a method like
    `translate` that takes two numbers, `dx` and `dy`, and adds them to the attributes
    `x` and `y`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This function translates the `Point` from one location in the plane to another.
    If we don’t want to modify an existing `Point`, we can use `copy` to copy the
    original object and then modify the copy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We can encapsulate those steps in another method called `translated`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the same way that the built in function `sort` modifies a list, and the `sorted`
    function creates a new list, now we have a `translate` method that modifies a
    `Point` and a `translated` method that creates a new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we’ll use these points to define and draw a line.
  prefs: []
  type: TYPE_NORMAL
- en: 16.2\. Creating a Line[#](#creating-a-line "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s define a class that represents the line segment between two points.
    As usual, we’ll start with an `__init__` method and a `__str__` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With those two methods, we can instantiate and display a `Line` object we’ll
    use to represent the `x` axis.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When we call `print` and pass `line` as a parameter, `print` invokes `__str__`
    on `line`. The `__str__` method uses an f-string to create a string representation
    of the `line`.
  prefs: []
  type: TYPE_NORMAL
- en: The f-string contains two expressions in curly braces, `self.p1` and `self.p2`.
    When those expressions are evaluated, the results are `Point` objects. Then, when
    they are converted to strings, the `__str__` method from the `Point` class gets
    invoked.
  prefs: []
  type: TYPE_NORMAL
- en: That’s why, when we display a `Line`, the result contains the string representations
    of the `Point` objects.
  prefs: []
  type: TYPE_NORMAL
- en: The following object diagram shows the state of this `Line` object.
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/4aaaffd556f4fee05dc8c25d40d9a66f559504d4c1b89fbe148c631e206580b0.png](../Images/0516eb6de9935e024c0b540a33ccc2f5.png)'
  prefs: []
  type: TYPE_IMG
- en: String representations and object diagrams are useful for debugging, but the
    point of this example is to generate graphics, not text! So we’ll use the `jupyturtle`
    module to draw lines on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did in [Chapter 4](chap04.html#section-turtle-module), we’ll use `make_turtle`
    to create a `Turtle` object and a small canvas where it can draw. To draw lines,
    we’ll use two new functions from the `jupyturtle` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jumpto`, which takes two coordinates and moves the `Turtle` to the given location
    without drawing a line, and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`moveto`, which moves the `Turtle` from its current location to the given location,
    and draws a line segment between them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here’s how we import them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: And here’s a method that draws a `Line`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To show how it’s used, I’ll create a second line that represents the `y` axis.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: And then draw the axes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As we define and draw more objects, we’ll use these lines again. But first let’s
    talk about object equivalence and identity.
  prefs: []
  type: TYPE_NORMAL
- en: 16.3\. Equivalence and identity[#](#equivalence-and-identity "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose we create two points with the same coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If we use the `==` operator to compare them, we get the default behavior for
    programmer-defined types – the result is `True` only if they are the same object,
    which they are not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If we want to change that behavior, we can provide a special method called `__eq__`
    that defines what it means for two `Point` objects to be equal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This definition considers two `Points` to be equal if their attributes are equal.
    Now when we use the `==` operator, it invokes the `__eq__` method, which indicates
    that `p1` and `p2` are considered equal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: But the `is` operator still indicates that they are different objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It’s not possible to override the `is` operator – it always checks whether the
    objects are identical. But for programmer-defined types, you can override the
    `==` operator so it checks whether the objects are equivalent. And you can define
    what equivalent means.
  prefs: []
  type: TYPE_NORMAL
- en: 16.4\. Creating a Rectangle[#](#creating-a-rectangle "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s define a class that represents and draws rectangles. To keep things
    simple, we’ll assume that the rectangles are either vertical or horizontal, not
    at an angle. What attributes do you think we should use to specify the location
    and size of a rectangle?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are at least two possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: You could specify the width and height of the rectangle and the location of
    one corner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You could specify two opposing corners.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point it’s hard to say whether either is better than the other, so let’s
    implement the first one. Here is the class definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As usual, the `__init__` method assigns the parameters to attributes and the
    `__str__` returns a string representation of the object. Now we can instantiate
    a `Rectangle` object, using a `Point` as the location of the upper-left corner.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The following diagram shows the state of this object.
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/93ab30dffba5edf8630e6bc3afd2c786600c5a1461f0695f96fd869a561a08c7.png](../Images/fcebfc419783d3fbf78fbf7d44c4e86e.png)'
  prefs: []
  type: TYPE_IMG
- en: To draw a rectangle, we’ll use the following method to make four `Point` objects
    to represent the corners.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Then we’ll make four `Line` objects to represent the sides.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Then we’ll draw the sides.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here’s an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The figure includes two lines to represent the axes.
  prefs: []
  type: TYPE_NORMAL
- en: 16.5\. Changing rectangles[#](#changing-rectangles "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s consider two methods that modify rectangles, `grow` and `translate`.
    We’ll see that `grow` works as expected, but `translate` has a subtle bug. See
    if you can figure it out before I explain.
  prefs: []
  type: TYPE_NORMAL
- en: '`grow` takes two numbers, `dwidth` and `dheight`, and adds them to the `width`
    and `height` attributes of the rectangle.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here’s an example that demonstrates the effect by making a copy of `box1` and
    invoking `grow` on the copy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If we draw `box1` and `box2`, we can confirm that `grow` works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s see about `translate`. It takes two numbers, `dx` and `dy`, and moves
    the rectangle the given distances in the `x` and `y` directions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: To demonstrate the effect, we’ll translate `box2` to the right and down.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s see what happens if we draw `box1` and `box2` again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It looks like both rectangles moved, which is not what we intended! The next
    section explains what went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 16.6\. Deep copy[#](#deep-copy "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we use `copy` to duplicate `box1`, it copies the `Rectangle` object but
    not the `Point` object it contains. So `box1` and `box2` are different objects,
    as intended.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: But their `corner` attributes refer to the same object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The following diagram shows the state of these objects.
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/351c7b94fa9021934acda94ae1dd3d5b3af81e1fc228a8aaee3ea80575486ff0.png](../Images/fa9acdcb0f0d6c848961d6dd6343293a.png)'
  prefs: []
  type: TYPE_IMG
- en: What `copy` does is called a **shallow copy** because it copies the object but
    not the objects it contains. As a result, changing the `width` or `height` of
    one `Rectangle` does not affect the other, but changing the attributes of the
    shared `Point` affects both! This behavior is confusing and error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the `copy` module provides another function, called `deepcopy`,
    that copies not only the object but also the objects it refers to, and the objects
    *they* refer to, and so on. This operation is called a **deep copy**.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate, let’s start with a new `Rectangle` that contains a new `Point`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: And we’ll make a deep copy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We can confirm that the two `Rectangle` objects refer to different `Point` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Because `box3` and `box4` are completely separate objects, we can modify one
    without affecting the other. To demonstrate, we’ll move `box3` and grow `box4`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: And we can confirm that the effect is as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 16.7\. Polymorphism[#](#polymorphism "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example, we invoked the `draw` method on two `Line` objects
    and two `Rectangle` objects. We can do the same thing more concisely by making
    a list of objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The elements of this list are different types, but they all provide a `draw`
    method, so we can loop through the list and invoke `draw` on each one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The first and second time through the loop, `shape` refers to a `Line` object,
    so when `draw` is invoked, the method that runs is the one defined in the `Line`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The third and fourth time through the loop, `shape` refers to a `Rectangle`
    object, so when `draw` is invoked, the method that runs is the one defined in
    the `Rectangle` class.
  prefs: []
  type: TYPE_NORMAL
- en: In a sense, each object knows how to draw itself. This feature is called **polymorphism**.
    The word comes from Greek roots that mean “many shaped”. In object-oriented programming,
    polymorphism is the ability of different types to provide the same methods, which
    makes it possible to perform many computations – like drawing shapes – by invoking
    the same method on different types of objects.
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise at the end of this chapter, you’ll define a new class that represents
    a circle and provides a `draw` method. Then you can use polymorphism to draw lines,
    rectangles, and circles.
  prefs: []
  type: TYPE_NORMAL
- en: 16.8\. Debugging[#](#debugging "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, we ran into a subtle bug that happened because we created
    a `Point` that was shared by two `Rectangle` objects, and then we modified the
    `Point`. In general, there are two ways to avoid problems like this: you can avoid
    sharing objects or you can avoid modifying them.'
  prefs: []
  type: TYPE_NORMAL
- en: To avoid sharing objects, you can use deep copy, as we did in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid modifying objects, consider replacing impure functions like `translate`
    with pure functions like `translated`. For example, here’s a version of `translated`
    that creates a new `Point` and never modifies its attributes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Python provides features that make it easier to avoid modifying objects. They
    are beyond the scope of this book, but if you are curious, ask a virtual assistant,
    “How do I make a Python object immutable?”
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new object takes more time than modifying an existing one, but the
    difference seldom matters in practice. Programs that avoid shared objects and
    impure functions are often easier to develop, test, and debug – and the best kind
    of debugging is the kind you don’t have to do.
  prefs: []
  type: TYPE_NORMAL
- en: 16.9\. Glossary[#](#glossary "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**shallow copy:** A copy operation that does not copy nested objects.'
  prefs: []
  type: TYPE_NORMAL
- en: '**deep copy:** A copy operation that also copies nested objects.'
  prefs: []
  type: TYPE_NORMAL
- en: '**polymorphism:** The ability of a method or operator to work with multiple
    types of objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 16.10\. Exercises[#](#exercises "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 16.10.1\. Ask a virtual assistant[#](#ask-a-virtual-assistant "Link to this
    heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For all of the following exercises, consider asking a virtual assistant for
    help. If you do, you’ll want include as part of the prompt the class definitions
    for `Point`, `Line`, and `Rectangle` – otherwise the VA will make a guess about
    their attributes and functions, and the code it generates won’t work.
  prefs: []
  type: TYPE_NORMAL
- en: 16.10.2\. Exercise[#](#exercise "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Write an `__eq__` method for the `Line` class that returns `True` if the `Line`
    objects refer to `Point` objects that are equivalent, in either order.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the following outline to get started.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: You can use these examples to test your code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This example should be `True` because the `Line` objects refer to `Point` objects
    that are equivalent, in the same order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Equivalence should always be transitive – that is, if `line_a` and `line_b`
    are equivalent, and `line_a` and `line_c` are equivalent, then `line_b` and `line_c`
    should also be equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This example should be `False` because the `Line` objects refer to `Point` objects
    that are not equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 16.10.3\. Exercise[#](#id1 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Write a `Line` method called `midpoint` that computes the midpoint of a line
    segment and returns the result as a `Point` object.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the following outline to get started.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: You can use the following examples to test your code and draw the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 16.10.4\. Exercise[#](#id2 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Write a `Rectangle` method called `midpoint` that find the point in the center
    of a rectangle and returns the result as a `Point` object.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the following outline to get started.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: You can use the following example to test your code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 16.10.5\. Exercise[#](#id3 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Write a `Rectangle` method called `make_cross` that:'
  prefs: []
  type: TYPE_NORMAL
- en: Uses `make_lines` to get a list of `Line` objects that represent the four sides
    of the rectangle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Computes the midpoints of the four lines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Makes and returns a list of two `Line` objects that represent lines connecting
    opposite midpoints, forming a cross through the middle of the rectangle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use this outline to get started.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: You can use the following example to test your code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 16.10.6\. Exercise[#](#id4 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Write a definition for a class named `Circle` with attributes `center` and `radius`,
    where `center` is a Point object and `radius` is a number. Include special methods
    `__init__` and a `__str__`, and a method called `draw` that uses `jupyturtle`
    functions to draw the circle.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the following function, which is a version of the `circle` function
    we wrote in Chapter 4.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: You can use the following example to test your code. We’ll start with a square
    `Rectangle` with width and height `100`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The following code should create a `Circle` that fits inside the square.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: If everything worked correctly, the following code should draw the circle inside
    the square (touching on all four sides).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[Think Python: 3rd Edition](https://allendowney.github.io/ThinkPython/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Copyright 2024 [Allen B. Downey](https://allendowney.com)
  prefs: []
  type: TYPE_NORMAL
- en: 'Code license: [MIT License](https://mit-license.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Text license: [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
  prefs: []
  type: TYPE_NORMAL
