<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. How to Evaluate Dask’s &#10;Components and Libraries"><div class="chapter" id="ch08">
<h1><span class="label">Chapter 8. </span>How to Evaluate Dask’s 
<span class="keep-together">Components and Libraries</span></h1>


<p>It’s hard, although possible, to build reliable systems out of unreliable components.<sup><a data-type="noteref" id="id712-marker" href="ch08.xhtml#id712">1</a></sup> Dask is a largely community-driven open source project, and its components evolve at different rates. Not all parts of Dask are equally mature; even the components we cover in this book have different levels of support and development. While Dask’s core parts are well maintained and tested, some parts lack the same level of maintenance.</p>

<p>Still, there are already dozens of popular libraries specifically for Dask, and the open source Dask community is growing around them. This gives us some confidence that many of these libraries are here to stay. <a data-type="xref" href="#libraries_used_with_dask_1687806941692">Table 8-1</a> shows a non-exhaustive list of foundational libraries in use and their relation to the core Dask project. It is meant as a road map for users and is not an endorsement of individual projects. Though we haven’t attempted to cover all the projects shown here, we offer evaluation of some individual projects <a data-type="indexterm" data-primary="libraries" id="lbrrs"/>throughout the book.</p>
<table id="libraries_used_with_dask_1687806941692" class="pagebreak-before less_space">
<caption><span class="label">Table 8-1. </span>Libraries frequently used with Dask</caption>
<thead>
<tr>
<th><strong>Category</strong></th>
<th><strong>Subcategory</strong></th>
<th><strong>Libraries</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Dask project</p></td>
<td/>
<td><div>
<ul>
<li>
<p>Dask</p>
</li>
<li>
<p>Distributed</p>
</li>
<li>
<p>dask-ml</p>
</li>
</ul></div></td>
</tr>
<tr>
<td rowspan="2"><p><strong>Data structures</strong>: Extend functionality, specific scientific data handling, or deployment hardware options of Dask built-in data structures</p></td>
<td><p>Functionalities and convenience</p></td>
<td><div>
<ul>
<li>
<p><em>xarray</em>: adds axis labels for Dask array</p>
</li>
<li>
<p><em>sparse</em>: an efficient implementation for sparse arrays and matrices, often found in ML and deep learning</p>
</li>
<li>
<p><em>pint</em>: scientific unit conversion</p>
</li>
<li>
<p><em>dask-geopandas</em>: parallelization of geopandas</p>
</li>
</ul></div></td>
</tr>
<tr>
<td><p>Hardware</p></td>
<td><div>
<ul>
<li>
<p><em>RAPIDS project</em>: NVIDIA-led effort to extend CUDA data structure for Dask</p>
</li>
<li>
<p><em>dask-cuda</em>:<sup><a data-type="noteref" id="libraries_table_foonote-marker" href="ch08.xhtml#libraries_table_foonote">a</a></sup> provides CUDA cluster, an extension of Dask’s cluster that better manages CUDA-enabled Dask workers</p>
</li>
<li>
<p><em>cuPY</em>:<sup><a class="tablefootnote" href="#libraries_table_foonote">a</a></sup> GPU-enabled arrays</p>
</li>
<li>
<p><em>cuDF</em>:<sup><a class="tablefootnote" href="#libraries_table_foonote">a</a></sup> CUDA DataFrame as partitions in Dask DataFrame</p>
</li>
</ul></div></td>
</tr>
<tr>
<td rowspan="4"><p><strong>Deployment</strong>: Extend deployment options for use with Dask distributed</p></td>
<td><p>Containers</p></td>
<td><div>
<ul>
<li>
<p><em>dask-kubernetes</em>:<sup><a class="tablefootnote" href="#libraries_table_foonote">a</a></sup> Dask on k8s</p>
</li>
<li>
<p><em>dask-helm</em>:<sup><a class="tablefootnote" href="#libraries_table_foonote">a</a></sup> alternate Dask on k8s and jupyterhub on k8s</p>
</li>
</ul></div></td>
</tr>
<tr>
<td><p>Cloud</p></td>
<td><div>
<ul>
<li>
<p><em>dask-cloudprovider</em>: commodity cloud APIs</p>
</li>
<li>
<p><em>dask-gateway</em></p>
</li>
<li>
<p><em>Dask-Yarn</em>:<sup><a class="tablefootnote" href="#libraries_table_foonote">a</a></sup> for YARN/Hadoop</p>
</li>
</ul></div></td>
</tr>
<tr>
<td><p>GPU</p></td>
<td><div>
<ul>
<li>
<p><em>dask-cuda</em>: Dask cluster optimized for GPUs</p>
</li>
</ul></div></td>
</tr>
<tr>
<td><p>HPC</p></td>
<td><div>
<ul>
<li>
<p><em>Dask-jobqueue</em>:<sup><a class="tablefootnote" href="#libraries_table_foonote">a</a></sup> deployment for PBS, Slurm, MOAB, SGE, LSF, and HTCondor</p>
</li>
<li>
<p><em>dask-mpi</em>:<sup><a class="tablefootnote" href="#libraries_table_foonote">a</a></sup> deployment for MPI</p>
</li>
</ul></div></td>
</tr>
<tr>
<td><p><strong>ML and analytics</strong>: Extend ML libraries and computation with Dask</p></td>
<td/>
<td><div>
<ul>
<li>
<p><em>dask-ml</em>:<sup><a class="tablefootnote" href="#libraries_table_foonote">a</a></sup> Distributed implementation of scikit-learn and more</p>
</li>
<li>
<p><em>xgboost</em>:<sup><a class="tablefootnote" href="#libraries_table_foonote">a</a></sup> gradient boosting with native Dask support</p>
</li>
<li>
<p><em>light-gbm</em>:<sup><a class="tablefootnote" href="#libraries_table_foonote">a</a></sup> another tree-based learning algorithm with native Dask support</p>
</li>
<li>
<p><em>Dask-SQL</em>:<sup><a class="tablefootnote" href="#libraries_table_foonote">a</a></sup> CPU-based SQL engine for Dask (ETL/compute logic can be run on SQL context; similar to SparkSQL)</p>
</li>
<li>
<p><em>BlazingSQL</em>:<sup><a class="tablefootnote" href="#libraries_table_foonote">a</a></sup> SQL query on cuDF and Dask</p>
</li>
<li>
<p><em>FugueSQL</em>:<sup><a class="tablefootnote" href="#libraries_table_foonote">a</a></sup> portability between pandas, Dask, and Spark, using the same SQL code (downside: requires ANTLR, a JVM-based tool)</p>
</li>
<li>
<p><em>Dask-on-Ray</em>:<sup><a class="tablefootnote" href="#libraries_table_foonote">a</a></sup> Dask’s distributed data structures and task graphs, run on Ray scheduler</p>
</li>
</ul></div></td>
</tr>
</tbody>
<tbody><tr class="footnotes"><td colspan="3"><p data-type="footnote" id="libraries_table_foonote"><sup><a href="ch08.xhtml#libraries_table_foonote-marker">a</a></sup> Covered in this book.</p></td></tr></tbody></table>

<p>It’s essential to understand the state of the <a data-type="indexterm" data-primary="libraries" data-startref="lbrrs" id="id713"/>components that you are considering using. If you need to use a less maintained or developed part of Dask, <a href="https://oreil.ly/IDXVs">defensive programming</a>, including thorough code testing, will become even more critical. Working on less-established parts of the Dask ecosystem can also be an exciting opportunity to become more involved and contribute fixes or documentation.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>This is not to say that closed source software does not suffer from the same challenges (e.g., untested components), but we are in a better place to evaluate and make informed choices with open source software.</p>
</div>

<p>Of course, not all of our projects need to be maintainable, but as the saying goes, “Nothing is more permanent than a temporary fix.” If something is truly a one-time-use project, you can likely skip most of the analysis here and try out the libraries to see if they work for you.</p>

<p>Dask is under rapid development, and any static table of which components are production-ready would be out of date by the time it was read. So instead of sharing our views on which components of Dask are currently well developed, this chapter aims to give you the tools to evaluate the libraries you may be considering. In this chapter, we separate metrics that you can measure concretely from the fuzzier qualitative metrics. Perhaps counterintuitively, we believe that the “fuzzier” qualitative metrics are a better framework for evaluating components and projects.</p>

<p>Along the way, we’ll look at some projects and how they are measured, but please keep in mind that these specific observations may be out of date by the time you read this, and you should do your own evaluation with the tools provided here.</p>
<div data-type="tip"><h6>Tip</h6>
<p>While we focus on the Dask ecosystem in this chapter, you can apply most of these techniques throughout software tool selection.</p>
</div>






<section data-type="sect1" data-pdf-bookmark="Qualitative Considerations for Project Evaluation"><div class="sect1" id="id267">
<h1>Qualitative Considerations for Project Evaluation</h1>

<p>We start by focusing on qualitative tools since we believe these tools are the best for determining the suitability of a particular library for your project.</p>








<section data-type="sect2" data-pdf-bookmark="Project Priorities"><div class="sect2" id="id207">
<h2>Project Priorities</h2>

<p>Some projects prioritize <a data-type="indexterm" data-primary="libraries" data-secondary="evaluating" data-tertiary="project priorities" id="lbvljp"/><a data-type="indexterm" data-primary="projects" data-secondary="library evaluation" data-tertiary="priorities" id="pjpbyv"/>benchmarks or performance numbers, while other projects can prioritize correctness and clarity, and still others may prioritize completeness. A project’s README or home page is often a good sign of what the project prioritizes. Early in its creation, Apache Spark’s home page focused on performance with benchmarks, whereas now it shows an ecosystem of tools leading more toward completeness. The Dask Kubernetes GitHub README shows a collection of badges indicating the state of the code and not much else, revealing a strong developer focus.</p>

<p>While there are many arguments for and against focusing on benchmarks, correctness should almost never be sacrificed.<sup><a data-type="noteref" id="id714-marker" href="ch08.xhtml#id714">2</a></sup> This does not mean that libraries will never have bugs; rather, projects should take reports of correctness issues seriously and treat them with higher priority than others. An excellent way to see whether a project values correctness is to look for reports of correctness and observe how the core developers respond.</p>

<p>Many Dask ecosystem projects use GitHub’s built-in issue tracker, but if you don’t see any activity, check the README and developer guides to see if the project uses a different issue tracker. For example, many ASF projects use JIRA. Looking into how folks respond to issues gives you a good idea of what issues they consider important. You don’t need to look at all of them, but a small sample of 10 will often give you a good <a data-type="indexterm" data-primary="libraries" data-secondary="evaluating" data-tertiary="project priorities" data-startref="lbvljp" id="id715"/><a data-type="indexterm" data-primary="projects" data-secondary="library evaluation" data-tertiary="priorities" data-startref="pjpbyv" id="id716"/>idea (look at open and not fixed issues as well as closed and fixed ones).</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Community"><div class="sect2" id="id66">
<h2>Community</h2>

<p>As one of the <a data-type="indexterm" data-primary="libraries" data-secondary="evaluating" data-tertiary="community" id="lbvlcm"/><a data-type="indexterm" data-primary="community, library evaluation and" id="cmmbyv"/><a data-type="indexterm" data-primary="community over code" id="id717"/><a data-type="indexterm" data-primary="projects" data-secondary="library evaluation" data-tertiary="community" id="pjlyvcy"/>unofficial ASF sayings goes, “Community over code.”<sup><a data-type="noteref" id="id718-marker" href="ch08.xhtml#id718">3</a></sup> The <a href="https://oreil.ly/CcJZ1">Apache Way website</a> describes this as meaning “the most successful long-lived projects value a broad and collaborative community over the details of the code itself.” This saying matches our experience, in which we’ve found that technical improvements are easier to copy from other projects, but the community is much harder to move. Measuring community is challenging, and it can be tempting to look at the number of developers or users, but we think it’s essential to go beyond that.</p>

<p>Finding the community associated with a particular project can be tricky. Take your time to look around at issue trackers, source code, forums (like Discourse), and mailing lists. For example, Dask’s <a href="https://oreil.ly/hSVE0">Discourse group</a> is highly active. Some projects use IRC, Slack, or Discord, or their “interactive” communication—and in our opinion, some of the best projects put in the effort to make the conversations from these communication channels appear in search indexes. Sometimes parts of the community may exist on external social media sites, and these pose a unique set of challenges to community standards.</p>

<p>There are multiple types of communities for open source software projects. The user community is the people who are using the software to build things. The developer community is the group working on improving the library. Some projects have large intersections between these communities, but often the user community is much larger than the developer community. We are biased toward evaluating the developer community, but it’s important to ensure both are healthy. Software projects without enough developers will move slowly, and projects without users are frequently challenging to use by anyone except the developers.</p>

<p>In many situations, a large community with enough jerks (or a lead jerk) can be a much less enjoyable environment than a small community of nice folks. You are less likely to be productive if you are not enjoying your work. Sadly, figuring out if someone is a jerk or if a community has jerks in it is a complex problem. If people are generally rude on the mailing list or in the issue tracker, this can be a sign that the community is not as welcoming to new members.<sup><a data-type="noteref" id="id719-marker" href="ch08.xhtml#id719">4</a></sup></p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Some projects, including one of Holden’s projects, have attempted to quantify some of these metrics using <a href="https://oreil.ly/ZLJ63">sentiment analysis combined with random sampling</a>, but this is a time-consuming process you can probably skip in most cases.</p>
</div>

<p>Even with the nicest people, it can matter which institutions the contributors are associated with. If, for example, the top contributors are all grad students in the same research lab or work at the same company, the risk that the software is abandoned increases. This is not to say that single-company or even single-person open source projects are bad,<sup><a data-type="noteref" id="id720-marker" href="ch08.xhtml#id720">5</a></sup> but you should adjust your expectations to match.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you are concerned a project does not meet your current level of maturity and you have a budget, this can be an excellent opportunity to support critical open source projects. Reach out to maintainers and see what they need; sometimes, it’s as simple as writing them a check for new hardware or hiring them to provide training for your company.</p>
</div>

<p class="pagebreak-after">Beyond whether people are nice in a community, it can be a positive sign if folks are using the project similarly to how you are considering using it. If, for example, you are the first person to apply Dask DataFrames to a new domain, even though Dask DataFrames themselves are very mature, you are more likely to find missing components than if other folks in the <a data-type="indexterm" data-primary="libraries" data-secondary="evaluating" data-tertiary="community" data-startref="lbvlcm" id="id721"/><a data-type="indexterm" data-primary="community, library evaluation and" data-startref="cmmbyv" id="id722"/><a data-type="indexterm" data-primary="projects" data-secondary="library evaluation" data-tertiary="community" data-startref="pjlyvcy" id="id723"/>same area of application are already using Dask.</p>
</div></section>








<section data-type="sect2" class="less_space" data-pdf-bookmark="Dask-Specific Best Practices"><div class="sect2" id="id174">
<h2>Dask-Specific Best Practices</h2>

<p>When it comes to Dask libraries, there <a data-type="indexterm" data-primary="libraries" data-secondary="evaluating" data-tertiary="best practices" id="id724"/><a data-type="indexterm" data-primary="projects" data-secondary="library evaluation" data-tertiary="best practices" id="id725"/><a data-type="indexterm" data-primary="best practices" data-secondary="library evaluation and" id="id726"/>are a number of Dask-specific best practices to look for. In general, libraries should not have too much work on the client node, and as much work as possible should be delegated to the workers. Sometimes the documentation will gloss over which parts happen where, and the fastest way to tell in our experience is to simply run the example code and look to see which tasks are getting scheduled on the workers. Relatedly, libraries should bring back only the smallest bits of data when possible. These best practices are slightly different from those for when you are writing your own Dask code, since you can know what your data size is beforehand and determine when local compute is the best path forward.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Up-to-Date Dependencies"><div class="sect2" id="id175">
<h2>Up-to-Date Dependencies</h2>

<p>If a project pins a dependency at a <a data-type="indexterm" data-primary="libraries" data-secondary="evaluating" data-tertiary="up-to-date dependencies" id="id727"/><a data-type="indexterm" data-primary="projects" data-secondary="library evaluation" data-tertiary="up-to-date dependencies" id="id728"/><a data-type="indexterm" data-primary="dependencies" data-secondary="library evaluation and" id="id729"/>specific version, it is important that the version pinned does not have conflicts with the other packages you want to use and, even more importantly, does not have pinned insecure dependencies. What constitutes “up to date” is a matter of opinion. If you are the kind of developer who likes using the latest version of everything, you’ll probably be happiest with libraries that 
<span class="keep-together">(mostly) provide minimum</span> but not maximum versions. However, this can be mis­leading as, especially in the Python ecosystem, many libraries do not use <a href="https://oreil.ly/RVVI7">semantic ver­sioning</a>—including Dask, which <a href="https://oreil.ly/fTTXZ">uses CalVer</a>—and just because a project does not exclude a new version does not mean it will actually work with it.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Some folks would call this quantitative, but in a CalVer-focused ecosystem, we believe this is more qualitative.</p>
</div>

<p>A good check, when considering adding a new library to an existing environment, is to try to run the new libraries test suite in the virtual environment that you plan to use it in (or in an equivalently configured one).</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Documentation"><div class="sect2" id="id67">
<h2>Documentation</h2>

<p>While not every tool needs a book (although <a data-type="indexterm" data-primary="libraries" data-secondary="evaluating" data-tertiary="documentation" id="id730"/><a data-type="indexterm" data-primary="projects" data-secondary="library evaluation" data-tertiary="documentation" id="id731"/><a data-type="indexterm" data-primary="documentation, library evaluation and" id="id732"/>we do hope you find books useful), very few libraries are truly self-explanatory. On the low end, for simple libraries, a few examples or well-written tests can serve as a stand-in for proper documentation. Complete documentation is a good sign of overall project maturity. Not all documentation is created equal, and as the saying goes, documentation is normally out of date as soon as it is finished (if not before). A good exercise to do, before you dive all the way into a new library, is to open up the documentation and try to run the examples. If the getting-started examples don’t work (and you can’t figure out how to fix them), you will likely be in for a rough ride.</p>

<p>Sometimes good documentation exists but is separate from the project (e.g., in books), and some research may be required. If you find a project has good but not self-evident documentation, consider trying to improve the visibility of the 
<span class="keep-together">documentation.</span></p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Openness to Contributions"><div class="sect2" id="id68">
<h2>Openness to Contributions</h2>

<p>If you find the library is promising but not <a data-type="indexterm" data-primary="libraries" data-secondary="evaluating" data-tertiary="contributions, openness to" id="id733"/><a data-type="indexterm" data-primary="projects" data-secondary="library evaluation" data-tertiary="contributions, openness to" id="id734"/><a data-type="indexterm" data-primary="contributions, library evaluation and" id="id735"/>all the way there, it’s important to be able to contribute your improvements back to the library. This is good for the community, and besides, if you can’t upstream your improvements, upgrading to new versions will be more challenging.<sup><a data-type="noteref" id="id736-marker" href="ch08.xhtml#id736">6</a></sup> Many projects nowadays have contribution guides that can give you an idea of how they like to work, but nothing beats a real test contribution. A great place to start with a project is fixing its documentation with the eyes of a newcomer, especially those getting-started examples from the previous section. Documentation often becomes out of sync in fast-moving projects, and if you find it difficult to get your documentation changes accepted, that is a strong indicator of how challenging it will be to contribute more complicated improvements later.</p>

<p>Something to pay attention to is what the issue-reporting experience is like. Since almost no software is completely free of bugs, you may encounter an issue. Whether you have the energy or skills to fix the bug, sharing your experience is vital so it can be fixed. Sharing the bug can help the next person encountering the same challenge feel not alone, even if the issue is unresolved.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Pay attention to your experience when trying to report an issue. Most large projects with active communities will have some guidance to help you submit your issue and ensure it’s not duplicating a previous issue. If that guidance is lacking (or if the project has a smaller community associated with it), reporting an issue could be more challenging.</p>
</div>

<p>If you don’t have time to make your own test contribution, you can always take a look at a project’s pull requests (or equivalent) and see if the responses seem positive or antagonistic.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Extensibility"><div class="sect2" id="id69">
<h2>Extensibility</h2>

<p>Not all changes to libraries necessarily <a data-type="indexterm" data-primary="libraries" data-secondary="evaluating" data-tertiary="extensibility" id="id737"/><a data-type="indexterm" data-primary="projects" data-secondary="library evaluation" data-tertiary="extensibility" id="id738"/><a data-type="indexterm" data-primary="extensibility, library evaluation and" id="id739"/>need to be able to go upstream. If a library is appropriately structured, you can add additional functionality without changing the underlying code. Part of what makes Dask so powerful is its extensibility. For example, adding user-defined functions and aggregations allows Dask to be usable by many.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Quantitative Metrics for Open Source Project Evaluation"><div class="sect1" id="id70">
<h1>Quantitative Metrics for Open Source Project Evaluation</h1>

<p>As software developers and <a data-type="indexterm" data-primary="projects" data-secondary="open source" data-tertiary="evaluating" id="pjpsvl"/><a data-type="indexterm" data-primary="open source projects, evaluating" id="id740"/>data scientists, we often try to use quantitative metrics to make our decisions. Quantitative metrics for software, in both open source and closed source, is an area of active research, so we won’t be able to cover all of the quantitative metrics. A large challenge with all of the quantitative metrics for open source projects is that, especially once money gets involved, the metrics can be influenced. We instead recommend focusing on qualitative factors, which, while more difficult to measure, are also more difficult to game.</p>

<p>Here we cover a few common metrics that folks commonly attempt to use, and there are many other frameworks for evaluating open source projects for use, including the <a href="https://oreil.ly/4lvK6">OSSM</a>, <a href="https://oreil.ly/Pcioq">OpenSSF Security Metrics</a>, and <a href="https://oreil.ly/6mmHu">many more</a>. Some of these frameworks ostensibly produce automated scores (like the OpenSSF), but in our experience, not only are the metrics collected gameable, they are often collected incorrectly.<sup><a data-type="noteref" id="id741-marker" href="ch08.xhtml#id741">7</a></sup></p>








<section data-type="sect2" data-pdf-bookmark="Release History"><div class="sect2" id="id176">
<h2>Release History</h2>

<p>Frequent releases can be a <a data-type="indexterm" data-primary="open source projects, evaluating" data-secondary="release history" id="id742"/>sign of a healthy library. If a project has not been released for a long time, you are more likely to run into conflicts with other libraries. For libraries built on top of tools like Dask, one detail to check is how many months (or days) it takes for a new version of the library to be released on top of the latest version of Dask. Some libraries do not do traditional releases, but rather suggest installing directly from the source repo. This is often a sign of a project earlier in the development phase, which can be more challenging to take on as a dependency.<sup><a data-type="noteref" id="id743-marker" href="ch08.xhtml#id743">8</a></sup></p>

<p class="pagebreak-before">Release history is one of the easiest metrics to game, as all it requires is the developers making a release. Some development styles will automatically create releases after every successful check-in, which in our opinion is an anti-pattern,<sup><a data-type="noteref" id="id744-marker" href="ch08.xhtml#id744">9</a></sup> as you often want some additional level of human testing or checking before a full release.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Commit Frequency (and Volume)"><div class="sect2" id="id177">
<h2>Commit Frequency (and Volume)</h2>

<p>Another popular metric people <a data-type="indexterm" data-primary="open source projects, evaluating" data-secondary="commit frequency" id="id745"/>consider is commit frequency or volume. This metric is far from perfect, as the frequency and volume can vary widely depending on coding styles, which lack correlation with software quality. For example, developers who tend to squash commits can have lower commit volume, whereas developers who use rebases primarily will have a higher volume of commits.</p>

<p>On the flip side, the complete lack of recent commits can be a sign that a project has become abandoned, and if you decide to use it, you will end up having to maintain a fork.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Library Usage"><div class="sect2" id="id178">
<h2>Library Usage</h2>

<p>One of the simplest metrics <a data-type="indexterm" data-primary="open source projects, evaluating" data-secondary="library usage" id="opspjvb"/>to check is if people are using a package, which you can see by looking at the installs. You can check PyPI package install stats on the <a href="https://oreil.ly/1HHL8">PyPI Stats website</a> (see <a data-type="xref" href="#dask-kubernetes-install-stats">Figure 8-1</a>) or on <a href="https://oreil.ly/83RIO">Google’s BigQuery</a>, and conda installs using the 
<span class="kturl"><a href="https://oreil.ly/4STsP">condastats library</a></span>.</p>

<p>Unfortunately, installation counts are a noisy metric, as PyPI downloads can come from anything from CI pipelines to even someone spinning up a new cluster with the library installed but never used. Not only is this metric unintentionally noisy, but the same techniques can also be used to increase the numbers artificially.</p>

<p>Instead of depending heavily on the number of package installs, we like to see if we can find examples of people using the libraries—such as by searching for imports on GitHub or <a href="https://oreil.ly/FrPTE">Sourcegraph</a>. For example, we can try to get an approximate number of people using Streamz or cuDF with Dask by searching <a href="https://oreil.ly/gQWZY"><code>(file:requirements.txt OR file:setup.py) cudf AND dask</code></a> and <a href="https://oreil.ly/tYIJu"><code>(file:requirements.txt OR file:setup.py) streamz AND dask</code></a> with Sourcegraph, which yields 72 and 33, respectively. This captures only a few, but when we compare this to the same query for Dask (which yields 500+), it suggests that Streamz has lower usage than cuDF in the Dask ecosystem.</p>

<figure><div id="dask-kubernetes-install-stats" class="figure">
<img src="Images/spwd_0801.png" alt="spwd 0801" width="1219" height="708"/>
<h6><span class="label">Figure 8-1. </span>Dask Kubernetes install stats from PyPI Stats</h6>
</div></figure>

<p>Looking for examples of people using a library has its limitations, especially with data processing. Since data and machine learning pipelines are not as frequently open sourced, finding examples can be harder for libraries used for those purposes.</p>

<p>Another proxy for usage you can look at is the frequency of issues or mailing list posts. If a project is hosted on something like GitHub, stars can also be an interesting way of measuring usage—but since people can now buy GitHub stars just like Instagram likes (as shown in <a data-type="xref" href="#fig_ghstarsforsale">Figure 8-2</a>), you shouldn’t weigh this metric too heavily.<sup><a data-type="noteref" id="id746-marker" href="ch08.xhtml#id746">10</a></sup></p>

<p>Even setting aside people purchasing stars, what constitutes a project worth starring varies from person to person. Some <a data-type="indexterm" data-primary="open source projects, evaluating" data-secondary="library usage" data-startref="opspjvb" id="id747"/>projects will, while not purchasing stars, ask many individuals to star their projects, which can quickly inflate this metric.<sup><a data-type="noteref" id="id748-marker" href="ch08.xhtml#id748">11</a></sup></p>

<figure><div id="fig_ghstarsforsale" class="figure">
<img src="Images/spwd_0802.png" alt="spwd 0802" width="767" height="502"/>
<h6><span class="label">Figure 8-2. </span>Someone selling GitHub stars</h6>
</div></figure>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Code and Best Practices"><div class="sect2" id="id71">
<h2>Code and Best Practices</h2>

<p class="pagebreak-after">Software testing is second nature to <a data-type="indexterm" data-primary="open source projects, evaluating" data-secondary="code practices" id="opspjcp"/><a data-type="indexterm" data-primary="open source projects, evaluating" data-secondary="best practices" id="opspjbp"/>many software engineers, but sometimes projects are created hastily without tests. If a project does not have tests, and tests that are mostly passing, then it’s much harder to have confidence in how the project will behave. Even in the most professional of projects, corners sometimes get cut when it comes to testing, and adding more tests to a project can be a great way to ensure that it continues to function in the ways you need it to. A good question is if the tests cover the parts that are important to you. If a project does have relevant tests, the next natural question is if they are being used. If it’s too difficult to run tests, human nature often takes over, and the tests may not be run. So a good step is to see if you can run the tests in the project.</p>
<div data-type="note" epub:type="note" class="less_space"><h6>Note</h6>
<p>Test coverage numbers can be especially informative, but unfortunately, for projects built on top of systems like Dask,<sup><a data-type="noteref" id="id749-marker" href="ch08.xhtml#id749">12</a></sup> getting accurate test coverage information is a challenge. Instead, a more qualitative approach is often needed here. In single-machine systems, test coverage can be an excellent automatically computed quantitative metric.</p>
</div>

<p>We believe that most good libraries will have some form of continuous integration (CI) or <a data-type="indexterm" data-primary="libraries" data-secondary="CI (continuous integration)" id="id750"/><a data-type="indexterm" data-primary="libraries" data-secondary="automated testing" id="id751"/>automated testing, including proposed changes (or when a pull request is created). You can check if a GitHub project has continuous integration by looking at the pull-requests tab. CI can be very helpful for reducing bugs overall, especially regressions.<sup><a data-type="noteref" id="id752-marker" href="ch08.xhtml#id752">13</a></sup> Historically, use of CI was somewhat a matter of project preference, but with the creation of free tools, including GitHub actions, many multi-person software projects now have some form of CI. This is a common software engineering practice, and we consider it essential for libraries that we depend on.</p>

<p>Static typing is frequently <a data-type="indexterm" data-primary="static typing" id="id753"/>considered a programming best practice, though there are some detractors. While the arguments for and against static types inside data pipelines are complex, we believe <em>some</em> typing at the <a data-type="indexterm" data-primary="projects" data-secondary="open source" data-tertiary="evaluating" data-startref="pjpsvl" id="id754"/><a data-type="indexterm" data-primary="open source projects, evaluating" data-secondary="code practices" data-startref="opspjcp" id="id755"/><a data-type="indexterm" data-primary="open source projects, evaluating" data-secondary="best practices" data-startref="opspjbp" id="id756"/>library level is something one should expect.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="id268">
<h1>Conclusion</h1>

<p>When building data (or other) applications on Dask, you will likely need many different tools from the ecosystem. The ecosystem evolves at different rates, with some parts requiring more investment by you before you can use them effectively. Choosing the right tools, and transitively the right people, is key to whether your project will succeed and, in our experience, to how enjoyable your work will be. It’s important to remember that these decisions are not set in stone, but changing a library tends to get harder the longer you’ve been using it in your project. In this chapter, you’ve learned how to evaluate the different components of the ecosystem for project maturity. You can use this knowledge to decide when to use a library versus writing the functionality you need yourself.</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="id712"><sup><a href="ch08.xhtml#id712-marker">1</a></sup> Although, in many ways, distributed systems have evolved to overcome their unreliable components. For example, fault tolerance is something a single machine cannot achieve but distributed systems can accomplish with replication.</p><p data-type="footnote" id="id714"><sup><a href="ch08.xhtml#id714-marker">2</a></sup> Sacrificing correctness means producing incorrect results. An example correctness issue is <code>set_index</code> in Dask-on-Ray causing rows to disappear; this issue took about a month to fix, which in our opinion is quite reasonable <a href="https://oreil.ly/P1L1W">given the challenges in reproducing it</a>. Sometimes correctness fixes, like security fixes, can result in slower processing; for example, MongoDB’s defaults are very fast but can lose data.</p><p data-type="footnote" id="id718"><sup><a href="ch08.xhtml#id718-marker">3</a></sup> We are uncertain of exactly whom or where this quote originates from; it’s appeared in the ASF director’s position statement as well as in the Apache Way documentation.</p><p data-type="footnote" id="id719"><sup><a href="ch08.xhtml#id719-marker">4</a></sup> The Linux kernel is a classic example of a somewhat <a href="https://oreil.ly/tXjhn">more challenging community</a>.</p><p data-type="footnote" id="id720"><sup><a href="ch08.xhtml#id720-marker">5</a></sup> One example of a small community developing a very popular and successful project is homebrew.</p><p data-type="footnote" id="id736"><sup><a href="ch08.xhtml#id736-marker">6</a></sup> Changes from upstream open source that you are unable to contribute back mean that you need to reapply those changes every time you upgrade. While modern tools like Git simplify the mechanics of this a little bit, it can be a time-consuming process.</p><p data-type="footnote" id="id741"><sup><a href="ch08.xhtml#id741-marker">7</a></sup> For example, the OpenSSF reports that Apache Spark has unsigned releases, but all of the releases are signed. Projects that are highly critical (like log4j) incorrectly have low criticality scores, illustrating some of the limits of these metrics.</p><p data-type="footnote" id="id743"><sup><a href="ch08.xhtml#id743-marker">8</a></sup> In these cases it’s good to pick a tag or a commit to install from so you don’t end up with mismatched versions.</p><p data-type="footnote" id="id744"><sup><a href="ch08.xhtml#id744-marker">9</a></sup> Snapshot artifacts are OK.</p><p data-type="footnote" id="id746"><sup><a href="ch08.xhtml#id746-marker">10</a></sup> There are some tools that can help you dig deeper into the star data, including <a href="https://oreil.ly/eKBdi">ghrr</a>, but we still think it’s better to not spend too much time on or give too much weight to stars.</p><p data-type="footnote" id="id748"><sup><a href="ch08.xhtml#id748-marker">11</a></sup> For example, we might ask you to star our <a href="https://oreil.ly/u6S0H">example repo</a>, and by doing this, we (hopefully) increase the number of stars without actually needing to increase our quality.</p><p data-type="footnote" id="id749"><sup><a href="ch08.xhtml#id749-marker">12</a></sup> This is because most of the Python tools that check code coverage assume that there is only one Python VM they need to attach to and see what parts of code are executed. However, in a distributed system, this is no longer the case, and many of these automated tools do not work.</p><p data-type="footnote" id="id752"><sup><a href="ch08.xhtml#id752-marker">13</a></sup> Where something that used to work stops working in a newer release.</p></div></div></section></div></body></html>