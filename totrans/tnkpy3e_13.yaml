- en: 11\. Tuples#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://allendowney.github.io/ThinkPython/chap11.html](https://allendowney.github.io/ThinkPython/chap11.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This chapter introduces one more built-in type, the tuple, and then shows how
    lists, dictionaries, and tuples work together. It also presents tuple assignment
    and a useful feature for functions with variable-length argument lists: the packing
    and unpacking operators.'
  prefs: []
  type: TYPE_NORMAL
- en: In the exercises, we’ll use tuples, along with lists and dictionaries, to solve
    more word puzzles and implement efficient algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'One note: There are two ways to pronounce “tuple”. Some people say “tuh-ple”,
    which rhymes with “supple”. But in the context of programming, most people say
    “too-ple”, which rhymes with “quadruple”.'
  prefs: []
  type: TYPE_NORMAL
- en: 11.1\. Tuples are like lists[#](#tuples-are-like-lists "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A tuple is a sequence of values. The values can be any type, and they are indexed
    by integers, so tuples are a lot like lists. The important difference is that
    tuples are immutable.
  prefs: []
  type: TYPE_NORMAL
- en: To create a tuple, you can write a comma-separated list of values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Although it is not necessary, it is common to enclose tuples in parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To create a tuple with a single element, you have to include a final comma.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: A single value in parentheses is not a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Another way to create a tuple is the built-in function `tuple`. With no argument,
    it creates an empty tuple.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If the argument is a sequence (string, list or tuple), the result is a tuple
    with the elements of the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Because `tuple` is the name of a built-in function, you should avoid using it
    as a variable name.
  prefs: []
  type: TYPE_NORMAL
- en: Most list operators also work with tuples. For example, the bracket operator
    indexes an element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: And the slice operator selects a range of elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `+` operator concatenates tuples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: And the `*` operator duplicates a tuple a given number of times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `sorted` function works with tuples – but the result is a list, not a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `reversed` function also works with tuples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The result is a `reversed` object, which we can convert to a list or tuple.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Based on the examples so far, it might seem like tuples are the same as lists.
  prefs: []
  type: TYPE_NORMAL
- en: 11.2\. But tuples are immutable[#](#but-tuples-are-immutable "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you try to modify a tuple with the bracket operator, you get a `TypeError`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: And tuples don’t have any of the methods that modify lists, like `append` and
    `remove`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Recall that an “attribute” is a variable or method associated with an object
    – this error message means that tuples don’t have a method named `remove`.
  prefs: []
  type: TYPE_NORMAL
- en: Because tuples are immutable, they are hashable, which means they can be used
    as keys in a dictionary. For example, the following dictionary contains two tuples
    as keys that map to integers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can look up a tuple in a dictionary like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Or if we have a variable that refers to a tuple, we can use it as a key.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Tuples can also appear as values in a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 11.3\. Tuple assignment[#](#tuple-assignment "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can put a tuple of variables on the left side of an assignment, and a tuple
    of values on the right.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The values are assigned to the variables from left to right – in this example,
    `a` gets the value `1` and `b` gets the value `2`. We can display the results
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'More generally, if the left side of an assignment is a tuple, the right side
    can be any kind of sequence – string, list or tuple. For example, to split an
    email address into a user name and a domain, you could write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The return value from `split` is a list with two elements – the first element
    is assigned to `username`, the second to `domain`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The number of variables on the left and the number of values on the right have
    to be the same – otherwise you get a `ValueError`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Tuple assignment is useful if you want to swap the values of two variables.
    With conventional assignments, you have to use a temporary variable, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: That works, but with tuple assignment we can do the same thing without a temporary
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This works because all of the expressions on the right side are evaluated before
    any of the assignments.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use tuple assignment in a `for` statement. For example, to loop
    through the items in a dictionary, we can use the `items` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Each time through the loop, `item` is assigned a tuple that contains a key and
    the corresponding value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write this loop more concisely, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Each time through the loop, a key and the corresponding value are assigned directly
    to `key` and `value`.
  prefs: []
  type: TYPE_NORMAL
- en: 11.4\. Tuples as return values[#](#tuples-as-return-values "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Strictly speaking, a function can only return one value, but if the value is
    a tuple, the effect is the same as returning multiple values. For example, if
    you want to divide two integers and compute the quotient and remainder, it is
    inefficient to compute `x//y` and then `x%y`. It is better to compute them both
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: The built-in function `divmod` takes two arguments and returns a tuple of two
    values, the quotient and remainder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We can use tuple assignment to store the elements of the tuple in two variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Here is an example of a function that returns a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '`max` and `min` are built-in functions that find the largest and smallest elements
    of a sequence. `min_max` computes both and returns a tuple of two values.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We can assign the results to variables like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '## 11.5\. Argument packing[#](#argument-packing "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: Functions can take a variable number of arguments. A parameter name that begins
    with the `*` operator **packs** arguments into a tuple. For example, the following
    function takes any number of arguments and computes their arithmetic mean – that
    is, their sum divided by the number of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameter can have any name you like, but `args` is conventional. We can
    call the function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: If you have a sequence of values and you want to pass them to a function as
    multiple arguments, you can use the `*` operator to **unpack** the tuple. For
    example, `divmod` takes exactly two arguments – if you pass a tuple as a parameter,
    you get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Even though the tuple contains two elements, it counts as a single argument.
    But if you unpack the tuple, it is treated as two arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Packing and unpacking can be useful if you want to adapt the behavior of an
    existing function. For example, this function takes any number of arguments, removes
    the lowest and highest, and computes the mean of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: First it uses `min_max` to find the lowest and highest elements. Then it converts
    `args` to a list so it can use the `remove` method. Finally it unpacks the list
    so the elements are passed to `mean` as separate arguments, rather than as a single
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example that shows the effect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This kind of “trimmed” mean is used in some sports with subjective judging –
    like diving and gymnastics – to reduce the effect of a judge whose score deviates
    from the others.
  prefs: []
  type: TYPE_NORMAL
- en: 11.6\. Zip[#](#zip "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tuples are useful for looping through the elements of two sequences and performing
    operations on corresponding elements. For example, suppose two teams play a series
    of seven games, and we record their scores in two lists, one for each team.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Let’s see how many games each team won. We’ll use `zip`, which is a built-in
    function that takes two or more sequences and returns a **zip object**, so-called
    because it pairs up the elements of the sequences like the teeth of a zipper.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We can use the zip object to loop through the values in the sequences pairwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Each time through the loop, `pair` gets assigned a tuple of scores. So we can
    assign the scores to variables, and count the victories for the first team, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Sadly, the first team won only three games and lost the series.
  prefs: []
  type: TYPE_NORMAL
- en: If you have two lists and you want a list of pairs, you can use `zip` and `list`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a list of tuples, so we can get the result of the last game like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: If you have a list of keys and a list of values, you can use `zip` and `dict`
    to make a dictionary. For example, here’s how we can make a dictionary that maps
    from each letter to its position in the alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Now we can look up a letter and get its index in the alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: In this mapping, the index of `'a'` is `0` and the index of `'z'` is `25`.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to loop through the elements of a sequence and their indices, you
    can use the built-in function `enumerate`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The result is an **enumerate object** that loops through a sequence of pairs,
    where each pair contains an index (starting from 0) and an element from the given
    sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 11.7\. Comparing and Sorting[#](#comparing-and-sorting "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The relational operators work with tuples and other sequences. For example,
    if you use the `<` operator with tuples, it starts by comparing the first element
    from each sequence. If they are equal, it goes on to the next pair of elements,
    and so on, until it finds a pair that differ.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Subsequent elements are not considered – even if they are really big.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: This way of comparing tuples is useful for sorting a list of tuples, or finding
    the minimum or maximum. As an example, let’s find the most common letter in a
    word. In the previous chapter, we wrote `value_counts`, which takes a string and
    returns a dictionary that maps from each letter to the number of times it appears.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Here is the result for the string `'banana'`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: With only three items, we can easily see that the most frequent letter is `'a'`,
    which appears three times. But if there were more items, it would be useful to
    sort them automatically.
  prefs: []
  type: TYPE_NORMAL
- en: We can get the items from `counter` like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: The result is a `dict_items` object that behaves like a list of tuples, so we
    can sort it like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: The default behavior is to use the first element from each tuple to sort the
    list, and use the second element to break ties.
  prefs: []
  type: TYPE_NORMAL
- en: However, to find the items with the highest counts, we want to use the second
    element to sort the list. We can do that by writing a function that takes a tuple
    and returns the second element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Then we can pass that function to `sorted` as an optional argument called `key`,
    which indicates that this function should be used to compute the **sort key**
    for each item.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The sort key determines the order of the items in the list. The letter with
    the lowest count appears first, and the letter with the highest count appears
    last. So we can find the most common letter like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: If we only want the maximum, we don’t have to sort the list. We can use `max`,
    which also takes `key` as an optional argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: To find the letter with the lowest count, we could use `min` the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 11.8\. Inverting a dictionary[#](#inverting-a-dictionary "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose you want to invert a dictionary so you can look up a value and get the
    corresponding key. For example, if you have a word counter that maps from each
    word to the number of times it appears, you could make a dictionary that maps
    from integers to the words that appear that number of times.
  prefs: []
  type: TYPE_NORMAL
- en: But there’s a problem – the keys in a dictionary have to be unique, but the
    values don’t. For example, in a word counter, there could be many words with the
    same count.
  prefs: []
  type: TYPE_NORMAL
- en: So one way to invert a dictionary is to create a new dictionary where the values
    are lists of keys from the original. As an example, let’s count the letters in
    `parrot`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'If we invert this dictionary, the result should be `{1: [''p'', ''a'', ''o'',
    ''t''], 2: [''r'']}`, which indicates that the letters that appear once are `''p''`,
    `''a''`, `''o''`, and `''t''`, and the letter than appears twice is `''r''`.'
  prefs: []
  type: TYPE_NORMAL
- en: The following function takes a dictionary and returns its inverse as a new dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: The `for` statement loops through the keys and values in `d`. If the value is
    not already in the new dictionary, it is added and associated with a list that
    contains a single element. Otherwise it is appended to the existing list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: And we get the result we expected.
  prefs: []
  type: TYPE_NORMAL
- en: This is the first example we’ve seen where the values in the dictionary are
    lists. We will see more!
  prefs: []
  type: TYPE_NORMAL
- en: '## 11.9\. Debugging[#](#debugging "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: Lists, dictionaries and tuples are **data structures**. In this chapter we are
    starting to see compound data structures, like lists of tuples, or dictionaries
    that contain tuples as keys and lists as values. Compound data structures are
    useful, but they are prone to errors caused when a data structure has the wrong
    type, size, or structure. For example, if a function expects a list of integers
    and you give it a plain old integer (not in a list), it probably won’t work.
  prefs: []
  type: TYPE_NORMAL
- en: To help debug these kinds of errors, I wrote a module called `structshape` that
    provides a function, also called `structshape`, that takes any kind of data structure
    as an argument and returns a string that summarizes its structure. You can download
    it from [https://raw.githubusercontent.com/AllenDowney/ThinkPython/v3/structshape.py](https://raw.githubusercontent.com/AllenDowney/ThinkPython/v3/structshape.py).
  prefs: []
  type: TYPE_NORMAL
- en: We can import it like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Here’s an example with a simple list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Here’s a list of lists.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: If the elements of the list are not the same type, `structshape` groups them
    by type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Here’s a list of tuples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: And here’s a dictionary with three items that map integers to strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: If you are having trouble keeping track of your data structures, `structshape`
    can help.
  prefs: []
  type: TYPE_NORMAL
- en: 11.10\. Glossary[#](#glossary "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**pack:** Collect multiple arguments into a tuple.'
  prefs: []
  type: TYPE_NORMAL
- en: '**unpack:** Treat a tuple (or other sequence) as multiple arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: '**zip object:** The result of calling the built-in function `zip`, can be used
    to loop through a sequence of tuples.'
  prefs: []
  type: TYPE_NORMAL
- en: '**enumerate object:** The result of calling the built-in function `enumerate`,
    can be used to loop through a sequence of tuples.'
  prefs: []
  type: TYPE_NORMAL
- en: '**sort key:** A value, or function that computes a value, used to sort the
    elements of a collection.'
  prefs: []
  type: TYPE_NORMAL
- en: '**data structure:** A collection of values, organized to perform certain operations
    efficiently.'
  prefs: []
  type: TYPE_NORMAL
- en: 11.11\. Exercises[#](#exercises "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 11.11.1\. Ask a virtual assistant[#](#ask-a-virtual-assistant "Link to this
    heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The exercises in this chapter might be more difficult than exercises in previous
    chapters, so I encourage you to get help from a virtual assistant. When you pose
    more difficult questions, you might find that the answers are not correct on the
    first attempt, so this is a chance to practice crafting good prompts and following
    up with good refinements.
  prefs: []
  type: TYPE_NORMAL
- en: One strategy you might consider is to break a big problems into pieces that
    can be solved with simple functions. Ask the virtual assistant to write the functions
    and test them. Then, once they are working, ask for a solution to the original
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: For some of the exercises below, I make suggestions about which data structures
    and algorithms to use. You might find these suggestions useful when you work on
    the problems, but they are also good prompts to pass along to a virtual assistant.
  prefs: []
  type: TYPE_NORMAL
- en: 11.11.2\. Exercise[#](#exercise "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter I said that tuples can be used as keys in dictionaries because
    they are hashable, and they are hashable because they are immutable. But that
    is not always true.
  prefs: []
  type: TYPE_NORMAL
- en: If a tuple contains a mutable value, like a list or a dictionary, the tuple
    is no longer hashable because it contains elements that are not hashable. As an
    example, here’s a tuple that contains two lists of integers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Write a line of code that appends the value `6` to the end of the second list
    in `t`. If you display `t`, the result should be `([1, 2, 3], [4, 5, 6])`.
  prefs: []
  type: TYPE_NORMAL
- en: Try to create a dictionary that maps from `t` to a string, and confirm that
    you get a `TypeError`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: For more on this topic, ask a virtual assistant, “Are Python tuples always hashable?”
  prefs: []
  type: TYPE_NORMAL
- en: '### 11.11.3\. Exercise[#](#section-exercise-11 "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we made a dictionary that maps from each letter to its index
    in the alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: For example, the index of `'a'` is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: To go in the other direction, we can use list indexing. For example, the letter
    at index `1` is `'b'`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: We can use `letter_map` and `letters` to encode and decode words using a Caesar
    cipher.
  prefs: []
  type: TYPE_NORMAL
- en: A Caesar cipher is a weak form of encryption that involves shifting each letter
    by a fixed number of places in the alphabet, wrapping around to the beginning
    if necessary. For example, `'a'` shifted by 2 is `'c'` and `'z'` shifted by 1
    is `'a'`.
  prefs: []
  type: TYPE_NORMAL
- en: Write a function called `shift_word` that takes as parameters a string and an
    integer, and returns a new string that contains the letters from the string shifted
    by the given number of places.
  prefs: []
  type: TYPE_NORMAL
- en: To test your function, confirm that “cheer” shifted by 7 is “jolly” and “melon”
    shifted by 16 is “cubed”.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hints: Use the modulus operator to wrap around from `''z''` back to `''a''`.
    Loop through the letters of the word, shift each one, and append the result to
    a list of letters. Then use `join` to concatenate the letters into a string.'
  prefs: []
  type: TYPE_NORMAL
- en: 11.11.4\. Exercise[#](#id2 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Write a function called `most_frequent_letters` that takes a string and prints
    the letters in decreasing order of frequency.
  prefs: []
  type: TYPE_NORMAL
- en: To get the items in decreasing order, you can use `reversed` along with `sorted`
    or you can pass `reverse=True` as a keyword parameter to `sorted`.
  prefs: []
  type: TYPE_NORMAL
- en: 11.11.5\. Exercise[#](#id3 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a previous exercise, we tested whether two strings are anagrams by sorting
    the letters in both words and checking whether the sorted letters are the same.
    Now let’s make the problem a little more challenging.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll write a program that takes a list of words and prints all the sets of
    words that are anagrams. Here is an example of what the output might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Hint: For each word in the word list, sort the letters and join them back into
    a string. Make a dictionary that maps from this sorted string to a list of words
    that are anagrams of it.'
  prefs: []
  type: TYPE_NORMAL
- en: 11.11.6\. Exercise[#](#id4 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Write a function called `word_distance` that takes two words with the same length
    and returns the number of places where the two words differ.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Use `zip` to loop through the corresponding letters of the words.'
  prefs: []
  type: TYPE_NORMAL
- en: 11.11.7\. Exercise[#](#id5 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: “Metathesis” is the transposition of letters in a word. Two words form a “metathesis
    pair” if you can transform one into the other by swapping two letters, like `converse`
    and `conserve`. Write a program that finds all of the metathesis pairs in the
    word list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: The words in a metathesis pair must be anagrams of each other.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Credit: This exercise is inspired by an example at [http://puzzlers.org](http://puzzlers.org).'
  prefs: []
  type: TYPE_NORMAL
- en: '[Think Python: 3rd Edition](https://allendowney.github.io/ThinkPython/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Copyright 2024 [Allen B. Downey](https://allendowney.com)
  prefs: []
  type: TYPE_NORMAL
- en: 'Code license: [MIT License](https://mit-license.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Text license: [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
  prefs: []
  type: TYPE_NORMAL
