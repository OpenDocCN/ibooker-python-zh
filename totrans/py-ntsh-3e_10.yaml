- en: Chapter 10\. Regular Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 正则表达式
- en: Regular expressions (REs, aka regexps) let programmers specify pattern strings
    and perform searches and substitutions. Regular expressions are not easy to master,
    but they can be a powerful tool for processing text. Python offers rich regular
    expression functionality through the built-in re module. In this chapter, we thoroughly
    present all about Python’s REs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式（REs，也称为 regexps）允许程序员指定模式字符串并进行搜索和替换。正则表达式并不容易掌握，但它们是处理文本的强大工具。Python
    通过内置的 re 模块提供了丰富的正则表达式功能。在本章中，我们全面介绍了关于 Python 的正则表达式的所有内容。
- en: Regular Expressions and the re Module
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式和 re 模块
- en: A regular expression is built from a string that represents a pattern. With
    RE functionality, you can examine any string and check which parts of the string,
    if any, match the pattern.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是由表示模式的字符串构建而成的。使用 RE 功能，你可以检查任何字符串，并查看字符串的哪些部分（如果有的话）匹配了模式。
- en: The re module supplies Python’s RE functionality. The compile function builds
    an RE object from a pattern string and optional flags. The methods of an RE object
    look for matches of the RE in a string or perform substitutions. The re module
    also exposes functions equivalent to an RE object’s methods, but with the RE’s
    pattern string as the first argument.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: re 模块提供了 Python 的 RE 功能。compile 函数从模式字符串和可选标志中构建一个 RE 对象。RE 对象的方法查找字符串中的 RE
    匹配项或执行替换。re 模块还公开了等效于 RE 对象方法的函数，但将 RE 的模式字符串作为第一个参数。
- en: This chapter covers the use of REs in Python; it does not teach every minute
    detail about how to create RE patterns. For general coverage of REs, we recommend
    the book *Mastering Regular Expressions*, by Jeffrey Friedl (O’Reilly), offering
    thorough coverage of REs at both tutorial and advanced levels. Many tutorials
    and references on REs can also be found online, including an excellent, detailed
    tutorial in Python’s [online docs](https://oreil.ly/tj7jh). Sites like [Pythex](http://pythex.org)
    and [regex101](https://regex101.com) let you test your REs interactively. Alternatively,
    you can start IDLE, the Python REPL, or any other interactive interpreter, **import**
    re, and experiment directly.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了在 Python 中使用 REs；它并不教授如何创建 RE 模式的每一个细节。对于正则表达式的一般覆盖，我们推荐 Jeffrey Friedl
    的书《*精通正则表达式*》（O’Reilly），该书在教程和高级水平上都对正则表达式进行了详尽的介绍。许多关于正则表达式的教程和参考资料也可以在网上找到，包括
    Python 的[在线文档](https://oreil.ly/tj7jh)中的优秀详细教程。像[Pythex](http://pythex.org)和[regex101](https://regex101.com)这样的网站可以让你交互式地测试你的
    REs。或者，你可以启动 IDLE，Python REPL 或任何其他交互式解释器，**import** re，并直接进行实验。
- en: REs and bytes Versus str
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REs 和 bytes 与 str
- en: 'REs in Python work in two ways, depending on the type of the object being matched:
    when applied to str instances, an RE matches accordingly (e.g., a Unicode character
    *c* is deemed to be “a letter” if ''LETTER'' **in** unicodedata.name(*c*)); when
    applied to bytes instances, an RE matches in terms of ASCII (e.g., a byte *c*
    is deemed to be “a letter” if *c* **in** string.ascii_letters). For example:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，REs 根据要匹配的对象的类型以两种方式工作：当应用于 str 实例时，REs 根据相应匹配（例如，Unicode 字符 *c*
    如果 'LETTER' **in** unicodedata.name(*c*) 则被认为是“字母”）；当应用于 bytes 实例时，REs 根据 ASCII
    进行匹配（例如，字节 *c* 如果 *c* **in** string.ascii_letters 则被认为是“字母”）。例如：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Pattern String Syntax
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式字符串语法
- en: 'The pattern string representing a regular expression follows a specific syntax:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 表示正则表达式的模式字符串遵循特定的语法：
- en: Alphabetic and numeric characters stand for themselves. An RE whose pattern
    is a string of letters and digits matches the same string.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字母和数字字符代表它们自身。一个 RE，其模式是由字母和数字组成的字符串，匹配相同的字符串。
- en: Many alphanumeric characters acquire special meaning in a pattern when they
    are preceded by a backslash (\), or *escaped*.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多字母数字字符在模式中以反斜杠（\）或 *转义* 的方式具有特殊含义。
- en: 'Punctuation characters work the other way around: they stand for themselves
    when escaped but have special meaning when unescaped.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标点符号字符的工作方式正好相反：它们在转义时代表它们自身，但在未转义时具有特殊含义。
- en: The backslash character is matched by a repeated backslash (\\).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反斜杠字符可以通过重复的反斜杠（\\）来匹配。
- en: An RE pattern is a string concatenating one or more pattern elements; each element
    in turn is itself an RE pattern. For example, r'a' is a one-element RE pattern
    that matches the letter a, and r'ax' is a two-element RE pattern that matches
    an a immediately followed by an x.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: RE 模式是一个将一个或多个模式元素串联起来的字符串；每个元素本身也是一个 RE 模式。例如，r'a' 是一个单元素 RE 模式，匹配字母 a，而 r'ax'
    是一个两元素 RE 模式，匹配紧接着的 a 后面跟着的 x。
- en: Since RE patterns often contain backslashes, it’s best to always specify RE
    patterns in raw string literal form (covered in [“Strings”](ch03.xhtml#string)).
    Pattern elements (such as r'\t', equivalent to the string literal '\\t') do match
    the corresponding special characters (in this case, the tab character \t), so
    you can use a raw string literal even when you need a literal match for such special
    characters.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 RE 模式经常包含反斜杠，最好总是以原始字符串字面形式指定 RE 模式（见 [“字符串”](ch03.xhtml#string)）。模式元素（例如
    r'\t'，等效于字符串字面量 '\\t'）确实匹配相应的特殊字符（在本例中是制表符 \t），因此即使需要字面匹配这些特殊字符，也可以使用原始字符串字面量。
- en: '[Table 10-1](#re_pattern_syntax) lists the special elements in RE pattern syntax.
    The exact meanings of some pattern elements change when you use optional flags,
    together with the pattern string, to build the RE object. The optional flags are
    covered in [“Optional Flags”](#optional_flags).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-1 列出了 RE 模式语法中的特殊元素。某些模式元素的确切含义会因可选标志与模式字符串一起构建 RE 对象而改变。可选标志在 [“可选标志”](#optional_flags)
    中介绍。
- en: Table 10-1\. RE pattern syntax
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-1\. RE 模式语法
- en: '| Element | Meaning |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 元素 | 含义 |'
- en: '| --- | --- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| . | Matches any single character except \n (if DOTALL, also matches \n) |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| . | 匹配任何单个字符，除了换行符 \n（如果启用 DOTALL，则也匹配换行符 \n） |'
- en: '| ^ | Matches start of string (if MULTILINE, also matches right after \n) |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| ^ | 匹配字符串的开头（如果启用 MULTILINE，则也匹配换行符后面的位置） |'
- en: '| $ | Matches end of string (if MULTILINE, also matches right before \n) |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| $ | 匹配字符串的结尾（如果启用 MULTILINE，则也匹配换行符前面的位置） |'
- en: '| * | Matches zero or more cases of the previous RE; greedy (matches as many
    as possible) |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| * | 匹配前一个 RE 的零次或多次；贪婪模式（尽可能多地匹配） |'
- en: '| + | Matches one or more cases of the previous RE; greedy (matches as many
    as possible) |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| + | 匹配前一个 RE 的一次或多次；贪婪模式（尽可能多地匹配） |'
- en: '| ? | Matches zero or one cases of the previous RE; greedy (matches one if
    possible) |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| ? | 匹配前一个 RE 的零次或一次；贪婪模式（如果可能，则匹配一次） |'
- en: '| *?, +?, ?? | Nongreedy versions of *, +, and ?, respectively (match as few
    as possible) |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| *?, +?, ?? | *非贪婪版本* 的 *, +, ?，分别匹配尽可能少的情况'
- en: '| {*m*} | Matches *m* cases of the previous RE |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| {*m*} | 匹配前一个 RE 的 *m* 次 |'
- en: '| {*m*, *n*} | Matches between *m* and *n* cases of the previous RE; *m* or
    *n* (or both) may be omitted, defaulting to *m*=0 and *n*=infinity (greedy) |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| {*m*, *n*} | 匹配前一个 RE 的 *m* 至 *n* 次；可以省略 *m* 或 *n*（或两者），默认 *m*=0 和 *n*=无穷大（贪婪模式）
    |'
- en: '| {*m*, *n*}? | Matches between *m* and *n* cases of the previous RE (nongreedy)
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| {*m*, *n*}? | 匹配前一个 RE 的 *m* 至 *n* 次；非贪婪模式 |'
- en: '| [...] | Matches any one of a set of characters contained within the brackets
    |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| [...] | 匹配括号内任一字符集合中的一个字符 |'
- en: '| [^...] | Matches one character *not* contained within the brackets after
    the caret ^ |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| [^...] | 匹配括号内不含字符的一个字符，^ 后面紧跟的字符 |'
- en: '| &#124; | Matches either the preceding RE or the following RE |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| &#124; | 匹配前一个 RE 或后一个 RE |'
- en: '| (...) | Matches the RE within the parentheses and indicates a *group* |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| (...) | 匹配括号内的 RE 并指示一个 *组* |'
- en: '| (?aiLmsux) | Alternate way to set optional flags^([a](ch10.xhtml#ch01fn97))
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| (?aiLmsux) | 设置可选标志的另一种方式^([a](ch10.xhtml#ch01fn97)) |'
- en: '| (?:...) | Like (...) but does not capture the matched characters in a group
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| (?:...) | 类似于 (...)，但不捕获匹配的字符组 |'
- en: '| (?P*<id>*...) | Like (...) but the group also gets the name *<id>* |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| (?P*<id>*...) | 类似于 (...)，但该组同时获取名称 *<id>* |'
- en: '| (?P=*<id>*) | Matches whatever was previously matched by the group named
    *<id>* |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| (?P=*<id>*) | 匹配先前由名称为 *<id>* 的组匹配的内容 |'
- en: '| (?#...) | Content of parentheses is just a comment; no effect on match |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| (?#...) | 括号内的内容仅作为注释；对匹配没有影响 |'
- en: '| (?=...) | *Lookahead assertion*: matches if RE ... matches what comes next,
    but does not consume any part of the string |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| (?=...) | *前行断言*：如果 RE ... 匹配接下来的内容，则匹配，并且不消耗字符串的任何部分 |'
- en: '| (?!...) | *Negative lookahead assertion*: matches if RE ... does *not* match
    what comes next, and does not consume any part of the string |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| (?!...) | *负向前行断言*：如果 RE ... 不匹配接下来的内容，则匹配，并且不消耗字符串的任何部分 |'
- en: '| (?<=...) | *Lookbehind assertion*: matches if there is a match ending at
    the current position for RE ... (... must match a fixed length) |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| (?<=...) | *后行断言*：如果 RE ... 的匹配正好结束于当前位置，则匹配 |'
- en: '| (?<!...) | *Negative lookbehind assertion*: matches if there is no match
    ending at the current position for RE ... (... must match a fixed length) |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| (?<!...) | *负向后行断言*：如果 RE ... 的匹配正好不结束于当前位置，则匹配 |'
- en: '| \ *number* | Matches whatever was previously matched by the group numbered
    *number* (groups are automatically numbered left to right, from 1 to 99) |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| \ *number* | 匹配之前由编号 *number* 的组匹配的内容（组自动从左到右编号，从 1 到 99） |'
- en: '| \A | Matches an empty string, but only at the start of the whole string |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| \A | 只在整个字符串的开头匹配一个空字符串 |'
- en: '| \b | Matches an empty string, but only at the start or end of a *word* (a
    maximal sequence of alphanumeric characters; see also \w) |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| \b | 只在单词的开头或结尾匹配一个空字符串（一个最大的字母数字字符序列；参见也 \w） |'
- en: '| \B | Matches an empty string, but not at the start or end of a word |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| \B | 匹配一个空字符串，但不匹配单词的开头或结尾 |'
- en: '| \d | Matches one digit, like the set [0-9] (in Unicode mode, many other Unicode
    characters also count as “digits” for \d, but not for [0-9]) |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| \d | 匹配一个数字，类似于集合 [0-9]（在 Unicode 模式下，许多其他 Unicode 字符也被视为“数字”对于 \d，但不适用于
    [0-9]） |'
- en: '| \D | Matches one nondigit character, like the set [^0-9] (in Unicode mode,
    many other Unicode characters also count as “digits” for \D, but not for [^0-9])
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| \D | 匹配一个非数字字符，类似于集合 [^0-9]（在 Unicode 模式下，许多其他 Unicode 字符也被视为“数字”对于 \D，但不适用于
    [^0-9]） |'
- en: '| \N{*name*} | 3.8+ Matches the Unicode character corresponding to *name* |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| \N{*name*} | 3.8+ 匹配与 *name* 对应的 Unicode 字符 |'
- en: '| \s | Matches a whitespace character, like the set [\t\n\r\f\v] |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| \s | 匹配一个空白字符，类似于集合 [\t\n\r\f\v] |'
- en: '| \S | Matches a nonwhitespace character, like the set [^\t\n\r\f\v] |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| \S | 匹配一个非空白字符，类似于集合 [^\t\n\r\f\v] |'
- en: '| \w | Matches one alphanumeric character; unless in Unicode mode, or if LOCALE
    or UNICODE is set, \w is like [a-zA-Z0-9_] |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| \w | 匹配一个字母数字字符；除非在 Unicode 模式下，或者 LOCALE 或 UNICODE 已设置，否则 \w 就像 [a-zA-Z0-9_]
    |'
- en: '| \W | Matches one nonalphanumeric character, the reverse of \w |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| \W | 匹配一个非字母数字字符，与 \w 的反义 |'
- en: '| \Z | Matches an empty string, but only at the end of the whole string |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| \Z | 只在整个字符串的结尾匹配一个空字符串 |'
- en: '| \\ | Matches one backslash character |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| \\ | 匹配一个反斜杠字符 |'
- en: '| ^([a](ch10.xhtml#ch01fn97-marker)) Always place the (?...) construct for
    setting flags, if any, at the start of the pattern, for readability; placing it
    elsewhere raises DeprecationWarning. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch10.xhtml#ch01fn97-marker)) 总是将设置标志（如果有）的 (?...) 结构放在模式的开头，以提高可读性；在其他位置放置会引发
    DeprecationWarning。 |'
- en: Using a \ character followed by an alphabetic character not listed here or in
    [Table 3-4](ch03.xhtml#operator_precedence_in_expressions) raises an re.error
    exception.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符 \ 后跟字母字符（不包括此处列出的字符或 [表 3-4](ch03.xhtml#operator_precedence_in_expressions)）会引发
    re.error 异常。
- en: Common Regular Expression Idioms
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见的正则表达式惯用法
- en: Always Use r’...’ Syntax for RE Pattern Literals
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 始终使用 r'...' 语法来表示 RE 模式文字
- en: Use raw string literals for all RE pattern literals, and only for them. This
    ensures you’ll never forget to escape a backslash (\), and improves code readability
    since it makes your RE pattern literals stand out.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有 RE 模式文字，请使用原始字符串文字，仅限于它们。这样可以确保您永远不会忘记转义反斜杠 (\)，并提高代码的可读性，因为它使您的 RE 模式文字更加突出。
- en: '.* as a substring of a regular expression’s pattern string means “any number
    of repetitions (zero or more) of any character.” In other words, .* matches any
    substring of a target string, including the empty substring. .+ is similar but
    matches only a nonempty substring. For example, this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: .* 作为正则表达式模式字符串的子串意味着“任意数量（零或多个）的任意字符。”换句话说，.* 匹配目标字符串的任何子串，包括空子串。. + 类似，但只匹配非空子串。例如，这样：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'matches a string containing a substring ''pre'' followed by a later substring
    ''post'', even if the latter is adjacent to the former (e.g., it matches both
    ''prepost'' and ''pre23post''). On the other hand, this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配包含子字符串 'pre' 后接后续子字符串 'post' 的字符串，即使后者紧邻前者（例如，它同时匹配 'prepost' 和 'pre23post'）。另一方面，此模式：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'matches only if ''pre'' and ''post'' are not adjacent (e.g., it matches ''pre23post''
    but does not match ''prepost''). Both patterns also match strings that continue
    after the ''post''. To constrain a pattern to match only strings that *end* with
    ''post'', end the pattern with \Z. For example, this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当 'pre' 和 'post' 不相邻时才匹配（例如，它匹配 'pre23post' 但不匹配 'prepost'）。这两种模式还会匹配在 'post'
    后继续的字符串。为了将模式限制为仅匹配以 'post' 结尾的字符串，请在模式结尾处使用 \Z。例如，这样：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: matches 'prepost' but not 'preposterous'.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 'prepost' 但不匹配 'preposterous'。
- en: All of these examples are *greedy*, meaning that they match the substring beginning
    with the first occurrence of 'pre' all the way to the *last* occurrence of 'post'.
    When you care about what part of the string you match, you may often want to specify
    *nongreedy* matching, which in our example would match the substring beginning
    with the first occurrence of 'pre' but only up to the *first* following occurrence
    of 'post'.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些示例都是 *贪婪* 的，意味着它们匹配从第一个出现的 'pre' 开始到最后一个出现的 'post' 的子串。当您关心匹配字符串的哪个部分时，您通常会希望指定
    *非贪婪* 匹配，在我们的例子中，它将匹配从第一个出现的 'pre' 开始，但仅限到下一个出现的 'post' 的第一次匹配。
- en: For example, when the string is 'preposterous and post facto', the greedy RE
    pattern r'pre.*post' matches the substring 'preposterous and post'; the nongreedy
    variant r'pre.*?post' matches just the substring 'prepost'.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当字符串为 'preposterous and post facto' 时，贪婪的正则表达式模式 r'pre.*post' 将匹配子串 'preposterous
    and post'；非贪婪的变体 r'pre.*?post' 则仅匹配子串 'prepost'。
- en: 'Another frequently used element in RE patterns is \b, which matches a word
    boundary. To match the word ''his'' only as a whole word and not its occurrences
    as a substring in such words as ''this'' and ''history'', the RE pattern is:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式模式中另一个经常使用的元素是 \b，它匹配单词边界。要仅匹配单词 'his' 而不是它在诸如 'this' 和 'history' 中出现的子串，正则表达式模式为：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'with word boundaries both before and after. To match the beginning of any word
    starting with ''her'', such as ''her'' itself and ''hermetic'', but not words
    that just contain ''her'' elsewhere, such as ''ether'' or ''there'', use:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在单词边界之前和之后。要匹配以 'her' 开头的任何单词的开头，如 'her' 本身和 'hermetic'，但不是其他地方仅包含 'her' 的单词，如
    'ether' 或 'there'，使用：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'with a word boundary before, but not after, the relevant string. To match the
    end of any word ending with ''its'', such as ''its'' itself and ''fits'', but
    not words that contain ''its'' elsewhere, such as ''itsy'' or ''jujitsu'', use:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在相关字符串之前的单词边界，但不是之后。要匹配以 'its' 结尾的任何单词的结尾，如 'its' 本身和 'fits'，但不是其他地方包含 'its'
    的单词，如 'itsy' 或 'jujitsu'，使用：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'with a word boundary after, but not before, the relevant string. To match whole
    words thus constrained, rather than just their beginning or end, add a pattern
    element \w* to match zero or more word characters. To match any full word starting
    with ''her'', use:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在相关字符串之后的单词边界，但不是之前。为了匹配这样受限的完整单词，而不仅仅是它们的开头或结尾，添加模式元素 \w* 来匹配零个或多个单词字符。要匹配以
    'her' 开头的任何完整单词，使用：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To match just the first three letters of any word starting with ''her'', but
    not the word ''her'' itself, use a negative word boundary \B:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要仅匹配以 'her' 开头的任何单词的前三个字母，但不包括单词 'her' 本身，使用负单词边界 \B：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To match any full word ending with ''its'', including ''its'' itself, use:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要匹配以 'its' 结尾的任何完整单词，包括 'its' 本身，使用：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Sets of Characters
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符集
- en: 'You denote sets of characters in a pattern by listing the characters within
    brackets ([]). In addition to listing characters, you can denote a range by giving
    the first and last characters of the range separated by a hyphen (-). The last
    character of the range is included in the set, differently from other Python ranges.
    Within a set, special characters stand for themselves, except \, ], and -, which
    you must escape (by preceding them with a backslash) when their position is such
    that, if not escaped, they would form part of the set’s syntax. You can denote
    a class of characters within a set by escaped-letter notation, such as \d or \S.
    \b in a set means a backspace character (chr(8)), not a word boundary. If the
    first character in the set’s pattern, right after the [, is a caret (^), the set
    is *complemented*: such a set matches any character *except* those that follow
    ^ in the set pattern notation.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在方括号([])内列出字符来表示模式中的字符集。除了列出字符外，还可以通过用连字符(-)分隔的第一个和最后一个字符来表示范围。范围的最后一个字符包括在集合中，与其他
    Python 范围不同。在集合内，特殊字符代表它们自己，除了 \、] 和 -，当它们的位置使它们不转义时（通过在它们前面加上反斜杠），它们将形成集合的语法部分。您可以通过转义字母表示法，如
    \d 或 \S，在集合中表示字符类。在集合的模式中，\b 表示退格字符(chr(8))，而不是单词边界。如果集合模式中的第一个字符，紧跟在 [ 之后，是一个插入符（^），则集合是
    *补充的*：这样的集合匹配除了在集合模式表示法中的^后跟随的字符之外的任何字符。
- en: 'A frequent use of character sets is to match a “word,” using a definition of
    which characters can make up a word that differs from \w’s default (letters and
    digits). To match a word of one or more characters, each of which can be an ASCII
    letter, an apostrophe, or a hyphen, but not a digit (e.g., "Finnegan-O''Hara"),
    use:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 字符集的一个常见用法是匹配“单词”，使用与\w默认值（字母和数字）不同的字符定义可以组成单词。要匹配一个或多个字符的单词，每个字符可以是ASCII字母，撇号或连字符，但不能是数字（例如，“Finnegan-O'Hara”），使用：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Always Escape Hyphens in Character Sets
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总是需要在字符集中转义连字符。
- en: 'It’s not strictly necessary to escape the hyphen with a backslash in this case,
    since its position at the end of the set makes the situation syntactically unambiguous.
    However, using the backslash is advisable because it makes the pattern more readable,
    by visually distinguishing the hyphen that you want to have as a character in
    the set from those used to denote ranges. (When you want to include a backslash
    in the character set, of course, you denote that by escaping the backslash itself:
    write it as \\.)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，严格来说不必在字符集中使用反斜杠转义连字符，因为其位置位于集合的末尾，使得情况在语法上不模棱两可。然而，使用反斜杠是明智的，因为它使模式更可读，通过视觉上区分你希望作为集合中的字符的连字符，而不是用于表示范围的连字符。（当你想在字符集中包含反斜杠时，当然，你通过转义反斜杠本身来表示：将其写为\\。）
- en: Alternatives
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替代项
- en: A vertical bar (|) in a regular expression pattern, used to specify alternatives,
    has low syntactic precedence. Unless parentheses change the grouping, | applies
    to the whole pattern on either side, up to the start or end of the pattern, or
    to another |. A pattern can be made up of any number of subpatterns joined by
    |. It is important to note that an RE of subpatterns joined by | will match the
    *first* matching subpattern, not the longest. A pattern like r'ab|abc' will never
    match 'abc' because the 'ab' match gets evaluated first.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式模式中的竖线（|），用于指定替代项，具有较低的语法优先级。除非括号改变了分组，|应用于两侧整个模式，直到模式的开始或结束，或者另一个|。模式可以由任意数量的由|连接的子模式组成。重要的是要注意，由|连接的子模式的RE将匹配*第一个*匹配的子模式，而不是最长的子模式。像r'ab|abc'的模式永远不会匹配'abc'，因为'ab'匹配首先得到评估。
- en: 'Given a list *L* of words, an RE pattern that matches any one of the words
    is:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 给定单词列表*L*，匹配任意一个单词的RE模式是：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Escaping Strings
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转义字符串
- en: 'If the items of *L* can be more general strings, not just words, you need to
    *escape* each of them with the function re.escape (covered in [Table 10-6](#additional_re_functions)),
    and you may not want the \b word boundary markers on either side. In this case,
    you could use the following RE pattern (sorting the list in reverse order by length
    to avoid accidentally “masking” a longer word by a shorter one):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*L*的项目可以是更一般的字符串，而不仅仅是单词，您需要使用re.escape函数（在[表10-6](https://example.org/additional_re_functions)中介绍）对每个项目进行*转义*，并且可能不希望在两侧使用\b单词边界标记。在这种情况下，您可以使用以下RE模式（通过长度逆序对列表进行排序，以避免意外“掩盖”较长单词的较短单词）：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Groups
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分组
- en: A regular expression can contain any number of *groups*, from none to 99 (or
    even more, but only the first 99 groups are fully supported). Parentheses in a
    pattern string indicate a group. The element (?P<*id*>...) also indicates a group
    and gives the group a name, *id*, that can be any Python identifier. All groups,
    named and unnamed, are numbered, left to right, 1 to 99; “group 0” means the string
    that the whole RE matches.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式可以包含从零到99个（甚至更多，但只完全支持前99个）*分组*。模式字符串中的括号表示一个组。元素(?P<*id*>...)也表示一个组，并为组命名一个名为*id*的名称，该名称可以是任何Python标识符。所有组，包括命名和未命名的，都按从左到右，从1到99进行编号；“组0”表示整个RE匹配的字符串。
- en: 'For any match of the RE with a string, each group matches a substring (possibly
    an empty one). When the RE uses |, some groups may not match any substring, although
    the RE as a whole does match the string. When a group doesn’t match any substring,
    we say that the group does not *participate* in the match. An empty string ('''')
    is used as the matching substring for any group that does not participate in a
    match, except where otherwise indicated later in this chapter. For example, this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于RE与字符串的任何匹配，每个组都匹配一个子字符串（可能为空）。当RE使用|时，一些组可能不匹配任何子字符串，尽管整个RE确实匹配字符串。当一个组不匹配任何子字符串时，我们说该组不*参与*匹配。对于任何不参与匹配的组，空字符串（''）用作匹配的子字符串，除非本章后面另有说明。例如，这个：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: matches a string made up of two or more repetitions of any nonempty substring.
    The (.+) part of the pattern matches any nonempty substring (any character, one
    or more times) and defines a group, thanks to the parentheses. The \1+ part of
    the pattern matches one or more repetitions of the group, and \Z anchors the match
    to the end of the string.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配由两个或更多次重复的非空子字符串组成的字符串。模式的 (.+) 部分匹配任何非空子字符串（任何字符，一次或多次），并定义了一个组，因为有括号。模式的
    \1+ 部分匹配组的一次或多次重复，并且 \Z 将匹配锚定到字符串的结尾。
- en: Optional Flags
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选标志
- en: 'The optional flags argument to the function compile is a coded integer built
    by bitwise ORing (with Python’s bitwise OR operator, |) one or more of the following
    attributes of the module re. Each attribute has both a short name (one uppercase
    letter), for convenience, and a long name (an uppercase multiletter identifier),
    which is more readable and thus normally preferable:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 compile 的可选标志参数是通过使用 Python 的按位或运算符（|）对模块 re 的以下属性之一或多个进行按位或运算构建的编码整数。每个属性都有一个简短名称（一个大写字母），以方便使用，以及一个更可读的长名称（一个大写的多字母标识符），因此通常更可取：
- en: A *or* ASCII
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: A *or* ASCII
- en: Uses ASCII-only characters for \w, \W, \b, \B, \d, and \D; overrides the default
    UNICODE flag
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用 ASCII 字符来匹配 \w、\W、\b、\B、\d 和 \D；覆盖默认的 UNICODE 标志
- en: I *or* IGNORECASE
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: I *or* IGNORECASE
- en: Makes matching case-insensitive
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使匹配不区分大小写
- en: L *or* LOCALE
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: L *or* LOCALE
- en: Uses the Python LOCALE setting to determine characters for \w, \W, \b, \B, \d,
    and \D markers; you can only use this option with bytes patterns
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python LOCALE 设置来确定 \w、\W、\b、\B、\d 和 \D 标记的字符；你只能在字节模式中使用此选项
- en: M *or* MULTILINE
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: M *or* MULTILINE
- en: Makes the special characters ^ and $ match at the start and end of each line
    (i.e., right after/before a newline), as well as at the start and end of the whole
    string (\A and \Z always match only the start and end of the whole string)
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使得特殊字符 ^ 和 $ 匹配每一行的开头和结尾（即，在换行符之后/之前），以及整个字符串的开头和结尾（\A 和 \Z 仅匹配整个字符串的开头和结尾）
- en: S *or* DOTALL
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: S *or* DOTALL
- en: Causes the special character . to match any character, including a newline
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 导致特殊字符 . 匹配任何字符，包括换行符
- en: U *or* UNICODE
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: U *or* UNICODE
- en: Uses full Unicode to determine characters for \w, \W, \b, \B, \d, and \D markers;
    although retained for backward compatibility, this flag is now the default
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完整的 Unicode 来确定 \w、\W、\b、\B、\d 和 \D 标记的字符；虽然保留了向后兼容性，但此标志现在是默认的
- en: X *or* VERBOSE
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: X *or* VERBOSE
- en: 'Causes whitespace in the pattern to be ignored, except when escaped or in a
    character set, and makes a nonescaped # character in the pattern begin a comment
    that lasts until the end of the line'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '导致忽略模式中的空格，除非转义或在字符集中，并使得模式中的非转义 # 字符成为从该行到行尾的注释的开始'
- en: Flags can also be specified by inserting a pattern element with one or more
    of the letters aiLmsux between (? and ), rather than by the flags argument to
    the compile function of the re module (the letters correspond to the uppercase
    flags given in the preceding list). Options should always be placed at the start
    of the pattern; not doing this produces a deprecation warning. In particular,
    placement at the start is mandatory if x (the inline flag character for verbose
    RE parsing) is among the options, since x changes the way Python parses the pattern.
    Options apply to the whole RE, except that the aLu options can be applied locally
    within a group.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 标志还可以通过在 (? 和 ) 之间插入一个或多个字母 aiLmsux 的模式元素来指定，而不是通过 re 模块的 compile 函数的标志参数（这些字母对应于前述列表中给出的大写标志）。选项应始终放在模式的开头；不这样做会产生弃用警告。特别是，如果
    x（用于详细 RE 解析的内联标志字符）位于选项中，则必须将其放在模式的开头，因为 x 会改变 Python 解析模式的方式。选项适用于整个 RE，但 aLu
    选项可以在组内局部应用。
- en: 'Using the explicit flags argument is more readable than placing an options
    element within the pattern. For example, here are three ways to define equivalent
    REs with the compile function. Each of these REs matches the word “hello” in any
    mix of upper- and lowercase letters:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用显式的标志参数比在模式中放置选项元素更易读。例如，以下是使用 compile 函数定义等效 RE 的三种方法。这些 RE 中的每一个都匹配任何大小写字母组合的单词“hello”：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The third approach is clearly the most readable, and thus the most maintainable,
    though slightly more verbose. The raw string form is not strictly necessary here,
    since the patterns do not include backslashes. However, using raw string literals
    does no harm, and we recommend you always use them for RE patterns to improve
    clarity and readability.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法显然是最易读的，因此也是最易维护的，尽管稍微冗长。在这里使用原始字符串形式并非完全必要，因为模式不包含反斜杠。然而，使用原始字符串字面量没有坏处，我们建议您始终使用它们来改善
    RE 模式的清晰度和可读性。
- en: 'The option re.VERBOSE (or re.X) lets you make patterns more readable and understandable
    through appropriate use of whitespace and comments. Complicated and verbose RE
    patterns are generally best represented by strings that take up more than one
    line, and therefore you normally want to use a triple-quoted raw string literal
    for such pattern strings. For example, to match a string representing an integer
    that may be in octal, hex, or decimal format, you could use use either of the
    following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 选项 re.VERBOSE（或 re.X）允许您通过适当使用空白和注释使模式更易读和理解。通常，复杂和冗长的 RE 模式最好由占据多行的字符串表示，因此您通常希望为这些模式字符串使用三重引号原始字符串字面量。例如，要匹配可能以八进制、十六进制或十进制格式表示的整数字符串，您可以使用以下任一种：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The two patterns defined in this example are equivalent, but the second one
    is made more readable and understandable by the comments and the free use of whitespace
    to visually group portions of the pattern in logical ways.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中定义的两个模式是等效的，但第二个模式通过注释和自由使用空白来以逻辑方式可视化分组模式，使其更易读和理解。
- en: Match Versus Search
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配与搜索
- en: So far, we’ve been using regular expressions to *match* strings. For example,
    the RE with pattern r'box' matches strings such as 'box' and 'boxes', but not
    'inbox'. In other words, an RE *match* is implicitly anchored at the start of
    the target string, as if the RE’s pattern started with \A.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用正则表达式来 *匹配* 字符串。例如，带有模式 r'box' 的 RE 可以匹配字符串 'box' 和 'boxes'，但不能匹配
    'inbox'。换句话说，RE 的 *匹配* 隐含地锚定在目标字符串的开头，就好像 RE 的模式以 \A 开头。
- en: 'Often you’ll be interested in locating possible matches for an RE anywhere
    in the string, without anchoring (e.g., find the r''box'' match within such strings
    as ''inbox'', as well as in ''box'' and ''boxes''). In this case, the Python term
    for the operation is a *search*, as opposed to a match. For such searches, use
    the search method of an RE object instead of the match method, which matches only
    from the beginning of the string. For example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 经常你会对 RE 中的可能匹配的位置感兴趣，无论在字符串的哪个位置（例如，在诸如 'inbox' 中找到 r'box' 的匹配，以及在 'box' 和
    'boxes' 中）。在这种情况下，Python 中的术语称为 *search*，而不是匹配。对于这样的搜索，请使用 RE 对象的 search 方法，而不是
    match 方法，后者仅从字符串的开头进行匹配。例如：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you want to check that the *whole* string matches, not just its beginning,
    you can instead use the method fullmatch. All of these methods are covered in
    [Table 10-3](#methods_of_re_objects).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想检查整个字符串是否匹配，而不仅仅是其开头，你可以使用 fullmatch 方法。所有这些方法都包含在 [表 10-3](#methods_of_re_objects)
    中。
- en: Anchoring at String Start and End
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在字符串的起始和结束锚定
- en: \A and \Z are the pattern elements ensuring that a regular expression match
    is *anchored* at the string’s start or end. The elements ^ for start and $ for
    end are also used in similar roles. For RE objects that are not flagged as MULTILINE,
    ^ is the same as \A, and $ is the same as \Z. For a multiline RE, however, ^ can
    anchor at the start of the string *or* the start of any line (where “lines” are
    determined based on \n separator characters). Similarly, with a multiline RE,
    $ can anchor at the end of the string *or* the end of any line. \A and \Z always
    anchor exclusively at the start and end of the string, whether the RE object is
    multiline or not.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: \A 和 \Z 是确保正则表达式匹配在字符串的起始或结尾处 *锚定* 的模式元素。元素 ^ 用于起始，而 $ 用于结尾，也用于类似的角色。对于未标记为
    MULTILINE 的 RE 对象，^ 等同于 \A，而 $ 等同于 \Z。然而，对于多行 RE，^ 可以锚定在字符串的起始或任何行的起始（“行”是基于 \n
    分隔符字符确定的）。类似地，对于多行 RE，$ 可以锚定在字符串的结尾或任何行的结尾。无论 RE 对象是否为多行，\A 和 \Z 始终只锚定在字符串的起始和结尾处。
- en: 'For example, here’s a way to check whether a file has any lines that end with
    digits:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是检查文件是否有任何以数字结尾的行的方法：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A pattern of r'\d\n' is almost equivalent, but in that case, the search fails
    if the very last character of the file is a digit not followed by an end-of-line
    character. With the preceding example, the search succeeds if a digit is at the
    very end of the file’s contents, as well as in the more usual case where a digit
    is followed by an end-of-line character.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 模式 r'\d\n' 几乎等效，但在这种情况下，如果文件的最后一个字符是一个不跟随换行符的数字，则搜索失败。使用前述示例，即使数字位于文件内容的最后，搜索也将成功，这与通常情况下数字后跟换行符的情况相同。
- en: Regular Expression Objects
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式对象
- en: '[Table 10-2](#attributes_of_re_objects) covers the read-only attributes of
    a regular expression object *r* that detail how *r* was built (by the function
    compile of the module re, covered in [Table 10-6](#additional_re_functions)).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 10-2](#attributes_of_re_objects) 涵盖了正则表达式对象 *r* 的只读属性，详细说明了 *r* 是如何构建的（由模块
    re 的 compile 函数完成，见 [表 10-6](#additional_re_functions)）。'
- en: Table 10-2\. Attributes of RE objects
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Table 10-2\. RE 对象的属性
- en: '| flags | The flags argument passed to compile, or re.UNICODE when flags is
    omitted; also includes any flags specified in the pattern itself using a leading
    (?...) element |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| flags | flags 参数传递给 compile 函数时的参数，或者当省略 flags 时为 re.UNICODE；还包括使用前导 (?...)
    元素在模式本身中指定的任何标志 |'
- en: '| groupindex | A dictionary whose keys are group names as defined by elements
    (?P<*id*>...); the corresponding values are the named groups’ numbers |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| groupindex | 一个字典，其键是由元素 (?P<*id*>...) 定义的组名；相应的值是命名组的编号 |'
- en: '| pattern | The pattern string from which *r* is compiled |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| pattern | 编译 *r* 的模式字符串 |'
- en: These attributes make it easy to retrieve from a compiled RE object its original
    pattern string and flags, so you never have to store those separately.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性使得可以轻松地从已编译的 RE 对象中检索其原始模式字符串和标志，因此您不必单独存储它们。
- en: An RE object *r* also supplies methods to find matches for *r* in a string,
    as well as to perform substitutions on such matches (see [Table 10-3](#methods_of_re_objects)).
    Matches are represented by special objects, covered in the following section.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: RE 对象 *r* 也提供了方法来在字符串中查找 *r* 的匹配项，并对这些匹配项执行替换操作（参见 [表 10-3](#methods_of_re_objects)）。这些匹配项由特殊对象表示，在下一节中详细介绍。
- en: Table 10-3\. Methods of RE objects
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Table 10-3\. RE 对象的方法
- en: '| findall | *r*.findall(*s*) When r has no groups, findall returns a list of
    strings, each a substring of *s* that is a nonoverlapping match with *r*. For
    example, to print out all words in a file, one per line:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '| findall | *r*.findall(*s*) 当 r 没有分组时，findall 返回一个字符串列表，其中每个字符串都是 *s* 中与 *r*
    非重叠匹配的子串。例如，要打印文件中的所有单词，每行一个：'
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| findall *(cont.)* | When *r* has exactly one group, findall also returns
    a list of strings, but each is the substring of *s* that matches *r*’s group.
    For example, to print only words that are followed by whitespace (not words followed
    by punctuation or the word at end of the string), you need to change only one
    statement in the preceding example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '| findall *(cont.)* | 当 *r* 恰好有一个分组时，findall 也返回一个字符串列表，但每个字符串都是与 *r* 的组匹配的
    *s* 的子串。例如，要仅打印后面跟有空白字符的单词（而不是跟有标点符号或字符串末尾的单词），您只需更改前面示例中的一个语句：'
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When *r* has *n* groups (with *n* > 1), findall returns a list of tuples, one
    per nonoverlapping match with *r*. Each tuple has *n* items, one per group of
    *r*, the substring of *s* matching the group. For example, to print the first
    and last word of each line that has at least two words:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *r* 有 *n* 个分组（其中 *n* > 1）时，findall 返回一个元组列表，每个元组对应 *r* 的一个非重叠匹配。每个元组有 *n*
    个项，对应 *r* 的每个分组匹配的 *s* 中的子串。例如，要打印每行中至少有两个单词的第一个和最后一个单词：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| finditer | *r*.finditer(*s*) finditer is like findall, except that, instead
    of a list of strings or tuples, it returns an iterator whose items are match objects
    (discussed in the following section). In most cases, therefore, finditer is more
    flexible, and usually performs better, than findall. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| finditer | *r*.finditer(*s*) finditer 类似于 findall，不同之处在于它返回一个迭代器，其项是匹配对象（在下一节中讨论）。因此，在大多数情况下，finditer
    比 findall 更灵活，通常性能更好。 |'
- en: '| fullmatch | *r*.fullmatch(*s*, start=0, end=sys.maxsize) Returns a match
    object when the complete substring *s*, starting at index start and ending just
    short of index end, matches *r.* Otherwise, fullmatch returns **None**. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| fullmatch | *r*.fullmatch(*s*, start=0, end=sys.maxsize) 当完整子串 *s*（从索引 start
    开始，结束于索引 end 之前）与 *r* 匹配时，返回一个匹配对象。否则，fullmatch 返回 **None**。 |'
- en: '| match | *r*.match(*s*, start=0, end=sys.maxsize) Returns an appropriate match
    object when a substring of *s*, starting at index start and not reaching as far
    as index end, matches *r*. Otherwise, match returns **None**. match is implicitly
    anchored at the starting position start in *s*. To search for a match with *r*
    at any point in *s* from start onward, call *r*.search, not *r*.match. For example,
    here is one way to print all lines in a file that start with digits:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '| match | *r*.match(*s*, start=0, end=sys.maxsize) 当 *s* 中以索引 start 开始且不到索引
    end 的子字符串与 *r* 匹配时，返回一个适当的匹配对象。否则，match 返回 **None**。match 在 *s* 中的起始位置 start 隐式锚定。要在
    *s* 中的任何位置搜索 *r* 的匹配项，从 start 开始，请调用 *r*.search，而不是 *r*.match。例如，这是一种打印所有以数字开头的行的方法:'
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| search | *r*.search(*s*, start=0, end=sys.maxsize) Returns an appropriate
    match object for the leftmost substring of *s*, starting not before index start
    and not reaching as far as index end, that matches *r*. When no such substring
    exists, search returns **None**. For example, to print all lines containing digits,
    one simple approach is as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '| search | *r*.search(*s*, start=0, end=sys.maxsize) 返回 *s* 的左侧子字符串的适当匹配对象，其起始位置不早于索引
    start，且不达到索引 end，并与 *r* 匹配。当不存在这样的子字符串时，search 返回 **None**。例如，要打印包含数字的所有行，一个简单的方法如下:'
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| split | *r*.split(*s*, maxsplit=0) Returns a list *L* of the *splits* of
    *s* by *r* (i.e., the substrings of *s* separated by nonoverlapping, nonempty
    matches with *r*). For example, here’s a way to eliminate all occurrences of ''hello''
    (in any mix of lowercase and uppercase) from a string:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '| split | *r*.split(*s*, maxsplit=0) 返回一个由 *s* 的 *r* 分割的列表 *L*（即由与 *r* 非重叠、非空匹配分隔的
    *s* 的子字符串）。例如，这是一种从字符串中消除所有出现的 ''hello''（不管大小写）的方法:'
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When *r* has *n* groups, *n* more items are interleaved in *L* between each
    pair of splits. Each of the *n* extra items is the substring of *s* that matches
    *r*’s corresponding group in that match, or **None** if that group did not participate
    in the match. For example, here’s one way to remove whitespace only when it occurs
    between a colon and a digit:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '当 *r* 有 *n* 组时，在 *L* 的每一对分割之间，*n* 个额外的项被交错插入。每个额外的项是 *s* 中与 *r* 对应组匹配的子字符串，如果该组未参与匹配，则为
    **None**。例如，这是一种仅在冒号和数字之间出现空白时删除空白的方法:'
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If maxsplit is greater than 0, at most maxsplit splits are in *L*, each followed
    by *n* items, while the trailing substring of *s* after maxsplit matches of *r*,
    if any, is *L*’s last item. For example, to remove only the *first* occurrence
    of substring ''hello'' rather than *all* of them, change the last statement in
    the first example here to:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 maxsplit 大于 0，则 *L* 中最多有 maxsplit 个分割，每个分割后跟随 *n* 项，而 *s* 的最后一个匹配 *r* 的尾随子字符串（如果有的话）是
    *L* 的最后一项。例如，要仅删除子字符串 ''hello'' 的第一个出现而不是全部出现，将第一个示例中的最后一条语句更改为:'
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| sub | *r*.sub(*repl*, *s*, count=0) Returns a copy of *s* where nonoverlapping
    matches with *r* are replaced by *repl*, which can be either a string or a callable
    object, such as a function. An empty match is replaced only when not adjacent
    to the previous match. When count is greater than 0, only the first count matches
    of *r* within *s* are replaced. When count equals 0, all matches of *r* within
    *s* are replaced. For example, here’s another, more natural way to remove only
    the first occurrence of substring ''hello'' in any mix of cases:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '| sub | *r*.sub(*repl*, *s*, count=0) 返回一个 *s* 的副本，其中与 *r* 非重叠的匹配项被 *repl*
    替换，*repl* 可以是字符串或可调用对象（如函数）。只有当空匹配不紧邻前一个匹配时，才替换空匹配。当 count 大于 0 时，仅替换 *s* 中前 count
    次出现的 *r*。当 count 等于 0 时，替换 *s* 中所有的 *r* 匹配。例如，这是另一种更自然的方法，用于从任意大小写混合的字符串中仅删除子字符串
    ''hello'' 的第一个出现:'
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Without the final 1 (one) argument to sub, the example removes all occurrences
    of 'hello'.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 未提供 sub 的最后一个参数 1（一个），示例将删除所有 'hello' 的出现。
- en: 'When *repl* is a callable object, *repl* must accept one argument (a match
    object) and return a string (or **None**, which is equivalent to returning the
    empty string '''') to use as the replacement for the match. In this case, sub
    calls *repl*, with a suitable match object argument, for each match with *r* that
    sub is replacing. For example, here’s one way to uppercase all occurrences of
    words starting with ''h'' and ending with ''o'' in any mix of cases:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '当 *repl* 是一个可调用对象时，*repl* 必须接受一个参数（匹配对象），并返回一个字符串（或 **None**，等效于返回空字符串 ''''）作为匹配的替换内容。在这种情况下，sub
    对每个与 *r* 匹配并替换的匹配调用 *repl*，并使用适当的匹配对象参数。例如，这是一种大写所有以 ''h'' 开头并以 ''o'' 结尾的单词的所有出现的方法:'
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '|'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| sub *(cont.)* | When *repl* is a string, sub uses *repl* itself as the replacement,
    except that it expands backreferences. A *backreference* is a substring of *repl*
    of the form \g<*id*>, where *id* is the name of a group in *r* (established by
    the syntax (?P<*id*>...) in *r*’s pattern string) or \dd, where *dd* is one or
    two digits taken as a group number. Each back reference, named or numbered, is
    replaced with the substring of *s* that matches the group of *r* that the back
    reference indicates. For example, here’s a way to enclose every word in braces:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '| sub *(续)* | 当*repl*是一个字符串时，sub使用*repl*本身作为替换，除了它会扩展反向引用。反向引用是*repl*中形式为 \g<*id*>
    的子串，其中*id*是*r*中的一个组的名称（由*r*的模式字符串中的 (?P<*id*>...) 语法确定），或者 \dd，其中*dd*被视为一个组编号，可以是一位或两位数字。每个命名或编号的反向引用都将被替换为与所指示的*r*组匹配的*s*的子串。例如，这是一种在每个单词周围加上大括号的方法：'
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '|'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| subn | *r*.subn(*repl*, *s*, count=0) subn is the same as sub, except that
    subn returns a pair (*new_string*, *n*), where *n* is the number of substitutions
    that subn has performed. For example, here’s one way to count the number of occurrences
    of substring ''hello'' in any mix of cases:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '| subn | *r*.subn(*repl*, *s*, count=0) subn与sub相同，只是subn返回一对（*new_string*，*n*），其中*n*是subn执行的替换数。例如，这是一种计算任何大小写混合中子字符串
    ''hello'' 出现次数的方法：'
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Match Objects
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配对象
- en: '*Match objects* are created and returned by the methods fullmatch, match, and
    search of a regular expression object, and are the items of the iterator returned
    by the method finditer. They are also implicitly created by the methods sub and
    subn when the argument *repl* is callable, since in that case the appropriate
    match object is passed as the only argument on each call to *repl*. A match object
    *m* supplies the following read-only attributes that detail how search or match
    created *m*, listed in [Table 10-4](#attributes_of_match_objects).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*匹配对象*由正则表达式对象的方法fullmatch、match和search创建并返回，并且是方法finditer返回的迭代器的项。当*repl*是可调用的时，它们也是方法sub和subn隐式创建的，因为在这种情况下，适当的匹配对象在每次调用*repl*时作为唯一参数传递。匹配对象*m*提供了以下只读属性，详细说明了搜索或匹配如何创建*m*，见
    [Table 10-4](#attributes_of_match_objects)。'
- en: Table 10-4\. Attributes of match objects
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Table 10-4\. 匹配对象的属性
- en: '| pos | The *start* argument that was passed to search or match (i.e., the
    index into *s* where the search for a match began) |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| pos | 传递给search或match的*start*参数（即，在*s*中开始匹配的索引） |'
- en: '| endpos | The *end* argument that was passed to search or match (i.e., the
    index into *s* before which the matching substring of *s* had to end) |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| endpos | 传递给search或match的*end*参数（即，匹配子串*s*必须结束的*s*中的索引） |'
- en: '| lastgroup | The name of the last-matched group (**None** if the last-matched
    group has no name, or if no group participated in the match) |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| lastgroup | 最后匹配的组的名称（如果最后匹配的组没有名称或者没有组参与匹配，则为**None**） |'
- en: '| lastindex | The integer index (1 and up) of the last-matched group (**None**
    if no group participated in the match) |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| lastindex | 最后匹配的组的整数索引（如果没有组参与匹配，则为**None**） |'
- en: '| re | The RE object *r* whose method created *m* |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| re | 创建*m*的方法所创建的RE对象*r* |'
- en: '| string | The string *s* passed to finditer, fullmatch, match, search, sub,
    or subn |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| string | 传递给finditer、fullmatch、match、search、sub或subn的字符串*s* |'
- en: In addition, match objects supply the methods detailed in [Table 10-5](#methods_of_match_objects).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，匹配对象提供了 [Table 10-5](#methods_of_match_objects) 中详细介绍的方法。
- en: Table 10-5\. Methods of match objects
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Table 10-5\. 匹配对象的方法
- en: '| end, span,'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '| end, span,'
- en: start | *m*.end(groupid=0), *m*.span(groupid=0),
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: start | *m*.end(groupid=0), *m*.span(groupid=0),
- en: '*m*.start(groupid=0)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*m*.start(groupid=0)'
- en: These methods return indices within *m*.string of the substring that matches
    the group identified by *groupid* (a group number or name; 0, the default value
    for groupid, means “the whole RE”). When the matching substring is *m*.string[*i*:*j*],
    *m*.start returns *i*, *m*.end returns *j*, and *m*.span returns (*i*, *j*). If
    the group did not participate in the match, *i* and *j* are -1. |
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法返回*m*.string中与*groupid*（组号或名称；0，groupid的默认值，表示“整个RE”）标识的组匹配的子串的索引。当匹配的子串是*m*.string[*i*:*j*]时，*m*.start返回*i*，*m*.end返回*j*，*m*.span返回(*i*，*j*)。如果该组没有参与匹配，则*i*和*j*均为-1。
    |
- en: '| expand | *m*.expand(*s*) Returns a copy of *s* where escape sequences and
    backreferences are replaced in the same way as for the method *r*.sub, covered
    in [Table 10-3](#methods_of_re_objects). |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| expand | *m*.expand(*s*) 返回一个副本，其中转义序列和反向引用的替换方式与方法*r*.sub中描述的方式相同，见 [Table 10-3](#methods_of_re_objects)。
    |'
- en: '| group | *m*.group(groupid=0, **groupids*) Called with a single argument groupid
    (a group number or name), *m*.group returns the substring matching the group identified
    by groupid, or **None** when that group did not participate in the match. *m*.group()—or
    *m*.group(0)—returns the whole matched substring (group 0 means the whole RE).
    Groups can also be accessed using *m*[*index*] notation, as if called using *m*.group(*index*)
    (in either case, *index* may be an int or a str).'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '| group | *m*.group(groupid=0, **groupids*) 使用单个参数 groupid（组号或名称），*m*.group
    返回与由 groupid 标识的组匹配的子字符串，如果该组没有参与匹配，则返回 **None**。*m*.group()—或 *m*.group(0)—返回整个匹配的子字符串（组
    0 表示整个 RE）。也可以使用 *m*[*index*] 访问组，就像使用 *m*.group(*index*) 调用一样（在任一情况下，*index*
    可以是 int 或 str）。'
- en: When group is called with multiple arguments, each argument must be a group
    number or name. group then returns a tuple with one item per argument, the substring
    matching the corresponding group, or **None** when that group did not participate
    in the match. |
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当 group 以多个参数调用时，每个参数必须是组号或名称。然后，group 返回一个元组，每个参数一个项目，对应组匹配的子字符串，如果该组没有参与匹配，则返回
    **None**。
- en: '| groupdict | *m*.groupdict(default=**None**) Returns a dictionary whose keys
    are the names of all named groups in *r*. The value for each name is the substring
    that matches the corresponding group, or default if that group did not participate
    in the match. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| groupdict | *m*.groupdict(default=**None**) 返回一个字典，其键是 *r* 中所有命名组的名称。每个名称的值是与相应组匹配的子字符串，如果该组没有参与匹配，则为默认值。
    |'
- en: '| groups | *m*.groups(default=**None**) Returns a tuple with one item per group
    in *r*. Each item is the substring matching the corresponding group, or default
    if that group did not participate in the match. The tuple does not include the
    0 group representing the full pattern match. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| groups | *m*.groups(default=**None**) 返回一个元组，其中包含 *r* 中每个组的一个项目。每个项目是与相应组匹配的子字符串，如果该组没有参与匹配，则为默认值。元组不包括表示完整模式匹配的
    0 组。 |'
- en: Functions of the re Module
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: re 模块的函数
- en: 'In addition to the attributes listed in [“Optional Flags”](#optional_flags),
    the re module provides one function for each method of a regular expression object
    (findall, finditer, fullmatch, match, search, split, sub, and subn, described
    in [Table 10-3](#methods_of_re_objects)), each with an additional first argument,
    a pattern string that the function implicitly compiles into an RE object. It is
    usually better to compile pattern strings into RE objects explicitly and call
    the RE object’s methods, but sometimes, for a one-off use of an RE pattern, calling
    functions of the module re can be handier. For example, to count the number of
    occurrences of ''hello'' in any mix of cases, one concise, function-based way
    is:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 [“可选标志”](#optional_flags) 中列出的属性之外，re 模块还为正则表达式对象的每个方法提供了一个函数（findall、finditer、fullmatch、match、search、split、sub
    和 subn，在 [表 10-3](#methods_of_re_objects) 中描述），每个函数都有一个额外的第一个参数，即模式字符串，该函数隐式编译为
    RE 对象。通常最好显式地将模式字符串编译为 RE 对象并调用 RE 对象的方法，但有时，对于一次性使用 RE 模式，调用 re 模块的函数可能更方便。例如，要计算任何大小写混合中
    'hello' 出现的次数，一种简洁的、基于函数的方法是：
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The re module internally caches RE objects it creates from the patterns passed
    to functions; to purge the cache and reclaim some memory, call re.purge.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: re 模块在内部缓存从传递给函数的模式创建的 RE 对象；要清除缓存并回收一些内存，调用 re.purge。
- en: The re module also supplies error, the class of exceptions raised upon errors
    (generally, errors in the syntax of a pattern string), and two more functions,
    listed in [Table 10-6](#additional_re_functions).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: re 模块还提供了 error，即在出错时引发的异常类（通常是模式字符串的语法错误），以及另外两个函数，在 [表 10-6](#additional_re_functions)
    中列出。
- en: Table 10-6\. Additional re functions
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10-6\. 其他 re 函数
- en: '| compile | compile(*pattern*, flags=0) Creates and returns an RE object, parsing
    the string *pattern*, as per the syntax covered in [“Pattern String Syntax”](#pattern_string_syntax),
    and using integer flags, as described in [“Optional Flags”](#optional_flags) |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| compile | compile(*pattern*, flags=0) 创建并返回一个 RE 对象，解析字符串 *pattern*，其语法如
    [“模式字符串语法”](#pattern_string_syntax) 中所述，并使用整数标志，如 [“可选标志”](#optional_flags) 中所描述
    |'
- en: '| escape | escape(*s*) Returns a copy of string *s* with each nonalphanumeric
    character escaped (i.e., preceded by a backslash, \); useful to match string *s*
    literally as part of an RE pattern string |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| escape | escape(*s*) 返回字符串 *s* 的副本，其中每个非字母数字字符都被转义（即，在其前面加上反斜杠，\）；这对于将字符串
    *s* 作为 RE 模式字符串的一部分进行文字匹配非常有用 |'
- en: REs and the := Operator
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RE 和 := 运算符
- en: The introduction of the := operator in Python 3.8 established support for a
    successive-match idiom in Python similar to the one that’s common in Perl. In
    this idiom, a series of **if**/**elsif** branches tests a string against different
    regular expressions. In Perl, the **if** ($var =~ /regExpr/) statement both evaluates
    the regular expression and saves the successful match in the variable var:^([1](ch10.xhtml#ch01fn98))
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3.8 中引入的 := 操作符支持了一种类似于 Perl 中常见的连续匹配习语。在这种习语中，一系列的 **if**/**elsif**
    分支根据不同的正则表达式测试字符串。在 Perl 中，**if** ($var =~ /regExpr/) 语句既评估正则表达式，又将成功的匹配保存在变量
    var 中：^([1](ch10.xhtml#ch01fn98))
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Prior to Python 3.8, this evaluate-and-store behavior was not possible in a
    single **if**/**elif** statement; developers had to use a cumbersome cascade of
    nested **if**/**else** statements:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3.8 之前，这种评估和存储行为在单个 **if**/**elif** 语句中是不可能的；开发者必须使用繁琐的嵌套 **if**/**else**
    语句级联：
- en: '[PRE32]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Using the := operator, this code simplifies to:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 := 操作符，此代码简化为：
- en: '[PRE33]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The Third-Party regex Module
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三方 regex 模块
- en: 'As an alternative to the Python standard library’s re module, a popular package
    for regular expressions is the third-party [regex module](https://oreil.ly/2wV-d),
    by Matthew Barnett. regex has an API that’s compatible with the re module and
    adds a number of extended features, including:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Python 标准库 re 模块的替代方案，第三方正则表达式包 [regex module](https://oreil.ly/2wV-d)，由
    Matthew Barnett 开发，非常流行。regex 提供与 re 模块兼容的 API，并添加了多种扩展功能，包括：
- en: Recursive expressions
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归表达式
- en: Defining character sets by Unicode property/value
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 Unicode 属性/值定义字符集
- en: Overlapping matches
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重叠匹配
- en: Fuzzy matching
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊匹配
- en: Multithreading support (releases GIL during matching)
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多线程支持（在匹配期间释放 GIL）
- en: Matching timeout
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配超时
- en: Unicode case folding in case-insensitive matches
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unicode 不区分大小写匹配中的大小写折叠
- en: Nested sets
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套集合
- en: ^([1](ch10.xhtml#ch01fn98-marker)) This example is taken from regex; see [“Match
    groups in Python” on Stack Overflow](https://oreil.ly/czLsu).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch10.xhtml#ch01fn98-marker)) 此示例取自正则表达式；参见[“Python 中的匹配组”](https://oreil.ly/czLsu)在
    Stack Overflow 上的讨论。
