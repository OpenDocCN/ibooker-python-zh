- en: Chapter 1\. The Modern Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Web as I envisaged it, we have not seen it yet. The future is still so much
    bigger than the past.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Tim Berners-Lee
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Preview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once upon a time, the web was small and simple. Developers had such fun throwing
    PHP, HTML, and MySQL calls into single files and proudly telling everyone to check
    out their website. But the web grew over time to zillions, nay, squillions of
    pages—and the early playground became a metaverse of theme parks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I’ll point out some areas that have become ever more relevant
    to the modern web:'
  prefs: []
  type: TYPE_NORMAL
- en: Services and APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next chapter will show what Python offers in these areas. After that, we’ll
    dive into the FastAPI web framework and see what it has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: Services and APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The web is a great connecting fabric. Although much activity still occurs on
    the *content* side—HTML, JavaScript, images, and so on—there’s an increasing emphasis
    on the application programming interfaces (APIs) that connect things.
  prefs: []
  type: TYPE_NORMAL
- en: Commonly, a web *service* handles low-level database access and middle-level
    business logic (often lumped together as a *backend*), while JavaScript or mobile
    apps provide a rich top-level *frontend* (interactive user interface). These fore
    and aft worlds have become more complex and divergent, usually requiring developers
    to specialize in one or the other. It’s harder to be a *full stack* developer
    than it used to be.^([1](ch01.html#id336))
  prefs: []
  type: TYPE_NORMAL
- en: These two worlds talk to each other using APIs. In the modern web, API design
    is as important as the design of websites themselves. An API is a contract, similar
    to a database schema. Defining and modifying APIs is now a major job.
  prefs: []
  type: TYPE_NORMAL
- en: Kinds of APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each API defines the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Protocol
  prefs: []
  type: TYPE_NORMAL
- en: The control structure
  prefs: []
  type: TYPE_NORMAL
- en: Format
  prefs: []
  type: TYPE_NORMAL
- en: The content structure
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple API methods have developed as technology has evolved from isolated
    machines, to multitasking systems, to networked servers. You’ll probably run across
    one or more of these at some point, so the following is a brief summary before
    getting to *HTTP* and its friends, which are featured in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: Before networking, an API usually meant a very close connection, like a function
    call to a *library* in the same language as your application—say, calculating
    a square root in a math library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Remote procedure calls (RPCs)* were invented to call functions in other processes,
    on the same machine or others, as though they were in the calling application.
    A popular current example is [gRPC](https://grpc.io).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Messaging* sends small chunks of data in pipelines among processes. Messages
    may be verb-like commands or may just indicate noun-like *events* of interest.
    Current popular messaging solutions, which vary broadly from toolkits to full
    servers, include [Apache Kafka](https://kafka.apache.org), [RabbitMQ](https://www.rabbitmq.com),
    [NATS](https://nats.io), and [ZeroMQ](https://zeromq.org). Communication can follow
    different patterns:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request-response
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'One: one, like a web browser calling a web server.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Publish-subscribe, or *pub-sub*
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A *publisher* emits messages, and *subscribers* act on each according to some
    data in the message, like a subject.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Queues
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Like pub-sub, but only one of a pool of subscribers grabs the message and acts
    on it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Any of these may be used alongside a web service—for example, performing a slow
    backend task like sending an email or creating a thumbnail image.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Berners-Lee proposed three components for his World Wide Web:'
  prefs: []
  type: TYPE_NORMAL
- en: HTML
  prefs: []
  type: TYPE_NORMAL
- en: A language for displaying data
  prefs: []
  type: TYPE_NORMAL
- en: HTTP
  prefs: []
  type: TYPE_NORMAL
- en: A client-server protocol
  prefs: []
  type: TYPE_NORMAL
- en: URLs
  prefs: []
  type: TYPE_NORMAL
- en: An addressing scheme for web resources
  prefs: []
  type: TYPE_NORMAL
- en: Although these seem obvious in retrospect, they turned out to be a ridiculously
    useful combination. As the web evolved, people experimented, and some ideas, like
    the `IMG` tag, survived the Darwinian struggle. And as needs became clearer, people
    got serious about defining standards.
  prefs: []
  type: TYPE_NORMAL
- en: REST(ful)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One chapter in Roy Fielding’s Ph.D. [thesis](https://oreil.ly/TwGmX) defined
    *Representational State Transfer (REST)*—an *architectural style* for HTTP use.^([2](ch01.html#id357))
    Although often referenced, it’s been largely [misunderstood](https://oreil.ly/bsSry).
  prefs: []
  type: TYPE_NORMAL
- en: 'A roughly shared adaptation has evolved and dominates the modern web. It’s
    called *RESTful*, with these characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Uses HTTP and client-server protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stateless (each connection is independent)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cacheable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource-based
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *resource* is data that you can distinguish and perform operations on. A web
    service provides an *endpoint*—a distinct URL and HTTP *verb* (action)—for each
    feature that it wants to expose. An endpoint is also called a *route*, because
    it routes the URL to a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Database users are familiar with the *CRUD* acronym of procedures: create,
    read, update, delete. The HTTP verbs are pretty CRUDdy:'
  prefs: []
  type: TYPE_NORMAL
- en: '`POST`'
  prefs: []
  type: TYPE_NORMAL
- en: Create (write)
  prefs: []
  type: TYPE_NORMAL
- en: '`PUT`'
  prefs: []
  type: TYPE_NORMAL
- en: Modify completely (replace)
  prefs: []
  type: TYPE_NORMAL
- en: '`PATCH`'
  prefs: []
  type: TYPE_NORMAL
- en: Modify partially (update)
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`'
  prefs: []
  type: TYPE_NORMAL
- en: Um, get (read, retrieve)
  prefs: []
  type: TYPE_NORMAL
- en: '`DELETE`'
  prefs: []
  type: TYPE_NORMAL
- en: Uh, delete
  prefs: []
  type: TYPE_NORMAL
- en: 'A client sends a *request* to a RESTful endpoint with data in one of the following
    areas of an HTTP message:'
  prefs: []
  type: TYPE_NORMAL
- en: Headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The URL string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Body values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In turn, an HTTP *response* returns these:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An integer [*status code*](https://oreil.ly/oBena) indicating the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 100s
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Info, keep going
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 200s
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Success
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 300s
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Redirection
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 400s
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Client error
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 500s
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Server error
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Various headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A body, which may be empty, single, or *chunked* (in successive pieces)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At least one status code is an Easter egg: `418` (I’m a [teapot](https://www.google.com/teapot))
    is supposed to be returned by a web-connected teapot, if asked to brew coffee.'
  prefs: []
  type: TYPE_NORMAL
- en: '![fapi 01in01](assets/fapi_01in01.png)'
  prefs: []
  type: TYPE_IMG
- en: You’ll find many websites and books on RESTful API design, all with useful rules
    of thumb. This book will dole some out on the way.
  prefs: []
  type: TYPE_NORMAL
- en: JSON and API Data Formats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Frontend applications can exchange plain ASCII text with backend web services,
    but how can you express data structures like lists of things?
  prefs: []
  type: TYPE_NORMAL
- en: Just about when we really started to need it, along came *JavaScript Object
    Notation (JSON)*—another simple idea that solves an important problem and seems
    obvious with hindsight. Although the *J* stands for *JavaScript*, the syntax looks
    a lot like Python too.
  prefs: []
  type: TYPE_NORMAL
- en: JSON has largely replaced older attempts like XML and SOAP. In the rest of this
    book, you’ll see that JSON is the default web service input and output format.
  prefs: []
  type: TYPE_NORMAL
- en: JSON:API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The combination of RESTful design and JSON data formats is common now. But some
    wiggle room still remains for ambiguity and nerd tussles. The recent [JSON:API](https://jsonapi.org)
    proposal aims to tighten specs a bit. This book will use the loose RESTful approach,
    but JSON:API or something similarly rigorous may be useful if you have significant
    tussles.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RESTful interfaces can be cumbersome for some purposes. Facebook (now Meta)
    designed [Graph Query Language (*GraphQL*)](https://graphql.org) to specify more
    flexible service queries. I won’t go into GraphQL in this book, but you may want
    to look into it if you find RESTful design inadequate for your application.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides the growth of service orientation, the rapid expansion of the number
    of connections to web services requires ever better efficiency and scale.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to reduce the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Latency
  prefs: []
  type: TYPE_NORMAL
- en: The up-front wait time
  prefs: []
  type: TYPE_NORMAL
- en: Throughput
  prefs: []
  type: TYPE_NORMAL
- en: The number of bytes per second between the service and its callers
  prefs: []
  type: TYPE_NORMAL
- en: In the old web days,^([3](ch01.html#id369)) people dreamed of supporting hundreds
    of simultaneous connections, then fretted about the “10K problem,” and now assume
    millions at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The term *concurrency* doesn’t mean full parallelism. Multiple processing isn’t
    occurring in the same nanosecond, in a single CPU. Instead, concurrency mostly
    avoids *busy waiting* (idling the CPU until a response is delivered). CPUs are
    zippy, but networks and disks are thousands to millions of times slower. So, whenever
    we talk to a network or disk, we don’t want to just sit there with a blank stare
    until it responds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normal Python execution is *synchronous*: one thing at a time, in the order
    specified by the code. Sometimes we want to be *asynchronous*: do a little of
    one thing, then a little of another thing, back to the first thing, and so on.
    If all our code uses the CPU to calculate things (*CPU bound*), there’s really
    no spare time to be asynchronous. But if we perform something that makes the CPU
    wait for an external thing to complete (I/O bound), we can be asynchronous.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Asynchronous systems provide an *event loop*: requests for slow operations
    are sent and noted, but we don’t hold up the CPU waiting for their responses.
    Instead, some immediate processing is done on each pass through the loop, and
    any responses that came in during that time are handled in the next pass.'
  prefs: []
  type: TYPE_NORMAL
- en: The effects can be dramatic. Later in this book, you’ll see how FastAPI’s support
    of asynchronous processing makes it much faster than typical web frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous processing isn’t magic. You still have to be careful to avoid doing
    too much CPU-intensive work during the event loop, because that will slow down
    everything. Later in this book, you’ll see the uses of Python’s `async` and `await`
    keywords, and how FastAPI lets you mix both synchronous and asynchronous processing.
  prefs: []
  type: TYPE_NORMAL
- en: Layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Shrek* fans may remember he noted his layers of personality, to which Donkey
    replied, “Like an onion?”'
  prefs: []
  type: TYPE_NORMAL
- en: '![fapi 01in02](assets/fapi_01in02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Well, if ogres and tearful vegetables can have layers, then so can software.
    To manage size and complexity, many applications have long used a so-called *three-tier
    model*.^([4](ch01.html#id377)) This isn’t terribly new. Terms differ,^([5](ch01.html#id378))
    but for this book I’m using the following simple separation of terms (see [Figure 1-1](#fig-vert-layers)):'
  prefs: []
  type: TYPE_NORMAL
- en: Web
  prefs: []
  type: TYPE_NORMAL
- en: Input/output layer over HTTP, which assembles client requests, calls the Service
    Layer, and returns responses
  prefs: []
  type: TYPE_NORMAL
- en: Service
  prefs: []
  type: TYPE_NORMAL
- en: The business logic, which calls the Data layer when needed
  prefs: []
  type: TYPE_NORMAL
- en: Data
  prefs: []
  type: TYPE_NORMAL
- en: Access to data stores and other services
  prefs: []
  type: TYPE_NORMAL
- en: Model
  prefs: []
  type: TYPE_NORMAL
- en: Data definitions shared by all layers
  prefs: []
  type: TYPE_NORMAL
- en: Web client
  prefs: []
  type: TYPE_NORMAL
- en: Web browser or other HTTP client-side software
  prefs: []
  type: TYPE_NORMAL
- en: Database
  prefs: []
  type: TYPE_NORMAL
- en: The data store, often an SQL or NoSQL server
  prefs: []
  type: TYPE_NORMAL
- en: '![fapi 0101](assets/fapi_0101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-1\. Vertical layers
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: These components will help you scale your site without having to start from
    scratch. They’re not laws of quantum mechanics, so consider them guidelines for
    this book’s exposition.
  prefs: []
  type: TYPE_NORMAL
- en: The layers talk to one another via APIs. These can be simple function calls
    to separate Python modules, but could access external code via any method. As
    I showed earlier, this could include RPCs, messages, and so on. In this book,
    I’m assuming a single web server, with Python code importing other Python modules.
    The separation and information hiding is handled by the modules.
  prefs: []
  type: TYPE_NORMAL
- en: The *Web layer* is the one that users see, via *client* applications and APIs.
    We’re usually talking about a RESTful web interface, with URLs, and JSON-encoded
    requests and responses. But alternative text (or command-line interface, CLI)
    clients also could be built alongside the Web layer. Python Web code may import
    Service-layer modules but should not import Data modules.
  prefs: []
  type: TYPE_NORMAL
- en: The *Service layer* contains the actual details of whatever this website provides.
    This layer essentially looks like a *library*. It imports Data modules to access
    databases and external services but should not know the details.
  prefs: []
  type: TYPE_NORMAL
- en: The *Data layer* provides the Service layer access to data, through files or
    client calls to other services. Alternative Data layers may also exist, communicating
    with a single Service layer.
  prefs: []
  type: TYPE_NORMAL
- en: The *Model box* isn’t an actual layer but a source of data definitions shared
    by the layers. This isn’t needed if you’re passing built-in Python data structures
    among them. As you will see, FastAPI’s inclusion of Pydantic enables the definition
    of data structures with many useful features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why make these divisions? Among many reasons, each layer can be:'
  prefs: []
  type: TYPE_NORMAL
- en: Written by specialists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tested in isolation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Replaced or supplemented: you might add a second Web layer, using a different
    API such as gRPC, alongside a web one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follow one rule from *Ghostbusters*: Don’t cross the streams. That is, don’t
    let web details leak out of the Web layer, or database details out of the Data
    layer.'
  prefs: []
  type: TYPE_NORMAL
- en: You can visualize *layers* as a vertical stack, like a cake in the Great British
    Bake Off.^([6](ch01.html#id392))
  prefs: []
  type: TYPE_NORMAL
- en: '![fapi 01in03](assets/fapi_01in03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are some reasons for separation of the layers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t separate the layers, expect a hallowed web meme: *Now you have
    two problems*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the layers are mixed, later separation will be *very* difficult.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll need to know two or more specialties to understand and write tests if
    code logic gets muddled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the way, even though I call them *layers*, you don’t need to assume that
    one layer is “above” or “below” another, and that commands flow with gravity.
    Vertical chauvinism! You could also view layers as sideways-communicating boxes
    ([Figure 1-2](#fig-horiz-layers)).
  prefs: []
  type: TYPE_NORMAL
- en: '![fapi 0102](assets/fapi_0102.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-2\. Sideways-communicating boxes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: However you visualize them, the *only* communication paths between the boxes/layers
    are the arrows (APIs). This is important for testing and debugging. If undocumented
    doors exist in a factory, the night watchman will inevitably be surprised.
  prefs: []
  type: TYPE_NORMAL
- en: The arrows between the web client and Web layer use HTTP or HTTPS to transport
    mostly JSON text. The arrows between the Data layer and database use a database-specific
    protocol and carry SQL (or other) text. The arrows between the layers themselves
    are function calls carrying data models.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the recommended data formats flowing through the arrows are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Client ⇔ Web
  prefs: []
  type: TYPE_NORMAL
- en: RESTful HTTP with JSON
  prefs: []
  type: TYPE_NORMAL
- en: Web ⇔ Service
  prefs: []
  type: TYPE_NORMAL
- en: Models
  prefs: []
  type: TYPE_NORMAL
- en: Service ⇔ Data
  prefs: []
  type: TYPE_NORMAL
- en: Models
  prefs: []
  type: TYPE_NORMAL
- en: Data ⇔ Databases and services
  prefs: []
  type: TYPE_NORMAL
- en: Specific APIs
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on my own experience, this is how I’ve chosen to structure the topics
    in this book. It’s workable and has scaled to fairly complex sites, but isn’t
    sacred. You may have a better design! However you do it, these are the important
    points:'
  prefs: []
  type: TYPE_NORMAL
- en: Separate domain-specific details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define standard APIs between the layers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t cheat; don’t leak.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes deciding which layer is the best home for code is a challenge. For
    example, [Chapter 11](ch11.html#ch11) looks at authentication and authorization
    requirements and how to implement them—as an extra layer between Web and Service,
    or within one of them. Software development is sometimes as much art as science.
  prefs: []
  type: TYPE_NORMAL
- en: Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The web has often been used as a frontend to relational databases, although
    many other ways of storing and accessing data have evolved, such as NoSQL or NewSQL
    databases.
  prefs: []
  type: TYPE_NORMAL
- en: But beyond databases, *machine learning (ML)*—or *deep learning* or just *AI*—is
    fundamentally remaking the technology landscape. The development of large models
    requires *lots* of messing with data, which has traditionally been called extract,
    transform, load (ETL).
  prefs: []
  type: TYPE_NORMAL
- en: As a general-purpose service architecture, the web can help with many of the
    fiddly bits of ML systems.
  prefs: []
  type: TYPE_NORMAL
- en: Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The web uses many APIs, but especially RESTful ones. Asynchronous calls allow
    better concurrency, which speeds up the overall process. Web service applications
    are often large enough to divide into layers. Data has become a major area in
    its own right. All these concepts are addressed in the Python programming language,
    coming in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch01.html#id336-marker)) I gave up trying a few years ago.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch01.html#id357-marker)) *Style* means a higher-level pattern, like *client-server*,
    rather than a specific design.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch01.html#id369-marker)) Around when caveman played hacky sack with giant
    ground sloths.
  prefs: []
  type: TYPE_NORMAL
- en: '^([4](ch01.html#id377-marker)) Choose your own dialect: tier/layer, tomato/tomahto/arigato.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch01.html#id378-marker)) You’ll often see the term *Model-View-Controller
    (MVC)* and variations. Commonly accompanied by religious wars, toward which I’m
    agnostic.
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch01.html#id392-marker)) As viewers know, if your layers get sloppy, you
    may not return to the tent the next week.
  prefs: []
  type: TYPE_NORMAL
