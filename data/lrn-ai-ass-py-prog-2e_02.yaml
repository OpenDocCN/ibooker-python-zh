- en: 3 Designing functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 设计函数
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章内容包括
- en: Functions in Python and their role in designing software
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 中的函数及其在软件设计中的角色
- en: The standard workflow when interacting with Copilot
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Copilot 互动的标准工作流程
- en: Examples of writing good functions using Copilot
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Copilot 编写良好函数的示例
- en: Reasonable tasks for Copilot to solve
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Copilot可以解决的合理任务
- en: One of the hardest challenges for programming novices is to know what a reasonable
    task is to give to Copilot so that it finds a good solution. If you give Copilot
    too big of a task, it will often fail in spectacular ways that can be extremely
    difficult to fix. What, then, is a reasonable task?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 编程新手面临的最大挑战之一就是如何知道给 Copilot 提供一个合理的任务，以便它能够找到一个好的解决方案。如果你给 Copilot 一个过于庞大的任务，它通常会以一种极为壮观的方式失败，这往往是非常难以修复的。那么，什么样的任务才是合理的呢？
- en: This question is important for our use of Copilot but goes far beyond it. Human
    programmers struggle with complexity too. If experienced software engineers try
    to write code to solve a problem that’s too complex without breaking it down into
    smaller, more solvable subparts, they often have trouble as well. The solution
    for humans has been to use something called a *function,* whose job is to perform
    one task. Functions help us organize our code and make it easier to think about
    and fix any bugs. There are various rules of thumb for how to write a reasonable
    function in terms of number of lines of code, but, fundamentally, these rules
    try to capture writing something that (1) performs a single task and (2) isn’t
    so complex that it’s hard to get right.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题对我们使用 Copilot 很重要，但远远超出了这个范畴。人类程序员同样也在与复杂性作斗争。如果经验丰富的软件工程师试图编写代码来解决一个过于复杂的问题，而没有将其拆解成更小、更易解决的子问题，他们通常也会遇到麻烦。人类的解决方案是使用一种叫做*函数*的东西，它的工作是执行一项任务。函数帮助我们组织代码，使其更容易理解并修复任何错误。关于如何编写合理的函数，通常有一些经验法则，特别是在代码行数方面，但从根本上说，这些规则试图确保编写的东西（1）执行一个单一的任务，（2）不至于复杂到难以正确实现。
- en: For people who learned to program the old-fashioned way, without Copilot, they
    may have struggled with syntax in code that’s 5–10 lines long before being introduced
    to functions. At that point, it’s natural for them to understand through experience
    that they shouldn’t write more code in a single function than they can handle
    testing and debugging. Because you’re learning to work with Copilot rather than
    syntax directly, our job in this chapter is to teach you about functions and what
    are considered reasonable and unreasonable tasks to ask Copilot to solve in a
    single function.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些通过传统方式学习编程的人来说，在接触函数之前，他们可能在写5到10行的代码时就已经为语法问题困扰。此时，他们通过经验自然地理解到，他们不应该在单一函数中写超过自己能测试和调试的代码。因为你正在学习与
    Copilot 一起工作，而不是直接与语法打交道，所以本章的任务是教你有关函数的知识，以及什么样的任务在 Copilot 中被视为合理或不合理的单一函数任务。
- en: To help you gain perspective on functions, we’ll provide you with a number of
    examples in this chapter. Those examples employ the central workflow of interacting
    with Copilot—specifically, the cycle of writing prompts, receiving code from Copilot,
    and testing to see whether that code is correct. In the functions produced by
    Copilot, you’ll begin to see the core programming tools, such as loops, conditionals,
    and lists, which we’ll expand on in the next two chapters.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你更好地理解函数，本章将提供多个示例。这些示例使用了与 Copilot 互动的核心工作流程——具体来说，就是编写提示、接收 Copilot 提供的代码，并测试代码是否正确。在
    Copilot 生成的函数中，你将开始看到核心编程工具，如循环、条件语句和列表等，这些内容将在接下来的两章中进一步扩展。
- en: 3.1 Functions
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 函数
- en: Before we can learn about the details of writing a function, we need some insight
    into their purpose in software. Functions are small tasks that help accomplish
    larger tasks, which, in turn, help solve larger tasks, and so forth. You probably
    already have a lot of intuition about breaking apart large tasks into smaller
    tasks. Let’s make that intuition concrete with an example.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习编写函数的细节之前，我们需要对函数在软件中的作用有一些基本的了解。函数是帮助完成更大任务的小任务，而这些大任务又帮助解决更复杂的任务，依此类推。你可能已经对将大任务拆解成小任务有了很多直觉。让我们通过一个示例将这一直觉具体化。
- en: Suppose you’ve found a word search puzzle in the newspaper that you’d like to
    solve (see figure 3.1 for an example puzzle). In these kinds of puzzles, you’re
    looking for each word in the word list. The words can be found going from left
    to right, right to left, top to bottom, or bottom to top.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在报纸上找到了一个字谜，并且想要解开它（请参见图 3.1 的示例谜题）。在这类谜题中，你需要找到字词列表中的每个单词。单词可以从左到右、从右到左、从上到下或从下到上查找。
- en: '![figure](../Images/3-1.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/3-1.png)'
- en: Figure 3.1 Example word search puzzle
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.1 示例字谜
- en: At a high level, your task is “find all the words in the word search.” Unfortunately,
    that description of the task isn’t helpful on its own. It doesn’t tell us what
    steps we need to take to solve the problem.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，你的任务是“找出字谜中的所有单词。”不幸的是，单独这样描述任务并没有帮助。它没有告诉我们需要采取哪些步骤来解决问题。
- en: Try working on the problem right now for a couple minutes. How did you start?
    How did you break down the overall task to make it more achievable?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试着花几分钟时间解决这个问题。你是如何开始的？你如何将整体任务分解成更容易实现的小任务？
- en: One thing you might do is say, “OK, finding every word is a big task, but a
    smaller task is just finding the first word (CAT). Let me work on that first!”
    This is an example of taking a large task and breaking it into smaller tasks.
    To solve the entire puzzle, then, you could repeat that smaller task for each
    word that you need to find.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以做的一件事是说：“好吧，找出所有单词是一个大任务，但一个更小的任务就是先找到第一个单词（CAT）。让我先做这个！”这就是将一个大任务分解为更小任务的一个例子。为了完成整个难题，你可以对每个需要找到的单词重复执行这个较小的任务。
- en: 'Now, how would we find an individual word, such as CAT? Even this task can
    be broken down further to make it easier to accomplish. For example, we could
    break it into four tasks: search for CAT from left to right, search for CAT from
    right to left, search for CAT from top to bottom, and search for CAT from bottom
    to top. Not only are we making simpler and simpler tasks, but we’re also organizing
    our work into logical pieces. Most importantly, as we’ll see throughout the chapter,
    it’s these simpler tasks whose code we’re going to ask Copilot to write and ultimately
    assemble into our complete programs.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何找到一个单独的单词，比如 CAT 呢？即使是这个任务，也可以进一步分解，以便更容易完成。例如，我们可以将其分解为四个任务：从左到右查找 CAT，从右到左查找
    CAT，从上到下查找 CAT，以及从下到上查找 CAT。我们不仅将任务变得越来越简单，而且还将工作组织成了逻辑性的部分。最重要的是，正如我们在本章中将看到的，正是这些更简单的任务的代码我们将要求
    Copilot 编写，并最终组装成我们的完整程序。
- en: Taking a large problem and dividing it into smaller tasks is called *problem
    decomposition,* which is such an important skill in software design that we’ve
    dedicated all of chapter 7 to it. For now, it’s essential to know when a task
    is too big to ask Copilot to complete it. Asking Copilot to make a new video game
    that’s a combination of Wordscapes meets Wordle isn’t going to work at all. However,
    you can get Copilot to write a function that’s important to solve a larger problem;
    for example, you might have a function that checks whether the word provided by
    the player is present in a list of valid words. Copilot can solve that problem
    well, and that function would help Copilot get closer to solving the larger problem.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个大问题分解成更小的任务被称为*问题分解*，这在软件设计中是一项非常重要的技能，以至于我们将第七章的内容专门讲解了这一点。目前，了解何时一个任务太大，无法让
    Copilot 完成是至关重要的。让 Copilot 制作一个结合了 Wordscapes 和 Wordle 的新视频游戏根本行不通。然而，你可以让 Copilot
    编写一个对解决更大问题至关重要的函数；例如，你可能需要一个函数来检查玩家提供的单词是否在有效单词列表中。Copilot 完全可以解决这个问题，这个函数也能帮助
    Copilot 更接近解决更大问题。
- en: 3.1.1 The components of a function
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 函数的组成部分
- en: 'The origin of the name *function* goes back to math where functions define
    the output of something based on an input. For example, in high school math, you
    probably learned to recognize the common way to write a function as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数*这个名字的起源可以追溯到数学，在数学中，函数定义了基于输入的输出。例如，在高中数学中，你可能学过如何识别常见的函数写法如下：'
- en: f(*x*) = *x*²
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: f(*x*) = *x*²
- en: This is a function that is given a value for the variable *x* and computes the
    square of that value. So, we can say that when *x* is 6, f(*x*) is 36\. As programming
    functions also have expected output for a particular input, the name is apt for
    programming as well.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个函数，给定变量 *x* 的值并计算该值的平方。所以，我们可以说，当 *x* 等于 6 时，f(*x*) 就是 36。由于编程函数也有特定输入对应的预期输出，因此这个名字在编程中也很合适。
- en: As programmers, we also like to think of functions as promises or contracts.
    If there is a function called `larger`, and we’re told that it takes two numbers
    and gives us the larger of the two, we have faith that when we give the function
    the numbers 2 and 5, it will return the answer of 5\. We don’t need to see how
    that function works to use it, any more than we need to know how the mechanics
    of a car works to use the brake pedal. Press the brake pedal, and the car slows
    down. Give the `larger` function two numbers, and it gives us back the larger
    of the two.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们还喜欢把函数看作是一种承诺或合同。如果有一个叫做 `larger` 的函数，我们被告知它接受两个数字并返回其中较大的一个，那么当我们提供数字
    2 和 5 时，我们相信它会返回 5。我们不需要知道这个函数是如何工作的，就像我们不需要知道汽车刹车的工作原理就能使用刹车踏板一样。踩下刹车踏板，汽车就会减速。给
    `larger` 函数两个数字，它会返回两个数字中的较大者。
- en: Every function in Python has a *function header* (also called a *function signature*),
    which is the first line of code of the function. Given their ubiquitous nature,
    we’ll want to read and write function headers. The function header describes the
    name of the function and its inputs. In some other languages, the function header
    sometimes includes information about what the output looks like, but in Python,
    you have to find that elsewhere in the code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的每个函数都有一个*函数头*（也叫做*函数签名*），它是函数的第一行代码。由于函数头在代码中无处不在，我们需要能够读取和编写函数头。函数头描述了函数的名称及其输入。在某些其他编程语言中，函数头有时还会包括输出的信息，但在
    Python 中，关于输出的内容需要在代码的其他地方寻找。
- en: 'In chapter 2, we wrote # comments to tell Copilot what to do. We can continue
    to use that approach if we want Copilot to generate a function. For example, we
    can use comments to ask Copilot to write a function that tells us which of two
    numbers is larger:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，我们使用了#注释来告诉 Copilot 做什么。如果我们希望 Copilot 生成一个函数，仍然可以继续使用这种方法。例如，我们可以使用注释请求
    Copilot 写一个函数，告诉我们两个数字中哪个更大：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '#1 This function header defines a function called “larger” that accepts two
    inputs called num1 and num2.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这个函数头定义了一个名为“larger”的函数，它接受两个名为 num1 和 num2 的输入。'
- en: '#2 Function body'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 函数体'
- en: 'As with the code in the previous chapter, we just wrote the comments to prompt
    Copilot to give us the code. The function header has three main components: the
    `def` keyword, which tells Python that this is a function; the name of the function;
    and the inputs to the function. There’s also a colon at the end of the line—be
    sure to include that or the code won’t be valid Python code. The word `def` denotes
    that it’s creating (defining) a function. After `def` is the name of the function;
    that name should describe the behavior of the function as well as possible. The
    name of this function is `larger`. If it’s hard to name a function because it
    does a bunch of different things, that’s usually a clue that it’s too big of a
    task for a single function (more on that later).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 和上一章中的代码一样，我们只是写了注释来提示 Copilot 给我们生成代码。函数头有三个主要部分：`def` 关键字，它告诉 Python 这是一个函数；函数的名称；以及函数的输入。行尾还有一个冒号——一定要包含它，否则代码将不是有效的
    Python 代码。`def` 这个词表示正在创建（定义）一个函数。在 `def` 后面是函数的名称；这个名称应该尽可能地描述函数的行为。这个函数的名称是
    `larger`。如果给函数起名很困难，因为它做了很多不同的事情，那通常意味着这个函数的任务过于庞大，不适合由一个函数来完成（稍后会详细讲解）。
- en: In the parentheses of the function declaration, you’ll find the parameters.
    *Parameters* are how you provide information to a function that it needs to run.
    A function can have any number of parameters, and some functions have no parameters.
    This function has two parameters named `num1` and `num2`; there are two parameters
    because it needs to know the two numbers it’s comparing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数声明的括号中，你会看到参数。*参数*是你向函数提供其运行所需信息的方式。一个函数可以有任意数量的参数，有些函数甚至没有参数。这个函数有两个参数，分别叫做
    `num1` 和 `num2`；这两个参数是因为函数需要知道它正在比较的两个数字。
- en: 'There can be only one output of a function; the keyword to look for when determining
    what the function is outputting is *return*. Whatever follows `return` is the
    output of the function. In this code, either `num1` or `num2` will be returned.
    Functions aren’t required to return anything (e.g., a function that prints a list
    to the screen has no reason to return anything), so if you don’t see a return
    statement, it isn’t necessarily a problem because the function may be doing something
    else (interacting with the user, for example) rather than returning something.
    Functions must also either return something or not return something: they can’t
    return something in some cases and nothing in other cases.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数只能有一个输出；在确定函数输出的内容时，关键字是*return*。紧随其后的`return`内容就是函数的输出。在这段代码中，`num1`或`num2`将被返回。函数不一定需要返回任何内容（例如，打印列表到屏幕的函数没有返回任何内容的必要），所以如果你没有看到`return`语句，这不一定是问题，因为函数可能在做其他事情（例如与用户交互）而不是返回某些东西。函数必须决定是返回某些东西还是不返回任何东西：它不能在某些情况下返回某些东西，而在其他情况下什么都不返回。
- en: 'Although we had Copilot generate this function using # comments, this approach
    is actually a lot of work for Copilot. It first must get the header right, including
    figuring out how many parameters you need. Then, it must get the actual code of
    the function right. In this example, Copilot also provided the code for the function
    (also known as the function’s body).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们让Copilot通过#注释生成了这个函数，但这种方法实际上对Copilot来说工作量很大。首先，它必须正确写出函数头部，包括确定需要多少个参数。然后，它必须确保函数的实际代码正确。在这个例子中，Copilot还提供了函数的代码（也叫函数体）。
- en: There’s an alternate way to prompt Copilot to write the code for a function
    that may help it generate code more accurately and may help us better understand
    exactly what we want our function to do. It involves writing a docstring, and
    we’ll use docstrings to write functions for the majority of the book.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种方法可以提示Copilot写出函数的代码，这可能帮助它更准确地生成代码，并且帮助我们更好地理解我们希望函数做什么。这种方法涉及写文档字符串，而我们将在本书的大部分内容中使用文档字符串来编写函数。
- en: Docstrings explain function behavior
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 文档字符串解释函数的行为
- en: '*Docstrings* are how Python functions are described by programmers. They follow
    the function header and begin and end with three double quotation marks, as shown
    in the upcoming code function for `larger`.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*文档字符串*是程序员用来描述Python函数的方式。它们位于函数头部之后，并以三个双引号开始和结束，如接下来的`larger`函数代码所示。'
- en: 'By writing the header and docstring, you’ll make it easier for Copilot to generate
    the right code. In the header, you’ll be the one deciding on the name of the function
    and providing the names of each parameter that you want the function to use. After
    the function header, you’ll provide a docstring that tells Copilot what the function
    does. Then, just as before, Copilot will generate the code for the function. Because
    we gave Copilot the function header, it will be able to learn from the header
    and is less likely to make mistakes. Here’s what the alternate approach would
    look like when writing that same `larger` function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过写出函数头部和文档字符串，你可以更容易地让Copilot生成正确的代码。在函数头部，你将决定函数的名称，并提供每个你希望函数使用的参数名称。写完函数头部后，你将提供文档字符串，告诉Copilot这个函数的作用。然后，像之前一样，Copilot会生成函数的代码。因为我们提供了函数头部，它将能够从头部中学习，并且更不容易出错。这就是写同一个`larger`函数的另一种方法：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**#1 Docstring description of the function**  **Notice that we wrote the function
    header as well as the docstring, and Copilot supplied the body of the function.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**#1 函数的文档字符串描述** **注意，我们写了函数头部和文档字符串，Copilot提供了函数体。'
- en: 3.1.2 Using a function
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 使用函数
- en: Once we have a function, how do we use it? Thinking back to our f(*x*) = *x*²
    analogy, how do we give the function a value of 6 for *x* so that it returns 36?
    Let’s see how to do this with code by using that `larger` function we just wrote.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了一个函数，我们该怎么使用它呢？回想一下我们之前提到的f(*x*) = *x*²的类比，我们如何给函数一个值6来作为*x*，使得它返回36？让我们通过使用我们刚刚写的`larger`函数来看一下如何通过代码实现。
- en: The way to use a function is to *call* it. Calling a function means to invoke
    the function on specific values of parameters. These parameter values are called
    arguments. Each value in Python has a *type*, and we need to take care to give
    values of the proper type. For example, that `larger` function is expecting two
    numbers; it might not work as expected if we supply inputs that aren’t numbers.
    When we call a function, it runs its code and returns its result. We need to capture
    that result so that we can use it later; otherwise, it will be lost. To capture
    a result, we use a *variable*, which is just a name that refers to a value.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数的方法是*调用*它。调用函数意味着在特定的参数值上调用函数。这些参数值称为实参。在 Python 中，每个值都有一个*类型*，我们需要小心地提供正确类型的值。例如，`larger`函数期望两个数字；如果我们提供不是数字的输入，它可能不会按预期工作。当我们调用函数时，它会运行其代码并返回结果。我们需要捕获这个结果，以便稍后使用；否则，它将丢失。要捕获结果，我们使用*变量*，它只是一个引用值的名称。
- en: 'Here, we ask Copilot to call the function, store the result in a variable,
    and then print the result:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们让 Copilot 调用函数，将结果存储在变量中，然后打印结果：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '#1 Calls the larger function with the values 3 and 5 as inputs and stores the
    result'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 调用`larger`函数，将3和5作为输入并存储结果'
- en: The code correctly calls `larger`. Notice that it puts the two values we want
    compared after the opening parenthesis. When the function finishes, it returns
    a value that we assign to result. Then we print the result. If you run this program,
    you’ll see that the output 5 gets produced because 5 is the larger of the two
    values that we asked about.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 代码正确地调用了`larger`。注意，它在开括号后面放入了我们希望比较的两个值。当函数完成时，它返回一个值，我们将其赋给`result`。然后我们打印结果。如果你运行这个程序，你会看到输出为5，因为5是我们要求比较的两个值中较大的一个。
- en: 'It’s okay if you aren’t comfortable with all the details here, but what we
    want you to recognize is when a function is being called, as in the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这些细节不完全熟悉也没关系，但我们希望你能识别出何时正在调用一个函数，如下所示：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The general format for a function call is
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用的一般格式是
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So, when you see those parentheses right after a name, it means there’s a function
    call. Calling functions as we did here will be important to our workflow with
    Copilot, particularly in how we test functions to see if they are working properly.
    We’ll also need to call functions to get work done because functions don’t do
    anything until we call them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当你看到名字后面紧跟着的括号时，意味着有一个函数调用。像我们这里这样调用函数对我们的 Copilot 工作流非常重要，特别是在我们测试函数是否正常工作时。我们还需要调用函数来完成工作，因为函数在我们调用它们之前什么都不做。
- en: 3.2 The design cycle of functions with Copilot
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 与 Copilot 一起设计函数的循环
- en: 'Let’s introduce you to the workflow we’ll use for the next few chapters. Designing
    functions with Copilot involves the following cycle of steps (see figure 3.2):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们介绍一下我们在接下来几章中将使用的工作流程。与 Copilot 一起设计函数涉及以下步骤的循环（见图 3.2）：
- en: Determine the desired behavior of the function.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定函数的预期行为。
- en: Write a prompt that describes the function as clearly as possible.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个尽可能清晰描述该函数的提示。
- en: Allow Copilot to generate the code.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许 Copilot 生成代码。
- en: Read through the code to see if it seems reasonable.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阅读代码，看看它是否合理。
- en: 'Test the code to see if it’s correct:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试代码，看它是否正确：
- en: If the code is correct after multiple tests, move on.
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果经过多次测试后代码正确，则继续进行。
- en: If the code is incorrect, move to step 2, and edit the prompt.
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果代码不正确，请转到步骤 2，编辑提示。
- en: '![figure](../Images/3-2.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/3-2.png)'
- en: Figure 3.2 General editing cycle with Copilot. This assumes you define a reasonable
    function.
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.2 与 Copilot 一起的通用编辑循环。假设你定义了一个合理的函数。
- en: We won’t learn how to do step 4 until the next chapter, but we bet you can already
    recognize when the code is blatantly wrong. For example, Copilot might give you
    only comments to fill the body of the function. Comments don’t do anything—they
    aren’t code—so a bunch of comments with no other code is clearly not the right
    thing to do. Or, Copilot might just write a single line such as `return` `-1`,
    or, our personal favorite, `Your` `code` `here`. Copilot learned that one from
    us professors when we provide students partial code and ask them to write the
    rest with “Your code here.” Those are all obviously incorrect, but in the next
    chapter, we’ll go over how to read code so you can more quickly spot when more
    complicated code is incorrect and, perhaps more importantly, see where and how
    to fix it. In later chapters, we’ll keep expanding on this cycle to include effective
    debugging practices, and we’ll keep practicing how to improve prompts.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章学习如何进行第4步，但我们敢打赌你现在已经能够识别出代码明显错误的情况。例如，Copilot可能只给你一些注释，要求你填写函数的主体。注释不做任何事情——它们不是代码——所以如果一大堆注释没有其他代码，这显然不是正确的做法。或者，Copilot可能只写一行代码，如`return`
    `-1`，或者我们个人最喜欢的`Your` `code` `here`。Copilot是从我们教授那里学到的，当我们给学生提供部分代码，并要求他们补全剩下的部分时，通常会加上“Your
    code here”。这些显然都是错误的，但在下一章中，我们将学习如何阅读代码，以便你能更快地发现更复杂的代码中的错误，并且，更重要的是，知道在哪里以及如何修复它。在后续的章节中，我们将继续扩展这个循环，包含有效的调试实践，同时不断练习如何改进提示。
- en: 3.3 Examples of creating good functions with Copilot
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 使用Copilot创建优秀函数的示例
- en: In this section, we’re going to write a bunch of functions with Copilot. We
    think you’ll get a much better feel for functions by seeing concrete examples,
    and we’ll code them entirely in Copilot to help you see the cycle of function
    design we just described. Although our goal in this chapter isn’t to help you
    read code just yet, we’ll see programming features (sometimes called *constructs*)
    in the solutions that are very common in code (e.g., `if` statements, loops),
    so we’ll point those out when we see them. Then, in chapter 4, we’ll say more
    about how to read this code in more detail.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Copilot编写一系列函数。我们认为通过查看具体的示例，你将更好地理解函数的概念，我们将完全通过Copilot来编写这些代码，帮助你理解我们刚刚描述的函数设计循环。虽然我们在这一章的目标不是帮助你阅读代码，但我们会在解决方案中看到一些常见的编程特性（有时被称为*构造*），例如`if`语句和循环，我们会在看到它们时指出来。然后，在第4章中，我们会详细讲解如何阅读这些代码。
- en: Many of the functions we’re about to work on are unrelated to each other. For
    example, we’ll start with a function about stock share prices and move to functions
    about strong passwords. You typically wouldn’t store unrelated stuff like this
    in the same Python file. Because we’re just exploring different examples of good
    functions, feel free to store all functions in the same Python file, perhaps named
    function ch3.py or function_practice.py.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要处理的很多函数彼此之间是没有关联的。例如，我们将从一个关于股票股价的函数开始，然后转到关于强密码的函数。通常，你不会把这些不相关的内容存储在同一个Python文件中。因为我们现在只是探讨一些好的函数示例，所以你可以把所有的函数都存储在同一个Python文件中，文件名可以是function_ch3.py或function_practice.py。
- en: 3.3.1 Dan’s stock pick
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 Dan的股票选择
- en: Dan is an investor in a stock called AAAPL. He purchased 10 shares for $15 each.
    Now, each of those shares is worth $17\. Dan would like to know how much money
    he has made on the stock.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Dan是一个投资者，他购买了名为AAAPL的股票，每股价格为15美元，共买了10股。现在，每股的价格已经涨到17美元。Dan想知道他在这只股票上赚了多少钱。
- en: Remember that we want to make our function as general as possible. If the only
    thing our function does is calculate this exact AAAPL situation, it wouldn’t be
    that useful in general. Sure, it would help Dan right now, but what about when
    AAAPL’s share price changes again or when he is interested in another stock entirely?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们希望将函数设计得尽可能通用。如果我们函数做的唯一事情就是计算这个特定的AAAPL情况，那它在一般情况下就不会很有用。当然，这对Dan现在有帮助，但当AAAPL的股价再次变化，或者当他对其他股票感兴趣时，这个函数就不再适用了。
- en: 'A useful general function here would take three parameters, all of which are
    numbers. The first parameter is the number of shares purchased, the second is
    the share price when the shares were purchased, and the third is the current share
    price. Let’s call this function `money_made`, because it’s going to determine
    how much money we’ve made or lost on the stock. In general, you want to name your
    function as an action word or words that describe what your function is doing.
    With that, we have enough to write the function header:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有用的一般函数，它需要三个参数，全部是数字。第一个参数是购买的股票数量，第二个参数是购买股票时的股价，第三个参数是当前的股价。我们称这个函数为
    `money_made`，因为它将确定我们在股票上赚了多少钱或亏了多少钱。通常，你会将函数命名为一个动词或多个动词，描述函数正在做的事情。有了这些，我们就可以写出函数头了：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we need a docstring. In the docstring, we need to explain what each parameter
    is for by using its name in a sentence. We also need to include what the function
    is supposed to do. Adding our docstring, here is the full prompt we provide to
    Copilot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个文档字符串。在文档字符串中，我们需要通过使用每个参数的名称来解释它的作用。我们还需要包含函数应该执行的内容。加入文档字符串后，这就是我们提供给
    Copilot 的完整提示：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After typing that prompt, go to the next line, and press the Tab key. Copilot
    will fill in the code for the function. Don’t worry that the code gets indented:
    the code of functions is supposed to be indented, and, in fact, it’s an error
    if it isn’t! Here’s what we got from Copilot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入完提示后，转到下一行，按下 Tab 键。Copilot 会填写函数的代码。不要担心代码被缩进：函数的代码本应缩进，实际上，如果不缩进，那就是一个错误！这是我们从
    Copilot 获得的内容：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code seems sensible. In the parentheses, it figures out the difference
    between the current price and the purchase price (the `-` is used for subtraction),
    and then it multiplies that by the number of shares that we have (the `*` is used
    for multiplication). Inspecting code like this is a useful skill, and we’ll get
    serious about it in the next chapter. Another useful skill is testing the function.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来合理。在括号中，它计算当前价格与购买价格之间的差额（`-` 用于减法），然后将其乘以我们拥有的股票数量（`*` 用于乘法）。检查这样的代码是一个有用的技能，我们将在下一章深入学习它。另一个有用的技能是测试函数。
- en: To test the `money_made` function, we call it using various inputs and observe
    the output in each case. We could do this by asking Copilot to call the function,
    and then we run our program, much as we did with our `larger` function. We could
    then ask Copilot to change the function call by asking it to call the function
    with a different input, and then we would run our program again, repeating as
    many times as needed. However, we find it easier and more convenient to call the
    function ourselves from an interactive window. This way, we can call the function
    as many times as we like without going through Copilot at all and without cluttering
    up our program with stuff we’re going to delete anyway.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试 `money_made` 函数，我们通过不同的输入来调用它，并观察每种情况的输出。我们可以通过让 Copilot 调用函数，然后运行程序，就像我们对
    `larger` 函数做的一样。然后我们可以让 Copilot 通过不同的输入来改变函数调用，然后我们再次运行程序，根据需要重复多次。然而，我们发现从交互式窗口中自己调用函数更容易、更方便。这样，我们可以根据需要多次调用函数，而无需经过
    Copilot，并且无需在程序中加入我们最终会删除的内容。
- en: To try this interactive approach, select/highlight all the code of the function,
    and then press Shift-Enter (you can access a similar interactive session by selecting
    the text, right-clicking, and choosing Run Selection/Line in the Python window,
    but the guidance here is if you use Shift-Enter). Figure 3.3 shows what this looks
    like if you select the text of the function and press Shift-Enter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这种交互式方法，选择/高亮显示函数的所有代码，然后按下 Shift-Enter（你也可以通过选择文本，右键点击并选择在 Python 窗口中运行选择/行来访问类似的交互式会话，但这里的指导是如果使用
    Shift-Enter）。图 3.3 显示了如果你选择函数的文本并按下 Shift-Enter 时的样子。
- en: '![figure](../Images/3-3.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/3-3.png)'
- en: Figure 3.3 Running Python in an interactive session in VS Code. Note the >>>
    at the bottom of the TERMINAL tab.
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.3 在 VS Code 中运行 Python 的交互式会话。注意 TERMINAL 标签底部的 >>>。
- en: At the bottom of the resulting window, you’ll see three greater-than symbols
    >>>. This is called a *prompt*, and you’re allowed to type Python code here. (This
    prompt has nothing to do with the kind of prompt that we use when interacting
    with Copilot.) It will show us right away the result of the code that we type,
    which is convenient and fast.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在结果窗口的底部，你将看到三个大于号 >>>。这叫做 *提示符*，你可以在这里输入 Python 代码。（这个提示符与我们与 Copilot 交互时使用的提示符无关。）它会立即显示你输入的代码的结果，既方便又快速。
- en: To call our `money_made` function, we need to provide three arguments, and they
    will be assigned left to right to the parameters. Whatever we put first will be
    assigned to `num_shares`, whatever we put second will be assigned to `purchase_share_price`,
    and whatever we put third will be assigned to `current_share_price`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用我们的 `money_made` 函数，我们需要提供三个参数，它们会从左到右分配给函数的参数。我们首先输入的会被分配给 `num_shares`，第二个输入会被分配给
    `purchase_share_price`，第三个输入会被分配给 `current_share_price`。
- en: 'Let’s try this! At the prompt, type the following, and press Enter (or Shift-Enter).
    Don’t type the >>>, as that’s already there; we’re including it throughout the
    book to make it clear where we’re typing. Figure 3.4 shows an example of running
    the function in the terminal at the Python prompt:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 来试试这个！在提示符下，键入以下内容并按回车（或 Shift+Enter）。不要键入 >>>，因为它已经存在；我们在书中一直使用它来清楚地标明我们正在输入的地方。图
    3.4 显示了在 Python 提示符下运行该函数的示例：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You’ll see the following output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Is `20` correct? Well, we bought 10 shares, and each of them went up $2 (from
    $15 to $17), so we did make $20\. Looks good!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`20` 正确吗？我们买了 10 股，每股涨了 2 美元（从 15 美元涨到 17 美元），所以我们确实赚了 20 美元。看起来没问题！'
- en: '![figure](../Images/3-4.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/3-4.png)'
- en: Figure 3.4 Calling the `money_made` function from the Python prompt in the VS
    Code terminal
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.4 从 VS Code 终端的 Python 提示符调用 `money_made` 函数
- en: We’re not done testing, though. When testing a function, you want to test it
    in various ways, not just once. All one test case tells you is that it happened
    to work with the particular input values that you provided. The more test cases
    we try, each testing the function in a different way, the more confident we are
    that our function is correct.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的测试还没有完成。当测试一个函数时，你需要以多种方式进行测试，而不是只测试一次。所有的单一测试用例只能告诉你它在你提供的特定输入值下是否有效。我们尝试的测试用例越多，每个用例以不同的方式测试函数，我们就越有信心认为我们的函数是正确的。
- en: How do we test this function in a different way? We’re looking for inputs that
    are somehow a different *category* of input. One not-so-good test right now would
    be to say, “What if our stock went from $15 to $18, instead of $15 to $17?” This
    is pretty much the same test as before, and chances are that it will work just
    fine.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如何以不同的方式测试这个函数？我们在寻找输入，它们在某种程度上属于不同的 *类别*。现在，一个不太好的测试是说：“如果我们的股票价格从 15 美元涨到
    18 美元，而不是从 15 美元涨到 17 美元，结果会怎样？”这几乎与之前的测试相同，很可能它也会正常工作。
- en: 'A good idea is to test what happens when the stock actually *loses* money.
    We expect to get a negative return value in this case. And it appears that our
    function works just fine with this category of test. Here’s our function call
    and the output returned to us:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好主意是测试股票实际 *亏损* 的情况。我们期望在这种情况下得到一个负的回报值。看起来我们的函数在这个测试类别下也能正常工作。以下是我们的函数调用和返回的输出：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'What other tests can we do? Well, sometimes a stock price doesn’t change at
    all. We expect 0 in this case. Let’s verify it:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还能做哪些其他测试？有时候股票价格根本没有变化。我们期望在这种情况下返回 0。让我们验证一下：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Looks good! Testing is a combination of science and art. How many categories
    of things are there to test? Are these two calls really two different categories?
    Have we missed any categories? You’ll improve your testing ability through practice,
    and we’ll spend all of chapter 6 talking about testing. For now, it looks like
    our `money_made` function is doing its job.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错！测试是科学与艺术的结合。需要测试的内容有多少种类别？这两个调用真的是两个不同的类别吗？我们是否遗漏了某些类别？你会通过实践提高测试能力，我们将在第
    6 章全面讨论测试。目前来看，我们的 `money_made` 函数似乎工作正常。
- en: 'It’s possible for a function to use variables (rather than just its parameters)
    in its code, and we want to show you an example of that now so that you’re ready
    when you see Copilot doing it. Here’s an equivalent way to write the code for
    our `money_made` function:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 函数有可能在其代码中使用变量（而不仅仅是它的参数），我们现在想通过一个例子展示这种情况，以便你在看到 Copilot 这样做时能够理解。以下是我们 `money_made`
    函数的等效写法：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This code may even be easier to read for you: it first figures out the difference
    in share price, and then it multiplies that by the number of shares. We encourage
    you to test this version to help convince yourself that it’s still correct.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可能对你来说更容易理解：它首先计算出股价的差异，然后将差异乘以股票数量。我们鼓励你测试这个版本，帮助自己确信它仍然是正确的。
- en: 3.3.2 Leo’s password
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.2 Leo的密码
- en: Leo is signing up for a new social network website called ProgrammerBook. He
    wants to make sure that his password is strong.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Leo正在注册一个新的社交网络网站，叫做ProgrammerBook。他想确保他的密码是强密码。
- en: 'Leo starts with a modest definition of what it means for a password to be strong:
    it’s strong if it’s not the word *password* and not the word *qwerty*. Those are
    terrible passwords, for sure, but in reality, we have to do way better than this
    definition to ensure that our password is strong! A helpful function would be
    one that takes a proposed password and tells us whether it’s strong or not.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Leo对强密码的定义开始得比较简单：如果密码不是*password*，也不是*qwerty*，那就算是强密码。当然，这些密码肯定很糟糕，但实际上，我们必须比这个定义做得更好，才能确保我们的密码足够强！一个有用的函数应该是接收一个提议的密码，并告诉我们它是否强大的那种。
- en: Unlike our previous functions in this chapter, we’re not dealing with numbers
    here. The parameter, the password to check, is text. And the return value is supposed
    to indicate some yes/no result. We need new types!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章之前的函数不同，这里我们不再处理数字。参数是待检查的密码，属于文本类型。而返回值应该表示一个是/否的结果。我们需要新的类型！
- en: 'The Python type for text is called a *string*. There are zillions of possible
    strings because we can use a string to store whatever text we want. The Python
    type for a yes/no result is called a *Boolean* or *bool*. A bool has only two
    values: `True` or `False`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的文本类型叫做*字符串*。由于我们可以用字符串存储任何文本，所以可能有成千上万种字符串。Python中表示是/否结果的类型叫做*布尔值*（*Boolean*）或*bool*。一个布尔值只有两个值：`True`或`False`。
- en: 'Alright! We’re ready to prompt Copilot. For functions that return bool (`True`/`False`)
    values, we usually name the function as `has_x`, `is_x`, or similar using some
    other verb that implies a true/false result:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！我们准备好向Copilot发起提示了。对于返回布尔值（`True`/`False`）的函数，我们通常将函数命名为`has_x`、`is_x`，或者使用其他动词来表示真/假的结果：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In response, here’s what Copilot wrote for us:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回应，以下是Copilot为我们写的内容：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Look over that code for a moment. That `!=` operator is the “not equal” operator,
    and each string that doesn’t count as a strong password is in single quotation
    marks. We’re going to use quotation marks every time we need to specify a specific
    string value. Again, we’ll talk more about how to read code in the next chapter,
    but for now, we hope that the code makes a fuzzy sort of sense: it looks like
    it’s checking that the password isn’t `password` and isn’t `qwerty`, which matches
    our definition of a strong password.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下那段代码。`!=`运算符是“非等于”运算符，每个不被认为是强密码的字符串都被单引号括起来。每当我们需要指定一个特定的字符串值时，就会使用引号。我们将在下一章深入讨论如何阅读代码，但现在，希望这段代码大致能够理解：它看起来是在检查密码是否不是`password`，并且不是`qwerty`，这符合我们对强密码的定义。
- en: 'Now let’s make sure that this function does indeed work by making a few test
    calls. We’ll start by testing the passwords that aren’t strong. We had better
    get back `False` for each of these—and we do:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过进行几个测试调用来确保这个函数确实有效。我们从测试那些不强的密码开始。对于这些密码，我们最好能返回`False`—而事实也是如此：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Good! Now, let’s try a strong password. We need to see `True` here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！现在，让我们试试一个强密码。我们需要在这里看到`True`：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Good stuff! We now see that the function sometimes returns `False` and other
    times returns `True`, so at least it’s not always returning `False`. Let’s try
    one more:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！我们现在看到该函数有时返回`False`，有时返回`True`，所以至少它不总是返回`False`。让我们再试一次：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Well, technically `True` is correct, but, wow, is `Leo` a bad password. We
    should really have done better with our definition of a strong password. Let’s
    change our prompt to give a more reasonable definition of what it means for a
    password to be strong. Here’s our next prompt and what Copilot gave us:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，严格来说，`True`是正确的，但是，哇，`Leo`是一个糟糕的密码。我们真的应该在强密码的定义上做得更好。让我们更改提示，给出一个更合理的强密码定义。以下是我们的下一个提示和Copilot给出的内容：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That `for` `char` `in` `password` that shows up a few times here is a way for
    Python to consider each character of the password. It enables something called
    a *loop*, which is a key topic that we’ll study in chapter 5.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 那个`for` `char` `in` `password`反复出现，是Python考虑密码中每个字符的一种方式。它启用了一个叫做*循环*的功能，这是我们将在第五章学习的一个关键主题。
- en: Of course, it’s possible that you didn’t get the same code from Copilot as we
    did. But based on the code that we got, it looks like the first piece is looking
    for any uppercase character, the second piece is looking for any digit, and the
    third is looking for something that’s not an `isalnum`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也有可能你没有从Copilot得到和我们一样的代码。但根据我们得到的代码来看，第一部分是查找任何大写字母，第二部分是查找任何数字，第三部分是查找任何不是`isalnum`的字符。
- en: 'Maybe `isalnum` means “is alphanumeric.” Does that include special symbols,
    and, if so, which ones? Let’s test this function to see how well we’re doing:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 也许`isalnum`的意思是“是字母数字”。那它包括特殊符号吗？如果包括，哪些符号呢？让我们测试一下这个函数，看看它的表现如何：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Uh-oh! We got the wrong answer for that third password. It looks pretty strong,
    but it’s not, because it lacks a special symbol. Our function returned `True`,
    but that’s the wrong return value: it was supposed to return `False`.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！我们得到了第三个密码的错误答案。看起来很强，但其实不强，因为它缺少一个特殊符号。我们的函数返回了`True`，但那是错误的返回值：它应该返回`False`。
- en: The code that Copilot gave us is wrong. Maybe the code that you got worked fine,
    but we didn’t get so lucky, and it’s important we know how to identify (like we
    just did) when the code is wrong and then fix it. It’s not important to know why
    it’s wrong right now, but if you’re curious about why our prompt may have given
    us the wrong behavior, it’s because we didn’t specify what we meant by a special
    character, and the code it gave us counts spaces as special characters.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot给出的代码是错误的。也许你得到的代码没有问题，但我们没有那么幸运，重要的是我们知道如何识别（就像我们刚才做的那样）代码错误，然后修复它。现在不重要的是为什么它错了，但如果你对为什么我们的提示可能给出错误行为感到好奇，那是因为我们没有明确说明特殊字符的意思，而它给出的代码将空格也算作特殊字符。
- en: At this point, as we begin to troubleshoot our wrong code, we have two options.
    One option is to press Ctrl-Enter and look through the other suggestions that
    Copilot gives us. Maybe one of those suggestions will have something to do with
    special symbols that looks different from the one that didn’t work?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，当我们开始排查错误代码时，我们有两个选择。一个选择是按Ctrl-Enter，查看Copilot给出的其他建议。也许这些建议中的某一个与特殊符号有关，且看起来不同于那个没有成功的选项？
- en: 'Indeed, on our computer here, we see such options, including this one:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，在我们的电脑上，我们看到了这些选项，其中包括这个：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '#1 Specific choice of special symbols'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 特殊符号的具体选择'
- en: Test this function with strings such as `Leo`, `N3w` `Y0rk` `J375`, and `N3w`
    `Y0rk` `J375$` and you should see that the function works well.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像`Leo`、`N3w`、`Y0rk`、`J375`以及`N3w`、`Y0rk`、`J375$`这样的字符串测试这个函数，你应该能看到该函数运行得很好。
- en: 'Our second option is to do some prompt engineering, which means adjusting our
    prompt to influence what Copilot gives us. In our original prompt, we talked about
    special symbols. This, in retrospect, is vague. We probably meant something more
    specific, such as punctuation. If we specifically talk about punctuation in our
    prompt, we get this interaction with Copilot:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个选择是进行一些提示工程，也就是调整我们的提示来影响Copilot给出的结果。在我们最初的提示中，我们提到了特殊符号。回头看，这个表述有些模糊。我们可能是想说更具体的内容，比如标点符号。如果我们在提示中具体谈论标点符号，就会得到这样的与Copilot的互动：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Looks good! That last line is talking about punctuation, which is hopeful.
    Let’s test it here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错！最后一行讲的是标点符号，这是令人期待的。让我们在这里测试一下：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Looking at the bottom of that error message, you’ll see that `'string'` isn’t
    defined. Copilot wants to use a module, called `string`, but it’s a module that
    needs to be imported before we can use it. This “not defined” result can happen
    for various types of errors related to names not being found, and oftentimes the
    culprit is a module that hasn’t been imported. There are a lot of modules in Python,
    but the `string` module is well known. As you work with Copilot more, you’ll learn
    which modules are commonly used so you know to import them. You could also do
    a quick internet search to ask, “Is string a Python module,” and the results would
    confirm that it is. What we need to do is import the module.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 看那个错误信息的底部，你会看到`'string'`没有定义。Copilot想要使用一个叫做`string`的模块，但这是一个需要在使用之前导入的模块。这个“未定义”结果可能是由于各种类型的错误，比如找不到名称，通常罪魁祸首是一个尚未导入的模块。Python有很多模块，但`string`模块是非常著名的。随着你在使用Copilot的过程中越来越多，你会学到哪些模块是常用的，这样你就知道该导入哪些模块。你也可以快速在网上搜索，问“string是Python模块吗”，结果会确认它是一个模块。我们需要做的是导入这个模块。
- en: Note that this is similar to what happened in the code that Copilot generated
    for us in chapter 2\. Back then, Copilot was using the csv module, which is a
    module already installed with Python. The string module is similarly included
    with Python; Copilot just forgot to import it. As we discussed in chapter 2, some
    modules do need to be manually installed, but the string module isn’t one of them.
    So, we don’t need to install string; we just have to import it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这与第二章中 Copilot 为我们生成的代码类似。那时，Copilot 使用了 csv 模块，这是一个已经与 Python 一起安装的模块。string
    模块同样是 Python 自带的；Copilot 只是忘记导入它。正如我们在第二章中讨论的，有些模块确实需要手动安装，但 string 模块不是其中之一。所以，我们不需要安装
    string；我们只需导入它。
- en: Importing modules
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 导入模块
- en: There are a number of useful modules available in Python. In chapter 2, Copilot
    used the csv module to make it easier to deal with comma-separated values (CSV)
    files. But for Python code to take advantage of a module, we have to import that
    module. You might ask why we don’t have modules available to us without importing
    them, but that would massively increase the complexity of the code and what Python
    has to do to run code behind the scenes. Instead, the model is to include modules
    if you want to use them, and they aren’t included by default.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了许多有用的模块。在第二章中，Copilot 使用了 csv 模块，使得处理逗号分隔值（CSV）文件变得更容易。但是，为了让 Python
    代码利用某个模块，我们必须先导入该模块。你可能会问，为什么我们不能直接使用模块，而不需要导入它们，但如果没有导入模块，这将大大增加代码的复杂性以及 Python
    在后台运行代码时需要做的工作。相反，Python 的模型是，如果你想使用某个模块，就必须导入它们，它们默认情况下并不包括在内。
- en: 'Let’s add `import` `string` at the top of our code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在代码顶部添加 `import` `string`：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we’re in good shape:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们状态良好：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That last one is `True`. It’s a strong password because it has the `$` punctuation
    added to it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个是 `True`。它是一个强密码，因为它添加了 `$` 符号。
- en: We hope that you’re now convinced of the value of testing. Sometimes, new programmers
    don’t test their code. They assume that the code they write is correct because
    it made sense to them. An interesting difference between novice and experienced
    programmers is that novices often assume their code is right, whereas experienced
    programmers assume their code is wrong until thoroughly tested and proved otherwise.
    Beyond this, we find that new programmers sometimes fail to test well because
    it’s disheartening to learn that the code is wrong. But it’s better to know now
    rather than later when others are using your code in a serious application. Finding
    errors through testing is actually a good thing.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望你现在已经相信了测试的价值。有时候，新的程序员不会测试他们的代码。他们认为自己写的代码是正确的，因为它对他们来说是有意义的。新手和经验丰富的程序员之间一个有趣的区别是，新手通常认为自己的代码是正确的，而经验丰富的程序员则假设自己的代码是错的，直到经过彻底测试并证明没有问题为止。除此之外，我们还发现新手程序员有时不善于测试，因为得知代码是错误的令人沮丧。但现在发现错误比等到别人将你的代码用于重要应用时才发现要好得多。通过测试发现错误实际上是一件好事。
- en: 3.3.3 Getting a strong password
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.3 获取强密码
- en: Now that we have a function that tells us whether a password is strong or not,
    let’s write a function that obtains a strong password from the user. It will ask
    again and again for a password until the user types a strong one. This is the
    kind of code that websites use when they tell you, “Sorry, your password is too
    weak, try again.”
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个可以告诉我们密码是否强大的函数，让我们编写一个从用户处获取强密码的函数。它会一遍又一遍地要求输入密码，直到用户输入一个强密码。这种代码就是网站在告诉你“抱歉，你的密码太弱，请再试一次”时使用的那种代码。
- en: 'What should the header for such a function look like? Well, it’s going to ask
    the user for a password, but we won’t have a password parameter. In fact, we won’t
    have any parameters at all because the function doesn’t need any information to
    do its job—it just has to prompt the user, and the user will type the password
    at the keyboard. When the function has done its work, it will return the strong
    password, so it will continue to return a string as the output. Let’s try this
    prompt:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的函数的头部应该是什么样的呢？嗯，它将会要求用户输入密码，但我们不会有密码参数。事实上，我们根本不需要任何参数，因为这个函数不需要任何信息来完成它的工作——它只需要提示用户，而用户会在键盘上输入密码。当函数完成其工作后，它将返回强密码，因此它将继续返回一个字符串作为输出。我们可以尝试这个提示：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We get the following code from Copilot as a result:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 Copilot 得到以下代码作为结果：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '#1 It’s calling our earlier is_strong_password function!'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 它正在调用我们之前的 is_strong_password 函数！'
- en: That `while` keyword creates another kind of loop, this one continuing as long
    as the entered password isn’t strong. Copilot is also smart enough to call our
    earlier `is_strong_password` function to determine what counts as a strong password.
    As you’ll see in future chapters, using functions as building blocks in this way
    is precisely how large programs are built. You’ll often notice Copilot calling
    your earlier functions to solve later ones, much as we observed here.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`关键字创建了另一种类型的循环，这种循环会一直继续，直到输入的密码足够强大。Copilot足够聪明，会调用我们之前的`is_strong_password`函数来判断什么算是强密码。正如你将在后续章节中看到的，像这样将函数作为构建块使用，正是大型程序构建的方式。你会经常注意到Copilot调用你之前的函数来解决后面的任务，就像我们在这里观察到的那样。'
- en: 'Let’s test this! Highlight all the code from our two password functions, and
    press Shift-Enter. We’ll call the function that we want to test. Then, try typing
    passwords, pressing Enter after each one. You’ll notice that it keeps asking until
    you finally provide a strong password:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下！选中我们两个密码函数的所有代码，并按下Shift-Enter。然后，我们调用我们想要测试的函数。接着，尝试输入密码，并在每次输入后按Enter。你会注意到它会一直要求输入，直到你最终提供一个强密码：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that it stops asking us for a password when we finally provide a strong
    password. Then, we see the string in quotes that it returned, which is, indeed,
    our strong password.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们最终提供一个强密码时，它就不再要求我们输入密码了。接着，我们会看到它返回的带引号的字符串，这正是我们的强密码。
- en: 3.3.4 Scrabble scoring
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.4 拼字游戏计分
- en: One of Dan’s favorite board games is Scrabble. Have you played it? If not, all
    you need to know is that you have some tiles in your hand, each with a letter
    on it, and your goal is to form a word using any combination of those letters.
    You don’t need to form the word exclusively with your tiles—you can attach those
    letters to existing letters on the board to create longer words—but we’re not
    going to worry about that here. The important thing for us is that different letters
    are worth different numbers of points. For example, an *a* is worth only 1 point
    because *a* is such a common letter. But *q* and *z*? Those doozies are each worth
    10 points because they’re so tough to use—or should we say *puzzling* to use.
    Yeah, that’s better.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Dan最喜欢的桌面游戏之一是拼字游戏（Scrabble）。你玩过吗？如果没有，你需要知道的是，你手中有一些字母牌，你的目标是用这些字母组成一个单词。你不必完全依赖你的字母牌来组成单词——你可以将这些字母连接到已有的字母上，从而创造更长的单词——但这里我们不讨论那个。对我们来说重要的是，不同的字母对应不同的分数。例如，*a*仅值1分，因为*a*是一个非常常见的字母。但*q*和*z*呢？这些字母每个都值10分，因为它们难以使用——或者我们可以说，用它们*令人费解*。嗯，这样更好。
- en: To calculate the score for a word, we add up the scores for each of its letters.
    For example, the score for *zap* would be 14\. That’s because *z* is worth 10,
    *a* is worth 1, and *p* is worth 3.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 计算一个单词的分数时，我们将每个字母的分数加起来。例如，*zap*的分数是14。原因是*z*值10，*a*值1，*p*值3。
- en: 'Dan would like a function that, given a word, tells him how many points that
    word is worth. OK, so we need a function that takes a word (which is just one
    parameter). Let’s try this prompt, where we’ve included the number of points that
    each letter is worth per official Scrabble rules:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Dan想要一个函数，给定一个单词，告诉他这个单词值多少分。好吧，所以我们需要一个函数，它接受一个单词（也就是一个参数）。让我们尝试这个提示，其中我们列出了每个字母在官方拼字游戏规则中的分值：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For this function, Copilot isn’t filling in the whole body for us with one press
    of the Tab key. Tab is also used to indent the code, which we also need to do
    here before Copilot will present us with code. So, we’re having to press Tab (sometimes
    once for the indentation and then again for Copilot), wait for the code to appear,
    then press Tab to accept that code, then press Enter again for more code to be
    presented, and repeat the process.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个函数，Copilot不会仅通过按Tab键来填充整个函数体。Tab键也用于缩进代码，在这里我们也需要这么做，Copilot才会为我们展示代码。所以，我们需要按Tab（有时按一次用于缩进，然后再按一次给Copilot），等待代码出现，然后按Tab接受这段代码，再按Enter让更多代码显示出来，并重复这个过程。
- en: Getting Copilot to suggest code may require pressing Tab or Enter
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 要让Copilot建议代码，可能需要按下Tab键或Enter键。
- en: We find that Copilot will sometimes pause in giving suggestions until you press
    a key to help prompt it. As mentioned in table 2.1, if you’re giving it comments,
    Copilot will sometimes just want to give you more comments as suggestions. Pressing
    Enter another time can often trigger it to start generating code instead. Other
    times, pressing Tab will cause it to continue providing suggestions. Refer to
    table 2.1 if Copilot isn’t generating code for you.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现Copilot有时会在提供建议时暂停，直到你按下一个键来帮助提示它。正如表2.1中所提到的，如果你给它评论，Copilot有时只想给你更多的评论作为建议。再按一次回车通常能触发它开始生成代码。其他时候，按Tab键会使它继续提供建议。如果Copilot没有为你生成代码，请参考表2.1。
- en: 'Finally, after doing that a few times, the entire code unfurls, and we get
    the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，做了几次之后，整个代码展开，我们得到如下结果：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice that all the letters of the alphabet are accounted for here, and the
    number of points that each category is worth is on the following line. We’ll discuss
    this overall kind of decision structure in the next chapter, but, at a high level,
    it’s walking through the word character by character and, for each character,
    figuring out which letter it is and adding the appropriate number of points for
    that letter.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里已经列出了所有字母，并且每个类别的得分在下一行给出。我们将在下一章讨论这种整体的决策结构，但从高层次来看，它是逐个字符地遍历单词，对于每个字符，找出它是什么字母，并为该字母添加相应的分数。
- en: 'Let’s test this to make sure our code is performing the way we want. We know
    that the word *zap* should be worth 14 points, and it is:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下，确保我们的代码按预期执行。我们知道单词 *zap* 应该值14分，结果也确实是这样：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let’s try a couple more. In each case, calculate by hand what you expect the
    answer to be—that way, you’ll know if the code is doing the right thing:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再尝试几个。在每个例子中，手动计算一下你预期的答案是什么——这样，你就能知道代码是否做对了：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There are many ways to write correct code for a function. If you press Ctrl-Enter
    and look at the Copilot suggestions, you may see different types of code. It doesn’t
    necessarily mean that one of these types is right and the others are wrong. For
    example, here’s another solution for `num_points` that we got from the other Copilot
    suggestions:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多方法可以编写正确的函数代码。如果你按Ctrl-Enter并查看Copilot的建议，你可能会看到不同类型的代码。这并不一定意味着某种类型是对的，其他的就是错的。例如，这是我们从其他Copilot建议中得到的`num_points`的另一种解法：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Notice here that each letter is listed individually along with its number of
    points. This structure with the letters and points is called a *dictionary*, and
    again, you’ll learn about dictionaries properly in a later chapter. The point
    for now is just that there are often multiple, equivalently good ways for Copilot
    to write the code for a function. Give this one a try with some test cases before
    you continue!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里每个字母都列出了，并附上了其得分。这种包含字母和分数的结构叫做 *字典*，而你将在后面的章节中更深入地学习字典。目前要记住的是，Copilot通常会有多种同样有效的方式来编写函数代码。在继续之前，尝试一下这个，并运行一些测试用例！
- en: 3.3.5 The best word
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.5 最佳单词
- en: Let’s continue with the Scrabble theme. Suppose that Dan has a bunch of words
    that he can make right now, but he doesn’t know which one will give him the most
    points. Should he make the word *zap*, *pack*, or *quack*? It would be nice if
    we had a function that could take a bunch of words and tell us which is the best
    one.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续以拼字游戏为主题。假设Dan现在可以构造出一堆单词，但他不知道哪个单词能获得最多的分数。他应该拼写 *zap*、*pack* 还是 *quack*
    呢？如果我们有一个函数，能够接受一堆单词并告诉我们哪个是最好的，那就太好了。
- en: How many parameters should we have in such a function? Your first instinct may
    be three parameters, one for each of the 3 words in our options. But that wouldn’t
    be very flexible. After all, what if we want to know the best of 5 words, 10 words,
    or 50 words? We would like our function to work no matter how many words we’re
    considering.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的函数中，我们应该有多少个参数呢？你最初的直觉可能是三个参数，每个参数对应我们选项中的三个单词。但这并不够灵活。毕竟，如果我们想要知道最佳的5个单词、10个单词或50个单词的情况怎么办呢？我们希望我们的函数无论考虑多少个单词都能正常工作。
- en: 'The trick is to use a function with one (yes, just one!) parameter, which is
    a *list* of words. Just like numbers, strings, and dictionaries, a `list` is a
    type supported by Python. It’s incredibly useful because it allows us to collect
    as many values into one place as we like. We can prompt Copilot like this to get
    the function that we want:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 诀窍是使用一个带有一个（没错，就是一个！）参数的函数，这个参数是一个*单词列表*。就像数字、字符串和字典一样，`list`是Python支持的一种类型。它非常有用，因为它允许我们将任意多个值收集到一个地方。我们可以像这样提示Copilot来获得我们想要的函数：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'How will Copilot know how many points each word is worth? Well, it can call
    that `num_points` function that we wrote in the previous section! Here’s the code
    that Copilot gives us:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Copilot如何知道每个单词的分数呢？好吧，它可以调用我们在上一节写的`num_points`函数！这是Copilot给出的代码：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We need to be careful to call this function correctly when testing. Using
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试时，我们需要小心正确调用这个函数。使用
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'won’t work because that’s passing values for three parameters, not one. The
    right way to call it is to put the words inside square brackets, like this (we’ll
    see more about lists in the next chapter):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 是行不通的，因为那是传递了三个参数的值，而不是一个。正确的调用方法是将单词放入方括号中，像这样（我们将在下一章看到更多关于列表的内容）：
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'But, as usual, you shouldn’t be content with just one test case. This function
    should work in other valid but perhaps strange cases too, such as when we have
    only one word in the list:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，像往常一样，你不应该仅仅满足于一个测试用例。这个函数也应该在其他有效但可能很奇怪的情况下工作，例如当我们列表中只有一个单词时：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: However, we wouldn’t test this function on a list that has no words in it. What
    would it even make sense to do in that case? Regardless of what the function does,
    it’d be hard to say one way or the other whether it was doing the correct thing
    in a situation where there really is no correct behavior!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不会在一个没有单词的列表上测试这个函数。在这种情况下，做什么才有意义呢？无论函数怎么做，若没有正确的行为，判定它是否正确就变得困难。
- en: 3.4 Benefits of functions
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 函数的好处
- en: 'Now that you’ve seen a number of functions, we hope you’re starting to get
    a feel for how functions are used in software. We already mentioned that functions
    are critical in performing problem decomposition. Beyond problem decomposition,
    functions are valuable in software for a number of other reasons, including the
    following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看过了许多函数，我们希望你已经开始对软件中函数的使用有了些许了解。我们之前提到过，函数在问题分解中至关重要。除了问题分解之外，函数在软件中的价值还体现在许多其他方面，包括以下几点：
- en: '**Cognitive load —*You may have heard of cognitive load [1] before. It’s the
    amount of information your brain can handle at any given time and still be effective.
    If you’re given four random words and asked to repeat them back, you might be
    able to do that. If you’re given the same task with 20 words, most of us would
    fail because it’s too much information to handle at once. Similarly, if you’ve
    ever been on a road trip with your family and are trying to optimize the travel
    time, combined with stops for the kids, lunch breaks, bathroom stops, gas station
    stops, good locations for hotels, and so on, you might have felt your head swimming
    to manage all those constraints at once. That point when you can’t handle it all
    at once is when you’ve exceeded your own brain’s processing power. Programmers
    have the same problem. If they are trying to do too much at once or solve too
    complex a problem in one piece of code, they struggle to do it correctly. Functions
    are designed to help programmers avoid doing too much work at once.*'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认知负荷 —*你可能听说过认知负荷[1]。它是指大脑在任何给定时间内可以处理的有效信息量。如果给你四个随机单词并要求你重复，你可能可以做到。如果给你同样的任务，但是是20个单词，大多数人都会失败，因为这太多信息一下子无法处理。类似的，如果你曾经和家人一起自驾旅行，并试图优化旅行时间，同时还得考虑孩子们的休息、午餐、厕所休息、加油站、酒店位置等等，你可能会感觉头脑混乱，无法同时管理所有这些约束。那时你就超过了大脑的处理能力。程序员也面临同样的问题。如果他们试图在一次编写的代码中做太多事或解决过于复杂的问题，他们往往会遇到困难。函数的设计正是为了帮助程序员避免一次性做太多工作。*'
- en: '**   **Avoid repetition —*Programmers (and, we’d argue, humans in general)
    aren’t very excited about solving the same problem over and over. If I write a
    function that can correctly compute the area of a circle once, I don’t need to
    write that code ever again. That means if I have two sections of my code that
    need to compute the area of a circle, I’d write one function that computes the
    area of the circle, and then I’d have my code call that function in each of those
    two places.***   *Improve* **testing —*It’s a lot harder to test a section of
    code that does multiple things compared to code that does one thing. Programmers
    use a variety of testing techniques, but a key technique is known as *unit testing*.
    Every function takes some input and produces some output. For a function that
    computes the area of a circle, for example, the input would be the circle’s radius,
    and the output would be its area. Unit tests give a function an input and then
    compare that input to the desired result. For the area-of-a-circle function, we
    might test it by giving it varying inputs (e.g., some small positive numbers,
    some large positive numbers, and 0) and compare the result of the function against
    the values we know to be correct. If the answers from the function match what
    we expect, we have a higher degree of confidence that the code is correct. If
    the code produces a mistake, we won’t have much code to check to find and fix
    the problem. But if a function does more than one task, it vastly complicates
    the testing process because you need to test each task and the interaction of
    those tasks.***   **Improve reliability —*When we write code as experienced software
    engineers, we know we make mistakes. We also know Copilot makes mistakes. If you
    imagine you’re an amazing programmer and each line of code you write is 95% likely
    to be correct, how many lines of code do you think you can write before at least
    one of those lines is likely to be incorrect? The answer is only 14\. We think
    95% correctness per line is probably a high bar for even experienced programmers
    and is likely a higher bar than what Copilot produces. By keeping the tasks small,
    tasks solvable in 12–20 lines of code, we reduce the likelihood that there’s an
    error in the code. If combined with good testing as noted previously, we can feel
    even more confident that the code is correct. Last, nothing is worse than code
    that has multiple mistakes that interact together, and the likelihood of multiple
    mistakes grows the more code you write. Both of us have been on multi-hour debugging
    expeditions because our code had more than one mistake, and we both became a lot
    better at frequent testing of short pieces of code as a result!***   **Improve
    code readability —*In this book, we mostly use Copilot to write code from scratch,
    but that’s not the only way to use Copilot. If you have a larger piece of software
    that you or your coworkers are all editing and using, Copilot can jump in to help
    write code for that too. It’s in everyone’s interest to understand the code, whether
    most of it is written by humans or by Copilot. That way, we can find bugs more
    easily, determine what code to start modifying when we want to add new features,
    and understand at a high level what would be easy or difficult to achieve with
    our overall program design. Having tasks broken down into functions helps us understand
    what each part of the code is doing so we can gain better insight into how it
    all works together. It also helps divide up the work and responsibility for ensuring
    the code is correct.*****'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免重复 —*程序员（而且我们认为，一般人类也是）对于不断重复解决相同问题并不感兴趣。如果我写了一个能够正确计算圆的面积的函数，那么我就不需要再写这段代码。那意味着，如果我的代码中有两个部分需要计算圆的面积，我就会写一个函数来计算圆的面积，然后在这两个地方调用这个函数。***
    *提高* **测试 —*相比做多件事的代码，测试只做一件事的代码要容易得多。程序员使用多种测试技术，其中一个关键的技术叫做*单元测试*。每个函数都有输入并产生输出。例如，对于一个计算圆面积的函数，输入是圆的半径，输出是它的面积。单元测试会给函数一个输入，然后将该输入与期望的结果进行比较。对于圆面积的函数，我们可能会通过给它不同的输入（例如一些小的正数，一些大的正数，和0）来测试它，并将函数的结果与我们知道的正确值进行比较。如果函数的结果与预期一致，我们就可以更有信心地认为代码是正确的。如果代码有错误，我们不需要检查太多的代码来找到并修复问题。但如果一个函数做多项任务，那么测试过程会变得更加复杂，因为你需要测试每项任务及其相互作用。***
    **提高可靠性 —*当我们作为经验丰富的软件工程师写代码时，我们知道我们会犯错误。我们也知道Copilot会犯错误。如果你想象自己是一个很棒的程序员，并且你写的每行代码有95%的概率是正确的，那么你认为你可以写多少行代码，直到至少有一行是错误的？答案是只有14行。我们认为每行95%的正确率对于经验丰富的程序员来说可能已经是一个很高的标准，而且可能比Copilot产生的代码质量还要高。通过将任务保持在小范围内，每个任务可以在12到20行代码内解决，我们就能降低代码出错的可能性。如果结合之前提到的良好测试，我们可以更有信心地认为代码是正确的。最后，没有什么比代码中存在多个相互影响的错误更糟糕了，而随着你写的代码增多，出现多个错误的可能性也会增加。我们俩都曾经历过多小时的调试，因为我们的代码中有多个错误，而且我们因此变得更加善于频繁测试小段代码！***
    **提高代码可读性 —*在本书中，我们主要使用Copilot从头开始写代码，但这并不是唯一的使用方式。如果你有一个较大的软件，且你或你的同事都在编辑和使用，Copilot也可以帮助写这部分代码。无论代码大部分是由人类写的还是由Copilot写的，大家理解代码都是有利的。这样我们可以更容易地找到bug，确定在我们想要添加新特性时应该修改哪些代码，并且高层次上了解哪些功能的实现容易，哪些则较难实现。将任务拆解成函数帮助我们理解代码的每一部分在做什么，这样我们就能更好地了解它们如何协同工作。这也有助于分配工作和责任，确保代码的正确性。*****'
- en: '**These benefits are huge for programmers. Programming languages haven’t always
    had functions. But even before they did, programmers did their best to use other
    features to mimic functions. They were ugly hacks (google “goto statements” if
    you’re interested), and all programmers are happy that we have proper functions
    now.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**这些好处对程序员来说非常重要。编程语言并非一开始就有函数。即使在函数出现之前，程序员也尽力利用其他特性来模拟函数。它们是一些丑陋的技巧（如果你感兴趣，可以搜索“goto
    语句”），所有程序员都很高兴现在我们有了真正的函数。'
- en: You may be asking, “I see how these advantages matter to humans, but how do
    they affect Copilot?” In general, we believe all the principles that apply to
    humans apply to Copilot, albeit sometimes for different reasons. Copilot may not
    have cognitive load, but it’s going to do better when we ask it to solve problems
    similar to what’s been done by humans before. Because humans write functions to
    solve tasks, Copilot will mimic that and write functions as well. Once we’ve written
    and tested a function, whether by hand or by Copilot, we don’t want to write it
    again. Knowing how to test if your program is working properly is just as essential
    for code produced by humans as it is by Copilot. Copilot is as likely to make
    mistakes when it generates code, so we want to catch those mistakes quickly, just
    as we do with human-written code. Even if you only work on your own code and never
    have anyone else read it, you’ll often have to go back years later to edit what
    you’ve written. Having done this ourselves, we can attest that it’s important
    for your code to be readable for your future self!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，“我明白这些优势对人类有什么影响，但它们对 Copilot 有什么影响？”通常来说，我们认为适用于人类的所有原则也适用于 Copilot，尽管有时原因不同。Copilot
    可能没有认知负担，但当我们让它解决与人类之前做过的相似的问题时，它会表现得更好。因为人类编写函数来解决任务，Copilot 也会模仿这种方式，编写函数。一旦我们编写并测试了一个函数，无论是手动编写还是
    Copilot 编写，我们都不想再写一遍它。了解如何测试你的程序是否正常工作，对人类编写的代码和 Copilot 生成的代码同样重要。Copilot 在生成代码时也很可能会犯错，所以我们希望能尽早发现这些错误，就像我们对待人工编写的代码一样。即使你只是在处理自己的代码，永远没有人会阅读它，你也常常需要在几年后回去编辑你写过的内容。我们亲自经历过这一过程，可以证明，让你的代码对未来的自己可读是非常重要的！
- en: 3.5 Roles of functions
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 函数的作用
- en: Functions are used in many different roles in programming. At a high level,
    programs are functions that (often) call other functions. Critically, all programs,
    including Python programs, originate with a single function (named `main` in languages
    such as Java, C, and C++). Python’s `main` function is essentially the first line
    of code that isn’t in a function. But if every program starts with a single function
    and trying to solve a large problem with a single function is a mistake, how does
    that work? Well, `main` will call other functions, which, in turn, will call other
    functions, and so forth. The code will still execute (mostly) sequentially in
    each function, so it may start in `main` but then move to another function, and
    so on.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，函数有许多不同的作用。从高层次来看，程序是函数，它们（通常）会调用其他函数。关键是，所有程序，包括 Python 程序，都从一个函数开始（在
    Java、C 和 C++ 等语言中，这个函数通常叫做 `main`）。Python 的 `main` 函数本质上是代码中第一个不在函数中的代码行。但是，如果每个程序都从一个函数开始，而试图用一个函数解决一个大问题是错误的，那怎么解决呢？其实，`main`
    会调用其他函数，后者又会调用其他函数，如此循环。代码仍然会在每个函数内按顺序执行，所以它可能从 `main` 开始，然后进入另一个函数，依此类推。
- en: As an example, let’s use the code in the following listing. We wrote this code,
    not Copilot, because no one would ever want to write this code for anything useful
    outside of teaching. It’s just for demonstrating how function calls work.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，下面的代码就是我们写的，不是 Copilot 写的，因为没有人会想要写这种毫无实际用途的代码，除非是为了教学。这段代码只是为了演示函数调用的工作原理。
- en: Listing 3.1 Code to demonstrate how Python handles function calls
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3.1 演示 Python 如何处理函数调用的代码
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '#1 This is the start of the program. We’ll call this “main” after the main
    function in other languages.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 这是程序的开始部分。我们将把它称为“main”，就像其他编程语言中的主函数一样。'
- en: 'If we ran this program, the output would be (we’ll explain why next):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个程序，输出结果将会是（我们稍后会解释原因）：
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In figure 3.5, we provide a diagram of how the code in listing 3.1 would be
    executed by the computer. We’ve intentionally provided an example that has many
    function calls to tie together what we just learned. Again, this is *not* practical
    code; it’s just for learning purposes. Let’s trace through the code execution
    together. It may be easier to refer to figure 3.5 than listing 3.1 as you follow
    along, but either will work.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 3.5 中，我们提供了一个示意图，展示了计算机如何执行清单 3.1 中的代码。我们故意提供了一个包含多个函数调用的示例，以便把我们刚学到的内容串联起来。再次强调，这*不是*实际的代码，它只是为了学习目的。让我们一起跟踪代码执行。你在跟随过程中可能会觉得参考图
    3.5 比清单 3.1 更容易，但无论哪种方式都可以。
- en: '![figure](../Images/3-5.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/3-5.png)'
- en: Figure 3.5 Flow of function execution in our example from listing 3.1
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.5 我们示例中从清单 3.1 中的函数执行流程
- en: 'The program will start execution with the first line in the Python code that
    isn’t a function ( `print("Hi")`). Although Python doesn’t have a `main` function
    per se, we’ll refer to the block of code after the functions as `main` to help
    with this explanation. Code executes sequentially unless it encounters commands
    that tell it to execute code somewhere else. So, after executing `print("Hi")`,
    it will go to the next line, which is the call to `funct1`: `funct1()`. The call
    to `funct1` changes where the code is executing to the start of that function,
    which is the following statement: `print("there")`. The next line of `funct1`
    calls `funct2`, so the program will execute the first line of `funct2`: `print("my")`.
    What gets interesting is what happens when `funct2` finishes. There are no more
    lines of code to execute, so it automatically moves execution back to the first
    line following the call to `funct2` in `funct1`. (If the function call is in the
    middle of another statement, that statement resumes execution, but for this example,
    the function calls are each on their own line.) You may be curious why it goes
    to the next line after the call to `funct2` rather than back to the call of `funct2`.
    The problem is if it returned back to the call to `funct2`, it would be trapped
    calling `funct2` forever. As a result, functions always return back to the next
    piece of code to execute (in this example, the next line) after they are called.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将从 Python 代码中不是函数的第一行开始执行（`print("Hi")`）。尽管 Python 本身没有 `main` 函数，但为了方便解释，我们会把函数之后的代码块称为
    `main`。代码会顺序执行，除非遇到命令指示它去执行其他地方的代码。所以，在执行完 `print("Hi")` 后，它会转到下一行，也就是对 `funct1`
    的调用：`funct1()`。调用 `funct1` 会改变代码的执行位置，跳到该函数的开头，即以下语句：`print("there")`。`funct1`
    的下一行代码调用 `funct2`，所以程序会执行 `funct2` 的第一行：`print("my")`。有趣的是当 `funct2` 执行完后会发生什么。由于没有更多的代码可以执行，它会自动将执行控制返回到
    `funct1` 中 `funct2` 调用后的第一行（如果函数调用出现在其他语句的中间，那个语句会接着执行，但在这个示例中，每个函数调用都是单独的一行）。你可能会好奇，为什么它会回到
    `funct2` 调用后的下一行，而不是回到 `funct2` 的调用处。问题在于，如果它回到 `funct2` 的调用处，程序就会陷入一直调用 `funct2`
    的死循环。因此，函数始终会在调用之后返回到接下来的代码片段（在这个例子中是下一行）执行。
- en: Continuing this example, the next line of the code executed will be the line
    that prints `friend`. The next line calls `funct3`, which prints a period (.)
    and then returns back to its caller.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接着执行的下一行代码会打印 `friend`。接下来的那一行调用 `funct3`，打印一个句点（.），然后返回到调用它的地方。
- en: 'So, we’re back in `funct1`, on the line `print("")`. Printing an empty piece
    of text causes a new line. Now `funct1` is finished, so it transfers execution
    back to the next line in `main` after it was called. We suspect you’re getting
    the idea by now, so let’s move a bit more quickly:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们回到 `funct1`，在 `print("")` 这一行。打印一个空文本会导致换行。现在 `funct1` 执行完了，因此它将执行控制权返回到
    `main` 中被调用后的下一行。我们猜到你已经大致理解了这个过程，现在让我们加快步伐：
- en: '`main` next prints `I''m` and then calls `funct4`.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main` 接着打印 `I''m`，然后调用 `funct4`。'
- en: '`funct4` prints `well` and then returns to `main` where the next line of code
    calls `funct3`.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`funct4` 打印 `well`，然后返回到 `main`，接下来的一行代码调用 `funct3`。'
- en: '`funct3` prints a period (.) and then returns to `main`. Notice that `funct3`
    was called both by `funct1` and by `main`, but that’s okay because functions remember
    how to return to the function that called them. In fact, having multiple functions
    calling the same function is a sign that the function being called multiple times
    is a good function because of its reuse.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`funct3` 打印一个句点（.），然后返回到 `main`。注意，`funct3` 被 `funct1` 和 `main` 都调用了，但这没问题，因为函数会记住如何返回到调用它们的函数。事实上，多个函数调用同一个函数是该函数可重用性强的标志。'
- en: After `funct3` returns to main, it will print `""`, which causes a new line
    to be started, and then it prints the word `Bye`.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`funct3`返回到主函数时，它会打印`""`，这会开始一个新行，然后打印单词`Bye`。
- en: 'That was a long example, but we provided it to give you an idea of how functions
    execute and how programs consist of defining and calling functions. In any software
    you use, think about the specific tasks that it performs: the programmers probably
    wrote one or more functions for each one. The button in a text editor that changes
    the text to bold probably calls a function to change the text to bold. That function
    might change the editor’s internal idea of the text (the editor likely stores
    your text in a different format than how you view it), and then it might call
    another function that updates the user’s (your) view of the text.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个长示例，但我们提供它是为了让你了解函数是如何执行的，以及程序是如何由定义和调用函数组成的。在你使用的任何软件中，想想它执行的具体任务：程序员可能为每个任务写了一个或多个函数。文本编辑器中将文本变为粗体的按钮可能会调用一个函数来改变文本的粗体样式。这个函数可能会改变编辑器内部对文本的理解（编辑器可能以不同于你所看到的格式存储文本），然后它可能会调用另一个函数来更新用户（你的）对文本的显示。
- en: We’d also like to use this example to discuss the different roles that functions
    play. A *helper* function is a function whose job is to make another function’s
    job easier. In a sense, every function that isn’t `main` is a helper function.
    The best helper functions are those that carry out some small, well-defined part
    of some other task, such as our `is_strong_password` function in section 3.3.2
    serving as a helper function for our `get_strong_password` function in section
    3.3.3.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想利用这个示例来讨论函数所扮演的不同角色。*辅助*函数是指通过简化其他函数的工作来完成任务的函数。从某种意义上来说，除了`main`函数之外的每个函数都是辅助函数。最好的辅助函数是那些执行某个其他任务的小而明确的部分，例如我们在第3.3.2节中介绍的`is_strong_password`函数，它作为`get_strong_password`函数的辅助函数，在第3.3.3节中有提到。
- en: Some functions simply call a bunch of other functions without doing any of their
    own work. There aren’t any of these in our example. However, if you removed the
    three `print` statements from `funct1`, it becomes this type of coordinating function.
    Others may call helper function(s) and then do some work on their own. `funct1`
    is a great example of a function that calls other functions but also does work
    on its own.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有些函数仅仅调用一堆其他函数，而没有做任何自己的工作。我们的示例中没有这样的函数。然而，如果你从`funct1`中删除了三条`print`语句，它就变成了这种类型的协调函数。其他函数可能会调用辅助函数，然后自己做一些工作。`funct1`是一个很好的例子，它调用了其他函数，但也做了一些自己的工作。
- en: Another type of function—which we call a *leaf* function—stands on its own without
    calling other functions for help (except perhaps functions that already come with
    Python). Why leaf? If you imagine all the function calls as a big tree, these
    functions are the leaves of the tree because they have nothing coming out of them.
    `funct2`, `funct3`, and `funct4` are all leaf functions in our example. We’re
    primarily concerned with leaf functions in this chapter, but you’ll see examples
    of other kinds of functions here and especially in later chapters.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类型的函数——我们称之为*叶子*函数——独立存在，不需要调用其他函数的帮助（除了可能是 Python 自带的函数）。为什么叫叶子？如果你把所有的函数调用想象成一棵大树，这些函数就是树的叶子，因为它们没有其他的调用。`funct2`、`funct3`和`funct4`都是我们示例中的叶子函数。本章我们主要关注叶子函数，但你会在这里以及后续章节中看到其他类型的函数的示例。
- en: 3.6 What’s a reasonable task for a function?
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.6 函数的合理任务是什么？
- en: There’s no clear rule for what makes a good function, but there are some intuitions
    and recommendations we can share. Make no mistake, though—identifying good functions
    is a skill that takes time and practice. To help you with this, we gave you some
    examples of good functions in section 3.3\. In this section, we’ll outline our
    recommendations and provide you with some additional good and bad examples to
    help build that intuition.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 没有明确的规则来定义什么是一个好的函数，但我们可以分享一些直觉和建议。不过，不要误解——识别良好的函数是一项需要时间和实践的技能。为了帮助你，我们在第3.3节中提供了一些良好函数的示例。在这一节中，我们将概述我们的建议，并提供一些额外的好坏示例，帮助你培养这种直觉。
- en: 3.6.1 Attributes of good functions
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.1 良好函数的特点
- en: 'Here are some guidelines that we believe will help you see what makes a good
    function:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们认为有助于你理解什么是良好函数的指南：
- en: '*One clear* **task to perform —*A leaf function might be something like “compute
    the volume of a sphere,” “find the largest number in a list,” or “check to see
    if a list contains a specific value.” Nonleaf functions can achieve broader goals,
    like “update the game graphics” or “collect and sanitize input from the user.”
    Nonleaf functions should still have a particular goal in mind, but they are designed
    knowing that they will likely call other functions to achieve their goal.*'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一个明确的* **任务执行—*叶子函数可能是像“计算一个球体的体积”、“找出列表中的最大数字”或“检查列表是否包含特定值”这样的功能。非叶子函数可以实现更广泛的目标，比如“更新游戏图形”或“收集并清理用户输入”。非叶子函数仍然应该有明确的目标，但它们的设计是基于会调用其他函数来实现目标的前提。*'
- en: '**   **Clearly defined behavior —*The task “find the largest number in a list”
    is clearly defined. If I gave you a list of numbers and asked you for the largest
    number, you know what you should do. In contrast, the task “find the best word
    in the list” is poorly defined as stated. You need more information: What is the
    “best” word? Is it the longest, the one that uses the fewest vowels, or the one
    that doesn’t share any of the same letters as “Leo” or “Dan”? You get the point;
    subjective tasks aren’t great for computers. Instead, we could write the function
    “find the word in the list that has the most characters” because what is expected
    is well defined. Often, programmers can’t put all the particulars of a function
    just in the name, so they fill in the details in the docstring to clarify its
    use. If you find yourself having to write more than a few sentences to describe
    the function’s behavior, the task is probably too much for a single function.***   **Short
    in number of lines of code —*We’ve heard different rules over the years for the
    length of functions, informed by different company style guidelines. The lengths
    we’ve heard vary from 12 to 20 lines of Python code as the maximum number of lines.
    In these rules, the number of lines is being used as a proxy for code complexity,
    and it’s not a bad rule of thumb. As programmers ourselves, we both apply similar
    rules to our code to ensure the complexity doesn’t get out of hand. With Copilot,
    we can use this as a guide as well. If you ask Copilot for a function, and it
    gives you back 50 lines of code, this probably isn’t a good function name or task.
    As we discussed earlier, that many lines of code are likely to have errors anyway.***   **General
    value over specific use —*A function that returns the number of values in a list
    that are greater than 1 might be a specific need for a part of your program, but
    there’s a way to make this better. The function should be rewritten to return
    the number of values in the list that are greater than another parameter. The
    new function would work for your use case (give the function 1 for the second
    parameter) and for any value other than 1\. We strive to have functions be as
    simple but as powerful as possible. This is why we wrote our function in section
    3.3.1 to work for any stock, not just AAAPL.***   **Clear input and output —*You
    generally don’t want a lot of parameters. That doesn’t mean you can’t have a lot
    of input, though. A single parameter could be a list of items, as in our `best_word`
    function in section 3.3.5\. It does mean that you want to find ways to keep the
    number of inputs to a minimum. You can only return one thing, but again, you can
    return a list so you aren’t as limited as it may appear. But if you find yourself
    writing a function that sometimes returns a list, sometimes returns a single value,
    and sometimes returns nothing, that’s probably not a good function.*****'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**   **行为清晰定义 —*任务“在列表中找到最大的数字”定义明确。如果我给你一个数字列表并让你找出最大的数字，你知道该怎么做。相反，任务“找到列表中最好的单词”定义不清楚。你需要更多的信息：“最好的”单词是什么？是最长的，还是使用最少元音的，或者是与“Leo”或“Dan”没有任何相同字母的？你明白我的意思了；主观任务不适合计算机。相反，我们可以编写函数“在列表中找到字符最多的单词”，因为预期的结果是明确的。通常，程序员不能将函数的所有细节都写在函数名中，因此他们会在文档字符串中填充细节以澄清其用途。如果你发现自己不得不写超过几句话来描述函数的行为，那么这个任务可能对单个函数来说太复杂了。***   **代码行数简短 —*多年来，我们听到过关于函数长度的不同规则，这些规则受到不同公司风格指南的影响。我们听到的规则长度从12行到20行Python代码不等，作为最大行数。在这些规则中，行数被用作代码复杂性的代理，作为一个经验法则，这并不是一个坏的做法。作为程序员，我们自己也会对代码应用类似的规则，以确保复杂性不会失控。通过Copilot，我们也可以将此作为指导。如果你请求Copilot给你一个函数，而它给你回了50行代码，那么这个函数名或任务可能就不太合适了。正如我们之前讨论的，很多行代码很可能本来就会有错误。***   **通用值优于特定用途 —*一个返回列表中大于1的值的个数的函数可能是程序中某部分的特定需求，但有一种方法可以让它变得更好。函数应该改写为返回列表中大于另一个参数的值的个数。新的函数将适用于你的使用案例（给第二个参数传1）和任何其他值，而不仅仅是1。我们努力让函数既简单又强大。这也是我们在第3.3.1节中编写函数以适用于任何股票，而不仅仅是AAAPL的原因。***   **清晰的输入和输出 —*你通常不希望有太多参数。但这并不意味着你不能有很多输入。一个单一的参数可以是一个项的列表，正如我们在第3.3.5节中的`best_word`函数。它的确意味着你希望找到方法将输入的数量保持到最小。你只能返回一个东西，但同样，你可以返回一个列表，这样你就不那么受限制了。但如果你发现自己在编写一个有时返回列表、有时返回单个值、有时什么都不返回的函数，那么这个函数可能就不好了。*****'
- en: '**### 3.6.2 Examples of good (and bad) leaf functions'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**### 3.6.2 良好（和不良）叶函数的示例'
- en: 'Here are examples of good leaf functions (the function is on the left in italics,
    and the goal of that function is described on the right):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些好的叶函数示例（左侧是函数，右侧描述了该函数的目标）：
- en: '*Compute the volume of a sphere —*Given the sphere’s radius, return its volume.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*计算球体的体积 —*给定球体的半径，返回其体积。'
- en: '*Find the largest number in a list —*Given a list, return the largest value.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*查找列表中的最大值 —*给定一个列表，返回最大值。'
- en: '*Check whether a list contains a specific value —*Given a list and a value,
    return True if the list contains the value and False if it does not.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*检查列表是否包含特定值 —*给定一个列表和一个值，如果列表中包含该值，则返回True，否则返回False。'
- en: '*Print the state of the checkers game —*Given a 2D list representing the game
    board, output the game board to the screen in text.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*打印跳棋游戏的状态 —*给定一个表示棋盘的二维列表，将棋盘以文本形式输出到屏幕上。'
- en: '*Insert a value in a list —*Given a list, a new value, and a location in the
    list, return a new list that is the old list with the new value inserted at the
    desired location.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在列表中插入一个值 —*给定一个列表、新的值以及插入位置，返回一个新的列表，其中新值被插入到指定位置。'
- en: 'Here are examples of bad leaf functions and our reasons for why they are bad:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些不好的叶函数示例，以及我们解释为什么它们不好：
- en: '*Request a user’s tax information and return the amount they owe this year —*Perhaps
    in some countries this wouldn’t be too bad, but we can’t imagine this as a single
    function in either the United States or Canada given the complexity of the tax
    rules!'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*请求用户的税务信息并返回他们今年应缴的税额 —*也许在某些国家这并不算太麻烦，但考虑到税务规则的复杂性，在美国或加拿大，这几乎不可能是一个单独的函数！'
- en: '*Identify the largest value in the list and remove that value from the list —*This
    might not seem so bad, but it’s really doing two things. The first is to find
    the largest value in the list. The second is to remove a value from the list.
    We’d recommend two leaf functions, one that finds the largest and one that removes
    the value from the list. However, this might make a good nonleaf function if your
    program needs to perform this task frequently.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*识别列表中的最大值并从列表中移除该值 —*这看起来不算太复杂，但实际上做了两件事。第一件是找出列表中的最大值，第二件是从列表中移除一个值。我们建议使用两个叶函数，一个用来找到最大值，另一个用来移除该值。但如果你的程序需要频繁执行这个任务，这也可以作为一个非叶函数。'
- en: (Thinking of our dataset from chapter 2.) *Return the names of the quarterbacks
    with more than 4,000 yards of passing in the dataset —*This has too much specificity.
    Without a doubt, the number 4,000 should be a parameter. But it’s likely better
    to make a function that takes as input the position (quarterback, running back),
    the statistic (passing yards, games played), and the cutoff that we care about
    (4,000, 8,000) as parameters. This new function provides far more capability than
    the original, allowing a user to call the function to determine not only the names
    of particular quarterbacks who threw for more than 4,000 yards but also, for example,
    running backs who had more than 12 rushing touchdowns.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （思考我们第二章的数据集。）*返回数据集中传球超过4,000码的四分卫名字 —*这个函数的具体性过强。毫无疑问，4,000这个数字应该是一个参数。但更好的做法是创建一个函数，接收位置（四分卫、跑卫）、统计数据（传球码数、比赛场次）以及我们关心的阈值（4,000、8,000）作为参数。这个新函数比原来更强大，允许用户调用该函数来确定不仅仅是传球超过4,000码的四分卫的名字，还可以查询例如跑卫超过12次冲球达阵的名字。
- en: '*Determine the best movie of all time —*This function is too vague. Best movie
    by what definition? What movies should be considered? A better version of this
    might be a function that determines the highest-rated movie by users given at
    least a minimum number of ratings. This function would likely be part of a larger
    program where the function would have data from a movie database (say, IMDB) and
    minimum number of user ratings as inputs. The output of the function would be
    the highest-rated movie that has at least as many ratings as specified.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*确定有史以来最好的电影 —*这个函数太模糊了。最佳电影按什么标准定义？应该考虑哪些电影？更好的版本可能是一个根据用户评分确定最高评分电影的函数，并且要求有至少一定数量的评分。这个函数很可能是一个大型程序的一部分，其中该函数将从一个电影数据库（比如IMDB）获取数据，并且会有用户评分数量作为输入。该函数的输出将是评分最高且至少有指定数量评分的电影。'
- en: '*Play Call of Duty —*This might be the `main` function in the large code base
    for the Call of Duty game, but it’s definitely not a leaf function.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*玩《使命召唤》 —*这可能是《使命召唤》大型代码库中的`main`函数，但它显然不是一个叶函数。'
- en: Overall, in this chapter, you’ve learned about functions in Python and how you
    can use Copilot to help write them. You’ve also learned about the characteristics
    of good functions and how important it is to make sure your functions are solving
    tasks that can be managed well by Copilot.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，在本章中，您了解了 Python 中的函数以及如何利用 Copilot 来帮助编写函数。您还学习了良好函数的特点，以及确保您的函数解决 Copilot
    能够良好处理的任务的重要性。
- en: Our next steps in this book all revolve around understanding whether the code
    produced by Copilot is correct and how to fix it when it isn’t. In the next chapter,
    we’ll start by explaining the basics of being able to read the code produced by
    Copilot because this gives us the first sanity check for whether Copilot is doing
    what we think it should be. Then, in later chapters, we’ll dig deeper into how
    to carefully test the code and what to do when it’s wrong.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 本书接下来的步骤都围绕着理解 Copilot 生成的代码是否正确，以及当它不正确时如何修复它。在下一章中，我们将从解释如何阅读 Copilot 生成的代码的基础知识开始，因为这为我们提供了对
    Copilot 是否按我们预期的方式工作的第一个理智检查。然后，在后续章节中，我们将深入探讨如何仔细测试代码以及当代码错误时该怎么办。
- en: 3.7 Exercises
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.7 练习
- en: Review the following function descriptions, and determine if each is a leaf
    function. Provide reasons for your answers based on the complexity of the tasks
    the functions perform and whether they are likely to require calling additional
    custom functions.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审查以下函数描述，判断每个函数是否是叶函数。根据函数执行的任务复杂性以及是否可能需要调用额外的自定义函数，给出理由。
- en: '*Scrape data.* Given a list of URLs, scrape data from each page, parse the
    content to extract specific information, and save the extracted data to a database.'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*抓取数据。* 给定一组 URL，从每个页面抓取数据，解析内容以提取特定信息，并将提取的数据保存到数据库中。'
- en: '*Process customer orders.* Given a list of customer orders, process each order
    by checking inventory, calculating total price with discounts and taxes, updating
    inventory, and generating an order summary.'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*处理客户订单。* 给定一个客户订单列表，通过检查库存、计算带有折扣和税费的总价、更新库存以及生成订单摘要来处理每个订单。'
- en: '*Find the largest number in a list.* Given a list, return the largest value.'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*找出列表中的最大数字。* 给定一个列表，返回其中的最大值。'
- en: '*Check whether a list contains a specific value.* Given a list and a value,
    return `True` if the list contains the value, and `False` if it does not.'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*检查列表是否包含特定值。* 给定一个列表和一个值，如果列表包含该值，则返回 `True`，如果不包含，则返回 `False`。'
- en: '*Generate student report cards.* Given a list of students and their grades,
    calculate the final grades, assign letter grades, determine class rank, and generate
    a formatted report card for each student.'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*生成学生报告卡。* 给定学生及其成绩的列表，计算最终成绩、分配字母等级、确定班级排名，并为每个学生生成格式化的报告卡。'
- en: 'Review the cycle of designing functions with Copilot as outlined in this chapter.
    This cycle includes steps from determining the function’s behavior to testing
    the generated code. Based on general programming practices, identify which of
    the following steps is *not* included in the cycle described but is commonly part
    of a software development process:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审查本章中描述的使用 Copilot 设计函数的周期。这个周期包括从确定函数行为到测试生成代码的步骤。根据一般的编程实践，识别以下哪个步骤是*不*包括在描述的周期中的，但通常是软件开发过程的一部分：
- en: Verifying the logical correctness of the generated code by running unit tests
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行单元测试验证生成代码的逻辑正确性
- en: Editing the function’s code manually to simplify complex logic after Copilot
    generation
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Copilot 生成代码后手动编辑函数的代码，以简化复杂逻辑
- en: Conducting performance benchmarks on the generated code to ensure efficiency
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对生成的代码进行性能基准测试，以确保其效率
- en: Consulting documentation or external resources to refine the function’s prompt
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查阅文档或外部资源，以完善函数的提示
- en: 'Based on the problem description provided, write a clear and concise prompt
    for Copilot that specifies the task to be completed. Ensure your prompt includes
    all necessary details such as expected inputs, the processing to be performed,
    and the expected output:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据提供的问题描述，为 Copilot 编写清晰简洁的提示，明确要完成的任务。确保您的提示包含所有必要的细节，例如预期输入、需要执行的处理步骤以及预期输出：
- en: In a quaint little town, there was a humble shopkeeper who, every so often,
    would delight his customers with discounts on his goods. To streamline this process,
    he sought to create a magical formula. This formula would take the original price
    of any item in his store and the special discount he wished to offer. With these
    two pieces of information, the formula would then reveal the final price the customer
    needed to pay after the discount was woven into the original tag, making both
    the shopkeeper and his customers very happy with the ease of their transactions.
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个宁静的小镇上，有一位谦逊的店主，他时不时地用折扣来让顾客们感到愉快。为了简化这一过程，他寻求创建一个神奇的公式。这个公式会根据商店里任何物品的原价和他希望提供的特别折扣，计算出顾客需要支付的最终价格。通过这两个信息，公式就能显示折扣后的价格，使得店主和顾客都能因为交易的简便而感到非常开心。
- en: Can you think of two or three input examples to verify the correctness of the
    function generated by Copilot based on your prompts? Include some scenarios to
    ensure the function handles different types of input correctly and calculates
    the correct output.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到两三个输入示例来验证由Copilot根据你的提示生成的函数的正确性吗？包括一些场景，确保该函数正确处理不同类型的输入并计算出正确的输出。
- en: 4\. Review the function description and the provided test cases for calculating
    the total cost of a meal, including tax and tip. Based on the scenario and typical
    requirements of such a function, can you think of inputs where the function doesn’t
    work correctly? Explain why handling this input is necessary to ensure the function’s
    reliability and correctness across all potential use cases.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4. 回顾函数描述和提供的测试用例，计算包括税费和小费在内的餐费总额。根据场景和这种函数的典型要求，你能想到一些该函数无法正确处理的输入吗？解释为什么处理这些输入是必要的，以确保该函数在所有潜在用例中的可靠性和正确性。
- en: 'Problem description: Create a function that calculates the total cost of a
    meal, including tax and tip. The function should take three inputs: the base price
    of the meal, the tax rate as a percentage, and the tip rate as a percentage. The
    function should calculate and return the total cost of the meal.'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 问题描述：创建一个函数，计算包括税费和小费在内的餐费总额。该函数应接受三个输入：餐费的基本价格、税率（百分比形式）和小费率（百分比形式）。该函数应计算并返回餐费的总额。
- en: 'Test cases:'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 测试用例：
- en: '*Standard Case*—Calculate the total price of a $50 meal with a 10% tax and
    a 15% tip:'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*标准案例*—计算一顿50美元的餐费，加上10%的税费和15%的小费：'
- en: 'Input: `base_price = 50`, `tax_rate = 10`, `tip_rate = 15`'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入：`base_price = 50`，`tax_rate = 10`，`tip_rate = 15`
- en: 'Expected output: $62.50 (calculated as $50 + $5 tax + $7.50 tip)'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 期望输出：62.50美元（计算方式为50美元 + 5美元税费 + 7.50美元小费）
- en: '*Zero Tip Case*—Calculate the total price of a $30 meal with a 5% tax and no
    tip:'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*零小费案例*—计算一顿30美元的餐费，加上5%的税费，不加小费：'
- en: 'Input: `base_price = 30`, `tax_rate = 5`, `tip_rate = 0`'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入：`base_price = 30`，`tax_rate = 5`，`tip_rate = 0`
- en: 'Expected output: $31.50 (calculated as $30 + $1.50 tax + $0 tip)'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 期望输出：31.50美元（计算方式为30美元 + 1.50美元税费 + 0美元小费）
- en: '*High Tax and Tip Case*—Calculate the total price of a $100 meal with a 20%
    tax and a 25% tip:'
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*高税和高小费案例*—计算一顿100美元的餐费，加上20%的税费和25%的小费：'
- en: 'Input: `base_price = 100`, `tax_rate = 20`, `tip_rate = 25`'
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入：`base_price = 100`，`tax_rate = 20`，`tip_rate = 25`
- en: 'Expected output: $145 (calculated as $100 + $20 tax + $25 tip)'
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 期望输出：145美元（计算方式为100美元 + 20美元税费 + 25美元小费）
- en: 5\. Review the initial prompt provided to Copilot and the resulting Python function.
    The code doesn’t fulfill the requirements as it only converts from Fahrenheit
    to Celsius and lacks the capability to convert in both directions based on a user-specified
    mode. How would you improve the prompt to ensure that the generated code meets
    the full requirements of the problem description?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5. 回顾提供给Copilot的初始提示以及生成的Python函数。该代码并未满足要求，因为它仅能将华氏温度转换为摄氏温度，并且缺少根据用户指定的模式进行双向转换的能力。你会如何改进提示，以确保生成的代码符合问题描述的完整要求？
- en: '[PRE40]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Summary
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Problem decomposition involves breaking a large problem into smaller tasks.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题分解是将一个大问题分解为更小的任务。
- en: We use functions to perform problem decomposition in our programs.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用函数在程序中进行问题分解。
- en: Each function must solve one small, well-defined task.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个函数必须解决一个小的、明确的任务。
- en: A function header or signature is the first line of code of the function.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数头或签名是函数的第一行代码。
- en: Parameters are used to provide information to functions.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数用于向函数提供信息。
- en: The function header indicates the name of the function and names of its parameters.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数头部表示函数的名称及其参数的名称。
- en: We use `return` to pass a value from a function to its caller.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`return`将一个值从函数传递给其调用者。
- en: A docstring uses the names of each function parameter to describe the purpose
    of the function.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档字符串使用每个函数参数的名称来描述函数的目的。
- en: To ask Copilot to write a function, we provide it the function header and docstring.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要求 Copilot 编写一个函数时，我们提供函数头和文档字符串。
- en: We get a function to do its work by calling it with values (also called arguments)
    for its parameters.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过为函数的参数提供值（也称为参数）来调用它，从而使函数执行工作。
- en: To test whether a function is correct, we call it with different types of inputs.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要测试一个函数是否正确，我们使用不同类型的输入来调用它。
- en: A variable is a name that refers to a value.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量是指向一个值的名称。
- en: Every Python value has a type, such as a number, text (string), true/false value
    (bool), or collection of values (list or dictionary).
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 Python 值都有一个类型，如数字、文本（字符串）、真假值（布尔值）或值的集合（列表或字典）。
- en: Prompt engineering involves modifying our prompt for Copilot to influence the
    code that we get back.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示工程涉及修改我们给 Copilot 的提示，以影响返回的代码。
- en: We need to ensure that we import any module (e.g., string) our code is using.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要确保导入代码中使用的任何模块（例如，string）。
- en: Functions reduce duplication, make it easier to test our code, and reduce the
    likelihood of bugs.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数减少了重复代码，便于测试我们的代码，并降低了出错的可能性。
- en: Unit testing involves checking that the function does what we expect on a variety
    of different inputs.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试涉及检查函数是否能在各种不同的输入下执行预期的操作。
- en: A helper function is a small function written to make it easier to write a bigger
    function.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 辅助函数是一个小函数，旨在使编写更大函数变得更容易。
- en: A leaf function doesn’t call any other function to do its job.******
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个叶子函数不会调用其他函数来完成其工作。******
