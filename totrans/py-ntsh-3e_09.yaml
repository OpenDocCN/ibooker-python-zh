- en: Chapter 9\. Strings and Things
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python’s str type implements Unicode text strings with operators, built-in
    functions, methods, and dedicated modules. The somewhat similar bytes type represents
    arbitrary binary data as a sequence of bytes, also known as a *bytestring* or
    *byte string*. Many textual operations are possible on objects of either type:
    since these types are immutable, methods mostly create and return a new string
    unless returning the subject string unchanged. A mutable sequence of bytes can
    be represented as a bytearray, briefly introduced in [“bytearray objects”](ch03.xhtml#bytearray_objects).'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter first covers the methods available on these three types, then discusses
    the string module and string formatting (including formatted string literals),
    followed by the textwrap, pprint, and reprlib modules. Issues related specifically
    to Unicode are covered at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Methods of String Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: str, bytes, and bytearray objects are sequences, as covered in [“Strings”](ch03.xhtml#string);
    of these, only bytearray objects are mutable. All immutable-sequence operations
    (repetition, concatenation, indexing, and slicing) apply to instances of all three
    types, returning a new object of the same type. Unless otherwise specified in
    [Table 9-1](#significant_str_and_bytes_methods), methods are present on objects
    of all three types. Most methods of str, bytes, and bytearray objects return values
    of the same type, or are specifically intended to convert among representations.
  prefs: []
  type: TYPE_NORMAL
- en: Terms such as “letters,” “whitespace,” and so on refer to the corresponding
    attributes of the string module, covered in the following section. Although bytearray
    objects are mutable, their methods returning a bytearray result do not mutate
    the object but instead return a newly created bytearray, even when the result
    is the same as the subject string.
  prefs: []
  type: TYPE_NORMAL
- en: 'For brevity, the term bytes in the following table refers to both bytes and
    bytearray objects. Take care when mixing these two types, however: while they
    are generally interoperable, the type of the result usually depends on the order
    of the operands.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Table 9-1](#significant_str_and_bytes_methods), since integer values in
    Python can be arbitrarily large, for conciseness we use sys.maxsize for integer
    default values to mean, in practice, “integer of unlimited magnitude.”
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-1\. Significant str and bytes methods
  prefs: []
  type: TYPE_NORMAL
- en: '| capitalize | *s*.capitalize() Returns a copy of *s* where the first character,
    if a letter, is uppercase, and all other letters, if any, are lowercase. |   |'
  prefs: []
  type: TYPE_TB
- en: '| casefold | *s*.casefold() **str** **only**. Returns a string processed by
    the algorithm described in [section 3.13 of the Unicode standard](https://oreil.ly/PjWUT).
    This is similar to *s*.lower (described later in this table) but also takes into
    account equivalences such as that between the German ''ß'' and ''ss'', and is
    thus better for case-insensitive matching when working with text that can include
    more than just the basic ASCII characters. |   |'
  prefs: []
  type: TYPE_TB
- en: '| center | *s*.center(*n*, *fillchar*='' '', /) Returns a string of length
    max(len(*s*), *n*), with a copy of *s* in the central part, surrounded by equal
    numbers of copies of character *fillchar* on both sides. The default fillchar
    is a space. For example, ''ciao''.center(2) is ''ciao'' and ''x''.center(4, ''_'')
    is ''_x__''. |   |'
  prefs: []
  type: TYPE_TB
- en: '| count | *s*.count(*sub*, *start*=0, *end*=sys.maxsize, /) Returns the number
    of nonoverlapping occurrences of substring *sub* in *s*[*start*:*end*]. |   |'
  prefs: []
  type: TYPE_TB
- en: '| decode | *s*.decode(encoding=''utf-8'', errors=''strict'') **bytes** **only**.
    Returns a str object decoded from the bytes *s* according to the given encoding.
    errors specifies how to handle decoding errors: ''strict'' causes errors to raise
    UnicodeError exceptions; ''ignore'' ignores the malformed values, while ''replace''
    replaces them with question marks (see [“Unicode”](#unicode) for details). Other
    values can be registered via codecs.register_error, covered in Table 9-10. |  
    |'
  prefs: []
  type: TYPE_TB
- en: '| encode | *s*.encode(encoding=''utf-8'', errors=''strict'') **str** **only**.
    Returns a bytes object obtained from str *s* with the given encoding and error
    handling. See [“Unicode”](#unicode) for more details. |   |'
  prefs: []
  type: TYPE_TB
- en: '| endswith | *s*.endswith(*suffix*, *start*=0, *end*=sys.maxsize, /) Returns
    **True** when *s*[*start*:*end*] ends with the string *suffix*; otherwise, returns
    **False**. *suffix* can be a tuple of strings, in which case endswith returns
    **True** when *s*[*start*:*end*] ends with any one of them. |   |'
  prefs: []
  type: TYPE_TB
- en: '| expandtabs | *s*.expandtabs(tabsize=8) Returns a copy of *s* where each tab
    character is changed into one or more spaces, with tab stops every *tabsize* characters.
    |   |'
  prefs: []
  type: TYPE_TB
- en: '| find | *s*.find(*sub*, *start*=0, *end*=sys.maxsize, /) Returns the lowest
    index in *s* where substring *sub* is found, such that *sub* is entirely contained
    in *s*[*start*:*end*]. For example, ''banana''.find(''na'') returns 2, as does
    ''banana''.find(''na'', 1), while ''banana''.find(''na'', 3) returns 4, as does
    ''banana''.find(''na'', -2). find returns -1 when *sub* is not found. |   |'
  prefs: []
  type: TYPE_TB
- en: '| format | *s*.format(**args*, ***kwargs*) **str** **only**. Formats the positional
    and named arguments according to formatting instructions contained in the string
    *s*. See [“String Formatting”](#string_formatting) for further details. |   |'
  prefs: []
  type: TYPE_TB
- en: '| format_map | *s*.format_map(mapping) **str** **only**. Formats the mapping
    argument according to formatting instructions contained in the string *s*. Equivalent
    to *s*.format(**mapping) but uses the mapping directly. See [“String Formatting”](#string_formatting)
    for formatting details. |   |'
  prefs: []
  type: TYPE_TB
- en: '| index | *s*.index(*sub*, *start*=0, *end*=sys.maxsize, /) Like find, but
    raises ValueError when *sub* is not found. |   |'
  prefs: []
  type: TYPE_TB
- en: '| isalnum | *s*.isalnum() Returns **True** when len(*s*) is greater than 0
    and all characters in *s* are Unicode letters or digits. When *s* is empty, or
    when at least one character of *s* is neither a letter nor a digit, isalnum returns
    **False**. |   |'
  prefs: []
  type: TYPE_TB
- en: '| isalpha | *s*.isalpha() Returns **True** when len(*s*) is greater than 0
    and all characters in *s* are letters. When *s* is empty, or when at least one
    character of *s* is not a letter, isalpha returns **False**. |   |'
  prefs: []
  type: TYPE_TB
- en: '| isascii | *s*.isascii() Returns **True** when the string is empty or all
    characters in the string are ASCII, or **False** otherwise. ASCII characters have
    codepoints in the range U+0000–U+007F. |   |'
  prefs: []
  type: TYPE_TB
- en: '| isdecimal | *s*.isdecimal() **str** **only**. Returns **True** when len(*s*)
    is greater than 0 and all characters in *s* can be used to form decimal-radix
    numbers. This includes Unicode characters defined as Arabic digits.^([a](ch09.xhtml#ch01fn95))
    |   |'
  prefs: []
  type: TYPE_TB
- en: '| isdigit | *s*.isdigit() Returns **True** when len(*s*) is greater than 0
    and all characters in *s* are Unicode digits. When *s* is empty, or when at least
    one character of *s* is not a Unicode digit, isdigit returns **False**. |   |'
  prefs: []
  type: TYPE_TB
- en: '| isidentifier | *s*.isidentifier() **str** **only**. Returns **True** when
    *s* is a valid identifier according to the Python language’s definition; keywords
    also satisfy the definition, so, for example, ''class''.isidentifier() returns
    **True**. |   |'
  prefs: []
  type: TYPE_TB
- en: '| islower | *s*.islower() Returns **True** when all letters in *s* are lowercase.
    When *s* contains no letters, or when at least one letter of *s* is uppercase,
    islower returns **False**. |   |'
  prefs: []
  type: TYPE_TB
- en: '| isnumeric | *s*.isnumeric() **str** **only**. Similar to *s*.isdigit(), but
    uses a broader definition of numeric characters that includes all characters defined
    as numeric in the Unicode standard (such as fractions). |   |'
  prefs: []
  type: TYPE_TB
- en: '| isprintable | *s*.isprintable() **str** **only**. Returns **True** when all
    characters in *s* are spaces (''\x20'') or are defined in the Unicode standard
    as printable. Because the null string contains no unprintable characters, ''''.isprintable()
    returns **True**. |   |'
  prefs: []
  type: TYPE_TB
- en: '| isspace | *s*.isspace() Returns **True** when len(*s*) is greater than 0
    and all characters in *s* are whitespace. When *s* is empty, or when at least
    one character of *s* is not whitespace, isspace returns **False**. |   |'
  prefs: []
  type: TYPE_TB
- en: '| istitle | *s*.istitle() Returns **True** when the string *s* is *titlecased*:
    i.e., with a capital letter at the start of every contiguous sequence of letters,
    and all other letters lowercase (e.g., ''King Lear''.istitle() returns **True**).
    When *s* contains no letters, or when at least one letter of *s* violates the
    title case condition, istitle returns **False** (e.g., ''1900''.istitle() and
    ''Troilus and Cressida''.istitle() return **False**). |   |'
  prefs: []
  type: TYPE_TB
- en: '| isupper | *s*.isupper() Returns **True** when all letters in *s* are uppercase.
    When *s* contains no letters, or when at least one letter of *s* is lowercase,
    isupper returns **False**. |   |'
  prefs: []
  type: TYPE_TB
- en: '| join | *s*.join(*seq*, /) Returns the string obtained by concatenating the
    items of *seq* separated by copies of *s* (e.g., ''''.join(str(x) **for** x **in**
    range(7)) returns ''0123456'' and ''x''.join(''aeiou'') returns ''axexixoxu'').
    |   |'
  prefs: []
  type: TYPE_TB
- en: '| ljust | *s*.ljust(*n*, *fillchar*='' '', /) Returns a string of length max(len(*s*),*n*),
    with a copy of *s* at the start, followed by zero or more trailing copies of character
    *fillchar*. |   |'
  prefs: []
  type: TYPE_TB
- en: '| lower | *s*.lower() Returns a copy of *s* with all letters, if any, converted
    to lowercase. |   |'
  prefs: []
  type: TYPE_TB
- en: '| lstrip | *s*.lstrip(*x*=string.whitespace, /) Returns a copy of *s* after
    removing any leading characters found in string *x*. For example, ''banana''.lstrip(''ab'')
    returns ''nana''. |   |'
  prefs: []
  type: TYPE_TB
- en: '| removeprefix | *s*.removeprefix(*prefix*, /) 3.9+ When *s* begins with *prefix*,
    returns the remainder of *s*; otherwise, returns *s*. |   |'
  prefs: []
  type: TYPE_TB
- en: '| removesuffix | *s*.removesuffix(*suffix*, /) 3.9+ When *s* ends with *suffix*,
    returns the rest of *s*; otherwise, returns *s*. |   |'
  prefs: []
  type: TYPE_TB
- en: '| replace | *s*.replace(*old*, *new*, *count*=sys.maxsize, /) Returns a copy
    of *s* with the first *count* (or fewer, if there are fewer) nonoverlapping occurrences
    of substring *old* replaced by string *new* (e.g., ''banana''.replace(''a'', ''e'',
    2) returns ''benena''). |   |'
  prefs: []
  type: TYPE_TB
- en: '| rfind | *s*.rfind(*sub*, *start*=0, *end*=sys.maxsize, /) Returns the highest
    index in *s* where substring *sub* is found, such that *sub* is entirely contained
    in *s*[*start*:*end*]. rfind returns -1 if *sub* is not found. |   |'
  prefs: []
  type: TYPE_TB
- en: '| rindex | *s*.rindex(*sub*, *start*=0, *end*=sys.maxsize, /) Like rfind, but
    raises ValueError if *sub* is not found. |   |'
  prefs: []
  type: TYPE_TB
- en: '| rjust | *s*.rjust(*n*, *fillchar*='' '', /) Returns a string of length max(len(*s*),*n*),
    with a copy of *s* at the end, preceded by zero or more leading copies of character
    *fillchar*. |   |'
  prefs: []
  type: TYPE_TB
- en: '| rstrip | *s*.rstrip(*x*=string.whitespace, /) Returns a copy of *s*, removing
    trailing characters that are found in string *x*. For example, ''banana''.rstrip(''ab'')
    returns ''banan''. |   |'
  prefs: []
  type: TYPE_TB
- en: '| split | *s*.split(sep=None, maxsplit=sys.maxsize) Returns a list *L* of up
    to maxsplit+1 strings. Each item of *L* is a “word” from *s*, where string sep
    separates words. When *s* has more than maxsplit words, the last item of *L* is
    the substring of *s* that follows the first maxsplit words. When sep is **None**,
    any string of whitespace separates words (e.g., ''four score and seven years''.split(**None**,
    3) returns [''four'', ''score'', ''and'', ''seven years'']).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the difference between splitting on **None** (any run of whitespace characters
    is a separator) and splitting on '' '' (where each single space character, *not*
    other whitespace such as tabs and newlines, and *not* strings of spaces, is a
    separator). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the first case, the two-spaces string in the middle is a single separator;
    in the second case, each single space is a separator, so that there is an empty
    string between the two spaces. |   |
  prefs: []
  type: TYPE_NORMAL
- en: '| splitlines | *s*.splitlines(keepends=**False**) Like *s*.split(''\n''). When
    keepends is **True**, however, the trailing ''\n'' is included in each item of
    the resulting list (except the last one, if *s* does not end with ''\n''). |  
    |'
  prefs: []
  type: TYPE_TB
- en: '| startswith | *s*.startswith(*prefix*, *start*=0, *end*=sys.maxsize, /) Returns
    **True** when *s*[*start*:*end*] starts with string *prefix*; otherwise, returns
    **False**. *prefix* can be a tuple of strings, in which case startswith returns
    **True** when *s*[*start*:*end*] starts with any one of them. |   |'
  prefs: []
  type: TYPE_TB
- en: '| strip | *s*.strip(*x*=string.whitespace, /) Returns a copy of *s*, removing
    both leading and trailing characters that are found in string *x*. For example,
    ''banana''.strip(''ab'') returns ''nan''. |   |'
  prefs: []
  type: TYPE_TB
- en: '| swapcase | *s*.swapcase() Returns a copy of *s* with all uppercase letters
    converted to lowercase and vice versa. |   |'
  prefs: []
  type: TYPE_TB
- en: '| title | *s*.title() Returns a copy of *s* transformed to title case: a capital
    letter at the start of each contiguous sequence of letters, with all other letters
    (if any) lowercase. |   |'
  prefs: []
  type: TYPE_TB
- en: '| translate | *s*.translate(*table*, /, delete*=*b'''') Returns a copy of *s*,
    where characters found in *table* are translated or deleted. When *s* is a str,
    you cannot pass the argument delete; *table* is a dict whose keys are Unicode
    ordinals and whose values are Unicode ordinals, Unicode strings, or **None** (to
    delete the corresponding character). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When *s* is a bytes, *table* is a bytes object of length 256; the result of
    *s*.translate(*t*, *b*) is a bytes object with each item *b* of *s* omitted if
    *b* is one of the items of delete, and otherwise changed to *t*[ord(*b*)].
  prefs: []
  type: TYPE_NORMAL
- en: bytes and str each have a class method named maketrans which you can use to
    build tables suitable for the respective translate methods. |   |
  prefs: []
  type: TYPE_NORMAL
- en: '| upper | *s*.upper() Returns a copy of *s* with all letters, if any, converted
    to uppercase. |   |'
  prefs: []
  type: TYPE_TB
- en: '| ^([a](ch09.xhtml#ch01fn95-marker)) This does *not* include punctuation marks
    used as a radix, such as a dot (.) or comma (,). |'
  prefs: []
  type: TYPE_TB
- en: The string Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The string module supplies several useful string attributes, listed in [Table 9-2](#predefined_constants_in_the_string_modu).
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-2\. Predefined constants in the string module
  prefs: []
  type: TYPE_NORMAL
- en: '| ascii_letters | The string ascii_lowercase+ascii_uppercase (the following
    two constants, concatenated) |'
  prefs: []
  type: TYPE_TB
- en: '| ascii_lowercase | The string ''abcdefghijklmnopqrstuvwxyz'' |'
  prefs: []
  type: TYPE_TB
- en: '| ascii_uppercase | The string ''ABCDEFGHIJKLMNOPQRSTUVWXYZ'' |'
  prefs: []
  type: TYPE_TB
- en: '| digits | The string ''0123456789'' |'
  prefs: []
  type: TYPE_TB
- en: '| hexdigits | The string ''0123456789abcdefABCDEF'' |'
  prefs: []
  type: TYPE_TB
- en: '| octdigits | The string ''01234567'' |'
  prefs: []
  type: TYPE_TB
- en: '| punctuation | The string ''!"#$%&\''()*+,-./:;<=>?@[\]^_''{&#124;}~'' (i.e.,
    all ASCII characters that are deemed punctuation characters in the C locale; does
    not depend on which locale is active) |'
  prefs: []
  type: TYPE_TB
- en: '| printable | The string of those ASCII characters that are deemed printable
    (i.e., digits, letters, punctuation, and whitespace) |'
  prefs: []
  type: TYPE_TB
- en: '| whitespace | A string containing all ASCII characters that are deemed whitespace:
    at least space, tab, linefeed, and carriage return, but more characters (e.g.,
    certain control characters) may be present, depending on the active locale |'
  prefs: []
  type: TYPE_TB
- en: You should not rebind these attributes; the effects of doing so are undefined,
    since other parts of the Python library may rely on them.
  prefs: []
  type: TYPE_NORMAL
- en: The module string also supplies the class Formatter, covered in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: String Formatting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python provides a flexible mechanism for formatting strings (but *not* bytestrings:
    for those, see [“Legacy String Formatting with %”](#legacy_string_formatting_with_percent)).
    A *format string* is simply a string containing *replacement fields* enclosed
    in braces ({}), made up of a *value part*, an optional *conversion part*, and
    an optional *format specifier*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The value part differs depending on the string type:'
  prefs: []
  type: TYPE_NORMAL
- en: For formatted string literals, or *f-strings*, the value part is evaluated as
    a Python expression (see the following section for details); expressions cannot
    end in an exclamation mark.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For other strings, the value part selects an argument, or an element of an argument,
    to the format method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The optional conversion part is an exclamation mark (!) followed by one of the
    letters s, r, or a (described in [“Value Conversion”](#value_conversion)).
  prefs: []
  type: TYPE_NORMAL
- en: The optional format specifier begins with a colon (:) and determines how the
    converted value is rendered for interpolation in the format string in place of
    the original replacement field.
  prefs: []
  type: TYPE_NORMAL
- en: Formatted String Literals (F-Strings)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This feature allows you to insert values to be interpolated inline surrounded
    by braces. To create a formatted string literal, put an f before the opening quote
    mark (this is why they’re called *f-strings*) of your string, e.g., f''{value}'':'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use nested braces to specify components of formatting expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We have tried to update most of the examples in the book to use f-strings, since
    they are the most compact way to format strings in Python. Do remember, though,
    that these string literals are *not* constants—they evaluate each time a statement
    containing them is executed, which involves runtime overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The values to be formatted inside formatted string literals are already inside
    quotes: therefore, take care to avoid syntax errors when using value-part expressions
    that themselves contain string quotes. With four different string quotes, plus
    the ability to use escape sequences, most things are possible, though admittedly
    readability can suffer.'
  prefs: []
  type: TYPE_NORMAL
- en: F-Strings Don’t Help Internationalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given a format whose contents will have to accommodate multiple languages, it’s
    much better to use the format method, since the values to be interpolated can
    then be computed independently before submitting them for formatting.
  prefs: []
  type: TYPE_NORMAL
- en: Debug printing with f-strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '3.8+ As a convenience for debugging, the last nonblank character of the value
    expression in a formatted string literal can be followed by an equals sign (=),
    optionally surrounded by spaces. In this case the text of the expression itself
    and the equals sign, including any leading and trailing spaces, are output before
    the value. In the presence of the equals sign, when no format is specified, Python
    uses the repr() of the value as output; otherwise, Python uses the str() of the
    value unless an !r value conversion is specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that this form is *only* available in formatted string literals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple f-string example. Notice that all text, including any whitespace,
    surrounding the replacement fields is copied literally into the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Formatting Using format Calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The same formatting operations available in formatted string literals can also
    be performed by a call to the string’s format method. In these cases, rather than
    the value appearing inline, the replacement field begins with a value part that
    selects an argument of that call. You can specify both positional and named arguments.
    Here’s an example of a simple format method call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: For simplicity, none of the replacement fields in this example contain a conversion
    part or a format specifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, the argument selection mechanism when using the format
    method can handle both positional and named arguments. The simplest replacement
    field is the empty pair of braces ({}), representing an *automatic* positional
    argument specifier. Each such replacement field automatically refers to the value
    of the next positional argument to format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To repeatedly select an argument, or use it out of order, use numbered replacement
    fields to specify the argument’s position in the list of arguments (counting from
    zero):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You cannot mix automatic and numbered replacement fields: it’s an either-or
    choice.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For named arguments, use argument names. If desired, you can mix them with
    (automatic or numbered) positional arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If an argument is a sequence, you can use numeric indices to select a specific
    element of the argument as the value to be formatted. This applies to both positional
    (automatic or numbered) and named arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If an argument is a composite object, you can select its individual attributes
    as values to be formatted by applying attribute-access dot notation to the argument
    selector. Here is an example using complex numbers, which have real and imag attributes
    that hold the real and imaginary parts, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Indexing and attribute-selection operations can be used multiple times, if required.
  prefs: []
  type: TYPE_NORMAL
- en: Value Conversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may apply a default conversion to the value via one of its methods. You
    indicate this by following any selector with !s to apply the object’s __str__
    method, !r for its __repr__ method, or !a for the ascii built-in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When a conversion is present, the conversion is applied to the value before
    it is formatted. Since the same value is required multiple times, in this example
    a format call makes much more sense than a formatted string literal, which would
    require the value to be repeated three times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Value Formatting: The Format Specifier'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final (optional) portion of the replacement field, known as the *format
    specifier* and introduced by a colon (:), provides any further required formatting
    of the (possibly converted) value. The absence of a colon in the replacement field
    means that the converted value (after representation as a string if not already
    in string form) is used with no further formatting. If present, a format specifier
    should be provided conforming to the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Details are provided in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Fill and alignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default fill character is the space. To use an alternative fill character
    (which cannot be an opening or closing brace), begin the format specifier with
    the fill character. The fill character, if any, should be followed by an *alignment
    indicator* (see [Table 9-3](#alignment_indicators)).
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-3\. Alignment indicators
  prefs: []
  type: TYPE_NORMAL
- en: '| Character | Significance as alignment indicator |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ''<'' | Align value on left of field |'
  prefs: []
  type: TYPE_TB
- en: '| ''>'' | Align value on right of field |'
  prefs: []
  type: TYPE_TB
- en: '| ''^'' | Align value at center of field |'
  prefs: []
  type: TYPE_TB
- en: '| ''='' | Only for numeric types: add fill characters between the sign and
    the first digit of the numeric value |'
  prefs: []
  type: TYPE_TB
- en: If the first and second characters are *both* valid alignment indicators, then
    the first is used as the fill character and the second is used to set the alignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'When no alignment is specified, values other than numbers are left-aligned.
    Unless a field width is specified later in the format specifier (see [“Field width”](#field_width)),
    no fill characters are added, whatever the fill and alignment may be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Sign indication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For numeric values only, you can indicate how positive and negative numbers
    are differentiated by including a sign indicator (see [Table 9-4](#sign_indicators)).
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-4\. Sign indicators
  prefs: []
  type: TYPE_NORMAL
- en: '| Character | Significance as sign indicator |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ''+'' | Insert + as sign for positive numbers; - as sign for negative numbers
    |'
  prefs: []
  type: TYPE_TB
- en: '| ''-'' | Insert - as sign for negative numbers; do not insert any sign for
    positive numbers (default behavior if no sign indicator is included) |'
  prefs: []
  type: TYPE_TB
- en: '| '' '' | Insert a space character as sign for positive numbers; - as sign
    for negative numbers |'
  prefs: []
  type: TYPE_TB
- en: 'The space is the default sign indication. If a fill is specified, it will appear
    between the sign, if any, and the numerical value; place the sign indicator *after*
    the = to avoid it being used as a fill character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Zero normalization (z)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '3.11+ Some numeric formats are capable of representing a negative zero, which
    is often a surprising and unwelcome result. Such negative zeros will be normalized
    to positive zeros when a z character appears in this position in the format specifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Radix indicator (#)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For numeric *integer* formats only, you can include a radix indicator, the
    # character. If present, this indicates that the digits of binary-formatted numbers
    should be preceded by ''0b'', those of octal-formatted numbers by ''0o'', and
    those of hexadecimal-formatted numbers by ''0x''. For example, ''{23:x}'' is ''17'',
    while ''{23:#x}'' is ''0x17'', clearly identifying the value as hexadecimal.'
  prefs: []
  type: TYPE_NORMAL
- en: Leading zero indicator (0)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For *numeric types only*, when the field width starts with a zero, the numeric
    value will be padded with leading zeros rather than leading spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Field width
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can specify the width of the field to be printed. If the width specified
    is less than the length of the value, the length of the value is used (but for
    string values, see the upcoming section [“Precision specification”](#precision_specification)).
    If alignment is not specified, the value is left justified (except for numbers,
    which are right justified):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Using nested braces, when calling the format method, the field width can be
    a format argument too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: See [“Nested Format Specifications”](#nested_format_specifications) for a fuller
    discussion of this technique.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping option
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For numeric values in the decimal (default) format type, you can insert either
    a comma (**,**) or an underscore (**_**) to request that each group of three digits
    (*digit group*) in the integer portion of the result be separated by that character.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This behavior ignores system locale; for a locale-aware use of digit grouping
    and decimal point character, see format type n in [Table 9-5](#integer_format_types).
  prefs: []
  type: TYPE_NORMAL
- en: Precision specification
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The precision (e.g., .2) has different meanings for different format types
    (see the following subsection for details), with .6 as the default for most numeric
    formats. For the f and F format types, it specifies the number of digits following
    the decimal point to which the value should be rounded in formatting; for the
    g and G format types, it specifies the number of *significant* digits to which
    the value should be *rounded*; for nonnumeric values, it specifies *truncation*
    of the value to its leftmost characters before formatting. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Format type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The format specification ends with an optional *format type*, which determines
    how the value gets represented in the given width and at the given precision.
    In the absence of an explicit format type, the value being formatted determines
    the default format type.
  prefs: []
  type: TYPE_NORMAL
- en: The s format type is always used to format Unicode strings.
  prefs: []
  type: TYPE_NORMAL
- en: Integer numbers have a range of acceptable format types, listed in [Table 9-5](#integer_format_types).
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-5\. Integer format types
  prefs: []
  type: TYPE_NORMAL
- en: '| Format type | Formatting description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| b | Binary format—a series of ones and zeros |'
  prefs: []
  type: TYPE_TB
- en: '| c | The Unicode character whose ordinal value is the formatted value |'
  prefs: []
  type: TYPE_TB
- en: '| d | Decimal (the default format type) |'
  prefs: []
  type: TYPE_TB
- en: '| n | Decimal format, with locale-specific separators (commas in the UK and
    US) when system locale is set |'
  prefs: []
  type: TYPE_TB
- en: '| o | Octal format—a series of octal digits |'
  prefs: []
  type: TYPE_TB
- en: '| x or X | Hexadecimal format—a series of hexadecimal digits, with the letters,
    respectively, in lower- or uppercase |'
  prefs: []
  type: TYPE_TB
- en: Floating-point numbers have a different set of format types, shown in [Table 9-6](#floating_point_format_types).
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-6\. Floating-point format types
  prefs: []
  type: TYPE_NORMAL
- en: '| Format type | Formatting description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| e or E | Exponential format—scientific notation, with an integer part between
    one and nine, using e or E just before the exponent |'
  prefs: []
  type: TYPE_TB
- en: '| f or F | Fixed-point format with infinities (inf) and nonnumbers (nan) in
    lower- or uppercase |'
  prefs: []
  type: TYPE_TB
- en: '| g or G | General format (the default format type)—uses a fixed-point format
    when possible, otherwise exponential format; uses lower- or uppercase representations
    for e, inf, and nan, depending on the case of the format type |'
  prefs: []
  type: TYPE_TB
- en: '| n | Like general format, but uses locale-specific separators, when system
    locale is set, for groups of three digits and decimal points |'
  prefs: []
  type: TYPE_TB
- en: '| % | Percentage format—multiplies the value by 100 and formats it as fixed-point
    followed by % |'
  prefs: []
  type: TYPE_TB
- en: When no format type is specified, a float uses the g format, with at least one
    digit after the decimal point and a default precision of 12.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code takes a list of numbers and displays each right justified
    in a field width of nine characters; it specifies that each number’s sign will
    always display, adds a comma between each group of three digits, and rounds each
    number to exactly two digits after the decimal point, converting ints to floats
    as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Nested Format Specifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some cases you’ll want to use expression values to help determine the precise
    format used: you can use nested formatting to achieve this. For example, to format
    a string in a field four characters wider than the string itself, you can pass
    a value for the width to format, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'With some care, you can use width specification and nested formatting to print
    a sequence of tuples into well-aligned columns. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Given this function, the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'prints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Formatting of User-Coded Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Values are ultimately formatted by a call to their __format__ method with the
    format specifier as an argument. Built-in types either implement their own method
    or inherit from object, whose rather unhelpful format method only accepts an empty
    string as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use this knowledge to implement an entirely different formatting mini-language
    of your own, should you so choose. The following simple example demonstrates the
    passing of format specifications and the return of a (constant) formatted string
    result. The interpretation of the format specification is under your control,
    and you may choose to implement whatever formatting notation you choose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The return value of the __format__ method is substituted for the replacement
    field in the formatted output, allowing any desired interpretation of the format
    string.
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique is used in the datetime module, to allow the use of strftime-style
    format strings. Consequently, the following all give the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: To help you format your objects more easily, the string module provides a Formatter
    class with many helpful methods for handling formatting tasks. See the [online
    docs](https://oreil.ly/aUmUs) for details.
  prefs: []
  type: TYPE_NORMAL
- en: Legacy String Formatting with %
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A legacy form of string formatting expression in Python has the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: where *format* is a str, bytes, or bytearray object containing format specifiers,
    and *values* are the values to format, usually as a tuple.^([1](ch09.xhtml#ch01fn96))
    Unlike Python’s newer formatting capabilities, you can also use % formatting with
    bytes and bytearray objects, not just str ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'The equivalent use in logging would be, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: with the *values* coming as positional arguments after the *format*.
  prefs: []
  type: TYPE_NORMAL
- en: The legacy string-formatting approach has roughly the same set of features as
    the C language’s printf and operates in a similar way. Each format specifier is
    a substring of *format* that starts with a percent sign (%) and ends with one
    of the conversion characters shown in [Table 9-7](#string_formatting_conversion_characters).
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-7\. String-formatting conversion characters
  prefs: []
  type: TYPE_NORMAL
- en: '| Character | Output format | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| d, i | Signed decimal integer | Value must be a number |'
  prefs: []
  type: TYPE_TB
- en: '| u | Unsigned decimal integer | Value must be a number |'
  prefs: []
  type: TYPE_TB
- en: '| o | Unsigned octal integer | Value must be a number |'
  prefs: []
  type: TYPE_TB
- en: '| x | Unsigned hexadecimal integer (lowercase letters) | Value must be a number
    |'
  prefs: []
  type: TYPE_TB
- en: '| X | Unsigned hexadecimal integer (uppercase letters) | Value must be a number
    |'
  prefs: []
  type: TYPE_TB
- en: '| e | Floating-point value in exponential form (lowercase e for exponent) |
    Value must be a number |'
  prefs: []
  type: TYPE_TB
- en: '| E | Floating-point value in exponential form (uppercase E for exponent) |
    Value must be a number |'
  prefs: []
  type: TYPE_TB
- en: '| f, F | Floating-point value in decimal form | Value must be a number |'
  prefs: []
  type: TYPE_TB
- en: '| g, G | Like e or E when *exp* is >=4 or < precision; otherwise, like f or
    F | *exp* is the exponent of the number being converted |'
  prefs: []
  type: TYPE_TB
- en: '| a | String | Converts any value with ascii |'
  prefs: []
  type: TYPE_TB
- en: '| r | String | Converts any value with repr |'
  prefs: []
  type: TYPE_TB
- en: '| s | String | Converts any value with str |'
  prefs: []
  type: TYPE_TB
- en: '| % | Literal % character | Consumes no value |'
  prefs: []
  type: TYPE_TB
- en: The a, r, and s conversion characters are the ones most often used with the
    logging module. Between the % and the conversion character, you can specify a
    number of optional modifiers, as we’ll discuss shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is logged with a formatting expression is *format*, where each format
    specifier is replaced by the corresponding item of *values* converted to a string
    according to the specifier. Here are some simple examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Format Specifier Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each format specifier corresponds to an item in *values* by position. A format
    specifier can include modifiers to control how the corresponding item in *values*
    is converted to a string. The components of a format specifier, in order, are:'
  prefs: []
  type: TYPE_NORMAL
- en: The mandatory leading % character that marks the start of the specifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Zero or more optional conversion flags:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '''#'''
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The conversion uses an alternate form (if any exists for its type).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '''0'''
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The conversion is zero padded.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '''-'''
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The conversion is left justified.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ''' '''
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Negative numbers are signed, and a space is placed before a positive number.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '''+'''
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A numeric sign (+ or -) is placed before any numeric conversion.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An optional minimum width of the conversion: one or more digits, or an asterisk
    (*), meaning that the width is taken from the next item in *values*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An optional precision for the conversion: a dot (.) followed by zero or more
    digits or by a *, meaning that the precision is taken from the next item in *values*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mandatory conversion type from [Table 9-7](#string_formatting_conversion_characters)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There must be exactly as many *values* as *format* has specifiers (plus one
    extra for each width or precision given by *). When a width or precision is given
    by *, the * consumes one item in *values*, which must be an integer and is taken
    as the number of characters to use as the width or precision of that conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Always Use %r (or %a) to Log Possibly Erroneous Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most often, the format specifiers in your *format* string will all be %s; occasionally,
    you’ll want to ensure horizontal alignment of the output (for example, in a right-justified,
    maybe truncated space of exactly six characters, in which case you’d use %6.6s).
    However, there is an important special case for %r or %a.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re logging a string value that might be erroneous (for example, the
    name of a file that is not found), don’t use %s: when the error is that the string
    has spurious leading or trailing spaces, or contains some nonprinting characters
    such as \b, %s can make this hard for you to spot by studying the logs. Use %r
    or %a instead, so that all characters are clearly shown, possibly via escape sequences.
    (For f-strings, the corresponding syntax would be {variable!r} or {variable!a}).'
  prefs: []
  type: TYPE_NORMAL
- en: Text Wrapping and Filling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The textwrap module supplies a class and a few functions to format a string
    by breaking it into lines of a given maximum length. To fine-tune the filling
    and wrapping, you can instantiate the TextWrapper class supplied by textwrap and
    apply detailed control. Most of the time, however, one of the functions exposed
    by textwrap suffices; the most commonly used functions are covered in [Table 9-8](#useful_functions_of_the_textwrap_module).
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-8\. Useful functions of the textwrap module
  prefs: []
  type: TYPE_NORMAL
- en: '| dedent | dedent(text) Takes a multiline string and returns a copy in which
    all lines have had the same amount of leading whitespace removed, so that some
    lines have no leading whitespace. |'
  prefs: []
  type: TYPE_TB
- en: '| fill | fill(text, width=70) Returns a single multiline string equal to ''\n''.join(wrap(text,
    width)). |'
  prefs: []
  type: TYPE_TB
- en: '| wrap | wrap(text, width=70) Returns a list of strings (without terminating
    newlines), each no longer than width characters. wrap also supports other named
    arguments (equivalent to attributes of instances of class TextWrapper); for such
    advanced uses, see the [online docs](https://oreil.ly/TjsSm). |'
  prefs: []
  type: TYPE_TB
- en: The pprint Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The pprint module pretty-prints data structures, with formatting that strives
    to be more readable than that supplied by the built-in function repr (covered
    in [Table 8-2](ch08.xhtml#pythonapostrophes_core_built_in_functio)). To fine-tune
    the formatting, you can instantiate the PrettyPrinter class supplied by pprint
    and apply detailed control, helped by auxiliary functions also supplied by pprint.
    Most of the time, however, one of the functions exposed by pprint suffices (see
    [Table 9-9](#useful_functions_of_the_pprint_module)).
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-9\. Useful functions of the pprint module
  prefs: []
  type: TYPE_NORMAL
- en: '| pformat | pformat(object) Returns a string representing the pretty-printing
    of object. |'
  prefs: []
  type: TYPE_TB
- en: '| pp, pprint | pp(object, stream=*sys.stdout*), pprint(object, stream=*sys.stdout*)'
  prefs: []
  type: TYPE_NORMAL
- en: Outputs the pretty-printing of object to open-for-writing file object stream,
    with a terminating newline.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following statements do exactly the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Either of these constructs is roughly the same as print(*x*) in many cases—for
    example, for a container that can be displayed within a single line. However,
    with something like *x*=list(range(30)), print(*x*) displays *x* in 2 lines, breaking
    at an arbitrary point, while using the module pprint displays x over 30 lines,
    one line per item. Use pprint when you prefer the module’s specific display effects
    to the ones of normal string representation.
  prefs: []
  type: TYPE_NORMAL
- en: pprint and pp support additional formatting arguments; consult the [online docs](https://oreil.ly/xwrN8)
    for details. |
  prefs: []
  type: TYPE_NORMAL
- en: The reprlib Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The reprlib module supplies an alternative to the built-in function repr (covered
    in [Table 8-2](ch08.xhtml#pythonapostrophes_core_built_in_functio)), with limits
    on length for the representation string. To fine-tune the length limits, you can
    instantiate or subclass the Repr class supplied by the reprlib module and apply
    detailed control. Most of the time, however, the only function exposed by the
    module suffices: repr(*obj*), which returns a string representing *obj*, with
    sensible limits on length.'
  prefs: []
  type: TYPE_NORMAL
- en: Unicode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To convert bytestrings into Unicode strings, use the decode method of bytestrings
    (see [Table 9-1](#significant_str_and_bytes_methods)). The conversion must always
    be explicit, and is performed using an auxiliary object known as a *codec* (short
    for *coder–decoder*). A codec can also convert Unicode strings to bytestrings
    using the encode method of strings. To identify a codec, pass the codec name to
    decode or encode. When you pass no codec name, Python uses a default encoding,
    normally 'utf-8'.
  prefs: []
  type: TYPE_NORMAL
- en: Every conversion has a parameter errors, a string specifying how conversion
    errors are to be handled. Sensibly, the default is 'strict', meaning any error
    raises an exception. When errors is 'replace', the conversion replaces each character
    causing errors with '?' in a bytestring result, or with u'\ufffd' in a Unicode
    result. When errors is 'ignore', the conversion silently skips characters causing
    errors. When errors is 'xmlcharrefreplace', the conversion replaces each character
    causing errors with the XML character reference representation of that character
    in the result. You may code your own function to implement a conversion error
    handling strategy and register it under an appropriate name by calling codecs.register_error,
    covered in the table in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: The codecs Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The mapping of codec names to codec objects is handled by the codecs module.
    This module also lets you develop your own codec objects and register them so
    that they can be looked up by name, just like built-in codecs. It provides a function
    that lets you look up any codec explicitly as well, obtaining the functions the
    codec uses for encoding and decoding, as well as factory functions to wrap file-like
    objects. Such advanced facilities are rarely used, and we do not cover them in
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: The codecs module, together with the encodings package of the standard Python
    library, supplies built-in codecs useful to Python developers dealing with internationalization
    issues. Python comes with over 100 codecs; you can find a complete list, with
    a brief explanation of each, in the [online docs](https://oreil.ly/3iAbC). It’s
    *not* good practice to install a codec as the site-wide default in the module
    sitecustomize; rather, the preferred usage is to always specify the codec by name
    whenever converting between byte and Unicode strings. Python’s default Unicode
    encoding is 'utf-8'.
  prefs: []
  type: TYPE_NORMAL
- en: 'The codecs module supplies codecs implemented in Python for most ISO 8859 encodings,
    with codec names from ''iso8859-1'' to ''iso8859-15''. A popular codec in Western
    Europe is ''latin-1'', a fast, built-in implementation of the ISO 8859-1 encoding
    that offers a one-byte-per-character encoding of special characters found in Western
    European languages (beware that it lacks the Euro currency character ''€''; however,
    if you need that, use ''iso8859-15''). On Windows systems only, the codec named
    ''mbcs'' wraps the platform’s multibyte character set conversion procedures. The
    codecs module also supplies various code pages with names from ''cp037'' to ''cp1258'',
    and Unicode standard encodings ''utf-8'' (likely to be most often the best choice,
    thus recommended, and the default) and ''utf-16'' (which has specific big-endian
    and little-endian variants: ''utf-16-be'' and ''utf-16-le''). For use with UTF-16,
    codecs also supplies attributes BOM_BE and BOM_LE, byte-order marks for big-endian
    and little-endian machines, respectively, and BOM, the byte-order mark for the
    current platform.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to various functions for more advanced uses, as mentioned earlier,
    the codecs module supplies a function to let you register your own conversion
    error handling functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| regis⁠t⁠e⁠r⁠_​e⁠r⁠r⁠or | register_error(*name*, *func*, /) *name* must be
    a string. *func* must be callable with one argument *e* that is an instance of
    UnicodeDecodeError, and must return a tuple with two items: the Unicode string
    to insert in the converted string result, and the index from which to continue
    the conversion (the latter is normally *e*.end). The function can use *e*.encoding,
    the name of the codec of this conversion, and *e*.object[*e*.start:*e*.end], the
    substring causing the conversion error. |'
  prefs: []
  type: TYPE_TB
- en: The unicodedata Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The unicodedata module provides easy access to the Unicode Character Database.
    Given any Unicode character, you can use functions supplied by unicodedata to
    obtain the character’s Unicode category, official name (if any), and other relevant
    information. You can also look up the Unicode character (if any) that corresponds
    to a given official name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: ^([1](ch09.xhtml#ch01fn96-marker)) In this book we cover only a subset of this
    legacy feature, the format specifier, that you must know about to properly use
    the logging module (discussed in [“The logging module”](ch06.xhtml#the_logging_module)).
  prefs: []
  type: TYPE_NORMAL
