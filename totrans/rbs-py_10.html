<html><head></head><body>
<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. User-Defined Types: Enums" class="preface"><div class="preface" id="enum">
<h1 class="calibre10" id="calibre_pb_0"><span class="calibre">Chapter 8. </span>User-Defined Types: Enums</h1>


<p class="author1">In this chapter, I’m going to focus on what a user-defined type is and cover the simplest user-defined data type: enumerations. I’ll discuss how to create an enumeration that will protect your code from common programming mistakes. I’ll then go over advanced features that allow you to express your ideas more clearly, such as creating aliases, making enumerations unique, or providing automatically generated values.</p>






</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. User-Defined Types: Enums" class="preface">
<div class="preface" id="enum">
<section data-type="sect1" data-pdf-bookmark="User-Defined Types" class="preface"><div class="preface" id="idm45644744544760">
<h1 class="calibre12" id="calibre_pb_1">User-Defined Types</h1>

<p class="author1">A user-defined type is a type that you, as a developer, create.<a data-type="indexterm" data-primary="user-defined types" data-secondary="about" id="ix_usrDT" class="calibre5"/> You define what data is associated with the type and what behaviors are associated with your type. Each of these types should tie to a singular concept. This will help other developers build mental models about your codebase.</p>

<p class="author1">For instance, if I am writing restaurant point-of-sale systems, I would expect to come across concepts about the restaurant domain in your codebase. Concepts like restaurants, menu items, and tax calculations should all be naturally represented in code. If I were to use lists, dictionaries, and tuples instead, I’d force my readers to constantly reinterpret the meaning of variables to their more natural mappings.</p>

<p class="author1">Consider a simple function that calculates a total with tax. Which function would you rather work with?</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">calculate_total_with_tax</code><code class="calibre17">(</code><code class="n">restaurant</code><code class="calibre17">:</code> <code class="nb">tuple</code><code class="calibre17">[</code><code class="nb">str</code><code class="calibre17">,</code> <code class="nb">str</code><code class="calibre17">,</code> <code class="nb">str</code><code class="calibre17">,</code> <code class="nb">int</code><code class="calibre17">],</code>
                             <code class="n">subtotal</code><code class="calibre17">:</code> <code class="nb">float</code><code class="calibre17">)</code> <code class="calibre17">-&gt;</code> <code class="nb">float</code><code class="calibre17">:</code>
    <code class="k">return</code> <code class="n">subtotal</code> <code class="calibre17">*</code> <code class="calibre17">(</code><code class="mi">1</code> <code class="calibre17">+</code> <code class="n">tax_lookup</code><code class="calibre17">[</code><code class="n">restaurant</code><code class="calibre17">[</code><code class="mi">2</code><code class="calibre17">]])</code></pre>

<p class="author1">or</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">calculate_total_with_tax</code><code class="calibre17">(</code><code class="n">restaurant</code><code class="calibre17">:</code> <code class="n">Restaurant</code><code class="calibre17">,</code>
                             <code class="n">subtotal</code><code class="calibre17">:</code> <code class="n">decimal</code><code class="calibre17">.</code><code class="n">Decimal</code><code class="calibre17">)</code> <code class="calibre17">-&gt;</code> <code class="n">decimal</code><code class="calibre17">.</code><code class="n">Decimal</code><code class="calibre17">:</code>
    <code class="k">return</code> <code class="n">subtotal</code> <code class="calibre17">*</code> <code class="calibre17">(</code><code class="mi">1</code> <code class="calibre17">+</code> <code class="n">tax_lookup</code><code class="calibre17">[</code><code class="n">restaurant</code><code class="calibre17">.</code><code class="n">zip_code</code><code class="calibre17">])</code></pre>

<p class="author1">By using the custom type <code class="calibre17">Restaurant</code>, you give readers crucial knowledge about the behavior of your code. Simple as it may be, it is incredibly powerful to build out these domain concepts.<a data-type="indexterm" data-primary="domain-related types, building" id="idm45644744509320" class="calibre5"/> Eric Evans, author of <em class="calibre6">Domain-Driven Design</em>, wrote, “The heart of software is its ability to solve domain-related problems for its user.”<sup class="calibre11"><a data-type="noteref" id="idm45644744508088-marker" href="part0012_split_011.html#idm45644744508088" class="calibre5">1</a></sup> If the heart of software is the ability to solve domain-related problems, domain-specific abstractions are the blood vessels. They are the support system, the network that flows through your codebase, all tying back to the central life giver that is the reason your code exists. By building up great domain-related types, you build a healthier system.</p>

<p class="author1">The most readable codebases are those that can be reasoned about, and it’s easiest to reason about the concepts that you encounter in your day to day. Newcomers to the codebase will already have a leg up if they are familiar with the core business concepts. You’ve spent the first part of this book focusing on expressing intent through annotations; this next part will focus on communicating intentions by building a shared vocabulary and making that vocabulary available to every developer working in the codebase.</p>

<p class="author1">The first way you’ll learn how to map a domain concept to a type is through Python’s enumeration type: <code class="calibre17">Enum</code>.<a data-type="indexterm" data-primary="user-defined types" data-secondary="about" data-startref="ix_usrDT" id="idm45644745022328" class="calibre5"/></p>
</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. User-Defined Types: Enums" class="preface">
<div class="preface" id="enum">
<section data-type="sect1" data-pdf-bookmark="Enumerations" class="preface"><div class="preface" id="idm45644744544136">
<h1 class="calibre12" id="calibre_pb_2">Enumerations</h1>

<p class="author1">In some scenarios, you want a developer to pick one value from a list.<a data-type="indexterm" data-primary="user-defined types" data-secondary="enumerations" id="ix_usrDTen" class="calibre5"/><a data-type="indexterm" data-primary="enumerations" id="ix_enum" class="calibre5"/> Colors of a traffic light, pricing plans of a web service, and HTTP methods are all great examples of this type of relationship. To express that relationship in Python, you should use <em class="calibre6">enumerations</em>. Enumerations are a construct that let you define the list of values, and developers pick the specific value they want. Python first supported enumerations in Python 3.4.</p>

<p class="author1">To illustrate what makes enumerations so special, let’s suppose you are developing an application that makes French cooking more accessible by providing a home-delivery network, from baguettes to beignets. It features a menu from which hungry users can select and then receive all the ingredients and cooking instructions by mail.</p>

<p class="author1">One of the most popluar offerings in this app is the customization. Users can pick which meat they want, which side, and which sauce to prepare. One of the most essential parts of French cooking is its <em class="calibre6">mother sauces</em>. These five well-known sauces are building blocks for countless other sauces, and I want to programmatically add new ingredients to these, creating what’s known as <em class="calibre6">daughter sauces</em>. This way, users can learn how French sauces are categorized when they order their food.</p>

<p class="author1">Let’s suppose I represent <a data-type="indexterm" data-primary="tuples" data-secondary="properties of" id="idm45644745973704" class="calibre5"/>the mother sauces as a Python tuple:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="c"># Note: use UPPER_CASE variable names to denote constant/immutable values</code>
<code class="n">MOTHER_SAUCES</code> <code class="calibre17">=</code> <code class="calibre17">(</code><code class="s">"Béchamel"</code><code class="calibre17">,</code> <code class="s">"Velouté"</code><code class="calibre17">,</code> <code class="s">"Espagnole"</code><code class="calibre17">,</code> <code class="s">"Tomato"</code><code class="calibre17">,</code> <code class="s">"Hollandaise"</code><code class="calibre17">)</code></pre>

<p class="author1">What does this tuple communicate to other developers?</p>

<ul class="printings">
<li class="calibre9">
<p class="author1">This collection is immutable.</p>
</li>
<li class="calibre9">
<p class="author1">They can iterate over this collection to get all the sauces.</p>
</li>
<li class="calibre9">
<p class="author1">They can retrieve a specific element through static indexing.</p>
</li>
</ul>

<p class="author1">The immutability and retrieval properties are important for my application.  I don’t want to add or subtract any mother sauces at runtime (such would be culinary blasphemy). Using a tuple makes it clear to future developers that they should not change these values. Retrieval lets me choose just one sauce, although it is a bit clunky.<a data-type="indexterm" data-primary="indexing" data-secondary="static indexing of tuples" id="idm45644744985928" class="calibre5"/> Every time I need to reference an element, I can do so through static indexing:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">MOTHER_SAUCES</code><code class="calibre17">[</code><code class="mi">2</code><code class="calibre17">]</code></pre>

<p class="author1">This unfortunately does not communicate intent. Every time a developer sees this, they  must remember that <code class="calibre17">2</code> means <code class="calibre17">"Espagnole"</code>. Constantly correlating numbers to sauces wastes time. This is fragile and will invariably cause mistakes. Should somebody alphabetically sort the sauces, the indices will change, breaking the code. Statically indexing into this tuple will not help the robustness of this code.</p>

<p class="author1">To combat<a data-type="indexterm" data-primary="type aliases" id="idm45644744982792" class="calibre5"/> this, I’ll make aliases for each of these:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">B</code><code class="err">É</code><code class="n">CHAMEL</code> <code class="calibre17">=</code> <code class="s">"Béchamel"</code>
<code class="n">VELOUT</code><code class="err">É</code> <code class="calibre17">=</code> <code class="s">"Velouté"</code>
<code class="n">ESPAGNOLE</code> <code class="calibre17">=</code> <code class="s">"Espagnole"</code>
<code class="n">TOMATO</code> <code class="calibre17">=</code> <code class="s">"Tomato"</code>
<code class="n">HOLLANDAISE</code> <code class="calibre17">=</code> <code class="s">"Hollandaise"</code>
<code class="n">MOTHER_SAUCES</code> <code class="calibre17">=</code> <code class="calibre17">(</code><code class="n">B</code><code class="err">É</code><code class="n">CHAMEL</code><code class="calibre17">,</code> <code class="n">VELOUT</code><code class="err">É</code><code class="calibre17">,</code> <code class="n">ESPAGNOLE</code><code class="calibre17">,</code> <code class="n">TOMATO</code><code class="calibre17">,</code> <code class="n">HOLLANDAISE</code><code class="calibre17">)</code></pre>

<p class="author1">That’s a bit more code, and still doesn’t make it any easier to index into that tuple. Furthermore, there is still a lingering issue in calling code.</p>

<p class="author1">Consider a function that creates a daughter sauce:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">create_daughter_sauce</code><code class="calibre17">(</code><code class="n">mother_sauce</code><code class="calibre17">:</code> <code class="nb">str</code><code class="calibre17">,</code>
                          <code class="n">extra_ingredients</code><code class="calibre17">:</code> <code class="nb">list</code><code class="calibre17">[</code><code class="nb">str</code><code class="calibre17">]):</code>
    <code class="c"># ...</code></pre>

<p class="author1">I want you to pause a moment and consider what this function tells future developers. I’m purposely leaving out the implementation, because I want to talk about first impressions; the function signature is the first thing a developer will see. Based on the function signature alone, does this function properly convey what is allowed?</p>

<p class="author1">Future developers would come across code like this:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">create_daughter_sauce</code><code class="calibre17">(</code><code class="n">MOTHER_SAUCES</code><code class="calibre17">[</code><code class="mi">0</code><code class="calibre17">],</code> <code class="calibre17">[</code><code class="s">"Onions"</code><code class="calibre17">])</code> <code class="c"># not super helpful</code>
<code class="n">create_daughter_sauce</code><code class="calibre17">(</code><code class="n">B</code><code class="err">É</code><code class="n">CHAMEL</code><code class="calibre17">,</code> <code class="calibre17">[</code><code class="s">"Onions"</code><code class="calibre17">])</code> <code class="c"># Better</code></pre>

<p class="author1">Or:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">create_daughter_sauce</code><code class="calibre17">(</code><code class="s">"Hollandaise"</code><code class="calibre17">,</code> <code class="calibre17">[</code><code class="s">"Horseradish"</code><code class="calibre17">])</code>
<code class="n">create_daughter_sauce</code><code class="calibre17">(</code><code class="s">"Veloute"</code><code class="calibre17">,</code> <code class="calibre17">[</code><code class="s">"Mustard"</code><code class="calibre17">])</code>


<code class="c"># Definitely wrong</code>
<code class="n">create_daughter_sauce</code><code class="calibre17">(</code><code class="s">"Alabama White BBQ Sauce"</code><code class="calibre17">,</code> <code class="calibre17">[])</code></pre>

<p class="author1">And here lies the crux of the problem. On the happy path, a developer can use the predefined variables. But if somebody accidentally were to use the wrong sauce (after all, <code class="calibre17">create_daughter_sauce</code> expects a string, which could be anything), you soon get unwanted behavior. Remember, I am talking about developers looking at this months (or potentially years) later. They have been tasked to add a feature to the codebase, even though they are not familiar with it. By choosing a string type, I’m just inviting the wrong values to be supplied later.</p>
<div data-type="warning" epub:type="warning" class="calibre23"><h6 class="calibre24">Warning</h6>
<p class="author1">Even honest mistakes have ramifications. Did you catch that I left an accent off of the “e” in <code class="calibre17">Velouté</code>? Have fun debugging that in production.</p>
</div>

<p class="author1">Instead, you want to find a way to communicate that you want a very specific, restricted set of values in specific locations. Since you’re in a chapter about “enumerations” and I haven’t shown them yet, I’m sure you can guess what the solution is.</p>








</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. User-Defined Types: Enums" class="preface">
<div class="preface" id="enum">
<section data-type="sect1" data-pdf-bookmark="Enumerations" class="preface">
<div class="preface" id="idm45644744544136">
<section data-type="sect2" data-pdf-bookmark="Enum" class="preface"><div class="preface" id="idm45644744840952">
<h2 class="calibre34" id="calibre_pb_3">Enum</h2>

<p class="author1">Here’s an example of <a data-type="indexterm" data-primary="enumerations" data-secondary="Enum type" id="idm45644744839352" class="calibre5"/>Python’s enumeration, <code class="calibre17">Enum</code>, in action:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">enum</code> <code class="k">import</code> <code class="n">Enum</code>
<code class="k">class</code> <code class="nc">MotherSauce</code><code class="calibre17">(</code><code class="n">Enum</code><code class="calibre17">):</code>
    <code class="n">B</code><code class="err">É</code><code class="n">CHAMEL</code> <code class="calibre17">=</code> <code class="s">"Béchamel"</code>
    <code class="n">VELOUT</code><code class="err">É</code> <code class="calibre17">=</code> <code class="s">"Velouté"</code>
    <code class="n">ESPAGNOLE</code> <code class="calibre17">=</code> <code class="s">"Espagnole"</code>
    <code class="n">TOMATO</code> <code class="calibre17">=</code> <code class="s">"Tomato"</code>
    <code class="n">HOLLANDAISE</code> <code class="calibre17">=</code> <code class="s">"Hollandaise"</code></pre>

<p class="author1">To access specific instances, you can just do:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">MotherSauce</code><code class="calibre17">.</code><code class="n">B</code><code class="err">É</code><code class="n">CHAMEL</code>
<code class="n">MotherSauce</code><code class="calibre17">.</code><code class="n">HOLLANDAISE</code></pre>

<p class="author1">This is near identical to the string aliases, but there are a few extra benefits.</p>

<p class="author1">You cannot accidentally create a <code class="calibre17">MotherSauce</code> with an unexpected value:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="calibre17">&gt;&gt;&gt;</code><code class="n">MotherSauce</code><code class="calibre17">(</code><code class="s">"Hollandaise"</code><code class="calibre17">)</code> <code class="c"># OKAY</code>

<code class="calibre17">&gt;&gt;&gt;</code><code class="n">MotherSauce</code><code class="calibre17">(</code><code class="s">"Alabama White BBQ Sauce"</code><code class="calibre17">)</code>
<code class="ne">ValueError</code><code class="calibre17">:</code> <code class="s">'Alabama White BBQ Sauce'</code> <code class="calibre19">is</code> <code class="calibre19">not</code> <code class="n">a</code> <code class="n">valid</code> <code class="n">MotherSauce</code></pre>

<p class="author1">That will certainly limit errors (either with invalid sauces or innocent typos).</p>

<p class="author1">If you wanted to print out all the values of the enumeration, you can simply iterate over the enumeration (no need to create a separate list).</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="calibre17">&gt;&gt;&gt;</code><code class="k">for</code> <code class="n">option_number</code><code class="calibre17">,</code> <code class="n">sauce</code> <code class="calibre19">in</code> <code class="nb">enumerate</code><code class="calibre17">(</code><code class="n">MotherSauce</code><code class="calibre17">,</code> <code class="n">start</code><code class="calibre17">=</code><code class="mi">1</code><code class="calibre17">):</code>
<code class="calibre17">&gt;&gt;&gt;</code>    <code class="k">print</code><code class="calibre17">(</code><code class="n">f</code><code class="s">"Option {option_number}: {sauce.value}"</code><code class="calibre17">)</code>

<code class="n">Option</code> <code class="mi">1</code><code class="calibre17">:</code> <code class="n">B</code><code class="err">é</code><code class="n">chamel</code>
<code class="n">Option</code> <code class="mi">2</code><code class="calibre17">:</code> <code class="n">Velout</code><code class="err">é</code>
<code class="n">Option</code> <code class="mi">3</code><code class="calibre17">:</code> <code class="n">Espagnole</code>
<code class="n">Option</code> <code class="mi">4</code><code class="calibre17">:</code> <code class="n">Tomato</code>
<code class="n">Option</code> <code class="mi">5</code><code class="calibre17">:</code> <code class="n">Hollandaise</code></pre>

<p class="author1">Finally, and crucially, you can <a data-type="indexterm" data-primary="intent" data-secondary="communicating in functions using Enum" id="idm45644745456024" class="calibre5"/>communicate your intent in functions that use this <code class="calibre17">Enum</code>:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">create_daughter_sauce</code><code class="calibre17">(</code><code class="n">mother_sauce</code><code class="calibre17">:</code> <code class="n">MotherSauce</code><code class="calibre17">,</code>
                          <code class="n">extra_ingredients</code><code class="calibre17">:</code> <code class="nb">list</code><code class="calibre17">[</code><code class="nb">str</code><code class="calibre17">]):</code>
    <code class="c"># ...</code></pre>

<p class="author1">This tells all the developers looking at this function that they should be passing in a <code class="calibre17">MotherSauce</code> enumeration, and not just any old string. It becomes much harder to introduce typos or incorrect values. (A user can still pass wrong values if they really want to, but they would be in direct violation of what’s expected, which is easier to catch—I covered how to catch these errors in <a data-type="xref" href="part0004.html#part_1" class="calibre5">Part I</a>.)</p>
</div></section>













</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. User-Defined Types: Enums" class="preface">
<div class="preface" id="enum">
<section data-type="sect1" data-pdf-bookmark="Enumerations" class="preface">
<div class="preface" id="idm45644744544136">
<section data-type="sect2" data-pdf-bookmark="Enum" class="preface">
<div class="preface" id="idm45644744840952">
<div data-type="note" epub:type="note" class="calibre21"><h1 class="calibre38" id="calibre_pb_4">Discussion Topic</h1>
<p class="author1">What sets of data in your codebase would benefit from an <code class="calibre17">Enum</code>? Do you have areas of code where developers pass in the wrong value, even though it is the right type? Discuss where enumerations would improve your codebase.</p>
</div>
</div></section>













</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. User-Defined Types: Enums" class="preface">
<div class="preface" id="enum">
<section data-type="sect1" data-pdf-bookmark="Enumerations" class="preface">
<div class="preface" id="idm45644744544136">
<section data-type="sect2" data-pdf-bookmark="When Not to Use" class="preface"><div class="preface" id="idm45644744840328">
<h2 class="calibre34" id="calibre_pb_5">When Not to Use</h2>

<p class="author1">Enumerations are great for <a data-type="indexterm" data-primary="enumerations" data-secondary="when not to use" id="idm45644745562424" class="calibre5"/>communicating a static set of choices for users. You don’t want to use them where your options are determined at runtime, as you lose a lot of their benefits around communicating intent and tooling (it is much tougher for a reader of code to know what values are possible if they can change in every run-through). If you find yourself in this situation, I recommend a dictionary, which offers a natural mapping between two values that can be changed at runtime. You will need to perform membership checks if you need to restrict what values a user can select, though.<a data-type="indexterm" data-primary="enumerations" data-startref="ix_enum" id="idm45644745560728" class="calibre5"/></p>
</div></section>





</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. User-Defined Types: Enums" class="preface">
<div class="preface" id="enum">
<section data-type="sect1" data-pdf-bookmark="Advanced Usage" class="preface"><div class="preface" id="idm45644745020136">
<h1 class="calibre12" id="calibre_pb_6">Advanced Usage</h1>

<p class="author1">Once you master the basics of enumerations, there are quite a few things you can do to even further refine your usage.<a data-type="indexterm" data-primary="enumerations" data-secondary="advanced usage" id="ix_enumadv" class="calibre5"/> Remember, the more specific type you choose, the more specific information you convey.</p>








</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. User-Defined Types: Enums" class="preface">
<div class="preface" id="enum">
<section data-type="sect1" data-pdf-bookmark="Advanced Usage" class="preface">
<div class="preface" id="idm45644745020136">
<section data-type="sect2" data-pdf-bookmark="Automatic Values" class="preface"><div class="preface" id="idm45644745524568">
<h2 class="calibre34" id="calibre_pb_7">Automatic Values</h2>

<p class="author1">For some enumerations, you might want to explicitly specify that you don’t care about the value that the enumeration is tied to.<a data-type="indexterm" data-primary="enumerations" data-secondary="advanced usage" data-tertiary="automatic values" id="idm45644745522888" class="calibre5"/><a data-type="indexterm" data-primary="automatic values for Enums" id="idm45644745521640" class="calibre5"/> This tells users that they should not rely on these values. For this, you can use the <code class="calibre17">auto()</code> function.</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">enum</code> <code class="k">import</code> <code class="n">auto</code><code class="calibre17">,</code> <code class="n">Enum</code>
<code class="k">class</code> <code class="nc">MotherSauce</code><code class="calibre17">(</code><code class="n">Enum</code><code class="calibre17">):</code>
    <code class="n">B</code><code class="err">É</code><code class="n">CHAMEL</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>
    <code class="n">VELOUT</code><code class="err">É</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>
    <code class="n">ESPAGNOLE</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>
    <code class="n">TOMATO</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>
    <code class="n">HOLLANDAISE</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>

<code class="calibre17">&gt;&gt;&gt;</code><code class="nb">list</code><code class="calibre17">(</code><code class="n">MotherSauce</code><code class="calibre17">)</code>
<code class="calibre17">[</code><code class="calibre17">&lt;</code><code class="n">MotherSauce</code><code class="calibre17">.</code><code class="n">B</code><code class="err">É</code><code class="n">CHAMEL</code><code class="calibre17">:</code> <code class="mi">1</code><code class="calibre17">&gt;</code><code class="calibre17">,</code> <code class="calibre17">&lt;</code><code class="n">MotherSauce</code><code class="calibre17">.</code><code class="n">VELOUT</code><code class="err">É</code><code class="calibre17">:</code> <code class="mi">2</code><code class="calibre17">&gt;</code><code class="calibre17">,</code> <code class="calibre17">&lt;</code><code class="n">MotherSauce</code><code class="calibre17">.</code><code class="n">ESPAGNOLE</code><code class="calibre17">:</code> <code class="mi">3</code><code class="calibre17">&gt;</code><code class="calibre17">,</code>
 <code class="calibre17">&lt;</code><code class="n">MotherSauce</code><code class="calibre17">.</code><code class="n">TOMATO</code><code class="calibre17">:</code> <code class="mi">4</code><code class="calibre17">&gt;</code><code class="calibre17">,</code> <code class="calibre17">&lt;</code><code class="n">MotherSauce</code><code class="calibre17">.</code><code class="n">HOLLANDAISE</code><code class="calibre17">:</code> <code class="mi">5</code><code class="calibre17">&gt;</code><code class="calibre17">]</code></pre>

<p class="author1">By default, <code class="calibre17">auto()</code> will select monotonically increasing values (1, 2, 3, 4, 5…). If <span class="calibre">you would like</span> to control what values are set, you should implement a <code class="calibre17">_generate_next_value_()</code> function:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">enum</code> <code class="k">import</code> <code class="n">auto</code><code class="calibre17">,</code> <code class="n">Enum</code>
<code class="k">class</code> <code class="nc">MotherSauce</code><code class="calibre17">(</code><code class="n">Enum</code><code class="calibre17">):</code>
    <code class="k">def</code> <code class="nf">_generate_next_value_</code><code class="calibre17">(</code><code class="n">name</code><code class="calibre17">,</code> <code class="n">start</code><code class="calibre17">,</code> <code class="n">count</code><code class="calibre17">,</code> <code class="n">last_values</code><code class="calibre17">):</code>
        <code class="k">return</code> <code class="n">name</code><code class="calibre17">.</code><code class="n">capitalize</code><code class="calibre17">()</code>
    <code class="n">B</code><code class="err">É</code><code class="n">CHAMEL</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>
    <code class="n">VELOUT</code><code class="err">É</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>
    <code class="n">ESPAGNOLE</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>
    <code class="n">TOMATO</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>
    <code class="n">HOLLANDAISE</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>

<code class="calibre17">&gt;&gt;&gt;</code><code class="nb">list</code><code class="calibre17">(</code><code class="n">MotherSauce</code><code class="calibre17">)</code>
<code class="calibre17">[</code><code class="calibre17">&lt;</code><code class="n">MotherSauce</code><code class="calibre17">.</code><code class="n">B</code><code class="err">É</code><code class="n">CHAMEL</code><code class="calibre17">:</code> <code class="s">'Béchamel'</code><code class="calibre17">&gt;</code><code class="calibre17">,</code> <code class="calibre17">&lt;</code><code class="n">MotherSauce</code><code class="calibre17">.</code><code class="n">VELOUT</code><code class="err">É</code><code class="calibre17">:</code> <code class="s">'Velouté'</code><code class="calibre17">&gt;</code><code class="calibre17">,</code>
 <code class="calibre17">&lt;</code><code class="n">MotherSauce</code><code class="calibre17">.</code><code class="n">ESPAGNOLE</code><code class="calibre17">:</code> <code class="s">'Espagnole'</code><code class="calibre17">&gt;</code><code class="calibre17">,</code> <code class="calibre17">&lt;</code><code class="n">MotherSauce</code><code class="calibre17">.</code><code class="n">TOMATO</code><code class="calibre17">:</code> <code class="s">'Tomato'</code><code class="calibre17">&gt;</code><code class="calibre17">,</code>
 <code class="calibre17">&lt;</code><code class="n">MotherSauce</code><code class="calibre17">.</code><code class="n">HOLLANDAISE</code><code class="calibre17">:</code> <code class="s">'Hollandaise'</code><code class="calibre17">&gt;</code><code class="calibre17">]</code></pre>

<p class="author1">Very rarely will you see <code class="calibre17">_generate_next_value_</code> defined like this, right inside of an enumeration with values. If <code class="calibre17">auto</code> is used to indicate that the value doesn’t matter, then <code class="calibre17">_generate_next_value_</code> indicates that you want very specific values for <code class="calibre17">auto</code>. It feels contradictory. This is why you typically use <code class="calibre17">_generate_next_value_</code> in base <code class="calibre17">Enum</code> classes, which are enumerations that are meant to be subtyped and don’t include any values. The <code class="calibre17">Flag</code> class, which you’ll see next, is a good example of a base class.</p>
<aside data-type="sidebar" epub:type="sidebar" class="calibre32"><div class="sidebar" id="idm45644745169000">
<h5 class="calibre33">Enums Versus Literals</h5>
<p class="author1">Python’s <code class="calibre17">Literal</code> (introduced in Python 3.8) has many of the same benefits as an <code class="calibre17">Enum</code> with automatically set values (assuming there is no <code class="calibre17">_generate_next_value_</code>). <a data-type="indexterm" data-primary="enumerations" data-secondary="Enums versus Literals" id="idm45644745166152" class="calibre5"/><a data-type="indexterm" data-primary="Literal types" data-secondary="Enums versus" id="idm45644745165144" class="calibre5"/>In both cases, you are restricting your variables to a very specific set of values.</p>

<p class="author1">From a typechecker’s perspective, there is very little difference between this:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">sauce</code><code class="o">:</code> <code class="n">Literal</code><code class="o">[</code><code class="s">'Béchamel'</code><code class="o">,</code> <code class="s">'Velouté'</code><code class="o">,</code> <code class="s">'Espagnole'</code><code class="o">,</code>
               <code class="s">'Tomato'</code><code class="o">,</code> <code class="s">'Hollandaise'</code><code class="o">]</code> <code class="o">=</code> <code class="s">'Hollandaise'</code></pre>

<p class="author1">and this:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">sauce</code><code class="o">:</code> <code class="n">MotherSauce</code> <code class="o">=</code> <code class="n">MotherSauce</code><code class="o">.</code><code class="n">HOLLANDAISE</code></pre>

<p class="author1">If you just need a simple restriction, reach for <code class="calibre17">Literal</code> first. However, if you want iteration, runtime checking, or different values mapped from name to value, use an <code class="calibre17">Enum</code>.</p>
</div></aside>
</div></section>













</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. User-Defined Types: Enums" class="preface">
<div class="preface" id="enum">
<section data-type="sect1" data-pdf-bookmark="Advanced Usage" class="preface">
<div class="preface" id="idm45644745020136">
<section data-type="sect2" data-pdf-bookmark="Flags" class="preface"><div class="preface" id="idm45644744735144">
<h2 class="calibre34" id="calibre_pb_8">Flags</h2>

<p class="author1">Now that you have the mother sauces represented in an <code class="calibre17">Enum</code>, you decide that you are ready to start serving meals with those sauces.<a data-type="indexterm" data-primary="flags, using with Enums" id="idm45644744733096" class="calibre5"/><a data-type="indexterm" data-primary="enumerations" data-secondary="advanced usage" data-tertiary="Flags" id="idm45644744732392" class="calibre5"/> But before you begin, you want to be conscious of your customers’ allergies, so you decide to represent allergy information for each dish. With your newfound knowledge of <code class="calibre17">auto()</code>, setting up the <code class="calibre17">Allergen</code> enumeration is a piece of cake:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">enum</code> <code class="k">import</code> <code class="n">auto</code><code class="calibre17">,</code> <code class="n">Enum</code>
<code class="k">from</code> <code class="nn">typing</code> <code class="k">import</code> <code class="n">Set</code>
<code class="k">class</code> <code class="nc">Allergen</code><code class="calibre17">(</code><code class="n">Enum</code><code class="calibre17">):</code>
    <code class="n">FISH</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>
    <code class="n">SHELLFISH</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>
    <code class="n">TREE_NUTS</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>
    <code class="n">PEANUTS</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>
    <code class="n">GLUTEN</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>
    <code class="n">SOY</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>
    <code class="n">DAIRY</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code></pre>

<p class="author1">And for a recipe, you might track a list of allergens as such:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">allergens</code><code class="calibre17">:</code> <code class="n">Set</code><code class="calibre17">[</code><code class="n">Allergen</code><code class="calibre17">]</code> <code class="calibre17">=</code> <code class="calibre17">{</code><code class="n">Allergen</code><code class="calibre17">.</code><code class="n">FISH</code><code class="calibre17">,</code> <code class="n">Allergen</code><code class="calibre17">.</code><code class="n">SOY</code><code class="calibre17">}</code></pre>

<p class="author1">This tells readers that a collection of allergens will be unique, and that there might be zero, one, or many allergens. This is exactly what you want. But what if I wanted all allergen information in the system to be tracked like this? I don’t want to rely on every developer remembering to use a set (just one use of a list or dictionary can invite wrong behavior). I want some way to represent a grouping of unique enumeration values universally.</p>

<p class="author1">The <code class="calibre17">enum</code> module gives you<a data-type="indexterm" data-primary="flags, using with Enums" data-secondary="Flag base class" id="idm45644745080520" class="calibre5"/> a handy base class to use—<code class="calibre17">Flag</code>:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">enum</code> <code class="k">import</code> <code class="n">Flag</code>
<code class="k">class</code> <code class="nc">Allergen</code><code class="calibre17">(</code><code class="n">Flag</code><code class="calibre17">):</code>
    <code class="n">FISH</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>
    <code class="n">SHELLFISH</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>
    <code class="n">TREE_NUTS</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>
    <code class="n">PEANUTS</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>
    <code class="n">GLUTEN</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>
    <code class="n">SOY</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>
    <code class="n">DAIRY</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code></pre>

<p class="author1">This lets you perform bitwise operations to combine allergens or check if certain allergens are present.<a data-type="indexterm" data-primary="bitwise operations, performing with Enum values" id="idm45644743603224" class="calibre5"/></p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="calibre17">&gt;&gt;&gt;</code><code class="n">allergens</code> <code class="calibre17">=</code> <code class="n">Allergen</code><code class="calibre17">.</code><code class="n">FISH</code> <code class="calibre17">|</code> <code class="n">Allergen</code><code class="calibre17">.</code><code class="n">SHELLFISH</code>
<code class="calibre17">&gt;&gt;&gt;</code><code class="n">allergens</code>
<code class="calibre17">&lt;</code><code class="n">Allergen</code><code class="calibre17">.</code><code class="n">SHELLFISH</code><code class="calibre17">|</code><code class="n">FISH</code><code class="calibre17">:</code> <code class="mi">3</code><code class="calibre17">&gt;</code>

<code class="calibre17">&gt;&gt;&gt;</code><code class="k">if</code> <code class="n">allergens</code> <code class="calibre17">&amp;</code> <code class="n">Allergen</code><code class="calibre17">.</code><code class="n">FISH</code><code class="calibre17">:</code>
<code class="calibre17">&gt;&gt;&gt;</code>    <code class="k">print</code><code class="calibre17">(</code><code class="s">"This recipe contains fish."</code><code class="calibre17">)</code>
<code class="n">This</code> <code class="n">recipe</code> <code class="n">contains</code> <code class="n">fish</code><code class="calibre17">.</code></pre>

<p class="author1">This is great when you want to represent a selection of values (say, something that was set through a multi–drop down or a bitmask). There are some limitations, though. The values must support the bitwise operations (|, &amp;, etc.). Strings would be an example of types that don’t, while integers do. Furthermore, the values cannot overlap when bitwise operations are performed. For example, you cannot use the values from 1 through 4 (inclusive) for your <code class="calibre17">Enum</code> because 4 will “bitwise and” for the values 1, 2, and 4 which is probably not what you want. <code class="calibre17">auto()</code> takes care of this for you because the <code class="calibre17">_generate_next_value_</code> of <code class="calibre17">Flag</code> automatically uses powers of 2.</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">class</code> <code class="nc">Allergen</code><code class="calibre17">(</code><code class="n">Flag</code><code class="calibre17">):</code>
    <code class="n">FISH</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>
    <code class="n">SHELLFISH</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>
    <code class="n">TREE_NUTS</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>
    <code class="n">PEANUTS</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>
    <code class="n">GLUTEN</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>
    <code class="n">SOY</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>
    <code class="n">DAIRY</code> <code class="calibre17">=</code> <code class="n">auto</code><code class="calibre17">()</code>
    <code class="n">SEAFOOD</code> <code class="calibre17">=</code> <code class="n">Allergen</code><code class="calibre17">.</code><code class="n">FISH</code> <code class="calibre17">|</code> <code class="n">Allergen</code><code class="calibre17">.</code><code class="n">SHELLFISH</code>
    <code class="n">ALL_NUTS</code> <code class="calibre17">=</code> <code class="n">Allergen</code><code class="calibre17">.</code><code class="n">TREE_NUTS</code> <code class="calibre17">|</code> <code class="n">Allergen</code><code class="calibre17">.</code><code class="n">PEANUTS</code></pre>

<p class="author1">The use of flags can express what you mean in very specific circumstances, but if you ever want more control of your values, or are enumerating values that don’t support bitwise operations, use a nonflag <code class="calibre17">Enum</code>.</p>

<p class="author1">As a final note, you are free to create your own aliases for built-in multiple enumeration selections, as I did with <code class="calibre17">SEAFOOD</code> and <code class="calibre17">ALL_NUTS</code> above.</p>
</div></section>













</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. User-Defined Types: Enums" class="preface">
<div class="preface" id="enum">
<section data-type="sect1" data-pdf-bookmark="Advanced Usage" class="preface">
<div class="preface" id="idm45644745020136">
<section data-type="sect2" data-pdf-bookmark="Integer Conversion" class="preface"><div class="preface" id="idm45644744734552">
<h2 class="calibre34" id="calibre_pb_9">Integer Conversion</h2>

<p class="author1">There are two more special case enumerations called <code class="calibre17">IntEnum</code> and <code class="calibre17">IntFlag</code>. These map to <code class="calibre17">Enum</code> and <code class="calibre17">Flag</code>, respectively, but allow degradation to raw integers for comparison.<a data-type="indexterm" data-primary="enumerations" data-secondary="advanced usage" data-tertiary="integer conversions" id="idm45644743438632" class="calibre5"/><a data-type="indexterm" data-primary="IntEnum" id="idm45644743437384" class="calibre5"/><a data-type="indexterm" data-primary="IntFlag" id="idm45644743436712" class="calibre5"/> I actually do not recommend using these features, and it’s important to understand why. First, let’s look at the problem they intend to solve.</p>

<p class="author1">In French cooking, the measurement of certain ingredients is paramount to success, so you need to make sure you have that covered as well. You create a metric and imperial liquid measure (you want to work internationally, after all) as enumerations, but are dismayed to find that you can’t just compare your enumerations to integers.</p>

<p class="author1">This code doesn’t work:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">class</code> <code class="nc">ImperialLiquidMeasure</code><code class="calibre17">(</code><code class="n">Enum</code><code class="calibre17">):</code>
    <code class="n">CUP</code> <code class="calibre17">=</code> <code class="mi">8</code>
    <code class="n">PINT</code> <code class="calibre17">=</code> <code class="mi">16</code>
    <code class="n">QUART</code> <code class="calibre17">=</code> <code class="mi">32</code>
    <code class="n">GALLON</code> <code class="calibre17">=</code> <code class="mi">128</code>

<code class="calibre17">&gt;&gt;&gt;</code><code class="n">ImperialLiquidMeasure</code><code class="calibre17">.</code><code class="n">CUP</code> <code class="calibre17">==</code> <code class="mi">8</code>
<code class="nb">False</code></pre>

<p class="author1">But, if you were to subclass from <code class="calibre17">IntEnum</code>, it works just fine:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">class</code> <code class="nc">ImperialLiquidMeasure</code><code class="calibre17">(</code><code class="n">IntEnum</code><code class="calibre17">):</code>
    <code class="n">CUP</code> <code class="calibre17">=</code> <code class="mi">8</code>
    <code class="n">PINT</code> <code class="calibre17">=</code> <code class="mi">16</code>
    <code class="n">QUART</code> <code class="calibre17">=</code> <code class="mi">32</code>
    <code class="n">GALLON</code> <code class="calibre17">=</code> <code class="mi">128</code>

<code class="calibre17">&gt;&gt;&gt;</code><code class="n">ImperialLiquidMeasure</code><code class="calibre17">.</code><code class="n">CUP</code> <code class="calibre17">==</code> <code class="mi">8</code>
<code class="nb">True</code></pre>

<p class="author1">An <code class="calibre17">IntFlag</code> performs similarly. You’ll see this more when interoperating between systems or possibly hardware. If you were not using an <code class="calibre17">IntEnum</code>, you would need to do something like:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="calibre17">&gt;&gt;&gt;</code><code class="n">ImperialLiquidMeasure</code><code class="calibre17">.</code><code class="n">CUP</code><code class="calibre17">.</code><code class="n">value</code> <code class="calibre17">==</code> <code class="mi">8</code>
<code class="nb">True</code></pre>

<p class="author1">The convenience of using an <code class="calibre17">IntEnum</code> does not often outweigh the drawback of being a weaker type.<a data-type="indexterm" data-primary="type conversions" data-secondary="integer conversions with IntEnum" id="idm45644743304664" class="calibre5"/> Any implicit conversion to integer hides the true intent of the class. Since implicit integer conversion happens, you might run into a copy/paste mistake (we’ve all made those, right?) in situations that don’t do what you want.</p>

<p class="author1">Consider:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">class</code> <code class="nc">Kitchenware</code><code class="calibre17">(</code><code class="n">IntEnum</code><code class="calibre17">):</code>
    <code class="c"># Note to future programmers: these numbers are customer-defined</code>
    <code class="c"># and apt to change</code>
    <code class="n">PLATE</code> <code class="calibre17">=</code> <code class="mi">7</code>
    <code class="n">CUP</code> <code class="calibre17">=</code> <code class="mi">8</code>
    <code class="n">UTENSILS</code> <code class="calibre17">=</code> <code class="mi">9</code></pre>

<p class="author1">Suppose somebody were to mistakenly do the following:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">pour_liquid</code><code class="calibre17">(</code><code class="n">volume</code><code class="calibre17">:</code> <code class="n">ImperialLiquidMeasure</code><code class="calibre17">):</code>
    <code class="k">if</code> <code class="n">volume</code> <code class="calibre17">==</code> <code class="n">Kitchenware</code><code class="calibre17">.</code><code class="n">CUP</code><code class="calibre17">:</code>
        <code class="n">pour_into_smaller_vessel</code><code class="calibre17">()</code>
    <code class="k">else</code><code class="calibre17">:</code>
        <code class="n">pour_into_larger_vessel</code><code class="calibre17">()</code></pre>

<p class="author1">If this makes it into production, it will be just fine, no exceptions thrown, all tests pass. However, once the <code class="calibre17">Kitchenware</code> enumeration changes (maybe it adds a <code class="calibre17">BOWL</code> into value <code class="calibre17">8</code> and moves <code class="calibre17">CUP</code> to <code class="calibre17">10</code>), this code will now do the exact opposite of what it was supposed to. <code class="calibre17">Kitchenware.CUP</code> is no longer the same as an <code class="calibre17">ImperialLiquidMeasure.CUP</code> (there’s no reason they should be linked); then you’ll start pouring into larger vessels instead of smaller vessels, which probably will create an overflow (of your liquid, not of an integer).</p>

<p class="author1">This is a textbook example of how unrobust code can lead to subtle mistakes that won’t become an issue until much later in the codebase’s life. This may be a quick fix, but the bug incurs a very real cost. Tests fail (or worse, a customer complains about pouring the wrong amount of liquid into a vessel), someone has to go crawl through the source code, find the bug, fix it, then take a long coffee break after wondering how this ever worked. All because somebody decided to be lazy and use an <code class="calibre17">IntEnum</code> so that they wouldn’t have to type out <code class="calibre17">.value</code> over and over again. So pay your future maintainers a favor: don’t use <code class="calibre17">IntEnum</code> unless you absolutely have to for legacy <span class="calibre">purposes</span>.</p>
</div></section>













</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. User-Defined Types: Enums" class="preface">
<div class="preface" id="enum">
<section data-type="sect1" data-pdf-bookmark="Advanced Usage" class="preface">
<div class="preface" id="idm45644745020136">
<section data-type="sect2" data-pdf-bookmark="Unique" class="preface"><div class="preface" id="idm45644743441752">
<h2 class="calibre34" id="calibre_pb_10">Unique</h2>

<p class="author1">One great feature of enumerations is the ability to alias values.<a data-type="indexterm" data-primary="aliases" data-secondary="aliasing values of enumerations" id="idm45644743188920" class="calibre5"/><a data-type="indexterm" data-primary="enumerations" data-secondary="advanced usage" data-tertiary="uniqueness of values" id="idm45644743187976" class="calibre5"/> Let’s go back to the <code class="calibre17">MotherSauce</code> enumeration. Maybe the codebase developed on French keyboards needs to be adapted to US keyboards, where the keyboard layout is not conducive to adding accent marks over vowels. Removing the accents to anglicize the native French spelling is a nonstarter for many of the developers (they insist we use the original spelling). To avoid an international incident, I will add an alias to some of the sauces.</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">enum</code> <code class="k">import</code> <code class="n">Enum</code>
<code class="k">class</code> <code class="nc">MotherSauce</code><code class="calibre17">(</code><code class="n">Enum</code><code class="calibre17">):</code>
    <code class="n">B</code><code class="err">É</code><code class="n">CHAMEL</code> <code class="calibre17">=</code> <code class="s">"Béchamel"</code>
    <code class="n">BECHAMEL</code> <code class="calibre17">=</code> <code class="s">"Béchamel"</code>
    <code class="n">VELOUT</code><code class="err">É</code> <code class="calibre17">=</code> <code class="s">"Velouté"</code>
    <code class="n">VELOUTE</code> <code class="calibre17">=</code> <code class="s">"Velouté"</code>
    <code class="n">ESPAGNOLE</code> <code class="calibre17">=</code> <code class="s">"Espagnole"</code>
    <code class="n">TOMATO</code> <code class="calibre17">=</code> <code class="s">"Tomato"</code>
    <code class="n">HOLLANDAISE</code> <code class="calibre17">=</code> <code class="s">"Hollandaise"</code></pre>

<p class="author1">With this, there was much rejoicing from all keyboard owners. Enumerations absolutely allow this sort of behavior; they can have duplicate values as long as the keys are not duplicated.</p>

<p class="author1">However, there are cases where you <a data-type="indexterm" data-primary="uniqueness, forcing for values of Enums" id="idm45644743116808" class="calibre5"/>want to force uniqueness on the values. Perhaps you are relying on the enumeration to always contain a set number of values, or perhaps it messes with some of the string representations that are shown to customers. No matter the case, if you want to preserve uniqueness in your <code class="calibre17">Enum</code>, simply add a <code class="calibre17">@unique</code> decorator.<a data-type="indexterm" data-primary="@unique decorator" id="idm45644743115016" class="calibre5"/></p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">enum</code> <code class="k">import</code> <code class="n">Enum</code><code class="calibre17">,</code> <code class="n">unique</code>
<code class="nd">@unique</code>
<code class="k">class</code> <code class="nc">MotherSauce</code><code class="calibre17">(</code><code class="n">Enum</code><code class="calibre17">):</code>
    <code class="n">B</code><code class="err">É</code><code class="n">CHAMEL</code> <code class="calibre17">=</code> <code class="s">"Béchamel"</code>
    <code class="n">VELOUT</code><code class="err">É</code> <code class="calibre17">=</code> <code class="s">"Velouté"</code>
    <code class="n">ESPAGNOLE</code> <code class="calibre17">=</code> <code class="s">"Espagnole"</code>
    <code class="n">TOMATO</code> <code class="calibre17">=</code> <code class="s">"Tomato"</code>
    <code class="n">HOLLANDAISE</code> <code class="calibre17">=</code> <code class="s">"Hollandaise"</code></pre>

<p class="author1">Creating aliases is more likely than preserving uniqueness in most of the use cases I’ve come across, so I default to making enumerations nonunique at first, and only adding the unique decorator when needed.<a data-type="indexterm" data-primary="enumerations" data-secondary="advanced usage" data-startref="ix_enumadv" id="idm45644743113448" class="calibre5"/></p>
</div></section>





</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. User-Defined Types: Enums" class="preface">
<div class="preface" id="enum">
<section data-type="sect1" data-pdf-bookmark="Closing Thoughts" class="preface"><div class="preface" id="idm45644743053944">
<h1 class="calibre12" id="calibre_pb_11">Closing Thoughts</h1>

<p class="author1">Enumerations are simple, and often overlooked as a powerful communication method. Any time that you want to represent a single value from a static collection of values, an enumeration should be your go-to user-defined type. It’s easy to define and use them. They offer a wealth of operations, including iteration, bitwise operations (in the case of <code class="calibre17">Flag</code> enumerations), and control over uniqueness.</p>

<p class="author1">Remember these key limitations:</p>

<ul class="printings">
<li class="calibre9">
<p class="author1">Enumerations are not meant for dynamic key-value mappings that change at runtime. Use a dictionary for this.<a data-type="indexterm" data-primary="enumerations" data-secondary="limitations of" id="idm45644743050024" class="calibre5"/></p>
</li>
<li class="calibre9">
<p class="author1"><code class="calibre17">Flag</code> enumerations only work with values that support bitwise operations with nonoverlapping values.</p>
</li>
<li class="calibre9">
<p class="author1">Avoid <code class="calibre17">IntEnum</code> and <code class="calibre17">IntFlag</code> unless absolutely necessary for system <span class="calibre">interoperability</span>.</p>
</li>
</ul>

<p class="author1">Next up, I will explore another user-defined type: a <code class="calibre17">dataclass</code>. While enumerations are great at specifying a relationship about a set of values in just one variable, data classes define relationships between multiple variables.<a data-type="indexterm" data-primary="user-defined types" data-secondary="enumerations" data-startref="ix_usrDTen" id="idm45644743044008" class="calibre5"/></p>
</div></section>







<div data-type="footnotes" class="calibre25"><p data-type="footnote" id="idm45644744508088" class="calibre26"><sup class="calibre27"><a href="part0012_split_001.html#idm45644744508088-marker" class="calibre5">1</a></sup> Eric Evans. <em class="calibre6">Domain-Driven Design: Tackling Complexity in the Heart of Software</em>. Upper Saddle River, NJ: Addison-Wesley Professional, 2003.</p></div></div></section></body></html>