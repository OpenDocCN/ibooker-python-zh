- en: Chapter 11\. Authentication and Authorization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 11 章\. 认证与授权
- en: Respect mah authoritay!
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尊重我的权威！
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Eric Cartman, *South Park*
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 艾瑞克·卡特曼，*南方公园*
- en: Preview
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预览
- en: Sometimes a website is wide open, and any visitor can visit any page. But if
    any of the site’s content may be modified, some endpoints will be restricted to
    certain people or groups. If anyone could alter pages on Amazon, imagine the odd
    items that would show up, and the amazing sales some people would suddenly get.
    Unfortunately, it’s human nature—for some humans—to take advantage of the rest,
    who pay a hidden tax for their activities.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有时一个网站是完全开放的，任何访客都可以访问任何页面。但如果网站的内容可能被修改，某些端点将被限制只允许特定的人或组访问。如果任何人都能修改亚马逊的页面，想象一下会出现什么奇怪的物品，以及某些人突然获得的惊人销量。不幸的是，这是人类的本性——对于一些人来说，他们会利用其他人支付他们活动的隐藏税。
- en: 'Should we leave our cryptid site open for any users to access any endpoint?
    No! Almost any sizable web service eventually needs to deal with the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该让我们的神秘动物网站对任何用户开放访问吗？不！几乎任何规模的网络服务最终都需要处理以下问题：
- en: Authentication (authn)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 认证（authn）
- en: Who are you?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你是谁？
- en: Authorization (authz)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 授权（authz）
- en: What do you want?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要什么？
- en: Should the authentication and authorization (auth) code have its own new layer,
    say between Web and Service? Or should everything be handled by the Web or Service
    layer itself? This chapter dips into auth techniques and where to put them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 认证和授权（auth）代码是否应该有自己的新层，例如在 Web 和服务之间添加一个新层？还是应该所有东西都由 Web 或服务层自己处理？本章将涉及认证技术及其放置位置的讨论。
- en: Often descriptions of web security seem more confusing than they need to be.
    Attackers can be really, really sneaky, and countermeasures may not be simple.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 往往关于 Web 安全的描述似乎比必要的复杂得多。攻击者可以非常狡猾，而反制措施可能并不简单。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As I’ve mentioned more than once, the official FastAPI documentation is excellent.
    Try the [Security section](https://oreil.ly/oYsKl) if this chapter doesn’t provide
    as many details as you’d like.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我多次提到的，官方的 FastAPI 文档非常出色。如果本章提供的细节不足以满足您的需求，请查看[安全部分](https://oreil.ly/oYsKl)。
- en: So, let’s take this walk-through in steps. I’ll start with simple techniques
    that are intended to only hook auth into a web endpoint for testing, but would
    not stand up in a public website.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们一步步地进行这次讲解。我将从简单的技术开始，这些技术仅用于将认证挂接到 Web 端点以进行测试，但不能在公共网站上使用。
- en: 'Interlude 1: Do You Need Authentication?'
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插曲 1：您是否需要认证？
- en: 'Again, *authentication* is concerned with *identity*: who are you? To implement
    authentication, we need a mapping of secret information to a unique identity.
    There are many ways to do this, with *many* variations of complexity. Let’s start
    small and work up.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，*认证* 关注的是 *身份*：你是谁？要实施认证，我们需要将秘密信息映射到唯一的身份。有许多方法可以做到这一点，复杂度也有很多变化。让我们从简单开始逐步深入。
- en: 'Often books and articles on web development jump right away into the details
    of authentication and authorization, sometimes muddling them. They sometimes skip
    the first question: do you really need either?'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 往往关于 Web 开发的书籍和文章会立即深入到认证和授权的细节中，有时会把它们弄混。它们有时会跳过第一个问题：您真的需要吗？
- en: You could allow completely anonymous access to all your website’s pages. But
    that would leave you open to exploits like denial-of-service attacks. Although
    some protections like rate limits can be implemented outside the web server (see
    [Chapter 13](ch13.html#ch13)), almost all public API providers require at least
    some authentication.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以允许完全匿名访问所有网站页面。但这将使您容易受到拒绝服务攻击等攻击的威胁。尽管某些保护措施（如速率限制）可以在 Web 服务器外部实施（参见[第
    13 章](ch13.html#ch13)），几乎所有公共 API 提供者都至少需要一些身份验证。
- en: 'Beyond security, we want to know how effective websites are:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了安全之外，我们还想知道网站的效果如何：
- en: How many unique visitors?
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有多少独立访问者？
- en: What are the most popular pages?
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些页面最受欢迎？
- en: Do some changes increase views?
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些更改是否会增加页面浏览量？
- en: What page sequences are common?
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些页面序列是常见的？
- en: The answers to these questions require authentication of specific visitors.
    Otherwise, you can get only total counts.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的答案需要对特定访问者进行认证。否则，您只能得到总计数。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If your site needs authentication or authorization, access to it should be encrypted
    (using HTTPS instead of HTTP), to prevent attackers from extracting secret data
    from plain text. See [Chapter 13](ch13.html#ch13) for details on setting up HTTPS.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的网站需要身份验证或授权，访问它应该是加密的（使用 HTTPS 而不是 HTTP），以防止攻击者从明文中提取机密数据。有关设置 HTTPS 的详细信息，请参见[第
    13 章](ch13.html#ch13)。
- en: Authentication Methods
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证方法
- en: 'There are many web authentication methods and tools:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多网络身份验证方法和工具：
- en: Username/email and password
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 用户名/电子邮件和密码
- en: Using classic HTTP Basic and Digest Authentication
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用经典的 HTTP 基本和摘要身份验证
- en: API key
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: API 密钥
- en: An opaque long string with an accompanying *secret*
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不透明的长字符串，带有一个附带的 *秘密*
- en: OAuth2
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth2
- en: A set of standards for authentication and authorization
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一组用于身份验证和授权的标准
- en: JavaScript Web Tokens (JWT)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript Web Tokens（JWT）
- en: An encoding format containing cryptographically signed user information
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一种包含经过加密签名的用户信息的编码格式
- en: In this section, I’ll review the first two methods and show you how to traditionally
    implement them. But I’ll stop before filling out the API and database code. Instead,
    we’ll fully implement a more modern scheme with OAuth2 and JWT.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将回顾前两种方法，并向你展示如何传统地实现它们。但是在填写 API 和数据库代码之前，我会停下来。相反，我们将完全实现一个更现代的方案，使用
    OAuth2 和 JWT。
- en: 'Global Authentication: Shared Secret'
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局身份验证：共享秘密
- en: The very simplest authentication method is to pass a secret that’s normally
    known only by the web server. If it matches, you’re in. This isn’t safe if your
    API site is exposed to the public with HTTP instead of HTTPS. If it’s hidden behind
    a frontend site that is itself open, the frontends and backends could communicate
    using a shared constant secret. But if your frontend site is hacked, then darn.
    Let’s see how FastAPI handles simple authentication.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的身份验证方法是传递一个通常只有 web 服务器知道的秘密。如果匹配，你就能进入。如果你的 API 网站暴露在公共网络中，使用 HTTP 而不是
    HTTPS 是不安全的。如果它被隐藏在一个前端网站背后，而该前端网站本身是公开的，前端和后端可以使用一个共享的常量秘密进行通信。但是如果你的前端网站被黑客攻击了，那就麻烦了。让我们看看
    FastAPI 如何处理简单的身份验证。
- en: Make a new top-level file called *auth.py*. Check that you don’t have another
    FastAPI server still running from one of those ever-changing *main.py* files from
    previous chapters. [Example 11-1](#ex-11-1) implements a server that just returns
    whatever `username` and `password` were sent to it using HTTP Basic Authentication—a
    method from the original days of the web.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 *auth.py* 的新顶级文件。检查一下，你之前的章节中是否仍然有另一个仍在运行的 FastAPI 服务器，该服务器来自于那些不断变化的
    *main.py* 文件。[示例 11-1](#ex-11-1) 实现了一个服务器，只是使用 HTTP 基本身份验证返回发送给它的任何 `username`
    和 `password`——这是网络原始时代的一种方法。
- en: 'Example 11-1\. Use HTTP Basic Auth to get user info: auth.py'
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-1\. 使用 HTTP 基本身份验证获取用户信息：auth.py
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In [Example 11-2](#ex-11-2), tell HTTPie to make this Basic Auth request (this
    requires the arguments `-a` *`name:password`*). Here, let’s use the name `me`
    and the password `secret`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 11-2](#ex-11-2)中，告诉 HTTPie 发送这个基本身份验证请求（这需要参数 `-a` *`name:password`*）。在这里，让我们使用名称
    `me` 和密码 `secret`。
- en: Example 11-2\. Test with HTTPie
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-2\. 使用 HTTPie 进行测试
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Testing with the Requests package in [Example 11-3](#ex-11-3) is similar, using
    the `auth` parameter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [示例 11-3](#ex-11-3) 中的 Requests 包进行测试类似，使用 `auth` 参数。
- en: Example 11-3\. Test with Requests
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-3\. 使用 Requests 进行测试
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can also test [Example 11-1](#ex-11-1) with the automatic docs page (*http://localhost:8000/docs*),
    shown in [Figure 11-1](#fig-docs-1).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用自动文档页面（*http://localhost:8000/docs*）测试 [示例 11-1](#ex-11-1)，如 [图 11-1](#fig-docs-1)
    所示。
- en: '![fapi 1101](assets/fapi_1101.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![fapi 1101](assets/fapi_1101.png)'
- en: Figure 11-1\. Docs page for simple authentication
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-1\. 简单身份验证的文档页面
- en: Click that down arrow on the right, then the Try It Out button, and then the
    Execute button. You’ll see a form requesting the username and password. Type anything.
    The documentation form will hit that server endpoint and show those values in
    the response.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 点击右边的下箭头，然后点击尝试按钮，然后点击执行按钮。你会看到一个请求用户名和密码的表单。输入任何内容。文档表单将命中该服务器端点，并在响应中显示这些值。
- en: These tests show that you can get a username and password to the server and
    back (although none of these actually checked anything). Something in the server
    needs to verify that this name and password match the approved values. So, in
    [Example 11-4](#ex-11-4), I’ll include a single secret username and password in
    the web server. The username and password that you pass in now needs to match
    them (each is a *shared secret*), or you’ll get an exception. The HTTP status
    code `401` is officially called `Unauthorized`, but it really means *unauthenticated*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试表明你可以将用户名和密码发送到服务器并返回（虽然这些测试实际上没有检查任何内容）。服务器中的某些东西需要验证这个名称和密码是否与批准的值匹配。因此，在[示例
    11-4](#ex-11-4)中，我将在 Web 服务器中包含一个单一的秘密用户名和密码。你现在传递的用户名和密码需要与它们匹配（每个都是一个 *共享的秘密*），否则你会得到一个异常。HTTP
    状态码 `401` 官方称为 `Unauthorized`，但实际上它的意思是*未经验证*。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Instead of memorizing all the HTTP status codes, you can import FastAPI’s status
    module (which itself is imported directly from Starlette). So you can use the
    more explanatory `sta⁠tus_code=​HTTP_401_UNAUTHORIZED` in [Example 11-4](#ex-11-4)
    instead of a plain `sta⁠tus_​code=401`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是记忆所有的HTTP状态码，你可以导入FastAPI的status模块（该模块直接从Starlette导入）。因此，你可以在[示例 11-4](#ex-11-4)中使用更加解释性的`sta⁠tus_code=​HTTP_401_UNAUTHORIZED`，而不是简单的`sta⁠tus_​code=401`。
- en: Example 11-4\. Add a secret username and password to auth.py
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-4\. 在auth.py中添加一个秘密的用户名和密码
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Misguessing the username and password will earn a mild `401` rebuke in [Example 11-5](#ex-11-5).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 11-5](#ex-11-5)中，如果用户名和密码猜测错误，会收到轻微的`401`警告。
- en: Example 11-5\. Test with HTTPie and a mismatched username/password
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-5\. 使用HTTPie测试不匹配的用户名/密码
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using the magic combination returns the username and password, as before, in
    [Example 11-6](#ex-11-6).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种魔法组合返回用户名和密码，如以前在[示例 11-6](#ex-11-6)中所示。
- en: Example 11-6\. Test with HTTPie and the correct username/password
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-6\. 使用HTTPie测试正确的用户名/密码
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Simple Individual Authentication
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的个人认证
- en: The previous section showed how you could use a shared secret to control access.
    It’s a broad approach, not very secure. And it doesn’t tell you anything about
    the individual visitor, just that they (or a sentient AI) know the secret.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节展示了如何使用共享秘密来控制访问。这是一种广义的方法，安全性不高。它并没有告诉你有关个体访问者的任何信息，只是它们（或有感知的人工智能）知道这个秘密。
- en: 'Many websites want to do the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网站希望执行以下操作：
- en: Define individual visitors in some way
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某种方式定义个别访问者
- en: Identify specific visitors as they access certain endpoints (authentication)
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识特定访问者在访问某些端点时（认证）
- en: Possibly assign different permissions to some visitors and endpoints (authorization)
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能为某些访问者和端点分配不同的权限（授权）
- en: Possibly save specific information per visitor (interests, purchases, and so
    on)
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能保存每个访问者的特定信息（兴趣，购买等）
- en: If your visitors are humans, you may want them to provide a username or email
    and a password. If they’re external programs, you may want them to provide an
    API key and secret.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的访问者是人类，你可能希望他们提供用户名或电子邮件以及密码。如果它们是外部程序，你可能希望它们提供API密钥和密钥。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: From here on, I’ll use just *username* to refer to either a user-selected name
    or an email.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我将仅使用*用户名*来指代用户选择的名称或电子邮件。
- en: 'To authenticate real individual users instead of a fake one, you’ll need to
    do a bit more:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要认证真实的个人用户而不是虚拟用户，你需要做更多工作：
- en: Pass the user values (name and password) to the API server endpoints as HTTP
    headers.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用户值（名称和密码）作为HTTP标头传递给API服务器端点。
- en: Use HTTPS instead of HTTP, to avoid anyone snooping the text of these headers.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTPS而不是HTTP，以避免任何人窥视这些标头的文本。
- en: '*Hash* the password to a different string. The result is not “de-hashable”—you
    can’t derive the original password from its hash.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*哈希*密码为不同的字符串。其结果是不可“解哈希化”的——你不能从其哈希值推导出原始密码。'
- en: Make a real database store a `User` database table containing the username and
    the hashed password (never the original plain-text password).
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个真实的数据库存储一个`User`数据库表，包含用户名和哈希密码（绝不是原始明文密码）。
- en: Hash the newly input password and compare the result with the hashed password
    in the database.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对新输入的密码进行哈希处理，并将结果与数据库中的哈希密码进行比较。
- en: If the username and hashed password match, pass the matching `User` object up
    the stack. If they don’t match, return `None` or raise an exception.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户名和哈希密码匹配，将匹配的`User`对象传递到堆栈上。如果它们不匹配，则返回`None`或引发异常。
- en: In the Service layer, fire off any metrics/logging/whatever that are relevant
    to individual user authentication.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务层中，触发与个人用户认证相关的任何指标/日志等。
- en: In the Web layer, send the authenticated user info to any functions that require
    it.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Web层中，将认证用户信息发送给需要的任何函数。
- en: I’ll show you how to do all these things in the following sections, using recent
    tools like OAuth2 and JWT.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在接下来的章节中向你展示如何使用OAuth2和JWT等最新工具来完成所有这些事情。
- en: Fancier Individual Authentication
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更复杂的个人认证
- en: If you want to authenticate individuals, you have to store some individual information
    somewhere—for example, in a database containing records with at least a key (username
    or API key), and a secret (password or API secret). Your website visitors will
    provide these when accessing protected URLs, and you need something in the database
    to match them with.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要认证个体，你必须在某处存储一些个体信息，例如在一个包含至少一个键（用户名或 API 密钥）和一个密钥（密码或 API 密钥）的数据库中。当访问受保护的
    URL 时，你的网站访问者将提供这些信息，而你需要在数据库中找到匹配项。
- en: The official FastAPI security docs ([introductory](https://oreil.ly/kkTUB) and
    [advanced](https://oreil.ly/biKwy)) have top-down descriptions of how to set up
    authentication for multiple users, using a local database. But, example web functions
    fake the actual database access.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的 FastAPI 安全文档（[入门](https://oreil.ly/kkTUB) 和 [高级](https://oreil.ly/biKwy)）详细描述了如何为多个用户设置认证，使用本地数据库。但是，示例网络功能模拟了实际数据库访问。
- en: 'Here, you’ll do the opposite: starting at the Data layer and working up. You’ll
    define how a user/visitor is defined, stored, and accessed. Then you’ll work up
    to the Web layer, and how user identification is passed in, evaluated, and authenticated.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将会做相反的操作：从数据层开始，逐步向上。你将定义用户/访客的定义、存储和访问方式。然后逐步向上到 Web 层，讨论用户身份验证的传递、评估和认证。
- en: OAuth2
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAuth2
- en: OAuth 2.0, which stands for “Open Authorization,” is a standard designed to
    allow a website or application to access resources hosted by other web apps on
    behalf of a user.
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: OAuth 2.0，即“开放授权”，是一个标准，旨在允许网站或应用程序代表用户访问其他网站应用程序托管的资源。
- en: ''
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Auth0
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Auth0
- en: In the early trusting web days, you could provide your login name and password
    of a website (let’s call it B) to another website (A, of course) and let it access
    stuff on B for you. This would give A *full access* to B, although it was trusted
    to access only what it was supposed to. Examples of B and resources were things
    like Twitter followers, Facebook friends, email contacts, and so on. Of course,
    this couldn’t last long, so various companies and groups got together to define
    OAuth. It was originally designed only to allow website A to access specific (not
    all) resources on website B.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期信任的 Web 时代，你可以将你在一个网站（我们称之为 B）的登录名和密码提供给另一个网站（当然是 A），让其代表你访问 B 上的资源。这会让 A
    获得对 B 的*完全访问权限*，尽管它只被信任访问它应该访问的内容。B 和资源的例子包括 Twitter 的粉丝、Facebook 的好友、电子邮件联系人等。当然，这种做法不可能长久存在，所以各种公司和组织联合起来定义了
    OAuth。它最初的设计目的只是允许网站 A 访问网站 B 上特定（而非全部）的资源。
- en: '[OAuth2](https://oauth.net/2) is a popular but complex *authorization* standard,
    with uses beyond the A/B example. There are many explanations of it, from [light](https://oreil.ly/ehmuf)
    to [heavy](https://oreil.ly/qAUaM).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[OAuth2](https://oauth.net/2) 是一个流行但复杂的*授权*标准，适用于 A/B 例子之外的多种情况。有许多对它的解释，从[轻量级](https://oreil.ly/ehmuf)到[深入](https://oreil.ly/qAUaM)。'
- en: Note
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There used to be an [OAuth1](https://oauth.net/1), but it isn’t used anymore.
    Some of the original OAuth2 recommendations are now deprecated (computerese for
    *don’t use them*). On the horizon are [OAuth2.1](https://oauth.net/2.1) and, even
    further into the mist, [txauth](https://oreil.ly/5PW2T).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经有一个 [OAuth1](https://oauth.net/1)，但它不再使用。一些最初的 OAuth2 建议现在已被弃用（计算机术语，意思是*不要使用它们*）。在未来，还会有
    [OAuth2.1](https://oauth.net/2.1) 和更远的 [txauth](https://oreil.ly/5PW2T)。
- en: OAuth offers various [flows](https://oreil.ly/kRiWh) for different circumstances.
    I’ll use the *authorization code flow* here. This section will walk through an
    implementation, one average-sized step at a time.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 提供了各种[流程](https://oreil.ly/kRiWh)以应对不同的情况。本节将使用*授权码流*来进行实现，逐步迈出平均大小的步骤。
- en: 'First, you’ll need to install these third-party Python packages:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要安装这些第三方 Python 包：
- en: JWT handling
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: JWT 处理
- en: '`pip install python-jose[cryptography]`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip install python-jose[cryptography]`'
- en: Secure password handling
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 安全的密码处理
- en: '`pip install passlib`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip install passlib`'
- en: Form handling
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 表单处理
- en: '`pip install python-multipart`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip install python-multipart`'
- en: The following sections start with the user data model and database management,
    and work up the familiar layers to the Service and Web, where OAuth pops up.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分从用户数据模型和数据库管理开始，逐步向上到服务和 Web 层，其中包括 OAuth。
- en: User Model
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户模型
- en: Let’s start with the very minimal user model definitions in [Example 11-7](#ex-11-7).
    These will be used in all layers.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 [示例 11-7](#ex-11-7) 中的极简用户模型定义开始。这些将在所有层中使用。
- en: 'Example 11-7\. User definition: model/user.py'
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-7\. 用户定义：model/user.py
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A `User` object contains an arbitrary `name` plus a `hash` string (the hashed
    password, not the original plain-text password), and is what’s saved in the database.
    We’ll need both to authenticate a visitor.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`User` 对象包含一个任意的 `name` 和一个 `hash` 字符串（经过哈希处理的密码，而不是原始的明文密码），这是保存在数据库中的内容。我们需要这两者来验证访客。'
- en: User Data Layer
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户数据层
- en: '[Example 11-8](#ex-11-8) contains the user database code.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 11-8](#ex-11-8) 包含了用户数据库代码。'
- en: Note
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code creates `user` (active users) and `xuser` (deleted users) tables.
    Often developers add a Boolean `deleted` field to a user table to indicate the
    user is no longer active, without actually deleting the record from the table.
    I prefer moving the deleted user’s data to another table. This avoids repetitive
    checking of the `deleted` field in all user queries. It can also help speed up
    queries: making an index for a *low cardinality* field like a Boolean does no
    good.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 代码创建了 `user`（活跃用户）和 `xuser`（已删除用户）表。通常开发者会向用户表添加一个布尔类型的 `deleted` 字段，以指示用户不再活跃，而实际上并没有从表中删除记录。我更倾向于将删除的用户数据移动到另一个表中。这样可以避免在所有用户查询中重复检查
    `deleted` 字段。它还有助于加快查询速度：对于像布尔类型这样的低基数字段，创建索引并不会带来实质的好处。
- en: 'Example 11-8\. Data layer: data/user.py'
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-8\. 数据层：data/user.py
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: User Fake Data Layer
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户伪数据层
- en: The module in [Example 11-9](#ex-11-9) is used in tests that exclude the database
    but need some user data.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在排除数据库但需要一些用户数据的测试中使用了 [示例 11-9](#ex-11-9) 模块。
- en: 'Example 11-9\. Fake layer: fake/user.py'
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-9\. 伪数据层：fake/user.py
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: User Service Layer
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户服务层
- en: '[Example 11-10](#ex-11-10) defines the Service layer for users. A difference
    from the other Service layer modules is the addition of OAuth2 and JWT functions.
    I think it’s cleaner to have them here than in the Web layer, though a few OAuth2
    Web-layer functions are in the upcoming *web/user.py*.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 11-10](#ex-11-10) 定义了用户的服务层。与其他服务层模块的不同之处在于增加了 OAuth2 和 JWT 函数。我认为将它们放在这里比放在
    Web 层中更清晰，尽管一些 OAuth2 Web 层函数位于即将到来的 *web/user.py* 中。'
- en: The CRUD functions are still pass-throughs for now but could be flavored to
    taste with metrics in the future. Notice that, like the creature and explorer
    services, this design supports runtime use of either the fake or real Data layers
    to access user data.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD 函数目前仍然是传递功能，但将来可以根据需求进行调整。请注意，与生物和探险者服务类似，这种设计支持在运行时使用伪数据层或真实数据层访问用户数据。
- en: 'Example 11-10\. Service layer: service/user.py'
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-10\. 服务层：service/user.py
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: User Web Layer
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户 Web 层
- en: '[Example 11-11](#ex-11-11) defines the base user module in the Web layer. It
    uses the new auth code from the *service/user.py* module in [Example 11-10](#ex-11-10).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 11-11](#ex-11-11) 在 Web 层中定义了基础用户模块。它使用了来自 *service/user.py* 模块中 [示例 11-10](#ex-11-10)
    的新授权代码。'
- en: 'Example 11-11\. Web layer: web/user.py'
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-11\. Web 层：web/user.py
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Test!
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试！
- en: The unit and full tests for this new user component are similar to those that
    you’ve already seen for creatures and explorers. Rather than using the ink and
    paper here, you can view them at this book’s accompanying website.^([1](ch11.html#id707))
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个新用户组件的单元测试和完整测试与你已经看过的生物和探险者的测试类似。与其在这里使用墨水和纸张，不如在本书附带的网站上查看它们。^([1](ch11.html#id707))
- en: Top Layer
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 顶层
- en: The previous section defined a new `router` variable for URLs starting with
    */user*, so [Example 11-12](#ex-11-12) adds this subrouter.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节为以 */user* 开头的 URL 定义了一个新的 `router` 变量，所以 [示例 11-12](#ex-11-12) 添加了这个子路由器。
- en: 'Example 11-12\. Top layer: main.py'
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-12\. 顶层：main.py
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When Uvicorn autoreloads, the */user/…​* endpoints should now be available.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Uvicorn 自动重载时，*/user/…* 终端现在应该是可用的。
- en: That was fun, in a stretched definition of fun. Given all the user code that
    was just created, let’s give it something to do.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 那真是有趣，按一种拉伸的定义来说是有趣的。考虑到刚刚创建的所有用户代码，让我们给它一些事情做。
- en: Authentication Steps
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证步骤
- en: 'Here’s a review of that heap of code from the previous sections:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是前面章节中大量代码的回顾：
- en: If an endpoint has the dependency `oauth2_dep()` (in *web/user.py*), a form
    containing username and password fields is generated and sent to the client.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个端点依赖于 `oauth2_dep()`（在 *web/user.py* 中），则会生成一个包含用户名和密码字段的表单，并发送给客户端。
- en: After the client fills out and submits this form, the username and password
    (hashed with the same algorithm as those already stored in the local database)
    are matched against the local database.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端填写并提交此表单后，用户名和密码（与本地数据库中已存储的相同算法的哈希值）将与本地数据库匹配。
- en: If a match occurs, an access token is generated (in JWT format) and returned.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果匹配成功，将生成一个访问令牌（JWT 格式）并返回。
- en: This access token is passed back to the web server as an `Authorization` HTTP
    header in subsequent requests. This JWT token is decoded on the local server to
    the username and other details. This name does not need to be looked up in the
    database again.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此访问令牌作为`Authorization` HTTP头传回Web服务器。此JWT令牌在本地服务器上被解码为用户名和其他详细信息。这个名称不需要再次在数据库中查找。
- en: The username is authenticated, and the server can do whatever it likes with
    it.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名已经过认证，服务器可以对其进行任意操作。
- en: 'What can the server do with this hard-won authentication information? The server
    can do the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以如何处理这些辛苦获得的认证信息？服务器可以执行以下操作：
- en: Generate metrics (this user, this endpoint, this time) to help study what’s
    being viewed, by whom, for how long, and so on.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成指标（此用户、此端点、此时段），以帮助研究谁查看了什么内容，持续多长时间等等。
- en: Save user-specific information.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存用户特定信息。
- en: JWT
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JWT
- en: This section contains some details on the JWT. You really don’t need them to
    use all the earlier code in this chapter, but if you’re a little curious…​
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分包含JWT的一些详细信息。在本章中，您实际上不需要这些信息来使用所有之前的代码，但如果您有点好奇……
- en: A [JWT](https://jwt.io) is an encoding scheme, not an authentication method.
    The low-level details are defined in [RFC 7519](https://oreil.ly/_op1j). It can
    be used to convey authentication information for OAuth2 (and other methods), and
    I’ll show that here.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[JWT](https://jwt.io)是一种编码方案，而不是一种认证方法。其低级细节在[RFC 7519](https://oreil.ly/_op1j)中有定义。它可用于传达OAuth2（以及其他方法）的认证信息，在这里我将展示出来。'
- en: 'A JWT is a readable string with three dot-separated sections:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: JWT是一个可读的字符串，由三部分点分隔而成：
- en: '*Header*: Encryption algorithm used, and token type'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Header*：使用的加密算法和令牌类型'
- en: '*Payload*: …​'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Payload*：……'
- en: '*Signature*: …​'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Signature*：……'
- en: 'Each section consists of a JSON string, encoded in [Base 64 URL](https://www.base64url.com)
    format. Here’s an example (which has been split at the dots to fit on this page):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分由一个JSON字符串组成，以[Base 64 URL](https://www.base64url.com)格式编码。这里有一个示例（已在点处拆分以适应本页）：
- en: '[PRE12]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As a plain ASCII string that’s also safe to use in URLs, it can be passed to
    web servers as part of the URL, a query parameter, HTTP header, cookie, and so
    on.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 作为纯ASCII字符串，它也可以安全地用作URL的一部分、查询参数、HTTP头、Cookie等，传递给Web服务器。
- en: JWT avoids a database lookup, but this also means that you can’t detect a revoked
    authorization directly.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: JWT避免了数据库查找，但这也意味着您无法直接检测到已撤销的授权。
- en: 'Third-Party Authentication: OIDC'
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三方认证：OIDC
- en: You’ll often see websites that let you log in with an ID and password, or let
    you log in via your account at a different site, like Google, Facebook/Meta, LinkedIn,
    or many others. These frequently use a standard called [OpenID Connect (OIDC)](https://openid.net/connect),
    which is built atop OAuth2. When you connect to an external OIDC-enabled site,
    you’ll get back an OAuth2 access token (as in the examples in this chapter), but
    also an *ID token*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您经常会看到一些网站，让您使用ID和密码登录，或者让您通过不同网站的账户登录，比如Google、Facebook/Meta、LinkedIn或许多其他网站。这些通常使用一个称为[OpenID
    Connect (OIDC)](https://openid.net/connect)的标准，它是建立在OAuth2之上的。当您连接到外部支持OIDC的站点时，您将收到一个OAuth2访问令牌（如本章的示例中所示），还会收到一个*ID令牌*。
- en: 'The official FastAPI docs don’t include example code for integration with OIDC.
    If you want to try it, some third-party packages (FastAPI-specific and more generic)
    will save time over rolling your own implementation:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的FastAPI文档不包含与OIDC集成的示例代码。如果您想尝试，一些第三方包（特定于FastAPI和更通用的）将比自行实现节省时间：
- en: '[FastAPI OIDC](https://oreil.ly/TDABr)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[FastAPI OIDC](https://oreil.ly/TDABr)'
- en: '[fastapi-third-party-auth](https://oreil.ly/yGaO6)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[fastapi-third-party-auth](https://oreil.ly/yGaO6)'
- en: '[FastAPI Resource Server](https://oreil.ly/THByF)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[FastAPI资源服务器](https://oreil.ly/THByF)'
- en: '[oauthlib](https://oreil.ly/J-pDB)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[oauthlib](https://oreil.ly/J-pDB)'
- en: '[oic](https://oreil.ly/AgYKZ)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[oic](https://oreil.ly/AgYKZ)'
- en: '[OIDC Client](https://oreil.ly/e9QGb)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[OIDC客户端](https://oreil.ly/e9QGb)'
- en: '[oidc-op](https://oreil.ly/cJCF4)'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[oidc-op](https://oreil.ly/cJCF4)'
- en: '[OpenID Connect](https://oreil.ly/WH49I)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[OpenID Connect](https://oreil.ly/WH49I)'
- en: The [FastAPI Repo Issues page](https://oreil.ly/ztR3r) includes multiple code
    examples, and a comment from tiangelo (Sebastián Ramírez) that FastAPI OIDC examples
    will be included in the official docs and tutorials in the future.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[FastAPI Repo Issues页面](https://oreil.ly/ztR3r)包含多个代码示例，以及来自tiangelo（Sebastián
    Ramírez）的评论，未来FastAPI OIDC示例将包含在官方文档和教程中。'
- en: Authorization
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权
- en: 'Authentication handles the *who* (identity), and authorization handles the
    *what*: which resources (web endpoints) are you allowed to access, and in what
    way? The number of combinations of *who* and *what* can be large.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 认证处理*who*（身份），授权处理*what*：您允许访问哪些资源（Web端点）以及以何种方式？*who*和*what*的组合数量可能很大。
- en: In this book, explorers and creatures have been the main resources. Looking
    up an explorer, or listing all of them, would typically be more “open” than adding
    or modifying an existing one. If the website is supposed to be a reliable interface
    to some data, write access should be more limited than read access. Because, grr,
    people.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，探险者和生物一直是主要资源。查找探险者或列出它们通常比添加或修改现有资源更“开放”。如果网站应该是一种可靠的接口到某些数据，写访问应该比读访问受到更严格的限制。因为，唉，人们。
- en: If every endpoint is completely open, you don’t need authorization and can skip
    this section. The simplest authorization could be a simple Boolean (is this user
    an admin or not?); for the examples in this book, you might require admin authorization
    to add, delete, or modify an explorer or creature. If your database has lots of
    entries, you might also want to limit the `get_all()` functions with further permissions
    for non-admins. As the website gets more complex, the permissions might become
    more fine-grained.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个端点完全开放，您不需要授权，可以跳过此部分。最简单的授权可能是一个简单的布尔值（这个用户是否是管理员？）；对于本书中的示例，您可能需要管理员授权来添加、删除或修改探险者或生物。如果您的数据库条目很多，您可能还希望为非管理员限制`get_all()`函数的进一步权限。随着网站变得更加复杂，权限可能变得更加细粒度化。
- en: 'Let’s look at a progression of authorization cases. We’ll use the `User` table,
    in which the `name` can be an email, username, or API key; “pair” tables are the
    relational database way of matching entries from two separate tables:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下授权案例的进展。我们将使用`User`表，其中`name`可以是电子邮件、用户名或API密钥；“配对”表是关系数据库匹配两个单独表条目的方式。
- en: 'If you want to track only admin visitors and leave the rest anonymous:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您只想跟踪管理员访问者并让其他人匿名：
- en: Use an `Admin` table of authenticated usernames. You’d look up the name from
    the `Admin` table, and if matched, compare the hashed passwords from the `User`
    table.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Admin`表进行经过身份验证的用户名。您可以从`Admin`表中查找名称，并且如果匹配，则与`User`表中的哈希密码进行比较。
- en: 'If *all* visitors should be authenticated, but you need to authorize admins
    for only some endpoints:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*所有*访问者都应该经过身份验证，但您只需为某些端点授权管理员：
- en: Authenticate everyone as in the earlier examples (from the `User` table), and
    then check the `Admin` table to see if this user is also an admin.
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与之前示例中的每个人进行身份验证（来自`User`表），然后检查`Admin`表以查看此用户是否也是管理员。
- en: 'For more than one type of permission (such as read-only, read, write):'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于多种类型的权限（如只读、读取、写入）：
- en: Use a `Permission` definition table.
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Permission`定义表。
- en: Use a `UserPermission` table that pairs users and permissions. This is sometimes
    called an *access control list*.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`UserPermission`表对用户和权限进行配对。这有时被称为访问控制列表（ACL）。
- en: 'If permission combinations are complex, add a level and define *roles* (independent
    sets of permissions):'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果权限组合复杂，添加一个级别并定义*角色*（独立的权限集合）：
- en: Create a `Role` table.
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`Role`表。
- en: Create a `UserRole` table pairing `User` and `Role` entries. This is sometimes
    called *role-based access control* (RBAC).
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`UserRole`表，配对`User`和`Role`条目。这有时被称为基于角色的访问控制（RBAC）。
- en: Middleware
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间件。
- en: 'FastAPI enables insertion of code at the Web layer that does the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI允许在Web层插入代码执行以下操作：
- en: Intercepts the request
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拦截请求。
- en: Does something with the request
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理请求的某些操作。
- en: Passes the request to a path function
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将请求传递给路径函数。
- en: Intercepts the response returned by the patch function
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拦截由补丁函数返回的响应。
- en: Does something with the response
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对响应执行某些操作。
- en: Returns the response to the caller
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回响应给调用者。
- en: It’s similar to what a Python decorator does to the function that it “wraps.”
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 它类似于Python装饰器对其“包装”的函数所做的事情。
- en: In some cases, you could use either middleware or dependency injection with
    `Depends()`. Middleware is handier for more global security issues like CORS,
    which brings up…​
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可以使用中间件或依赖注入与`Depends()`。中间件更方便处理像CORS这样的全局安全问题，这也提出了...​​
- en: CORS
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨源资源共享（CORS）。
- en: '*Cross-origin resource sharing* (CORS) involves communication between other
    trusted servers and your website. If your site has all the frontend and backend
    code in one place, then there’s no problem. But these days, it’s common to have
    a JavaScript frontend talking to a backend written in something like FastAPI.
    These servers will not have the same *origin*:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*跨源资源共享*（CORS）涉及与其他受信任的服务器和您的网站之间的通信。如果您的站点将所有前端和后端代码放在一个地方，那就没问题了。但是现在，将 JavaScript
    前端与 FastAPI 等后端进行通信已经很普遍了。这些服务器将不具有相同的*源*：'
- en: Protocol
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 协议
- en: '`http` or `https`'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`http` 或 `https`'
- en: Domain
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 域名
- en: Internet domain, like `google.com` or `localhost`
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网域名，比如 `google.com` 或 `localhost`
- en: Port
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 端口
- en: Numeric TCP/IP port on that domain, like `80`, `443`, or `8000`
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在该域上的数字 TCP/IP 端口，比如 `80`、`443` 或 `8000`
- en: 'How does the backend know a trustable frontend from a box of moldy radishes,
    or a mustache-twirling attacker? That’s a job for CORS, which specifies what the
    backend trusts, the most prominent being the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 后端如何知道可信任的前端和一个充满霉菌的萝卜箱或一个胡子拨弄的攻击者之间的区别？这是 CORS 的工作，它指定了后端信任的内容，最重要的是以下内容：
- en: Origins
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来源
- en: HTTP methods
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 方法
- en: HTTP headers
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 头部
- en: CORS cache timeout
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CORS 缓存超时
- en: You hook into CORS at the Web level. [Example 11-13](#ex-11-13) shows how to
    allow only one frontend server (with the domain *https://ui.cryptids.com*), and
    any HTTP headers or methods.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 Web 层级上连接到 CORS。[示例 11-13](#ex-11-13) 展示了如何允许只有一个前端服务器（具有域名 *https://ui.cryptids.com*）以及任何
    HTTP 头部或方法。
- en: Example 11-13\. Activate the CORS middleware
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 11-13\. 激活 CORS 中间件。
- en: '[PRE13]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once that’s done, any other domain that tries to contact your backend site directly
    will be refused.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，任何试图直接联系您的后端站点的其他域都将被拒绝。
- en: Third-Party Packages
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三方包
- en: You’ve now read examples of how to code authentication and authorization solutions
    with FastAPI. But maybe you don’t need to do everything yourself. The FastAPI
    ecosystem is growing fast, and packages may be available that do a lot of the
    work for you.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经阅读了如何使用 FastAPI 编写身份验证和授权解决方案的示例。但也许你不需要自己做所有的事情。FastAPI 生态系统发展迅速，可能已经有可用的包来为你做大部分工作了。
- en: 'Here are some untested examples. There are no guarantees that any package in
    this list will still be around and supported over time, but they may be worth
    a look:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些未经测试的示例。不能保证此列表中的任何包在未来仍然存在并得到支持，但可能值得一看：
- en: '[FastAPI Users](https://oreil.ly/ueVfq)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[FastAPI Users](https://oreil.ly/ueVfq) 是 FastAPI 的用户管理模块。'
- en: '[FastAPI JWT Auth](https://oreil.ly/ooGSK)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[FastAPI JWT Auth](https://oreil.ly/ooGSK) 是一个与 FastAPI 集成的 JWT 认证模块。'
- en: '[FastAPI-Login](https://oreil.ly/oWA3p)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[FastAPI-Login](https://oreil.ly/oWA3p) 是一个用于 FastAPI 的登录认证模块。'
- en: '[fastapi-auth0](https://oreil.ly/fHfkU)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[fastapi-auth0](https://oreil.ly/fHfkU)'
- en: '[AuthX](https://authx.yezz.me)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[AuthX](https://authx.yezz.me)'
- en: '[FastAPI-User-Auth](https://oreil.ly/J57xu)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[FastAPI-User-Auth](https://oreil.ly/J57xu) 是 FastAPI 的用户认证模块。'
- en: '[fastapi-authz](https://oreil.ly/aAGzW)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[fastapi-authz](https://oreil.ly/aAGzW)'
- en: '[fastapi-opa](https://oreil.ly/Bvzv3)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[fastapi-opa](https://oreil.ly/Bvzv3)'
- en: '[FastAPI-key-auth](https://oreil.ly/s-Ui5)'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[FastAPI-key-auth](https://oreil.ly/s-Ui5)'
- en: '[FastAPI Auth Middleware](https://oreil.ly/jnR-s)'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[FastAPI Auth Middleware](https://oreil.ly/jnR-s) 是 FastAPI 的认证中间件。'
- en: '[fastapi-jwt](https://oreil.ly/RrxUZ)'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[fastapi-jwt](https://oreil.ly/RrxUZ) 是 FastAPI 的 JWT 认证模块。'
- en: '[fastapi_auth2](https://oreil.ly/5DXkB)'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[fastapi_auth2](https://oreil.ly/5DXkB)'
- en: '[fastapi-sso](https://oreil.ly/GLTdt)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[fastapi-sso](https://oreil.ly/GLTdt) 是一个 FastAPI 单点登录（SSO）模块。'
- en: '[Fief](https://www.fief.dev)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Fief](https://www.fief.dev)'
- en: Review
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾
- en: This was a heavier chapter than most. It showed ways that you can authenticate
    visitors and authorize them to do certain things. These are two aspects of web
    security. The chapter also discussed CORS, another important web security topic.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个比大多数更重的章节。它展示了你可以对访问者进行身份验证并授权他们执行某些操作的方式。这是 Web 安全的两个方面。该章还讨论了 CORS，另一个重要的
    Web 安全主题。
- en: ^([1](ch11.html#id707-marker)) If I were paid by the line, fate might have intervened.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch11.html#id707-marker)) 如果我按行收费，命运可能会干涉。
