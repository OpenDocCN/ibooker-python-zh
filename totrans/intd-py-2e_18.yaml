- en: 'Chapter 16\. Data in a Box: Persistent Storage'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章。盒子中的数据：持久存储
- en: It is a capital mistake to theorize before one has data.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在获得数据之前进行理论化是一个重大的错误。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Arthur Conan Doyle
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 亚瑟·柯南·道尔
- en: 'An active program accesses data stored in Random Access Memory, or RAM. RAM
    is very fast, but it is expensive and requires a constant supply of power; if
    the power goes out, all the data in memory is lost. Disk drives are slower than
    RAM but have more capacity, cost less, and retain data even after someone trips
    over the power cord. Thus, a huge amount of effort in computer systems has been
    devoted to making the best trade-offs between storing data on disk and RAM. As
    programmers, we need *persistence*: storing and retrieving data using nonvolatile
    media such as disks.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 活跃的程序访问存储在随机存取存储器（RAM）中的数据。RAM非常快速，但价格昂贵，并且需要持续的电源供应；如果电源中断，内存中的所有数据都将丢失。磁盘驱动器比RAM慢，但容量更大，成本更低，并且即使有人绊倒电源线后，也可以保留数据。因此，计算机系统中的大量工作已经致力于在磁盘和RAM之间进行最佳权衡。作为程序员，我们需要*持久性*：使用非易失性介质（如磁盘）存储和检索数据。
- en: 'This chapter is all about the different flavors of data storage, each optimized
    for different purposes: flat files, structured files, and databases. File operations
    other than input and output are covered in [Chapter 14](ch14.html#ch_files).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了为不同目的优化的数据存储的不同类型：平面文件、结构化文件和数据库。除了输入和输出之外的文件操作在[第14章](ch14.html#ch_files)中有所涵盖。
- en: A *record* is a term for one chunk of related data, consisting of individual
    *fields*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*记录*是指一块相关数据的术语，由各个*字段*组成。'
- en: Flat Text Files
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平面文本文件
- en: The simplest persistence is a plain old flat file. This works well if your data
    has a very simple structure and you exchange all of it between disk and memory.
    Plain text data might be suitable for this treatment.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的持久性是普通的平面文件。如果您的数据结构非常简单并且在磁盘和内存之间交换所有数据，则此方法非常有效。纯文本数据可能适合这种处理方式。
- en: Padded Text Files
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充文本文件
- en: In this format, each field in a record has a fixed width, and is padded (usually
    with space characters) to that width in the file, giving each line (record) the
    same width. A programmer can use `seek()` to jump around the file and only read
    and write the records and fields that are needed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种格式中，记录中的每个字段都有固定的宽度，并且在文件中（通常用空格字符）填充到该宽度，使得每行（记录）具有相同的宽度。程序员可以使用`seek()`来在文件中跳转，并且仅读取和写入需要的记录和字段。
- en: Tabular Text Files
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表格式文本文件
- en: With simple text files, the only level of organization is the line. Sometimes,
    you want more structure than that. You might want to save data for your program
    to use later, or send data to another program.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的文本文件，唯一的组织级别是行。有时，您可能需要比这更多的结构。您可能希望将数据保存供程序稍后使用，或者将数据发送到另一个程序。
- en: 'There are many formats, and here’s how you can distinguish them:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多格式，这里是如何区分它们的方式：
- en: A *separator*, or *delimiter*, character like tab (`'\t'`), comma (`','`), or
    vertical bar (`'|'`). This is an example of the comma-separated values (CSV) format.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分隔符*或*分隔符*字符，如制表符（`''\t''`）、逗号（`'',''`）或竖线（`''|''`）。这是逗号分隔值（CSV）格式的一个例子。'
- en: '`''<''` and `''>''` around *tags*. Examples include XML and HTML.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''<''` 和 `''>''`围绕*标签*。例如XML和HTML。'
- en: Punctuation. An example is JavaScript Object Notation (JSON).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标点符号。一个例子是JavaScript对象表示法（JSON）。
- en: Indentation. An example is YAML (which is recursively defined as “YAML Ain’t
    Markup Language”).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩进。一个例子是YAML（递归定义为“YAML不是标记语言”）。
- en: Miscellaneous, such as configuration files for programs.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 杂项，例如程序的配置文件。
- en: Each of these structured file formats can be read and written by at least one
    Python module.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结构化文件格式中的每一个都可以由至少一个Python模块读取和写入。
- en: CSV
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSV
- en: 'Delimited files are often used as an exchange format for spreadsheets and databases.
    You could read CSV files manually, a line at a time, splitting each line into
    fields at comma separators, and adding the results to data structures such as
    lists and dictionaries. But it’s better to use the standard `csv` module, because
    parsing these files can get more complicated than you think. Following are a few
    important characteristics to keep in mind when working with CSV:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 分隔文件通常用作电子表格和数据库的交换格式。您可以手动读取CSV文件，一次读取一行，在逗号分隔符处拆分每行成字段，并将结果添加到诸如列表和字典之类的数据结构中。但最好使用标准的`csv`模块，因为解析这些文件可能比您想象的要复杂得多。在处理CSV时需要记住以下几个重要特征：
- en: 'Some have alternate delimiters besides a comma: `''|''` and `''\t''` (tab)
    are common.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些分隔符除了逗号以外还有：`'|'` 和 `'\t'`（制表符）是常见的。
- en: Some have *escape sequences*. If the delimiter character can occur within a
    field, the entire field might be surrounded by quote characters or preceded by
    some escape character.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有些有*转义序列*。如果定界符字符可以出现在字段内，则整个字段可能用引号字符括起来或者在某些转义字符之前。
- en: Files have different line-ending characters. Unix uses `'\n'`, Microsoft uses
    `'\r\n'`, and Apple used to use `'\r'` but now uses `'\n'`.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件具有不同的行尾字符。Unix 使用`'\n'`，Microsoft 使用`'\r\n'`，而Apple 曾使用`'\r'`，但现在使用`'\n'`。
- en: The first line may contain column names.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行可能包含列名。
- en: 'First, we see how to read and write a list of rows, each containing a list
    of columns:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们看看如何读取和写入包含列列表的行列表：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This creates the file *villains* with these lines:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建包含这些行的文件*villains*：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we try to read it back in:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们试着再次读取它：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We took advantage of the structure created by the `reader()` function. It created
    rows in the `cin` object that we could extract in a `for` loop.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用了`reader()`函数创建的结构。它在`cin`对象中创建了可以在`for`循环中提取的行。
- en: Using `reader()` and `writer()` with their default options, the columns are
    separated by commas and the rows by line feeds.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`reader()`和`writer()`及其默认选项，列由逗号分隔，行由换行符分隔。
- en: 'The data can be a list of dictionaries rather than a list of lists. Let’s read
    the *villains* file again, this time using the new `DictReader()` function and
    specifying the column names:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以是字典列表而不是列表列表。让我们再次使用新的`DictReader()`函数和指定的列名读取*villains*文件：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That `OrderedDict` is there for compatibility with versions of Python before
    3.6, when dictionaries kept their order by default.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 那个 `OrderedDict` 用于兼容 Python 3.6 之前的版本，当时字典默认保持其顺序。
- en: 'Let’s rewrite the CSV file by using the new `DictWriter()` function. We also
    call `writeheader()` to write an initial line of column names to the CSV file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用新的 `DictWriter()` 函数重新编写 CSV 文件。我们还调用 `writeheader()` 来向 CSV 文件写入初始列名行：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That creates a *villains.csv* file with a header line ([Example 16-1](#villains_csv)).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个带有头行的*villains.csv*文件（[示例 16-1](#villains_csv)）。
- en: Example 16-1\. villains.csv
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-1\. villains.csv
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let’s read it back. By omitting the `fieldnames` argument in the `DictReader()`
    call, we tell it to use the values in the first line of the file (`first,last`)
    as column labels and matching dictionary keys:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们读取它。在`DictReader()`调用中省略`fieldnames`参数，告诉它使用文件的第一行的值(`first,last`)作为列标签和匹配的字典键：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: XML
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML
- en: 'Delimited files convey only two dimensions: rows (lines) and columns (fields
    within a line). If you want to exchange data structures among programs, you need
    a way to encode hierarchies, sequences, sets, and other structures as text.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 分隔文件仅传达两个维度：行（行）和列（行内字段）。如果要在程序之间交换数据结构，需要一种方法将层次结构、序列、集合和其他结构编码为文本。
- en: 'XML is a prominent *markup* format that does this. It uses *tags* to delimit
    data, as in this sample *menu.xml* file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: XML 是一种突出显示的*标记*格式，它使用*标签*来界定数据，就像这个样本*menu.xml*文件中所示。
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Following are a few important characteristics of XML:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 XML 的一些重要特征：
- en: Tags begin with a `<` character. The tags in this sample were `menu`, `breakfast`,
    `lunch`, `dinner`, and `item`.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签以 `<` 字符开始。这个示例中的标签是 `menu`、`breakfast`、`lunch`、`dinner` 和 `item`。
- en: Whitespace is ignored.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空白符将被忽略。
- en: Usually a *start tag* such as `<menu>` is followed by other content and then
    a final matching *end tag* such as `</menu>`.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常像`<menu>`这样的*开始标签*后面跟着其他内容，然后是最终匹配的*结束标签*，例如`</menu>`。
- en: Tags can *nest* within other tags to any level. In this example, `item` tags
    are children of the `breakfast`, `lunch`, and `dinner` tags; they, in turn, are
    children of `menu`.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签可以在其他标签内*嵌套*到任何级别。在此示例中，`item`标签是`breakfast`、`lunch`和`dinner`标签的子标签；它们反过来是`menu`的子标签。
- en: Optional *attributes* can occur within the start tag. In this example, `price`
    is an attribute of `item`.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的*属性*可以出现在开始标签内。在这个例子中，`price` 是 `item` 的一个属性。
- en: Tags can contain *values*. In this example, each `item` has a value, such as
    `pancakes` for the second breakfast item.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签可以包含*值*。在这个例子中，每个 `item` 都有一个值，比如第二个早餐项目的 `pancakes`。
- en: If a tag named `thing` has no values or children, it can be expressed as the
    single tag by including a forward slash just before the closing angle bracket,
    such as `<thing/>`, rather than a start and end tag, like `<thing></thing>`.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果名为`thing`的标签没有值或子项，则可以通过在闭合尖括号之前包含一个斜杠来表示为单个标签，例如`<thing/>`，而不是开始和结束标签，像`<thing></thing>`。
- en: The choice of where to put data—attributes, values, child tags—is somewhat arbitrary.
    For instance, we could have written the last `item` tag as `<item price="$8.00"
    food="spaghetti"/>`.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据放在哪里的选择——属性、值、子标签——有些是任意的。例如，我们可以将最后一个 `item` 标签写成 `<item price="$8.00" food="spaghetti"/>`。
- en: XML is often used for data *feeds* and *messages* and has subformats like RSS
    and Atom. Some industries have many specialized XML formats, such as the [finance
    field](http://bit.ly/xml-finance).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: XML 通常用于数据 *feeds* 和 *messages*，并具有诸如 RSS 和 Atom 之类的子格式。一些行业有许多专门的 XML 格式，比如
    [金融领域](http://bit.ly/xml-finance)。
- en: XML’s über-flexibility has inspired multiple Python libraries that differ in
    approach and capabilities.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: XML 的超级灵活性启发了多个 Python 库，这些库在方法和功能上有所不同。
- en: 'The simplest way to parse XML in Python is by using the standard `ElementTree`
    module. Here’s a little program to parse the *menu.xml* file and print some tags
    and attributes:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中解析 XML 的最简单方法是使用标准的 `ElementTree` 模块。下面是一个简单的程序，用于解析 *menu.xml* 文件并打印一些标签和属性：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For each element in the nested lists, `tag` is the tag string and `attrib` is
    a dictionary of its attributes. `ElementTree` has many other ways of searching
    XML-derived data, modifying it, and even writing XML files. The `ElementTree`
    [documentation](http://bit.ly/elementtree) has the details.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于嵌套列表中的每个元素，`tag` 是标签字符串，`attrib` 是其属性的字典。`ElementTree` 有很多其他搜索 XML 派生数据，修改它的方法，甚至编写
    XML 文件的方法。`ElementTree` [文档](http://bit.ly/elementtree) 上有详细信息。
- en: 'Other standard Python XML libraries include the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 其他标准的 Python XML 库包括以下内容：
- en: '`xml.dom`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`xml.dom`'
- en: The Document Object Model (DOM), familiar to JavaScript developers, represents
    web documents as hierarchical structures. This module loads the entire XML file
    into memory and lets you access all the pieces equally.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 文件对象模型（DOM），对于 JavaScript 开发者来说很熟悉，它将 web 文档表示为分层结构。这个模块将整个 XML 文件加载到内存中，并允许您平等地访问所有部分。
- en: '`xml.sax`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`xml.sax`'
- en: Simple API for XML, or SAX, parses XML on the fly, so it does not have to load
    everything into memory at once. Therefore, it can be a good choice if you need
    to process very large streams of XML.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的 XML API，或 SAX，可以实时解析 XML，因此它不必一次加载所有内容到内存中。因此，如果您需要处理非常大的 XML 流，它可能是一个不错的选择。
- en: An XML Security Note
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: XML 安全注意事项
- en: You can use all the formats described in this chapter to save objects to files
    and read them back again. It’s possible to exploit this process and cause security
    problems.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用本章中描述的所有格式将对象保存到文件中，然后再读取它们。可以利用这个过程来造成安全问题。
- en: 'For example, the following XML snippet from the billion laughs Wikipedia page
    defines 10 nested entities, each expanding the lower level 10 times for a total
    expansion of one billion:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面来自十亿笑话维基百科页面的 XML 片段定义了 10 个嵌套实体，每个实体扩展了低一级 10 次，总扩展量达到了十亿：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The bad news: billion laughs would blow up all of the XML libraries mentioned
    in the previous sections. [Defused XML](https://bitbucket.org/tiran/defusedxml)
    lists this attack and others, along with the vulnerability of Python libraries.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 坏消息：十亿笑话将会使前面提到的所有 XML 库爆炸。[Defused XML](https://bitbucket.org/tiran/defusedxml)
    列出了这个攻击和其他攻击，以及 Python 库的漏洞。
- en: 'The link shows how to change the settings for many of the libraries to avoid
    these problems. Also, you can use the `defusedxml` library as a security frontend
    for the other libraries:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 该链接展示了如何更改许多库的设置以避免这些问题。此外，您可以使用 `defusedxml` 库作为其他库的安全前端：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The standard Python site also has its own page on [XML vulnerabilities](https://oreil.ly/Rnsiw).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的 Python 网站上也有关于 [XML 漏洞](https://oreil.ly/Rnsiw) 的页面。
- en: HTML
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML
- en: Gigagobs of data are saved as Hypertext Markup Language (HTML), the basic document
    format of the web. The problem is that much of it doesn’t follow the HTML rules,
    which can make it difficult to parse. HTML is a better display format than a data
    interchange format. Because this chapter is intended to describe fairly well-defined
    data formats, I’ve separated out the discussion about HTML to [Chapter 18](ch18.html#ch_web).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 庞大的数据以超文本标记语言（HTML）的形式保存，这是 web 的基本文档格式。问题是其中的大部分都不符合 HTML 规则，这可能会使解析变得困难。HTML
    比数据交换格式更好地显示格式。因为本章旨在描述相当明确定义的数据格式，我已将有关 HTML 的讨论分离到 [第 18 章](ch18.html#ch_web)
    中。
- en: JSON
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON
- en: '[JavaScript Object Notation (JSON)](http://www.json.org) has become a very
    popular data interchange format, beyond its JavaScript origins. The JSON format
    is a subset of JavaScript, and often legal Python syntax, as well. Its close fit
    to Python makes it a good choice for data interchange among programs. You’ll see
    many examples of JSON for web development in [Chapter 18](ch18.html#ch_web).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[JavaScript Object Notation (JSON)](http://www.json.org) 已成为非常流行的数据交换格式，超越了其
    JavaScript 的起源。JSON 格式是 JavaScript 的子集，通常也是合法的 Python 语法。它与 Python 的密切配合使其成为程序之间数据交换的良好选择。您将在
    [第 18 章](ch18.html#ch_web) 中看到许多用于 Web 开发的 JSON 示例。'
- en: 'Unlike the variety of XML modules, there’s one main JSON module, with the unforgettable
    name `json`. This program encodes (dumps) data to a JSON string and decodes (loads)
    a JSON string back to data. In this next example, let’s build a Python data structure
    containing the data from the earlier XML example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与各种 XML 模块不同，主要的 JSON 模块只有一个，其名称令人难忘，即 `json`。此程序将数据编码（转储）为 JSON 字符串，并将 JSON
    字符串解码（加载）回数据。在下面的示例中，让我们构建一个包含先前 XML 示例中的数据的 Python 数据结构：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, encode the data structure (`menu`) to a JSON string (`menu_json`) by
    using `dumps()`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 `dumps()` 将数据结构 (`menu`) 编码为 JSON 字符串 (`menu_json`)：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And now, let’s turn the JSON string `menu_json` back into a Python data structure
    (`menu2`) by using `loads()`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过使用 `loads()` 将 JSON 字符串 `menu_json` 转换回 Python 数据结构 (`menu2`)：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`menu` and `menu2` are both dictionaries with the same keys and values.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`menu` 和 `menu2` 都是具有相同键和值的字典。'
- en: 'You might get an exception while trying to encode or decode some objects, including
    objects such as `datetime` (covered in detail in [Chapter 13](ch13.html#ch_times)),
    as demonstrated here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试编码或解码某些对象时，可能会遇到异常，包括诸如 `datetime` 的对象（在 [第 13 章](ch13.html#ch_times) 中有详细说明），如下所示：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This can happen because the JSON standard does not define date or time types;
    it expects you to define how to handle them. You could convert the `datetime`
    to something JSON understands, such as a string or an *epoch* value (see [Chapter 13](ch13.html#ch_times)):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是因为 JSON 标准未定义日期或时间类型；它期望您定义如何处理它们。您可以将 `datetime` 转换为 JSON 理解的内容，如字符串或 *epoch*
    值（见 [第 13 章](ch13.html#ch_times)）：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If the `datetime` value could occur in the middle of normally converted data
    types, it might be annoying to make these special conversions. You can modify
    how JSON is encoded by using inheritance, which is described in [Chapter 10](ch10.html#ch_objects).
    Python’s JSON [documentation](http://bit.ly/json-docs) gives an example of this
    for complex numbers, which also makes JSON play dead. Let’s modify it for `datetime`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `datetime` 值可能出现在通常转换的数据类型中间，这些特殊转换可能会令人困扰。您可以通过使用继承修改 JSON 的编码方式来进行修改，详见
    [第 10 章](ch10.html#ch_objects)。Python 的 JSON [文档](http://bit.ly/json-docs) 提供了关于复数的示例，这也使
    JSON 看起来像是死的。我们修改它以适应 `datetime`：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The new class `DTEncoder` is a subclass, or child class, of `JSONEncoder`. We
    need to override its only `default()` method to add `datetime` handling. Inheritance
    ensures that everything else will be handled by the parent class.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 新的类 `DTEncoder` 是 `JSONEncoder` 的子类或子类，我们需要重写其唯一的 `default()` 方法以添加 `datetime`
    处理。继承确保所有其他内容都将由父类处理。
- en: 'The `isinstance()` function checks whether the object `obj` is of the class
    `datetime.datetime`. Because everything in Python is an object, `isinstance()`
    works everywhere:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`isinstance()` 函数检查对象 `obj` 是否为 `datetime.datetime` 类的实例。因为 Python 中的所有东西都是对象，所以
    `isinstance()` 在任何地方都适用：'
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For JSON and other structured text formats, you can load from a file into data
    structures without knowing anything about the structures ahead of time. Then,
    you can walk through the structures by using `isinstance()` and type-appropriate
    methods to examine their values. For example, if one of the items is a dictionary,
    you can extract contents through `keys()`, `values()`, and `items()`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 JSON 和其他结构化文本格式，您可以从文件加载到数据结构中，而无需事先了解结构的任何信息。然后，您可以使用 `isinstance()` 和适当类型的方法遍历这些结构以检查其值。例如，如果其中一个项目是字典，您可以通过
    `keys()`、`values()` 和 `items()` 提取内容。
- en: 'After making you do it the hard way, it turns out that there’s an even easier
    way to convert `datetime` objects to JSON:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在让您以困难的方式处理后，事实证明有一种更简单的方法可以将 `datetime` 对象转换为 JSON：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That `default=str` tells `json.dumps()` to apply the `str()` conversion function
    for data types that it doesn’t understand. This works because the definition of
    the `datetime.datetime` class includes a `__str__()` method.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`default=str` 告诉 `json.dumps()` 对于它不理解的数据类型应用 `str()` 转换函数。这是因为 `datetime.datetime`
    类的定义包含一个 `__str__()` 方法。'
- en: YAML
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: YAML
- en: Similar to JSON, [YAML](http://www.yaml.org) has keys and values, but handles
    more data types such as dates and times. The standard Python library does not
    yet include YAML handling, so you need to install a third-party library named
    [`yaml`](http://pyyaml.org/wiki/PyYAML) to manipulate it. `((("dump() function")))((("load()
    function")))load()` converts a YAML string to Python data, whereas `dump()` does
    the opposite.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于JSON，[YAML](http://www.yaml.org)具有键和值，但处理更多数据类型，如日期和时间。标准的Python库尚未包含YAML处理，因此您需要安装名为[`yaml`](http://pyyaml.org/wiki/PyYAML)的第三方库来操作它。`((("dump()
    function")))((("load() function")))load()`将YAML字符串转换为Python数据，而`dump()`则相反。
- en: 'The following YAML file, *mcintyre.yaml*, contains information on the Canadian
    poet James McIntyre, including two of his poems:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的YAML文件，*mcintyre.yaml*，包含了加拿大诗人詹姆斯·麦金太尔（James McIntyre）的信息，包括他的两首诗：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Values such as `true`, `false`, `on`, and `off` are converted to Python booleans.
    Integers and strings are converted to their Python equivalents. Other syntax creates
    lists and dictionaries:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 值如`true`、`false`、`on`和`off`会转换为Python布尔值。整数和字符串会转换为它们的Python等效项。其他语法创建列表和字典：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The data structures that are created match those in the YAML file, which in
    this case are more than one level deep in places. You can get the title of the
    second poem with this dict/list/dict reference:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的数据结构与YAML文件中的相匹配，这在某些情况下是多层次的。您可以使用这个字典/列表/字典引用获取第二首诗的标题：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Warning
  id: totrans-108
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: PyYAML can load Python objects from strings, and this is dangerous. Use `safe_load()`
    instead of `load()` if you’re importing YAML that you don’t trust. Better yet,
    *always* use `safe_load()`. Read Ned Batchelder’s blog post [“War is Peace”](http://bit.ly/war-is-peace)
    for a description of how unprotected YAML loading compromised the Ruby on Rails
    platform.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: PyYAML可以从字符串加载Python对象，这是危险的。如果您导入不信任的YAML，请使用`safe_load()`而不是`load()`。更好的做法是，*总是*使用`safe_load()`。阅读Ned
    Batchelder的博客文章[“War is Peace”](http://bit.ly/war-is-peace)了解未受保护的YAML加载如何危及Ruby
    on Rails平台。
- en: Tablib
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tablib
- en: After reading all of the previous sections, there’s one third-party package
    that lets you import, export, and edit tabular data in CSV, JSON, *or* YAML format,^([1](ch16.html#idm45794977436440))
    as well as Microsoft Excel, Pandas DataFrame, and a few others. You install it
    with the familiar refrain (`pip install tablib`), and peek at the [docs](http://docs.python-tablib.org).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读所有先前的章节之后，有一个第三方包可以让您导入、导出和编辑CSV、JSON或YAML格式的表格数据，^([1](ch16.html#idm45794977436440))还有Microsoft
    Excel、Pandas DataFrame和其他几个。您可以用熟悉的叠歌（`pip install tablib`）安装它，并查看[文档](http://docs.python-tablib.org)。
- en: Pandas
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pandas
- en: 'This is as good place as any to introduce [pandas](https://pandas.pydata.org)—a
    Python library for structured data. It’s an excellent tool for handling real-life
    data issues:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是介绍[pandas](https://pandas.pydata.org)的好地方——一个用于结构化数据的Python库。它是处理现实生活数据问题的优秀工具：
- en: 'Read and write many text and binary file formats:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读写许多文本和二进制文件格式：
- en: Text, with fields separated by commas (CSV), tabs (TSV), or other characters
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本，字段由逗号（CSV）、制表符（TSV）或其他字符分隔
- en: Fixed-width text
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定宽度文本
- en: Excel
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Excel
- en: JSON
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON
- en: HTML tables
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTML表格
- en: SQL
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL
- en: HDF5
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: HDF5
- en: and [others](https://oreil.ly/EWlgS).
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 和[其他](https://oreil.ly/EWlgS)。
- en: Group, split, merge, index, slice, sort, select, label
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分组、拆分、合并、索引、切片、排序、选择、标记
- en: Convert data types
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换数据类型
- en: Change size or shape
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改大小或形状
- en: Handle missing data
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理丢失的数据
- en: Generate random values
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成随机值
- en: Manage time series
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理时间序列
- en: The read functions return a [`DataFrame`](https://oreil.ly/zupYI) object, Pandas’
    standard representation for two-dimensional data (rows and columns). It’s similar
    in some ways to a spreadsheet or a relational database table. Its one-dimensional
    little brother is a [`Series`](https://oreil.ly/pISZT).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 读取函数返回一个[`DataFrame`](https://oreil.ly/zupYI)对象，Pandas的标准表示形式，用于二维数据（行和列）。在某些方面类似于电子表格或关系数据库表。它的一维小兄弟是[`Series`](https://oreil.ly/pISZT)。
- en: '[Example 16-2](#pandas_csv_example) demonstrates a simple application that
    reads our *villains.csv* file from [Example 16-1](#villains_csv).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 16-2](#pandas_csv_example)演示了一个简单的应用程序，从[示例 16-1](#villains_csv)中读取我们的*villains.csv*文件。'
- en: Example 16-2\. Read CSV with Pandas
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-2\. 使用Pandas读取CSV
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The variable `data` just shown is a `DataFrame`. which has many more tricks
    than a basic Python dictionary. It’s especially useful for heavy numeric work
    with NumPy, and data preparation for machine learning.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`data`刚刚展示的是一个`DataFrame`。它比基本的Python字典有更多的技巧。它特别适用于使用NumPy进行大量数字工作和为机器学习准备数据。
- en: Refer to the [“Getting Started”](https://oreil.ly/VKSrZ) section of the documentation
    for Pandas’ features, and [“10 Minutes to Pandas”](https://oreil.ly/CLoVg) for
    working examples.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 参考Pandas文档的[“入门指南”](https://oreil.ly/VKSrZ)部分以及[“10分钟入门Pandas”](https://oreil.ly/CLoVg)中的工作示例。
- en: 'Let’s use Pandas for a little calendar example—make a list of the first day
    of the first three months in 2019:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举个小日历例子使用Pandas——列出2019年前三个月的第一天的列表：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You could write something that does this, using the time and date functions
    described in [Chapter 13](ch13.html#ch_times), but it would be a lot more work—especially
    debugging (dates and times are frustrating). Pandas also handles many special
    date/time [details](https://oreil.ly/vpeTP), like business months and years.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写一些代码来实现这一点，使用[第13章](ch13.html#ch_times)中描述的时间和日期函数，但这需要更多的工作——特别是调试（日期和时间常常令人沮丧）。Pandas还处理许多特殊的日期/时间[细节](https://oreil.ly/vpeTP)，如业务月和年。
- en: Pandas will appear again later when I talk about mapping ([“Geopandas”](ch21.html#geopandas))
    and scientific applications ([“Pandas”](ch22.html#sci_pandas)).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 后面当我谈论映射时，Pandas会再次出现（[“Geopandas”](ch21.html#geopandas)）以及科学应用（[“Pandas”](ch22.html#sci_pandas)）。
- en: Configuration Files
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置文件
- en: Most programs offer various *options* or *settings*. Dynamic ones can be provided
    as program arguments, but long-lasting ones need to be kept somewhere. The temptation
    to define your own quick-and-dirty *config file* format is strong—but resist it.
    It often turns out to be dirty, but not so quick. You need to maintain both the
    writer program and the reader program (sometimes called a *parser*). There are
    good alternatives that you can just drop into your program, including those in
    the previous sections.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序提供各种*options*或*settings*。动态的可以作为程序参数提供，但长期的需要保存在某个地方。定义自己快速而脏的*config file*格式的诱惑力很强——但要抵制它。它经常变得脏乱，但并不快速。您需要维护编写程序和读取程序（有时称为*parser*）。有很多好的替代方案可以直接插入您的程序，包括前面的部分中提到的那些。
- en: 'Here, we’ll use the standard `configparser` module, which handles Windows-style
    *.ini* files. Such files have sections of *key* = *value* definitions. Here’s
    a minimal *settings.cfg* file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将使用标准`configparser`模块，它处理Windows风格的*.ini*文件。这些文件有*key* = *value*定义的部分。这是一个最小的*settings.cfg*文件：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here’s the code to read it into Python data structures:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将其读入Python数据结构的代码：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Other options are available, including fancier interpolation. See the `configparser`
    [documentation](http://bit.ly/configparser). If you need deeper nesting than two
    levels, try YAML or JSON.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他选择，包括更高级的插值。参见`configparser`的[文档](http://bit.ly/configparser)。如果需要比两级更深的嵌套，请尝试YAML或JSON。
- en: Binary Files
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二进制文件
- en: Some file formats were designed to store particular data structures but are
    neither relational nor NoSQL databases. The sections that follow present some
    of them.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有些文件格式设计用于存储特定的数据结构，但既不是关系型数据库也不是NoSQL数据库。接下来的部分介绍了其中的一些。
- en: Padded Binary Files and Memory Mapping
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充的二进制文件和内存映射
- en: These are similar to padded text files, but the contents may be binary, and
    the padding byte may be `\x00` instead of a space character. Each record has a
    fixed size, as does each field within a record. This makes it simpler to `seek()`
    throughout the file for the desired records and fields. Every operation on the
    data is manual, so this approach tends to be used only in very low-level (e.g.,
    close to the hardware) situations.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类似于填充的文本文件，但内容可能是二进制的，填充字节可能是`\x00`而不是空格字符。每个记录和记录内的每个字段都有固定的大小。这使得在文件中通过`seek()`查找所需的记录和字段变得更简单。数据的每一项操作都是手动的，因此这种方法通常仅在非常低级别（例如接近硬件）的情况下使用。
- en: Data in this form can be *memory mapped* with the standard `mmap` library. See
    some [examples](https://pymotw.com/3/mmap), and the standard [documentation](https://oreil.ly/eI0mv).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式的数据可以使用标准的`mmap`库进行*memory mapped*。参见一些[示例](https://pymotw.com/3/mmap)和标准的[文档](https://oreil.ly/eI0mv)。
- en: Spreadsheets
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电子表格
- en: Spreadsheets, notably Microsoft Excel, are widespread binary data formats. If
    you can save your spreadsheet to a CSV file, you can read it by using the standard
    `csv` module that was described earlier. This will work for a binary `xls` file,
    [`xlrd`](https://oreil.ly/---YE), or `tablib` (mentioned earlier at [“Tablib”](#tablib)).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 电子表格，特别是Microsoft Excel，是广泛使用的二进制数据格式。如果可以将电子表格保存为CSV文件，可以使用早期描述的标准`csv`模块进行读取。这对于二进制的`xls`文件、[`xlrd`](https://oreil.ly/---YE)或`tablib`（在[“Tablib”](#tablib)早些时候提到）都适用。
- en: HDF5
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HDF5
- en: '[HDF5](https://oreil.ly/QTT6x) is a binary data format for multidimensional
    or hierarchical numeric data. It’s used mainly in science, where fast random access
    to large datasets (gigabytes to terabytes) is a common requirement. Even though
    HDF5 could be a good alternative to databases in some cases, for some reason HDF5
    is almost unknown in the business world. It’s best suited to *WORM* (write once/read
    many) applications for which database protection against conflicting writes is
    not needed. Here are some modules that you might find useful:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[HDF5](https://oreil.ly/QTT6x) 是用于多维或层次化数值数据的二进制数据格式。它主要用于科学领域，其中快速访问大数据集（从几千兆字节到几太字节）是常见需求。尽管在某些情况下，HDF5可能是数据库的良好替代品，但由于某些原因，HDF5在商业界几乎不为人知。它最适合于*WORM*（写入一次/多次读取）应用程序，这种应用程序不需要数据库对抗冲突写入。以下是一些可能对你有用的模块：'
- en: '`h5py` is a full-featured low-level interface. Read the [documentation](http://www.h5py.org)
    and [code](https://github.com/h5py/h5py).'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`h5py` 是一个功能齐全的低级接口。阅读[文档](http://www.h5py.org)和[代码](https://github.com/h5py/h5py)。'
- en: '`PyTables` is a bit higher-level, with database-like features. Read the [documentation](http://www.pytables.org)
    and [code](http://pytables.github.com).'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PyTables` 是一个稍微高级的库，具有类似数据库的功能。阅读[文档](http://www.pytables.org)和[代码](http://pytables.github.com)。'
- en: Both of these are discussed in terms of scientific applications of Python in
    [Chapter 22](ch22.html#ch_science). I’m mentioning HDF5 here in case you have
    a need to store and retrieve large amounts of data and are willing to consider
    something outside the box as well as the usual database solutions. A good example
    is the [Million Song dataset](http://millionsongdataset.com), which has downloadable
    song data in HDF5 and SQLite formats.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者都是讨论Python在[第22章](ch22.html#ch_science)科学应用程序方面的应用。我在这里提到HDF5是因为你可能需要存储和检索大量数据，并愿意考虑除了传统数据库解决方案以外的其他选择。一个很好的例子是[百万首歌数据集](http://millionsongdataset.com)，其中包含以HDF5和SQLite格式提供的可下载歌曲数据。
- en: TileDB
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TileDB
- en: A recent successor to HDF5 for dense or spare array storage is [TileDB](https://tiledb.io).
    Install the [Python interface](https://github.com/TileDB-Inc/TileDB-Py) (which
    includes the TileDB library itself) by running `pip install tiledb`. This is aimed
    at scientific data and applications.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 用于密集或稀疏数组存储的最新后继者是[TileDB](https://tiledb.io)。通过运行 `pip install tiledb` 安装[Python接口](https://github.com/TileDB-Inc/TileDB-Py)（包括TileDB库本身）。这专为科学数据和应用程序设计。
- en: Relational Databases
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关系数据库
- en: 'Relational databases are only about 40 years old but are ubiquitous in the
    computing world. You’ll almost certainly have to deal with them at one time or
    another. When you do, you’ll appreciate what they provide:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库虽然只有大约40年的历史，但在计算世界中无处不在。你几乎肯定会在某个时候必须处理它们。当你这样做时，你会感谢它们提供的：
- en: Access to data by multiple simultaneous users
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个同时用户访问数据
- en: Protection from corruption by those users
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受用户防止损坏
- en: Efficient methods to store and retrieve the data
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效存储和检索数据的方法
- en: Data defined by *schemas* and limited by *constraints*
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由*模式*定义的数据和受*约束*限制
- en: '*Joins* to find relationships across diverse types of data'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*连接*以找到跨多种类型数据的关系'
- en: 'A declarative (rather than imperative) query language: *SQL* (Structured Query
    Language)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种声明性（而不是命令性）查询语言：*SQL*（结构化查询语言）
- en: These are called *relational* because they show relationships among different
    kinds of data in the form of rectangular *tables*. For instance, in our menu example
    earlier, there is a relationship between each item and its price.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这些被称为*关系*数据库，因为它们展示了不同类型数据之间的关系，以矩形*表格*的形式。例如，在我们之前的菜单示例中，每个项目与其价格之间存在关系。
- en: A table is a rectangular grid of *columns* (data fields) and *rows* (individual
    data records), similar to a spreadsheet. The intersection of a row and column
    is a table *cell*. To create a table, name it and specify the order, names, and
    types of its columns. Each row has the same columns, although a column may be
    defined to allow missing data (called *nulls*) in cells. In the menu example,
    you could create a table with one row for each item being sold. Each item has
    the same columns, including one for the price.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 表格是*列*（数据字段）和*行*（单个数据记录）的矩形网格，类似于电子表格。行和列的交集是表格的*单元格*。要创建表格，需要命名它并指定其列的顺序、名称和类型。每行都具有相同的列，尽管可以定义某列允许在单元格中包含缺失数据（称为*nulls*）。在菜单示例中，你可以为每个出售的项目创建一个包含价格等列的表格。
- en: A column or group of columns is usually the table’s *primary key*; its values
    must be unique in the table. This prevents adding the same data to the table more
    than once. This key is *indexed* for fast lookups during queries. An index works
    a little like a book index, making it fast to find a particular row.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 表的列或一组列通常是表的*主键*；其值在表中必须是唯一的。这样可以防止将相同的数据多次添加到表中。此键被*索引*以便在查询期间快速查找。索引的工作方式有点像书籍索引，使得快速找到特定行。
- en: Each table lives within a parent *database*, like a file within a directory.
    Two levels of hierarchy help keep things organized a little better.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 每个表都位于父*数据库*中，就像目录中的文件一样。两个层次的层次结构有助于使事物组织得更好一些。
- en: Note
  id: totrans-172
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Yes, the word *database* is used in multiple ways: as the server, the table
    container, and the data stored therein. If you’ll be referring to all of them
    at the same time, it might help to call them *database server*, *database*, and
    *data*.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，单词*数据库*以多种方式使用：作为服务器，表容器和其中存储的数据。如果您同时提到它们所有，可能有助于将它们称为*数据库服务器*，*数据库*和*数据*。
- en: If you want to find rows by some nonkey column value, define a *secondary index*
    on that column. Otherwise, the database server must perform a *table scan*—a brute-force
    search of every row for matching column values.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要通过某些非关键列值查找行，请在该列上定义*二级索引*。否则，数据库服务器必须执行*表扫描*—对每一行进行匹配列值的 brute-force 搜索。
- en: Tables can be related to each other with *foreign keys*, and column values can
    be constrained to these keys.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 表可以通过*外键*相互关联，并且列值可以受限于这些键。
- en: SQL
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL
- en: 'SQL is not an API or a protocol, but a declarative *language*: you say *what*
    you want rather than *how* to do it. It’s the universal language of relational
    databases. SQL queries are text strings sent by a client to the database server,
    which in turn figures out what to do with them.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: SQL不是API或协议，而是声明性*语言*：您说您想要什么而不是如何做。这是关系数据库的通用语言。SQL查询是由客户端发送到数据库服务器的文本字符串，数据库服务器然后确定如何处理它们。
- en: 'There have been various SQL standard definitions, and all database vendors
    have added their own tweaks and extensions, resulting in many SQL *dialects*.
    If you store your data in a relational database, SQL gives you some portability.
    Still, dialect and operational differences can make it difficult to move your
    data to another type of database. There are two main categories of SQL statements:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种各样的SQL标准定义，所有数据库供应商都添加了自己的调整和扩展，导致了许多SQL *方言*。如果您将数据存储在关系型数据库中，SQL可以提供一些可移植性。然而，方言和操作差异可能会使您将数据移动到另一种类型的数据库变得困难。SQL语句有两个主要类别：
- en: DDL (data definition language)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: DDL（数据定义语言）
- en: Handles creation, deletion, constraints, and permissions for tables, databases,
    and users.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 处理表，数据库和用户的创建，删除，约束和权限。
- en: DML (data manipulation language)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: DML（数据操纵语言）
- en: Handles data insertions, selects, updates, and deletions.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 处理数据插入，选择，更新和删除。
- en: '[Table 16-1](#table_8-1) lists the basic SQL DDL commands.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 16-1](#table_8-1) 列出了基本的SQL DDL命令。'
- en: Table 16-1\. Basic SQL DDL commands
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 表16-1\. 基本的SQL DDL命令
- en: '| Operation | SQL pattern | SQL example |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | SQL模式 | SQL示例 |'
- en: '| --- | --- | --- |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Create a database | `CREATE DATABASE` *dbname* | `CREATE DATABASE d` |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 创建数据库 | `CREATE DATABASE` *dbname* | `CREATE DATABASE d` |'
- en: '| Select current database | `USE` *dbname* | `USE d` |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 选择当前数据库 | `USE` *dbname* | `USE d` |'
- en: '| Delete a database and its tables | `DROP DATABASE` *dbname* | `DROP DATABASE
    d` |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 删除数据库及其表 | `DROP DATABASE` *dbname* | `DROP DATABASE d` |'
- en: '| Create a table | `CREATE TABLE` *tbname* `(` *coldefs* `)` | `CREATE TABLE
    t (id INT, count INT)` |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 创建表 | `CREATE TABLE` *tbname* `(` *coldefs* `)` | `CREATE TABLE t (id INT,
    count INT)` |'
- en: '| Delete a table | `DROP TABLE` *tbname* | `DROP TABLE t` |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 删除表 | `DROP TABLE` *tbname* | `DROP TABLE t` |'
- en: '| Remove all rows from a table | `TRUNCATE TABLE` *tbname* | `TRUNCATE TABLE
    t` |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 从表中删除所有行 | `TRUNCATE TABLE` *tbname* | `TRUNCATE TABLE t` |'
- en: Note
  id: totrans-193
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Why all the CAPITAL LETTERS? SQL is case-insensitive, but it’s a tradition (don’t
    ask me why) to SHOUT its keywords in code examples to distinguish them from column
    names.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么所有的大写字母？SQL不区分大小写，但在代码示例中大声喊出关键字是一种传统（不要问我为什么），以区分它们和列名。
- en: 'The main DML operations of a relational database are often known by the acronym
    CRUD:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库的主要DML操作通常以CRUD缩写而闻名：
- en: '*C*reate by using the SQL `INSERT` statement'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SQL `INSERT`语句*C*reate
- en: '*R*ead by using `SELECT`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*R*通过`SELECT`读取'
- en: '*U*pdate by using `UPDATE`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*U*通过`UPDATE`更新'
- en: '*D*elete by using `DELETE`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*D*通过`DELETE`删除'
- en: '[Table 16-2](#sql_dml) looks at the commands available for SQL DML.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 16-2](#sql_dml) 查看了可用于SQL DML的命令。'
- en: Table 16-2\. Basic SQL DML commands
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 表 16-2\. 基本 SQL DML 命令
- en: '| Operation | SQL pattern | SQL example |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | SQL 模式 | SQL 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Add a row | `INSERT INTO` *tbname* `VALUES(` … `)` | `INSERT INTO t VALUES(7,
    40)` |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 添加一行 | `INSERT INTO` *tbname* `VALUES(` … `)` | `INSERT INTO t VALUES(7,
    40)` |'
- en: '| Select all rows and columns | `SELECT * FROM` *tbname* | `SELECT * FROM t`
    |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 选择所有行和列 | `SELECT * FROM` *tbname* | `SELECT * FROM t` |'
- en: '| Select all rows, some columns | `SELECT` *cols* `FROM` *tbname* | `SELECT
    id, count FROM t` |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 选择所有行，某些列 | `SELECT` *cols* `FROM` *tbname* | `SELECT id, count FROM t` |'
- en: '| Select some rows, some columns | `SELECT` *cols* `FROM` *tbname* `WHERE`
    *condition* | `SELECT id, count from t WHERE count > 5 AND id = 9` |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 选择某些行，某些列 | `SELECT` *cols* `FROM` *tbname* `WHERE` *condition* | `SELECT
    id, count from t WHERE count > 5 AND id = 9` |'
- en: '| Change some rows in a column | `UPDATE` *tbname* `SET` *col* `=` *value*
    `WHERE` *condition* | `UPDATE t SET count=3 WHERE id=5` |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 更改某列中的一些行 | `UPDATE` *tbname* `SET` *col* `=` *value* `WHERE` *condition*
    | `UPDATE t SET count=3 WHERE id=5` |'
- en: '| Delete some rows | `DELETE FROM` *tbname* `WHERE` *condition* | `DELETE FROM
    t WHERE count <= 10 OR id = 16` |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 删除某些行 | `DELETE FROM` *tbname* `WHERE` *condition* | `DELETE FROM t WHERE
    count <= 10 OR id = 16` |'
- en: DB-API
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DB-API
- en: An application programming interface (API) is a set of functions that you can
    call to get access to some service. [DB-API](http://bit.ly/db-api) is Python’s
    standard API for accessing relational databases. Using it, you can write a single
    program that works with multiple kinds of relational databases instead of writing
    a separate program for each one. It’s similar to Java’s JDBC or Perl’s dbi.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序编程接口（API）是一组可以调用以访问某些服务的函数。[DB-API](http://bit.ly/db-api) 是 Python 访问关系型数据库的标准
    API。使用它，你可以编写一个程序，可以与多种关系型数据库一起工作，而不是为每种数据库编写单独的程序。它类似于 Java 的 JDBC 或 Perl 的 dbi。
- en: 'Its main functions are the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 它的主要功能如下：
- en: '`connect()`'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect()`'
- en: Make a connection to the database; this can include arguments such as username,
    password, server address, and others.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 建立与数据库的连接；这可以包括用户名、密码、服务器地址等参数。
- en: '`cursor()`'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`cursor()`'
- en: Create a *cursor* object to manage queries.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 *cursor* 对象来管理查询。
- en: '`execute()` and `executemany()`'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute()` 和 `executemany()`'
- en: Run one or more SQL commands against the database.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对数据库运行一个或多个 SQL 命令。
- en: '`fetchone()`, `fetchmany()`, and `fetchall()`'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetchone()`、`fetchmany()` 和 `fetchall()`'
- en: Get the results from `execute()`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `execute()` 获取结果。
- en: The Python database modules in the coming sections conform to DB-API, often
    with extensions and some differences in details.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节中的 Python 数据库模块符合 DB-API，通常具有扩展和一些细节上的差异。
- en: SQLite
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQLite
- en: '[SQLite](http://www.sqlite.org) is a good, light, open source relational database.
    It’s implemented as a standard Python library, and stores databases in normal
    files. These files are portable across machines and operating systems, making
    SQLite a very portable solution for simple relational database applications. It
    isn’t as full featured as MySQL or PostgreSQL, but it does support SQL, and it
    manages multiple simultaneous users. Web browsers, smartphones, and other applications
    use SQLite as an embedded database.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLite](http://www.sqlite.org) 是一个优秀、轻量、开源的关系型数据库。它作为标准的 Python 库实现，并且将数据库存储在普通文件中。这些文件可以跨机器和操作系统移植，使
    SQLite 成为简单关系数据库应用程序的非常便携的解决方案。虽然不如 MySQL 或 PostgreSQL 功能全面，但它支持 SQL，并且能够管理多个同时用户。Web
    浏览器、智能手机和其他应用程序都将 SQLite 用作嵌入式数据库。'
- en: You begin with a `connect()` to the local SQLite database file that you want
    to use or create. This file is the equivalent of the directory-like *database*
    that parents tables in other servers. The special string `':memory:'` creates
    the database in memory only; this is fast and useful for testing but will lose
    data when your program terminates or if your computer goes down.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 首先通过 `connect()` 连接到你要使用或创建的本地 SQLite 数据库文件。这个文件相当于其他服务器中父表所在的类似目录的*数据库*。特殊字符串
    `':memory:'` 仅在内存中创建数据库；这对测试很快并且很有用，但在程序终止或计算机关机时会丢失数据。
- en: 'For the next example, let’s make a database called `enterprise.db` and the
    table `zoo` to manage our thriving roadside petting zoo business. The table columns
    are as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一个示例，让我们创建一个名为 `enterprise.db` 的数据库和一个名为 `zoo` 的表，以管理我们蓬勃发展的路边宠物动物园业务。表的列如下：
- en: '`critter`'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`critter`'
- en: A variable length string, and our primary key.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 变长字符串，以及我们的主键。
- en: '`count`'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`'
- en: An integer count of our current inventory for this animal.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这种动物的当前库存的整数计数。
- en: '`damages`'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`damages`'
- en: The dollar amount of our current losses from animal–human interactions.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前因动物与人类互动而造成的损失金额。
- en: '[PRE26]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Python’s triple quotes are handy when creating long strings such as SQL queries.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的三引号在创建长字符串（如 SQL 查询）时很方便。
- en: 'Now, add some animals to the zoo:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，向动物园添加一些动物：
- en: '[PRE27]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'There’s a safer way to insert data, using a *placeholder*:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种更安全的方式可以插入数据，即使用*占位符*：
- en: '[PRE28]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This time, we used three question marks in the SQL to indicate that we plan
    to insert three values, and then pass those three values as a tuple to the `execute()`
    function. Placeholders handle tedious details such as quoting. They protect you
    against *SQL injection*, a kind of external attack that inserts malicious SQL
    commands into the system (and which is common on the web).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们在 SQL 中使用了三个问号来表示我们打算插入三个值，然后将这三个值作为元组传递给 `execute()` 函数。占位符处理繁琐的细节，如引用。它们保护您免受*SQL注入*的攻击，这是一种将恶意SQL命令插入系统的外部攻击（在网络上很常见）。
- en: 'Now, let’s see if we can get all our animals out again:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看是否可以再次把我们所有的动物都放出来：
- en: '[PRE29]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let’s get them again, but ordered by their counts:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次获取它们，但按计数排序：
- en: '[PRE30]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Hey, we wanted them in descending order:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，我们希望它们按降序排列：
- en: '[PRE31]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Which type of animal is costing us the most?
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种类型的动物给我们花费最多？
- en: '[PRE32]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You would have thought it was the bears. It’s always best to check the actual
    data.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为是熊。最好检查一下实际数据。
- en: 'Before we leave SQLite, we need to clean up. If we opened a connection and
    a cursor, we need to close them when we’re done:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开 SQLite 之前，我们需要清理一下。如果我们打开了连接和游标，那么在完成时我们需要关闭它们：
- en: '[PRE33]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: MySQL
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MySQL
- en: '[MySQL](http://www.mysql.com) is a very popular open source relational database.
    Unlike SQLite, it’s an actual server, so clients can access it from different
    devices across the network.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[MySQL](http://www.mysql.com) 是一个非常流行的开源关系型数据库。与 SQLite 不同，它是一个实际的服务器，因此客户端可以从网络上的不同设备访问它。'
- en: '[Table 16-3](#mysql_drivers) lists the drivers you can use to access MySQL
    from Python. For more details on all Python MySQL drivers, see the *python.org*
    [wiki](https://wiki.python.org/moin/MySQL).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[表16-3](#mysql_drivers)列出了您可以使用的驱动程序，以从 Python 访问 MySQL。有关所有 Python MySQL 驱动程序的更多详细信息，请参见*python.org*
    [wiki](https://wiki.python.org/moin/MySQL)。'
- en: Table 16-3\. MySQL drivers
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 表16-3\. MySQL 驱动程序
- en: '| Name | Link | Pypi package | Import as | Notes |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| Name | Link | Pypi package | Import as | Notes |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| mysqlclient | [*https://https://mysqlclient.readthedocs.io*](https://mysqlclient.readthedocs.io/)
    | mysql-connector-python | `MySQLdb` |  |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| mysqlclient | [*https://https://mysqlclient.readthedocs.io*](https://mysqlclient.readthedocs.io/)
    | mysql-connector-python | `MySQLdb` |  |'
- en: '| MySQL Connector | [*http://bit.ly/mysql-cpdg*](http://bit.ly/mysql-cpdg)
    | mysql-connector-python | `mysql.connector` |  |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| MySQL Connector | [*http://bit.ly/mysql-cpdg*](http://bit.ly/mysql-cpdg)
    | mysql-connector-python | `mysql.connector` |  |'
- en: '| PYMySQL | [*https://github.com/petehunt/PyMySQL*](https://github.com/petehunt/PyMySQL/)
    | pymysql | `pymysql` |  |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| PYMySQL | [*https://github.com/petehunt/PyMySQL*](https://github.com/petehunt/PyMySQL/)
    | pymysql | `pymysql` |  |'
- en: '| oursql | [*http://pythonhosted.org/oursql*](http://pythonhosted.org/oursql/)
    | oursql | `oursql` | Requires the MySQL C client libraries |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| oursql | [*http://pythonhosted.org/oursql*](http://pythonhosted.org/oursql/)
    | oursql | `oursql` | 需要 MySQL C 客户端库 |'
- en: PostgreSQL
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: '[PostgreSQL](http://www.postgresql.org) is a full-featured open source relational
    database. Indeed in many ways, it’s more advanced than MySQL. [Table 16-4](#postgres_drivers)
    presents the Python drivers you can use to access it.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[PostgreSQL](http://www.postgresql.org) 是一个功能齐全的开源关系型数据库。事实上，在许多方面，它比 MySQL
    更先进。[表16-4](#postgres_drivers)列出了您可以用来访问它的 Python 驱动程序。'
- en: Table 16-4\. PostgreSQL drivers
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 表16-4\. PostgreSQL 驱动程序
- en: '| Name | Link | Pypi package | Import as | Notes |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| Name | Link | Pypi package | Import as | Notes |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| psycopg2 | [*http://initd.org/psycopg*](http://initd.org/psycopg/) | psycopg2
    | psycopg2 | Needs `pg_config` from PostgreSQL client tools |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| psycopg2 | [*http://initd.org/psycopg*](http://initd.org/psycopg/) | psycopg2
    | psycopg2 | 需要来自 PostgreSQL 客户端工具的 `pg_config` |'
- en: '| py-postgresql | [*https://pypi.org/project/py-postgresql*](https://pypi.org/project/py-postgresql/)
    | py-postgresql | postgresql |  |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| py-postgresql | [*https://pypi.org/project/py-postgresql*](https://pypi.org/project/py-postgresql/)
    | py-postgresql | postgresql |  |'
- en: The most popular driver is `psycopg2`, but its installation requires the PostgreSQL
    client libraries.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的驱动程序是 `psycopg2`，但它的安装需要 PostgreSQL 客户端库。
- en: SQLAlchemy
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQLAlchemy
- en: SQL is not quite the same for all relational databases, and DB-API takes you
    only so far. Each database implements a particular *dialect* reflecting its features
    and philosophy. Many libraries try to bridge these differences in one way or another.
    The most popular cross-database Python library is [SQLAlchemy](http://www.sqlalchemy.org).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有关系数据库，SQL 并不完全相同，而 DB-API 也只能带你走到这一步。每个数据库都实现了一个反映其特性和哲学的特定*方言*。许多库试图以一种或另一种方式弥合这些差异。最流行的跨数据库
    Python 库是 [SQLAlchemy](http://www.sqlalchemy.org)。
- en: 'It isn’t in the standard library, but it’s well known and used by many people.
    You can install it on your system by using this command:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 它不在标准库中，但它是众所周知的，并被许多人使用。你可以通过使用这个命令在你的系统上安装它：
- en: '[PRE34]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can use SQLAlchemy on several levels:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在几个层面上使用 SQLAlchemy：
- en: The lowest level manages database connection *pools*, executes SQL commands,
    and returns results. This is closest to the DB-API.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最低级别管理数据库连接*池*，执行 SQL 命令并返回结果。这是最接近 DB-API 的层次。
- en: Next up is the *SQL expression language*, which lets you express queries in
    a more Python-oriented way.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是 *SQL 表达式语言*，它允许你以更加面向 Python 的方式表达查询。
- en: Highest is the ORM (Object Relational Model) layer, which uses the SQL Expression
    Language and binds application code with relational data structures.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最高级别是 ORM（对象关系模型）层，它使用 SQL 表达语言并将应用程序代码与关系数据结构绑定。
- en: 'As we go along, you’ll understand what the terms mean in those levels. SQLAlchemy
    works with the database drivers documented in the previous sections. You don’t
    need to import the driver; the initial connection string you provide to SQLAlchemy
    will determine it. That string looks like this:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的进行，你会理解在这些层次中术语的含义。SQLAlchemy 与前面章节中记录的数据库驱动程序一起使用。你不需要导入驱动程序；你提供给 SQLAlchemy
    的初始连接字符串将决定它。这个字符串看起来像这样：
- en: '[PRE35]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The values you put in this string are as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这个字符串中放入的值如下：
- en: '`dialect`'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`dialect`'
- en: The database type
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库类型
- en: '`driver`'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`driver`'
- en: The particular driver you want to use for that database
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要用于该数据库的特定驱动程序
- en: '`user` and `password`'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`user` 和 `password`'
- en: Your database authentication strings
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 您的数据库认证字符串
- en: '`host` and `port`'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`host` 和 `port`'
- en: 'The database server’s location (`: port` is needed only if it’s not the standard
    one for this server)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库服务器的位置（仅在不是该服务器的标准端口时需要）
- en: '`dbname`'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`dbname`'
- en: The database to initially connect to on the server
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 最初连接到服务器的数据库
- en: '[Table 16-5](#sqlalchemy_dialects) lists the dialects and drivers.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 16-5](#sqlalchemy_dialects) 列出了方言和驱动程序。'
- en: Table 16-5\. SQLAlchemy connection
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 表 16-5\. SQLAlchemy 连接
- en: '| dialect | driver |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| 方言 | 驱动程序 |'
- en: '| --- | --- |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `sqlite` | `pysqlite` (or omit) |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `sqlite` | `pysqlite`（或省略） |'
- en: '| `mysql` | `mysqlconnector` |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `mysql` | `mysqlconnector` |'
- en: '| `mysql` | `pymysql` |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `mysql` | `pymysql` |'
- en: '| `mysql` | `oursql` |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| `mysql` | `oursql` |'
- en: '| `postgresql` | `psycopg2` |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| `postgresql` | `psycopg2` |'
- en: '| `postgresql` | `pypostgresql` |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| `postgresql` | `pypostgresql` |'
- en: See also the SQLAlchemy details on dialects for [MySQL](https://oreil.ly/yVHy-),
    [SQLite](https://oreil.ly/okP9v), [PostgreSQL](https://oreil.ly/eDddn), and [other
    databases](https://oreil.ly/kp5WS).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅关于 [MySQL](https://oreil.ly/yVHy-)、[SQLite](https://oreil.ly/okP9v)、[PostgreSQL](https://oreil.ly/eDddn)
    和 [其他数据库](https://oreil.ly/kp5WS) 的 SQLAlchemy 详细信息。
- en: The engine layer
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引擎层
- en: First, let’s try the lowest level of SQLAlchemy, which does little more than
    the base DB-API functions.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们尝试 SQLAlchemy 的最低级别，它只比基本的 DB-API 函数多做一些事情。
- en: Let’s try it with SQLite, which is already built in to Python. The connection
    string for SQLite skips the *`host`*, *`port`*, *`user`*, and *`password`*. The
    *`dbname`* tells SQLite what file to use to store your database. If you omit the
    *`dbname`*, SQLite builds a database in memory. If the *`dbname`* starts with
    a slash (/), it’s an absolute filename on your computer (as in Linux and macOS;
    for example, `C:\` on Windows). Otherwise, it’s relative to your current directory.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试使用内置到 Python 中的 SQLite。SQLite 的连接字符串省略了 *`host`*、*`port`*、*`user`* 和 *`password`*。*`dbname`*
    告诉 SQLite 要使用哪个文件来存储你的数据库。如果省略 *`dbname`*，SQLite 将在内存中构建一个数据库。如果 *`dbname`* 以斜杠
    (/) 开头，它是计算机上的绝对文件名（如在 Linux 和 macOS 中；例如，在 Windows 中是 `C:\`）。否则，它相对于当前目录。
- en: The following segments are all part of one program, separated here for explanation.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的段落都属于一个程序的一部分，这里分开说明。
- en: 'To begin, you need to import what we need. The following is an example of an
    *import alias*, which lets us use the string `sa` to refer to SQLAlchemy methods.
    I do this mainly because `sa` is a lot easier to type than `sqlalchemy`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，您需要导入所需内容。以下是一个 *导入别名* 的示例，它允许我们使用字符串 `sa` 来引用 SQLAlchemy 方法。我主要这样做是因为 `sa`
    比 `sqlalchemy` 更容易输入：
- en: '[PRE36]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Connect to the database and create the storage for it in memory (the argument
    string `''sqlite:///:memory:''` also works):'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到数据库并在内存中创建存储它的位置（参数字符串 `'sqlite:///:memory:'` 也适用）：
- en: '[PRE37]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create a database table called `zoo` that comprises three columns:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `zoo` 的数据库表，包含三列：
- en: '[PRE38]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Running `conn.execute()` returns a SQLAlchemy object called a `ResultProxy`.
    You’ll soon see what to do with it.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `conn.execute()` 会返回一个称为 `ResultProxy` 的 SQLAlchemy 对象。您很快就会看到如何处理它。
- en: By the way, if you’ve never made a database table before, congratulations. Check
    that one off your bucket list.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，如果您以前从未制作过数据库表，请恭喜。在您的待办清单中打勾。
- en: 'Now, insert three sets of data into your new empty table:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将三组数据插入到您的新空表中：
- en: '[PRE39]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, ask the database for everything that we just put in:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，向数据库请求我们刚刚放入的所有内容：
- en: '[PRE40]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In SQLAlchemy, `rows` is not a list; it’s that special `ResultProxy` thing
    that we can’t print directly:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLAlchemy 中，`rows` 不是一个列表；它是我们无法直接打印的那个特殊的 `ResultProxy` 东西：
- en: '[PRE41]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'However, you can iterate over it like a list, so we can get a row at a time:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可以像迭代列表一样迭代它，因此我们可以逐行获取：
- en: '[PRE42]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: That was almost the same as the SQLite DB-API example that you saw earlier.
    The one advantage is that we didn’t need to import the database driver at the
    top; SQLAlchemy figured that out from the connection string. Just changing the
    connection string would make this code portable to another type of database. Another
    plus is SQLAlchemy’s *connection pooling*, which you can read about at its [documentation
    site](http://bit.ly/conn-pooling).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与您之前看到的 SQLite DB-API 示例相同。一个优点是我们不需要在顶部导入数据库驱动程序；SQLAlchemy 从连接字符串中找到了这一点。只需更改连接字符串，即可将此代码移植到另一种类型的数据库。另一个优点是
    SQLAlchemy 的 *连接池*，您可以在其 [文档站点](http://bit.ly/conn-pooling) 上阅读有关它的信息。
- en: The SQL Expression Language
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL 表达式语言
- en: The next level up is SQLAlchemy’s SQL Expression Language. It introduces functions
    to create the SQL for various operations. The Expression Language handles more
    of the SQL dialect differences than the lower-level engine layer does. It can
    be a handy middle-ground approach for relational database applications.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 上一级是 SQLAlchemy 的 SQL 表达式语言。它引入了函数来创建各种操作的 SQL。表达式语言处理的 SQL 方言差异比底层引擎层更多。对于关系数据库应用程序来说，它可以是一个方便的中间途径。
- en: Here’s how to create and populate the `zoo` table. Again, these are successive
    fragments of a single program.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何创建和填充 `zoo` 表的方法。同样，这些是单个程序的连续片段。
- en: 'The import and connection are the same as before:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 导入和连接与之前相同：
- en: '[PRE43]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To define the `zoo` table, we begin using some of the Expression Language instead
    of SQL:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义 `zoo` 表，我们开始使用一些表达式语言，而不是 SQL：
- en: '[PRE44]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Check out the parentheses in that multiline call in the preceding example. The
    structure of the `Table()` method matches the structure of the table. Just as
    our table contains three columns, there are three calls to `Column()` inside the
    parentheses of the `Table()` method call.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 查看前面示例中多行调用中的括号。`Table()` 方法的结构与表的结构匹配。正如我们的表包含三列一样，在 `Table()` 方法调用的括号内有三次对
    `Column()` 的调用。
- en: Meanwhile, `zoo` is some magic object that bridges the SQL database world and
    the Python data structure world.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，`zoo` 是一个魔术对象，连接了 SQL 数据库世界和 Python 数据结构世界。
- en: 'Insert the data with more Expression Language functions:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更多表达式语言函数插入数据：
- en: '[PRE45]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, create the SELECT statement (`zoo.select()` selects everything from the
    table represented by the `zoo` object, such as `SELECT * FROM zoo` would do in
    plain SQL):'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建 SELECT 语句（`zoo.select()` 选择由 `zoo` 对象表示的表中的所有内容，就像在普通 SQL 中执行 `SELECT
    * FROM zoo` 一样）：
- en: '[PRE46]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, get the results:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，获取结果：
- en: '[PRE47]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The Object-Relational Mapper (ORM)
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象关系映射器（ORM）
- en: In the previous section, the `zoo` object was a mid-level connection between
    SQL and Python. At the top layer of SQLAlchemy, the Object-Relational Mapper (ORM)
    uses the SQL Expression Language but tries to make the actual database mechanisms
    invisible. You define classes, and the ORM handles how to get their data in and
    out of the database. The basic idea behind that complicated phrase, “object-relational
    mapper,” is that you can refer to objects in your code and thus stay close to
    the way Python likes to operate while still using a relational database.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，`zoo`对象是SQL和Python之间的中间连接。在SQLAlchemy的顶层，对象关系映射器（ORM）使用SQL表达语言，但尝试使实际的数据库机制变得不可见。您定义类，ORM处理如何将它们的数据进出数据库。复杂短语“对象关系映射器”的基本思想是，您可以在代码中引用对象，从而保持接近Python喜欢操作的方式，同时仍然使用关系数据库。
- en: We’ll define a `Zoo` class and hook it into the ORM. This time, we make SQLite
    use the file *zoo.db* so that we can confirm that the ORM worked.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个`Zoo`类，并将其与ORM连接起来。这次，我们让SQLite使用文件*zoo.db*，以便确认ORM的工作。
- en: As in the previous two sections, the snippets that follow are actually one program
    separated by explanations. Don’t worry if you don’t understand some if it. The
    SQLAlchemy documentation has all the details—and this stuff can get complex. I
    just want you to get an idea of how much work it is to do this, so that you can
    decide which of the approaches discussed in this chapter suits you.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 与前两节类似，接下来的片段实际上是一个程序，由解释分隔开。如果您对某些内容不理解也不要担心。SQLAlchemy文档中有所有细节——这些内容可能会变得复杂。我只是希望您了解做这件事情需要多少工作，这样您可以决定本章讨论的哪种方法最适合您。
- en: 'The initial import is the same, but this time we need another something also:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 初始导入是相同的，但这次我们还需要另外一些东西：
- en: '[PRE48]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here, we make the connection:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们建立连接：
- en: '[PRE49]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, we get into SQLAlchemy’s ORM. We define the `Zoo` class and associate
    its attributes with table columns:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们进入SQLAlchemy的ORM。我们定义`Zoo`类，并关联其属性与表列：
- en: '[PRE50]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following line magically creates the database and table:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码神奇地创建了数据库和表：
- en: '[PRE51]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You can then insert data by creating Python objects. The ORM manages these
    internally:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过创建Python对象来插入数据。ORM在内部管理这些数据：
- en: '[PRE52]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, we get the ORM to take us to SQL land. We create a session to talk to
    the database:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们让ORM带我们进入SQL世界。我们创建一个会话来与数据库交互：
- en: '[PRE53]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Within the session, we write the three objects that we created to the database.
    The `add()` function adds one object, and `add_all()` adds a list:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在会话中，我们将创建的三个对象写入数据库。`add()`函数添加一个对象，而`add_all()`添加一个列表：
- en: '[PRE54]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, we need to force everything to complete:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要强制完成所有操作：
- en: '[PRE55]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Did it work? Well, it created a *zoo.db* file in the current directory. You
    can use the command-line `sqlite3` program to check it:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 它是否起作用？好吧，它在当前目录下创建了一个*zoo.db*文件。您可以使用命令行`sqlite3`程序来检查：
- en: '[PRE56]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The purpose of this section was to show what an ORM is and how it works at
    a high level. The author of SQLAlchemy has written a full [tutorial](http://bit.ly/obj-rel-tutorial).
    After reading this, decide which of the following levels would best fit your needs:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目的是展示ORM是什么以及它如何在高层次上工作。SQLAlchemy的作者写了一个完整的[教程](http://bit.ly/obj-rel-tutorial)。阅读后，请决定以下哪种层次最适合您的需求：
- en: Plain DB-API, as in the earlier SQLite section
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像之前的SQLite部分中的普通DB-API一样
- en: The SQLAlchemy engine
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLAlchemy引擎
- en: The SQLAlchemy Expression Language
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLAlchemy表达语言
- en: The SQLAlchemy ORM
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLAlchemy ORM
- en: 'It seems like a natural choice to use an ORM to avoid the complexities of SQL.
    Should you use one? Some people think ORMs should be [avoided](http://bit.ly/obj-rel-map),
    but others think the criticism is [overdone](http://bit.ly/fowler-orm). Whoever’s
    right, an ORM is an abstraction, and all abstractions are [leaky](http://bit.ly/leaky-law)
    and break down at some point. When your ORM doesn’t do what you want, you must
    figure out both how it works and how to fix it in SQL. To borrow an internet meme:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ORM似乎是避免SQL复杂性的自然选择。您应该使用ORM吗？有些人认为应该[避免](http://bit.ly/obj-rel-map)使用ORM，但其他人认为这种批评是[过度的](http://bit.ly/fowler-orm)。不管谁是对的，ORM都是一种抽象，所有抽象都会[泄漏](http://bit.ly/leaky-law)，并在某些时候出现问题。当ORM不能按您的意愿工作时，您必须弄清楚它的工作原理以及如何在SQL中修复它。借用互联网迷因：
- en: Some people, when confronted with a problem, think, “I know, I’ll use an ORM.”
    Now they have two problems.
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有些人面对问题时会想：“我知道了，我会使用ORM。”现在他们有两个问题。
- en: Use ORMs for simple applications or applications that map data pretty directly
    to database tables. If the application is that simple, you may consider using
    straight SQL or the SQL Expression Language.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的应用程序或将数据相当直接映射到数据库表的应用程序，请使用ORM。如果应用程序如此简单，您可以考虑使用纯SQL或SQL表达式语言。
- en: Other Database Access Packages
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他数据库访问包
- en: 'If you’re looking for Python tools that will handle multiple databases, with
    more features than the bare db-api but less than SQLAlchemy, these are worth a
    look:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在寻找能处理多个数据库的Python工具，具有比纯db-api更多功能但少于SQLAlchemy的功能，那么这些工具值得一看：
- en: '[`dataset`](https://dataset.readthedocs.org) claims the goal “databases for
    lazy people”. It’s built on SQLAlchemy and provides a simple ORM for SQL, JSON,
    and CSV storage.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`dataset`](https://dataset.readthedocs.org)声称其目标是“懒惰人的数据库”。它构建在SQLAlchemy之上，并为SQL、JSON和CSV存储提供了一个简单的ORM。'
- en: '[`records`](https://pypi.org/project/records) bills itself as “SQL for Humans.”
    It supports only SQL queries, using SQLAlchemy internally to handle SQL dialect
    issues, connection pooling, and other details. Its integration with `tablib` (mentioned
    at [“Tablib”](#tablib)) lets you export data to CSV, JSON, and other formats.'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`records`](https://pypi.org/project/records)自称为“人类的SQL”。它仅支持SQL查询，内部使用SQLAlchemy处理SQL方言问题、连接池和其他细节。它与`tablib`的集成（在[“Tablib”](#tablib)中提到）允许您将数据导出为CSV、JSON和其他格式。'
- en: NoSQL Data Stores
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NoSQL数据存储
- en: Relational tables are rectangular, but data come in many shapes and may be very
    difficult to fit without significant effort and contortion. It’s a square peg/round
    hole problem.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 关系表是矩形的，但数据有多种形状，可能非常难以适应，需要进行大量努力和扭曲。这是一个方孔/圆孔问题。
- en: Some nonrelational databases have been written to allow more flexible data definitions
    as well as to process very large data sets or support custom data operations.
    They’ve been collectively labeled *NoSQL* (formerly meaning *no SQL*, now the
    less confrontational *not only SQL*).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 一些非关系数据库已被编写，允许更灵活的数据定义，以及处理非常大的数据集或支持自定义数据操作。它们被统称为*NoSQL*（原意为*no SQL*，现在是更不具对抗性的*not
    only SQL*）。
- en: The simplest type of NoSQL databases are *key-value stores*. One popularity
    [ranking](https://oreil.ly/_VCKq) shows some that I cover in the following sections.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单类型的NoSQL数据库是*键值存储*。一个流行的[排名](https://oreil.ly/_VCKq)展示了我在以下章节中涵盖的一些数据库。
- en: The dbm Family
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: dbm家族
- en: 'The `dbm` formats were around long before the *NoSQL* label was coined. They’re
    simple key-value stores, often embedded in applications such as web browsers to
    maintain various settings. A dbm database is like a Python dictionary in the following
    ways:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`dbm`格式在*NoSQL*标签被创造之前就存在了。它们是简单的键值存储，通常嵌入在诸如Web浏览器之类的应用程序中，用于维护各种设置。dbm数据库类似于Python字典的以下方面：'
- en: You can assign a value to a key, and it’s automatically saved to the database
    on disk.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以为键分配一个值，并且它会自动保存到数据库中。
- en: You can query a key for its value.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以查询键的值。
- en: 'The following is a quick example. The second argument to the following `open()`
    method is `''r''` to read, `''w''` to write, and `''c''` for both, creating the
    file if it doesn’t exist:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个快速示例。以下`open()`方法的第二个参数是`'r'`表示读取，`'w'`表示写入，`'c'`表示两者，如果文件不存在则创建：
- en: '[PRE57]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To create key-value pairs, just assign a value to a key just as you would a
    dictionary:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建键值对，只需像创建字典一样将值分配给键：
- en: '[PRE58]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let’s pause and check what we have so far:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们停下来检查一下我们到目前为止所做的：
- en: '[PRE59]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now close, then reopen to see whether it actually saved what we gave it:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在关闭，然后重新打开以查看它是否实际保存了我们给予的内容：
- en: '[PRE60]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Keys and values are stored as `bytes`. You cannot iterate over the database
    object `db`, but you can get the number of keys by using `len()`. `get()` and
    `setdefault()` work as they do for dictionaries.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 键和值被存储为`bytes`。您不能对数据库对象`db`进行迭代，但可以使用`len()`来获取键的数量。`get()`和`setdefault()`的工作方式与字典相同。
- en: Memcached
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Memcached
- en: '[`memcached`](http://memcached.org) is a fast in-memory key-value *cache* server.
    It’s often put in front of a database, or used to store web server session data.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '[`memcached`](http://memcached.org)是一个快速的内存中键值*缓存*服务器。它经常被放在数据库前面，或用于存储Web服务器会话数据。'
- en: You can download versions for [Linux and macOS](https://memcached.org/downloads)
    as well as [Windows](http://bit.ly/memcache-win). If you want to try out this
    section, you’ll need a running memcached server and Python driver.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[Linux和macOS](https://memcached.org/downloads)以及[Windows](http://bit.ly/memcache-win)下载版本。如果您想尝试本节，您需要一个正在运行的memcached服务器和Python驱动程序。
- en: 'There are many Python drivers; one that works with Python 3 is [`python3-memcached`](https://oreil.ly/7FA3-),
    which you can install by using this command:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多 Python 驱动程序；与 Python 3 兼容的一个是 [`python3-memcached`](https://oreil.ly/7FA3-)，您可以使用以下命令安装它：
- en: '[PRE61]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To use it, connect to a memcached server, after which you can do the following:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，请连接到 memcached 服务器，之后您可以执行以下操作：
- en: Set and get values for keys
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为键设置和获取值
- en: Increment or decrement a value
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`incr`或`decr`增加或减少值
- en: Delete a key
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除一个键
- en: Data keys and values are *not* persistent, and data that you wrote earlier might
    disappear. This is inherent in memcached—it’s a cache server, not a database,
    and it avoids running out of memory by discarding old data.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 数据键和值*不*是持久的，之前写入的数据可能会消失。这是 memcached 的固有特性——它是一个缓存服务器，而不是数据库，并通过丢弃旧数据来避免内存耗尽。
- en: 'You can connect to multiple memcached servers at the same time. In this next
    example, we’re just talking to one on the same computer:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以同时连接多个 memcached 服务器。在下一个示例中，我们仅与同一台计算机上的一个服务器通信：
- en: '[PRE62]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Redis
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Redis
- en: '[Redis](http://redis.io) is a *data structure server*. It handles keys and
    their values, but the values are richer than those in other key-value stores.
    Like memcached, all of the data in a Redis server should fit in memory. Unlike
    memcached, Redis can do the following:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '[Redis](http://redis.io)是一个*数据结构服务器*。它处理键及其值，但是与其他键值存储中的值相比，值更丰富。与 memcached
    一样，Redis 服务器中的所有数据都应该适合内存。不同于 memcached，Redis 可以执行以下操作：'
- en: Save data to disk for reliability and restarts
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据保存到磁盘以保证可靠性和重新启动
- en: Keep old data
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留旧数据
- en: Provide more data structures than simple strings
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供比简单字符串更多的数据结构
- en: The Redis data types are a close match to Python’s, and a Redis server can be
    a useful intermediary for one or more Python applications to share data. I’ve
    found it so useful that it’s worth a little extra coverage here.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 的数据类型与 Python 的非常接近，并且 Redis 服务器可以成为一个或多个 Python 应用程序共享数据的有用中介。我发现它非常有用，因此在这里额外进行一些覆盖是值得的。
- en: 'The Python driver `redis-py` has its source code and tests on [GitHub](https://oreil.ly/aZIbQ)
    as well as [documentation](http://bit.ly/redis-py-docs). You can install it by
    using this command:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: Python 驱动程序 `redis-py` 在 [GitHub](https://oreil.ly/aZIbQ) 上有其源代码和测试，以及 [文档](http://bit.ly/redis-py-docs)。您可以使用以下命令安装它：
- en: '[PRE63]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The [Redis server](http://redis.io) has good documentation. If you install and
    start the Redis server on your local computer (with the network nickname `localhost`),
    you can try the programs in the following sections.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '[Redis 服务器](http://redis.io)有很好的文档。如果在本地计算机上安装并启动 Redis 服务器（使用网络别名`localhost`），您可以尝试以下部分的程序。'
- en: Strings
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串
- en: 'A key with a single value is a Redis *string*. Simple Python data types are
    automatically converted. Connect to a Redis server at some host (default is `localhost`)
    and port (default is `6379`):'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有单个值的键是 Redis *字符串*。简单的 Python 数据类型会自动转换。连接到某个主机上的 Redis 服务器（默认为`localhost`）和端口（默认为`6379`）：
- en: '[PRE64]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Connecting to `redis.Redis('localhost')` or `redis.Redis('localhost', 6379)`
    would have given the same result.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到`redis.Redis('localhost')`或`redis.Redis('localhost', 6379)`将给出相同的结果。
- en: 'List all keys (none so far):'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 列出所有键（目前没有）：
- en: '[PRE65]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Set a simple string (key `''secret''`), integer (key `''carats''`), and float
    (key `''fever''`):'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个简单的字符串（键`'secret'`）、整数（键`'carats'`）和浮点数（键`'fever'`）：
- en: '[PRE66]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Get the values back (as Python `byte` values) by key:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 通过键获取值（作为 Python `byte` 值）：
- en: '[PRE67]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Here, the `setnx()` method sets a value only if the key does not exist:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`setnx()`方法仅在键不存在时设置一个值：
- en: '[PRE68]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'It failed because we had already defined `''secret''`:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已经定义了`'secret'`，所以失败了：
- en: '[PRE69]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `getset()` method returns the old value and sets it to a new one at the
    same time:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`getset()`方法返回旧值，并同时设置为新值：'
- en: '[PRE70]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Let’s not get too far ahead of ourselves. Did it work?
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 不要急于前进。这有用吗？
- en: '[PRE71]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, get a substring by using `getrange()` (as in Python, offset `0` means
    start, and `-1` means end):'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`getrange()`获取子字符串（与 Python 中一样，偏移量`0`表示起始，`-1`表示结尾）：
- en: '[PRE72]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Replace a substring by using `setrange()` (using a zero-based offset):'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`setrange()`替换子字符串（使用从零开始的偏移量）：
- en: '[PRE73]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Next, set multiple keys at once by using `mset()`:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`mset()`一次设置多个键：
- en: '[PRE74]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Get more than one value at once by using `mget()`:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`mget()`一次获取多个值：
- en: '[PRE75]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Delete a key by using `delete()`:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`delete()`方法删除一个键：
- en: '[PRE76]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Increment by using the `incr()` or `incrbyfloat()` commands, and decrement
    with `decr()`:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`incr()`或`incrbyfloat()`命令进行增量，并使用`decr()`进行减量：
- en: '[PRE77]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'There’s no `decrbyfloat()`. Use a negative increment to reduce the fever:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 没有`decrbyfloat()`。使用负增量来减少发烧：
- en: '[PRE78]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Lists
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表
- en: 'Redis lists can contain only strings. The list is created when you do your
    first insertion. Insert at the beginning by using `lpush()`:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: Redis列表只能包含字符串。当您进行第一次插入时，列表被创建。通过使用`lpush()`在开头插入：
- en: '[PRE79]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Insert more than one item at the beginning:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在开头插入多个项目：
- en: '[PRE80]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Insert before or after a value by using `linsert()`:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`linsert()`在值之前或之后插入：
- en: '[PRE81]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Insert at an offset by using `lset()` (the list must exist already):'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`lset()`在偏移处插入（列表必须已经存在）：
- en: '[PRE82]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Insert at the end by using `rpush()`:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`rpush()`在末尾插入：
- en: '[PRE83]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Get the value at an offset by using `lindex()`:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`lindex()`按偏移量获取值：
- en: '[PRE84]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Get the values in an offset range by using `lrange()` (0 to -1 for all):'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`lrange()`获取偏移范围内的值（0到-1获取所有）：
- en: '[PRE85]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Trim the list with `ltrim()`, keeping only those in a range of offsets:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ltrim()`修剪列表，仅保留偏移范围内的元素：
- en: '[PRE86]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Get a range of values (use `0` to `-1` for all) by using `lrange()`:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`lrange()`获取值的范围（使用`0`到`-1`获取所有）：
- en: '[PRE87]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[Chapter 15](ch15.html#ch_systems) shows you how you can use Redis lists and
    *publish-subscribe* to implement job queues.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '[第15章](ch15.html#ch_systems)展示了如何使用Redis列表和*发布-订阅*来实现作业队列。'
- en: Hashes
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 哈希
- en: 'Redis *hashes* are similar to Python dictionaries but can contain only strings.
    Also, you can go only one level deep, not make deep-nested structures. Here are
    examples that create and play with a Redis hash called `song`:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: Redis *哈希*类似于Python字典，但只能包含字符串。此外，您只能深入到一级，不能创建深度嵌套的结构。以下是创建和操作名为`song`的Redis哈希的示例：
- en: 'Set the fields `do` and `re` in hash `song` at once by using `hmset()`:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`hmset()`一次设置哈希`song`中的字段`do`和`re`：
- en: '[PRE88]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Set a single field value in a hash by using `hset()`:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`hset()`在哈希中设置单个字段值：
- en: '[PRE89]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Get one field’s value by using `hget()`:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`hget()`获取一个字段的值：
- en: '[PRE90]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Get multiple field values by using `hmget()`:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`hmget()`获取多个字段值：
- en: '[PRE91]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Get all field keys for the hash by using `hkeys()`:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`hkeys()`获取哈希的所有字段键：
- en: '[PRE92]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Get all field values for the hash by using `hvals()`:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`hvals()`获取哈希的所有字段值：
- en: '[PRE93]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Get the number of fields in the hash by using `hlen()`:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`hlen()`获取哈希中字段的数量：
- en: '[PRE94]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Get all field keys and values in the hash by using `hgetall()`:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`hgetall()`获取哈希中的所有字段键和值：
- en: '[PRE95]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Set a field if its key doesn’t exist by using `hsetnx()`:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其键不存在，则使用`hsetnx()`设置字段：
- en: '[PRE96]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Sets
  id: totrans-480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合
- en: Redis sets are similar to Python sets, as you’ll see in the following examples.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: Redis集合与Python集合类似，您将在以下示例中看到。
- en: 'Add one or more values to a set:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 向集合添加一个或多个值：
- en: '[PRE97]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Get the number of values from the set:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 获取集合的值的数量：
- en: '[PRE98]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Get all of the set’s values:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 获取集合的所有值：
- en: '[PRE99]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Remove a value from the set:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 从集合中移除一个值：
- en: '[PRE100]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Let’s make a second set to show some set operations:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再建立一个集合来展示一些集合操作：
- en: '[PRE101]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Intersect (get the common members of) the `zoo` and `better_zoo` sets:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 求交集（获取`zoo`和`better_zoo`集合的共同成员）：
- en: '[PRE102]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Get the intersection of `zoo` and `better_zoo`, and store the result in the
    set `fowl_zoo`:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 获取`zoo`和`better_zoo`的交集，并将结果存储在集合`fowl_zoo`中：
- en: '[PRE103]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Who’s in there?
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 里面有谁？
- en: '[PRE104]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Get the union (all members) of `zoo` and `better_zoo`:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 获取`zoo`和`better_zoo`的并集（所有成员）：
- en: '[PRE105]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Store that union result in the set `fabulous_zoo`:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 将联合结果存储在集合`fabulous_zoo`中：
- en: '[PRE106]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'What does `zoo` have that `better_zoo` doesn’t? Use `sdiff()` to get the set
    difference, and `sdiffstore()` to save it in the `zoo_sale` set:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '`zoo`有什么，`better_zoo`没有？使用`sdiff()`获取集合的差集，并使用`sdiffstore()`将其保存在`zoo_sale`集合中：'
- en: '[PRE107]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Sorted sets
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排序集合
- en: 'One of the most versatile Redis data types is the *sorted set*, or *zset*.
    It’s a set of unique values, but each value has an associated floating-point *score*.
    You can access each item by its value or score. Sorted sets have many uses:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 最多用途的Redis数据类型之一是*排序集合*，或*zset*。它是一组唯一值，但每个值都有一个关联的浮点数*分数*。您可以通过其值或分数访问每个项目。排序集合有许多用途：
- en: Leader boards
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排行榜
- en: Secondary indexes
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二级索引
- en: Timeseries, using timestamps as scores
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间序列，使用时间戳作为分数
- en: 'We show the last use case, tracking user logins via timestamps. We’re using
    the Unix *epoch* value (more on this in [Chapter 15](ch15.html#ch_systems)) that’s
    returned by the Python `time()` function:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了最后一个用例，通过时间戳跟踪用户登录。我们使用Python `time()`函数返回的Unix *epoch*值（更多详情请参见[第15章](ch15.html#ch_systems)）：
- en: '[PRE108]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Let’s add our first guest, looking nervous:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加第一个看起来紧张的客人：
- en: '[PRE109]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Five minutes later, another guest:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 五分钟后，另一位客人：
- en: '[PRE110]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Two hours later:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 两小时后：
- en: '[PRE111]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'One day later, not hasty:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 一天后，不要着急：
- en: '[PRE112]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: In what order did `bilbo` arrive?
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '`bilbo`以什么顺序到达？'
- en: '[PRE113]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: When was that?
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 那是什么时候？
- en: '[PRE114]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Let’s see everyone in login order:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按登录顺序查看每个人：
- en: '[PRE115]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'With their times, please:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 请附上它们的时间：
- en: '[PRE116]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Caches and expiration
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存和过期
- en: 'All Redis keys have a time-to-live, or *expiration date*. By default, this
    is forever. We can use the `expire()` function to instruct Redis how long to keep
    the key. The value is a number of seconds:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 Redis 键都有一个*到期时间*，默认情况下是永久的。我们可以使用`expire()`函数来指示 Redis 保留键的时间长度。该值是以秒为单位的数字：
- en: '[PRE117]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The `expireat()` command expires a key at a given epoch time. Key expiration
    is useful to keep caches fresh and to limit login sessions. An analogy: in the
    refrigerated room behind the milk racks at your grocery store, store employees
    yank those gallons as they reach their freshness dates.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '`expireat()`命令在给定的纪元时间点过期键。键的过期对于保持缓存新鲜和限制登录会话非常有用。类比：在你的杂货店货架后面的冷藏室中，当牛奶达到保质期时，店员们就会将那些加仑装出货。'
- en: Document Databases
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档数据库
- en: A *document database* is a NoSQL database that stores data with varying fields.
    Compared to a relational table (rectangular, with the same columns in every row)
    such data is “ragged,” with varying fields (columns) per row, and even nested
    fields. You could handle data like this in memory with Python dictionaries and
    lists, or store it as JSON files. To store such data in a relational database
    table, you would need to define every possible column and use nulls for missing
    data.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '*文档数据库*是一种 NoSQL 数据库，它以不同的字段存储数据。与关系表（每行具有相同列的矩形表）相比，这样的数据是“参差不齐”的，每行具有不同的字段（列），甚至是嵌套字段。你可以使用
    Python 字典和列表在内存中处理这样的数据，或者将其存储为 JSON 文件。要将这样的数据存储在关系数据库表中，你需要定义每个可能的列，并使用 null
    来表示缺失的数据。'
- en: '*ODM* can stand for Object Data Manager or Object Document Mapper (at least
    they agree on the *O* part). An ODM is the document database counterpart of a
    relational database ORM. Some [popular](https://oreil.ly/5Zpxx) document databases
    and tools (drivers and ODMs) are listed in [Table 16-6](#document_db_table).'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '*ODM*可以代表对象数据管理器或对象文档映射器（至少它们同意“O”部分）。ODM是文档数据库的关系数据库ORM对应物。一些[流行的](https://oreil.ly/5Zpxx)文档数据库和工具（驱动程序和ODM）列在[表
    16-6](#document_db_table)中。 '
- en: Table 16-6\. Document databases
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 表 16-6\. 文档数据库
- en: '| Database | Python API |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
  zh: '| 数据库 | Python API |'
- en: '| --- | --- |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [Mongo](https://www.mongodb.com) | [tools](https://api.mongodb.com/python/current/tools.html)
    |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
  zh: '| [Mongo](https://www.mongodb.com) | [tools](https://api.mongodb.com/python/current/tools.html)
    |'
- en: '| [DynamoDB](https://aws.amazon.com/dynamodb) | [`boto3`](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GettingStarted.Python.html)
    |'
  id: totrans-538
  prefs: []
  type: TYPE_TB
  zh: '| [DynamoDB](https://aws.amazon.com/dynamodb) | [`boto3`](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GettingStarted.Python.html)
    |'
- en: '| [CouchDB](http://couchdb.apache.org) | [`couchdb`](https://couchdb-python.readthedocs.io/en/latest/index.html)
    |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '| [CouchDB](http://couchdb.apache.org) | [`couchdb`](https://couchdb-python.readthedocs.io/en/latest/index.html)
    |'
- en: Note
  id: totrans-540
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'PostgreSQL can do some of the things that document databases do. Some of its
    extensions allow it to escape relational orthodoxy while keeping features like
    transactions, data validation, and foreign keys: 1) multidimensional [*arrays*](https://oreil.ly/MkfLY)—store
    more than one value in a table cell; 2) [*jsonb*](https://oreil.ly/K_VJg)—store
    JSON data in a cell, with full indexing and querying.'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL可以做一些文档数据库可以做的事情。它的一些扩展允许它逃离关系规范，同时保留事务、数据验证和外键等特性：1）多维[*数组*](https://oreil.ly/MkfLY)
    - 在表单元格中存储多个值；2）[*jsonb*](https://oreil.ly/K_VJg) - 在单元格中存储 JSON 数据，并进行完整的索引和查询。
- en: Time Series Databases
  id: totrans-542
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间序列数据库
- en: '*Time series* data may be collected at fixed intervals (such as computer performance
    metrics) or at random times, which has led to many storage methods. Among [many](https://oreil.ly/CkjC0)
    of [these](https://oreil.ly/IbOxQ), some with Python support are listed in [Table 16-7](#temporal_db_table).'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '*时间序列*数据可以在固定间隔（如计算机性能指标）或随机时间收集，这导致了许多存储方法。其中[许多](https://oreil.ly/CkjC0)中[的一些](https://oreil.ly/IbOxQ)，一些具有
    Python 支持的方法列在[表 16-7](#temporal_db_table)中。'
- en: Table 16-7\. Temporal databases
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 表 16-7\. 时间数据库
- en: '| Database | Python API |'
  id: totrans-545
  prefs: []
  type: TYPE_TB
  zh: '| 数据库 | Python API |'
- en: '| --- | --- |'
  id: totrans-546
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [InfluxDB](https://www.influxdata.com) | [`influx-client`](https://pypi.org/project/influx-client)
    |'
  id: totrans-547
  prefs: []
  type: TYPE_TB
  zh: '| [InfluxDB](https://www.influxdata.com) | [`influx-client`](https://pypi.org/project/influx-client)
    |'
- en: '| [kdb+](https://kx.com) | [PyQ](https://code.kx.com/v2/interfaces/pyq/) |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
  zh: '| [kdb+](https://kx.com) | [PyQ](https://code.kx.com/v2/interfaces/pyq/) |'
- en: '| [Prometheus](https://prometheus.io) | [`prometheus_client`](https://github.com/prometheus/client_python/blob/master/README.md)
    |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '| [Prometheus](https://prometheus.io) | [`prometheus_client`](https://github.com/prometheus/client_python/blob/master/README.md)
    |'
- en: '| [TimescaleDB](https://www.timescale.com) | (PostgreSQL clients) |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '| [TimescaleDB](https://www.timescale.com) | (PostgreSQL clients) |'
- en: '| [OpenTSDB](http://opentsdb.net) | [`potsdb`](https://pypi.org/project/potsdb)
    |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
  zh: '| [OpenTSDB](http://opentsdb.net) | [`potsdb`](https://pypi.org/project/potsdb)
    |'
- en: '| [PyStore](https://github.com/ranaroussi/pystore) | [`PyStore`](https://pypi.org/project/PyStore)
    |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '| [PyStore](https://github.com/ranaroussi/pystore) | [`PyStore`](https://pypi.org/project/PyStore)
    |'
- en: Graph Databases
  id: totrans-553
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图数据库
- en: 'For our last case of data that need its own database category, we have *graphs*:
    *nodes* (data) connected by *edges* or *vertices* (relationships). An individual
    Twitter *user* could be a node, with edges to other users like *following* and
    *followed*.'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要有自己数据库类别的最后一种数据案例，我们有 *图形*：*节点*（数据）通过 *边缘* 或 *顶点*（关系）相连。一个个体 Twitter *用户*
    可以是一个节点，与其他用户的关系如 *关注* 和 *被关注* 为边。
- en: Graph data has become more visible with the growth of social media, where the
    value is in the connections as much as the content. Some [popular](https://oreil.ly/MAwMQ)
    graph databases are outlined in [Table 16-8](#graph_db_table).
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 随着社交媒体的增长，图形数据变得更加明显，价值在于连接而非内容本身。一些流行的图数据库在 [表 16-8](#graph_db_table) 中概述。
- en: Table 16-8\. Graph databases
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 表 16-8\. 图数据库
- en: '| Database | Python API |'
  id: totrans-557
  prefs: []
  type: TYPE_TB
  zh: '| 数据库 | Python API |'
- en: '| --- | --- |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [Neo4J](https://neo4j.com) | [`py2neo`](https://py2neo.org/v3) |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '| [Neo4J](https://neo4j.com) | [`py2neo`](https://py2neo.org/v3) |'
- en: '| [OrientDB](https://orientdb.com) | [`pyorient`](https://orientdb.com/docs/last/PyOrient.html)
    |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '| [OrientDB](https://orientdb.com) | [`pyorient`](https://orientdb.com/docs/last/PyOrient.html)
    |'
- en: '| [ArangoDB](https://www.arangodb.com) | [`pyArango`](https://github.com/ArangoDB-Community/pyArango)
    |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '| [ArangoDB](https://www.arangodb.com) | [`pyArango`](https://github.com/ArangoDB-Community/pyArango)
    |'
- en: Other NoSQL
  id: totrans-562
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他 NoSQL
- en: The NoSQL servers listed here handle data larger than memory, and many of them
    use multiple computers. [Table 16-9](#nosql_table) presents notable servers and
    their Python libraries.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出的 NoSQL 服务器处理比内存更大的数据，并且许多使用多台计算机。[表 16-9](#nosql_table) 展示了显著的服务器及其 Python
    库。
- en: Table 16-9\. NoSQL databases
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 表 16-9\. NoSQL 数据库
- en: '| Database | Python API |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '| 数据库 | Python API |'
- en: '| --- | --- |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [Cassandra](http://cassandra.apache.org) | [`pycassa`](https://github.com/pycassa/pycassa)
    |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
  zh: '| [Cassandra](http://cassandra.apache.org) | [`pycassa`](https://github.com/pycassa/pycassa)
    |'
- en: '| [CouchDB](http://couchdb.apache.org) | [`couchdb-python`](https://github.com/djc/couchdb-python)
    |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '| [CouchDB](http://couchdb.apache.org) | [`couchdb-python`](https://github.com/djc/couchdb-python)
    |'
- en: '| [HBase](http://hbase.apache.org) | [`happybase`](https://github.com/wbolster/happybase)
    |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
  zh: '| [HBase](http://hbase.apache.org) | [`happybase`](https://github.com/wbolster/happybase)
    |'
- en: '| [Kyoto Cabinet](http://fallabs.com/kyotocabinet) | [`kyotocabinet`](http://bit.ly/kyotocabinet)
    |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
  zh: '| [Kyoto Cabinet](http://fallabs.com/kyotocabinet) | [`kyotocabinet`](http://bit.ly/kyotocabinet)
    |'
- en: '| [MongoDB](http://www.mongodb.org) | [`mongodb`](http://api.mongodb.org/python/current)
    |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
  zh: '| [MongoDB](http://www.mongodb.org) | [`mongodb`](http://api.mongodb.org/python/current)
    |'
- en: '| [Pilosa](https://www.pilosa.com) | [`python-pilosa`](https://github.com/pilosa/python-pilosa)
    |'
  id: totrans-572
  prefs: []
  type: TYPE_TB
  zh: '| [Pilosa](https://www.pilosa.com) | [`python-pilosa`](https://github.com/pilosa/python-pilosa)
    |'
- en: '| [Riak](http://basho.com/riak) | [`riak-python-client`](https://github.com/basho/riak-python-client)
    |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
  zh: '| [Riak](http://basho.com/riak) | [`riak-python-client`](https://github.com/basho/riak-python-client)
    |'
- en: Full-Text Databases
  id: totrans-574
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全文搜索数据库
- en: Finally, there’s a special category of databases for *full-text* search. They
    index everything, so you can find that poem that talks about windmills and giant
    wheels of cheese. You can see some popular open source examples along with their
    Python APIs in [Table 16-10](#full_text_table).
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有一个专门用于 *全文* 搜索的数据库类别。它们索引所有内容，因此您可以找到那些讲述风车和巨大芝士轮的诗歌。您可以在 [表 16-10](#full_text_table)
    中看到一些流行的开源示例及其 Python API。
- en: Table 16-10\. Full-text databases
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 表 16-10\. 全文搜索数据库
- en: '| Site | Python API |'
  id: totrans-577
  prefs: []
  type: TYPE_TB
  zh: '| 网站 | Python API |'
- en: '| --- | --- |'
  id: totrans-578
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [Lucene](http://lucene.apache.org) | [`pylucene`](http://lucene.apache.org/pylucene)
    |'
  id: totrans-579
  prefs: []
  type: TYPE_TB
  zh: '| [Lucene](http://lucene.apache.org) | [`pylucene`](http://lucene.apache.org/pylucene)
    |'
- en: '| [Solr](http://lucene.apache.org/solr) | [`SolPython`](http://wiki.apache.org/solr/SolPython)
    |'
  id: totrans-580
  prefs: []
  type: TYPE_TB
  zh: '| [Solr](http://lucene.apache.org/solr) | [`SolPython`](http://wiki.apache.org/solr/SolPython)
    |'
- en: '| [ElasticSearch](http://www.elasticsearch.org) | [`elasticsearch`](https://elasticsearch-py.readthedocs.io)
    |'
  id: totrans-581
  prefs: []
  type: TYPE_TB
  zh: '| [ElasticSearch](http://www.elasticsearch.org) | [`elasticsearch`](https://elasticsearch-py.readthedocs.io)
    |'
- en: '| [Sphinx](http://sphinxsearch.com) | [`sphinxapi`](http://bit.ly/sphinxapi)
    |'
  id: totrans-582
  prefs: []
  type: TYPE_TB
  zh: '| [Sphinx](http://sphinxsearch.com) | [`sphinxapi`](http://bit.ly/sphinxapi)
    |'
- en: '| [Xapian](http://xapian.org) | [`xappy`](https://code.google.com/p/xappy)
    |'
  id: totrans-583
  prefs: []
  type: TYPE_TB
  zh: '| [Xapian](http://xapian.org) | [`xappy`](https://code.google.com/p/xappy)
    |'
- en: '| [Whoosh](http://bit.ly/mchaput-whoosh) | (written in Python, includes an
    API) |'
  id: totrans-584
  prefs: []
  type: TYPE_TB
  zh: '| [Whoosh](http://bit.ly/mchaput-whoosh) | （用 Python 编写，包含 API） |'
- en: Coming Up
  id: totrans-585
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即将出现
- en: The previous chapter was about interleaving code in time (*concurrency*). The
    next one is about moving data through space (*networking*), which can be used
    for concurrency and other reasons.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章讨论了在时间上交错使用代码（*并发*）。接下来的章节将介绍如何在空间中移动数据（*网络*），这不仅可以用于并发，还有其他用途。
- en: Things to Do
  id: totrans-587
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 待办事项
- en: '16.1 Save the following text lines to a file called *books.csv* (notice that
    if the fields are separated by commas, you need to surround a field with quotes
    if it contains a comma):'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 16.1 将以下文本行保存到名为 *books.csv* 的文件中（注意，如果字段由逗号分隔，如果字段包含逗号，你需要用引号括起来）：
- en: '[PRE118]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 16.2 Use the `csv` module and its `DictReader` method to read *books.csv* to
    the variable `books`. Print the values in `books`. Did `DictReader` handle the
    quotes and commas in the second book’s title?
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 16.2 使用 `csv` 模块及其 `DictReader` 方法读取 *books.csv* 并存入变量 `books`。打印 `books` 中的值。`DictReader`
    是否处理了第二本书标题中的引号和逗号？
- en: '16.3 Create a CSV file called *books2.csv* by using these lines:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 16.3 使用以下代码创建一个名为 *books2.csv* 的 CSV 文件：
- en: '[PRE119]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '16.4 Use the `sqlite3` module to create a SQLite database called *books.db*
    and a table called `books` with these fields: `title` (text), `author` (text),
    and `year` (integer).'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 16.4 使用 `sqlite3` 模块创建一个名为 *books.db* 的 SQLite 数据库，并创建一个名为 `books` 的表，具有以下字段：`title`（文本）、`author`（文本）和
    `year`（整数）。
- en: 16.5 Read *books2.csv* and insert its data into the `book` table.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 16.5 读取 *books2.csv* 并将其数据插入到 `book` 表中。
- en: 16.6 Select and print the `title` column from the `book` table in alphabetical
    order.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 16.6 按字母顺序选择并打印 `book` 表中的 `title` 列。
- en: 16.7 Select and print all columns from the `book` table in order of publication.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 16.7 按照出版顺序选择并打印 `book` 表中的所有列。
- en: 16.8 Use the `sqlalchemy` module to connect to the sqlite3 database *books.db*
    that you just made in exercise 16.4. As in 16.6, select and print the `title`
    column from the `book` table in alphabetical order.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 16.8 使用 `sqlalchemy` 模块连接到你在练习 16.4 中刚刚创建的 sqlite3 数据库 *books.db*。如同 16.6，按字母顺序选择并打印
    `book` 表中的 `title` 列。
- en: 16.9 Install the Redis server and the Python `redis` library (`pip install redis`)
    on your computer. Create a Redis hash called `test` with the fields `count` (`1`)
    and `name` (`'Fester Bestertester'`). Print all the fields for `test`.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 16.9 在你的计算机上安装 Redis 服务器和 Python `redis` 库（`pip install redis`）。创建一个名为 `test`
    的 Redis 哈希，具有字段 `count`（`1`）和 `name`（`'Fester Bestertester'`）。打印 `test` 的所有字段。
- en: 16.10 Increment the `count` field of `test` and print it.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 16.10 增加 `test` 的 `count` 字段并打印它。
- en: ^([1](ch16.html#idm45794977436440-marker)) Alas, not XML yet.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch16.html#idm45794977436440-marker)) 啊，还没到 XML 的时候。
