- en: 9\. Lists#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9\. 列表#
- en: 原文：[https://allendowney.github.io/ThinkPython/chap09.html](https://allendowney.github.io/ThinkPython/chap09.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://allendowney.github.io/ThinkPython/chap09.html](https://allendowney.github.io/ThinkPython/chap09.html)
- en: This chapter presents one of Python’s most useful built-in types, lists. You
    will also learn more about objects and what can happen when multiple variables
    refer to the same object.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Python最有用的内建类型之一——列表。你还将学习更多关于对象的知识，以及当多个变量指向同一对象时会发生什么。
- en: In the exercises at the end of the chapter, we’ll make a word list and use it
    to search for special words like palindromes and anagrams.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末的练习中，我们将创建一个单词列表，并用它来查找特殊单词，如回文和变位词。
- en: 9.1\. A list is a sequence[#](#a-list-is-a-sequence "Link to this heading")
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.1\. 列表是一个序列[#](#a-list-is-a-sequence "Link to this heading")
- en: Like a string, a **list** is a sequence of values. In a string, the values are
    characters; in a list, they can be any type. The values in a list are called **elements**.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 像字符串一样，**列表**是值的序列。在字符串中，值是字符；在列表中，它们可以是任何类型。列表中的值称为**元素**。
- en: There are several ways to create a new list; the simplest is to enclose the
    elements in square brackets (`[` and `]`). For example, here is a list of two
    integers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以创建一个新列表；最简单的方法是将元素括在方括号(`[`和`]`)中。例如，这是一个包含两个整数的列表。
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: And here’s a list of three strings.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个包含三个字符串的列表。
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The elements of a list don’t have to be the same type. The following list contains
    a string, a float, an integer, and even another list.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的元素不必是相同的类型。以下列表包含了一个字符串，一个浮点数，一个整数，甚至另一个列表。
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A list within another list is **nested**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含在另一个列表中的列表被称为**嵌套**列表。
- en: A list that contains no elements is called an empty list; you can create one
    with empty brackets, `[]`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不包含任何元素的列表被称为空列表；你可以用空括号`[]`来创建一个空列表。
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `len` function returns the length of a list.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`len`函数返回列表的长度。'
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The length of an empty list is `0`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 空列表的长度是`0`。
- en: The following figure shows the state diagram for `cheeses`, `numbers` and `empty`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了`cheeses`、`numbers`和`empty`的状态图。
- en: '![_images/957063a97a11b84c82fcc4b0a736a796b5d1a3da6dc4f71db1409a9e25d1a570.png](../Images/7a76c4015360d2c859efe99a405dc889.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![_images/957063a97a11b84c82fcc4b0a736a796b5d1a3da6dc4f71db1409a9e25d1a570.png](../Images/7a76c4015360d2c859efe99a405dc889.png)'
- en: Lists are represented by boxes with the word “list” outside and the numbered
    elements of the list inside.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表用带有“list”字样的盒子表示，列表的编号元素位于其中。
- en: 9.2\. Lists are mutable[#](#lists-are-mutable "Link to this heading")
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.2\. 列表是可变的[#](#lists-are-mutable "Link to this heading")
- en: To read an element of a list, we can use the bracket operator. The index of
    the first element is `0`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取列表的一个元素，我们可以使用括号运算符。第一个元素的索引是`0`。
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Unlike strings, lists are mutable. When the bracket operator appears on the
    left side of an assignment, it identifies the element of the list that will be
    assigned.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与字符串不同，列表是可变的。当括号运算符出现在赋值语句的左侧时，它标识了将被赋值的列表元素。
- en: '[PRE8]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The second element of `numbers`, which used to be `123`, is now `17`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`numbers`的第二个元素，原本是`123`，现在是`17`。'
- en: 'List indices work the same way as string indices:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 列表索引的工作方式与字符串索引相同：
- en: Any integer expression can be used as an index.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何整数表达式都可以用作索引。
- en: If you try to read or write an element that does not exist, you get an `IndexError`.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你尝试读取或写入一个不存在的元素，将会出现`IndexError`。
- en: If an index has a negative value, it counts backward from the end of the list.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果索引是负值，它从列表的末尾开始倒数。
- en: The `in` operator works on lists – it checks whether a given element appears
    anywhere in the list.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`in`运算符作用于列表——它检查给定的元素是否出现在列表中的任何位置。'
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Although a list can contain another list, the nested list still counts as a
    single element – so in the following list, there are only four elements.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一个列表可以包含另一个列表，但嵌套的列表仍然被视为一个元素——因此，在以下列表中，只有四个元素。
- en: '[PRE14]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And `10` is not considered to be an element of `t` because it is an element
    of a nested list, not `t`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 而`10`不被视为`t`的一个元素，因为它是嵌套列表中的一个元素，而不是`t`的元素。
- en: '[PRE16]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 9.3\. List slices[#](#list-slices "Link to this heading")
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.3\. 列表切片[#](#list-slices "Link to this heading")
- en: The slice operator works on lists the same way it works on strings. The following
    example selects the second and third elements from a list of four letters.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 切片运算符作用于列表的方式与它在字符串上作用的方式相同。以下示例选择了四个字母列表中的第二和第三个元素。
- en: '[PRE18]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you omit the first index, the slice starts at the beginning.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略第一个索引，切片将从列表的开头开始。
- en: '[PRE20]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you omit the second, the slice goes to the end.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略第二个索引，切片将延伸到列表的末尾。
- en: '[PRE22]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So if you omit both, the slice is a copy of the whole list.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略两个索引，切片将是整个列表的副本。
- en: '[PRE24]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Another way to copy a list is to use the `list` function.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 复制列表的另一种方式是使用 `list` 函数。
- en: '[PRE26]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Because `list` is the name of a built-in function, you should avoid using it
    as a variable name.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `list` 是一个内置函数的名称，你应该避免将它用作变量名。
- en: 9.4\. List operations[#](#list-operations "Link to this heading")
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.4\. 列表操作[#](#list-operations "链接到此标题")
- en: The `+` operator concatenates lists.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`+` 运算符用于连接列表。'
- en: '[PRE28]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `*` operator repeats a list a given number of times.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`*` 运算符会将列表重复给定的次数。'
- en: '[PRE30]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: No other mathematical operators work with lists, but the built-in function `sum`
    adds up the elements.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 没有其他数学运算符可以与列表一起使用，但内置函数 `sum` 会将元素相加。
- en: '[PRE32]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: And `min` and `max` find the smallest and largest elements.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`min` 和 `max` 用于找到最小和最大元素。'
- en: '[PRE34]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 9.5\. List methods[#](#list-methods "Link to this heading")
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.5\. 列表方法[#](#list-methods "链接到此标题")
- en: 'Python provides methods that operate on lists. For example, `append` adds a
    new element to the end of a list:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了对列表操作的方法。例如，`append` 会将一个新元素添加到列表的末尾：
- en: '[PRE38]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`extend` takes a list as an argument and appends all of the elements:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`extend` 接受一个列表作为参数，并将其中的所有元素附加到当前列表中：'
- en: '[PRE40]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There are two methods that remove elements from a list. If you know the index
    of the element you want, you can use `pop`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以从列表中删除元素。如果你知道要删除元素的索引，可以使用 `pop`。
- en: '[PRE42]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The return value is the element that was removed. And we can confirm that the
    list has been modified.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值是被删除的元素。我们也可以确认列表已经被修改。
- en: '[PRE44]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you know the element you want to remove (but not the index), you can use
    `remove`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道要删除的元素（但不知道索引），可以使用 `remove`：
- en: '[PRE46]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The return value from `remove` is `None`. But we can confirm that the list has
    been modified.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove` 的返回值是 `None`，但我们可以确认列表已经被修改。'
- en: '[PRE47]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If the element you ask for is not in the list, that’s a ValueError.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你请求的元素不在列表中，那就会抛出 ValueError 错误。
- en: '[PRE49]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 9.6\. Lists and strings[#](#lists-and-strings "Link to this heading")
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.6\. 列表和字符串[#](#lists-and-strings "链接到此标题")
- en: A string is a sequence of characters and a list is a sequence of values, but
    a list of characters is not the same as a string. To convert from a string to
    a list of characters, you can use the `list` function.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是字符的序列，而列表是值的序列，但字符列表和字符串并不相同。要将字符串转换为字符列表，可以使用 `list` 函数。
- en: '[PRE51]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `list` function breaks a string into individual letters. If you want to
    break a string into words, you can use the `split` method:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`list` 函数将字符串拆分为单独的字母。如果你想将字符串拆分为单词，可以使用 `split` 方法：'
- en: '[PRE53]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: An optional argument called a **delimiter** specifies which characters to use
    as word boundaries. The following example uses a hyphen as a delimiter.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可选参数叫做**分隔符**，用于指定哪些字符作为单词边界。以下示例使用了连字符作为分隔符。
- en: '[PRE55]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If you have a list of strings, you can concatenate them into a single string
    using `join`. `join` is a string method, so you have to invoke it on the delimiter
    and pass the list as an argument.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个字符串列表，可以使用 `join` 将它们连接成一个单一的字符串。`join` 是一个字符串方法，因此你需要在分隔符上调用它，并将列表作为参数传递。
- en: '[PRE57]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this case the delimiter is a space character, so `join` puts a space between
    words. To join strings without spaces, you can use the empty string, `''`, as
    a delimiter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，分隔符是空格字符，所以 `join` 会在单词之间加上空格。要将字符串连接在一起而不添加空格，可以使用空字符串 `''` 作为分隔符。
- en: 9.7\. Looping through a list[#](#looping-through-a-list "Link to this heading")
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.7\. 遍历列表[#](#looping-through-a-list "链接到此标题")
- en: You can use a `for` statement to loop through the elements of a list.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `for` 语句遍历列表中的元素。
- en: '[PRE59]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: For example, after using `split` to make a list of words, we can use `for` to
    loop through them.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用 `split` 将字符串分割成单词列表后，我们可以使用 `for` 遍历它们。
- en: '[PRE61]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: A `for` loop over an empty list never runs the indented statements.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对一个空列表进行 `for` 循环时，缩进的语句永远不会执行。
- en: '[PRE63]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 9.8\. Sorting lists[#](#sorting-lists "Link to this heading")
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.8\. 排序列表[#](#sorting-lists "链接到此标题")
- en: Python provides a built-in function called `sorted` that sorts the elements
    of a list.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了一个内置函数 `sorted`，用于对列表的元素进行排序。
- en: '[PRE64]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The original list is unchanged.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 原始列表保持不变。
- en: '[PRE66]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '`sorted` works with any kind of sequence, not just lists. So we can sort the
    letters in a string like this.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted` 可以与任何类型的序列一起使用，不仅限于列表。所以我们可以像这样对字符串中的字母进行排序。'
- en: '[PRE68]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The result is a list. To convert the list to a string, we can use `join`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个列表。要将列表转换为字符串，我们可以使用 `join`。
- en: '[PRE70]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: With an empty string as the delimiter, the elements of the list are joined with
    nothing between them.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空字符串作为分隔符时，列表中的元素将被连接在一起，中间没有任何分隔符。
- en: 9.9\. Objects and values[#](#objects-and-values "Link to this heading")
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.9\. 对象和值[#](#objects-and-values "链接到此标题")
- en: 'If we run these assignment statements:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这些赋值语句：
- en: '[PRE72]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We know that `a` and `b` both refer to a string, but we don’t know whether they
    refer to the *same* string. There are two possible states, shown in the following
    figure.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 `a` 和 `b` 都指向一个字符串，但我们不知道它们是否指向*同一个*字符串。有两种可能的状态，如下图所示。
- en: '![_images/2e5ee2dabd4af114f59b1130cfa488eb144238c577461e791df9db8984a2de95.png](../Images/d47075b35980a553f7e01bc56e1e6c1f.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![_images/2e5ee2dabd4af114f59b1130cfa488eb144238c577461e791df9db8984a2de95.png](../Images/d47075b35980a553f7e01bc56e1e6c1f.png)'
- en: In the diagram on the left, `a` and `b` refer to two different objects that
    have the same value. In the diagram on the right, they refer to the same object.
    To check whether two variables refer to the same object, you can use the `is`
    operator.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧的图表中，`a` 和 `b` 引用两个具有相同值的不同对象。在右侧的图表中，它们引用同一个对象。要检查两个变量是否引用同一个对象，可以使用 `is`
    运算符。
- en: '[PRE73]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In this example, Python only created one string object, and both `a` and `b`
    refer to it. But when you create two lists, you get two objects.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，Python 只创建了一个字符串对象，`a` 和 `b` 都引用它。但是当你创建两个列表时，你得到两个对象。
- en: '[PRE75]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: So the state diagram looks like this.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所以状态图看起来是这样的。
- en: '![_images/c8cfa39ca5b7bb5dc02b5731f4e053972e409045852e63845c82d4f14657fb77.png](../Images/32a99d0796e7c6eb18f5b3038069d04e.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![_images/c8cfa39ca5b7bb5dc02b5731f4e053972e409045852e63845c82d4f14657fb77.png](../Images/32a99d0796e7c6eb18f5b3038069d04e.png)'
- en: In this case we would say that the two lists are **equivalent**, because they
    have the same elements, but not **identical**, because they are not the same object.
    If two objects are identical, they are also equivalent, but if they are equivalent,
    they are not necessarily identical.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们会说这两个列表是**等价**的，因为它们有相同的元素，但不是**相同**的，因为它们不是同一个对象。如果两个对象是相同的，则它们也是等价的，但如果它们是等价的，则它们不一定是相同的。
- en: 9.10\. Aliasing[#](#aliasing "Link to this heading")
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.10\. 别名[#](#aliasing "Link to this heading")
- en: If `a` refers to an object and you assign `b = a`, then both variables refer
    to the same object.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `a` 引用一个对象，然后你赋值 `b = a`，那么两个变量都引用同一个对象。
- en: '[PRE77]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: So the state diagram looks like this.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 所以状态图看起来是这样的。
- en: '![_images/bdf2f2d164766afae1abfc341924bf22fd6235f7db44edc4d5ab322d1a5323a1.png](../Images/90be22db2df1a3c8bf4e0ef5ba93a2a5.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![_images/bdf2f2d164766afae1abfc341924bf22fd6235f7db44edc4d5ab322d1a5323a1.png](../Images/90be22db2df1a3c8bf4e0ef5ba93a2a5.png)'
- en: The association of a variable with an object is called a **reference**. In this
    example, there are two references to the same object.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将变量与对象的关联称为**引用**。在这个例子中，有两个对同一对象的引用。
- en: An object with more than one reference has more than one name, so we say the
    object is **aliased**. If the aliased object is mutable, changes made with one
    name affect the other. In this example, if we change the object `b` refers to,
    we are also changing the object `a` refers to.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有多个引用的对象有多个名称，因此我们说对象是**别名**的。如果别名对象是可变的，则使用一个名称进行更改会影响到另一个名称。在这个例子中，如果我们更改
    `b` 所引用的对象，也会更改 `a` 所引用的对象。
- en: '[PRE79]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: So we would say that `a` “sees” this change. Although this behavior can be useful,
    it is error-prone. In general, it is safer to avoid aliasing when you are working
    with mutable objects.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因此我们会说 `a` “看到”了这个变化。虽然这种行为可能很有用，但也容易出错。一般来说，在处理可变对象时最好避免使用别名。
- en: 'For immutable objects like strings, aliasing is not as much of a problem. In
    this example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像字符串这样的不可变对象，别名不是太大的问题。在这个例子中：
- en: '[PRE81]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: It almost never makes a difference whether `a` and `b` refer to the same string
    or not.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 是否 `a` 和 `b` 引用同一个字符串几乎没有影响。
- en: 9.11\. List arguments[#](#list-arguments "Link to this heading")
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.11\. 列表参数[#](#list-arguments "Link to this heading")
- en: When you pass a list to a function, the function gets a reference to the list.
    If the function modifies the list, the caller sees the change. For example, `pop_first`
    uses the list method `pop` to remove the first element from a list.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将列表传递给函数时，函数会得到对列表的引用。如果函数修改了列表，则调用者会看到更改。例如，`pop_first` 使用列表方法 `pop` 来删除列表中的第一个元素。
- en: '[PRE82]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: We can use it like this.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用它。
- en: '[PRE83]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The return value is the first element, which has been removed from the list
    – as we can see by displaying the modified list.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值是已从列表中删除的第一个元素，我们可以通过显示修改后的列表来看到。
- en: '[PRE85]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'In this example, the parameter `lst` and the variable `letters` are aliases
    for the same object, so the state diagram looks like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，参数 `lst` 和变量 `letters` 是同一个对象的别名，所以状态图看起来是这样的：
- en: '[PRE87]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '![_images/afbc48196f8175d6ba5fc8d3b6406623158939478a7457ea70ae7c0aab651eb8.png](../Images/7f7d1aba33d53ebfe1703790b81777d2.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![_images/afbc48196f8175d6ba5fc8d3b6406623158939478a7457ea70ae7c0aab651eb8.png](../Images/7f7d1aba33d53ebfe1703790b81777d2.png)'
- en: Passing a reference to an object as an argument to a function creates a form
    of aliasing. If the function modifies the object, those changes persist after
    the function is done.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象的引用作为参数传递给函数会创建一种别名形式。如果函数修改了该对象，这些更改将在函数结束后持续存在。
- en: '## 9.12\. Making a word list[#](#making-a-word-list "Link to this heading")'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '## 9.12\. 创建单词列表[#](#making-a-word-list "Link to this heading")'
- en: In the previous chapter, we read the file `words.txt` and searched for words
    with certain properties, like using the letter `e`. But we read the entire file
    many times, which is not efficient. It is better to read the file once and put
    the words in a list. The following loop shows how.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们读取了 `words.txt` 文件并搜索了具有特定属性的单词，比如使用字母 `e`。但是我们多次读取整个文件，这样效率不高。更好的做法是只读取一次文件，并将单词存入列表。以下循环展示了如何操作。
- en: '[PRE88]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Before the loop, `word_list` is initialized with an empty list. Each time through
    the loop, the `append` method adds a word to the end. When the loop is done, there
    are more than 113,000 words in the list.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环之前，`word_list` 被初始化为空列表。每次循环时，`append` 方法会将一个单词添加到列表末尾。当循环结束时，列表中有超过 113,000
    个单词。
- en: Another way to do the same thing is to use `read` to read the entire file into
    a string.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种做法是使用 `read` 将整个文件读取为一个字符串。
- en: '[PRE90]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The result is a single string with more than a million characters. We can use
    the `split` method to split it into a list of words.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个包含超过百万个字符的单一字符串。我们可以使用 `split` 方法将其拆分为一个单词列表。
- en: '[PRE92]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Now, to check whether a string appears in the list, we can use the `in` operator.
    For example, `'demotic'` is in the list.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了检查一个字符串是否出现在列表中，我们可以使用 `in` 运算符。例如，`'demotic'` 在列表中。
- en: '[PRE94]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: But `'contrafibularities'` is not.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`'contrafibularities'` 不是。
- en: '[PRE96]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: And I have to say, I’m anaspeptic about it.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我得说，我对它感到有点麻木。
- en: 9.13\. Debugging[#](#debugging "Link to this heading")
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.13\. 调试[#](#debugging "Link to this heading")
- en: Note that most list methods modify the argument and return `None`. This is the
    opposite of the string methods, which return a new string and leave the original
    alone.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，大多数列表方法修改参数并返回 `None`。这与字符串方法相反，后者返回一个新字符串，并且不修改原始字符串。
- en: 'If you are used to writing string code like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯于编写像这样的字符串代码：
- en: '[PRE98]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'It is tempting to write list code like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易写出像这样的列表代码：
- en: '[PRE100]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '`remove` modifies the list and returns `None`, so next operation you perform
    with `t` is likely to fail.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove` 修改列表并返回 `None`，因此你接下来在 `t` 上执行的操作可能会失败。'
- en: '[PRE101]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This error message takes some explaining. An **attribute** of an object is a
    variable or method associated with it. In this case, the value of `t` is `None`,
    which is a `NoneType` object, which does not have a attribute named `remove`,
    so the result is an `AttributeError`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误信息需要一些解释。一个**属性**是与对象关联的变量或方法。在这个案例中，`t` 的值是 `None`，它是一个 `NoneType` 对象，并没有一个名为
    `remove` 的属性，因此结果是 `AttributeError`。
- en: If you see an error message like this, you should look backward through the
    program and see if you might have called a list method incorrectly.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到这样的错误信息，应该向后检查程序，看看你是否错误地调用了列表方法。
- en: 9.14\. Glossary[#](#glossary "Link to this heading")
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.14\. 术语表[#](#glossary "Link to this heading")
- en: '**list:** An object that contains a sequence of values.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表:** 一种包含一系列值的对象。'
- en: '**element:** One of the values in a list or other sequence.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**元素:** 列表或其他序列中的一个值。'
- en: '**nested list:** A list that is an element of another list.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**嵌套列表:** 作为另一个列表的元素的列表。'
- en: '**delimiter:** A character or string used to indicate where a string should
    be split.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**分隔符:** 用于指示字符串应该在哪儿拆分的字符或字符串。'
- en: '**equivalent:** Having the same value.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**等价的:** 具有相同的值。'
- en: '**identical:** Being the same object (which implies equivalence).'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**相同的:** 是指相同的对象（这意味着等价性）。'
- en: '**reference:** The association between a variable and its value.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**引用:** 变量与其值之间的关联。'
- en: '**aliased:** If there is more than one variable that refers to an object, the
    object is aliased.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**别名化:** 如果有多个变量引用同一个对象，那么这个对象就是别名化的。'
- en: '**attribute:** One of the named values associated with an object.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性:** 与对象关联的命名值之一。'
- en: 9.15\. Exercises[#](#exercises "Link to this heading")
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 9.15\. 练习[#](#exercises "Link to this heading")
- en: '[PRE103]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 9.15.1\. Ask a virtual assistant[#](#ask-a-virtual-assistant "Link to this heading")
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.15.1\. 向虚拟助手提问[#](#ask-a-virtual-assistant "Link to this heading")
- en: In this chapter, I used the words “contrafibularities” and “anaspeptic”, but
    they are not actually English words. They were used in the British television
    show *Black Adder*, Season 3, Episode 2, “Ink and Incapability”.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我使用了“contrafibularities”和“anaspeptic”这两个词，但它们实际上并不是英语单词。它们出现在英国电视节目*黑爵士*第3季第2集“墨水与无能”中。
- en: However, when I asked ChatGPT 3.5 (August 3, 2023 version) where those words
    came from, it initially claimed they are from Monty Python, and later claimed
    they are from the Tom Stoppard play *Rosencrantz and Guildenstern Are Dead*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我询问ChatGPT 3.5（2023年8月3日版本）这些单词的来源时，它最初声称这些单词来自《蒙提·派森》，后来又声称它们来自汤姆·斯托帕德的剧作*《罗斯恩·克兰茨与吉尔登斯特恩死了》*。
- en: If you ask now, you might get different results. But this example is a reminder
    that virtual assistants are not always accurate, so you should check whether the
    results are correct. As you gain experience, you will get a sense of which questions
    virtual assistants can answer reliably. In this example, a conventional web search
    can identify the source of these words quickly.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在提问，你可能会得到不同的结果。但这个例子提醒我们，虚拟助手并不总是准确的，因此你应该检查结果是否正确。随着经验的积累，你会对哪些问题虚拟助手能够可靠回答有一个直觉。在这个例子中，常规的网络搜索可以迅速识别这些单词的来源。
- en: If you get stuck on any of the exercises in this chapter, consider asking a
    virtual assistant for help. If you get a result that uses features we haven’t
    learned yet, you can assign the VA a “role”.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在本章的任何练习中遇到困难，可以考虑向虚拟助手寻求帮助。如果你得到的结果使用了我们还没有学过的功能，你可以为虚拟助手分配一个“角色”。
- en: 'For example, before you ask a question try typing “Role: Basic Python Programming
    Instructor”. After that, the responses you get should use only basic features.
    If you still see features we you haven’t learned, you can follow up with “Can
    you write that using only basic Python features?”'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，在你提问之前，尝试输入“Role: Basic Python Programming Instructor”。之后，你得到的回答应该仅使用基本功能。如果你仍然看到我们还没有学过的功能，你可以跟进询问：“能否只用基本的Python功能编写那个？”'
- en: 9.15.2\. Exercise[#](#exercise "Link to this heading")
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.15.2\. 练习[#](#exercise "链接到此标题")
- en: Two words are anagrams if you can rearrange the letters from one to spell the
    other. For example, `tops` is an anagram of `stop`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个单词的字母可以重新排列使其拼写为另一个单词，则这两个单词是字谜。例如，`tops`是`stop`的字谜。
- en: One way to check whether two words are anagrams is to sort the letters in both
    words. If the lists of sorted letters are the same, the words are anagrams.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 检查两个单词是否是字谜的一种方法是将两个单词中的字母排序。如果排序后的字母列表相同，则这两个单词是字谜。
- en: Write a function called `is_anagram` that takes two strings and returns `True`
    if they are anagrams.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为`is_anagram`的函数，该函数接受两个字符串，并返回`True`（如果它们是字谜）或`False`（如果它们不是字谜）。
- en: Using your function and the word list, find all the anagrams of `takes`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你的函数和单词列表，找到`takes`的所有字谜。
- en: 9.15.3\. Exercise[#](#id1 "Link to this heading")
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.15.3\. 练习[#](#id1 "链接到此标题")
- en: Python provides a built-in function called `reversed` that takes as an argument
    a sequence of elements – like a list or string – and returns a `reversed` object
    that contains the elements in reverse order.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一个名为`reversed`的内置函数，它接受一个序列（如列表或字符串）作为参数，并返回一个`reversed`对象，其中包含按相反顺序排列的元素。
- en: '[PRE104]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: If you want the reversed elements in a list, you can use the `list` function.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望反转的元素以列表形式返回，可以使用`list`函数。
- en: '[PRE106]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Or if you want them in a string, you can use the `join` method.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你希望它们以字符串形式呈现，可以使用`join`方法。
- en: '[PRE108]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: So we can write a function that reverses a word like this.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们可以这样编写一个函数来反转一个单词。
- en: '[PRE110]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: A palindrome is a word that is spelled the same backward and forward, like “noon”
    and “rotator”. Write a function called `is_palindrome` that takes a string argument
    and returns `True` if it is a palindrome and `False` otherwise.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 回文是指正着读和反着读都一样的单词，如“noon”和“rotator”。编写一个名为`is_palindrome`的函数，该函数接受一个字符串作为参数，如果它是回文，返回`True`，否则返回`False`。
- en: You can use the following loop to find all of the palindromes in the word list
    with at least 7 letters.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下循环查找单词列表中至少包含7个字母的所有回文。
- en: '[PRE111]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 9.15.4\. Exercise[#](#id2 "Link to this heading")
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.15.4\. 练习[#](#id2 "链接到此标题")
- en: Write a function called `reverse_sentence` that takes as an argument a string
    that contains any number of words separated by spaces. It should return a new
    string that contains the same words in reverse order. For example, if the argument
    is “Reverse this sentence”, the result should be “Sentence this reverse”.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为`reverse_sentence`的函数，该函数接受一个字符串作为参数，该字符串包含由空格分隔的若干单词。它应该返回一个新的字符串，其中包含按相反顺序排列的单词。例如，如果参数是“Reverse
    this sentence”，结果应该是“Sentence this reverse”。
- en: 'Hint: You can use the `capitalize` methods to capitalize the first word and
    convert the other words to lowercase.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：你可以使用`capitalize`方法将第一个单词首字母大写，并将其他单词转换为小写。
- en: 9.15.5\. Exercise[#](#id3 "Link to this heading")
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.15.5\. 练习[#](#id3 "链接到此标题")
- en: Write a function called `total_length` that takes a list of strings and returns
    the total length of the strings. The total length of the words in `word_list`
    should be \(902{,}728\).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为`total_length`的函数，接受一个字符串列表，并返回这些字符串的总长度。`word_list`中单词的总长度应该是\(902{,}728\)。
- en: '[Think Python: 3rd Edition](https://allendowney.github.io/ThinkPython/index.html)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[《思考 Python：第三版》](https://allendowney.github.io/ThinkPython/index.html)'
- en: Copyright 2024 [Allen B. Downey](https://allendowney.com)
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 版权所有 2024 [Allen B. Downey](https://allendowney.com)
- en: 'Code license: [MIT License](https://mit-license.org/)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 代码许可证：[MIT 许可证](https://mit-license.org/)
- en: 'Text license: [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 文本许可证：[创意共享署名-非商业性使用-相同方式共享 4.0 国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/)
