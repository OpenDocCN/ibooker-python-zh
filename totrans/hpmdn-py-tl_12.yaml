- en: Chapter 9\. Linting with Ruff and pre-commit
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章。使用 Ruff 和 pre-commit 进行代码检查
- en: 'In 1978, Stephen C. Johnson, a researcher at Bell Labs, wrote a program that
    could detect a number of bugs and obscurities in C code. He named the program
    after the fluff on your pullover when you take it out of the washing machine:
    Lint. It was to become the first in a long line of *linters*, programs that analyze
    source code and point out problematic constructs.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 1978 年，贝尔实验室的研究员 Stephen C. Johnson 编写了一个程序，可以检测 C 代码中的许多错误和模糊之处。他将该程序命名为您从洗衣机中取出毛衣时的绒毛：Lint。它成为一系列
    *linters* 的第一个，这些程序分析源代码并指出问题构造。
- en: Linters don’t *run* a program to discover issues with it; they read and analyze
    its source code. This process is known as *static analysis*, as opposed to *runtime*
    (or *dynamic*) *analysis*. It makes linters both fast and safe—​you needn’t worry
    about side effects, such as requests to production systems. Static checks can
    be smart and also fairly complete—​you needn’t hit the right combination of edge
    cases to dig up a latent bug.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Linters 不会 *运行* 程序来发现问题；它们读取并分析源代码。这个过程被称为 *静态分析*，与 *运行时*（或 *动态*）*分析* 相对。这使得
    linters 既快速又安全 —— 你不必担心副作用，比如对生产系统的请求。静态检查可以很智能，也相当完整 —— 你不必命中边缘情况的正确组合来挖掘潜在的
    bug。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Static analysis is powerful, but you should still write tests for your programs.
    Where static checks use deduction, tests use observation. Linters verify a limited
    set of generic code properties, while tests can validate that a program satisfies
    its requirements.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析很强大，但你仍然应该为你的程序编写测试。静态检查使用推断，而测试使用观察。Linters 验证一组有限的通用代码属性，而测试可以验证程序是否满足其要求。
- en: 'Linters are also great at enforcing a readable and consistent style, with a
    preference for idiomatic and modern constructs over obscure and deprecated syntax.
    Organizations have adopted style guides for years, such as the recommendations
    in [PEP 8](https://peps.python.org/pep-0008/) or the [Google Style Guide for Python](https://google.github.io/styleguide/pyguide.html).
    Linters can function as *executable* style guides: by flagging offending constructs
    automatically, they keep code review focused on the meaning of a change, rather
    than stylistic nitpicks.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Linters 在强制执行可读和一致的风格方面也表现出色，它们更倾向于惯用和现代构造，而不是晦涩和已弃用的语法。组织多年来一直采用风格指南，比如 [PEP
    8](https://peps.python.org/pep-0008/) 中的建议或 [Google Style Guide for Python](https://google.github.io/styleguide/pyguide.html)。Linters
    可以作为 *可执行* 风格指南：通过自动标记违规构造，它们使代码审查专注于更改的含义，而不是风格上的琐碎细节。
- en: 'This chapter has three parts:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为三部分：
- en: The first part introduces the Ruff linter, a Rust implementation of Python linters
    that automatically fixes many of the issues it detects.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一部分介绍了 Ruff linter，这是 Python linters 的 Rust 实现，它可以自动修复检测到的许多问题。
- en: The second part describes pre-commit, a linter framework with Git integration.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二部分描述了 pre-commit，一个与 Git 集成的代码检查框架。
- en: The third part presents the Ruff code formatter, a Rust implementation of the
    Black code style.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三部分介绍了 Ruff 代码格式化程序，这是 Black 代码风格的 Rust 实现。
- en: But first, let’s look at a typical problem that linters help you solve.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们看看 linters 帮你解决的典型问题。
- en: Linting Basics
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查基础知识
- en: The constructs flagged by linters may not be outright illegal. More often, they
    just trigger your spider sense that something might be wrong. Consider the Python
    code in [Example 9-1](#example_linting_mutable_default).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: linters 标记的结构可能不是绝对不合法的。更多情况下，它们只是触发了你的直觉，感觉可能有问题。考虑一下 [Example 9-1](#example_linting_mutable_default)
    中的 Python 代码。
- en: Example 9-1\. Can you spot the problem?
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 9-1。你能发现问题吗？
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you haven’t been bitten by this bug before, you may be surprised to find
    that the function sometimes passes `--force` to the command when it shouldn’t:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前没有遇到过这个 bug，你可能会惊讶地发现这个函数有时会在不应该的时候传递`--force`给命令：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The bug is known as a *mutable argument default*. Python evaluates argument
    defaults when a function is defined, not when you call it. In other words, both
    of your calls used the same list as the default for `args`. The first call appended
    the item `"--force"`, so that item got passed to the second call, as well.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 bug 被称为*可变参数默认值*。Python 在定义函数时计算参数默认值，而不是在调用函数时。换句话说，你的两次调用都使用了相同的列表作为`args`的默认值。第一次调用附加了项目`"--force"`，所以这个项目也传递给了第二次调用。
- en: Linters can detect pitfalls like this, warn you about them, and even fix them
    for you. Let’s use a linter named Ruff on the function—​you’ll hear a lot more
    about it in this chapter. For now, just take note of its error message, which
    identifies the bug:^([1](ch09.html#id311))
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查工具可以检测到这样的陷阱，提醒您并甚至为您修复它们。让我们在这个函数上使用一个名为 Ruff 的代码审查工具——在本章中，您会听到更多关于它的内容。目前，只需注意其错误消息，该消息标识了错误：^([1](ch09.html#id311))
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The Ruff Linter
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruff 代码审查工具
- en: Ruff is a blazingly fast open-source Python linter and code formatter, written
    in the Rust programming language. Ruff’s linter re-implements dozens of Python
    linters—​including many Flake8 plugins, Pylint, Pyupgrade, Bandit, Isort, and
    more.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Ruff 是一个采用 Rust 编程语言编写的极快的开源 Python 代码审查工具和代码格式化程序。Ruff 的代码审查工具重新实现了数十个 Python
    代码审查工具——包括许多 Flake8 插件、Pylint、Pyupgrade、Bandit、Isort 等等。
- en: Astral, the company behind Ruff, also created the Python packaging tool uv (see
    [“Managing Environments with uv”](ch02.html#section_environments_uv)), and they’ve
    assumed the stewardship of Rye, a Python project manager (see [“Managing Packages
    with Rye”](ch03.html#section_packages_rye)). All of these tools are implemented
    in Rust.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Astral 公司，Ruff 的背后，还创建了 Python 打包工具 uv（见 [“使用 uv 管理环境”](ch02.html#section_environments_uv)），他们还承担了
    Rye 的管理工作，这是一个 Python 项目管理器（见 [“使用 Rye 管理软件包”](ch03.html#section_packages_rye)）。所有这些工具都是用
    Rust 实现的。
- en: Tip
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you manage your project with Rye, the Ruff linter and code formatter is available
    under the commands `rye lint` and `rye fmt`, respectively.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 Rye 管理项目，则可以在命令 `rye lint` 和 `rye fmt` 下使用 Ruff 代码审查工具和代码格式化程序，分别。
- en: 'Install Ruff globally with pipx:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pipx 全局安装 Ruff：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: But wait—​how can pipx install a Rust program? The Ruff binary is available
    as a wheel on PyPI, so Python folks like you and me can install it with good old
    pip and pipx. You could even run it with `py -m ruff`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等——pipx 怎么会安装 Rust 程序呢？Ruff 二进制程序作为一个 wheel 文件在 PyPI 上可用，所以像您我这样的 Python 爱好者可以用老
    pip 和 pipx 安装它。您甚至可以用 `py -m ruff` 运行它。
- en: 'Let’s look at another example of working with Ruff. Consider this refactoring
    of HTTP headers, which replaces a list with a dictionary:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个使用 Ruff 的例子。考虑对 HTTP 标头进行的这次重构，将列表替换为字典：
- en: Example 9-2\. Converting a list of HTTP headers to a dictionary
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-2\. 将 HTTP 标头列表转换为字典
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When you refactor f-strings, it’s easy to leave the `f` prefix behind after
    removing placeholders. Ruff flags f-strings without placeholders—​they’re noisy,
    they confuse readers, and somebody might have forgotten to include a placeholder.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当您重构 f-strings 时，很容易在移除占位符后留下 `f` 前缀。Ruff 会标记没有占位符的 f-strings——它们很吵闹，会让读者困惑，也可能有人忘记包含占位符。
- en: 'Run the command `ruff check`—the front-end for Ruff’s linter. Without arguments,
    the command lints every Python file under your current directory, unless it’s
    listed in a *.gitignore* file:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令 `ruff check`——Ruff 代码审查工具的前端。没有参数，该命令会审查当前目录下的每个 Python 文件，除非它在 *.gitignore*
    文件中列出：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[Figure 9-1](#figure_ruff_codes) takes a closer look at Ruff’s diagnostic message.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-1](#figure_ruff_codes) 详细介绍了 Ruff 的诊断消息。'
- en: '![The diagram shows an example warning from Ruff and identifies its parts.
    The first part is the location ''example.py:1:7:'', which consists of a filename,
    line, and column. The second part is the rule code ''F541'', which is composed
    of the linter prefix ''F'' and the numeric code ''541'' for a specific rule of
    that linter. The third part is the sign ''[*]'', which informs you that a fix
    is available. The fourth and last part is the summary ''f-string without any placeholders''.](assets/hmpt_0901.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图中显示了 Ruff 的一个示例警告并标识了其各部分。第一部分是位置 ''example.py:1:7:''，由文件名、行和列组成。第二部分是规则代码
    ''F541''，由代码审查工具前缀 ''F'' 和数字代码 ''541'' 组成，表示该代码审查工具的特定规则。第三部分是符号 ''[*]''，通知您可以使用修复功能。第四部分也是最后一部分是概要
    ''f-string 没有任何占位符''。](assets/hmpt_0901.png)'
- en: Figure 9-1\. A diagnostic message from Ruff
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-1\. Ruff 的诊断消息
- en: 'Ruff tells you where the violation occurred—​the file, line, and line offset—​and
    gives you a short summary of what went wrong: *f-string without any placeholders*.
    Two interesting bits are sandwiched between the location and the summary: An alphanumeric
    code (`F541`) identifies the linter rule, and the sign `[*]` indicates that Ruff
    can automatically fix the issue.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Ruff 会告诉你违规出现的位置——文件、行和行偏移——并简要说明出了什么问题：*f-string 没有任何占位符*。在位置和概要之间夹杂着两个有趣的部分：一个字母数字代码（`F541`）标识了代码审查工具规则，而符号
    `[*]` 表示 Ruff 可以自动修复该问题。
- en: 'If you’re ever confused why you’re getting a warning, you can ask Ruff to explain
    it using the command `ruff rule`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对收到的警告感到困惑，可以使用命令 `ruff rule` 要求 Ruff 解释它：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Rule codes have a prefix of one or more letters, followed by three or more
    digits. The prefix identifies a specific linter—​for example, the `F` in `F541`
    stands for the Pyflakes linter. Ruff re-implements many more Python code-quality
    tools—​as of this writing, it ships over 50 built-in plugins modeled after existing
    tools. You can find out which linters are available using the command `ruff linter`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 规则代码以一个或多个字母开头，后跟三个或更多数字。前缀标识特定的代码检查工具，例如 `F541` 中的 `F` 表示 Pyflakes 检查工具。Ruff
    重新实现了许多 Python 代码质量工具，截至目前，它内置了超过 50 个插件，这些插件模仿了现有工具。你可以使用命令 `ruff linter` 查看可用的检查工具：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can activate linters and individual rules for your project in its *pyproject.toml*
    file. The setting `tool.ruff.lint.select` enables any rules whose code starts
    with one of the given prefixes. Out of the box, Ruff enables some basic all-around
    checks from Pyflakes and Pycodestyle:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 *pyproject.toml* 文件中为项目激活检查工具和单独的规则。设置 `tool.ruff.lint.select` 可以启用任何代码以给定前缀开头的规则。Ruff
    默认启用了一些基本的全面检查，来自 Pyflakes 和 Pycodestyle：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Pyflakes and Pycodestyle
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pyflakes 和 Pycodestyle
- en: Pyflakes (`F`) flags constructs that are almost certainly mistakes, such as
    unused imports or the pointless f-strings you’ve seen above. It steers clear of
    any questions of style. Pycodestyle (whose rules use the prefixes `E` and `W`),
    detects violations of PEP 8, the style guide originally written by Python’s inventor,
    Guido van Rossum, together with Barry Warsaw and Alyssa Coghlan.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Pyflakes (`F`) 标记几乎肯定是错误的结构，比如未使用的导入或前面看到的无意义的 f-字符串。它避免了任何风格问题。Pycodestyle（其规则使用前缀
    `E` 和 `W`）检测违反 PEP 8 的情况，这是由 Python 的发明者 Guido van Rossum、Barry Warsaw 和 Alyssa
    Coghlan 原创的风格指南。
- en: Ruff enables only a subset of Pycodestyle by default, because code formatters
    have obviated many of its checks. Still, PEP 8 makes style recommendations that
    go beyond mere code formatting. Would you agree that `x is not None` sounds more
    natural than `not x is None`? The default rules detect and fix a number of such
    issues, leading to code that’s easier to read and understand.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Ruff 默认只启用 Pycodestyle 的部分功能，因为代码格式化工具已经替代了其中的许多检查。然而，PEP 8 提出了超出纯代码格式化的风格建议。你是否认同
    `x is not None` 比 `not x is None` 更自然？默认规则能够检测和修复许多这类问题，使得代码更易读和理解。
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you aren’t using an opinionated code formatter, consider enabling the entire
    `E` and `W` blocks. Their automatic fixes help ensure minimal PEP 8 compliance.
    They’re similar to, but not yet as feature-complete as, the Autopep8 formatter
    (see [“Approaches to Code Formatting: Autopep8”](#section_linting_autopep8)).^([3](ch09.html#id313))'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用特定的代码格式化工具，考虑启用整个 `E` 和 `W` 块。它们的自动修复有助于确保最小的 PEP 8 符合性。它们类似于 Autopep8
    格式化器（参见 [“代码格式化方法：Autopep8”](#section_linting_autopep8)）。^([3](ch09.html#id313))
- en: Fantastic Linters and Where to Find Them
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 奇幻检查工具及其去向
- en: Ruff has too many rules to describe in this book, and more are being added all
    the time. How do you find the good ones for your project? Try them out! Depending
    on your project, you may want to enable individual rules (`"B006"`), groups of
    rules (`"E4"`), entire plugins (`"B"`), or even every existing plugin at the same
    time (`"ALL"`).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Ruff 包含太多规则，无法在本书中详细描述，而且还在不断添加新规则。如何找到适合项目的好规则？试试它们吧！根据项目的需要，你可以启用单个规则 (`"B006"`)，规则组
    (`"E4"`)，整个插件 (`"B"`)，甚至同时启用所有现有插件 (`"ALL"`)。
- en: Warning
  id: totrans-51
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'Reserve the special `ALL` code for experimentation: it will implicitly enable
    new linters whenever you upgrade Ruff. Beware: some plugins require configuration
    to produce useful results, and some rules conflict with other rules.^([4](ch09.html#id314))'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 保留特殊代码 `ALL` 用于实验：它将在您升级 Ruff 时隐式启用新的检查工具。注意：某些插件需要配置才能产生有用的结果，而某些规则可能与其他规则冲突。^([4](ch09.html#id314))
- en: 'Besides `select`, Ruff has an `extend-select` directive which selects rules
    in addition to the default set (see [“Linting Basics”](#section_linting_basics)).
    Generally, you should prefer the `select` directive, because it keeps your configuration
    self-contained and explicit:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `select`，Ruff 还有一个 `extend-select` 指令，可以选择额外的规则集（参见 [“检查基础知识”](#section_linting_basics)）。通常建议使用
    `select` 指令，因为它保持配置的自包含性和明确性：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you’re unsure where to start, [Table 9-1](#table_linting_ruff_plugins) describes
    a dozen built-in plugins to try.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定从哪里开始，[表 9-1](#table_linting_ruff_plugins) 描述了一些内置插件，可以尝试使用。
- en: Table 9-1\. A dozen widely useful Ruff plugins
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-1\. 十二个广泛使用的 Ruff 插件
- en: '| Prefix | Name | Description |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 前缀 | 名称 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `RUF` | Ruff-specific rules | A collection of lints native to Ruff |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `RUF` | Ruff 特定规则 | Ruff 本地的一系列检查项 |'
- en: '| `I` | `isort` | Group and sort import statements |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `I` | `isort` | 对导入语句进行分组和排序 |'
- en: '| `UP` | `pyupgrade` | Use modern language features compatible with your target
    Python version |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `UP` | `pyupgrade` | 使用与目标 Python 版本兼容的现代语言特性 |'
- en: '| `SIM` | `flake8-simplify` | Use idiomatic constructs to simplify code |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `SIM` | `flake8-simplify` | 使用惯用结构简化代码 |'
- en: '| `FURB` | `refurb` | Use idiomatic constructs to make good code even better
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `FURB` | `refurb` | 使用惯用结构使优秀代码更加完善 |'
- en: '| `PIE` | `flake8-pie` | A collection of miscellaneous lints |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `PIE` | `flake8-pie` | 一系列杂项检查项 |'
- en: '| `PERF` | `Perflint` | Avoid performance antipatterns |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `PERF` | `Perflint` | 避免性能反模式 |'
- en: '| `C4` | `flake8-comprehensions` | Use `list`, `set`, and `dict` comprehensions
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `C4` | `flake8-comprehensions` | 使用 `list`、`set` 和 `dict` 推导式 |'
- en: '| `B` | `flake8-bugbear` | Eliminate likely bugs and design problems |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `B` | `flake8-bugbear` | 消除可能的错误和设计问题 |'
- en: '| `PL` | `Pylint` | A large collection of rules from the mother of all Python
    linters |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `PL` | `Pylint` | 来自所有 Python 代码检查工具之母的大量规则集合 |'
- en: '| `D` | `pydocstyle` | Require well-formed docstrings for your functions, classes,
    and modules |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `D` | `pydocstyle` | 要求函数、类和模块的文档字符串格式良好 |'
- en: '| `S` | `flake8-bandit` | Detect potential security vulnerabilities |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `S` | `flake8-bandit` | 检测潜在的安全漏洞 |'
- en: 'When onboarding legacy projects to Ruff, your first task will be to decide
    which linters provide the most useful feedback. At this stage, individual diagnostics
    can be quite overwhelming. It helps to zoom out using the `--statistics` option:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在将传统项目接入 Ruff 时，首要任务是决定哪些代码检查工具提供了最有用的反馈。在此阶段，单独的诊断可能会非常压倒性。使用 `--statistics`
    选项可以放大视角：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At this point, you have two options. First, if a linter is particularly noisy,
    hide it from the output using the `--ignore` option. For example, if you’re not
    ready to add type annotations and docstrings, exclude `flake8-annotations` and
    `pydocstyle` with `--ignore ANN,D`. Second, if you see a linter with interesting
    findings, enable it permanently in *pyproject.toml* and fix its warnings. Rinse
    and repeat.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你有两个选择。首先，如果某个代码检查工具的输出特别嘈杂，可以使用 `--ignore` 选项隐藏它。例如，如果尚未准备好添加类型注解和文档字符串，可以使用
    `--ignore ANN,D` 排除 `flake8-annotations` 和 `pydocstyle`。其次，如果发现某个代码检查工具有有趣的发现，可以在
    *pyproject.toml* 中永久启用它并修复其警告。反复进行此过程。
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: Work towards enforcing the same set of linters for all your projects, with the
    same configurations, and prefer default configurations over customizations. This
    will make your codebase more consistent and accessible across the entire organization.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在所有项目中推行相同的一组代码检查工具及其配置，并优先选择默认配置而非定制配置。这样可以使整个组织的代码库更加一致和易于访问。
- en: Disabling Rules and Warnings
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用规则和警告
- en: 'The `select` setting is flexible, but purely additive: it lets you opt into
    rules whose code starts with a given prefix. The `ignore` setting lets you fine-tune
    in the other direction: it disables individual rules and rule groups. Like `select`,
    it matches rule codes by their prefixes.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`select` 设置非常灵活，但纯粹是增量的：它允许你选择那些代码以特定前缀开头的规则。`ignore` 设置则让你可以微调，反向操作：禁用单独的规则和规则组。和
    `select` 一样，它通过前缀匹配规则代码。'
- en: 'The subtractive method is handy when you need most, but not all, of a linter’s
    rules, and when you’re adopting a linter gradually. The `pydocstyle` plugin (`D`)
    checks that every module, class, and function has a well-formed docstring. Your
    project may be *almost* there, with the exception of module docstrings (`D100`).
    Use the `ignore` setting to disable all warnings about missing module docstrings
    until you’ve fully onboarded your project:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要大部分而非全部的代码检查规则，或者逐步采用代码检查工具时，减法方法非常实用。`pydocstyle` 插件 (`D`) 检查每个模块、类和函数是否具有格式良好的文档字符串。你的项目可能已经接近目标，只剩下模块文档字符串
    (`D100`) 未达标。在完全接入项目之前，使用 `ignore` 设置禁用所有关于缺少模块文档字符串的警告：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `per-file-ignore` setting lets you disable rules for a part of your codebase.
    Here’s another example: The `bandit` plugin (`S`) has a rich inventory of checks
    to help you detect security vulnerabilities in your code. Its rule `S101` flags
    every use of the `assert` keyword.^([5](ch09.html#id315)) But you still need `assert`
    to express expectations in pytest (see [Chapter 6](ch06.html#chapter_testing)).
    If your test suite lives in a *tests* directory, disable `S101` for its files
    like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`per-file-ignore` 设置允许您在代码库的一部分禁用规则。另一个例子是：`bandit` 插件 (`S`) 具有丰富的检查清单，可帮助您检测代码中的安全漏洞。它的规则
    `S101` 标记了每个使用 `assert` 关键字的地方。^([5](ch09.html#id315)) 但是在 pytest 中，您仍然需要 `assert`
    来表达预期（参见 [第6章](ch06.html#chapter_testing)）。如果您的测试套件位于 *tests* 目录中，可以像这样为其文件禁用
    `S101`：'
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Disabling rules should be a last resort. It’s usually better to suppress individual
    warnings by adding a special comment to offending lines. This comment has the
    form `# noqa:` followed by one or more rule codes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 禁用规则应该是最后的选择。通常最好通过为有问题的行添加特殊注释来抑制单个警告。这种注释的形式是 `# noqa:`，后面跟着一个或多个规则代码。
- en: Warning
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Always include rule codes in your `noqa` comments. Blanket `noqa` comments can
    hide unrelated issues. Marking violations also makes them easier to find when
    you’re ready to fix them. Use the rule `PGH004` from the `pygrep-hooks` linter
    to require rule codes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 `noqa` 注释中始终包含规则代码。一般的 `noqa` 注释可能会隐藏无关的问题。标记违规行也会使它们在您准备修复时更易于查找。使用 `pygrep-hooks`
    linter 的规则 `PGH004` 要求规则代码。
- en: 'The `noqa` system lets you silence false positives as well as legitimate warnings
    that you choose not to prioritize at this point in time. For example, the MD5
    message-digest algorithm is generally agreed to be insecure, and Bandit’s `S324`
    flags its uses. But if your code interacts with a legacy system that requires
    you to compute an MD5 hash, you may not have much of a choice. Disable the warning
    with a `noqa` comment:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`noqa` 系统允许您消除虚假阳性以及您选择在此时不优先考虑的合法警告。例如，MD5 消息摘要算法通常被认为是不安全的，Bandit 的 `S324`
    标记了其使用。但是，如果您的代码与需要您计算 MD5 哈希的旧系统交互，您可能别无选择。使用 `noqa` 注释来禁用此警告：'
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Bandit’s checks often flag constructs that deserve close scrutiny, without meaning
    to outright ban them. The idea is that you will vet the offending lines one by
    one and suppress the warning if you determine the specific usage to be innocuous.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Bandit 的检查通常会标记出值得仔细审查的结构，但并不打算彻底禁止它们。其想法是您将逐个审查有问题的行，并在确定特定使用无害时抑制警告。
- en: 'It can be reasonable to enable a rule and suppress *all* of its warnings. This
    lets you enforce a rule going forward only—​that is, only when you touch a region
    of code. Ruff supports this workflow with the `--add-noqa` option, which inserts
    `noqa` comments to all offending lines on your behalf:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 启用一个规则并抑制 *所有* 其警告可能是合理的。这样可以只在您触及代码区域时才执行规则—​即，只有当您触及代码区域时才执行。Ruff 支持此工作流程，其
    `--add-noqa` 选项会为所有有问题的行代表您插入 `noqa` 注释：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Like every comment, `noqa` comments can become outdated—​for example, a refactoring
    may have inadvertently fixed the suppressed warning. Stale `noqa` comments are
    noisy and create friction when you’re out to squash linter violations. Luckily,
    Ruff is in an excellent position to remediate this. Its rule `RUF100` automatically
    removes `noqa` comments that no longer apply.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每个注释一样，`noqa` 注释可能会过时—​例如，重构可能会无意中修复被抑制的警告。过时的 `noqa` 注释会产生噪音，并在试图消除 linter
    违规时产生摩擦。幸运的是，Ruff 处于优越的位置来修复这个问题。其规则 `RUF100` 可自动移除不再适用的 `noqa` 注释。
- en: Automation with Nox
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Nox 进行自动化
- en: Without corrective measures, the code quality of large projects degrades over
    time. Linting, as an automated, mandatory check, helps to counteract that natural
    entropy. Nox (see [Chapter 8](ch08.html#chapter_nox)) is an automation framework
    that lets you run linters as a part of your mandatory checks.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有纠正措施，大型项目的代码质量会随时间而下降。作为自动化的强制检查，linting 有助于抵消自然熵的影响。Nox（参见 [第8章](ch08.html#chapter_nox)）是一个自动化框架，可以作为强制检查的一部分运行
    linters。
- en: 'Here’s a Nox session that runs Ruff on every Python file in the current directory:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 Nox 会话，它在当前目录中的每个 Python 文件上运行 Ruff：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Nox is a valid choice here, but when it comes to linting, there’s a more convenient
    and powerful alternative: pre-commit, a cross-language linter framework with Git
    integration.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Nox 在这里是一个合理的选择，但是在 linting 方面，有一个更方便和强大的选择：pre-commit，一个具有 Git 集成的跨语言 linter
    框架。
- en: The pre-commit Framework
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[预提交框架](https://wiki.example.org/pre-commit_framework)'
- en: Pre-commit is a tool and framework that lets you add third-party linters to
    a project with minimal boilerplate. Linters in various languages come with ready-to-use
    integrations for pre-commit, called *hooks*. You can run these hooks explicitly
    from the command line, or you can configure your local repository to run them
    whenever you commit changes (and on some other events).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Pre-commit 是一个工具和框架，允许你将第三方 linter 添加到项目中，并带有最少的样板文件。各种语言的 linter 都有为 pre-commit
    准备的即用集成，称为 *hooks*。你可以从命令行显式运行这些 hooks，或者在本地仓库中配置以在提交更改时运行它们（以及其他一些事件）。
- en: 'Install pre-commit globally using pipx:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pipx 全局安装 pre-commit：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First Steps with pre-commit
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初识 pre-commit
- en: Let’s add a pre-commit hook for Ruff to your project. Create a file named *.pre-commit-config.yaml*
    in the top-level directory, with contents as in [Example 9-3](#example_linting_pre_commit_config).
    You’ll find a short YAML fragment like this in the public documentation of most
    linters that support pre-commit.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为你的项目添加一个 Ruff 的 pre-commit 钩子。在顶级目录创建一个名为 *.pre-commit-config.yaml* 的文件，内容如
    [示例 9-3](#example_linting_pre_commit_config) 所示。你会在支持 pre-commit 的大多数 linter 的公共文档中找到类似这样的短
    YAML 片段。
- en: Example 9-3\. A *.pre-commit-config.yaml* file with a hook for Ruff
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-3\. 一个包含 Ruff 钩子的 *.pre-commit-config.yaml* 文件
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Authors distribute their pre-commit hooks via Git repositories. In the *.pre-commit-config.yaml*
    file, you specify the URL, revision, and hooks for each repository you want to
    use. The URL can be any location Git can clone from. The revision is most commonly
    a Git tag pointing to the latest release of the linter. A repository can have
    more than one hook—​for example, Ruff provides `ruff` and `ruff-format` hooks
    for its linter and code formatter, respectively.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 作者通过 Git 仓库分发他们的 pre-commit 钩子。在 *.pre-commit-config.yaml* 文件中，你需要为每个想要使用的仓库指定
    URL、修订版本和钩子。URL 可以是 Git 可以克隆的任何位置。修订版本通常是指向 linter 最新发布版本的 Git tag。一个仓库可以有多个钩子—例如，Ruff
    提供了 `ruff` 和 `ruff-format` 钩子用于其 linter 和代码格式化器。
- en: 'Pre-commit is intimately tied to Git, and you must invoke it from within a
    Git repository. Let’s establish a baseline by linting every file in the repository,
    using the command `pre-commit run` with the `--all-files` option:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Pre-commit 与 Git 密切相关，你必须在 Git 仓库内部调用它。我们将通过使用带有 `--all-files` 选项的命令 `pre-commit
    run` 来为仓库中的每个文件建立基准进行 linting：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When you run a hook for the first time, pre-commit clones the hook repository
    and installs the linter into an isolated environment. This can take some time,
    but you don’t have to do it often: Pre-commit caches the linter environments across
    multiple projects.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次运行一个钩子时，pre-commit 会克隆钩子仓库并将 linter 安装到隔离环境中。这可能需要一些时间，但你不必经常这样做：pre-commit
    在多个项目中缓存 linter 环境。
- en: A Hook Up Close
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 靠近钩子
- en: If you’re curious how a pre-commit hook works under the hood, take a peek at
    Ruff’s [hook repository](https://github.com/astral-sh/ruff-pre-commit). The file
    *.pre-commit-hooks.yaml* in the repository defines the hooks. [Example 9-4](#example_linting_hook_definition)
    shows an excerpt from the file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道 pre-commit 钩子在幕后是如何工作的，可以看一下 Ruff 的 [hook repository](https://github.com/astral-sh/ruff-pre-commit)。仓库中的
    *.pre-commit-hooks.yaml* 文件定义了这些 hooks。示例 9-4 展示了文件中的一个摘录。
- en: Example 9-4\. An excerpt from the .pre-commit-hooks.yaml file for Ruff
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-4\. 来自 Ruff 的 .pre-commit-hooks.yaml 文件的摘录
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Every hook comes with a unique identifier and a friendly name (`id` and `name`).
    Refer to hooks by their unique identifier when you interact with pre-commit. Their
    names only appear in console messages from the tool.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每个钩子都有一个唯一的标识符和一个友好的名称（`id` 和 `name`）。与 pre-commit 交互时，请通过其唯一标识符引用钩子。它们的名称只出现在来自该工具的控制台消息中。
- en: The hook definition tells pre-commit how to install and run the linter by specifying
    its implementation language (`language`) and its command and command-line arguments
    (`entry` and `args`). The Ruff hook is a Python package, so it specifies Python
    as the language. The `--force-exclude` option ensures that you can exclude files
    from linting. It tells Ruff to honor its `exclude` setting even when pre-commit
    passes excluded source files explicitly.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子定义告诉 pre-commit 如何安装和运行 linter，通过指定其实现语言（`language`）和其命令及命令行参数（`entry` 和 `args`）。Ruff
    钩子是一个 Python 包，因此它将 Python 指定为语言。`--force-exclude` 选项确保你可以排除 linting 的文件。它告诉 Ruff
    即使 pre-commit 明确传递了排除的源文件，也要遵循其 `exclude` 设置。
- en: Tip
  id: totrans-114
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You can override the `args` key in your *.pre-commit-config.yaml* file to pass
    custom command-line options to a hook. By contrast, command-line arguments in
    the `entry` key are mandatory—​you can’t override them.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在*.pre-commit-config.yaml*文件中覆盖`args`键，以向钩子传递自定义命令行选项。相比之下，`entry`键中的命令行参数是强制性的——您无法覆盖它们。
- en: Finally, the hook declares which file types the linter understands (`types_or`).
    The `python` file type matches files with *.py* or related extensions and executable
    scripts with a Python shebang. The `pyi` file type refers to stub files with type
    annotations (see [“Distributing Types with Python Packages”](ch10.html#section_typing_distributing)).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，该钩子声明了linter理解的文件类型（`types_or`）。`python`文件类型匹配具有*.py*或相关扩展名的文件以及带有Python
    shebang的可执行脚本。`pyi`文件类型是指带有类型注解的存根文件（参见[“使用Python包分发类型”](ch10.html#section_typing_distributing)）。
- en: For a Python hook, pre-commit creates a virtual environment in its cache directory.
    It installs the hook by running, essentially, `pip install .` inside the hook
    repository. When it’s time to run the hook, pre-commit activates the virtual environment
    and invokes the command with any selected source files.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python钩子，pre-commit在其缓存目录中创建一个虚拟环境。它通过在钩子存储库中运行类似于`pip install .`的命令来安装钩子。当运行钩子时，pre-commit会激活虚拟环境并使用任何选定的源文件调用命令。
- en: '[Figure 9-2](#figure_pre_commit) shows a developer machine with three Python
    projects using pre-commit hooks. Pre-commit clones the hook repositories into
    its cache directory and installs the hooks into isolated environments. Hook repositories
    define hooks in *.pre-commit-hooks.yaml* files, while projects reference the hooks
    in *.pre-commit-config.yaml* files.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-2](#figure_pre_commit)展示了一个开发者机器，上面有三个使用pre-commit钩子的Python项目。pre-commit会将钩子存储库克隆到其缓存目录并将钩子安装到隔离环境中。钩子存储库在*.pre-commit-hooks.yaml*文件中定义钩子，而项目在*.pre-commit-config.yaml*文件中引用这些钩子。'
- en: '![The diagram shows repositories with pre-commit hooks for Ruff, Flake8, and
    Black, as well as a developer machine with three projects referencing these hooks.
    At the bottom, the diagram shows the pre-commit cache with cloned repositories
    and environments with installed hooks.](assets/hmpt_0902.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![该图显示了带有Ruff、Flake8和Black预提交钩子的存储库以及带有这些钩子引用的三个项目的开发者机器。在底部，该图显示了带有克隆存储库和已安装钩子环境的pre-commit缓存。](assets/hmpt_0902.png)'
- en: Figure 9-2\. Three projects with pre-commit hooks for Ruff, Black, and Flake8.
  id: totrans-120
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-2。三个项目使用了Ruff、Black和Flake8的pre-commit钩子。
- en: Automatic Fixes
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动修复
- en: Modern linters can fix many violations by modifying the offending source files
    in place. Linters with automatic fixes eliminate entire classes of bugs and code
    smells^([6](ch09.html#id316)) at nearly zero cost. Like code formatters, they
    have caused a paradigm shift in software development, letting you focus on higher-level
    concerns without compromising on code quality.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现代的linter可以通过直接修改违规的源文件来修复许多违规。具有自动修复功能的linter在几乎零成本的情况下消除了整个类别的错误和代码异味^([6](ch09.html#id316))。像代码格式化工具一样，它们在软件开发中引起了范式转变，使您可以专注于更高级别的问题，而不会牺牲代码质量。
- en: By convention, most pre-commit hooks enable automatic fixes by default. Thanks
    to Git, they can apply fixes with relative safety, without risk of overwriting
    your work irreversibly. That said, they work best if you commit early and often.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 根据约定，大多数pre-commit钩子默认启用自动修复。由于Git的存在，它们可以相对安全地应用修复，而不会不可逆地覆盖您的工作。尽管如此，如果您早早地提交并频繁地提交，它们的效果会更好。
- en: Warning
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'Automatic fixes bring tremendous benefits, but they assume some basic Git hygiene:
    Don’t pile up uncommitted changes in your repository (or stash them before linting).
    Pre-commit saves and restores your local modifications in some contexts, but not
    all.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 自动修复带来了巨大的好处，但它们假设了一些基本的Git卫生习惯：不要在您的存储库中堆积未提交的更改（或在linting之前将它们存储）。在某些情况下，pre-commit会保存和恢复您的本地修改，但并非所有情况都是如此。
- en: 'Let’s try this out. When Ruff detects the mutable argument default, it indicates
    that you can enable a “hidden” fix. (Ruff asks you to opt into the fix because
    people might conceivably depend on mutable defaults, say, for caching.) First,
    enable the linter rule and the fix in *pyproject.toml*:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试这个。当Ruff检测到可变参数默认值时，表示您可以启用一个“隐藏”的修复（Ruff要求您选择修复，因为人们可能依赖于可变默认值，例如用于缓存）。首先，在*pyproject.toml*中启用linter规则和修复：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Ruff’s pre-commit hook requires you to opt in with the `--fix` option, as shown
    in [Example 9-5](#example_linting_ruff_fix). The options `--show-fixes` and `--exit-non-zero-on-fix`
    ensure that all violations are displayed in the terminal and result in a non-zero
    exit status, even if Ruff was able to fix them.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Ruff 的 pre-commit 钩子要求你选择 `--fix` 选项，就像 [示例 9-5](#example_linting_ruff_fix)
    中展示的那样。选项 `--show-fixes` 和 `--exit-non-zero-on-fix` 确保所有违规将在终端显示，并导致非零退出状态，即使
    Ruff 能够修复它们。
- en: Example 9-5\. Enabling automatic fixes for the Ruff hook
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-5\. 启用 Ruff 钩子的自动修复功能
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Save [Example 9-1](#example_linting_mutable_default) in a file called *bad.py*,
    commit the file, and run pre-commit:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将 [示例 9-1](#example_linting_mutable_default) 保存到名为 *bad.py* 的文件中，提交该文件，并运行 pre-commit：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you inspect the modified file, you’ll see that Ruff has replaced the argument
    default with `None`. The empty list is now assigned inside the function, giving
    every call its own instance of `args`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查修改后的文件，你会看到 Ruff 已经用 `None` 替换了参数默认值。空列表现在分配给函数内部，使得每次调用都有自己的 `args` 实例。
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Instead of inspecting the modified files, you can also run `git diff` to see
    the changes applied to your code. Alternatively, you can tell pre-commit to show
    you a diff of the fixes right away, using the option `--show-diff-on-fail`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行 `git diff` 来查看应用于代码的更改，而不是检查修改后的文件。或者，你可以告诉 pre-commit 立即显示修复的差异，使用选项
    `--show-diff-on-fail`。
- en: Running pre-commit from Nox
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Nox 运行 pre-commit
- en: Pre-commit gives you access to production-ready integrations for linters in
    many languages. For this reason alone, I recommend running linters from pre-commit
    instead of Nox. (If you still need convincing, bear with me for the next section,
    which presents another compelling reason to use pre-commit.)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Pre-commit 为许多语言的 linters 提供了生产就绪的集成。光是因为这个原因，我建议使用 pre-commit 而不是 Nox 运行 linters。（如果你还需要说服，请看下一节，它会为使用
    pre-commit 提供另一个令人信服的理由。）
- en: That said, you should still include a Nox session for pre-commit itself. This
    ensures that you can run all the checks for your project with a single command,
    `nox`. [Example 9-6](#example_linting_nox) shows how to define the session. If
    your *noxfile.py* sets `nox.options.sessions`, add the session to that list, as
    well.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，你仍然应该为 pre-commit 本身包含一个 Nox 会话。这可以确保你可以通过单个命令 `nox` 运行项目的所有检查。[示例 9-6](#example_linting_nox)
    展示了如何定义该会话。如果你的 *noxfile.py* 设置了 `nox.options.sessions`，请将该会话添加到该列表中。
- en: Example 9-6\. A Nox session for linting with pre-commit
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-6\. 使用 pre-commit 进行 lint 的 Nox 会话
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'By default, pre-commit runs every hook you’ve configured for your project.
    You can run specific hooks by passing them as additional command-line arguments.
    This comes in handy when addressing complaints from a specific linter. Thanks
    to `session.posargs` (see [“Session Arguments”](ch08.html#section_nox_session_arguments)),
    this also works from Nox:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，pre-commit 会运行你为项目配置的所有钩子。你可以通过将它们作为额外的命令行参数传递来运行特定的钩子。这在解决特定 linter 的问题时非常方便。借助
    `session.posargs`（参见 [“Session Arguments”](ch08.html#section_nox_session_arguments)），在
    Nox 中也同样适用：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Having a single entry point to checks and tasks, including linters, greatly
    reduces friction for everybody working on a project. But you shouldn’t stop there.
    Pre-commit was designed to be triggered from Git on every commit. The next section
    explains how to set up projects to lint changes as you commit them (and why it’s
    great).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有在项目上工作的人来说，包括 linters 在内的检查和任务具有单一的入口点，可以极大地减少摩擦。但你不应该止步于此。Pre-commit 的设计目标是在每次提交时从
    Git 触发。下一节将解释如何设置项目，以便在提交更改时进行 lint（以及为什么这样做是很好的）。
- en: Running pre-commit from Git
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Git 运行 pre-commit
- en: 'Running linters on each commit is a game changer, for three reasons:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次提交时运行 linters 是一个改变游戏规则的操作，原因有三：
- en: You remove the overhead and distraction of invoking checks manually. Linters
    run in the background, alerting you only if a violation is found.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你消除了手动调用检查的开销和干扰。Linters 在后台运行，只有在发现违规时才会提醒你。
- en: You run checks as early as possible. As a general rule, the earlier you spot
    an issue, the cheaper it is to fix. (Say goodbye to CI failures due to stylistic
    nitpicks.)
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你尽早进行检查。一般来说，越早发现问题，修复成本就越低。（对于因风格细微差异导致的 CI 失败，告别吧。）
- en: 'It’s fast: You only lint files staged for a commit, instead of the entire codebase.^([7](ch09.html#id317))'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它速度很快：你只需要对提交阶段的文件进行 lint，而不是整个代码库。^([7](ch09.html#id317))
- en: 'Set up Git to invoke pre-commit on every commit by running the following command
    inside your project:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Git 在每次提交时调用 pre-commit 的方法是在项目内运行以下命令：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This command installs a short wrapper script into the *.git/hooks* directory
    that transfers control to pre-commit ([Figure 9-3](#figure_pre_commit_git)). Programs
    in the *.git/hooks* directory are known as *Git hooks*. When you run `git commit`,
    Git invokes the *pre-commit* Git hook. The hook, in turn, invokes pre-commit,
    which runs Ruff and any other pre-commit hooks you have.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将一个简短的包装脚本安装到 *.git/hooks* 目录中，将控制权转移给预提交（见 [图 9-3](#figure_pre_commit_git)）。*.git/hooks*
    目录中的程序被称为 *Git 钩子*。当你运行`git commit`时，Git 调用 *pre-commit* Git 钩子。这个钩子又调用预提交，其中运行了
    Ruff 和你拥有的任何其他预提交钩子。
- en: '![The diagram shows how Git hooks invoke pre-commit hooks, using pre-commit
    as a switch board.](assets/hmpt_0903.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![该图示了 Git 钩子如何调用预提交钩子，使用预提交作为交换机。](assets/hmpt_0903.png)'
- en: Figure 9-3\. Git hooks and pre-commit hooks
  id: totrans-153
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-3\. Git 钩子和预提交钩子
- en: Git hooks let you trigger actions at predefined points during Git’s execution.
    For example, the *pre-commit* and *post-commit* Git hooks run before and after
    Git creates a commit. You’ve probably guessed by now which of these Git hooks
    pre-commit installs by default—​but it supports the other Git hooks as well, if
    you need them.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Git 钩子允许你在 Git 执行的预定义点触发动作。例如，*pre-commit* 和 *post-commit* Git 钩子在 Git 创建提交之前和之后运行。你可能已经猜到预提交默认安装了哪些
    Git 钩子——但它也支持其他 Git 钩子，如果你需要的话。
- en: '[Figure 9-4](#figure_pre_commit_flow) depicts a typical workflow with pre-commit.
    On the left, there’s a file you’re editing in your project (*worktree*); the center
    represents the staging area for the next commit (*index*); and the current commit
    is on the right (`HEAD`).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-4](#figure_pre_commit_flow) 描述了带有预提交的典型工作流程。左边是你项目中正在编辑的文件（*工作树*）；中间代表下一个提交的暂存区（*索引*）；右边是当前提交（`HEAD`）。'
- en: '![The diagram shows how pre-commit rejects a commit.](assets/hmpt_0904.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![该图示了预提交如何拒绝一个提交。](assets/hmpt_0904.png)'
- en: Figure 9-4\. Workflow with pre-commit
  id: totrans-157
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9-4\. 带有预提交的工作流程
- en: Initially, the three areas are in sync. Suppose you remove the placeholder from
    the f-string, but forget to remove the `f` prefix from the string literal (marked
    as *1* in [Figure 9-4](#figure_pre_commit_flow)). You stage your edit using `git
    add` *(2)* and run `git commit` to create a commit *(3a)*. Before your editor
    can pop up for the commit message, Git transfers control to pre-commit. Ruff promptly
    catches your mistake and fixes the string literal in your worktree *(3b)*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，这三个区域是同步的。假设你从 f-string 中移除了占位符，但忘记从字符串字面量中移除`f`前缀（在 [图 9-4](#figure_pre_commit_flow)
    中标记为 *1*）。你使用`git add` *(2)* 阶段性地提交你的编辑，并运行`git commit`来创建一个提交 *(3a)*。在你的编辑器弹出提交消息之前，Git
    将控制权转移给预提交。Ruff 迅速捕捉到你的错误，并在你的工作树中修复了字符串字面量 *(3b)*。
- en: At this point, all three areas have different contents. Your worktree contains
    your change with Ruff’s fix, the staging area has your change without the fix,
    and `HEAD` still points to the commit before your change. This lets you audit
    the fix by comparing the worktree to the staging area, using `git diff`. If you’re
    happy with what you see, you can stage the fix with `git add` *(4)* and retry
    the commit with `git commit` *(5)*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，所有三个区域具有不同的内容。你的工作树包含了带有 Ruff 修复的修改，暂存区包含了没有修复的修改，而`HEAD`仍然指向修改之前的提交。这允许你通过使用`git
    diff`来比较工作树和暂存区来审计修复。如果你对所看到的结果满意，你可以使用`git add` *(4)* 将修复加入暂存区，并使用`git commit`
    *(5)* 重新尝试提交。
- en: 'With automatic fixes, this workflow reduces the interference of linters to
    a minimum, rerunning the commit. But sometimes you don’t want to be distracted
    by linters at all—​for example, you may want to record some work in progress.
    Git and pre-commit give you two options to get your commit past a stubborn linter.
    First, you can skip Git hooks entirely using the `--no-verify` or `-n` option:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过自动修复，这个工作流程将最小化 lint 工具的干扰，并重新运行提交。但有时候，你可能根本不想被 lint 工具打扰——例如，你可能想记录一些正在进行中的工作。Git
    和预提交为你提供了两个选项，以便你的提交能够通过顽固的 lint 工具。首先，你可以完全跳过 Git 钩子，使用`--no-verify`或`-n`选项：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Alternatively, you can skip a specific pre-commit hook using the `SKIP` environment
    variable (which also takes a comma-separated list, if you need to skip more than
    one hook):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用`SKIP`环境变量跳过特定的预提交钩子（如果需要跳过多个钩子，也可以使用逗号分隔的列表）：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Git hooks control which changes enter your local repository, but they’re voluntary—​they
    don’t replace CI checks as a gatekeeper for the default branch in your shared
    repository. If you already run Nox in CI, the session in [Example 9-6](#example_linting_nox)
    takes care of that.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Git 钩子控制哪些更改进入您的本地存储库，但它们是自愿的 — 不会替换 CI 检查作为共享存储库中默认分支的门卫。如果您已在 CI 中运行 Nox，则[示例
    9-6](#example_linting_nox) 中的会话会处理此问题。
- en: 'Skipping hooks doesn’t help with false positives or when you want to deploy
    a critical fix despite minor nits: your mandatory checks would still fail in CI.
    In these cases, you’ll need to advise the linter to ignore the specific violation
    (see [“Disabling Rules and Warnings”](#section_linting_ruff_ignore)).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过钩子对于假阳性或者当您想部署关键修复时并没有帮助：您的强制检查仍会在 CI 中失败。在这些情况下，您需要建议代码检查器忽略特定违规行为（见[“禁用规则和警告”](#section_linting_ruff_ignore)）。
- en: The Ruff Formatter
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ruff 格式化程序
- en: Over the course of months, Ruff reimplemented a plethora of Python linters behind
    the `ruff check` command and saw wide adoption in the Python world. A bit over
    a year in, Ruff acquired the `ruff format` command.^([8](ch09.html#id318)) The
    Ruff formatter reimplements the de-facto standard of Python code formatting, Black,
    in Rust. It provides yet another building block for the integrated and highly
    performant toolchain that Ruff has become for Python.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 几个月来，Ruff 在`ruff check`命令背后重新实现了大量 Python 代码检查器，并在 Python 社区中广泛采用。一年多一点后，Ruff
    获得了`ruff format`命令[^8]。Ruff 格式化程序在 Rust 中重新实现了 Python 代码格式化的事实标准 Black。它为 Ruff
    在 Python 领域中成为集成和高性能工具链的又一个构建块提供了支持。
- en: But let’s start at the beginning.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们从头开始。
- en: 'Approaches to Code Formatting: Autopep8'
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码格式化方法：Autopep8
- en: 'Consider the following gem of Python code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下这段 Python 代码的珍珠：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The function showcases various formatting issues, such as inconsistent alignment,
    lack or excess of whitespace, and single-line `if` constructs. Some of these clearly
    hurt readability. Others, such as two-space indentation, deviate from a widely
    accepted practice codified in PEP 8.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数展示了各种格式问题，例如不一致的对齐、缺少或过多的空白以及单行`if`结构。其中一些显然影响可读性。另一些，例如两空格缩进，偏离了 PEP 8 中编码的广泛接受做法。
- en: A minimal approach for dealing with stylistic issues of this sort is Autopep8,
    an early pioneer of automatic linter fixes and still in use. Building on Pycodestyle,
    it surgically corrects offenses while preserving the code layout otherwise.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 处理此类风格问题的最小方法是 Autopep8，这是自动代码检查和修复的早期先驱，并仍在使用中。建立在 Pycodestyle 的基础上，它在保留代码布局的同时手术性地纠正违规行为。
- en: 'Let’s run Autopep8 on the code example with default settings:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用默认设置运行 Autopep8 代码示例：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here’s the function as formatted by Autopep8:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由 Autopep8 格式化的函数：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You’ll likely find this easier on the eye. For better or worse, Autopep8 didn’t
    touch some other questionable stylistic choices, such as the rogue blank line
    in the `return` statement and the inconsistent quote characters. Autopep8 uses
    Pycodestyle to detect issues, and Pycodestyle had no complaint here.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会发现这样更容易阅读。无论好坏，Autopep8 没有触及其他一些可疑的风格选择，例如`return`语句中的流浪空行和不一致的引号字符。Autopep8
    使用 Pycodestyle 来检测问题，在这里没有投诉。
- en: Tip
  id: totrans-179
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Unlike most code formatters, Autopep8 lets you apply selected fixes by passing
    `--select` with appropriate rule codes. For example, you can run `autopep8 --select=E111`
    to enforce four-space indentation.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数代码格式化程序不同，Autopep8 允许您通过传递`--select`和适当的规则代码来应用选定的修复。例如，您可以运行`autopep8 --select=E111`来强制使用四空格缩进。
- en: 'Approaches to Code Formatting: YAPF'
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码格式化方法：YAPF
- en: Developed at Google in 2015, the YAPF formatter borrows its design and sophisticated
    formatting algorithm from `clang-format`. The name YAPF stands for “Yet Another
    Python Formatter.”^([9](ch09.html#id319)) YAPF reformats a codebase according
    to a wealth of configuration options.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 2015 年由 Google 开发，YAPF 格式化程序从`clang-format`借用其设计和复杂的格式化算法。YAPF 的名称代表“Yet Another
    Python Formatter”[^9]。YAPF 根据丰富的配置选项重新格式化代码库。
- en: 'Run it like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 运行方式如下：
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here’s YAPF’s version of the code, using default settings:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 YAPF 代码的版本，使用默认设置：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: YAPF’s formatting rules touch more ground than Autopep8—​for example, it arranges
    the function parameters in a consistent way and removes the bogus empty line.
    YAPF respects existing formatting choices as long as they’re compatible with your
    configuration. For example, it didn’t split the single-line `if` statements or
    eliminate parentheses around `if` conditions.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: YAPF 的格式规则覆盖的范围比 Autopep8 更广泛——例如，它以一致的方式排列函数参数并移除伪空行。只要与你的配置兼容，YAPF 就会尊重现有的格式选择。例如，它不会分割单行的
    `if` 语句或删除 `if` 条件周围的括号。
- en: An Uncompromising Code Formatter
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个不妥协的代码格式化工具。
- en: 'In 2018, a new code formatter named Black entered the scene. Its core principle:
    minimal configurability!'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2018 年，一个名为 Black 的新代码格式化工具进入了舞台。它的核心原则是：最小可配置性！
- en: 'Let’s try Black on the code example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在代码示例中尝试一下 Black：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Black formats the function as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Black 对函数的格式化如下所示：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Black doesn’t fix individual style offenses like Autopep8, nor does it enforce
    your style preferences like YAPF. Rather, Black reduces the source code into a
    canonical form, using a deterministic algorithm—​mostly without taking existing
    formatting into account. In a certain sense, Black makes code style “disappear.”
    This normalization massively reduces the cognitive overhead of working with Python
    code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Black 不像 Autopep8 那样修复个别的风格问题，也不像 YAPF 那样强制你的风格偏好。相反，Black 将源代码简化为一个规范形式，使用确定性算法——大多数情况下不考虑现有的格式。从某种意义上说，Black
    使代码风格“消失”。这种归一化大大减少了使用 Python 代码时的认知负担。
- en: 'Black promotes a form of universal readability across the Python ecosystem.
    Code is read more often than it’s being written—​a transparent style helps. At
    the same time, Black makes code more “writable,” too. When you’re contributing
    to other people’s code, there’s no need to conform to a bespoke and manual code
    style. Even in a solo project, Black boosts your productivity: if you configure
    your editor to reformat on save, you can reduce your keystrokes to a minimum while
    coding.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Black 促进了 Python 生态系统中普遍的可读性。代码阅读的频率远高于编写——透明的风格有助于此。与此同时，Black 也使得代码更易“书写”。当你贡献于他人的代码时，无需遵循定制和手动的代码风格。即使在独立项目中，Black
    也能提升你的生产力：如果你配置编辑器在保存时重排格式，编码时可以将击键减少到最小。
- en: Black took the Python world by storm, with project after project deciding to
    “blacken” their source files.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Black 席卷了 Python 世界，一个接一个项目决定“黑化”他们的源文件。
- en: The Black Code style
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Black 的代码风格。
- en: Black’s code style becomes invisible once you’ve worked with it for a while.
    Inevitably, though, some of its choices have led to controversy, even forks. To
    understand its formatting rules, it helps to look at Black’s goal of producing
    readable and consistent source code in a predictable and repeatable way.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你使用了一段时间，Black 的代码风格就会变得无形。不可避免地，一些选择引起了争议，甚至分岐。要理解其格式化规则，有助于查看 Black 旨在以可预测和可重复的方式生成可读和一致的源代码的目标。
- en: Take the default of double quotes for string literals, for example. According
    to the style recommendations of PEP 257 and PEP 8, both docstrings and English
    text with apostrophes already require double quotes. Choosing double quotes over
    single quotes therefore results in a more consistent style overall.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，采用双引号作为字符串文字的默认值。根据 PEP 257 和 PEP 8 的风格建议，文档字符串和带撇号的英文文本已经要求使用双引号。因此，选择双引号而不是单引号会导致更一致的风格。
- en: Sometimes Black places a lone `):` after the parameters of a function. Nicknamed
    the “sad face,” it clearly demarcates the function signature from the body without
    indenting parameters beyond the standard four spaces. This layout also treats
    parameter lists like any other bracketed constructs, such as tuples, lists, and
    set literals.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，Black 在函数的参数后放置一个孤立的 `):`。这被昵称为“悲伤的脸”，清晰地划分了函数签名和函数体，而无需使参数缩进超出标准的四个空格。这种布局也将参数列表视为其他的括号结构，例如元组、列表和集合字面量。
- en: Black also caps lines at 88 characters (one of its few configurable settings).
    This tradeoff between lateral eye movement and vertical scrolling is based on
    a data-driven approach, tested on millions of lines of Python code at Meta.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Black 还将行限制在 88 个字符以内（这是它少数可配置的设置之一）。这种横向眼动与垂直滚动之间的权衡是基于数据驱动的方法，在 Meta 的数百万行
    Python 代码上进行了测试。
- en: 'Another goal of Black is to avoid *merge conflicts*, when concurrent changes
    to the same region of code cannot be combined without human intervention. The
    trailing comma—​placing a comma behind the last item in a sequence—​serves this
    purpose: it lets you insert before and after the last item without conflict.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Black的另一个目标是避免*合并冲突*，当对同一代码区域的并发更改无法在不人工干预的情况下合并时。尾逗号—​在序列的最后一项后面放置逗号—​正是为此目的而设计：它允许您在最后一项之前和之后插入而无冲突。
- en: Note
  id: totrans-203
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Reducing dependencies between edits helps different people work on the same
    code. But it also lets you separate or reorder drive-by bugfixes or refactorings
    and back out tentative commits before submitting your changes for code review.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 减少编辑之间的依赖有助于不同的人在同一段代码上工作。但这也让您可以将驱动式修复或重构分离或重新排序，并在提交更改进行代码审查之前撤销尝试性提交。
- en: As mentioned above, Black’s algorithm is deterministic, and existing layouts
    hardly affect it. A “blackened” file may look as if it was generated straight
    from the AST.^([11](ch09.html#id321)) In reality, this can’t be the case, though.
    For one thing, the AST doesn’t include comments, since they don’t affect program
    execution.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，Black算法是确定性的，现有的布局几乎不会影响它。一个“变黑”的文件看起来就像是直接从AST生成的。^([11](ch09.html#id321))
    然而实际情况并非如此。首先，AST不包括注释，因为它们不影响程序执行。
- en: 'Black takes some cues from the formatted source code besides comments. One
    example is the blank lines that divide a function body into logical partitions.
    Likely the most powerful way of affecting Black’s output, however, is the *magic
    trailing comma*: if a sequence contains a trailing comma, Black splits its elements
    across multiple lines, even if they would fit on a single line.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 除了注释，Black还从格式化的源代码中获取一些线索。一个例子是将函数体分成逻辑分区的空行。然而，影响Black输出最强大的方式可能是*神奇的尾逗号*：如果序列包含尾逗号，Black会将其元素拆分成多行，即使它们可以在单行上放得下。
- en: Black provides an escape hatch to let you disable formatting for a region of
    code ([Example 9-7](#example_linting_black_fmt_off)).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Black提供了一个逃生通道，让您可以禁用代码区域的格式化（[示例 9-7](#example_linting_black_fmt_off)）。
- en: Example 9-7\. Disabling formatting for a region of code
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-7\. 禁用代码区域的格式化
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Hand-formatting can be useful for program data, such as large tables with properly
    aligned columns.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于程序数据，如具有正确对齐列的大表格，手动格式化可能很有用。
- en: Formatting Code with Ruff
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Ruff格式化代码
- en: Code formatters can process millions of lines of code in a batch, or run in
    quick succession when triggered from your editor or on a busy CI server. Being
    fast was an explicit goal of Black from the start—​it ships binary wheels with
    native code generated by `mypyc`, a compiler for type-annotated Python. While
    Black is fast, the Ruff formatter further improves performance thirtyfold, thanks
    to its efficient Rust implementation.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 代码格式化程序可以批处理处理数百万行代码，或者在触发编辑器或繁忙CI服务器上运行时快速连续运行。从一开始，Black的明确目标是快速的—​它通过`mypyc`生成的本地代码二进制轮速度快。虽然Black速度快，但Ruff格式化程序通过其高效的Rust实现进一步提高了性能三十倍。
- en: Ruff aims for full compatibility with the Black code style. Unlike Black, Ruff
    lets you opt into single quotes and indentation using tabs. However, I’d recommend
    adhering to Black’s widely adopted style nonetheless.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Ruff的目标是与Black代码风格完全兼容。与Black不同，Ruff允许您选择使用单引号和使用制表符进行缩进。但无论如何，我建议坚持采用Black广泛采纳的风格。
- en: When run without arguments, `ruff format` processes any Python files beneath
    the current directory. Instead of invoking Ruff manually, add it to your pre-commit
    hooks, as shown in [Example 9-8](#example_linting_ruff_format).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有参数运行时，`ruff format`处理当前目录下的任何Python文件。不要手动调用Ruff，而是将其添加到您的pre-commit钩子中，如[示例 9-8](#example_linting_ruff_format)所示。
- en: Example 9-8\. Running Ruff from pre-commit as a linter and code formatter
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-8\. 作为linter和代码格式化程序从pre-commit运行Ruff
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The pre-commit hook for the code formatter comes last. This gives it an opportunity
    to reformat any automatic fixes made by linters.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 代码格式化程序的pre-commit钩子最后运行。这为它提供了重新格式化任何由linters自动修复的机会。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you’ve seen how to improve and preserve the code quality in
    your projects using linters and code formatters. Ruff is an efficient reimplementation
    of many Python code-quality tools in Rust, including Flake8 and Black. While it’s
    possible to run Ruff and other tools manually, you should automate this process
    and include it as a mandatory check in CI. One of the best options is pre-commit,
    a cross-language linter framework with Git integration. Invoke pre-commit from
    a Nox session to keep a single entry point to your suite of checks.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经了解了如何通过使用 linter 和代码格式化工具来提高和保护项目中的代码质量。Ruff 是许多 Python 代码质量工具的高效重写，包括
    Flake8 和 Black。虽然可以手动运行 Ruff 和其他工具，但是您应该自动化此过程并将其作为 CI 中的强制性检查。最佳选项之一是 pre-commit，它是一个具有
    Git 集成的跨语言 linter 框架。从 Nox 会话中调用 pre-commit，以保持您的一套检查的单一入口点。
- en: ^([1](ch09.html#id311-marker)) The `B` short code activates a group of checks
    pioneered by `flake8-bugbear`, a plugin for the Flake8 linter.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch09.html#id311-marker)) `B` 短代码激活了由 `flake8-bugbear` 开创的一组检查，这是 Flake8
    linter 的一个插件。
- en: '^([2](ch09.html#id312-marker)) Charlie Marsh: [“Python tooling could be much,
    much faster”](https://notes.crmarsh.com/python-tooling-could-be-much-much-faster),
    August 30, 2022.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '^([2](ch09.html#id312-marker)) Charlie Marsh: [“Python tooling could be much,
    much faster”](https://notes.crmarsh.com/python-tooling-could-be-much-much-faster)，2022年8月30日。'
- en: ^([3](ch09.html#id313-marker)) As of this writing, you’ll also need to enable
    Ruff’s preview mode. Set `tool.ruff.lint.preview` to `true`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch09.html#id313-marker)) 在撰写本文时，您还需要启用 Ruff 的预览模式。将 `tool.ruff.lint.preview`
    设置为 `true`。
- en: ^([4](ch09.html#id314-marker)) My reviewer Hynek disagrees. He sets his projects
    to `ALL` and opts out of rules that don’t apply to him. “Otherwise, you’ll miss
    new rules. If something starts failing after an update, you can take action.”
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch09.html#id314-marker)) 我的审阅员 Hynek 不同意。他将项目设置为 `ALL` 并取消了对他不适用的规则。“否则，您会错过新规则。如果更新后出现问题，您可以采取行动。”
- en: ^([5](ch09.html#id315-marker)) What’s wrong with assertions? Nothing, but Python
    skips them when run with `-O` for optimizations—a common way to speed up production
    environments. So don’t use `assert` to validate untrusted input!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch09.html#id315-marker)) 断言有什么问题吗？没有，但是 Python 在优化运行时会跳过它们，使用 `-O` 命令行参数可以实现这一点——这是加速生产环境的常用方式。因此，不要使用
    `assert` 来验证不受信任的输入！
- en: '^([6](ch09.html#id316-marker)) Kent Beck and Martin Fowler describe *code smells*
    as “certain structures in the code that suggest—​sometimes, scream for—​the possibility
    of refactoring.” Martin Fowler: *Refactoring: Improving the Design of Existing
    Code*, Second Edition, Boston: Addison-Wesley, 2019.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '^([6](ch09.html#id316-marker)) Kent Beck 和 Martin Fowler 将 *code smells* 描述为“代码中的某些结构，暗示——有时候，大声呼喊——需要重构的可能性。”
    Martin Fowler: *Refactoring: Improving the Design of Existing Code*，第二版，波士顿：Addison-Wesley，2019年。'
- en: '^([7](ch09.html#id317-marker)) Running pre-commit from Git is the safest way
    to run linters with automatic fixes: Pre-commit saves and restores any changes
    you haven’t staged, and it rolls back the fixes if they conflict with your changes.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch09.html#id317-marker)) 从 Git 运行 pre-commit 是运行带有自动修复功能的 linter 的最安全方式：Pre-commit
    保存并恢复了您未暂存的任何更改，并在修复冲突时撤销这些修复。
- en: '^([8](ch09.html#id318-marker)) Charlie Marsh: [“The Ruff Formatter”](https://astral.sh/blog/the-ruff-formatter),
    October 24, 2023.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '^([8](ch09.html#id318-marker)) Charlie Marsh: [“The Ruff Formatter”](https://astral.sh/blog/the-ruff-formatter)，2023年10月24日。'
- en: ^([9](ch09.html#id319-marker)) Stephen C. Johnson, the author of Lint, also
    established this infamous naming convention by writing Yacc (Yet Another Compiler-Compiler)
    in the early 1970s at Bell Labs.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch09.html#id319-marker)) Lint 的作者 Stephen C. Johnson 也通过在 1970 年代早期在贝尔实验室编写
    Yacc（Yet Another Compiler-Compiler）来建立了这个臭名昭著的命名约定。
- en: '^([10](ch09.html#id320-marker)) [“AST before and after formatting,”](https://black.readthedocs.io/en/stable/the_black_code_style/current_style.html#labels-ast-changes)
    *Black documentation*. Last accessed: March 22, 2024.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch09.html#id320-marker)) [“AST before and after formatting,”](https://black.readthedocs.io/en/stable/the_black_code_style/current_style.html#labels-ast-changes)
    *Black documentation*，上次访问时间：2024年3月22日。
- en: ^([11](ch09.html#id321-marker)) You can inspect the AST of a source file with
    the standard `ast` module, using `py -m ast example.py`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch09.html#id321-marker)) 您可以使用标准 `ast` 模块检查源文件的 AST，使用 `py -m ast example.py`。
