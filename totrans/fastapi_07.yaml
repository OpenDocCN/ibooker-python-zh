- en: Chapter 5\. Pydantic, Type Hints, and Models Tour
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data validation and settings management using Python type hints.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fast and extensible, Pydantic plays nicely with your linters/IDE/brain. Define
    how data should be in pure, canonical Python 3.6+; validate it with Pydantic.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Samuel Colvin, developer of Pydantic
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Preview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FastAPI stands largely on a Python package called Pydantic. This uses *models*
    (Python object classes) to define data structures. These are heavily used in FastAPI
    applications and are a real advantage when writing larger applications.
  prefs: []
  type: TYPE_NORMAL
- en: Type Hinting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s time to learn a little more about Python *type hints*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2](ch02.html#ch02) mentioned that, in many computer languages, a variable
    points directly to a value in memory. This requires the programmer to declare
    its type, so the size and bits of the value can be determined. In Python, variables
    are just names associated with objects, and it’s the objects that have types.'
  prefs: []
  type: TYPE_NORMAL
- en: In standard programming, a variable is usually associated with the same object.
    If we associate a type hint with that variable, we can avoid some programming
    mistakes. So Python added type hinting to the language, in the standard typing
    module. The Python interpreter ignores the type hint syntax and runs the program
    as though it isn’t there. Then what’s the point?
  prefs: []
  type: TYPE_NORMAL
- en: You might treat a variable as a string in one line, and forget later and assign
    it an object of a different type. Although compilers for other languages would
    complain, Python won’t. The standard Python interpreter will catch normal syntax
    errors and runtime exceptions, but not mixing types for a variable. Helper tools
    like mypy pay attention to type hints and warn you about any mismatches.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the hints are available to Python developers, who can write tools that
    do more than type error checking. The following sections describe how the Pydantic
    package was developed to address needs that weren’t obvious. Later, you’ll see
    how its integration with FastAPI makes a lot of web development issues much easier
    to handle.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, what do type hints look like? There’s one syntax for variables and
    another for function return values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variable type hints may include only the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'or also initialize the variable with a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The *type* can be one of the standard Python simple types like `int` or `str`,
    or collection types like `tuple`, `list`, or `dict`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Before Python 3.9, you need to import capitalized versions of these standard
    type names from the typing module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples with initializations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also include subtypes of collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The typing module has useful extras for subtypes; the most common are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Any`'
  prefs: []
  type: TYPE_NORMAL
- en: Any type
  prefs: []
  type: TYPE_NORMAL
- en: '`Union`'
  prefs: []
  type: TYPE_NORMAL
- en: Any type of those specified, such as `Union[str, int]`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In Python 3.10 and up, you can say `*type1* | *type2*` instead of `Union[*type1*,
    *type2*]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of Pydantic definitions for a Python `dict` include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, a little more specific:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'or (Python 3.10 and up):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that a type-hinted variable line is legal Python, but a bare variable
    line is not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, incorrect type uses are not caught by the regular Python interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'But they will be caught by mypy. If you don’t already have it, run `pip install
    mypy`. Save those two preceding lines to a file called *stuff.py*,^([1](ch05.html#id541))
    and then try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'A function return type hint uses an arrow instead of a colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a Pydantic example of a function return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can use any type, including classes that you’ve defined or combinations
    of them. You’ll see that in a few pages.
  prefs: []
  type: TYPE_NORMAL
- en: Data Grouping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often we need to keep a related group of variables together rather than passing
    around lots of individual variables. How do we integrate multiple variables as
    a group and keep the type hints?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s leave behind our tepid greeting example from previous chapters and start
    using richer data from now on. As in the rest of this book, we’ll use examples
    of *cryptids* (imaginary creatures) and the (also imaginary) explorers who seek
    them. Our initial cryptid definitions will include only string variables for the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`'
  prefs: []
  type: TYPE_NORMAL
- en: Key
  prefs: []
  type: TYPE_NORMAL
- en: '`country`'
  prefs: []
  type: TYPE_NORMAL
- en: Two-character ISO country code (3166-1 alpha 2) or `*` = all
  prefs: []
  type: TYPE_NORMAL
- en: '`area`'
  prefs: []
  type: TYPE_NORMAL
- en: Optional; United States state or other country subdivision
  prefs: []
  type: TYPE_NORMAL
- en: '`description`'
  prefs: []
  type: TYPE_NORMAL
- en: Free-form
  prefs: []
  type: TYPE_NORMAL
- en: '`aka`'
  prefs: []
  type: TYPE_NORMAL
- en: Also known as…​
  prefs: []
  type: TYPE_NORMAL
- en: 'And explorers will have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`'
  prefs: []
  type: TYPE_NORMAL
- en: Key
  prefs: []
  type: TYPE_NORMAL
- en: '`country`'
  prefs: []
  type: TYPE_NORMAL
- en: Two-character ISO country code
  prefs: []
  type: TYPE_NORMAL
- en: '`description`'
  prefs: []
  type: TYPE_NORMAL
- en: Free-form
  prefs: []
  type: TYPE_NORMAL
- en: 'Python’s historic data grouping structures (beyond the basic `int`, `string`,
    and such) are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tuple`'
  prefs: []
  type: TYPE_NORMAL
- en: An immutable sequence of objects
  prefs: []
  type: TYPE_NORMAL
- en: '`list`'
  prefs: []
  type: TYPE_NORMAL
- en: A mutable sequence of objects
  prefs: []
  type: TYPE_NORMAL
- en: '`set`'
  prefs: []
  type: TYPE_NORMAL
- en: Mutable distinct objects
  prefs: []
  type: TYPE_NORMAL
- en: '`dict`'
  prefs: []
  type: TYPE_NORMAL
- en: Mutable key-value object pairs (the key needs to be of an immutable type)
  prefs: []
  type: TYPE_NORMAL
- en: Tuples ([Example 5-1](#ex-5-1)) and lists ([Example 5-2](#ex-5-2)) let you access
    a member variable only by its offset, so you have to remember what went where.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-1\. Using a tuple
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Example 5-2\. Using a list
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 5-3](#ex-5-3) shows that you can get a little more explanatory by
    defining names for the integer offsets.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-3\. Using tuples and named offsets
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Dictionaries are a little better in [Example 5-4](#ex-5-4), giving you access
    by descriptive keys.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-4\. Using a dictionary
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Sets contain only unique values, so they’re not very helpful for clustering
    various variables.
  prefs: []
  type: TYPE_NORMAL
- en: In [Example 5-5](#ex-5-5), a *named tuple* is a tuple that gives you access
    by integer offset *or* name.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-5\. Using a named tuple
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can’t say `namedtuple_thing["name"]`. It’s a `tuple`, not a `dict`, so the
    index needs to be an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 5-6](#ex-5-6) defines a new Python `class` and adds all the attributes
    with `self`. But you’ll need to do a lot of typing just to define them.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-6\. Using a standard class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You might think, what’s so bad about that? With a regular class, you can add
    more data (attributes), but especially behavior (methods). You might decide, one
    madcap day, to add a method that looks up an explorer’s favorite songs. (This
    wouldn’t apply to a creature.^([2](ch05.html#id551))) But the use case here is
    just to move a clump of data undisturbed among the layers, and to validate on
    the way in and out. Also, methods are square pegs that would struggle to fit in
    the round holes of a database.
  prefs: []
  type: TYPE_NORMAL
- en: Does Python have anything similar to what other computer languages call a *record*
    or a *struct* (a group of names and values)? A recent addition to Python is the
    *dataclass*. [Example 5-7](#ex-5-7) shows how all that `self` stuff disappears
    with dataclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-7\. Using a dataclass
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is pretty good for the keeping-variables-together part. But we want more,
    so let’s ask Santa for these:'
  prefs: []
  type: TYPE_NORMAL
- en: A *union* of possible alternative types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing/optional values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serialization to and from formats like JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It’s tempting to use Python’s built-in data structures, especially dictionaries.
    But you’ll inevitably find that dictionaries are a bit too “loose.” Freedom comes
    at a price. You need to check *everything*:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the key optional?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the key is missing, is there a default value?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the key exist?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If so, is the key’s value of the right type?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If so, is the value in the right range or matching a pattern?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At least three solutions address at least some of these requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Dataclasses](https://oreil.ly/mxANA)'
  prefs: []
  type: TYPE_NORMAL
- en: Part of standard Python.
  prefs: []
  type: TYPE_NORMAL
- en: '[attrs](https://www.attrs.org)'
  prefs: []
  type: TYPE_NORMAL
- en: Third party, but a superset of dataclasses.
  prefs: []
  type: TYPE_NORMAL
- en: '[Pydantic](https://docs.pydantic.dev)'
  prefs: []
  type: TYPE_NORMAL
- en: Also third party, but integrated into FastAPI, so an easy choice if you’re already
    using FastAPI. And if you’re reading this book, that’s likely.
  prefs: []
  type: TYPE_NORMAL
- en: A handy comparison of the three is on [YouTube](https://oreil.ly/pkQD3). One
    takeaway is that Pydantic stands out for validation, and its integration with
    FastAPI catches many potential data errors. Another is that Pydantic relies on
    inheritance (from the `BaseModel` class), and the other two use Python decorators
    to define their objects. This is more a matter of style.
  prefs: []
  type: TYPE_NORMAL
- en: In [another comparison](https://oreil.ly/gU28a), Pydantic outperformed older
    validation packages like [marshmallow](https://marshmallow.readthedocs.io) and
    the intriguingly named [Voluptuous](https://github.com/alecthomas/voluptuous).
    Another big plus for Pydantic is that it uses standard Python type hint syntax;
    older libraries pre-dated type hints and rolled their own.
  prefs: []
  type: TYPE_NORMAL
- en: So I’m going with Pydantic in this book, but you may find uses for either of
    the alternatives if you’re not using FastAPI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pydantic provides ways to specify any combination of these checks:'
  prefs: []
  type: TYPE_NORMAL
- en: Required versus optional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default value if unspecified but required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data type or types expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value range restrictions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other function-based checks if needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serialization and deserialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Simple Example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve seen how to feed a simple string to a web endpoint via the URL, a query
    parameter, or the HTTP body. The problem is that you usually request and receive
    groups of data, of many types. That’s where Pydantic models first appear in FastAPI.
  prefs: []
  type: TYPE_NORMAL
- en: 'This initial example will use three files:'
  prefs: []
  type: TYPE_NORMAL
- en: '*model.py* defines a Pydantic model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*data.py* is a fake data source, defining an instance of a model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*web.py* defines a FastAPI web endpoint that returns the fake data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For simplicity in this chapter, let’s keep all the files in the same directory.
    In later chapters that discuss larger websites, we’ll separate them into their
    respective layers. First, define the *model* for a creature in [Example 5-8](#ex-5-8).
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 5-8\. Define a creature model: model.py'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Creature` class inherits from Pydantic’s `BaseModel`. That `: str` part
    after `name`, `country`, `area`, `description`, and `aka` is a type hint that
    each is a Python string.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this example, all fields are required. In Pydantic, if `Optional` is not
    in the type description, the field must have a value.
  prefs: []
  type: TYPE_NORMAL
- en: In [Example 5-9](#ex-5-9), pass the arguments in any order if you include their
    names.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-9\. Create a creature
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: For now, [Example 5-10](#ex-5-10) defines a teeny source of data; in later chapters,
    databases will do this. The type hint `list[Creature]` tells Python that this
    is a list of `Creature` objects only.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-10\. Define fake data in data.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: (We’re using `"*"` for Bigfoot’s `area` because he’s almost everywhere.)
  prefs: []
  type: TYPE_NORMAL
- en: This code imports the *model.py* that we just wrote. It does a little data hiding
    by calling its list of `Creature` objects `_creatures`, and providing the `get_creatures()`
    function to return them.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 5-11](#ex-5-11) lists *web.py*, a file that defines a FastAPI web
    endpoint.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 5-11\. Define a FastAPI web endpoint: web.py'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now fire up this one-endpoint server in [Example 5-12](#ex-5-12).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-12\. Start Uvicorn
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In another window, [Example 5-13](#ex-5-13) accesses the web application with
    the HTTPie web client (try your browser or the Requests module if you like too).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-13\. Test with HTTPie
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: FastAPI and Starlette automatically convert the original `Creature` model object
    list into a JSON string. This is the default output format in FastAPI, so we don’t
    need to specify it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the window in which you originally started the Uvicorn web server should
    have printed a log line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Validate Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous section showed how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Apply type hints to variables and functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define and use a Pydantic model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return a list of models from a data source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return the model list to a web client, automatically converting the model list
    to JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s really put it to work validating data.
  prefs: []
  type: TYPE_NORMAL
- en: Try assigning a value of the wrong type to one or more of the `Creature` fields.
    Let’s use a standalone test for this (Pydantic doesn’t apply on any web code;
    it’s a data thing).
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 5-14](#ex-5-14) lists *test1.py*.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-14\. Test the Creature model
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now try the test in [Example 5-15](#ex-5-15).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-15\. Run the test
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This finds that we’ve assigned a list of strings to the `description` field,
    and it wants a plain old string.
  prefs: []
  type: TYPE_NORMAL
- en: Validate Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Even if the value’s type matches its specification in the `Creature` class,
    more checks may need to pass. Some restrictions can be placed on the value itself:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Integer (`conint`) or float:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gt`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Greater than
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`lt`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Less than
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ge`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Greater than or equal to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`le`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Less than or equal to
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`multiple_of`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: An integer multiple of a value
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'String (`constr`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min_length`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Minimum character (not byte) length
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`max_length`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Maximum character length
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`to_upper`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Convert to uppercase
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`to_lower`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Convert to lowercase
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`regex`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Match a Python regular expression
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Tuple, list, or set:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min_items`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Minimum number of elements
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`max_items`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Maximum number of elements
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These are specified in the type parts of the model.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 5-16](#ex-5-16) ensures that the `name` field is always at least two
    characters long. Otherwise, `""` (an empty string) is a valid string.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-16\. See a validation failure
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: That `constr` means a *constrained string*. [Example 5-17](#ex-5-17) uses an
    alternative, the Pydantic `Field` specification.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-17\. Another validation failure, using `Field`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: That `...` argument to `Field()` means that a value is required, and that there’s
    no default value.
  prefs: []
  type: TYPE_NORMAL
- en: This is a minimal introduction to Pydantic. The main takeaway is that it lets
    you automate the validation of your data. You’ll see how useful this is when getting
    data from either the Web or Data layers.
  prefs: []
  type: TYPE_NORMAL
- en: Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Models are the best way to define data that will be passed around in your web
    application. Pydantic leverages Python’s *type hints* to define data models to
    pass around in your application. Coming next: defining *dependencies* to separate
    specific details from your general code.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch05.html#id541-marker)) Do I have any detectable imagination? Hmm…​no.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch05.html#id551-marker)) Except that small group of yodeling yetis (a
    good name for a band).
  prefs: []
  type: TYPE_NORMAL
