- en: Appendix B. Supplementary Material
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This appendix contains some additional code related to the case studies presented
    in the book. You might find this material helpful to round out your understanding
    of the examples.
  prefs: []
  type: TYPE_NORMAL
- en: Cutlery Example Using Asyncio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[“Case Study: Robots and Cutlery”](ch02.html#robotcut) analyzed a race condition
    bug caused by multiple threads modifying the cutlery records in the global “kitchen”
    object instance. For completeness, here is how we might create an async version
    of the solution.'
  prefs: []
  type: TYPE_NORMAL
- en: There is a specific point I want to highlight about the *observability* of concurrency
    in the `asyncio` approach, shown in [Example B-1](#corobot).
  prefs: []
  type: TYPE_NORMAL
- en: Example B-1\. Cutlery management using asyncio
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_supplementary_material_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of a ThreadBot, we now have a CoroBot. This code sample uses only one
    thread, and that thread will be managing all 10 separate CoroBot object instances—one
    for each table in the restaurant.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_supplementary_material_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of `queue.Queue`, we’re using the `asyncio`-enabled queue.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_supplementary_material_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the main point: the only places at which execution can switch between
    different CoroBot instances is where the `await` keyword appears. It is *not possible*
    to have a context switch during the rest of this function, and this is why there
    is no race condition during the modification of the kitchen cutlery inventory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The presence of `await` keywords makes context switches *observable*. This
    makes it significantly easier to reason about any potential race conditions in
    concurrent applications. This version of the code always passes the test, no matter
    how many tasks are assigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This really isn’t impressive at all: it’s an entirely predictable outcome based
    on the fact that there are clearly no race conditions in the code. And that is
    *exactly* the point.'
  prefs: []
  type: TYPE_NORMAL
- en: Supplementary Material for News Website Scraper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This *index.html* file shown in [Example B-2](#indexhtml) is required to run
    the code in [“Case Study: Scraping the News”](ch04.html#scrapingthenews).'
  prefs: []
  type: TYPE_NORMAL
- en: Example B-2\. The index.html file required for the web scraping case study
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It’s a very basic template with rudimentary styling.
  prefs: []
  type: TYPE_NORMAL
- en: Supplementary Material for the ZeroMQ Case Study
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [“Case Study: Application Performance Monitoring”](ch04.html#appmon), I
    mentioned that you’ll need the HTML file being served to show the metrics charts.
    That file, *charts.html*, is presented in [Example B-3](#chartshtml). You should
    obtain a URL for *smoothie.min.js* from [Smoothie Charts](http://smoothiecharts.org)
    or one of the CDNs, and use that URL as the `src` attribute instead.'
  prefs: []
  type: TYPE_NORMAL
- en: Example B-3\. charts.html
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_supplementary_material_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`cpu` and `mem` are each a mapping of a color to a `TimeSeries()` instance.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_supplementary_material_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: One chart instance is created for CPU, and one for memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_supplementary_material_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: We create a `TimeSeries()` instance *inside* the `onmessage` event of the `EventSource()`
    instance. This means that any new data coming in (e.g., on a different color name)
    will automatically get a new time series created for it. The `add_timeseries()`
    function creates the `TimeSeries()` instance and adds to the given chart instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_supplementary_material_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `EventSource()` instance on the */feed* URL. The browser will connect
    to this endpoint on our server, (*metric_server.py*). Note that the browser will
    automatically try to reconnect if the connection is lost. Server-sent events are
    often overlooked, but in many situations their simplicity makes them preferable
    to WebSockets.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_supplementary_material_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The `onmessage` event will fire every time the server sends data. Here the data
    is parsed as JSON.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_supplementary_material_CO2-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the `cpu` identifier is a mapping of a color to a `TimeSeries()`
    instance. Here, we obtain that time series and append data to it. We also obtain
    the timestamp and parse it to get the correct format required by the chart.
  prefs: []
  type: TYPE_NORMAL
- en: Database Trigger Handling for the asyncpg Case Study
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [“Case Study: Cache Invalidation”](ch04.html#asyncpg_cs), one of the required
    Python source files was omitted in the interest of saving space. That file is
    presented in [Example B-4](#triggers).'
  prefs: []
  type: TYPE_NORMAL
- en: Example B-4\. triggers.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_supplementary_material_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: These functions require `asyncpg`, although this import is used only to allow
    `Connection` to be used in type annotations.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_supplementary_material_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `create_notify_trigger()` coroutine function will create the trigger function
    itself in the database. The trigger function will contain the name of the channel
    that updates will be sent to. The code for the function itself is in the `SQL_CREATE_TRIGGER`
    identifier, and it is set up as a format string.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_supplementary_material_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Recall from the case study example that update notifications included a “diff”
    section in which the difference between old and new data was shown. We use the
    `hstore` feature of PostgreSQL to calculate that diff. It provides something close
    to the semantics of sets. The `hstore` extension is not enabled by default, so
    we enable it here.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_supplementary_material_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The desired trigger name and channel are substituted into the template and then
    executed.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_supplementary_material_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The second function, `add_table_triggers()`, connects the trigger function to
    table events like insert, update, and delete.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_supplementary_material_CO3-6)'
  prefs: []
  type: TYPE_NORMAL
- en: There are three format strings for each of the three methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_supplementary_material_CO3-7)'
  prefs: []
  type: TYPE_NORMAL
- en: The desired variables are substituted into the templates and then executed.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_supplementary_material_CO3-8)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This SQL code took me a lot longer than expected to get exactly right! This
    PostgreSQL procedure is called for insert, update, and delete events; the way
    to know which is to check the `TG_OP` variable. If the operation is `INSERT`,
    then `NEW` will be defined (and `OLD` will *not* be defined). For `DELETE`, `OLD`
    will be defined but not `NEW`. For `UPDATE`, both are defined, which allows us
    to calculate the diff. We also make use of PostgreSQL’s built-in support for JSON
    with the `row_to_json()` and `hstore_to_json()` functions: these mean that our
    callback handler will receive valid JSON.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the call to the `pg_notify()` function is what actually sends the event.
    *All subscribers* on `{channel}` will receive the notification.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_supplementary_material_CO3-9)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is standard trigger code: it sets up a trigger to call a specific procedure
    `{trigger_name}()` when a specific event occurs, like an `INSERT` or an `UPDATE`.'
  prefs: []
  type: TYPE_NORMAL
- en: There are sure to be many useful applications that can be built around notifications
    received from PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Supplementary Material for the Sanic Example: aelapsed and aprofiler'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Sanic case study (see [*asyncpg* case study](ch04.html#asyncpg_cs)) included
    utility decorators for printing out elapsed time taken by a function. These are
    shown in [Example B-5](#aelapsed).
  prefs: []
  type: TYPE_NORMAL
- en: Example B-5\. perf.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_supplementary_material_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `aelapsed()` decorator will record the time taken to execute the wrapped
    coroutine.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_supplementary_material_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `aprofiler()` metaclass will make sure that every member of the class that
    is a coroutine function will get wrapped in the `aelapsed()` decorator.
  prefs: []
  type: TYPE_NORMAL
