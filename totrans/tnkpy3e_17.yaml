- en: 15\. Classes and Methods#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://allendowney.github.io/ThinkPython/chap15.html](https://allendowney.github.io/ThinkPython/chap15.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Python is an **object-oriented language** – that is, it provides features that
    support object-oriented programming, which has these defining characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the computation is expressed in terms of operations on objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects often represent things in the real world, and methods often correspond
    to the ways things in the real world interact.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programs include class and method definitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, in the previous chapter we defined a `Time` class that corresponds
    to the way people record the time of day, and we defined functions that correspond
    to the kinds of things people do with times. But there was no explicit connection
    between the definition of the `Time` class and the function definitions that follow.
    We can make the connection explicit by rewriting a function as a **method**, which
    is defined inside a class definition.
  prefs: []
  type: TYPE_NORMAL
- en: 15.1\. Defining methods[#](#defining-methods "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter we defined a class named `Time` and wrote a function
    named `print_time` that displays a time of day.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To make `print_time` a method, all we have to do is move the function definition
    inside the class definition. Notice the change in indentation.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, we’ll change the name of the parameter from `time` to `self`.
    This change is not necessary, but it is conventional for the first parameter of
    a method to be named `self`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To call this method, you have to pass a `Time` object as an argument. Here’s
    the function we’ll use to make a `Time` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: And here’s a `Time` instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now there are two ways to call `print_time`. The first (and less common) way
    is to use function syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this version, `Time` is the name of the class, `print_time` is the name
    of the method, and `start` is passed as a parameter. The second (and more idiomatic)
    way is to use method syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this version, `start` is the object the method is invoked on, which is called
    the **receiver**, based on the analogy that invoking a method is like sending
    a message to an object.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the syntax, the behavior of the method is the same. The receiver
    is assigned to the first parameter, so inside the method, `self` refers to the
    same object as `start`.
  prefs: []
  type: TYPE_NORMAL
- en: 15.2\. Another method[#](#another-method "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s the `time_to_int` function from the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: And here’s a version rewritten as a method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first line uses the special command `add_method_to`, which adds a method
    to a previously-defined class. This command works in a Jupyter notebook, but it
    is not part of Python, so it won’t work in other environments. Normally, all methods
    of a class are inside the class definition, so they get defined at the same time
    as the class. But for this book, it is helpful to define one method at a time.
  prefs: []
  type: TYPE_NORMAL
- en: As in the previous example, the method definition is indented and the name of
    the parameter is `self`. Other than that, the method is identical to the function.
    Here’s how we invoke it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It is common to say that we “call” a function and “invoke” a method, but they
    mean the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: 15.3\. Static methods[#](#static-methods "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As another example, let’s consider the `int_to_time` function. Here’s the version
    from the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This function takes `seconds` as a parameter and returns a new `Time` object.
    If we transform it into a method of the `Time` class, we have to invoke it on
    a `Time` object. But if we’re trying to create a new `Time` object, what are we
    supposed to invoke it on?
  prefs: []
  type: TYPE_NORMAL
- en: We can solve this chicken-and-egg problem using a **static method**, which is
    a method that does not require an instance of the class to be invoked. Here’s
    how we rewrite this function as a static method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Because it is a static method, it does not have `self` as a parameter. To invoke
    it, we use `Time`, which is the class object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The result is a new object that represents 9:40.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have `Time.from_seconds`, we can use it to write `add_time` as a
    method. Here’s the function from the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: And here’s a version rewritten as a method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`add_time` has `self` as a parameter because it is not a static method. It
    is an ordinary method – also called an **instance method**. To invoke it, we need
    a `Time` instance.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 15.4\. Comparing Time objects[#](#comparing-time-objects "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As one more example, let’s write `is_after` as a method. Here’s the `is_after`
    function, which is a solution to an exercise in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: And here it is as a method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Because we’re comparing two objects, and the first parameter is `self`, we’ll
    call the second parameter `other`. To use this method, we have to invoke it on
    one object and pass the other as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: One nice thing about this syntax is that it almost reads like a question, “`end`
    is after `start`?”
  prefs: []
  type: TYPE_NORMAL
- en: 15.5\. The `__str__` method[#](#the-str-method "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you write a method, you can choose almost any name you want. However, some
    names have special meanings. For example, if an object has a method named `__str__`,
    Python uses that method to convert the object to a string. For example, here is
    a `__str__` method for a time object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This method is similar to `print_time`, from the previous chapter, except that
    it returns the string rather than printing it.
  prefs: []
  type: TYPE_NORMAL
- en: You can invoke this method in the usual way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: But Python can also invoke it for you. If you use the built-in function `str`
    to convert a `Time` object to a string, Python uses the `__str__` method in the
    `Time` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: And it does the same if you print a `Time` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Methods like `__str__` are called **special methods**. You can identify them
    because their names begin and end with two underscores.
  prefs: []
  type: TYPE_NORMAL
- en: 15.6\. The **init** method[#](#the-init-method "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most special of the special methods is `__init__`, so-called because it
    initializes the attributes of a new object. An `__init__` method for the `Time`
    class might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now when we instantiate a `Time` object, Python invokes `__init__`, and passes
    along the arguments. So we can create an object and initialize the attributes
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the parameters are optional, so if you call `Time` with no
    arguments, you get the default values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If you provide one argument, it overrides `hour`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If you provide two arguments, they override `hour` and `minute`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: And if you provide three arguments, they override all three default values.
  prefs: []
  type: TYPE_NORMAL
- en: When I write a new class, I almost always start by writing `__init__`, which
    makes it easier to create objects, and `__str__`, which is useful for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 15.7\. Operator overloading[#](#operator-overloading "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By defining other special methods, you can specify the behavior of operators
    on programmer-defined types. For example, if you define a method named `__add__`
    for the `Time` class, you can use the `+` operator on Time objects.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an `__add__` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We can use it like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a lot happening when we run these three lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: When we instantiate a `Time` object, the `__init__` method is invoked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we use the `+` operator with a `Time` object, its `__add__` method is invoked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And when we print a `Time` object, its `__str__` method is invoked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the behavior of an operator so that it works with programmer-defined
    types is called **operator overloading**. For every operator, like `+`, there
    is a corresponding special method, like `__add__`.
  prefs: []
  type: TYPE_NORMAL
- en: 15.8\. Debugging[#](#debugging "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `Time` object is valid if the values of `minute` and `second` are between
    `0` and `60` – including `0` but not `60` – and if `hour` is positive. Also, `hour`
    and `minute` should be integer values, but we might allow `second` to have a fraction
    part. Requirements like these are called **invariants** because they should always
    be true. To put it a different way, if they are not true, something has gone wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Writing code to check invariants can help detect errors and find their causes.
    For example, you might have a method like `is_valid` that takes a Time object
    and returns `False` if it violates an invariant.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Then, at the beginning of each method you can check the arguments to make sure
    they are valid.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `assert` statement evaluates the expression that follows. If the result
    is `True`, it does nothing; if the result is `False`, it causes an `AssertionError`.
    Here’s an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`assert` statements are useful because they distinguish code that deals with
    normal conditions from code that checks for errors.'
  prefs: []
  type: TYPE_NORMAL
- en: 15.9\. Glossary[#](#glossary "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**object-oriented language:** A language that provides features to support
    object-oriented programming, notably user-defined types.'
  prefs: []
  type: TYPE_NORMAL
- en: '**method:** A function that is defined inside a class definition and is invoked
    on instances of that class.'
  prefs: []
  type: TYPE_NORMAL
- en: '**receiver:** The object a method is invoked on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**static method:** A method that can be invoked without an object as receiver.'
  prefs: []
  type: TYPE_NORMAL
- en: '**instance method:** A method that must be invoked with an object as receiver.'
  prefs: []
  type: TYPE_NORMAL
- en: '**special method:** A method that changes the way operators and some functions
    work with an object.'
  prefs: []
  type: TYPE_NORMAL
- en: '**operator overloading:** The process of using special methods to change the
    way operators with with user-defined types.'
  prefs: []
  type: TYPE_NORMAL
- en: '**invariant:** A condition that should always be true during the execution
    of a program.'
  prefs: []
  type: TYPE_NORMAL
- en: 15.10\. Exercises[#](#exercises "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 15.10.1\. Ask a virtual assistant[#](#ask-a-virtual-assistant "Link to this
    heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information about static methods, ask a virtual assistant:'
  prefs: []
  type: TYPE_NORMAL
- en: “What’s the difference between an instance method and a static method?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Why are static methods called static?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you ask a virtual assistant to generate a static method, the result will
    probably begin with `@staticmethod`, which is a “decorator” that indicates that
    it is a static method. Decorators are not covered in this book, but if you are
    curious, you can ask a VA for more information.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we rewrote several functions as methods. Virtual assistants
    are generally good at this kind of code transformation. As an example, paste the
    following function into a VA and ask it, “Rewrite this function as a method of
    the `Time` class.”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 15.10.2\. Exercise[#](#exercise "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous chapter, a series of exercises asked you to write a `Date` class
    and several functions that work with `Date` objects. Now let’s practice rewriting
    those functions as methods.
  prefs: []
  type: TYPE_NORMAL
- en: Write a definition for a `Date` class that represents a date – that is, a year,
    month, and day of the month.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write an `__init__` method that takes `year`, `month`, and `day` as parameters
    and assigns the parameters to attributes. Create an object that represents June
    22, 1933.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write `__str__` method that uses an f-string to format the attributes and returns
    the result. If you test it with the `Date` you created, the result should be `1933-06-22`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a method called `is_after` that takes two `Date` objects and returns `True`
    if the first comes after the second. Create a second object that represents September
    17, 1933, and check whether it comes after the first object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hint: You might find it useful write a method called `to_tuple` that returns
    a tuple that contains the attributes of a `Date` object in year-month-day order.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Think Python: 3rd Edition](https://allendowney.github.io/ThinkPython/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Copyright 2024 [Allen B. Downey](https://allendowney.com)
  prefs: []
  type: TYPE_NORMAL
- en: 'Code license: [MIT License](https://mit-license.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Text license: [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
  prefs: []
  type: TYPE_NORMAL
