- en: Chapter 2\. Automating Files and the Filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of Python’s most powerful features is its ability to manipulate text and
    files. In the DevOps world, you are continually parsing, searching, and changing
    the text in files, whether you’re searching application logs or propagating configuration
    files. Files are a means of persisting the state of your data, code, and configuration;
    they are how you look back at what happened in logs and how you control what happens
    with configuration. With Python, you can create, read, and change files and text
    in the code that you can use repeatedly. Automating these tasks is indeed one
    aspect of modern DevOps that separates it from traditional system administration.
    Rather than keeping a set of instructions that you have to follow manually, you
    can write code. This diminishes your chances of missing steps or doing them out
    of order. If you are confident that your system uses the same steps every time
    you run it, you can have greater understanding and confidence in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and Writing Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use the `open` function to create a file object that can read and write
    files. It takes two arguments, the path of the file and the mode (mode optionally
    defaults to reading). You use the mode to indicate, among other things, if you
    want to read or write a file and if it is text or binary data. You can open a
    text file using the mode *r* to read its contents. The file object has a `read`
    method that returns the contents of the file as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It is a good practice to close a file when you finish with it. Python closes
    a file when it is out of scope, but until then the file consumes resources and
    may prevent other processes from opening it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also read a file using the `readlines` method. This method reads the
    file and splits its contents on newline characters. It returns a list of strings.
    Each string is one line of the original text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A handy way of opening files is to use `with` statements. You do not need to
    close a file explicitly in this case. Python closes it and releases the file resource
    at the end of the indented block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Different operating systems use different escaped characters to represent line
    endings. Unix systems use `\n` and Windows systems use `\r\n`. Python converts
    these to `\n` when you open a file as text. If you are opening a binary file,
    such as a *.jpeg* image, you are likely to corrupt the data by this conversion
    if you open it as text. You can, however, read binary files by appending a *b*
    to mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Adding this opens the file without any line-ending conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write to a file, use the write mode, represented as the argument `w`. The
    tool `direnv` is used to automatically set up some development environments. You
    can define environment variables and application runtimes in a file named *.envrc*;
    `direnv` uses it to set these things up when you enter the directory with the
    file. You can set the environment variable `STAGE` to `PROD` and `TABLE_ID` to
    `token-storage-1234` in such a file in Python by using `open` with the `write`
    flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Be warned that `pathlib`’s `write` method will overwrite a file if it already
    exists.
  prefs: []
  type: TYPE_NORMAL
- en: The `open` function creates a file if it does not already exist and overwrites
    if it does. If you want to keep existing contents and only append the file, use
    the append flag `a`. This flag appends new text to the end of the file while keeping
    the original content. If you are writing nontext content, such as the contents
    of a *.jpeg* file, you are likely to corrupt it if you use either the `w` or `a`
    flag. This corruption is likely as Python converts line endings to platform-specific
    ones when it writes text data. To write binary data, you can safely use `wb` or
    `ab`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3](ch03.html#working_with_the_command_line) covers `pathlib` in depth.
    Two useful features are convenience functions for reading and writing files. `pathlib`
    handles the file object behind the scenes. The following allows you to read text
    from a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To read binary data, use the `path.read_bytes` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you want to overwrite a file or write a new file, there are methods for
    writing text and for writing binary data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Reading and writing using the file object’s `read` and `write` functions is
    usually adequate for unstructured text, but what if you are dealing with more
    complex data? The Javascript Object Notation (JSON) format is widely used to store
    simple structured data in modern web services. It uses two data structures: a
    mapping of key-value pairs similar to a Python `dict` and a list of items somewhat
    similar to a Python `list`. It defines data types for numbers, strings, *booleans*
    (which hold true/false values), and *nulls* (empty values). The AWS Identity and
    Access Management (IAM) web service allows you to control access to AWS resources.
    It uses JSON files to define access policies, as in this sample file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You could use the standard file object `read` or `readlines` methods to get
    the data from such a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The result would not be immediately usable, as it would be a single string
    or list of strings, depending on your chosen read method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You would then need to parse this string (or strings) into data structures
    and types that match the original, which may be a great deal of work. A far better
    way is to use the `json` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This module parses the JSON format for you, returning the data in appropriate
    Python data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `pprint` module automatically formats Python objects for printing. Its output
    is often more easily read and is a handy way of looking at nested data structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can use the data with the original file structure. For example, here
    is how you would change the resource whose access this policy controls to `S3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can write a Python dictionary as a JSON file by using the `json.dump` method.
    This is how you would update the policy file you just modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Another language commonly used in configuration files is *YAML* (“YAML Ain’t
    Markup Language”). It is a superset of JSON, but has a more compact format, using
    whitespace similar to how Python uses it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible is a tool used to automate software configuration, management, and
    deployment. Ansible uses files, referred to as *playbooks*, to define actions
    you want to automate. These playbooks use the YAML format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The most commonly used library for parsing YAML files in Python is PyYAML.
    It is not in the Python Standard Library, but you can install it using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, you can use PyYAML to import and export YAML data much as you
    did with JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The data loads as familiar Python data structures (a `list` containing a `dict`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also save Python data to a file in YAML format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Another language widely used for representing structured data is Extensible
    Markup Language (XML). It consists of hierarchical documents of tagged elements.
    Historically, many web systems used XML to transport data. One such use is for
    Real Simple Syndication (RSS) feeds. RSS feeds are used to track and notify users
    of updates to websites and have been used to track the publication of articles
    from various sources. RSS feeds use XML-formatted pages. Python offers the `xml`
    library for dealing with XML documents. It maps the XML documents’ hierarchical
    structure to a tree-like data structure. The nodes of the tree are elements, and
    a parent-child relationship is used to model the hierarchy. The top parent node
    is referred to as the root element. To parse an RSS XML document and get its root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can walk down the tree by iterating over the child nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'XML allows for *namespacing* (using tags to group data). XML prepends tags
    with namespaces enclosed in brackets. If you know the structure of the hierarchy,
    you can search for elements by using their paths. You can supply a dictionary
    that defines namespaces as a convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You may find yourself dealing with data stored as comma-separated values (CSV).
    This format is common for spreadsheet data. You can use the Python `csv` module
    to read these easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `csv` reader object iterates through the *.csv* file one line at a time,
    allowing you to process the data one row at a time. Processing a file this way
    is especially useful for large *.csv* files that you do not want to read into
    memory all at once. Of course, if you need to do multiple row calculations across
    columns and the file is not overly large, you should load it all at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Pandas package is a mainstay in the data science world. It includes a data
    structure, the `pandas.DataFrame`, which acts like a data table, similar to a
    very powerful spreadsheet. If you have table-like data on which you want to do
    statistical analysis or that you want to manipulate by rows and columns, DataFrames
    is the tool for you. It is a third-party library, so you need to install it with
    `pip`. You can use a variety of methods to load data into the DataFrames; one
    of the most common is from a *.csv* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can take a look at the top rows of your DataFrame using the `head` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can get a statistical insight using the `describe` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can view a single column of data by using its name in square
    brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Pandas has many more methods for analyzing and manipulating table-like data,
    and there are many books on its use. It is a tool you should be aware of if you
    have the need to do data analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Using Regular Expressions to Search Text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Apache HTTP server is an open source web server widely used to serve web
    content. The web server can be configured to save log files in different formats.
    One widely used format is the Common Log Format (CLF). A variety of log analysis
    tools can understand this format. Below is the layout of this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'What follows is an example line from a log in this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[Chapter 1](ch01.html#python_essentials_for_devops) introduced you to regular
    expressions and the Python `re` module, so let’s use it to pull information from
    a log in the common log format. One trick to constructing regular expressions
    is to do it in sections. Doing so enables you to get each subexpression working
    without the complication of debugging the whole expression. You can create a regular
    expression using named groups to pull out the IP address from a line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create a regular expression to get the time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You can grab multiple elements, as has been done here: the IP, user, time,
    and request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Parsing a single line of a log is interesting but not terribly useful. However,
    you can use this regular expression as a basis for designing one to pull information
    from the whole log. Let’s say you want to pull all of the IP addresses for `GET`
    requests that happened on November 8, 2019\. Using the preceding expression, you
    make modifications based on the specifics of your request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `finditer` method to process the log, printing the IP addresses of
    the matching lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There is a lot that you can do with regular expressions and texts of all sorts.
    If they do not daunt you, you will find them one of the most powerful tools in
    dealing with text.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with Large Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times that you need to process very large files. If the files contain
    data that can be processed one line at a time, the task is easy with Python. Rather
    than loading the whole file into memory as you have done up until now, you can
    read one line at a time, process the line, and then move to the next. The lines
    are removed from memory automatically by Python’s garbage collector, freeing up
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Python automatically allocates and frees memory. Garbage collection is one means
    of doing this. The Python garbage collector can be controlled using the `gc` package,
    though this is rarely needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that operating systems use alternate line endings can be a hassle
    when reading a file created on a different OS. Windows-created files have `\r`
    characters in addition to `\n`. These show up as part of the text on a Linux-based
    system. If you have a large file and you want to correct the line endings to fit
    your current OS, you can open the file, read one line at a time, and save it to
    a new file. Python handles the line-ending translation for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that you can nest the `with` statements to open two files at once and
    loop through the source file object one line at a time. You can define a generator
    function to handle this, especially if you need to parse multiple files a single
    line at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do not or cannot use line endings as a means of breaking up your data,
    as in the case of a large binary file, you can read your data in chunks. You pass
    the number of bytes read in each chunk to the file objects `read` method. When
    there is nothing left to read, the expression returns an empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Encrypting Text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many times you need to encrypt text to ensure security. In addition
    to Python’s built-in package `hashlib`, there is a widely used third-party package
    called `cryptography`. Let’s take a look at both.
  prefs: []
  type: TYPE_NORMAL
- en: Hashing with Hashlib
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To be secure, user passwords must be stored encrypted. A common way to handle
    this is to use a one-way function to encrypt the password into a bit string, which
    is very hard to reverse engineer. Functions that do this are called *hash functions*.
    In addition to obscuring passwords, hash functions ensure that documents sent
    over the web are unchanged during transmission. You run the hash function on the
    document and send the result along with the document. The recipient can then confirm
    that the value is the same when they hash the document. The `hashlib` includes
    secure algorithms for doing this, including *SHA1*, *SHA224*, *SHA384*, *SHA512*,
    and RSA’s *MD5*. This is how you would hash a password using the MD5 algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Notice that if your password or document is a string, you need to turn it into
    a binary string by using the `encode` method.
  prefs: []
  type: TYPE_NORMAL
- en: Encryption with Cryptography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `cryptography` library is a popular choice for handling encryption problems
    in Python. It is a third-party package, so you must install it with `pip`. *Symmetric
    key encryption* is a group of encryption algorithms based on shared keys. These
    algorithms include Advanced Encryption Algorithm (AES), Blowfish, Data Encryption
    Standard (DES), Serpent, and Twofish. A shared key is similar to a password that
    is used to both encrypt and decrypt text. The fact that both the creator and the
    reader of an encrypted file need to share the key is a drawback when compared
    to *asymmetric key encryption*, which we will touch on later. However, symmetric
    key encryption is faster and more straightforward, and so is appropriate for encrypting
    large files. Fernet is an implementation of the popular AES algorithm. You first
    need to generate a key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to store this key securely, as you need it to decrypt. Keep in mind
    that anyone who has access to it is also able to decrypt your files. If you choose
    to save the key to a file, use the binary data type. The next step is to encrypt
    the data using the `Fernet` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You can decrypt the data using a `Fernet` object created with the same key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Asymmetric key encryption uses a pair of keys, one public and one private.
    The public key is designed to be widely shared, while a single user holds the
    private one. The only way you can decrypt messages that have been encrypted using
    your public key is by using your private key. This style of encryption is widely
    used to pass information confidentially both on local networks and across the
    internet. One very popular asymmetric key algorithm is Rivest-Shamir-Adleman (RSA),
    which is widely used for communication across networks. The cryptography library
    offers the ability to create public/private key pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then use the public key to encrypt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the private key to decrypt messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The os Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `os` module is one of the most used modules in Python. This module handles
    many low-level operating system calls and attempts to offer a consistent interface
    across multiple operating systems, which is important if you think your application
    might run on both Windows and Unix-based systems. It does offer some operating-specific
    features (`os.O_TEXT` for Windows and `os.O_CLOEXEC` on Linux) that are not available
    across platforms. Use these only if you are confident that your application does
    not need to be portable across operating systems. [Example 2-1](#Example-2-1)
    shows some of the most useful additional methods of the `os` module.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-1\. More os methods
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_automating_files_and_the_filesystem_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: List the contents of a directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_automating_files_and_the_filesystem_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Rename a file or directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_automating_files_and_the_filesystem_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Change the permission settings of a file or directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_automating_files_and_the_filesystem_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_automating_files_and_the_filesystem_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Recursively create a directory path.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_automating_files_and_the_filesystem_CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Delete a file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_automating_files_and_the_filesystem_CO1-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Delete a single directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_automating_files_and_the_filesystem_CO1-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Delete a tree of directories, starting with the leaf directory and working up
    the tree. The operation stops with the first nonempty directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_automating_files_and_the_filesystem_CO1-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Get stats about the file or directory. These stats include `st_mode`, the file
    type and permissions, and `st_atime`, the time the item was last accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Files and Directories Using os.path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Python, you can use strings (binary or otherwise) to represent paths. The
    `os.path` module offers a plethora of path-related methods for creating and manipulating
    paths as strings. As previously mentioned, the `os` module tries to offer cross-platform
    behaviors, and the `os.path` submodule is no exception. This module interprets
    paths based on the current operating system, using forward slashes to separate
    directories in Unix-like systems and backward slashes in Windows. Your program
    can construct paths on the fly that work on the current system, whichever it is.
    The ability to easily split and join paths is probably the most used functionality
    of `os.path`. The three methods used to split paths are `split`, `basename`, and
    `dirname`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_automating_files_and_the_filesystem_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Get the current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_automating_files_and_the_filesystem_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`os.path.split` splits the leaf level of the path from the parent path.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_automating_files_and_the_filesystem_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '`os.path.dirname` returns the parent path.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_automating_files_and_the_filesystem_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: '`os.path.basename` returns the leaf name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily use `os.path.dirname` to walk up a directory tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Using files to configure an application at runtime is a common practice; files
    in Unix-like systems are named by convention as dotfiles ending with *rc*. Vim’s
    *.vimrc* file and the Bash shell’s *.bashrc* are two common examples. You can
    store these files in different locations. Often programs will define a hierarchy
    of locations to check. For example, your tool might look first for an environment
    variable that defines which *rc* file to use, and in its absence, check the working
    directory, and then the user’s home directory. In [Example 2-2](#Example-2-2)
    we try to locate an *rc* file in these locations. We use the `*file*` variable
    that Python automatically sets when Python code runs from a file. This variable
    is populated with a path relative to the current working directory, not an absolute
    or full path. Python does not automatically expand paths, as is common in Unix-like
    systems, so we must expand this path before we use it to construct the path to
    check our *rc* file. Similarly, Python does not automatically expand environment
    variables in paths, so we must expand these explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-2\. find_rc method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_automating_files_and_the_filesystem_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether the environment variable exists in the current environment.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_automating_files_and_the_filesystem_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `join` to construct a path with the environment variable name. This will
    look something like `$EXAMPLERC_DIR/.examplerc`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_automating_files_and_the_filesystem_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Expand the environment variable to insert its value into the path.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_automating_files_and_the_filesystem_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Check to see if the file exists.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_automating_files_and_the_filesystem_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a path using the current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_automating_files_and_the_filesystem_CO3-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `expanduser` function to get the path to the user’s home directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_automating_files_and_the_filesystem_CO3-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Expand the relative path stored in `*file*` to an absolute path.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_automating_files_and_the_filesystem_CO3-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `dirname` to get the path to the directory holding the current file.
  prefs: []
  type: TYPE_NORMAL
- en: The `path` submodule also offers ways to interrogate stats about a path. You
    can determine if a path is a file, a directory, a link, or a mount. You can get
    stats such as it’s size or time of last access or modification. In [Example 2-3](#Example-2-3)
    we use `path` to walk down a directory tree and report on the size and last access
    time of all files therein.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-3\. os_path_walk.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_automating_files_and_the_filesystem_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`os.listdir` returns the contents of a directory.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_automating_files_and_the_filesystem_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Construct the full path of an item in the parent directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_automating_files_and_the_filesystem_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Check to see if the path represents a file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_automating_files_and_the_filesystem_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Get the last time the file was accessed.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_automating_files_and_the_filesystem_CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Get the size of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_automating_files_and_the_filesystem_CO4-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Check if the path represents a directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_automating_files_and_the_filesystem_CO4-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Check the tree from this directory down.
  prefs: []
  type: TYPE_NORMAL
- en: You could use a script like this to identify large files or files that have
    not been accessed and then report, move, or delete them.
  prefs: []
  type: TYPE_NORMAL
- en: Walking Directory Trees Using os.walk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `os` module offers a convenience function for walking directory trees called
    `os.walk`. This function returns a generator that in turn returns a tuple for
    each iteration. The tuple consists of the current path, a list of directories,
    and a list of files. In [Example 2-4](#Example-2-4) we rewrite our `walk_path`
    function from [Example 2-3](#Example-2-3) to use `os.walk`. As you can see in
    this example, with `os.walk` you don’t need to test which paths are files or recall
    the function with every subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-4\. Rewrite walk_path
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Paths as Objects with Pathlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `pathlib` library represents paths as objects rather than strings. In [Example 2-5](#Example-2-5)
    we rewrite [Example 2-2](#Example-2-2) using `pathlib` rather than `os.path`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-5\. rewrite find_rc
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_automating_files_and_the_filesystem_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: As of this writing, `pathlib` does not expand environment variables. Instead
    you grab the value of the variable from `os.environ`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_automating_files_and_the_filesystem_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This creates a `pathlib.Path` object appropriate for the currently running operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_automating_files_and_the_filesystem_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: You can construct new `pathlib.Path` objects by following a parent path with
    forward slashes and strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_automating_files_and_the_filesystem_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `pathlib.Path` object itself has an `exists` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_automating_files_and_the_filesystem_CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Call `as_postix` to return the path as a string. Depending on your use case,
    you can return the `pathlib.Path` object itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_automating_files_and_the_filesystem_CO5-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The class method `pathlib.Path.cwd` returns a `pathlib.Path` object for the
    current working directory. This object is used immediately here to create the
    `config_path` by joining it with the string `rc_name`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_automating_files_and_the_filesystem_CO5-7)'
  prefs: []
  type: TYPE_NORMAL
- en: The class method `pathlib.Path.home` returns a `pathlib.Path` object for the
    current user’s home directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_automating_files_and_the_filesystem_CO5-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `pathlib.Path` object using the relative path stored in `*file*` and
    then call its `resolve` method to get the absolute path.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](assets/9.png)](#co_automating_files_and_the_filesystem_CO5-9)'
  prefs: []
  type: TYPE_NORMAL
- en: This returns a parent `pathlib.Path` object directly from the object itself.
  prefs: []
  type: TYPE_NORMAL
