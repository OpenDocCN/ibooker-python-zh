# 前言

> 原文：[Preface](https://www.cosmicpython.com/book/preface.html)
> 
> 译者：[飞龙](https://github.com/wizardforcel)
> 
> 协议：[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/)

也许你会想知道我们是谁，为什么要写这本书。

在 Harry 的最后一本书[*Test-Driven Development with Python*](http://obeythetestinggoat.com)（O'Reilly）中，他发现自己对架构提出了一堆问题，比如，如何构建应用程序的最佳结构，以便易于测试？更具体地说，如何确保核心业务逻辑由单元测试覆盖，并最小化需要的集成和端到端测试的数量？他模糊地提到了“六边形架构”、“端口和适配器”和“功能核心，命令式外壳”，但如果他诚实的话，他不得不承认这些并不是他真正理解或实践过的东西。

然后他很幸运地遇到了 Bob，他对所有这些问题都有答案。

Bob 最终成为了一名软件架构师，因为他所在团队中没有其他人在做这件事。结果他发现自己在这方面表现得相当糟糕，但*他*很幸运地遇到了 Ian Cooper，后者教会了他关于编写和思考代码的新方法。

# 管理复杂性，解决业务问题

我们都在 MADE.com 工作，这是一家在欧洲在线销售家具的电子商务公司；在那里，我们应用这本书中的技术来构建模拟现实世界业务问题的分布式系统。我们的示例领域是 Bob 为 MADE 建立的第一个系统，这本书试图记录下我们在加入我们团队的新程序员时需要教授的所有*东西*。

MADE.com 在全球范围内运营货运合作伙伴和制造商的供应链。为了降低成本，我们努力优化库存的交付到我们的仓库，以便我们不会有未售出的商品堆积在这里。

理想情况下，你想要购买的沙发将在你决定购买的当天到达港口，然后我们会直接将其运送到你的家，而不会存放。当货物需要三个月才能通过集装箱船到达时，把握时机是一个棘手的平衡行为。在这个过程中，货物会损坏或水损，风暴会导致意外延迟，物流合作伙伴会处理不当，文件会丢失，客户会改变主意并修改订单，等等。

我们通过构建智能软件来解决这些问题，这些软件代表了现实世界中发生的各种操作，以便我们尽可能地自动化业务的大部分内容。

# 为什么选择 Python？

如果你正在阅读这本书，我们可能不需要说服你 Python 有多么棒，所以真正的问题是“为什么*Python*社区需要这样一本书？”答案与 Python 的流行和成熟度有关：尽管 Python 可能是世界上增长最快的编程语言，接近绝对流行榜的顶端，但它才刚刚开始解决 C#和 Java 世界多年来一直在处理的那种问题。初创公司变成真正的企业；Web 应用程序和脚本自动化正在成为（小声说）*企业* *软件*。

在 Python 世界中，我们经常引用 Python 之禅：“应该有一种——最好只有一种——明显的方法来做到这一点。”¹不幸的是，随着项目规模的增长，做事情的最明显方式并不总是帮助你管理复杂性和不断变化的需求的方式。

我们在这本书中讨论的所有技术和模式都不是新的，但它们在 Python 世界中大多是新的。这本书也不是领域驱动设计等领域的经典著作的替代品，比如 Eric Evans 的*Domain-Driven Design*或 Martin Fowler 的*Patterns of Enterprise Application Architecture*（Addison-Wesley Professional 出版）——我们经常参考并鼓励你去阅读。

但是，文献中所有经典的代码示例往往都是用 Java 或 C++/#编写的，如果您是 Python 人，并且很长时间没有使用过这两种语言（或者根本没有使用过），那么这些代码清单可能会相当困难。这就是为什么另一本经典文本《重构》（Addison-Wesley Professional）的最新版本是用 JavaScript 编写的原因。

# TDD、DDD 和事件驱动架构

按照声名显赫的顺序，我们知道三种管理复杂性的工具：

1.  *测试驱动开发*（TDD）帮助我们构建正确的代码，并使我们能够进行重构或添加新功能，而不用担心回归。但是，如何确保测试尽可能快地运行？我们如何确保从快速、无依赖的单元测试中获得尽可能多的覆盖和反馈，并且具有最少数量的较慢、不稳定的端到端测试？

1.  *领域驱动设计*（DDD）要求我们将努力集中在构建业务领域的良好模型上，但我们如何确保我们的模型不受基础设施问题的影响，不会变得难以更改？

1.  松散耦合（微）服务通过消息集成（有时称为*反应式微服务*）是管理多个应用程序或业务领域复杂性的一种成熟解决方案。但如何使它们与 Python 世界中已建立的工具（如 Flask、Django、Celery 等）相适应并不总是显而易见。

###### 注意

如果您不使用（或对）微服务不感兴趣，也不要被吓到。我们讨论的大多数模式，包括大部分事件驱动架构材料，在单体架构中也是完全适用的。

我们的目标是介绍几种经典的架构模式，并展示它们如何支持 TDD、DDD 和事件驱动服务。我们希望它能作为在 Python 中实现它们的参考，并且人们可以将其用作进一步研究这一领域的第一步。

# 谁应该阅读本书

以下是我们对您的一些假设，亲爱的读者：

+   您曾接触过一些相当复杂的 Python 应用程序。

+   您已经看到了尝试管理这种复杂性所带来的一些痛苦。

+   您不一定了解 DDD 或任何经典应用程序架构模式。

我们围绕一个示例应用程序来探讨架构模式，逐章构建它。我们在工作中使用 TDD，所以我们倾向于先展示测试清单，然后是实现。如果您不习惯先测试工作，开始时可能会感到有点奇怪，但我们希望您很快就会习惯在看到代码“被使用”（即从外部）之前先看到它是如何在内部构建的。

我们使用一些特定的 Python 框架和技术，包括 Flask、SQLAlchemy 和 pytest，以及 Docker 和 Redis。如果您已经熟悉它们，那不会有什么坏处，但我们认为这并非必需。本书的主要目标之一是构建一个特定技术选择变成次要实现细节的架构。

# 您将学到的简要概述

本书分为两部分；以下是我们将涵盖的主题以及它们所在的章节。

## [第一部分，*构建支持领域建模的架构*](part01.xhtml#part1)

领域建模和 DDD（第 1 章和第 7 章）

在某个层面上，每个人都学到了一个教训，即复杂的业务问题需要在代码中反映出来，以领域模型的形式。但为什么总是似乎如此难以做到而不陷入基础设施问题、web 框架或其他问题？在第一章中，我们对*领域建模*和 DDD 进行了广泛概述，并展示了如何开始一个没有外部依赖和快速单元测试的模型。后来，我们回到 DDD 模式，讨论如何选择正确的聚合，以及这个选择与数据完整性问题的关系。

仓储、服务层和工作单元模式（第 2、4 和 5 章）

在这三章中，我们提出了三种密切相关且相互加强的模式，以支持我们保持模型不受外部依赖的野心。我们在持久存储周围构建了一个抽象层，并建立了一个服务层来定义系统的入口点并捕获主要用例。我们展示了这一层如何使得构建系统的薄入口变得容易，无论是 Flask API 还是 CLI。

关于测试和抽象的一些想法（第 3 和 6 章）

在介绍第一个抽象（仓储模式）之后，我们有机会进行一般性讨论，讨论如何选择抽象，以及它们在选择我们的软件如何耦合在一起方面的作用。在介绍服务层模式之后，我们稍微谈了一下如何实现*测试金字塔*，以及在最高可能的抽象级别编写单元测试。

## [第二部分，*事件驱动架构*](part02.xhtml#part2)

事件驱动架构（第 8-11 章）

我们介绍了另外三种相互加强的模式：领域事件、消息总线和处理程序模式。*领域事件*是捕获系统某些交互触发其他交互的一种方式。我们使用*消息总线*允许动作触发事件并调用适当的*处理程序*。我们继续讨论事件如何作为微服务架构中服务之间集成的模式。最后，我们区分了*命令*和*事件*。我们的应用现在基本上是一个消息处理系统。

命令查询职责分离（第十二章）

我们提供了一个*命令查询职责分离*的示例，有和没有事件。

依赖注入（第十三章）

我们整理了显式和隐式的依赖关系，并实现了一个简单的依赖注入框架。

## 额外内容

我怎样才能从这里到那里？（后记）

当你展示一个简单的例子，从头开始实现架构模式总是看起来很容易，但你们中的许多人可能会想知道如何将这些原则应用到现有软件中。我们将在后记中提供一些指引和一些进一步阅读的链接。

# 示例代码和编码过程

你正在阅读一本书，但你可能会同意我们的观点，即了解代码的最佳方式是编写代码。我们大部分知识都是通过与他人配对、与他们一起编写代码并通过实践学习而得到的，我们希望在这本书中尽可能多地为你重新创造那种经验。

因此，我们围绕一个单一的示例项目构建了这本书（尽管我们有时会加入其他示例）。随着章节的进展，我们将逐步构建这个项目，就好像你和我们一起配对，我们在每一步都解释我们在做什么以及为什么。

但要真正掌握这些模式，你需要动手编写代码，了解它的工作原理。你可以在 GitHub 上找到所有的代码；每个章节都有自己的分支。你也可以在 GitHub 上找到[分支列表](https://github.com/cosmicpython/code/branches/all)。

这里有三种你可以跟着书本编码的方式：

+   创建自己的存储库，并尝试按照书中的示例构建应用程序，并偶尔查看我们的存储库以获取提示。但是，需要警告一句：如果您已经阅读了哈里的上一本书，并且跟着书本编码，您会发现这本书需要您更多地自己解决问题；您可能需要在 GitHub 上的工作版本上依赖得更多。

+   尝试将每个模式逐章应用到您自己的（最好是小型/玩具）项目中，看看是否可以让它适用于您的用例。这是高风险/高回报（除了高努力之外！）。让事情适应您的项目的具体情况可能需要相当多的工作，但另一方面，您可能会学到最多。

+   在每一章中，我们都会概述一个“读者练习”，并指向一个 GitHub 位置，您可以在其中下载一些部分完成的代码，该代码缺少一些部分需要您自己编写。

特别是如果您打算在自己的项目中应用其中一些模式，通过简单的示例进行实践是一个安全的练习方式。

###### 提示

至少在阅读每一章时，从我们的存储库中进行`git checkout`。能够随时跳转并查看代码在实际工作应用中的上下文将有助于解答许多问题，并使一切更加真实。您将在每章的开头找到如何执行此操作的说明。

# 许可证

该代码（以及书的在线版本）根据知识共享 CC BY-NC-ND 许可证许可，这意味着您可以自由复制和与任何人分享，只要您进行归因，且用于非商业目的。如果您想重复使用本书中的任何内容，并且对许可证有任何疑虑，请联系 O'Reilly，邮箱为[*permissions@oreilly.com*](mailto:permissions@oreilly.com)。

印刷版的许可证不同，请参阅版权页。

# 本书使用的约定

本书中使用以下排版约定：

*斜体*

指示新术语、URL、电子邮件地址、文件名和文件扩展名。

`等宽`

用于程序清单，以及在段萂中用于引用程序元素，如变量或函数名称、数据库、数据类型、环境变量、语句和关键字。

**`等宽粗体`**

显示用户应该按字面输入的命令或其他文本。

*`等宽斜体`*

显示应该由用户提供的值或由上下文确定的值替换的文本。

###### 提示

此元素表示提示或建议。

###### 注意

此元素表示一般说明。

###### 警告

此元素表示警告或注意。

# O'Reilly 在线学习

###### 注意

40 多年来，[*O'Reilly Media*](http://oreilly.com)已经提供技术和商业培训、知识和见解，帮助公司取得成功。

我们独特的专家和创新者网络通过书籍、文章、会议和我们的在线学习平台分享他们的知识和专长。O'Reilly 的在线学习平台为您提供按需访问实时培训课程、深入学习路径、交互式编码环境以及来自 O'Reilly 和其他 200 多家出版商的大量文本和视频。有关更多信息，请访问[*http://oreilly.com*](http://oreilly.com)。

# 如何联系 O'Reilly

请将有关本书的评论和问题发送给出版商：

+   O'Reilly Media, Inc.

+   1005 Gravenstein Highway North

+   Sebastopol, CA 95472

+   800-998-9938（在美国或加拿大）

+   707-829-0515（国际或本地）

+   707-829-0104（传真）

我们为这本书建立了一个网页，列出勘误、示例和任何额外信息。您可以在[*https://oreil.ly/architecture-patterns-python*](https://oreil.ly/architecture-patterns-python)上访问这个页面。

给[*bookquestions@oreilly.com*](mailto:bookquestions@oreilly.com)发邮件，评论或提出关于这本书的技术问题。

有关我们的图书、课程、会议和新闻的更多信息，请访问我们的网站[*http://www.oreilly.com*](http://www.oreilly.com)。

在 Facebook 上找到我们：[*http://facebook.com/oreilly*](http://facebook.com/oreilly)

在 Twitter 上关注我们：[*http://twitter.com/oreillymedia*](http://twitter.com/oreillymedia)

在 YouTube 上观看我们：[*http://www.youtube.com/oreillymedia*](http://www.youtube.com/oreillymedia)

# 致谢

对于我们的技术审阅者 David Seddon，Ed Jung 和 Hynek Schlawack：我们绝对配不上你们。你们都非常专注、尽责和严谨。你们每个人都非常聪明，你们不同的观点对彼此都非常有用和互补。我们由衷地感谢你们。

还要特别感谢我们的早期读者，感谢他们的评论和建议：Ian Cooper，Abdullah Ariff，Jonathan Meier，Gil Gonçalves，Matthieu Choplin，Ben Judson，James Gregory，Łukasz Lechowicz，Clinton Roy，Vitorino Araújo，Susan Goodbody，Josh Harwood，Daniel Butler，Liu Haibin，Jimmy Davies，Ignacio Vergara Kausel，Gaia Canestrani，Renne Rocha，pedroabi，Ashia Zawaduk，Jostein Leira，Brandon Rhodes 等等；如果我们在这个名单上漏掉了你，我们向你道歉。

特别感谢我们的编辑 Corbin Collins，他的温和督促和对读者的不懈支持。同样特别感谢制作人员 Katherine Tozer，Sharon Wilkey，Ellen Troutman-Zaig 和 Rebecca Demarest，感谢你们的专业精神和对细节的关注。这本书因为有了你们而得到了极大的改善。

书中仍然存在的任何错误都是我们自己的。

¹ `python -c "import this"`
