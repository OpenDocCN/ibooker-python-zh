- en: 8 Debugging and better understanding your code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 调试并更好地理解你的代码
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章内容包括
- en: Determining the source of a bug
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定 bug 的来源
- en: Fixing errors with Copilot techniques
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Copilot 技巧修复错误
- en: Debugging code with Copilot
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Copilot 调试代码
- en: Using the VS Code debugger to see how code is functioning
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 VS Code 调试器查看代码的运行情况
- en: There will be a point in every programmer’s career when their code isn’t doing
    what they want it to do. This has likely happened to you already, and, rest assured,
    it’s a normal part of learning to program. How do we fix the code? Sometimes,
    changing the prompt or better decomposing the problem like you learned in earlier
    chapters is sufficient to fix the problem. But what do you do when you just can’t
    get Copilot to give you different or better code, nor can you figure out why the
    code you’ve been given doesn’t work properly?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序员的职业生涯中，都会遇到代码无法按预期运行的情况。这可能已经发生在你身上了，放心，这是学习编程过程中很正常的一部分。我们该如何修复代码呢？有时，仅仅改变提示语或更好地分解问题（就像你在之前的章节中学到的那样）就足以解决问题。但当你无法让
    Copilot 给你不同或更好的代码，或者无法弄清楚为何你得到的代码无法正常工作时该怎么办呢？
- en: This chapter serves two purposes. The primary goal is to learn how to find errors
    (called bugs) in the code and fix them. To find those bugs, you’ll need to fulfill
    the second goal, which is gaining a deeper understanding of how your code works
    while you’re running it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有两个目的。主要目标是学习如何找到代码中的错误（称为 bug）并修复它们。为了找到这些 bugs，你需要实现第二个目标，即在运行代码时更深入地理解你的代码是如何工作的。
- en: The good news is that having an error in your code is such a common occurrence
    for programmers that programming environments, such as Visual Studio Code (VS
    Code), have tools to help us uncover what’s going wrong. We’ll learn how to use
    that tool, called a debugger, in this chapter as well.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，代码中出现错误对程序员来说是再常见不过的事情，因此编程环境（如 Visual Studio Code，VS Code）提供了帮助我们发现问题的工具。在本章中，我们将学习如何使用这个叫做调试器的工具。
- en: Like the past few chapters where we started small, we’ll learn the concepts
    behind finding and fixing errors with some small examples, and then we’ll more
    authentically showcase the process by diving into a larger example that’s similar
    to the kind of code you’re likely to write in the future.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在之前几章中我们从小例子开始一样，我们将通过一些小例子来学习如何找到和修复错误的概念，然后通过深入一个更大的示例来更真实地展示这个过程，这个示例类似于你未来可能编写的代码。
- en: 8.1 What causes errors (bugs)?
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 错误（bug）是如何产生的？
- en: First up is a quick terminology lesson. Many decades ago, computers used relays
    or vacuum tubes rather than transistors. The story goes that Dr. Grace Hopper,
    while programming one of these early computers, experienced an error caused by
    an actual bug (a moth) in a relay. Today, we use the term bug to refer to a mistake
    in a program, though we’re not dealing with literal bugs anymore. Now, bugs are
    caused by mistakes by programmers; when we debug our code, we’re working on removing
    those bugs. (There can be bugs in the implementation of Python itself or even
    in computer hardware, but they are so rare, it’s safe to assume an error in your
    code is because of your code.)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是一个简短的术语课程。几十年前，计算机使用继电器或真空管，而不是晶体管。故事是这样的：Grace Hopper 博士在编程早期的计算机时，遇到了一次由继电器中的一只真实的虫子（蛾）引起的错误。今天，我们使用“bug”这个词来指代程序中的错误，尽管我们现在不再处理真实的虫子了。现在，bug
    是由程序员的错误引起的；当我们调试代码时，我们是在去除这些 bugs。（Python 本身的实现或者计算机硬件中也可能存在 bugs，但它们非常罕见，所以我们可以假设代码中的错误是由于代码本身的原因。）
- en: 'No one intentionally causes bugs in their code if they are genuinely trying
    to solve a problem. So why do bugs happen? Well, software engineers, and Copilot,
    make mistakes. What kind of mistakes you might ask? There are two primary categories
    of bugs:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序员真心想解决问题，他们是不会故意在代码中引入 bug 的。那么，为什么会出现 bug 呢？软件工程师和 Copilot 也会犯错误。你可能会问，是什么样的错误呢？有两种主要的
    bug 类别：
- en: '***Syntax errors*—These errors occur when the code doesn’t follow the Python
    syntax requirements. For example, forgetting to write a `:` at the end of the
    first line of a `for` loop is a syntax error. When you run Python, because it’s
    trying to generate machine code based on your program description, it will run
    into a mistake, not know what to do, and give you an error. Sometimes, these error
    messages are more readable than others. When people learn to program in the traditional
    way, without Copilot, these errors are really, really common. It takes a while
    to learn all the rules of Python and to make those rules a habit. Even the two
    of us still sometimes write code with syntax errors, despite decades of writing
    code. The good news is that writing code with Copilot almost entirely eliminates
    this problem! The bad news is that of the two types of bugs, syntax errors are
    the easier to find and fix.**'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***语法错误*——当代码没有遵循 Python 语法要求时，就会发生这些错误。例如，在 `for` 循环的第一行末尾忘记写 `:` 就是一个语法错误。当你运行
    Python 时，由于它试图根据你的程序描述生成机器代码，程序会遇到错误，不知道该怎么做，并给出错误提示。有时，这些错误信息比其他错误信息更易读。当人们以传统方式学习编程时，没有
    Copilot，这些错误非常常见。学习所有 Python 语法规则并将其养成习惯需要一些时间。即使是我们两个，尽管编写了几十年的代码，有时仍然会写出带有语法错误的代码。好消息是，使用
    Copilot 编写代码几乎完全消除了这个问题！坏消息是，在两种类型的 bug 中，语法错误是最容易发现和修复的。**'
- en: '***   ***Logical errors—*These errors occur when there is something logically
    wrong with the program. For example, maybe the intent of the code is to count
    how many times the exact word “Dan” appears in a list of words, but the code actually
    counts how many words in the list contain “dan” (ignoring case) anywhere in the
    word. This code would be doing the wrong thing on two counts: it would count words
    like *dan* and *DAN* as matches even though we don’t want those to be matches,
    and it would find *dan* as any part of a word rather than the full word. That
    is, it would count words like *Daniel*, *danger*, and *dan*, even though we don’t
    want to count any of these! Somewhere, the code isn’t doing what it should, and
    we have to figure out where and why. Often, finding the logical error is the hardest
    part. Once we know where the mistake is, we have to fix it, and fixing these bugs
    can range from changing a single character to completely rewriting the code. Logical
    errors can happen when a prompt isn’t well described or when Copilot, for various
    reasons, generates the wrong code.****'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '***   ***逻辑错误——*这些错误发生在程序的逻辑上有问题时。例如，也许代码的目的是统计“Dan”这个词在单词列表中出现的次数，但代码实际上统计的是单词列表中包含“dan”（不区分大小写）这个子串的单词的数量。这段代码在两个方面做错了：它会将
    *dan* 和 *DAN* 这样的词视为匹配项，尽管我们并不希望这些匹配；而且，它会把 *dan* 当作一个单词的一部分，而不是完整的单词。也就是说，它会把
    *Daniel*、*danger* 和 *dan* 这样的词计数进来，尽管我们并不希望将这些计入！代码的某个地方出了问题，我们需要找出问题所在并理解原因。通常，找到逻辑错误是最困难的部分。一旦我们知道了错误的所在，我们需要修复它，修复这些
    bug 可能需要更改一个字符，也可能需要完全重写代码。逻辑错误可能发生在提示描述不清晰，或者 Copilot 因各种原因生成了错误的代码。****'
- en: '****## 8.2 How to find the bug'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '****## 8.2 如何找到 bug'
- en: Finding bugs can be challenging. Fundamentally, whether you or Copilot wrote
    the code, you thought or Copilot “thought” the code was correct when it was written.
    This is why it’s often easier for a colleague to find a bug in the code rather
    than the author. The author can’t see the bug because they created it!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 找到 bug 可能是一个挑战。从根本上来说，不管是你还是 Copilot 编写了代码，你在编写时都认为（或 Copilot “认为”）代码是正确的。这就是为什么同事往往比作者更容易发现代码中的
    bug，作者自己反而看不出来，因为是自己编写的代码！
- en: Bugs aren’t new to us in this book as we’ve seen mistakes in code already, and
    we’ve found those errors by reading the code and/or testing. In previous chapters,
    we figured out the source of the bug by reading through the code. In this chapter,
    we’ll address the bugs that you identify when testing but can’t seem to figure
    out why the code is wrong. Often, you can bypass the process of figuring out why
    the code is wrong by trying other Copilot suggestions, using new prompts to fix
    the error, or asking Copilot to fix the bug for you, but in our experience, these
    techniques don’t always work. What we need then are more tools to help us figure
    out where the error is in the code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，bug 对我们来说并不陌生，因为我们已经看到过代码中的错误，我们通过阅读代码和/或测试找出了这些错误。在前几章中，我们通过阅读代码找到了 bug
    的源头。在本章中，我们将讨论你在测试时发现的 bug，但无法弄清楚代码为什么出错。通常，你可以通过尝试其他 Copilot 提示、使用新提示修复错误，或者请求
    Copilot 为你修复 bug 来绕过弄清楚代码出错的过程，但根据我们的经验，这些方法并不总是有效。那么，我们需要更多的工具来帮助我们找出代码中的错误位置。
- en: 8.2.1 Using print statements to learn about the code behavior
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 使用 `print` 语句了解代码行为
- en: Fundamentally, a logical error means that there is a mismatch between what the
    author thought the code would do and what the code actually does. A common way
    to identify that mismatch is by using `print` statements to get insight into the
    behavior of the program because they tell you what the computer is actually doing.
    A useful practice is to print variables at various points in time to see what
    the values of those variables are at those points. Let’s try this for that example
    we just gave of looking for the word *Dan* in a list of words. Here’s the wrong
    code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从根本上讲，逻辑错误意味着作者认为代码会做的事情和代码实际做的事情之间存在不匹配。识别这种不匹配的一种常见方法是使用 `print` 语句来了解程序的行为，因为它们能告诉你计算机实际在做什么。一种有用的做法是，在不同的时间点打印变量，以查看这些变量在这些时刻的值。让我们试试我们刚才给出的那个例子，查找单词
    *Dan* 在单词列表中的位置。这里是错误的代码。
- en: Listing 8.1 Incorrect function for counting matching words
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.1 计数匹配单词的错误函数
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '#1 The method lower makes the word all lowercase letters.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 `lower` 方法将单词转换为全小写字母。'
- en: 'You may already see what’s wrong with the code, but let’s assume we don’t know
    what’s going on, and we’re trying to figure out where the code went wrong. Suppose
    we found out that our code is wrong by running the following test case:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经看出代码哪里出错了，但让我们假设我们不知道问题出在哪里，正在尝试弄清楚代码出了什么问题。假设我们通过运行以下测试用例发现我们的代码是错误的：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We expected the answer of 1, but we got 2\. Notably, including *danger* in this
    test case helped us catch the error in the code. Where in the code did things
    go wrong? To figure that out, we could add `print` statements. When you want to
    do this, you’ll need to read the code to figure out where to put them. Looking
    at this code, printing the list at the start of the function might not be a bad
    idea depending on the bug we’re seeing, but the bug here seems to have to do with
    the count and not specifically with the list of words. Printing each word in the
    list as the first line in the `for` loop may be helpful so we can check that the
    code is processing each word. We might print `count` right before it’s returned,
    but we already have a good idea of the value returned. These are all reasonable
    ideas that will help you get closer to the bug, but it’s not where we’d start.
    To be clear, if we started with one of these other ideas, we wouldn’t be wrong;
    it might just take a few more steps before finding the bug.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预计得到的答案是 1，但我们得到了 2。值得注意的是，将 *danger* 包含在这个测试用例中帮助我们找到了代码中的错误。问题出在哪里呢？为了弄清楚这一点，我们可以添加
    `print` 语句。当你想这样做时，你需要阅读代码，弄清楚应该在哪里放置这些语句。看着这段代码，在函数开始时打印列表可能是个不错的主意，具体取决于我们看到的
    bug，但这里的 bug 似乎与计数有关，而不特别是与单词列表有关。我们可以在 `for` 循环的第一行打印每个单词，以便检查代码是否正在处理每个单词。我们可能会在返回
    `count` 之前打印它，但我们已经对返回的值有了较好的了解。这些都是合理的想法，有助于你更接近 bug，但这不是我们开始的地方。明确来说，如果我们从这些其他想法开始，也不会错；可能只是要多走几步才能找到
    bug。
- en: Because the bug is counting too many words as *Dan* words, we’d put the `print`
    statement within the `if` statement right where `count` is incremented, as in
    the following listing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 bug 是将太多单词错误地计数为 *Dan* 单词，所以我们会将 `print` 语句放在 `if` 语句中，正是 `count` 被递增的地方，如以下列表所示。
- en: Listing 8.2 Example of a print statement to find the bug
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.2 查找 bug 的 `print` 语句示例
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '#1 A print statement to show which words are being counted'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 显示被计数的单词的 `print` 语句'
- en: 'Rerunning our code with the same test case, this is what is printed now:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的测试用例重新运行代码，现在打印的是：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Aha! This would tell us that our program is counting the word *danger* when
    it shouldn’t be. We could then give Copilot a new prompt incorporating what we
    just learned to hopefully have Copilot fix the problem. Here’s the prompt we added
    in the editor, and Copilot fixed the code in the following listing.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 哦！这告诉我们程序在不应该的情况下将单词 *danger* 计算在内。接着我们可以给 Copilot 提供一个新的提示，将我们刚刚学到的知识结合进来，希望
    Copilot 能修复这个问题。以下是我们在编辑器中添加的提示，Copilot 在接下来的示例中修复了代码。
- en: Listing 8.3 Using a prompt to fix a known bug
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8.3 使用提示修复已知的 bug
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '#1 Prompt that causes Copilot to generate the correct code'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 触发 Copilot 生成正确代码的提示'
- en: '#2 Code added by Copilot in response to the prompt'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 Copilot 根据提示添加的代码'
- en: Once we knew the bug, it was easier to tell Copilot how to fix it. Granted,
    this is a basic example, but the idea applies to far more complex code. The process
    is often iterative. You ask the code to print something, and what it prints aligns
    with what you think it should be doing. You then ask the code to print something
    else and check it against what you expect. You keep doing this until there’s a
    point where what the code prints doesn’t align with what you wanted it to do.
    That’s when you’ve found the bug and can give Copilot a prompt to help it give
    you better code, or if the fix is simple, you can change the code directly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道了 bug，告诉 Copilot 如何修复它就容易多了。当然，这是一个简单的例子，但这个方法同样适用于更复杂的代码。这个过程通常是迭代的。你让代码打印出一些内容，看看它打印的结果是否与预期一致。接着你再让代码打印其他内容，并与预期进行对比。你不断重复这个过程，直到发现代码打印的内容与预期不符。那时你就找到了
    bug，可以给 Copilot 提供提示，帮助它生成更好的代码；如果修复很简单，你也可以直接修改代码。
- en: Depending on the complexity of the code, using `print` statements is often an
    effective way of debugging. We often use it as our first step in debugging.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 根据代码的复杂性，使用 `print` 语句通常是调试的一种有效方式。我们通常将它作为调试的第一步。
- en: 'Debugging: An art more than a science'
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 调试：一种艺术，更多的是一门技巧
- en: The iterative process when debugging is necessary because we’re genuinely confused
    about what the code is doing and why it isn’t matching our expectations. It’s
    okay to add a bunch of `print` statements that just tell you what you thought
    was happening in the first place because each of these `print` statements tells
    you where *not* to look for the bug and is an effective process of elimination.
    Figuring out where to look for bugs takes time and practice, so don’t worry if
    you find yourself spending a fair bit of time on it when you first start.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试时，迭代过程是必要的，因为我们真的不清楚代码在做什么，为什么它没有达到我们的预期。添加一堆 `print` 语句，告诉你最初认为会发生的事情是没问题的，因为这些
    `print` 语句会帮助你排除不该看的地方，这是一个有效的排除过程。找出应该寻找 bug 的地方需要时间和实践，所以如果你刚开始时发现自己花了很多时间，不要担心。
- en: 8.2.2 Using VS Code’s debugger to learn about the code behavior
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 使用 VS Code 的调试器了解代码行为
- en: VS Code is used by novices and professionals alike, so it has tools to help
    with the process of debugging. Because it’s used by professionals, debugging tools
    have a large number of features. For the purpose of this book, we’ll focus on
    a few of the most commonly used features, but feel free to look into more resources
    on using the VS Code debugger if you’re curious ([https://code.visualstudio.com/docs/editor/debugging](https://code.visualstudio.com/docs/editor/debugging)).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 被初学者和专业人士都在使用，因此它具备帮助调试过程的工具。由于它被专业人士使用，调试工具拥有许多功能。为了本书的目的，我们将重点讲解一些最常用的功能，但如果你感兴趣，可以查看更多关于如何使用
    VS Code 调试器的资源 ([https://code.visualstudio.com/docs/editor/debugging](https://code.visualstudio.com/docs/editor/debugging))。
- en: To showcase these tools, we’ll work through debugging the same function from
    the previous example (refer to listing 8.1) in a few ways. Listing 8.4 provides
    the code we’ll be working with throughout this section. Note that we’ve added
    the test of the `count_words` function to the program.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这些工具，我们将通过几种方式调试前面示例中的同一个函数（请参考示例 8.1）。示例 8.4 提供了我们在本节中使用的代码。请注意，我们已经将 `count_words`
    函数的测试添加到程序中。
- en: Listing 8.4 Incorrect `count_words` function for debugging
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8.4 用于调试的错误 `count_words` 函数
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '#1 Code to call the count_words function directly'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 直接调用 count_words 函数的代码'
- en: Getting started with the debugger and setting breakpoints
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用调试器并设置断点
- en: To use the debugger, we need to set a *breakpoint* and start the debugger. Setting
    a breakpoint tells the debugger when you want to start debugging the program as
    it executes. Once you hit the breakpoint, you’ll be able to inspect variable values
    and step through the program line by line. Breakpoints are extremely useful. For
    a large program, you wouldn’t want to step line by line through the entire program
    because that could take a great deal of time. Instead, using a breakpoint, you
    can step through just the lines of code that are most relevant to you.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用调试器，我们需要设置一个 *断点* 并启动调试器。设置断点告诉调试器在你希望开始调试程序执行的地方停下来。一旦到达断点，你将能够检查变量值并逐行调试程序。断点非常有用。对于一个大型程序，你不想逐行调试整个程序，因为那样可能会花费大量时间。相反，通过使用断点，你可以只调试与你最相关的代码行。
- en: To set a breakpoint, hover your mouse cursor to the left of the code, and you’ll
    see a dot appear. Click that dot, as shown in figure 8.1, and you’ll have a breakpoint
    set. For your projects, you’ll likely want to start by creating a breakpoint at
    the start of the function’s execution and then step through it one step at a time.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置断点，将鼠标光标悬停在代码左侧，你将看到一个圆点出现。点击该圆点，如图 8.1 所示，这样就设置了一个断点。在你的项目中，你可能会想先在函数执行的开始处创建一个断点，然后逐步调试每一步。
- en: '![figure](../Images/8-1.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/8-1.png)'
- en: Figure 8.1 Creating a breakpoint in VS Code by clicking to the left of the line
    of code
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.1 在 VS Code 中通过点击代码行左侧设置断点
- en: If you see a red dot to the left of the breakpoint after you move your mouse
    away, as shown in figure 8.2, that means it’s properly set.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你移开鼠标后看到断点左侧有一个红点，如图 8.2 所示，那么说明断点设置正确。
- en: '![figure](../Images/8-2.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/8-2.png)'
- en: Figure 8.2 A breakpoint has been set on line 2 of our count_words.py file in
    VS Code.
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.2 我们在 VS Code 中的 count_words.py 文件的第2行设置了一个断点。
- en: You can have more than one breakpoint, but for this example, let’s just stick
    with the one breakpoint on line 2\. (Note that you can remove a breakpoint by
    clicking on that red dot again.) Next, we’ll start the debugger and see how it
    works with the breakpoint.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以设置多个断点，但在这个例子中，我们只设置一个断点在第2行。（注意，你可以通过再次点击那个红点来移除断点。）接下来，我们将启动调试器并查看它如何与断点一起工作。
- en: How to step through the code line by line
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 如何逐行调试代码
- en: To start the debugger, choose Run > Start Debugging, as shown in figure 8.3.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动调试器，选择运行 > 开始调试，如图 8.3 所示。
- en: '![figure](../Images/8-3.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/8-3.png)'
- en: Figure 8.3 Starting the debugger in VS Code
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.3 在 VS Code 中启动调试器
- en: Once the debugger is started, you should see a screen similar to figure 8.4\.
    (If this is the first time using the debugger, it may ask you to select a debug
    configuration, in which case, you’ll want to choose Python.)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调试器启动，你应该看到类似于图 8.4 的界面。（如果这是第一次使用调试器，它可能会要求你选择一个调试配置，在这种情况下，你需要选择 Python。）
- en: '![figure](../Images/8-4.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/8-4.png)'
- en: Figure 8.4 The Debugging view in VS Code
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.4 VS Code 中的调试视图
- en: 'The VS Code debugger has a number of components [1]. On the left-hand side,
    the Debug Side Bar contains the Variables section, Watch section, and Call Stack
    section. Let’s briefly examine each of these sections:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 调试器有多个组件[1]。在左侧，调试侧边栏包含变量部分、观察部分和调用堆栈部分。让我们简要了解一下这些部分：
- en: The *Variables section* contains the variables that are declared within the
    current scope (e.g., within `count_words`) and their current values. For example,
    the `words` parameter is defined to be a list containing `['Dan',` `'danger',`
    `'Leo']`. You can click the arrow (>) to the left of `words` to see more details
    about that variable. This section is incredibly useful because you can examine
    the value of each variable.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*变量部分*包含当前作用域内声明的变量（例如，`count_words` 内的变量）及其当前值。例如，`words` 参数被定义为包含 `[''Dan'',`
    `''danger'',` `''Leo'']` 的列表。你可以点击 `words` 左侧的箭头（>）查看该变量的更多详细信息。这个部分非常有用，因为你可以检查每个变量的值。'
- en: 'The *Watch section* contains any expressions you want to watch specifically.
    For example, you might add the expression: `"dan"` `in` `word.lower()` to the
    watched expressions, and you’d be able to see if it’s `True` or `False` for each
    different value of `word`. To add an expression, hover over the Watch section
    and click the + sign.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*观察部分*包含你希望特别监视的表达式。例如，你可以将表达式：`"dan"` `in` `word.lower()` 添加到观察表达式中，然后你就可以看到它对于每个不同的
    `word` 值是否为 `True` 或 `False`。要添加一个表达式，只需将鼠标悬停在观察部分并点击 + 号。'
- en: The *Call Stack section* contains the functions that have been called that have
    led to this line of code executing. Here, the main function (called `<module>`
    by VS Code) called the function `count_words` on line 9\. Within the function
    `count_words`, we’re presently on line 2\. You can double-check that this is true
    by looking at the line of code presently highlighted as line 2 is highlighted
    in figure 8.4\.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调用堆栈部分*包含了导致这行代码执行的已调用的函数。在这里，主函数（VS Code中称之为 `<module>`）在第9行调用了 `count_words`
    函数。在 `count_words` 函数内，我们当前在第2行。你可以通过查看当前高亮的代码行来再次确认这一点，因为第2行在图8.4中被高亮显示。'
- en: Speaking of which, on the right-hand side, which shows our code editor, we can
    see the line `count` `=` `0` highlighted. This is the current line of code that
    hasn’t yet been executed. The reason the line hasn’t been executed yet is because
    we set our breakpoint, shown by the arrow with a dot in it, at this line of code.
    When we started the debugger, it ran the code until just before executing `count`
    `=` `0`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这一点，在右侧显示我们的代码编辑器，我们可以看到高亮显示的行 `count` `=` `0`。这就是当前还未执行的代码行。该行尚未执行的原因是因为我们在这行代码上设置了断点，通过带有点的箭头表示。当我们启动调试器时，它运行了代码，直到执行
    `count` `=` `0` 之前。
- en: 'The Debug Toolbar (figure 8.5) is critical as it drives the process once you
    start debugging: you can advance an instruction, restart debugging, or stop debugging.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 调试工具栏（图8.5）至关重要，因为它在你开始调试后驱动整个过程：你可以推进指令、重新启动调试或停止调试。
- en: '![figure](../Images/8-5.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/8-5.png)'
- en: Figure 8.5 The Debugging Toolbar
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.5 调试工具栏
- en: The buttons on the toolbar, going left to right, are
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 工具栏上的按钮，从左到右依次是
- en: '***Continue (F5)—*This button will advance until the next time a breakpoint
    is executed. In our example, line 2 of `count_words` never executes again, so
    clicking Continue will cause the program and debugging session to run to the end.**'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***继续（F5）—*此按钮将继续执行，直到下一个断点被触发。在我们的示例中，`count_words` 中的第2行不会再执行，所以点击继续将使程序和调试会话一直运行到结束。**'
- en: '***   ***Step Over (F10)—*This button advances to the next line of code in
    the current function. Step Over means that if a line of code in this function
    calls another function (e.g., when `word.lower()` is called on line 4), the debugger
    will stay in the `count_words` function and will just run the called function
    (e.g., `word.lower()`) to its completion.*****   ***Step Into (F11)—*This button
    advances to the next line of code, including going into any functions that are
    called. Unlike Step Over, when you use Step Into, the debugger will go into any
    function called by the current function. For example, if you used Step Into on
    a line of code that calls another function, it would go into that function and
    continue debugging (line by line) from inside that function. By default, it doesn’t
    step into library function calls (e.g., `word.lower()` is part of the Python standard
    library) but will step into functions you’ve written.*****   ***Step Out (Shift
    + F11)—*This button will execute the code until the present function ends and
    then continue debugging from after this function’s exit.*****   ***Restart—*This
    button restarts the debugging process. It will restart the program, and the program
    will execute until its first breakpoint.*****   ***Stop—*This button stops the
    debugging process.************'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '***   ***步过（F10）—*此按钮将跳到当前函数中的下一行代码。如果当前函数中的一行代码调用了另一个函数（例如，当第4行调用 `word.lower()`
    时），调试器将保持在 `count_words` 函数中，只会运行被调用的函数（例如，`word.lower()`）直到完成。*****   ***步入（F11）—*此按钮将跳到下一行代码，包括进入所有被调用的函数。与步过不同，当你使用步入时，调试器将进入当前函数调用的任何函数。例如，如果你在调用另一个函数的代码行上使用步入，它会进入该函数并继续从该函数内部逐行调试。默认情况下，它不会进入库函数调用（例如，`word.lower()`
    是 Python 标准库的一部分），但会进入你编写的函数。*****   ***步出（Shift + F11）—*此按钮将执行代码直到当前函数结束，然后继续从该函数退出后的地方调试。*****   ***重新启动—*此按钮将重新启动调试过程。它将重新启动程序，并执行到第一个断点为止。*****   ***停止—*此按钮将停止调试过程。************'
- en: '******#### Stepping through the code line by line'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '******#### 一行一行地调试代码'
- en: Now that we have a handle on the debugger, let’s continue our example by using
    the Step Over button. Let’s click Step Over once and see how our view changes
    (figure 8.6). Step Over advanced to the next line of code, line 3\. This means
    it executed
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了调试器的使用，让我们继续我们的示例，使用“步过”按钮。点击一次“步过”按钮，看看我们的视图如何变化（见图8.6）。“步过”执行到了下一行代码，第3行。这意味着它执行了
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: and is just about ready to execute
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 并且即将准备好执行
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![figure](../Images/8-6.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/8-6.png)'
- en: Figure 8.6 Our debugger after clicking Step Over once. The next line (line 3)
    is now highlighted.
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.6 我们在点击一次“Step Over”后的调试器视图。下一行（第 3 行）现在被高亮显示。
- en: We can see from various clues in the interface that the line `count` `=` `0`
    was executed. First, in the editor on the right, we can see the `for` loop is
    highlighted, and the arrow on the left points to this line of code. On the left,
    in the Call Stack section, we can see that it’s now on line 3 of `count_words`
    `(`as shown by the line `count_words` being highlighted and the number in the
    oval on the right reading 3:1). Perhaps most importantly, on the left in the Variables
    section, we can now see the variable `count` has been added to the local variables,
    and it has a value of `0`. This last piece is pretty amazing because if you were
    trying to read through the code and trace what is happening line by line, the
    line `count` `=` `0` on line 2 would mean that a variable count is created and
    assigned a value of `0`. This is just what the VS Code debugger has told us as
    well. We hope you’re starting to see how powerful this tool can be.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从界面中的各种线索看到 `count` `=` `0` 这一行代码已经执行。首先，在右侧的编辑器中，我们可以看到 `for` 循环被高亮显示，并且左侧的箭头指向了这一行代码。在左侧的调用堆栈部分，我们可以看到它现在位于
    `count_words` 的第 3 行（如左侧显示 `count_words` 被高亮并且右侧的数字显示 3:1）。也许最重要的是，在左侧的变量部分，我们可以看到变量
    `count` 已经被添加到局部变量中，并且其值为 `0`。最后这一点相当惊人，因为如果你试图逐行阅读代码并跟踪发生的事情，第 2 行的 `count` `=`
    `0` 会意味着一个名为 `count` 的变量被创建并赋值为 `0`。这正是 VS Code 调试器告诉我们的内容。我们希望你现在已经开始看到这个工具有多强大了。
- en: Let’s click Step Over one more time. Now we’re stopping just before the line
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再点击一次“Step Over”。现在我们停在这一行之前。
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can see that there is now a new variable, `word`, which has been assigned
    the value `"Dan"`, and that’s just what we’d expect: `word` was given the value
    of the first element in the list `words`. This is a good spot to point out that
    in addition to being able to read the variables values in the Variables section,
    you can also just hover your mouse over any variable that’s been declared already
    to see its value as well. Pretty neat, huh?'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到现在有了一个新的变量 `word`，其值为 `"Dan"`，这正是我们期望的：`word` 被赋值为 `words` 列表中的第一个元素。这是一个很好的时机来指出，除了在变量部分查看变量的值之外，你还可以将鼠标悬停在任何已经声明的变量上，来查看它的值。相当不错吧？
- en: Let’s click Step Over one more time and see that the condition in the `if` statement,
    `"dan"` `in` `word.lower()`, evaluated to `True`, so we’re going to execute the
    line
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再点击一次“Step Over”并观察 `if` 语句中的条件，`"dan"` `in` `word.lower()` 被评估为 `True`，所以我们将执行这一行代码。
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that we’re getting the hang of this, let’s keep clicking Step Over a few
    more times. The first time you click Step Over, it will go back to the `for` loop,
    and you can see `count` has incremented to `1`. The second time you click Step
    Over, it will stop at the `if` statement, and you can see that word is now `"danger"`.
    We could stop here and add a watch expression to see what this `if` statement
    will do. To add a watch expression, hover your mouse over the Watch section, and
    click the plus arrow that appears to the right of the word Watch. This will let
    you type anything you want. We typed `"dan"` `in` `word.lower()` and pressed Enter
    to add this watch expression, as shown in the Debug Side Bar of figure 8.7.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了这个操作，继续多点击几次“Step Over”。第一次点击时，它会返回到 `for` 循环，并且可以看到 `count` 已经增加到了
    `1`。第二次点击时，它会停在 `if` 语句处，并且可以看到 `word` 的值现在是 `"danger"`。我们可以在这里停下来并添加一个监视表达式，看看这个
    `if` 语句会做什么。要添加监视表达式，将鼠标悬停在 Watch 区域，然后点击出现在 Watch 右侧的加号箭头。这将允许你输入任何你想要的内容。我们输入了
    `"dan"` `in` `word.lower()` 并按下回车键来添加这个监视表达式，如图 8.7 的调试侧边栏所示。
- en: '![figure](../Images/8-7.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/8-7.png)'
- en: Figure 8.7 View of the debugger after adding the watch expression
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.7 添加监视表达式后的调试器视图
- en: If we hadn’t already found the bug earlier in this chapter, this is where we’d
    find it. The expression `"dan"` `in` `word.lower()` evaluates to `True`, which
    means `count` will be incremented again. But we only wanted exact matches to the
    word `"Dan"` and didn’t want `"danger"` to count!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在本章之前没有找到 bug，那么就是在这里我们会发现它。表达式 `"dan"` `in` `word.lower()` 被评估为 `True`，这意味着
    `count` 会再次增加。但是我们只希望精确匹配 `"Dan"` 这个单词，而不希望 `"danger"` 被计算在内！
- en: This is a completely reasonable way to debug a function. As we noted earlier,
    putting a breakpoint at the start of the function’s execution and then stepping
    through it one step at a time often is a great starting point for debugging. The
    only times you might struggle to use this approach is if the `for` loop ran through
    thousands of values before making a mistake. To address challenges like this,
    we might put a breakpoint in a specific spot to avoid spending a lot of time in
    the debugger. Let’s stop the debugger (click Stop in the Debug Toolbar), remove
    the breakpoint from line 2 (click the red dot to the left of the line), and try
    a different breakpoint.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是调试函数的完全合理方式。正如我们之前注意到的，将断点放在函数执行的开头，然后逐步执行是调试的一个很好的起点。唯一可能使您难以使用这种方法的时候是`for`循环在出错前运行了成千上万个值。为了解决这样的挑战，我们可能会在特定位置放置一个断点，以避免在调试器中花费大量时间。让我们停止调试器（在调试工具栏中点击“停止”），移除第
    2 行的断点（点击行左侧的红点），并尝试一个不同的断点。
- en: Using a breakpoint to selectively debug
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用断点进行选择性调试
- en: This time, let’s put the breakpoint at a point in the code we want to monitor
    more closely. Based on our test case showing that two words of the list “counted”
    when we expected just one to, we should try putting our breakpoint at the line
    where `count` is incremented, as we have in figure 8.8.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，让我们将断点放在我们想要更密切监视的代码位置上。基于我们的测试案例显示列表中“计数”了两个单词，而我们只期望一个，我们应该尝试将断点放在递增`count`的行上，就像我们在图
    8.8 中做的那样。
- en: '![figure](../Images/8-8.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/8-8.png)'
- en: Figure 8.8 View of the code after placing our new breakpoint on line 5
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.8 在第 5 行放置新断点后的代码视图
- en: Once we start the debugger, the code will run until the first time the `if`
    statement is evaluated to `True` and the line `count` `+=` `1` is ready to execute.
    Figure 8.9 offers the view of the debugger once we start it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们启动调试器，代码将运行，直到第一次`if`语句评估为`True`并且准备执行`count += 1`的行。图 8.9 显示了我们启动调试器后的调试器视图。
- en: '![figure](../Images/8-9.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/8-9.png)'
- en: Figure 8.9 View of the debugger when it encounters the breakpoint (line 5) for
    the first time
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.9 调试器首次遇到断点（第 5 行）时的视图
- en: We put the breakpoint at the incrementing of `count` because we wanted to see
    what item in the list is causing `count` to increment. Examining our local variables,
    we can see that `word` is `'Dan'`, and that is when we want the `count` variable
    to be incremented. Given this is what we wanted to happen, we haven’t found our
    bug yet.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将断点放在递增`count`的位置上，因为我们想看看列表中的哪个项目导致`count`增加。检查我们的局部变量，我们可以看到`word`是`'Dan'`，这时我们希望`count`变量增加。考虑到这是我们想要发生的，我们还没有找到我们的错误。
- en: Now is when we can really take advantage of our breakpoint placement. We want
    the code to execute until it comes across the breakpoint again. The way to do
    this is to click Continue in the Debug Toolbar (refer to figure 8.5). After clicking
    Continue, the debugger should appear as in figure 8.10.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们真正利用断点位置的时候。我们希望代码执行直到再次遇到断点。这样做的方法是在调试工具栏中点击“继续”（参见图 8.5）。点击“继续”后，调试器应该显示如图
    8.10 中所示。
- en: '![figure](../Images/8-10.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/8-10.png)'
- en: Figure 8.10 View of the debugger when it encounters the breakpoint (line 5)
    for the second time
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.10 调试器在第二次遇到断点（第 5 行）时的视图
- en: In the Variables section, notice that the value of `count` and the value of
    `word` are highlighted. This is to tell you that because you clicked Continue,
    those two values have changed. The value in `count` increased to `1`, as expected,
    after having found the word `'Dan'`. The value in `word` updated to `'danger'`.
    Although `'danger'` is the next value in the list of words, we shouldn’t expect
    to find the code incrementing `count` for the word `'danger'`. At this point,
    we’d have found our bug. Notice how much quicker it can be to find a bug with
    a good placement of a breakpoint. But we caution that knowing the best place to
    put a breakpoint is a lot like knowing the best variables to print when debugging—it
    takes time and practice to learn how to do it well.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量部分，请注意`count`的值和`word`的值被突出显示。这是告诉您因为您点击了“继续”，这两个值已经改变了。`count`的值增加到了`1`，正如预期的那样，找到单词`'Dan'`后。`word`的值更新为`'danger'`。尽管`'danger'`是单词列表中的下一个值，但我们不应该期望找到代码为单词`'danger'`递增`count`。在这一点上，我们应该找到了我们的错误。请注意，通过良好放置断点，找到错误可以更快。但我们警告说，知道放置断点的最佳位置很像知道调试时要打印的最佳变量一样，这需要时间和练习来学会如何做得好。
- en: In this section, we’ve seen how powerful the debugger can be in VS Code. It’s
    pretty easy to set a breakpoint and start a debugging session. As the debugger
    monitors the variables in the function, you can inspect those in the Debug Side
    Bar as the code executes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经看到调试器在VS Code中的强大功能。设置断点并开始调试会话非常容易。当调试器监视函数中的变量时，你可以在调试侧边栏中检查这些变量，随着代码的执行，查看它们的变化。
- en: 8.3 How to fix a bug (once found)
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 如何修复错误（找到错误后）
- en: In the old way of learning to program, this would be a short section that would
    tell you to fix the bug yourself. Although that’s still an option, we have a lot
    of choices now with Copilot. These choices include asking Copilot to fix it, giving
    it a new prompt for the entire function that better describes the problem in a
    way to avoid the bug, giving Copilot a targeted prompt to fix the spot in the
    code you found that was wrong, and, if it’s a small fix, making it yourself. Let’s
    see how we could do each of these.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧的编程学习方式中，这部分内容会告诉你如何自己修复错误。虽然这仍然是一个选择，但现在我们有了更多的选择，可以通过Copilot来解决问题。这些选择包括要求Copilot修复它，给它一个新的提示，重新描述问题，避免出现错误；给Copilot一个有针对性的提示，修复你找到的错误代码部分；如果是一个小问题，也可以自己修复。让我们看看如何做这些。
- en: 8.3.1 Asking Copilot to fix your bug via Copilot Chat
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 通过Copilot Chat请求Copilot修复您的错误
- en: '*In the following example, we’ll interact with the Copilot Chat feature. The
    Copilot Chat feature lets you interact with Copilot as you might with ChatGPT
    but is limited to questions pertaining to programming. Feel free to interact with
    ChatGPT instead (available via [https://openai.com](https://openai.com) with free
    tiers at the time of writing) in the same way as we interact with Copilot in this
    section. We’re preferential to Copilot Chat just because its interface is built
    in to the latest version of VS Code and the Copilot extension.*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*在下面的示例中，我们将与Copilot Chat功能进行交互。Copilot Chat功能允许你像与ChatGPT互动一样与Copilot互动，但仅限于编程相关的问题。你也可以与ChatGPT进行相同的互动（可以通过[https://openai.com](https://openai.com)访问，在写这篇文章时，ChatGPT提供免费层）。我们更倾向于使用Copilot
    Chat，因为它的界面是内置在最新版本的VS Code和Copilot扩展中的。*'
- en: '*In previous chapters, we’ve mostly just asked Copilot Chat for single answers,
    whereas in this chapter and later chapters, we’ll be using Copilot Chat to have
    a conversation with the tool. When we’re having a conversation with the tool,
    we’ll work to separate out what we write (“Human”) from Copilot’s responses (“GitHub
    Copilot”). Using the Copilot Chat feature, let’s see if Copilot can help us out
    here:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*在之前的章节中，我们大多只要求Copilot Chat给出单一的答案，而在本章及后续章节中，我们将使用Copilot Chat与工具进行对话。当我们与工具对话时，我们将努力将我们写的内容（“Human”）与Copilot的回答（“GitHub
    Copilot”）分开。通过Copilot Chat功能，让我们看看Copilot是否能帮我们解决这个问题：*'
- en: LPHumanI have a function, below, that is supposed to count the number of times
    the word “Dan” appears in the parameter list “words”. Instead, it seems to be
    counting the number of times the characters “dan” appear anywhere in the list.
    Can you help fix this for me?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman我有一个函数，下面是它的代码，应该统计单词“Dan”在参数列表“words”中出现的次数。相反，它似乎统计的是字符“dan”在列表中出现的次数。你能帮我修复这个问题吗？
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Certainly! To count the number
    of times the word “Dan” appears in the list, you can modify the `if` statement
    to check if the whole word is equal to “Dan” (case-insensitive). Here’s the modified
    code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot 当然！要计算单词“Dan”在列表中出现的次数，您可以修改`if`语句，检查整个单词是否等于“Dan”（不区分大小写）。这是修改后的代码：'
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code will count the number of times the word “Dan” (case-insensitive) appears
    in the list.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将计算单词“Dan”（不区分大小写）在列表中出现的次数。
- en: The answer back from Copilot Chat changed the line
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Copilot Chat返回的答案更改了这一行代码
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: to
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Although the change may look small, it has a big effect. The original line of
    code searched for the string `"dan"` anywhere in `word` (after the word has been
    made all lowercase letters by the `.lower()` method). The new line of code checks
    to see whether `word` (again, made all lowercase letters by the `.lower()` method)
    is an exact match for the string `"dan"`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个变化看起来很小，但它的影响却很大。原始的代码行会在`word`中搜索字符串`"dan"`（在通过`.lower()`方法将单词转换为小写字母之后）。新的代码行检查`word`（同样，通过`.lower()`方法将其转换为小写字母）是否与字符串`"dan"`完全匹配。
- en: This answer from Copilot is a step closer to a correct solution as it will only
    match the whole word rather than looking for an occurrence of `dan` anywhere in
    the word. However, the call to `.lower()` makes it case-insensitive, so it would
    also match `dan` rather than how our solution earlier (listing 8.3) was case-sensitive
    (it had to be exactly `Dan`). We’d like to be case-sensitive, so we could continue
    with Copilot Chat to have Copilot fix this for us.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个来自Copilot的回答离正确的解决方案更近一步，因为它只会匹配整个单词，而不是在单词的任何位置查找`dan`。然而，调用`.lower()`会让它变得不区分大小写，因此它也会匹配`dan`，而我们之前的解决方案（列表8.3）是区分大小写的（必须是完全的`Dan`）。我们希望保持区分大小写，因此我们可以继续使用Copilot
    Chat来让Copilot为我们修复这个问题。
- en: LPHumanCan you give me the same code but count only the word “Dan” (case-sensitive)?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: LPHuman：你能给我相同的代码，但只统计单词“Dan”（区分大小写）出现的次数吗？
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Sure! Here’s the modified code
    that counts only the word “Dan” (case-sensitive):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![chatGpt](../Images/chatGpt.png)GitHub Copilot：当然！这是修改后的代码，它只统计单词“Dan”（区分大小写）：'
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code will count the number of times the word “Dan” (case-sensitive) appears
    in the list.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将统计单词“Dan”（区分大小写）在列表中出现的次数。
- en: In this case, Copilot Chat was able to solve the problem for us when we knew
    how the code was misfunctioning. We didn’t explicitly say what line of code was
    broken, but if you knew this, you could convey that to Copilot Chat as well. One
    advantage of knowing which line was broken, like we did here, is that we could
    look to make sure the fix from Copilot changes the broken line. Let’s move on
    and examine other options for fixing the bug.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当我们知道代码出错的方式时，Copilot Chat能够为我们解决问题。我们并没有明确说明哪一行代码有问题，但如果你知道这一点，也可以把它告诉Copilot
    Chat。知道哪一行有问题的一个好处是，我们可以检查Copilot的修复是否确实更改了那一行代码。接下来，我们将继续探索其他修复该错误的选项。
- en: 8.3.2 Giving Copilot a new prompt for the whole function
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 给Copilot一个新的整个函数的提示
- en: You’ve seen us rewrite the prompt for a function a fair number of times already
    in this book. It simply involves rewriting the function prompt and seeing if Copilot
    can do better, sometimes using Ctrl-Enter to explore Copilot’s solutions. We won’t
    repeat this here because you’ve already seen it many times before (e.g., in chapter
    6, section 6.5.2).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到我们在本书中多次重写函数的提示了。这仅仅是涉及到重写函数提示，并看看Copilot是否能够做得更好，有时使用Ctrl-Enter来探索Copilot的解决方案。我们在这里不再重复这一过程，因为你已经在之前的章节中看到过很多次了（例如，在第6章第6.5.2节）。
- en: 8.3.3 Giving Copilot a targeted prompt for part of a function
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.3 给Copilot一个有针对性的部分函数提示
- en: We used this technique earlier in the chapter in listing 8.3\. We’ve reproduced
    this as listing 8.5.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的列表8.3中使用了这个技巧。我们已将其作为列表8.5重新呈现。
- en: Listing 8.5 Using a prompt to fix a known bug (relisted)
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.5 使用提示修复已知错误（重新列出）
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '#1 Prompt that causes Copilot to generate correct code'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 导致Copilot生成正确代码的提示'
- en: Here, we’d figured out that the previous line
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经弄清楚了前一行
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: wasn’t doing what we wanted. So, we removed the incorrect code and specifically
    added a prompt to say exactly what we wanted Copilot to do, and it was able to
    produce the correct code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 并没有达到我们想要的效果。所以，我们删除了错误的代码，并特别添加了一个提示，明确告诉Copilot我们想要的是什么，结果它能够生成正确的代码。
- en: 8.3.4 Modifying the code to fix the bug yourself
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.4 自行修改代码修复错误
- en: This approach to fixing broken code is new to this chapter. You’ve seen enough
    code at this point in the book that you can likely fix some code by yourself by
    directly modifying it. For example, suppose we wrote the following code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 修复损坏代码的方法是本章的新内容。到目前为止，你在本书中已经看到了足够多的代码，可能能够通过直接修改代码来修复一些问题。例如，假设我们编写了以下代码。
- en: Listing 8.6 Function to count specified numbers in a list
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.6 统计指定数字出现在列表中的函数
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We’ve seen functions like this earlier in the book. It iterates through all
    the numbers in the list of numbers and checks if each number is bigger than or
    equal to `x` and is less than or equal to `y`. If a number is between `x` and
    `y`, it increases the `count`. At the end of the function, it returns the `count`.
    The code isn’t wrong here if the goal is to count numbers in the list that are
    between `x` and `y` (including `x` and `y`).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书的早些时候见过类似的函数。它会遍历数字列表中的所有数字，并检查每个数字是否大于或等于`x`且小于或等于`y`。如果数字位于`x`和`y`之间，它就会增加`count`。在函数的最后，它会返回`count`。如果目标是统计列表中位于`x`和`y`之间的数字（包括`x`和`y`），那么这里的代码是没有错的。
- en: However, the term *between* can be a bit ambiguous. Do you want to include `x`
    and `y` or just the values between them (not including them)? Suppose that when
    you imagined this function, you wanted to not include `x` and `y.` For example,
    if the list were 2, 4, 8, and you provided `x` and `y` values of 3 and 8, you
    would want the `count` to be 1 (including 4, but not 8). You might already see
    how the function is wrong for this goal and how to fix it, but let’s pretend you
    don’t realize yet that the code doesn’t match what you want.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，*between*这个术语可能有些模糊。你想包含`x`和`y`，还是只想包括它们之间的值（不包括它们）？假设当你想象这个函数时，你希望不包括`x`和`y`。例如，如果列表是2、4、8，而你提供的`x`和`y`值分别是3和8，你希望`count`的值为1（包括4，但不包括8）。你可能已经看到这个函数在这个目标下是错误的，并且知道如何修复它，但让我们假装你还没有意识到代码并没有达到你的期望。
- en: 'As with any function that is created either by Copilot or us, we should test
    the function. Fortunately, when writing the first test case, we included a value
    in the test case (`numbers`) that is equal to `x` (the lower bound) and equal
    to `y` (the upper bound):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 和任何由Copilot或我们自己创建的函数一样，我们应该测试该函数。幸运的是，在编写第一个测试用例时，我们在测试用例（`numbers`）中包括了一个等于`x`（下限）和等于`y`（上限）的值：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Testing the code at the prompt, we found that our function returns 5 as the
    answer, but we thought the answer should be 3\. By our definition of *between*,
    we felt that only the numbers 4, 5, and 6 are between 3 and 7, so the answer should
    be 3, that is, there are three numbers between 3 and 7\. Instead, the code gave
    us the answer of 5\. So, we know it isn’t working correctly thanks to our test
    cases. Whether we go on to find the bug by inspecting the code or by using the
    debugging techniques from this chapter, we realize the statement
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试提示中的代码时，我们发现函数返回的答案是5，但我们认为答案应该是3。根据我们对*between*的定义，我们认为只有4、5和6位于3和7之间，所以答案应该是3，也就是说，3和7之间有三个数字。相反，代码给出的答案是5。因此，我们知道代码没有正确运行，这得益于我们的测试用例。无论是通过检查代码，还是使用本章的调试技巧来寻找错误，我们意识到语句
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: is the culprit. Here, the complete fix requires us to change the `if` statement
    from
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 是罪魁祸首。在这里，完整的修复要求我们将`if`语句从
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: to
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is a change we could just make directly, without asking for Copilot’s help
    (although Copilot would likely be able to help us here as well). Listing 8.7 has
    the fixed function after the change.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以直接进行的更改，无需寻求Copilot的帮助（尽管Copilot也可能能帮助我们）。列表8.7中是更改后的修复函数。
- en: Listing 8.7 Function to count specified numbers (corrected)
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.7 修正后的计算指定数字的函数
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '#1 Changed the >= to > and <= to < manually'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 手动将 >= 改为 >，将 <= 改为 <'
- en: 8.4 Modifying our workflow in light of our new skills
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 根据我们新学到的技能修改工作流程
- en: Now that we know how to find and fix bugs in a more deliberate manner, let’s
    revisit the workflow we last visited in chapter 6\. Note that this workflow is
    about how to design a single function, so it presumes you’ve already done the
    function decomposition described in chapter 7 to determine the appropriate functions.
    The new workflow appears in figure 8.11.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何以更加有意识的方式查找和修复错误，让我们回顾一下在第6章最后回顾过的工作流程。请注意，这个工作流程是关于如何设计单个函数的，因此它假设你已经完成了第7章中描述的函数分解，以确定适当的函数。新工作流程出现在图8.11中。
- en: '![figure](../Images/8-11.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/8-11.png)'
- en: Figure 8.11 The function design cycle with Copilot, augmented to include debugging
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.11 与Copilot一起的函数设计周期，增加了调试部分
- en: Although the figure is starting to get a bit complicated, most of this is what
    you saw previously in chapter 6\. The only changes here are to include debugging.
    Specifically, if you’ve already tried to revise the prompt and you still can’t
    get code that works, then it’s time to try debugging explicitly. With the tools
    you’ve gained in this chapter, you’ll likely be successful at finding some bugs
    but not all possible bugs. If you find the bug and feel you’ve successfully fixed
    it, the flowchart sends you back to testing to make sure your fix worked (and
    didn’t break any other test cases). On the off chance you can’t get the code to
    work through new prompts and just can’t seem to debug it, we’ve found that problem
    decomposition is often your best next step. In other words, if you can’t get a
    function to work no matter how hard you try, the function should probably be broken
    into multiple functions, and you’re more likely to be successful coding those
    smaller functions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然图表开始变得有些复杂，但大部分内容与第六章中看到的类似。这里唯一的变化是加入了调试的内容。具体来说，如果你已经尝试修改提示，仍然无法得到有效的代码，那么就该开始显式地进行调试了。利用本章学到的工具，你可能能成功地找出一些错误，但不一定能发现所有的错误。如果你发现了错误并认为已经修复了它，那么流程图会让你回到测试阶段，以确保你的修复有效（并且没有破坏其他测试用例）。如果你万一通过新的提示无法让代码工作，且调试似乎无法进行，我们发现问题分解往往是你最好的下一步。换句话说，如果你怎么也调试不好某个函数，可能是该函数应该被拆分成多个小函数，这样你更有可能成功地编写这些小函数。
- en: 8.5 Applying our debugging skills to a new problem
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 将我们的调试技能应用到新问题上
- en: With our new skills in place and a new workflow, let’s try tackling a more challenging
    debugging problem. Remember in chapter 6 when we tried to determine the largest
    number of empty seats in a given row in a classroom? We’re going to solve a similar
    problem here.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 配备了新的技能和工作流程后，让我们尝试解决一个更具挑战性的调试问题。还记得第六章中我们试图确定教室中某一排座位中空座位最多的数量吗？我们将要在这里解决一个类似的问题。
- en: Instead of looking for empty seats, let’s say that we want to count the most
    students seated consecutively in a row because you’re trying to space them out
    better before an exam. You could also imagine using this to space out people more
    if they want more personal space or if there’s a pandemic. We wrote the prompt
    and a basic doctest, and Copilot generated a solution. The code appears in the
    following listing.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 与其寻找空座位，不如说我们想要计算在一排座位中连续坐着的最多学生，因为你可能想在考试前更好地安排他们的位置。你还可以想象，如果人们想要更多的私人空间，或者如果发生了疫情，这个方法可以用来更好地分散人群。我们编写了提示和一个基本的
    doctest，Copilot 生成了一个解决方案。代码如下所示。
- en: Listing 8.8 First attempt to count consecutive students in a row
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.8 尝试计数连续座位上的学生
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '#1 Our prompt to Copilot'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 我们给 Copilot 的提示'
- en: '#2 The first test case'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '#2 第一个测试用例'
- en: '#3 The code from Copilot'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '#3 Copilot 生成的代码'
- en: '#4 The code to run the doctest that we added'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '#4 我们添加的 doctest 运行代码'
- en: Given this chapter is about debugging, you can probably guess the code isn’t
    working correctly. We caught this bug when we read the code Copilot gave us, but
    it’s a subtle bug that we suspect could be missed fairly easily. If you see it
    already, great job, but pretend you didn’t for the rest of the chapter. If you
    haven’t seen it, the rest of the chapter is going to be more valuable to you.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 既然本章是关于调试的，你可能已经猜到代码并没有正确工作。我们在阅读 Copilot 给我们的代码时发现了这个错误，但它是一个微妙的错误，我们怀疑很容易被忽略。如果你已经发现了这个问题，做得很好，但假装你没有看到它，并继续阅读本章。如果你还没有发现它，那么本章的内容对你会更有价值。
- en: Let’s imagine then that we just wrote this prompt and test case. We read through
    the code, and it looks like it’s probably keeping track of the most consecutive
    students. As long as it sees a student in a seat, it increments the count. When
    there isn’t a student in the seat, it checks to see whether the count is bigger
    than any previously seen and resets the count. It seems like it’s at least on
    the right track. We included a test case, so we ran the code, and the test case
    passed. We’re feeling pretty good about the code but know we need to do more test
    cases, particularly ones to catch edge cases (remember that edge cases are uncommon
    cases that could break the code).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们刚刚编写了这个提示和测试用例。我们通读了代码，发现它似乎是在跟踪最多的连续学生。只要看到座位上有学生，它就会增加计数。当座位上没有学生时，它会检查计数是否比之前的任何计数都大，并重置计数。看起来它至少走在了正确的轨道上。我们加入了一个测试用例，因此我们运行了代码，测试用例通过了。我们对这段代码感觉不错，但知道我们需要做更多的测试用例，特别是用于捕捉边界情况的测试用例（记住，边界情况是那些可能会导致代码出错的不常见情况）。
- en: 'We know when we work with lists, it’s good to check that the code does the
    right thing at the start and end of the list. To test the end of the list, let’s
    add a test case where the largest group of consecutive students includes the last
    seat and then rerun the code. Here’s the new test case we’re adding to the docstring:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道在处理列表时，检查代码是否在列表的开始和结束处正确执行是很重要的。为了测试列表的末尾，我们添加了一个测试用例，其中最大的连续学生组包含最后一个座位，然后重新运行代码。以下是我们在文档字符串中添加的新测试用例：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '#1 The longest group of consecutive students is 4.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 连续学生中最大的组数是4。'
- en: 'We run the code again and are surprised when the test cases fail. Here’s what
    it told us (we reformatted the output for readability):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次运行代码，结果测试用例失败，令我们吃惊。以下是它告诉我们的信息（我们为了可读性重新格式化了输出）：
- en: '[PRE25]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'That’s odd—the code seemed to be working properly. Something about this edge
    case has uncovered the error. At this point, we’d want to generate some hypotheses
    about why the code isn’t working properly to help guide our debugging efforts.
    (If you’re truly stumped, you could take the approach of just setting a breakpoint
    at the first line of code in the function and stepping through it rather than
    trying to create a hypothesis.) Here are two hypotheses that come to mind:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这很奇怪——代码似乎正常工作。这个边缘情况暴露了错误。在这一点上，我们希望生成一些假设，帮助我们引导调试工作。（如果你确实陷入困境，可以采取在函数的第一行代码处设置断点并逐步调试的方式，而不是尝试创建假设。）以下是我想到的两个假设：
- en: The updating of `count` is skipping the last element in the list.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`的更新跳过了列表中的最后一个元素。'
- en: The updating of `max_count` is missing the last element in the list.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_count`的更新缺少了列表中的最后一个元素。'
- en: To simplify the debugging process, we removed the test that is passing (just
    set it aside to restore later) and are only going to run the test that is failing.
    The following listing shows our full code before we start the debugging process.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化调试过程，我们去除了通过的测试（将其放置一旁稍后恢复），并只运行失败的测试。以下代码显示了我们在开始调试过程之前的完整代码。
- en: Listing 8.9 Code that we’ll debug to count consecutive students
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.9 我们将调试的代码来计算连续学生数
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '#1 Failed test case'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 失败的测试用例'
- en: We’ll start with the first hypothesis, that `count` isn’t updating properly
    at the end of the list and set a breakpoint at the updating of `count`. Figure
    8.12 shows the first time the debugger pauses after it’s started.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从第一个假设开始，即`count`在列表末尾未正确更新，并在`count`更新的位置设置断点。图8.12显示了调试器在启动后第一次暂停的情况。
- en: '![figure](../Images/8-12.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/8-12.png)'
- en: Figure 8.12 Debugger stopping before the first update of `count`
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.12 调试器在`count`第一次更新之前停止
- en: From the debugger, we can see that `count` is still `0`, so it hasn’t been updated
    yet. We’re in the first row of that first test case because `row` is `['S',` `'`
    `',` `'S',` `'S',` `'S',` `'S']`. The seat we’re looking at is an `'S'`, which
    is why the count is increasing. Let’s click Continue in the Debug Toolbar to see
    the next update of `count`. The state of the debugger after clicking Continue
    appears in figure 8.13.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从调试器中我们可以看到，`count`仍然是`0`，所以它还没有被更新。我们处于第一个测试用例的第一行，因为`row`是`['S',` `'` `',`
    `'S',` `'S',` `'S',` `'S']`。我们正在查看的是一个`'S'`，这就是`count`在增加的原因。让我们点击调试工具栏中的继续按钮，查看`count`的下一个更新。点击继续后，调试器的状态如图8.13所示。
- en: '![figure](../Images/8-13.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/8-13.png)'
- en: Figure 8.13 Debugger stopping before the second update of `count`
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.13 调试器在`count`第二次更新之前停止
- en: A fair bit has happened, it seems, since the last update of `count` because
    `max_count` is now `1`. This must have happened when the empty space was processed
    because `max_count` was set to `1` and `count` was reset back to `0`. At this
    point, we’re at the third seat in the row with a student there, and `count` is
    ready to update. We’ll want to check that `count` keeps updating with each new
    student. We clicked Continue, and `count` increased to `1`. We clicked Continue
    again, and the `count` increased to `2`. We click Continue once more, and the
    `count` increased to `3`. At this point, we’re at the last student in the row,
    and we want to check that `count` increases to `4`. To check this, we clicked
    Step Over once, and `count` indeed updates to `4`. You can see the state of the
    debugger at this point in figure 8.14.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 看来自从上次更新`count`以来发生了不少事情，因为此时`max_count`的值是`1`。这一定是在处理空位时发生的，因为`max_count`被设置为`1`，并且`count`被重置为`0`。此时，我们已经到了这一行的第三个座位，并且有学生坐在那里，`count`准备好更新了。我们需要检查`count`是否随着每个新学生的出现而持续更新。我们点击了继续，`count`增加到`1`。我们再次点击继续，`count`增加到`2`。我们再次点击继续，`count`增加到`3`。此时，我们已经到了该行的最后一个学生，接下来要检查`count`是否增加到`4`。为此，我们点击了“Step
    Over”一次，`count`确实更新为`4`。你可以在图8.14中看到此时调试器的状态。
- en: '![figure](../Images/8-14.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/8-14.png)'
- en: Figure 8.14 Debugger stopping right after the fourth consecutive update of `count`
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.14 调试器在`count`连续四次更新后停下
- en: Well, we have good news and bad news at this point. The good news is that `count`
    is properly updating. The bad news is that our first hypothesis was wrong, and
    we haven’t found our bug yet. We could move our breakpoint to the line where `max_
    count` is updated (line 22) and then click Restart and start over the debugging
    process for our second hypothesis, but given that `count` is `4` right now in
    our debugger, let’s just continue to trace through the code and make sure `max_count`
    gets updated. Or rather, we know it won’t be, so we want to see why.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息和坏消息此时都来了。好消息是`count`正在正确更新。坏消息是我们的第一个假设是错的，我们还没找到我们的 bug。我们可以将断点移到`max_count`更新的那一行（第22行），然后点击重新启动并从头开始调试第二个假设，但考虑到目前在调试器中`count`的值是`4`，我们不如继续跟踪代码，确保`max_count`得到更新。或者说，我们知道它不会更新，所以我们想要看看为什么。
- en: Before clicking Step Over, we’ve got a clue already present in the debugger.
    This clue comes from the fact that the next line of code to execute is `for` `seat`
    `in` `row`. But the student we just saw was the last student in `row`. This means
    this `for` loop is just about to finish (meaning we won’t execute the body of
    the loop again, which means `max_count` can’t get updated). Let’s see whether
    that’s what happens by clicking Step Over. The state of the debugger appears in
    figure 8.15.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在点击“Step Over”之前，调试器中已经有了一个线索。这个线索来自于下一个要执行的代码行是`for` `seat` `in` `row`。但我们刚才看到的学生是`row`中的最后一个学生。这意味着这个`for`循环即将结束（意味着我们不会再次执行循环体，也就意味着`max_count`无法更新）。让我们通过点击“Step
    Over”看看是否真是这样。调试器的状态如图8.15所示。
- en: '![figure](../Images/8-15.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![figure](../Images/8-15.png)'
- en: Figure 8.15 Debugger stopping after finishing the first row
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.15 调试器在完成第一行后停止
- en: We just finished processing the first row, but we never updated the `max_count`.
    The next line of code will pick the next `row`, and the line after that will set
    `count` to `0` again. We finished the loop over the row without ever updating
    `max_count` even though we found a `count` that’s bigger than the current `max_count`.
    If you don’t see the bug yet, we encourage you to step through until the next
    time `max_count` is updated, and it may be more obvious at that point.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚完成了第一行的处理，但我们从未更新`max_count`。下一行代码将选择下一个`row`，之后的代码会将`count`重新设置为`0`。我们在没有更新`max_count`的情况下完成了行的循环，尽管我们找到了一个比当前`max_count`更大的`count`。如果你还没看到
    bug，建议你继续步进，直到下次`max_count`更新为止，那时问题可能会更加明显。
- en: The error in the code is that it only updates `max_count` when it encounters
    an empty seat. This means that if a row ends with a student, the code to check
    whether `max_count` should be updated will never run for that row. Examining the
    code more closely, the test to see whether `max_count` should be updated and the
    update of `max_count` should both occur either outside the `if-else` statement
    or right after `count` is updated.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的错误在于只有遇到空座位时才会更新`max_count`。这意味着如果一行以学生结束，那么检查是否应更新`max_count`的代码将永远不会在该行运行。仔细检查代码后发现，检查是否应更新`max_count`和更新`max_count`的操作应该发生在`if-else`语句之外，或者在`count`更新后紧接着进行。
- en: This is a fix we can probably just make manually because all we need to do is
    move two lines of code to a better location. The code in listing 8.10 is the corrected
    function (without the tests or prompts).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个我们可能可以手动修复的问题，因为我们只需要将两行代码移动到更合适的位置。列表 8.10 中的代码是修正后的函数（没有测试或提示）。
- en: Listing 8.10 Corrected function to count consecutive students
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.10 修正后的统计连续学生的函数
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '#1 Moved the testing of count against max_count to immediately after the updating
    of count'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '#1 将 count 与 max_count 的测试移动到更新 count 后面'
- en: This new code does pass the test that failed with the old code and the original
    test. After adding another test that makes sure the code works when the longest
    group of consecutive students appears at the start of the row, we’re more confident
    the code is now working properly.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这段新代码通过了之前旧代码和原始测试未能通过的测试。添加了另一个测试，确保当连续学生的最长组出现在行的开头时，代码仍然有效。现在我们更加确信代码已正确运行。
- en: 8.6 Using the debugger to better understand code
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6 使用调试器更好地理解代码
- en: We suspect you’re already pretty impressed by the debugger. We are too. When
    students were taught programming in the traditional manner, a lot of time was
    spent making sure students could essentially trace through code like a debugger
    would, drawing out the state of all the variables and updating them with each
    new line of execution. Indeed, there’s even a free tool on the web called Python
    Tutor [2] that creates diagrams of the state of memory that can be easier to read
    than a debugger, just to help new programmers learn how the code executes.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们猜想你已经对调试器印象深刻了，我们也是。当学生以传统方式学习编程时，很多时间都花在确保学生能够像调试器一样逐步跟踪代码，绘制所有变量的状态，并在每一行执行后更新它们。事实上，网络上甚至有一个免费的工具叫做
    Python Tutor [2]，它可以创建内存状态的图示，比调试器更易于阅读，帮助新程序员了解代码的执行过程。
- en: Whether you like using the debugger or want to use a tool like Python Tutor,
    we encourage you to play with some of the code you’ve written from earlier sections
    of the book. In our personal experience working with people learning how to program,
    walking through a program line by line and watching how the state of variables
    changes can be a truly enlightening experience, and we hope you’ll appreciate
    it too.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你喜欢使用调试器，还是想使用像 Python Tutor 这样的工具，我们鼓励你尝试一下自己在书中早些章节写的代码。从我们个人与学习编程的人合作的经验来看，逐行跟踪程序并观察变量的状态如何变化，可能是一次真正启发性的体验，我们希望你也能从中受益。
- en: 8.7 A caution about debugging
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7 调试的注意事项
- en: From working with students, we’ve also seen that debugging can be a really frustrating
    experience for new learners [3]. When learning how to program, everyone wants
    their code to work, and finding and fixing bugs is time spent when things aren’t
    working. There are a couple of ways to help overcome this frustration. First,
    problem decomposition can go a really long way to helping you get code from Copilot
    that is right without the need for extensive debugging. Second, remember that
    everyone’s code doesn’t work sometimes, including ours. It’s just a natural part
    of the programming process and a part that can take some practice. Last, always,
    and we mean always, test every function you write. More often than not, when our
    students are really stuck debugging, it’s because there are bugs in multiple functions
    interacting as a result of not testing each function. When that happens, it’s
    exceptionally hard to find and remedy the bugs. Debugging interacting bugs is
    so frustrating that avoiding the experience is a big reason why both of us religiously
    test every function we write.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 从与学生的互动中，我们也发现调试对新手学习者来说，可能是一种非常令人沮丧的体验 [3]。在学习编程时，每个人都希望自己的代码能正常工作，找到并修复错误是在代码没有正常工作时花费的时间。有几种方法可以帮助克服这种沮丧。首先，问题分解可以极大帮助你获得正确的
    Copilot 代码，而无需进行大量的调试。其次，记住每个人的代码有时也不会工作，包括我们的代码。这是编程过程中很自然的一部分，也是需要一些练习的部分。最后，始终，必须始终，测试你编写的每个函数。我们发现，当学生在调试中卡住时，通常是因为多个函数之间的相互作用中存在错误，导致没有对每个函数进行测试。当这种情况发生时，找到并修复错误是非常困难的。调试相互作用的错误非常令人沮丧，避免这种经历是我们俩都严格测试每个编写的函数的一个重要原因。
- en: The good news is that if you test every function you write and diligently break
    down problems into small, manageable steps, you shouldn’t find yourself debugging
    that often. And, if you do, you’ll be debugging the error in one function, which
    is what essentially every programmer on the planet does. With some practice, you’ll
    get the hang of it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，如果你测试每个编写的函数，并且仔细将问题分解成小而易于管理的步骤，你就不会经常遇到调试的情况。而且，即便遇到调试，你也只是在调试某个函数中的错误，这正是几乎每个程序员都会做的事。通过一些练习，你会掌握这一技能。
- en: 8.8 Exercises
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.8 练习
- en: 'You’re given a Python function that is supposed to calculate the sum of all
    even numbers in a list. However, the function isn’t working correctly. When you
    call the function with the list `[1,` `2,` `3,` `4]`, it returns `4` instead of
    `6`:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一个Python函数，应该计算列表中所有偶数的总和。然而，函数并未正确工作。当你调用该函数并传入列表`[1,` `2,` `3,` `4]`时，它返回`4`而不是`6`：
- en: '[PRE28]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Identify the bug in the `sum_even_numbers` function, and explain how to fix
    it. Modify the code to correct the bug, and verify your solution with the provided
    test case.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 识别`sum_even_numbers`函数中的错误，并解释如何修复它。修改代码以修正错误，并使用提供的测试用例验证解决方案。
- en: '2\. You’re given a Python function that is supposed to find the maximum number
    in a list of numbers. However, the function isn’t working as expected. Your task
    is to determine why the function is working incorrectly, and how you can fix this
    (hint, think about the possible integer values in the input list):'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 你给定了一个Python函数，应该查找列表中数字的最大值。然而，函数并未按预期工作。你的任务是确定该函数为何不正确工作，以及如何修复它（提示，考虑输入列表中可能的整数值）：
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '3\. You’re given a Python function that is supposed to check if a string is
    a valid password. A valid password must meet the following criteria:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 你给定了一个Python函数，应该检查一个字符串是否是有效的密码。一个有效的密码必须满足以下标准：
- en: It must be at least 8 characters long.
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 密码长度必须至少为8个字符。
- en: It must contain at least one uppercase letter.
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 密码必须包含至少一个大写字母。
- en: It must contain at least one lowercase letter.
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 密码必须包含至少一个小写字母。
- en: It must contain at least one digit.
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 密码必须包含至少一个数字。
- en: 'However, the function isn’t working correctly. Determine what is wrong with
    the function and fix it:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，函数并未正确工作。确定函数的问题所在，并修复它：
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '4\. You’re writing a Python function to greet users based on the time of day.
    The function takes an hour (integer between 0 and 23) as input and returns a greeting
    message (“Good morning”, “Good afternoon”, or “Good evening”):'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 你正在编写一个Python函数，根据一天中的时间向用户打招呼。该函数接受一个小时（0到23之间的整数）作为输入，并返回问候消息（“Good morning”，“Good
    afternoon”或“Good evening”）：
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You’re considering using this prompt to ask Copilot to help you fix the bug:
    “I have a function to greet users based on the time of day, but it seems to classify
    noon as ‘Good evening’. Can you help me fix the logic?” The prompt mentions the
    problem but doesn’t pinpoint the exact error. See if you can edit the provided
    prompt to make it more specific and guide Copilot toward suggesting the correct
    fix.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在考虑使用以下提示来让Copilot帮助你修复错误：“我有一个根据时间向用户问候的函数，但它似乎将中午分类为‘Good evening’。你能帮我修复逻辑吗？”该提示提到了问题，但没有准确指出错误所在。看看你是否能修改提供的提示，使其更加具体，并引导Copilot提出正确的修复方法。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Debugging is an important skill that includes finding errors in code and then
    correcting them.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试是一项重要的技能，它包括查找代码中的错误并加以修正。
- en: '`Print` statements can be an effective way of learning about what is happening
    in your code.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Print`语句是了解代码运行情况的一种有效方式。'
- en: The VS Code debugger is another way of learning what is happening in your code
    that provides powerful features for monitoring how variables change as the code
    executes.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VS Code调试器是另一种了解代码运行情况的方式，提供了强大的功能来监控变量在代码执行过程中如何变化。
- en: Once an error is uncovered, there are multiple ways to help Copilot fix the
    error for you, but if that fails, you can often fix the code directly.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦发现错误，有多种方法可以帮助Copilot修复错误，但如果失败，你通常也可以直接修复代码。
- en: Our workflow of designing functions now includes debugging, and with the skill
    of debugging, you’re more apt to write the software you want.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们的函数设计流程包括调试，而凭借调试技能，你更有可能编写出你想要的软件。
- en: Outside of debugging, the VS Code debugger can be a powerful tool in learning
    more about how the code works.***********
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了调试外，VS Code调试器还可以作为学习如何理解代码的重要工具。
