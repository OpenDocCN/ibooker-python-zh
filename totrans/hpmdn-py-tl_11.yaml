- en: Chapter 8\. Automation with Nox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you maintain a Python project, you’re faced with many chores. Running
    checks on your code is an important part:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing helps you reduce the defect rate of your code ([Chapter 6](ch06.html#chapter_testing)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coverage reporting pinpoints untested parts of your code ([Chapter 7](ch07.html#chapter_coverage)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linters analyze your source code to find ways to improve it ([Chapter 9](ch09.html#chapter_linting)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code formatters lay out the source code in a readable way ([Chapter 9](ch09.html#chapter_linting)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type checkers verify the type correctness of your code ([Chapter 10](ch10.html#chapter_typing)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other chores include:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to build and publish packages for distribution ([Chapter 3](ch03.html#chapter_packages)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to update the dependencies of your project ([Chapter 4](ch04.html#chapter_dependencies)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to deploy your service (see [Example 5-7](ch05.html#example_docker_poetry_bundle)
    in [Chapter 5](ch05.html#chapter_poetry)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to build the documentation for your project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating these tasks has many benefits. You focus on coding while the check
    suite covers your back. You gain confidence in the steps that take your code from
    development to production. You remove human error and encode each process, so
    others can review and improve it.
  prefs: []
  type: TYPE_NORMAL
- en: Automation gives you leverage to make each step as repeatable, each result as
    reproducible, as possible. Checks and tasks run in the same way on developer machines
    and in continuous integration (CI). They run across different Python versions,
    operating systems, and platforms.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn about Nox, a Python automation framework. Nox
    serves as a single entry point to your checks and tasks—​for your team, external
    contributors, and automated systems like CI runners.
  prefs: []
  type: TYPE_NORMAL
- en: 'You write Nox sessions in plain Python: each Nox session is a Python function
    that executes commands in a dedicated, isolated environment. Using Python as the
    automation language gives Nox great simplicity, portability, and expressivity.'
  prefs: []
  type: TYPE_NORMAL
- en: First Steps with Nox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install Nox globally using pipx:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Specify the latest stable version of Python—​Nox defaults to that version when
    creating environments. Pipx makes the command `nox` available globally, while
    keeping its dependencies isolated from your global Python installation (see [“Installing
    Applications with Pipx”](ch02.html#section_environments_pipx)).
  prefs: []
  type: TYPE_NORMAL
- en: Configure Nox in a Python file named *noxfile.py* in your project, next to *pyproject.toml*.
    [Example 8-1](#example_nox_simple) shows a *noxfile.py* for running the test suite.
    It’s meant for a simple Python project with no test dependencies besides pytest.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-1\. A session for running the test suite
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Sessions* are the central concept in Nox: each session comprises an environment
    and some commands to run within it. You define a session by writing a Python function
    decorated with `@nox.session`. The function receives a session object as an argument,
    which you can use to install packages (`session.install`) and run commands (`session.run`)
    in the session environment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can try the session with the example project from previous chapters. For
    now, add your test dependencies to the `session.install` arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke `nox` without arguments to run all sessions in the *noxfile.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the output, Nox starts by creating a virtual environment
    for the `tests` session using `virtualenv`. If you’re curious, you can find this
    environment under the *.nox* directory in your project.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: By default, environments use the same interpreter as Nox itself. In [“Working
    with Multiple Python Interpreters”](#section_nox_pythons), you’ll learn how to
    run sessions on another interpreter, and even across multiple ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the session installs the project and pytest into its environment. The
    function `session.install` is just `pip install` underneath. You can pass any
    appropriate options and arguments to pip. For example, you can install your dependencies
    from a requirements file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you keep your development dependencies in an extra, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Above, you’ve used `session.install(".")` to install your project. Behind the
    scenes, pip builds a wheel using the build backend you’ve specified in *pyproject.toml*.
    Nox runs in the directory containing *noxfile.py*, so this command assumes both
    files are in the same directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nox lets you use `uv` instead of virtualenv and pip for creating environments
    and installing packages. You can switch the backend to `uv` by setting an environment
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Second, the session runs the `pytest` command you just installed. If a command
    fails, the session is marked as failed. By default, Nox continues with the next
    session, but it will exit with a non-zero status at the end if any session failed.
    In the run above, the test suite passes and Nox reports success.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 8-2](#example_nox_build) adds a session to build packages for the
    project (see [Chapter 3](ch03.html#chapter_packages)). The session also validates
    the packages using Twine’s `check` command.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-2\. A session for building packages
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 8-2](#example_nox_build) relies on the standard library for clearing
    out stale packages and locating the freshly built ones: `Path.glob` matches files
    against wildcards, and `shutil.rmtree` removes a directory and its contents.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Nox doesn’t implicitly run commands in a shell, unlike tools such as `make`.
    Shells differ widely between platforms, so they’d make Nox sessions less portable.
    For the same reason, avoid Unix utilities like `rm` or `find` in your sessions—use
    Python’s standard library instead!
  prefs: []
  type: TYPE_NORMAL
- en: The programs you invoke with `session.run` should be available inside the environment.
    If they’re not, Nox prints a friendly warning and falls back to the system-wide
    environment. In the Python world, running programs outside their intended environment
    is a mistake that’s easy to make and hard to diagnose. Turn the warning into an
    error! [Example 8-3](#example_nox_external_error) shows how.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-3\. Preventing external commands in Nox sessions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_automation_with_nox_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Modify `nox.options` at the top of your *noxfile.py*, outside of sessions.
  prefs: []
  type: TYPE_NORMAL
- en: At times, you do need to run external commands, such as non-Python build tools.
    You can allow external commands by passing the `external` flag to `session.run`.
    [Example 8-4](#example_nox_external) shows how to build packages using an existing
    Poetry installation on your system.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-4\. Using an external command to build the packages
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You’re trading off reliability for speed here. [Example 8-2](#example_nox_build)
    works with any build backend declared in *pyproject.toml* and installs it in an
    isolated environment on each run. [Example 8-4](#example_nox_external) assumes
    that contributors have a recent version of Poetry on their system and breaks if
    they don’t. Prefer the first method unless every developer environment has a well-known
    Poetry version.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over time, *noxfile.py* may accumulate a number of sessions. The `--list` option
    gives you a quick overview of them. If you add module and function docstrings
    with helpful descriptions, Nox includes them in the listing as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Running Nox with the `--session` option lets you select individual sessions
    by name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'During development, running `nox` repeatedly lets you catch errors early. On
    the other hand, you don’t need to validate your packages each time. Fortunately,
    you can change which sessions run by default by setting `nox.options.sessions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, when you run `nox` without arguments, only the `tests` session runs. You
    can still select the `build` session using the `--session` option. Command-line
    options override values specified in `nox.options` in *noxfile.py*.^([1](ch08.html#id304))
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Keep your default sessions aligned with the mandatory checks for your project.
    Contributors should be able to run `nox` without arguments to check if their code
    changes are acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: Every time a session runs, Nox creates a fresh virtual environment and installs
    the dependencies. This is a good default, because it makes the checks strict,
    deterministic, and repeatable. You won’t miss problems with your code due to stale
    packages in the session environment.
  prefs: []
  type: TYPE_NORMAL
- en: However, Nox gives you a choice. Setting up environments each time might be
    a tad slow if you re-run your tests in quick succession while coding. You can
    reuse environments with the option `-r` or `--reuse-existing-virtualenvs`. Additionally,
    you can skip installation commands by specifying `--no-install`, or combine these
    options using the shorthand `-R`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Working with Multiple Python Interpreters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your project supports more than a single version of Python, you should run
    your tests on all of them. Nox really shines when it comes to running sessions
    on multiple interpreters. When you define the session with `@nox.session`, use
    the `python` keyword to request one or more specific Python versions, as shown
    in [Example 8-5](#example_nox_python).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-5\. Running tests across multiple Python versions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Nox creates an environment for each version and runs the commands in those
    environments in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Did you get errors from pip when you ran Nox just now? Don’t use the same compiled
    requirements file for every Python version. You need to lock dependencies separately
    for each environment (see [“Session Dependencies”](#section_nox_dependencies)).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can narrow down sessions by Python version using the option `--python`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: During development, the `--python` option comes in handy, as it lets you save
    time by running tests on the latest version only.
  prefs: []
  type: TYPE_NORMAL
- en: Nox discovers interpreters by searching `PATH` for commands like `python3.12`,
    `python3.11`, and so on. You can also specify a string like `"pypy3.10"` to request
    the PyPy interpreter—​any command that can be resolved against `PATH` will work.
    On Windows, Nox also queries the Python Launcher to find available interpreters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you’ve installed a prerelease of Python and want to test your project
    on it. The `--python` option would require that the session lists the prerelease.
    Instead, you can specify `--force-python`: it overrides the interpreter for a
    single run. For example, the following invocation runs the `tests` session on
    Python 3.13:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Session Arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, the `tests` session runs pytest without arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You *could* pass additional options—​such as `--verbose`, which lists every
    individual test separately in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'But you don’t always want the same options for pytest. For example, the `--pdb`
    option launches the Python debugger on test failures. The debug prompt can be
    a life saver when you investigate a mysterious bug. But it’s worse than useless
    in a CI context: it would hang forever since there’s nobody to enter commands.
    Similarly, when you work on a feature, the `-k` option lets you run tests with
    a specific keyword in their name—​but you wouldn’t want to hardcode it in *noxfile.py*
    either.'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Nox lets you pass additional command-line arguments for a session.
    The session can forward the session arguments to a command or evaluate them for
    its own purposes. Session arguments are available in the session as `session.posargs`.
    [Example 8-6](#example_nox_posargs) shows how you forward them to a command like
    pytest.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-6\. Forwarding session arguments to pytest
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You must separate session arguments from Nox’s own command-line arguments with
    the `--` delimiter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Automating Coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Coverage tools give you a sense of how much your tests exercise the codebase
    (see [Chapter 7](ch07.html#chapter_coverage)). In a nutshell, you install the
    `coverage` package and invoke pytest via `coverage run`. [Example 8-7](#example_nox_coverage_run)
    shows how to automate this process with Nox:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-7\. Running tests with code coverage
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When you’re testing in multiple environments, you need to store the coverage
    data from each environment in a separate file (see [“Parallel Coverage”](ch07.html#section_coverage_parallel)).
    Add the following lines to *pyproject.toml* to enable this mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In [Chapter 7](ch07.html#chapter_coverage), you installed your project in editable
    mode. The Nox session builds and installs a wheel of your project instead. This
    ensures that you’re testing the final artifact you’re distributing to users. But
    it also means that Coverage.py needs to map the installed files back to your source
    tree. Configure the mapping in *pyproject.toml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_automation_with_nox_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This maps files installed in the *site-packages* directory in an environment
    to files in your *src* directory. The key `source` is an arbitrary identifier;
    it’s needed because you can have multiple mappings in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 8-8](#example_nox_coverage_report) aggregates the coverage files and
    displays the coverage report:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-8\. Reporting the code coverage
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The session only invokes `coverage combine` if there are any coverage data files—​the
    command would fail with an error otherwise. As a result, you can safely use `nox
    -s coverage` to inspect your test coverage without having to re-run the tests
    first.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike [Example 8-7](#example_nox_coverage_run), this session runs on the default
    Python version and installs only Coverage.py. You don’t need to install your project
    to generate the coverage report.
  prefs: []
  type: TYPE_NORMAL
- en: If you run these sessions on the example project, make sure to configure Coverage.py
    as shown in [Chapter 7](ch07.html#chapter_coverage). Include Python 3.7 in the
    `tests` session if your project uses the conditional import for `importlib-metadata`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `coverage` session still reports missing coverage for the `main` function
    and the `__main__` module. You’ll take care of that in [“Automating Coverage in
    Subprocesses”](#section_nox_subprocess_coverage).
  prefs: []
  type: TYPE_NORMAL
- en: Session Notification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As it stands, this *noxfile.py* has a subtle problem. Until you run the `coverage`
    session, your project will be littered with data files waiting to be processed.
    And if you haven’t run the `tests` session recently, the data in those files may
    be stale—​so your coverage report won’t reflect the latest state of the codebase.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 8-9](#example_nox_coverage_notify) triggers the `coverage` session
    to run automatically after the test suite. Nox supports this with the `session.notify`
    method. If the notified session isn’t already selected, it runs after the other
    sessions have completed.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-9\. Triggering coverage reports from the tests
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `try...finally` block ensures you get a coverage report even when a test
    fails. That’s helpful when you start development with a failing test: you want
    to be sure the test exercises the code you’re writing to make it pass.'
  prefs: []
  type: TYPE_NORMAL
- en: Automating Coverage in Subprocesses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Alan Kay, a pioneer in object-oriented programming and graphical user interface
    design, once said, “Simple things should be simple; complex things should be possible.”^([2](ch08.html#id305))
    Many Nox sessions will be two-liners: a line to install dependencies and a line
    to run a command. Yet some automations require more complex logic, and Nox excels
    at those, too—​primarily by staying out of your way and deferring to Python as
    a general-purpose programming language.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s iterate on the `tests` session and measure coverage in subprocesses. As
    you saw in [Chapter 7](ch07.html#chapter_coverage), setting this up requires a
    little dance. First, you install a *.pth* file into the environment; this gives
    `coverage` a chance to initialize when the subprocess starts up. Second, you set
    an environment variable to point `coverage` to its configuration file. It’s tedious
    and a bit tricky to get right. Let’s “automate it away”!
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to determine the location for the *.pth* file. The directory
    is named *site-packages*, but the exact path depends on your platform and the
    Python version. Instead of taking a guess, you can query the `sysconfig` module
    for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If you called the function directly in your session, it would return a location
    in the environment where you’ve installed Nox. Instead, you need to query the
    interpreter *in the session environment*. You can do this by running `python`
    with `session.run`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `silent` keyword lets you capture the output instead of echoing it to the
    terminal. Thanks to `pathlib` from the standard library, writing the *.pth* file
    now only takes a couple of statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 8-10](#example_nox_coverage_pth) extracts these statements into a
    helper function. The function takes a `session` argument, but it isn’t a Nox session—​it
    lacks the `@nox.session` decorator. In other words, the function won’t run unless
    you call it from a session.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-10\. Installing *coverage.pth* into the environment
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You’re almost done. What’s left is invoking the helper function from the `tests`
    session and passing the environment variable to `coverage`. [Example 8-11](#example_nox_coverage_subprocess)
    shows the final session.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-11\. The `tests` session with subprocess coverage enabled
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_automation_with_nox_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Install the dependencies before the *.pth* file. The order matters because the
    *.pth* file imports the `coverage` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'With subprocess coverage enabled, the end-to-end test produces the missing
    coverage data for the `main` function and the `__main__` module. Invoke `nox`
    and watch it run your tests and generate a coverage report. Here’s what the report
    should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Parameterizing Sessions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The phrase “works for me” describes a common story: a user reports an issue
    with your code, but you can’t reproduce the bug in your environment. Runtime environments
    in the real world differ in a myriad of ways. Testing across Python versions covers
    one important variable. Another common cause of surprise is the packages that
    your project uses directly or indirectly—​its dependency tree.'
  prefs: []
  type: TYPE_NORMAL
- en: Nox offers a powerful technique for testing your project against different versions
    of a dependency. *Parameterization* allows you to add parameters to your session
    functions and supply predefined values for them; Nox runs the session with each
    of these values.
  prefs: []
  type: TYPE_NORMAL
- en: You declare the parameter and its values in a decorator named `@nox.parametrize`.^([3](ch08.html#id306))
    [Example 8-12](#example_nox_parametrize) demonstrates this feature and how it
    allows you to test against different versions of the Django web framework.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-12\. Testing the project with multiple Django versions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameterized sessions are similar to parameterized tests in pytest (see [Chapter 6](ch06.html#chapter_testing)),
    which is where Nox borrowed the concept from. You can stack `@nox.parametrize`
    decorators to run sessions against all combinations of parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If you only want to check for certain combinations, you can combine parameters
    in a single `@nox.parametrize` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When running a session across Python versions, you’re effectively parameterizing
    the session by the interpreter. In fact, Nox let’s you write the following instead
    of passing the versions to `@nox.session`:^([4](ch08.html#id307))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax is useful when you want specific combinations of Python and the
    dependency. Here’s an example: As of this writing, Django 3.2 (LTE) doesn’t officially
    support Python versions newer than 3.10\. Consequently, you need to exclude these
    combinations from the test matrix. [Example 8-13](#example_nox_parametrize_python)
    shows how.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-13\. Parameterizing by valid Python and Django combinations
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Session Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you’ve followed [Chapter 4](ch04.html#chapter_dependencies) closely, you
    may see some problems with the way [Example 8-8](#example_nox_coverage_report)
    and [Example 8-11](#example_nox_coverage_subprocess) install packages. Here are
    the relevant parts again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'For one, the `coverage` session doesn’t specify which version of `coverage`
    the project requires. The `tests` session does this right: it references the `tests`
    extra in *pyproject.toml*, which includes the appropriate version specifiers (see
    [“Managing Test Dependencies”](ch06.html#section_testing_dependencies)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `coverage` session doesn’t need the project, though, so an extra seems
    like a bad fit. But before I get to this, let me point out another problem with
    the sessions above: They don’t lock their dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running checks without locking dependencies has two drawbacks. First, the checks
    aren’t deterministic: subsequent runs of the same session may install different
    packages. Second, if a dependency breaks your project, checks fail until you exclude
    the release or another release fixes the problem.^([5](ch08.html#id308)) In other
    words, any project you depend on, even indirectly, has the power to block your
    entire CI pipeline.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, lock file updates are a constant churn, and they clutter
    your Git history. Reducing their frequency comes at the price of running checks
    with stale dependencies. If you don’t require locking for other reasons, such
    as secure deployments—​and you’re happy to quickly fix a build when an incompatible
    release wreaks havoc on your CI—​you may prefer to keep your dependencies unlocked.
    There ain’t no such thing as a free lunch.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [“Development Dependencies”](ch04.html#section_dependencies_development),
    you grouped dependencies in extras and compiled requirements files from each.
    In this section, I’ll show you a lighter-weight method for locking: *constraints
    files*. You only need a single extra for it. It also doesn’t require installing
    the project itself, as extras usually do—​which helps with the `coverage` session.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constraints files look similar to requirements files: Each line lists a package
    with a version specifier. Unlike requirements files, however, constraints files
    don’t cause pip to install a package—​they only control which version pip selects
    *if* it needs to install the package.'
  prefs: []
  type: TYPE_NORMAL
- en: A constraints file works great for locking session dependencies. You can share
    it across sessions while only installing the packages each session needs. Its
    only drawback, compared to using a set of requirements files, is that you need
    to resolve all dependencies together, so there’s a higher chance of dependency
    conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: You can generate constraints files using pip-tools or uv (see [“Compiling Requirements
    with pip-tools and uv”](ch04.html#section_dependencies_piptools)). Nox can automate
    this part, too, as shown in [Example 8-14](#example_nox_constraints).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-14\. Locking the dependencies with uv
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_automation_with_nox_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Explicitly require uv as the environment backend. (You could also install uv
    into the session with `session.install("uv")`, but uv supports a broader range
    of Python versions than you can use to install its PyPI package.)
  prefs: []
  type: TYPE_NORMAL
- en: The `--output-file` option specifies the conventional name for a constraints
    file, *constraints.txt*. The `--upgrade` option ensures that you get up-to-date
    dependencies whenever you run the session. The `--all-extras` option includes
    all the optional dependencies of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Don’t forget to commit the constraints file to source control. You need to share
    this file with every contributor, and it needs to be available in CI.
  prefs: []
  type: TYPE_NORMAL
- en: Pass the constraints file to `session.install` using the `--constraint` or `-c`
    option. [Example 8-15](#example_nox_single_constraints) shows the `tests` and
    `coverage` sessions with locked dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-15\. Using a constraints file to lock session dependencies
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Using a single constraints file requires that you target a well-known interpreter
    and platform. You can’t use the same constraints file for different environments
    because each environment may require different packages.
  prefs: []
  type: TYPE_NORMAL
- en: If you support multiple Python versions, operating systems, or processor architectures,
    compile a separate constraints file for each environment. Keep the constraints
    files in a subdirectory to avoid clutter. [Example 8-16](#example_nox_constraints_helper)
    shows a helper function that constructs filenames like *constraints/python3.12-linux-arm64.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-16\. Constructing paths for a constraints file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 8-17](#example_nox_constraints_multipython) updates the `lock` session
    to generate the constraints files. The session now runs on every Python version.
    It uses the helper function to build the path for the constraints file, ensures
    that the target directory exists, and passes the filename to uv.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-17\. Locking dependencies on multiple Python versions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `tests` and `coverage` sessions can now reference the appropriate constraints
    file for each Python version. For this to work, you have to declare a Python version
    for the `coverage` session as well.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-18\. The `tests` and `coverage` session with multi-Python constraints
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Using Nox with Poetry Projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you manage your project with Poetry, you organize dependencies in dependency
    groups (see [“Dependency Groups”](ch05.html#section_poetry_development_dependencies)).
    Dependency groups align naturally with Nox sessions: packages for the `tests`
    session go into a `tests` group, those for a `docs` session into a `docs` group,
    and so on. Using Poetry as the installer means you get locked dependencies for
    free—​all installations honor the lock file.'
  prefs: []
  type: TYPE_NORMAL
- en: Before I show you how to use Poetry in Nox sessions, let me call out a couple
    of differences between Poetry environments and Nox environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the Poetry environment is comprehensive: by default, it includes the
    project, its main dependencies, and every non-optional dependency group. Nox environments
    only install packages required for the task they automate.'
  prefs: []
  type: TYPE_NORMAL
- en: Second, the Poetry environment uses editable installs for the project so you
    don’t need to reinstall after every code change. Nox environments build and install
    a wheel so automated checks see the project the same way an end user would.
  prefs: []
  type: TYPE_NORMAL
- en: There’s no right and wrong here. Poetry environments are perfect for ad-hoc
    interactions with your project during development, with every tool just a `poetry
    run` away. Nox environments, on the other hand, are optimized for reliable and
    repeatable checks; they aim to be as isolated and deterministic as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you use Poetry in a Nox session, it’s good to be mindful of these differences.
    I recommend these guidelines for invoking `poetry install` with Nox:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the option `--no-root` to avoid an editable install of the project. If the
    session needs the project to be installed (not every session does), follow the
    command with `session.install(".")` to build and install a wheel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the option `--only=*<group>*` to install the appropriate dependency group
    for the session. If the session needs the project to be installed, list the special
    group `main` as well—​this ensures that every package is pinned using *poetry.lock*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the option `--sync` to remove packages from a reused session environment
    when your project no longer depends on them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example 8-19](#example_nox_poetry_install) puts this logic into a helper function
    that you can share across your session functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-19\. Installing session dependencies with Poetry
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The helper function uses `session.run_install` instead of `session.run`. The
    two functions work exactly alike, but `session.run_install` marks the command
    as an installation. This avoids package installations when you reuse environments
    with `--no-install` or `-R`.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve followed along using Poetry in [Chapter 6](ch06.html#chapter_testing)
    and [Chapter 7](ch07.html#chapter_coverage), your *pyproject.toml* should have
    a dependency group named `tests` containing pytest and coverage. Let’s split the
    `coverage` dependency off into a separate group, since you don’t need the test
    dependencies for the `coverage` session:^([6](ch08.html#id309))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how you’d install the dependencies in the `tests` session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s what the `coverage` session looks like with the helper function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: How does Poetry know to use a Nox environment instead of the Poetry environment?
    Poetry installs packages into the active environment, if one exists. When Nox
    runs Poetry, it activates the session environment by exporting the `VIRTUAL_ENV`
    environment variable (see [“Virtual Environments”](ch02.html#section_environments_venv)).
  prefs: []
  type: TYPE_NORMAL
- en: Locking Dependencies with nox-poetry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There’s an alternative approach to using Nox with Poetry projects. The `nox-poetry`
    package is an unofficial plugin for Nox that lets you write sessions without worrying
    about locking, using plain `session.install`. Behind the scenes, `nox-poetry`
    exports a constraints file for pip using `poetry export`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `nox-poetry` into the same environment as Nox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Decorate your sessions with `@session` from the `nox-poetry` package, which
    is a drop-in replacement for `@nox.session`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: When you install packages with `session.install`, the constraints file keeps
    their versions in sync with `poetry.lock`. You can manage dependencies in separate
    dependency groups or put them into a single `dev` group.
  prefs: []
  type: TYPE_NORMAL
- en: While this approach is convenient and simplifies the resulting *noxfile.py*,
    it doesn’t come for free. Translating Poetry’s dependency information into a constraints
    file isn’t lossless—​for example, it doesn’t include package hashes or the URLs
    of private package repositories. Another drawback is that contributors have another
    global dependency to worry about. When I wrote `nox-poetry` in 2020, dependency
    groups didn’t exist. As of this writing, I recommend using Poetry directly, as
    described in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nox lets you automate checks and tasks for a project. Its Python configuration
    file *noxfile.py* organizes them into one or more sessions. Sessions are functions
    decorated with `@nox.session`. They receive a single argument `session` providing
    the session API ([Table 8-1](#table_nox_session)). Every session runs in an isolated
    virtual environment. If you pass a list of Python versions to `@nox.session`,
    Nox runs the session across all of them.
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-1\. The session object
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Description | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `run()` | Run a command | `session.run("coverage", "report")` |'
  prefs: []
  type: TYPE_TB
- en: '| `install()` | Install packages with pip | `session.install(".", "pytest")`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `run_install()` | Run an installation command | `session.run_install("poetry",
    "install")` |'
  prefs: []
  type: TYPE_TB
- en: '| `notify()` | Enqueue another session | `session.notify("coverage")` |'
  prefs: []
  type: TYPE_TB
- en: '| `python` | The interpreter for this session | `"3.12"` |'
  prefs: []
  type: TYPE_TB
- en: '| `posargs` | Extra command-line arguments | `nox -- --verbose --pdb` |'
  prefs: []
  type: TYPE_TB
- en: The command `nox` ([Table 8-2](#table_nox_options)) provides a single entry
    point to your suite of checks. Without arguments, it runs every session defined
    in *noxfile.py* (or those you’ve listed in `nox.options.sessions`). The earlier
    you identify issues with your code, the cheaper it is to fix them—​so use Nox
    to run the same checks locally as in continuous integration (CI). Besides checks,
    you can automate many other chores, such as building packages or documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-2\. Command-line options for `nox`
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `--list` | List the available sessions | `nox -l` |'
  prefs: []
  type: TYPE_TB
- en: '| `--session` | Select sessions by name | `nox -s tests` |'
  prefs: []
  type: TYPE_TB
- en: '| `--python` | Select sessions by interpreter | `nox -p 3.12` |'
  prefs: []
  type: TYPE_TB
- en: '| `--force-python` | Override the interpreter for a session | `nox --force-python
    3.13` |'
  prefs: []
  type: TYPE_TB
- en: '| `--reuse-existing-virtualenvs` | Reuse existing virtual environments | `nox
    -rs tests` |'
  prefs: []
  type: TYPE_TB
- en: '| `--no-install` | Skip installation commands | `nox -Rs tests` |'
  prefs: []
  type: TYPE_TB
- en: There’s a lot more to Nox that this chapter didn’t cover. For example, you can
    use Conda or Mamba to create environments and install packages. You can organize
    sessions using keywords and tags, and assign friendly identifiers using `nox.param`.
    Last but not least, Nox comes with a GitHub Action that makes it easy to run Nox
    sessions in CI. Take a look at the [official documentation](https://nox.thea.codes)
    to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch08.html#id304-marker)) In case you’re wondering, always use the plural
    form `nox.options.sessions` in *noxfile.py*. On the command line, both `--session`
    and `--sessions` work. You can specify any number of sessions with these options.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch08.html#id305-marker)) Alan Kay, [“What is the story behind Alan Kay’s
    adage *Simple things should be simple, complex things should be possible*?”](https://qr.ae/pyjKrs),
    *Quora Answer*, June 19, 2020.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch08.html#id306-marker)) Like pytest, Nox uses the alternate spelling
    “parametrize” to protect your “E” keycap from excessive wear.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch08.html#id307-marker)) The eagle-eyed reader may notice that `python`
    is not a function parameter here. If you do need it in the session function, use
    `session.python` instead.
  prefs: []
  type: TYPE_NORMAL
- en: '^([5](ch08.html#id308-marker)) Semantic Versioning constraints do more harm
    here than they help. Bugs occur in all releases, and your upstream’s definition
    of a breaking change may be narrower than you like. See Hynek Schlawack: [“Semantic
    Versioning Will Not Save You,”](https://hynek.me/articles/semver-will-not-save-you/)
    March 2, 2021.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch08.html#id309-marker)) Run `poetry lock --no-update` after editing *pyproject.toml*
    to update the *poetry.lock* file.
  prefs: []
  type: TYPE_NORMAL
