<html><head></head><body><section data-pdf-bookmark="Appendix C. Something Completely Different: Async" data-type="appendix" epub:type="appendix"><div class="appendix" id="app_async">&#13;
<h1><span class="label">Appendix C. </span>Something Completely Different: Async</h1>&#13;
&#13;
&#13;
<p><a data-primary="asynchronous tasks" data-type="indexterm" id="ix_appC-async-asciidoc0"/>Our first two appendixes were for beginning programmers,&#13;
but this one is for those who are a bit advanced.</p>&#13;
&#13;
<p>Like most programming languages,&#13;
Python has been <em>synchronous</em>.&#13;
It runs through code linearly,&#13;
a line at a time,&#13;
from top to bottom.&#13;
When you call a function,&#13;
Python jumps into its code,&#13;
and the caller waits until&#13;
the function returns before resuming what it was doing.</p>&#13;
&#13;
<p>Your CPU can do only one thing at a time,&#13;
so synchronous execution makes perfect sense.&#13;
But it turns out that often a program&#13;
is not actually running any code,&#13;
but waiting for something,&#13;
like data from a file or a network service.&#13;
This is like us staring at a browser screen&#13;
while waiting for a site to load.&#13;
If we could avoid this “busy waiting,”&#13;
we might shorten the total time of our programs.&#13;
This is also called improving <em>throughput</em>.</p>&#13;
&#13;
<p>In <a data-type="xref" href="ch15.html#ch_systems">Chapter 15</a>,&#13;
you saw that if you want some concurrency,&#13;
your choices included threads, processes,&#13;
or a third-party solution like <code>gevent</code> or <code>twisted</code>.&#13;
But there are now a growing number of <em>asynchronous</em>&#13;
answers, both built in to Python and third-party solutions.&#13;
These coexist with the usual synchronous Python code,&#13;
but, to borrow a Ghostbusters warning,&#13;
you can’t cross the streams.&#13;
I’ll show you how to avoid any ectoplasmic side effects.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before less_space" data-pdf-bookmark="Coroutines and Event Loops" data-type="sect1"><div class="sect1" id="idm45794959472696">&#13;
<h1>Coroutines and Event Loops</h1>&#13;
&#13;
<p><a data-primary="asynchronous tasks" data-secondary="coroutines and event loops" data-type="indexterm" id="ix_appC-async-asciidoc1"/><a data-primary="coroutines" data-type="indexterm" id="ix_appC-async-asciidoc2"/><a data-primary="event loops" data-type="indexterm" id="ix_appC-async-asciidoc3"/><a data-primary="loops" data-secondary="coroutines and event loops" data-type="indexterm" id="ix_appC-async-asciidoc4"/>In Python 3.4,&#13;
<a data-primary="asyncio library" data-secondary="about" data-type="indexterm" id="idm45794959465848"/>Python added a standard <em>asynchronous</em> module&#13;
called <code>asyncio</code>.&#13;
Python 3.5 then added the keywords&#13;
<code>async</code> and <code>await</code>.&#13;
These implement some new concepts:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><em>Coroutines</em> are functions that pause at various&#13;
points</p>&#13;
</li>&#13;
<li>&#13;
<p>An <em>event loop</em> that schedules and runs coroutines</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>These let us write asynchronous code that&#13;
looks something like the normal synchronous code&#13;
that we’re used to.&#13;
Otherwise, we’d need to use one of the methods&#13;
mentioned in <a data-type="xref" href="ch15.html#ch_systems">Chapter 15</a> and <a data-type="xref" href="ch17.html#ch_networks">Chapter 17</a>,&#13;
and summarized later in <a data-type="xref" href="#async_versus">“Async Versus…”</a>.</p>&#13;
&#13;
<p>Normal multitasking is what your operating system does&#13;
to your processes.&#13;
It decides what’s fair, who’s being a CPU hog,&#13;
when to open the I/O spigots, and so on.&#13;
<a data-primary="cooperative multitasking" data-type="indexterm" id="idm45794959456328"/>The event loop, however,&#13;
provides <em>cooperative multitasking</em>,&#13;
in which coroutines indicate when they’re able to start and stop.&#13;
They run in a single thread, so you don’t have the&#13;
potential issues that I mentioned in <a data-type="xref" href="ch15.html#threads">“Threads”</a>.</p>&#13;
&#13;
<p>You <em>define</em> a coroutine by putting <code>async</code> before&#13;
its initial <code>def</code>.&#13;
You <em>call</em> a coroutine by:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Putting <code>await</code> before it,&#13;
which quietly adds the coroutine to an existing event loop.&#13;
You can do this only within another coroutine.</p>&#13;
</li>&#13;
<li>&#13;
<p>Or by using <code>asyncio.run()</code>,&#13;
which explicitly starts an event loop.</p>&#13;
</li>&#13;
<li>&#13;
<p>Or by using <code>asyncio.create_task()</code> or <code>asyncio.ensure_future()</code>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>This example uses the first two calling methods:</p>&#13;
&#13;
<pre data-code-language="pycon" data-type="programlisting"><code class="gp">&gt;&gt;&gt; </code><code class="kn">import</code> <code class="nn">asyncio</code>&#13;
<code class="go">&gt;&gt;&gt;</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">async</code> <code class="k">def</code> <code class="nf">wicked</code><code class="p">():</code>&#13;
<code class="gp">... </code>    <code class="k">print</code><code class="p">(</code><code class="s">"Surrender,"</code><code class="p">)</code>&#13;
<code class="gp">... </code>    <code class="n">await</code> <code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code>&#13;
<code class="gp">... </code>    <code class="k">print</code><code class="p">(</code><code class="s">"Dorothy!"</code><code class="p">)</code>&#13;
<code class="gp">...</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">asyncio</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="n">wicked</code><code class="p">())</code>&#13;
<code class="go">Surrender,</code>&#13;
<code class="go">Dorothy!</code></pre>&#13;
&#13;
<p>These was a dramatic two-second wait in there&#13;
that you can’t see on&#13;
a printed page.&#13;
To prove that we didn’t cheat&#13;
(see <a data-type="xref" href="ch19.html#ch_pythonista">Chapter 19</a> for&#13;
<code>timeit</code> details):</p>&#13;
&#13;
<pre data-code-language="pycon" data-type="programlisting"><code class="gp">&gt;&gt;&gt; </code><code class="kn">from</code> <code class="nn">timeit</code> <code class="kn">import</code> <code class="n">timeit</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">timeit</code><code class="p">(</code><code class="s">"asyncio.run(wicked())"</code><code class="p">,</code> <code class="nb">globals</code><code class="o">=</code><code class="nb">globals</code><code class="p">(),</code> <code class="n">number</code><code class="o">=</code><code class="mi">1</code><code class="p">)</code>&#13;
<code class="go">Surrender,</code>&#13;
<code class="go">Dorothy!</code>&#13;
<code class="go">2.005701574998966</code></pre>&#13;
&#13;
<p>That <code>asyncio.sleep(2)</code> call was itself a coroutine,&#13;
just an example here to fake something time consuming&#13;
like an API call.</p>&#13;
&#13;
<p>The line <code>asyncio.run(wicked())</code> is a way of running&#13;
a coroutine from synchronous Python code&#13;
(here, the top level of the program).</p>&#13;
&#13;
<p>The difference from a standard synchronous counterpart&#13;
(using <code>time.sleep()</code>) is that the caller of <code>wicked()</code>&#13;
is not blocked for two seconds while it runs.</p>&#13;
&#13;
<p>The third way to run a coroutine is to create a <em>task</em>&#13;
and <code>await</code> it.&#13;
This example shows the task approach along with the&#13;
previous two methods:</p>&#13;
&#13;
<pre data-code-language="pycon" data-type="programlisting"><code class="gp">&gt;&gt;&gt; </code><code class="kn">import</code> <code class="nn">asyncio</code>&#13;
<code class="go">&gt;&gt;&gt;</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">async</code> <code class="k">def</code> <code class="nf">say</code><code class="p">(</code><code class="n">phrase</code><code class="p">,</code> <code class="n">seconds</code><code class="p">):</code>&#13;
<code class="gp">... </code>    <code class="k">print</code><code class="p">(</code><code class="n">phrase</code><code class="p">)</code>&#13;
<code class="gp">... </code>    <code class="n">await</code> <code class="n">asyncio</code><code class="o">.</code><code class="n">sleep</code><code class="p">(</code><code class="n">seconds</code><code class="p">)</code>&#13;
<code class="gp">...</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">async</code> <code class="k">def</code> <code class="nf">wicked</code><code class="p">():</code>&#13;
<code class="gp">... </code>    <code class="n">task_1</code> <code class="o">=</code> <code class="n">asyncio</code><code class="o">.</code><code class="n">create_task</code><code class="p">(</code><code class="n">say</code><code class="p">(</code><code class="s">"Surrender,"</code><code class="p">,</code> <code class="mi">2</code><code class="p">))</code>&#13;
<code class="gp">... </code>    <code class="n">task_2</code> <code class="o">=</code> <code class="n">asyncio</code><code class="o">.</code><code class="n">create_task</code><code class="p">(</code><code class="n">say</code><code class="p">(</code><code class="s">"Dorothy!"</code><code class="p">,</code> <code class="mi">0</code><code class="p">))</code>&#13;
<code class="gp">... </code>    <code class="n">await</code> <code class="n">task_1</code>&#13;
<code class="gp">... </code>    <code class="n">await</code> <code class="n">task_2</code>&#13;
<code class="gp">...</code>&#13;
<code class="gp">&gt;&gt;&gt; </code><code class="n">asyncio</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="n">wicked</code><code class="p">())</code>&#13;
<code class="go">Surrender,</code>&#13;
<code class="go">Dorothy!</code></pre>&#13;
&#13;
<p>If you run this, you’ll see that there was no delay between&#13;
the two lines printing this time.&#13;
That’s because they were separate tasks.&#13;
<code>task_1</code> paused two seconds after printing <code>Surrender</code>,&#13;
but that didn’t affect <code>task_2</code>.</p>&#13;
&#13;
<p>An <code>await</code> is similar to a <code>yield</code> in a generator,&#13;
but rather than returning a value,&#13;
it marks a spot where the event loop can pause it&#13;
if needed.</p>&#13;
&#13;
<p>There’s lots more where this came from in the&#13;
<a href="https://oreil.ly/Cf_hd">docs</a>.&#13;
Synchronous and asynchronous code can coexist in the&#13;
same program.&#13;
Just remember to put <code>async</code> before the <code>def</code> and&#13;
<code>await</code> before the call of your asynchronous function.</p>&#13;
&#13;
<p>Some more information:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A <a href="https://oreil.ly/Vj0yD">list</a> of <code>asyncio</code> links.</p>&#13;
</li>&#13;
<li>&#13;
<p>Code for an <code>asyncio</code> <a href="https://oreil.ly/n4FVx">web crawler</a>.<a data-startref="ix_appC-async-asciidoc4" data-type="indexterm" id="idm45794959217160"/><a data-startref="ix_appC-async-asciidoc3" data-type="indexterm" id="idm45794959216424"/><a data-startref="ix_appC-async-asciidoc2" data-type="indexterm" id="idm45794959215752"/><a data-startref="ix_appC-async-asciidoc1" data-type="indexterm" id="idm45794959215080"/></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before less_space" data-pdf-bookmark="Asyncio Alternatives" data-type="sect1"><div class="sect1" id="idm45794959471752">&#13;
<h1>Asyncio Alternatives</h1>&#13;
&#13;
<p><a data-primary="asynchronous tasks" data-secondary="asyncio alternatives" data-type="indexterm" id="ix_appC-async-asciidoc5"/><a data-primary="asyncio library" data-secondary="alternatives to" data-type="indexterm" id="ix_appC-async-asciidoc6"/>Although <code>asyncio</code> is a standard Python package,&#13;
you can use <code>async</code> and <code>await</code> without it.&#13;
Coroutines and the event loop are independent.&#13;
The design of <code>asyncio</code> is sometimes&#13;
<a href="https://oreil.ly/n4FVx">criticized</a>,&#13;
and third-party alternatives have appeared:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://curio.readthedocs.io"><code>curio</code></a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://trio.readthedocs.io"><code>trio</code></a></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Let’s show a real example&#13;
using <code>trio</code> and&#13;
<a href="https://asks.readthedocs.io"><code>asks</code></a>&#13;
(an async web framework, modeled on the <code>requests</code> API).&#13;
<a data-type="xref" href="#exC1">Example C-1</a> shows a concurrent web-crawling&#13;
example using <code>trio</code> and <code>asks</code>,&#13;
adapted from a stackoverflow&#13;
<a href="https://oreil.ly/CbINS">answer</a>.&#13;
To run this, first <code>pip install</code> both <code>trio</code> and <code>asks</code>.</p>&#13;
<div data-type="example" id="exC1">&#13;
<h5><span class="label">Example C-1. </span>trio_asks_sites.py</h5>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="kn">import</code> <code class="nn">time</code>&#13;
&#13;
<code class="kn">import</code> <code class="nn">asks</code>&#13;
<code class="kn">import</code> <code class="nn">trio</code>&#13;
&#13;
<code class="n">asks</code><code class="o">.</code><code class="n">init</code><code class="p">(</code><code class="s2">"trio"</code><code class="p">)</code>&#13;
&#13;
<code class="n">urls</code> <code class="o">=</code> <code class="p">[</code>&#13;
    <code class="s1">'https://boredomtherapy.com/bad-taxidermy/'</code><code class="p">,</code>&#13;
    <code class="s1">'http://www.badtaxidermy.com/'</code><code class="p">,</code>&#13;
    <code class="s1">'https://crappytaxidermy.com/'</code><code class="p">,</code>&#13;
    <code class="s1">'https://www.ranker.com/list/bad-taxidermy-pictures/ashley-reign'</code><code class="p">,</code>&#13;
<code class="p">]</code>&#13;
&#13;
<code class="n">async</code> <code class="k">def</code> <code class="nf">get_one</code><code class="p">(</code><code class="n">url</code><code class="p">,</code> <code class="n">t1</code><code class="p">):</code>&#13;
    <code class="n">r</code> <code class="o">=</code> <code class="n">await</code> <code class="n">asks</code><code class="o">.</code><code class="n">get</code><code class="p">(</code><code class="n">url</code><code class="p">)</code>&#13;
    <code class="n">t2</code> <code class="o">=</code> <code class="n">time</code><code class="o">.</code><code class="n">time</code><code class="p">()</code>&#13;
    <code class="k">print</code><code class="p">(</code><code class="n">f</code><code class="s2">"{(t2-t1):.04}</code><code class="se">\t</code><code class="s2">{len(r.content)}</code><code class="se">\t</code><code class="s2">{url}"</code><code class="p">)</code>&#13;
&#13;
<code class="n">async</code> <code class="k">def</code> <code class="nf">get_sites</code><code class="p">(</code><code class="n">sites</code><code class="p">):</code>&#13;
    <code class="n">t1</code> <code class="o">=</code> <code class="n">time</code><code class="o">.</code><code class="n">time</code><code class="p">()</code>&#13;
    <code class="n">async</code> <code class="k">with</code> <code class="n">trio</code><code class="o">.</code><code class="n">open_nursery</code><code class="p">()</code> <code class="k">as</code> <code class="n">nursery</code><code class="p">:</code>&#13;
        <code class="k">for</code> <code class="n">url</code> <code class="ow">in</code> <code class="n">sites</code><code class="p">:</code>&#13;
            <code class="n">nursery</code><code class="o">.</code><code class="n">start_soon</code><code class="p">(</code><code class="n">get_one</code><code class="p">,</code> <code class="n">url</code><code class="p">,</code> <code class="n">t1</code><code class="p">)</code>&#13;
&#13;
<code class="k">if</code> <code class="nv-Magic">__name__</code> <code class="o">==</code> <code class="s2">"__main__"</code><code class="p">:</code>&#13;
    <code class="k">print</code><code class="p">(</code><code class="s2">"seconds</code><code class="se">\t</code><code class="s2">bytes</code><code class="se">\t</code><code class="s2">url"</code><code class="p">)</code>&#13;
    <code class="n">trio</code><code class="o">.</code><code class="n">run</code><code class="p">(</code><code class="n">get_sites</code><code class="p">,</code> <code class="n">urls</code><code class="p">)</code></pre></div>&#13;
&#13;
<p class="pagebreak-before">Here’s what I got:</p>&#13;
<pre>$ <strong>python trio_asks_sites.py</strong>&#13;
seconds bytes   url&#13;
0.1287  5735    https://boredomtherapy.com/bad-taxidermy/&#13;
0.2134  146082  https://www.ranker.com/list/bad-taxidermy-pictures/ashley-reign&#13;
0.215   11029   http://www.badtaxidermy.com/&#13;
0.3813  52385   https://crappytaxidermy.com/</pre>&#13;
&#13;
<p>You’ll notice that <code>trio</code> did not use <code>asyncio.run()</code>,&#13;
but instead its own <code>trio.open_nursery()</code>.&#13;
If you’re curious,&#13;
you can read an&#13;
<a href="https://oreil.ly/yp1-r">essay</a>&#13;
and&#13;
<a href="https://oreil.ly/P21Ra">discussion</a>&#13;
of the design decisions behind <code>trio</code>.</p>&#13;
&#13;
<p>A new package called&#13;
<a href="https://anyio.readthedocs.io/en/latest"><code>AnyIO</code></a>&#13;
provides a single interface to&#13;
<code>asyncio</code>, <code>curio</code>, and <code>trio</code>.</p>&#13;
&#13;
<p>In the future, you can expect more async approaches,&#13;
both in standard Python and from third-party developers.<a data-startref="ix_appC-async-asciidoc6" data-type="indexterm" id="idm45794959027336"/><a data-startref="ix_appC-async-asciidoc5" data-type="indexterm" id="idm45794959026632"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Async Versus…" data-type="sect1"><div class="sect1" id="async_versus">&#13;
<h1>Async Versus…</h1>&#13;
&#13;
<p><a data-primary="asynchronous tasks" data-secondary="versus other approaches" data-type="indexterm" id="idm45794959024344"/><a data-primary="concurrency" data-secondary="asynchronous versus other approaches" data-type="indexterm" id="idm45794959023368"/>As you’ve seen in many places in this book,&#13;
there are many techniques for concurrency.&#13;
How does the async stuff compare with them?</p>&#13;
<dl>&#13;
<dt>Processes</dt>&#13;
<dd>&#13;
<p>This is a good solution if you want to use all the CPU&#13;
cores on your machine, or multiple machines.&#13;
But processes are heavy,&#13;
take a while to start,&#13;
and require serialization for interprocess communication.</p>&#13;
</dd>&#13;
<dt>Threads</dt>&#13;
<dd>&#13;
<p>Although threads were designed as a “lightweight”&#13;
alternative to processes, each thread uses&#13;
a good chunk of memory.&#13;
Coroutines are much lighter than threads;&#13;
you can create hundreds of thousands of coroutines&#13;
on a machine that might only support a few thousand threads.</p>&#13;
</dd>&#13;
<dt>Green threads</dt>&#13;
<dd>&#13;
<p>Green threads like <code>gevent</code> work well and look&#13;
like synchronous code, but they require&#13;
<em>monkey-patching</em> standard Python functions, such as&#13;
socket libraries.</p>&#13;
</dd>&#13;
<dt>Callbacks</dt>&#13;
<dd>&#13;
<p>Libraries like <code>twisted</code> rely on <em>callbacks</em>: functions&#13;
that are called when when certain events occur.&#13;
This is familiar to GUI and JavaScript programmers.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Queues—These tend to be a large-scale solution,&#13;
when your data or processes really need more than one machine.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Async Frameworks and Servers" data-type="sect1"><div class="sect1" id="idm45794959013192">&#13;
<h1>Async Frameworks and Servers</h1>&#13;
&#13;
<p><a data-primary="asynchronous tasks" data-secondary="frameworks and servers" data-type="indexterm" id="idm45794959011784"/>The async additions to Python are recent,&#13;
and it’s taking time for developers to create&#13;
async versions of frameworks like Flask.</p>&#13;
&#13;
<p>The&#13;
<a href="https://asgi.readthedocs.io">ASGI</a>&#13;
standard is an async version of WSGI,&#13;
discussed further&#13;
<a href="https://oreil.ly/BnEXT">here</a>.</p>&#13;
&#13;
<p>Here are some ASGI web servers:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://pgjones.gitlab.io/hypercorn"><code>hypercorn</code></a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://sanic.readthedocs.io"><code>sanic</code></a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://www.uvicorn.org"><code>uvicorn</code></a></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>And some async web frameworks:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://aiohttp.readthedocs.io"><code>aiohttp</code></a>—Client <em>and</em> server</p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://pythonhosted.org/api_hour"><code>api_hour</code></a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://asks.readthedocs.io"><code>asks</code></a>—Like <code>requests</code></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://github.com/RobertoPrevato/BlackSheep"><code>blacksheep</code></a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://github.com/bocadilloproject/bocadillo"><code>bocadillo</code></a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://channels.readthedocs.io"><code>channels</code></a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://fastapi.tiangolo.com"><code>fastapi</code></a>—Uses type annotations</p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://muffin.readthedocs.io"><code>muffin</code></a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://gitlab.com/pgjones/quart"><code>quart</code></a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://python-responder.org"><code>responder</code></a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://sanic.readthedocs.io"><code>sanic</code></a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://www.starlette.io"><code>starlette</code></a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://www.tornadoweb.org"><code>tornado</code></a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://vibora.io"><code>vibora</code></a></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Finally, some async database interfaces:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://aiomysql.readthedocs.io"><code>aiomysql</code></a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://aioredis.readthedocs.io"><code>aioredis</code></a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://github.com/magicstack/asyncpg"><code>asyncpg</code></a><a data-startref="ix_appC-async-asciidoc0" data-type="indexterm" id="idm45794958976120"/></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>