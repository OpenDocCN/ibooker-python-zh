<html><head></head><body>
<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Constraining Types" class="preface"><div class="preface" id="constraints">
<h1 class="calibre10" id="calibre_pb_0"><span class="calibre">Chapter 4. </span>Constraining Types</h1>


<p class="author1">Many developers learn the basic type annotations and call it a day. But we’re far from done.<a data-type="indexterm" data-primary="constraining types" id="ix_constyp" class="calibre5"/> There is a wealth of advanced type annotations that are invaluable. These advanced type annotations allow you to constrain types, further restricting what they can represent. Your goal is to make illegal states unrepresentable. Developers should physically not be able to create types that are contradictory or otherwise invalid in your system.<a data-type="indexterm" data-primary="types" data-secondary="constraining" data-see="constraining types" id="idm45644755868632" class="calibre5"/><a data-type="indexterm" data-primary="type annotations" data-seealso="constraining types" id="idm45644755867416" class="calibre5"/> You can’t have errors in your code if it’s impossible to create the error in the first place. You can use type annotations to achieve this very goal, saving time and money. In this chapter I’ll teach you six different techniques:</p>
<dl class="calibre13">
<dt class="calibre14"><code class="calibre17">Optional</code></dt>
<dd class="calibre15">
<p class="calibre16">Use to replace <code class="calibre17">None</code> references in your codebase.</p>
</dd>
<dt class="calibre14"><code class="calibre17">Union</code></dt>
<dd class="calibre15">
<p class="calibre16">Use to present a selection of types.</p>
</dd>
<dt class="calibre14"><code class="calibre17">Literal</code></dt>
<dd class="calibre15">
<p class="calibre16">Use to restrict developers to very specific values.</p>
</dd>
<dt class="calibre14"><code class="calibre17">Annotated</code></dt>
<dd class="calibre15">
<p class="calibre16">Use to provide additional description of your types.</p>
</dd>
<dt class="calibre14"><code class="calibre17">NewType</code></dt>
<dd class="calibre15">
<p class="calibre16">Use to restrict a type to a specific context.</p>
</dd>
<dt class="calibre14"><code class="calibre17">Final</code></dt>
<dd class="calibre15">
<p class="calibre16">Use to prevent variables from being rebound to a new value.</p>
</dd>
</dl>

<p class="author1">Let’s start with handling <code class="calibre17">None</code> references with <code class="calibre17">Optional</code> types.</p>






</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Constraining Types" class="preface">
<div class="preface" id="constraints">
<section data-type="sect1" data-pdf-bookmark="Optional Type" class="preface"><div class="preface" id="idm45644755854968">
<h1 class="calibre12" id="calibre_pb_1">Optional Type</h1>

<p class="author1">Null references are often<a data-type="indexterm" data-primary="constraining types" data-secondary="Optional types" id="ix_constypOpt" class="calibre5"/><a data-type="indexterm" data-primary="Optional types" id="ix_Optty" class="calibre5"/><a data-type="indexterm" data-primary="null references" id="idm45644755822808" class="calibre5"/><a data-type="indexterm" data-primary="“billion-dollar mistake”" data-primary-sortas="billion" id="idm45644755822136" class="calibre5"/><a data-type="indexterm" data-primary="Hoare, C.A.R." id="idm45644755821128" class="calibre5"/> referred to as the “billion-dollar mistake,” coined by C.A.R. Hoare:</p>
<blockquote class="pcalibre2 calibre28 pcalibre1">
<p class="calibre29">I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language. My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn’t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.<sup class="calibre11"><a data-type="noteref" id="idm45644755819000-marker" href="part0007_split_009.html#idm45644755819000" class="calibre5">1</a></sup></p></blockquote>

<p class="author1">While null references started in Algol, they would pervade countless other languages. C and C++ are often derided for null pointer dereference (which produces a segmentation fault or other program-halting crash). Java was well-known for requiring the user to catch <code class="calibre17">NullPointerException</code> throughout their code. It’s not a stretch to say that these sorts of bugs have a price tag measured in the billions. Think of the developer time, customer loss, and system failures due to accidental null pointers or <span class="calibre">references</span>.</p>

<p class="author1">So, why does this matter in Python? Hoare’s quote is about object-oriented compiled languages back in the 60s; Python must be better by now, right?<a data-type="indexterm" data-primary="None values" id="ix_None" class="calibre5"/> I regret to inform you that this billion-dollar mistake is in Python as well. It appears to us under a different name: <code class="calibre17">None</code>. I will show you a way to avoid the costly <code class="calibre17">None</code> mistake, but first, let’s talk about why <code class="calibre17">None</code> is so bad.</p>
<div data-type="note" epub:type="note" class="calibre21"><h6 class="calibre22">Note</h6>
<p class="author1">It is especially illuminating that Hoare admits that null references were born out of convenience. It goes to show you how taking the quicker path can lead to all sorts of pain later in your development life cycle. Think how your short-term decisions today will adversely affect your maintenance tomorrow.</p>
</div>

<p class="author1">Let’s consider some code that runs an automated hot dog stand. I want my system to take a bun, put a frank in the bun, and then squirt ketchup and mustard through automated dispensers, as described in <a data-type="xref" href="part0007_split_001.html#figure_4_1" class="calibre5">Figure 4-1</a>. What could go wrong?</p>

<figure class="calibre36"><div id="figure_4_1" class="figure">
<img src="../images/00004.gif" alt="Worfklow for the automated hotdog stand" class="calibre40"/>
<h6 class="calibre37"><span class="calibre">Figure 4-1. </span>Workflow for the automated hot dog stand</h6>
</div></figure>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">create_hot_dog</code><code class="calibre17">():</code>
    <code class="n">bun</code> <code class="calibre17">=</code> <code class="n">dispense_bun</code><code class="calibre17">()</code>
    <code class="n">frank</code> <code class="calibre17">=</code> <code class="n">dispense_frank</code><code class="calibre17">()</code>
    <code class="n">hot_dog</code> <code class="calibre17">=</code> <code class="n">bun</code><code class="calibre17">.</code><code class="n">add_frank</code><code class="calibre17">(</code><code class="n">frank</code><code class="calibre17">)</code>
    <code class="n">ketchup</code> <code class="calibre17">=</code> <code class="n">dispense_ketchup</code><code class="calibre17">()</code>
    <code class="n">mustard</code> <code class="calibre17">=</code> <code class="n">dispense_mustard</code><code class="calibre17">()</code>
    <code class="n">hot_dog</code><code class="calibre17">.</code><code class="n">add_condiments</code><code class="calibre17">(</code><code class="n">ketchup</code><code class="calibre17">,</code> <code class="n">mustard</code><code class="calibre17">)</code>
    <code class="n">dispense_hot_dog_to_customer</code><code class="calibre17">(</code><code class="n">hot_dog</code><code class="calibre17">)</code></pre>

<p class="author1">Pretty straightforward, no? Unfortunately, there’s no way to really tell. It’s easy to think through the happy path, or the control flow of the program when everything goes right, but when talking about robust code, you need to consider error conditions. If this were an automated stand with no manual intervention, what errors can you think of?</p>

<p class="author1">Here’s a noncomprehensive list of errors I can think of:</p>

<ul class="printings">
<li class="calibre9">
<p class="author1">Out of ingredients (buns, hot dogs, or ketchup/mustard).</p>
</li>
<li class="calibre9">
<p class="author1">Order cancelled midprocess.</p>
</li>
<li class="calibre9">
<p class="author1">Condiments get jammed.</p>
</li>
<li class="calibre9">
<p class="author1">Power is interrupted.</p>
</li>
<li class="calibre9">
<p class="author1">Customer doesn’t want ketchup or mustard and tries to move the bun <span class="calibre">midprocess</span>.</p>
</li>
<li class="calibre9">
<p class="author1">Rival vendor switches the ketchup out with catsup; chaos ensues.</p>
</li>
</ul>

<p class="author1">Now, your system is state of the art and will detect all of these conditions, but it does so by returning <code class="calibre17">None</code> when any one step fails. What does this mean for this code? You start seeing errors like the following:</p>
<pre class="calibre35">Traceback (most recent call last):
 File "&lt;stdin&gt;", line 4, in &lt;module&gt;
AttributeError: 'NoneType' object has no attribute 'add_frank'

Traceback (most recent call last):
 File "&lt;stdin&gt;", line 7, in &lt;module&gt;
AttributeError: 'NoneType' object has no attribute 'add_condiments'</pre>

<p class="author1">It would be catastrophic if these errors bubbled up to your customers; you pride yourself on a clean UI and don’t want ugly tracebacks defiling your interface. To address this, you start to code <em class="calibre6">defensively</em>, or coding in such a way that you try to foresee every possible error case and account for it. Defensive programming is a good thing, but it leads to code like this:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">create_hot_dog</code><code class="calibre17">():</code>
    <code class="n">bun</code> <code class="calibre17">=</code> <code class="n">dispense_bun</code><code class="calibre17">()</code>
    <code class="k">if</code> <code class="n">bun</code> <code class="calibre19">is</code> <code class="nb">None</code><code class="calibre17">:</code>
        <code class="n">print_error_code</code><code class="calibre17">(</code><code class="s">"Bun unavailable. Check for bun"</code><code class="calibre17">)</code>
        <code class="k">return</code>

    <code class="n">frank</code> <code class="calibre17">=</code> <code class="n">dispense_frank</code><code class="calibre17">()</code>
    <code class="k">if</code> <code class="n">frank</code> <code class="calibre19">is</code> <code class="nb">None</code><code class="calibre17">:</code>
        <code class="n">print_error_code</code><code class="calibre17">(</code><code class="s">"Frank was not properly dispensed"</code><code class="calibre17">)</code>
        <code class="k">return</code>

    <code class="n">hot_dog</code> <code class="calibre17">=</code> <code class="n">bun</code><code class="calibre17">.</code><code class="n">add_frank</code><code class="calibre17">(</code><code class="n">frank</code><code class="calibre17">)</code>
    <code class="k">if</code> <code class="n">hot_dog</code> <code class="calibre19">is</code> <code class="nb">None</code><code class="calibre17">:</code>
        <code class="n">print_error_code</code><code class="calibre17">(</code><code class="s">"Hot Dog unavailable. Check for Hot Dog"</code><code class="calibre17">)</code>
        <code class="k">return</code>

    <code class="n">ketchup</code> <code class="calibre17">=</code> <code class="n">dispense_ketchup</code><code class="calibre17">()</code>
    <code class="n">mustard</code> <code class="calibre17">=</code> <code class="n">dispense_mustard</code><code class="calibre17">()</code>
    <code class="k">if</code> <code class="n">ketchup</code> <code class="calibre19">is</code> <code class="nb">None</code> <code class="calibre19">or</code> <code class="n">mustard</code> <code class="calibre19">is</code> <code class="nb">None</code><code class="calibre17">:</code>
        <code class="n">print_error_code</code><code class="calibre17">(</code><code class="s">"Check for invalid catsup"</code><code class="calibre17">)</code>
        <code class="k">return</code>

    <code class="n">hot_dog</code><code class="calibre17">.</code><code class="n">add_condiments</code><code class="calibre17">(</code><code class="n">ketchup</code><code class="calibre17">,</code> <code class="n">mustard</code><code class="calibre17">)</code>
    <code class="n">dispense_hot_dog_to_customer</code><code class="calibre17">(</code><code class="n">hot_dog</code><code class="calibre17">)</code></pre>

<p class="author1">This feels, well, tedious. Because any value can be <code class="calibre17">None</code> in Python, it seems like you need to engage in defensive programming and do an <code class="calibre17">is None</code> check before every dereference. This is overkill; most developers will trace through the call stack and ensure that no <code class="calibre17">None</code> values are returned to the caller. That leaves calls to external systems and maybe a scant few calls in your codebase that you always have to wrap with <code class="calibre17">None</code> checking. This is error prone; you cannot expect every developer who ever touches your codebase to know instinctively where to check for <code class="calibre17">None</code>. Furthermore, the original assumptions you’ve made when writing (e.g., this function will never return <code class="calibre17">None</code>) can be broken in the future, and now your code has a bug. And herein lies your problem: counting on manual intervention to catch error cases is unreliable.</p>
<aside data-type="sidebar" epub:type="sidebar" class="calibre32"><div class="sidebar" id="idm45644755613928">
<h5 class="calibre33">Exceptions</h5>
<p class="author1">A valiant attempt at solving the billion-dollar problem is exceptions.<a data-type="indexterm" data-primary="exceptions" id="idm45644755612712" class="calibre5"/> Anytime something goes wrong in your system, throw an exception! When an exception is thrown, that function stops executing and the exception gets passed up the call chain, until either a) some code catches it in an appropriate except block, or b) nobody catches it and it terminates the program. This will not help your robustness problems. You still rely on manual intervention to catch errors (by someone writing an appropriate <code class="calibre17">except</code> block). If that manual intervention isn’t applied, the program crashes and the user will have a bad time.</p>

<p class="author1">This should not come as a surprise; dereferencing <code class="calibre17">None</code> values throws an exception, so it’s the exact same behavior. In order to be able to detect exceptions through static analysis, you typically need support in the language for checked exceptions: exceptions that are part of your type signature that tell your static analysis tools what exceptions to expect.<a data-type="indexterm" data-primary="exceptions" data-secondary="checked, Python and" id="idm45644755609816" class="calibre5"/> Python does not support any sort of checked exception at the time of this writing and I am doubtful it ever will, due to the verbosity and viral nature of checked exceptions.</p>

<p class="author1">This isn’t to say don’t use exceptions. Use them for exceptional use cases that you don’t expect to happen, but still wish to guard against, such as the network going down.  Don’t use exceptions for normal behavior, such as not finding an element when searching through a list. Remember, the return value can be enforced through typing, but exceptions cannot.</p>
</div></aside>

<p class="author1">The reason this is so tricky (and so costly) is that <code class="calibre17">None</code> is treated as a special case. It exists outside the normal type hierarchy. Every variable can be assigned to <code class="calibre17">None</code>. In order to combat this, you need to find a way of representing <code class="calibre17">None</code> inside your type hierarchy. You need <code class="calibre17">Optional</code> types.</p>

<p class="author1"><code class="calibre17">Optional</code> types offer you two choices: either you have a value or you don’t. In other words, it is optional to set the variable to a value.</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">typing</code> <code class="k">import</code> <code class="n">Optional</code>
<code class="n">maybe_a_string</code><code class="calibre17">:</code> <code class="n">Optional</code><code class="calibre17">[</code><code class="nb">str</code><code class="calibre17">]</code> <code class="calibre17">=</code> <code class="s">"abcdef"</code> <code class="c"># This has a value</code>
<code class="n">maybe_a_string</code><code class="calibre17">:</code> <code class="n">Optional</code><code class="calibre17">[</code><code class="nb">str</code><code class="calibre17">]</code> <code class="calibre17">=</code> <code class="nb">None</code>     <code class="c"># This is the absence of a value</code></pre>

<p class="author1">This code indicates that the variable <code class="calibre17">maybe_a_string</code> may optionally contain a string. That code typechecks just fine, whether <code class="calibre17">maybe_a_string</code> contains <code class="calibre17">"abcdef"</code> or <code class="calibre17">None</code>.</p>

<p class="author1">At first glance, it’s not apparent what this buys you. You still need to use <code class="calibre17">None</code> to represent the absence of a value. I have good news for you, though. There are three benefits I associate with <code class="calibre17">Optional</code> types.</p>

<p class="author1">First, you communicate your intent more clearly.<a data-type="indexterm" data-primary="intent" data-secondary="communicating with Optional types" id="idm45644755576872" class="calibre5"/><a data-type="indexterm" data-primary="None values" data-secondary="Optional type and" id="idm45644755575928" class="calibre5"/> If a developer sees an <code class="calibre17">Optional</code> type in a type signature, they view that as a big red flag that they should expect <code class="calibre17">None</code> as a possibility.</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">dispense_bun</code><code class="calibre17">()</code> <code class="calibre17">-&gt;</code> <code class="n">Optional</code><code class="calibre17">[</code><code class="n">Bun</code><code class="calibre17">]:</code>
<code class="c"># ...</code></pre>

<p class="author1">If you notice a function returning an <code class="calibre17">Optional</code> value, take heed and check for <code class="calibre17">None</code> values.</p>

<p class="author1">Second, you are able to further distinguish the absence of value from an empty value.<a data-type="indexterm" data-primary="empty value versus absence of value" id="idm45644755567528" class="calibre5"/> Consider the innocuous list. What happens if you make a function call and receive an empty list? Was it just that no results were provided back to you? Or was it that an error occurred and you need to take explicit action? If you are receiving a raw list, you don’t know without trawling through source code. However, if you use an <code class="calibre17">Optional</code>, you are conveying one of three possibilities:</p>
<dl class="calibre13">
<dt class="calibre14">A list with elements</dt>
<dd class="calibre15">
<p class="calibre16">Valid data to be operated on</p>
</dd>
<dt class="calibre14">A list with no elements</dt>
<dd class="calibre15">
<p class="calibre16">No error occurred, but no data was available (provided that no data is not an error condition)</p>
</dd>
<dt class="calibre14"><code class="calibre17">None</code></dt>
<dd class="calibre15">
<p class="calibre16">An error occurred that you need to handle</p>
</dd>
</dl>

<p class="author1">Finally, typecheckers can detect <code class="calibre17">Optional</code> types and make<a data-type="indexterm" data-primary="typecheckers" data-secondary="detection of Optional values and checking for None" id="idm45644755560440" class="calibre5"/> sure that you aren’t letting <code class="calibre17">None</code> values slip through.</p>

<p class="author1">Consider:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">dispense_bun</code><code class="calibre17">()</code> <code class="calibre17">-&gt;</code> <code class="n">Bun</code><code class="calibre17">:</code>
    <code class="k">return</code> <code class="n">Bun</code><code class="calibre17">(</code><code class="s">'Wheat'</code><code class="calibre17">)</code></pre>

<p class="author1">Let’s add some error cases to this code:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">dispense_bun</code><code class="calibre17">()</code> <code class="calibre17">-&gt;</code> <code class="n">Bun</code><code class="calibre17">:</code>
    <code class="k">if</code> <code class="calibre19">not</code> <code class="n">are_buns_available</code><code class="calibre17">():</code>
        <code class="k">return</code> <code class="nb">None</code>
    <code class="k">return</code> <code class="n">Bun</code><code class="calibre17">(</code><code class="s">'Wheat'</code><code class="calibre17">)</code></pre>

<p class="author1">When run with a typechecker, you get the following error:</p>
<pre class="calibre35">code_examples/chapter4/invalid/dispense_bun.py:12:
    error: Incompatible return value type (got "None", expected "Bun")</pre>

<p class="author1">Excellent! The typechecker will not allow you to return a <code class="calibre17">None</code> value by default. By changing the return type from <code class="calibre17">Bun</code> to <code class="calibre17">Optional[Bun]</code>, the code will typecheck successfully. This will give developers hints that they should not return <code class="calibre17">None</code> without encoding information in the return type. You can catch a common mistake and make this code more robust. But what about the calling code?</p>

<p class="author1">It turns out that the calling code benefits from this as well. Consider:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">create_hot_dog</code><code class="calibre17">():</code>
    <code class="n">bun</code> <code class="calibre17">=</code> <code class="n">dispense_bun</code><code class="calibre17">()</code>
    <code class="n">frank</code> <code class="calibre17">=</code> <code class="n">dispense_frank</code><code class="calibre17">()</code>
    <code class="n">hot_dog</code> <code class="calibre17">=</code> <code class="n">bun</code><code class="calibre17">.</code><code class="n">add_frank</code><code class="calibre17">(</code><code class="n">frank</code><code class="calibre17">)</code>
    <code class="n">ketchup</code> <code class="calibre17">=</code> <code class="n">dispense_ketchup</code><code class="calibre17">()</code>
    <code class="n">mustard</code> <code class="calibre17">=</code> <code class="n">dispense_mustard</code><code class="calibre17">()</code>
    <code class="n">hot_dog</code><code class="calibre17">.</code><code class="n">add_condiments</code><code class="calibre17">(</code><code class="n">ketchup</code><code class="calibre17">,</code> <code class="n">mustard</code><code class="calibre17">)</code>
    <code class="n">dispense_hot_dog_to_customer</code><code class="calibre17">(</code><code class="n">hot_dog</code><code class="calibre17">)</code></pre>

<p class="author1">If <code class="calibre17">dispense_bun</code> returns an <code class="calibre17">Optional</code>, this code will not typecheck. It will complain with the following error:</p>
<pre class="calibre35">code_examples/chapter4/invalid/hotdog_invalid.py:27:
    error: Item "None" of "Optional[Bun]" has no attribute "add_frank"</pre>
<div data-type="warning" epub:type="warning" class="calibre23"><h6 class="calibre24">Warning</h6>
<p class="author1">Depending on your typechecker, you may need to specifically enable an option to catch these sorts of errors. Always look through your typechecker’s documentation to learn what options are available. If there is an error you absolutely want to catch, you should test that your typechecker does indeed catch the error. I highly recommend testing out <code class="calibre17">Optional</code> behavior specifically.<a data-type="indexterm" data-primary="mypy typechecker" data-secondary="--strict-optional command-line flag" id="idm45644755353720" class="calibre5"/> For the version of <code class="calibre17">mypy</code> I am running (0.800), I have to use <code class="calibre17">--strict-optional</code> as a command-line flag to catch this error.</p>
</div>

<p class="author1">If you are interested in silencing the typechecker, you need to check for <code class="calibre17">None</code> explicitly and handle the <code class="calibre17">None</code> value, or assert that the value cannot be <code class="calibre17">None</code>. The following code typechecks successfully:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">create_hot_dog</code><code class="calibre17">():</code>
    <code class="n">bun</code> <code class="calibre17">=</code> <code class="n">dispense_bun</code><code class="calibre17">()</code>
    <code class="k">if</code> <code class="n">bun</code> <code class="calibre19">is</code> <code class="nb">None</code><code class="calibre17">:</code>
        <code class="n">print_error_code</code><code class="calibre17">(</code><code class="s">"Bun could not be dispensed"</code><code class="calibre17">)</code>
        <code class="k">return</code>

    <code class="n">frank</code> <code class="calibre17">=</code> <code class="n">dispense_frank</code><code class="calibre17">()</code>
    <code class="n">hot_dog</code> <code class="calibre17">=</code> <code class="n">bun</code><code class="calibre17">.</code><code class="n">add_frank</code><code class="calibre17">(</code><code class="n">frank</code><code class="calibre17">)</code>
    <code class="n">ketchup</code> <code class="calibre17">=</code> <code class="n">dispense_ketchup</code><code class="calibre17">()</code>
    <code class="n">mustard</code> <code class="calibre17">=</code> <code class="n">dispense_mustard</code><code class="calibre17">()</code>
    <code class="n">hot_dog</code><code class="calibre17">.</code><code class="n">add_condiments</code><code class="calibre17">(</code><code class="n">ketchup</code><code class="calibre17">,</code> <code class="n">mustard</code><code class="calibre17">)</code>
    <code class="n">dispense_hot_dog_to_customer</code><code class="calibre17">(</code><code class="n">hot_dog</code><code class="calibre17">)</code></pre>

<p class="author1"><code class="calibre17">None</code> values truly are a billion-dollar mistake.<a data-type="indexterm" data-primary="Optional types" data-secondary="using to tell developers to beware of None" id="idm45644755278504" class="calibre5"/> If they slip through, programs can crash, users are frustrated, and money is lost. Use <code class="calibre17">Optional</code> types to tell other developers to beware of <code class="calibre17">None</code>, and benefit from the automated checking of your tools.</p>
</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Constraining Types" class="preface">
<div class="preface" id="constraints">
<section data-type="sect1" data-pdf-bookmark="Optional Type" class="preface">
<div class="preface" id="idm45644755854968">
<div data-type="note" epub:type="note" class="calibre21"><h1 class="calibre38" id="calibre_pb_2">Discussion Topic</h1>
<p class="author1">How often do you deal with <code class="calibre17">None</code> in your codebase? How confident are you that every possible <code class="calibre17">None</code> value is handled correctly? Look through bugs and failing tests to see how many times you’ve been bitten by incorrect <code class="calibre17">None</code> handling. Discuss how <code class="calibre17">Optional</code> types will help your codebase.<a data-type="indexterm" data-primary="None values" data-startref="ix_None" id="idm45644755273160" class="calibre5"/><a data-type="indexterm" data-primary="constraining types" data-secondary="Optional types" data-startref="ix_constypOpt" id="idm45644755272184" class="calibre5"/><a data-type="indexterm" data-primary="Optional types" data-startref="ix_Optty" id="idm45644755270968" class="calibre5"/></p>
</div>
</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Constraining Types" class="preface">
<div class="preface" id="constraints">
<section data-type="sect1" data-pdf-bookmark="Union Types" class="preface"><div class="preface" id="idm45644755825864">
<h1 class="calibre12" id="calibre_pb_3">Union Types</h1>

<p class="author1">A <code class="calibre17">Union</code> type is a type that indicates that multiple disparate types may be used with the same variable.<a data-type="indexterm" data-primary="constraining types" data-secondary="Union types" id="ix_constypUn" class="calibre5"/><a data-type="indexterm" data-primary="Union types" id="ix_Untyp" class="calibre5"/> A <code class="calibre17">Union[int,str]</code> means that either an <code class="calibre17">int</code> <em class="calibre6">or</em> a <code class="calibre17">str</code> can be used for a variable. For instance, consider the following code:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">dispense_snack</code><code class="calibre17">()</code> <code class="calibre17">-&gt;</code> <code class="n">HotDog</code><code class="calibre17">:</code>
    <code class="k">if</code> <code class="calibre19">not</code> <code class="n">are_ingredients_available</code><code class="calibre17">():</code>
        <code class="k">raise</code> <code class="ne">RuntimeError</code><code class="calibre17">(</code><code class="s">"Not all ingredients available"</code><code class="calibre17">)</code>
    <code class="k">if</code> <code class="n">order_interrupted</code><code class="calibre17">():</code>
        <code class="k">raise</code> <code class="ne">RuntimeError</code><code class="calibre17">(</code><code class="s">"Order interrupted"</code><code class="calibre17">)</code>
    <code class="k">return</code> <code class="n">create_hot_dog</code><code class="calibre17">()</code></pre>

<p class="author1">I now want my hot dog stand to break into the lucrative pretzel business. Instead of trying to deal with weird class inheritance (we’ll cover more about inheritance in <a data-type="xref" href="part0011.html#part_2" class="calibre5">Part II</a>) that doesn’t belong between hot dogs and pretzels, you simply can return a <code class="calibre17">Union</code> of the two.</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">typing</code> <code class="k">import</code> <code class="n">Union</code>
<code class="k">def</code> <code class="nf">dispense_snack</code><code class="calibre17">(</code><code class="n">user_input</code><code class="calibre17">:</code> <code class="nb">str</code><code class="calibre17">)</code> <code class="calibre17">-&gt;</code> <code class="n">Union</code><code class="calibre17">[</code><code class="n">HotDog</code><code class="calibre17">,</code> <code class="n">Pretzel</code><code class="calibre17">]:</code>
    <code class="k">if</code> <code class="n">user_input</code> <code class="calibre17">==</code> <code class="s">"Hot Dog"</code><code class="calibre17">:</code>
        <code class="k">return</code> <code class="n">dispense_hot_dog</code><code class="calibre17">()</code>
    <code class="k">elif</code> <code class="n">user_input</code> <code class="calibre17">==</code> <code class="s">"Pretzel"</code><code class="calibre17">:</code>
        <code class="k">return</code> <code class="n">dispense_pretzel</code><code class="calibre17">()</code>
    <code class="k">raise</code> <code class="ne">RuntimeError</code><code class="calibre17">(</code><code class="s">"Should never reach this code,"</code>
                       <code class="s">"as an invalid input has been entered"</code><code class="calibre17">)</code></pre>
<div data-type="note" epub:type="note" class="calibre21"><h6 class="calibre22">Note</h6>
<p class="author1"><code class="calibre17">Optional</code> is just a specialized version of a <code class="calibre17">Union</code>. <code class="calibre17">Optional[int]</code> is the same exact thing as <code class="calibre17">Union[int, None]</code>.</p>
</div>

<p class="author1">Using a <code class="calibre17">Union</code> offers much the same benefit as an <code class="calibre17">Optional</code>. First, you reap the same communication advantages. A developer encountering a <code class="calibre17">Union</code> knows that they must be able to handle more than one type in their calling code. Furthermore, a typechecker is just as aware of <code class="calibre17">Union</code> as it is of <code class="calibre17">Optional</code>.</p>

<p class="author1">You will find <code class="calibre17">Unions</code> useful in a variety of applications:</p>

<ul class="printings">
<li class="calibre9">
<p class="author1">Handling disparate types returned based on user input (as above)</p>
</li>
<li class="calibre9">
<p class="author1">Handling error return types a la <code class="calibre17">Optional</code>s, but with more information, such as a string or error code</p>
</li>
<li class="calibre9">
<p class="author1">Handling different user input (such as if a user is able to supply a list or a string)</p>
</li>
<li class="calibre9">
<p class="author1">Returning different types, say for backward compatibility (returning an old version of an object or a new version of an object depending on requested <span class="calibre">operation</span>)</p>
</li>
<li class="calibre9">
<p class="author1">And any other case where you may legitimately have more than one value <span class="calibre">represented</span></p>
</li>
</ul>

<p class="author1">Suppose you had code that called the <code class="calibre17">dispense_snack</code> function but was only expecting a <code class="calibre17">HotDog</code> (or <code class="calibre17">None</code>) to be returned:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">typing</code> <code class="k">import</code> <code class="n">Union</code>
<code class="k">def</code> <code class="nf">place_order</code><code class="calibre17">()</code> <code class="calibre17">-&gt;</code> <code class="n">Optional</code><code class="calibre17">[</code><code class="n">HotDog</code><code class="calibre17">]:</code>
    <code class="n">order</code> <code class="calibre17">=</code> <code class="n">get_order</code><code class="calibre17">()</code>
    <code class="n">result</code> <code class="calibre17">=</code> <code class="n">dispense_snack</code><code class="calibre17">(</code><code class="n">order</code><code class="calibre17">.</code><code class="n">name</code><code class="calibre17">)</code>
    <code class="k">if</code> <code class="n">result</code> <code class="calibre19">is</code> <code class="nb">None</code>
        <code class="n">print_error_code</code><code class="calibre17">(</code><code class="s">"An error occurred"</code> <code class="calibre17">+</code> <code class="n">result</code><code class="calibre17">)</code>
        <code class="k">return</code> <code class="nb">None</code>
    <code class="c"># Return our HotDog</code>
    <code class="k">return</code> <code class="n">result</code></pre>

<p class="author1">As soon as <code class="calibre17">dispense_snack</code> starts returning <code class="calibre17">Pretzels</code>, this code fails to typecheck.</p>

<pre data-type="programlisting" class="calibre35">code_examples/chapter4/invalid/union_hotdog.py:22:
    error: Incompatible return value type (got "Union[HotDog, Pretzel]",
                                           expected "Optional[HotDog]")</pre>

<p class="author1">The fact that the typechecker errors out in this case is fantastic. If any function you depend on changes to return a new type, its return signature must be updated to <code class="calibre17">Union</code> a new type, which forces you to update your code to handle the new type. This means that your code will be flagged when your dependencies change in a way that contradicts your assumptions. With the decisions you make today, you can catch errors in the future. This is the mark of robust code; you are making it increasingly harder for developers to make mistakes, which reduces their error rates, which reduces the number of bugs users will experience.</p>

<p class="author1">There is one more fundamental benefit of using a <code class="calibre17">Union</code>, but to explain it, I need to teach you a smidge of <em class="calibre6">type theory</em>, which is a branch of mathematics around type <span class="calibre">systems</span>.<a data-type="indexterm" data-primary="type theory" id="idm45644755040120" class="calibre5"/></p>








</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Constraining Types" class="preface">
<div class="preface" id="constraints">
<section data-type="sect1" data-pdf-bookmark="Union Types" class="preface">
<div class="preface" id="idm45644755825864">
<section data-type="sect2" data-pdf-bookmark="Product and Sum Types" class="preface"><div class="preface" id="idm45644755039256">
<h2 class="calibre34" id="calibre_pb_4">Product and Sum Types</h2>

<p class="author1"><code class="calibre17">Unions</code> are beneficial because they help constrain representable state space. <em class="calibre6">Representable state space</em> is the set of all possible combinations an object can take.<a data-type="indexterm" data-primary="representable state space" id="idm45644755036856" class="calibre5"/></p>

<p class="author1">Take this <code class="calibre17">dataclass</code>:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">dataclasses</code> <code class="k">import</code> <code class="n">dataclass</code>
<code class="c"># If you aren't familiar with data classes, you'll learn more in chapter 10</code>
<code class="c"># but for now, treat this as four fields grouped together and what types they are</code>
<code class="nd">@dataclass</code>
<code class="k">class</code> <code class="nc">Snack</code><code class="calibre17">:</code>
    <code class="n">name</code><code class="calibre17">:</code> <code class="nb">str</code>
    <code class="n">condiments</code><code class="calibre17">:</code> <code class="nb">set</code><code class="calibre17">[</code><code class="nb">str</code><code class="calibre17">]</code>
    <code class="n">error_code</code><code class="calibre17">:</code> <code class="nb">int</code>
    <code class="n">disposed_of</code><code class="calibre17">:</code> <code class="nb">bool</code>


<code class="n">Snack</code><code class="calibre17">(</code><code class="s">"Hotdog"</code><code class="calibre17">,</code> <code class="calibre17">{</code><code class="s">"Mustard"</code><code class="calibre17">,</code> <code class="s">"Ketchup"</code><code class="calibre17">},</code> <code class="mi">5</code><code class="calibre17">,</code> <code class="nb">False</code><code class="calibre17">)</code></pre>

<p class="author1">I have a name, the condiments that can go on top, an error code in case something goes wrong, and if something does go wrong, a boolean to track whether I have <span class="calibre">disposed</span> of the item correctly or not. How many different combinations of values can be put into this dictionary? A potentially infinite number, right? The <code class="calibre17">name</code> alone could be anything from valid values (“hotdog” or “pretzel”) to invalid values (“samosa”, “kimchi”, or “poutine”) to absurd (“12345”, “”, or “(╯°□°)╯︵ ┻━┻”). <code class="calibre17">condiments</code> has a similar problem. As it stands, there is no way to compute the possible options.</p>

<p class="author1">For the sake of simplicity, I will artificially constrain this type:</p>

<ul class="printings">
<li class="calibre9">
<p class="author1">The name can be one of three values: hotdog, pretzel, or veggie burger</p>
</li>
<li class="calibre9">
<p class="author1">The condiments can be empty, mustard, ketchup, or both.</p>
</li>
<li class="calibre9">
<p class="author1">There are six error codes (0–5); 0 indicates success).</p>
</li>
<li class="calibre9">
<p class="author1"><code class="calibre17">disposed_of</code> is only <code class="calibre17">True</code> or <code class="calibre17">False</code>.</p>
</li>
</ul>

<p class="author1">Now how many different values can be represented in this combination of fields? The answer is 144, which is a grossly large number. I achieve this by the following:</p>
<blockquote class="pcalibre2 calibre28 pcalibre1">
<p class="calibre29">3 possible types for name × 4 possible types for condiments × 6 error codes × 2 boolean values for if the entry has been disposed of = 3×4×6×2 = 144.</p></blockquote>

<p class="author1">If you were to accept that any of these values could be <code class="calibre17">None</code>, the total balloons to 420. While you should always think about <code class="calibre17">None</code> while coding (see earlier in this chapter about <code class="calibre17">Optional</code>), for this thought exercise, I’m going to ignore <code class="calibre17">None values</code>.</p>

<p class="author1">This sort of operation is known as a <em class="calibre6">product type</em>; the number of representable states is determined by the product of possible values.<a data-type="indexterm" data-primary="product type" id="idm45644754953928" class="calibre5"/> The problem is, not all of these states are valid. The variable <code class="calibre17">disposed_of</code> should only be set to <code class="calibre17">True</code> if an error code is set to nonzero. Developers will make this assumption, and trust that the illegal state never shows up. However, one innocent mistake can bring your whole system crashing to a halt. Consider the following code:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">serve</code><code class="calibre17">(</code><code class="n">snack</code><code class="calibre17">):</code>
    <code class="c"># if something went wrong, return early</code>
    <code class="k">if</code> <code class="n">snack</code><code class="calibre17">.</code><code class="n">disposed_of</code><code class="calibre17">:</code>
        <code class="k">return</code>
    <code class="c"># ...</code></pre>

<p class="author1">In this case, a developer is checking <code class="calibre17">disposed_of</code> without checking for the nonzero error code first. This is a logic bomb waiting to happen. This code will work completely fine as long as <code class="calibre17">disposed_of</code> is <code class="calibre17">True</code> <em class="calibre6">and</em> the error code is nonzero. If a valid snack ever sets the <code class="calibre17">disposed_of</code> flag to <code class="calibre17">True</code> erroneously, this code will start producing invalid results. This can be hard to find, as there’s no reason for a developer who is creating the snack to check this code. As it stands, you have no way of catching this sort of error other than manually inspecting every use case, which is intractable for large code bases. By allowing an illegal state to be representable, you open the door to fragile code.</p>

<p class="author1">To remedy this, I need to make this illegal state unrepresentable. To do that, I’ll rework my example and use a <code class="calibre17">Union</code>:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">dataclasses</code> <code class="k">import</code> <code class="n">dataclass</code>
<code class="k">from</code> <code class="nn">typing</code> <code class="k">import</code> <code class="n">Union</code>
<code class="nd">@dataclass</code>
<code class="k">class</code> <code class="nc">Error</code><code class="calibre17">:</code>
    <code class="n">error_code</code><code class="calibre17">:</code> <code class="nb">int</code>
    <code class="n">disposed_of</code><code class="calibre17">:</code> <code class="nb">bool</code>

<code class="nd">@dataclass</code>
<code class="k">class</code> <code class="nc">Snack</code><code class="calibre17">:</code>
    <code class="n">name</code><code class="calibre17">:</code> <code class="nb">str</code>
    <code class="n">condiments</code><code class="calibre17">:</code> <code class="nb">set</code><code class="calibre17">[</code><code class="nb">str</code><code class="calibre17">]</code>

<code class="n">snack</code><code class="calibre17">:</code> <code class="n">Union</code><code class="calibre17">[</code><code class="n">Snack</code><code class="calibre17">,</code> <code class="n">Error</code><code class="calibre17">]</code> <code class="calibre17">=</code> <code class="n">Snack</code><code class="calibre17">(</code><code class="s">"Hotdog"</code><code class="calibre17">,</code> <code class="calibre17">{</code><code class="s">"Mustard"</code><code class="calibre17">,</code> <code class="s">"Ketchup"</code><code class="calibre17">})</code>

<code class="n">snack</code> <code class="calibre17">=</code> <code class="n">Error</code><code class="calibre17">(</code><code class="mi">5</code><code class="calibre17">,</code> <code class="nb">True</code><code class="calibre17">)</code></pre>

<p class="author1">In this case, <code class="calibre17">snack</code> can be either a <code class="calibre17">Snack</code> (which is just a <code class="calibre17">name</code> and <code class="calibre17">condiments</code>) or an <code class="calibre17">Error</code> (which is just a number and a boolean). With the use of a <code class="calibre17">Union</code>, how many representable states are there now?</p>

<p class="author1">For <code class="calibre17">Snack</code>, there are 3 names and 4 possible list values, which is a total of 12 representable states. For <code class="calibre17">ErrorCode</code>, I can remove the 0 error code (since that was only for success), which gives me 5 values for the error code and 2 values for the boolean for a total of 10 representable states. Since the <code class="calibre17">Union</code> is an either/or construct, I can either have 12 representable states in one case or 10 in the other, for a total of 22.<a data-type="indexterm" data-primary="sum type" id="idm45644754807800" class="calibre5"/> This is an example of a <em class="calibre6">sum type</em>, since I’m adding the number of representable states together rather than multiplying.</p>

<p class="author1">That’s 22 total representable states. Compare that with the 144 states when all the fields were lumped in a single entity. I’ve reduced my representable state space by almost 85%. I’ve made it impossible to mix and match fields that are incompatible with one another. It becomes much harder to make a mistake, and there are far fewer combinations to test. Anytime you use a sum type, such as a <code class="calibre17">Union</code>, you are dramatically decreasing the number of possible representable states.<a data-type="indexterm" data-primary="constraining types" data-secondary="Union types" data-startref="ix_constypUn" id="idm45644754805352" class="calibre5"/><a data-type="indexterm" data-primary="Union types" data-startref="ix_Untyp" id="idm45644754804104" class="calibre5"/></p>
</div></section>





</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Constraining Types" class="preface">
<div class="preface" id="constraints">
<section data-type="sect1" data-pdf-bookmark="Literal Types" class="preface"><div class="preface" id="idm45644755825400">
<h1 class="calibre12" id="calibre_pb_5">Literal Types</h1>

<p class="author1">When calculating the number of representable states, I made some assumptions in the last section.<a data-type="indexterm" data-primary="constraining types" data-secondary="Literal types" id="idm45644754801688" class="calibre5"/><a data-type="indexterm" data-primary="Literal types" id="ix_Littyp" class="calibre5"/> I limited the number of values that were possible, but that’s a bit of a cheat, isn’t it? As I said before, there is almost an infinite number of values possible. Fortunately, there is a way to limit the values through Python: <code class="calibre17">Literals</code>. <code class="calibre17">Literal</code> types allow you to restrict the variable to a very specific set of values.</p>

<p class="author1">I’ll change my earlier <code class="calibre17">Snack</code> class to employ <code class="calibre17">Literal</code> values:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">typing</code> <code class="k">import</code> <code class="n">Literal</code>
<code class="nd">@dataclass</code>
<code class="k">class</code> <code class="nc">Error</code><code class="calibre17">:</code>
    <code class="n">error_code</code><code class="calibre17">:</code> <code class="n">Literal</code><code class="calibre17">[</code><code class="mi">1</code><code class="calibre17">,</code><code class="mi">2</code><code class="calibre17">,</code><code class="mi">3</code><code class="calibre17">,</code><code class="mi">4</code><code class="calibre17">,</code><code class="mi">5</code><code class="calibre17">]</code>
    <code class="n">disposed_of</code><code class="calibre17">:</code> <code class="nb">bool</code>

<code class="nd">@dataclass</code>
<code class="k">class</code> <code class="nc">Snack</code><code class="calibre17">:</code>
    <code class="n">name</code><code class="calibre17">:</code> <code class="n">Literal</code><code class="calibre17">[</code><code class="s">"Pretzel"</code><code class="calibre17">,</code> <code class="s">"Hot Dog"</code><code class="calibre17">,</code> <code class="s">"Veggie Burger"</code><code class="calibre17">]</code>
    <code class="n">condiments</code><code class="calibre17">:</code> <code class="nb">set</code><code class="calibre17">[</code><code class="n">Literal</code><code class="calibre17">[</code><code class="s">"Mustard"</code><code class="calibre17">,</code> <code class="s">"Ketchup"</code><code class="calibre17">]]</code></pre>

<p class="author1">Now, if I try to instantiate these data classes with wrong values:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">Error</code><code class="calibre17">(</code><code class="mi">0</code><code class="calibre17">,</code> <code class="nb">False</code><code class="calibre17">)</code>
<code class="n">Snack</code><code class="calibre17">(</code><code class="s">"Invalid"</code><code class="calibre17">,</code> <code class="nb">set</code><code class="calibre17">())</code>
<code class="n">Snack</code><code class="calibre17">(</code><code class="s">"Pretzel"</code><code class="calibre17">,</code> <code class="calibre17">{</code><code class="s">"Mustard"</code><code class="calibre17">,</code> <code class="s">"Relish"</code><code class="calibre17">})</code></pre>

<p class="author1">I receive the following typechecker errors:</p>
<pre class="calibre35">code_examples/chapter4/invalid/literals.py:14: error: Argument 1 to "Error" has
    incompatible type "Literal[0]";
                      expected "Union[Literal[1], Literal[2], Literal[3],
                                      Literal[4], Literal[5]]"

code_examples/chapter4/invalid/literals.py:15: error: Argument 1 to "Snack" has
    incompatible type "Literal['Invalid']";
                       expected "Union[Literal['Pretzel'], Literal['Hotdog'],
                                       Literal['Veggie Burger']]"

code_examples/chapter4/invalid/literals.py:16: error: Argument 2 to &lt;set&gt; has
    incompatible type "Literal['Relish']";
                       expected "Union[Literal['Mustard'], Literal['Ketchup']]"</pre>

<p class="author1"><code class="calibre17">Literals</code> were introduced in Python 3.8, and they are an invaluable way of restricting possible values of a variable.<a data-type="indexterm" data-primary="Literal types" data-startref="ix_Littyp" id="idm45644754640600" class="calibre5"/> They are a little more lightweight than Python enumerations (which I’ll cover in <a data-type="xref" href="part0012_split_000.html#enum" class="calibre5">Chapter 8</a>).</p>
</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Constraining Types" class="preface">
<div class="preface" id="constraints">
<section data-type="sect1" data-pdf-bookmark="Annotated Types" class="preface"><div class="preface" id="idm45644754638632">
<h1 class="calibre12" id="calibre_pb_6">Annotated Types</h1>

<p class="author1">What if I wanted to get even deeper and specify more complex constraints?<a data-type="indexterm" data-primary="constraining types" data-secondary="Annotated types" id="idm45644754637080" class="calibre5"/><a data-type="indexterm" data-primary="Annotated types" id="idm45644754636104" class="calibre5"/> It would be tedious to write hundreds of literals, and some constraints aren’t able to be modeled by <code class="calibre17">Literal</code> types. There’s no way with a <code class="calibre17">Literal</code> to constrain a string to a certain size or to match a specific regular expression.<a data-type="indexterm" data-primary="metadata, arbitrary, specifying with Annotated types" id="idm45644754707560" class="calibre5"/> This is where <code class="calibre17">Annotated</code> comes in. With <code class="calibre17">Annotated</code>, you can specify arbitrary metadata alongside your type annotation.</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">x</code><code class="calibre17">:</code> <code class="n">Annotated</code><code class="calibre17">[</code><code class="nb">int</code><code class="calibre17">,</code> <code class="n">ValueRange</code><code class="calibre17">(</code><code class="mi">3</code><code class="calibre17">,</code><code class="mi">5</code><code class="calibre17">)]</code>
<code class="n">y</code><code class="calibre17">:</code> <code class="n">Annotated</code><code class="calibre17">[</code><code class="nb">str</code><code class="calibre17">,</code> <code class="n">MatchesRegex</code><code class="calibre17">(</code><code class="s">'[0-9]{4}'</code><code class="calibre17">)]</code></pre>

<p class="author1">Unfortunately, the above code will not run, as <code class="calibre17">ValueRange</code> and <code class="calibre17">MatchesRegex</code> are not built-in types; they are arbitrary expressions. You will need to write your own metadata as part of an <code class="calibre17">Annotated</code> variable. Secondly,  there are no tools that will typecheck this for you. The best you can do until such a tool exists is write dummy annotations or use strings to describe your constraints. At this point, <code class="calibre17">Annotated</code> is best served as a communication method.</p>
</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Constraining Types" class="preface">
<div class="preface" id="constraints">
<section data-type="sect1" data-pdf-bookmark="NewType" class="preface"><div class="preface" id="idm45644754558840">
<h1 class="calibre12" id="calibre_pb_7">NewType</h1>

<p class="author1">While waiting for tooling to support <code class="calibre17">Annotated</code>, there is another way to represent more complicated constraints: <code class="calibre17">NewType</code>. <code class="calibre17">NewType</code> allows you to, well, create a new type.<a data-type="indexterm" data-primary="constraining types" data-secondary="NewType" id="ix_constypNT" class="calibre5"/><a data-type="indexterm" data-primary="NewType" id="ix_NewTyp" class="calibre5"/></p>

<p class="author1">Suppose I want to separate my hot dog stand code to handle two separate cases: a hot dog in its unservable form (no plate, no napkins) and a hot dog that is ready to serve (plated, with napkins). In my code, there exist some functions that should only be operating on the hot dog in one case or the other. For example, an unservable hot dog should never be dispensed to the customer.</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">class</code> <code class="nc">HotDog</code><code class="calibre17">:</code>
    <code class="c"># ... snip hot dog class implementation ...</code>

<code class="k">def</code> <code class="nf">dispense_to_customer</code><code class="calibre17">(</code><code class="n">hot_dog</code><code class="calibre17">:</code> <code class="n">HotDog</code><code class="calibre17">):</code>
    <code class="c"># note, this should only accept ready-to-serve hot dogs.</code>
    <code class="c"># ...</code></pre>

<p class="author1">However, nothing prevents someone from passing in an unservable hot dog. If a developer makes a mistake and passes an unservable hot dog to this function, customers will be quite surprised to see just their order with no plate or napkins come out of the machine.</p>

<p class="author1">Rather than relying on developers to catch these errors whenever they happen, you need a way for your typechecker to catch this. To do that, you can use <code class="calibre17">NewType</code>:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">typing</code> <code class="k">import</code> <code class="n">NewType</code>

<code class="k">class</code> <code class="nc">HotDog</code><code class="calibre17">:</code>
    <code class="sd">''' Used to represent an unservable hot dog'''</code>
    <code class="c"># ... snip hot dog class implementation ...</code>

<code class="n">ReadyToServeHotDog</code> <code class="calibre17">=</code> <code class="n">NewType</code><code class="calibre17">(</code><code class="s">"ReadyToServeHotDog"</code><code class="calibre17">,</code> <code class="n">HotDog</code><code class="calibre17">)</code>

<code class="k">def</code> <code class="nf">dispense_to_customer</code><code class="calibre17">(</code><code class="n">hot_dog</code><code class="calibre17">:</code> <code class="n">ReadyToServeHotDog</code><code class="calibre17">):</code>
    <code class="c"># ...</code></pre>

<p class="author1">A <code class="calibre17">NewType</code> takes an existing type and creates a brand new type that has all the same fields and methods as the existing type.<a data-type="indexterm" data-primary="NewType" data-secondary="conversions of existing type to" id="idm45644749101896" class="calibre5"/> In this case, I am creating a type <code class="calibre17">ReadyToServeHotDog</code> that is distinct from <code class="calibre17">HotDog</code>; they are not interchangeable. What’s beautiful about this is that this type restricts implicit type conversions. You cannot use a <code class="calibre17">HotDog</code> anywhere you are expecting a <code class="calibre17">ReadyToServeHotDog</code> (you can use a <code class="calibre17">ReadyToServeHotDog</code> in place of <code class="calibre17">HotDog</code>, though). In the previous example, I am restricting <code class="calibre17">dispense_to_customer</code> to only take <code class="calibre17">ReadyToServeHotDog</code> values as an argument. This prevents developers from invalidating assumptions. If a developer were to pass a <code class="calibre17">HotDog</code> to this method, the typechecker will yell at them:</p>
<pre class="calibre35">code_examples/chapter4/invalid/newtype.py:10: error:
	Argument 1 to "dispense_to_customer"
	has incompatible type "HotDog";
	expected "ReadyToServeHotDog"</pre>

<p class="author1">It is important to stress the one-way nature of this type conversion. As a developer, you can control when your old type becomes your new type.</p>

<p class="author1">For example, I’ll create a function that takes a unservable <code class="calibre17">HotDog</code> and makes it ready to serve:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">prepare_for_serving</code><code class="calibre17">(</code><code class="n">hot_dog</code><code class="calibre17">:</code> <code class="n">HotDog</code><code class="calibre17">)</code> <code class="calibre17">-&gt;</code> <code class="n">ReadyToServeHotDog</code><code class="calibre17">:</code>
    <code class="k">assert</code> <code class="calibre19">not</code> <code class="n">hot_dog</code><code class="calibre17">.</code><code class="n">is_plated</code><code class="calibre17">(),</code> <code class="s">"Hot dog should not already be plated"</code>
    <code class="n">hot_dog</code><code class="calibre17">.</code><code class="n">put_on_plate</code><code class="calibre17">()</code>
    <code class="n">hot_dog</code><code class="calibre17">.</code><code class="n">add_napkins</code><code class="calibre17">()</code>
    <code class="k">return</code> <code class="n">ReadyToServeHotDog</code><code class="calibre17">(</code><code class="n">hot_dog</code><code class="calibre17">)</code></pre>

<p class="author1">Notice how I’m explicitly returning a <code class="calibre17">ReadyToServeHotDog</code> instead of a normal <code class="calibre17">HotDog</code>. This acts as a “blessed” function; it is the only sanctioned way that I want developers to create a <code class="calibre17">ReadyToServeHotDog</code>. Any user trying to use a method that takes a <code class="calibre17">ReadyToServeHotDog</code> needs to create it using <code class="calibre17">prepare_for_serving</code> first.</p>

<p class="author1">It is important to notify users that the only way to create your new type is through a set of “blessed” functions. You don’t want users creating your new type in any circumstance other than a predetermined method, as that defeats the purpose.</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">make_snack</code><code class="calibre17">():</code>
    <code class="n">serve_to_customer</code><code class="calibre17">(</code><code class="n">ReadyToServeHotDog</code><code class="calibre17">(</code><code class="n">HotDog</code><code class="calibre17">()))</code></pre>

<p class="author1">Unfortunately, Python has no great way of telling users this, other than a comment.</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">from</code> <code class="nn">typing</code> <code class="k">import</code> <code class="n">NewType</code>
<code class="c"># NOTE: Only create ReadyToServeHotDog using prepare_for_serving method.</code>
<code class="n">ReadyToServeHotDog</code> <code class="calibre17">=</code> <code class="n">NewType</code><code class="calibre17">(</code><code class="s">"ReadyToServeHotDog"</code><code class="calibre17">,</code> <code class="n">HotDog</code><code class="calibre17">)</code></pre>

<p class="author1">Still, <code class="calibre17">NewType</code> is applicable to many real-world scenarios.<a data-type="indexterm" data-primary="NewType" data-secondary="scenarios for use" id="idm45644749011688" class="calibre5"/> For example, these are all scenarios that I’ve run into that a <code class="calibre17">NewType</code> would solve:</p>

<ul class="printings">
<li class="calibre9">
<p class="author1">Separating a <code class="calibre17">str</code> from a <code class="calibre17">SanitizedString</code>, to catch bugs like SQL injection vulnerabilities. By making <code class="calibre17">SanitizedString</code> a <code class="calibre17">NewType</code>, I made sure that only properly sanitized strings were operated upon, eliminating the chance of SQL injection.</p>
</li>
<li class="calibre9">
<p class="author1">Tracking a <code class="calibre17">User</code> object and <code class="calibre17">LoggedInUser</code> separately. By restricting <code class="calibre17">Users</code> with <code class="calibre17">NewType</code> from <code class="calibre17">LoggedInUser</code>, I wrote functions that were only applicable to users that were logged in.</p>
</li>
<li class="calibre9">
<p class="author1">Tracking an integer that should represent a valid User ID. By restricting the User ID to a <code class="calibre17">NewType</code>, I could make sure that some functions were only operating on IDs that were valid, without having to check <code class="calibre17">if</code> statements.</p>
</li>
</ul>

<p class="author1">In <a data-type="xref" href="part0014_split_000.html#classes" class="calibre5">Chapter 10</a>, you’ll see how you can use classes and invariants to do something very similar, with a much stronger guarantee of avoiding illegal states. However, <code class="calibre17">NewType</code> is still a useful pattern to be aware of, and is much more lightweight than a full-blown class.</p>
<aside data-type="sidebar" epub:type="sidebar" class="calibre32"><div class="sidebar" id="idm45644748945416">
<h5 class="calibre33">Type Aliases</h5>
<p class="author1"><code class="calibre17">NewType</code> is not the same as a type alias.<a data-type="indexterm" data-primary="NewType" data-secondary="versus type aliases" data-secondary-sortas="type aliases" id="idm45644748943560" class="calibre5"/><a data-type="indexterm" data-primary="type aliases" data-secondary="NewType versus" id="idm45644748942312" class="calibre5"/> A type alias just provides another name for a type and is completely interchangeable with the old type.</p>

<p class="author1">For example:</p>

<pre data-type="programlisting" class="calibre35">IdOrName = Union[str, int]</pre>

<p class="author1">If a function expects <code class="calibre17">IDOrName</code>, it can take either an <code class="calibre17">IDOrName</code> or a <code class="calibre17">Union[str,int]</code> and it will typecheck just fine, where a <code class="calibre17">NewType</code> will only work if an <code class="calibre17">IDOrName</code> is passed in.</p>

<p class="author1">I have found type aliases to be very helpful when I start nesting complex types, such as <code class="calibre17">Union[dict[int, User], list[dict[str, User]]]</code>. It’s much easier to give it a conceptual name, such as <code class="calibre17">IDOrNameLookup</code>, to simplify types.<a data-type="indexterm" data-primary="constraining types" data-secondary="NewType" data-startref="ix_constypNT" id="idm45644748935896" class="calibre5"/><a data-type="indexterm" data-primary="NewType" data-startref="ix_NewTyp" id="idm45644748934616" class="calibre5"/></p>
</div></aside>
</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Constraining Types" class="preface">
<div class="preface" id="constraints">
<section data-type="sect1" data-pdf-bookmark="Final Types" class="preface"><div class="preface" id="idm45644748933416">
<h1 class="calibre12" id="calibre_pb_8">Final Types</h1>

<p class="author1">Finally (pun intended), you may want to restrict a type from changing its value.<a data-type="indexterm" data-primary="constraining types" data-secondary="Final types" id="idm45644748914984" class="calibre5"/><a data-type="indexterm" data-primary="Final types" id="idm45644748914136" class="calibre5"/> That’s where <code class="calibre17">Final</code> comes in. <code class="calibre17">Final</code>, introduced in Python 3.8, indicates to a typechecker that a variable cannot be bound to another value. For instance, I want to start franchising out my hot dog stand, but I don’t want the name to be changed by accident.</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="n">VENDOR_NAME</code><code class="calibre17">:</code> <code class="n">Final</code> <code class="calibre17">=</code> <code class="s">"Viafore's Auto-Dog"</code></pre>

<p class="author1">If a developer accidentally changed the name later on, they would see an error.</p>

<pre data-type="programlisting" data-code-language="python" class="calibre35"><code class="k">def</code> <code class="nf">display_vendor_information</code><code class="calibre17">():</code>
    <code class="n">vendor_info</code> <code class="calibre17">=</code> <code class="s">"Auto-Dog v1.0"</code>
    <code class="c"># whoops, copy-paste error, this code should be vendor_info += VENDOR_NAME</code>
    <code class="n">VENDOR_NAME</code> <code class="calibre17">+=</code> <code class="n">VENDOR_NAME</code>
    <code class="k">print</code><code class="calibre17">(</code><code class="n">vendor_info</code><code class="calibre17">)</code></pre>
<pre class="calibre35">code_examples/chapter4/invalid/final.py:3: error:
	Cannot assign to final name "VENDOR_NAME"
Found 1 error in 1 file (checked 1 source file)</pre>

<p class="author1">In general, <code class="calibre17">Final</code> is best used when the variable’s scope spans a large amount of code, such as a module. It is difficult for developers to keep track of all the uses of a variable in such large scopes; letting the typechecker catch immutability guarantees is a boon in these cases.</p>
<div data-type="warning" epub:type="warning" class="calibre23"><h6 class="calibre24">Warning</h6>
<p class="author1"><code class="calibre17">Final</code> will not error out when mutating an object through a function. It only prevents the variable from being rebound (set to a new value).</p>
</div>
</div></section>













</div></section>

<section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Constraining Types" class="preface">
<div class="preface" id="constraints">
<section data-type="sect1" data-pdf-bookmark="Closing Thoughts" class="preface"><div class="preface" id="idm45644748893000">
<h1 class="calibre12" id="calibre_pb_9">Closing Thoughts</h1>

<p class="author1">You’ve learned about many different ways to constrain your types in this chapter. All of them serve a specific purpose, from handling <code class="calibre17">None</code> with <code class="calibre17">Optional</code> to restricting to specific values with <code class="calibre17">Literal</code> to preventing a variable from being rebound with <code class="calibre17">Final</code>. By using these techniques, you’ll be able to encode assumptions and restrictions directly into your codebase, preventing future readers from needing to guess about your logic. Typecheckers will use these advanced type annotations to provide you with stricter guarantees about your code, which will give maintainers confidence when working in your codebase. With this confidence, they will make fewer mistakes, and your codebase will become more robust because of it.</p>

<p class="author1">In the next chapter, you’ll move on from type annotating single values, and learn how to properly annotate collection types. Collection types pervade most of Python; you must take care to express your intentions for them as well. You need to be well-versed in all the ways you can represent a collection, including in cases where you must create your own.<a data-type="indexterm" data-primary="constraining types" data-startref="ix_constyp" id="idm45644748888488" class="calibre5"/></p>
</div></section>







<div data-type="footnotes" class="calibre25"><p data-type="footnote" id="idm45644755819000" class="calibre26"><sup class="calibre27"><a href="part0007_split_001.html#idm45644755819000-marker" class="calibre5">1</a></sup> C.A.R. Hoare. “Null References: The Billion Dollar Mistake.” <em class="calibre6">Historically Bad Ideas</em>. Presented at Qcon London 2009, n.d.</p></div></div></section></body></html>