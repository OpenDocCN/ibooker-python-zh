- en: Chapter 15\. Crawling Through APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章。通过API爬行
- en: JavaScript has traditionally been the bane of web crawlers everywhere. At one
    point in the ancient history of the internet, you could be guaranteed that a request
    for an HTML page made to the web server would represent the same HTML website
    you would see in a browser.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript一直是网络爬虫的克星。在互联网古老历史的某个时刻，你可以确保向Web服务器请求一个HTML页面，所得到的内容与在浏览器中看到的完全相同。
- en: 'As JavaScript and Ajax content generation and loading become more ubiquitous,
    that situation is becoming less common. In [Chapter 14](ch14.html#c-14), you looked
    at one way of solving this: using Selenium to automate a browser and fetch the
    data. This is an easy thing to do. It works almost all of the time.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着JavaScript和Ajax内容的生成和加载变得更加普遍，这种情况变得不那么常见了。在[第14章](ch14.html#c-14)中，你看到了解决这个问题的一种方法：使用Selenium自动化浏览器并获取数据。这是一件容易的事情。它几乎总是有效的。
- en: The problem is that, when you have a “hammer” as powerful and effective as Selenium,
    every web scraping problem starts to look a lot like a nail.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，当你拥有像Selenium这样强大和高效的“锤子”时，每个网络抓取问题开始看起来都很像一个钉子。
- en: 'In this chapter, you’ll look at cutting through the JavaScript entirely (no
    need to execute it or even load it!) and getting straight to the source of the
    data: the APIs that generate it.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将完全消除JavaScript的影响（甚至无需执行它或加载它！），直接访问数据源：生成数据的API。
- en: A Brief Introduction to APIs
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API简介
- en: Although countless books, talks, and guides have been written about the intricacies
    of REST, GraphQL, JSON, and XML APIs, at their core they are based on a simple
    concept. An *API*, or Application Programming Interface, defines a standardized
    syntax that allows one piece of software to communicate with another piece of
    software, even though they might be written in different languages or otherwise
    structured differently.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管关于REST、GraphQL、JSON和XML API的复杂性有无数书籍、演讲和指南，但它们的核心基于一个简单的概念。一个*API*，或者应用程序编程接口，定义了一种标准化的语法，允许一个软件件与另一个软件件通信，即使它们可能是用不同的语言编写或以其他方式不同结构化的。
- en: This section focuses on web APIs (in particular, APIs that allow a web server
    to communicate to a browser) and uses the term *API* to refer specifically to
    that type. But you may want to keep in mind that, in other contexts, *API* is
    also a generic term that can be used to, say, allow a Java program to communicate
    with a Python program running on the same machine. An API does not always have
    to be “across the internet” and does not necessarily involve any web technologies.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本节专注于Web API（特别是允许Web服务器与浏览器通信的API），并使用术语*API*特指这种类型。但是你可能想记住，在其他情境中，*API*也是一个通用术语，可以用来允许例如Java程序与同一台机器上运行的Python程序通信。API并不总是“通过互联网”并且不一定涉及任何Web技术。
- en: Web APIs are most often used by developers who are using a well-advertised and
    documented public service. For example, the US National Weather Service provides
    a [weather API](https://www.weather.gov/documentation/services-web-api) that gives
    current weather data and forecasts for any location. Google has dozens of APIs
    in its [Developers section](https://console.developers.google.com) for language
    translations, analytics, and geolocation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Web API最常被使用的是那些使用良好宣传和文档化的公共服务的开发人员。例如，美国国家气象局提供了一个[weather API](https://www.weather.gov/documentation/services-web-api)，可以获取任何地点的当前天气数据和预报。Google在其[开发者部分](https://console.developers.google.com)提供了几十种API，用于语言翻译、分析和地理位置。
- en: The documentation for these APIs typically describes routes or *endpoints*,
    as URLs that you can request, with variable parameters, either in the path of
    the URL or as `GET` parameters.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这些API的文档通常描述路由或*端点*，即你可以请求的URL，带有可变参数，可以是URL路径中的一部分，也可以是`GET`参数。
- en: 'For example, the following provides `pathparam` as a parameter in the route
    path:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下示例将`pathparam`作为路由路径的参数提供：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And this provides `pathparam` as the value for the parameter `param1`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 而这个示例将`pathparam`作为参数`param1`的值提供：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Both methods of passing variable data to the API are frequently used, although,
    like many topics in computer science, philosophic debate has raged on when and
    where variables should be passed through the path or through the parameters.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管像许多计算机科学中的主题一样，有关何时以及在哪里通过路径或参数传递变量的哲学辩论一直在进行，但两种通过API传递变量数据的方法经常被使用。
- en: The response from the API is usually returned in a JSON or XML format. JSON
    is far more popular in modern times than XML, but you may still see some XML responses.
    Many APIs allow you to change the response type, using another parameter to define
    which type of response you would like.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: API的响应通常以JSON或XML格式返回。在现代，JSON比XML更流行，但您仍然可能会看到一些XML响应。许多API允许您更改响应类型，使用另一个参数来定义您想要的响应类型。
- en: 'Here’s an example of a JSON-formatted API response:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个JSON格式的API响应的示例：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here’s an example of an XML-formatted API response:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个XML格式的API响应的示例：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[ip-api.com](http://ip-api.com) provides an easy-to-use and simple API that
    translates IP addresses to actual physical addresses. You can try a simple API
    request by entering the following in your browser:^([1](ch15.html#id773))'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[ip-api.com](http://ip-api.com) 提供了一个易于使用且简单的API，将IP地址转换为实际物理地址。您可以尝试在浏览器中输入以下内容进行简单的API请求：^([1](ch15.html#id773))'
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This should produce a response like the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生类似以下的响应：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Notice that the request contains the parameter `json` in the path. You can
    request an XML or CSV response by changing this parameter accordingly:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，请求路径中包含`json`参数。您可以通过相应地更改此参数来请求XML或CSV响应：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: HTTP Methods and APIs
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP方法和API
- en: 'In the previous section, you looked at APIs making a `GET` request to the server
    for information. There are four main ways (or *methods*) to request information
    from a web server via HTTP:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，您看到了通过`GET`请求从服务器获取信息的API。通过HTTP，有四种主要的方式（或*方法*）来请求从Web服务器获取信息：
- en: '`` `GET` ``'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `GET` ``'
- en: '`` `POST` ``'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `POST` ``'
- en: '`` `PUT` ``'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `PUT` ``'
- en: '`` `DELETE` ``'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`` `DELETE` ``'
- en: Technically, more than these four exist (such as `HEAD`, `OPTIONS`, and `CONNECT`),
    but they are rarely used in APIs, and it is unlikely that you will ever see them.
    The vast majority of APIs limit themselves to these four methods or even a subset
    of these four methods. It is common to see APIs that use only `GET`, or use only
    `GET` and `POST`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，还存在更多的方法（如`HEAD`、`OPTIONS`和`CONNECT`），但它们在API中很少使用，您几乎不太可能看到它们。绝大多数API限制自己使用这四种方法或这四种方法的子集。常见的是只看到使用`GET`，或者只看到使用`GET`和`POST`的API。
- en: '`GET` is what you use when you visit a website through the address bar in your
    browser. `GET` is the method you are using when you make a call to [*http://ip-api.com/json/50.78.253.58*](http://ip-api.com/json/50.78.253.58).
    You can think of `GET` as saying, “Hey, web server, please retrieve/get me this
    information.”'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当您通过浏览器地址栏访问网站时，使用的是`GET`。当您像这样调用[*http://ip-api.com/json/50.78.253.58*](http://ip-api.com/json/50.78.253.58)时，您可以将`GET`视为说：“嘿，Web服务器，请检索/获取我这些信息。”
- en: A `GET` request, by definition, makes no changes to the information in the server’s
    database. Nothing is stored; nothing is modified. Information is only read.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，`GET`请求不会对服务器数据库中的信息进行任何更改。不会存储任何内容；不会修改任何内容。只是读取信息。
- en: '`POST` is what you use when you fill out a form or submit information, presumably
    to a backend script on the server. Every time you log in to a website, you are
    making a `POST` request with your username and (hopefully) encrypted password.
    If you are making a `POST` request with an API, you are saying, “Please store
    this information in your database.”'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST` 在您填写表单或提交信息时使用。每次登录网站时，您都在使用`POST`请求与您的用户名和（希望的话）加密密码。如果您使用API发送`POST`请求，则表示：“请将此信息存储在您的数据库中。”'
- en: '`PUT` is less commonly used when interacting with websites but is used from
    time to time in APIs. A `PUT` request is used to update an object or information.
    An API might require a `POST` request to create a new user, for example, but it
    might need a `PUT` request if you want to update that user’s email address.^([2](ch15.html#id776))'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT` 在与网站交互时使用较少，但在API中有时会用到。`PUT` 请求用于更新对象或信息。例如，一个API可能需要用`POST`请求创建新用户，但如果要更新用户的电子邮件地址，则可能需要用`PUT`请求。^([2](ch15.html#id776))'
- en: '`DELETE` is used, as you might imagine, to delete an object. For instance,
    if you send a `DELETE` request to *http://example.com/user/23*, it will delete
    the user with the ID 23. `DELETE` methods are not often encountered in public
    APIs, which are primarily created to disseminate information or allow users to
    create or post information, rather than allow users to remove that information
    from their databases.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`DELETE` 被用来删除对象，正如您可以想象的那样。例如，如果您向 *http://example.com/user/23* 发送一个 `DELETE`
    请求，它将删除 ID 为 23 的用户。`DELETE` 方法在公共 API 中并不常见，这些 API 主要用于传播信息或允许用户创建或发布信息，而不是允许用户从数据库中删除信息。'
- en: Unlike `GET` requests, `POST`, `PUT`, and `DELETE` requests allow you to send
    information in the body of a request, in addition to the URL or route from which
    you are requesting data.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `GET` 请求不同，`POST`、`PUT` 和 `DELETE` 请求允许您在请求的主体中发送信息，除了 URL 或路由外。
- en: 'Just like the response that you receive from the web server, this data in the
    body is typically formatted as JSON or, less commonly, as XML, and the format
    of this data is defined by the syntax of the API. For example, if you are using
    an API that creates comments on blog posts, you might make a `PUT` request to:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 就像您从 Web 服务器收到的响应一样，这些数据通常被格式化为 JSON 或者更少见的 XML，这些数据的格式由 API 的语法定义。例如，如果您正在使用一个用于在博客文章上创建评论的
    API，您可能会发出 `PUT` 请求到：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'with the following request body:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下请求主体：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that the ID of the blog post (`123`) is passed as a parameter in the URL,
    where the content for the new comment you are making is passed in the body of
    the request. Parameters and data may be passed in both the parameter and the body.
    Which parameters are required and where they are passed is determined, again,
    by the syntax of the API.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，博客文章的 ID（`123`）作为 URL 的参数传递，您正在创建的新评论的内容则在请求的主体中传递。参数和数据可以同时传递到参数和主体中。哪些参数是必需的以及它们被传递的位置，再次由
    API 的语法确定。
- en: More About API Responses
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多关于 API 响应的信息
- en: As you saw in the ip-api.com example at the beginning of the chapter, an important
    feature of APIs is that they have well-formatted responses. The most common types
    of response formatting are *eXtensible Markup Language* (XML) and *JavaScript
    Object Notation* (JSON).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在本章开头看到的 ip-api.com 示例中所见，API 的一个重要特性是它们具有良好格式化的响应。最常见的响应格式包括 *可扩展标记语言*（XML）和
    *JavaScript 对象表示法*（JSON）。
- en: 'In recent years, JSON has become vastly more popular than XML for a couple
    of major reasons. First, JSON files are generally smaller than well-designed XML
    files. Compare, for example, the following XML data, which clocks in at 98 characters:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，JSON 比 XML 更受欢迎的原因有几个主要因素。首先，良好设计的 XML 文件通常比 JSON 文件更小。例如，比较以下这段包含 98 个字符的
    XML 数据：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And now look at the same data in JSON:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看相同的 JSON 数据：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is only 73 characters, or a whopping 36% smaller than the equivalent XML.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅有 73 个字符，比等效的 XML 小了整整 36%。
- en: 'Of course, one could argue that the XML could be formatted like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有人可能会争辩说 XML 可以这样格式化：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: But this is considered bad practice because it doesn’t support deep nesting
    of data. Regardless, it still requires 71 characters, about the same length as
    the equivalent JSON.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但这被认为是一种不良做法，因为它不支持数据的深度嵌套。尽管如此，它仍然需要 71 个字符，大约与等效的 JSON 一样长。
- en: Another reason JSON is quickly becoming more popular than XML is due to a shift
    in web technologies. In the past, it was more common for a server-side script
    such as PHP or .NET to be on the receiving end of an API. Nowadays, it is likely
    that a framework, such as Angular or Backbone, will be sending and receiving API
    calls. Server-side technologies are somewhat agnostic as to the form in which
    their data comes. But JavaScript libraries like Backbone find JSON easier to handle.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 之所以比 XML 更受欢迎的另一个原因是由于 Web 技术的变化。过去，接收 API 的一端通常是服务器端脚本，如 PHP 或 .NET。如今，像
    Angular 或 Backbone 这样的框架可能会发送和接收 API 调用。服务器端技术对数据的形式有些中立。但像 Backbone 这样的 JavaScript
    库更容易处理 JSON。
- en: Although APIs are typically thought of as having either an XML response or a
    JSON response, anything is possible. The response type of the API is limited only
    by the imagination of the programmer who created it. CSV is another typical response
    output (as seen in the ip-api.com example). Some APIs may even be designed to
    generate files. A request may be made to a server to generate an image with some
    particular text overlaid on it or to request a particular XLSX or PDF file.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管API通常被认为具有XML响应或JSON响应，但任何事情都有可能。API的响应类型仅受其创建者想象力的限制。CSV是另一种典型的响应输出（如在ip-api.com示例中看到的）。某些API甚至可能设计用于生成文件。可以向服务器发送请求以生成带有特定文本覆盖的图像或请求特定的XLSX或PDF文件。
- en: 'Some APIs return no response at all. For example, if you are making a request
    to a server to create a new blog post comment, it may return only an HTTP response
    code 200, meaning “I posted the comment; everything is great!” Others may return
    a minimal response like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有些API根本不返回任何响应。例如，如果您正在向服务器发出请求以创建新的博客文章评论，则它可能仅返回HTTP响应代码200，意味着“我发布了评论；一切都很好！”其他可能返回类似这样的最小响应：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If an error occurs, you may get a response like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生错误，可能会得到这样的响应：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Or if the API is not particularly well configured, you may get a nonparsable
    stack trace or some plain English text. When making a request to an API, it’s
    usually wise to first check that the response you get is actually JSON (or XML,
    or CSV, or whatever format you’re expecting back).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果API配置不是特别好，您可能会得到一个无法解析的堆栈跟踪或一些简单的英文文本。在向API发出请求时，通常最明智的做法是首先检查您收到的响应是否实际上是JSON（或XML、CSV或您期望返回的任何其他格式）。
- en: Parsing JSON
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析JSON
- en: In this chapter, you’ve looked at various types of APIs and how they function,
    and you’ve looked at sample JSON responses from these APIs. Now let’s look at
    how to parse and use this information.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经看过各种类型的API及其功能，并查看了这些API的示例JSON响应。现在让我们看看如何解析和使用这些信息。
- en: 'At the beginning of the chapter you saw the example of the ip-api.com  API,
    which resolves IP addresses to physical addresses:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头，您看到了ip-api.com API的示例，该API将IP地址解析为物理地址：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can take the output of this request and use Python’s JSON-parsing functions
    to decode it:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Python的JSON解析函数解码此请求的输出：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This prints the country code for the IP address 50.78.253.58.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印IP地址`50.78.253.58`的国家代码。
- en: The JSON parsing library used is part of Python’s core library. Just type in
    `import json` at the top, and you’re all set! Unlike many languages that might
    parse JSON into a special JSON object or JSON node, Python uses a more flexible
    approach and turns JSON objects into dictionaries, JSON arrays into lists, JSON
    strings into strings, and so forth. In this way, it is extremely easy to access
    and manipulate values stored in JSON.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Python使用的JSON解析库是Python核心库的一部分。只需在顶部输入`import json`，一切就搞定了！与许多语言不同，可能将JSON解析为特殊的JSON对象或JSON节点，Python使用了一种更灵活的方法，将JSON对象转换为字典，将JSON数组转换为列表，将JSON字符串转换为字符串等等。这样一来，访问和操作存储在JSON中的值就变得非常容易了。
- en: 'The following gives a quick demonstration of how Python’s JSON library handles
    the values that might be encountered in a JSON string:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下快速演示了Python的JSON库如何处理可能在JSON字符串中遇到的值：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is the output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Line 1 is a list of dictionary objects, line 2 is a dictionary object, line
    3 is an integer (the sum of the integers accessed in the dictionaries), and line
    4 is a string.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第1行是字典对象的列表，第2行是字典对象，第3行是整数（访问字典中的整数的总和），第4行是字符串。
- en: Undocumented APIs
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未记录的API
- en: So far in this chapter, we’ve discussed only APIs that are documented. Their
    developers intend them to be used by the public, publish information about them,
    and assume that the APIs will be used by other developers. But the vast majority
    of APIs don’t have any published documentation at all.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们只讨论了已记录的API。它们的开发人员打算让它们被公众使用，发布有关它们的信息，并假设API将被其他开发人员使用。但是绝大多数API根本没有任何已发布的文档。
- en: But why would you create an API without any public documentation? As mentioned
    in the beginning of this chapter, it all has to do with JavaScript.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么要创建没有任何公共文档的API呢？正如本章开头提到的，这一切都与JavaScript有关。
- en: 'Traditionally, the web servers for dynamic websites had several tasks whenever
    a user requested a page:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，动态网站的Web服务器在用户请求页面时有几个任务：
- en: Handle `GET` requests from users requesting a page of a website
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理用户请求网站页面的`GET`请求
- en: Retrieve the data from the database that appears on that page
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从出现在该页面上的数据库中检索数据
- en: Format the data into the HTML template for the page
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为页面的HTML模板格式化数据
- en: Send that formatted HTML to the user
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将格式化后的HTML发送给用户
- en: As JavaScript frameworks became more ubiquitous, many of the HTML creation tasks
    handled by the server moved into the browser. The server might send a hardcoded
    HTML template to the user’s browser, but separate Ajax requests would be made
    to load the content and place it in the correct slots in that HTML template. All
    this would happen on the browser/client side.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 随着JavaScript框架的普及，许多由服务器处理的HTML创建任务移至了浏览器端。服务器可能会向用户的浏览器发送一个硬编码的HTML模板，但是会发起单独的Ajax请求来加载内容，并将其放置在HTML模板的正确位置。所有这些操作都会在浏览器/客户端上进行。
- en: This was initially a problem for web scrapers. They were accustomed to making
    a request for an HTML page and getting back exactly that—an HTML page with all
    of the content already in place. Instead, they now got an HTML template without
    any content.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这最初对Web爬虫构成了问题。他们习惯于请求一个HTML页面，并返回完全相同的内容已就绪的HTML页面。但是，现在他们得到的是一个HTML模板，没有任何内容。
- en: Selenium was used to solve this problem. Now the programmer’s web scraper could
    become the browser, request the HTML template, execute any JavaScript, allow all
    the data to load in its place, and only *then* scrape the page for data. Because
    the HTML was all loaded, it was essentially reduced to a previously solved problem—the
    problem of parsing and formatting existing HTML.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium用于解决这个问题。现在程序员的网络爬虫可以变成浏览器，请求HTML模板，执行任何JavaScript，允许所有数据加载到位，然后仅*然后*再爬取页面数据。因为HTML已经全部加载，它基本上变成了一个先前解决过的问题——解析和格式化现有的HTML问题。
- en: However, because the entire content management system (that used to reside only
    in the web server) had essentially moved to the browser client, even the simplest
    websites could balloon into several megabytes of content and a dozen HTTP requests.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于整个内容管理系统（原本只存在于Web服务器中）基本上已经移至浏览器客户端，即使是最简单的网站也可能膨胀到数兆字节的内容和十几个HTTP请求。
- en: 'In addition, when Selenium is used, all of the “extras” that the user doesn’t
    necessarily care about are loaded: calls to tracking programs, loading sidebar
    ads, calls to tracking programs for the sidebar ads. Images, CSS, third-party
    font data—all of it needs to be loaded. This may seem great when you’re using
    a browser to browse the web, but if you’re writing a web scraper that needs to
    move fast, collect specific data, and place the lowest possible load on the web
    server, you can be loading a hundred times more data than you need.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当使用Selenium时，所有用户可能不关心的“额外内容”都会被加载：调用跟踪程序，加载侧边栏广告，调用侧边栏广告的跟踪程序。图像、CSS、第三方字体数据——所有这些都需要加载。当您使用浏览器浏览网页时，这可能看起来很好，但是如果您正在编写一个需要快速移动、收集特定数据并尽可能减少对Web服务器负载的网络爬虫，则可能加载的数据量要比您需要的数据多100倍。
- en: 'But there’s a silver lining to all of this JavaScript, Ajax, and web modernization:
    because servers are no longer formatting the data into HTML, they often act as
    thin wrappers around the database itself. This thin wrapper simply extracts data
    from the database and returns it to the page via an API.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，所有这些JavaScript、Ajax和Web现代化都有其积极的一面：因为服务器不再将数据格式化为HTML，它们通常只是作为数据库本身的薄包装。这个薄包装只是从数据库中提取数据，并通过API返回到页面中。
- en: Of course, these APIs aren’t meant to be used by anyone or anything besides
    the web page itself, and so developers leave them undocumented and assume (or
    hope) that no one will notice them. But they do exist.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些API并不打算被除了网页本身之外的任何人或任何东西使用，因此开发人员将它们未记录，并假设（或希望）没有人会注意到它们。但是它们确实存在。
- en: The American retail giant target.com, for example, loads all of its search results
    via JSON. You can search for a product on their site by visiting [*https://www.target.com/s?searchTerm=web%20scraping%20with%20python*](https://www.target.com/s?searchTerm=web%20scraping%20with%20python).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，美国零售巨头target.com通过JSON加载其所有搜索结果。您可以通过访问[*https://www.target.com/s?searchTerm=web%20scraping%20with%20python*](https://www.target.com/s?searchTerm=web%20scraping%20with%20python)在他们的网站上搜索产品。
- en: 'If you scrape this page using urllib or the Requests library, you won’t find
    any search results. These are loaded separately via an API call to the URL:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用urllib或Requests库来爬取此页面，您将找不到任何搜索结果。这些结果是通过对URL的API调用单独加载的：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Because Target’s API requires a key for each request, and those API keys time
    out, I recommend that you try this out yourself and see the JSON results.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Target的API每个请求都需要一个密钥，并且这些API密钥会超时，我建议你自己试一试并查看JSON结果。
- en: You could, of course, use Selenium to load all the search results and parse
    the resulting HTML. However, you would be making about 260 requests and transferring
    megabytes of data with each search. Using the API directly, you make only one
    request and transfer approximately only the 10 kb of nicely formatted data that
    you need.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以使用Selenium加载所有搜索结果并解析生成的HTML。不过，每次搜索将需要进行约260次请求并传输数兆字节的数据。直接使用API，你只需发出一次请求并传输大约只有你所需的10
    KB精美格式的数据。
- en: Finding Undocumented APIs
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找未记录的API
- en: 'You’ve used the Chrome inspector in previous chapters to examine the contents
    of an HTML page, but now you’ll use it for a slightly different purpose: to examine
    the requests and responses of the calls that are used to construct that page.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，你使用Chrome检查器来检查HTML页面的内容，但现在你将以稍微不同的目的使用它：来检查用于构建页面的调用的请求和响应。
- en: To do this, open the Chrome inspector window and click the Network tab, shown
    in [Figure 15-1](#chromeinspect).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请打开Chrome检查器窗口，点击Network选项卡，如图[15-1](#chromeinspect)所示。
- en: '![](assets/wsp3_1501.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/wsp3_1501.png)'
- en: Figure 15-1\. The Chrome network inspector tool provides a view into all calls
    your browser is making and receiving
  id: totrans-98
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图15-1。Chrome网络检查工具提供了浏览器正在进行和接收的所有调用的视图。
- en: Note that you need to open this window before the page loads. It does not track
    network calls while it’s closed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在页面加载之前需要打开此窗口。关闭窗口时不会跟踪网络调用。
- en: While the page is loading, you’ll see a line appear in real time whenever your
    browser makes a call back to the web server for additional information to render
    the page. This may include an API call.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面加载时，每当浏览器向Web服务器发出调用以获取渲染页面所需的附加信息时，你将实时看到一条线。这可能包括API调用。
- en: Finding undocumented APIs can take a little detective work (to take the detective
    work out of this, see [“Documenting Undocumented APIs”](#documenting_undocumented_apis)),
    especially with larger sites with lots of network calls. Generally, though, you’ll
    know it when you see it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 找到未记录的API可能需要一些侦探工作（为了避免这种侦探工作，请参见[“记录未记录的API”](#documenting_undocumented_apis)），特别是在具有大量网络调用的大型站点中。不过，一般来说，一旦看到它，你就会知道。
- en: 'API calls tend to have several features that are useful for locating them in
    the list of network calls:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: API调用往往具有几个有助于在网络调用列表中定位它们的特征：
- en: They often have JSON or XML in them. You can filter the list of requests by
    using the search/filter field.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们通常包含JSON或XML。你可以使用搜索/过滤字段来过滤请求列表。
- en: With `GET` requests, the URL will contain the parameter values passed to them.
    This will be useful if, for example, you’re looking for an API call that returns
    the results of a search or is loading data for a specific page. Simply filter
    the results with the search term you used, page ID, or other identifying information.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`GET`请求，URL将包含传递给它们的参数值。例如，如果你正在寻找一个API调用，返回搜索结果或加载特定页面的数据，那么这将非常有用。只需用你使用的搜索词、页面ID或其他标识信息来过滤结果。
- en: They will usually be of the type XHR.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们通常是XHR类型。
- en: APIs may not always be obvious, especially in large sites with lots of features
    that may make hundreds of calls while loading a single page. However, spotting
    the metaphorical needle in the haystack becomes much easier with a little practice.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: API可能并不总是显而易见，特别是在具有大量功能的大型网站中，可能在加载单个页面时会进行数百次调用。然而，通过一点实践，就能更轻松地找到草堆中的比喻性针。
- en: Documenting Undocumented APIs
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录未记录的API
- en: After you’ve found an API call being made, it’s often useful to document it
    to some extent, especially if your scrapers will rely heavily on the call. You
    may want to load several pages on the website, filtering for the target API call
    in the inspector console Network tab. By doing this, you can see how the call
    changes from page to page and identify the fields that it accepts and returns.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当你发现正在进行的API调用时，通常有必要至少部分记录它，特别是如果你的爬虫将严重依赖该调用。你可能希望在网站上加载多个页面，在检查器控制台的网络选项卡中过滤目标API调用。通过这样做，你可以看到调用在不同页面之间的变化，并确定它接受和返回的字段。
- en: 'Every API call can be identified and documented by paying attention to the
    following fields:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每个API调用都可以通过关注以下字段来识别和记录：
- en: HTTP method used
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的HTTP方法
- en: Inputs
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入
- en: Path parameters
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径参数
- en: Headers (including cookies)
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标头（包括cookie）
- en: Body content (for `PUT` and `POST` calls)
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正文内容（用于`PUT`和`POST`调用）
- en: Outputs
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出
- en: Response headers (including cookies set)
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应头（包括设置的cookie）
- en: Response body type
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应体类型
- en: Response body fields
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应体字段
- en: Combining APIs with Other Data Sources
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将API与其他数据源结合使用
- en: Although the raison d'être of many modern web applications is to take existing
    data and format it in a more appealing way, I would argue that this isn’t an interesting
    thing to do in most instances. If you’re using an API as your only data source,
    the best you can do is merely copy someone else’s database that already exists
    and which is, essentially, already published. What can be far more interesting
    is to take two or more data sources and combine them in a novel way or use an
    API as a tool to look at scraped data from a new perspective.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多现代Web应用程序的存在理由是获取现有数据并以更吸引人的方式格式化它，但我认为在大多数情况下这并不是一个有趣的事情。如果你只使用API作为数据源，那么你所能做的就是简单地复制已经存在并基本上已经发布的别人的数据库。更有趣的可能是以新颖的方式结合两个或更多数据源，或者使用API作为一个工具来从新的角度查看抓取的数据。
- en: Let’s look at one example of how data from APIs can be used in conjunction with
    web scraping to see which parts of the world contribute the most to Wikipedia.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，说明如何将API中的数据与网络抓取结合使用，以查看哪些地区对维基百科贡献最多。
- en: If you’ve spent much time on Wikipedia, you’ve likely come across an article’s
    revision history page, which displays a list of recent edits. If users are logged
    in to Wikipedia when they make the edit, their username is displayed. If they
    are not logged in, their IP address is recorded, as shown in [Figure 15-2](#wiki_history).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在维基百科上花了很多时间，你可能已经见过文章的修订历史页面，显示了最近的编辑列表。如果用户在编辑时已登录维基百科，会显示他们的用户名。如果未登录，则记录其IP地址，如[图 15-2](#wiki_history)所示。
- en: '![Alt Text](assets/wsp3_1502.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![Alt Text](assets/wsp3_1502.png)'
- en: Figure 15-2\. The IP address of an anonymous editor on the revision history
    page for Wikipedia’s Python entry
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 15-2\. 维基百科Python条目修订历史页面上匿名编辑者的IP地址
- en: The IP address provided on the history page is 121.97.110.145\. By using the
    ip-api.com API, that IP address is from Quezon, Philippines, as of this writing
    (IP addresses can occasionally shift geographically).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在历史页面上提供的IP地址是121.97.110.145。根据目前的信息，使用ip-api.com API，该IP地址来自菲律宾卡尼洛，菲律宾（IP地址有时会在地理位置上略微变动）。
- en: This information isn’t all that interesting on its own, but what if you could
    gather many points of geographic data about Wikipedia edits and where they occur?
    A few years ago, I did just that and used [Google’s GeoChart library](https://developers.google.com/chart/interactive/docs/gallery/geochart)
    to create an [interesting chart](http://www.pythonscraping.com/pages/wikipedia.html)
    that shows the origins of edits to the English-language Wikipedia, as well as
    the Wikipedias written in other languages ([Figure 15-3](#geochart_library)).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息单独来看并不那么有趣，但是如果你能够收集关于维基百科编辑及其发生地点的许多地理数据，会怎么样呢？几年前，我确实做到了，并使用[Google的GeoChart库](https://developers.google.com/chart/interactive/docs/gallery/geochart)创建了一个[有趣的图表](http://www.pythonscraping.com/pages/wikipedia.html)，展示了对英语维基百科以及其他语言维基百科的编辑来源（[图 15-3](#geochart_library)）。
- en: '![Alt Text](assets/wsp3_1503.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![Alt Text](assets/wsp3_1503.png)'
- en: Figure 15-3\. Visualization of Wikipedia edits created using Google’s GeoChart
    library
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 15-3\. 使用Google的GeoChart库创建的维基百科编辑可视化
- en: 'Creating a basic script that crawls Wikipedia, looks for revision history pages,
    and then looks for IP addresses on those revision history pages isn’t difficult.
    Using modified code from [Chapter 6](ch06.html#c-6), the following script does
    just that:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个基本的脚本来爬取维基百科，查找修订历史页面，然后在这些修订历史页面上查找IP地址并不难。使用修改自[第6章](ch06.html#c-6)的代码，以下脚本正是如此：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This program uses two main functions: `getLinks` (which was also used in [Chapter 6](ch06.html#c-6)),
    and the  new `getHistoryIPs`, which searches for the contents of all links with
    the class `mw-anonuserlink` (indicating an anonymous user with an IP address,
    rather than a username) and returns it as a set.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序使用两个主要函数：`getLinks`（在[第6章](ch06.html#c-6)中也使用过），以及新的`getHistoryIPs`，后者搜索所有带有类`mw-anonuserlink`的链接内容（指示使用IP地址而不是用户名的匿名用户）并将其作为集合返回。
- en: This code also uses a somewhat arbitrary (yet effective for the purposes of
    this example) search pattern to look for articles from which to retrieve revision
    histories. It starts by retrieving the histories of all Wikipedia articles linked
    to by the starting page (in this case, the article on the Python programming language).
    Afterward, it randomly selects a new starting page and retrieves all revision
    history pages of articles linked to by that page. It will continue until it hits
    a page with no links.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码还使用了一个有些任意的（但对于本例来说很有效）搜索模式来查找要检索修订历史记录的文章。它首先检索由起始页面链接到的所有维基百科文章的历史记录（在本例中是关于Python编程语言的文章）。之后，它会随机选择一个新的起始页面，并检索该页面链接到的所有文章的修订历史页面。它会一直持续下去，直到碰到没有链接的页面。
- en: 'Now that you have code that retrieves IP addresses as a string, you can combine
    this with the `getCountry` function from the previous section to resolve these
    IP addresses to countries. You’ll modify `getCountry` slightly to account for
    invalid or malformed IP addresses that result in a 404 Not Found error:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了检索IP地址作为字符串的代码，您可以将其与上一节中的`getCountry`函数结合使用，将这些IP地址解析为国家。您将稍微修改`getCountry`以处理导致404
    Not Found错误的无效或格式不正确的IP地址：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here’s the sample output:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是示例输出：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: More About APIs
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于API的更多信息
- en: This chapter has shown a few ways that modern APIs are commonly used to access
    data on the web, and how those APIs can be used to build faster and more powerful
    web scrapers. If you’re looking to build APIs instead of just using them, or if
    you want to learn more about the theory of their construction and syntax, I recommend [*RESTful
    Web APIs*](http://bit.ly/RESTful-Web-APIs) by Leonard Richardson, Mike Amundsen,
    and Sam Ruby (O’Reilly). This book provides a strong overview of the theory and
    practice of using APIs on the web. In addition, Mike Amundsen has a fascinating
    video series, [*Designing APIs for the Web*](http://oreil.ly/1GOXNhE) (O’Reilly),
    that teaches you how to create your own APIs—a useful thing to know if you decide
    to make your scraped data available to the public in a convenient format.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了现代API通常用于访问网络数据的几种方式，以及这些API如何用于构建更快更强大的网络爬虫。如果您想构建API而不仅仅是使用它们，或者如果您想进一步了解它们的构建和语法理论，我推荐阅读[《RESTful
    Web APIs》](http://bit.ly/RESTful-Web-APIs)，作者是Leonard Richardson、Mike Amundsen和Sam
    Ruby（O’Reilly）。这本书提供了关于在网络上使用API的理论和实践的强大概述。此外，Mike Amundsen还有一系列有趣的视频，[*《Designing
    APIs for the Web》*](http://oreil.ly/1GOXNhE)（O’Reilly），教你如何创建自己的API——如果您决定以方便的格式向公众提供您的抓取数据，这是一个有用的技能。
- en: While some might bemoan the ubiquity of JavaScript and dynamic websites, making
    traditional “grab and parse the HTML page” practices outdated, I, for one, welcome
    our new robot overlords. As dynamic websites rely less on HTML pages for human
    consumption and more on strictly formatted JSON files for HTML consumption, this
    provides a boon for everyone trying to get clean, well-formatted data.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有些人可能对JavaScript和动态网站的无处不在感到惋惜，使得传统的“抓取和解析HTML页面”的做法已经过时，但我对我们的新机器人统治者表示欢迎。随着动态网站对HTML页面的人类消费依赖程度降低，更多地依赖于严格格式化的JSON文件进行HTML消费，这为每个试图获取干净、格式良好的数据的人提供了便利。
- en: The web is no longer a collection of HTML pages with occasional multimedia and
    CSS adornments. It’s a collection of hundreds of file types and data formats,
    whizzing hundreds at a time to form the pages that you consume through your browser.
    The real trick is often to look beyond the page in front of you and grab the data
    at its source.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 网络已不再是偶尔带有多媒体和CSS装饰的HTML页面集合。它是数百种文件类型和数据格式的集合，一次传输数百个，形成您通过浏览器消耗的页面。真正的诀窍通常是超越你面前的页面，抓取其源头的数据。
- en: ^([1](ch15.html#id773-marker)) This API resolves IP addresses to geographic
    locations and is one you’ll be using later in the chapter as well.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch15.html#id773-marker)) 这个API将IP地址解析为地理位置，您稍后在本章中也将使用它。
- en: ^([2](ch15.html#id776-marker)) In reality, many APIs use `POST` requests in
    lieu of `PUT` requests when updating information. Whether a new entity is created
    or an old one is merely updated is often left to how the API request itself is
    structured. However, it’s still good to know the difference, and you will often
    encounter `PUT` requests in commonly used APIs.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch15.html#id776-marker)) 实际上，许多API在更新信息时使用`POST`请求代替`PUT`请求。新实体是创建还是仅更新一个旧实体通常取决于API请求本身的结构。但是，了解区别仍然是很重要的，您经常会在常用API中遇到`PUT`请求。
