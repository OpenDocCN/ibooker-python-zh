- en: Chapter 20\. Serving HTTP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 20 章。提供 HTTP
- en: When a browser (or any other web client) requests a page from a server, the
    server may return either static or dynamic content. Serving dynamic content involves
    server-side web programs generating and delivering content on the fly, often based
    on information stored in a database.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器（或任何其他 Web 客户端）从服务器请求页面时，服务器可以返回静态或动态内容。提供动态内容涉及服务器端 Web 程序根据存储在数据库中的信息动态生成和传递内容。
- en: In the early history of the web, the standard for server-side programming was
    the *Common Gateway Interface* (CGI), which required the server to run a separate
    program each time a client requested dynamic content. Process startup time, interpreter
    initialization, connection to databases, and script initialization add up to measurable
    overhead; CGI did not scale well.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 的早期历史上，服务器端编程的标准是 *通用网关接口*（CGI），它要求服务器在客户端请求动态内容时每次运行一个单独的程序。进程启动时间、解释器初始化、连接数据库和脚本初始化累积起来会带来可衡量的开销；CGI
    的扩展性不佳。
- en: Nowadays, web servers support many server-specific ways to reduce overhead,
    serving dynamic content from processes that can serve for several hits rather
    than starting up a new process per hit. Therefore, we do not cover CGI in this
    book. To maintain existing CGI programs, or better yet, port them to more modern
    approaches, consult the online docs (especially [PEP 594](https://oreil.ly/qNhHr)
    for recommendations) and check out the standard library modules [cgi](https://oreil.ly/h5Fo_)
    (deprecated as of 3.11) and [http.cookies](https://oreil.ly/U4JL9).^([1](ch20.xhtml#ch01fn151))
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，Web 服务器支持许多特定于服务器的方式来减少开销，从可以为多次访问提供动态内容的进程中服务，而不是每次访问都启动新进程。因此，本书不涵盖 CGI。要维护现有的
    CGI 程序，或更好地将它们移植到更现代的方法，请参阅在线文档（特别是 [PEP 594](https://oreil.ly/qNhHr) 的建议）并查看标准库模块
    [cgi](https://oreil.ly/h5Fo_)（自 3.11 版起已弃用）和 [http.cookies](https://oreil.ly/U4JL9)。^([1](ch20.xhtml#ch01fn151))
- en: 'HTTP has become even more fundamental to distributed systems design with the
    emergence of systems based on [microservices](https://microservices.io), offering
    a convenient way to transport between processes the JSON content that is frequently
    used. There are thousands of publicly available HTTP data APIs on the internet.
    While HTTP’s principles remain almost unchanged since its inception in the mid-1990s,
    it has been significantly enhanced over the years to extend its capabilities.^([2](ch20.xhtml#ch01fn152))
    For a thorough grounding with excellent reference materials we recommend [*HTTP:
    The Definitive Guide*](https://learning.oreilly.com/library/view/http-the-definitive/1565925092)
    by David Gourley et al. (O’Reilly).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '随着基于 [微服务](https://microservices.io) 的系统的出现，HTTP 对于分布式系统设计变得更加基础，提供了一种方便的方式来传输经常使用的
    JSON 内容之间的数据。互联网上有成千上万的公共可用 HTTP 数据 API。虽然 HTTP 的原则自其于 1990 年代中期问世以来几乎未发生变化，但多年来已显著增强其功能以扩展其能力。^([2](ch20.xhtml#ch01fn152))
    对于深入学习并具有优秀参考资料，我们推荐阅读 [*HTTP: The Definitive Guide*](https://learning.oreilly.com/library/view/http-the-definitive/1565925092)（David
    Gourley 等著，O’Reilly）。'
- en: http.server
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: http.server
- en: Python’s standard library includes a module containing the server and handler
    classes to implement a simple HTTP server.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的标准库包括一个模块，其中包含服务器和处理程序类，用于实现简单的 HTTP 服务器。
- en: 'You can run this server from the command line by just entering:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过命令行直接运行此服务器：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'By default, the server listens on all interfaces and provides access to the
    files in the current directory. One author uses this as a simple means for file
    transfer: start up a Python http.server in the file directory on the source system,
    and then copy files to the destination using a utility such as wget or curl.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，服务器监听所有接口，并提供对当前目录中文件的访问。一位作者将其用作文件传输的简单方式：在源系统的文件目录中启动 Python http.server，然后使用
    wget 或 curl 等工具将文件复制到目标系统。
- en: http.server has very limited security features. You can find further information
    on http.server in the [online docs](https://oreil.ly/5ckN2). For production use,
    we recommend that you use one of the frameworks mentioned in the following sections.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: http.server 的安全功能非常有限。你可以在[在线文档](https://oreil.ly/5ckN2)中找到有关 http.server 的更多信息。对于生产使用，我们建议您使用以下章节中提到的框架之一。
- en: WSGI
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WSGI
- en: Python’s *Web Server Gateway Interface* (WSGI) is the standard way for all modern
    Python web development frameworks to interface with underlying web servers or
    gateways. WSGI is not meant for direct use by your application programs; rather,
    you code your programs using any one of many higher-abstraction frameworks, and
    the framework, in turn, uses WSGI to talk to the web server.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python的*Web服务器网关接口*（WSGI）是所有现代Python Web开发框架与底层Web服务器或网关交互的标准方式。WSGI不适用于你的应用程序直接使用；相反，你使用众多高级抽象框架之一编写你的程序，然后框架使用WSGI与Web服务器交互。
- en: You need to care about the details of WSGI only if you’re implementing the WSGI
    interface for a web server that doesn’t already provide it (should any such server
    exist), or if you’re building a new Python web framework.^([3](ch20.xhtml#ch01fn153))
    In that case, study the WSGI [PEP](https://oreil.ly/CALIJ), the docs for the standard
    library package [wsgiref](https://oreil.ly/9HmUO), and the [archive](https://oreil.ly/UWcaq)
    of [WSGI.org](http://WSGI.org).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在为尚未提供WSGI接口的Web服务器实现WSGI接口（如果有这样的服务器存在的话），或者如果你正在构建一个新的Python Web框架时，你才需要关注WSGI的细节。^([3](ch20.xhtml#ch01fn153))在这种情况下，你需要研究WSGI
    [PEP](https://oreil.ly/CALIJ)，标准库包[wsgiref](https://oreil.ly/9HmUO)的文档，以及[WSGI.org](http://WSGI.org)的[存档](https://oreil.ly/UWcaq)。
- en: 'A few WSGI concepts may be important to you if you use lightweight frameworks
    (i.e., ones that match WSGI closely). WSGI is an *interface*, and that interface
    has two sides: the *web server/gateway* side, and the *application/framework*
    side.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用轻量级框架（即与WSGI紧密匹配的框架），一些WSGI概念可能对你很重要。WSGI是一个*接口*，这个接口有两个方面：*Web服务器/网关*方面和*应用程序/框架*方面。
- en: The framework side’s job is to provide a *WSGI application* object, a callable
    object (often the instance of a class with a __call__ special method, but that’s
    an implementation detail) respecting conventions in the PEP, and to connect the
    application object to the server by whatever means the specific server documents
    (often a few lines of code, or configuration files, or just a convention such
    as naming the WSGI application object application as a top-level attribute in
    a module). The server calls the application object for each incoming HTTP request,
    and the application object responds appropriately so that the server can form
    the outgoing HTTP response and send it on—all according to said conventions. A
    framework, even a lightweight one, shields you from such details (except that
    you may have to instantiate and connect the application object, depending on the
    specific server).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 框架的工作是提供一个*WSGI应用*对象，一个可调用对象（通常是一个具有__call__特殊方法的类的实例，但这是一个实现细节），符合PEP中的约定，并通过特定服务器文档中指定的任何手段连接应用程序对象（通常是几行代码，或配置文件，或只是一个约定，例如将WSGI应用对象命名为模块中的顶级属性application）。服务器为每个传入的HTTP请求调用应用程序对象，应用程序对象适当地响应，以便服务器可以形成传出的HTTP响应并将其发送出去——都按照上述约定进行。一个框架，即使是一个轻量级的框架，也会屏蔽这些细节（除非你可能需要根据具体的服务器来实例化和连接应用程序对象）。
- en: WSGI Servers
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WSGI服务器
- en: An extensive list of servers and adapters you can use to run WSGI frameworks
    and applications (for development and testing, in production web setups, or both)
    is available [online](https://oreil.ly/7De2i)—extensive, but just partial. For
    example, it does not mention that Google App Engine’s Python runtime is also a
    WSGI server, ready to dispatch WSGI apps as directed by the *app.yaml* configuration
    file.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[线上](https://oreil.ly/7De2i)找到一个广泛的服务器和适配器列表，用于运行WSGI框架和应用程序（用于开发和测试，在生产Web设置中，或两者兼而有之）——这是一个广泛的列表，但仅仅是部分列表。例如，它没有提到Google
    App Engine的Python运行时也是一个WSGI服务器，准备根据*app.yaml*配置文件指示调度WSGI应用。
- en: 'If you’re looking for a WSGI server to use for development, or to deploy in
    production behind, say, an Nginx-based load balancer, you should be happy, at
    least on Unix-like systems, with [Gunicorn](https://gunicorn.org): pure Python
    goodness, supporting nothing but WSGI, very lightweight. A worthy (also pure Python
    and WSGI-only) alternative, currently with better Windows support, is [Waitress](https://oreil.ly/bs4IW).
    If you need richer features (such as support for Perl and Ruby as well as Python,
    and many other forms of extensibility), consider the bigger, more complex [uWSGI](https://oreil.ly/DwiOe).^([4](ch20.xhtml#ch01fn154))'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找一个用于开发或部署在生产环境中的 WSGI 服务器，例如在基于 Nginx 的负载均衡器后面，那么你应该会对 [Gunicorn](https://gunicorn.org)
    感到满意：纯 Python 的良好支持，仅支持 WSGI，非常轻量级。一个值得考虑的（也是纯 Python 和仅支持 WSGI 的）替代方案，目前在 Windows
    上支持更好的是 [Waitress](https://oreil.ly/bs4IW)。如果你需要更丰富的功能（例如对 Perl 和 Ruby 的支持以及许多其他形式的可扩展性），请考虑更大、更复杂的
    [uWSGI](https://oreil.ly/DwiOe)^([4](ch20.xhtml#ch01fn154))。
- en: WSGI also has the concept of *middleware*, a subsystem that implements both
    the server and application sides of WSGI. A middleware object “wraps” a WSGI application;
    can selectively alter requests, environments, and responses; and presents itself
    to the server as “the application.” Multiple layers of wrappers are allowed and
    common, forming a “stack” of middleware offering services to the actual application-level
    code. If you want to write a cross-framework middleware component, then you may,
    indeed, need to become a WSGI expert.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: WSGI 还有 *middleware* 的概念，这是一个实现了 WSGI 服务器和应用程序两端的子系统。中间件对象“包装”了一个 WSGI 应用程序；可以选择性地更改请求、环境和响应；并向服务器呈现自身为“应用程序”。允许并且常见的是多层包装，形成为实际应用级别代码提供服务的中间件“堆栈”。如果你想编写一个跨框架的中间件组件，那么你可能确实需要成为一个
    WSGI 专家。
- en: ASGI
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ASGI
- en: If you’re into asynchronous Python (which we don’t cover in this book), you
    should definitely investigate [ASGI](https://oreil.ly/ceEuZ), which sets out to
    do pretty much what WSGI does, but asynchronously. As is usually the case for
    asynchronous programs in a networking environment, it can offer greatly improved
    performance, albeit (arguably) with some increase in cognitive load for the developer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对异步 Python（本书不涵盖）感兴趣，你应该一定要调查 [ASGI](https://oreil.ly/ceEuZ)，它旨在做的基本上与 WSGI
    做的一样，但是是异步的。通常情况下，在网络环境中进行异步编程时，它可以提供大大提高的性能，尽管（有人认为）会增加开发者的认知负担。
- en: Python Web Frameworks
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python Web 框架
- en: For a survey of Python web frameworks, see the Python [wiki page](https://oreil.ly/Me-Ig).
    It’s authoritative since it’s on the official [Python.org](http://Python.org)
    website, and it’s community curated, so it stays up-to-date as time goes by. The
    wiki lists and points to dozens of frameworks^([5](ch20.xhtml#ch01fn155)) that
    it identifies as “active,” plus many more it identifies as “discontinued/inactive.”
    In addition, it points to separate wiki pages about Python content management
    systems, web servers, and web components and libraries thereof.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Python web 框架的调查，请参阅 Python [维基页面](https://oreil.ly/Me-Ig)。它权威性的原因在于它位于官方
    [Python.org](http://Python.org) 网站上，并且是由社区共同维护的，因此随着时间的推移始终保持更新。该维基列出并指向数十个被识别为“活跃”的框架^([5](ch20.xhtml#ch01fn155))，以及被识别为“已停用/不活跃”的许多其他框架。此外，它还指向了关于
    Python 内容管理系统、Web 服务器以及相关 Web 组件和库的单独维基页面。
- en: “Full-Stack” Versus “Lightweight” Frameworks
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “全栈”与“轻量级”框架
- en: Roughly speaking, Python web frameworks can be classified as being either *full-stack*
    (trying to supply all the functionality you may need to build a web application)
    or *lightweight* (supplying just a handy interface to web serving itself, and
    letting you pick and choose your own favorite components for tasks such as interfacing
    to databases and templating). Of course, like all taxonomies, this one is imprecise
    and incomplete, and requires value judgments; however, it’s one way to start making
    sense of the many Python web frameworks.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 大致来说，Python web 框架可以被分类为 *全栈*（试图提供构建 Web 应用程序所需的所有功能）或 *轻量级*（仅提供与 Web 服务本身的便利接口，并让您选择自己喜欢的组件用于诸如与数据库接口和模板化等任务）。当然，像所有分类法一样，这个分类法并不精确和完整，并且需要价值判断；然而，这是开始理解众多
    Python web 框架的一种方式。
- en: In this book, we do not thoroughly cover any full-stack frameworks—each is far
    too complex. Nevertheless, one of them might be the best approach for your specific
    applications, so we do mention a few of the most popular ones, and recommend that
    you check out their websites.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们不深入研究任何全栈框架——每一个都太复杂了。尽管如此，其中之一可能是您特定应用的最佳选择，因此我们提到了一些最流行的框架，并建议您访问它们的网站。
- en: A Few Popular Full-Stack Frameworks
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 几种流行的全栈框架
- en: By far the most popular full-stack framework is [Django](https://oreil.ly/JLnV5),
    which is sprawling and extensible. Django’s so-called *applications* are in fact
    reusable subsystems, while what’s normally called “an application” Django calls
    a *project*. Django requires its own unique mindset, but offers enormous power
    and functionality in return.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止最流行的全栈框架是[Django](https://oreil.ly/JLnV5)，它庞大而可扩展。Django所谓的*应用程序*实际上是可重用的子系统，而Django称之为*项目*的通常被称为“应用程序”。Django需要其独特的思维模式，但换取巨大的力量和功能。
- en: 'An excellent alternative is [web2py](http://www.web2py.com): it’s just about
    as powerful, easier to learn, and well known for its dedication to backward compatibility
    (if it keeps up its great track record, any web2py application you code today
    will keep working far into the future). web2py also has outstanding documentation.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的选择是[web2py](http://www.web2py.com)：它几乎和Django一样强大，更易学，并因其对向后兼容性的奉献而闻名（如果它保持其良好的记录，今天编写的任何web2py应用程序将长期保持运行）。web2py还有出色的文档。
- en: A third worthy contender is [TurboGears](https://turbogears.org), which starts
    out as a lightweight framework but achieves “full-stack” status by fully integrating
    other, independent third-party projects for the various other functionalities
    needed in most web apps, such as database interfacing and templating, rather than
    designing its own. Another somewhat philosophically similar “light but rich” framework
    is [Pyramid](https://trypyramid.com).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个值得一提的是[TurboGears](https://turbogears.org)，它开始时是一个轻量级框架，但通过完全集成其他独立的第三方项目来实现“全栈”状态，以满足大多数Web应用程序中所需的数据库接口和模板等各种功能，而不是设计自己的功能。另一个在哲学上类似的“轻量但功能丰富”的框架是[Pyramid](https://trypyramid.com)。
- en: Considerations When Using Lightweight Frameworks
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用轻量级框架时的考虑事项
- en: Whenever you use a lightweight framework, if you need any database, templating,
    or other functionality not strictly related to HTTP, you’ll be picking and choosing
    separate components for that purpose. However, the lighter in weight your framework,
    the more components you will need to understand and integrate, for purposes such
    as authenticating a user or maintaining state across web requests by a given user.
    Many WSGI middleware packages can help you with such tasks. Some excellent ones
    are quite focused—for example, [Oso](https://oreil.ly/zyXl0) for access control,
    [Beaker](https://oreil.ly/v8LxQ) for maintaining state in the form of lightweight
    sessions of any one of several kinds, and so forth.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您使用轻量级框架时，如果您需要任何数据库、模板或其他与HTTP不严格相关的功能，您将需要挑选和集成单独的组件来实现。然而，框架越轻量级，您就需要理解和集成的组件越多，例如对用户进行身份验证或通过给定用户的Web请求保持状态。许多WSGI中间件包可以帮助您完成这些任务。一些优秀的中间件集中于特定任务——例如，[Oso](https://oreil.ly/zyXl0)用于访问控制，[Beaker](https://oreil.ly/v8LxQ)用于以轻量级会话形式维护状态等等。
- en: However, when we (the authors of this book) require good WSGI middleware for
    just about any purpose, we almost invariably first check [Werkzeug](https://oreil.ly/lF9H3),
    a collection of such components that’s amazing in breadth and quality. We don’t
    cover Werkzeug in this book (just as we don’t cover other middleware), but we
    recommend it highly (Werkzeug is also the foundation on which Flask—our favorite
    lightweight framework, which we do cover later in this chapter—is built).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们（本书的作者）需要用于几乎任何目的的良好WSGI中间件时，我们几乎总是首先检查[Werkzeug](https://oreil.ly/lF9H3)，这是一个令人惊叹的组件集合，具有广泛的应用和高质量。我们在本书中不涵盖Werkzeug（就像我们不涵盖其他中间件一样），但我们强烈推荐它（Werkzeug也是Flask的基础，Flask是我们最喜欢的轻量级框架，在本章后面我们会详细介绍）。
- en: You may notice that properly using lightweight frameworks requires you to understand
    HTTP (in other words, to know what you’re doing), while a full-stack framework
    tries to lead you by the hand and have you do the right thing without really needing
    to understand how or why it is right—at the cost of time and resources, and of
    accepting the full-stack framework’s conceptual map and mindset. The authors of
    this book are enthusiasts of the knowledge-heavy, resources-light approach of
    lightweight frameworks, but we acknowledge that there are many situations where
    the rich, heavy, all-embracing full-stack frameworks are more appropriate. To
    each their own!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到，正确使用轻量级框架要求你理解HTTP（换句话说，知道你在做什么），而全栈框架试图手把手地指导你做正确的事情，而不需要真正理解为什么或如何是正确的——这是以时间和资源为代价，并接受全栈框架的概念图和思维方式。本书的作者们热衷于知识密集、资源轻的轻量级框架方法，但我们承认，在许多情况下，富有、重量级、全面性的全栈框架更为合适。各取所需！
- en: A Few Popular Lightweight Frameworks
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 几个流行的轻量级框架
- en: 'As mentioned, Python has multiple frameworks, including many lightweight ones.
    We cover two of the latter here: the popular, general-purpose Flask, and API-centric
    FastAPI.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Python有多个框架，包括许多轻量级框架。我们在这里介绍了两个后者：流行的通用框架Flask和面向API的FastAPI。
- en: Flask
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Flask
- en: The most popular Python lightweight framework is [Flask](https://oreil.ly/oCnoc),
    a third-party pip-installable package. Although lightweight, it includes a development
    server and debugger, and it explicitly relies on other well-chosen packages such
    as Werkzeug for middleware and [Jinja](https://oreil.ly/-HdvE) for templating
    (both packages were originally authored by Armin Ronacher, the author of Flask).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的Python轻量级框架是[Flask](https://oreil.ly/oCnoc)，一个第三方可通过pip安装的包。尽管轻巧，它包含了开发服务器和调试器，并且显式地依赖于其他精选的包，如Werkzeug用于中间件和[Jinja](https://oreil.ly/-HdvE)用于模板（这两个包最初由Flask的作者Armin
    Ronacher编写）。
- en: In addition to the project website (which includes rich, detailed docs), look
    at the [sources on GitHub](https://oreil.ly/v_YkH) and the [PyPI entry](https://oreil.ly/-76be).
    If you want to run Flask on Google App Engine (locally on your computer, or on
    Google’s servers at *[appspot.com](http://appspot.com)*), Dough Mahugh’s [Medium
    article](https://oreil.ly/bs0JC) can be quite handy.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除了项目网站（包含丰富详细的文档），还可以查看[GitHub上的源代码](https://oreil.ly/v_YkH)和[PyPI条目](https://oreil.ly/-76be)。如果你想在Google
    App Engine上运行Flask（在本地计算机上或在Google的服务器上*[appspot.com](http://appspot.com)*），Dough
    Mahugh的[Medium文章](https://oreil.ly/bs0JC)可能非常方便。
- en: 'We also highly recommend Miguel Grinberg’s book [*Flask Web Development*](https://learning.oreilly.com/library/view/flask-web-development/9781491991725/)
    (O’Reilly): although the second edition is rather dated (almost four years old
    at the time of this writing), it still provides an excellent foundation, on top
    of which you’ll have a far easier time learning the latest new additions.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还强烈推荐Miguel Grinberg的书籍[*Flask Web Development*](https://learning.oreilly.com/library/view/flask-web-development/9781491991725/)（O'Reilly）：尽管第二版在撰写本文时已经过时（几乎四年），但它仍然为你提供了一个优秀的基础，使你更容易学习最新的新增内容。
- en: 'The main class supplied by the flask package is named Flask. An instance of
    flask.Flask, besides being a WSGI application itself, also wraps a WSGI application
    as its wsgi_app property. When you need to further wrap the WSGI app in some WSGI
    middleware, use the idiom:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Flask包提供的主要类被命名为Flask。一个flask.Flask的实例，除了作为一个WSGI应用程序外，还通过其wsgi_app属性包装了一个WSGI应用程序。当你需要在WSGI中间件中进一步包装WSGI应用程序时，请使用以下习惯用法：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When you instantiate flask.Flask, always pass it as the first argument the application
    name (often just the __name__ special variable of the module where you instantiate
    it; if you instantiate it from within a package, usually in *__init__.py*, __name__.partition('.')[0]
    works). Optionally, you can also pass named parameters such as static_folder and
    template_folder to customize where static files and Jinja templates are found;
    however, that’s rarely needed—the default values (subfolders named *static* and
    *templates*, respectively, located in the same folder as the Python script that
    instantiates flask.Flask) make perfect sense.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当你实例化flask.Flask时，始终将应用程序名称作为第一个参数传递（通常只是模块中__name__特殊变量的值；如果你在一个包内实例化它，通常在*\_\_init\_\_.py*中，使用__name__.partition('.')[0]也可以）。可选地，你还可以传递命名参数，如static_folder和template_folder来自定义静态文件和Jinja模板的位置；但这很少需要——默认值（分别位于与实例化flask.Flask的Python脚本相同的文件夹中的子文件夹*static*和*templates*）非常合理。
- en: An instance *app* of flask.Flask supplies more than 100 methods and properties,
    many of them decorators to bind functions to *app* in various roles, such as *view
    functions* (serving HTTP verbs on a URL) or *hooks* (letting you alter a request
    before it’s processed or a response after it’s built, handling errors, and so
    forth).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: flask.Flask 的实例 *app* 提供了超过 100 个方法和属性，其中许多是装饰器，用于将函数绑定到 *app* 中的各种角色，例如 *视图函数*（在
    URL 上提供 HTTP 动词）或 *钩子*（在处理请求前或构建响应后修改请求、处理错误等）。
- en: flask.Flask takes just a few parameters at instantiation (and the ones it takes
    are not ones that you usually need to compute in your code), and it supplies decorators
    you’ll want to use as you define, for example, view functions. Thus, the normal
    pattern in flask is to instantiate *app* early in your main script, just as your
    application is starting up, so that the app’s decorators, and other methods and
    properties, are available as you **def** view functions and so on.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: flask.Flask 在实例化时只需几个参数（而且这些参数通常不需要在你的代码中计算），它提供了一些装饰器，你在定义例如视图函数时会用到。因此，在 Flask
    中的正常模式是在你的主脚本早期实例化 *app*，就像你的应用程序启动时一样，这样 app 的装饰器和其他方法属性在你 **def** 视图函数等时就可用了。
- en: 'Since there is a single global *app* object, you may wonder how thread-safe
    it can be to access, mutate, and rebind *app*’s properties and attributes. Not
    to worry: the names you see are actually just proxies to actual objects living
    in the *context* of a specific request, in a specific thread or [greenlet](https://oreil.ly/IaGCM).
    Never type-check those properties (their types are in fact obscure proxy types),
    and you’ll be fine.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在单个全局 *app* 对象，你可能会想知道在访问、修改和重新绑定 *app* 的属性和属性时，它的线程安全性如何。不用担心：你看到的名称实际上只是特定请求上下文中实际对象的代理，在特定线程或
    [greenlet](https://oreil.ly/IaGCM) 的上下文中。永远不要对这些属性进行类型检查（它们的类型实际上是不透明的代理类型），你就没问题。
- en: Flask also supplies many other utility functions and classes; often, the latter
    subclass or wrap classes from other packages to add seamless, convenient Flask
    integration. For example, Flask’s Request and Response classes add just a little
    handy functionality by subclassing the corresponding Werkzeug classes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 还提供许多其他实用函数和类；通常，后者会从其他包中的类继承或包装，以添加无缝、便捷的 Flask 集成。例如，Flask 的 Request
    和 Response 类通过子类化相应的 Werkzeug 类添加了一些便捷的功能。
- en: Flask request objects
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Flask 请求对象
- en: The class flask.Request supplies a large number of [thoroughly documented properties](https://oreil.ly/mmYul).
    [Table 20-1](#useful_properties_of_flaskdotrequest) lists the ones you’ll be using
    most often.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 类 flask.Request 提供了大量 [详细记录的属性](https://oreil.ly/mmYul)。[表 20-1](#useful_properties_of_flaskdotrequest)
    列出了你经常使用的属性。
- en: Table 20-1\. Useful properties of flask.Request
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 表 20-1\. flask.Request 的有用属性
- en: '| args | A MultiDict of the request’s query arguments |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| args | 一个 MultiDict，包含请求的查询参数 |'
- en: '| cookies | A dict with the cookies from the request |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| cookies | 一个包含请求中的 cookies 的字典 |'
- en: '| data | A bytes string, the request’s body (typically for POST and PUT requests)
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| data | 一个字节字符串，请求的主体（通常用于 POST 和 PUT 请求） |'
- en: '| files | A MultiDict of uploaded files in the request, mapping the files’
    names to file-like objects containing each file’s data |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| files | 一个 MultiDict，包含请求中上传的文件，将文件名映射到包含每个文件数据的类文件对象 |'
- en: '| form | A MultiDict with the request’s form fields, provided in the request’s
    body |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| form | 一个 MultiDict，包含请求体中提供的表单字段 |'
- en: '| headers | A MultiDict with the request’s headers |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| headers | 一个 MultiDict，包含请求的头部 |'
- en: '| values | A MultiDict combining the args and form properties |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| values | 一个 MultiDict，合并了 args 和 form 属性 |'
- en: A MultiDict is like a dict, except that it can have multiple values for a key.
    Indexing and get on a MultiDict instance *m* return an arbitrary one of the values;
    to get the list of values for a key (an empty list, if the key is not in *m*),
    call *m*.getlist(*key*).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: MultiDict 类似于字典，但可以为一个键拥有多个值。对 MultiDict 实例 *m* 进行索引和获取时会返回该键的任意一个值；要获取一个键的值列表（如果该键不在
    *m* 中则返回空列表），可以调用 *m*.getlist(*key*)。
- en: Flask response objects
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Flask 响应对象
- en: 'Often, a Flask view function can just return a string (which becomes the response’s
    body): Flask transparently wraps an instance *r* of flask.Response around the
    string, so you don’t have to worry about the response class. However, sometimes
    you want to alter the response’s headers; in this case, in the view function,
    call *r* = flask.make_response(*astring*), alter *r*.headers as you want, then
    return *r*. (To set a cookie, don’t use *r*.headers; rather, call [*r*.set_cookie](https://oreil.ly/AehLj).)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Flask 视图函数可以直接返回一个字符串（它将成为响应的主体）：Flask 会自动在字符串周围包装一个 flask.Response 实例 *r*，因此您无需担心响应类。然而，有时您需要修改响应的标头；在这种情况下，在视图函数中调用
    *r* = flask.make_response(*astring*)，按您的要求修改 *r*.headers，然后返回 *r*。（要设置一个 cookie，请勿使用
    *r*.headers；而是调用 [*r*.set_cookie](https://oreil.ly/AehLj)。）
- en: 'Some of Flask’s built-in integrations with other systems don’t require subclassing:
    for example, the templating integration implicitly injects into the Jinja context
    the Flask globals config, request, session, and g (the latter being the handy
    “globals catch-all” object flask.g, a proxy in application context, in which your
    code can store whatever you want to “stash” for the duration of the request being
    served) and the functions url_for (to translate an endpoint to the corresponding
    URL, same as flask.url_for) and get_flashed_messages (to support *flashed messages*,
    which we do not cover in this book; same as flask.get_flashed_messages). Flask
    also provides convenient ways for your code to inject more filters, functions,
    and values into the Jinja context, without any subclassing.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 与其他系统的许多内置集成无需子类化：例如，模板集成会将 Flask 全局对象 config、request、session 和 g（后者是方便的“全局捕获”对象
    flask.g，在应用上下文中，您的代码可以存储请求处理期间想要“存放”的任何内容）隐式注入到 Jinja 上下文中，以及函数 url_for（将端点转换为相应的
    URL，与 flask.url_for 相同）和 get_flashed_messages（支持 *flashed messages*，在本书中我们不涵盖；与
    flask.get_flashed_messages 相同）。Flask 还提供了方便的方式，让您的代码将更多过滤器、函数和值注入到 Jinja 上下文中，无需任何子类化。
- en: Most of the officially recognized or approved Flask [extensions](https://oreil.ly/V8mD7)
    (hundreds are available from PyPI at the time of this writing) adopt similar approaches,
    supplying classes and utility functions to seamlessly integrate other popular
    subsystems with your Flask applications.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数官方认可或批准的 Flask [扩展](https://oreil.ly/V8mD7)（在撰写本文时有数百种可在 PyPI 上获取）采用类似的方法，提供类和实用函数，以无缝集成其他流行的子系统到您的
    Flask 应用程序中。
- en: In addition, Flask introduces other features, such as [*signals*](https://oreil.ly/YmEuJ)
    to provide looser dynamic coupling in a “pub/sub” pattern and [*blueprints*](https://oreil.ly/jMIZE),
    offering a substantial subset of a Flask application’s functionality to ease refactoring
    large applications in highly modular, flexible ways. We do not cover these advanced
    concepts in this book.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Flask 还引入了其他功能，如 [*signals*](https://oreil.ly/YmEuJ)，以提供“发布/订阅”模式中更松散的动态耦合，以及
    [*blueprints*](https://oreil.ly/jMIZE)，以一种高度模块化、灵活的方式提供 Flask 应用程序功能的大部分子集，以便于重构大型应用程序。我们在本书中不涵盖这些高级概念。
- en: '[Example 20-1](#example_twozero_onedot_a_flask_example) shows a simple Flask
    example. (After using pip to install Flask, run the example using the command
    **flask --app flask_example run**.)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 20-1](#example_twozero_onedot_a_flask_example) 展示了一个简单的 Flask 示例。（使用 pip
    安装 Flask 后，使用命令 **flask --app flask_example run** 运行该示例。）'
- en: Example 20-1\. A Flask example
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 20-1\. 一个 Flask 示例
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This example shows how to use just a few of the many building blocks that Flask
    offers—the Flask class, a view function, and rendering the response (in this case,
    using render_template_string on a Jinja template; in real life, templates are
    usually kept in separate files rendered with render_template). The example also
    shows how to maintain continuity of state among multiple interactions with the
    server from the same browser, with the handy flask.session variable. (It could
    alternatively have put together the HTML response in Python code instead of using
    Jinja, and used a cookie directly instead of the session; however, real-world
    Flask apps do tend to use Jinja and sessions by preference.)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了如何使用 Flask 提供的众多构建模块中的一小部分：Flask 类、视图函数以及渲染响应（在本例中，使用 Jinja 模板的 render_template_string；在实际应用中，通常将模板保存在单独的文件中，并使用
    render_template 渲染）。该示例还展示了如何通过方便的 flask.session 变量，在同一浏览器中多次交互与服务器时保持状态的连续性。（也可以使用
    Python 代码直接组合 HTML 响应，而不是使用 Jinja，并直接使用 cookie 而非 session；然而，实际的 Flask 应用程序更倾向于使用
    Jinja 和 session。）
- en: 'If this app had multiple view functions, it might want to set lastvisit in
    the session to whatever URL had triggered the request. Here’s how to code and
    decorate a hook function to execute after each request:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此应用程序有多个视图函数，可能希望在会话中设置`lastvisit`为触发请求的任何URL。以下是如何编写和装饰钩子函数以在每个请求后执行的代码：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can now remove the flask.session['lastvisit'] = newvisit statement from
    the view function greet, and the app will keep working fine.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以从视图函数`greet`中删除`flask.session['lastvisit'] = newvisit`语句，应用程序将继续正常工作。
- en: FastAPI
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FastAPI
- en: '[FastAPI](https://fastapi.tiangolo.com) is of a more recent design than Flask
    or Django. While both of the latter have very usable extensions to provide API
    services, FastAPI aims squarely at producing HTTP-based APIs, as its name suggests.
    It’s also perfectly capable of producing dynamic web pages intended for browser
    consumption, making it a versatile server. FastAPI’s [home page](https://fastapi.tiangolo.com)
    provides simple, short examples showing how it works and highlighting the advantages,
    backed up by very thorough and detailed reference documentation.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[FastAPI](https://fastapi.tiangolo.com) 的设计比 Flask 或 Django 更为新颖。尽管后者都有非常可用的扩展以提供
    API 服务，但 FastAPI 的目标直指生成基于 HTTP 的 API，正如其名称所示。它也完全能够生成面向浏览器消费的动态网页，使其成为一款多才多艺的服务器。FastAPI
    的[主页](https://fastapi.tiangolo.com)提供了简单、简洁的示例，展示了它的工作原理和优势，支持非常全面和详细的参考文档。'
- en: As type annotations (covered in [Chapter 5](ch05.xhtml#type_annotations)) entered
    the Python language, they found wider use than originally intended in tools like
    [pydantic](https://pydantic-docs.helpmanual.io), which uses them to perform runtime
    parsing and validation. The FastAPI server exploits this support for clean data
    structures, demonstrating great potential to improve web coding productivity through
    built-in and tailored conversion and validation of inputs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型注释（在[第5章](ch05.xhtml#type_annotations)中介绍）进入了 Python 语言，它们在工具中的使用范围超出了最初的意图，例如[pydantic](https://pydantic-docs.helpmanual.io)，它使用它们来执行运行时解析和验证。FastAPI
    服务器利用此支持来创建清晰的数据结构，通过内置和定制的输入转换和验证来展示通过对输入进行转换和验证的内置和定制功能，从而极大地提高了 Web 编码的生产力。
- en: FastAPI also relies on [Starlette](https://www.starlette.io), a high-performance
    asynchronous web framework, which in turn uses an ASGI server such as [Uvicorn](https://www.uvicorn.org)
    or [Hypercorn](https://oreil.ly/SXsur). You don’t need to use async techniques
    directly to take advantage of FastAPI. You can write your application in more
    traditional Python style, though it might perform even faster if you do switch
    to the async style.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 还依赖于[Starlette](https://www.starlette.io)，一个高性能的异步 Web 框架，该框架又使用 ASGI
    服务器，如[Uvicorn](https://www.uvicorn.org) 或 [Hypercorn](https://oreil.ly/SXsur)。您无需直接使用异步技术即可利用
    FastAPI。您可以使用更传统的 Python 风格编写您的应用程序，尽管如果您切换到异步风格，它可能会表现得更快。
- en: FastAPI’s ability to provide type-accurate APIs (and automatically generated
    documentation for them) aligned with the types indicated by your annotations means
    it can provide automatic parsing of incoming data and conversion on both input
    and output.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 能够提供类型准确的 API（以及自动生成的文档），与您的注释所指示的类型相符，这意味着它可以对输入和输出的数据进行自动解析和转换。
- en: 'Consider the sample code shown in [Example 20-2](#example_twozero_twodot_modelsdotpy_pyda),
    which defines a simple model for both pydantic and mongoengine. Each has four
    fields: name and description are strings, price and tax are decimal. Values are
    required for the name and price fields, but description and tax are optional.
    pydantic establishes a default value of **None** for the latter two fields; mongoengine
    does not store a value for fields whose value is **None**.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑[示例20-2](#example_twozero_twodot_modelsdotpy_pyda)中显示的示例代码，该示例为 pydantic
    和 mongoengine 定义了一个简单的模型。每个模型都有四个字段：name 和 description 是字符串，price 和 tax 是十进制数。对于
    name 和 price 字段，需要值，但 description 和 tax 是可选的。pydantic 为后两个字段建立了默认值**None**；mongoengine
    不存储值为**None**的字段的值。
- en: 'Example 20-2\. models.py: pydantic and mongoengine data models'
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 20-2\. models.py：pydantic 和 mongoengine 数据模型
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Suppose you wanted to accept such data through a web form or as JSON, and be
    able to retrieve the data as JSON or display it in HTML. The skeletal [Example 20-3](#example_twozero_threedot_serverdotpy_fa)
    (offering no facilities to maintain existing data) shows you how you might do
    this with FastAPI. This example uses the Uvicorn HTTP server, but makes no attempt
    to explicitly use Python’s async features. As with Flask, the program begins by
    creating an application object app. This object has decorator methods for each
    HTTP method, but the app.route decorator (while available) is eschewed in favor
    of app.get for HTTP GET, app.post for HTTP POST, and the like, and those determine
    which view function handles requests to the paths for different HTTP methods.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您希望通过 Web 表单或 JSON 接受此类数据，并能够将数据作为 JSON 检索或在 HTML 中显示。骨架 [示例 20-3](#example_twozero_threedot_serverdotpy_fa)（不提供维护现有数据的功能）展示了您如何使用
    FastAPI 实现这一点。此示例使用 Uvicorn HTTP 服务器，但未显式使用 Python 的异步特性。与 Flask 一样，程序从创建应用程序对象
    app 开始。此对象具有用于每种 HTTP 方法的装饰器方法，但是它避免了 app.route 装饰器，而是选择 app.get 用于 HTTP GET，app.post
    用于 HTTP POST 等，这些确定了哪个视图函数处理不同 HTTP 方法的路径请求。
- en: 'Example 20-3\. server.py: FastAPI sample code to accept and display item data'
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 20-3\. server.py：FastAPI 接受并显示项目数据的示例代码
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The home_page function, which takes no arguments, simply renders a minimal HTML
    home page containing a form from the *index.xhtml* file, shown in [Example 20-4](#example_twozero_fourdot_the_indexdothtm).
    The form posts to the */items/new/form/* endpoint, which triggers a call to the
    create_item_from_form function, which is declared in the routing decorator as
    producing an HTML response rather than the default JSON.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: home_page 函数不带参数，简单地呈现包含来自 *index.xhtml* 文件的表单的最小 HTML 主页。该表单提交到 */items/new/form/*
    端点，触发调用 create_item_from_form 函数，在路由装饰器中声明生成 HTML 响应而不是默认的 JSON。
- en: Example 20-4\. The index.xhtml file
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 20-4\. index.xhtml 文件
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The form, shown in [Figure 20-1](#input_form_for_fastapi_demonstrator), is handled
    by the create_item_from_form function, whose signature takes an argument for each
    form field, with annotations defining each as a form field. Note that the signature
    defines its own default values for description and tax. The function creates an
    MItem object from the form data and tries to save it in the database. The save
    function forces insertions, inhibiting the update of an existing record, and reports
    failure by returning **None**; the return value is used to formulate a simple
    HTML reply. In a production application, a templating engine such as Jinja would
    typically be used to render the response.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 表单，显示在 [图 20-1](#input_form_for_fastapi_demonstrator) 中，由 create_item_from_form
    函数处理，其签名为每个表单字段指定一个参数，并使用注解定义每个字段为表单字段。注意，签名为描述和税收定义了自己的默认值。该函数从表单数据创建一个 MItem
    对象，并尝试将其保存到数据库中。save 函数强制插入，抑制更新现有记录，并通过返回 **None** 报告失败；返回值用于构建简单的 HTML 回复。在生产应用中，通常会使用像
    Jinja 这样的模板引擎来渲染响应。
- en: '![Input form for FastAPI Demonstrator](assets/pns4_2001.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![FastAPI演示程序的输入表单](assets/pns4_2001.png)'
- en: Figure 20-1\. Input form for FastAPI Demonstrator
  id: totrans-87
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 20-1\. FastAPI 演示程序的输入表单
- en: The create_item_from_json function, routed from the */items/new/* endpoint,
    takes JSON input from a POST request. Its signature accepts a pydantic record,
    so in this case, FastAPI will use pydantic’s validation to determine whether the
    input is acceptable. The function returns a Python dictionary, which FastAPI automatically
    converts to a JSON response. This can easily be tested with a simple client, shown
    in [Example 20-5](#example_twozero_fivedot_fastapi_test_cl).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: create_item_from_json 函数，从 */items/new/* 端点路由，接收来自 POST 请求的 JSON 输入。其签名接受一个
    pydantic 记录，在这种情况下，FastAPI 将使用 pydantic 的验证来确定输入是否可接受。该函数返回一个 Python 字典，FastAPI
    会自动将其转换为 JSON 响应。可以通过一个简单的客户端轻松测试，如 [示例 20-5](#example_twozero_fivedot_fastapi_test_cl)
    所示。
- en: Example 20-5\. FastAPI test client
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 20-5\. FastAPI 测试客户端
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The results of running this program are as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序的结果如下：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first POST request to */items/new/* sees the server returning the same data
    it was presented with, confirming that it has been saved in the database. Note
    that the tax field was not supplied, so the pydantic default value is used here.
    The second line shows the output from retrieving the newly stored item (mongoengine
    identifies the primary key using the name _id). The third line shows an error
    message, generated by the attempt to store a nonnumeric value in the price field.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个POST请求到 */items/new/* 会看到服务器返回与其展示的相同数据，确认其已保存在数据库中。请注意，未提供税收字段，因此这里使用了pydantic的默认值。第二行显示了检索到的新存储项的输出（mongoengine使用名称
    _id 标识主键）。第三行显示了一个错误消息，由于尝试将非数值值存储在价格字段中而生成。
- en: Finally, the retrieve_item view function, routed from URLs such as */items/Item1/*,
    extracts the key as the second path element and returns the JSON representation
    of the given item. It looks up the given key in mongoengine and converts the returned
    record to a dictionary that is rendered as JSON by FastAPI.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，retrieve_item视图函数，由诸如 */items/Item1/* 这样的URL路由，提取第二个路径元素作为键，并返回给定项的JSON表示。它在mongoengine中查找给定的键，并将返回的记录转换为字典，FastAPI将其呈现为JSON。
- en: ^([1](ch20.xhtml#ch01fn151-marker)) One historical legacy is that, in CGI, a
    server provided the CGI script with information about the HTTP request to be served
    mostly via the operating system’s environment (in Python, that’s os.environ);
    to this day, interfaces between web servers and application frameworks rely on
    “an environment” that’s essentially a dictionary and generalizes and speeds up
    the same fundamental idea.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch20.xhtml#ch01fn151-marker)) 一个历史遗留问题是，在CGI中，服务器通过操作系统环境（在Python中为os.environ）向CGI脚本提供关于要服务的HTTP请求的信息；直至今日，Web服务器和应用程序框架之间的接口仍然依赖于“一个环境”，这本质上是一个字典，并且泛化并加速了相同的基本思想。
- en: ^([2](ch20.xhtml#ch01fn152-marker)) More [advanced versions of HTTP exist](https://oreil.ly/tAyoT),
    but we do not cover them in this book.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch20.xhtml#ch01fn152-marker)) 还存在更 [高级版本的HTTP](https://oreil.ly/tAyoT)，但本书不涉及它们。
- en: ^([3](ch20.xhtml#ch01fn153-marker)) Please don’t. As Titus Brown once pointed
    out, Python is (in)famous for having more web frameworks than keywords. One of
    this book’s authors once showed Guido how to easily fix that problem when he was
    first designing Python 3—just add a few hundred new keywords—but, for some reason,
    Guido was not very receptive to this suggestion.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch20.xhtml#ch01fn153-marker)) 请不要。正如Titus Brown曾指出的那样，Python因拥有比关键字还多的Web框架而（臭名昭著）。本书的一位作者曾在Guido设计Python
    3时向他展示了如何轻松解决这个问题——只需添加几百个新关键字——但出于某种原因，Guido对这一建议并不十分接受。
- en: ^([4](ch20.xhtml#ch01fn154-marker)) Installing uWSGI on Windows currently requires
    compiling it with Cygwin.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch20.xhtml#ch01fn154-marker)) 在Windows上安装uWSGI目前需要使用Cygwin进行编译。
- en: ^([5](ch20.xhtml#ch01fn155-marker)) Since Python has fewer than 40 keywords,
    you can see why Titus Brown once pointed out that Python has more web frameworks
    than keywords.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch20.xhtml#ch01fn155-marker)) 由于Python关键字少于40个，你可以理解为什么Titus Brown曾指出Python拥有比关键字更多的Web框架。
