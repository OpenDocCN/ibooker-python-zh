- en: 'Chapter 9\. User-Defined Types: Data Classes'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data classes are user-defined types that let you group related data together.
    Many types, such as integers, strings, and enumerations, are *scalar*; they represent
    one and only one value. Other types, such as lists, sets, and dictionaries, represent
    homogeneous collections. However, you still need to be able compose multiple fields
    of data into a single data type. Dictionaries and tuples are OK at this, but they
    suffer from a few issues. Readability is tricky, as it can be difficult knowing
    what a dictionary or tuple contains at runtime. This makes them hard to reason
    about when reading and reviewing code, which is a major blow to robustness.
  prefs: []
  type: TYPE_NORMAL
- en: When your data is hard to understand, readers will make incorrect assumptions
    and won’t be able to spot bugs as easily. Data classes are easier to read and
    understand, and the typechecker knows how to naturally handle them.
  prefs: []
  type: TYPE_NORMAL
- en: Data Classes in Action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Data classes represent a heterogeneous collection of variables, all rolled
    into a *composite type*. Composite types are made up of multiple values, and should
    always represent some sort of relationship or logical grouping. For example, a
    `Fraction` is an excellent example of a composite type. It contains two scalar
    values: a `numerator` and a `denominator`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This `Fraction` represents the relationship between that `numerator` and `denominator`.
    The `numerator` and `denominator` are independent of each other; changing one
    does not change the other. However, by combining them into a single type, they
    are grouped together to create a logical concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data classes allow you to create these concepts quite easily. To represent
    a fraction with a `dataclass`, you do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Simple, isn’t it? The `@dataclass` before the class definition is known as a
    *decorator*. You’ll learn more about decorators in [Chapter 17](part0022_split_000.html#composability),
    but for now, all you need to know is that putting `@dataclass` before your class
    turns it into a `dataclass`. Once you’ve decorated the class, you need to list
    out all the fields that you want to represent as a relationship. It is imperative
    that you provide a default value or a type, so that Python recognizes it as a
    member of that `dataclass`. In the above case, I am demonstrating both.
  prefs: []
  type: TYPE_NORMAL
- en: By building relationships like this, you are adding to the shared vocabulary
    in your codebase. Instead of developers always needing to implement each field
    individually, you instead provide a reusable grouping. Data classes force you
    to explicitly assign types to your fields, so there’s less chance of type confusion
    among maintainers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data classes and other user-defined types can be nested within the `dataclass`.
    Suppose I’m creating an automated soup maker and I need to group my soup ingredients
    together. Using `dataclass`, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](../images/00002.gif)](part0013_split_001.html#co_user_defined_types__data_classes_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: An enumeration to track different liquid measure sizes
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](../images/00005.gif)](part0013_split_001.html#co_user_defined_types__data_classes_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: An enumeration to track which broth is used in the soup
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](../images/00006.gif)](part0013_split_001.html#co_user_defined_types__data_classes_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: A `dataclass` representing an individual ingredient to be put in the soup. Note
    that the parameter `frozen=True` is a special property of data classes to indicate
    that this `dataclass` is immutable (more on that later). This does not mean the
    ingredients come from the freezer section of the supermarket.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](../images/00007.gif)](part0013_split_001.html#co_user_defined_types__data_classes_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: A `dataclass` representing a soup recipe
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re able to take multiple user-defined types (`ImperialMeasure`, `Broth`,
    and `Ingredient`) to compose them all into the composite type: `Recipe`. From
    this `Recipe`, you can infer multiple concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: A soup recipe is a set of grouped information. Specifically, it can be defined
    by its ingredients (separated into specific categories), the broth used, and how
    long it takes to cook.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each ingredient has a name and an amount you need for the recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have enumerations to tell you about the soup broth and measures. These are
    not a relationship by themselves, but they do communicate intention to the reader.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each grouping of ingredients is a set, rather than a tuple. This means that
    the user can change these after construction, but still prevent duplicates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create the `dataclass`, I do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also get and set individual fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 9-1](part0013_split_001.html#figure_9_1) shows how this `dataclass`
    is constructed.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Construction of the dataclass](../images/00013.gif)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-1\. Construction of the `dataclass`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Through the use of types, I have made it crystal clear what comprises a recipe.
    Users cannot leave off fields. Creating composite types is one of the best ways
    to express relationships through your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: So far, I’ve just described the fields in a `dataclass`, but you are also able
    to add in behaviors in the form of methods. Suppose I want to make any soup vegetarian
    by substituting vegetable broth and removing any meats. I also want to list out
    all the ingredients so that you can make sure that no meat products snuck in.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can add methods directly to the `dataclass` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is a major improvement over raw dictionaries or tuples. I can embed functionality
    directly inside my `dataclass`, improving reusability. If a user wants to get
    all the ingredient names or make a recipe vegetarian, they don’t have to remember
    to do it on their own every time. It’s simple enough to call the function. Here’s
    an example of calling a function directly on a `dataclass`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data classes have some built-in functions that make them really easy to work
    with. You’ve already seen that constructing data classes is a cinch, but what
    else can you do?
  prefs: []
  type: TYPE_NORMAL
- en: String Conversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two special methods, `__str__` and `__repr__`, used to convert your
    object to its informal and offical string representation.^([1](part0013_split_012.html#idm45644742249656))
    Note the double underscores surrounding them; they are known as *magic methods*.
    I’ll cover magic methods more in [Chapter 11](part0015_split_000.html#api), but
    for now, you can treat them as functions that get called when you invoke `str()`
    or `repr()` on an object. Data classes define these functions by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A bit lengthy, but it means that you won’t get something uglier like `<__main__.Recipe
    object at 0x7fef44240730>`, which is the default string conversion for other user-defined
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Equality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to be able to test equality (==, !=) between two data classes,
    you can specify `eq=True` when defining your `dataclass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: By default, equality checks will compare every field across two instances of
    a `dataclass`. Mechanically, Python invokes a function named `__eq__` when doing
    equality checks. If you’d like to provide different default functionality for
    equality checks, you can write your own `__eq__` function.
  prefs: []
  type: TYPE_NORMAL
- en: Relational Comparison
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose I want to display nutritional information in my soup app for the health-conscious.
    I want to be able to sort the soups by various axes, such as the number of calories
    or carbohydrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, data classes do not support relational comparison (`<`, `>`, `<=`,
    `>=`), so you cannot sort the information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you want to be able to define relational comparison (`<`, `>`, `<=`, `>=`),
    you need to set `eq=True` and `order=True` in the `dataclass` definition. The
    generated comparison functions will go through each field, comparing them in the
    order in which they were defined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to control how comparison is defined, you can write your own `__le__`,
    `__lt__`, `__gt__`, and `__ge__` functions in the `dataclass`, which map to less-than-or-equals,
    less-than, greater-than, and greater-than-or-equals, respectively. For instance,
    if you wanted your `NutritionInformation` sorted first by fat, then carbohydrates,
    and then calories by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you override comparison functions, do not specify `order=True`, as that will
    raise a `ValueError`.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you need to convey that a `dataclass` should not be able to be changed.
    In that case, you can specify that a `dataclass` must be `frozen`, or unable to
    change. Anytime you change the state of a `dataclass`, you introduce entire classes
    of errors that might happen:'
  prefs: []
  type: TYPE_NORMAL
- en: Callers of your code may be unaware that the fields changed; they could erroneously
    assume that the fields are static.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting a single field to an incorrect value might be incompatible with how
    the other fields are set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are multiple threads modifying the fields, you run the risk of a data
    race, which means you cannot guarantee in which order the modifications are applied
    in relation to one another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'None of these error cases occur if your `dataclass` is `frozen`. To freeze
    a `dataclass`, add a `frozen=True` to the `dataclass` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you want to use your `dataclass` in a set or as a key in a dictionary it
    must be *hashable*. This means it must define a `__hash__` function that takes
    your object and distills it down to a number.^([2](part0013_split_012.html#idm45644741402248))
    When you freeze a `dataclass`, it automatically becomes hashable, as long as you
    don’t explicitly disable equality checking and all fields are hashable.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two caveats around this immutability, however. First, when I say
    immutability, I am referencing the fields in the `dataclass`, not the variable
    containing the `dataclass` itself. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you would like the typechecker to error out if the variable is rebound, you
    can annotate the variable as `Final` (see [Chapter 4](part0007_split_000.html#constraints)
    for more details on `Final`).
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, a `frozen` `dataclass` only prevents its members from being set. If
    the members are mutable, you are still able to call methods on those members to
    modify their values. `frozen` `dataclass`es do not extend immutability to their
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this code is perfectly fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Even though it is modifying the *aromatics* field of a `frozen` `dataclass`,
    no error is raised. When using `frozen` `dataclass`es, make the members immutable
    (such as integers, strings, or other `frozen` `dataclass`es) to avoid this pitfall.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison to Other Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data classes are relatively new (introduced in Python 3.7); a lot of legacy
    code will not contain data classes. As you evaluate data class adoption, you need
    to understand where a data class shines in relation to other constructs.
  prefs: []
  type: TYPE_NORMAL
- en: Data Classes Versus Dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in [Chapter 5](part0008_split_000.html#collections), dictionaries
    are fantastic for mapping keys to values, but they are most appropriate when they
    are homogeneous (when all the keys are the same type and all the values are the
    same type). When used for heterogeneous data, dictionaries are tougher for humans
    to reason about. Also, typecheckers don’t know enough about the dictionary to
    check for errors.
  prefs: []
  type: TYPE_NORMAL
- en: Data classes, however, are a natural fit for fundamentally heterogeneous data.
    Readers of the code know the exact fields present in the type and typecheckers
    can check for correct usage. If you have heterogeneous data, use a data class
    before you reach for a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Data Classes Versus TypedDict
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Also discussed in [Chapter 5](part0008_split_000.html#collections) was the `TypedDict`
    type. This is another way to store heterogeneous data that makes sense for readers
    and typecheckers. At first glance, `TypedDict` and data classes solve a very similar
    problem, so it can be tough to decide which one is appropriate. My rule of thumb
    is to think of a `dataclass` as the default, as it can have functions defined
    on it and you can control immutability, comparability, equality, and other operations.
    However, if you are already working with dictionaries (such as for working with
    JSON), you should reach for a `TypedDict`, provided that you don’t need any of
    the benefits of a `dataclass`.
  prefs: []
  type: TYPE_NORMAL
- en: Data Classes Versus namedtuple
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`namedtuple` is a tuple-like collection type in the collections module. Unlike
    tuples, it allows for you to name the fields in a tuple like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'A `namedtuple` goes a long way toward making a tuple more readable, but so
    does using a `dataclass` in its place. I almost always pick a `dataclass` instead
    of a `namedtuple`. A `dataclass`, like a `namedtuple`, provides named fields along
    with other benefits like:'
  prefs: []
  type: TYPE_NORMAL
- en: Explicitly type annotating your arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control of immutability, comparability, and equality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier to define functions in the type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, I only reach for a `namedtuple` if I explicitly need compatibility
    with Python 3.6 or before.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion Topic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What types do you use to represent heterogeneous data in your codebase? If you
    use dictionaries, how easy is it for developers to know all the key-value pairs
    in the dictionary? If you use tuples, how easy is it for developers to know what
    the meaning of individual fields are?
  prefs: []
  type: TYPE_NORMAL
- en: Closing Thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data classes were a game changer when released in Python 3.7, because they allowed
    developers to define heterogeneous types that were fully typed while still staying
    lightweight. As I write code, I find myself reaching for data classes more and
    more. Whenever you encounter heterogeneous, developer-controlled dictionaries
    or `namedtuple`s, a data class is more suitable. You can find a wealth of additional
    information in the [`dataclass` documentation](https://oreil.ly/1toSU).
  prefs: []
  type: TYPE_NORMAL
- en: However, as great as data classes are, they should not be universally used.
    A data class, at its heart, represents a conceptual relationship, but it really
    is only appropriate when the members within the data class are independent of
    one another. If any of the members should be restricted depending on the other
    members, a data class will make it harder to reason about your code. Any developer
    could change the fields during your data classes’ lifetime, potentially creating
    an illegal state. In these cases, you need to reach for something a bit heavier.
    In the next chapter, I’ll teach you how to do just that with classes.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](part0013_split_003.html#idm45644742249656-marker)) The informal string
    representation is useful for printing the object. The official string representation
    reproduces all information about the object so that it can be reconstructed.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](part0013_split_006.html#idm45644741402248-marker)) Hashing is a complicated
    subject, beyond the scope of this book. You can learn more about the `hash` function
    in the [Python documentation](https://oreil.ly/JDgLO).
  prefs: []
  type: TYPE_NORMAL
