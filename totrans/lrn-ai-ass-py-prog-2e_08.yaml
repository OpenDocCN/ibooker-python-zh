- en: 9 *Automating tedious tasks*
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Understanding why programmers write tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining which modules we need to write a given tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating cleaning up emails that have > > > symbols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating manipulating PDF files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating removing duplicate pictures across multiple image libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppose that you’re responsible for creating 100 reports, one for each of 100
    people. Perhaps you’re a teacher and need to send a report to each of your students.
    Perhaps you work for HR and need to send an annual assessment report to each employee.
    Regardless of your role, you have the problem of having to create these reports,
    and you decided to prepare your reports as .pdf files. You need a customized cover
    page for each report too, and those cover pages are designed by one of your colleagues
    (a graphic design artist).
  prefs: []
  type: TYPE_NORMAL
- en: You and your colleague work independently, and, finally, the job is done. Or
    wait, not so fast. Because now you have to put each cover page at the beginning
    of each report.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, a nonprogrammer might grit their teeth and start on the job,
    manually merging the cover page with the first report, the second cover page with
    the second report, and so on. That could take hours. Not knowing that there may
    be another way, a nonprogrammer may just power ahead until the job is done.
  prefs: []
  type: TYPE_NORMAL
- en: But you’re a programmer now. And most programmers, the two of us included, would
    never power ahead with manual work like this.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’re going to show you how to write programs to automate tedious
    tasks. The second example in the chapter will automate the “merging cover pages
    with reports” situation. But we’ll do others as well. Received an email that’s
    been forwarded so many times
  prefs: []
  type: TYPE_NORMAL
- en: that it looks
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: like
  prefs: []
  type: TYPE_NORMAL
- en: this?
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Or does your family have several phones, each with hundreds of images, and you
    just want to get the images all in the same place so that you can archive them
    without losing anything? In this chapter, we’ll show you how to automate tasks
    like that.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1 Why programmers make tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There’s a common sentiment that programmers often express: we’re lazy. This
    doesn’t mean that we don’t want to do our work. It means that we don’t want to
    do *repetitive, boring, tedious* work because that’s what computers are good at.
    Programmers develop a sort of spidey-sense for this kind of drudgery. Suppose
    Leo has a few hundred photos, and he wants to delete any photos that are duplicates.
    There’s no way he’d do this by hand. Or suppose that Dan has to send out a customized
    email to each of his students. If it’s more than a few students, there’s no way
    he’s doing this by hand. As soon as programmers start noticing that they’re repeating
    the same keys on the keyboard or working through the same steps over and over,
    they’ll stop and make a tool to automate it.'
  prefs: []
  type: TYPE_NORMAL
- en: When programmers talk about tools, they’re talking about programs that do something
    that saves them time. A tool often isn’t the end goal, and writing one can itself
    feel tedious and not glamorous. But once we have a tool, we can use it to save
    us time. Sometimes, we’ll use a tool once, for one specific job, and then never
    again. Commonly, though, a tool ends up being useful over and over, whether we
    use the tool exactly as we wrote it or by making some small changes. For example,
    after Dan finishes teaching each course, he uses a program he wrote to collate
    all student grades and submit them to the university. He makes small changes to
    the tool each time—changing the weights of each assignment, for example—but then
    Dan can use that slightly modified tool to do the work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The great thing about using Copilot is that it makes cranking out these tools
    easier. Here’s how one software engineer explains it:'
  prefs: []
  type: TYPE_NORMAL
- en: We all know that tools are important, that effective tools are challenging to
    create, and that management doesn’t care or understand the need for tools. . .
    . I can’t express how fundamentally different programming feels now that I can
    build two quality tools per day, for every single itch I want to scratch. [1]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 9.2 How to use Copilot to write tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we learned in chapter 5 when talking about modules, sometimes we need to
    use a module to help us write the program we want. Some modules are built into
    Python. For example, in chapter 5, we used the built-in zipfile module to help
    us create a .zip file. Other modules aren’t built in, and we need to install them
    first before we can use them.
  prefs: []
  type: TYPE_NORMAL
- en: When writing a tool, it’s often the case that we’ll be working with some specialized
    data format (zip files, PDF files, Microsoft Excel spreadsheets, images) or performing
    some specialized task (sending email, interacting with a website, moving files
    around). For most of this, we’re going to need to use a module. Which module,
    though? And is it built in, or do we need to install it? These are the first questions
    we need to get answers to.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we can use Copilot Chat (or ChatGPT) to help us get started. As
    a reminder, we’re using the Copilot Chat feature because it’s built into our Visual
    Studio Code (VS Code) IDE and because Copilot Chat has access to the very code
    we’re currently writing so it can incorporate what we’re doing into its answers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The plan is to have a conversation with Copilot to determine which module we
    need to use. Once we know that and install the module, if necessary, then we can
    get down to the business of writing the code for our tool. We’ll do that the way
    we’ve always done it: by writing the function header and a docstring and having
    Copilot fill in the code for us. Once Copilot starts writing code, we need to
    follow the same steps as in previous chapters, including checking code correctness,
    fixing bugs, and maybe even doing some problem decomposition. To focus our attention
    on writing tools to automate tasks, we’ll minimize the time we spend on these
    additional tasks here.'
  prefs: []
  type: TYPE_NORMAL
- en: It may be possible to ask Copilot or ChatGPT to write the entire tool for us,
    without even having to put it inside of a function. We won’t do that here, though,
    because we still think that the benefits of functions are worthwhile. A function
    will help us document our code so that we know what it does, and it enables flexibility
    if we later decide, for example, to add additional parameters to our function
    to change the behavior of the tool.
  prefs: []
  type: TYPE_NORMAL
- en: '9.3 Example 1: Cleaning up email text'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, an email gets replied to and forwarded so many times that it becomes
    a mess, with many greater than (>) signs and spaces on some of the lines. Here’s
    a sample email of what we mean:'
  prefs: []
  type: TYPE_NORMAL
- en: Hi Leo,
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Dan -- any luck with your natural language research?
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Yes! That website you showed me
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[https://www.kaggle.com/](https://www.kaggle.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: is very useful. I found a dataset on there that collects
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: a lot
  prefs: []
  type: TYPE_NORMAL
- en: of questions and answers that might be useful to my research.
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Thank you,
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: Dan
  prefs:
  - PREF_BQ
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Suppose that you wanted to save this email information for future use. You
    might like to clean up the > and space symbols at the start of lines. You could
    start manually deleting them—this email isn’t that long, after all—but don’t do
    that because here you have an opportunity to design a general-purpose tool that
    you can use whenever you need to perform this task. Whether your email has five
    lines, a hundred lines, or a million lines, it won’t matter: just use the tool
    and be done.'
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.1 Conversing with Copilot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need to make the messy email available to our tool so that the tool can clean
    it up. One way we can do this is to first copy the text of an email to the clipboard
    (using your Copy to Clipboard command on your operating system, such as Ctrl-C).
  prefs: []
  type: TYPE_NORMAL
- en: Each computer operating system has a clipboard to store the last thing copied.
    If you’ve ever used Copy-Paste, you’ve used that clipboard. We’re going to use
    the clipboard for temporary storage of text so we can edit the text in the clipboard
    and then paste it where we need it.
  prefs: []
  type: TYPE_NORMAL
- en: After copying the text from the messy email to the clipboard, we could then
    run the tool on the text in the clipboard, and the tool could clean up the email
    and replace the clipboard contents with the cleaned-up version. For the tool to
    do something reasonable, we assume that your clipboard has email text on it. The
    tool will remove the > and space characters at the start of each line so that
    you can paste (using your operating system Paste command, such as Ctrl-V) the
    newly cleaned-up email wherever you want. In terms of Python, it will need to
    pull the clipboard contents into a string (i.e., copy the contents of the clipboard),
    clean it up, and then put that new cleaned-up text back on the clipboard (i.e.,
    paste to the clipboard), replacing the junky version of the email that was there
    before.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we access the clipboard in our Python program? That’s what we need
    to figure out, so that will frame the conversation that we have with Copilot.
    Similar to chapter 8, we’re going to use “Human” for the prompts that we type
    and “GitHub Copilot” for Copilot’s responses. You can use the Copilot Chat feature
    or ChatGPT to have a similar conversation. We’re typing our prompts into the Copilot
    Chat window.
  prefs: []
  type: TYPE_NORMAL
- en: In our chats with Copilot, we’re going to explore widely before settling on
    a solution. We’ll explain why we’re doing this once we’ve gotten the hang of things
    through one example, but we note this here so that you’ll be ready for this seemingly
    less direct approach. Copilot provides quite a bit of sample code in its responses.
    As we’re exploring, feel free to skim that code, but don’t get bogged down in
    it. We’ll look at more particulars of the code once we finish exploring and settle
    on a plan. Let’s start learning!
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanI would like to write a Python program that accesses the clipboard and
    lets me copy and paste using the clipboard. How can I do this?
  prefs: []
  type: TYPE_NORMAL
- en: '![chatGpt](../Images/chatGpt.png)GitHub CopilotYou can use the pyperclip module
    to access the clipboard in Python. Here’s an example program that lets you copy
    and paste using the clipboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]`*[PRE1]`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*import pyperclip*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Copy to clipboard*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*pyperclip.copy(''Hello, world!'')*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Paste from clipboard*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*text = pyperclip.paste()*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*print(text)*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE2]*[PRE3]'
  prefs: []
  type: TYPE_NORMAL
- en: This program first imports the pyperclip module. It then copies the string `'Hello,`
    `world!'` to the clipboard using the `copy()` function. Finally, it pastes the
    contents of the clipboard into the “text” variable using the `paste()` function
    and prints the result.
  prefs: []
  type: TYPE_NORMAL
- en: You can install the pyperclip module using pip by running `pip` `install` `pyperclip`
    in your terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Copilot’s response teaches us that we can use the pyperclip module to interact
    with the clipboard in our Python program. The sample code that it provided even
    showed us how to copy stuff from our program to the clipboard and paste stuff
    from the clipboard into a variable (`text`). We’re making great progress!
  prefs: []
  type: TYPE_NORMAL
- en: The final paragraph of the response tells us how to install pyperclip. Aha!
    So pyperclip doesn’t come with Python by default. While we’ll learn how to install
    modules later, it might be nice to not have to worry about that. So, let’s continue
    the conversation, asking Copilot if we can do better.
  prefs: []
  type: TYPE_NORMAL
- en: LPHuman Is there a way I can do it without having to install a Python module?
  prefs: []
  type: TYPE_NORMAL
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Yes, you can use the tkinter
    module that comes with Python to access the clipboard. Here’s an example program
    that lets you copy and paste using the clipboard without installing any additional
    modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]`*[PRE5]`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*import tkinter as tk*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Create a Tkinter window*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*root = tk.Tk()*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Hide the window*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*root.withdraw()*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Copy to clipboard*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*root.clipboard_clear()*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*root.clipboard_append(''Hello, world!'')*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Paste from clipboard*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*text = root.clipboard_get()*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*print(text)*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE6]*[PRE7]'
  prefs: []
  type: TYPE_NORMAL
- en: This program first creates a hidden Tkinter window using the `Tk()` function
    and hides it using the `withdraw()` method. It then clears the clipboard using
    the `clipboard_ clear()` method and appends the string `'Hello,` `world!'` to
    the clipboard using the `clipboard_append()` method. Finally, it retrieves the
    contents of the clipboard using the `clipboard_get()` method and prints the result.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this method only works if you have a graphical environment available,
    such as a desktop environment on Linux or macOS, or the Windows desktop on Windows.
    If you’re running Python in a terminal-only environment, you’ll need to use a
    different method to access the clipboard.
  prefs: []
  type: TYPE_NORMAL
- en: It seems that we’ve won something and lost something else. The win is that this
    tkinter module is built into Python. The loss is that “the method only works if
    you have a graphical environment available.” Do we have a graphical environment
    available in our Python setup? While we could certainly try the code to find out,
    this requirement gives us pause. After all, the pyperclip solution didn’t have
    that requirement, so we might not need it (whatever it happens to mean). Let’s
    try again.
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanIs there another way I can do it without having to install a Python module?
  prefs: []
  type: TYPE_NORMAL
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Yes, you can access the clipboard
    using the win32clipboard module, which is included in the standard library on
    Windows. Here’s an example program that allows you to copy and paste using the
    clipboard without installing any additional modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]`*[PRE9]`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*import win32clipboard*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Copy to clipboard*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*text = "Hello, world!"*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*win32clipboard.OpenClipboard()*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*win32clipboard.EmptyClipboard()*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*win32clipboard.SetClipboardText(text)*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*win32clipboard.CloseClipboard()*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Paste from clipboard*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*win32clipboard.OpenClipboard()*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*pasted_text = win32clipboard.GetClipboardData()*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*win32clipboard.CloseClipboard()*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*print(pasted_text)*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE10]*[PRE11]'
  prefs: []
  type: TYPE_NORMAL
- en: This program first imports the win32clipboard module. To copy text to the clipboard,
    you can call the `OpenClipboard()` function to open the clipboard, then call `EmptyClipboard()`
    to clear any existing data, and finally call `SetClipboardText()` to set the text
    on the clipboard. After setting the text, you should call `CloseClipboard()` to
    close the clipboard.
  prefs: []
  type: TYPE_NORMAL
- en: To paste from the clipboard, you can call `OpenClipboard()` to open the clipboard,
    then call `GetClipboardData()` to get the text from the clipboard. After getting
    the text, you should call `CloseClipboard()` to close the clipboard. In this example,
    the program copies the text `"Hello,` `world!"` to the clipboard, then pastes
    it and prints it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: “Standard library on Windows,” eh? That’s concerning because it means that our
    tool might not work on other operating systems. Let’s see about that.
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanDoes that work on Linux or macOS too?
  prefs: []
  type: TYPE_NORMAL
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot No, the win32clipboard module
    is specific to Windows and won’t work on Linux or macOS. On Linux, you can use
    the `xclip` command-line utility to access the clipboard. Here’s an example program
    that allows you to copy and paste using the clipboard on Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]`*[PRE13]`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*import subprocess*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Copy to clipboard*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*text = "Hello, world!"*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*subprocess.run([''xclip'', ''-selection'', ''clipboard''], input=text.encode(''utf-8''))*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Paste from clipboard*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*p = subprocess.Popen([''xclip'', ''-selection'', ''clipboard'', ''-o''],
    stdout=subprocess.PIPE)*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*pasted_text = p.stdout.read().decode(''utf-8'')*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*print(pasted_text)*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE14]*[PRE15]'
  prefs: []
  type: TYPE_NORMAL
- en: This program uses the subprocess module to run the `xclip` command-line utility.
    To copy text to the clipboard, you can call `subprocess.run()` and pass in the
    `xclip` command with the `-selection` `clipboard` option to specify the clipboard
    selection, and the `input` parameter to pass in the text you want to copy. To
    paste from the clipboard, you can call `subprocess.Popen()` and pass in the `xclip`
    command with the `-selection` `clipboard` `-o` options to read the text from the
    clipboard, and then read the output of the command using the `stdout` attribute
    of the `Popen` object. In this example, the program copies the text `"Hello,`
    `world!"` to the clipboard, then pastes it and prints it to the console.
  prefs: []
  type: TYPE_NORMAL
- en: On macOS, you can use the `pbcopy` and `pbpaste` command-line utilities to access
    the clipboard. The usage is similar to `xclip`.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve gotten some solutions that are specific to different operating systems.
    We don’t like this! We want our tool to work no matter which operating system
    we’re using. (Even if we’re using only Windows ourselves, maybe one day, we’ll
    share this tool with others who use different operating systems.)
  prefs: []
  type: TYPE_NORMAL
- en: We could continue our conversation, but in retrospect, having to install that
    single pyperclip module doesn’t seem so bad. Let’s go ahead with it. In general,
    it can be valuable to explore your options when deciding how to start writing
    a tool, and conversing with Copilot is helpful for carrying out this exploration.
  prefs: []
  type: TYPE_NORMAL
- en: Why we should explore and understand our options
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'There are several reasons why you shouldn’t just use the first module that
    Copilot chat tells you to use:'
  prefs: []
  type: TYPE_NORMAL
- en: It may not work on all operating systems. In general, we want to find modules
    that work across multiple operating systems so that the tool can be used by you
    (if you later switch operating systems) or others with whom you’ve shared the
    tool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It may turn out not to work for our use case after all, or we may struggle to
    get the code to work. If we have other options, we can start trying those before
    sinking too much time into a strategy that may or may not ultimately work out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules are updated frequently. Usually this is to add new features and fix
    bugs, but sometimes, functions are removed or changed in this process as well.
    When the author of a module removes a function, it’s known as *deprecating that
    function**.* Once a function is deprecated,it may no longer work, and we need
    to find a replacement. Copilot is trained only every once in a while, not continuously,
    so if a new version of a module comes out after Copilot was trained on it, Copilot
    won’t know about the updates. This can lead to Copilot suggesting code that depends
    on an older version of the module than the one you have. There are ways to address
    this, as we’ll see later in the chapter. But if you run into trouble, having other
    options to explore is useful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9.3.2 Writing the tool to clean up email
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first thing we need to do is to install the pyperclip module. How do we
    install it, though? The good news is that Python has made it easy to install new
    modules. Go to the Terminal at the bottom right of VS Code and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note  For some operating systems, you may need to use `pip3` rather than `pip`.
    On Windows machines, we recommend using `pip` if you followed our installation
    instructions from chapter 2\. On Mac or Linux machines, we recommend using `pip3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this command, you might see that other modules get installed too.
    Don’t worry about that: sometimes modules need other modules to be able to do
    their work, and Python just installs them all so that you don’t have to worry
    about installing those dependencies yourself.'
  prefs: []
  type: TYPE_NORMAL
- en: Once that’s installed, we can import the module and then write the header and
    docstring for our function that will remove the > and space characters from the
    start of lines. The reason we’re importing the module here is to influence Copilot
    to use that module when writing the code for the function. Here’s the prompt we
    used and the code that Copilot gave us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 9.1 First try: Clean up email text in the clipboard'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Puts the current contents of the clipboard into the text string'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Splits the string into a list of its lines'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Loops through each line'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Removes spaces and &gt; symbols from the start of the line'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 This looks odd.'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Copies the cleaned-up text to the clipboard'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Note a common Python convention (see the following discussion).'
  prefs: []
  type: TYPE_NORMAL
- en: '#8 Calls our function to automatically clean up the clipboard!'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that the program is carrying out the correct sequence of steps:
    it’s obtaining the clipboard contents, cleaning up that text, and then copying
    the cleaned-up text back to the clipboard. As we learned from our earlier chat
    with Copilot, we want Copilot to write code that uses the `paste` and `copy` functions
    of `pyperclip`, and that’s exactly what it’s doing. The second-to-last line of
    the program is something we haven’t seen before in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can actually remove this line if you like (and if you do, also unindent
    the line below it). It ensures that the `clean_email` function is only called
    when you run your program, not when you import it as a module. After all, if you
    did want to import this as a module (to be used as part of a larger program),
    you would call `clean_email` whenever you needed that functionality, not necessarily
    as soon as the module was imported. (And, in general, whenever you’re interested
    in understanding a line of code more fully, you can ask Copilot about it!) Unfortunately,
    this code doesn’t work. If you run it, you’ll receive this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax error means that we have a program that isn’t written in valid Python
    code. We’re going to fix this now! We have a couple of options for how to do so.
    One is to highlight your code and ask Copilot Chat to fix the bug. For us, this
    did fix the problem. You could also try asking ChatGPT in conversation: “Propose
    a fix for the bugs in my code <insert your code>.” This is a useful tip to keep
    in mind whenever the code that you get back from Copilot doesn’t work as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: Copilot fixed the code for us by fixing the line with the syntax error. The
    new code is shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 9.2 Second try: Clean up email text in the clipboard'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Joins the individual lines back into one string'
  prefs: []
  type: TYPE_NORMAL
- en: The new line of code, changed from the odd line of code that we had previously,
    is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The goal of this line is to join all the lines of text together into a single
    string that the program will later copy to the clipboard. What does that `\n`
    mean? That represents the start of a newline in code. What is the `join` method?
    It takes all the items in a list (lines) and joins them together into a single
    string.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can understand how this works in more detail by experimenting a little with
    `join`. Here’s an example of using `join` with an empty string rather than the
    `''\n''` string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Shows the list of three lines'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Calls join on the empty string'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that some of the words are squished together. That’s not exactly what
    we want—we need something between them. How about a space? Let’s try using `join`
    again, this time with a space in the string rather than the empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we could use `''*''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: That fixes our squished words. And, the `*s` tells us where each line ends,
    but it would be nicer to actually maintain the fact that the email is three lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a way in Python to use a line break or newline character, rather than
    a space or `*`. We can’t just press Enter because that would split the string
    over two lines and that isn’t valid Python syntax. The way to do it is by using
    `''\n''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our tool is ready to be used. If you copy some messy email text to your
    clipboard, run our program, and paste the clipboard, you’ll see that the email
    has been cleaned up. For example, if we run it on our previous sample email, we
    get the following cleaned-up version:'
  prefs: []
  type: TYPE_NORMAL
- en: Hi Leo,
  prefs: []
  type: TYPE_NORMAL
- en: Dan -- any luck with your natural language research?
  prefs: []
  type: TYPE_NORMAL
- en: Yes! That website you showed me
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.kaggle.com/](https://www.kaggle.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: is very useful. I found a dataset on there that collects
  prefs: []
  type: TYPE_NORMAL
- en: a lot
  prefs: []
  type: TYPE_NORMAL
- en: of questions and answers that might be useful to my research.
  prefs: []
  type: TYPE_NORMAL
- en: Thank you,
  prefs: []
  type: TYPE_NORMAL
- en: Dan
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we could still do more. The line breaks in that email aren’t great
    (the line “a lot” is extremely and needlessly short), and you might want to clean
    that up as well. You could begin to make these kinds of improvements by adding
    new requirements to your prompts to Copilot. We’ll stop here because we’ve accomplished
    our initial goal of email cleanup, but we encourage you to continue exploring
    more robust solutions on your own.
  prefs: []
  type: TYPE_NORMAL
- en: '9.4 Example 2: Adding cover pages to PDF files'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s return to the scenario from the start of the chapter. We have written
    100 reports that are in .pdf format. Our colleague has designed 100 covers for
    those reports that are also in .pdf format, and we need to merge the covers with
    the reports so that each finalized .pdf file starts with the cover and continues
    with the report. Figure 9.1 provides an illustration of the desired process.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/9-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 Illustration of the desired process of creating combined .pdfs by
    merging the report cover in the cover directory with the report in the report’s
    directory. Note that the reports may be more than one page.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: PDF files (and Microsoft Word and Excel files) aren’t text files
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You might wonder why we can’t simply use Python methods such as `read` and `write`
    to manipulate .pdf files. After all, that’s just what we did when working with
    .csv files in chapter 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'The big difference is that .csv files are text files, which are files readable
    by humans with no formatting or special commands. However, many other file formats
    aren’t text files. A .pdf file, for example, isn’t human-readable and needs to
    be processed by code that is aware of the .pdf format. This is true of Microsoft
    Word files and Microsoft Excel files as well: they’re not text files, so we need
    specialized tools to work with them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the resources for this book, in the ch9 folder, you’ll find two subfolders:
    the reports subfolder contains 100 reports as .pdf files, and the covers subfolder
    contains 100 covers as .pdf files, one for each report. The reports are named
    1.pdf, 2.pdf, 3.pdf, and so on; the respective covers are named cover1.pdf, cover2.pdf,
    cover3.pdf, and so on. We’ll merge these reports and covers together in this section.'
  prefs: []
  type: TYPE_NORMAL
- en: Open some of the cover .pdf files and some of the report .pdf files. You can
    do that using a program such as Adobe Acrobat or however you typically open .pdf
    files on your computer. You’ll notice that the covers are always exactly one page,
    but the reports can be more than one page. When we get to the code, we should
    take care to tell Copilot that reports can be more than one page; otherwise, Copilot
    might write code assuming that the reports, like the covers, are only one page.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering how we created these 100 covers and reports. You’d be
    disappointed if we made them manually, one at a time, right? Don’t worry. We automated
    that creation process in much the same way we’ll automate the merging process
    next.
  prefs: []
  type: TYPE_NORMAL
- en: 9.4.1 Conversing with Copilot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need our tool to find all reports and covers, add the cover to the front
    of each report, and produce a finalized .pdf for each report that contains both
    the cover page and report pages. How do we merge .pdf files using Python? Let’s
    find out.
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanI need to write a **Python program that merges .pdf files. How do I do
    this?**
  prefs: []
  type: TYPE_NORMAL
- en: '**![chatGpt](../Images/chatGpt.png)GitHub Copilot You can use the PyPDF2 library
    to merge PDF files in Python. Here is an example code snippet that shows how to
    merge two PDF files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]`*[PRE27]`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*import PyPDF2*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Open the PDF files to be merged*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*pdf1 = open(''file1.pdf'', ''rb'')*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*pdf2 = open(''file2.pdf'', ''rb'')*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Create a PDF reader object for each file*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*reader1 = PyPDF2.PdfFileReader(pdf1)*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*reader2 = PyPDF2.PdfFileReader(pdf2)*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Create a PDF writer object*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*writer = PyPDF2.PdfFileWriter()*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Loop through the pages of each PDF and add them to the writer object*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*for i in range(reader1.getNumPages()):*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*page = reader1.getPage(i)*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*writer.addPage(page)*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*for i in range(reader2.getNumPages()):*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*page = reader2.getPage(i)*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*writer.addPage(page)*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Write the merged PDF to a file*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*output = open(''merged.pdf'', ''wb'')*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*writer.write(output)*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Close the input and output files*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*pdf1.close()*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*pdf2.close()*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*output.close()*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE28]*[PRE29]'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we first open the two PDF files to be merged using the `open()`
    function. We then create a PDF reader object for each file using the `PdfFileReader()`
    function from PyPDF2.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a PDF writer object using the `PdfFileWriter()` function. We
    then loop through the pages of each PDF file using the `getNumPages()` and `getPage()`
    methods of the reader objects and add each page to the writer object using the
    `addPage()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we write the merged PDF to a file using the `write()` method of the
    writer object and close all the input and output files using the `close()` method.
  prefs: []
  type: TYPE_NORMAL
- en: We have a lead! This PyPDF2 module seems to do what we need. It looks like it
    gives us `PdfFileReader` to read an existing .pdf file and `PdfFileWriter` to
    create a new .pdf file. We see the code using `getPage` to get a page from an
    existing .pdf file and `addPage` to write it to the new .pdf file—very promising.
    Is there something built-in to Python that we could use, so that we don’t have
    to worry about installing PyPDF2?
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanIs there a way I can do it without having to install a Python module?
  prefs: []
  type: TYPE_NORMAL
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Yes, you can use the subprocess
    module to call a command-line tool like `pdftk` to merge PDF files. Here is an
    example code snippet that shows how to merge two PDF files using `pdftk`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]`*[PRE31]`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*import subprocess*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Call pdftk to merge the PDF files*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*subprocess.call([''pdftk'', ''file1.pdf'', ''file2.pdf'',*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*''cat'', ''output'', ''merged.pdf''])*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE32]*[PRE33]'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we use the `subprocess.call()` function to call `pdftk` with
    the appropriate arguments to merge the two PDF files `file1.pdf` and `file2.pdf`.
    The `cat` argument tells `pdftk` to concatenate the input files, and the `output`
    argument specifies the output file name as `merged.pdf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you will need to have `pdftk` installed on your system for this code
    to work. If you don’t have `pdftk` installed, you can download it from the official
    website: [https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/](https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/).'
  prefs: []
  type: TYPE_NORMAL
- en: This approach may ultimately end up being valuable, but it’s not exactly a built-in
    solution. After all, the final paragraph talks about us having to install some
    new software called `pdftk`!
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we’d probably go with the first option of using PyPDF2\. But
    let’s press forward once more with Copilot to make sure we don’t miss any good
    options.
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanAre there other Python .pdf libraries that I should consider?
  prefs: []
  type: TYPE_NORMAL
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Yes, there are several other
    Python libraries that you can use to work with PDF files. Here are some popular
    ones:'
  prefs: []
  type: TYPE_NORMAL
- en: ReportLab—a library for creating PDF documents from scratch, with support for
    text, graphics, and images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: FPDF—a library for creating PDF documents from scratch, with support for text,
    graphics, and images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: PDFMiner—a library for extracting text and metadata from PDF files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: PyMuPDF—a library for working with PDF files, with support for text, graphics,
    and images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: pdfrw—a library for reading and writing PDF files, with support for text, graphics,
    and images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each library has its own strengths and weaknesses, so you should choose the
    one that best fits your needs. If you only need to merge PDF files, then PyPDF2
    or pdftk may be sufficient. However, if you need to create or manipulate PDF files
    in more complex ways, then one of the other libraries may be a better choice.
  prefs: []
  type: TYPE_NORMAL
- en: The last paragraph tells us that we’re probably in good shape using PyPDF2 if
    all we need to do is merge .pdf files. But let’s finish our conversation here
    by understanding the pros and cons of all of these tools. That way, if we get
    stuck with PyPDF2, we know where to turn to next.
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanCan you summarize the **strengths and weaknesses of these libraries?**
  prefs: []
  type: TYPE_NORMAL
- en: '**![chatGpt](../Images/chatGpt.png)GitHub Copilot Certainly! Here is a summary
    of the strengths and weaknesses of the libraries I mentioned:'
  prefs: []
  type: TYPE_NORMAL
- en: PyPDF2—a library for working with PDF files, with support for text, graphics,
    and images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strengths:'
  prefs: []
  type: TYPE_NORMAL
- en: Easy to use for simple tasks like merging PDF files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Good documentation and examples available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Supports a wide range of PDF features.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Weaknesses:'
  prefs: []
  type: TYPE_NORMAL
- en: Limited support for advanced PDF features like forms and annotations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can be slow for large PDF files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ReportLab—a library for creating PDF documents from scratch, with support for
    text, graphics, and images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strengths:'
  prefs: []
  type: TYPE_NORMAL
- en: Very powerful and flexible for creating complex PDF documents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Supports a wide range of PDF features.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Good documentation and examples available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Weaknesses:'
  prefs: []
  type: TYPE_NORMAL
- en: Steep learning curve for beginners.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can be slow for large PDF files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: FPDF—a library for creating PDF documents from scratch, with support for text,
    graphics, and images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strengths:'
  prefs: []
  type: TYPE_NORMAL
- en: Lightweight and easy to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Good documentation and examples available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Supports a wide range of PDF features.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Weaknesses:'
  prefs: []
  type: TYPE_NORMAL
- en: Limited support for advanced PDF features like forms and annotations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can be slow for large PDF files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: PDFMiner—a library for extracting text and metadata from PDF files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strengths:'
  prefs: []
  type: TYPE_NORMAL
- en: Very powerful and flexible for extracting text and metadata from PDF files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Supports a wide range of PDF features.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Good documentation and examples available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Weaknesses:'
  prefs: []
  type: TYPE_NORMAL
- en: Steep learning curve for beginners.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Limited support for creating or manipulating PDF files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: PyMuPDF—a library for working with PDF files, with support for text, graphics,
    and images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strengths:'
  prefs: []
  type: TYPE_NORMAL
- en: Very fast and efficient for working with PDF files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Supports a wide range of PDF features.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Good documentation and examples available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Weaknesses:'
  prefs: []
  type: TYPE_NORMAL
- en: Steep learning curve for beginners.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Limited support for creating or manipulating PDF files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: pdfrw—a library for reading and writing PDF files, with support for text, graphics,
    and images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strengths:'
  prefs: []
  type: TYPE_NORMAL
- en: Very powerful and flexible for reading and writing PDF files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Supports a wide range of PDF features.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Good documentation and examples available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Weaknesses:'
  prefs: []
  type: TYPE_NORMAL
- en: Steep learning curve for beginners.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can be slow for large PDF files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Don’t be too intimidated by the “Steep learning curve for beginners” cautions
    in there. If Copilot has been trained on the library, then you may still be successful.
  prefs: []
  type: TYPE_NORMAL
- en: Based on what we’ve learned here, we might eliminate PDFMiner because it apparently
    has “limited support for creating or manipulating PDF files,” but we’d keep all
    others in contention just in case we need them. For now, we’re going to proceed
    with PyPDF2 and see how it goes.
  prefs: []
  type: TYPE_NORMAL
- en: 9.4.2 Writing the tool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Go ahead and install the PyPDF2 module. Be careful with the capitalization:
    the module is called exactly PyPDF2, not pypdf2, pyPDF2, or any other capitalization.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our previous example, we wrote a function to clean up an email that was
    on the clipboard. We didn’t need to pass any information to that function, so
    the function had no parameters. Here, our function will need three parameters:
    the name of the directory with the reports, the name of the directory with the
    covers, and the name of the directory where we want to write our finalized (merged)
    .pdf files.'
  prefs: []
  type: TYPE_NORMAL
- en: In our docstring, we need to explain what each of these directories is for and
    also the pattern of the filenames in the directories. After all, Copilot will
    need to know how the reports match up with the cover pages.
  prefs: []
  type: TYPE_NORMAL
- en: Trying PyPDF2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’re going to use the PyPDF2 Python library to try to get the job done. Look
    back to what Copilot Chat told us about the PyPDF2 library. The sample code it
    gave us used `PdfFileReader` to read existing .pdf files and `PdfFileWriter` to
    create a new .pdf file. It also used `getPage` and `addPage` to manipulate pages.
    Look out for these in the code that Copilot produces—they’re telltale signs that
    Copilot is generating code that’s on the right track. Here’s the prompt that we
    used and the code that Copilot gave us.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.3 Function to add covers to .pdf documents
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Gets list of the .pdf reports'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Loops through the .pdf reports'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 We can use report_reader to read the pages of the report.'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 We can use report_writer to write pages into a new .pdf file'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Loops through each page of the report'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Adds the page to our new .pdf file'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Opens the cover associated with this report'
  prefs: []
  type: TYPE_NORMAL
- en: '#8 We can use cover_reader to read the cover.'
  prefs: []
  type: TYPE_NORMAL
- en: '#9 Adds the cover to the start of our new .pdf file'
  prefs: []
  type: TYPE_NORMAL
- en: '#10 Saves our new .pdf file'
  prefs: []
  type: TYPE_NORMAL
- en: '#11 Calls our function to do all the merging!'
  prefs: []
  type: TYPE_NORMAL
- en: Be careful with automation programs
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Programs like the one we’ve written to merge .pdf files can rip through hundreds
    or thousands of files very quickly. If they aren’t operating correctly, they can
    easily result in damaged or lost files. Any time we use `open` with `'w'` or `'wb'`
    as the second parameter, it means that we’re overwriting a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s focus on this line from our program in listing 9.3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It’s using the `open` function to open a file. Specifically, it’s opening the
    current `report_file` file in the `final_dir` directory. The second argument to
    `open` here, `'wb'`, means that we want to open the file so we can write to it
    (that’s the `'w'`) and that the file we’re writing is a binary file (that’s the
    `'b'`), not a text file. If the file doesn’t already exist, then the `'w'` we’ve
    included will result in the file being created. That’s not the dangerous part.
    The dangerous part is what happens when the file already exists. In that case,
    `'w'` wipes out its contents and gives us an empty file that we can start writing
    to. Now, if our program is working correctly and only doing this in our `final_dir`,
    then we’re OK. But this is what we need to carefully verify before letting our
    program loose.
  prefs: []
  type: TYPE_NORMAL
- en: 'We highly recommend that you first test on a small directory of files that
    you don’t care about. Further, we recommend changing lines of code that open files
    using `''w''` or `''wb''` to print a harmless output message instead, so that
    you can see exactly which files are going to be overwritten or created. For example,
    in our program here, we need to comment out these two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we’ll use `print` to print out the file that we would have created
    or overwritten:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Then, when you run your program, you’ll see the names of files that the program
    *intended* to write. If the output looks good—that is, the program is operating
    exactly on the files that you wanted it to operate on—then you can uncomment the
    code that actually does the work.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise caution, and *always* keep backups of your important files!
  prefs: []
  type: TYPE_NORMAL
- en: The last line of the program in listing 9.3 makes the assumption that the directory
    of reports is called `reports`, the directory of cover pages is called `covers`,
    and the directory where the final .pdf files should go is called `final`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, create the `final` directory. It should be there along with your `reports`
    and `covers` directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'The overall structure of the code looks promising to us: it’s getting a list
    of the .pdf reports, and then, for each one, it’s merging those pages with the
    cover page. It’s using a `for` loop to loop through the pages of the report, which
    is good because it can grab all the pages that way. By contrast, it’s *not* using
    a `for` loop on the cover .pdf file, which again is good because we know that
    the cover has only one page anyway.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the first line of code it gave us looks like it’s using a function
    called `listdir` in a module called os. There are other lines that use this module
    as well. Do we need to be importing that os module? Indeed, we do! And we can
    prove it by running the code. If you run the code, you’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We need to add `import os` at the start of our program to fix this. The updated
    code is in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.4 Improved function to add covers to .pdf documents
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '#1 We were missing this import before.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re not out of the woods yet, though. Our updated program still doesn’t work.
    Here’s the error we get when we run our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '#1 The line in our code that’s causing an error'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 We can’t use PdfFileReader anymore—it’s gone!'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve run into the problem where Copilot thinks, “Hey, let’s use `PdfFileReader`,
    since I’ve been trained that this is part of PyPDF2,” but between Copilot being
    trained and the time of our writing, the PyPDF2 maintainers have removed `PdfFileReader`
    and replaced it with something else (`PdfReader`, according to the final line
    of the error message). This discrepancy may very well be fixed for you by the
    time you read this book, but we want to pretend it’s still messed up so that we
    can teach you what to do if this does happen to you in the future. At this point,
    we have three options:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Install an earlier version of PyPDF2.* The last two lines of the error message
    tell us that `PdfFileReader`, the function we need from PyPDF2, was removed in
    PyPDF2 3.0.0\. As a result, if we install a version of PyPDF2 earlier than 3.0.0,
    we should have our function back. In general, installing earlier versions of libraries
    isn’t advisable because security concerns may be present in those versions that
    have since been fixed in more recent versions. In addition, there may be bugs
    present in the older versions that have since been fixed. It’s worth googling
    what has been changed in the library recently to determine whether using an older
    version is safe. In this case, we have done that homework and see no obvious risk
    in using an older version of PyPDF2\.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Fix the code ourselves using the suggestion in the error message.* That is,
    we would replace `PdfFileReader` with `PdfReader` and run the program again. In
    this case, we would be told about other deprecations, and we’d need to fix those
    following the same process. It’s very nice of the authors of PyPDF2 to tell us
    what to do inside the error messages. For practice, you might like to work through
    this, making each update suggested by the error message. We wish all error messages
    were so useful, but this won’t always be the case. Sometimes, a function will
    be removed without giving us any recourse. In that case, it may be easier to consider
    our next option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Use a different library.* Earlier, we asked Copilot for other possible .pdf
    Python libraries we could use, and we received many suggestions. If the first
    two of our options here aren’t satisfactory, we could jump to trying one of those.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’re going to illustrate how to solve the problem and get our code running
    with the first option (using an earlier version of PyPDF2) and the third option
    (using a different library entirely).
  prefs: []
  type: TYPE_NORMAL
- en: Using an earlier version of PyPDF2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When using `pip install` to install a Python library, by default, we get the
    most current version of the library. That’s usually what we want—the latest and
    greatest—but it’s also possible to explicitly request an older version of the
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we need a version of PyPDF2 prior to version 3.0.0\. Rather than the standard
    usage of pip,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: we can instead use
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `< 3.0.0` is what we use to ask for the most recent version of the library
    that’s less than version 3.0.0\. The command should result in output like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '#1 We had an existing version that is &gt;= 3.0.0.'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 That version is being removed . . .'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 . . . and version 2.12.1 is being installed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have an older version of PyPDF2 installed. At this point, you should
    be able to run our program. It’ll take a few seconds, and then the job will be
    done. You can check your final directory for the newly created .pdf files. Open
    a few of them to make sure that our program has done the right thing: each .pdf
    file should start with a cover page and contain all the pages of the report (not
    just the first page if the report has multiple pages).'
  prefs: []
  type: TYPE_NORMAL
- en: Think of how tedious this would have been by hand, and we’ve gotten the computer
    to do it for us. Moreover, the next time we have to do the same thing at work
    (more reports for more people), we’ve got a tool all set to help us get it done
    quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Using a different .pdf library
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s try solving our problem with PyPDF2 by using another library—one of
    those that Copilot told us about in our initial conversation about .pdf libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'We won’t go through all the gory details with you on how we decided which library
    to try next, but we’ll walk through the highlights of our journey. We started
    by asking Copilot Chat how we can use the ReportLab Python module to merge .pdf
    files, but that redirected us back to using PyPDF2\. We received the same response
    for FPDF: we were told that FPDF can’t merge .pdf files but that PyPDF2 can. We
    then moved on to asking about PyMuPDF, and this part of the conversation was productive:'
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanHow can I use the Python PyMuPDF library to merge .pdf files?
  prefs: []
  type: TYPE_NORMAL
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot You can use the fitz module
    from the PyMuPDF library to merge PDF files. Here’s an example code snippet that
    shows how to merge two PDF files using PyMuPDF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]`*[PRE45]`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*import fitz*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Merge the two PDF files*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*pdf_files = [''file1.pdf'', ''file2.pdf'']*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*pdf_writer = fitz.Document()*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*for pdf_file in pdf_files:*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*pdf_reader = fitz.open(pdf_file)*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*for page in pdf_reader:*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*pdf_writer.insert_pdf(page)*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*pdf_writer.save(''merged.pdf'')*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*pdf_writer.close()*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE46]*[PRE47]'
  prefs: []
  type: TYPE_NORMAL
- en: This code first creates a list of PDF files to merge (`file1.pdf` and `file2.pdf`).
    It then creates a new `Document` object using `fitz`, which represents the merged
    PDF. It loops through each PDF file in the list, opens it using `fitz`, and inserts
    each page of the PDF file into the `pdf_writer` object using the `insert_pdf()`
    method. Finally, it saves the merged PDF to a new file called `merged.pdf` using
    the `save()` method.
  prefs: []
  type: TYPE_NORMAL
- en: You can modify this code to add any additional content to the merged PDF using
    PyMuPDF. Just create a new `Page` object, add the content to the page, and insert
    the page into the `pdf_writer` object using the `insert_page()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The sample code here is using `insert_pdf` to add each .pdf file to the merged
    .pdf file. We should be on the lookout for our code using `insert_pdf` as well.
    The library is called PyMuPDF, so we need to install it with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: But then we have to use `import fitz`? Why `import fitz` and not `import PyMuPDF`?
    Apparently, the designers of this library liked fitz more than PyMuPDF, so we’ll
    need to go with it. It’s rare indeed, but occasionally we use one name to install
    the library and another to import it!
  prefs: []
  type: TYPE_NORMAL
- en: If you encounter NameError when you import
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If Python gives you a `NameError` referring to the library that you’re trying
    to import, it’s a good bet that you haven’t successfully imported that library.
    It could be that the library isn’t in fact installed, or that you need to use
    a different name to import it. Use Copilot Chat to have a conversation if you
    ever find that you’ve installed a library but can’t seem to import it.
  prefs: []
  type: TYPE_NORMAL
- en: Now we’re ready to generate some code. The following listing shows the prompt
    that we used and the code that Copilot gave us.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.5 Improved function to add covers to .pdf documents
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '#1 If the final_dir directory doesn’t exist, . . .'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 . . . create the final_dir directory.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Loops through the .pdf reports'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Used to read the cover'
  prefs: []
  type: TYPE_NORMAL
- en: '#5 Used to read the report'
  prefs: []
  type: TYPE_NORMAL
- en: '#6 Used as our new output file'
  prefs: []
  type: TYPE_NORMAL
- en: '#7 Adds the cover to our new .pdf file'
  prefs: []
  type: TYPE_NORMAL
- en: '#8 Adds the report to our new .pdf file'
  prefs: []
  type: TYPE_NORMAL
- en: '#9 Saves our new .pdf file'
  prefs: []
  type: TYPE_NORMAL
- en: This program happens to start with some code that creates the output directory
    if it doesn’t already exist. After that, the steps are similar to those in our
    earlier program that used PyPDF2, although the functions called by each program
    are different. (That makes sense because PyPDF2 and PyMuPDF are different libraries,
    with different features and functions.) In both cases, we’re using `listdir` to
    get a list of the report .pdf filenames. In the `for` loop, we go through each
    of those reports; the code in the loop is responsible for creating a new .pdf
    file that contains the cover followed by the report. In our PyPDF2 code, there
    was an inner `for` loop that we needed to loop through all the pages of the report.
    In our current program, we don’t need that because Copilot used the `insert_pdf`
    function, which inserts a .pdf file into another .pdf file in one shot (not page
    by page). Whether you took the approach of installing the older library or you
    chose to use a different library, we’ve solved our problem and automated what
    would have been an unpleasantly tedious task.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we’ve slightly altered the workflow that we described in the previous
    chapter to take into account handling the different Python modules that could
    aid you with your task. A modified workflow is provided in figure 9.2.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/9-2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 Additions to our workflow to account for working with different Python
    modules
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '9.5 Example 3: Merging phone picture libraries'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now suppose that you take a lot of pictures on your phone. Your partner (or
    sibling, parent, or child) also takes a lot of pictures on their phone. You each
    have hundreds or thousands of pictures! Sometimes you send pictures to your partner,
    and they send pictures to you, so that you and your partner have some but not
    all of each other’s pictures.
  prefs: []
  type: TYPE_NORMAL
- en: You live life like this for a while, but honestly, it’s becoming a mess. Half
    the time when you want a picture, you can’t find it because it’s a picture that
    your partner took on their phone that they didn’t send you. And, you’re starting
    to have many duplicate pictures all over the place.
  prefs: []
  type: TYPE_NORMAL
- en: 'You then have an idea: “What if we take all the pictures from my phone and
    all the pictures from your phone, and we create a combined library of all the
    pictures! Then we’ll have all the pictures in one place!” Remember that both of
    your phones may have hundreds of pictures, so doing this manually is out of the
    question. We’re going to automate this!'
  prefs: []
  type: TYPE_NORMAL
- en: To specify our task more precisely, we’ll say that we have two directories of
    pictures (think of each directory as the contents of a phone) that we want to
    combine into a new directory. A common file format for pictures is a .png file,
    so we’ll work with those files here. Your actual phone might use .jpg files rather
    than .png files, but don’t worry. You can adapt what we do here to that picture
    file format (or any other picture file format) if you like.
  prefs: []
  type: TYPE_NORMAL
- en: In the resources for this book, in the ch9 directory, you’ll find two subdirectories
    of picture files. These subdirectories are named pictures1 and pictures2\. You
    can imagine that pictures1 has the pictures from your phone (98 pictures) and
    pictures2 has the pictures from your partner’s phone (112 pictures). We’re going
    to combine these two phone directories into a new directory.
  prefs: []
  type: TYPE_NORMAL
- en: Open some of the .png files in the same way that you open pictures or photos
    on your computer. The pictures we’ve generated are just some random shapes, but
    the program we write here will work no matter what’s inside the pictures.
  prefs: []
  type: TYPE_NORMAL
- en: At the outset, we said that the same picture might be on both phones, so we’ve
    generated some duplicate files in our pictures. (We have a total of 210 picture
    files, but 10 of them are duplicates, so there are only 200 unique pictures.)
    For example, in the pictures1 directory, there’s a file called 1566.png, and in
    the pictures2 directory, there’s a file called 2471.png. These two files are identical,
    and when we generate our directory of files from both phones, we’ll only want
    to keep one of these. What’s tricky here is that these pictures are the same even
    though their filenames are not.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if two filenames are the same? Does that mean that the pictures are the
    same? For example, notice that each directory, pictures1 and pictures2, has a
    file called 9595.png. You might think that filenames being the same means that
    the pictures inside will be the same too. But no, if you open these pictures,
    you’ll see that they’re different! This could happen in real life too: you and
    your partner could both take different pictures, and, however remote, it’s possible
    that the filenames your phones choose for those pictures just happen to be the
    same.'
  prefs: []
  type: TYPE_NORMAL
- en: If we’re not careful, we’ll end up copying 9595.png from pictures1 into our
    new directory and then overwriting it later by copying 9595.png from pictures2
    into our new directory. We need to be sure that when we copy a file, we’re not
    overwriting a different picture that may already be there with the same filename.
    We provide an example of this process in figure 9.3.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/9-3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 Example of merging the photos in the pictures1 and pictures2 folders
    into the pictures–combined folder and managing the removal of duplicates
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’re working with directories, not actual phones
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’re assuming here that you have two directories of pictures already on your
    computer. These directories could have come from anywhere, and nothing we do here
    has anything specific to do with cell phones.
  prefs: []
  type: TYPE_NORMAL
- en: But if you wanted to do this task for real, with pictures on your phones, you’d
    need to get those pictures onto your computer first. You could use ChatGPT to
    have that discussion! As the details are specific to different phones and go beyond
    what we want to use Copilot to automate, we won’t go further into this here.
  prefs: []
  type: TYPE_NORMAL
- en: 9.5.1 Conversing with Copilot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our tool is going to create a combined directory of pictures from pictures1
    and pictures2, but without duplicate pictures. If our combined original picture
    directories have the same picture multiple times, we want only one of those copies
    of the picture to survive in our new directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, there are at least two things we might like to know: How do
    we copy a file using Python, and how do we know whether two files are the same
    picture? Let’s start by asking Copilot Chat how we can copy a file:'
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanI need to write a Python program that copies files. How do I do this?
  prefs: []
  type: TYPE_NORMAL
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot You can use the shutil module
    in Python to copy files. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]`*[PRE51]`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*import shutil*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Replace the source and destination paths with your own*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*source = ''/path/to/source/file''*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*destination = ''/path/to/destination/file''*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Copy the file*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*shutil.copy(source, destination)*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE52]*[PRE53]'
  prefs: []
  type: TYPE_NORMAL
- en: This will copy the file from the source path to the destination path. If the
    destination file already exists, it will be overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: Excellent. We can use that shutil module to copy a file; we’ll need to remember
    to import that module. The final sentence that Copilot gave us is an important
    warning. We should be careful to avoid copying a file over the top of another
    file that already exists. Next, let’s determine whether this shutil module is
    built-in to Python.
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanIs this shutil module built into Python?
  prefs: []
  type: TYPE_NORMAL
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot Yes, the shutil module is a
    built-in module in Python, so you don’t need to install anything extra to use
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder why we’re focusing on making copies of files and putting them
    into our new directory, rather than moving them from our original directories
    into the new directory. The reason is that we want to leave our original directories
    alone just in case we have a bug and fail to get all the files into our new directory.
    If anything goes wrong in our new directory, it won’t matter because our original
    directories will still be intact.
  prefs: []
  type: TYPE_NORMAL
- en: That wraps up what we need to know about copying files. Now let’s move on to
    learn how we can determine whether two files are the same picture.
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve already said, it’s not sufficient to use filenames to determine whether
    pictures are the same. How can we do it, then?
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanUsing Python, how can I determine whether .png files are the same?
  prefs: []
  type: TYPE_NORMAL
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot You can use the filecmp module
    in Python to compare two files and check if they are the same. Here’s an example
    code snippet that compares two .png files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]`*[PRE55]`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*import filecmp*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Replace these file paths with the actual file paths of the .png files*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# you want to compare*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*file1 = ''/path/to/file1.png''*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*file2 = ''/path/to/file2.png''*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*if filecmp.cmp(file1, file2):*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*print(''The files are the same.'')*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*else:*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*print(''The files are different.'')*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE56]*[PRE57]'
  prefs: []
  type: TYPE_NORMAL
- en: This code will compare the contents of the two files and return `True` if they
    are the same, and `False` if they are different.
  prefs: []
  type: TYPE_NORMAL
- en: As a quick aside, the last sentence from Copilot is wrong. That code isn’t returning
    `True` or `False` anywhere. Just like Copilot can generate faulty code for us
    in our Python file, Copilot Chat can produce faulty explanations.
  prefs: []
  type: TYPE_NORMAL
- en: Our prompt wasn’t precise about the number of files that we need to compare.
    Do we want to compare two files? Hundreds of files? Our prompt doesn’t say. Copilot
    has told us what to do if we want to compare two files, which is a reasonable
    thing to tell us. But that’s not quite what we need. We need to be able to determine,
    among hundreds of files, which files are duplicates of other files. That way,
    we can detect a duplicate file and not copy it into our new directory. Let’s try
    again.
  prefs: []
  type: TYPE_NORMAL
- en: LPHumanWhat if I have hundreds of .png files and I want to find duplicates—is
    that approach you gave me still good?
  prefs: []
  type: TYPE_NORMAL
- en: '![chatGpt](../Images/chatGpt.png)GitHub Copilot If you have hundreds of .png
    files and you want to find duplicates, you can use the os module to iterate over
    all the files in a directory and compare each file to every other file in the
    directory. Here’s an example code snippet that does that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]`*[PRE59]`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*import os*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*import filecmp*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Replace this with the actual directory path where your .png*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# files are located*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*directory = ''/path/to/directory''*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*# Iterate over all the files in the directory*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*for filename1 in os.listdir(directory):*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*if filename1.endswith(''.png''):*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*for filename2 in os.listdir(directory):*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*if filename2.endswith(''.png'') and filename1 != filename2:*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*file1 = os.path.join(directory, filename1)*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*file2 = os.path.join(directory, filename2)*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*if filecmp.cmp(file1, file2):*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*`*print(f''{filename1} and {filename2} are duplicates.'')*`*'
  prefs: []
  type: TYPE_NORMAL
- en: '*[PRE60]*[PRE61]'
  prefs: []
  type: TYPE_NORMAL
- en: This code will iterate over all the files in the directory and compare each
    `.png` file to every other `.png` file in the directory. If two files are the
    same, it will print a message indicating that they are duplicates. Note that this
    approach can be slow for large directories with many files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The outer `for` loop goes through each file in the directory. How do we know
    whether the current file has a duplicate? Well, we can go through each other file
    in the directory and compare it to the current file. That’s the role of the inner
    `for` loop: it uses `filecmp.cmp` to compare the current file (`file1`) to each
    other file (`file2`).'
  prefs: []
  type: TYPE_NORMAL
- en: We didn’t mention in our prompt that we care about finding duplicates across
    multiple directories, so Copilot has focused on a single directory here. If that
    difference turns out to be a roadblock, we could make our prompt more precise.
  prefs: []
  type: TYPE_NORMAL
- en: Copilot is using two other modules here, os and filecmp. We could ask Copilot
    if these are built-in Python modules or not, but we’ll save a little time and
    just tell you here that they are built-in.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now want you to focus on the final sentence from Copilot: “Note that this
    approach can be slow for large directories with many files.” How slow is “slow”?
    How many is “many”? We don’t know.'
  prefs: []
  type: TYPE_NORMAL
- en: You might be tempted to ask Copilot for a better solution, one that isn’t “slow
    for large directories with many files.” But many programmers wouldn’t do that.
    It’s often a mistake to optimize our solution before we have even tried out our
    (unoptimized, apparently slow) approach for two reasons. First, maybe our “slow”
    program turns out to be fast enough! We may as well try it. Second, more optimized
    programs are often more sophisticated programs, and they may be more difficult
    for us to get right. That isn’t always the case, but it can be. And again, if
    our unoptimized program gets the job done, we don’t even have to worry about a
    more optimized version at all.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if it turns out that our program really is too slow or you find yourself
    using the program repeatedly, then it may be worth the extra investment in continuing
    to work with Copilot on a faster solution. For now, though, we’re good.
  prefs: []
  type: TYPE_NORMAL
- en: 9.5.2 Top-down design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There’s a little more going on in this task than in our prior two tasks. For
    one, we need to be careful not to overwrite a file that already exists in our
    new directory. For another, we need to determine which files to copy in the first
    place (remember that we only want to copy files that don’t already match a file
    in our new directory). Compare this to the .pdf merging task we just accomplished,
    where we didn’t have these extra concerns.
  prefs: []
  type: TYPE_NORMAL
- en: To that end, we’re going to use top-down design and problem decomposition here.
    Don’t worry, it won’t be a full-on top-down design example like we did in chapter
    7\. Our task here is much smaller than our spelling suggestions task from that
    chapter. We’ll just do a little top-down design and that will help Copilot get
    us what we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our top-level function will be responsible for solving our overall task: taking
    the pictures1 and pictures2 directories and putting all unique pictures into a
    target directory. Back in chapter 3, we learned that we should make functions
    as general as we can, to make them more useful or generalizable to other tasks.
    Here, we’ve been thinking about combining two picture directories together. But
    why not 3, 5, or 50 directories? Who cares how many directories we have; we should
    be able to just combine as many directories as we want.'
  prefs: []
  type: TYPE_NORMAL
- en: So, instead of designing our top-level function to take two strings (directory
    names) as parameters, we’ll have the function take a list of strings. That way,
    we can use it on as many picture directories as we want. And, we can still readily
    use it on two picture directories—we’ll just pass a list containing the names
    of the two directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll name our top-level function `make_copies`. We’ll need two parameters:
    the list of directory names that we just discussed, and the name of our target
    directory where we want all the files to go.'
  prefs: []
  type: TYPE_NORMAL
- en: What’s this function going to do? It’s going to loop through each directory
    in the list of directories, and then, for each directory, it’s going to loop through
    each file. For each file, we need to determine whether to copy it or not and,
    if we need to copy it, to do the actual copying.
  prefs: []
  type: TYPE_NORMAL
- en: 'Determining whether to copy the file, and then possibly copying it, is a subtask
    that we can split out of `make_copies`. We’ll name our function for this subtask
    `make_copy`. Our `make_copy` function will take two parameters: the name of a
    file and the target directory. If the file isn’t identical to any file in the
    target directory, then the function will copy the file into the target directory.'
  prefs: []
  type: TYPE_NORMAL
- en: Say we want to copy a file called 9595.png from one of our picture directories
    into our target directory but that file already exists in the target directory.
    We don’t want to overwrite the file that’s already there, so we’ll need to come
    up with a new filename. We might try adding an _ (underscore) character prior
    to the .png part of the filename. That would give us 9595_.png. That one probably
    wouldn’t exist in the target directory, but if it did, we could then try 9595__.png,
    9595___.png, and so on, until we find a filename that doesn’t already exist in
    there.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a unique filename is a task that we can split out of our `make_copy`
    function. We’ll call it `get_good_filename`. It will take a filename as a parameter
    and return a version of that filename that doesn’t already exist.
  prefs: []
  type: TYPE_NORMAL
- en: And with that, our top-down design is done. Figure 9.4 depicts our work as a
    tree (well, at least the trunk of a tree), showing which function is called by
    which other function.
  prefs: []
  type: TYPE_NORMAL
- en: '![figure](../Images/9-4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 Top-down design for image merging. The top-most (left-most) function
    is `make_copies`, the child of that is `make_copy`, and the child of that is `get_good_filename`.
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 9.5.3 Writing the tool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We don’t have any modules to install this time around. We do know from our Copilot
    conversation that we’ll use the built-in shutil module to copy files. We’ll also
    use the built-in filecmp module to compare files and the built-in os module to
    get a list of the files in a directory. We’ll therefore import these three modules
    at the top of our Python program.
  prefs: []
  type: TYPE_NORMAL
- en: As in chapter 7, we’re going to solve our problem by starting at the bottom
    of our function tree and working toward the top. We do that so Copilot can call
    our already-written functions when writing code for a parent function. For each
    function, we provide the `def` line and docstring, and Copilot writes the code.
    We’ve also provided some annotations to explain how the code works.
  prefs: []
  type: TYPE_NORMAL
- en: Looking again at figure 9.4, we see that the first function we need to implement
    is `get_good_filename`. Let’s get that one done now in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.6 `get_good_filename` function for our picture merge task
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '#1 While the filename exists . . .'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 . . . insert an _ prior to .png by replacing .png with _.png.'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Returns the filename that we know now doesn’t exist'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function we need to write is `make_copy`. This is the function that
    copies a file into a target directory but only if the file isn’t identical to
    a file that we’ve already copied. We’re looking for Copilot to do several things
    in its code here:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `os.listdir` to get a list of files in the target directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `filecmp.cmp` to determine whether two files are identical.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `shutil.copy` to copy the file if there was no identical file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call the function `get_good_filename` that we just wrote.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following listing shows our prompt and the code that Copilot provided. Notice
    that the code is doing everything that we wanted it to do.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.7 `make_copy` function for our pictures merge task
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Loops through the files in the target directory'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 If the file is the same as one of the files in the target directory, . .
    .'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 . . . returns from the function without having copied the file.'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Otherwise, copies the file and uses a good filename that doesn’t already
    exist.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s only one function to go, and it’s our top-level `make_copies` function.
    For each file in each of our picture directories, we’re expecting the code to
    call `make_copy` to copy the file if needed, as shown in the following listing.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 9.8 `make_copies` function for our picture merge task
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '#1 Loops through our picture directories'
  prefs: []
  type: TYPE_NORMAL
- en: '#2 Loops through the files in the current picture directory'
  prefs: []
  type: TYPE_NORMAL
- en: '#3 Copies the current file into the target directory, if needed'
  prefs: []
  type: TYPE_NORMAL
- en: '#4 Runs our program on our two picture directories and the given target directory'
  prefs: []
  type: TYPE_NORMAL
- en: The final line of code from Copilot, beneath the `make_copies` function, makes
    the assumption that our target directory will be named pictures_combined. Create
    that directory now so that it sits alongside your pictures1 and pictures2 directories
    of pictures.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed when working with .pdf files earlier in the chapter, it’s important
    that you first test the program on sample directories that you don’t care about.
    Your sample directories should have only a few files in them, so that you can
    manually determine whether the program is working as expected. You should also
    include important edge cases, such as having the same filename in each directory.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have your sample directories, you should create a “harmless” version
    of the program that simply outputs messages rather than actually copying files.
    For our program here, you would change the line in `make_copy` to use `print`
    rather than `shutil.copy`.
  prefs: []
  type: TYPE_NORMAL
- en: If the output looks good after you check the results carefully, only then should
    you run the real program on your real directories. Remember that our program is
    copying (rather than moving) files, so even in our real directories, if something
    goes wrong, there’s a good chance that the problem will be in our new directory
    and not the original directories that we actually care about.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll assume that you’re now ready to run the program on the pictures1 and pictures2
    directories. Once you run it, you can check your pictures_combined directory for
    the results. You should see that the directory has 200 files, which is exactly
    the number of unique pictures that we had across our two picture directories.
    Did we correctly handle the situation where the same filename existed in both
    picture directories but were different pictures? Yes, you can see that we have
    files named 9595.png and 9595_.png and that we therefore haven’t overwritten one
    with the other.
  prefs: []
  type: TYPE_NORMAL
- en: Oh, and how long did the program take to run on your computer? At most a few
    seconds, right? It turns out that Copilot’s warning that “this approach can be
    slow for large directories with many files” didn’t matter for us.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we all know that people tend to have thousands of pictures on their phones,
    not hundreds. If you ran this program on two real phone picture libraries, you
    would again need to determine whether it completes in an acceptable amount of
    time. You could run the program and let it run for a minute or two or however
    long you’re willing to wait. For fun, we also tested our program on a total of
    10,000 small image files (a more realistic scenario than the 210 pictures across
    our pictures1 and pictures2 directories that we used in this chapter), and we
    found that it only took 1 minute to complete. At some point, our program will
    become too slow to be practical, and that’s when you’d need to do further research
    with Copilot Chat to arrive at a more efficient program.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we succeeded in automating three tedious tasks: cleaning up
    an email, adding covers to hundreds of .pdf files, and wrangling multiple picture
    libraries into one. The approach in each case was the same: use Copilot Chat to
    determine which module(s) to use, then follow the approach that we’ve honed throughout
    the book to have Copilot write the required code.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember, whenever you find yourself repeating the same task, it’s worth trying
    to automate it using Copilot and Python. There are many helpful Python modules
    for doing so, beyond what we showed in this chapter. For example, there are modules
    to manipulate images, work with Microsoft Excel or Microsoft Word files, send
    email, scrape data from websites, and more. If it’s a tedious task, chances are
    that someone has made a Python module to help with it and that Copilot will be
    able to help you use that module effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 9.6 Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You already have a tool that cleans up email text by removing any `>` or space
    characters from the beginning of each line. What steps will you take to enhance
    this tool to also remove lines that are excessively short (e.g., lines with fewer
    than five characters, excluding spaces)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You’re writing a Python program to clean up a bunch of images that you have
    stored on your computer, and you’ve decided to use the Pillow library (a fork
    of the Python Image Library [PIL]). After installing the latest version of Pillow,
    you run your program but encounter the following error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: What steps can you take to fix this problem?
  prefs: []
  type: TYPE_NORMAL
- en: 3\. You’ve been given an Excel file named sales_data.xlsx that contains monthly
    sales data for different products. Your task is to write a Python program that
    reads the sales data, calculates the total sales for each product, and writes
    the results to a new Excel file named total_sales.xlsx. The sales_data.xlsx file
    has columns for each month (January, February, etc.).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your program should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Read the data from `sales_data.xlsx`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the total sales for each product across all months.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the product names and their total sales to `total_sales.xlsx`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hints: make reasonable assumptions about the input file and you may need to
    import libraries to help you work with the .xlsx files. If you don’t have Excel
    or OpenOffice to read/write .xlsx files, feel free to do the task with .csv files
    instead.'
  prefs: []
  type: TYPE_NORMAL
- en: 4\. It can be tedious to find news articles from different sources to read every
    day. Your task is to write a webscraper in Python that extracts and display the
    titles and URLs of the latest articles from a news website. You’ll need the beautifulsoup4
    and requests modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programmers often make tools to automate tedious tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s often necessary to use a Python module to help us write our tool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use Copilot Chat to determine which Python modules we should be using.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s helpful to converse with Copilot to understand the pros and cons of various
    Python modules that may be available to us.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are Python modules for working with the clipboard, working with .pdf files
    and other file formats, copying files, and more.****
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
