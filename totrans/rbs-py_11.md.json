["```py\nfrom fraction import Fraction\nFraction(numerator=3, denominator=5)\n```", "```py\nfrom dataclasses import dataclass\n@dataclass\nclass MyFraction:\n    numerator: int = 0\n    denominator: int = 1\n```", "```py\nimport datetime\nfrom dataclasses import dataclass\nfrom enum import auto, Enum\n\nclass ImperialMeasure(Enum): ![1](../images/00002.gif)\n    TEASPOON = auto()\n    TABLESPOON = auto()\n    CUP = auto()\n\nclass Broth(Enum): ![2](../images/00005.gif)\n    VEGETABLE = auto()\n    CHICKEN = auto()\n    BEEF = auto()\n    FISH = auto()\n\n@dataclass(frozen=True) ![3](../images/00006.gif)\n# Ingredients added into the broth\nclass Ingredient:\n    name: str\n    amount: float = 1\n    units: ImperialMeasure = ImperialMeasure.CUP\n\n@dataclass\nclass Recipe: ![4](../images/00007.gif)\n    aromatics: set[Ingredient]\n    broth: Broth\n    vegetables: set[Ingredient]\n    meats: set[Ingredient]\n    starches: set[Ingredient]\n    garnishes: set[Ingredient]\n    time_to_cook: datetime.timedelta\n```", "```py\npepper = Ingredient(\"Pepper\", 1, ImperialMeasure.TABLESPOON)\ngarlic = Ingredient(\"Garlic\", 2, ImperialMeasure.TEASPOON)\ncarrots = Ingredient(\"Carrots\", .25, ImperialMeasure.CUP)\ncelery = Ingredient(\"Celery\", .25, ImperialMeasure.CUP)\nonions = Ingredient(\"Onions\", .25, ImperialMeasure.CUP)\nparsley = Ingredient(\"Parsley\", 2, ImperialMeasure.TABLESPOON)\nnoodles = Ingredient(\"Noodles\", 1.5, ImperialMeasure.CUP)\nchicken = Ingredient(\"Chicken\", 1.5, ImperialMeasure.CUP)\n\nchicken_noodle_soup = Recipe(\n    aromatics={pepper, garlic},\n    broth=Broth.CHICKEN,\n    vegetables={celery, onions, carrots},\n    meats={chicken},\n    starches={noodles},\n    garnishes={parsley},\n    time_to_cook=datetime.timedelta(minutes=60))\n```", "```py\nchicken_noodle_soup.broth\n>>> Broth.CHICKEN\nchicken_noodle_soup.garnishes.add(pepper)\n```", "```py\n@dataclass\nclass Recipe:\n    aromatics: set[Ingredient]\n    broth: Broth\n    vegetables: set[Ingredient]\n    meats: set[Ingredient]\n    starches: set[Ingredient]\n    garnishes: set[ingredient]\n    time_to_cook: datetime.timedelta\n\n    def make_vegetarian(self):\n        self.meats.clear()\n        self.broth = Broth.VEGETABLE\n\n    def get_ingredient_names(self):\n        ingredients = (self.aromatics |\n                       self.vegetables |\n                       self.meats |\n                       self.starches |\n                       self.garnishes)\n\n        return ({i.name for i in ingredients} |\n                {self.broth.name.capitalize() + \" broth\"})\n```", "```py\nfrom copy import deepcopy\n# make a deep copy so that changing one soup\n# does not change the original\nnoodle_soup = deepcopy(chicken_noodle_soup)\nnoodle_soup.make_vegetarian()\nnoodle_soup.get_ingredient_names()\n>>> {'Garlic', 'Pepper', 'Carrots', 'Celery', 'Onions',\n     'Noodles', 'Parsley', 'Vegetable Broth'}\n```", "```py\n# Both repr() and str() will return the output below\nstr(chicken_noodle_soup)\n>>> Recipe(\n    aromatics={\n        Ingredient(name='Pepper', amount=1, units=<ImperialMeasure.TABLESPOON: 2>),\n        Ingredient(name='Garlic', amount=2, units=<ImperialMeasure.TEASPOON: 1>)},\n    broth=<Broth.CHICKEN: 2>,\n    vegetables={\n        Ingredient(name='Celery', amount=0.25, units=<ImperialMeasure.CUP: 3>),\n        Ingredient(name='Onions', amount=0.25, units=<ImperialMeasure.CUP: 3>),\n        Ingredient(name='Carrots', amount=0.25, units=<ImperialMeasure.CUP: 3>)},\n    meats={\n        Ingredient(name='Chicken', amount=1.5, units=<ImperialMeasure.CUP: 3>)},\n    starches={\n        Ingredient(name='Noodles', amount=1.5, units=<ImperialMeasure.CUP: 3>)},\n    garnishes={\n        Ingredient(name='Parsley', amount=2,\n                   units=<ImperialMeasure.TABLESPOON: 2>)},\n    time_to_cook=datetime.timedelta(seconds=3600)\n)\n```", "```py\nfrom copy import deepcopy\n\n@dataclass(eq=True)\nclass Recipe:\n    # ...\n\nchicken_noodle_soup == noodle_soup\n>>> False\n\nnoodle_soup == deepcopy(noodle_soup)\n>>> True\n```", "```py\nnutritionals = [NutritionInformation(calories=100, fat=1, carbohydrates=3),\n                NutritionInformation(calories=50, fat=6, carbohydrates=4),\n                NutritionInformation(calories=125, fat=12, carbohydrates=3)]\n```", "```py\n>>> sorted(nutritionals)\n```", "```py\nTypeError: '<' not supported between instances of\n           'NutritionInformation' and 'NutritionInformation'\n```", "```py\n@dataclass(eq=True, order=True)\nclass NutritionInformation:\n    calories: int\n    fat: int\n    carbohydrates: int\nnutritionals = [NutritionInformation(calories=100, fat=1, carbohydrates=3),\n                NutritionInformation(calories=50, fat=6, carbohydrates=4),\n                NutritionInformation(calories=125, fat=12, carbohydrates=3)]\n\n>>> sorted(nutritionals)\n    [NutritionInformation(calories=50, fat=6, carbohydrates=4),\n     NutritionInformation(calories=100, fat=1, carbohydrates=3),\n     NutritionInformation(calories=125, fat=12, carbohydrates=3)]\n```", "```py\n@dataclass(eq=True)\nclass NutritionInformation:\n    calories: int\n    fat: int\n    carbohydrates: int\n\n    def __lt__(self, rhs) -> bool:\n        return ((self.fat, self.carbohydrates, self.calories) <\n                (rhs.fat, rhs.carbohydrates, rhs.calories))\n\n    def __le__(self, rhs) -> bool:\n        return self < rhs or self == rhs\n\n    def __gt__(self, rhs) -> bool:\n        return not self <= rhs\n\n    def __ge__(self, rhs) -> bool:\n        return not self < rhs\n\nnutritionals = [NutritionInformation(calories=100, fat=1, carbohydrates=3),\n                NutritionInformation(calories=50, fat=6, carbohydrates=4),\n                NutritionInformation(calories=125, fat=12, carbohydrates=3)]\n\n>>> sorted(nutritionals)\n    [NutritionInformation(calories=100, fat=1, carbohydrates=3),\n     NutritionInformation(calories=50, fat=6, carbohydrates=4),\n     NutritionInformation(calories=125, fat=12, carbohydrates=3)]\n```", "```py\n@dataclass(frozen=True)\nclass Recipe:\n    aromatics: Set[Ingredient]\n    broth: Broth\n    vegetables: Set[Ingredient]\n    meats: Set[Ingredient]\n    starches: Set[Ingredient]\n    garnishes: Set[Ingredient]\n    time_to_cook: datetime.timedelta\n```", "```py\n# assume that Recipe is immutable because\n# frozen was set to true in the decorator\nsoup = Recipe(\n    aromatics={pepper, garlic},\n    broth=Broth.CHICKEN,\n    vegetables={celery, onions, carrots},\n    meats={chicken},\n    starches={noodles},\n    garnishes={parsley},\n    time_to_cook=datetime.timedelta(minutes=60))\n\n# this is an error\nsoup.broth =  Broth.VEGETABLE\n\n# this is not an error\nsoup = Recipe(\n    aromatics=set(),\n    broth=Broth.CHICKEN,\n    vegetables=set(),\n    meats=set(),\n    starches=set(),\n    garnishes=set(),\n    time_to_cook=datetime.timedelta(seconds=3600))\n)\n```", "```py\nsoup.aromatics.add(Ingredient(\"Garlic\"))\n```", "```py\n>>> from collections import namedtuple\n>>> NutritionInformation = namedtuple('NutritionInformation',\n                                      ['calories', 'fat', 'carbohydrates'])\n>>> nutrition = NutritionInformation(calories=100, fat=5, carbohydrates=10)\n>>> print(nutrition.calories)\n\n100\n```"]