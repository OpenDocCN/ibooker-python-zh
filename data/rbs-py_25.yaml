- en: Chapter 21\. Testing Strategy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 21 章。测试策略
- en: Tests are one of most important safety nets you can build around your codebase.
    It is incredibly comforting to make a change and see that all tests pass afterwards.
    However, it is challenging to gauge the best use of your time regarding testing.
    Too many tests and they become a burden; you spend more time maintaining tests
    than delivering features. Too few tests and you are letting potential catastrophes
    make it into production.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是你可以在代码库周围建立的最重要的安全网之一。改变后，看到所有测试通过是非常令人欣慰的。然而，评估测试的最佳时间使用是具有挑战性的。测试过多会成为负担；你会花更多时间维护测试而非交付功能。测试过少会让潜在的灾难进入生产环境。
- en: In this chapter, I will ask you to focus on your testing strategy. I’ll break
    down the different types of tests and how to choose which tests to write. I’ll
    focus on Python best practices around test construction, and then I’ll end with
    some common testing strategies specific to Python.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将请你专注于你的测试策略。我将分解不同类型的测试以及如何选择要编写的测试。我将关注Python在测试构建方面的最佳实践，然后我会结束一些特定于Python的常见测试策略。
- en: Defining Your Test Strategy
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义你的测试策略
- en: 'Before you write tests, you should decide what your *test strategy* will be.
    A test strategy is a plan for spending time and effort to test your software in
    order to mitigate risk. This strategy will influence what types of tests you write,
    how you write them, and how much time you spend writing (and maintaining) them.
    Everybody’s test strategy will be different, but they will all be in a similar
    form: a list of questions about your system and how you plan on answering them.
    For example, if I were writing a calorie-counting app, here would be a part of
    my test strategy:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在你编写测试之前，你应该决定你的 *测试策略* 将是什么。测试策略是在测试软件以减少风险方面花费时间和精力的计划。这种策略将影响你编写什么类型的测试，如何编写它们以及你花费多少时间编写（和维护）它们。每个人的测试策略都会有所不同，但它们都会有类似的形式：关于你的系统及其如何计划回答这些问题的问题列表。例如，如果我正在编写一个卡路里计数应用程序，这将是我的测试策略的一部分：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-6
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Do not treat your test strategy as a static document that is created once and
    never modified. As you develop your software, continue to ask questions as they
    come to mind, and discuss whether your strategy needs to evolve as you learn more.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将你的测试策略视为一次创建并永不修改的静态文档。在开发软件时，继续提问并讨论是否需要根据学到的知识进化你的策略。
- en: This test strategy will govern where you put your focus for writing tests. As
    you start to fill it out, the first thing you need to do is understand what a
    test is and why you write them.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试策略将决定你在编写测试时的关注点。当你开始填写它时，你首先需要了解什么是测试以及为什么要编写它们。
- en: What Is a Test?
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是测试？
- en: You should understand the *what* and the *why* you are writing the software.
    Answering these questions will frame your goals for writing tests. Tests serve
    as a way of verifying *what* the code is doing, and you write tests so that you
    don’t negatively impact the *why*. Software produces value. That’s it. Every piece
    of software has some value attached to it. Web apps provide important services
    for the general population. Data science pipelines may create prediction models
    that help us better understand the patterns in our world. Even malicious software
    has value; the people who are performing the exploit are using the software to
    achieve a goal (even if there is negative value to anyone affected).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该理解为什么和为什么编写软件。回答这些问题将为编写测试确定目标。测试是验证代码执行 *what* 的一种方式，你编写测试是为了不会负面影响 *why*。软件产生价值。这就是全部。每个软件都有一定的附加值。Web
    应用为广大人群提供重要服务。数据科学管道可能创建预测模型，帮助我们更好地理解世界中的模式。即使是恶意软件也有价值；执行攻击的人使用软件来实现目标（即使对受影响者有负面价值）。
- en: That’s *what* software provides, but *why* does anyone write software? Most
    people answer “money,” and I don’t want to knock that, but there are other reasons
    too. Sometimes software is written for money, sometimes it’s written for self-fulfilment,
    and sometimes it’s written for advertising (such as contributing to an open source
    project to bolster a resume). Tests serve as validation for these systems. They
    go so much deeper than just catching errors or giving you confidence in shipping
    a product.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是软件提供的*内容*，但是为什么要写软件呢？大多数人会说“钱”，我不想否认这一点，但也有其他原因。有时候软件是为了赚钱而写的，有时候是为了自我实现，有时候是为了广告（比如为开源项目做贡献以增强简历）。测试为这些系统提供了验证。它们远不止于捕捉错误或者让你在发布产品时有信心。
- en: If I’m writing some code for learning purposes, my *why* is purely for self-fulfilment,
    and the value is derived from how much I learn. If I do things wrong, that is
    still a learning opportunity; I can get by if all my tests are just manual spot
    checks at the end of the project. However, a company that markets tools to other
    developers might have a completely different strategy. Developers at that company
    may choose to write tests to make sure they are not regressing any functionality
    so that the company does not lose customers (which would translate to a loss of
    profit). Each of these projects needs a different level of testing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我为学习目的编写一些代码，那么我的*为什么*纯粹是为了自我实现，价值来自我学到了多少。如果我做错了事情，那也是一个学习机会；如果所有测试只是项目结束时的手工抽查，我也可以应付。然而，市场上为其他开发者提供工具的公司可能有完全不同的策略。这些公司的开发人员可能选择编写测试，以确保他们没有退化任何功能，从而避免公司失去客户（这会转化为利润损失）。每个项目都需要不同层次的测试。
- en: So, what is a test? Is it something that catches errors? Is it something that
    gives you confidence to ship your product? Yes, but the true answer goes a little
    deeper. Tests answer questions about your system. I want you to think about the
    software you write. What is its purpose? What do you want to always know about
    the things you build? The things that are important to you form your test strategy.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '所以，测试是什么？它是用来捕捉错误的东西吗？它是让你有信心发布产品的东西吗？是的，但真正的答案还要深入一些。测试回答了关于你的系统的问题。我希望你思考一下你写的软件。它的目的是什么？关于你构建的东西，你希望永远知道什么？对你重要的东西构成了你的测试策略。  '
- en: 'When you ask yourself questions, you really are asking yourself what tests
    you find valuable:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当你问自己问题时，你真正在问自己的是哪些测试对你有价值：
- en: Will my application handle a predicted load?
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的应用程序能处理预测的负载吗？
- en: Does my code meet the customer’s needs?
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的代码是否满足客户的需求？
- en: Is my application secure?
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我的应用程序安全吗？
- en: What happens when a customer inputs bad data into my system?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当客户向我的系统输入不良数据时会发生什么？
- en: Each one of these questions points to a different type of test that you might
    need to write. Check out [Table 21-1](part0027_split_002.html#testing_questions)
    for a list of common questions and the appropriate tests that answer those questions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个问题都指向你可能需要编写的不同类型的测试。查看[表 21-1](part0027_split_002.html#testing_questions)，列出了常见问题和相应的测试类型。
- en: Table 21-1\. Types of tests and the questions they answer
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 表 21-1\. 测试类型及其所回答的问题
- en: '| Test type | Question the test answers |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 测试类型 | 测试回答的问题 |'
- en: '| --- | --- |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Unit | Do units (functions and classes) act as developers expect? |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 单元 | 单元（函数和类）是否如开发人员期望的那样工作？ |'
- en: '| Integration | Are separate parts of the system stitched together properly?
    |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 集成 | 系统的各个部分是否正确地拼接在一起？ |'
- en: '| Acceptance | Does the system do what the end user expects? |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 验收 | 系统是否符合最终用户的期望？ |'
- en: '| Load | Does the system stay operational under heavy duress? |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 负载 | 系统在重压下是否保持操作能力？ |'
- en: '| Security | Does the system resist specific attacks and exploits? |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 安全性 | 系统是否能抵御特定的攻击和利用？ |'
- en: '| Usability | Is the system intuitive to use? |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 可用性 | 系统是否直观易用？ |'
- en: Notice that [Table 21-1](part0027_split_002.html#testing_questions) did not
    say anything about making sure your software is bug free. As Edsger Djikstra wrote,
    “Program testing can be used to show the presence of bugs, but never to show their
    absence!”^([1](part0027_split_007.html#idm45644727274344)) Tests answer questions
    regarding the *quality* of your software.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，[表 21-1](part0027_split_002.html#testing_questions) 没有提到确保软件没有bug。正如Edsger
    Djikstra所说，“程序测试可以用来显示bug的存在，但永远不能证明其不存在！”^([1](part0027_split_007.html#idm45644727274344))
    测试回答了关于你的软件*质量*的问题。
- en: '*Quality* is this nebulous, ill-defined term that gets tossed around quite
    a bit. It’s a tough thing to pin down, but I prefer this quote from Gerald Weinberg:
    “Quality is value to some person.”^([2](part0027_split_007.html#idm45644727268952))
    I love how open-ended this quote is; you need to think of anyone who may receive
    some value from your system. It’s not just your direct customers, but your customers’
    customers, your operations team, your sales, your coworkers, and so on.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*质量* 是一个模糊的、难以定义的术语，经常被人提及。这是一个难以把握的东西，但我更喜欢 Gerald Weinberg 的这句话：“质量是对某个人的价值。”^([2](part0027_split_007.html#idm45644727268952))
    我喜欢这句话多么开放式；你需要考虑到任何可能从你的系统中获得价值的人。不仅仅是你的直接客户，还有你客户的客户，你的运维团队，你的销售团队，你的同事等等。'
- en: Once you’ve identified who receives the value of your system, you need to measure
    the impact when something goes wrong. For every test that is not run, you lose
    a chance to learn whether you are delivering value. What is the impact if that
    value is not delivered? For core business needs, the impact is pretty high. For
    features that lie outside of an end user’s critical path, the impact may be low.
    Know your impact, and weigh that against the cost of testing. If the impact’s
    cost is higher than the test, write the test. If it’s lower, skip writing the
    test and spend your time doing something more impactful.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了谁从你的系统中获得价值，你需要在出现问题时衡量影响。对于每个未运行的测试，你失去了了解你是否正在交付价值的机会。如果未能交付该价值会有什么影响？对于核心业务需求，影响是相当大的。对于不在最终用户关键路径之外的功能，影响可能较小。了解你的影响，并将其与测试成本进行权衡。如果影响的成本高于测试的成本，写测试。如果低于测试成本，跳过编写测试，花时间做更有影响力的事情。
- en: The testing pyramid
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试金字塔
- en: 'In just about any testing book, you are bound to come across a figure similar
    to [Figure 21-1](part0027_split_002.html#testing_pyramid): a “testing pyramid.”^([3](part0027_split_007.html#idm45644727260312))'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎在任何测试书籍中，你都会碰到类似于 [图 21-1](part0027_split_002.html#testing_pyramid) 的图：一个“测试金字塔”。^([3](part0027_split_007.html#idm45644727260312))
- en: '![ropy 2101](../images/00039.gif)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![ropy 2101](../images/00039.gif)'
- en: Figure 21-1\. The testing pyramid
  id: totrans-35
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 21-1\. 测试金字塔
- en: The idea is that you want to write a lot of small, isolated unit tests. These
    are theoretically cheaper and should make up the bulk of your testing, hence they’re
    at the bottom. You have fewer integration tests, which are costly, and even fewer
    UI tests, which are very costly. Now, ever since its inception, developers have
    argued about the testing pyramid in a multitude of ways, including where the lines
    get drawn, the usefulness of unit tests, and even the shape of the triangle (I’ve
    even seen the triangle inverted).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是你想要编写大量小型、孤立的单元测试。理论上这些测试成本较低，应该占据你测试的大部分，因此它们位于底部。你有较少的集成测试，这些成本较高，甚至更少的
    UI 测试，这些成本非常高。从诞生之时起，开发者们就在多种方式上辩论测试金字塔，包括画线的位置、单元测试的有效性，甚至三角形的形状（我甚至见过倒置的三角形）。
- en: The truth is, it doesn’t matter what the labels are or how you separate your
    tests. What you want is your triangle to look like [Figure 21-2](part0027_split_002.html#pat_testing_pyramid),
    which focuses on the ratio of value to cost.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，标签是什么或者你如何分隔你的测试并不重要。你想要的是你的三角形看起来像 [图 21-2](part0027_split_002.html#pat_testing_pyramid)，它侧重于价值与成本的比率。
- en: '![ropy 2102](../images/00040.gif)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![ropy 2102](../images/00040.gif)'
- en: Figure 21-2\. The testing pyramid focused on value-to-cost
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 21-2\. 着眼于价值与成本的测试金字塔
- en: Write lots of tests that have a high value-to-cost ratio. It doesn’t matter
    if they are unit tests or acceptance tests. Find ways to run them often. Make
    tests fast so that developers run them multiple times between commits to verify
    that things are still working. Keep your less valuable, slower, or more costly
    tests for testing on each commit (or at least periodically).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 写大量价值与成本比高的测试。无论是单元测试还是验收测试都无所谓。找到方法经常运行它们。让测试快速运行，这样开发者在提交之间多次运行它们，验证事情仍然正常工作。把你的不那么有价值、较慢或者成本较高的测试保留用于每次提交时的测试（或至少定期测试）。
- en: The more tests you have, the fewer unknowns you have. The fewer unknowns you
    have, the more robust your codebase will be. With every change you make, you have
    a bigger safety net to check for any regression. But what if the tests are becoming
    too costly, far outweighing the cost of any impact? If you feel these tests are
    still worthwhile, you need to find a way to reduce their cost.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你拥有的测试越多，你就会有越少的未知数。你拥有的未知数越少，你的代码库就会更加健壮。每次你进行更改时，你都有一个更大的安全网来检查任何回归。但是，如果测试变得过于昂贵，远远超过任何影响的成本，该怎么办？如果你觉得这些测试仍然值得，你需要找到一种方式来降低它们的成本。
- en: 'The cost of a test is threefold: the initial cost of writing, the cost of running,
    and the cost for maintenance. Tests, at a minimum, will have to run for some amount
    of time, and that does cost money. However, reducing that cost often becomes an
    optimization exercise, where you look for ways of parallelizing your tests or
    running them more frequently on developer machines. You still need to reduce the
    initial cost of writing and ongoing cost of maintaining your tests. Fortunately,
    everything you’ve read in this book so far directly applies to reducing those
    costs. Your test code is just as much a part of your codebase as the rest of your
    code, and you need to make sure it is robust as well. Choose the right tools,
    organize your test cases properly, and make your tests clear to read and maintain.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 测试成本包括三个方面：编写的初始成本、运行的成本以及维护的成本。测试至少需要运行一段时间，这将耗费资金。然而，减少这些成本通常成为优化练习，您可以寻找并行化测试或在开发人员机器上更频繁地运行测试的方式。您仍然需要减少编写的初始成本和维护测试的持续成本。幸运的是，迄今为止您所阅读的每一本书都直接适用于减少这些成本。您的测试代码与您代码库的其余部分一样重要，您需要确保它同样强大。选择正确的工具，正确组织您的测试用例，并确保您的测试清晰易读且易于维护。
- en: Discussion Topic
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论话题
- en: Measure the costs of tests in your system. Does time to write, time to run,
    or time spent maintaining dominate your costs? What can you do to reduce those
    costs?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 评估系统中测试的成本。编写时间、运行时间或维护时间哪个占主导地位？您可以采取什么措施来降低这些成本？
- en: Reducing Test Cost
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 降低测试成本
- en: When you examine the value against the cost of a test, you are gathering information
    that will help you prioritize your testing strategy. Some tests may not be worth
    running, and some will stand out as the first tests you want to write to maximize
    value. However, sometimes you run into the case where there is a really important
    test that you want to write, but it is incredibly costly to write and/or maintain.
    In these cases, find a way to reduce the costs of that test. The way you write
    and organize your tests is paramount to making a test cheaper to write and understand.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当您对比测试成本与价值时，您正在收集将帮助您优先考虑测试策略的信息。有些测试可能不值得运行，而有些则会成为您希望首先编写以最大化价值的测试。然而，有时候您可能会遇到这样的情况：有一个非常重要的测试，您希望编写，但编写和/或维护成本非常高。在这种情况下，找到一种方法来降低该测试的成本。编写和组织测试的方式对于使测试更便宜、更易于理解至关重要。
- en: AAA Testing
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AAA测试
- en: As with production code, focus on readability and maintainability in your test
    code. Communicate your intent as clearly as possible. Future test readers will
    thank you if they can see exactly what you are trying to test. When writing a
    test, it helps for each test to follow the same basic pattern.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与生产代码一样，专注于测试代码的可读性和可维护性。尽可能清晰地传达您的意图。如果测试读者能清楚地看到您试图测试的内容，他们会感谢您。在编写测试时，每个测试遵循相同的基本模式会有所帮助。
- en: One of the most common patterns you’ll find in tests is the 3A, or AAA, test
    pattern.^([4](part0027_split_007.html#idm45644727210584)) AAA stands for *Arrange-Act-Assert*.
    You break up each test into three separate blocks of code, one for setting up
    your preconditions (arrange), one for performing the operations that are being
    tested (act), and then one for checking for any post-conditions (assert). You
    may also hear about a fourth A, for *annihilate*, or your clean-up code. I’ll
    cover each of these steps in detail to discuss how to make your tests easier to
    read and maintain.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中您将发现的最常见的模式之一是3A或AAA测试模式^([4](part0027_split_007.html#idm45644727210584))。AAA代表*Arrange-Act-Assert*。您将每个测试分为三个独立的代码块：一个用于设置预置条件（arrange），一个用于执行正在测试的操作（act），然后一个用于检查任何后置条件（assert）。您可能也会听说第四个A，用于*annihilate*或清理代码。我将详细介绍每个步骤，讨论如何使您的测试更易于阅读和维护。
- en: Arrange
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安排
- en: The *arrange* step is all about setting up the system in a state that is ready
    to test. These are called the *preconditions* of the test. You set up any dependencies
    or test data that are needed for the test to operate correctly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*安排*步骤主要是设置系统处于准备测试的状态。这些被称为测试的*前置条件*。您设置任何依赖项或测试数据，以确保测试能够正确运行。'
- en: 'Consider the following test:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下测试：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First, I add ingredients to a database and associate a list of ingredients with
    a dish called “Bacon Cheeseburger w/ Fries.” Then I find out how many calories
    are in the burger, check this against a known value, and clean up the database.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我向数据库添加食材，并将食材列表与名为“培根奶酪汉堡配薯条”的菜肴关联。然后，我查找汉堡的卡路里数量，检查它与已知值是否一致，并清理数据库。
- en: Look how much code there is before I actually get to the test itself (the `get_calories`
    invocation). Large *arrange* blocks are a red flag. You will have many tests that
    look very similar, and you want readers to be able to know how they differ at
    a glance.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 看看在我实际进入测试本身之前有多少代码（`get_calories` 调用）。庞大的*arrange*块是一个警告信号。你将会有很多看起来非常相似的测试，你希望读者能够一目了然地知道它们之间的区别。
- en: Warning
  id: totrans-56
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Large *arrange* blocks may indicate a complicated setup of dependencies. Any
    user of this code will presumably have to set up the dependencies in a similar
    way. Take a step back and ask if there are simpler ways to handle dependencies,
    such as using the strategies described in [Part III](part0019.html#part_3).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 大型的*arrange*块可能表示依赖关系的复杂设置。代码的任何使用者都可能需要以类似的方式设置这些依赖关系。退一步思考，问自己是否有更简单的方法来处理依赖关系，比如使用第
    III 部分中描述的策略。
- en: In the preceding example, if I have to add 15 ingredients in two separate tests
    but set an ingredient slightly differently to simulate substitutions, it will
    be difficult to eyeball how the tests differ. Giving the tests verbose names indicating
    their differences is a good step to make, but that only goes so far. Find a balance
    between keeping the test informative and making it easy to read at a glance.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，如果我必须在两个单独的测试中添加15种成分，但设置一个成分稍有不同以模拟替换，那么眼测这些测试的区别将会很困难。给这些测试起一个能够指示它们不同之处的详细名称是一个不错的方法，但这只能走得这么远。要在保持测试信息丰富与便于一目了然之间找到平衡点。
- en: Consistent preconditions versus changing preconditions
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一致的前提条件与变化的前提条件
- en: 'Look through your tests and ask yourself what preconditions are the same across
    sets of tests. Extract these through a function and reuse that function across
    each test. Look how much easier it is to compare the following two tests:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 查看你的测试并问问自己哪些前提条件在一组测试中是相同的。通过函数提取这些条件并在每个测试中重复使用该函数。看看比较以下两个测试变得多么容易：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By creating helper functions (in this case, `add_base_ingredients_to_database`
    and `setup_bacon_cheeseburger`), you take all the unimportant boilerplate of the
    tests and reduce it, allowing developers to hone in on differences between tests.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建辅助函数（在本例中为 `add_base_ingredients_to_database` 和 `setup_bacon_cheeseburger`），你可以将所有不重要的测试样板代码减少，使开发人员能够专注于测试之间的差异。
- en: Use test framework features for boilerplate code
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用测试框架特性来处理样板代码
- en: Most test frameworks provide a way to run code automatically before tests. In
    the built-in `unittest` module, you can write a `setUp` function to run before
    every test. In `pytest`, you accomplish something similar with fixtures.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数测试框架都提供了一种在测试前自动运行代码的方法。在内置的 `unittest` 模块中，你可以编写一个 `setUp` 函数在每个测试前运行。在
    `pytest` 中，你可以通过 fixture 实现类似的功能。
- en: 'A *fixture* in `pytest` is a way of specifying initialization and teardown
    code for tests. Fixtures offer a ton of useful features, like defining dependencies
    on other fixtures (letting `pytest` control initialization order) and controlling
    initialization so that a fixture is only initialized once per module. In the previous
    example, we could have used a fixture for the `test_database`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `pytest` 中，*fixture* 是指定测试初始化和清理代码的一种方式。Fixture 提供了许多有用的功能，如定义对其他 fixture
    的依赖（让 `pytest` 控制初始化顺序）和控制初始化，以便每个模块只初始化一次 fixture。在前面的示例中，我们可以为 `test_database`
    使用一个 fixture：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice how the test has an argument for `test_database` now. This is the fixture
    at work; the function `test_database` (as well as `db_creation`) will get called
    before the test. Fixtures only become more useful as the number of tests grows.
    They are composable, allowing you to mix them together and reduce code duplication.
    I won’t generally use them to abstract code in a single file, but as soon as that
    initialization needs to be used in multiple files, fixtures are the way to go.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在测试中有一个 `test_database` 参数。这就是 fixture 的工作原理；函数 `test_database`（以及 `db_creation`）会在测试之前调用。随着测试数量的增加，fixture
    变得越来越有用。它们是可组合的，允许你将它们组合在一起，减少代码重复。通常情况下，我不会将它们用来抽象单个文件中的代码，但一旦初始化需要在多个文件中使用时，fixture
    就是最佳选择。
- en: Mocking
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模拟
- en: 'Python offers duck typing (first mentioned in [Chapter 2](part0005_split_000.html#types))
    as part of its type system, which means that you can easily substitute types for
    one another as long as they uphold the same contract (as discussed in [Chapter 12](part0016_split_000.html#subtyping)).
    This means that you can tackle complex dependencies in a completely different
    way: use a simple mocked object instead. A *mocked* object is something that looks
    identical to a production object as far as methods and fields go, but offers simplified
    data.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了鸭子类型（首次在[第二章](part0005_split_000.html#types)提到）作为其类型系统的一部分，这意味着只要它们遵循相同的契约，你可以很容易地将类型替换为另一个类型（如在[第12章](part0016_split_000.html#subtyping)中讨论的那样）。这意味着你可以完全不同地处理复杂的依赖关系：使用一个简单的模拟对象代替。*mocked*对象是看起来与生产对象完全相同（方法和字段），但提供了简化的数据。
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Mocks are used a lot in unit tests, but you will see their usage decline the
    less granular the tests become. This is because you try to test more of the system
    at a higher level; the services you are mocking are often part of the tests.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试中经常使用模拟对象（Mocks），但随着测试变得不那么细粒度，它们的使用会减少。这是因为你尝试在更高层次测试系统的同时，你正在模拟的服务往往是测试的一部分。
- en: 'For instance, if the database in the previous example was quite complex to
    set up with multiple tables and schemas, it might not be worth setting up for
    every test, especially if tests share a database; you want to keep tests isolated
    from one another. (I’ll cover this more in a moment.) The class handling the database
    might look like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果前面示例中的数据库设置非常复杂，有多个表和模式，可能不值得为每个测试设置，特别是如果测试共享一个数据库；你希望保持测试互相隔离。（稍后我将详细讨论这一点。）处理数据库的类可能如下所示：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Instead of using this class verbatim, create a mock class that just looks like
    a database handler:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是直接使用这个类，创建一个看起来像数据库处理程序的模拟类：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With the mock, I’m just using a simple dictionary to store my data. How you
    mock your data will be different for each scenario, but if you can find a way
    to substitute the real object with a mock object, you can dramatically reduce
    the complexity of your setup.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模拟对象，我只是使用一个简单的字典来存储我的数据。如何模拟你的数据将因情况而异，但如果你能找到一种方法用模拟对象替换真实对象，你可以显著降低设置的复杂性。
- en: Warning
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Some people use [*monkeypatching*](https://oreil.ly/xBFHl), or swapping out
    methods at runtime to inject mocks. This is OK in moderation, but if you find
    your tests littered with monkeypatching, this is an antipattern. It means that
    you have far too rigid a physical dependency between different modules and should
    look at finding ways to make your system more modular. (Consult [Part III](part0019.html#part_3)
    for more ideas on making code extensible.)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人使用[*monkeypatching*](https://oreil.ly/xBFHl)，即在运行时替换方法以注入模拟对象。适度使用这种方法是可以接受的，但如果你发现你的测试中充斥着monkeypatching，这是一种反模式。这意味着你的不同模块之间有过于严格的物理依赖，应该考虑找到方法使你的系统更加模块化。（请参阅[第三部分](part0019.html#part_3)了解更多关于使代码可扩展性的想法。）
- en: Annihilate
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消灭
- en: Technically, the *annihilate* stage is the last thing you do in a test, but
    I’m covering it second. Why? Because it’s inherently tied to your *arrange* step.
    Whatever you set up in *arrange* needs to be torn down if it could influence other
    tests.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，*annihilate* 阶段是你在测试中做的最后一件事，但我却在第二次讨论它。为什么呢？因为它与你的*arrange*步骤密切相关。无论你在*arrange*中设置了什么，如果它可能影响其他测试，都需要拆除。
- en: You want your tests to be isolated from one another; it will make them easier
    to maintain. One of the biggest nightmares for a test automation writer is having
    tests fail depending on what order they run in (especially if you have thousands).
    This is a sure sign of tests having subtle dependencies on one another. Clean
    up your tests before you leave them and reduce the chances of tests interacting
    with one another. Here are some strategies for dealing with test cleanup.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望你的测试互相隔离；这样会使它们更易于维护。对于测试自动化写作者来说，最大的噩梦之一就是测试失败取决于它们运行的顺序（尤其是如果你有成千上万个测试）。这是测试彼此之间存在微妙依赖的明确迹象。在离开之前清理你的测试，并减少测试相互交互的可能性。以下是一些处理测试清理的策略。
- en: Don’t use shared resources
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不要使用共享资源
- en: If you can get away with it, share nothing between tests. This isn’t always
    feasible, but it should be your goal. If no tests share any resources, then you
    don’t need to clean anything up. A shared resource can be in Python (global variable,
    class variables) or in the environment (database, file access, socket pools).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以做到的话，测试之间不要共享任何东西。这并不总是可行的，但这应该是你的目标。如果没有测试共享任何资源，那么你就不需要清理任何东西。共享资源可以是Python中的（全局变量，类变量）或环境中的（数据库，文件访问，套接字池）。
- en: Use context managers
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用上下文管理器
- en: 'Use a context manager (discussed in [Chapter 11](part0015_split_000.html#api))
    to ensure that resources are always cleaned up. In my previous example, eagle-eyed
    readers may have noticed a bug:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上下文管理器（在[第11章](part0015_split_000.html#api)讨论）确保资源始终被清理。在我的上一个示例中，眼尖的读者可能已经注意到了一个错误：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If the assertion fails, an exception is raised and `cleanup_database` never
    executes. It would be much better to force usage through a context manager:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果断言失败，则会引发异常，`cleanup_database`永远不会执行。更好的方法是通过上下文管理器强制使用：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Put your cleanup code in the context manager so that your test writers never
    have to actively think about it; it’s just done for them.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将清理代码放在上下文管理器中，这样你的测试编写者永远不必主动考虑它；它已经为他们完成了。
- en: Use fixtures
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用夹具
- en: 'If you are using `pytest` fixtures, you can use them much like you could a
    context manager. You can *yield* values from a fixture, allowing you to return
    to the fixture’s execution after the test finishes. Observe:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用`pytest`夹具，你可以像使用上下文管理器一样使用它们。你可以从夹具*yield*值，允许你在测试完成后返回到夹具的执行。观察：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice how the `test_database` fixture now yields the database. When any test
    using this function finishes (whether it passes or fails), the database cleanup
    function will always execute.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意现在`test_database`夹具如何产生数据库。当使用此函数的任何测试完成（无论是通过还是失败），数据库清理函数都将始终执行。
- en: Act
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行动
- en: The *act* stage is the most important part of the test. It embodies the actual
    operation that you are testing. In the preceding examples, the *act* stage was
    getting the calories for a specific dish. You do not want an *act* stage to be
    much longer than one or two lines of code. Less is more; by keeping this stage
    small, you reduce the time it takes readers to understand the meat of the test.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*act*阶段是测试中最重要的部分。它体现了你要测试的实际操作。在前面的例子中，*act*阶段是获取特定菜品的卡路里。你不希望*act*阶段比一两行代码长。少即是多；通过保持此阶段小，可以减少读者理解测试的核心内容所需的时间。'
- en: Sometimes, you want to reuse the same *act* stage across multiple tests. If
    you find yourself wanting to write the same test on the same action, but with
    slightly different input data and assertions, consider *parameterizing* your tests.
    Test *parameterization* is a way of running the same test on different parameters.
    This allows you to write *table-driven* tests, or a way of organizing your test
    data in a tabular form.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你希望在多个测试之间重复使用相同的*act*阶段。如果你发现自己想要编写相同的测试，但输入数据和断言略有不同，请考虑对测试*参数化*。测试*参数化*是一种在不同参数上运行相同测试的方法。这允许你编写*table-driven*测试，或以表格形式组织测试数据的方法。
- en: 'Here is the `get_calories` test with parameterization:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用参数化的`get_calories`测试：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You define your parameters as a list of tuples, one per test case. Each parameter
    is passed to the test case as an argument. `pytest` automatically will run this
    test, once per parameter set.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将参数定义为元组列表，每个测试用例一个。每个参数都作为参数传递给测试用例。`pytest`会自动对每组参数运行此测试。
- en: Parameterized tests have the benefit of condensing a lot of test cases into
    one function. Readers of the test can just go down through the table listed in
    the parameterization to understand what expected input and output is (Cobb salad
    should have 1,000 calories, mashed potatoes should have 400 calories, and so on).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化测试的好处是将许多测试用例压缩到一个函数中。测试的读者只需按照参数化表中列出的顺序查看表格，就可以理解预期的输入和输出是什么（科布沙拉应该有1,000卡路里，土豆泥应该有400卡路里，等等）。
- en: Warning
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Parameterization is a great way to separate the test data from the actual test
    (similar to separating policy and mechanisms, as discussed in [Chapter 17](part0022_split_000.html#composability)).
    However, be careful. If you make your tests too generic, it will be harder to
    ascertain what they are testing. Avoid using more than three or four parameters
    if you can.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化是将测试数据与实际测试分离的好方法（类似于分离策略和机制，如[第17章](part0022_split_000.html#composability)所讨论的）。但是要小心。如果你让你的测试过于通用，那么确定它们在测试什么就会更加困难。如果可以的话，避免使用三四个以上的参数。
- en: Assert
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断言
- en: The last step to do before cleaning up is *asserting* some property is true
    about the system. Preferably, there should be one logical assertion near the end
    of your test. If you find yourself jamming too many assertions into a test, you
    either have too many actions in your test or too many tests matched into one.
    When a test has too many responsibilities, it makes it harder for maintainers
    to debug software. If they make a change that produces a failed test, you want
    them to be able to quickly find out what the problem is. Ideally, they can figure
    out what’s wrong based on the test name, but at the very least, they should be
    able to open up the test, look for about 20 or 30 seconds, and realize what went
    wrong. If you have multiple assertions, you have multiple reasons a test can go
    wrong, and it will take maintainers time to sort through them.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在清理之前要做的最后一步是*断言*关于系统的某个属性为真。最好，在你的测试末尾应该有一个逻辑断言。如果你发现自己在一个测试中塞入了太多断言，要么是你的测试中有太多动作，要么是太多测试匹配到了一个。当一个测试有太多责任时，维护者很难调试软件。如果他们进行了一个导致测试失败的更改，你希望他们能快速找出问题所在。理想情况下，他们可以根据测试名称找出问题，但至少他们应该能打开测试，看上去大约20或30秒，就能意识到出了什么问题。如果有多个断言，就有多个原因会导致测试失败，维护者需要花时间来梳理它们。
- en: This doesn’t mean that you should only have one *assert* statement; it is OK
    to have a few *assert* statements as long as they are all involved in testing
    the same property. Make your assertions verbose as well, so that developers get
    an informative message when things go wrong. In Python, you can supply a text
    message that gets passed along with the `AssertionError` to help with debugging.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着你只能有一个*assert*语句；只要它们都涉及测试相同的属性，有几个*assert*语句也是可以的。同样要使你的断言详细，这样开发人员在出错时能得到有用的信息。在Python中，你可以提供一个文本消息，随着`AssertionError`一起传递，以帮助调试。
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`pytest` rewrites assertion statements, which also provides an extra level
    of debug messages. If the above test were to fail, the message returned to the
    test writer would be:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest`重新编写断言语句，这也提供了额外的调试消息级别。如果上述测试失败，返回给测试编写者的消息将是：'
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For more complex assertions, build up an assertion library that makes it incredibly
    easy to define new tests. This is like building a vocabulary in your codebase;
    you want a diverse set of concepts to share in your test code as well. For this,
    I recommend using [Hamcrest matchers](http://hamcrest.org).^([5](part0027_split_007.html#idm45644726341656))
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的断言，构建一个断言库可以非常轻松地定义新的测试。这就像在你的代码库中建立词汇表一样；你希望测试代码中有多样的概念可以共享。为此，我推荐使用[Hamcrest匹配器](http://hamcrest.org)。^([5](part0027_split_007.html#idm45644726341656))
- en: '*Hamcrest matchers* are a way of writing assertions to read similarly to natural
    language. The [`PyHamcrest`](https://github.com/hamcrest/PyHamcrest) library supplies
    common matchers to help you write your asserts. Take a look at how it uses custom
    assertion matchers to make tests more clear:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*Hamcrest匹配器*是一种编写断言，以类似自然语言的方式阅读的方法。[`PyHamcrest`](https://github.com/hamcrest/PyHamcrest)库提供了常见的匹配器，帮助你编写你的断言。看看它如何使用自定义断言匹配器来使测试更加清晰：'
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The real strength of `PyHamcrest` is that you can define your own matchers.^([6](part0027_split_007.html#idm45644726260312))
    Here’s an example of a matcher for checking if a dish is vegan:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`PyHamcrest`的真正强大之处在于你可以定义自己的匹配器。^([6](part0027_split_007.html#idm45644726260312))'
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the test fails, you get the following error:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试失败，你会得到以下错误：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Discussion Topic
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论主题
- en: Where in your tests can you use custom matchers? Discuss what a shared testing
    vocabulary would be in your tests and how custom matchers would improve readability.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的测试中，你可以在哪里使用自定义匹配器？讨论在你的测试中共享的测试词汇会是什么，以及自定义匹配器如何提高可读性。
- en: Closing Thoughts
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结思考
- en: Just like a tightrope walker’s safety net, tests give you comfort and confidence
    as you work. It’s not just about finding bugs. Tests verify that what you build
    is performing as you expect. They give future collaborators leeway to make more
    risky changes; they know that if they fall, the tests will catch them. You will
    find that regressions become more rare, and your codebase becomes easier to work
    in.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 就像走钢丝的安全网一样，测试在你工作时给予你安全感和信心。这不仅仅是找到错误。测试验证你构建的东西是否按照你的期望执行。它们给未来的合作者提供了更多的自由去做更多风险的改变；他们知道如果他们失败，测试会捕捉到他们。你会发现回归变得更加少见，你的代码库变得更容易工作。
- en: 'However, tests are not free. There is a cost to writing, running, and maintaining
    them. You need to be careful how you spend your time and effort. Use well-known
    patterns in constructing tests to minimize the cost: follow the AAA pattern, keep
    each stage small, and make your tests clear and readable. Your tests are just
    as important as your codebase. Treat them with just as much respect and make them
    robust.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，测试并非免费。编写、运行和维护测试都是有成本的。你需要谨慎地安排你的时间和精力。使用构建测试的知名模式来最小化成本：遵循 AAA 模式，保持每个阶段简短，并确保你的测试清晰易读。你的测试和你的代码库一样重要。要同样尊重它们，并使其健壮。
- en: In the next chapter, I will focus on acceptance tests. Acceptance tests have
    a different purpose than unit or integration tests, and some of the patterns you
    use will differ.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将专注于验收测试。验收测试有不同于单元测试或集成测试的目的，你使用的一些模式将不同。
- en: You will learn about how acceptance tests create conversations, as well as how
    they make sure your codebase is doing the right thing for your customers. They
    are an invaluable tool for your codebase in delivering value.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习到验收测试如何引发对话，以及如何确保你的代码库为客户正确执行任务。它们是交付价值的代码库中的宝贵工具。
- en: ^([1](part0027_split_002.html#idm45644727274344-marker)) Edsger W. Dijkstra.
    “Notes on Structured Programming.” Technological University Eindhoven, The Netherlands,
    Department of Mathematics, 1970\. [*https://oreil.ly/NAhWf*](https://oreil.ly/NAhWf).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](part0027_split_002.html#idm45644727274344-marker)) Edsger W. Dijkstra。“关于结构化编程的注释。”荷兰，埃因霍温科技大学，数学系，1970年。[*https://oreil.ly/NAhWf*](https://oreil.ly/NAhWf)。
- en: '^([2](part0027_split_002.html#idm45644727268952-marker)) Gerald M. Weinberg.
    *Quality Software Management*. Vol. 1: *Systems Thinking*. New York, NY: Dorset
    House Publishing, 1992.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](part0027_split_002.html#idm45644727268952-marker)) Gerald M. Weinberg。《优质软件管理》。第
    1 卷：《系统思维》。纽约，纽约：Dorset House Publishing，1992年。
- en: ^([3](part0027_split_002.html#idm45644727260312-marker)) This is known as the
    testing pyramid, introduced in *Succeeding with Agile* by Mike Cohn (Addison-Wesley
    Professional). Cohn originally has “Service” level tests in place of integration
    tests, but I’ve seen more iterations with “integration” tests as the middle layer.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](part0027_split_002.html#idm45644727260312-marker)) 这被称为测试金字塔，在迈克·科恩（Mike
    Cohn）的《成功实现敏捷》（Addison-Wesley Professional）中首次提出。Cohn 最初使用“Service”级别测试代替集成测试，但我看到更多的迭代使用“integration”测试作为中间层。
- en: ^([4](part0027_split_005.html#idm45644727210584-marker)) The AAA pattern was
    first named by Bill Wake in 2001\. Check out [this blog post](https://oreil.ly/gdU4T)
    for more information.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](part0027_split_005.html#idm45644727210584-marker)) AAA 模式最早由 Bill Wake
    在 2001 年命名。查看[这篇博文](https://oreil.ly/gdU4T)了解更多信息。
- en: ^([5](part0027_split_005.html#idm45644726341656-marker)) Hamcrest is an anagram
    of “matchers.”
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](part0027_split_005.html#idm45644726341656-marker)) Hamcrest 是“matchers”的字母重排。
- en: ^([6](part0027_split_005.html#idm45644726260312-marker)) Check out the [PyHamcrest
    documentation](https://oreil.ly/XWjOd) for more information, such as additional
    matchers or integrating with test frameworks.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](part0027_split_005.html#idm45644726260312-marker)) 查看[PyHamcrest 文档](https://oreil.ly/XWjOd)了解更多信息，如额外的匹配器或与测试框架的集成。
