- en: Chapter 8\. Dictionaries and Sets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章。字典和集合
- en: If a word in the dictionary were misspelled, how would we know?
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果字典中的单词拼错了，我们怎么知道呢？
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Steven Wright
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 史蒂文·赖特
- en: Dictionaries
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典
- en: 'A *dictionary* is similar to a list, but the order of items doesn’t matter,
    and they aren’t selected by an offset such as 0 or 1. Instead, you specify a unique
    *key* to associate with each *value*. This key is often a string, but it can actually
    be any of Python’s immutable types: boolean, integer, float, tuple, string, and
    others that you’ll see in later chapters. Dictionaries are mutable, so you can
    add, delete, and change their key-value elements. If you’ve worked with languages
    that support only arrays or lists, you’ll love dictionaries.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*字典* 类似于列表，但条目的顺序无关紧要，也不是通过像 0 或 1 这样的偏移来选择。而是为每个 *值* 指定一个唯一的 *key* 来关联。这个键通常是一个字符串，但实际上可以是
    Python 的任何不可变类型：布尔值、整数、浮点数、元组、字符串和其他在后面章节中会看到的类型。字典是可变的，因此可以添加、删除和更改它们的键值元素。如果您曾经使用过只支持数组或列表的语言，您会喜欢字典的。'
- en: Note
  id: totrans-6
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In other languages, dictionaries might be called *associative arrays*, *hashes*,
    or *hashmaps*. In Python, a dictionary is also called a *dict* to save syllables
    and make teenage boys snicker.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中，字典可能被称为 *关联数组*、*哈希* 或 *哈希映射*。在 Python 中，字典也被称为 *dict*，以节省音节并让十几岁的男孩窃笑。
- en: Create with {}
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 {} 创建
- en: 'To create a dictionary, you place curly brackets (`{}`) around comma-separated
    *`key`* `:` *`value`* pairs. The simplest dictionary is an empty one, containing
    no keys or values at all:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建字典，您需要在逗号分隔的 *`key`* `:` *`value`* 对之间放置花括号 (`{}`)。最简单的字典是一个完全不包含任何键或值的空字典：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s make a small dictionary with quotes from Ambrose Bierce’s *The Devil’s*
    *Dictionary*:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从安布罗斯·彼尔斯的 *魔鬼的词典* 中摘取一些引文，制作一个小字典：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Typing the dictionary’s name in the interactive interpreter will print its
    keys and values:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互解释器中输入字典的名称将打印其键和值：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-15
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In Python, it’s okay to leave a comma after the last item of a list, tuple,
    or dictionary. Also, you don’t need to indent, as I did in the preceding example,
    when you’re typing keys and values within the curly braces. It just helps readability.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，如果列表、元组或字典的最后一项后面留有逗号是可以的。当您在花括号中键入键和值时，就像在前面的例子中所做的那样，不需要缩进。这只是为了提高可读性。
- en: Create with dict()
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 dict() 创建
- en: Some people don’t like typing so many curly brackets and quotes. You can also
    create a dictionary by passing named arguments and values to the `dict()` function.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人不喜欢输入那么多花括号和引号。您也可以通过将命名参数和值传递给 `dict()` 函数来创建字典。
- en: 'The traditional way:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的方式：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Using `dict()`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dict()`：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'One limitation of the second way is that the argument names need to be legal
    variable names (no spaces, no reserved words):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方式的一个限制是参数名必须是合法的变量名（不能有空格，不能是保留字）：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Convert with dict()
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 dict() 转换
- en: You can also use the `dict()` function to convert two-value sequences into a
    dictionary. You might run into such key-value sequences at times, such as “Strontium,
    90, Carbon, 14.”^([1](ch08.html#idm45795008873832)) The first item in each sequence
    is used as the key and the second as the value.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用 `dict()` 函数将包含两个值的序列转换为字典。有时您可能会遇到这样的键值序列，例如 “锶，90，碳，14。”^([1](ch08.html#idm45795008873832))
    每个序列的第一项用作键，第二项用作值。
- en: 'First, here’s a small example using `lol` (a list of two-item lists):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这里是使用 `lol`（一个包含两项列表的列表）的一个小例子：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We could have used any sequence containing two-item sequences. Here are other
    examples.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用包含两项序列的任何序列。以下是其他示例。
- en: 'A list of two-item tuples:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含两项元组的列表：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A tuple of two-item lists:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含两项列表的元组：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A list of two-character strings:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含两个字符字符串的列表：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A tuple of two-character strings:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含两个字符字符串的元组：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The section [“Iterate Multiple Sequences with zip()”](ch07.html#list_zip) introduces
    you to the `zip()` function, which makes it easy to create these two-item sequences.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 章节 [“使用 zip() 迭代多个序列”](ch07.html#list_zip) 介绍了 `zip()` 函数，它使得创建这些两项序列变得容易。
- en: Add or Change an Item by [ *key* ]
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加或更改一个项目由 [ *key* ]
- en: Adding an item to a dictionary is easy. Just refer to the item by its key and
    assign a value. If the key was already present in the dictionary, the existing
    value is replaced by the new one. If the key is new, it’s added to the dictionary
    with its value. Unlike lists, you don’t need to worry about Python throwing an
    exception during assignment by specifying an index that’s out of range.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 向字典中添加项很简单。只需通过其键引用该项并赋予一个值。如果键已存在于字典中，现有值将被新值替换。如果键是新的，则将其添加到字典中并赋予其值。与列表不同，你不必担心Python在分配时抛出超出范围的索引异常。
- en: 'Let’s make a dictionary of most of the members of Monty Python, using their
    last names as keys, and first names as values:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个蒙提·派森大部分成员的字典，使用他们的姓作为键，名作为值：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We’re missing one member: the one born in America, Terry Gilliam. Here’s an
    attempt by an anonymous programmer to add him, but he’s botched the first name:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遗漏了一个成员：出生在美国的那个，特里·吉列姆。这里有一个匿名程序员试图添加他的尝试，但是他搞砸了名字的第一个字：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And here’s some repair code by another programmer who is Pythonic in more than
    one way:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有另一位程序员编写的修复代码，他在多个方面都符合Python风格：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By using the same key (`'Gilliam'`), we replaced the original value `'Gerry'`
    with `'Terry'`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用相同的键（`'Gilliam'`），我们用`'Terry'`替换了原始值`'Gerry'`。
- en: 'Remember that dictionary keys must be *unique*. That’s why we used last names
    for keys instead of first names here—two members of Monty Python have the first
    name `''Terry''`! If you use a key more than once, the last value wins:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 记住字典键必须是*唯一*的。这就是为什么我们在这里使用姓氏而不是名字作为键——蒙提·派森的两个成员都有名字 `'Terry'`！如果你使用一个键多次，最后一个值会覆盖之前的值：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We first assigned the value `'Gilliam'` to the key `'Terry'` and then replaced
    it with the value `'Jones'`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将值`'Gilliam'`分配给键`'Terry'`，然后将其替换为值`'Jones'`。
- en: Get an Item by [key] or with get()
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过[key]或者使用get()获取项
- en: 'This is the most common use of a dictionary. You specify the dictionary and
    key to get the corresponding value: Using `some_pythons` from the previous section:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是字典的最常见用法。你指定字典和键以获取对应的值：使用前面部分的`some_pythons`：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If the key is not present in the dictionary, you’ll get an exception:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字典中不存在该键，则会引发异常：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There are two good ways to avoid this. The first is to test for the key at
    the outset by using `in`, as you saw in the previous section:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种很好的方法可以避免这种情况。第一种是在开始时使用`in`来测试键，就像你在上一节看到的那样：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The second is to use the special dictionary `get()` function. You provide the
    dictionary, key, and an optional value. If the key exists, you get its value:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是使用特殊的字典`get()`函数。你提供字典、键和一个可选值。如果键存在，你将得到其值：
- en: '[PRE18]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If not, you get the optional value, if you specified one:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，你将得到可选的值（如果你指定了的话）：
- en: '[PRE19]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Otherwise, you get `None` (which displays nothing in the interactive interpreter):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，你将得到`None`（在交互式解释器中显示为空）：
- en: '[PRE20]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Get All Keys with keys()
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用keys()获取所有的键
- en: 'You can use `keys()` to get all of the keys in a dictionary. We’ll use a different
    sample dictionary for the next few examples:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`keys()`来获取字典中的所有键。我们将在接下来的几个示例中使用一个不同的样本字典：
- en: '[PRE21]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In Python 2, `keys()` just returns a list. Python 3 returns `dict_keys()`, which
    is an iterable view of the keys. This is handy with large dictionaries because
    it doesn’t use the time and memory to create and store a list that you might not
    use. But often you actually *do* want a list. In Python 3, you need to call `list()`
    to convert a `dict_keys` object to a list.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 2中，`keys()`仅返回一个列表。而Python 3返回`dict_keys()`，它是键的可迭代视图。这在处理大型字典时很方便，因为它不会使用时间和内存来创建和存储一个可能不会使用的列表。但通常你确实*需要*一个列表。在Python
    3中，你需要调用`list()`将`dict_keys`对象转换为列表。
- en: '[PRE22]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In Python 3, you also need to use the `list()` function to turn the results
    of `values()` and `items()` into normal Python lists. I use that in these examples.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3中，你还需要使用`list()`函数将`values()`和`items()`的结果转换为普通的Python列表。我在这些例子中使用了这个。
- en: Get All Values with values()
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用values()获取所有的值
- en: 'To obtain all the values in a dictionary, use `values()`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取字典中的所有值，使用values()：
- en: '[PRE23]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Get All Key-Value Pairs with items()
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用items()获取所有的键-值对
- en: 'When you want to get all the key-value pairs from a dictionary, use the `items()`
    function:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想从字典中获取所有的键-值对时，使用`items()`函数：
- en: '[PRE24]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Each key and value is returned as a tuple, such as `('green', 'go')`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 每个键和值都作为元组返回，例如`('green', 'go')`。
- en: Get Length with len()
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用len()获取长度
- en: 'Count your key-value pairs:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 计算你的键值对数：
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Combine Dictionaries with {**a, **b}
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用{**a, **b}合并字典
- en: 'Starting with Python 3.5, there’s a new way to merge dictionaries, using the
    `**` unicorn glitter, which has a very different use in [Chapter 9](ch09.html#ch_functions):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从Python 3.5开始，有一种新的方法可以合并字典，使用`**`魔法，这在[第9章](ch09.html#ch_functions)中有着非常不同的用途：
- en: '[PRE26]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Actually, you can pass more than two dictionaries:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您可以传递多于两个字典：
- en: '[PRE27]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: These are *shallow* copies. See the discussion of `deepcopy()` ([“Copy Everything
    with deepcopy()”](#dict_deepcopy)) if you want full copies of the keys and values,
    with no connection to their origin dictionaries.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是*浅*复制。 如果您希望得到键和值的完整副本，并且与它们的原始字典没有关联，请参阅`deepcopy()`的讨论（[“使用deepcopy()复制一切”](#dict_deepcopy)）。
- en: Combine Dictionaries with update()
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用update()合并字典
- en: You can use the `update()` function to copy the keys and values of one dictionary
    into another.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`update()`函数将一个字典的键和值复制到另一个字典中。
- en: 'Let’s define the `pythons` dictionary, with all members:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义包含所有成员的`pythons`字典：
- en: '[PRE28]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We also have a dictionary of other humorous persons called `others`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个名为`others`的其他幽默人物字典：
- en: '[PRE29]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, along comes another anonymous programmer who decides that the members
    of `others` should be members of Monty Python:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，又来了另一个匿名程序员，他决定将`others`的成员作为蒙提·派森的成员：
- en: '[PRE30]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'What happens if the second dictionary has the same key as the dictionary into
    which it’s being merged? The value from the second dictionary wins:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第二个字典与它要合并的字典具有相同的键，会发生什么？ 第二个字典的值将覆盖第一个字典的值：
- en: '[PRE31]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Delete an Item by Key with del
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用del按键删除项目
- en: 'The previous `pythons.update(others)` code from our anonymous programmer was
    technically correct, but factually wrong. The members of `others`, although funny
    and famous, were not in Monty Python. Let’s undo those last two additions:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 先前来自我们的匿名程序员的`pythons.update(others)`代码在技术上是正确的，但事实上是错误的。 虽然`others`的成员风趣而著名，但并非蒙提·派森的成员。
    让我们撤销最后两次添加：
- en: '[PRE32]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Get an Item by Key and Delete It with pop()
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用pop()按键获取项目并删除它
- en: 'This combines `get()` and `del`. If you give `pop()` a key and it exists in
    the dictionary, it returns the matching value and deletes the key-value pair.
    If it doesn’t exist, it raises an exception:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这结合了`get()`和`del`。 如果给`pop()`传递一个键，并且它存在于字典中，则返回匹配的值并删除键值对。 如果不存在，则会引发异常：
- en: '[PRE33]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'But if you give `pop()` a second default argument (as with `get()`), all is
    well and the dictionary is not changed:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果给`pop()`传递第二个默认参数（与`get()`一样），一切都会很好，字典不会更改：
- en: '[PRE34]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Delete All Items with clear()
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用clear()删除所有项目
- en: 'To delete all keys and values from a dictionary, use `clear()` or just reassign
    an empty dictionary (`{}`) to the name:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字典中删除所有键和值，请使用`clear()`或只需重新分配一个空字典（`{}`）给名称：
- en: '[PRE35]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Test for a Key with in
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用in测试键是否存在
- en: 'If you want to know whether a key exists in a dictionary, use `in`. Let’s redefine
    the `pythons` dictionary again, this time omitting a name or two:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道字典中是否存在某个键，请使用`in`。 让我们再次重新定义`pythons`字典，这次省略一个或两个名称：
- en: '[PRE36]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now let’s see who’s in there:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看里面有谁：
- en: '[PRE37]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Did we remember to add Terry Gilliam this time?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们记得添加特里·吉列姆了吗？
- en: '[PRE38]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Drat.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 唉。
- en: Assign with =
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用=分配
- en: 'As with lists, if you make a change to a dictionary, it will be reflected in
    all the names that refer to it:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表一样，如果您对字典进行更改，则将反映在引用它的所有名称中：
- en: '[PRE39]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Copy with copy()
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用copy()复制
- en: 'To actually copy keys and values from a dictionary to another dictionary and
    avoid this, you can use `copy()`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际从一个字典复制键和值到另一个字典，并避免这种情况，您可以使用`copy()`：
- en: '[PRE40]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is a *shallow* copy, and works if the dictionary values are immutable (as
    they are in this case). If they aren’t, you need `deepcopy()`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个*浅*复制，并且在字典值是不可变的情况下有效。 如果不是，您需要`deepcopy()`。
- en: Copy Everything with deepcopy()
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用deepcopy()复制一切
- en: 'Suppose that the value for `red` in the previous example was a list instead
    of a single string:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 假设前面示例中`red`的值是一个列表而不是一个单独的字符串：
- en: '[PRE41]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let’s change one of the values in the `red` list:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改`red`列表中的一个值：
- en: '[PRE42]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You get the usual change-by-either-name behavior. The `copy()` method copied
    the values as-is, meaning `signal_copy` got the same list value for `'red'` that
    `signals` had.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得按名称更改的通常行为。 `copy()`方法直接复制了值，这意味着`signal_copy`对于`'red'`得到了与`signals`相同的列表值。
- en: 'The solution is `deepcopy()`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是`deepcopy()`：
- en: '[PRE43]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Compare Dictionaries
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较字典
- en: 'Much like lists and tuples in the previous chapter, dictionaries can be compared
    with the simple comparison operators `==` and `!=`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章的列表和元组一样，字典可以使用简单的比较运算符`==`和`!=`进行比较：
- en: '[PRE44]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Other operators won’t work:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 其他运算符不起作用：
- en: '[PRE45]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Python compares the keys and values one by one. The order in which they were
    originally created doesn’t matter. In this example, `a` and `b` are equal, except
    key `1` has the list value `[1, 2]` in `a` and the list value `[1, 1]` in `b`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Python逐一比较键和值。它们最初创建的顺序无关紧要。在这个例子中，`a`和`b`是相等的，除了键`1`在`a`中具有列表值`[1, 2]`，而在`b`中具有列表值`[1,
    1]`：
- en: '[PRE46]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Iterate with for and in
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`for`和`in`进行迭代
- en: 'Iterating over a dictionary (or its `keys()` function) returns the keys. In
    this example, the keys are the types of cards in the board game Clue (Cluedo outside
    of North America):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历字典（或其`keys()`函数）会返回键。在这个例子中，键是桌游Clue（在北美以外称为Cluedo）中的卡片类型：
- en: '[PRE47]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To iterate over the values rather than the keys, you use the dictionary’s `values()`
    function:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要迭代值而不是键，可以使用字典的`values()`函数：
- en: '[PRE48]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To return both the key and value as a tuple, you can use the `items()` function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回键和值作为元组，可以使用`items()`函数：
- en: '[PRE49]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You can assign to a tuple in one step. For each tuple returned by `items()`,
    assign the first value (the key) to `card`, and the second (the value) to `contents`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 可以一步到位地将元组分配给元组。对于由`items()`返回的每个元组，将第一个值（键）分配给`card`，第二个值（值）分配给`contents`：
- en: '[PRE50]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Dictionary Comprehensions
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典推导
- en: 'Not to be outdone by those bourgeois lists, dictionaries also have comprehensions.
    The simplest form looks familiar:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不被那些资产阶级列表所抛弃，字典也有推导。最简单的形式看起来很熟悉：
- en: '[PRE51]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We’re running a loop over each of the seven letters in the string `''letters''`
    and counting how many times that letter appears. Two uses of `word.count(letter)`
    are a waste of time because we have to count all the `e`’s twice and all the `t`’s
    twice. But when we count the `e`’s the second time, we do no harm because we just
    replace the entry in the dictionary that was already there; the same goes for
    counting the `t`’s. So, the following would have been a teeny bit more Pythonic:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在循环遍历字符串`'letters'`中的每个字母，并计算该字母出现的次数。两次使用`word.count(letter)`是浪费时间的，因为我们必须两次计算所有`e`和所有`t`。但是当我们第二次计算`e`时，我们不会有任何损害，因为我们只是替换已经存在的字典条目；对于计算`t`的情况也是如此。因此，以下方式可能会更符合Python的风格：
- en: '[PRE53]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The dictionary’s keys are in a different order than the previous example because
    iterating `set(word)` returns letters in a different order than iterating the
    string `word`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子不同，字典的键的顺序不同，因为对`set(word)`进行迭代会以不同的顺序返回字母，而迭代字符串`word`则以不同的顺序返回。
- en: 'Similar to list comprehensions, dictionary comprehensions can also have `if`
    tests and multiple `for` clauses:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表推导类似，字典推导也可以有`if`测试和多个`for`子句：
- en: '[PRE54]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: See [PEP-274](https://oreil.ly/6udkb) for more examples of dictionary comprehensions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[PEP-274](https://oreil.ly/6udkb)以获取更多字典推导的例子。
- en: Sets
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: A *set* is like a dictionary with its values thrown away, leaving only the keys.
    As with a dictionary, each key must be unique. You use a set when you only want
    to know that something exists, and nothing else about it. It’s a bag of keys.
    Use a dictionary if you want to attach some information to the key as a value.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*集合*类似于一个字典，它的值被丢弃，只留下键。与字典一样，每个键必须是唯一的。当你只想知道某个东西是否存在时，可以使用集合，而不需要其他信息。它是一组键的袋子。如果你想将一些信息附加到键上作为值，请使用字典。'
- en: At some bygone time, in some places, set theory was taught in elementary school
    along with basic mathematics. If your school skipped it (or you were staring out
    the window), [Figure 8-1](#fig_set_ops) shows the ideas of set union and intersection.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些过去的时代和某些地方，集合理论是与基本数学一起教授的内容。如果你的学校跳过了它（或者你当时在看窗外），[图 8-1](#fig_set_ops)展示了集合并和交的概念。
- en: Suppose that you take the union of two sets that have some keys in common. Because
    a set must contain only one of each item, the union of two sets will contain only
    one of each key. The *null* or *empty* set is a set with zero elements. In [Figure 8-1](#fig_set_ops),
    an example of a null set would be female names beginning with `X`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你对有一些共同键的两个集合取并集。因为集合必须仅包含每个项的一个副本，两个集合的并集将只包含每个键的一个副本。*空*集合是一个没有元素的集合。在[图 8-1](#fig_set_ops)中，空集合的一个例子是以`X`开头的女性名字。
- en: '![inp2 0801](assets/inp2_0801.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![inp2 0801](assets/inp2_0801.png)'
- en: Figure 8-1\. Common things to do with sets
  id: totrans-163
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-1\. 集合的常见操作
- en: Create with set()
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`set()`创建集合
- en: 'To create a set, you use the `set()` function or enclose one or more comma-separated
    values in curly brackets, as shown here:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个集合，可以使用`set()`函数或将一个或多个逗号分隔的值放在花括号中，如下所示：
- en: '[PRE56]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Sets are unordered.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是无序的。
- en: Note
  id: totrans-168
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Because `[]` creates an empty list, you might expect `{}` to create an empty
    set. Instead, `{}` creates an empty dictionary. That’s also why the interpreter
    prints an empty set as `set()` instead of `{}`. Why? Dictionaries were in Python
    first and took possession of the curly brackets. And possession is nine-tenths
    of the law.^([2](ch08.html#idm45795006303816))
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `[]` 创建一个空列表，你可能期望 `{}` 创建一个空集合。相反，`{}` 创建一个空字典。这也是为什么解释器将空集合打印为 `set()`
    而不是 `{}`。为什么？字典在 Python 中先出现，并且拿下了花括号的所有权。拥有是法律的九分之一。^([2](ch08.html#idm45795006303816))
- en: Convert with set()
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `set()` 进行转换：
- en: You can create a set from a list, string, tuple, or dictionary, discarding any
    duplicate values.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从列表、字符串、元组或字典创建一个集合，丢弃任何重复的值。
- en: 'First, let’s take a look at a string with more than one occurrence of some
    letters:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看一个字符串中某些字母出现多次的情况：
- en: '[PRE57]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Notice that the set contains only one `'e'` or `'t'`, even though `'letters'`
    contained two of each.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意集合只包含一个 `'e'` 或 `'t'`，即使 `'letters'` 包含两个每个。
- en: 'Now, let’s make a set from a list:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从列表创建一个集合：
- en: '[PRE58]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This time, a set from a tuple:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，从元组创建一个集合：
- en: '[PRE59]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'When you give `set()` a dictionary, it uses only the keys:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当你给 `set()` 一个字典时，它只使用键：
- en: '[PRE60]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Get Length with len()
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 len() 获取长度：
- en: 'Let’s count our reindeer:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们数一数我们的驯鹿：
- en: '[PRE61]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Add an Item with add()
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `add()` 添加一个项目：
- en: 'Throw another item into a set with the set `add()` method:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集合的 `add()` 方法将另一个项目添加到集合中：
- en: '[PRE62]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Delete an Item with remove()
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 remove() 删除一个项目：
- en: 'You can delete a value from a set by value:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过值从集合中删除一个值：
- en: '[PRE63]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Iterate with for and in
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 for 和 in 进行迭代：
- en: 'Like dictionaries, you can iterate over all items in a set:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 像字典一样，你可以遍历集合中的所有项目：
- en: '[PRE64]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Test for a Value with in
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 in 测试一个值：
- en: 'This is the most common use of a set. We’ll make a dictionary called `drinks`.
    Each key is the name of a mixed drink, and the corresponding value is a set of
    that drink’s ingredients:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这是集合的最常见用法。我们将创建一个名为 `drinks` 的字典。每个键是混合饮料的名称，相应的值是该饮料成分的集合：
- en: '[PRE65]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Even though both are enclosed by curly braces (`{` and `}`), a set is just
    a bunch of values, and a dictionary contains *key* : *value* pairs.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 即使两者都用花括号（`{` 和 `}`）括起来，一个集合只是一堆值，而字典包含 *键* ：*值* 对。
- en: Which drinks contain vodka?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些饮料含有伏特加？
- en: '[PRE66]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We want something with vodka but are lactose intolerant, and think vermouth
    tastes like kerosene:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要一些伏特加，但我们对乳糖不耐受，并且认为苦艾酒味道像煤油：
- en: '[PRE67]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We’ll rewrite this a bit more succinctly in the next section.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中简要重写这段话。
- en: Combinations and Operators
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合和操作符
- en: 'What if you want to check for combinations of set values? Suppose that you
    want to find any drink that has orange juice or vermouth? Let’s use the *set intersection
    operator*, which is an ampersand (`&`):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要检查集合值的组合怎么办？假设你想要找到任何含有橙汁或苦艾酒的饮料？让我们使用 *集合交集操作符*，即 `&`：
- en: '[PRE68]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The result of the `&` operator is a set that contains all of the items that
    appear in both lists that you compare. If neither of those ingredients were in
    `contents`, the `&` returns an empty set, which is considered `False`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`&` 操作符的结果是一个集合，其中包含与比较的两个列表中都出现的所有项。如果这些成分都不在 `contents` 中，则 `&` 返回一个空集合，被视为
    `False`。'
- en: 'Now, let’s rewrite the example from the previous section, in which we wanted
    vodka but neither cream nor vermouth:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新写前一节的示例，在这个示例中，我们想要伏特加，但不要奶油和苦艾酒：
- en: '[PRE69]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Let’s save the ingredient sets for these two drinks in variables, just to save
    our delicate fingers some typing in the coming examples:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这两种饮料的成分集合保存在变量中，以节省我们娇贵的手指在接下来的示例中的打字：
- en: '[PRE70]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The following are examples of all the set operators. Some have special punctuation,
    some have special functions, and some have both. Let’s use test sets `a` (contains
    `1` and `2`) and `b` (contains `2` and `3`):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是所有集合操作符的示例。有些有特殊的标点符号，有些有特殊的功能，还有些两者兼有。让我们使用测试集合 `a`（包含 `1` 和 `2`）和 `b`（包含
    `2` 和 `3`）：
- en: '[PRE71]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'As you saw earlier, you get the *intersection* (members common to both sets)
    with the special punctuation symbol `&`. The set `intersection()` function does
    the same:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你之前看到的，使用特殊标点符号 `&` 获取 *交集*（两个集合共同的成员）。集合 `intersection()` 函数也是如此。
- en: '[PRE72]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This snippet uses our saved drink variables:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段使用我们保存的饮料变量：
- en: '[PRE73]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In this example, get the *union* (members of either set) by using `|` or the
    set `union()` function:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，使用特殊标点符号 `&` 获取 *并集*（两个集合的成员）或集合 `union()` 函数。
- en: '[PRE74]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'And here’s the alcoholic version:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是酒精版本：
- en: '[PRE75]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The *difference* (members of the first set but not the second) is obtained
    by using the character `-` or the `difference()` function:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*差集*（第一个集合的成员但不是第二个集合的成员）可以通过使用字符`-`或`difference()`函数获得：'
- en: '[PRE76]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: By far, the most common set operations are union, intersection, and difference.
    I’ve included the others for completeness in the examples that follow, but you
    might never use them.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，最常见的集合操作是并集、交集和差集。我在接下来的示例中包括了其他操作，但你可能永远不会用到它们。
- en: 'The *exclusive or* (items in one set or the other, but not both) uses `^` or
    `symmetric_difference()`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*异或*（一个集合中的项目或另一个，但不是两者都有）使用`^`或`symmetric_difference()`：'
- en: '[PRE78]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This finds the exclusive ingredient in our two russian drinks:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这找到我们两种俄罗斯饮料中独特的成分：
- en: '[PRE79]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'You can check whether one set is a *subset* of another (all members of the
    first set are also in the second set) by using `<=` or `issubset()`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`<=`或`issubset()`来检查一个集合是否是另一个的*子集*（第一个集合的所有成员也在第二个集合中）：
- en: '[PRE80]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Adding cream to a black russian makes a white russian, so `wruss` is a superset
    of `bruss`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 给黑俄罗斯加奶油会变成白俄罗斯，所以`wruss`是`bruss`的超集：
- en: '[PRE81]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Is any set a subset of itself? Yup.^([3](ch08.html#idm45795005210776))
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 任何集合都是其自身的子集吗？是的。^([3](ch08.html#idm45795005210776))
- en: '[PRE82]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'To be a *proper subset*, the second set needs to have all the members of the
    first and more. Calculate it by using `<`, as in this example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要成为一个*真子集*，第二个集合需要包含第一个集合的所有成员及更多。通过使用`<`，如下例所示：
- en: '[PRE83]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'A *superset* is the opposite of a subset (all members of the second set are
    also members of the first). This uses `>=` or `issuperset()`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*超集*是子集的反义词（第二个集合的所有成员也是第一个集合的成员）。这使用`>=`或`issuperset()`：'
- en: '[PRE85]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Any set is a superset of itself:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 任何集合都是其自身的超集：
- en: '[PRE87]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'And finally, you can find a *proper superset* (the first set has all members
    of the second, and more) by using `>`, as shown here:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以通过使用`>`来找到一个*真子集*（第一个集合包含第二个集合的所有成员，且更多）如下所示：
- en: '[PRE88]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'You can’t be a proper superset of yourself:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能是你自己的真超集：
- en: '[PRE90]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Set Comprehensions
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合推导式
- en: 'No one wants to be left out, so even sets have comprehensions. The simplest
    version looks like the list and dictionary comprehensions that you’ve just seen:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人想被忽略，所以即使是集合也有推导式。最简单的版本看起来像你刚刚看到的列表和字典推导式：
- en: '`{` *`expression`* `for` *`expression`* `in` *`iterable`* `}`'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`{` *`expression`* `for` *`expression`* `in` *`iterable`* `}`'
- en: 'And it can have the optional condition tests:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可以具有可选的条件测试：
- en: '`{` *`expression`* `for` *`expression`* `in` *`iterable`* `if` *`condition`*
    `}`'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`{` *`expression`* `for` *`expression`* `in` *`iterable`* `if` *`condition`*
    `}`'
- en: '[PRE91]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Create an Immutable Set with frozenset()
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`frozenset()`创建不可变集合
- en: 'If you want to create a set that can’t be changed, call the `frozenset()` function
    with any iterable argument:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想创建一个不能被更改的集合，可以使用`frozenset()`函数和任何可迭代参数：
- en: '[PRE92]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Is it really frozen?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 它真的冻结了吗？
- en: '[PRE93]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Yes, pretty frosty.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，非常冷。
- en: Data Structures So Far
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 到目前为止的数据结构
- en: 'To review, you *make*:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，你可以*创建*：
- en: A list by using square brackets (`[]`)
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用方括号(`[]`)创建列表
- en: A tuple by using commas and optional parentheses
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过逗号和可选括号创建元组
- en: A dictionary or set by using curly brackets (`{}`)
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用花括号(`{}`)创建字典或集合
- en: 'For all but sets, you *access* a single element with square brackets. For the
    list and tuple, the value between the square brackets is an integer offset. For
    the dictionary, it’s a key. For all three, the result is a value. For the set,
    it’s either there or it’s not; there’s no index or key:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 除了集合，你可以通过使用方括号访问单个元素。对于列表和元组，方括号中的值是整数偏移量。对于字典，它是一个键。对于这三个，结果是一个值。对于集合，要么有，要么没有；没有索引或键：
- en: '[PRE94]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Make Bigger Data Structures
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建更大的数据结构
- en: 'We worked up from simple booleans, numbers, and strings to lists, tuples, sets,
    and dictionaries. You can combine these built-in data structures into bigger,
    more complex structures of your own. Let’s start with three different lists:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从简单的布尔值、数字和字符串逐步进阶到列表、元组、集合和字典。你可以将这些内置数据结构组合成更大、更复杂的结构。让我们从三个不同的列表开始：
- en: '[PRE95]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We can make a tuple that contains each list as an element:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个包含每个列表作为元素的元组：
- en: '[PRE96]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'And we can make a list that contains the three lists:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个包含这三个列表的列表：
- en: '[PRE97]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Finally, let’s create a dictionary of lists. In this example, let’s use the
    name of the comedy group as the key and the list of members as the value:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个字典的列表。在这个例子中，让我们使用喜剧组的名字作为键，成员列表作为值：
- en: '[PRE98]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Your only limitations are those in the data types themselves. For example,
    dictionary keys need to be immutable, so a list, dictionary, or set can’t be a
    key for another dictionary. But a tuple can be. For example, you could index sites
    of interest by GPS coordinates (latitude, longitude, and altitude; see [Chapter 21](ch21.html#ch_business)
    for more mapping examples):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你的唯一限制是数据类型本身的限制。例如，字典键必须是不可变的，因此列表、字典或集合不能作为另一个字典的键。但元组可以。例如，你可以通过 GPS 坐标（纬度、经度和高度；请参见
    [第 21 章](ch21.html#ch_business) 获取更多映射示例）来索引感兴趣的站点：
- en: '[PRE99]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Coming Up
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即将发生
- en: Back to code structures. You’ll learn how to wrap code in *functions*, and how
    to deal with *exceptions* when things go awry.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 回到代码结构。你将学习如何将代码包装在 *函数* 中，以及在出现 *异常* 时如何处理。
- en: Things to Do
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要做的事情
- en: '8.1 Make an English-to-French dictionary called `e2f` and print it. Here are
    your starter words: `dog` is `chien`, `cat` is `chat`, and `walrus` is `morse`.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 8.1 制作一个英语到法语的字典 `e2f` 并打印出来。以下是你的起始词汇：`dog` 是 `chien`，`cat` 是 `chat`，`walrus`
    是 `morse`。
- en: 8.2 Using your three-word dictionary `e2f`, print the French word for `walrus`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 8.2 使用你的三词字典 `e2f`，打印法语单词 `walrus` 的英文对应词。
- en: 8.3 Make a French-to-English dictionary called `f2e` from `e2f`. Use the `items`
    method.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 8.3 使用 `e2f` 创建一个法语到英语的字典 `f2e`。使用 `items` 方法。
- en: 8.4 Print the English equivalent of the French word `chien`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 8.4 打印法语单词 `chien` 的英文对应词。
- en: 8.5 Print the set of English words from `e2f`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 8.5 打印从 `e2f` 中得到的英语单词集合。
- en: '8.6 Make a multilevel dictionary called `life`. Use these strings for the topmost
    keys: `''animals''`, `''plants''`, and `''other''`. Make the `''animals''` key
    refer to another dictionary with the keys `''cats''`, `''octopi''`, and `''emus''`.
    Make the `''cats''` key refer to a list of strings with the values `''Henri''`,
    `''Grumpy''`, and `''Lucy''`. Make all the other keys refer to empty dictionaries.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 8.6 制作一个名为 `life` 的多级字典。使用以下字符串作为最顶层键：`'animals'`、`'plants'` 和 `'other'`。使 `'animals'`
    键参考另一个具有键 `'cats'`、`'octopi'` 和 `'emus'` 的字典。使 `'cats'` 键参考一个包含值 `'Henri'`、`'Grumpy'`
    和 `'Lucy'` 的字符串列表。使所有其他键参考空字典。
- en: 8.7 Print the top-level keys of `life`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 8.7 打印 `life` 的顶层键。
- en: 8.8 Print the keys for `life['animals']`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 8.8 打印 `life['animals']` 的键。
- en: 8.9 Print the values for `life['animals']['cats']`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 8.9 打印 `life['animals']['cats']` 的值。
- en: 8.10 Use a dictionary comprehension to create the dictionary `squares`. Use
    `range(10)` to return the keys, and use the square of each key as its value.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 8.10 使用字典推导来创建字典 `squares`。使用 `range(10)` 返回键，并使用每个键的平方作为其值。
- en: 8.11 Use a set comprehension to create the set `odd` from the odd numbers in
    `range(10)`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 8.11 使用集合推导来创建集合 `odd`，其中包含 `range(10)` 中的奇数。
- en: 8.12 Use a generator comprehension to return the string `'Got '` and a number
    for the numbers in `range(10)`. Iterate through this by using a `for` loop.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 8.12 使用生成器推导来返回字符串 `'Got '` 和 `range(10)` 中的数字。通过使用 `for` 循环进行迭代。
- en: 8.13 Use `zip()` to make a dictionary from the key tuple `('optimist', 'pessimist',
    'troll')` and the values tuple `('The glass is half full',` `'The glass is half
    empty',` `'How did you get a glass?')`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 8.13 使用 `zip()` 从键元组 `('optimist', 'pessimist', 'troll')` 和值元组 `('The glass
    is half full', 'The glass is half empty', 'How did you get a glass?')` 创建一个字典。
- en: '8.14 Use `zip()` to make a dictionary called `movies` that pairs these lists:
    `titles =` `[''Creature of Habit'',` `''Crewel Fate'',` `''Sharks On a Plane'']`
    and `plots =` `[''A nun turns into a monster'',` `''A haunted yarn shop'',` `''Check
    your exits'']`'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 8.14 使用 `zip()` 创建一个名为 `movies` 的字典，将以下列表配对：`titles = ['Creature of Habit',
    'Crewel Fate', 'Sharks On a Plane']` 和 `plots = ['A nun turns into a monster',
    'A haunted yarn shop', 'Check your exits']`
- en: ^([1](ch08.html#idm45795008873832-marker)) Also, the final score in the Strontium-Carbon
    game.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch08.html#idm45795008873832-marker)) 同时，Strontium-Carbon 游戏的最终得分。
- en: ^([2](ch08.html#idm45795006303816-marker)) According to lawyers and exorcists.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch08.html#idm45795006303816-marker)) 根据律师和驱魔师的说法。
- en: ^([3](ch08.html#idm45795005210776-marker)) Although, paraphrasing Groucho Marx,
    “I wouldn’t want to belong to a club that would have someone like me as a member.”
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch08.html#idm45795005210776-marker)) 尽管，借用格劳乔·马尔克斯的话，“我不想加入那种会接受我作为成员的俱乐部。”
