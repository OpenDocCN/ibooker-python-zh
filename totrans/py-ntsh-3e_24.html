<html><head></head><body>
<div id="sbo-rt-content"><section data-nutshell-tab="Packaging Programs and Extensions" data-pdf-bookmark="Chapter 24. Packaging Programs and Extensions" data-type="chapter" epub:type="chapter"><div class="chapter" id="packaging_programs_and_extensions">
<h1><span class="label">Chapter 24. </span>Packaging Programs and Extensions</h1>
<p><em>In this chapter, abridged for print publication, we describe the packaging ecosystem’s development. We provide additional material in the<a contenteditable="false" data-primary="online material" data-secondary="packaging programs and extensions" data-type="indexterm" id="idm44924475833552"/><a contenteditable="false" data-primary="supplemental material, obtaining" data-type="indexterm" id="idm44924475832208"/> <a href="https://oreil.ly/python-nutshell-24">online version of this chapter</a>, available in the<a contenteditable="false" data-primary="GitHub repository" data-type="indexterm" id="idm44924475769584"/> GitHub repository for this book. Among other topics (see <a data-type="xref" href="#online_materia">“Online Material”</a> for a complete list), in the online version we describe <span class="code">poetry</span>, a modern standards-compliant Python build system, and compare it with the more traditional <span class="code">setuptools</span> approach.</em></p>
<p>Suppose<a contenteditable="false" data-primary="packaging programs and extensions" data-type="indexterm" id="pacprog24"/><a contenteditable="false" data-primary="extension modules" data-secondary="packaging programs and extensions" data-type="indexterm" id="EMpack24"/> you have some Python code that you need to deliver to other people and groups. It works on your machine, but now you have the added complication of making it work for other people. This involves packaging your code in a suitable format and making it available to its intended audience.</p>
<p>The quality and diversity of the Python packaging ecosystem have greatly improved since the last edition, and its documentation is both better organized and much more complete. These improvements are based on careful work to specify a Python source tree format independent of any specific build system in <a href="https://oreil.ly/Vm1QZ">PEP 517</a>, “A Build-System Independent Format for Source Trees,” and the minimum build system requirements in <a href="https://oreil.ly/KwMjb">PEP 518</a>, “Specifying Minimum Build System Requirements for Python Projects.” The “Rationale” section of the latter document concisely describes why these changes were required, the most significant being removal of the need to run the <em>setup.py</em> file to discover (presumably by observing tracebacks) the build’s requirements.</p>
<p>The major purpose of PEP 517 is to specify the format of build definitions in a file called <em>pyproject.toml</em>. The file is organized into sections called<a contenteditable="false" data-primary="tables" data-type="indexterm" id="idm44924475759744"/> <em>tables</em>, each with a header comprising the table’s name in brackets, much like a config file. Each table contains values for various parameters, consisting of a name, an equals sign, and a value. <span class="version">3.11+</span> Python includes the<a contenteditable="false" data-primary="tomllib module" data-type="indexterm" id="idm44924475757632"/><a contenteditable="false" data-primary="standard library modules" data-secondary="tomllib" data-type="indexterm" id="idm44924475756656"/> <a href="https://oreil.ly/fdSIV"><span class="code">tomllib</span></a> module for extracting these definitions, with <span class="code">load</span> and <span class="code">loads</span> methods similar to those in the <span class="code">json</span> module.<sup><a data-type="noteref" href="ch24.xhtml#ch01fn161" id="ch01fn161-marker">1</a></sup></p>
<p>Although more and more tools in the Python ecosystem are using these modern standards, you should still expect to continue to encounter the more traditional <span class="code">setuptools</span>-based build system (which is itself <a href="https://oreil.ly/aF454">transitioning</a> to the <em>pyproject.toml</em> base recommended in PEP 517). For an excellent survey of packaging tools available, see the <a href="https://oreil.ly/ttIW6">list</a> maintained by the<a contenteditable="false" data-primary="Python Packaging Authority (PyPA)" data-type="indexterm" id="idm44924475748416"/><a contenteditable="false" data-primary="PyPA (Python Packaging Authority)" data-type="indexterm" id="idm44924475747440"/> Python Packaging Authority (PyPA).</p>
<p>To explain packaging, we first describe its development, then we discuss <span class="code">poetry</span> and <span class="code">setuptools</span>. Other PEP 517-compliant build tools worth mentioning include<a contenteditable="false" data-primary="hatch tool" data-type="indexterm" id="idm44924475744480"/><a contenteditable="false" data-primary="flit tool" data-type="indexterm" id="idm44924475743504"/> <a href="https://oreil.ly/sF7Zp"><span class="code">flit</span></a> and <a href="https://oreil.ly/AKylH"><span class="code">hatch</span></a>, and you should expect their number to grow as interoperability continues to improve. For distributing relatively simple pure Python packages, we also introduce the standard library module <span class="code">zipapp</span>, and we complete the chapter with a short section explaining how to access data bundled as part of a package.</p>
<section data-pdf-bookmark="What We Don’t Cover in This Chapter" data-type="sect1"><div class="sect1" id="what_we_donapostrophet_cover_in_this_ch">
<h1>What We Don’t Cover in This Chapter</h1>
<p>Apart from the PyPA-sanctioned methods, there are many other possible ways of distributing Python code—far too many to cover in a single chapter. We do not cover the following packaging and distribution topics, which may well be of interest to those wishing to distribute Python code:</p>
<ul>
<li>
<p>Using <a href="https://docs.conda.io"><span class="code">conda</span></a></p>
</li>
<li>
<p>Using <a href="https://docs.docker.com">Docker</a></p>
</li>
<li>
<p>Various methods of creating binary executable files from Python code, such as the following (these tools can be tricky to set up for complex projects, but they repay the effort by widening the potential audience for an application):</p>
<ul>
<li>
<p><a href="https://pyinstaller.org">PyInstaller</a>, which takes a Python application and bundles all the required dependencies (including the Python interpreter and necessary extension libraries) into a single executable program that can be distributed as a standalone application. Versions exist for Windows, macOS, and Linux, though each architecture can only produce its own executable.</p>
</li>
<li>
<p><a href="https://oreil.ly/GC_5w">PyOxidizer</a>, the main tool in a utility set of the same name, which not only allows the creation of standalone executables but can also create Windows and macOS installers and other artifacts.</p>
</li>
<li>
<p><a href="https://oreil.ly/pnWdA">cx_Freeze</a>, which creates a folder containing a Python interpreter, extension libraries, and a ZIP file of the Python code. You can convert this into either a Windows installer or a macOS disk image.</p>
</li>
</ul>
</li>
</ul>
</div></section>
<section data-pdf-bookmark="A Brief History of Python Packaging" data-type="sect1"><div class="sect1" id="a_brief_history_of_python_packaging">
<h1>A Brief History of Python Packaging</h1>
<p>Before the advent of virtual environments, maintaining multiple Python projects and avoiding conflicts between their different dependency requirements was a complex business involving careful management of <span class="code">sys.path</span> and the <span class="code">PYTHONPATH</span> environment variable. If different projects required the same dependency in two different versions, no single Python environment could support both. Nowadays, each virtual environment (see <a data-type="xref" href="ch07.xhtml#python_environments">“Python Environments”</a> for a refresher on this topic) has its own <em>site_packages</em> directory into which third-party and local packages and modules can be installed in a number of convenient ways, making it largely unnecessary to think about the mechanism.<sup><a data-type="noteref" href="ch24.xhtml#ch01fn162" id="ch01fn162-marker">2</a></sup></p>
<p>When the Python Package Index was conceived in 2003, no such features were available, and there was no uniform way to package and distribute Python code. Developers had to carefully adapt their environment to each different project they worked on. This changed with the development of the <span class="code">distutils</span> standard library package, soon leveraged by the third-party <span class="code">setuptools</span> package and its <span class="code">easy_install</span> utility. The now-obsolete platform-independent <em>egg</em> packaging format was the first definition of a single-file format for Python package distribution, allowing easy download and installation of eggs from network sources. Installing a package used a <em>setup.py</em> component, whose execution would integrate the package’s code into an existing Python environment using the features of <span class="code">setuptools</span>. Requiring a third-party (i.e., not part of the standard distribution) module such as <span class="code">setuptools</span> was clearly not a fully satisfactory solution.</p>
<p>In parallel with these developments came the creation of the <span class="code">virtualenv</span> package, vastly simplifying project management for the average Python programmer by offering clean separation between the Python environments used by different projects. Shortly after this, the <span class="code">pip</span> utility, again largely based on the ideas behind <span class="code">setuptools</span>, was introduced. Using source trees rather than eggs as its distribution format, <span class="code">pip</span> could not only install packages but uninstall them as well. It could also list the contents of a virtual environment and accept a versioned list of the project’s dependencies, by convention in a file named <em>requirements.txt</em>.</p>
<p><span class="code">setuptools</span> development was somewhat idiosyncratic and not responsive to community needs, so a fork named <span class="code">distribute</span> was created as a drop-in replacement (it installed under the <span class="code">setuptools</span> name), to allow development work to proceed along more collaborative lines. This was eventually merged back into the <span class="code">setuptools</span> codebase, which is nowadays controlled by the PyPA: the ability to do this affirmed the value of Python’s open source licensing policy.</p>
<p class="pagebreak-before"><span class="version">-3.11</span> The <span class="code">distutils</span> package was originally designed as a standard library component to help with installing extension modules (particularly those written in compiled languages, covered in <a href="https://oreil.ly/python-nutshell-25">Chapter 25</a>). Although it currently remains in the standard library, it has been deprecated and is scheduled for removal from version 3.12, when it will likely be incorporated into <span class="code">setuptools</span>. A number of other tools have emerged that conform to PEPs 517 and 518. In this chapter we’ll look at different ways to install additional functionality into a Python environment.</p>
<p>With the acceptance of <a href="https://oreil.ly/vB13q">PEP 425</a>, “Compatibility Tags for Built Distributions,” and <a href="https://oreil.ly/B_xwu">PEP 427</a>, “The Wheel Binary Package Format,” Python finally had a specification for a binary distribution format (the <em>wheel</em>, whose definition has <a href="https://oreil.ly/XYnsg">since been updated</a>) that would allow the distribution of compiled extension packages for different architectures, falling back to installing from source when no appropriate binary wheel is available.</p>
<p><a href="https://oreil.ly/FhWDt">PEP 453</a>, “Explicit Bootstrapping of pip in Python Installations,” determined that the <span class="code">pip</span> utility should become the preferred way to install packages in Python, and established a process whereby it could be updated independently of Python to allow new deployment features to be delivered without waiting for new language releases.</p>
<p>These developments and many others that have rationalized the Python ecosystem are due to a lot of hard work by the PyPA, to whom Python’s ruling “Steering Council” has delegated most matters relating to packaging and distribution. For a more in-depth and advanced explanation of the material in this chapter, see the <a href="https://packaging.python.org">“Python Packaging User Guide”</a>, which offers sound advice and useful instruction to anyone who wants to make their Python software widely available.</p>
</div></section>
<section data-pdf-bookmark="Online Material" data-type="sect1"><div class="sect1" id="online_materia">
<h1>Online Material</h1>
<p>As mentioned at the start of the chapter, the <a href="https://oreil.ly/python-nutshell-24">online version of this chapter</a> contains additional material. The topics covered are:</p>
<ul class="two-col">
<li>
<p>The build process</p>
</li>
<li>
<p>Entry points</p>
</li>
<li>
<p>Distribution formats</p>
</li>
<li>
<p><span class="code">poetry</span></p>
</li>
<li>
<p><span class="code">setuptools</span></p>
</li>
<li>
<p>Distributing your package</p>
</li>
<li>
<p><span class="code">zipapp</span></p>
</li>
<li>
<p>Accessing data included with your code<a contenteditable="false" data-primary="" data-startref="pacprog24" data-type="indexterm" id="idm44924475695440"/><a contenteditable="false" data-primary="" data-startref="EMpack24" data-type="indexterm" id="idm44924475694224"/></p>
</li>
</ul>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="ch01fn161"><sup><a href="ch24.xhtml#ch01fn161-marker">1</a></sup> Users of older versions can install the library from PyPI with <span class="code"><strong>pip install toml</strong></span>.</p><p data-type="footnote" id="ch01fn162"><sup><a href="ch24.xhtml#ch01fn162-marker">2</a></sup> Be aware that some packages are less than friendly to virtual environments. Happily, these are few and far between.</p></div></div></section></div></body></html>