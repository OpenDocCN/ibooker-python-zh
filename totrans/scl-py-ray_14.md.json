["```py\nclass MailClient(object):\n    \"\"\"\n Mail Client\n \"\"\"\n\n    def __init__(self, settings: Settings):\n        self.settings = settings\n\n    def send_message(self, *args, **kwargs):\n        \"\"\"\n Wrap send_msg to include settings.\n \"\"\"\n        return self.send_msg.remote(self, *args, **kwargs)\n\n    @ray.remote(retry_exceptions=True)\n    def send_msg(self, msg_from: str, msg_to: str, data: str):\n        message = MIMEMultipart(\"alternative\")\n        message[\"From\"] = msg_from\n        message[\"To\"] = msg_to\n        message[\"Subject\"] = f\"A satelite msg: f{data[0:20]}\"\n        part1 = MIMEText(data, \"plain\")\n        # Possible later: HTML\n        message.attach(part1)\n\n        with SMTP(self.settings.mail_server, port=self.settings.mail_port) as smtp:\n            if self.settings.mail_username is not None:\n                smtp.login(self.settings.mail_username,\n                           self.settings.mail_password)\n            logging.info(f\"Sending message {message}\")\n            r = smtp.sendmail(\n                msg=str(message),\n                from_addr=msg_from,\n                to_addrs=msg_to)\n            return r\n```", "```py\nclass LazyNamedPool:\n    \"\"\"\n Lazily constructed pool by name.\n \"\"\"\n\n    def __init__(self, name, size, min_size=1):\n        self._actors = []\n        self.name = name\n        self.size = size\n        self.min_actors = min_size\n\n    def _get_actor(self, idx):\n        actor_name = f\"{self.name}_{idx}\"\n        try:\n            return [ray.get_actor(actor_name)]\n        except Exception as e:\n            print(f\"Failed to fetch {actor_name}: {e} ({type(e)})\")\n            return []\n\n    def _get_actors(self):\n        \"\"\"\n Get actors by name, caches result once we have the \"full\" set.\n \"\"\"\n        if len(self._actors) < self.size:\n            return list(flat_map(self._get_actor, range(0, self.size)))\n\n    def get_pool(self):\n        new_actors = self._get_actors()\n        # Wait for at least min_actors to show up\n        c = 0\n        while len(new_actors) < self.min_actors and c < 10:\n            print(f\"Have {new_actors} waiting for {self.min_actors}\")\n            time.sleep(2)\n            new_actors = self._get_actors()\n            c = c + 1\n        # If we got more actors\n        if (len(new_actors) > len(self._actors)):\n            self._actors = new_actors\n            self._pool = ActorPool(new_actors)\n        if len(new_actors) < self.min_actors:\n            raise Exception(\"Could not find enough actors to launch pool.\")\n        return self._pool\n```", "```py\n    async def prepare_for_shutdown(self):\n        \"\"\"\n Prepare for shutdown, so stop remove pod label (if present) \n then stop accepting connections.\n \"\"\"\n        if self.label is not None:\n            try:\n                self.update_label(opp=\"remove\")\n                await asyncio.sleep(120)\n            except Exception:\n                pass\n        self.server.stop()\n```", "```py\n    async def handle_RCPT(self, server, session, envelope, address, rcpt_options):\n        \"\"\"\n Call back for RCPT. This only accepts email for us, no relaying.\n \"\"\"\n        logging.info(f\"RCPT to with {address} received.\")\n        if not address.endswith(f\"@{self.domain}\"):\n            self.emails_rejected.inc()\n            return '550 not relaying to that domain'\n        # Do we really want to support multiple emails? idk.\n        envelope.rcpt_tos.append(address)\n        return '250 OK'\n\n    async def handle_DATA(self, server, session, envelope):\n        \"\"\"\n Call back for the message data.\n \"\"\"\n        logging.info(f\"Received message {envelope}\")\n        print('Message for %s' % envelope.rcpt_tos)\n        parsed_email = message_from_bytes(envelope.content, policy=policy.SMTPUTF8)\n        text = \"\"\n        if \"subject\" in parsed_email:\n            subject = parsed_email[\"subject\"]\n            text = f\"{subject}\\n\"\n        body = None\n        # You would think \"get_body\" would give us the body but...maybe not? ugh\n        try:\n            body = (parsed_email.get_body(preferencelist=('plain', 'html',)).\n                    get_content())\n        except Exception:\n            if parsed_email.is_multipart():\n                for part in parsed_email.walk():\n                    ctype = part.get_content_type()\n                    cdispo = str(part.get('Content-Disposition'))\n\n                    # skip any text/plain (txt) attachments\n                    if ctype == 'text/plain' and 'attachment' not in cdispo:\n                        body = part.get_payload(decode=True)  # decode\n                        break\n                    # not multipart - i.e. plain text, no attachments, \n                    # keeping fingers crossed\n            else:\n                body = parsed_email.get_payload(decode=True)\n        text = f\"{text}{body}\"\n        text = text.replace(\"\\r\\n\", \"\\n\").rstrip(\"\\n\")\n        self.emails_forwaded.inc()\n        for rcpt in envelope.rcpt_tos:\n            message = CombinedMessage(\n                text=text,\n                to=parseaddr(rcpt)[1].split('@')[0],\n                msg_from=envelope.mail_from,\n                from_device=False,\n                protocol=EMAIL_PROTOCOL)\n            self.user_pool.get_pool().submit(\n                lambda actor, message: actor.handle_message.remote(message),\n                message)\n        return '250 Message accepted for delivery'\n```", "```py\n    def update_label(self, opp=\"add\"):\n        label = self.label\n        patch_json = (\n            \"[{\" +\n            f\"\"\" \"op\": \"{opp}\", \"path\": \"/metadata/labels/{label}\", \"\"\" + \n            f\"\"\" \"value\": \"present\" \"\"\" +\n            \"}]\")\n        print(f\"Preparing to patch with {patch_json}\")\n        try:\n            kube_host = os.getenv(\"KUBERNETES_SERVICE_HOST\")\n            kube_port = os.getenv(\"KUBERNETES_PORT_443_TCP_PORT\", \"443\")\n            pod_namespace = os.getenv(\"POD_NAMESPACE\")\n            pod_name = os.getenv(\"POD_NAME\")\n            url = f\"http://{kube_host}:{kube_port}/api/v1/namespace/\" + \n                  f\"{pod_namespace}/pods/{pod_name}\"\n            headers = {\"Content-Type\": \"application/json-patch+json\"}\n            print(f\"Patching with url {url}\")\n            result = requests.post(url, data=patch_json, headers=headers)\n            logging.info(f\"Got back {result} updating header.\")\n            print(f\"Got patch result {result}\")\n            if result.status_code != 200:\n                raise Exception(f\"Got back a bad status code {result.status_code}\")\n        except Exception as e:\n            print(f\"Got an error trying to patch with https API {e}\")\n            patch_cmd = [\n                \"kubectl\",\n                \"patch\",\n                \"pod\",\n                \"-n\",\n                pod_namespace,\n                pod_name,\n                \"--type=json\",\n                f\"-p={patch_json}\"]\n            print(\"Running cmd:\")\n            print(\" \".join(patch_cmd))\n            out = subprocess.check_output(patch_cmd)\n            print(f\"Got {out} from patching pod.\")\n        print(\"Pod patched?\")\n```", "```py\n    async def run(self):\n        print(\"Prepairing to run.\")\n        internal_retries = 0\n        self.running = True\n        while self.running:\n            try:\n                self._login()\n                while True:\n                    await asyncio.sleep(self.delay)\n                    await self.check_msgs()\n                    internal_retries = 0  # On success reset retry counter.\n            except Exception as e:\n                print(f\"Error {e} while checking messages.\")\n                logging.error(f\"Error {e}, retrying\")\n                internal_retries = internal_retries + 1\n                if (internal_retries > self.max_internal_retries):\n                    raise e\n```", "```py\n    async def check_msgs(self):\n        print(\"Checking messages...\")\n        res = self.session.get(\n            self._getMessageURL,\n            headers=self.hdrs,\n            params={'count': self._page_request_size, 'status': 0})\n        messages = res.json()\n        for item in messages:\n            # Is this a message we are responsible for\n            if int(item[\"messageId\"]) % self.poolsize == self.idx:\n                try:\n                    await self._process_mesage(item)\n                except Exception as e:\n                    logging.error(f\"Error {e} processing {item}\")\n                self.session.post(\n                    self._ackMessageURL.format(item['packetId']),\n                    headers=self.hdrs)\n        print(\"Done!\")\n```", "```py\n    async def _decode_message(self, item: dict) -> AsyncIterator[CombinedMessage]:\n        \"\"\"\n Decode a message. Note: result is not serializable.\n \"\"\"\n        raw_msg_data = item[\"data\"]\n        logging.info(f\"msg: {raw_msg_data}\")\n        messagedata = MessageDataPB()  # noqa\n        bin_data = base64.b64decode(raw_msg_data)\n        # Note: this really does no validation, so if it gets a message instead\n        # of MessageDataPb it just gives back nothing\n        messagedata.ParseFromString(bin_data)\n        logging.info(f\"Formatted: {text_format.MessageToString(messagedata)}\")\n        if (len(messagedata.message) < 1):\n            logging.warn(f\"Received {raw_msg_data} with no messages?\")\n        for message in messagedata.message:\n            yield CombinedMessage(\n                text=message.text, to=message.to, protocol=message.protocol,\n                msg_from=item[\"deviceId\"], from_device=True\n            )\n\n    async def _ser_decode_message(self, item: dict) -> List[CombinedMessage]:\n        \"\"\"\n Decode a message. Serializeable but blocking. Exposed for testing.\n \"\"\"\n        gen = self._decode_message(item)\n        # See PEP-0530\n        return [i async for i in gen]\n\n    async def _process_message(self, item: dict):\n        messages = self._decode_message(item)\n        async for message in messages:\n            self.user_pool.get_pool().submit(\n                lambda actor, msg: actor.handle_message.remote(msg),\n                message)\n```", "```py\nclass UserActorBase():\n    \"\"\"\n Base client class for talking to the swarm.space APIs.\n Note: this actor is not async because Django's ORM is not happy with\n async.\n \"\"\"\n\n    def __init__(self, settings: Settings, idx: int, poolsize: int):\n        print(f\"Running on {platform.machine()}\")\n        self.settings = settings\n        self.idx = idx\n        self.poolsize = poolsize\n        self.satellite_pool = utils.LazyNamedPool(\"satellite\", poolsize)\n        self.outbound_sms = utils.LazyNamedPool(\"sms\", poolsize)\n        self.mail_client = MailClient(self.settings)\n        self.messages_forwarded = Counter(\n            \"messages_forwarded\",\n            description=\"Messages forwarded\",\n            tag_keys=(\"idx\",),\n        )\n        self.messages_forwarded.set_default_tags(\n            {\"idx\": str(idx)})\n        self.messages_rejected = Counter(\n            \"messages_rejected\",\n            description=\"Rejected messages\",\n            tag_keys=(\"idx\",),\n        )\n        self.messages_rejected.set_default_tags(\n            {\"idx\": str(idx)})\n        print(f\"Starting user actor {idx}\")\n\n    def _fetch_user(self, msg: CombinedMessage) -> User:\n        \"\"\"\n Find the user associated with the message.\n \"\"\"\n        if (msg.from_device):\n            device = Device.objects.get(serial_number=msg.msg_from)\n            return device.user\n        elif (msg.protocol == EMAIL_PROTOCOL):\n            username = msg.to\n            print(f\"Fetching user {msg.to}\")\n            try:\n                return User.objects.get(username=username)\n            except Exception as e:\n                print(f\"Failed to get user: {username}?\")\n                raise e\n        elif (msg.protocol == SMS_PROTOCOL):\n            print(f\"Looking up user for phone {msg.to}\")\n            try:\n                return User.objects.get(twillion_number=str(msg.to))\n            except Exception as e:\n                print(f\"Failed to get user: {username}?\")\n                raise e\n        else:\n            raise Exception(f\"Unhandled protocol? - {msg.protocol}\")\n\n    def prepare_for_shutdown(self):\n        \"\"\"\n Prepare for shutdown (not needed for sync DB connection)\n \"\"\"\n        pass\n\n    def handle_message(self, input_msg: CombinedMessage):\n        \"\"\"\n Handle messages.\n \"\"\"\n        print(f\"Handling message {input_msg}\")\n        user = self._fetch_user(input_msg)\n        self.messages_forwarded.inc()\n        if (input_msg.from_device):\n            msg = {\n                \"data\": input_msg.text,\n                \"msg_from\": f\"{user.username}@spacebeaver.com\",\n                \"msg_to\": input_msg.to\n            }\n            # Underneath this calls a ray.remote method.\n            self.mail_client.send_message(**msg)\n        else:\n            msg = {\n                \"protocol\": input_msg.protocol,\n                \"msg_from\": input_msg.msg_from,\n                \"msg_to\": user.device.serial_number,\n                \"data\": input_msg.text\n            }\n            self.satellite_pool.get_pool().submit(\n                lambda actor, msg: actor.send_message.remote(**msg),\n                msg)\n\n@ray.remote(max_restarts=-1)\nclass UserActor(UserActorBase):\n    \"\"\"\n Routes messages and checks the user account info.\n \"\"\"\n```", "```py\nfrom messaging.utils import utils\nfrom pydantic import BaseModel, Field\nfrom fastapi import FastAPI, HTTPException, Request\nfrom ray import serve\nfrom messaging.settings.settings import Settings\nfrom messaging.proto.MessageDataPB_pb2 import SMS as SMS_PROTOCOL\nfrom messaging.internal_types import CombinedMessage\nfrom typing import Optional\nfrom twilio.request_validator import RequestValidator\n\n# 1: Define a FastAPI app and wrap it in a deployment with a route handler.\napp = FastAPI()\n\nclass InboundMessage(BaseModel):\n    x_twilio_signature: str\n    message_from: str = Field(None, alias='from')\n    to: str\n    body: str\n    msg_type: Optional[str] = Field(None, alias=\"type\")\n\n@serve.deployment(num_replicas=3, route_prefix=\"/\")\n@serve.ingress(app)\nclass PhoneWeb:\n    def __init__(self, settings: Settings, poolsize: int):\n        self.settings = settings\n        self.poolsize = poolsize\n        self.user_pool = utils.LazyNamedPool(\"user\", poolsize)\n        self.validator = RequestValidator(settings.TW_AUTH_TOKEN)\n\n    # FastAPI will automatically parse the HTTP request for us.\n    @app.get(\"/sms\")\n    async def inbound_message(self, request: Request, \n    message: InboundMessage) -> str:\n        # Validate the message\n        request_valid = self.validator.validate(\n            request.url,\n            request.form,\n            request.headers.get('X-TWILIO-SIGNATURE', ''))\n        if request_valid:\n            internal_message = CombinedMessage(\n                text=message.body, to=message.to, protocol=SMS_PROTOCOL,\n                msg_from=message.message_from, from_device=False\n            )\n            self.user_pool.get_pool().submit(\n                lambda actor, msg: actor.handle_message.remote(msg), \n                internal_message)\n            return \"\"\n        else:\n            raise HTTPException(status_code=403, detail=\"Validation failed.\")\n```", "```py\nclass StandaloneMailServerActorTests(unittest.TestCase):\n    port = 7779 + 100 * random.randint(0, 9)\n\n    def setUp(self):\n        self.port = self.port + 1\n        self.actor = mailserver_actor.MailServerActorBase(\n            idx=1, poolsize=1, port=self.port, hostname=\"0.0.0.0\",\n            label=None)\n        self.actor.user_pool = test_utils.FakeLazyNamedPool(\"u\", 1)\n        self.pool = self.actor.user_pool.get_pool()\n\n    def tearDown(self):\n        self.actor.server.stop()\n        self.server = None\n\n    def test_constructor_makes_server(self):\n        self.assertEquals(self.actor.server.hostname, \"0.0.0.0\")\n\n    def test_extract_body_and_connect(self):\n        client = Client(\"localhost\", self.port)\n        msg_text = \"Hi Boop, this is timbit.\"\n        client.sendmail(\"c@gull.com\", \"boop@spacebeaver.com\",\n                        msg_text)\n        self.assertEquals(self.pool.submitted[0][1].text, msg_text)\n        self.assertEquals(self.pool.submitted[0][1].protocol, EMAIL_PROTOCOL)\n        self.assertEquals(self.pool.submitted[0][1].from_device, False)\n```", "```py\n@ray.remote\nclass MailServerActorForTesting(mailserver_actor.MailServerActorBase):\n    def __init__(self, idx, poolsize, port, hostname):\n        mailserver_actor.MailServerActorBase.__init__(self, idx, poolsize, \n                                                      port, hostname)\n        self.user_pool = test_utils.FakeLazyNamedPool(\"user\", 1)\n\nclass MailServerActorTestCases(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        ray.init()\n\n    @classmethod\n    def tearDownClass(cls):\n        ray.shutdown()\n\n    def test_mail_server_actor_construct(self):\n        mailserver_actor.MailServerActor.remote(0, 1, 7587, \"localhost\")\n```", "```py\napiVersion: v1\nkind: Service\nmetadata:\n  name: message-backend-svc\n  namespace: spacebeaver\nspec:\n  selector:\n    mail_ingress: present\n  ports:\n    - name: smtp\n      protocol: TCP\n      port: 25\n      targetPort: 7420\n  type: LoadBalancer\n  loadBalancerIP: 23.177.16.210\n  sessionAffinity: None\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: phone-api-svc\n  namespace: spacebeaver\nspec:\n  selector:\n    ray-cluster-name: spacebeaver\n  ports:\n    - name: http\n      protocol: TCP\n      port: 80\n      targetPort: 8000\n  type: LoadBalancer\n  sessionAffinity: None\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: spacebeaver-phone-api-ingress\n  namespace: spacebeaver\n  annotations:\n    cert-manager.io/cluster-issuer: letsencrypt\n    cert-manager.io/issue-temporary-certificate: \"true\"\n    acme.cert-manager.io/http01-edit-in-place: \"true\"\nspec:\n  ingressClassName: nginx\n  tls:\n  - hosts:\n      - phone-api.spacebeaver.com\n    secretName: phone-api-tls-secret\n  rules:\n    - host: \"phone-api.spacebeaver.com\"\n      http:\n        paths:\n        - pathType: Prefix\n          path: \"/\"\n          backend:\n            service:\n              name: phone-api-svc\n              port:\n                number: 80\n```"]