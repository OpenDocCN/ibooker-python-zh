<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Dependency Management"><div class="chapter" id="chapter_dependencies">
<h1><span class="label">Chapter 4. </span>Dependency Management</h1>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id272">
<h1>A Note for Early Release Readers</h1>
<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>

<p>This will be the fourth chapter of the final book. Please note that the GitHub repo will be made active later on.</p>

<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the author at <a href="mailto:mail@claudiojolowicz.com">mail@claudiojolowicz.com</a>.</p>
</div></aside>

<p>Python programmers benefit from a rich ecosystem of third-party libraries and
tools. Standing on the shoulders of giants comes at a price: The packages you
depend on for your projects generally depend on a number of packages themselves.
All of these are moving targets—​as long as any project is alive, its
maintainers will publish a stream of releases to fix bugs, add features, and
adapt to the evolving ecosystem.</p>

<p>Managing dependencies is a major challenge when you maintain software over time.
You need to keep your project up-to-date, if only to close security
vulnerabilities in a timely fashion. Often this requires updating your
dependencies to the latest version—​few open source projects have the resources
to distribute security updates for older releases. You’ll be updating
dependencies all the time! Making the process as frictionless, automated, and
reliable as possible comes with a huge payoff.</p>

<p><em>Dependencies</em> of a Python project are the third-party packages that must be
installed in its environment.<sup><a data-type="noteref" id="id273-marker" href="ch04.html#id273">1</a></sup> Most commonly, you
incur a dependency on a package because it distributes a module you import. We
also say that the project <em>requires</em> a package.</p>

<p>Many projects also use third-party tools for developer tasks—​like running the
test suite or building documentation. These packages are known as <em>development
dependencies</em>: end users don’t need them to run your code. A related case is the
build dependencies from <a data-type="xref" href="ch03.html#chapter_packages">Chapter 3</a>, which let you create packages for
your project.</p>

<p>Dependencies are like relatives. If you depend on a package, its dependencies
are your dependencies, too—​no matter how much you like them. These packages are
known as <em>indirect dependencies</em>; you can think of them as a tree with your
project at its root.</p>

<p>This chapter explains how to manage dependencies effectively. In the next
section, you’ll learn how to specify dependencies in <em>pyproject.toml</em>, as part
of the project metadata. Afterwards, I’ll talk about development dependencies
and requirements files. Finally, I’ll explain how you can <em>lock</em> dependencies to
precise versions for reliable deployments and repeatable checks.</p>






<section data-type="sect1" data-pdf-bookmark="Adding Dependencies to the Example Application"><div class="sect1" id="id120">
<h1>Adding Dependencies to the Example Application</h1>

<p>As a working example, let’s enhance <code>random-wikipedia-article</code> from
<a data-type="xref" href="ch03.html#example_packages_wikipedia">Example 3-1</a> with the <a href="https://www.python-httpx.org/">HTTPX</a>
library, a fully featured HTTP client that supports both synchronous and
asynchronous requests, as well as the newer (and far more efficient) protocol
version HTTP/2. You’ll also improve the output of the program using
<a href="https://rich.readthedocs.io">Rich</a>, a library for rich text and beautiful
formatting in the terminal.</p>








<section data-type="sect2" data-pdf-bookmark="Consuming an API with HTTPX"><div class="sect2" id="id121">
<h2>Consuming an API with HTTPX</h2>

<p>Wikipedia asks developers to set a <code>User-Agent</code> header with contact details.
That’s not so they can send out postcards to congratulate folks on their
proficient use of the Wikipedia API. It gives them a way to reach out if a
client inadvertently hammers their servers.</p>

<p><a data-type="xref" href="#example_dependencies_wikipedia_httpx">Example 4-1</a> shows how you can use <code>httpx</code> to send a
request to the Wikipedia API with the header. You could also use the standard
library to send a <code>User-Agent</code> header with your requests. But <code>httpx</code> offers a
more intuitive, explicit, and flexible interface, even when you’re not using any
of its advanced features. Try it out:</p>
<div id="example_dependencies_wikipedia_httpx" data-type="example">
<h5><span class="label">Example 4-1. </span>Using <code>httpx</code> to consume the Wikipedia API</h5>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code><code> </code><code class="nn">textwrap</code><code>
</code><code class="kn">import</code><code> </code><code class="nn">httpx</code><code>
</code><code>
</code><code class="n">API_URL</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">https://en.wikipedia.org/api/rest_v1/page/random/summary</code><code class="s2">"</code><code>
</code><code class="n">USER_AGENT</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">random-wikipedia-article/0.1 (Contact: you@example.com)</code><code class="s2">"</code><code>
</code><code>
</code><code class="k">def</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">headers</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code class="s2">"</code><code class="s2">User-Agent</code><code class="s2">"</code><code class="p">:</code><code> </code><code class="n">USER_AGENT</code><code class="p">}</code><code>
</code><code>
</code><code>    </code><code class="k">with</code><code> </code><code class="n">httpx</code><code class="o">.</code><code class="n">Client</code><code class="p">(</code><code class="n">headers</code><code class="o">=</code><code class="n">headers</code><code class="p">)</code><code> </code><code class="k">as</code><code> </code><code class="n">client</code><code class="p">:</code><code> </code><a class="co" id="co_dependency_management_CO1-1" href="#callout_dependency_management_CO1-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>        </code><code class="n">response</code><code> </code><code class="o">=</code><code> </code><code class="n">client</code><code class="o">.</code><code class="n">get</code><code class="p">(</code><code class="n">API_URL</code><code class="p">,</code><code> </code><code class="n">follow_redirects</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code><code> </code><a class="co" id="co_dependency_management_CO1-2" href="#callout_dependency_management_CO1-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a><code>
</code><code>        </code><code class="n">response</code><code class="o">.</code><code class="n">raise_for_status</code><code class="p">(</code><code class="p">)</code><code> </code><a class="co" id="co_dependency_management_CO1-3" href="#callout_dependency_management_CO1-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a><code>
</code><code>        </code><code class="n">data</code><code> </code><code class="o">=</code><code> </code><code class="n">response</code><code class="o">.</code><code class="n">json</code><code class="p">(</code><code class="p">)</code><code> </code><a class="co" id="co_dependency_management_CO1-4" href="#callout_dependency_management_CO1-4"><img src="assets/4.png" alt="4" width="12" height="12"/></a><code>
</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="n">data</code><code class="p">[</code><code class="s2">"</code><code class="s2">title</code><code class="s2">"</code><code class="p">]</code><code class="p">,</code><code> </code><code class="n">end</code><code class="o">=</code><code class="s2">"</code><code class="se">\n</code><code class="se">\n</code><code class="s2">"</code><code class="p">)</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="n">textwrap</code><code class="o">.</code><code class="n">fill</code><code class="p">(</code><code class="n">data</code><code class="p">[</code><code class="s2">"</code><code class="s2">extract</code><code class="s2">"</code><code class="p">]</code><code class="p">)</code><code class="p">)</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" id="callout_dependency_management_CO1-1" href="#co_dependency_management_CO1-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>When creating a client instance, you can specify headers that it should send with every request—​like the <code>User-Agent</code> header. Using the client as a context manager ensures that the network connection is closed at the end of the <code>with</code> block.</p></dd>
<dt><a class="co" id="callout_dependency_management_CO1-2" href="#co_dependency_management_CO1-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>This line performs two HTTP <code>GET</code> requests to the API. The first one goes to the <em>random</em> endpoint, which responds with a redirect to the actual article. The second one follows the redirect.</p></dd>
<dt><a class="co" id="callout_dependency_management_CO1-3" href="#co_dependency_management_CO1-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>The <code>raise_for_status</code> method raises an exception if the server response indicates an error via its status code.</p></dd>
<dt><a class="co" id="callout_dependency_management_CO1-4" href="#co_dependency_management_CO1-4"><img src="assets/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>The <code>json</code> method abstracts the details of parsing the response body as JSON.</p></dd>
</dl>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Console Output with Rich"><div class="sect2" id="id122">
<h2>Console Output with Rich</h2>

<p>While you’re at it, let’s improve the look and feel of the program.
<a data-type="xref" href="#example_dependencies_wikipedia_rich">Example 4-2</a> uses Rich, a library for console output,
to display the article title in bold. That hardly scrapes the surface of Rich’s
formatting options. Modern terminals are surprisingly capable, and Rich lets you
leverage their potential with ease. Take a look at its
<a href="https://rich.readthedocs.io/">official documentation</a> for details.</p>
<div id="example_dependencies_wikipedia_rich" data-type="example">
<h5><span class="label">Example 4-2. </span>Using Rich to enhance console output</h5>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code><code> </code><code class="nn">httpx</code><code>
</code><code class="kn">from</code><code> </code><code class="nn">rich</code><code class="nn">.</code><code class="nn">console</code><code> </code><code class="kn">import</code><code> </code><code class="n">Console</code><code>
</code><code>
</code><code class="k">def</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>
</code><code>    </code><code class="n">console</code><code> </code><code class="o">=</code><code> </code><code class="n">Console</code><code class="p">(</code><code class="n">width</code><code class="o">=</code><code class="mi">72</code><code class="p">,</code><code> </code><code class="n">highlight</code><code class="o">=</code><code class="kc">False</code><code class="p">)</code><code> </code><a class="co" id="co_dependency_management_CO2-1" href="#callout_dependency_management_CO2-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>    </code><code class="n">console</code><code class="o">.</code><code class="n">print</code><code class="p">(</code><code class="n">data</code><code class="p">[</code><code class="s2">"</code><code class="s2">title</code><code class="s2">"</code><code class="p">]</code><code class="p">,</code><code> </code><code class="n">style</code><code class="o">=</code><code class="s2">"</code><code class="s2">bold</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="n">end</code><code class="o">=</code><code class="s2">"</code><code class="se">\n</code><code class="se">\n</code><code class="s2">"</code><code class="p">)</code><code> </code><a class="co" id="co_dependency_management_CO2-2" href="#callout_dependency_management_CO2-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a><code>
</code><code>    </code><code class="n">console</code><code class="o">.</code><code class="n">print</code><code class="p">(</code><code class="n">data</code><code class="p">[</code><code class="s2">"</code><code class="s2">extract</code><code class="s2">"</code><code class="p">]</code><code class="p">)</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" id="callout_dependency_management_CO2-1" href="#co_dependency_management_CO2-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Console objects provide a featureful <code>print</code> method for console output.
Setting the console width to 72 characters replaces our earlier call to
<code>textwrap.fill</code>. You’ll also want to disable automatic syntax highlighting,
since you’re formatting prose rather than data or code.</p></dd>
<dt><a class="co" id="callout_dependency_management_CO2-2" href="#co_dependency_management_CO2-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>The <code>style</code> keyword allows you to set the title apart using a bold font.</p></dd>
</dl>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Specifying Dependencies for a Project"><div class="sect1" id="section_dependencies_specifications">
<h1>Specifying Dependencies for a Project</h1>

<p>If you haven’t done so yet, create and activate a virtual environment for the
project, and perform an editable install from the current directory:</p>
<pre data-type="programlisting">$ <strong>uv venv</strong>
$ <strong>uv pip install --editable .</strong></pre>

<p>You may be tempted to install <code>httpx</code> and <code>rich</code> manually into the environment.
Instead, add them to the project dependencies in <em>pyproject.toml</em>. This ensures
that whenever you install your project, the two packages are installed along
with it.</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project]</code><code class="w"/>
<code class="n">name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"random-wikipedia-article"</code><code class="w"/>
<code class="n">version</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"0.1"</code><code class="w"/>
<code class="n">dependencies</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"httpx"</code><code class="p">,</code><code class="w"> </code><code class="s2">"rich"</code><code class="p">]</code><code class="w"/>
<code class="p">...</code><code class="w"/></pre>

<p>If you reinstall the project, you’ll see that uv installs its dependencies as
well:</p>
<pre data-type="programlisting">$ <strong>uv pip install --editable .</strong></pre>

<p>Each entry in the <code>dependencies</code> field is a <em>dependency specification</em>. Besides
the package name, it lets you supply additional information: version specifiers,
extras, and environment markers. The following sections explain what these are.</p>








<section data-type="sect2" data-pdf-bookmark="Version Specifiers"><div class="sect2" id="section_dependencies_version_specifiers">
<h2>Version Specifiers</h2>

<p><em>Version specifiers</em> define the range of acceptable versions for a package. When
you add a new dependency, it’s a good idea to include its current version as a
lower bound—​unless your project needs to be compatible with older releases.
Update the lower bound whenever you start relying on newer features of the
package.</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project]</code><code class="w"/>
<code class="n">dependencies</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"httpx&gt;=0.27.0"</code><code class="p">,</code><code class="w"> </code><code class="s2">"rich&gt;=13.7.1"</code><code class="p">]</code><code class="w"/></pre>

<p>Why declare lower bounds on your dependencies? Installers choose the latest
version for a dependency by default. There are three reasons why you should
care. First, libraries are typically installed alongside other packages, which
may have additional version constraints. Second, even applications aren’t always
installed in isolation—​for example, Linux distros may package your application
for the system-wide environment. Third, lower bounds help you detect version
conflicts in your own dependency tree—​such as when you require a recent release
of a package, but another dependency only works with its older releases.</p>

<p>Avoid speculative upper version bounds—​you shouldn’t guard against newer
releases unless you know they’re incompatible with your project. See
<a data-type="xref" href="#sidebar_dependencies_upper_version_bounds">“Upper Version Bounds in Python”</a> about issues with version capping.</p>

<p><em>Lock files</em> are a much better solution to dependency-induced breakage than
upper bounds—​they request “known good” versions of your dependencies when
deploying a service or running automated checks (see
<a data-type="xref" href="#section_dependencies_locking">“Locking Dependencies”</a>).</p>

<p>If a botched release breaks your project, publish a bugfix release to exclude
that specific broken version:</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project]</code><code class="w"/>
<code class="n">dependencies</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"awesome&gt;=1.2,!=1.3.1"</code><code class="p">]</code><code class="w"/></pre>

<p>Use an upper bound as a last resort if a dependency breaks compatibility
permanently. Lift the version cap once you’re able to adapt your code:</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project]</code><code class="w"/>
<code class="n">dependencies</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"awesome&gt;=1.2,&lt;2"</code><code class="p">]</code><code class="w"/></pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Excluding versions after the fact has a pitfall that you need to be aware of.
Dependency resolvers can decide to downgrade your project to a version without
the exclusion and upgrade the dependency anyway. Lock files can help with this.</p>
</div>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_dependencies_upper_version_bounds">
<h1>Upper Version Bounds in Python</h1>
<p>Some people routinely include upper bounds in version constraints. Packages
following the Semantic Versioning scheme use major versions to signal a
<em>breaking change</em>: an incompatible change to their public API.</p>

<p>As engineers, we err on the side of safety to build robust products. At first
glance, guarding against major releases seems like something any responsible
person would do. Even if most of them don’t break your project, isn’t it better
to opt in after you have a chance to test the release?</p>

<p>Unfortunately, upper version bounds quickly lead to unsolvable dependency
conflicts.<sup><a data-type="noteref" id="id274-marker" href="ch04.html#id274">2</a></sup> Python environments (unlike
Node.js environments, in particular) can only contain a single version of each
package. Libraries that put upper bounds on their dependencies prevent
downstream projects from receiving security and bug fixes. Before adding an
upper version bound, carefully consider the costs and benefits.</p>

<p>What exactly constitutes a breaking change is less defined than it may seem. For
example, should a project increment its major version every time it drops
support for an old Python version?</p>

<p>Even in clear cases, a breaking change will only break your project if it
affects the part of the public API that your project uses. By contrast, many
changes that will break your project aren’t marked by a version number: they’re
just bugs. In the end, you’ll still rely on automated tests to discover “bad”
versions and deal with them after the fact.</p>
</div></aside>

<p>Version specifiers support several operators, as shown in
<a data-type="xref" href="#table_dependencies_version_specifiers">Table 4-1</a>. In short, use the equality and
comparison operators you know from Python: <code>==</code>, <code>!=</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&lt;</code>, and <code>&gt;</code>.</p>
<table id="table_dependencies_version_specifiers">
<caption><span class="label">Table 4-1. </span>Version Specifiers</caption>
<thead>
<tr>
<th>Operator</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>==</code></p></td>
<td><p>Version matching</p></td>
<td><p>Versions must compare equal after normalization. Trailing zeros are stripped off.</p></td>
</tr>
<tr>
<td><p><code>!=</code></p></td>
<td><p>Version exclusion</p></td>
<td><p>The inverse of the <code>==</code> operator</p></td>
</tr>
<tr>
<td><p><code>&lt;=</code>, <code>&gt;=</code></p></td>
<td><p>Inclusive ordered comparison</p></td>
<td><p>Performs lexicographical comparison. Prereleases precede final releases.</p></td>
</tr>
<tr>
<td><p><code>&lt;</code>, <code>&gt;</code></p></td>
<td><p>Exclusive ordered comparison</p></td>
<td><p>Similar as above, but the versions must not compare equal</p></td>
</tr>
<tr>
<td><p><code>~=</code></p></td>
<td><p>Compatible release</p></td>
<td><p>Equivalent to <code>&gt;=x.y,==x.*</code> to the specified precision</p></td>
</tr>
<tr>
<td><p><code>===</code></p></td>
<td><p>Arbitrary equality</p></td>
<td><p>Simple string comparison for non-standard versions</p></td>
</tr>
</tbody>
</table>

<p>Three operators merit additional discussion:</p>

<ul>
<li>
<p>The <code>==</code> operator supports wildcards (<code>*</code>), albeit only at the end of the
version string. In other words, you can require the version to match a
particular prefix, such as <code>1.2.*</code>.</p>
</li>
<li>
<p>The <code>===</code> operator lets you perform a simple character-by-character
comparison. It’s best used as a last resort for non-standard versions.</p>
</li>
<li>
<p>The <code>~=</code> operator for compatible releases specifies that the version should be
greater than or equal to the given value, while still starting with the same
prefix. For example, <code>~=1.2.3</code> is equivalent to <code>&gt;=1.2.3,==1.2.*</code>, and <code>~=1.2</code>
is equivalent to <code>&gt;=1.2,==1.*</code>.</p>
</li>
</ul>

<p>You don’t need to guard against prereleases—​version specifiers exclude them by
default. Prereleases are valid candidates in three situations only: when
they’re already installed, when no other releases satisfy the dependency
specification, and when you request them explicitly, using a clause like
<code>&gt;=1.0.0rc1</code>.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Extras"><div class="sect2" id="section_dependencies_extras">
<h2>Extras</h2>

<p>Suppose you want to use the newer HTTP/2 protocol with <code>httpx</code>. This only
requires a small change to the code that creates the HTTP client:</p>

<pre data-type="programlisting" data-code-language="python"><code class="k">def</code> <code class="nf">main</code><code class="p">():</code>
    <code class="n">headers</code> <code class="o">=</code> <code class="p">{</code><code class="s2">"User-Agent"</code><code class="p">:</code> <code class="n">USER_AGENT</code><code class="p">}</code>
    <code class="k">with</code> <code class="n">httpx</code><code class="o">.</code><code class="n">Client</code><code class="p">(</code><code class="n">headers</code><code class="o">=</code><code class="n">headers</code><code class="p">,</code> <code class="n">http2</code><code class="o">=</code><code class="kc">True</code><code class="p">)</code> <code class="k">as</code> <code class="n">client</code><code class="p">:</code>
        <code class="o">...</code></pre>

<p>Under the hood, <code>httpx</code> delegates the gory details of speaking HTTP/2 to another
package, <code>h2</code>. That dependency is not pulled in by default, however. This way,
users who don’t need the newer protocol get away with a smaller dependency tree.
You do need it here, so activate the optional feature using the syntax
<code>httpx[http2]</code>:</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project]</code><code class="w"/>
<code class="n">dependencies</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"httpx[http2]&gt;=0.27.0"</code><code class="p">,</code><code class="w"> </code><code class="s2">"rich&gt;=13.7.1"</code><code class="p">]</code><code class="w"/></pre>

<p>Optional features that require additional dependencies are known as <em>extras</em>,
and you can have more than one. For example, you could specify
<code>httpx[http2,brotli]</code> to allow decoding responses with <em>Brotli compression</em>,
which is a compression algorithm developed at Google that’s common in web
servers and content delivery networks.</p>










<section data-type="sect3" data-pdf-bookmark="Optional dependencies"><div class="sect3" id="section_dependencies_optional">
<h3>Optional dependencies</h3>

<p>Let’s take a look at this situation from the point of view of <code>httpx</code>. The <code>h2</code>
and <code>brotli</code> dependencies are optional, so <code>httpx</code> declares them under
<code>optional-dependencies</code> instead of <code>dependencies</code>
(<a data-type="xref" href="#example_dependencies_httpx_extras">Example 4-3</a>).</p>
<div id="example_dependencies_httpx_extras" data-type="example">
<h5><span class="label">Example 4-3. </span>Optional dependencies of <code>httpx</code> (simplified)</h5>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project]</code><code class="w"/>
<code class="n">name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"httpx"</code><code class="w"/>

<code class="k">[project.optional-dependencies]</code><code class="w"/>
<code class="n">http2</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"h2&gt;=3,&lt;5"</code><code class="p">]</code><code class="w"/>
<code class="n">brotli</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"brotli"</code><code class="p">]</code><code class="w"/></pre></div>

<p>The <code>optional-dependencies</code> field is a TOML table. It can hold multiple lists of
dependencies, one for each extra provided by the package. Each entry is a
dependency specification and uses the same rules as the <code>dependencies</code> field.</p>

<p>If you add an optional dependency to your project, how do you use it in your
code? Don’t check if your package was installed with the extra—​just import the
optional package. You can catch the <code>ImportError</code> exception if the user didn’t
request the extra:</p>

<pre data-type="programlisting" data-code-language="python"><code class="k">try</code><code class="p">:</code>
    <code class="kn">import</code> <code class="nn">h2</code>
<code class="k">except</code> <code class="ne">ImportError</code><code class="p">:</code>
    <code class="n">h2</code> <code class="o">=</code> <code class="kc">None</code>

<code class="c1"># Check h2 before use.</code>
<code class="k">if</code> <code class="n">h2</code> <code class="ow">is</code> <code class="ow">not</code> <code class="kc">None</code><code class="p">:</code>
    <code class="o">...</code></pre>

<p>This is a common pattern in Python—​so common it comes with a name and an
acronym: “Easier to Ask Forgiveness than Permission” (EAFP). Its less Pythonic
counterpart is dubbed “Look Before You Leap” (LBYL).</p>
</div></section>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Environment Markers"><div class="sect2" id="section_dependencies_environment_markers">
<h2>Environment Markers</h2>

<p>The third piece of metadata you can specify for a dependency is environment
markers. Before I explain what these markers are, let me show you an example of
where they come in handy.</p>

<p>If you looked at the <code>User-Agent</code> header in
<a data-type="xref" href="#example_dependencies_wikipedia_httpx">Example 4-1</a> and thought, “I shouldn’t have to
repeat the version number in the code,” you’re absolutely right. As you saw in
<a data-type="xref" href="ch03.html#section_packages_single_sourcing_the_version">“Single-sourcing the project version”</a>, you can read the version of
your package from its metadata in the environment.</p>

<p><a data-type="xref" href="#example_dependencies_wikipedia_importlib_metadata">Example 4-4</a> shows how you can use the
function <code>importlib.metadata.metadata</code> to construct the <code>User-Agent</code> header from
the core metadata fields <code>Name</code>, <code>Version</code>, and <code>Author-email</code>. These fields
correspond to <code>name</code>, <code>version</code>, and <code>authors</code> in the project
metadata.<sup><a data-type="noteref" id="id275-marker" href="ch04.html#id275">3</a></sup></p>
<div id="example_dependencies_wikipedia_importlib_metadata" data-type="example">
<h5><span class="label">Example 4-4. </span>Using <code>importlib.metadata</code> to build a <code>User-Agent</code> header</h5>

<pre data-type="programlisting" data-code-language="python"><code class="kn">from</code><code> </code><code class="nn">importlib</code><code class="nn">.</code><code class="nn">metadata</code><code> </code><code class="kn">import</code><code> </code><code class="n">metadata</code><code>
</code><code>
</code><code class="n">USER_AGENT</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="si">{Name}</code><code class="s2">/</code><code class="si">{Version}</code><code class="s2"> (Contact: </code><code class="s2">{</code><code class="s2">Author-email})</code><code class="s2">"</code><code>
</code><code>
</code><code class="k">def</code><code> </code><code class="nf">build_user_agent</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">fields</code><code> </code><code class="o">=</code><code> </code><code class="n">metadata</code><code class="p">(</code><code class="s2">"</code><code class="s2">random-wikipedia-article</code><code class="s2">"</code><code class="p">)</code><code> </code><a class="co" id="co_dependency_management_CO3-1" href="#callout_dependency_management_CO3-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>    </code><code class="k">return</code><code> </code><code class="n">USER_AGENT</code><code class="o">.</code><code class="n">format_map</code><code class="p">(</code><code class="n">fields</code><code class="p">)</code><code> </code><a class="co" id="co_dependency_management_CO3-2" href="#callout_dependency_management_CO3-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a><code>
</code><code>
</code><code class="k">def</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="n">headers</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code class="s2">"</code><code class="s2">User-Agent</code><code class="s2">"</code><code class="p">:</code><code> </code><code class="n">build_user_agent</code><code class="p">(</code><code class="p">)</code><code class="p">}</code><code>
</code><code>    </code><code class="o">.</code><code class="o">.</code><code class="o">.</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" id="callout_dependency_management_CO3-1" href="#co_dependency_management_CO3-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>The <code>metadata</code> function retrieves the core metadata fields for the package.</p></dd>
<dt><a class="co" id="callout_dependency_management_CO3-2" href="#co_dependency_management_CO3-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>The <code>str.format_map</code> function looks up each placeholder in the mapping.</p></dd>
</dl>

<p>The <code>importlib.metadata</code> library was introduced in Python 3.8. While it’s now
available in all supported versions, that wasn’t always so. Were you out of luck
if you had to support an older Python version?</p>

<p>Not quite. Fortunately, many additions to the standard library come with
<em>backports</em>—third-party packages that provide the functionality for older
interpreters. For <code>importlib.metadata</code>, you can fall back to the
<code>importlib-metadata</code> backport from PyPI. The backport remains useful because the
library changed several times after its introduction.</p>

<p>You only need backports in environments that use specific Python versions. An
environment marker lets you express this as a conditional dependency:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">importlib</code><code class="o">-</code><code class="n">metadata</code><code class="p">;</code> <code class="n">python_version</code> <code class="o">&lt;</code> <code class="s1">'3.8'</code></pre>

<p>Installers will only install the package on interpreters older than Python 3.8.</p>

<p>More generally, an <em>environment marker</em> expresses a condition that an
environment must satisfy for the dependency to apply. Installers evaluate the
condition on the interpreter of the target environment.</p>

<p>Environment markers let you request dependencies for specific operating systems,
processor architectures, Python implementations, or Python versions.
<a data-type="xref" href="#table_dependencies_environment_markers">Table 4-2</a> lists all the environment markers at
your disposal, as specified in PEP 508.<sup><a data-type="noteref" id="id276-marker" href="ch04.html#id276">4</a></sup></p>
<table id="table_dependencies_environment_markers">
<caption><span class="label">Table 4-2. </span>Environment Markers<sup><a data-type="noteref" id="id277-marker" href="ch04.html#id277">a</a></sup></caption>
<thead>
<tr>
<th>Environment Marker</th>
<th>Standard Library</th>
<th>Description</th>
<th>Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>os_name</code></p></td>
<td><p><code>os.name()</code></p></td>
<td><p>The operating system family</p></td>
<td><p><code>posix</code>, <code>nt</code></p></td>
</tr>
<tr>
<td><p><code>sys_platform</code></p></td>
<td><p><code>sys.platform()</code></p></td>
<td><p>The platform identifier</p></td>
<td><p><code>linux</code>, <code>darwin</code>, <code>win32</code></p></td>
</tr>
<tr>
<td><p><code>platform_system</code></p></td>
<td><p><code>platform.system()</code></p></td>
<td><p>The system name</p></td>
<td><p>Linux, Darwin, Windows</p></td>
</tr>
<tr>
<td><p><code>platform_release</code></p></td>
<td><p><code>platform.release()</code></p></td>
<td><p>The operating system release</p></td>
<td><p><code>23.2.0</code></p></td>
</tr>
<tr>
<td><p><code>platform_version</code></p></td>
<td><p><code>platform.version()</code></p></td>
<td><p>The system release</p></td>
<td><p><code>Darwin Kernel Version 23.2.0: ...</code></p></td>
</tr>
<tr>
<td><p><code>platform_machine</code></p></td>
<td><p><code>platform.machine()</code></p></td>
<td><p>The processor architecture</p></td>
<td><p><code>x86_64</code>, <code>arm64</code></p></td>
</tr>
<tr>
<td><p><code>python_version</code></p></td>
<td><p><code>platform.python_version_tuple()</code></p></td>
<td><p>The Python feature version in the format <code>x.y</code></p></td>
<td><p><code>3.12</code></p></td>
</tr>
<tr>
<td><p><code>python_full_version</code></p></td>
<td><p><code>platform.python_version()</code></p></td>
<td><p>The full Python version</p></td>
<td><p><code>3.12.0</code>, <code>3.13.0a4</code></p></td>
</tr>
<tr>
<td><p><code>platform_python_implementation</code></p></td>
<td><p><code>platform.python_implementation()</code></p></td>
<td><p>The Python implementation</p></td>
<td><p><code>CPython</code>, <code>PyPy</code></p></td>
</tr>
<tr>
<td><p><code>implementation_name</code></p></td>
<td><p><code>sys.implementation.name</code></p></td>
<td><p>The Python implementation</p></td>
<td><p><code>cpython</code>, <code>pypy</code></p></td>
</tr>
<tr>
<td><p><code>implementation_version</code></p></td>
<td><p><code>sys.implementation.version</code></p></td>
<td><p>The Python implementation version</p></td>
<td><p><code>3.12.0</code>, <code>3.13.0a4</code></p></td>
</tr>
</tbody>
<tbody><tr class="footnotes"><td colspan="4"><p data-type="footnote" id="id277"><sup><a href="ch04.html#id277-marker">a</a></sup> The <code>python_version</code> and <code>implementation_version</code> markers apply transformations. See PEP 508 for details.</p></td></tr></tbody></table>

<p>Going back to <a data-type="xref" href="#example_dependencies_wikipedia_importlib_metadata">Example 4-4</a>, here’s the
full <code>dependencies</code> field with the <code>python_version</code> marker for
<code>importlib-metadata</code>:</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project]</code><code class="w"/>
<code class="n">dependencies</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="w"/>
<code class="w">    </code><code class="s2">"httpx[http2]&gt;=0.27.0"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="s2">"rich&gt;=13.7.1"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="s2">"importlib-metadata&gt;=7.0.2; python_version &lt; '3.8'"</code><code class="p">,</code><code class="w"/>
<code class="p">]</code><code class="w"/></pre>

<p>The import name for the backport is <code>importlib_metadata</code>, while the standard
library module is named <code>importlib.metadata</code>. You can import the appropriate
module in your code by checking the Python version in <code>sys.version_info</code>:</p>

<pre data-type="programlisting" data-code-language="python"><code class="k">if</code> <code class="n">sys</code><code class="o">.</code><code class="n">version_info</code> <code class="o">&gt;=</code> <code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="mi">8</code><code class="p">):</code>
    <code class="kn">from</code> <code class="nn">importlib.metadata</code> <code class="kn">import</code> <code class="n">metadata</code>
<code class="k">else</code><code class="p">:</code>
    <code class="kn">from</code> <code class="nn">importlib_metadata</code> <code class="kn">import</code> <code class="n">metadata</code></pre>

<p>Did I just hear somebody shout “EAFP”? If your imports depend on the Python
version, it’s better to avoid the technique from
<a data-type="xref" href="#section_dependencies_optional">“Optional dependencies”</a> and “look before you leap.” An explicit
version check communicates your intent to static analyzers, such as the mypy
type checker (see <a data-type="xref" href="ch10.html#chapter_typing">Chapter 10</a>). EAFP may result in errors from these
tools because they can’t detect when each module is available.</p>

<p>Markers support the same equality and comparison operators as version specifiers
(<a data-type="xref" href="#table_dependencies_version_specifiers">Table 4-1</a>). Additionally, you can use <code>in</code> and
<code>not in</code> to match a substring against the marker. For example, the expression
<code>'arm' in platform_version</code> checks if <code>platform.version()</code> contains the string
<code>'arm'</code>.</p>

<p>You can also combine multiple markers using the boolean operators <code>and</code> and
<code>or</code>. Here’s a rather contrived example combining all these features:</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project]</code><code class="w"/>
<code class="n">dependencies</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"""                                                         </code><code class="se">\</code><code class="w"/>
<code class="s2">  awesome-package; python_full_version &lt;= '3.8.1'                           </code><code class="se">\</code><code class="w"/>
<code class="s2">    and (implementation_name == 'cpython' or implementation_name == 'pypy') </code><code class="se">\</code><code class="w"/>
<code class="s2">    and sys_platform == 'darwin'                                            </code><code class="se">\</code><code class="w"/>
<code class="s2">    and 'arm' in platform_version                                           </code><code class="se">\</code><code class="w"/>
<code class="s2">"""</code><code class="p">]</code><code class="w"/></pre>

<p>The example also relies on TOML’s support for multi-line strings, which uses
triple quotes just like Python. Dependency specifications cannot span multiple
lines, so you have to escape the newlines with a backslash.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Development Dependencies"><div class="sect1" id="section_dependencies_development">
<h1>Development Dependencies</h1>

<p>Development dependencies are third-party packages that you require during
development. As a developer, you might use the pytest testing framework to run
the test suite for your project, the Sphinx documentation system to build its
docs, or a number of other tools to help with project maintenance. Your users,
on the other hand, don’t need to install any of these packages to run your code.</p>








<section data-type="sect2" data-pdf-bookmark="An Example: Testing with pytest"><div class="sect2" id="section_dependencies_pytest">
<h2>An Example: Testing with pytest</h2>

<p>As a concrete example, let’s add a small test for the <code>build_user_agent</code>
function from <a data-type="xref" href="#example_dependencies_wikipedia_importlib_metadata">Example 4-4</a>. Create a
directory <em>tests</em> with two files: an empty <em>__init__.py</em> and a module
<em>test_random_wikipedia_article.py</em> with the code from
<a data-type="xref" href="#example_dependencies_test_build_user_agent">Example 4-5</a>.</p>
<div id="example_dependencies_test_build_user_agent" data-type="example">
<h5><span class="label">Example 4-5. </span>Testing the generated <code>User-Agent</code> header</h5>

<pre data-type="programlisting" data-code-language="python"><code class="kn">from</code> <code class="nn">random_wikipedia_article</code> <code class="kn">import</code> <code class="n">build_user_agent</code>

<code class="k">def</code> <code class="nf">test_build_user_agent</code><code class="p">():</code>
    <code class="k">assert</code> <code class="s2">"random-wikipedia-article"</code> <code class="ow">in</code> <code class="n">build_user_agent</code><code class="p">()</code></pre></div>

<p><a data-type="xref" href="#example_dependencies_test_build_user_agent">Example 4-5</a> only uses built-in Python
features, so you could just import and run the test manually. But even for this
tiny test, pytest adds three useful features. First, it discovers modules and
functions whose names start with <code>test</code>, so you can run your tests by invoking
<code>pytest</code> without arguments. Second, pytest shows tests as it executes them, as
well as a summary with the test results at the end. Third, pytest rewrites
assertions in your tests to give you friendly, informative messages when they
fail.</p>

<p>Let’s run the test with pytest. I’m assuming you already have an active
virtual environment with an editable install of your project. Enter the commands
below to install and run pytest in that environment:</p>
<pre data-type="programlisting">$ <strong>uv pip install pytest</strong>
$ <strong>py -m pytest</strong>
========================= test session starts ==========================
platform darwin -- Python 3.12.2, pytest-8.1.1, pluggy-1.4.0
rootdir: ...
plugins: anyio-4.3.0
collected 1 item

tests/test_random_wikipedia_article.py .                          [100%]

========================== 1 passed in 0.22s ===========================
</pre>

<p>For now, things look great. Tests help your project evolve without breaking
things. The test for <code>build_user_agent</code> is a first step in that direction.
Installing and running pytest is a small infrastructure cost compared to these
long-term benefits.</p>

<p>Setting up a project environment becomes harder as you acquire more development
dependencies—​documentation generators, linters, code formatters, type checkers,
or other tools. Even your test suite may require more than pytest: plugins for
pytest, tools for measuring code coverage, or just packages that help you
exercise your code.</p>

<p>You also need compatible versions of these packages—​your test suite may require
the latest version of pytest, while your documentation may not build on the new
Sphinx release. Each of your projects may have slightly different requirements.
Multiply this by the number of developers working on each project, and it
becomes clear that you need a way to track your development dependencies.</p>

<p>As of this writing, Python doesn’t have a standard way to declare the
development dependencies of a project—​although many Python project managers
support them in their <code>[tool]</code> table and a draft PEP exists.<sup><a data-type="noteref" id="id278-marker" href="ch04.html#id278">5</a></sup> Besides project managers, people use two
approaches to fill the gap: optional dependencies and requirements files.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Optional Dependencies"><div class="sect2" id="id130">
<h2>Optional Dependencies</h2>

<p>As you’ve seen in <a data-type="xref" href="#section_dependencies_extras">“Extras”</a>, the <code>optional-dependencies</code>
table contains groups of optional dependencies named extras. It has three
properties that make it suitable for tracking development dependencies. First,
the packages aren’t installed by default, so end users don’t pollute their
Python environment with them. Second, it lets you group the packages under
meaningful names like <code>tests</code> or <code>docs</code>. And third, the field comes with the
full expressivity of dependency specifications, including version constraints
and environment markers.</p>

<p>On the other hand, there’s an impedance mismatch between development
dependencies and optional dependencies. Optional dependencies are exposed to
users through the package metadata—​they let users opt into features that
require additional packages. By contrast, users aren’t meant to install
development dependencies—​these packages aren’t required for any user-facing
features.</p>

<p>Furthermore, you can’t install extras without the project itself. By contrast,
not all developer tools need your project installed. For example, linters
analyze your source code for bugs and potential improvements. You can run them
on a project without installing it into the environment. Besides wasting time
and space, “fat” environments constrain dependency resolution unnecessarily. For
example, many Python projects could no longer upgrade important dependencies
when the Flake8 linter put a version cap on <code>importlib-metadata</code>.</p>

<p>Keeping this in mind, extras are widely used for development dependencies and
are the only method covered by a packaging standard. They’re a pragmatic choice,
especially if you manage linters with pre-commit (see <a data-type="xref" href="ch09.html#chapter_linting">Chapter 9</a>).
<a data-type="xref" href="#example_dependencies_dev_extras_tests_and_docs">Example 4-6</a> shows how you’d use extras to
track packages required for testing and documentation.</p>
<div id="example_dependencies_dev_extras_tests_and_docs" data-type="example">
<h5><span class="label">Example 4-6. </span>Using extras to represent development dependencies</h5>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[</code><code class="k">project</code><code class="k">.</code><code class="k">optional-dependencies</code><code class="k">]</code><code class="w">
</code><code class="n">tests</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"</code><code class="s2">pytest&gt;=8.1.1</code><code class="s2">"</code><code class="p">,</code><code class="w"> </code><code class="s2">"</code><code class="s2">pytest-sugar&gt;=1.0.0</code><code class="s2">"</code><code class="p">]</code><code class="w"> </code><a class="co" id="co_dependency_management_CO4-1" href="#callout_dependency_management_CO4-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a><code class="w">
</code><code class="n">docs</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"</code><code class="s2">sphinx&gt;=7.2.6</code><code class="s2">"</code><code class="p">]</code><code class="w"> </code><a class="co" id="co_dependency_management_CO4-2" href="#callout_dependency_management_CO4-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a></pre></div>
<dl class="calloutlist">
<dt><a class="co" id="callout_dependency_management_CO4-1" href="#co_dependency_management_CO4-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>The <code>pytest-sugar</code> plugin enhances pytest’s output with a progress bar and
shows failures immediately.</p></dd>
<dt><a class="co" id="callout_dependency_management_CO4-2" href="#co_dependency_management_CO4-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Sphinx is a documentation generator used by the official Python
documentation and many open source projects.</p></dd>
</dl>

<p>You can now install the test dependencies using the <code>tests</code> extra:</p>
<pre data-type="programlisting">$ <strong>uv pip install -e ".[tests]"</strong>
$ <strong>py -m pytest</strong>
</pre>

<p>You can also define a <code>dev</code> extra with all the development dependencies. This
lets you set up a development environment in one go, with your project and every
tool it uses:</p>
<pre data-type="programlisting">$ <strong>uv pip install -e ".[dev]"</strong></pre>

<p>There’s no need to repeat all the packages when you define <code>dev</code>. Instead, you
can just reference the other extras, as shown in
<a data-type="xref" href="#example_dependencies_dev_extra">Example 4-7</a>.</p>
<div id="example_dependencies_dev_extra" data-type="example">
<h5><span class="label">Example 4-7. </span>Providing a <code>dev</code> extra with all development dependencies</h5>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project.optional-dependencies]</code><code class="w"/>
<code class="n">tests</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"pytest&gt;=8.1.1"</code><code class="p">,</code><code class="w"> </code><code class="s2">"pytest-sugar&gt;=1.0.0"</code><code class="p">]</code><code class="w"/>
<code class="n">docs</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"sphinx&gt;=7.2.6"</code><code class="p">]</code><code class="w"/>
<code class="n">dev</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"random-wikipedia-article[tests,docs]"</code><code class="p">]</code><code class="w"/></pre></div>

<p>This style of declaring an extra is also known as a <em>recursive optional
dependency</em>, since the package with the <code>dev</code> extra depends on itself (with
<code>tests</code> and <code>docs</code> extras).</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Requirements Files"><div class="sect2" id="section_dependencies_requirements_files">
<h2>Requirements Files</h2>

<p><em>Requirements files</em> are plain text files with dependency specifications on each
line (<a data-type="xref" href="#example_dependencies_requirements_txt">Example 4-8</a>). Additionally, they can contain
URLs and paths, optionally prefixed by <code>-e</code> for an editable install, as well as
global options, such as <code>-r</code> to include another requirements file or
<code>--index-url</code> to use a package index other than PyPI. The file format also
supports Python-style comments (with a leading <code>#</code> character) and line
continuations (with a trailing <code>\</code> character).</p>
<div id="example_dependencies_requirements_txt" data-type="example">
<h5><span class="label">Example 4-8. </span>A simple requirements.txt file</h5>

<pre data-type="programlisting" data-code-language="python"><code class="n">pytest</code><code class="o">&gt;=</code><code class="mf">8.1.1</code>
<code class="n">pytest</code><code class="o">-</code><code class="n">sugar</code><code class="o">&gt;=</code><code class="mf">1.0.0</code>
<code class="n">sphinx</code><code class="o">&gt;=</code><code class="mf">7.2.6</code></pre></div>

<p>You can install the dependencies listed in a requirements file using pip or uv:</p>
<pre data-type="programlisting">$ <strong>uv pip install -r requirements.txt</strong>
</pre>

<p>By convention, a requirements file is named <em>requirements.txt</em>. However,
variations are common. You might have a <em>dev-requirements.txt</em> for development
dependencies or a <em>requirements</em> directory with one file per dependency group
(<a data-type="xref" href="#example_dependencies_dev_requirements">Example 4-9</a>).</p>
<div id="example_dependencies_dev_requirements" data-type="example">
<h5><span class="label">Example 4-9. </span>Using requirements files to specify development dependencies</h5>

<pre data-type="programlisting" data-code-language="python"><code class="c1"># requirements/tests.txt</code><code>
</code><code class="o">-</code><code class="n">e</code><code> </code><code class="o">.</code><code> </code><a class="co" id="co_dependency_management_CO5-1" href="#callout_dependency_management_CO5-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a><code>
</code><code class="n">pytest</code><code class="o">&gt;</code><code class="o">=</code><code class="mf">8.1</code><code class="mf">.1</code><code>
</code><code class="n">pytest</code><code class="o">-</code><code class="n">sugar</code><code class="o">&gt;</code><code class="o">=</code><code class="mf">1.0</code><code class="mf">.0</code><code>
</code><code>
</code><code class="c1"># requirements/docs.txt</code><code>
</code><code class="n">sphinx</code><code class="o">&gt;</code><code class="o">=</code><code class="mf">7.2</code><code class="mf">.6</code><code> </code><a class="co" id="co_dependency_management_CO5-2" href="#callout_dependency_management_CO5-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a><code>
</code><code>
</code><code class="c1"># requirements/dev.txt</code><code>
</code><code class="o">-</code><code class="n">r</code><code> </code><code class="n">tests</code><code class="o">.</code><code class="n">txt</code><code> </code><a class="co" id="co_dependency_management_CO5-3" href="#callout_dependency_management_CO5-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a><code>
</code><code class="o">-</code><code class="n">r</code><code> </code><code class="n">docs</code><code class="o">.</code><code class="n">txt</code></pre></div>
<dl class="calloutlist">
<dt><a class="co" id="callout_dependency_management_CO5-1" href="#co_dependency_management_CO5-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>The <em>tests.txt</em> file requires an editable install of the project because the
test suite needs to import the application modules.</p></dd>
<dt><a class="co" id="callout_dependency_management_CO5-2" href="#co_dependency_management_CO5-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>The <em>docs.txt</em> file doesn’t require the project. (That’s assuming you build
the documentation from static files only. If you use the <code>autodoc</code> Sphinx
extension to generate API documentation from docstrings in your code, you’ll
also need the project here.)</p></dd>
<dt><a class="co" id="callout_dependency_management_CO5-3" href="#co_dependency_management_CO5-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>The <em>dev.txt</em> file includes the other requirements files.</p></dd>
</dl>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you include other requirements files using <code>-r</code>, their paths are evaluated
relative to the including file. By contrast, paths to dependencies are evaluated
relative to your current directory, which is typically the project directory.</p>
</div>

<p>Create and activate a virtual environment, then run the following commands to
install the development dependencies and run the test suite:</p>
<pre data-type="programlisting">$ <strong>uv pip install -r requirements/dev.txt</strong>
$ <strong>py -m pytest</strong>
</pre>

<p>Requirements files aren’t part of the project metadata. You share them with
other developers using the version control system, but they’re invisible to your
users. For development dependencies, this is exactly what you want. What’s more,
requirements files don’t implicitly include your project in the dependencies.
That shaves off time from all tasks that don’t need the project installed.</p>

<p>Requirements files also have downsides. They aren’t a packaging standard, and
unlikely to become one—​each line of a requirements file is essentially an
argument to <code>pip install</code>. “Whatever pip does” may remain the unwritten law for
many edge cases in Python packaging, but community standards replace it more and
more. Another downside is the clutter these files cause in your project when
compared to a table in <em>pyproject.toml</em>.</p>

<p>As mentioned above, Python project managers let you declare dependency groups in
<em>pyproject.toml</em>, outside of the project metadata—​Rye, Hatch, PDM, and Poetry
all offer this feature. See <a data-type="xref" href="ch05.html#chapter_poetry">Chapter 5</a> for a description of Poetry’s
dependency groups.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Locking Dependencies"><div class="sect1" id="section_dependencies_locking">
<h1>Locking Dependencies</h1>

<p>You’ve installed your dependencies in a local environment or in continuous
integration (CI), and you’ve run your test suite and any other checks you have
in place. Everything looks good, and you’re ready to deploy your code. But how
do you install the same packages in production that you used when you ran your
checks?</p>

<p>Using different packages in development and production has consequences.
Production may end up with a package that’s incompatible with your code, has a
bug or security vulnerability, or—​in the worst case—​has been hijacked by an
attacker. If your service gets a lot of exposure, this scenario is worrying—​and
it can involve any package in your dependency tree, not just those that you
import directly.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p><em>Supply chain attacks</em> infiltrate a system by targeting its third-party
dependencies. For example, in 2022, a threat actor dubbed “JuiceLedger” uploaded
malicious packages to legitimate PyPI projects after compromising them with a
phishing campaign.<sup><a data-type="noteref" id="id279-marker" href="ch04.html#id279">6</a></sup></p>
</div>

<p>There are many reasons why environments end up with different packages given the
same dependency specifications. Most of them fall into two categories: upstream
changes and environment mismatch. First, you can get different packages if the
set of available packages changes upstream:</p>

<ul>
<li>
<p>A new release comes in before you deploy.</p>
</li>
<li>
<p>A new artifact is uploaded for an existing release. For example, maintainers
sometimes upload additional wheels when a new Python release comes out.</p>
</li>
<li>
<p>A maintainer deletes or yanks a release or artifact. <em>Yanking</em> is a soft
delete that hides the file from dependency resolution unless you request it
specifically.</p>
</li>
</ul>

<p>Second, you can get different packages if your development environment doesn’t
match the production environment:</p>

<ul>
<li>
<p>Environment markers evaluate differently on the target interpreter (see
<a data-type="xref" href="#section_dependencies_environment_markers">“Environment Markers”</a>). For example, the production
environment might use an old Python version that requires a backport like
<code>importlib-metadata</code>.</p>
</li>
<li>
<p>Wheel compatibility tags can cause the installer to select a different wheel
for the same package (see <a data-type="xref" href="ch03.html#sidebar_packages_wheel_compatibility_tags">“Wheel Compatibility Tags”</a>). For
example, this can happen if you develop on a Mac with Apple Silicon while
production uses Linux on an x86-64 architecture.</p>
</li>
<li>
<p>If the release doesn’t include a wheel for the target environment, the
installer builds it from the sdist on the fly. Wheels for extension modules
often lag behind when a new Python version sees the light.</p>
</li>
<li>
<p>If the environments don’t use the same installer (or different versions of the
same installer), each installer may resolve the dependencies differently. For
example, uv uses the PubGrub algorithm for dependency
resolution,<sup><a data-type="noteref" id="id280-marker" href="ch04.html#id280">7</a></sup> while pip uses a backtracking resolver for Python
packages, <code>resolvelib</code>.</p>
</li>
<li>
<p>Tooling configuration or state can also cause different results—​for example,
you might install from a different package index or from a local cache.</p>
</li>
</ul>

<p>You need a way to define the exact set of packages required by your application,
and you want its environment to be an exact image of this package inventory.
This process is known as <em>locking</em>, or <em>pinning</em>, the project dependencies,
which are listed in a <em>lock file</em>.</p>

<p>So far, I’ve talked about locking dependencies for reliable and reproducible
deployments. Locking is also beneficial during development, for both
applications and libraries. By sharing a lock file with your team and with
contributors, you put everybody on the same page: every developer uses the same
dependencies when running the test suite, building the documentation, or
performing other tasks. Using the lock file for mandatory checks avoids
surprises where checks fail in CI after passing locally. To reap these benefits,
lock files must include development dependencies, too.</p>

<p>As of this writing, Python lacks a packaging standard for lock files—​although
the topic is under active consideration.<sup><a data-type="noteref" id="id281-marker" href="ch04.html#id281">8</a></sup> Meanwhile, many
Python project managers, such as Poetry, PDM, and pipenv, have implemented their
own lock file formats; others, like Rye, use requirements files for locking
dependencies.</p>

<p>In this section, I’ll introduce two methods for locking dependencies using
requirements files: <em>freezing</em> and <em>compiling requirements</em>. In
<a data-type="xref" href="ch05.html#chapter_poetry">Chapter 5</a>, I’ll describe Poetry’s lock files.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_dependencies_pinning_in_project_metadata">
<h1>“Locking” Dependencies in the Project Metadata</h1>
<p>If you want to lock the dependencies for an application, why not narrow down the
version constraints in <em>pyproject.toml</em>? For example, couldn’t you lock the
dependencies on <code>httpx</code> and <code>rich</code> as shown below?</p>

<pre data-type="programlisting" data-code-language="toml"><code class="k">[project]</code><code class="w"/>
<code class="n">dependencies</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">[</code><code class="s2">"httpx[http2]==0.27.0"</code><code class="p">,</code><code class="w"> </code><code class="s2">"rich==13.7.1"</code><code class="p">]</code><code class="w"/></pre>

<p>There are two main problems with this approach.</p>

<p>First, you’ve only locked direct dependencies. For example,
<code>random-wikipedia-article</code> uses <code>h2</code> to communicate via HTTP/2, but that package
is missing from the dependency specifications.</p>

<p>Second, and more importantly, you’ve lost valuable information: the compatible
version ranges for your top-level dependencies. Version constraints determine
the search space for a dependency resolver. The resolver can no longer help you
upgrade packages or resolve dependencies for a new environment—​like when you
bump the Python version in production.</p>

<p>You need a way to record dependencies outside of the <code>dependencies</code> table.</p>
</div></aside>








<section data-type="sect2" data-pdf-bookmark="Freezing Requirements with pip and uv"><div class="sect2" id="id133">
<h2>Freezing Requirements with pip and uv</h2>

<p>Requirements files are a popular format for locking dependencies. They let you
keep the dependency information separate from the project metadata. Pip and uv
can generate these files from an existing environment:</p>
<pre data-type="programlisting">$ <strong>uv pip install .</strong>
$ <strong>uv pip freeze</strong>
anyio==4.3.0
certifi==2024.2.2
h11==0.14.0
h2==4.1.0
hpack==4.0.0
httpcore==1.0.4
httpx==0.27.0
hyperframe==6.0.1
idna==3.6
markdown-it-py==3.0.0
mdurl==0.1.2
pygments==2.17.2
random-wikipedia-article @ file:///Users/user/random-wikipedia-article
rich==13.7.1
sniffio==1.3.1
</pre>

<p>Taking an inventory of the packages installed in an environment is known as
<em>freezing</em>. Store the list in <em>requirements.txt</em> and commit the file to source
control—​with one change: replace the file URL with a dot for the current
directory. This lets you use the requirements file anywhere, as long as you’re
inside the project directory.</p>

<p>When deploying your project to production, you can install the project and its
dependencies like this:</p>
<pre data-type="programlisting">$ <strong>uv pip install -r requirements.txt</strong></pre>

<p>Assuming your development environment uses a recent interpreter, the
requirements file won’t list <code>importlib-metadata</code>—that library is only required
before Python 3.8. If your production environment runs an ancient Python
version, your deployment will break. There’s an important lesson here: lock your
dependencies in an environment that matches the production environment.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Lock your dependencies on the same Python version, Python implementation,
operating system, and processor architecture as those used in production. If you
deploy to multiple environments, generate a requirements file for each one.</p>
</div>

<p>Freezing requirements comes with a few limitations. First, you need to install
your dependencies every time you refresh the requirements file. Second, it’s
easy to pollute the requirements file inadvertently if you temporarily install a
package and forget to create the environment from scratch
afterward.<sup><a data-type="noteref" id="id282-marker" href="ch04.html#id282">9</a></sup> Third, freezing
doesn’t allow you to record package hashes—​it merely takes an inventory of an
environment, and environments don’t record hashes for the packages you install
into them. (I’ll cover package hashes in the next section.)</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Compiling Requirements with pip-tools and uv"><div class="sect2" id="section_dependencies_piptools">
<h2>Compiling Requirements with pip-tools and uv</h2>

<p>The pip-tools project lets you lock dependencies without these limitations. You
can compile requirements directly from <em>pyproject.toml</em>, without installing the
packages. Under the hood, pip-tools leverages pip and its dependency resolver.</p>

<p>Pip-tools comes with two commands: <code>pip-compile</code>, to create a requirements file
from dependency specifications, and <code>pip-sync</code>, to apply the requirements file
to an existing environment. The uv tool provides drop-in replacements for both
commands: <code>uv pip compile</code> and <code>uv pip sync</code>.</p>

<p>Run <code>pip-compile</code> in an environment that matches the target environment for your
project. If you use pipx, specify the target Python version:</p>
<pre data-type="programlisting">$ <strong>pipx run --python=3.12 --spec=pip-tools pip-compile</strong></pre>

<p>By default, <code>pip-compile</code> reads from <em>pyproject.toml</em> and writes to
<em>requirements.txt</em>. You can use the <code>--output-file</code> option to specify a
different destination. The tool also prints the requirements to standard error,
unless you specify <code>--quiet</code> to switch off terminal output.</p>

<p>Uv requires you to be explicit about the input and output files:</p>
<pre data-type="programlisting">$ <strong>uv pip compile --python-version=3.12 pyproject.toml -o requirements.txt</strong></pre>

<p>Pip-tools and uv annotate the file to indicate the dependent package for each
dependency, as well as the command used to generate the file. There’s one more
difference to the output of <code>pip freeze</code>: the compiled requirements don’t
include your own project. You’ll have to install it separately after applying
the requirements file.</p>

<p>Requirements files allow you to specify package hashes for each dependency.
These hashes add another layer of security to your deployments: they enable you
to install only vetted packaging artifacts in production. The option
<code>--generate-hashes</code> includes SHA256 hashes for each package listed in the
requirements file. For example, here are hashes over the sdist and wheel files
for an <code>httpx</code> release:</p>

<pre data-type="programlisting" data-code-language="text">httpx==0.27.0 \
--hash=sha256:71d5465162c13681bff01ad59b2cc68dd838ea1f10e51574bac27103f00c91a5 \
--hash=sha256:a0cb88a46f32dc874e04ee956e4c2764aba2aa228f650b06788ba6bda2962ab5</pre>

<p>Package hashes make installations more deterministic and reproducible. They’re
also an important tool in organizations that require screening every artifact
that goes into production. Validating the integrity of packages prevents
<em>on-path attacks</em> where a threat actor (“man in the middle”) intercepts a
package download to supply a compromised artifact.</p>

<p>Hashes also have the side effect that pip refuses to install packages without
them: either all packages have hashes, or none do. As a consequence, hashes
protect you from installing files that aren’t listed in the requirements file.</p>

<p>Install the requirements file in the target environment using pip or uv,
followed by the project itself. You can harden the installation using a couple
of options: the option <code>--no-deps</code> ensures that you only install packages listed
in the requirements file, and the option <code>--no-cache</code> prevents the installer
from reusing downloaded or locally built artifacts.</p>
<pre data-type="programlisting">$ <strong>uv pip install -r requirements.txt</strong>
$ <strong>uv pip install --no-deps --no-cache .</strong>
</pre>

<p>Update your dependencies at regular intervals. Once per week may be acceptable
for a mature application running in production. Daily may be more appropriate
for a project under active development—​or even as soon as the releases come in.
Tools like Dependabot and Renovate help with this chore: They open pull requests
in your repositories with automated dependency upgrades.</p>

<p>If you don’t upgrade dependencies regularly, you may be forced to apply a “big
bang” upgrade under time pressure. A single security vulnerability can force you
to port your project to major releases of multiple packages, as well as Python
itself.</p>

<p>You can upgrade your dependencies all at once, or one dependency at a time. Use
the <code>--upgrade</code> option to upgrade all dependencies to their latest version, or
pass a specific package with the <code>--upgrade-package</code> option (<code>-P</code>).</p>

<p>For example, here’s how you’d upgrade Rich to the latest version:</p>
<pre data-type="programlisting">$ <strong>uv pip compile -p 3.12 pyproject.toml -o requirements.txt -P rich</strong>
</pre>

<p>So far, you’ve created the target environment from scratch. You can also use
<code>pip-sync</code> to synchronize the target environment with the updated requirements
file. Don’t install pip-tools in the target environment for this: its
dependencies may conflict with those of your project. Instead, use pipx, as you
did with <code>pip-compile</code>. Point <code>pip-sync</code> to the target interpreter using its
<code>--python-executable</code> option:</p>
<pre data-type="programlisting">$ <strong>pipx run --spec=pip-tools pip-sync --python-executable=.venv/bin/python</strong></pre>

<p>The command removes the project itself since it’s not listed in the requirements
file. Re-install it after synchronizing:</p>
<pre data-type="programlisting">$ <strong>.venv/bin/python -m pip install --no-deps --no-cache .</strong></pre>

<p>Uv uses the environment in <em>.venv</em> by default, so you can simplify these
commands:</p>
<pre data-type="programlisting">$ <strong>uv pip sync requirements.txt</strong>
$ <strong>uv pip install --no-deps --no-cache .</strong>
</pre>

<p>In <a data-type="xref" href="#section_dependencies_development">“Development Dependencies”</a>, you saw two ways to declare development
dependencies: extras and requirements files. Pip-tools and uv support both as
inputs. If you track development dependencies in a <code>dev</code> extra, generate the
<em>dev-requirements.txt</em> file like this:</p>
<pre data-type="programlisting">$ <strong>uv pip compile --extra=dev pyproject.toml -o dev-requirements.txt</strong>
</pre>

<p>If you have finer-grained extras, the process is the same. You may want to store
the requirements files in a <em>requirements</em> directory to avoid clutter.</p>

<p>If you specify your development dependencies in requirements files instead of
extras, compile each of these files in turn. By convention, input requirements
use the <em>.in</em> extension, while output requirements use the <em>.txt</em> extension
(<a data-type="xref" href="#example_dependencies_dev_requirements_in">Example 4-10</a>).</p>
<div id="example_dependencies_dev_requirements_in" data-type="example">
<h5><span class="label">Example 4-10. </span>Input requirements for development dependencies</h5>

<pre data-type="programlisting" data-code-language="python"><code class="c1"># requirements/tests.in</code>
<code class="n">pytest</code><code class="o">&gt;=</code><code class="mf">8.1.1</code>
<code class="n">pytest</code><code class="o">-</code><code class="n">sugar</code><code class="o">&gt;=</code><code class="mf">1.0.0</code>

<code class="c1"># requirements/docs.in</code>
<code class="n">sphinx</code><code class="o">&gt;=</code><code class="mf">7.2.6</code>

<code class="c1"># requirements/dev.in</code>
<code class="o">-</code><code class="n">r</code> <code class="n">tests</code><code class="o">.</code><code class="ow">in</code>
<code class="o">-</code><code class="n">r</code> <code class="n">docs</code><code class="o">.</code><code class="ow">in</code></pre></div>

<p>Unlike <a data-type="xref" href="#example_dependencies_dev_requirements">Example 4-9</a>, the input requirements don’t
list the project itself. If they did, the output requirements would include the
path to the project—​and every developer would end up with a different path.
Instead, pass <em>pyproject.toml</em> together with the input requirements to lock the
entire set of dependencies together:</p>
<pre data-type="programlisting">$ <strong>uv pip compile requirements/tests.in pyproject.toml -o requirements/tests.txt</strong>
$ <strong>uv pip compile requirements/docs.in -o requirements/docs.txt</strong>
$ <strong>uv pip compile requirements/dev.in pyproject.toml -o requirements/dev.txt</strong>
</pre>

<p>Remember to install the project after you’ve installed the output requirements.</p>

<p>Why bother compiling <em>dev.txt</em> at all? Can’t it just include <em>docs.txt</em> and
<em>tests.txt</em>? If you install separately locked requirements on top of each other,
they may well end up conflicting. Let the dependency resolver see the full
picture. If you pass all the input requirements, it can give you a consistent
dependency tree in return.</p>

<p><a data-type="xref" href="#table_dependencies_pipcompile_options">Table 4-3</a> summarizes the command-line options for
<code>pip-compile</code> you’ve seen in this chapter:</p>
<table id="table_dependencies_pipcompile_options">
<caption><span class="label">Table 4-3. </span>Selected command-line options for <code>pip-compile</code></caption>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>--generate-hashes</code></p></td>
<td><p>Include SHA256 hashes for every packaging artifact</p></td>
</tr>
<tr>
<td><p><code>--output-file</code></p></td>
<td><p>Specify the destination file</p></td>
</tr>
<tr>
<td><p><code>--quiet</code></p></td>
<td><p>Do not print the requirements to standard error</p></td>
</tr>
<tr>
<td><p><code>--upgrade</code></p></td>
<td><p>Upgrade all dependencies to their latest version</p></td>
</tr>
<tr>
<td><p><code>--upgrade-package=<em>&lt;package&gt;</em></code></p></td>
<td><p>Upgrade a specific package to its latest version</p></td>
</tr>
<tr>
<td><p><code>--extra=<em>&lt;extra&gt;</em></code></p></td>
<td><p>Include dependencies from the given extra in <em>pyproject.toml</em></p></td>
</tr>
</tbody>
</table>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="id135">
<h1>Summary</h1>

<p>In this chapter, you’ve learned how to declare project dependencies using
<em>pyproject.toml</em> and how to declare development dependencies using either extras
or requirements files. You’ve also learned how to lock dependencies for reliable
deployments and reproducible checks using pip-tools. In the next chapter, you’ll
see how the project manager Poetry helps with dependency management using
dependency groups and lock files.</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="id273"><sup><a href="ch04.html#id273-marker">1</a></sup> In a wider sense, the dependencies of a project consist of all software packages that users require to run its code—​including the interpreter, the standard library, third-party packages, and system libraries. Conda and distro-level package managers like APT, DNF, and Homebrew support this generalized notion of dependencies.</p><p data-type="footnote" id="id274"><sup><a href="ch04.html#id274-marker">2</a></sup> Henry Schreiner: <a href="https://iscinumpy.dev/post/bound-version-constraints/">“Should You Use Upper Bound Version Constraints?,”</a> December 9, 2021.</p><p data-type="footnote" id="id275"><sup><a href="ch04.html#id275-marker">3</a></sup> For simplicity, the code doesn’t handle multiple authors—​which one ends up in the header is undefined.</p><p data-type="footnote" id="id276"><sup><a href="ch04.html#id276-marker">4</a></sup> Robert Collins: <a href="https://peps.python.org/pep-0508/">“PEP 508 – Dependency specification for Python Software Packages,”</a> November 11, 2015.</p><p data-type="footnote" id="id278"><sup><a href="ch04.html#id278-marker">5</a></sup> Stephen Rosen: <a href="https://peps.python.org/pep-0735/">“PEP 735 – Dependency Groups in pyproject.toml,”</a> November 20, 2023.</p><p data-type="footnote" id="id279"><sup><a href="ch04.html#id279-marker">6</a></sup> Dan Goodin: <a href="https://arstechnica.com/information-technology/2022/09/actors-behind-pypi-supply-chain-attack-have-been-active-since-late-2021/">“Actors behind PyPI supply chain attack have been active since late 2021,”</a> September 2, 2022.</p><p data-type="footnote" id="id280"><sup><a href="ch04.html#id280-marker">7</a></sup> Natalie Weizenbaum: <a href="https://nex3.medium.com/pubgrub-2fb6470504f">“PubGrub: Next-Generation Version Solving,”</a> April 2, 2018</p><p data-type="footnote" id="id281"><sup><a href="ch04.html#id281-marker">8</a></sup> Brett Cannon: <a href="https://discuss.python.org/t/lock-files-again-but-this-time-w-sdists/46593">“Lock files, again (but this time w/ sdists!),”</a> February 22, 2024.</p><p data-type="footnote" id="id282"><sup><a href="ch04.html#id282-marker">9</a></sup> Uninstalling the package isn’t enough: the installation can have side effects on your dependency tree. For example, it may upgrade or downgrade other packages or pull in additional dependencies.</p></div></div></section></div>
</div>
</body></html>