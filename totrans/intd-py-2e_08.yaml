- en: Chapter 7\. Tuples and Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The human animal differs from the lesser primates in his passion for lists.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: H. Allen Smith
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In the previous chapters, we started with some of Python’s basic data types:
    booleans, integers, floats, and strings. If you think of those as atoms, the data
    structures in this chapter are like molecules. That is, we combine those basic
    types in more complex ways. You will use these every day. Much of programming
    consists of chopping and gluing data into specific forms, and these are your hacksaws
    and glue guns.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most computer languages can represent a sequence of items indexed by their
    integer position: first, second, and so on down to the last. You’ve already seen
    Python *strings*, which are sequences of characters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python has two other sequence structures: *tuples* and *lists*. These contain
    zero or more elements. Unlike strings, the elements can be of different types.
    In fact, each element can be *any* Python object. This lets you create structures
    as deep and complex as you like.'
  prefs: []
  type: TYPE_NORMAL
- en: Why does Python contain both lists and tuples? Tuples are *immutable*; when
    you assign elements (only once) to a tuple, they’re baked in the cake and can’t
    be changed. Lists are *mutable*, meaning you can insert and delete elements with
    great enthusiasm. I’ll show many examples of each, with an emphasis on lists.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s get one thing out of the way first. You may hear two different pronunciations
    for *tuple*. Which is right? If you guess wrong, do you risk being considered
    a Python poseur? No worries. Guido van Rossum, the creator of Python, said [via
    Twitter](http://bit.ly/tupletweet):'
  prefs: []
  type: TYPE_NORMAL
- en: I pronounce tuple too-pull on Mon/Wed/Fri and tub-pull on Tue/Thu/Sat. On Sunday
    I don’t talk about them. :)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Create with Commas and ()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The syntax to make tuples is a little inconsistent, as the following examples
    demonstrate. Let’s begin by making an empty tuple using `()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To make a tuple with one or more elements, follow each element with a comma.
    This works for one-element tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You could enclose them in parentheses and still get the same tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a little gotcha: if you have a single thing in parentheses and omit
    that comma, you would not get a tuple, but just the thing (in this example, the
    string `''Groucho''`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have more than one element, follow all but the last one with a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Python includes parentheses when echoing a tuple. You often don’t need them
    when you define a tuple, but using parentheses is a little safer, and it helps
    to make the tuple more visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You do need the parentheses for cases in which commas might also have another
    use. In this example, you can create and assign a single-element tuple with just
    a trailing comma, but you can’t pass it as an argument to a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Tuples let you assign multiple variables at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is sometimes called *tuple unpacking*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use tuples to exchange values in one statement without using a temporary
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Create with tuple()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `tuple()` conversion function makes tuples from other things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Combine Tuples by Using `+`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is similar to combining strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Duplicate Items with *
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is like repeated use of `+`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Compare Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This works much like list comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Iterate with for and in
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tuple iteration is like iteration of other types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Modify a Tuple
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can’t! Like strings, tuples are immutable, so you can’t change an existing
    one. As you saw just before, you can *concatenate* (combine) tuples to make a
    new one, as you can with strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that you can appear to modify a tuple like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'But it isn’t the same `t1`. Python made a new tuple from the original tuples
    pointed to by `t1` and `t2`, and assigned the name `t1` to this new tuple. You
    can see with `id()` when a variable name is pointing to a new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lists are good for keeping track of things by their order, especially when the
    order and contents might change. Unlike strings, lists are mutable. You can change
    a list in place, add new elements, and delete or replace existing elements. The
    same value can occur more than once in a list.
  prefs: []
  type: TYPE_NORMAL
- en: Create with []
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A list is made from zero or more elements, separated by commas and surrounded
    by square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `first_names` list shows that values do not need to be unique.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you want to keep track of only unique values and don’t care about order,
    a Python *set* might be a better choice than a list. In the previous example,
    `big_birds` could have been a set. We explore sets in [Chapter 8](ch08.html#ch_dicts).
  prefs: []
  type: TYPE_NORMAL
- en: Create or Convert with list()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also make an empty list with the `list()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Python’s `list()` function also converts other *iterable* data types (such
    as tuples, strings, sets, and dictionaries) to lists. The following example converts
    a string to a list of one-character strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This example converts a tuple to a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Create from a String with split()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As I mentioned earlier in [“Split with split()”](ch05.html#string_split), use
    `split()` to chop a string into a list by some separator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'What if you have more than one separator string in a row in your original string?
    Well, you get an empty string as a list item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you had used the two-character separator string `//`, instead, you would
    get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Get an Item by [ *offset* ]
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with strings, you can extract a single value from a list by specifying its
    offset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, as with strings, negative indexes count backward from the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The offset has to be a valid one for this list—a position you have assigned
    a value previously. If you specify an offset before the beginning or after the
    end, you’ll get an exception (error). Here’s what happens if we try to get the
    sixth Marx brother (offset `5` counting from `0`), or the fifth before the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Get Items with a Slice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can extract a subsequence of a list by using a *slice*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: A slice of a list is also a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with strings, slices can step by values other than one. The next example
    starts at the beginning and goes right by 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we start at the end and go left by 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, the trick to reverse a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'None of these slices changed the `marxes` list itself, because we didn’t assign
    them to `marxes`. To reverse a list in place, use `*list*.reverse()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `reverse()` function changes the list but doesn’t return its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you saw with strings, a slice can specify an invalid index, but will not
    cause an exception. It will “snap” to the closest valid index or return nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Add an Item to the End with append()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The traditional way of adding items to a list is to `append()` them one by
    one to the end. In the previous examples, we forgot Zeppo, but that’s alright
    because the list is mutable, so we can add him now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Add an Item by Offset with insert()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `append()` function adds items only to the end of the list. When you want
    to add an item before any offset in the list, use `insert()`. Offset `0` inserts
    at the beginning. An offset beyond the end of the list inserts at the end, like
    `append()`, so you don’t need to worry about Python throwing an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Duplicate All Items with *
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 5](ch05.html#ch_strings), you saw that you can duplicate a string’s
    characters with `*`. The same works for a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Combine Lists by Using extend() or `+`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can merge one list into another by using `extend()`. Suppose that a well-meaning
    person gave us a new list of Marxes called `others`, and we’d like to merge them
    into the main `marxes` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use `+` or `+=`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If we had used `append()`, `others` would have been added as a *single* list
    item rather than merging its items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This again demonstrates that a list can contain elements of different types.
    In this case, four strings, and a list of two strings.
  prefs: []
  type: TYPE_NORMAL
- en: Change an Item by [ *offset* ]
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as you can get the value of a list item by its offset, you can change
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Again, the list offset needs to be a valid one for this list.
  prefs: []
  type: TYPE_NORMAL
- en: You can’t change a character in a string in this way, because strings are immutable.
    Lists are mutable. You can change how many items a list contains as well as the
    items themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Change Items with a Slice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous section showed how to get a sublist with a slice. You can also
    assign values to a sublist with a slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The righthand thing that you’re assigning to the list doesn’t even need to
    have the same number of elements as the slice on the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, the righthand thing doesn’t even need to be a list. Any Python *iterable*
    will do, separating its items and assigning them to list elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Delete an Item by Offset with del
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our fact checkers have just informed us that Gummo was indeed one of the Marx
    Brothers, but Karl wasn’t, and that whoever inserted him earlier was very rude.
    Let’s fix that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'When you delete an item by its position in the list, the items that follow
    it move back to take the deleted item’s space, and the list’s length decreases
    by one. If we deleted `''Chico''` from the last version of the `marxes` list,
    we get this as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`del` is a Python *statement*, not a list method—you don’t say `marxes[-1].del()`.
    It’s sort of the reverse of assignment (`=`): it detaches a name from a Python
    object and can free up the object’s memory if that name were the last reference
    to it.'
  prefs: []
  type: TYPE_NORMAL
- en: Delete an Item by Value with remove()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’re not sure or don’t care where the item is in the list, use `remove()`
    to delete it by value. Goodbye, Groucho:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If you had duplicate list items with the same value, `remove()` deletes only
    the first one it finds.
  prefs: []
  type: TYPE_NORMAL
- en: Get an Item by Offset and Delete It with pop()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can get an item from a list and delete it from the list at the same time
    by using `pop()`. If you call `pop()` with an offset, it will return the item
    at that offset; with no argument, it uses `-1`. So, `pop(0)` returns the head
    (start) of the list, and `pop()` or `pop(-1)` returns the tail (end), as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It’s computing jargon time! Don’t worry, these won’t be on the final exam. If
    you use `append()` to add new items to the end and `pop()` to remove them from
    the same end, you’ve implemented a data structure known as a *LIFO* (last in,
    first out) queue. This is more commonly known as a *stack*. `pop(0)` would create
    a *FIFO* (first in, first out) queue. These are useful when you want to collect
    data as they arrive and work with either the oldest first (FIFO) or the newest
    first (LIFO).
  prefs: []
  type: TYPE_NORMAL
- en: Delete All Items with clear()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python 3.3 introduced a method to clear a list of all its elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Find an Item’s Offset by Value with index()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to know the offset of an item in a list by its value, use `index()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If the value is in the list more than once, only the offset of the first one
    is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Test for a Value with in
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Pythonic way to check for the existence of a value in a list is using `in`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The same value may be in more than one position in the list. As long as it’s
    in there at least once, `in` will return `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you check for the existence of some value in a list often and don’t care
    about the order of items, a Python *set* is a more appropriate way to store and
    look up unique values. We talk about sets in [Chapter 8](ch08.html#ch_dicts).
  prefs: []
  type: TYPE_NORMAL
- en: Count Occurrences of a Value with count()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To count how many times a particular value occurs in a list, use `count()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Convert a List to a String with join()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Combine by Using join()”](ch05.html#join) discussed `join()` in greater detail,
    but here’s another example of what you can do with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You might be thinking that this seems a little backward. `join()` is a string
    method, not a list method. You can’t say `marxes.join('', '')`, even though it
    seems more intuitive. The argument to `join()` is a string or any iterable sequence
    of strings (including a list), and its output is a string. If `join()` were just
    a list method, you couldn’t use it with other iterable objects such as tuples
    or strings. If you did want it to work with any iterable type, you’d need special
    code for each type to handle the actual joining. It might help to remember—`join()`
    *is the opposite of* `split()`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Reorder Items with sort() or sorted()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’ll often need to sort the items in a list by their values rather than their
    offsets. Python provides two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: The list method `sort()` sorts the list itself, *in place*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The general function `sorted()` returns a sorted *copy* of the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the items in the list are numeric, they’re sorted by default in ascending
    numeric order. If they’re strings, they’re sorted in alphabetical order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '`sorted_marxes` is a new list, and creating it did not change the original
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'But calling the list function `sort()` on the `marxes` list does change `marxes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'If the elements of your list are all of the same type (such as strings in `marxes`),
    `sort()` will work correctly. You can sometimes even mix types—for example, integers
    and floats—because they are automatically converted to one another by Python in
    expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The default sort order is ascending, but you can add the argument `reverse=True`
    to set it to descending:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Get Length with len()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`len()` returns the number of items in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Assign with =
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you assign one list to more than one variable, changing the list in one
    place also changes it in the other, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'So what’s in `b` now? Is it still `[1, 2, 3]`, or `[''surprise'', 2, 3]`? Let’s
    see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember the box (object) and string with note (variable name) analogy in [Chapter 2](ch02.html#ch_names)?
    `b` just refers to the same list object as `a` (both name strings lead to the
    same object box). Whether we change the list contents by using the name `a` or
    `b`, it’s reflected in both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Copy with copy(), list(), or a Slice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can *copy* the values of a list to an independent, fresh list by using
    any of these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The list `copy()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `list()` conversion function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list slice `[:]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our original list will be `a` again. We make `b` with the list `copy()` function,
    `c` with the `list()` conversion function, and `d` with a list slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, `b`, `c`, and `d` are *copies* of `a`: they are new objects with their
    own values and no connection to the original list object `[1, 2, 3]` to which
    `a` refers. Changing `a` does *not* affect the copies `b`, `c`, and `d`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Copy Everything with deepcopy()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `copy()` function works well if the list values are all immutable. As you’ve
    seen before, mutable values (like lists, tuples, or dicts) are references. A change
    in the original or the copy would be reflected in both.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use the previous example but make the last element in list `a` the list
    `[8, 9]` instead of the integer `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good. Now change an element in that sublist in `a`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The value of `a[2]` is now a list, and its elements can be changed. All the
    list-copying methods we used were *shallow* (not a value judgment, just a depth
    one).
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, we need to use the `deepcopy()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '`deepcopy()` can handle deeply nested lists, dictionaries, and other objects.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll read more about `import` in [Chapter 9](ch09.html#ch_functions).
  prefs: []
  type: TYPE_NORMAL
- en: Compare Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can directly compare lists with the comparison operators like `==`, `<`,
    and so on. The operators walk through both lists, comparing elements at the same
    offsets. If list `a` is shorter than list `b`, and all of its elements are equal,
    `a` is less than `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Iterate with for and in
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 6](ch06.html#ch_for), you saw how to iterate over a string with
    `for`, but it’s much more common to iterate over lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, `break` ends the `for` loop and `continue` steps to the next iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'You can still use the optional `else` if the `for` completed without a `break`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'If the initial `for` never ran, control goes to the `else` also:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Because the `cheeses` list was empty in this example, `for cheese in cheeses`
    never completed a single loop and its `break` statement was never executed.
  prefs: []
  type: TYPE_NORMAL
- en: Iterate Multiple Sequences with zip()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There’s one more nice iteration trick: iterating over multiple sequences in
    parallel by using the `zip()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '`zip()` stops when the shortest sequence is done. One of the lists (`desserts`)
    was longer than the others, so no one gets any pudding unless we extend the other
    lists.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8](ch08.html#ch_dicts) shows you how the `dict()` function can create
    dictionaries from two-item sequences like tuples, lists, or strings. You can use
    `zip()` to walk through multiple sequences and make tuples from items at the same
    offsets. Let’s make two tuples of corresponding English and French words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, use `zip()` to pair these tuples. The value returned by `zip()` is itself
    not a tuple or list, but an iterable value that can be turned into one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Feed the result of `zip()` directly to `dict()` and voilà: a tiny English-French
    dictionary!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Create a List with a Comprehension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You saw how to create a list with square brackets or the `list()` function.
    Here, we look at how to create a list with a *list comprehension*, which incorporates
    the `for`/`in` iteration that you just saw.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could build a list of integers from `1` to `5`, one item at a time, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you could also use an iterator and the `range()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you could just turn the output of `range()` into a list directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'All of these approaches are valid Python code and will produce the same result.
    However, a more Pythonic (and often faster) way to build a list is by using a
    *list comprehension*. The simplest form of list comprehension looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how a list comprehension would build the integer list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first line, you need the first `number` variable to produce values for
    the list: that is, to put a result of the loop into `number_list`. The second
    `number` is part of the `for` loop. To show that the first `number` is an expression,
    try this variant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The list comprehension moves the loop inside the square brackets. This comprehension
    example really wasn’t simpler than the previous example, but there’s more that
    you can do. A list comprehension can include a conditional expression, looking
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s make a new comprehension that builds a list of only the odd numbers between
    `1` and `5` (remember that `number % 2` is `True` for odd numbers and `False`
    for even numbers):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the comprehension is a little more compact than its traditional counterpart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, just as there can be nested loops, there can be more than one set
    of `for ...` clauses in the corresponding comprehension. To show this, let’s first
    try a plain old nested loop and print the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s use a comprehension and assign it to the variable `cells`, making
    it a list of `(row, col)` tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'By the way, you can also use *tuple unpacking* to get the `row` and `col` values
    from each tuple as you iterate over the `cells` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The `for row ...` and `for col ...` fragments in the list comprehension could
    also have had their own `if` tests.
  prefs: []
  type: TYPE_NORMAL
- en: Lists of Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lists can contain elements of different types, including other lists, as illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: So what does `all_birds`, a list of lists, look like?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the first item in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The first item is a list: in fact, it’s `small_birds`, the first item we specified
    when creating `all_birds`. You should be able to guess what the second item is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s the second item we specified, `extinct_birds`. If we want the first item
    of `extinct_birds`, we can extract it from `all_birds` by specifying two indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: The `[1]` refers to the list that’s the second item in `all_birds`, and the
    `[0]` refers to the first item in that inner list.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples Versus Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can often use tuples in place of lists, but they have many fewer functions—there
    is no `append()`, `insert()`, and so on—because they can’t be modified after creation.
    Why not just use lists instead of tuples everywhere?
  prefs: []
  type: TYPE_NORMAL
- en: Tuples use less space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can’t clobber tuple items by mistake.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use tuples as dictionary keys (see [Chapter 8](ch08.html#ch_dicts)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Named tuples* (see [“Named Tuples”](ch10.html#named_tuples)) can be a simple
    alternative to objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I won’t go into much more detail about tuples here. In everyday programming,
    you’ll use lists and dictionaries more.
  prefs: []
  type: TYPE_NORMAL
- en: There Are No Tuple Comprehensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mutable types (lists, dictionaries, and sets) have comprehensions. Immutable
    types like strings and tuples need to be created with the other methods listed
    in their sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have thought that changing the square brackets of a list comprehension
    to parentheses would create a tuple comprehension. And it would appear to work
    because there’s no exception if you type this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'The thing between the parentheses is something else entirely: a *generator
    comprehension*, and it returns a *generator object*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: I’ll get into generators in more detail in [“Generators”](ch09.html#generators).
    A generator is one way to provide data to an iterator.
  prefs: []
  type: TYPE_NORMAL
- en: Coming Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'They’re so swell, they get their own chapter: *dictionaries* and *sets*.'
  prefs: []
  type: TYPE_NORMAL
- en: Things to Do
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use lists and tuples with numbers ([Chapter 3](ch03.html#ch_numbers)) and strings
    ([Chapter 5](ch05.html#ch_strings)) to represent elements in the real world with
    great variety.
  prefs: []
  type: TYPE_NORMAL
- en: 7.1 Create a list called `years_list`, starting with the year of your birth,
    and each year thereafter until the year of your fifth birthday. For example, if
    you were born in 1980, the list would be `years_list = [1980, 1981, 1982, 1983,
    1984, 1985]`. If you’re less than five years old and reading this book, I don’t
    know what to tell you.
  prefs: []
  type: TYPE_NORMAL
- en: 7.2 In which year in `years_list` was your third birthday? Remember, you were
    0 years of age for your first year.
  prefs: []
  type: TYPE_NORMAL
- en: 7.3 In which year in `years_list` were you the oldest?
  prefs: []
  type: TYPE_NORMAL
- en: '7.4 Make a list called `things` with these three strings as elements: `"mozzarella"`,
    `"cinderella"`, `"salmonella"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.5 Capitalize the element in `things` that refers to a person and then print
    the list. Did it change the element in the list?
  prefs: []
  type: TYPE_NORMAL
- en: 7.6 Make the cheesy element of `things` all uppercase and then print the list.
  prefs: []
  type: TYPE_NORMAL
- en: 7.7 Delete the disease element from `things`, collect your Nobel Prize, and
    print the list.
  prefs: []
  type: TYPE_NORMAL
- en: 7.8 Create a list called `surprise` with the elements `"Groucho"`, `"Chico"`,
    and `"Harpo"`.
  prefs: []
  type: TYPE_NORMAL
- en: 7.9 Lowercase the last element of the `surprise` list, reverse it, and then
    capitalize it.
  prefs: []
  type: TYPE_NORMAL
- en: 7.10 Use a list comprehension to make a list called `even` of the even numbers
    in `range(10)`.
  prefs: []
  type: TYPE_NORMAL
- en: '7.11 Let’s create a jump rope rhyme maker. You’ll print a series of two-line
    rhymes. Start with this program fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'For each tuple (`first`, `second`) in `rhymes`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first line:'
  prefs: []
  type: TYPE_NORMAL
- en: Print each string in `start1`, capitalized and followed by an exclamation point
    and a space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print `first`, also capitalized and followed by an exclamation point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the second line:'
  prefs: []
  type: TYPE_NORMAL
- en: Print `start2` and a space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print `second` and a period.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
