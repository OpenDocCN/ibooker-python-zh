- en: Chapter 6\. Exceptions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章. 异常
- en: Python uses *exceptions* to indicate errors and anomalies. When Python detects
    an error, it *raises* an exception—that is, Python signals the occurrence of an
    anomalous condition by passing an exception object to the exception propagation
    mechanism. Your code can explicitly raise an exception by executing a **raise**
    statement.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python 使用 *异常* 来指示错误和异常情况。当 Python 检测到错误时，它 *引发* 一个异常——也就是说，Python 通过将异常对象传递给异常传播机制来表示异常条件的发生。您的代码可以通过执行
    **raise** 语句显式地引发异常。
- en: '*Handling* an exception means catching the exception object from the propagation
    mechanism and taking actions as needed to deal with the anomalous situation. If
    a program does not handle an exception, the program terminates with an error message
    and traceback message. However, a program can handle exceptions and keep running,
    despite errors or other anomalies, by using the **try** statement with **except**
    clauses.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*处理* 异常意味着从传播机制捕获异常对象，并根据需要采取行动来处理异常情况。如果程序未处理异常，则程序将以错误消息和回溯消息终止。然而，程序可以通过使用带有
    **except** 子句的 **try** 语句来处理异常并继续运行，尽管存在错误或其他异常情况。'
- en: Python also uses exceptions to indicate some situations that are not errors,
    and not even abnormal. For example, as covered in [“Iterators”](ch03.xhtml#iterators),
    calling the next built-in function on an iterator raises StopIteration when the
    iterator has no more items. This is not an error; it is not even an anomaly, since
    most iterators run out of items eventually. The optimal strategies for checking
    and handling errors and other special situations in Python are therefore different
    from those in other languages; we cover them in [“Error-Checking Strategies”](#error_checking_strategies).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python 还使用异常来指示一些不是错误，甚至不是异常的情况。例如，如在 [“Iterators”](ch03.xhtml#iterators) 中所述，对迭代器调用内置的
    next 函数在迭代器没有更多项时引发 StopIteration。这不是错误；它甚至不是异常，因为大多数迭代器最终会耗尽项目。因此，在 Python 中检查和处理错误及其他特殊情况的最佳策略与其他语言不同；我们在
    [“Error-Checking Strategies”](#error_checking_strategies) 中介绍它们。
- en: This chapter shows how to use exceptions for errors and special situations.
    It also covers the logging module of the standard library, in [“Logging Errors”](#logging_errors),
    and the **assert** statement, in [“The assert Statement”](#the_assert_statement).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍如何使用异常处理错误和特殊情况。还涵盖了标准库中的日志记录模块，在 [“Logging Errors”](#logging_errors) 中，以及
    **assert** 语句，在 [“The assert Statement”](#the_assert_statement) 中。
- en: The try Statement
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The try Statement
- en: 'The **try** statement is Python’s core exception handling mechanism. It’s a
    compound statement with three kinds of optional clauses:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**try** 语句是 Python 的核心异常处理机制。它是一个复合语句，具有三种可选的子句：'
- en: It may have zero or more **except** clauses, defining how to handle particular
    classes of exceptions.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它可以有零个或多个 **except** 子句，定义如何处理特定类别的异常。
- en: If it has **except** clauses, then it may also have, right afterwards, one **else**
    clause, executed only if the **try** suite raised no exceptions.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它有 **except** 子句，那么紧接着可能还有一个 **else** 子句，仅当 **try** 语句块未引发异常时执行。
- en: Whether or not it has **except** clauses, it may have a single **finally** clause,
    unconditionally executed, with the behavior covered in [“try/except/finally”](#trysolidusexceptsolidusfinally).
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论它是否有 **except** 子句，它都可能有一个单独的 **finally** 子句，无条件执行，其行为在 [“try/except/finally”](#trysolidusexceptsolidusfinally)
    中介绍。
- en: Python’s syntax requires the presence of at least one **except** clause or a
    **finally** clause, both of which might also be present in the same statement;
    **else** is only valid following one or more **except**s.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的语法要求至少有一个 **except** 子句或一个 **finally** 子句，两者都可以在同一语句中存在；**else** 只能在一个或多个
    **except** 之后才有效。
- en: try/except
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: try/except
- en: 'Here’s the syntax for the **try**/**except** form of the **try** statement:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 **try** 语句的 **try**/**except** 形式的语法：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This form of the **try** statement has one or more **except** clauses, as well
    as an optional **else** clause (and an optional **finally** clause, whose meaning
    does not depend on whether **except** and **else** clauses are present: we cover
    this in the following section).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式的 **try** 语句具有一个或多个 **except** 子句，以及一个可选的 **else** 子句（和一个可选的 **finally**
    子句，其含义不取决于是否存在 **except** 和 **else** 子句：我们在下一节中详细介绍这一点）。
- en: The body of each **except** clause is known as an *exception handler*. The code
    executes when the *expression* in the **except** clause matches an exception object
    propagating from the **try** clause. *expression* is a class or tuple of classes,
    in parentheses, and matches any instance of one of those classes or their subclasses.
    The optional *target* is an identifier that names a variable that Python binds
    to the exception object just before the exception handler executes. A handler
    can also obtain the current exception object by calling the exc_info function
    (3.11+ or the exception function) of the module sys (covered in [Table 9-3](ch09.xhtml#alignment_indicators)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 **except** 子句的主体称为 *异常处理程序*。当 **except** 子句中的 *表达式* 与从 **try** 子句传播出的异常对象匹配时，代码执行。*表达式*
    是一个类或类元组，用括号括起来，匹配任何一个这些类或它们的子类的实例。可选的 *目标* 是一个标识符，它命名一个变量，Python 在异常处理程序执行之前将异常对象绑定到该变量上。处理程序还可以通过调用模块
    sys 的 exc_info 函数（3.11+ 或异常函数）来获取当前的异常对象（在 [Table 9-3](ch09.xhtml#alignment_indicators)
    中介绍）。
- en: 'Here is an example of the try/except form of the try statement:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 **try** 语句的 try/except 形式的示例：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When an exception is raised, execution of the **try** suite immediately ceases.
    If a **try** statement has several **except** clauses, the exception propagation
    mechanism checks the **except** clauses in order; the first **except** clause
    whose expression matches the exception object executes as the handler, and the
    exception propagation mechanism checks no further **except** clauses after that.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当引发异常时，**try** 套件的执行立即停止。如果一个 **try** 语句有多个 **except** 子句，异常传播机制按顺序检查 **except**
    子句；第一个表达式匹配异常对象的 **except** 子句作为处理程序执行，异常传播机制在此之后不再检查任何其他 **except** 子句。
- en: Specific Before General
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 先具体后一般
- en: 'Place handlers for specific cases before handlers for more general cases: when
    you place a general case first, the more specific **except** clauses that follow
    never execute.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 将特定情况的处理程序放在一般情况的处理程序之前：当你首先放置一个一般情况时，随后的更特定的 **except** 子句将不会执行。
- en: The last **except** clause need not specify an expression. An **except** clause
    without any expression handles any exception that reaches it during propagation.
    Such unconditional handling is rare, but it does occur, often in “wrapper” functions
    that must perform some extra task before re-raising an exception (see [“The raise
    Statement”](#the_raise_statement)).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的 **except** 子句不需要指定表达式。一个没有任何表达式的 **except** 子句处理在传播期间达到它的任何异常。这样的无条件处理很少见，但确实会发生，通常在必须在重新引发异常之前执行某些额外任务的“包装器”函数中（参见
    [“The raise Statement”](#the_raise_statement)）。
- en: Avoid a “Bare Except” That Doesn’t Re-Raise
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免“裸的 except” 没有重新引发
- en: 'Beware of using a “bare” **except** (an **except** clause without an expression)
    unless you’re re-raising the exception in it: such sloppy style can make bugs
    very hard to find, since the bare **except** is overly broad and can easily mask
    coding errors and other kinds of bugs by allowing execution to continue after
    an unanticipated exception.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 小心使用“裸”的 **except**（一个没有表达式的 **except** 子句），除非你在其中重新引发异常：这种粗糙的风格会使得错误非常难以找到，因为裸的
    **except** 太宽泛，可以轻易掩盖编码错误和其他类型的错误，允许执行在未预期的异常后继续。
- en: 'New programmers who are “just trying to get things to work” may even write
    code like:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: “只是想让事情运行起来”的新程序员甚至可能编写如下的代码：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a dangerous practice, since it catches important process-exiting exceptions
    such as KeyboardInterrupt or SystemExit—a loop with such an exception handler
    can’t be exited with Ctrl-C, and possibly not even terminated with a system **kill**
    command. At the very least, such code should use **except** Exception:, which
    is still overly broad but at least does not catch the process-exiting exceptions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种危险的做法，因为它捕捉到重要的进程退出异常，如 KeyboardInterrupt 或 SystemExit ——带有这种异常处理程序的循环无法通过
    Ctrl-C 退出，并且可能甚至无法通过系统 **kill** 命令终止。至少，这样的代码应该使用 **except** Exception:，这仍然太宽泛，但至少不会捕获导致进程退出的异常。
- en: 'Exception propagation terminates when it finds a handler whose expression matches
    the exception object. When a **try** statement is nested (lexically in the source
    code, or dynamically within function calls) in the **try** clause of another **try**
    statement, a handler established by the inner **try** is reached first on propagation,
    so it handles the exception when it matches it. This may not be what you want.
    Consider this example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当它找到一个表达式与异常对象匹配的处理程序时，异常传播终止。当`try`语句嵌套（在源代码的词法上，或在函数调用中动态地）在另一个`try`语句的`try`子句中时，内部`try`建立的处理程序首先在传播时达到，因此当匹配时它处理异常。这可能不是您想要的。考虑这个例子：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this case, it does not matter that the handler established by the clause
    **except** ZeroDivisionError: in the outer **try** clause is more specific than
    the catch-all **except**: in the inner **try** clause. The outer **try** does
    not enter into the picture: the exception doesn’t propagate out of the inner **try**.
    For more on exception propagation, see [“Exception Propagation”](#exception_propagation).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由外部`try`子句中的`except ZeroDivisionError:`建立的处理程序比内部`try`子句中的通用`except:`更为具体，并不重要。外部`try`不参与其中：异常不会从内部`try`传播出来。有关异常传播的更多信息，请参阅[“异常传播”](#exception_propagation)。
- en: 'The optional **else** clause of **try**/**except** executes only when the **try**
    clause terminates normally. In other words, the **else** clause does not execute
    when an exception propagates from the **try** clause, or when the **try** clause
    exits with a **break**, **continue**, or **return** statement. Handlers established
    by **try**/**except** cover only the **try** clause, not the **else** clause.
    The **else** clause is useful to avoid accidentally handling unexpected exceptions.
    For example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`/`except`的可选`else`子句仅在`try`子句正常终止时执行。换句话说，当异常从`try`子句传播出来时，或者`try`子句以`break`、`continue`或`return`语句退出时，`else`子句不会执行。由`try`/`except`建立的处理程序仅覆盖`try`子句，而不包括`else`子句。`else`子句对于避免意外处理未预期的异常很有用。例如：'
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: try/finally
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`try`/`finally`'
- en: 'Here’s the syntax for the **try**/**finally** form of the **try** statement:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`try`语句的`try`/`finally`形式的语法：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This form has one **finally** clause, and no else clause (unless it also has
    one or more **except** clauses, as covered in the following section).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此形式有一个`finally`子句，没有`else`子句（除非它还有一个或多个`except`子句，如下一节所述）。
- en: The **finally** clause establishes what is known as a *cleanup handler*. This
    code always executes after the **try** clause terminates in any way. When an exception
    propagates from the **try** clause, the **try** clause terminates, the cleanup
    handler executes, and the exception keeps propagating. When no exception occurs,
    the cleanup handler executes anyway, regardless of whether the **try** clause
    reaches its end or exits by executing a **break**, **continue**, or **return**
    statement.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally`子句建立了所谓的*清理处理程序*。这段代码在`try`子句以任何方式终止后始终执行。当异常从`try`子句传播时，`try`子句终止，清理处理程序执行，异常继续传播。当没有异常发生时，无论`try`子句是否达到其末尾或通过执行`break`、`continue`或`return`语句退出，清理处理程序都会执行。'
- en: 'Cleanup handlers established with **try**/**finally** offer a robust and explicit
    way to specify finalization code that must always execute, no matter what, to
    ensure consistency of program state and/or external entities (e.g., files, databases,
    network connections). Such assured finalization is nowadays usually best expressed
    via a *context manager* used in a **with** statement (see [“The with Statement
    and Context Managers”](#the_with_statement_and_context_managers)). Here is an
    example of the **try**/**finally** form of the **try** statement:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`try`/`finally`建立的清理处理程序提供了一种健壮且明确的方式来指定必须始终执行的最终代码，无论如何，以确保程序状态和/或外部实体（例如文件、数据库、网络连接）的一致性。这种确保的最终化现在通常通过在`with`语句中使用*上下文管理器*来表达最佳（请参阅[“with语句和上下文管理器”](#the_with_statement_and_context_managers)）。这里是`try`语句的`try`/`finally`形式的示例：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'and here is the corresponding, more concise and readable, example of using
    **with** for exactly the same purpose:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是相应的更简洁和可读性更好的示例，使用`with`来达到完全相同的目的：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Avoid break and return Statements in a finally Clause
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免在`finally`子句中使用`break`和`return`语句。
- en: 'A **finally** clause may contain one or more of the statements **continue**,
    3.8+ **break**, or **return**. However, such usage may make your program less
    clear: exception propagation stops when such a statement executes, and most programmers
    would not expect propagation to be stopped within a **finally** clause. This usage
    may confuse people who are reading your code, so we recommend you avoid it.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**finally** 子句可以包含一个或多个语句 **continue**，3.8+ **break** 或 **return**。 然而，这种用法可能使你的程序变得不太清晰：当这样的语句执行时，异常传播会停止，并且大多数程序员不希望在
    **finally** 子句内停止传播。 这种用法可能会使阅读你代码的人感到困惑，因此我们建议你避免使用它。'
- en: try/except/finally
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: try/except/finally
- en: 'A **try**/**except**/**finally** statement, such as:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 **try**/**except**/**finally** 语句，例如：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'is equivalent to the nested statement:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于嵌套语句：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A **try** statement can have multiple **except** clauses, and optionally an
    **else** clause, before a terminating **finally** clause. In all variations, the
    effect is always as just shown—that is, it’s just like nesting a **try**/**except**
    statement, with all the **except** clauses and the **else** clause, if any, into
    a containing **try**/**finally** statement.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**try** 语句可以有多个 **except** 子句，并且可选地有一个 **else** 子句，在终止的 **finally** 子句之前。 在所有变体中，效果总是像刚才展示的那样
    - 即，它就像将一个 **try**/**except** 语句的所有 **except** 子句和 **else** 子句（如果有的话）嵌套到包含的 **try**/**finally**
    语句中。'
- en: The raise Statement
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**raise** 语句'
- en: 'You can use the **raise** statement to raise an exception explicitly. **raise**
    is a simple statement with the following syntax:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 **raise** 语句显式地引发异常。 **raise** 是一个简单语句，其语法如下：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Only an exception handler (or a function that a handler calls, directly or indirectly)
    can use **raise** without any expression. A plain **raise** statement re-raises
    the same exception object that the handler received. The handler terminates, and
    the exception propagation mechanism keeps going up the call stack, searching for
    other applicable handlers. Using **raise** without any expression is useful when
    a handler discovers that it is unable to handle an exception it receives, or can
    handle the exception only partially, so the exception should keep propagating
    to allow handlers up the call stack to perform their own handling and cleanup.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 只有异常处理程序（或处理程序直接或间接调用的函数）可以使用没有任何表达式的 **raise**。 一个普通的 **raise** 语句会重新引发处理程序收到的相同异常对象。
    处理程序终止，异常传播机制继续沿调用堆栈向上搜索其他适用的处理程序。 当处理程序发现无法处理接收到的异常或只能部分处理异常时，使用没有任何表达式的 **raise**
    是有用的，因此异常应继续传播以允许调用堆栈上的处理程序执行其自己的处理和清理。
- en: When *expression* is present, it must be an instance of a class inheriting from
    the built-in class BaseException, and Python raises that instance.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在 *expression* 时，它必须是从内置类 BaseException 继承的类的实例，Python 将引发该实例。
- en: When **from** *exception* is included (which can only occur in an **except**
    block that receives *exception*), Python raises the received expression “nested”
    in the newly raised exception expression. [“Exceptions “wrapping” other exceptions
    or tracebacks”](#exceptions_quotation_markwrappingquotat) describes this in more
    detail.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当包括 **from** *exception*（只能出现在接收 *exception* 的 **except** 块中）时，Python 会将接收到的表达式“嵌套”在新引发的异常表达式中。
    ["异常“包裹”其他异常或回溯"](＃exceptions_quotation_markwrappingquotat) 更详细地描述了这一点。
- en: 'Here’s an example of a typical use of the **raise** statement:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 **raise** 语句的一个典型用例示例：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#comarker1)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#comarker1)'
- en: Some people consider raising a standard exception here to be inappropriate,
    and would prefer to raise an instance of a custom exception, as covered later
    in this chapter; this book’s authors disagree with this opinion.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人认为在此处引发标准异常是不合适的，他们更倾向于引发自定义异常的实例，这在本章后面有所涵盖；本书的作者对此持不同意见。
- en: This cross_product example function returns a list of all pairs with one item
    from each of its sequence arguments, but first, it tests both arguments. If either
    argument is empty, the function raises ValueError rather than just returning an
    empty list as the list comprehension would normally do.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此 cross_product 示例函数返回由其序列参数中的每个项目组成的所有配对的列表，但首先它测试了两个参数。 如果任一参数为空，则该函数引发 ValueError，而不仅仅像列表推导通常所做的那样返回一个空列表。
- en: Check Only What You Need To
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只检查你需要的内容
- en: 'There is no need for cross_product to check whether seq1 and seq2 are iterable:
    if either isn’t, the list comprehension itself raises the appropriate exception,
    presumably a TypeError.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 无需 cross_product 检查 seq1 和 seq2 是否可迭代：如果其中任一者不可迭代，则列表推导本身会引发适当的异常，通常是 TypeError。
- en: Once an exception is raised, by Python itself or with an explicit **raise**
    statement in your code, it is up to the caller to either handle it (with a suitable
    **try**/**except** statement) or let it propagate further up the call stack.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦由 Python 本身引发异常，或者在代码中使用显式 **raise** 语句引发异常，就由调用者来处理它（使用合适的 **try**/**except**
    语句）或让它继续向调用堆栈上传播。
- en: Don’t Use raise for Redundant Error Checks
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要为冗余错误检查使用 raise 语句
- en: Use the raise statement only to raise additional exceptions for cases that would
    normally be OK but that your specification defines to be errors. Do not use raise
    to duplicate the same error checking that Python already (implicitly) does on
    your behalf.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在你的规范定义为错误的情况下，才使用 raise 语句来引发额外的异常。不要使用 raise 来复制 Python 已（隐式地）代表你执行的相同错误检查。
- en: The with Statement and Context Managers
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**with** 语句和上下文管理器'
- en: 'The **with** statement is a compound statement with the following syntax:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**with** 语句是一个复合语句，具有以下语法：'
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The semantics of **with** are equivalent to:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**with** 的语义等效于'
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: where _manager and _normal_exit are arbitrary internal names that are not used
    elsewhere in the current scope. If you omit the optional **as** *varname* part
    of the **with** clause, Python still calls _manager.__enter__, but doesn’t bind
    the result to any name, and still calls _manager.__exit__ at block termination.
    The object returned by the *expression*, with methods __enter__ and __exit__,
    is known as a *context manager*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 _manager 和 _normal_exit 是当前范围中不使用的任意内部名称。如果在 **with** 子句的可选 **as** *varname*
    部分中省略 *varname*，Python 仍会调用 _manager.__enter__，但不会将结果绑定到任何名称，并且仍会在块终止时调用 _manager.__exit__。通过
    *expression* 返回的对象，具有方法 __enter__ 和 __exit__，被称为 *上下文管理器*。
- en: 'The **with** statement is the Python embodiment of the well-known C++ idiom
    [“resource acquisition is initialization” (RAII)](https://oreil.ly/vROml): you
    need only write context manager classes—that is, classes with two special methods,
    __enter__ and __exit__. __enter__ must be callable without arguments. __exit__
    must be callable with three arguments: all **None** when the body completes without
    propagating exceptions, and otherwise, the type, value, and traceback of the exception.
    This provides the same guaranteed finalization behavior as typical ctor/dtor pairs
    have for auto variables in C++ and **try**/**finally** statements have in Python
    or Java. In addition, they can finalize differently depending on what exception,
    if any, propagates, and optionally block a propagating exception by returning
    a true value from __exit__.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**with** 语句是 Python 中著名的 C++ 惯用语 [“资源获取即初始化” (RAII)](https://oreil.ly/vROml)
    的体现：你只需编写上下文管理器类，即包含两个特殊方法的类，__enter__ 和 __exit__。__enter__ 方法必须可被无参数调用。__exit__
    方法必须接受三个参数：当主体完成且未传播异常时均为 **None**，否则为异常的类型、值和回溯信息。这提供了与 C++ 中自动变量的典型构造函数/析构函数对和
    Python 或 Java 中 **try**/**finally** 语句相同的确保最终化行为。此外，它们可以根据传播的异常（如果有的话）以不同方式进行最终化，并且通过从
    __exit__ 返回 true 值来选择性地阻止传播的异常。'
- en: 'For example, here is a simple, purely illustrative way to ensure <name> and
    </name> tags are printed around some other output (note that context manager classes
    often have lowercase names, rather than following the normal title case convention
    for class names):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是一个简单的纯示例方式，确保在一些其他输出周围打印 <name> 和 </name> 标签（请注意，上下文管理器类通常具有小写名称，而不是遵循类名的正常大写约定）：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A simpler way to build context managers is to use the contextmanager decorator
    in the contextlib module of the Python standard library. This decorator turns
    a generator function into a factory of context manager objects.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 构建上下文管理器的一种更简单方法是使用 Python 标准库中 contextlib 模块中的 contextmanager 装饰器。此装饰器将生成器函数转换为上下文管理器对象的工厂。
- en: 'The contextlib way to implement the enclosing_tag context manager, having imported
    contextlib earlier, is:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 contextlib 模块中导入之后，实现 enclosing_tag 上下文管理器的方式是：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: contextlib supplies, among others, the class and functions listed in [Table 6-1](#commonly_used_classes_and_functions_in).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: contextlib 提供了 Table 6-1 中列出的类和函数，以及其他一些类和函数。
- en: Table 6-1\. Commonly used classes and functions in the contextlib module
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-1\. 上下文管理模块中常用的类和函数
- en: '| AbstractContextManager | AbstractContextManager An abstract base class with
    two overridable methods: __enter__, which defaults to **return** self, and __exit__,
    which defaults to **return** None. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| AbstractContextManager | AbstractContextManager 是一个具有两个可重写方法的抽象基类：__enter__
    默认为 **return** self，__exit__ 默认为 **return** None。 |'
- en: '| chdir | chdir(*dir_path*) 3.11+ A context manager whose __enter__ method
    saves the current working directory path and performs os.chdir(*dir_path*), and
    whose __exit__ method performs os.chdir(*saved_path*). |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| chdir | chdir(*dir_path*) 3.11+ 一个上下文管理器，其__enter__方法保存当前工作目录路径并执行os.chdir(*dir_path*)，其__exit__方法执行os.chdir(*saved_path*)。
    |'
- en: '| closing | closing(*something*) A context manager whose __enter__ method is
    **return** *something*, and whose __exit__ method calls *something*.close(). |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| closing | closing(*something*) 一个上下文管理器，其__enter__方法返回*something*，而其__exit__方法调用*something*.close()。
    |'
- en: '| contextmanager | contextmanager A decorator that you apply to a generator
    to make it into a context manager. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| contextmanager | contextmanager 将生成器应用为上下文管理器的装饰器。 |'
- en: '| nullcontext | nullcontext(*something*) A context manager whose __enter__
    method is **return** *something*, and whose __exit__ method does nothing. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| nullcontext | nullcontext(*something*) 一个上下文管理器，其__enter__方法返回*something*，而其__exit__方法什么也不做。
    |'
- en: '| redirect_stderr | redirect_stderr(*destination*) A context manager that temporarily
    redirects, within the body of the **with** statement, sys.stderr to the file or
    file-like object *destination*. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| redirect_stderr | redirect_stderr(*destination*) 一个上下文管理器，可以临时将sys.stderr在**with**语句体内重定向到文件或类文件对象*destination*。
    |'
- en: '| redirect_stdout | redirect_stdout(*destination*) A context manager that temporarily
    redirects, within the body of the **with** statement, sys.stdout to the file or
    file-like object *destination*. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| redirect_stdout | redirect_stdout(*destination*) 一个上下文管理器，可以临时将sys.stdout在**with**语句体内重定向到文件或类文件对象*destination*。
    |'
- en: '| suppress | suppress(**exception_classes*) A context manager that silently
    suppresses exceptions occurring in the body of the **with** statement of any of
    the classes listed in *exception_classes*. For instance, this function to delete
    a file ignores FileNotFoundError:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '| suppress | suppress(*exception_classes*) 一个上下文管理器，可以在列出的*exception_classes*中的任何一种出现在**with**语句体中时，静默地抑制异常。例如，这个删除文件的函数忽略了FileNotFoundError：'
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Use sparingly, since silently suppressing exceptions is often bad practice.
    |
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用时要节制，因为静默地抑制异常通常是不好的做法。 |
- en: For more details, examples, “recipes,” and even more (somewhat abstruse) classes,
    see Python’s [online docs](https://oreil.ly/Jwr_w).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 更多细节、示例、“配方”甚至更多（有些深奥）的类，请参阅Python的[在线文档](https://oreil.ly/Jwr_w)。
- en: Generators and Exceptions
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Generators and Exceptions
- en: 'To help generators cooperate with exceptions, **yield** statements are allowed
    inside **try**/**finally** statements. Moreover, generator objects have two other
    relevant methods, throw and close. Given a generator object *g* built by calling
    a generator function, the throw method’s signature is:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助生成器与异常协作，**try**/**finally**语句中允许使用**yield**语句。此外，生成器对象还有另外两个相关方法，throw和close。给定通过调用生成器函数构建的生成器对象*g*，throw方法的签名为：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When the generator’s caller calls *g*.throw, the effect is just as if a **raise**
    statement with the same argument executed at the spot of the **yield** at which
    generator *g* is suspended.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当生成器的调用者调用*g*.throw时，其效果就好像在生成器*g*暂停的**yield**处执行具有相同参数的**raise**语句一样。
- en: The generator method close has no arguments; when the generator’s caller calls
    *g*.close(), the effect is like calling *g*.throw(GeneratorExit()).^([1](ch06.xhtml#ch01fn78))
    GeneratorExit is a built-in exception class that inherits directly from BaseException.
    Generators also have a finalizer (the special method __del__) that implicitly
    calls close when the generator object is garbage-collected.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器方法close没有参数；当生成器的调用者调用*g*.close()时，其效果就像调用*g*.throw(GeneratorExit())一样。^([1](ch06.xhtml#ch01fn78))
    GeneratorExit是一个直接继承自BaseException的内置异常类。生成器还有一个终结器（特殊方法__del__），当生成器对象被垃圾回收时会隐式调用close方法。
- en: If a generator raises or propagates a StopIteration exception, Python turns
    the exception’s type into RuntimeError.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果生成器引发或传播StopIteration异常，Python会将异常类型转换为RuntimeError。
- en: Exception Propagation
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常传播
- en: When an exception is raised, the exception propagation mechanism takes control.
    The normal control flow of the program stops, and Python looks for a suitable
    exception handler. Python’s **try** statement establishes exception handlers via
    its **except** clauses. The handlers deal with exceptions raised in the body of
    the **try** clause, as well as exceptions propagating from functions called by
    that code, directly or indirectly. If an exception is raised within a **try**
    clause that has an applicable **except** handler, the **try** clause terminates
    and the handler executes. When the handler finishes, execution continues with
    the statement after the **try** statement (in the absence of any explicit change
    to the flow of control, such as a **raise** or **return** statement).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当引发异常时，异常传播机制接管控制。程序的正常控制流停止，Python 寻找合适的异常处理程序。Python 的 **try** 语句通过其 **except**
    子句设立异常处理程序。处理程序处理 **try** 子句中引发的异常，以及直接或间接调用该代码的函数中传播的异常。如果在具有适用 **except** 处理程序的
    **try** 子句中引发异常，则 **try** 子句终止并执行处理程序。处理程序完成后，继续执行 **try** 语句之后的语句（在没有显式更改控制流程的情况下，例如
    **raise** 或 **return** 语句）。
- en: If the statement raising the exception is not within a **try** clause that has
    an applicable handler, the function containing the statement terminates, and the
    exception propagates “upward” along the stack of function calls to the statement
    that called the function. If the call to the terminated function is within a **try**
    clause that has an applicable handler, that **try** clause terminates, and the
    handler executes. Otherwise, the function containing the call terminates, and
    the propagation process repeats, *unwinding* the stack of function calls until
    an applicable handler is found.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果引发异常的语句不在具有适用处理程序的 **try** 子句内，则包含该语句的函数终止，并且异常沿着函数调用堆栈向上“传播”到调用该函数的语句。如果终止的函数调用位于具有适用处理程序的
    **try** 子句内，则该 **try** 子句终止，并执行处理程序。否则，包含调用的函数终止，并且传播过程重复，*展开* 函数调用堆栈，直到找到适用的处理程序。
- en: If Python cannot find any applicable handler, by default the program prints
    an error message to the standard error stream (sys.stderr). The error message
    includes a traceback that gives details about functions terminated during propagation.
    You can change Python’s default error-reporting behavior by setting sys.excepthook
    (covered in [Table 8-3](ch08.xhtml#functions_and_attributes_of_the_sys_mod)).
    After error reporting, Python goes back to the interactive session, if any, or
    terminates if execution was not interactive. When the exception type is SystemExit,
    termination is silent and ends the interactive session, if any.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Python 找不到任何适用的处理程序，默认情况下程序会将错误消息打印到标准错误流（sys.stderr）。错误消息包括有关在传播过程中终止的函数的详细跟踪信息。您可以通过设置
    sys.excepthook（在 [表 8-3](ch08.xhtml#functions_and_attributes_of_the_sys_mod) 中讨论）来更改
    Python 的默认错误报告行为。在错误报告之后，Python 返回交互会话（如果有），或者如果执行不是交互的，则终止。当异常类型为 SystemExit
    时，终止是静默的，并结束交互会话（如果有）。
- en: 'Here are some functions to show exception propagation at work:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些函数来展示异常传播的工作原理：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Calling the h function prints the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 h 函数会打印以下内容：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That is, none of the “after” print statements execute, since the flow of exception
    propagation cuts them off.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，由于异常传播的流程切断了它们，没有一个“after”打印语句被执行。
- en: The function h establishes a **try** statement and calls the function g within
    the **try** clause. g, in turn, calls f, which performs a division by 0, raising
    an exception of type ZeroDivisionError. The exception propagates all the way back
    to the **except** clause in h. The functions f and g terminate during the exception
    propagation phase, which is why neither of their “after” messages is printed.
    The execution of h’s **try** clause also terminates during the exception propagation
    phase, so its “after” message isn’t printed either. Execution continues after
    the handler, at the end of h’s **try**/**except** block.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 h 设立了一个 **try** 语句并在 **try** 子句中调用函数 g。g 反过来调用 f，而 f 进行了除以 0 的操作，引发了 ZeroDivisionError
    类型的异常。异常传播直到 h 的 **except** 子句。函数 f 和 g 在异常传播阶段终止，这就是为什么它们的“after”消息都没有打印出来。h
    的 **try** 子句的执行也在异常传播阶段终止，因此它的“after”消息也没有打印出来。在处理程序之后，h 的 **try**/**except**
    块结束时，继续执行。
- en: Exception Objects
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常对象
- en: Exceptions are instances of BaseException (more specifically, instances of one
    of its subclasses). [Table 6-2](#attributes_and_methods_of_the_baseexcep) lists
    the attributes and methods of BaseException.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是BaseException的实例（更具体地说，是其子类之一的实例）。[Table 6-2](#attributes_and_methods_of_the_baseexcep)
    列出了BaseException的属性和方法。
- en: Table 6-2\. Attributes and methods of the BaseException class
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Table 6-2\. BaseException类的属性和方法
- en: '| __cause__ | *exc*.__cause__ Returns the parent exception of an exception
    raised using **raise** **from**. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| __cause__ | *exc*.__cause__ 返回使用**raise** **from**引发的异常的父异常。 |'
- en: '| __notes__ | *exc*.__notes__ 3.11+ Returns a list of strs added to the exception
    using add_note. This attribute only exists if add_note has been called at least
    once, so the safe way to access this list is with getattr(*exc*, ''__notes__'',
    []). |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| __notes__ | *exc*.__notes__ 3.11+ 返回一个包含使用add_note添加到异常中的字符串列表。只有在至少调用一次add_note之后才存在此属性，因此安全的访问此列表的方法是使用getattr(*exc*,
    ''__notes__'', [])。 |'
- en: '| add_note | *exc*.add_note(*note*) 3.11+ Appends the str *note* to the notes
    on this exception. These notes are shown after the traceback when displaying the
    exception. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| add_note | *exc*.add_note(*note*) 3.11+ 将字符串 *note* 添加到此异常的注释中。在显示异常时，这些注释会显示在回溯信息之后。
    |'
- en: '| args | *exc.*args Returns a tuple of the arguments used to construct the
    exception. This error-specific information is useful for diagnostic or recovery
    purposes. Some exception classes interpret args and set convenient named attributes
    on the classes’ instances. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| args | *exc.*args 返回用于构造异常的参数的元组。这些特定于错误的信息对诊断或恢复目的非常有用。某些异常类解释args并在类的实例上设置便捷的命名属性。
    |'
- en: '| wi⁠t⁠h⁠_​t⁠r⁠a⁠ceback | *exc*.with_traceback(*tb*) Returns a new exception,
    replacing the original exception’s traceback with the new traceback *tb*, or with
    no traceback if *tb* is **None**. Can be used to trim the original traceback to
    remove internal library function call frames. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| wi⁠t⁠h⁠_​t⁠r⁠a⁠c⁠e⁠b⁠a⁠c⁠k | *exc*.with_traceback(*tb*) 返回一个新的异常，用新的回溯 *tb*
    替换原始异常的回溯，如果 *tb* 是 **None** 则不包含回溯。可用于修剪原始回溯以删除内部库函数调用帧。 |'
- en: The Hierarchy of Standard Exceptions
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准异常的层次结构
- en: As mentioned previously, exceptions are instances of subclasses of BaseException.
    The inheritance structure of exception classes is important, as it determines
    which **except** clauses handle which exceptions. Most exception classes extend
    the class Exception; however, the classes KeyboardInterrupt, GeneratorExit, and
    SystemExit inherit directly from BaseException and are not subclasses of Exception.
    Thus, a handler clause **except** Exception **as** e does not catch KeyboardInterrupt,
    GeneratorExit, or SystemExit (we covered exception handlers in [“try/except”](#trysolidusexcept)
    and GeneratorExit in [“Generators and Exceptions”](#generators_and_exceptions)).
    Instances of SystemExit are normally raised via the exit function in the sys module
    (covered in [Table 8-3](ch08.xhtml#functions_and_attributes_of_the_sys_mod)).
    When the user hits Ctrl-C, Ctrl-Break, or other interrupting keys on their keyboard,
    that raises KeyboardInterrupt.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，异常是BaseException的子类的实例。异常类的继承结构很重要，因为它决定了哪些**except**子句处理哪些异常。大多数异常类扩展自Exception类；然而，KeyboardInterrupt、GeneratorExit和SystemExit直接继承自BaseException，并不是Exception的子类。因此，一个处理器子句**except**
    Exception **as** e无法捕获KeyboardInterrupt、GeneratorExit或SystemExit（我们在[“try/except”](#trysolidusexcept)和[“Generators
    and Exceptions”](#generators_and_exceptions)中介绍了异常处理程序）。SystemExit的实例通常是通过sys模块中的exit函数引发的（在[Table 8-3](ch08.xhtml#functions_and_attributes_of_the_sys_mod)中有所涵盖）。当用户按Ctrl-C、Ctrl-Break或其他中断键时，会引发KeyboardInterrupt。
- en: 'The hierarchy of built-in exception classes is, roughly:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 内置异常类的层次结构大致如下：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There are other exception subclasses (in particular, Warning and OSError have
    many, whose omission is indicated here with ellipses), but this is the gist. A
    complete list is available in Python’s [online docs](https://oreil.ly/pLihr).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 其他异常子类（特别是警告和OSError有很多，这里用省略号表示），但这就是要点。完整列表可在Python的[在线文档](https://oreil.ly/pLihr)中找到。
- en: The classes marked “(abstract)” are never instantiated directly; their purpose
    is to make it easier for you to specify **except** clauses that handle a range
    of related errors.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为“(abstract)”的类永远不会直接实例化；它们的目的是使您能够指定处理一系列相关错误的**except**子句。
- en: Standard Exception Classes
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准异常类
- en: '[Table 6-3](#standard_exception_classes) lists exception classes raised by
    common runtime errors.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[Table 6-3](#standard_exception_classes) 列出了由常见运行时错误引发的异常类。'
- en: Table 6-3\. Standard exception classes
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Table 6-3\. 标准异常类
- en: '| Exception class | Raised when |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 异常类 | 抛出时机 |'
- en: '| --- | --- |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| AssertionError | An **assert** statement failed. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| AssertionError | 一个**assert**语句失败。 |'
- en: '| AttributeError | An attribute reference or assignment failed. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| AttributeError | 属性引用或赋值失败。 |'
- en: '| ImportError | An **import** or **from**...**import** statement (covered in
    [“The import Statement”](ch07.xhtml#the_import_statement)) couldn’t find the module
    to import (in this case, what Python raises is actually an instance of ImportError’s
    subclass ModuleNotFoundError), or couldn’t find a name to be imported from the
    module. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| ImportError | 一个**import**或**from**...**import**语句（详见[“import语句”](ch07.xhtml#the_import_statement)）找不到要导入的模块（在这种情况下，Python实际引发的是ImportError的子类ModuleNotFoundError），或找不到要从模块导入的名称。
    |'
- en: '| IndentationError | The parser encountered a syntax error due to incorrect
    indentation. Subclasses SyntaxError. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| IndentationError | 解析器由于不正确的缩进而遇到语法错误。子类SyntaxError。 |'
- en: '| IndexError | An integer used to index a sequence is out of range (using a
    noninteger as a sequence index raises TypeError). Subclasses LookupError. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| IndexError | 用于索引序列的整数超出范围（使用非整数作为序列索引会引发TypeError）。子类LookupError。 |'
- en: '| KeyboardInterrupt | The user pressed the interrupt key combination (Ctrl-C,
    Ctrl-Break, Delete, or others, depending on the platform’s handling of the keyboard).
    |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| KeyboardInterrupt | 用户按下中断键组合（Ctrl-C、Ctrl-Break、Delete或其他，取决于平台对键盘的处理）。 |'
- en: '| KeyError | A key used to index a mapping is not in the mapping. Subclasses
    LookupError. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| KeyError | 用于索引映射的键不在映射中。子类LookupError。 |'
- en: '| MemoryError | An operation ran out of memory. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| MemoryError | 操作耗尽了内存。 |'
- en: '| NameError | A name was referenced, but it was not bound to any variable in
    the current scope. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| NameError | 引用了一个名称，但它没有绑定到当前作用域中的任何变量。 |'
- en: '| N⁠o⁠t⁠I⁠m⁠p⁠l⁠e⁠m⁠e⁠n⁠t⁠e⁠d​E⁠r⁠r⁠o⁠r | Raised by abstract base classes to
    indicate that a concrete subclass must override a method. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| N⁠o⁠t⁠I⁠m⁠p⁠l⁠e⁠m⁠e⁠n⁠t⁠e⁠d​E⁠r⁠r⁠o⁠r | 抽象基类引发以指示必须重写方法的具体子类。 |'
- en: '| OSError | Raised by functions in the module os (covered in [“The os Module”](ch11.xhtml#the_os_module)
    and [“Running Other Programs with the os Module”](ch15.xhtml#running_other_programs_with_the_os_modu))
    to indicate platform-dependent errors. OSError has many subclasses, covered in
    the following subsection. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| OSError | 由os模块中的函数引发（详见[“os模块”](ch11.xhtml#the_os_module)和[“使用os模块运行其他程序”](ch15.xhtml#running_other_programs_with_the_os_modu)），以指示平台相关的错误。OSError有许多子类，详见下一小节。
    |'
- en: '| RecursionError | Python detected that the recursion depth has been exceeded.
    Subclasses RuntimeError. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| RecursionError | Python检测到递归深度已超出。子类RuntimeError。 |'
- en: '| RuntimeError | Raised for any error or anomaly not otherwise classified.
    |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| RuntimeError | 为未归类的任何错误或异常引发。 |'
- en: '| SyntaxError | Python’s parser encountered a syntax error. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| SyntaxError | Python解析器遇到语法错误。 |'
- en: '| SystemError | Python has detected an error in its own code, or in an extension
    module. Please report this to the maintainers of your Python version, or of the
    extension in question, including the error message, the exact Python version (sys.version),
    and, if possible, your program’s source code. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| SystemError | Python检测到自己代码或扩展模块中的错误。请向您的Python版本维护者或相关扩展的维护者报告此问题，包括错误消息、确切的Python版本（sys.version），如果可能的话，请附上程序源代码。
    |'
- en: '| TypeError | An operation or function was applied to an object of an inappropriate
    type. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| TypeError | 应用于不适当类型的对象的操作或函数。 |'
- en: '| UnboundLocalError | A reference was made to a local variable, but no value
    is currently bound to that local variable. Subclasses NameError. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| UnboundLocalError | 引用了一个本地变量，但当前未绑定任何值到该本地变量。子类NameError。 |'
- en: '| UnicodeError | An error occurred while converting Unicode (i.e., a str) to
    a byte string, or vice versa. Subclasses ValueError. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| UnicodeError | 在转换Unicode（即str）到字节字符串或反之过程中发生错误。子类ValueError。 |'
- en: '| ValueError | An operation or function was applied to an object that has a
    correct type but an inappropriate value, and nothing more specific (e.g., KeyError)
    applies. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| ValueError | 应用于具有正确类型但不合适值的对象的操作或函数，且没有更具体的异常适用（例如KeyError）。 |'
- en: '| ZeroDivisionError | A divisor (the righthand operand of a /, //, or % operator,
    or the second argument to the built-in function divmod) is 0. Subclasses ArithmeticError.
    |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| ZeroDivisionError | 除数（/、//或%运算符的右操作数，或内置函数divmod的第二个参数）为0。子类ArithmeticError。
    |'
- en: OSError subclasses
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OSError的子类
- en: OSError represents errors detected by the operating system. To handle such errors
    more elegantly, OSError has many subclasses, whose instances are what actually
    get raised; for a complete list, see Python’s [online docs](https://oreil.ly/3vJ3W).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: OSError 代表操作系统检测到的错误。为了更优雅地处理这些错误，OSError 有许多子类，其实例是实际抛出的内容；完整列表请参阅 Python 的[在线文档](https://oreil.ly/3vJ3W)。
- en: 'For example, consider this task: try to read and return the contents of a certain
    file, return a default string if the file does not exist, and propagate any other
    exception that makes the file unreadable (except for the file not existing). Using
    an existing OSError subclass, you can accomplish the task quite simply:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑这个任务：尝试读取并返回某个文件的内容，如果文件不存在则返回默认字符串，并传播使文件不可读的任何其他异常（除了文件不存在）。使用现有的 OSError
    子类，您可以很简单地完成这个任务：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The FileNotFoundError subclass of OSError makes this kind of common task simple
    and direct to express in code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: FileNotFoundError 的 OSError 子类使得这种常见任务在代码中表达起来简单直接。
- en: Exceptions “wrapping” other exceptions or tracebacks
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常“包装”其他异常或 traceback
- en: Sometimes, you cause an exception while trying to handle another. To let you
    clearly diagnose this issue, each exception instance holds its own traceback object;
    you can make another exception instance with a different traceback with the with_traceback
    method.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，在尝试处理另一个异常时会引发异常。为了让您清楚地诊断此问题，每个异常实例都持有其自己的 traceback 对象；您可以使用 with_traceback
    方法创建另一个具有不同 traceback 的异常实例。
- en: 'Moreover, Python automatically stores which exception it’s handling as the
    __context__ attribute of any further exception raised during the handling (unless
    you set the exception’s __suppress_context__ attribute to **True** with the **raise**...**from**
    statement, which we cover shortly). If the new exception propagates, Python’s
    error message uses that exception’s __context__ attribute to show details of the
    problem. For example, take the (deliberately!) broken code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Python 自动存储它正在处理的异常作为任何后续异常的 __context__ 属性（除非您使用 **raise**...**from** 语句并将异常的
    __suppress_context__ 属性设置为 **True**，这部分我们稍后会讲到）。如果新异常传播，Python 的错误消息将使用该异常的 __context__
    属性显示问题的详细信息。例如，看看这个（故意！）有问题的代码：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The error displayed is:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的错误是：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Thus, Python clearly displays both exceptions, the original and the intervening
    one.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Python 明确显示原始异常和干预异常。
- en: 'To get more control over the error display, you can, if you wish, use the **raise**...**from**
    statement. When you execute **raise** *e* **from** *ex*, both *e* and *ex* are
    exception objects: *e* is the one that propagates, and *ex* is its “cause.” Python
    records *ex* as the value of *e.__cause__*, and sets *e.*__suppress_context__
    to true. (Alternatively, *ex* can be **None**: then, Python sets *e.__cause__*
    to **None**, but still sets *e.*__suppress_context__ to true, and thus leaves
    *e.*__context__ alone).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望更多地控制错误显示，可以使用 **raise**...**from** 语句。当您执行 **raise** *e* **from** *ex*
    时，*e* 和 *ex* 都是异常对象：*e* 是传播的异常，*ex* 是其“原因”。Python 记录 *ex* 作为 *e.__cause__* 的值，并将
    *e.__suppress_context__* 设置为 true。（或者，*ex* 可以为 **None**：然后，Python 将 *e.__cause__*
    设置为 **None**，但仍将 *e.__suppress_context__* 设置为 true，并因此保持 *e.__context__* 不变）。
- en: 'As another example, here’s a class implementing a mock filesystem directory
    using a Python dict, with the filenames as the keys and the file contents as the
    values:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个示例，这里是一个使用 Python 字典实现模拟文件系统目录的类，其中文件名作为键，文件内容作为值：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When read_file is called with a nonexistent filename, the access to the self._files
    dict raises KeyError. Since this code is intended to emulate a filesystem directory,
    read_file catches the KeyError and raises FileNotFoundError instead.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用不存在的文件名调用 read_file 时，对 self._files 字典的访问会引发 KeyError。由于此代码旨在模拟文件系统目录，read_file
    捕获 KeyError 并抛出 FileNotFoundError。
- en: 'As is, accessing a nonexistent file named ''data.txt'' will output an exception
    message similar to:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 就像现在，访问名为 'data.txt' 的不存在文件将输出类似以下的异常消息：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This exception report shows both the KeyError and the FileNotFoundError. To
    suppress the internal KeyError exception (to hide implementation details of FileSystemDirectory),
    we change the **raise** statement in read_file to:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此异常报告显示了 KeyError 和 FileNotFoundError。为了抑制内部 KeyError 异常（隐藏 FileSystemDirectory
    的实现细节），我们在 read_file 中的 **raise** 语句改为：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now the exception only shows the FileNotFoundError information:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在异常只显示 FileNotFoundError 的信息：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For details and motivations regarding exception chaining and embedding, see
    [PEP 3134](https://oreil.ly/wE9rL).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 关于异常链和嵌入的详细信息和动机，请参阅 [PEP 3134](https://oreil.ly/wE9rL)。
- en: Custom Exception Classes
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义异常类
- en: 'You can extend any of the standard exception classes in order to define your
    own exception class. Often, such a subclass adds nothing more than a docstring:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以扩展任何标准异常类来定义自己的异常类。通常，这样的子类除了一个文档字符串外没有其他内容：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: An Empty Class or Function Should Have a Docstring
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空类或函数应该有一个文档字符串。
- en: As covered in [“The pass Statement”](ch03.xhtml#the_pass_statement), you don’t
    need a pass statement to make up the body of a class. The docstring (which you
    should always write, to document the class’s purpose if nothing else!) is enough
    to keep Python happy. Best practice for all “empty” classes (regardless of whether
    they are exception classes), just like for all “empty” functions, is usually to
    have a docstring and no **pass** statement.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如[“pass 语句”](ch03.xhtml#the_pass_statement)所述，你不需要一个 pass 语句来构成一个类的主体。只要有文档字符串（如果什么都不写的话，也应该写一个来记录类的目的！），Python
    就足够了。对于所有“空”类（无论是否为异常类），最佳实践通常是只有一个文档字符串，而没有**pass**语句。
- en: 'Given the semantics of **try**/**except**, raising an instance of a custom
    exception class such as InvalidAttributeError is almost the same as raising an
    instance of its standard exception superclass, AttributeError, but with some advantages.
    Any **except** clause that can handle AttributeError can handle InvalidAttributeError
    just as well. In addition, client code that knows about your InvalidAttributeError
    custom exception class can handle it specifically, without having to handle all
    other cases of AttributeError when it is not prepared for those. For example,
    suppose you write code like the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于**try**/**except**的语义，引发自定义异常类的实例（如InvalidAttributeError）几乎与引发其标准异常超类AttributeError的实例相同，但具有一些优势。任何可以处理AttributeError的**except**子句也可以很好地处理InvalidAttributeError。此外，了解你的InvalidAttributeError自定义异常类的客户端代码可以专门处理它，而不必在不准备处理其他情况的情况下处理所有其他AttributeError的情况。例如，假设你编写如下代码：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, client code can, if it so chooses, be more selective in its handlers.
    For example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，客户端代码可以选择性地更加精确地处理异常。例如：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Use Custom Exception Classes
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义异常类
- en: It’s an excellent idea to define, and raise, instances of custom exception classes
    in your modules, rather than plain standard exceptions. By using custom exception
    classes that extend standard ones, you make it easier for callers of your module’s
    code to handle exceptions that come from your module separately from others, if
    they choose to.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的模块中定义和引发自定义异常类的实例，而不是普通的标准异常，是一个绝佳的主意。通过使用扩展标准异常的自定义异常类，你使调用者更容易单独处理来自你模块的异常，如果他们选择这样做的话。
- en: Custom Exceptions and Multiple Inheritance
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义异常和多重继承
- en: 'An effective approach to the use of custom exceptions is to multiply inherit
    exception classes from your module’s special custom exception class and a standard
    exception class, as in the following snippet:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义异常类的有效方法是从你模块的特定自定义异常类和标准异常类中多重继承异常类，如下片段所示：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, an instance of CustomAttributeError can only be raised explicitly and deliberately,
    showing an error related specifically to your code that *also* happens to be an
    AttributeError. When your code raises an instance of CustomAttributeError, that
    exception can be caught by calling code that’s designed to catch all cases of
    AttributeError as well as by code that’s designed to catch all exceptions raised
    only, specifically, by your module.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，CustomAttributeError的实例只能被显式和有意地引发，显示了与你的代码特别相关的错误，*也*恰好是一个AttributeError。当你的代码引发CustomAttributeError的实例时，该异常可以被设计为捕获所有AttributeError情况的调用代码以及被设计为仅处理你模块引发的所有异常情况的代码捕获。
- en: Use Multiple Inheritance for Custom Exceptions
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多重继承定义自定义异常
- en: Whenever you must decide whether to raise an instance of a specific standard
    exception, such as AttributeError, or of a custom exception class you define in
    your module, consider this multiple inheritance approach, which, in this book’s
    authors’ opinion,^([2](ch06.xhtml#ch01fn79)) gives you the best of both worlds
    in such cases. Make sure you clearly document this aspect of your module, because
    the technique, although handy, is not widely used. Users of your module may not
    expect it unless you clearly and explicitly document what you are doing.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您必须决定是否引发特定标准异常的实例，例如 AttributeError，或者您在模块中定义的自定义异常类的实例时，请考虑这种多重继承的方法，在本书作者的观点中，这种方法在这些情况下是最佳选择。确保您清楚地记录模块的这一方面，因为这种技术虽然方便，但使用并不广泛。除非您明确和明确地记录您正在做什么，否则模块的用户可能不会预期到这一点。
- en: Other Exceptions Used in the Standard Library
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准库中使用的其他异常
- en: Many modules in Python’s standard library define their own exception classes,
    which are equivalent to the custom exception classes that your own modules can
    define. Typically, all functions in such standard library modules may raise exceptions
    of such classes, in addition to exceptions in the standard hierarchy covered in
    [“Standard Exception Classes”](#standard_exception_classe). We cover the main
    cases of such exception classes throughout the rest of this book, in chapters
    covering the standard library modules that supply and may raise them.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Python 标准库中的许多模块定义了它们自己的异常类，这些异常类相当于您自己模块可以定义的自定义异常类。通常，这类标准库模块中的所有函数可能会引发这些类的异常，除了[“标准异常类”](#standard_exception_classe)中覆盖的标准层次结构的异常之外。我们将在本书的其余部分中涵盖此类异常类的主要情况，这些情况涵盖了提供和可能引发它们的标准库模块的章节。
- en: ExceptionGroup and except*
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ExceptionGroup 和 except*
- en: 3.11+ In some circumstances, such as when performing validation of some input
    data against multiple criteria, it is useful to be able to raise more than a single
    exception at once. Python 3.11 introduced a mechanism to raise multiple exceptions
    at once using an ExceptionGroup instance and to process more than one exception
    using an **except*** form in place of **except**.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 3.11+ 在某些情况下，例如对某些输入数据执行多个条件验证时，能够一次引发多个异常是有用的。Python 3.11 引入了一种使用 ExceptionGroup
    实例一次引发多个异常并使用 **except*** 形式处理多个异常的机制。
- en: 'To raise ExceptionGroup, the validating code captures multiple Exceptions into
    a list and then raises an ExceptionGroup that is constructed using that list.
    Here is some code that searches for misspelled and invalid words, and raises an
    ExceptionGroup containing all of the found errors:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要引发 ExceptionGroup，验证代码会将多个异常捕获到一个列表中，然后使用该列表构造一个 ExceptionGroup 并引发它。以下是一些搜索拼写错误和无效单词的代码，并引发包含所有找到错误的
    ExceptionGroup 的示例：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following code validates a sample text string and lists out all the found
    errors:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码验证了一个示例文本字符串，并列出了所有找到的错误：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'giving this output:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 给出以下输出：
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Unlike **except**, after it finds an initial match, **except*** continues to
    look for additional exception handlers matching exception types in the raised
    ExceptionGroup.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与 **except** 不同，在找到初始匹配后，**except*** 会继续寻找匹配引发的 ExceptionGroup 中异常类型的其他异常处理程序。
- en: Error-Checking Strategies
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误检查策略
- en: Most programming languages that support exceptions raise exceptions only in
    rare cases. Python’s emphasis is different. Python deems exceptions appropriate
    whenever they make a program simpler and more robust, even if that makes exceptions
    rather frequent.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数支持异常的编程语言只在极少数情况下引发异常。Python 的重点不同。Python 认为在使程序更简单和更健壮时适当的地方引发异常，即使这样做使异常相当频繁。
- en: LBYL Versus EAFP
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LBYL 与 EAFP
- en: 'A common idiom in other languages, sometimes known as “look before you leap”
    (LBYL), is to check in advance, before attempting an operation, for anything that
    might make the operation invalid. This approach is not ideal, for several reasons:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中的一种常见习惯用法，有时称为“先入为主”（LBYL），是在尝试操作之前提前检查可能使操作无效的任何内容。这种方法并不理想，原因如下：
- en: The checks may diminish the readability and clarity of the common, mainstream
    cases where everything is OK.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些检查可能会降低在一切正常的常见主流情况下的可读性和清晰度。
- en: The work needed for checking purposes may duplicate a substantial part of the
    work done in the operation itself.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了进行检查而需要的工作可能会重复操作本身的大部分工作。
- en: The programmer might easily err by omitting a needed check.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序员可能很容易通过省略所需的检查而出错。
- en: The situation might change between the moment when you perform the checks and
    the moment when, later (even by a tiny fraction of a second!), you attempt the
    operation.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你执行检查的时刻和稍后（即使只有一小部分时间！）尝试操作的时刻之间，情况可能会发生变化。
- en: 'The preferred idiom in Python is to attempt the operation in a **try** clause
    and handle the exceptions that may result in one or more **except** clauses. This
    idiom is known as [“It’s easier to ask forgiveness than permission” (EAFP)](https://oreil.ly/rGXC9),
    a frequently quoted motto widely credited to Rear Admiral Grace Murray Hopper,
    co-inventor of COBOL. EAFP shares none of the defects of LBYL. Here is a function
    using the LBYL idiom:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中首选的习惯用法是在 **try** 子句中尝试操作，并在一个或多个 **except** 子句中处理可能引发的异常。这种习惯用法称为[“宁愿请求原谅，也不要事先征求许可”（EAFP）](https://oreil.ly/rGXC9)，这是一个经常引用的格言，被广泛认为是
    COBOL 的共同发明者之一的 Rear Admiral Grace Murray Hopper 所创。EAFP 不具有 LBYL 的任何缺陷。以下是一个使用
    LBYL 惯用法的函数：
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: With LBYL, the checks come first, and the mainstream case is somewhat hidden
    at the end of the function.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 LBYL，检查首先进行，主流情况在函数末尾有点隐藏。
- en: 'Here is the equivalent function using the EAFP idiom:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 EAFP 惯用法的等效函数：
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With EAFP, the mainstream case is up front in a **try** clause, and the anomalies
    are handled in the following **except** clause, making the whole function easier
    to read and understand.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 EAFP，主流情况在 **try** 子句中前置，异常情况在接下来的 **except** 子句中处理，使整个函数更易于阅读和理解。
- en: 'EAFP is a good error-handling strategy, but it is not a panacea. In particular,
    you must take care not to cast too wide a net, catching errors that you did not
    expect and therefore did not mean to catch. The following is a typical case of
    such a risk (we cover built-in function getattr in [Table 8-2](ch08.xhtml#pythonapostrophes_core_built_in_functio)):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: EAFP 是一种很好的错误处理策略，但它并非包治百病。特别是，您必须小心不要铺得太宽，捕捉到您没有预期到的错误，因此也没有打算捕捉到的错误。以下是这种风险的典型案例（我们在[表 8-2](ch08.xhtml#pythonapostrophes_core_built_in_functio)中介绍了内置函数
    getattr）：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The intention of the trycalling function is to try calling a method named *attrib*
    on the object *obj*, but to return *default* if *obj* has no method thus named.
    However, the function as coded does not do *just* that: it also accidentally hides
    any error case where an AttributeError is raised inside the sought-after method,
    silently returning *default* in those cases. This could easily hide bugs in other
    code. To do exactly what’s intended, the function must take a little bit more
    care:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 trycalling 的意图是尝试在对象 obj 上调用名为 *attrib* 的方法，但如果 obj 没有这样的方法，则返回 *default*。然而，所编写的函数并不仅仅如此：它还意外隐藏了在所寻找的方法内部引发
    AttributeError 的任何错误情况，默默地在这些情况下返回 *default*。这可能会轻易隐藏其他代码中的 bug。要完全达到预期效果，函数必须多加小心：
- en: '[PRE38]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This implementation of trycalling separates the getattr call, placed in the
    **try** clause and therefore guarded by the handler in the **except** clause,
    from the call of the method, placed in the **else** clause and therefore free
    to propagate any exception. The proper approach to EAFP involves frequent use
    of the **else** clause in **try**/**except** statements (which is more explicit,
    and thus better Python style, than just placing the nonguarded code after the
    whole **try**/**except** statement).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 trycalling 的实现将 getattr 调用与方法调用分开，getattr 调用放置在 **try** 子句中，因此受到 **except**
    子句的保护，而方法调用放置在 **else** 子句中，因此可以自由传播任何异常。正确的 EAFP 方法涉及在 **try**/**except** 语句中频繁使用
    **else** 子句（这比在整个 **try**/**except** 语句后放置非受保护代码更加明确，因此更符合 Python 风格）。
- en: Handling Errors in Large Programs
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理大型程序中的错误
- en: In large programs, it is especially easy to err by making your **try**/**except**
    statements too broad, particularly once you have convinced yourself of the power
    of EAFP as a general error-checking strategy. A **try**/**except** combination
    is too broad when it catches too many different errors, or an error that can occur
    in too many different places. The latter is a problem when you need to distinguish
    exactly what went wrong and where, and the information in the traceback is not
    sufficient to pinpoint such details (or you discard some or all of the information
    in the traceback). For effective error handling, you have to keep a clear distinction
    between errors and anomalies that you expect (and thus know how to handle) and
    unexpected errors and anomalies that may indicate a bug in your program.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型程序中，特别容易犯错的地方是将你的**try**/**except**语句设计得过于宽泛，特别是一旦你深信EAFP作为一种通用的错误检查策略的强大之后。当一个**try**/**except**组合捕获了太多不同的错误，或者在太多不同的位置可能发生错误时，这种组合就显得过于宽泛了。当你需要准确区分出错原因及位置，并且回溯信息不足以精确定位这些细节（或者你丢弃了回溯信息中的一些或全部信息）时，后者会成为问题。为了有效地处理错误，你必须清楚地区分你预期的（因此知道如何处理）和意外的错误和异常，后者可能表明你程序中存在漏洞。
- en: 'Some errors and anomalies are not really erroneous, and perhaps not even all
    that anomalous: they are just special “edge” cases, perhaps somewhat rare but
    nevertheless quite expected, which you choose to handle via EAFP rather than via
    LBYL to avoid LBYL’s many intrinsic defects. In such cases, you should just handle
    the anomaly, often without even logging or reporting it.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有些错误和异常并非真正错误，也许甚至不算太反常：它们只是特殊的“边缘”情况，也许比较罕见，但仍然完全可以预料到，你选择通过EAFP处理而不是通过LBYL来避免LBYL的许多内在缺陷。在这种情况下，你应该只是处理这种异常，通常甚至不需要记录或报告它。
- en: Keep Your try/except Constructs Narrow
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持你的try/except结构尽可能狭窄
- en: Be very careful to keep **try**/**except** constructs as narrow as feasible.
    Use a small **try** clause that contains a small amount of code that doesn’t call
    too many other functions, and use very specific exception class tuples in the
    **except** clauses. If need be, further analyze the details of the exception in
    your handler code, and **raise** again as soon as you know it’s not a case this
    handler can deal with.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 非常小心地保持**try**/**except**结构尽可能狭窄。使用一个小的**try**子句，其中包含少量不调用太多其他函数的代码，并在**except**子句中使用非常具体的异常类元组。如果需要，进一步分析异常的详细信息在你的处理代码中，当你知道这个处理程序无法处理的情况时，尽快**raise**出来。
- en: Errors and anomalies that depend on user input or other external conditions
    not under your control are always expected, precisely because you have no control
    over their underlying causes. In such cases, you should concentrate your effort
    on handling the anomaly gracefully, reporting and logging its exact nature and
    details, and keeping your program running with undamaged internal and persistent
    state. Your **try**/**except** clauses should still be reasonably narrow, although
    this is not quite as crucial as when you use EAFP to structure your handling of
    not-really-erroneous special/edge cases.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖用户输入或其他不受你控制的外部条件导致的错误和异常总是可以预期的，这正是因为你无法控制它们的根本原因。在这种情况下，你应该集中精力优雅地处理这些异常，记录和记录其确切的性质和细节，并保持你程序的内部状态和持久状态不受损害。尽管当你使用EAFP来处理并非真正错误的特殊/边缘情况时，这并不像那么关键，但你的**try**/**except**子句仍应该相对狭窄。
- en: Lastly, entirely unexpected errors and anomalies indicate bugs in your program’s
    design or coding. In most cases, the best strategy regarding such errors is to
    avoid **try**/**except** and just let the program terminate with error and traceback
    messages. (You might want to log such information and/or display it more suitably
    with an application-specific hook in sys.excepthook, as we’ll discuss shortly.)
    In the unlikely case that your program must keep running at all costs, even under
    dire circumstances, **try**/**except** statements that are quite wide may be appropriate,
    with the **try** clause guarding function calls that exercise vast swaths of program
    functionality, and broad **except** clauses.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，完全意想不到的错误和异常表明你程序的设计或编码存在漏洞。在大多数情况下，处理这类错误的最佳策略是避免使用**try**/**except**，直接让程序带着错误和回溯信息终止运行。（你可能想要在sys.excepthook的应用特定钩子中记录这些信息和/或更适当地显示，我们稍后会讨论这个。）在极少数情况下，即使在极端情况下你的程序必须继续运行，也可能适合使用相当宽泛的**try**/**except**语句，其中**try**子句保护调用涵盖大片程序功能的函数，并且广泛的**except**子句。
- en: In the case of a long-running program, make sure to log all details of the anomaly
    or error to some persistent place for later study (and also report to yourself
    some indication of the problem, so that you know such later study is necessary).
    The key is making sure that you can revert the program’s persistent state to some
    undamaged, internally consistent point. The techniques that enable long-running
    programs to survive some of their own bugs, as well as environmental adversities,
    are known as [checkpointing](https://oreil.ly/GX4hz) (basically, periodically
    saving program state, and writing the program so it can reload the saved state
    and continue from there) and [transaction processing](https://oreil.ly/0MaWS);
    we do not cover them further in this book.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在长时间运行的程序中，务必记录异常或错误的所有细节到某个持久化存储位置，以便日后研究（同时也向自己报告问题的某些指示，这样您就知道需要进行这样的后续研究）。关键在于确保您能将程序的持久状态还原到某个未受损、内部一致的状态点。使长时间运行的程序能够克服其自身的某些缺陷以及环境逆境的技术被称为[检查点技术](https://oreil.ly/GX4hz)（基本上是周期性保存程序状态，并编写程序以便重新加载保存的状态并从那里继续）和[事务处理](https://oreil.ly/0MaWS)；在本书中我们不进一步介绍它们。
- en: Logging Errors
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录错误
- en: When Python propagates an exception all the way to the top of the stack without
    finding an applicable handler, the interpreter normally prints an error traceback
    to the standard error stream of the process (sys.stderr) before terminating the
    program. You can rebind sys.stderr to any file-like object usable for output in
    order to divert this information to a destination more suitable for your purposes.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当Python将异常传播到堆栈的顶部而没有找到适用的处理程序时，解释器通常会在终止程序之前将错误回溯打印到进程的标准错误流（sys.stderr）。您可以重新绑定sys.stderr到任何可用于输出的类似文件的对象，以便将此信息重定向到更适合您目的的位置。
- en: 'When you want to change the amount and kind of information output on such occasions,
    rebinding sys.stderr is not sufficient. In such cases, you can assign your own
    function to sys.excepthook: Python calls it when terminating the program due to
    an unhandled exception. In your exception-reporting function, output whatever
    information will help you diagnose and debug the problem and direct that information
    to whatever destinations you please. For example, you might use the traceback
    module (covered in [“The traceback Module”](ch17.xhtml#the_traceback_module))
    to format stack traces. When your exception-reporting function terminates, so
    does your program.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当您希望在这些情况下更改输出的信息数量和类型时，重新绑定sys.stderr是不够的。在这种情况下，您可以将自己的函数分配给sys.excepthook：当由于未处理的异常而终止程序时，Python会调用它。在您的异常报告函数中，输出任何有助于诊断和调试问题的信息，并将该信息定向到任何您希望的位置。例如，您可以使用traceback模块（在[“traceback模块”](ch17.xhtml#the_traceback_module)中介绍）格式化堆栈跟踪。当您的异常报告函数终止时，程序也会终止。
- en: The logging module
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日志模块
- en: The Python standard library offers the rich and powerful logging module to let
    you organize the logging of messages from your applications in systematic, flexible
    ways. Pushing things to the limit, you might write a whole hierarchy of Logger
    classes and subclasses; you could couple the loggers with instances of Handler
    (and subclasses thereof), or insert instances of the class Filter to fine-tune
    criteria determining what messages get logged in which ways.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库提供了丰富而强大的日志记录模块，让您以系统化、灵活的方式组织应用程序的日志记录消息。在极限情况下，您可以编写一整套Logger类和其子类；您可以将记录器与Handler类（及其子类）的实例或者插入Filter类的实例结合起来，以微调决定哪些消息以何种方式记录的标准。
- en: Messages are formatted by instances of the Formatter class—the messages themselves
    are instances of the LogRecord class. The logging module even includes a dynamic
    configuration facility, whereby you may dynamically set logging configuration
    files by reading them from disk files, or even by receiving them on a dedicated
    socket in a specialized thread.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 消息由Formatter类的实例格式化——消息本身是LogRecord类的实例。日志模块甚至包括动态配置功能，通过该功能，您可以通过从磁盘文件读取或者通过专用线程中的专用套接字接收它们，动态设置日志配置文件。
- en: 'While the logging module sports a frighteningly complex and powerful architecture,
    suitable for implementing highly sophisticated logging strategies and policies
    that may be needed in vast and complicated software systems, in most applications
    you might get away with using a tiny subset of the package. First, **import**
    logging. Then, emit your message by passing it as a string to any of the module’s
    functions debug, info, warning, error, or critical, in increasing order of severity.
    If the string you pass contains format specifiers such as %s (as covered in [“Legacy
    String Formatting with %”](ch09.xhtml#legacy_string_formatting_with_percent)),
    then, after the string, pass as further arguments all the values to be formatted
    in that string. For example, don’t call:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然日志模块拥有一个复杂且强大的架构，适用于实现可能在庞大和复杂的软件系统中需要的高度复杂的日志策略和策略，但在大多数应用程序中，您可能只需使用该包的微小子集。首先，**导入**
    logging。然后，通过将其作为字符串传递给模块的任何函数 debug、info、warning、error 或 critical，按严重性递增地发出您的消息。如果您传递的字符串包含诸如
    %s（如 [“使用 % 进行遗留字符串格式化”](ch09.xhtml#legacy_string_formatting_with_percent) 中所述）的格式说明符，则在字符串之后，传递所有要在该字符串中格式化的值作为进一步的参数。例如，不要调用：
- en: '[PRE39]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'which performs the formatting operation whether it’s needed or not; rather,
    call:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这会执行格式化操作，无论是否需要；相反，调用：
- en: '[PRE40]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'which performs formatting if and only if needed (i.e., if and only if calling
    debug is going to result in logging output, depending on the current threshold
    logging level). If foo is used only for logging and is especially compute- or
    I/O-intensive to create, you can use isEnabledFor to conditionalize the expensive
    code that creates foo:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这会执行格式化，仅在需要时执行（即仅当调用 debug 会导致日志输出时，取决于当前的阈值日志级别）。如果 foo 仅用于日志记录，并且创建 foo 特别耗费计算或
    I/O，您可以使用 isEnabledFor 来有条件地执行创建 foo 的昂贵代码：
- en: '[PRE41]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Configuring logging
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置日志记录
- en: Unfortunately, the logging module does not support the more readable formatting
    approaches covered in [“String Formatting”](ch09.xhtml#string_formatting), but
    only the legacy one mentioned in the previous subsection. Fortunately, it’s very
    rare to need any formatting specifiers beyond %s (which calls __str__) and %r
    (which calls __repr__).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，日志模块不支持在 [“字符串格式化”](ch09.xhtml#string_formatting) 中涵盖的更易读的格式化方法，而仅支持前面子节中提到的遗留方法。幸运的是，很少需要超出
    %s（调用 __str__）和 %r（调用 __repr__）之外的任何格式化说明符。
- en: 'By default, the threshold level is WARNING: any of the functions warning, error,
    or critical results in logging output, but the functions debug and info do not.
    To change the threshold level at any time, call logging.getLogger().setLevel,
    passing as the only argument one of the corresponding constants supplied by the
    logging module: DEBUG, INFO, WARNING, ERROR, or CRITICAL. For example, once you
    call:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，阈值级别为 WARNING：任何 warning、error 或 critical 函数都会产生日志输出，但 debug 和 info 函数不会。要随时更改阈值级别，请调用
    logging.getLogger().setLevel，并将 logging 模块提供的相应常量之一作为唯一参数传递：DEBUG、INFO、WARNING、ERROR
    或 CRITICAL。例如，一旦调用：
- en: '[PRE42]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'all of the logging functions from debug to critical result in logging output
    until you change the level again. If later you call:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 所有从 debug 到 critical 的所有日志函数都会产生日志输出，直到再次更改级别。如果稍后调用：
- en: '[PRE43]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: then only the functions error and critical result in logging output (debug,
    info, and warning won’t result in logging output); this condition, too, persists
    until you change the level again, and so forth.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 那么只有 error 和 critical 函数会产生日志输出（debug、info 和 warning 不会产生日志输出）；这个条件也会持续，直到再次更改级别，依此类推。
- en: 'By default, logging output goes to your process’s standard error stream (sys.stderr,
    as covered in [Table 8-3](ch08.xhtml#functions_and_attributes_of_the_sys_mod))
    and uses a rather simplistic format (for example, it does not include a timestamp
    on each line it outputs). You can control these settings by instantiating an appropriate
    handler instance, with a suitable formatter instance, and creating and setting
    a new logger instance to hold it. In the simple, common case in which you just
    want to set these logging parameters once and for all, after which they persist
    throughout the run of your program, the simplest approach is to call the logging.basicConfig
    function, which lets you set things up quite simply via named parameters. Only
    the very first call to logging.basicConfig has any effect, and only if you call
    it before any of the logging functions (debug, info, and so on). Therefore, the
    most common use is to call logging.basicConfig at the very start of your program.
    For example, a common idiom at the start of a program is something like:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，日志输出到进程的标准错误流（sys.stderr，如在[表 8-3](ch08.xhtml#functions_and_attributes_of_the_sys_mod)中所述），并使用相对简单的格式（例如，每行输出不包括时间戳）。您可以通过实例化适当的处理程序实例、合适的格式化程序实例，并创建和设置一个新的记录器实例来控制这些设置。在简单且常见的情况下，您只需设置这些日志参数一次，然后它们在程序运行期间将保持不变，最简单的方法是通过命名参数调用
    logging.basicConfig 函数。只有对 logging.basicConfig 的第一次调用才会产生任何效果，并且只有在调用任何日志函数（例如
    debug、info 等）之前调用它才会产生效果。因此，最常见的用法是在程序的最开始调用 logging.basicConfig。例如，在程序的开始处常见的习惯用法如下：
- en: '[PRE44]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This setting writes logging messages to a file, nicely formatted with a precise
    human-readable timestamp, followed by the severity level right-aligned in an eight-character
    field, followed by the message proper.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 此设置将日志消息写入文件，并以精确的人类可读时间戳进行格式化，后跟右对齐的八字符字段，然后是适当的消息内容。
- en: For much, much more detailed information on the logging module and all the wonders
    you can perform with it, be sure to consult Python’s [rich online documentation](https://oreil.ly/AO1Xa)*.*
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有关日志模块及其所有功能的详细信息，请务必查阅 Python 的[丰富在线文档](https://oreil.ly/AO1Xa)。
- en: The assert Statement
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: assert 语句
- en: 'The **assert** statement allows you to introduce “sanity checks” into a program.
    **assert** is a simple statement with the following syntax:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**assert** 语句允许您在程序中引入“健全性检查”。**assert** 是一个简单语句，其语法如下：'
- en: '[PRE45]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When you run Python with the optimize flag (**-O**, as covered in [“Command-Line
    Syntax and Options”](ch02.xhtml#command_line_syntax_and_options)), **assert**
    is a null operation: the compiler generates no code for it. Otherwise, **assert**
    evaluates *condition*. When *condition* is satisfied, **assert** does nothing.
    When *condition* is not satisfied, **assert** instantiates AssertionError with
    *expression* as the argument (or without arguments, if there is no *expression*)
    and raises the resulting instance.^([3](ch06.xhtml#ch01fn80))'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Python 时，如果使用优化标志（**-O**，如在[“命令行语法和选项”](ch02.xhtml#command_line_syntax_and_options)中介绍的），**assert**
    是一个空操作：编译器不会为其生成任何代码。否则，**assert** 会评估 *condition*。当 *condition* 满足时，**assert**
    什么也不做。当 *condition* 不满足时，**assert** 会实例化 AssertionError，并将 *expression* 作为参数（如果没有
    *expression*，则不带参数），然后引发该实例^([3](ch06.xhtml#ch01fn80))。
- en: '**assert** statements can be an effective way to document your program. When
    you want to state that a significant, nonobvious condition *C* is known to hold
    at a certain point in a program’s execution (known as an *invariant* of your program),
    **assert** *C* is often better than a comment that just states that *C* holds.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**assert** 语句可以是记录程序的有效方法。当您想要声明在程序执行的某一点上已知存在一个重要且不明显的条件 *C*（称为程序的 *不变量*）时，**assert**
    *C* 通常比仅仅声明 *C* 成立的注释更好。'
- en: Don’t Overuse assert
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要过度使用 assert。
- en: Never use **assert** for other purposes besides sanity-checking program invariants.
    A serious but very common mistake is to use **assert** about the values of inputs
    or arguments. Checking for erroneous arguments or inputs is best done more explicitly,
    and in particular must not be done using **assert**, since it can be turned into
    a null operation by a Python command-line flag.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用于健全性检查程序不变性之外，永远不要将 **assert** 用于其他目的。一个严重但非常常见的错误是在输入或参数的值上使用 **assert**。检查错误的参数或输入最好更加明确，特别是不能使用
    **assert**，因为它可以通过 Python 命令行标志变成空操作。
- en: The advantage of **assert** is that, when *C* does *not* in fact hold, **assert**
    immediately alerts you to the problem by raising AssertionError, if the program
    is running without the **-O** flag. Once the code is thoroughly debugged, run
    it with **-O**, turning **assert** into a null operation and incurring no overhead
    (the **assert** remains in your source code to document the invariant).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**assert** 的优势在于，当 *C* 实际上 *不* 成立时，**assert** 会立即通过引发 AssertionError 警示问题，如果程序在没有
    **-O** 标志的情况下运行。一旦代码彻底调试完成，使用 **-O** 运行它，将 **assert** 转换为一个空操作且不会产生任何开销（**assert**
    保留在源代码中以记录不变量）。'
- en: The __debug__ Built-in Variable
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: __debug__ 内置变量
- en: When you run Python without the option **-O**, the __debug__ built-in variable
    is **True**. When you run Python with the option **-O**, __debug__ is **False**.
    Also, in the latter case the compiler generates no code for any **if** statement
    whose sole guard condition is __debug__.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有 **-O** 选项运行 Python 时，__debug__ 内置变量为 **True**。在使用 **-O** 选项运行 Python 时，__debug__
    为 **False**。此外，在后一种情况下，编译器对唯一保护条件为 __debug__ 的任何 **if** 语句不生成代码。
- en: To exploit this optimization, surround the definitions of functions that you
    call only in **assert** statements with **if** __debug__:. This technique makes
    compiled code smaller and faster when Python is run with **-O**, and enhances
    program clarity by showing that those functions exist only to perform sanity checks.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '为了利用这一优化，用 **if** __debug__: 包围仅在 **assert** 语句中调用的函数的定义。这种技术使得在使用 **-O** 运行
    Python 时，编译代码更小更快，并通过显示这些函数仅用于执行健全性检查来增强程序的清晰度。'
- en: '^([1](ch06.xhtml#ch01fn78-marker)) Except that multiple calls to close are
    allowed and innocuous: all but the first one perform no operation.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch06.xhtml#ch01fn78-marker)) 除了允许多次调用 close 并且无害外：除第一个外的所有调用均不执行操作。
- en: '^([2](ch06.xhtml#ch01fn79-marker)) This is somewhat controversial: while this
    book’s authors agree on this being “best practice,” some others strongly insist
    that one should always avoid multiple inheritance, including in this specific
    case.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch06.xhtml#ch01fn79-marker)) 这在某种程度上是有争议的：虽然本书的作者认为这是“最佳实践”，但一些人坚决主张应始终避免多重继承，包括在这个特定情况下。
- en: ^([3](ch06.xhtml#ch01fn80-marker)) Some third-party frameworks, such as [pytest](http://docs.pytest.org/en/latest),
    materially improve the usefulness of the **assert** statement.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch06.xhtml#ch01fn80-marker)) 一些第三方框架，如 [pytest](http://docs.pytest.org/en/latest)，实质上提高了
    **assert** 语句的实用性。
