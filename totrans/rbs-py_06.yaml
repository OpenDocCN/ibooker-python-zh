- en: Chapter 5\. Collection Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can’t go very far in Python without encountering *collection types*. Collection
    types store a grouping of data, such as a list of users or a lookup between restaurant
    or address. Whereas other types (e.g., `int`, `float`, `bool`, etc.) may focus
    on a single value, collections may store any arbitrary amount of data. In Python,
    you will encounter common collection types such as dictionaries, lists, and sets
    (oh, my!). Even a string is a type of collection; it contains a sequence of characters.
    However, collections can be difficult to reason about when reading new code. Different
    collection types have different behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in [Chapter 1](part0003_split_000.html#intro), I went over some of the
    differences between the collections, where I talked about mutability, iterability,
    and indexing requirements. However, picking the right collection is just the first
    step. You must understand the implications of your collection and ensure that
    users can reason about it. You also need to recognize when the standard collection
    types aren’t cutting it and you need to roll your own. But the first step is knowing
    how to communicate your collection choices to the future. For that, we’ll turn
    to an old friend: type annotations.'
  prefs: []
  type: TYPE_NORMAL
- en: Annotating Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’ve covered type annotations for non–collection types, and now you need to
    know how to annotate collection types. Fortunately, these annotations don’t differ
    too much from the annotations you’ve already learned.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, suppose I’m building a digital cookbook app. I want to
    organize all my cookbooks digitally so I can search them by cuisine, ingredient,
    or author. One of the questions I might have about a cookbook collection is how
    many books from each author I have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This function has been annotated; it takes in a list of cookbooks and will return
    a dictionary. Unfortunately, while this tells me what collections to expect, it
    doesn’t tell me how to use the collections at all. There is nothing telling me
    what the elements inside the collection are. For instance, how do I know what
    type the cookbook is? If you were reviewing this code, how do you know that the
    use of `book.author` is legitimate? Even if you do the digging to make sure `book.author`
    is right, this code is not future-proof. If the underlying type changes, such
    as removing the `author` field, this code will break. I need a way to catch this
    with my typechecker.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll do this by encoding more information with my types by using bracket syntax
    to indicate information about the types *inside* the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I used an alias, `AuthorToCountMapping`, to represent a `dict[str, int]`. I
    do this because I find it difficult sometimes to remember what the `str` and the
    `int` are supposed to represent. However, I do concede that this loses some information
    (readers of the code will have to find out what `AuthorToCountMapping` is an alias
    to). Ideally, your code editor can display what the underlying type is without
    you needing to look it up.
  prefs: []
  type: TYPE_NORMAL
- en: I can indicate the exact types expected in the collection. The cookbooks list
    contains `Cookbook` objects, and the return value of the function is returning
    a dictionary mapping strings (keys) to integers (values). Note that I’m using
    a type alias to give more meaning to my return value. Mapping from a `str` to
    an `int` does not tell the user the context of the type. Instead, I create a type
    alias named `AuthorToCountMapping` to make it clear how this dictionary relates
    to the problem domain.
  prefs: []
  type: TYPE_NORMAL
- en: You need to think through what types are contained in the collection in order
    to be effective in type-hinting it. In order to do that, you need to think about
    homogeneous and heterogeneous collections.
  prefs: []
  type: TYPE_NORMAL
- en: Homogeneous Versus Heterogeneous Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Homogeneous collections* are collections in which every value has the same
    type. In contrast, values in *heterogeneous collections* may have different types
    within them. From a usability standpoint, your lists, sets, and dictionaries should
    nearly always be homogenous. Users need a way to reason about your collections,
    and they can’t if they don’t have the guarantee that every value is the same type.
    If you make a list, set, or dictionary a heterogeneous collection, you are indicating
    to the user that they need to take care to handle special cases. Suppose I want
    to resurrect an example from [Chapter 1](part0003_split_000.html#intro) for adjusting
    recipes for my cookbook app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'At the time, I mentioned how parts of this code were ugly; one confounding
    factor was the fact that the first element of the recipe list was a special case:
    an integer representing the servings. This contrasts with the rest of the list
    elements, which are tuples representing actual ingredients, such as `("flour",
    1.5, "cup")`. This highlights the troubles of a heterogeneous collection. For
    every use of your collection, the user needs to remember to handle the special
    case. This is predicated on the assumption that the developer even knew about
    the special case in the first place. There’s no way as it stands to represent
    that a specific element needs to be handled differently. Therefore, a typechecker
    will not catch when a developer forgets. This leads to brittle code down the road.'
  prefs: []
  type: TYPE_NORMAL
- en: When talking about homogeneity, it’s important to talk about what a *single
    type* means. When I mention a single type, I’m not necessarily referring to a
    concrete type in Python; rather, I’m referring to a set of behaviors that define
    that type. A single type indicates that a consumer must operate on every value
    of that type in the exact same way. For the cookbook list, the single type is
    a `Cookbook`. For the dictionary example, the key’s single type is a string and
    the value’s single type is an integer. For heterogeneous collections, this will
    not always be the case. What do you do if you must have different types in your
    collection and there is no relation between them?
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider what my ugly code from [Chapter 1](part0003_split_000.html#intro)
    communicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a lot of information in the docstring, but docstrings have no guarantee
    of being correct. They also won’t protect developers if they accidentally break
    assumptions. This code does not communicate intention adequately to future collaborators.
    Those future collaborators won’t be able to reason about your code. The last thing
    you want to burden them with is having to go through the codebase, looking for
    invocations and implementations to work out how to use your collection. Ultimately,
    you need a way to reconcile the first element (an integer) with the remaining
    elements in the list (which are tuples). To solve this, I’ll use a `Union` (and
    some type aliases to make the code more readable):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This takes a heterogeneous collection (items could be an integer or an ingredient)
    and allows developers to reason about the collection as if it were homogeneous.
    The developer needs to treat every single value as the same—it is either an integer
    or an `Ingredient`—before operating on it. While more code is needed to handle
    the typechecks, you can rest easier knowing that your typechecker will catch users
    not checking for special cases. Bear in mind, this is not perfect by any means;
    it’d be better if there was no special case in the first place and `servings`
    was passed to the function another way. But for the cases where you absolutely
    must handle special cases, represent them as a type so that the typechecker benefits
    you.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When heterogeneous collections are complex enough that they involve lots of
    validation logic strewn about your codebase, consider making them a user-defined
    type, such as a data class or class. Consult [Part II](part0011.html#part_2) for
    more information on creating user-defined types.
  prefs: []
  type: TYPE_NORMAL
- en: You can add too many types in a `Union`, though. The more special cases of types
    you handle, the more code a developer has to write every time they use that type,
    and the more unwieldy the codebase becomes.
  prefs: []
  type: TYPE_NORMAL
- en: At the far end of the spectrum lies the `Any` type. `Any` can be used to indicate
    that all types are valid in this context. This sounds appealing to get around
    special cases, but it also means that the consumers of your collection have no
    clue what to do with the values in the collection, defeating the purpose of type
    annotations in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Developers working in a statically typed language don’t need to put in as much
    care to ensure collections are homogeneous; the static type system does that for
    them already. The challenge in Python is due to Python’s dynamically typed nature.
    It is much easier for a developer to create a heterogeneous collection without
    any warnings from the language itself.
  prefs: []
  type: TYPE_NORMAL
- en: Heterogeneous collection types still have a lot of uses; don’t assume that you
    should use homogeneity for every collection type because it is easier to reason
    about. Tuples, for example, are often heterogeneous.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose a tuple containing a name and page count represents a `Cookbook`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'I am describing specific fields for this tuple: name and page count. This is
    a prime example of an heterogeneous collection:'
  prefs: []
  type: TYPE_NORMAL
- en: Each field (name and page count) will always be in the same order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All names are strings; all page counts are integers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating over the tuple is rare, since I won’t treat both types the same.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name and page count are fundamentally different types, and should not be treated
    as equivalent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When accessing a tuple, you will typically index to the specific field you
    want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in many codebases, tuples like these soon become burdensome. Developers
    tire of writing `cookbook[0]` whenever they want a name. A better thing to do
    would be to find some way to name these fields. A first choice might be a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, they can refer to fields as `food_lab[''name'']` and `food_lab[''page_count'']`.
    The problem is, dictionaries are typically meant to be a homogeneous mapping from
    a key to a value. However, when dictionaries are used to represent data that is
    heterogeneous, you run into similar problems as above when writing a valid type
    annotation. If I want to try to use a type system to represent this dictionary,
    I end up with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach has the following problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Large dictionaries may have many different types of values. Writing a `Union`
    is quite cumbersome.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is tedious for a user to handle every case for every dictionary access. (Since
    I indicate that the dictionary is homogeneous, I convey to developers that they
    need to treat every value as the same type, meaning typechecks for every value
    access. *I* know that the `name` is always a `str` and the `page_count` is always
    an `int`, but a consumer of this type would not know that.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developers do not have any indication what keys are available in the dictionary.
    They must search all the code from dictionary creation time to the current access
    to see what fields have been added.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the dictionary grows, developers have a tendency to use `Any` as the type
    of the value. Using `Any` defeats the purpose of the typechecker in this case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`Any` can be used for valid type annotations; it merely indicates that you
    are making zero assumptions about what the type is. For instance, if you wanted
    to copy a list, the type signature would be `def copy(coll: list[Any]) -> list[Any]`.
    Of course, you could also do `def copy(coll: list) -> list`, and it would mean
    the same thing.'
  prefs: []
  type: TYPE_NORMAL
- en: These problems all stem from heterogeneous data in homogeneous data collections.
    You either pass the burden onto the caller or abandon type annotations completely.
    In some cases, you want the caller to explicitly check each type on each value
    access, but in other cases, this is overcomplicated and tedious. So, how can you
    explain your reasoning with heterogeneous types, especially in cases where keeping
    data in a dictionary is natural, such as API interactions or user-configurable
    data? For these cases, you should use a `TypedDict`.
  prefs: []
  type: TYPE_NORMAL
- en: TypedDict
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`TypedDict`, introduced in Python 3.8, is for the scenarios where you absolutely
    must store heterogeneous data in a dictionary. These are typically situations
    where you can’t avoid heterogeneous data. JSON APIs, YAML, TOML, XML, and CSVs
    all have easy-to-use Python modules that convert these data formats into a dictionary
    and are naturally hetereogeneous. This means the data that gets returned has all
    the same problems as listed in the previous section. Your typechecker won’t help
    out much and users won’t know what keys and values are available.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you have full control of the dictionary, meaning you create it in code you
    own and handle it in code you own, you should consider using a `dataclass` (see
    [Chapter 9](part0013_split_000.html#dataclasses)) or a `class` (see [Chapter 10](part0014_split_000.html#classes))
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose I want to augment my digital cookbook app to provide nutritional
    information for the recipes listed. I decide to use the [Spoonacular API](https://oreil.ly/joTNh)
    and write some code to get nutritional information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were reviewing the code, how would you know that this code is right?
    If you wanted to also print out the calories, how do you access the data? What
    guarantees do you have about the fields inside of this dictionary? To answer these
    questions, you have two options:'
  prefs: []
  type: TYPE_NORMAL
- en: Look up the API documentation (if any) and confirm that the right fields are
    being used. In this scenario, you hope that the documentation is actually complete
    and correct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the code and print out the returned dictionary. In this situation, you hope
    that test responses are pretty identical to production responses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The problem is that you are requiring every reader, reviewer, and maintainer
    to do one of these two steps in order to understand the code. If they don’t, you
    will not get good code review feedback and developers will run the risk of using
    the response incorrectly. This leads to incorrect assumptions and brittle code.
    `TypedDict` allows you to encode what you’ve learned about that API directly into
    your type system.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now it is incredibly apparent exactly what data types you can rely upon. If
    the API ever changes, a developer can update all the `TypedDict` classes and let
    the typechecker catch any incongruities. Your typechecker now completely understands
    your dictionary, and readers of your code can reason about responses without having
    to do any external searching.
  prefs: []
  type: TYPE_NORMAL
- en: Even better, these `TypedDict` collections can be as arbitrarily complex as
    you need them to be. You’ll see that I nested `TypedDict` instances for reusability
    purposes, but you can also embed your own custom types, `Unions`, and `Optionals`
    to reflect the possibilities that an API can return. And while I’ve mostly been
    talking about API, remember that these benefits apply to any heterogeneous dictionary,
    such as when reading JSON or YAML.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`TypedDict` is only for the typechecker’s benefit. There is no runtime validation
    at all; the runtime type is just a dictionary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, I’ve been teaching you how to deal with built-in collection types:
    lists/sets/dictionaries for homogeneous collections and tuples/`TypedDict` for
    heterogenous collections. What if these types don’t do *everything* that you want?
    What if you want to create new collections that are easy to use? To do that, you’ll
    need a new set of tools.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating New Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When writing a new collection, you should ask yourself: am I trying to write
    a new collection that isn’t representable by another collection type, or am I
    trying to modify an existing collection to provide some new behavior? Depending
    on the answer, you may need to employ different techniques to achieve your goal.'
  prefs: []
  type: TYPE_NORMAL
- en: If you write a collection type that isn’t representable by another collection
    type, you are bound to come across *generics* at some point.
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A generic type indicates that you don’t care what type you are using. However,
    it helps restrict users from mixing types where inappropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the innocuous reverse list function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'How do I indicate that the returned list should contain the same type as the
    passed-in list? To achieve this, I use a generic, which is done with a `TypeVar`
    in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This says that for a type `T`, reverse takes in a list of elements of type
    `T` and returns a list of elements of type `T`. I can’t mix types: a list of integers
    will never be able to become a list of strings if those lists aren’t using the
    same `TypeVar`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I can use this sort of pattern to define entire classes. Suppose I want to
    integrate a cookbook recommender service into the cookbook collection app. I want
    to be able to recommend cookbooks or recipes based on a customer’s ratings. To
    do this, I want to store each of these pieces of rating information in a *graph*.
    A graph is a data structure that contains a series of entities known as *nodes*
    and that tracks *edges* (relationships between those nodes). However, I don’t
    want to write separate code for a cookbook graph and a recipe graph. So I define
    a `Graph` class that can be used for generic types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With this code, I can define all sorts of graphs and still have them typecheck
    successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas this code does not typecheck:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Using generics can help you write collections that use types consistently throughout
    their lifetime. This reduces the amount of duplication in your codebase, which
    minimizes the chances of bugs and reduces cognitive burden.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying Existing Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generics are nice for creating your own collection types, but what if you just
    want to tweak some behavior of an existing collection type, such as a list or
    dictionary? Having to completely rewrite all the semantics of a collection would
    be tedious and error-prone. Thankfully, methods exist to make this a snap. Let’s
    go back to our cookbook app. I’ve written code earlier that grabs nutrition information,
    but now I want to store all that nutrition information in a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, I hit a problem: the same ingredient has very different names depending
    on where you’re from. Take a dark leafy green, common in salads. While an American
    chef might call it “arugula,” a European might call it “rocket.” This doesn’t
    even begin to cover the names in languages other than English. To combat this,
    I want to create a dictionary-like object that automatically handles these aliases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: So how can I write `NutritionalInformation` to act like a dict?
  prefs: []
  type: TYPE_NORMAL
- en: 'A lot of a developer’s first instinct is to subclass dictionaries. No worries
    if you aren’t awesome at subclassing; I’ll be going much more in depth in [Chapter 12](part0016_split_000.html#subtyping).
    For now, just treat subclassing as a way of saying, “I want my subclass to behave
    exactly like the parent class.” However, you’ll learn that subclassing a dictionary
    may not always be what you want. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](../images/00002.gif)](part0008_split_006.html#co_collection_types_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `(dict)` syntax indicates that we are subclassing from dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](../images/00005.gif)](part0008_split_006.html#co_collection_types_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`__getitem__` is what gets called when you use brackets to check a key in a
    dictionary: (`nutrition["rocket"]`) calls `__getitem__(nutrition, "rocket")`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](../images/00006.gif)](part0008_split_006.html#co_collection_types_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: If a key is found, use the parent dictionary’s key check.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](../images/00007.gif)](part0008_split_006.html#co_collection_types_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: For every alias, check if it is in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](../images/00008.gif)](part0008_split_006.html#co_collection_types_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Throw a `KeyError` if no key is found, either with what’s passed in or any of
    its aliases.
  prefs: []
  type: TYPE_NORMAL
- en: We are overriding the `__getitem__` function, and this works!
  prefs: []
  type: TYPE_NORMAL
- en: If I try to access `nutrition["rocket"]` in that snippet above, I get the same
    nutritional information as `nutrition["arugula"]`. Huzzah! So you deploy it in
    production and call it a day.
  prefs: []
  type: TYPE_NORMAL
- en: But (and there’s always a but), as time goes on, a developer comes to you and
    complains that sometimes the dictionary doesn’t work. You spend some time debugging,
    and it always works for you. You look for race conditions, threading, API tomfoolery,
    or any other nondeterminism, and come up with absolutely zero potential bugs.
    Finally, you get some time where you can sit with the other developer and see
    what they are doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'And sitting at their terminal are the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get` function on a dictionary tries to get the key, and if not found,
    will return the second argument (in this case “No Ingredient Found”). Herein lies
    the problem: when subclassing from a dictionary and overriding methods, you have
    no guarantee that those methods are called from every other method in the dictionary.
    Built-in collection types are built with performance in mind; many methods use
    inlined code to go fast. This means that overriding one method, such as `__getitem__`,
    will not be used in most dictionary methods. This certainly violates the Law of
    Least Surprise, which we talked about in [Chapter 1](part0003_split_000.html#intro).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It is OK to subclass from the built-in collection if you are only adding methods,
    but because future modifications may make this same mistake, I still prefer to
    use one of the other methods of building custom collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'So overriding `dict` is out. Instead I’ll use types from the `collections`
    module. For this case, there is a handy type called `collections.UserDict`. `UserDict`
    fits the exact use case that I need: I can subclass from `UserDict`, override
    key methods, and get the behavior I expect.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This fits your use case exactly. You subclass from `UserDict` instead of `dict`,
    and then use `self.data` to access the underlying dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'You go run your teammate’s code again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: And you get the nutrition information for arugula.
  prefs: []
  type: TYPE_NORMAL
- en: '`UserDict` isn’t the only collection type that you can override in this case.
    There also is a `UserString` and a `UserList` in the collections model. Anytime
    you want to tweak a dictionary, string, or list, these are the collections you
    want to use.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Inheriting from these classes does incur a performance cost. Built-in collections
    make some assumptions in order to achieve performance. With `UserDict`, `UserString`,
    and `UserList`, methods can’t be inlined, since you might override them. If you
    need to use these constructs in performance-critical code, make sure you benchmark
    and measure your code to find potential problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll notice that I talked about dictionaries, lists, and strings above, but
    left out one big built-in: sets. There exists no `UserSet` in the `collections`
    module. I’ll have to select a different abstraction from the `collections` module.
    More specifically, I need abstract base classes, which are found in `collections.abc`.'
  prefs: []
  type: TYPE_NORMAL
- en: As Easy as ABC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Abstract base classes (ABCs) in the `collections.abc` module provide another
    grouping of classes that you can override to create your own collections. ABCs
    are classes intended to be subclassed, and require the subclass to implement very
    specific functions. For the `collections.abc`, these ABCs are all centered on
    custom collections. In order to create a custom collection, you must override
    specific functions, depending on the type you want to emulate. Once you implement
    these required functions, though, the ABC fills in other functions automatically.
    You can find a full list of required functions to implement at the `collections.abc's`
    [module documentation](https://oreil.ly/kb8j3).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In contrast to the `User*` classes, there is no built-in storage, such as `self.data`,
    inside the `collections.abc` classes. You must provide your own storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a `collections.abc.Set`, since there is no `UserSet` elsewhere
    in collections. I want to create a custom set that automatically handles aliases
    of ingredients (such as rocket and arugula). In order to create this custom set,
    I need to implement three methods, as required by `collections.abc.Set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__contains__`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is for membership checks: `"arugula" in ingredients`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`__iter__`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is for iterating: `for ingredient in ingredients`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`__len__`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is for checking the length: `len(ingredients)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once these three methods are defined, methods like relational operations, equality
    operations, and set operations (union, intersection, difference, disjoint) will
    just work. That’s the beauty of `collections.abc`. Once you define a select few
    methods, the rest come for free. Here it is in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s not the only cool thing about `collections.abc`, though. Using it in
    type annotations can help you write more generic code. Take this code from all
    the way back in [Chapter 2](part0005_split_000.html#types):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'I talked about how duck typing can be both a boon and a curse for robst code.
    It’s great that I can write a single function that can take so many different
    types, but communicating intent through type annotations becomes challenging.
    Fortunately, I can use the `collections.abc` classes to provide type hints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this case, I am indicating that items are simply iterable through the `Iterable`
    ABC. As long as the parameter supports an `__iter__` method (and most collections
    do), this code will typecheck.
  prefs: []
  type: TYPE_NORMAL
- en: As of Python 3.9, there are 25 different ABCs for you to use. Check them all
    out in the [Python documentation](https://oreil.ly/lDeak).
  prefs: []
  type: TYPE_NORMAL
- en: Closing Thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can’t go far without running into collections in Python. Lists, dictionaries,
    and sets are commonplace, and it’s imperative that you provide hints to the future
    about what collection types you’re working with. Consider whether your collections
    are homogeneous or heterogeneous and what that tells future readers. For the cases
    where you do use heterogeneous collections, provide enough information for other
    developers to reason about them, such as a `TypedDict`. Once you learn the techniques
    to allow other developers to reason about your collections, your codebase becomes
    so much more understandable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Always think through your options when creating new collections:'
  prefs: []
  type: TYPE_NORMAL
- en: If you are just extending a type, such as adding new methods, you can subclass
    directly from collections such as a list or dictionary. However, beware the rough
    edges, as there is some surprising Python behavior if a user ever overrides a
    built-in method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are looking to change out a small part of a list, dictionary or string,
    use `collections.UserList`, `collections.UserDict`, or `collections.UserString`,
    respectively. Remember to reference `self.data` to access the storage of the respective
    type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to write a more complicated class with the interface of another
    collection type, use `collections.abc`. You will need to provide your own storage
    for the data inside the class and implement all required methods, but once you
    do, you can customize that collection to your heart’s content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussion Topic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Look through the uses of collections and generics in your codebase, and assess
    how much information is conveyed to future developers. How many custom collection
    types are in your codebase? What can a new developer tell about the collection
    types by just looking at type signatures and names? Are there collections you
    could be defining more generically? What about other types using generics?
  prefs: []
  type: TYPE_NORMAL
- en: Now, type annotations don’t reach their full potential without the aid of a
    typechecker. In the next chapter, I’m going to focus on the typechecker itself.
    You’ll learn how to effectively configure a typechecker, generate reports, and
    evaluate different checkers. The more you know about a tool, the more effectively
    you can wield it. This is especially true for your typechecker.
  prefs: []
  type: TYPE_NORMAL
