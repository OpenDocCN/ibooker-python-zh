- en: Chapter 5\. Collection Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章\. 集合类型
- en: You can’t go very far in Python without encountering *collection types*. Collection
    types store a grouping of data, such as a list of users or a lookup between restaurant
    or address. Whereas other types (e.g., `int`, `float`, `bool`, etc.) may focus
    on a single value, collections may store any arbitrary amount of data. In Python,
    you will encounter common collection types such as dictionaries, lists, and sets
    (oh, my!). Even a string is a type of collection; it contains a sequence of characters.
    However, collections can be difficult to reason about when reading new code. Different
    collection types have different behaviors.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，没有遇到*集合类型*就无法深入学习。集合类型存储数据的分组，比如用户列表或餐馆或地址之间的查找。而其他类型（例如，`int`、`float`、`bool`等）可能专注于单个值，集合可以存储任意数量的数据。在Python中，你会遇到常见的集合类型，如字典、列表和集合（哦，我的！）。甚至字符串也是一种集合类型；它包含一系列字符。然而，当阅读新代码时，理解集合类型可能会很困难。不同的集合类型有不同的行为。
- en: 'Back in [Chapter 1](part0003_split_000.html#intro), I went over some of the
    differences between the collections, where I talked about mutability, iterability,
    and indexing requirements. However, picking the right collection is just the first
    step. You must understand the implications of your collection and ensure that
    users can reason about it. You also need to recognize when the standard collection
    types aren’t cutting it and you need to roll your own. But the first step is knowing
    how to communicate your collection choices to the future. For that, we’ll turn
    to an old friend: type annotations.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾[第1章](part0003_split_000.html#intro)，我讨论了一些集合之间的差异，讨论了可变性、可迭代性和索引需求。然而，选择正确的集合只是第一步。你必须理解你的集合的影响，并确保用户可以理解它。当标准集合类型无法满足需求时，你还需要知道如何创建自定义集合。但第一步是知道如何向未来传达你的集合选择。为此，我们将转向一位老朋友：类型注解。
- en: Annotating Collections
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注释集合
- en: I’ve covered type annotations for non–collection types, and now you need to
    know how to annotate collection types. Fortunately, these annotations don’t differ
    too much from the annotations you’ve already learned.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经涵盖了非集合类型的类型注解，现在你需要知道如何注释集合类型。幸运的是，这些注解与你已经学过的注解并没有太大的不同。
- en: 'To illustrate this, suppose I’m building a digital cookbook app. I want to
    organize all my cookbooks digitally so I can search them by cuisine, ingredient,
    or author. One of the questions I might have about a cookbook collection is how
    many books from each author I have:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 举例说明，假设我正在构建一个数字食谱应用程序。我希望将所有的食谱书籍数字化，以便可以按照菜系、配料或作者搜索它们。关于食谱集合的一个问题是，我可能会问每位作者有多少本书：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This function has been annotated; it takes in a list of cookbooks and will return
    a dictionary. Unfortunately, while this tells me what collections to expect, it
    doesn’t tell me how to use the collections at all. There is nothing telling me
    what the elements inside the collection are. For instance, how do I know what
    type the cookbook is? If you were reviewing this code, how do you know that the
    use of `book.author` is legitimate? Even if you do the digging to make sure `book.author`
    is right, this code is not future-proof. If the underlying type changes, such
    as removing the `author` field, this code will break. I need a way to catch this
    with my typechecker.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数已经被注释；它接受一个食谱书籍列表，并返回一个字典。不幸的是，虽然这告诉我可以期待哪些集合，但它并没有告诉我如何使用这些集合。没有任何内容告诉我集合内部的元素是什么。例如，我怎么知道食谱书是什么类型？如果你在审查这段代码，你怎么知道使用
    `book.author` 是合法的？即使你进行了调查以确保 `book.author` 是正确的，这段代码也不具备未来的可扩展性。如果底层类型发生变化，比如移除
    `author` 字段，这段代码将会出问题。我需要一种方式来在类型检查器中捕获这一点。
- en: 'I’ll do this by encoding more information with my types by using bracket syntax
    to indicate information about the types *inside* the collection:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过使用方括号语法在我的类型中编码更多信息来做到这一点，以指示集合内部的类型信息：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: I used an alias, `AuthorToCountMapping`, to represent a `dict[str, int]`. I
    do this because I find it difficult sometimes to remember what the `str` and the
    `int` are supposed to represent. However, I do concede that this loses some information
    (readers of the code will have to find out what `AuthorToCountMapping` is an alias
    to). Ideally, your code editor can display what the underlying type is without
    you needing to look it up.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用一个别名，`AuthorToCountMapping`，来表示一个`dict[str, int]`。我这样做是因为有时我会觉得很难记住`str`和`int`应该表示什么。但是，我承认这会丢失一些信息（代码的读者将不得不找出`AuthorToCountMapping`是什么的别名）。理想情况下，你的代码编辑器可以显示出底层类型，而不需要你查找。
- en: I can indicate the exact types expected in the collection. The cookbooks list
    contains `Cookbook` objects, and the return value of the function is returning
    a dictionary mapping strings (keys) to integers (values). Note that I’m using
    a type alias to give more meaning to my return value. Mapping from a `str` to
    an `int` does not tell the user the context of the type. Instead, I create a type
    alias named `AuthorToCountMapping` to make it clear how this dictionary relates
    to the problem domain.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以指示集合中预期的确切类型。cookbooks列表包含`Cookbook`对象，并且函数的返回值返回一个字符串（键）到整数（值）的字典映射。请注意，我正在使用一个类型别名来为我的返回值提供更多含义。从`str`到`int`的映射并没有告诉用户类型的上下文。相反，我创建了一个名为`AuthorToCountMapping`的类型别名，以清楚地说明这个字典与问题域的关系。
- en: You need to think through what types are contained in the collection in order
    to be effective in type-hinting it. In order to do that, you need to think about
    homogeneous and heterogeneous collections.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地为集合进行类型提示，你需要考虑集合中包含的类型。为了做到这一点，你需要考虑同类集合和异类集合。
- en: Homogeneous Versus Heterogeneous Collections
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同类集合与异类集合
- en: '*Homogeneous collections* are collections in which every value has the same
    type. In contrast, values in *heterogeneous collections* may have different types
    within them. From a usability standpoint, your lists, sets, and dictionaries should
    nearly always be homogenous. Users need a way to reason about your collections,
    and they can’t if they don’t have the guarantee that every value is the same type.
    If you make a list, set, or dictionary a heterogeneous collection, you are indicating
    to the user that they need to take care to handle special cases. Suppose I want
    to resurrect an example from [Chapter 1](part0003_split_000.html#intro) for adjusting
    recipes for my cookbook app:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*同类集合*是指每个值都具有相同类型的集合。相比之下，*异类集合*中的值可能在其内部具有不同的类型。从可用性的角度来看，你的列表、集合和字典几乎总是应该是同类的。用户需要一种方法来推理你的集合，如果他们不能保证每个值都是相同类型的，那么他们就无法做到这一点。如果你将列表、集合或字典设为异类集合，那么你就在告诉用户他们需要注意处理特殊情况。假设我想从[第一章](part0003_split_000.html#intro)中复活一个调整配方的示例，用于我的烹饪书应用：'
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'At the time, I mentioned how parts of this code were ugly; one confounding
    factor was the fact that the first element of the recipe list was a special case:
    an integer representing the servings. This contrasts with the rest of the list
    elements, which are tuples representing actual ingredients, such as `("flour",
    1.5, "cup")`. This highlights the troubles of a heterogeneous collection. For
    every use of your collection, the user needs to remember to handle the special
    case. This is predicated on the assumption that the developer even knew about
    the special case in the first place. There’s no way as it stands to represent
    that a specific element needs to be handled differently. Therefore, a typechecker
    will not catch when a developer forgets. This leads to brittle code down the road.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当时，我提到这段代码的部分很丑陋；一个令人困惑的因素是配方列表的第一个元素是一个特殊情况：一个表示份量的整数。这与其余列表元素形成对比，其为表示实际配料的元组，比如`("面粉",
    1.5, "杯")`。这突显了异类集合的问题。对于您集合的每次使用，用户都需要记住处理特殊情况。这是建立在开发人员甚至知道特殊情况的假设的基础上的。目前没有办法表示特定元素需要以不同方式处理。因此，类型检查器不会在开发人员忘记时捕捉到。这会导致未来代码脆弱。
- en: When talking about homogeneity, it’s important to talk about what a *single
    type* means. When I mention a single type, I’m not necessarily referring to a
    concrete type in Python; rather, I’m referring to a set of behaviors that define
    that type. A single type indicates that a consumer must operate on every value
    of that type in the exact same way. For the cookbook list, the single type is
    a `Cookbook`. For the dictionary example, the key’s single type is a string and
    the value’s single type is an integer. For heterogeneous collections, this will
    not always be the case. What do you do if you must have different types in your
    collection and there is no relation between them?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到同质性时，重要的是讨论*单一类型*的含义。当我提到单一类型时，并不一定指的是 Python 中的具体类型；我指的是定义该类型的一组行为。单一类型表明消费者必须以完全相同的方式处理该类型的每个值。对于食谱列表，单一类型是`Cookbook`。对于字典示例，键的单一类型是字符串，值的单一类型是整数。对于异构集合，情况并非总是如此。如果您的集合必须具有不同的类型，并且它们之间没有关系，该怎么办？
- en: 'Consider what my ugly code from [Chapter 1](part0003_split_000.html#intro)
    communicates:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑一下我从[第 1 章](part0003_split_000.html#intro)中的丑陋代码所传达的意思：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There is a lot of information in the docstring, but docstrings have no guarantee
    of being correct. They also won’t protect developers if they accidentally break
    assumptions. This code does not communicate intention adequately to future collaborators.
    Those future collaborators won’t be able to reason about your code. The last thing
    you want to burden them with is having to go through the codebase, looking for
    invocations and implementations to work out how to use your collection. Ultimately,
    you need a way to reconcile the first element (an integer) with the remaining
    elements in the list (which are tuples). To solve this, I’ll use a `Union` (and
    some type aliases to make the code more readable):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档字符串中包含了大量信息，但文档字符串并不能保证是正确的。它们也不能保护开发者免受意外破坏假设的影响。这段代码未能充分传达未来合作者的意图。未来的合作者无法推理你的代码。你最不希望给他们的是让他们不得不查看代码库，寻找调用和实现方式来使用你的集合。最终，你需要一种方法来协调列表中的第一个元素（一个整数）与列表中剩余元素（元组）之间的关系。为了解决这个问题，我将使用一个`Union`（以及一些类型别名来使代码更易读）：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This takes a heterogeneous collection (items could be an integer or an ingredient)
    and allows developers to reason about the collection as if it were homogeneous.
    The developer needs to treat every single value as the same—it is either an integer
    or an `Ingredient`—before operating on it. While more code is needed to handle
    the typechecks, you can rest easier knowing that your typechecker will catch users
    not checking for special cases. Bear in mind, this is not perfect by any means;
    it’d be better if there was no special case in the first place and `servings`
    was passed to the function another way. But for the cases where you absolutely
    must handle special cases, represent them as a type so that the typechecker benefits
    you.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这将异构集合（项目可以是整数或成分）转换为开发者可以像处理同质集合一样推理的集合。开发者需要将每个值视为相同——它要么是整数，要么是`Ingredient`——然后再对其进行操作。虽然需要更多的代码来处理类型检查，但您可以放心，您的类型检查器将会捕获到未检查特例的用户。请记住，这并不完美；如果首次没有特例，并且`serving`可以以另一种方式传递给函数，那将更好。但对于您绝对必须处理特例的情况，请将它们表示为一种类型，以便类型检查器为您提供帮助。
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: When heterogeneous collections are complex enough that they involve lots of
    validation logic strewn about your codebase, consider making them a user-defined
    type, such as a data class or class. Consult [Part II](part0011.html#part_2) for
    more information on creating user-defined types.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当异构集合足够复杂，涉及大量验证逻辑散布在代码库中时，考虑将其作为用户定义类型，例如数据类或类。有关创建用户定义类型的更多信息，请参阅[第 II 部分](part0011.html#part_2)。
- en: You can add too many types in a `Union`, though. The more special cases of types
    you handle, the more code a developer has to write every time they use that type,
    and the more unwieldy the codebase becomes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可能会在`Union`中添加太多类型。您处理的类型特例越多，每次使用该类型时开发者需要编写的代码就越多，代码库也就变得越来越难以管理。
- en: At the far end of the spectrum lies the `Any` type. `Any` can be used to indicate
    that all types are valid in this context. This sounds appealing to get around
    special cases, but it also means that the consumers of your collection have no
    clue what to do with the values in the collection, defeating the purpose of type
    annotations in the first place.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在光谱的另一端是`Any`类型。`Any`可以用于指示在此上下文中所有类型都是有效的。这听起来很吸引人，可以避开特殊情况，但这也意味着集合的消费者不知道如何处理集合中的值，从而打败了首次使用类型注解的目的。
- en: Warning
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Developers working in a statically typed language don’t need to put in as much
    care to ensure collections are homogeneous; the static type system does that for
    them already. The challenge in Python is due to Python’s dynamically typed nature.
    It is much easier for a developer to create a heterogeneous collection without
    any warnings from the language itself.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态类型语言中工作的开发人员无需花费太多精力确保集合是同构的；静态类型系统已经为他们完成了这项工作。Python的挑战在于Python的动态类型特性。对于开发人员来说，创建一个异构集合而不受语言本身的任何警告要容易得多。
- en: Heterogeneous collection types still have a lot of uses; don’t assume that you
    should use homogeneity for every collection type because it is easier to reason
    about. Tuples, for example, are often heterogeneous.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 异构的集合类型仍然有很多用途；不要假设你应该为每种集合类型使用同构性，因为这样更容易理解。例如，元组经常是异构的。
- en: 'Suppose a tuple containing a name and page count represents a `Cookbook`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个包含名称和页数的元组表示一个`Cookbook`：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'I am describing specific fields for this tuple: name and page count. This is
    a prime example of an heterogeneous collection:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在描述此元组的特定字段：名称和页数。这是一个异构集合的典型例子：
- en: Each field (name and page count) will always be in the same order.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个字段（名称和页数）将始终按相同顺序出现。
- en: All names are strings; all page counts are integers.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有名称都是字符串；所有页数都是整数。
- en: Iterating over the tuple is rare, since I won’t treat both types the same.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很少迭代元组，因为我不会将两种类型视为相同。
- en: Name and page count are fundamentally different types, and should not be treated
    as equivalent.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称和页数是根本不同的类型，不应视为相等。
- en: 'When accessing a tuple, you will typically index to the specific field you
    want:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 访问元组时，您通常会索引到您想要的特定字段：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'However, in many codebases, tuples like these soon become burdensome. Developers
    tire of writing `cookbook[0]` whenever they want a name. A better thing to do
    would be to find some way to name these fields. A first choice might be a dictionary:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在许多代码库中，这样的元组很快就会变得繁琐。开发人员厌倦了每次想要名称时都写`cookbook[0]`。更好的做法是找到一种方法来为这些字段命名。第一选择可能是一个字典：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, they can refer to fields as `food_lab[''name'']` and `food_lab[''page_count'']`.
    The problem is, dictionaries are typically meant to be a homogeneous mapping from
    a key to a value. However, when dictionaries are used to represent data that is
    heterogeneous, you run into similar problems as above when writing a valid type
    annotation. If I want to try to use a type system to represent this dictionary,
    I end up with the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，他们可以将字段称为`food_lab['name']`和`food_lab['page_count']`。问题是，字典通常用于表示从键到值的同构映射。但是，当字典用于表示异构数据时，您会遇到与上述写有效类型注释时相似的问题。如果我想尝试使用类型系统来表示这个字典，我最终会得到以下结果：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This approach has the following problems:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法存在以下问题：
- en: Large dictionaries may have many different types of values. Writing a `Union`
    is quite cumbersome.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大字典可能有许多不同类型的值。编写一个`Union`非常麻烦。
- en: It is tedious for a user to handle every case for every dictionary access. (Since
    I indicate that the dictionary is homogeneous, I convey to developers that they
    need to treat every value as the same type, meaning typechecks for every value
    access. *I* know that the `name` is always a `str` and the `page_count` is always
    an `int`, but a consumer of this type would not know that.)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于用户来说，处理每个字典访问的每种情况都很烦琐。（因为我表明字典是同构的，我向开发人员传达了他们需要将每个值视为相同类型的信息，这意味着对每个值访问进行类型检查。*我*知道`name`总是`str`，`page_count`总是`int`，但这种类型的消费者不会知道。）
- en: Developers do not have any indication what keys are available in the dictionary.
    They must search all the code from dictionary creation time to the current access
    to see what fields have been added.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员没有任何指示字典中有哪些键。他们必须从字典创建时间到当前访问的所有代码中查找已添加的字段。
- en: As the dictionary grows, developers have a tendency to use `Any` as the type
    of the value. Using `Any` defeats the purpose of the typechecker in this case.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当字典增长时，开发者往往倾向于将值的类型用`Any`表示。在这种情况下，使用`Any`会使类型检查器失去作用。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`Any` can be used for valid type annotations; it merely indicates that you
    are making zero assumptions about what the type is. For instance, if you wanted
    to copy a list, the type signature would be `def copy(coll: list[Any]) -> list[Any]`.
    Of course, you could also do `def copy(coll: list) -> list`, and it would mean
    the same thing.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Any`可以用于有效的类型注解；它仅表示你对类型没有任何假设。例如，如果你想要复制一个列表，类型签名将是`def copy(coll: list[Any])
    -> list[Any]`。当然，你也可以这样做`def copy(coll: list) -> list`，它的含义是一样的。'
- en: These problems all stem from heterogeneous data in homogeneous data collections.
    You either pass the burden onto the caller or abandon type annotations completely.
    In some cases, you want the caller to explicitly check each type on each value
    access, but in other cases, this is overcomplicated and tedious. So, how can you
    explain your reasoning with heterogeneous types, especially in cases where keeping
    data in a dictionary is natural, such as API interactions or user-configurable
    data? For these cases, you should use a `TypedDict`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题都源于同质数据集合中的异构数据。你要么把负担转嫁给调用者，要么完全放弃类型注解。在某些情况下，你希望调用者在每次值访问时明确检查每个类型，但在其他情况下，这种方法会显得过于复杂和乏味。那么，在处理异构类型时，特别是在像
    API 交互或用户可配置数据这样自然使用字典的情况下，你该如何解释你的理由呢？对于这些情况，你应该使用`TypedDict`。
- en: TypedDict
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypedDict
- en: '`TypedDict`, introduced in Python 3.8, is for the scenarios where you absolutely
    must store heterogeneous data in a dictionary. These are typically situations
    where you can’t avoid heterogeneous data. JSON APIs, YAML, TOML, XML, and CSVs
    all have easy-to-use Python modules that convert these data formats into a dictionary
    and are naturally hetereogeneous. This means the data that gets returned has all
    the same problems as listed in the previous section. Your typechecker won’t help
    out much and users won’t know what keys and values are available.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`TypedDict`，引入于 Python 3.8，用于必须在字典中存储异构数据的场景。这些通常是你无法避免异构数据的情况。JSON API、YAML、TOML、XML
    和 CSV 都有易于使用的 Python 模块，可以将这些数据格式转换为字典，并且自然是异构的。这意味着返回的数据具有前面章节列出的所有问题。你的类型检查器帮不上忙，用户也不知道可用的键和值是什么。'
- en: Tip
  id: totrans-54
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you have full control of the dictionary, meaning you create it in code you
    own and handle it in code you own, you should consider using a `dataclass` (see
    [Chapter 9](part0013_split_000.html#dataclasses)) or a `class` (see [Chapter 10](part0014_split_000.html#classes))
    instead.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你完全控制字典，即你在自己的代码中创建它并在自己的代码中处理它，你应该考虑使用`dataclass`（见[第9章](part0013_split_000.html#dataclasses)）或`class`（见[第10章](part0014_split_000.html#classes)）。
- en: 'For example, suppose I want to augment my digital cookbook app to provide nutritional
    information for the recipes listed. I decide to use the [Spoonacular API](https://oreil.ly/joTNh)
    and write some code to get nutritional information:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我想扩展我的数字食谱应用程序，以提供列出的食谱的营养信息。我决定使用[Spoonacular API](https://oreil.ly/joTNh)，并编写一些代码来获取营养信息：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you were reviewing the code, how would you know that this code is right?
    If you wanted to also print out the calories, how do you access the data? What
    guarantees do you have about the fields inside of this dictionary? To answer these
    questions, you have two options:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在审查代码，你如何知道这段代码是正确的？如果你还想打印卡路里，你如何访问这些数据？你对这个字典内部字段有什么保证？要回答这些问题，你有两个选择：
- en: Look up the API documentation (if any) and confirm that the right fields are
    being used. In this scenario, you hope that the documentation is actually complete
    and correct.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查阅 API 文档（如果有的话），确认是否使用了正确的字段。在这种情况下，你希望文档实际上是完整和正确的。
- en: Run the code and print out the returned dictionary. In this situation, you hope
    that test responses are pretty identical to production responses.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行代码并打印返回的字典。在这种情况下，你希望测试响应与生产响应基本相同。
- en: The problem is that you are requiring every reader, reviewer, and maintainer
    to do one of these two steps in order to understand the code. If they don’t, you
    will not get good code review feedback and developers will run the risk of using
    the response incorrectly. This leads to incorrect assumptions and brittle code.
    `TypedDict` allows you to encode what you’ve learned about that API directly into
    your type system.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，你要求每个读者、审阅者和维护者必须执行这两个步骤之一才能理解代码。如果他们没有这样做，你将得不到良好的代码审查反馈，开发者将冒着使用响应不正确的风险。这会导致错误的假设和脆弱的代码。`TypedDict`允许你直接将你对API的了解编码到你的类型系统中。
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now it is incredibly apparent exactly what data types you can rely upon. If
    the API ever changes, a developer can update all the `TypedDict` classes and let
    the typechecker catch any incongruities. Your typechecker now completely understands
    your dictionary, and readers of your code can reason about responses without having
    to do any external searching.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在非常明显，你可以依赖哪些数据类型。如果API有所更改，开发者可以更新所有`TypedDict`类，并让类型检查器捕捉到任何不一致之处。你的类型检查器现在完全理解你的字典，代码的读者可以在不进行任何外部搜索的情况下推理出响应。
- en: Even better, these `TypedDict` collections can be as arbitrarily complex as
    you need them to be. You’ll see that I nested `TypedDict` instances for reusability
    purposes, but you can also embed your own custom types, `Unions`, and `Optionals`
    to reflect the possibilities that an API can return. And while I’ve mostly been
    talking about API, remember that these benefits apply to any heterogeneous dictionary,
    such as when reading JSON or YAML.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，这些`TypedDict`集合可以随意复杂化，以满足你的需求。你会看到我嵌套了`TypedDict`实例以提高复用性，但你也可以嵌入自己的自定义类型、`Union`和`Optional`，以反映API可能返回的情况。虽然我大多数时候在谈论API，但请记住，这些好处适用于任何异质字典，比如读取JSON或YAML时。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`TypedDict` is only for the typechecker’s benefit. There is no runtime validation
    at all; the runtime type is just a dictionary.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`TypedDict`仅用于类型检查器的利益。完全没有运行时验证；运行时类型只是一个字典。'
- en: 'So far, I’ve been teaching you how to deal with built-in collection types:
    lists/sets/dictionaries for homogeneous collections and tuples/`TypedDict` for
    heterogenous collections. What if these types don’t do *everything* that you want?
    What if you want to create new collections that are easy to use? To do that, you’ll
    need a new set of tools.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我教你如何处理内置的集合类型：列表/集合/字典用于同质集合，元组/`TypedDict`用于异质集合。如果这些类型不能满足你的*所有*需求呢？如果你想创建易于使用的新集合呢？为此，你需要一套新的工具。
- en: Creating New Collections
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新集合
- en: 'When writing a new collection, you should ask yourself: am I trying to write
    a new collection that isn’t representable by another collection type, or am I
    trying to modify an existing collection to provide some new behavior? Depending
    on the answer, you may need to employ different techniques to achieve your goal.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当你要编写一个新的集合时，你应该问自己：我是想编写一个无法用其他集合类型表示的新集合，还是想修改一个现有集合以提供一些新的行为？根据答案的不同，你可能需要采用不同的技术来实现你的目标。
- en: If you write a collection type that isn’t representable by another collection
    type, you are bound to come across *generics* at some point.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写了一个无法用其他集合类型表示的集合类型，你在某个时候必然会遇到*泛型*。
- en: Generics
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型
- en: A generic type indicates that you don’t care what type you are using. However,
    it helps restrict users from mixing types where inappropriate.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型表示你不关心使用什么类型。然而，它有助于阻止用户在不合适的地方混合类型。
- en: 'Consider the innocuous reverse list function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个无害的反转列表函数：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'How do I indicate that the returned list should contain the same type as the
    passed-in list? To achieve this, I use a generic, which is done with a `TypeVar`
    in Python:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我如何表明返回的列表应该包含与传入列表相同类型的类型？为了实现这一点，我使用了一个泛型，在Python中使用`TypeVar`来实现：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This says that for a type `T`, reverse takes in a list of elements of type
    `T` and returns a list of elements of type `T`. I can’t mix types: a list of integers
    will never be able to become a list of strings if those lists aren’t using the
    same `TypeVar`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着对于类型`T`，`reverse`接受一个类型为`T`的元素列表，并返回一个类型为`T`的元素列表。我不能混合类型：如果这些列表没有使用相同的`TypeVar`，那么整数列表永远无法变成字符串列表。
- en: 'I can use this sort of pattern to define entire classes. Suppose I want to
    integrate a cookbook recommender service into the cookbook collection app. I want
    to be able to recommend cookbooks or recipes based on a customer’s ratings. To
    do this, I want to store each of these pieces of rating information in a *graph*.
    A graph is a data structure that contains a series of entities known as *nodes*
    and that tracks *edges* (relationships between those nodes). However, I don’t
    want to write separate code for a cookbook graph and a recipe graph. So I define
    a `Graph` class that can be used for generic types:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用这种模式来定义整个类。假设我想将一个烹饪书推荐服务集成到烹饪集合应用程序中。我想要根据客户的评分推荐烹饪书或食谱。为此，我想将每个这些评分信息存储在一个*图*中。图是一种包含一系列实体（称为*节点*）并跟踪*边*（这些节点之间的关系）的数据结构。但是，我不想为烹饪图和食谱图编写单独的代码。因此，我定义了一个可以用于通用类型的`Graph`类：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With this code, I can define all sorts of graphs and still have them typecheck
    successfully:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，我可以定义各种类型的图并且仍然可以成功进行类型检查：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Whereas this code does not typecheck:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 而这段代码无法进行类型检查：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using generics can help you write collections that use types consistently throughout
    their lifetime. This reduces the amount of duplication in your codebase, which
    minimizes the chances of bugs and reduces cognitive burden.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用泛型可以帮助您编写在其整个生命周期中一致使用类型的集合。这减少了代码库中的重复量，从而减少了错误的机会并减轻了认知负担。
- en: Modifying Existing Types
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改现有类型
- en: Generics are nice for creating your own collection types, but what if you just
    want to tweak some behavior of an existing collection type, such as a list or
    dictionary? Having to completely rewrite all the semantics of a collection would
    be tedious and error-prone. Thankfully, methods exist to make this a snap. Let’s
    go back to our cookbook app. I’ve written code earlier that grabs nutrition information,
    but now I want to store all that nutrition information in a dictionary.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型非常适合创建自己的集合类型，但是如果您只想调整现有集合类型（例如列表或字典）的某些行为怎么办？完全重新编写集合的所有语义将是乏味且容易出错的。幸运的是，存在可以轻松完成这项工作的方法。让我们回到我们的烹饪应用程序。我之前写过代码来获取营养信息，但现在我想将所有这些营养信息存储在一个字典中。
- en: 'However, I hit a problem: the same ingredient has very different names depending
    on where you’re from. Take a dark leafy green, common in salads. While an American
    chef might call it “arugula,” a European might call it “rocket.” This doesn’t
    even begin to cover the names in languages other than English. To combat this,
    I want to create a dictionary-like object that automatically handles these aliases:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我遇到了一个问题：同一种成分在不同地方具有非常不同的名称。以沙拉中常见的深色叶绿素为例。美国厨师可能称之为“火箭”，而欧洲厨师可能称之为“火箭菜”。这甚至还不包括除英语以外的其他语言中的名称。为了应对这个问题，我想创建一个类似字典的对象，可以自动处理这些别名：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So how can I write `NutritionalInformation` to act like a dict?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我如何让`NutritionalInformation`的行为像字典一样呢？
- en: 'A lot of a developer’s first instinct is to subclass dictionaries. No worries
    if you aren’t awesome at subclassing; I’ll be going much more in depth in [Chapter 12](part0016_split_000.html#subtyping).
    For now, just treat subclassing as a way of saying, “I want my subclass to behave
    exactly like the parent class.” However, you’ll learn that subclassing a dictionary
    may not always be what you want. Consider the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发人员的第一反应是对字典进行子类化。如果您对子类化不是很擅长也不用担心；我将在[第12章](part0016_split_000.html#subtyping)中更加深入地讨论这个问题。目前，只需将子类化视为一种表达“我希望我的子类的行为与父类完全相同”的方式即可。但是，您将会发现，子类化字典可能并不总是您想要的。考虑以下代码：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](../images/00002.gif)](part0008_split_006.html#co_collection_types_CO1-1)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](../images/00002.gif)](part0008_split_006.html#co_collection_types_CO1-1)'
- en: The `(dict)` syntax indicates that we are subclassing from dictionaries.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`(dict)`语法表示我们正在从字典进行子类化。'
- en: '[![2](../images/00005.gif)](part0008_split_006.html#co_collection_types_CO1-2)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](../images/00005.gif)](part0008_split_006.html#co_collection_types_CO1-2)'
- en: '`__getitem__` is what gets called when you use brackets to check a key in a
    dictionary: (`nutrition["rocket"]`) calls `__getitem__(nutrition, "rocket")`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`__getitem__`是在字典中使用括号检查键时调用的方法：(`nutrition["rocket"]`)调用 `__getitem__(nutrition,
    "rocket")`。'
- en: '[![3](../images/00006.gif)](part0008_split_006.html#co_collection_types_CO1-3)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](../images/00006.gif)](part0008_split_006.html#co_collection_types_CO1-3)'
- en: If a key is found, use the parent dictionary’s key check.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到键，则使用父字典的键检查。
- en: '[![4](../images/00007.gif)](part0008_split_006.html#co_collection_types_CO1-4)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](../images/00007.gif)](part0008_split_006.html#co_collection_types_CO1-4)'
- en: For every alias, check if it is in the dictionary.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个别名，请检查它是否在字典中。
- en: '[![5](../images/00008.gif)](part0008_split_006.html#co_collection_types_CO1-5)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](../images/00008.gif)](part0008_split_006.html#co_collection_types_CO1-5)'
- en: Throw a `KeyError` if no key is found, either with what’s passed in or any of
    its aliases.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到键或其任何别名，则抛出`KeyError`异常。
- en: We are overriding the `__getitem__` function, and this works!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在重写`__getitem__`函数，这样就可以了！
- en: If I try to access `nutrition["rocket"]` in that snippet above, I get the same
    nutritional information as `nutrition["arugula"]`. Huzzah! So you deploy it in
    production and call it a day.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我尝试在上面的片段中访问`nutrition["rocket"]`，我将获得与`nutrition["arugula"]`相同的营养信息。太棒了！于是你将其部署到生产环境，并算是一天结束了。
- en: But (and there’s always a but), as time goes on, a developer comes to you and
    complains that sometimes the dictionary doesn’t work. You spend some time debugging,
    and it always works for you. You look for race conditions, threading, API tomfoolery,
    or any other nondeterminism, and come up with absolutely zero potential bugs.
    Finally, you get some time where you can sit with the other developer and see
    what they are doing.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 但是（总会有个但是），随着时间的推移，一位开发人员向你抱怨说有时字典不起作用。你花了些时间进行调试，但是它对你来说总是有效的。你寻找竞态条件、线程问题、API问题或任何其他非确定性因素，但却完全找不到潜在的错误。最终，你找到了一些时间可以和另一位开发人员坐下来看看他们在做什么。
- en: 'And sitting at their terminal are the following lines:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在他们的终端上显示以下行：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `get` function on a dictionary tries to get the key, and if not found,
    will return the second argument (in this case “No Ingredient Found”). Herein lies
    the problem: when subclassing from a dictionary and overriding methods, you have
    no guarantee that those methods are called from every other method in the dictionary.
    Built-in collection types are built with performance in mind; many methods use
    inlined code to go fast. This means that overriding one method, such as `__getitem__`,
    will not be used in most dictionary methods. This certainly violates the Law of
    Least Surprise, which we talked about in [Chapter 1](part0003_split_000.html#intro).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 字典上的`get`函数尝试获取键，如果找不到，则返回第二个参数（在本例中是“No Ingredient Found”）。这里出现了问题：当从字典派生并重写方法时，你无法保证其他方法在字典中调用这些方法。内置集合类型的设计考虑了性能；许多方法使用内联代码以提高速度。这意味着重写一个方法（如`__getitem__`）将不会被大多数字典方法使用。这显然违反了最小惊讶法则，我们在第一章中讨论过这一点。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It is OK to subclass from the built-in collection if you are only adding methods,
    but because future modifications may make this same mistake, I still prefer to
    use one of the other methods of building custom collections.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仅添加方法，则可以从内置集合类继承，但是因为将来的修改可能会犯同样的错误，我仍然更喜欢使用其他一种方法来构建自定义集合。
- en: 'So overriding `dict` is out. Instead I’ll use types from the `collections`
    module. For this case, there is a handy type called `collections.UserDict`. `UserDict`
    fits the exact use case that I need: I can subclass from `UserDict`, override
    key methods, and get the behavior I expect.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，覆盖`dict`是不行的。我将使用`collections`模块中的类型。在这种情况下，有一个便利的类型叫做`collections.UserDict`。`UserDict`正好符合我需要的用例：我可以从`UserDict`派生，重写关键方法，并获得我期望的行为。
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This fits your use case exactly. You subclass from `UserDict` instead of `dict`,
    and then use `self.data` to access the underlying dictionary.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这正好符合你的使用场景。你应该从`UserDict`而不是`dict`派生，然后使用`self.data`来访问底层字典。
- en: 'You go run your teammate’s code again:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你再次运行你同事的代码：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: And you get the nutrition information for arugula.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以获取芝麻菜的营养信息。
- en: '`UserDict` isn’t the only collection type that you can override in this case.
    There also is a `UserString` and a `UserList` in the collections model. Anytime
    you want to tweak a dictionary, string, or list, these are the collections you
    want to use.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`UserDict`并不是你可以重写的唯一集合类型。`collections`模块中还有`UserString`和`UserList`。每当你想要调整字典、字符串或列表时，这些集合就派上用场了。
- en: Warning
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Inheriting from these classes does incur a performance cost. Built-in collections
    make some assumptions in order to achieve performance. With `UserDict`, `UserString`,
    and `UserList`, methods can’t be inlined, since you might override them. If you
    need to use these constructs in performance-critical code, make sure you benchmark
    and measure your code to find potential problems.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些类继承确实会增加性能成本。内置集合做了一些假设以实现性能优化。对于`UserDict`、`UserString`和`UserList`，方法无法内联，因为你可能会重写它们。如果你需要在性能关键代码中使用这些结构，请确保进行基准测试和测量，找出潜在问题。
- en: 'You’ll notice that I talked about dictionaries, lists, and strings above, but
    left out one big built-in: sets. There exists no `UserSet` in the `collections`
    module. I’ll have to select a different abstraction from the `collections` module.
    More specifically, I need abstract base classes, which are found in `collections.abc`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，我上面谈到了字典、列表和字符串，但是遗漏了一个重要的内置类型：集合。在 `collections` 模块中不存在 `UserSet`。我将不得不从
    `collections.abc` 中选择一个不同的抽象。更具体地说，我需要抽象基类，这些基类位于 `collections.abc` 中。
- en: As Easy as ABC
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ABC 就这么简单
- en: Abstract base classes (ABCs) in the `collections.abc` module provide another
    grouping of classes that you can override to create your own collections. ABCs
    are classes intended to be subclassed, and require the subclass to implement very
    specific functions. For the `collections.abc`, these ABCs are all centered on
    custom collections. In order to create a custom collection, you must override
    specific functions, depending on the type you want to emulate. Once you implement
    these required functions, though, the ABC fills in other functions automatically.
    You can find a full list of required functions to implement at the `collections.abc's`
    [module documentation](https://oreil.ly/kb8j3).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections.abc` 模块中的抽象基类（ABC）提供了另一组可以重写以创建自定义集合的类。ABC 是打算作为子类化的类，并要求子类实现非常具体的函数。对于
    `collections.abc`，这些 ABC 都围绕着自定义集合展开。为了创建自定义集合，您必须覆盖特定的函数，具体取决于您想要模拟的类型。一旦实现了这些必需的函数，ABC
    就会自动填充其他函数。您可以在 `collections.abc` 的[模块文档](https://oreil.ly/kb8j3)中找到要实现的全部必需函数列表。'
- en: Note
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: In contrast to the `User*` classes, there is no built-in storage, such as `self.data`,
    inside the `collections.abc` classes. You must provide your own storage.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `User*` 类不同，`collections.abc` 类中没有内置存储，如 `self.data`。您必须提供自己的存储。
- en: 'Let’s look at a `collections.abc.Set`, since there is no `UserSet` elsewhere
    in collections. I want to create a custom set that automatically handles aliases
    of ingredients (such as rocket and arugula). In order to create this custom set,
    I need to implement three methods, as required by `collections.abc.Set`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个 `collections.abc.Set`，因为在 `collections` 中没有 `UserSet`。我想创建一个自定义集合，自动处理成分的别名（如
    rocket 和 arugula）。为了创建此自定义集合，我需要按照 `collections.abc.Set` 的要求实现三种方法：
- en: '`__contains__`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`__contains__`'
- en: 'This is for membership checks: `"arugula" in ingredients`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 用于成员检查：`"arugula" in ingredients`。
- en: '`__iter__`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`__iter__`'
- en: 'This is for iterating: `for ingredient in ingredients`.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 用于迭代：`for ingredient in ingredients`。
- en: '`__len__`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`__len__`'
- en: 'This is for checking the length: `len(ingredients)`.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 用于检查长度：`len(ingredients)`。
- en: 'Once these three methods are defined, methods like relational operations, equality
    operations, and set operations (union, intersection, difference, disjoint) will
    just work. That’s the beauty of `collections.abc`. Once you define a select few
    methods, the rest come for free. Here it is in action:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了这三种方法，像关系操作、相等操作和集合操作（并集、交集、差集、不相交）等方法就能正常工作。这就是 `collections.abc` 的美妙之处。一旦定义了少数几个方法，其他方法就会自动补充。它在这里得以实现：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'That’s not the only cool thing about `collections.abc`, though. Using it in
    type annotations can help you write more generic code. Take this code from all
    the way back in [Chapter 2](part0005_split_000.html#types):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections.abc` 的另一个酷炫之处在于，使用它进行类型注释可以帮助你编写更通用的代码。回到[第二章](part0005_split_000.html#types)中的这段代码：'
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'I talked about how duck typing can be both a boon and a curse for robst code.
    It’s great that I can write a single function that can take so many different
    types, but communicating intent through type annotations becomes challenging.
    Fortunately, I can use the `collections.abc` classes to provide type hints:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我谈到了鸭子类型如何成为可靠代码的福音和诅咒。能够编写一个可以接受多种不同类型的单一函数是很棒的，但是通过类型注释来传达意图变得具有挑战性。幸运的是，我可以使用
    `collections.abc` 类来提供类型提示：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this case, I am indicating that items are simply iterable through the `Iterable`
    ABC. As long as the parameter supports an `__iter__` method (and most collections
    do), this code will typecheck.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我指出项目仅通过 `Iterable` ABC 可迭代。只要参数支持 `__iter__` 方法（大多数集合都支持），此代码将进行类型检查。
- en: As of Python 3.9, there are 25 different ABCs for you to use. Check them all
    out in the [Python documentation](https://oreil.ly/lDeak).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Python 3.9 起，有 25 种不同的 ABC 可供使用。在 [Python 文档](https://oreil.ly/lDeak) 中查看它们的全部内容。
- en: Closing Thoughts
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: You can’t go far without running into collections in Python. Lists, dictionaries,
    and sets are commonplace, and it’s imperative that you provide hints to the future
    about what collection types you’re working with. Consider whether your collections
    are homogeneous or heterogeneous and what that tells future readers. For the cases
    where you do use heterogeneous collections, provide enough information for other
    developers to reason about them, such as a `TypedDict`. Once you learn the techniques
    to allow other developers to reason about your collections, your codebase becomes
    so much more understandable.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，少不了与集合打交道。列表、字典和集合很常见，因此向未来提供关于你正在使用的集合类型的提示是至关重要的。考虑你的集合是同质的还是异质的，以及这对未来的读者有何启发。对于使用异质集合的情况，提供足够的信息让其他开发者能够推理，比如`TypedDict`。一旦学会了让其他开发者理解你的集合的技巧，你的代码库将变得更加易读。
- en: 'Always think through your options when creating new collections:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新集合时，务必仔细考虑各种选择：
- en: If you are just extending a type, such as adding new methods, you can subclass
    directly from collections such as a list or dictionary. However, beware the rough
    edges, as there is some surprising Python behavior if a user ever overrides a
    built-in method.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你只是在扩展类型，比如添加新方法，可以直接从集合（如列表或字典）派生子类。然而，要注意粗糙的边缘，因为如果用户覆盖了内置方法，Python会有一些出人意料的行为。
- en: If you are looking to change out a small part of a list, dictionary or string,
    use `collections.UserList`, `collections.UserDict`, or `collections.UserString`,
    respectively. Remember to reference `self.data` to access the storage of the respective
    type.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要更改列表、字典或字符串中的一小部分，请分别使用`collections.UserList`、`collections.UserDict`或`collections.UserString`。记得引用`self.data`来访问相应类型的存储。
- en: If you need to write a more complicated class with the interface of another
    collection type, use `collections.abc`. You will need to provide your own storage
    for the data inside the class and implement all required methods, but once you
    do, you can customize that collection to your heart’s content.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要编写接口与其他集合类型相似的更复杂的类，请使用`collections.abc`。你需要为类内部的数据提供自己的存储，并实现所有必需的方法，但一旦完成，你可以根据心情自定义该集合。
- en: Discussion Topic
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论主题
- en: Look through the uses of collections and generics in your codebase, and assess
    how much information is conveyed to future developers. How many custom collection
    types are in your codebase? What can a new developer tell about the collection
    types by just looking at type signatures and names? Are there collections you
    could be defining more generically? What about other types using generics?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 查看代码库中对集合和泛型的使用情况，并评估向未来开发者传达了多少信息。你的代码库中有多少自定义的集合类型？新开发者只需查看类型签名和名称就能了解集合类型的多少信息？你是否可以更通用地定义一些集合？其他类型是否可以使用泛型？
- en: Now, type annotations don’t reach their full potential without the aid of a
    typechecker. In the next chapter, I’m going to focus on the typechecker itself.
    You’ll learn how to effectively configure a typechecker, generate reports, and
    evaluate different checkers. The more you know about a tool, the more effectively
    you can wield it. This is especially true for your typechecker.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，类型注解没有一个类型检查器的帮助就无法充分发挥其潜力。在接下来的章节中，我将专注于类型检查器本身。你将学会如何有效地配置类型检查器、生成报告并评估不同的检查器。你了解的工具越多，就能越有效地使用它。对于你的类型检查器来说，这一点尤为重要。
