- en: Chapter 22\. Acceptance Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a developer, it is easy to focus on the tests that directly surround your
    codebase: unit tests, integration tests, UI tests, and the like. These tests verify
    that the code is doing what you intend. They are an invaluable tool to keep your
    codebase regression free. They are also completely the *wrong* tool for building
    what a customer expects.'
  prefs: []
  type: TYPE_NORMAL
- en: Developers write these tests with full knowledge of the code, which means the
    tests are biased toward that developer’s expectations. There is no guarantee that
    this tested behavior is actually what the *customer* wants, though.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This test might be airtight; it passes and catches any regression made in the
    code. However, when presented to a customer, you might be confronted with: “No,
    I wanted Texas-style chili! You know, no tomatoes or beans?” All the unit tests
    in the world won’t save you from building the wrong thing.'
  prefs: []
  type: TYPE_NORMAL
- en: This is where acceptance testing comes in. *Acceptance tests* check that you
    are building the correct product. While unit tests and integration tests are a
    form of *verification*, acceptance tests are *validation*. They validate that
    you are building what the user expects.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about acceptance testing in Python. I’ll show
    you the `behave` framework, which uses the Gherkin language to define requirements
    in a whole new fashion.^([1](part0028_split_012.html#idm45644725935272)) You’ll
    walk through behavior-driven development (BDD) as a tool to clarify conversations.
    Acceptance testing is a crucial part of building a safety net; it will protect
    you from building the wrong thing.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior-Driven Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The mismatch between customer expectations and software behavior is as old as
    software development. The problem stems from translating natural language to programming
    language. Natural language is rife with ambiguities, inconsistencies, and nuance.
    Programming languages are rigid. The computer does exactly what you tell it to
    do (even if it’s not what you meant). Even worse, it’s like a game of Telephone^([2](part0028_split_012.html#idm45644725926616))
    as the requirements get passed through a few people (customers, sales, managers,
    testers) before the test is ever written.
  prefs: []
  type: TYPE_NORMAL
- en: As with everything in the software life cycle, this error case only gets more
    costly the longer it takes to fix. Ideally, you want to find out these issues
    as you’re coming up with user requirements. This is where behavior-driven development
    comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: The Gherkin Language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Behavior-driven development*, first pioneered by [Daniel Terhorst-North](https://oreil.ly/MnziJ),
    is a practice that focuses on defining the behaviors in your system. BDD focuses
    on clarifying communications; you iterate over the requirements with the end user,
    defining the behaviors they want.'
  prefs: []
  type: TYPE_NORMAL
- en: Before you write a single lick of code, you make sure that you have agreement
    on what the right thing to build is. The set of defined behaviors will *drive*
    what code you write. You work with the end user (or their proxy, such as a business
    analyst or product manager) to define your requirements as a specification. These
    specifications follow a formal language, to introduce a bit more rigidity in their
    definition. One of the most common languages for specifying requirements is Gherkin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gherkin is a specification that follows the *Given-When-Then* (GWT) format.
    Every requirement is organized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, if I wanted to capture a requirement that checks for vegan substitution
    of a dish, I would write it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Another requirement might be that certain dishes can’t be made vegan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If the GWT format feels familiar, that’s because it’s identical to the AAA test
    organization you learned about in [Chapter 21](part0027_split_000.html#testing_strategy).
  prefs: []
  type: TYPE_NORMAL
- en: 'By working with your end users to write your requirements in this fashion,
    you benefit from a few key principles:'
  prefs: []
  type: TYPE_NORMAL
- en: Write using plain language
  prefs: []
  type: TYPE_NORMAL
- en: There’s no need to delve into any programming languages or formal logic. Everything
    is written in a form that is intelligible to both business people and developers.
    This makes it incredibly easy to home in on what the end user actually wants.
  prefs: []
  type: TYPE_NORMAL
- en: Build a shared vocabulary
  prefs: []
  type: TYPE_NORMAL
- en: As the number of requirements increases, you find that you start having the
    same clauses in multiple requirements (see above with `When I ask for vegan substitutions`).
    This builds up your domain language and will make it easier for all involved parties
    to understand the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements are testable
  prefs: []
  type: TYPE_NORMAL
- en: 'This is probably the biggest benefit of this requirement format. Because you
    are writing the requirement as GWT, you are inherently specifying an acceptance
    test to write. With the chili example used in this chapter, imagine if the Gherkin
    test was specified as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It becomes much clearer what tests need to be written to act as acceptance
    tests. If the Gherkin test has any ambiguities, you can work with the end user
    to figure out what a concrete test should be. This can also help with traditionally
    vague requirements such as, “The Chili-Making Machine should be fast.” Instead,
    by focusing on a concrete test, you end up with a test like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: These requirements specifications are not a silver bullet to eliminate bugs
    in requirements. They are instead a mitigation strategy. If you have technical
    and business people review them before code is written, you will have a better
    chance of discovering ambiguities or mismatched intentions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you start defining your tests in Gherkin, you can do something awesome:
    you can make your specifications *executable*.'
  prefs: []
  type: TYPE_NORMAL
- en: Executable Specifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Executable specifications* translate a set of requirements directly to code.
    This means that not only are your requirements *testable*, but they are *tests*
    as well. When the requirements change, your tests will change at the same time.
    This is the ultimate form of *traceability*, or the ability to connect your requirements
    to specific tests or code.'
  prefs: []
  type: TYPE_NORMAL
- en: Discussion Topic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does your organization track requirements? How do you trace those requirements
    to test cases? How do you handle requirements changing? Discuss how your processes
    would change if your requirements and tests were the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: The Python module [`behave`](https://oreil.ly/VywJX) allows you to back your
    Gherkin requirements with concrete tests. It does so by associating functions
    with specific clauses in the requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: By default, `behave` expects your Gherkin files to be in a folder called *features*
    and your Python functions (called steps) to be in a folder called *features/steps*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the first Gherkin requirement I showed earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With `behave`, I can write Python code that maps to each of these GWT statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Each step is represented as a decorator that matches the clause of the Gherkin
    requirement. The decorated function is what gets executed as part of the specification.
    In the above example, the Gherkin requirement would be represented by the following
    code (you do not have to write this; Gherkin does it for you):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To run this, first install `behave`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run `behave` on the folder containing your requirements and steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following as output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When this code is run in a terminal or an IDE, all the steps show up as green.
    If any step fails, the step turns red and you get a stack trace of what went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can tie your requirements directly to your acceptance tests. If an end
    user changes their mind, they can write a new test. If the GWT clause already
    exists for the new tests, that’s a win; new tests can be written without the help
    of a developer. If the clauses do not already exist, that’s also a win, because
    it kick-starts a conversation when the test immediately fails. Your end users
    and your business people need no Python knowledge to understand what you are testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the Gherkin specifications to drive conversations about the software that
    you need to build. `behave` allows you to tie your acceptance tests directly to
    these requirements, and they serve as a way of focusing conversations. Using BDD
    prevents you from jumping right into coding the wrong thing. As the popular saying
    goes: “Weeks of coding will save you hours of planning.”^([3](part0028_split_012.html#idm45644725698696))'
  prefs: []
  type: TYPE_NORMAL
- en: Additional behave Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous example was a bit bare-bones, but thankfully, `behave` provides
    some extra features to make test writing even easier.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterized Steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may have noticed that I have two `Given` steps that are very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It’d be silly to write two similar functions to link this in Python. `behave`
    lets you parameterize the steps to reduce the need for writing multiple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can stack clauses on a function if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Parameterizing and reusing steps will help you build up vocabulary that is intuitive
    to use, which will reduce the cost of writing Gherkin tests.
  prefs: []
  type: TYPE_NORMAL
- en: Table-Driven Requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 21](part0027_split_000.html#testing_strategy), I mentioned how
    you can parameterize tests so that all your pre-conditions and assertions are
    defined in a table. `behave` offers something very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`behave` will automatically run a test for each table entry. This is a great
    way to run the same test on very similar data.'
  prefs: []
  type: TYPE_NORMAL
- en: Step Matching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, the basic decorators don’t have enough flexibility to capture what
    you are trying to express. You can tell `behave` to use regular expression parsing
    in your decorators. This is useful to make the Gherkin specifications feel more
    natural to write (especially getting around complex data formats or wonky grammar
    issues). Here’s an example that allows you to specify dishes with an optional
    “a” or “an” beforehand (so that dish names can be simplified).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Customizing the Test Life Cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you need to run code before or after your tests run. Say you need
    to set up a database before all the specifications are set, or tell a service
    to clear its cache between test runs. Just like `setUp` and `tearDown` in the
    built-in `unittest` module, `behave` offers functions that let you hook in functions
    before or after steps, features, or the entire test run. Use this to consolidate
    common setup code. To take full advantage of this functionality, you can define
    specifically named functions in a file named *environment.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Check out the [`behave` documentation](https://oreil.ly/NjEtf) for more information
    on controlling your environment. If you are more comfortable with `pytest` fixtures,
    check out `behave` [fixtures](https://oreil.ly/6ZZA4) for very similar ideas.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Functions like `before_feature` and `before_scenario` get the feature or scenario,
    respectively, passed to them. You can key off the names of these features and
    scenarios to do specific actions for specific parts of your tests.
  prefs: []
  type: TYPE_NORMAL
- en: Using Tags to Selectively Run Tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`behave` also offers the ability to tag certain tests with arbitrary text.
    These tags can be anything you want: `@wip` for work in progress, `@slow` for
    slow running tests, `@smoke` for a select few tests for running on each check-in,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To tag a test in `behave`, just decorate your Gherkin scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To run just tests with a specific tag, you can pass a `--tags` flag to your
    `behave` invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you’d like to exclude tests from being run, prefix the tags with a hyphen,
    as seen in this example where I exclude tests tagged with `wip` from being run:'
  prefs: []
  type: TYPE_NORMAL
- en: '`behave code_examples/chapter22 --tags=-wip`'
  prefs: []
  type: TYPE_NORMAL
- en: Report Generation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using `behave` and BDD to drive your acceptance testing will not pay off if
    you are not involving your end users or their proxies. Find ways to make it easy
    for them to understand and use the Gherkin requirements.
  prefs: []
  type: TYPE_NORMAL
- en: You can get a list of all step definitions by invoking `behave --steps-catalog`.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you also need a way of showing test results to give your end users
    an idea of what is working and what is not. `behave` lets you format outputs in
    a variety of different ways (and you can define your own). Out of the box, there
    is also the ability to create reports from [JUnit](https://junit.org/junit5),
    a unit-testing framework designed for the Java language. JUnit writes its test
    results as a XML file, and a lot of tools were built to ingest and visualize the
    test results.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate a JUnit test report, you can pass `--junit` to your `behave` invocation.
    Then, you can use a tool [`junit2html`](https://github.com/inorton/junit2html)
    to get a report for all of your test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: An example output is shown in [Figure 22-1](part0028_split_011.html#behave_output).
  prefs: []
  type: TYPE_NORMAL
- en: '![ropy 2201](../images/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 22-1\. Example `behave` report with `junit2html`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are plenty of JUnit report generators, so look around for one you like
    and use it to produce HTML reports of your test results.
  prefs: []
  type: TYPE_NORMAL
- en: Closing Thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If all your tests pass but don’t deliver what the end user wants, you have wasted
    time and effort. It is costly to build the right thing; you want to try and get
    it right the first time. Use BDD to drive crucial conversations about the requirements
    for your system. Once you have requirements, use `behave` and the Gherkin language
    to write acceptance tests. These acceptance tests become your safety net for ensuring
    that you deliver what the end user wants.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll continue to learn how to repair holes in your safety
    net. You’ll learn about property-based testing with a Python tool called `Hypothesis`.
    It can generate test cases for you, including tests you might never have thought
    of. You can rest easier knowing that your tests have broader coverage than ever
    before.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](part0028_split_000.html#idm45644725935272-marker)) The Gherkin language
    was created by Aslak Hellesøy. His wife suggested that his BDD testing tool be
    named Cucumber (apparently for no specific reason), and he wanted to distinguish
    the specfication language from the testing tool itself. Since a gherkin is a small,
    pickled cucumber, he continued the theme, and the Gherkin specfication language
    was born.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](part0028_split_001.html#idm45644725926616-marker)) Telephone is a game
    where everyone sits in a circle, and one person whispers a message to another.
    The message continues to get whispered around the circle until it reaches the
    origin. Everyone has a laugh at how the message has gotten distorted.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](part0028_split_004.html#idm45644725698696-marker)) While this quote’s
    author is anonymous, I first came across it on the [Programming Wisdom Twitter
    account](https://oreil.ly/rKsVj).
  prefs: []
  type: TYPE_NORMAL
