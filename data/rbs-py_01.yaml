- en: Chapter 1\. Introduction to Robust Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 介绍健壮的Python
- en: 'This book is all about making your Python more manageable. As your codebase
    grows, you need a specific toolbox of tips, tricks, and strategies to build maintainable
    code. This book will guide you toward fewer bugs and happier developers. You’ll
    be taking a hard look at how you write code, and you’ll learn the implications
    of your decisions. When discussing how code is written, I am reminded of these
    wise words from C.A.R. Hoare:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的重点是让你的Python代码更易管理。随着代码库的增长，你需要一套特定的技巧、诀窍和策略来构建可维护的代码。这本书将指导你减少bug，让开发者更快乐。你将深入探讨自己编写代码的方式，并了解你的决策所带来的影响。在讨论代码编写方式时，我想起了C.A.R.
    Hoare的这些明智的话：
- en: 'There are two ways of constructing a software design: One way is to make it
    so simple that there are obviously no deficiencies, and the other way is to make
    it so complicated that there are no obvious deficiencies. The first method is
    far more difficult.^([1](part0003_split_011.html#idm45644759414136))'
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有两种构建软件设计的方法：一种是使它非常简单，以至于显然没有缺陷，另一种是使它非常复杂，以至于显然没有缺陷。第一种方法要困难得多。^([1](part0003_split_011.html#idm45644759414136))
- en: This book is about developing systems the first way. It will be more difficult,
    yes, but have no fear. I will be your guide on your journey to leveling up your
    Python game such that, as C.A.R. Hoare says above, *there are obviously no deficiencies*
    in your code. Ultimately, this is a book all about writing *robust* Python.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书讨论的是第一种方式开发系统。是的，这会更加困难，但不要害怕。我将成为你在提升Python水平旅程中的向导，确保如C.A.R. Hoare所说，你的代码中显然没有缺陷。归根结底，这是一本关于编写*健壮*Python的书籍。
- en: In this chapter we’re going to cover what *robustness* means and why you should
    care about it. We’ll go through how your communication method implies certain
    benefits and drawbacks, and how best to represent your intentions. [“The Zen of
    Python”](https://oreil.ly/SHq8i) states that, when developing code, “There should
    be one -- and preferably only one -- obvious way to do it.” You’ll learn how to
    evaluate whether your code is written in an obvious way, and what you can do to
    fix it. First, we need to address the basics. What is *robustness* in the first
    place?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论*健壮性*的含义以及你为何应关注它。我们将介绍你的沟通方式如何暗示某些利弊，并探讨最佳表示意图的方法。["Python之禅"](https://oreil.ly/SHq8i)提到，在开发代码时，“应该有一种——最好只有一种——显而易见的方法来做到这一点。”你将学会如何评估你的代码是否以显而易见的方式编写，以及如何修复它。首先，我们需要解决基础问题。首先，*健壮性*究竟是什么？
- en: Robustness
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健壮性
- en: 'Every book needs at least one dictionary definition, so I’ll get this out of
    the way nice and early. Merriam-Webster offers many definitions for [*robustness*](https://oreil.ly/2skKO):'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 每本书至少需要一个字典定义，所以我会早早地把这个解决掉。Merriam-Webster为[*健壮性*](https://oreil.ly/2skKO)提供了许多定义：
- en: having or exhibiting strength or vigorous health
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具有力量或健壮的表现
- en: having or showing vigor, strength, or firmness
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具有或显示活力、力量或坚定
- en: strongly formed or constructed
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 强壮的或建造的
- en: capable of performing without failure under a wide range of conditions
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 能够在广泛的条件下无故障运行
- en: These are fantastic descriptions of what to aim for. We want a *healthy* system,
    one that meets expectations for years. We want our software to *exhibit strength*;
    it should be obvious that this code will stand the test of time. We want a *strongly
    constructed* system, one that is built upon solid foundations. Crucially, we want
    a system that is *capable of performing without failure*; the system should not
    become vulnerable as changes are introduced.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是我们的目标的精彩描述。我们希望一个*健康*的系统，一个能够满足多年期望的系统。我们希望我们的软件*表现出力量*；显然，这段代码将经得起时间的考验。我们希望一个*坚固构建*的系统，一个建立在坚实基础上的系统。关键是，我们希望一个能够在没有故障的情况下运行的系统；随着变更的引入，系统不应变得脆弱。
- en: It is common to think of a software like a skyscraper, some grand structure
    that stands as a bulwark against all change and a paragon of immortality. The
    truth is, unfortunately, messier. Software systems constantly evolve. Bugs are
    fixed, user interfaces get tweaked, and features are added, removed, and then
    re-added. Frameworks shift, components go out of date, and security bugs arise.
    Software changes. Developing software is more akin to handling sprawl in city
    planning than it is constructing a static building. With ever changing codebases,
    how can you make your code robust? How can you build a strong foundation that
    is resilient to bugs?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 人们通常把软件比作摩天大楼，一种伟大的结构，挺过所有变化，成为不朽的典范。不幸的是，事实更为复杂。软件系统不断演化。错误被修复，用户界面被调整，功能被添加、移除，然后重新添加。框架转变，组件过时，安全漏洞出现。软件在变化。开发软件更像是处理城市规划中的蔓延，而不是建造静态建筑。面对不断变化的代码库，如何使你的代码健壮？如何构建一个能抵御错误的坚固基础？
- en: The truth is, you have to accept change. Your code will be split apart, stitched
    together, and reworked. New use cases will alter huge swaths of code—and that’s
    OK. Embrace it. Understand that it’s not enough that your code can easily be changed;
    it might be best for it to be deleted and rewritten as it goes out of date. That
    doesn’t diminish its value; it will still have a long life in the spotlight. Your
    job is to make it easy to rewrite parts of the system. Once you start to accept
    the ephemeral nature of your code, you start to realize that it’s not enough to
    write bug-free code for the present; you need to enable the codebase’s future
    owners to be able to change your code with confidence. That is what this book
    is about.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 事实是，你必须接受变化。你的代码将被拆分，重新组合和重构。新的用例将改变大片代码——这是可以接受的。拥抱变化。明白你的代码可以轻易改变是不够的；最好的情况可能是它被删除并重写，因为它过时了。这并不会减少其价值；它仍然可以在聚光灯下有很长的寿命。你的任务是使系统的部分易于重写。一旦你开始接受你的代码的短暂性，你就开始意识到，为现在编写无BUG的代码是不够的；你需要让代码库的未来所有者能够有信心地修改你的代码。这就是本书的内容所在。
- en: You are going to learn to build strong systems. This strength doesn’t come from
    rigidity, as exhibited by a bar of iron. It instead comes from flexibility. Your
    code needs to be strong like a tall willow tree, swaying in the wind, flexing
    but not breaking. Your software will need to handle situations you would never
    dream of. Your codebase needs to be able to adapt to new circumstances, because
    it won’t always be you maintaining it. Those future maintainers need to know they
    are working in a healthy codebase. Your codebase needs to communicate its strength.
    You must write Python code in a way that reduces failure, even as future maintainers
    tear it apart and reconstruct it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学会构建强大的系统。这种强度不是来自于铁块那种僵化的展示。它来自于灵活性。你的代码需要像一棵高大的柳树一样强壮，能在风中摇曳，灵活但不易折断。你的软件需要处理你从未梦到的情况。你的代码库需要能够适应新的环境，因为不总是你来维护它。未来的维护者需要知道他们在一个健康的代码库中工作。你的代码库需要传达其强度。你必须以一种方式编写Python代码，以减少失败，即使未来的维护者在拆解和重构它。
- en: Writing robust code means deliberately thinking about the future. You want future
    maintainers to look at your code and understand your intentions easily, not curse
    your name during late-night debugging sessions. You must convey your thoughts,
    reasoning, and cautions. Future developers will need to bend your code into new
    shapes—and will want to do so without worrying that each change may cause it to
    collapse like a teetering house of cards.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 写健壮的代码意味着深思熟虑未来。你希望未来的维护者看着你的代码能轻松理解你的意图，而不是在深夜调试时咒骂你的名字。你必须传达你的思想、推理和警告。未来的开发者需要把你的代码弯成新的形状，并且希望这样做时不用担心每次修改都可能像摇摇欲坠的纸牌房屋一样崩溃。
- en: Put simply, you don’t want your systems to fail, especially when the unexpected
    happens. Testing and quality assurance are huge parts of this, but neither of
    those bake quality completely in. They are more suited to illuminating gaps in
    expectations and offering a safety net. Instead, you must make your software stand
    the test of time. In order to do that, you must write *clean and maintainable*
    code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，你不希望系统失败，尤其是在发生意外情况时。测试和质量保证在其中占据重要地位，但它们都不能完全保证质量。它们更适合揭示期望中的差距并提供安全网。相反，你必须让你的软件经得起时间的考验。为了做到这一点，你必须编写*清晰且易于维护*的代码。
- en: Clean code expresses its intent clearly and concisely, in that order. When you
    look at a line of code and say to yourself, “ah, that makes complete sense,” that’s
    an indicator of clean code. The more you have to step through a debugger, the
    more you have to look at a lot of other code to figure out what’s happening, the
    more you have to stop and stare at the code, the less clean it is. Clean code
    does not favor clever tricks if it makes the code unreadable to other developers.
    Just like C.A.R. Hoare said earlier, you do not want to make your code so obtuse
    that it will be difficult to understand upon visual inspection.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰的代码按照顺序清晰而简洁地表达其意图。当你看着一行代码对自己说，“啊，这完全讲得通”，这就是清晰代码的指标。你越要通过调试器逐步执行，越要查看大量其他代码以弄清发生了什么，越要停下来盯着代码看，代码就越不清晰。清晰的代码不会因为巧妙的技巧而使其他开发人员无法阅读。就像C.A.R.
    Hoare之前说的那样，你不希望使你的代码如此晦涩，以至于仅凭视觉检查就难以理解。
- en: Maintainable code is code that…well, can be easily maintained. Maintenance begins
    immediately after the first commit and continues until not a single developer
    is looking at the project anymore. Developers will be fixing bugs, adding features,
    reading code, extracting code for use in other libraries, and more. Maintainable
    code makes these tasks frictionless. Software lives for years, if not decades.
    Focus on your maintainability *today*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护的代码是能够轻松维护的代码。维护从第一个提交开始，并持续到没有一个开发人员再看项目为止。开发人员将修复错误，添加功能，阅读代码，提取代码以供在其他库中使用等。可维护的代码使这些任务变得无摩擦。软件生命周期长达数年，甚至数十年。今天就专注于您的可维护性吧。
- en: 'You don’t want to be the reason systems fail, whether you are actively working
    on them or not. You need to be proactive in making your system stand the test
    of time. You need a testing strategy to be your safety net, but you also need
    to be able to avoid falling in the first place. So with all that in mind, I offer
    my definition of robustness in terms of your codebase:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是积极参与工作还是不参与，你都不希望成为系统失败的原因。你需要积极主动地让你的系统经得起时间的考验。你需要一个测试策略来作为你的安全网，但你也需要能够在第一时间避免掉入。因此，考虑到这一切，我提出了我对代码库稳健性的定义：
- en: A robust codebase is resilient and error-free in spite of constant change.
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 稳健的代码库在不断变化中仍然是弹性和无错误的。
- en: Why Does Robustness Matter?
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么健壮性很重要？
- en: A lot of energy goes into making software do what it’s supposed to, but it’s
    not easy to know when you’re done. Development milestones are not easily predicted.
    Human factors such as UX, accessibility, and documentation only increase the complexity.
    Now add in testing to ensure that you’ve covered a slice of known and unknown
    behaviors, and you are looking at lengthy development cycles.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让软件按照预期运行需要花费大量精力，但是很难确定何时才算完成。开发里程碑不容易预测。人为因素，如用户体验、可访问性和文档，只会增加复杂性。现在加入测试以确保您覆盖了已知和未知行为的片段，您将面临漫长的开发周期。
- en: The purpose of software is to provide value. It is in every stakeholder’s interests
    to deliver that full value as early as possible. Given the uncertainty around
    some development schedules, there is often extra pressure to meet expectations.
    We’ve all been on the wrong end of an unrealistic schedule or deadline. Unfortunately,
    many of the tools to make software incredibly robust only add onto our development
    cycle in the short term.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 软件的目的是提供价值。每个利益相关者都有兴趣尽早交付这些价值。鉴于某些开发进度的不确定性，往往会增加满足期望的压力。我们都曾经历过不切实际的进度表或截止日期的反面。不幸的是，许多增强软件健壮性的工具只会在短期内增加我们的开发周期。
- en: It’s true that there is an inherent tension between immediate delivery of value
    and making code robust. If your software is “good enough,” why add even more complexity?
    To answer that, consider how often that piece of software will be iterated upon.
    Delivering software value is typically not a static exercise; it’s rare that a
    system provides value and is never modified again. Software is ever-evolving by
    its very nature. The codebase needs to be prepared to deliver value frequently
    and for long periods of time. This is where robust software engineering practices
    come into play. If you can’t painlessly deliver features quickly and without compromising
    quality, you need to re-evaluate techniques to make your code more maintainable.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，在即时交付价值和编写健壮代码之间存在固有的紧张关系。如果你的软件“足够好”，为什么还要增加更多复杂性呢？为了回答这个问题，考虑那段软件将被迭代多少次。提供软件价值通常不是一个静态的过程；一个系统提供价值且永不修改的情况是罕见的。软件本质上是不断发展的。代码库需要准备好在长时间内频繁地提供价值。这就是健壮软件工程实践发挥作用的地方。如果你无法快速无损地交付功能，你需要重新评估技术，使你的代码更易维护。
- en: If you deliver your system late, or broken, you incur real-time costs. Think
    through your codebase. Ask yourself what happens if your code breaks a year from
    now because someone wasn’t able to understand your code. How much value do you
    lose? Your value might be measured in money, time, or even lives. Ask yourself
    what happens if the value isn’t delivered on time? What are the repercussions?
    If the answers to these questions are scary, good news, the work you’re doing
    is valuable. But it also underscores why it’s so important to eliminate future
    errors.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你推迟或破坏你的系统，你会产生实时成本。仔细思考你的代码库。问问自己，如果你的代码一年后由于有人无法理解而出现问题会怎么样。你会损失多少价值？你的价值可能以金钱、时间，甚至生命来衡量。问问自己，如果价值不能按时交付会发生什么？会有什么后果？如果这些问题的答案让人感到害怕，好消息是，你正在做有价值的工作。但这也强调了消除未来错误的重要性。
- en: Multiple developers work on the same codebase simlutaneously. Many software
    projects will outlast most of those developers. You need to find a way to communicate
    to the present and future developers, without having the benefit of being there
    in person to explain. Future developers will be building off of *your* decisions.
    Every false trail, every rabbit hole, and every yak-shaving^([2](part0003_split_011.html#idm45644754042936))
    adventure will slow them down, which impedes value. You need empathy for those
    who come after you. You need to step into their shoes. This book is your gateway
    to thinking about your collaborators and maintainers. You need to think about
    sustainable engineering practices. You need to write code that lasts. The first
    step to making code that lasts is being able to communicate through your code.
    You need to make sure future developers understand your intent.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 多个开发人员同时在同一代码库上工作。许多软件项目将超过大多数开发人员的寿命。你需要找到一种方式与现在和未来的开发人员沟通，而不依赖于当面解释的好处。未来的开发人员将根据*你*的决策进行构建。每一个错误的路径，每一个兔子洞，以及每一个Yak-shaving^([2](part0003_split_011.html#idm45644754042936))冒险都会减慢他们的速度，从而阻碍价值的实现。你需要为那些接替你工作的人们感到同情。你需要站在他们的角度思考。这本书是你思考协作者和维护者的入口。你需要考虑可持续的工程实践。你需要编写持久的代码。制造持久代码的第一步是通过你的代码进行沟通。你需要确保未来的开发人员理解你的意图。
- en: What’s Your Intent?
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的意图是什么？
- en: Why should you strive to write clean and maintainable code? Why should you care
    so much about robustness? The heart of these answers lies in communication. You’re
    not delivering static systems. The code will continue to change. You also have
    to consider that maintainers change over time. Your goal, when writing code, is
    to deliver value. It’s also to write your code in such a way that other developers
    can deliver value just as quickly. In order to do that, you need to be able to
    communicate reasoning and intent without ever meeting your future maintainers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你应该努力编写清晰和可维护的代码？为什么你应该如此关注健壮性？这些答案的核心在于沟通。你不是在交付静态系统。代码将继续变化。你还必须考虑维护者随时间变化。在编写代码时，你的目标是提供价值。你还要以一种能让其他开发人员同样快速提供价值的方式编写代码。为了做到这一点，你需要能够在未来维护者没有见面的情况下沟通推理和意图。
- en: Let’s take a look at a code block found in a hypothetical legacy system. I want
    you to estimate how long it takes for you to understand what this code is doing.
    It’s OK if you’re not familiar with all the concepts here, or if you feel like
    this code is convoluted (it intentionally is!).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个在假设的传统系统中找到的代码块。我希望你估计一下你理解这段代码所需的时间。如果你对这里的所有概念不熟悉，或者觉得这段代码很复杂（这是有意的！），也没关系。
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This function takes a recipe and adjusts every ingredient to handle a new number
    of servings. However, this code prompts many questions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个食谱，并调整每个成分以处理新的份数。然而，这段代码引发了许多问题。
- en: What is the `pop` for?
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pop`是干什么用的？'
- en: What does `recipe[0]` signify? Why is that the old servings?
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recipe[0]`代表什么？为什么是旧的分量？'
- en: Why do I need a comment for numbers that will be easily measurable?
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我需要为可轻松测量的数字添加注释？
- en: 'This is a bit of questionable Python, for sure. I won’t blame you if you feel
    the need to rewrite it. It looks much nicer written like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是有些值得商榷的Python代码。如果你觉得有必要重写它，我不会责怪你。像这样写起来看起来好多了：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Those who favor clean code probably prefer the second version (I certainly do).
    No raw loops. Variables do not mutate. I’m returning a dictionary instead of a
    list of tuples. All these changes can be seen as positive, depending on the circumstances.
    But I may have just introduced three subtle bugs.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 喜欢整洁代码的人可能更喜欢第二个版本（我肯定是这样）。没有原始循环。变量不变异。我返回一个字典而不是元组列表。根据情况，所有这些变化都可以看作是积极的。但我可能刚刚引入了三个微妙的错误。
- en: In the original code snippet, I was clearing out the original recipe. Now I
    am not. Even if it’s just one area of calling code that is relying on this behavior,
    I broke that calling code’s assumptions.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在原始代码片段中，我清理了原始食谱。现在我没有了。即使只有一个区域的调用代码依赖于这种行为，我也破坏了该调用代码的假设。
- en: By returning a dictionary, I have removed the ability to have duplicate ingredients
    in a list. This might have an effect on recipes that have multiple parts (such
    as a main dish and a sauce) that both use the same ingredient.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过返回一个字典，我已经删除了在列表中具有重复成分的能力。这可能会影响那些使用同一成分的多个部分（如主菜和酱料）的食谱。
- en: If any of the ingredients are named “servings” I’ve just introduced a collision
    with naming.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任何成分都被命名为“servings”，我刚刚引入了与命名冲突。
- en: 'Whether these are bugs or not depends on two interrelated things: the original
    author’s intent and calling code. The author intended to solve a problem, but
    I am unsure of why they wrote the code the way they did. Why are they popping
    elements? Why is “servings” a tuple inside the list? Why is a list used? Presumably,
    the original author knew why, and communicated it locally to their peers. Their
    peers wrote calling code based on those assumptions, but as time wore on, that
    intent became lost. Without communication to the future, I am left with two options
    of maintaining this code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是否是错误取决于两个相互关联的事情：原始作者的意图和调用代码。作者打算解决一个问题，但我不确定他们为什么以这种方式编写代码。他们为什么弹出元素？为什么“servings”是列表内的元组？为什么使用列表？据推测，原始作者知道原因，并在本地向同事传达了。他们的同事根据这些假设编写了调用代码，但随着时间的推移，这种意图变得模糊了。在没有向未来传达信息的情况下，我只能有两种选择来维护这段代码：
- en: Look at all calling code and confirm that this behavior is not relied upon before
    implementing. Good luck if this is a public API for a library with external callers.
    I would spend a lot of time doing this, which would frustrate me.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看所有调用代码，并确认在实施之前，这种行为并不依赖于它。如果这是一个带有外部调用者的库的公共API，祝你好运。我会花很多时间来做这件事情，这会让我很沮丧。
- en: Make the change and wait to see what the fallout is (customer complaints, broken
    tests, etc.). If I’m lucky, nothing bad will happen. If I’m not, I would spend
    a lot of time fixing use cases, which would frustrate me.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行更改并等待看看结果如何（客户投诉、测试失败等）。如果我幸运的话，不会发生什么不好的事情。如果不幸的话，我会花很多时间来修复用例，这会让我很沮丧。
- en: Neither option feels productive in a maintenance setting (especially if I have
    to modify this code). I don’t want to waste time; I want to deal with my current
    task quickly and move on to the next one. It gets worse if I consider how to call
    this code. Think about how you interact with previously unseen code. You might
    see other examples of calling code, copy them to fit your use case, and never
    realize that you needed to pass a specific string called “servings” as the first
    element of your list.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在维护设置中，这两种选项都不太高效（尤其是如果我必须修改这段代码）。我不想浪费时间；我希望快速处理当前任务并继续下一个任务。如果考虑如何调用这段代码，情况会变得更糟。想想你如何与之前从未见过的代码互动。你可能看到其他调用代码的示例，将它们复制以适应你的用例，并且从未意识到你需要将一个名为“servings”的特定字符串作为列表的第一个元素传递。
- en: These are the sorts of decisions that will make you scratch your head. We’ve
    all seen them in larger codebases. They aren’t written maliciously, but organically
    over time with the best intentions. Functions start simple, but as use cases grow
    and multiple developers contribute, that code tends to morph and obscure original
    intent. This is a sure sign that maintainability is suffering. You need to express
    intent in your code up front.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是会让你感到困惑的决策。我们在更大的代码库中都见过它们。它们并非出于恶意编写，而是随着时间的推移和多个开发者的贡献而有机地形成。函数起初很简单，但随着用例的增长，那些代码往往会变形并且遮蔽原始意图。这明显表明可维护性正在受到影响。你需要在代码开发初期表达出你的意图。
- en: So what if the original author made use of better naming patterns and better
    type usage? What would that code look like?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果原始作者使用了更好的命名模式和更好的类型使用，那么代码会是什么样子呢？
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This looks much better, is better documented, and expresses original intent
    clearly. The original developer encoded their ideas directly into the code. From
    this snippet, you know the following is true:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来好多了，文档化更好，明确表达了原始意图。原始开发者直接将他们的想法编码到了代码中。从这段代码片段中，你知道以下内容是正确的：
- en: I am using a `Recipe` class. This allows me to abstract away certain operations.
    Presumably, inside the class itself there is an invariant that allows for duplicate
    ingredients. (I’ll talk more about classes and invariants in [Chapter 10](part0014_split_000.html#classes).)
    This provides a common vocabulary that makes the function’s behavior more explicit.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我正在使用 `Recipe` 类。这使我能够抽象出某些操作。可以假定，在类内部有一个不变量，允许存在重复的成分。（关于类和不变量，我会在[第10章](part0014_split_000.html#classes)详细讲解。）这提供了一个通用词汇，使函数的行为更加明确。
- en: Servings are now an explicit part of a `Recipe` class, rather than needing to
    be the first element of the list, which was handled as a special case. This greatly
    simplifies calling code, and prevents inadvertent collisions.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，份量已经成为 `Recipe` 类的显式部分，而不需要作为列表的第一个元素处理，这作为一种特殊情况。这大大简化了调用代码，并防止了意外冲突。
- en: It is very apparent that I want to clear out ingredients on the old recipe.
    No ambiguous reason for why I needed to do a `.pop(0)`.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很明显，我想要清除旧食谱上的成分。没有模棱两可的原因，我需要执行 `.pop(0)`。
- en: Ingredients are a separate class, and handle [fractions](https://oreil.ly/YxUHK)
    rather than an explicit `float`. It’s clearer for all involved that I am dealing
    with fractional units, and can easily do things such as `limit_denominator()`,
    which can be called when people want to restrict measuring units (instead of relying
    on a comment).
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成分是一个单独的类，并且处理 [fractions](https://oreil.ly/YxUHK) 而不是显式的 `float`。这对所有参与者更清晰，我在处理分数单位时可以轻松执行
    `limit_denominator()`，当人们想要限制计量单位时可以调用该方法（而不是依赖于注释）。
- en: I’ve replaced variables with types, such as a recipe type and an ingredient
    type. I’ve also defined operations (`clear_ingredients`, `adjust_proportion`)
    to communicate my intent. By making these changes, I’ve made the code’s behavior
    crystal clear to future readers. They no longer have to come talk to me to understand
    the code. Instead, they comprehend what I’m doing without ever talking to me.
    This is *asynchronous communication* at its finest.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经用类型替换了变量，比如食谱类型和成分类型。我还定义了操作（`clear_ingredients`，`adjust_proportion`）来传达我的意图。通过做出这些改变，我已经让代码的行为对未来的读者非常清晰。他们不再需要来找我以理解这段代码。相反，他们理解我在做什么而不必与我交流。这就是*异步通信*的最佳体现。
- en: Asynchronous Communication
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步通信
- en: 'It’s weird writing about asynchronous communication in a Python book without
    mentioning `async` and `await`. But I’m afraid I have to discuss asynchronous
    communication in a much more complex place: *the real world*.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 书中写关于异步通信而不提及`async`和`await`感觉有些奇怪。但我不得不在一个更复杂的地方——*现实世界*中讨论异步通信。
- en: Asynchronous communication means that producing information and consuming that
    information are independent of each other. There is a time gap between the production
    and consumption. It might be a few hours, as is the case of collaborators in different
    time zones. Or it might be years, as future maintainers try to do a deep dive
    into the inner workings of code. You can’t predict when somebody will need to
    understand your logic. You might not even be working on that codebase (or for
    that company) by the time they consume the information you produced.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 异步沟通意味着生产信息和消费信息是相互独立的。在生产和消费之间存在时间间隔。这可能是几小时，就像处于不同时区的合作者的情况。或者可能是多年，未来的维护者试图深入了解代码的内部工作原理。你无法预测某人何时需要理解你的逻辑。甚至在他们消费信息时，你可能已经不再从事那个代码库（或那家公司）的工作。
- en: Contrast that with *synchronous communication*. Synchronous communication is
    the exchange of ideas live (in real time). This form of direct communication is
    one of the best ways to express your thoughts but unfortunately, it doesn’t scale,
    and you won’t always be around to answer questions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与之形成对比的是*同步沟通*。同步沟通是实时交换想法。这种直接沟通是表达思想的最佳方式之一，但不幸的是，它缺乏可扩展性，你并不总是能在那儿回答问题。
- en: 'In order to evaluate how appropriate each method of communication is when trying
    to understand intentions, let’s look at two axes: proximity and cost.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估每种沟通方法在试图理解意图时的适用性，让我们看看两个轴：亲近度和成本。
- en: '*Proximity* is how close in time the communicators need to be in order for
    that communication to be fruitful. Some methods of communication excel with real-time
    transfer of information. Other methods of communication excel at communicating
    years later.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*亲近度*是沟通者在时间上需要多么接近才能使沟通富有成效。某些沟通方法在实时传递信息方面表现出色，而其他方法则在多年后传播信息方面表现出色。'
- en: '*Cost* is the measure of effort to communicate. You must weigh the time and
    money expended to communicate with the value provided. Your future consumers then
    have to weigh the cost of consuming the information with the value they are trying
    to deliver. Writing code and not providing any other communication channels is
    your baseline; you have to do this to produce value. To evaluate additional communication
    channels’ cost, here is what I factor in:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*成本*是沟通所需的努力的度量。你必须权衡花费时间和金钱来沟通所提供的价值。然后，你的未来消费者必须权衡消费信息的成本与他们试图提供的价值。编写代码并没有提供任何其他沟通渠道是你的基准；你必须这样做来产生价值。为了评估额外沟通渠道的成本，我考虑以下因素：'
- en: Discoverability
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可发现性
- en: How easy was it to find this information outside of a normal workflow? How ephemeral
    is the knowledge? Is it easy to search for information?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常工作流程之外查找这些信息有多容易？知识有多短暂？搜索信息容易吗？
- en: Maintenance cost
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 维护成本
- en: How accurate is the information? How often does it need to be updated? What
    goes wrong if this information is out of date?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 信息的准确性如何？更新频率如何？如果信息过时会出现什么问题？
- en: Production cost
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 生产成本
- en: How much time and money went into producing the communication?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 制作沟通所花费的时间和金钱有多少？
- en: In [Figure 1-1](part0003_split_004.html#figure_1_1), I plot some common communication
    methods’ cost and proximity required, based on my own experience.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 1-1](part0003_split_004.html#figure_1_1)中，我根据自己的经验绘制了一些常见沟通方法的成本和所需亲近度。
- en: Figure 1-1\. Plotting cost and proximity of communcation methods
  id: totrans-68
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-1\. 绘制沟通方法的成本和亲近度
- en: There are four quadrants that make up the cost/proximity graph.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 组成成本/亲近度图的四个象限。
- en: Low cost, high proximity required
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 低成本，高亲近度需求
- en: These are cheap to produce and consume, but are not scalable across time. Direct
    communication and instant messaging are great examples of these methods. Treat
    these as snapshots of information in time; they are only valuable when the user
    is actively listening. Don’t rely on these methods to communicate to the future.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些虽然便宜易于生产和消费，但在时间上不具有可扩展性。直接沟通和即时通讯是这些方法的典型例子。把它们视为时间点上的信息快照；只有用户在积极倾听时，它们才有价值。不要依赖这些方法来传达给未来。
- en: High cost, high proximity required
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 高成本，高亲近度需求
- en: These are costly events, and often only happen once (such as meetings or conferences).
    These events should deliver a lot of value at the time of communication, because
    they do not provide much value to the future. How many times have you been to
    a meeting that felt like a waste of time? You’re feeling the direct loss of value.
    Talks require a multiplicative cost for each attendee (time spent, hosting space,
    logistics, etc.). Code reviews are rarely looked at once they are done.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是昂贵的事件，并且通常只发生一次（如会议或会议）。这些事件在沟通时应提供大量价值，因为它们对未来的价值贡献不大。你参加过多少次觉得浪费时间的会议？你正在感受到直接的价值损失。每个参与者都需要支付多重成本（时间花费、主办空间、后勤等）。代码审查完成后很少被查看。
- en: High cost, low proximity required
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 成本高，所需接近度低
- en: These are costly, but that cost can be paid back over time in value delivered,
    due to the low proximity needed. Emails and agile boards contain a wealth of information,
    but are not discoverable by others. These are great for bigger concepts that don’t
    need frequent updates. It becomes a nightmare to try and sift through all the
    noise just to find the nugget of information you are looking for. Video recordings
    and design documentation are great for understanding snapshots in time, but are
    costly to keep updated. Don’t rely on these communication methods to understand
    day-to-day decisions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是昂贵的，但随着时间的推移，可以通过提供的价值来回报成本，因为所需的接近度较低。电子邮件和敏捷看板包含大量信息，但他人无法发现。这些适合不需要经常更新的大概念。试图筛选出你寻找的信息之前必须经历噪音的噩梦。视频录像和设计文档适合了解某一时刻的快照，但更新成本高昂。不要依赖这些沟通方法来理解日常决策。
- en: Low cost, low proximity required
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 成本低，所需接近度低
- en: These are cheap to create, and are easily consumable. Code comments, version
    control history, and project READMEs all fall into this category, since they are
    adjacent to the source code we write. Users can view this communication years
    after it was produced. Anything that a developer encounters during their day-to-day
    workflow is inherently discoverable. These communication methods are a natural
    fit for the first place someone will look after the source code. However, your
    code is one of your best documentation tools, as it is the living record and single
    source of truth for your system.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内容易于创建，并且易于消费。代码注释、版本控制历史和项目 README 都属于此类，因为它们与我们编写的源代码相邻。用户可以在数年后查看这些通信内容。开发者在日常工作流程中遇到的任何内容都是可以发现的。这些沟通方法自然适合作为源代码之后某人首先查看的地方。然而，你的代码是你最好的文档工具之一，因为它是系统的生动记录和唯一真相来源。
- en: Discussion Topic
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论主题
- en: This plot in [Figure 1-1](part0003_split_004.html#figure_1_1) was created based
    on generalized use cases. Think about the communication paths you and your organization
    use. Where would you plot them on the graph? How easy is it to consume accurate
    information? How costly is it to produce information? Your answers to these questions
    may result in a slightly different graph, but the single source of truth will
    be in the executable software you deliver.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表在[图 1-1](part0003_split_004.html#figure_1_1)中基于一般化的使用案例创建。考虑你和你的组织使用的沟通路径。你会在图表上的哪个位置标出它们？消费准确信息有多容易？制造信息有多昂贵？这些问题的答案可能导致略有不同的图表，但真相的单一来源将在您交付的可执行软件中。
- en: Low cost, low proximity communication methods are the best tools for communicating
    to the future. You should strive to minimize the cost of production and of consumption
    of communication. You have to write software to deliver value anyway, so the lowest
    cost option is making your code your primary communication tool. Your codebase
    becomes the best possible option for expressing your decisions, opinions, and
    workarounds clearly.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 成本低，所需接近度低的沟通方法是向未来沟通的最佳工具。你应该努力将生产成本和沟通消费成本最小化。无论如何，你都必须编写软件来提供价值，因此最低成本的选项是将你的代码作为主要沟通工具。你的代码库成为清晰表达你的决策、观点和解决方法的最佳选择。
- en: However, for this assertion to hold true, the code has to be cheap to consume
    as well. Your intent has to come across clearly in your code. Your goal is to
    minimize the time needed for a reader of your code to understand it. Ideally,
    a reader does not need to read your implementation, but just your function signature.
    Through the use of good types, comments and variable names, it should be crystal
    clear what your code does.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了使这个断言成立，代码也必须很容易消耗。你的意图必须清晰地在你的代码中表达出来。你的目标是尽量减少读者理解代码所需的时间。理想情况下，读者不需要阅读你的实现，只需阅读你的函数签名。通过使用良好的类型、注释和变量名，你的代码应该清晰地表明你的代码是做什么的。
- en: Examples of Intent in Python
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 中的意图示例
- en: 'Now that I’ve talked through what intent is and how it matters, let’s look
    at examples through a Python lens. How can you make sure that you are correctly
    expressing your intentions? I will take a look at two different examples of how
    a decision affects intentions: collections and iteration.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经讲解了意图是什么以及它的重要性，让我们通过 Python 的视角看一些示例。你如何确保你正确地表达了你的意图？我将看两个不同的决策如何影响意图的示例：集合和迭代。
- en: Collections
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: When you pick a collection, you are communicating specific information. You
    must pick the right collection for the task at hand. Otherwise, maintainers will
    infer the wrong intention from your code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择一个集合时，你正在传达特定的信息。你必须为手头的任务选择正确的集合。否则，维护人员将从你的代码中推断出错误的意图。
- en: 'Consider this code that takes a list of cookbooks and provides a mapping between
    authors and the number of books written:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这段代码，它接受一系列烹饪书，并提供了作者和书籍数量之间的映射：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'What does my use of collections tell you? Why am I not passing a dictionary
    or a set? Why am I not returning a list? Based on my current usage of collections,
    here’s what you can assume:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我对集合的使用告诉了你什么？为什么我不传递一个字典或一个集合？为什么我不返回一个列表？根据我对集合的当前使用，你可以假设：
- en: I pass in a list of cookbooks. There may be duplicate cookbooks in this list
    (I might be counting a shelf of cookbooks in a store with multiple copies).
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我传入了一系列烹饪书。这个列表中可能有重复的烹饪书（我可能正在数一家商店里有多本副本的烹饪书架）。
- en: I am returning a dictionary. Users can look up a specific author, or iterate
    over the entire dictionary. I do not have to worry about duplicate authors in
    the returned collection.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我正在返回一个字典。用户可以查找特定的作者，或者遍历整个字典。我不必担心返回集合中的重复作者。
- en: What if I wanted to communicate that no duplicates should be passed into this
    function? A list communicates the wrong intention. Instead, I should have chosen
    a set to communicate that this code absolutely will not handle duplicates.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想传达的是这个函数不应该传入重复的内容怎么办？一个列表传达了错误的意图。相反，我应该选择一个集合来表明这段代码绝对不会处理重复项。
- en: 'Choosing a collection tells readers about your specific intentions. Here’s
    a list of common collection types, and the intention they convey:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个集合告诉读者你的具体意图。下面是一些常见集合类型及其传达的意图的列表：
- en: List
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表
- en: 'This is a collection to be iterated over. It is *mutable*: able to be changed
    at any time. Very rarely do you expect to be retrieving specific elements from
    the middle of the list (using a static list index). There may be duplicate elements.
    The cookbooks on a shelf might be stored in a list.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可迭代的集合。它是*可变*的：可以随时更改。你几乎不会指望从列表中间检索特定的元素（使用静态列表索引）。可能会有重复的元素。书架上的烹饪书可能会被存储在一个列表中。
- en: String
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: An immutable collection of characters. The name of a cookbook would be a string.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不可变的字符集合。一本烹饪书的名称将是一个字符串。
- en: Generator
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器
- en: A collection to be iterated over, and never indexed into. Each element access
    is performed lazily, so it may take time and/or resources through each loop iteration.
    They are great for computationally expensive or infinite collections. An online
    database of recipes might be returned as a generator; you don’t want to fetch
    all the recipes in the world when the user is only going to look at the first
    10 results of a search.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可迭代的集合，永远不会被索引。每个元素访问都是惰性执行的，所以每次循环迭代可能需要时间和/或资源。它们非常适合计算昂贵或无限的集合。一个在线的菜谱数据库可能会被返回为生成器；当用户只查看搜索结果的前10个结果时，你不希望获取世界上所有的菜谱。
- en: Tuple
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 元组
- en: An immutable collection. You do not expect it to change, so it is more likely
    to extract specific elements from the middle of the tuple (either through indices
    or unpacking). It is very rarely iterated over. The information about a specific
    cookbook might be represented as a tuple, such as `(cookbook_name, author, pagecount)`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不可变的集合。你不希望它改变，因此更有可能从元组的中间提取特定元素（通过索引或解包）。很少会迭代它。关于特定菜谱的信息可能以元组的形式表示，如`(cookbook_name,
    author, pagecount)`。
- en: Set
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 集合
- en: An iterable collection that contains no duplicates. You cannot rely on ordering
    of elements. The ingredients in a cookbook might be stored as a set.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可迭代的集合，不包含重复项。您不能依赖元素的顺序。菜谱中的食材可能以集合的形式存储。
- en: Dictionary
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 字典
- en: A mapping from keys to values. Keys are unique across the dictionary. Dictionaries
    are typically iterated over, or indexed into using dynamic keys. A cookbook’s
    index is a great example of a key to value mapping (from topic to page number.)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从键到值的映射。字典中的键在整个字典中是唯一的。通常会迭代字典，或者使用动态键索引进入。菜谱索引是一个很好的键到值映射的例子（从主题到页码）。
- en: Do not use the wrong collection for your purposes. Too many times have I come
    across a list that should not have had duplicates or a dictionary that wasn’t
    actually being used to map keys to values. Every time there is a disconnect between
    what you intend and what is in code, you create a maintenance burden. Maintainers
    must pause, work out what you really meant, and then work around their faulty
    assumptions (and your faulty assumptions, too).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 不要为你的目的使用错误的集合。我太多次看到应该没有重复项的列表或者实际上并没有被用来映射键值对的字典。每当你的意图与代码不一致时，你就会创建维护负担。维护者必须停下来，弄清楚你实际上想表达的是什么，然后围绕他们错误的假设（还有你的错误假设）进行工作。
- en: 'These are basic collections, but there are more ways to express intent. Here
    are some special collection types that are even more expressive in communicating
    to the future:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是基本集合，但还有更多表达意图的方法。以下是一些特殊的集合类型，它们在向未来传达意图方面更具表现力：
- en: '`frozenset`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`frozenset`'
- en: A set that is immutable.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不可变的集合。
- en: '`OrderedDict`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderedDict`'
- en: A dictionary that preserves order of elements based on insertion time. As of
    CPython 3.6 and Python 3.7, built-in dictionaries will also preserve order of
    elements based on insertion of time.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个根据插入时间保留元素顺序的字典。截至到 CPython 3.6 和 Python 3.7，内置字典也会根据插入时间保留元素的顺序。
- en: '`defaultdict`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict`'
- en: 'A dictionary that provides a default value if the key is missing. For example,
    I could rewrite my earlier example as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字典，如果键缺失则提供默认值。例如，我可以将我之前的例子重写如下：
- en: '[PRE4]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This introduces a new behavior for end users—if they query the dictionary for
    a value that doesn’t exist, they will receive a 0\. This might be beneficial in
    some use cases, but if it’s not, you can just return `dict(counter)` instead.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这为最终用户引入了一种新的行为 —— 如果他们查询字典中不存在的值，他们将收到一个0。这在某些情况下可能是有益的，但如果不是的话，你可以只返回`dict(counter)`。
- en: '`Counter`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter`'
- en: 'A special type of dictionary used for counting how many times an element appears.
    This greatly simplifies our above code to the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一种特殊的字典类型，用于计算元素出现的次数。这极大地简化了我们上面的代码为以下形式：
- en: '[PRE5]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Take a minute to reflect on that last example. Notice how using a `Counter`
    gives us much more concise code without sacrificing readability. If your readers
    are familiar with `Counter`, the meaning of this function (and how the implementation
    works) is immediately apparent. This is a great example of communicating intent
    to the future through better selection of collection types. I’ll explore collections
    further in [Chapter 5](part0008_split_000.html#collections).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间反思一下最后一个例子。注意使用`Counter`如何使我们的代码更加简洁，而不会牺牲可读性。如果读者熟悉`Counter`，这个函数的含义（以及实现方式）就会立即显而易见。这是通过更好地选择集合类型向未来传达意图的一个很好的例子。我将在[第
    5 章](part0008_split_000.html#collections)进一步探讨集合。
- en: There are plenty of additional types to explore, including `array`, `bytes`,
    and `range`. Whenever you come across a new collection type, built-in or otherwise,
    ask yourself how it differs from other collections and what it conveys to future
    readers.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他类型可以探索，包括`array`、`bytes`和`range`。无论何时遇到一个新的集合类型，无论是内置的还是其他类型，都要问问自己它与其他集合有何不同，以及它向未来的读者传达了什么。
- en: Iteration
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代
- en: Iteration is another example where the abstraction you choose dictates the intent
    you convey.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代是另一个例子，抽象你选择的决定了你传达的意图。
- en: How many times have you seen code like this?
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你多少次见过这样的代码？
- en: '[PRE6]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This simple code prints each character on a separate line. This is perfectly
    fine for a first pass at Python for this problem, but the solution quickly evolves
    into the more *Pythonic* (code written in an idiomatic style that aims to emphasize
    simplicity and is recognizable to most Python developers):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这段简单的代码将每个字符打印在单独的一行上。对于这个问题的Python初步解决方案来说，这是完全可以接受的，但解决方案很快就会演变为更*Pythonic*（用惯用风格编写的代码，旨在强调简洁并且对大多数Python开发人员来说是可识别的）：
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Take a moment and reflect on why this option is preferable. The `for` loop
    is a more appropriate choice; it communicates intentions more clearly. Just like
    collection types, the looping construct you select explicitly communicates different
    concepts. Here’s a list of some common looping constructs and what they convey:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请花一点时间思考为什么这个选项更可取。`for`循环是一个更合适的选择；它更清晰地传达了意图。就像集合类型一样，您选择的循环结构明确地传达了不同的概念。以下是一些常见的循环结构及其传达的概念：
- en: '`for` loops'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环'
- en: '`for` loops are used for iterating over each element in a collection or range
    and performing an action/side effect.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环用于遍历集合或范围中的每个元素，并执行操作/副作用。'
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`while` loops'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环'
- en: '`while` loops are used for iterating as long as a certain condition is true.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环用于在某个条件为真时进行迭代。'
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Comprehensions
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 推导式
- en: Comprehensions are used for transforming one collection into another (normally,
    this does not have side effects, especially if the comprehension is lazy).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 推导式用于将一个集合转换为另一个集合（通常情况下，这不会产生副作用，特别是如果推导是惰性的）。
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Recursion
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 递归
- en: Recursion is used when the substructure of a collection is identical to the
    structure of a collection (for example, each child of a tree is also a tree).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当集合的子结构与集合的结构相同时（例如，树的每个子节点也是一棵树），就会使用递归。
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You want each line of your codebase to deliver value. Furthermore, you want
    each line to clearly communicate what that value is to future developers. This
    drives a need to minimize any amount of boilerplate, scaffolding, and superfluous
    code. In the example above, I am iterating over each element and performing a
    side effect (printing an element), which makes the `for` loop an ideal looping
    construct. I am not wasting code. In contrast, the `while` loop requires us to
    explicitly track looping until a certain condition occurs. In other words, I need
    to track a specific condition and mutate a variable every iteration. This distracts
    from the value the loop provides, and provides unwanted cognitive burden.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望代码库的每一行都能提供价值。此外，您希望每一行都能清晰地向未来的开发人员传达这个价值是什么。这驱使我们需要尽量减少任何样板代码、脚手架和多余的代码。在上面的示例中，我正在遍历每个元素并执行一个副作用（打印一个元素），这使得`for`循环成为一个理想的循环结构。我没有浪费代码。相比之下，`while`循环要求我们明确跟踪循环，直到某个特定条件发生为止。换句话说，我需要追踪一个特定的条件，并在每次迭代时改变一个变量。这会分散注意力，增加不必要的认知负担。
- en: Law of Least Surprise
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小惊奇法则
- en: 'Distractions from intent are bad, but there’s a class of communication that
    is even worse: when code actively surprises your future collaborators. You want
    to adhere to the *Law of Least Surprise*; when someone reads through the codebase,
    they should almost never be surprised at behavior or implementation (and when
    they are surprised, there should be a great comment near the code to explain why
    it is that way). This is why communicating intent is paramount. Clear, clean code
    lowers the likelihood of miscommunication.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从意图中分散注意力是不好的，但有一类通信更糟糕：当代码主动让您未来的协作者感到惊讶时。您希望遵循*最小惊奇法则*；当某人阅读代码库时，他们几乎不应该对行为或实现感到惊讶（当他们感到惊讶时，附近应该有一个很好的注释来解释为什么是这样）。这就是为什么传达意图至关重要。清晰、干净的代码降低了误传的可能性。
- en: Note
  id: totrans-142
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The *Law Of Least Surprise*, also known as the *Law of Least Astonishment*,
    states that a program should always respond to the user in the way that astonishes
    them the least.^([3](part0003_split_011.html#idm45644757634344)) Surprising behavior
    leads to confusion. Confusion leads to misplaced assumptions. Misplaced assumptions
    lead to bugs. And that is how you get unreliable software.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*最小惊奇法则*，也称为*最小惊讶法则*，规定程序应该以最少让用户惊讶的方式响应用户。令人惊讶的行为会导致混淆。混淆会导致错误的假设。错误的假设会导致错误。这就是如何得到不可靠的软件。'
- en: Bear in mind, you can write completely correct code and still surprise someone
    in the future. There was one nasty bug I was chasing early in my career that crashed
    due to corrupted memory. Putting the code under a debugger or putting in too many
    print statements affected timing such that the bug would not manifest (a true
    “heisenbug”).^([4](part0003_split_011.html#idm45644757628952)) There were literally
    thousands of lines of code that related to this bug.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您可以编写完全正确的代码，但将来仍会令某人感到惊讶。在我职业生涯早期，我曾经追踪过一个由于内存损坏而导致崩溃的恶心错误。通过调试器或添加太多打印语句会影响时序，使得错误不会显现出来（真正的“海森堡”现象）。^([4](part0003_split_011.html#idm45644757628952))
    与此问题相关的代码行数多达数千行。
- en: So I had to do a manual bisect, splitting the code in half, see which half actually
    had the crash by removing the other half, and then do it all over again in that
    code half. After two weeks of tearing my hair out, I finally decided to inspect
    an innocuous sounding function called `getEvent`. It turns out that this function
    was actually *setting* an event with invalid data. Needless to say, I was very
    surprised. The function was completely correct in what it was doing, but because
    I missed the intent of the code, I overlooked the bug for at least three days.
    Surprising your collaborators will cost their time.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我不得不手动进行二分，将代码一分为二，看看哪一半实际上有崩溃，通过删除另一半再次执行此操作。在抓狂两周之后，我最终决定检查一个听起来无害的函数 `getEvent`。结果发现，这个函数实际上是在用无效数据
    *设置* 一个事件。毫无疑问，我感到非常惊讶。这个函数在执行它的功能时完全正确，但因为我忽视了代码的意图，至少有三天我都没有注意到这个错误。惊讶会浪费您协作者的时间。
- en: 'A lot of this surprise ends up coming from complexity. There are two types
    of complexity: *necessary complexity* and *accidental complexity*. Necessary complexity
    is the complexity inherent in your domain. Deep learning models are necessarily
    complex; they are not something you browse through the inner workings of and understand
    in a few minutes. Optimizing object–relational mapping (ORM) is necessarily complex;
    there is a large variety of possible user inputs have to be accounted for. You
    won’t be able to remove necessary complexity, so your best bet would be to try
    and contain it, lest it sprawls across your codebase and ends up becoming accidental
    complexity instead.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种惊讶大多来自复杂性。复杂性有两种类型：*必要复杂性* 和 *偶发复杂性*。必要复杂性是您领域内在的复杂性。深度学习模型必然复杂；不是您能在几分钟内浏览其内部工作原理就能理解的东西。优化对象关系映射（ORM）必然复杂；必须考虑大量可能的用户输入。您无法消除必要复杂性，所以最好的选择是试图将其限制在一定范围内，以免蔓延到代码库中，最终变成偶发复杂性。
- en: In contrast, accidental complexity is complexity that produces superfluous,
    wasteful, or confusing statements in code. It’s what happens when a system evolves
    over time and developers are jamming features in without reevaluating old code
    to determine whether their original assertions hold true. I once worked on a project
    where adding a single command-line option (and associated means of programmatically
    setting it) touched no fewer than 10 files. Why would adding one simple value
    ever need to require changes all over the codebase?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，偶发复杂性是代码中产生多余、浪费或混淆语句的复杂性。这种情况发生在系统随时间演变，开发者不断添加功能而不重新评估旧代码是否仍然有效时。我曾经参与过一个项目，其中添加一个单一的命令行选项（及其相关的程序设置）影响到了至少10个文件。为什么添加一个简单的值需要在整个代码库中进行更改呢？
- en: 'You know you have accidental complexity if you’ve ever experienced the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经经历以下情况，则说明您有偶发复杂性：
- en: Things that sound simple (adding users, changing a UI control, etc.) are non-trivial
    to implement.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看起来简单的事情（例如添加用户、更改UI控件等）实际上并不容易实现。
- en: Difficulty onboarding new developers into understanding your codebase. New developers
    on a project are your best indicators of how maintainable your code is right now—no
    need to wait years.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 难以使新开发者理解您的代码库入职困难。项目中的新开发者是评估当前代码可维护性的最佳指标 —— 无需等待多年。
- en: Estimates for adding functionality are always high, yet you slip the schedule
    nonetheless.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加功能的估算总是很高，然而您仍然会超时。
- en: Remove accidental complexity and isolate your necessary complexity wherever
    possible. Those will be the stumbling blocks for your future collaborators. These
    sources of complexity compound miscommunication, as they obscure and diffuse intent
    throughout the codebase.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能消除意外复杂性，并将必要的复杂性隔离开来。这些将成为未来合作者的绊脚石。这些复杂性的来源会加剧沟通不畅，因为它们会在代码库中模糊和扩散意图。
- en: Discussion Topic
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论主题
- en: What accidental complexities do you have in your codebase? How challenging would
    it be to understand simple concepts if you were dropped into the codebase with
    no communication to other developers? What can you do to simplify complexities
    identified in this exercise (especially if they are in often-changing code)?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码库中有哪些意外复杂性？如果你被丢到没有与其他开发者沟通的代码库中，理解简单的概念会有多大挑战？在本练习中，你能做些什么来简化识别出的复杂性（特别是它们经常变化的代码中）？
- en: Throughout the rest of the book, I will look at different techniques for communicating
    intent in Python.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我将探讨在Python中传达意图的不同技术。
- en: Closing Thoughts
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结语
- en: Robust code matters. Clean code matters. Your code needs to be maintainable
    for the entire lifetime of the codebase, and in order to ensure that outcome,
    you need to put active foresight into what you are communicating and how. You
    need to clearly embody your knowledge as close to the code as possible. It will
    feel like a burden to continuously look forward, but with practice it becomes
    natural, and you start reaping the benefits as you work in your own codebase.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 强大的代码很重要。清晰的代码很重要。你的代码需要在整个代码库的生命周期内都能够维护，为了确保这一点，你需要在你所传达的内容和方式上投入积极的前瞻性。你需要尽可能清晰地体现你的知识。不断朝前看可能会感到负担，但通过实践，这会变得自然，并且你开始在自己的代码库中享受成果。
- en: Every time you map a real-world concept to code, you are creating an abstraction,
    whether it is through the use of a collection or your decision to keep functions
    separate. Every abstraction is a choice, and every choice communicates something,
    whether intentional or not. I encourage you to think about each line of code you
    are writing and ask yourself, “What will a future developer learn from this?”
    You owe it to future maintainers to enable them to deliver value at the same speed
    that you can today. Otherwise, your codebase will get bloated, schedules will
    slip, and complexity will grow. It is your job as a developer to mitigate that
    risk.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你将现实世界的概念映射到代码时，你都在创建一个抽象，无论是通过使用集合还是决定保持函数分离。每个抽象都是一个选择，每个选择都传达着某种信息，无论是有意还是无意的。我鼓励你思考每一行代码你正在写的内容，并问自己，“未来的开发者会从中学到什么？”你有责任让未来的维护者能够以与你今天相同的速度交付价值。否则，你的代码库将变得臃肿，进度将滑坡，复杂性将增加。作为开发者，你的工作就是减少这种风险。
- en: Look for potential hotspots, such as incorrect abstractions (such as collections
    or iteration) or accidental complexity. These are prime areas where communication
    can break down over time. If these types of hotspots are in areas that change
    often, they are a priority to address now.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找潜在的热点，比如不正确的抽象（如集合或迭代），或意外的复杂性。这些是随着时间推移可能导致沟通中断的主要区域。如果这些热点位于经常变化的区域，现在就应该优先处理。
- en: 'In the next chapter, you’re going to take what you learned from this chapter
    and apply it to a fundamental Python concept: types. The types you choose express
    your intent to future developers, and picking the correct types will lead to better
    maintainability.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将会将本章学到的内容应用到一个基本的Python概念中：类型。你选择的类型表达了你对未来开发者的意图，选择正确的类型将有助于提高可维护性。
- en: ^([1](part0003_split_000.html#idm45644759414136-marker)) Charles Antony Richard
    Hoare. “The Emperor’s Old Clothes.” *Commun. ACM* 24, 2 (Feb. 1981), 75–83\. [*https://doi.org/10.1145/358549.358561*](https://doi.org/10.1145/358549.358561).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](part0003_split_000.html#idm45644759414136-marker)) 查尔斯·安东尼·理查德·霍尔。"皇帝的旧衣服"。*Commun.
    ACM* 24, 2 (1981年2月), 75–83\. [*https://doi.org/10.1145/358549.358561*](https://doi.org/10.1145/358549.358561)。
- en: ^([2](part0003_split_002.html#idm45644754042936-marker)) Yak-shaving describes
    a situation where you frequently have to solve unrelated problems before you can
    even begin to tackle the original problem. You can learn about the origins of
    the term at [*https://oreil.ly/4iZm7*](https://oreil.ly/4iZm7).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](part0003_split_002.html#idm45644754042936-marker)) "Yak-shaving" 描述了一种情况，即在解决原始问题之前，你经常不得不解决不相关的问题。你可以在
    [*https://oreil.ly/4iZm7*](https://oreil.ly/4iZm7) 了解这个术语的起源。
- en: ^([3](part0003_split_009.html#idm45644757634344-marker)) Geoffrey James. *The
    Tao of Programming*. [*https://oreil.ly/NcKNK*](https://oreil.ly/NcKNK).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](part0003_split_009.html#idm45644757634344-marker)) Geoffrey James。*程序设计之道*。[*https://oreil.ly/NcKNK*](https://oreil.ly/NcKNK)。
- en: '^([4](part0003_split_009.html#idm45644757628952-marker)) A bug that displays
    different behavior when being observed. *SIGSOFT ’83: Proceedings of the ACM SIGSOFT/SIGPLAN
    software engineering symposium on High-level debugging*.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '^([4](part0003_split_009.html#idm45644757628952-marker)) 当被观察时显示不同行为的一个 bug。*SIGSOFT
    ’83: ACM SIGSOFT/SIGPLAN 软件工程高级调试研讨会论文集*。'
