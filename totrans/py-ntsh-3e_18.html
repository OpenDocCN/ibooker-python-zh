<html><head></head><body>
<div id="sbo-rt-content"><section data-nutshell-tab="Networking Basics" data-pdf-bookmark="Chapter 18. Networking Basics" data-type="chapter" epub:type="chapter"><div class="chapter" id="networking_basics">
<h1><span class="label">Chapter 18. </span>Networking Basics</h1>
<p><em>Connection-oriented</em> protocols<a contenteditable="false" data-primary="networking basics" data-secondary="overview of" data-type="indexterm" id="idm44924490434560"/><a contenteditable="false" data-primary="connection-oriented protocols" data-type="indexterm" id="idm44924490433152"/> work like making a telephone call. You request a connection to a particular<a contenteditable="false" data-primary="network endpoints" data-type="indexterm" id="idm44924490431952"/> <em>network endpoint</em> (equivalent to dialing somebody’s phone number), and your party either answers or doesn’t. If they do, you can talk to them and hear them talking back (simultaneously, if necessary), and you know that nothing is getting lost. At the end of the conversation you both say goodbye and hang up, so it’s obvious something has gone wrong if that closing event doesn’t occur (for example, if you just suddenly stop hearing the other party). The<a contenteditable="false" data-primary="Transmission Control Protocol (TCP)" data-type="indexterm" id="idm44924490430272"/><a contenteditable="false" data-primary="TCP (Transmission Control Protocol)" data-type="indexterm" id="idm44924490429200"/> Transmission Control Protocol (TCP) is the main connection-oriented transport protocol of the internet, used by web browsers, secure shells, email, and many other applications.</p>
<p><em>Connectionless</em> or <em>datagram</em> protocols<a contenteditable="false" data-primary="connectionless protocols" data-type="indexterm" id="idm44924490426976"/><a contenteditable="false" data-primary="datagram protocols" data-type="indexterm" id="idm44924490425872"/> work more like communicating by sending postcards. Mostly, the messages get through, but if anything goes wrong you have to be prepared to cope with the consequences—the protocol doesn’t notify you whether your messages have been received, and messages can arrive out of order. For exchanging short messages and getting answers, datagram protocols have less overhead than connection-oriented ones, as long as the overall service can cope with occasional disruptions. For example, a Domain Name Service (DNS) server may fail to respond: most DNS communication was until recently connectionless. The User Datagram Protocol (UDP)<a contenteditable="false" data-primary="User Datagram Protocol (UDP)" data-type="indexterm" id="idm44924490424640"/><a contenteditable="false" data-primary="UDP (User Datagram Protocol)" data-type="indexterm" id="idm44924490423568"/> is the main connectionless transport protocol for internet communications.</p>
<p>Nowadays, security is increasingly important: understanding the underlying basis of secure communications helps you ensure that your communications are as secure as they need to be. If this summary dissuades you from trying to implement such technology yourself without a thorough understanding of the issues and risks, it will have served a worthwhile purpose.</p>
<p>All communications across network interfaces exchange strings of bytes. To communicate text, or indeed most other information, the sender must encode it as bytes, which the receiver must decode. We limit our discussion in this chapter to the case of a single sender and a single receiver.</p>
<section data-pdf-bookmark="The Berkeley Socket Interface" data-type="sect1"><div class="sect1" id="the_berkeley_socket_interface">
<h1>The Berkeley Socket Interface</h1>
<p>Most<a contenteditable="false" data-primary="networking basics" data-secondary="Berkeley socket interface" data-type="indexterm" id="NBbsocket18"/><a contenteditable="false" data-primary="Berkeley socket interface" data-secondary="networking using sockets" data-type="indexterm" id="idm44924490417696"/><a contenteditable="false" data-primary="sockets" data-secondary="networking using" data-type="indexterm" id="idm44924490416352"/> networking nowadays uses <em>sockets.</em> Sockets give access to pipelines between independent endpoints, using a<a contenteditable="false" data-primary="transport layer protocol" data-type="indexterm" id="idm44924490414432"/> <em>transport layer protocol</em> to move information between those endpoints. The socket concept is general enough that the endpoints can be on the same computer, or on different computers networked together, either locally or via a wide area network.</p>
<p>The most frequently used transport layers today are UDP (for connectionless networking) and TCP (for connection-oriented networking); each is carried over a common Internet Protocol (IP) network layer. This stack of protocols, along with the many application protocols that run over them, is collectively known as<a contenteditable="false" data-primary="TCP/IP protocols" data-type="indexterm" id="idm44924490412528"/> <em>TCP/IP.</em> A good introduction is Gordon McMillan’s (dated but still perfectly valid) <a href="https://oreil.ly/9Y5pc"><em>Socket Programming HOWTO</em></a>.</p>
<p>The<a contenteditable="false" data-primary="sockets" data-secondary="internet and Unix sockets" data-type="indexterm" id="idm44924490409616"/><a contenteditable="false" data-primary="internet sockets" data-type="indexterm" id="idm44924490408240"/><a contenteditable="false" data-primary="Unix sockets" data-type="indexterm" id="idm44924490407136"/> two most common socket families are <em>internet sockets</em> based on TCP/IP communications (available in two flavors, to accommodate the modern IPv6 and the more traditional IPv4) and <em>Unix sockets</em>, though other families are also available. Internet sockets allow communication between any two computers that can exchange IP datagrams; Unix sockets can only communicate between processes on the same Unix machine.</p>
<p>To support many concurrent internet sockets, the TCP/IP protocol stack uses endpoints identified by an IP address, a<a contenteditable="false" data-primary="port numbers" data-type="indexterm" id="idm44924490404528"/> <em>port number</em>, and a protocol. The port numbers allow protocol handling software to distinguish between different endpoints at the same IP address using the same protocol. A connected socket is also associated with a<a contenteditable="false" data-primary="remote endpoints" data-type="indexterm" id="idm44924490402848"/> <em>remote endpoint</em>, the counterparty socket to which it is connected and with which it can communicate.</p>
<p>Most Unix sockets have names in the Unix filesystem. On Linux platforms, sockets whose names begin with a zero byte live in a name pool maintained by the kernel. These are useful for communicating with a<a contenteditable="false" data-primary="chroot-jail process" data-type="indexterm" id="idm44924490400752"/> <a href="https://oreil.ly/qvgaC">chroot-jail process</a>, for example, where no filesystem is shared between two processes.</p>
<p>Both internet and Unix sockets support connectionless and connection-oriented networking, so if you write your programs carefully, they can work over either socket family. It is beyond the scope of this book to discuss other socket families, though we should mention that<a contenteditable="false" data-primary="raw sockets" data-type="indexterm" id="idm44924490398384"/><a contenteditable="false" data-primary="sockets" data-secondary="raw sockets" data-type="indexterm" id="idm44924490397280"/> <em>raw sockets</em>, a subtype of the internet socket family, let you send and receive link layer packets (for example, Ethernet packets) directly. This is useful for some experimental applications and for<a contenteditable="false" data-primary="packet sniffing" data-type="indexterm" id="idm44924490395520"/> <a href="https://oreil.ly/bmYSI">packet sniffing</a>.</p>
<p>After creating an internet socket, you can<a contenteditable="false" data-primary="binding" data-secondary="port numbers" data-type="indexterm" id="idm44924490392992"/> associate (<em>bind</em>) a specific port number with the socket (as long as that port number is not in use by some other socket). This is the strategy many servers use, offering service on so-called <a href="https://oreil.ly/Y2XeE"><em>well-known port numbers</em></a> defined by internet standards as being in the range 1–1,023. On Unix systems, <em>root</em> privileges<a contenteditable="false" data-primary="root privileges" data-type="indexterm" id="idm44924490389808"/> are required to gain access to these ports. A typical client is unconcerned with the port number it uses, and so it typically requests an <em>ephemeral port</em>, assigned by the protocol driver and guaranteed to be unique on that host. There is no need to bind client ports.</p>
<p>Consider two processes on the same computer, each acting as a client to the same remote server. The full association for their sockets has five components, <span class="code">(local_IP_address, local_port_number, protocol, remote_IP_address, remote_port_number)</span>. When packets arrive at the remote server, the destination, source IP address, destination port number, and protocol are the same for both clients. The guarantee of uniqueness for ephemeral port numbers lets the server distinguish between traffic from the two clients. This is how TCP/IP handles multiple conversations between the same two IP addresses.<sup><a data-type="noteref" href="ch18.xhtml#ch01fn136" id="ch01fn136-marker">1</a></sup></p>
<section data-pdf-bookmark="Socket Addresses" data-type="sect2"><div class="sect2" id="socket_addresses">
<h2>Socket Addresses</h2>
<p>The<a contenteditable="false" data-primary="Berkeley socket interface" data-secondary="socket addresses" data-type="indexterm" id="idm44924490383152"/><a contenteditable="false" data-primary="sockets" data-secondary="socket addresses" data-type="indexterm" id="idm44924490381776"/> different types of sockets use different address formats:</p>
<ul>
<li>
<p>Unix socket addresses are strings naming a node in the filesystem (on Linux platforms, bytestrings starting with <span class="code">b'\0'</span> and corresponding to names in a kernel table).</p>
</li>
<li>
<p>IPv4 socket addresses are <span class="code">(<em>address</em>,</span> <span class="code"><em>port</em></span><span class="code">)</span> pairs. The first item is an IPv4 address, the second a port number in the range 1–65,535.</p>
</li>
<li>
<p>IPv6 socket addresses are four-item <span class="code">(<em>address</em>,</span> <span class="code"><em>port</em></span><span class="code">,</span> <span class="code"><em>flowinfo</em></span><span class="code">,</span> <span class="code"><em>scopeid</em></span><span class="code">)</span> tuples. When providing an address as an argument, the <span class="code"><em>flowinfo</em></span> and <span class="code"><em>scopeid</em></span> items can generally be omitted, as long as the <a href="https://oreil.ly/RcIfb">address scope</a> is unimportant.</p>
</li>
</ul>
</div></section>
<section data-pdf-bookmark="Client/Server Computing" data-type="sect2"><div class="sect2" id="clientsolidusserver_computing">
<h2>Client/Server Computing</h2>
<p>The<a contenteditable="false" data-primary="Berkeley socket interface" data-secondary="client/server computing" data-type="indexterm" id="BSIclserv18"/><a contenteditable="false" data-primary="client/server computing" data-type="indexterm" id="clsercomp18"/> pattern we discuss hereafter is usually referred to as <em>client/server</em> networking, where a <em>server</em> listens for traffic on a specific endpoint from <em>clients</em> requiring the service. We do not cover<a contenteditable="false" data-primary="peer-to-peer networking" data-type="indexterm" id="idm44924490358432"/> <em>peer-to-peer</em> networking, which, lacking any central server, has to include the ability for peers to discover each other.</p>
<p>Most, though by no means all, network communication is performed using client/server techniques. The server listens for incoming traffic at a predetermined or advertised network endpoint. In the absence of such input, it does nothing, simply sitting there waiting for input from clients. Communication is somewhat different between connectionless and connection-oriented endpoints.</p>
<p>In<a contenteditable="false" data-primary="connectionless protocols" data-type="indexterm" id="idm44924490355920"/> connectionless networking, such as via UDP, requests arrive at a server randomly and are dealt with immediately: a response is dispatched to the requester without delay. Each request is handled on its own, usually without reference to any communications that may previously have occurred between the two parties. Connectionless networking is well suited to short-term, stateless interactions such as those required by DNS or network booting.</p>
<p>In<a contenteditable="false" data-primary="connection-oriented protocols" data-type="indexterm" id="idm44924490354048"/> connection-oriented networking, the client engages in an initial exchange with the server that effectively establishes a connection across a network pipeline between two processes (sometimes referred to as a<a contenteditable="false" data-primary="virtual circuits" data-type="indexterm" id="idm44924490352800"/> <a href="https://oreil.ly/ePVQo"><em>virtual circuit</em></a>), across which the processes can communicate until both indicate their willingness to end the connection. In this case, serving needs to use parallelism (via a concurrency mechanism such as threads, processes, or asynchronicity: see <a data-type="xref" href="ch15.xhtml#concurrency_threads_and_processes">Chapter 15</a>) to handle each incoming connection asynchronously or simultaneously. Without parallelism, the server would be unable to handle new incoming connections before earlier ones have terminated, since calls to socket methods normally <em>block</em> (meaning they pause the thread calling them until they terminate or time out). Connections are the best way to handle lengthy interactions such as mail exchanges, command-line shell interactions, or the transmission of web content, and offer automatic error detection and correction when they use TCP.</p>
<section data-pdf-bookmark="Connectionless client and server structures" data-type="sect3"><div class="sect3" id="connectionless_client_and_server_struct">
<h3>Connectionless client and server structures</h3>
<p>The broad logic flow of a connectionless server proceeds as follows:</p>
<ol>
<li>
<p>Create a socket of type <span class="code">socket.SOCK_DGRAM</span> by calling <span class="code">socket.socket</span>.</p>
</li>
<li>
<p>Associate the socket with the service endpoint by calling the socket’s <span class="code">bind</span> method.</p>
</li>
<li>
<p>Repeat the following steps <em>ad infinitum</em>:</p>
<ol type="a">
<li>
<p>Request an incoming datagram from a client by calling the socket’s <span class="code">recvfrom</span> method; this call blocks until a datagram is received.</p>
</li>
<li>
<p>Compute or look up the result.</p>
</li>
<li>
<p>Send the result back to the client by calling the socket’s <span class="code">sendto</span> method.</p>
</li>
</ol>
</li>
</ol>
<p>The server spends most of its time in step 3a, awaiting input from clients.</p>
<p>A connectionless client’s interaction with the server proceeds as follows:</p>
<ol>
<li>
<p>Create a socket of type <span class="code">socket.SOCK_DGRAM</span> by calling <span class="code">socket.socket</span>.</p>
</li>
<li>
<p>Optionally, associate the socket with a specific endpoint by calling the socket’s <span class="code">bind</span> method.</p>
</li>
<li>
<p>Send a request to the server’s endpoint by calling the socket’s <span class="code">sendto</span> method.</p>
</li>
<li>
<p>Await the server reply by calling the socket’s <span class="code">recvfrom</span> method; this call blocks until the response is received. It’s necessary to apply a <em>timeout</em> to this call, to handle the case where a datagram goes missing and the program must either retry or abort the attempt: connectionless sockets don’t guarantee delivery.</p>
</li>
<li>
<p>Use the result in the remainder of the client program’s logic.</p>
</li>
</ol>
<p>A single client program can perform several interactions with the same or multiple servers, depending on the services it needs to use. Many such interactions are hidden from the application programmer inside library code. A typical example is the resolution of a hostname to the appropriate network address, which commonly uses the <span class="code">gethostbyname</span> library function (implemented in Python’s <span class="code">socket</span> module, discussed shortly). Connectionless interactions normally involve sending a single packet to the server and receiving a single packet in response. The main exceptions involve <em>streaming</em> protocols such as the Real-time Transport Protocol (RTP),<sup><a data-type="noteref" href="ch18.xhtml#ch01fn137" id="ch01fn137-marker">2</a></sup> which are typically layered on top of UDP to minimize latency and delays: in streaming, many datagrams are sent and received.</p>
</div></section>
<section data-pdf-bookmark="Connection-oriented client and server structures" data-type="sect3"><div class="sect3" id="connection_oriented_client_and_server_s">
<h3>Connection-oriented client and server structures</h3>
<p>The broad flow of logic of a connection-oriented server is as follows:</p>
<ol>
<li>
<p>Create a socket of type <span class="code">socket.SOCK_STREAM</span> by calling <span class="code">socket.socket</span>.</p>
</li>
<li>
<p>Associate the socket with the appropriate server endpoint by calling the socket’s <span class="code">bind</span> method.</p>
</li>
<li>
<p>Start the endpoint listening for connection requests by calling the socket’s <span class="code">listen</span> method.</p>
</li>
<li>
<p>Repeat the following steps <em>ad infinitum</em>:</p>
<ol type="a">
<li>
<p>Await an incoming client connection by calling the socket’s <span class="code">accept</span> method; the server process blocks until an incoming connection request is received. When such a request arrives, a new socket object is created whose other endpoint is the client program.</p>
</li>
<li>
<p>Create a new control thread or process to handle this specific connection, passing it the newly created socket; the main thread of control then continues by looping back to step 4a.</p>
</li>
<li>
<p>In the new control thread, interact with the client using the new socket’s <span class="code">recv</span> and <span class="code">send</span> methods, respectively, to read data from the client and send data to it. The <span class="code">recv</span> method blocks until data is available from the client (or the client indicates it wishes to close the connection, in which case <span class="code">recv</span> returns an empty result). The <span class="code">send</span> method only blocks when the network software has so much data buffered that communication has to pause until the transport layer has emptied some of its buffer memory. When the server wishes to close the connection, it can do so by calling the socket’s <span class="code">close</span> method, optionally calling its <span class="code">shutdown</span> method first.</p>
</li>
</ol>
</li>
</ol>
<p>The server spends most of its time in step 4a, awaiting connection requests from clients.</p>
<p>A connection-oriented client’s overall logic is as follows:</p>
<ol>
<li>
<p>Create a socket of type <span class="code">socket.SOCK_STREAM</span> by calling <span class="code">socket.socket</span>.</p>
</li>
<li>
<p>Optionally, associate the socket with a specific endpoint by calling the socket’s <span class="code">bind</span> method.</p>
</li>
<li>
<p>Establish a connection to the server by calling the socket’s <span class="code">connect</span> method.</p>
</li>
<li>
<p>Interact with the server using the socket’s <span class="code">recv</span> and <span class="code">send</span> methods, respectively, to read data from the server and send data to it. The <span class="code">recv</span> method blocks until data is available from the server (or the server indicates it wishes to close the connection, in which case the <span class="code">recv</span> call returns an empty result). The <span class="code">send</span> method only blocks when the network software has so much data buffered that communications have to pause until the transport layer has emptied some of its buffer memory. When the client wishes to close the connection, it can do so by calling the socket’s <span class="code">close</span> method, optionally calling its <span class="code">shutdown</span> method first.</p>
</li>
</ol>
<p>Connection-oriented interactions tend to be more complex than connectionless ones. Specifically, determining when to read and write data is more complicated, because inputs must be parsed to determine when a transmission from the other end of the socket is complete. The higher-layer protocols used in connection-oriented networking accommodate this determination; sometimes this is done by indicating the data length as a part of the content, sometimes by more sophisticated methods.<a contenteditable="false" data-primary="" data-startref="BSIclserv18" data-type="indexterm" id="idm44924490289120"/><a contenteditable="false" data-primary="" data-startref="clsercomp18" data-type="indexterm" id="idm44924490287744"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="The socket Module" data-type="sect2"><div class="sect2" id="the_socket_module">
<h2>The socket Module</h2>
<p>Python’s <span class="code">socket</span> module<a contenteditable="false" data-primary="Berkeley socket interface" data-secondary="socket module" data-type="indexterm" id="BSIsmod18"/><a contenteditable="false" data-primary="socket module" data-type="indexterm" id="socmod18"/><a contenteditable="false" data-primary="standard library modules" data-secondary="socket" data-type="indexterm" id="idm44924490280560"/><a contenteditable="false" data-primary="is keyword" data-type="indexterm" id="iskey18"/> handles networking with the socket interface. There are minor differences between platforms, but the module hides most of them, making it relatively easy to write portable networking applications.</p>
<p>The module defines three exception classes, all subclasses of the built-in exception class <span class="code">OSError</span> (see <a data-type="xref" href="#socket_module_exception_classes">Table 18-1</a>).</p>
<table class="border" id="socket_module_exception_classes">
<caption><span class="label">Table 18-1. </span><span class="code">socket</span> module exception classes</caption>
<tbody>
<tr>
<td><span class="code">herror</span></td>
<td>Identifies hostname resolution errors: e.g., <span class="code">socket.gethostbyname</span> cannot convert a name to a network address, or <span class="code">socket.gethostbyaddr</span> can find no hostname for a network address. The accompanying value is a two-element tuple <span class="code">(<em>h_errno</em>,</span> <span class="code"><em>string</em></span><span class="code">)</span>, where <span class="code"><em>h_errno</em></span> is the integer error number from the operating system, and <span class="code"><em>string</em></span> is a description of the error.</td>
</tr>
<tr>
<td><span class="code">gaierror</span></td>
<td>Identifies addressing errors encountered in <span class="code">socket.getaddrinfo</span> or <span class="code">socket.getnameinfo</span>.</td>
</tr>
<tr>
<td><span class="code">timeout</span></td>
<td>Raised when an operation takes longer than the timeout limit (as per <span class="code">socket.setdefaulttimeout</span>, overridable on a per-socket basis).</td>
</tr>
</tbody>
</table>
<p>The module defines many constants. The most important of these are the address families (<span class="code">AF_*</span>) and the socket types (<span class="code">SOCK_*</span>) listed in <a data-type="xref" href="#important_constants_defined_in_the_sock">Table 18-2</a>, members of <span class="code">IntEnum</span> collections. The module also defines many other constants used to set socket options, but the documentation does not define them fully: to use them you must be familiar with documentation for the C sockets library and system calls.</p>
<table class="border" id="important_constants_defined_in_the_sock">
<caption><span class="label">Table 18-2. </span>Important constants defined in the <span class="code">socket</span> module</caption>
<tbody>
<tr>
<td><span class="code">AF_BLUETOOTH</span></td>
<td>Used to create sockets of the Bluetooth address family, used in mobile and Personal Area Network (PAN) applications.</td>
</tr>
<tr>
<td><span class="code">AF_CAN</span></td>
<td>Used to create sockets for the Controller Area Network (CAN) address family, widely used in automation, automotive, and embedded device applications.</td>
</tr>
<tr>
<td><span class="code">AF_INET</span></td>
<td>Used to create sockets of the IPv4 address family.</td>
</tr>
<tr>
<td><span class="code">AF_INET6</span></td>
<td>Used to create sockets of the IPv6 address family.</td>
</tr>
<tr>
<td><span class="code">AF_UNIX</span></td>
<td>Used to create sockets of the Unix address family. This constant is only defined on platforms that make Unix sockets available.</td>
</tr>
<tr>
<td><span class="code">SOCK_DGRAM</span></td>
<td>Used to create connectionless sockets, which provide best-effort message delivery without connection capabilities or error detection.</td>
</tr>
<tr>
<td><span class="code">SOCK_RAW</span></td>
<td>Used to create sockets that give direct access to the link layer drivers; typically used to implement lower-level network features.</td>
</tr>
<tr>
<td><span class="code">SOCK_RDM</span></td>
<td>Used to create reliable connectionless message sockets used in the Transparent Inter Process Communication (TIPC) protocol.</td>
</tr>
<tr>
<td><span class="code">SOCK_SEQPACKET</span></td>
<td>Used to create reliable connection-oriented message sockets used in the TIPC protocol.</td>
</tr>
<tr>
<td><span class="code">SOCK_STREAM</span></td>
<td>Used to create connection-oriented sockets, which provide full error detection and correction facilities.</td>
</tr>
</tbody>
</table>
<p>The module defines many functions to create sockets, manipulate address information, and assist with standard representations of data. We do not cover all of them in this book, as the socket module’s <a href="https://oreil.ly/LU9FI">documentation</a> is fairly comprehensive; we deal only with those that are essential in writing networked applications.</p>
<p>The <span class="code">socket</span> module contains many functions, most of which are only used in specific situations. For example, when communication takes place between network endpoints, the computers at either end might have architectural differences and represent the same data in different ways, so there are functions to handle translation of a limited number of data types to and from a network-neutral form. <a data-type="xref" href="#useful_functions_of_the_socket_module">Table 18-3</a> lists a few of the more generally applicable functions this module provides.</p>
<table class="border" id="useful_functions_of_the_socket_module">
<caption><span class="label">Table 18-3. </span>Useful functions of the <span class="code">socket</span> module</caption>
<tbody>
<tr>
<td><span class="code">getaddrinfo</span></td>
<td><span class="code">socket.getaddrinfo(<em>host</em>,</span> <span class="code"><em>port</em></span><span class="code">, family=0, type=0, proto=0, flags=0)</span><br/>
			Takes a <span class="code"><em>host</em></span> and <span class="code"><em>port</em></span> and returns a list of five-item tuples of the form <span class="code">(family, type, proto,</span> <span class="code"><em>canonical_name, socket</em></span><span class="code">)</span> usable to create a socket connection to a specific service. <span class="code"><em>canonical_name</em></span> is an empty string unless the <span class="code">socket.AI_CANONNAME</span> bit is set in the <span class="code">flags</span> argument. When you pass a hostname rather than an IP address, <span class="code">getaddrinfo</span> returns a list of tuples, one per IP address associated with the name.</td>
</tr>
<tr>
<td><span class="code">getdefa⁠u⁠l⁠t​t⁠i⁠m⁠eout</span></td>
<td><span class="code">socket.getdefaulttimeout()</span><br/>
			Returns the default timeout value in seconds for socket operations, or <span class="code"><strong>None</strong></span> if no value has been set. Some functions let you specify explicit timeouts.</td>
</tr>
<tr>
<td><span class="code">getfqdn</span></td>
<td><span class="code">socket.getfqdn([<em>host</em>])</span><br/>
			Returns the fully qualified domain name associated with a hostname or network address (by default, that of the computer on which you call it).</td>
</tr>
<tr>
<td><span class="code">gethostbyaddr</span></td>
<td><span class="code">socket.gethostbyaddr(<em>ip_address</em>)</span><br/>
			Takes<a contenteditable="false" data-primary="gethostbyaddr (socket module)" data-type="indexterm" id="idm44924490207552"/> a string containing an IPv4 or IPv6 address and returns a three-item tuple of the form <span class="code">(<em>hostname</em>,</span> <span class="code"><em>aliaslist</em></span><span class="code">,</span> <span class="code"><em>ipaddrlist</em></span><span class="code">)</span>. <span class="code"><em>hostname</em></span> is the canonical name for the IP address, <span class="code"><em>aliaslist</em></span> is a list of alternative names, and <span class="code"><em>ipaddrlist</em></span> is a list of IPv4 and IPv6 addresses.</td>
</tr>
<tr>
<td><span class="code">gethostbyname</span></td>
<td><span class="code">socket.gethostbyname(hostname)</span><br/>
			Returns<a contenteditable="false" data-primary="gethostbyname (socket module)" data-type="indexterm" id="idm44924490197376"/> a string containing the IPv4 address associated with the given hostname. If called with an IP address, returns that address. This function does not support IPv6: use <span class="code">getaddrinfo</span> for IPv6.</td>
</tr>
<tr>
<td><span class="code">getnameinfo</span></td>
<td><span class="code">socket.getnameinfo(<em>sock_addr</em>, flags=0)</span><br/>
			Takes a socket address and returns a <span class="code">(<em>host</em>,</span> <span class="code"><em>port</em></span><span class="code">)</span> pair. Without <span class="code">flags</span><em>,</em> <span class="code"><em>host</em></span> is an IP address and <span class="code"><em>port</em></span> is an <span class="code">int</span>.</td>
</tr>
<tr>
<td><span class="code">setdefa⁠u⁠l⁠t​t⁠i⁠m⁠eout</span></td>
<td><span class="code">socket.setdefaulttimeout(<em>timeout</em>)</span><br/>
			Sets<a contenteditable="false" data-primary="setdefaulttimeout (socket module)" data-type="indexterm" id="idm44924490183216"/> sockets’ default timeout as a value in floating-point seconds. Newly created sockets operate in the mode determined by the <span class="code"><em>timeout</em></span> value, as discussed in the next section. Pass <span class="code"><em>timeout</em></span> as <span class="code"><strong>None</strong></span> to cancel the implicit use of timeouts on subsequently created sockets.<a contenteditable="false" data-startref="BSIsmod18" data-type="indexterm" id="idm44924490179200"/><a contenteditable="false" data-primary="" data-startref="socmod18" data-type="indexterm" id="idm44924490178128"/><a contenteditable="false" data-primary="" data-startref="iskey18" data-type="indexterm" id="idm44924490176752"/></td>
</tr>
</tbody>
</table>
</div></section>
<section data-pdf-bookmark="Socket Objects" data-type="sect2"><div class="sect2" id="socket_objects">
<h2>Socket Objects</h2>
<p>The<a contenteditable="false" data-primary="Berkeley socket interface" data-secondary="socket objects" data-type="indexterm" id="BSIsobj18"/><a contenteditable="false" data-primary="socket objects" data-type="indexterm" id="sockobj18"/> socket object is the primary means of network communication in Python. A new socket is also created when a <span class="code">SOCK_STREAM</span> socket accepts a connection, each such socket being used to communicate with the relevant client.</p>
<div data-type="tip">
<h1>Socket Objects and with Statements</h1>
<p>Every socket object<a contenteditable="false" data-primary="with statement" data-type="indexterm" id="idm44924490167808"/> is a context manager: you can use any socket object in a <span class="code"><strong>with</strong></span> statement to ensure proper termination of the socket at exit from the statement’s body. For further details, see <a data-type="xref" href="ch06.xhtml#the_with_statement_and_context_managers">“The with Statement and Context Managers”</a>.</p>
</div>
<p>There are several ways to create a socket, as detailed in the next section. Sockets can operate in three different modes, shown in <a data-type="xref" href="#timeout_values_and_their_associated_mod">Table 18-4</a>, according to the timeout value, which can be set in different ways:</p>
<ul>
<li>
<p>By providing the timeout value as an argument on socket creation</p>
</li>
<li>
<p>By calling the socket object’s <span class="code">settimeout</span> method</p>
</li>
<li>
<p>According to the <span class="code">socket</span> module’s default timeout value as returned by the <span class="code">socket.getdefaulttimeout</span> function</p>
</li>
</ul>
<p>The timeout values to establish each possible mode are listed in <a data-type="xref" href="#timeout_values_and_their_associated_mod">Table 18-4</a>.</p>
<table class="border" id="timeout_values_and_their_associated_mod">
<caption><span class="label">Table 18-4. </span>Timeout values and their associated modes</caption>
<tbody>
<tr>
<td><span class="code"><strong>None</strong></span></td>
<td>Sets <em>blocking</em> mode. Each operation suspends the thread (<em>blocks</em>) until the operation completes, unless the operating system raises an exception.</td>
</tr>
<tr>
<td><span class="code">0</span></td>
<td>Sets <em>nonblocking</em> mode. Each operation raises an exception when it cannot be completed immediately, or when an error occurs. Use the <a href="https://oreil.ly/UBypi"><span class="code">selectors</span> module</a> to find out whether an operation can be completed immediately.</td>
</tr>
<tr>
<td><span class="code">&gt;0.0</span></td>
<td>Sets <em>timeout</em> mode. Each operation blocks until complete, or the timeout elapses (in which case it raises a <span class="code">socket.timeout</span> exception), or an error occurs.</td>
</tr>
</tbody>
</table>
<p>Socket objects represent network endpoints. The <span class="code">socket</span> module supplies several functions to create a socket (see <a data-type="xref" href="#socket_creation_functions">Table 18-5</a>).</p>
<table class="border" id="socket_creation_functions">
<caption><span class="label">Table 18-5. </span>Socket creation functions</caption>
<tbody>
<tr>
<td class="width-10"><span class="code">cre⁠a⁠t⁠e⁠_​c⁠o⁠n⁠n⁠e⁠c⁠t⁠i⁠o⁠n</span></td>
<td><span class="code">create_connection([<em>address</em>[,</span> <span class="code"><em>timeout</em></span><span class="code">[,</span> <span class="code"><em>source_address</em></span><span class="code">]]])</span><br/>
			Creates a socket connected to a TCP endpoint at an address (a <span class="code">(<em>host</em>,</span> <span class="code"><em>port</em></span><span class="code">)</span> pair). <span class="code"><em>host</em></span> can either be a numeric network address or a DNS hostname; in the latter case, name resolution is attempted for both <span class="code">AF_INET</span> and <span class="code">AF_INET6</span> (in unspecified order), then a connection is attempted to each returned address in turn—a convenient way to create client programs able to use either IPv6 or IPv4.<br/>
			The <span class="code"><em>timeout</em></span> argument, if given, specifies the connection timeout in seconds and thereby sets the socket’s mode (see <a data-type="xref" href="#timeout_values_and_their_associated_mod">Table 18-4</a>); when not present, the <span class="code">socket.getdefaulttimeout</span> function is called to determine the value. The <span class="code"><em>source_address</em></span> argument, if given, must also be a <span class="code">(<em>host, port</em>)</span> pair that the remote socket gets passed as the connecting endpoint. When <span class="code"><em>host</em></span> is <span class="code">''</span> or <span class="code"><em>port</em></span> is <span class="code">0</span>, the default OS behavior is used.</td>
</tr>
<tr>
<td><span class="code">socket</span></td>
<td><span class="code">socket(family=AF_INET, type=SOCK_STREAM, proto=0,<br/> fileno=<strong>None</strong>)</span><br/>
			Creates and returns a socket of the appropriate address family and type (by default, a TCP socket on IPv4). Child processes do not inherit the socket thus created. The protocol number <span class="code">proto</span> is only used with CAN sockets. When you pass the <span class="code">fileno</span> argument, other arguments are ignored: the function returns the socket already associated with the given file descriptor.</td>
</tr>
<tr>
<td><span class="code">socketpair</span></td>
<td><span class="code">socketpair([<em>family</em>[,</span> <span class="code"><em>type</em></span><span class="code">[,</span> <span class="code"><em>proto</em></span><span class="code">]]])</span><br/>
			Returns a connected pair of sockets of the given address family, socket type, and (for CAN sockets only) protocol. When <span class="code"><em>family</em></span> is not specified, the sockets are of family <span class="code">AF_UNIX</span> on platforms where the family is available; otherwise, they are of family <span class="code">AF_INET</span>. When <span class="code"><em>type</em></span> is not specified, it defaults to <span class="code">SOCK_STREAM</span>.</td>
</tr>
</tbody>
</table>
<p>A socket object <span class="code"><em>s</em></span> provides the methods listed in <a data-type="xref" href="#methods_of_an_instance_s_of_socket">Table 18-6</a>. Those dealing with connections or requiring connected sockets work only for <span class="code">SOCK_STREAM</span> sockets, while the others work with both <span class="code">SOCK_STREAM</span> and <span class="code">SOCK_DGRAM</span> sockets. For methods that take a <span class="code"><em>flags</em></span> argument, the exact set of flags available depends on your specific platform (the values available are documented on the Unix manual pages for <a href="https://oreil.ly/boM-c"><span class="code">recv(2)</span></a> and <a href="https://oreil.ly/JAaNO"><span class="code">send(</span><span class="code">2</span><span class="code">)</span></a> and in the <a href="https://oreil.ly/90h4R">Windows docs</a>); if omitted, <span class="code"><em>flags</em></span> defaults to <span class="code">0</span>.</p>
<table class="border" id="methods_of_an_instance_s_of_socket">
<caption><span class="label">Table 18-6. </span>Methods of an instance <span class="code">s</span> of <span class="code">socket</span></caption>
<tbody>
<tr>
<td class="width-20"><span class="code">accept</span></td>
<td><span class="code">accept()</span><br/>
			Blocks until a client establishes a connection to <span class="code"><em>s</em></span>, which must have been bound to an address (with a call to <span class="code"><em>s</em></span><span class="code">.bind</span>) and set to listening (with a call to <span class="code"><em>s</em></span><span class="code">.listen</span>). Returns a <em>new</em> socket object, which can be used to communicate with the other endpoint of the connection.</td>
</tr>
<tr>
<td><span class="code">bind</span></td>
<td><span class="code">bind(<em>address</em>)</span><br/>
			Binds <span class="code"><em>s</em></span> to a specific address. The form of the <span class="code"><em>address</em></span> argument depends on the socket’s address family (see <a data-type="xref" href="#socket_addresses">“Socket Addresses”</a>).</td>
</tr>
<tr>
<td><span class="code">close</span></td>
<td><span class="code">close()</span><br/>
			Marks the socket as closed. Calling <span class="code"><em>s</em></span><span class="code">.close</span> does not necessarily close the connection immediately, depending on whether other references to the socket exist. If immediate closure is required, call the <span class="code"><em>s</em></span><span class="code">.shutdown</span> method first. The simplest way to ensure a socket is closed in a timely fashion is to use it in a <span class="code"><strong>with</strong></span> statement, since sockets are context managers.</td>
</tr>
<tr>
<td><span class="code">connect</span></td>
<td><span class="code">connect(<em>address</em>)</span><br/>
			Connects to a remote socket at <span class="code"><em>address</em></span>. The form of the <span class="code"><em>address</em></span> argument depends on the address family (see <a data-type="xref" href="#socket_addresses">“Socket Addresses”</a>).</td>
</tr>
<tr>
<td><span class="code">detach</span></td>
<td><span class="code">detach()</span><br/>
			Puts the socket into closed mode, but allows the socket object to be reused for further connections (by calling <span class="code">connect</span> again).</td>
</tr>
<tr>
<td><span class="code">dup</span></td>
<td><span class="code">dup()</span><br/>
			Returns a duplicate of the socket, not inheritable by child processes.</td>
</tr>
<tr>
<td><span class="code">fileno</span></td>
<td><span class="code">fileno()</span><br/>
			Returns<a contenteditable="false" data-primary="fileno method" data-secondary="socket module" data-type="indexterm" id="idm44924490058560"/> the socket’s file descriptor.</td>
</tr>
<tr>
<td><span class="code">getblocking</span></td>
<td><span class="code">getblocking()</span><br/>
			Returns <span class="code"><strong>True</strong></span> if the socket is set to be blocking, either with a call to <span class="code"><em>s</em></span><span class="code">.setblocking(<strong>True</strong>)</span> or <span class="code"><em>s</em></span><span class="code">.settimeout(<strong>None</strong>)</span>. Otherwise, returns <span class="code"><strong>False</strong></span>.</td>
</tr>
<tr>
<td><span class="code">g⁠e⁠t⁠_​i⁠n⁠h⁠e⁠r⁠i⁠t⁠a⁠b⁠l⁠e</span></td>
<td><span class="code">get_inheritable()</span><br/>
			Returns <span class="code"><strong>True</strong></span> when the socket is able to be inherited by child processes. Otherwise, returns <span class="code"><strong>False</strong></span>.</td>
</tr>
<tr>
<td><span class="code">getpeername</span></td>
<td><span class="code">getpeername()</span><br/>
			Returns the address of the remote endpoint to which this socket is connected.</td>
</tr>
<tr>
<td><span class="code">getsockname</span></td>
<td><span class="code">getsockname()</span><br/>
			Returns the address being used by this socket.</td>
</tr>
<tr>
<td><span class="code">gettimeout</span></td>
<td><span class="code">gettimeout()</span><br/>
			Returns the timeout associated with this socket.</td>
</tr>
<tr>
<td><span class="code">listen</span></td>
<td><span class="code">listen([<em>backlog</em>])</span><br/>
			Starts the socket listening for traffic on its associated endpoint. If given, the integer <span class="code"><em>backlog</em></span> argument determines how many unaccepted connections the operating system allows to queue up before starting to refuse connections.</td>
</tr>
<tr>
<td><span class="code">makefile</span></td>
<td><span class="code">makefile(<em>mode</em>, buffering=<strong>None</strong>, *, encoding=<strong>None</strong>, newline=<strong>None</strong>)</span><br/>
			Returns a file object allowing the socket to be used with file-like operations such as <span class="code">read</span> and <span class="code">write</span>. The arguments are like those for the built-in <span class="code">open</span> function (see <a data-type="xref" href="ch11.xhtml#creating_a_file_object_with_open">“Creating a File Object with open”</a>). <span class="code"><em>mode</em></span> can be <span class="code">'r'</span> or <span class="code">'w'</span>; <span class="code">'b'</span> can be added for binary transmission. The socket must be in blocking mode; if a timeout value is set, unexpected results may be observed if a timeout occurs.</td>
</tr>
<tr>
<td><span class="code">recv</span></td>
<td><span class="code">recv(<em>bufsiz</em>[,</span> <span class="code"><em>flags</em></span><span class="code">])</span><br/>
			Receives and returns a maximum of <span class="code"><em>bufsiz</em></span> bytes of data from the socket <span class="code"><em>s</em></span>.</td>
</tr>
<tr>
<td><span class="code">recvfrom</span></td>
<td><span class="code">recvfrom(<em>bufsiz</em>[,</span> <span class="code"><em>flags</em></span><span class="code">])</span><br/>
			Receives a maximum of <span class="code"><em>bufsiz</em></span> bytes of data from <span class="code"><em>s</em></span>. Returns a pair <span class="code">(<em>bytes</em>,</span> <span class="code"><em>address</em></span><span class="code">)</span>: <span class="code"><em>bytes</em></span> is the received data, <span class="code"><em>address</em></span> the address of the counterparty socket that sent the data.</td>
</tr>
<tr>
<td><span class="code">recvfrom_into</span></td>
<td><span class="code">recvfrom_into(<em>buffer</em>[,</span> <span class="code"><em>nbytes</em></span><span class="code">[,</span> <span class="code"><em>flags</em></span><span class="code">]])</span><br/>
			Receives a maximum of <span class="code"><em>nbytes</em></span> bytes of data from <span class="code"><em>s</em></span>, writing it into the given <span class="code"><em>buffer</em></span> object. If <span class="code"><em>nbytes</em></span> is omitted or 0, <span class="code">len(<em>buffer</em>)</span> is used. Returns a pair <span class="code">(<em>nbytes</em>,</span> <span class="code"><em>address</em></span><span class="code">)</span>: <span class="code"><em>nbytes</em></span> is the number of bytes received, <span class="code"><em>address</em></span> the address of the counterparty socket that sent the data (*<span class="code"><em>_into</em></span> functions can be faster than “plain” ones allocating new buffers).</td>
</tr>
<tr>
<td><span class="code">recv_into</span></td>
<td><span class="code">recv_into(<em>buffer</em>[,</span> <span class="code"><em>nbytes</em></span><span class="code">[,</span> <span class="code"><em>flags</em></span><span class="code">]])</span><br/>
			Receives a maximum of <span class="code"><em>nbytes</em></span> bytes of data from <span class="code"><em>s</em></span>, writing it into the given <span class="code"><em>buffer</em></span> object. If <span class="code"><em>nbytes</em></span> is omitted or <span class="code">0</span>, <span class="code">len(<em>buffer</em>)</span> is used. Returns the number of bytes received.</td>
</tr>
<tr>
<td><span class="code">recvmsg</span></td>
<td><span class="code">recvmsg(<em>bufsiz</em>[,</span> <span class="code"><em>ancbufsiz</em></span><span class="code">[,</span> <span class="code"><em>flags</em></span><span class="code">]])</span><br/>
			Receives a maximum of <span class="code"><em>bufsiz</em></span> bytes of data on the socket and a maximum of <span class="code"><em>ancbufsiz</em></span> bytes of ancillary (“out-of-band”) data. Returns a four-item tuple <span class="code">(<em>data</em>,</span> <span class="code"><em>ancdata</em></span><span class="code">,</span> <span class="code"><em>msg_flags</em></span><span class="code">,</span> <span class="code"><em>address</em></span><span class="code">)</span>, where <span class="code"><em>bytes</em></span> is the received data, <span class="code"><em>ancdata</em></span> is a list of three-item <span class="code">(<em>cmsg_level</em>,</span> <span class="code"><em>cmsg_type</em></span><span class="code">,</span> <span class="code"><em>cmsg_data</em></span><span class="code">)</span> tuples representing the received ancillary data, <span class="code"><em>msg_flags</em></span> holds any flags received with the message (documented on the Unix manual page for the <a href="https://oreil.ly/boM-c"><span class="code">recv(2)</span></a> system call or in the <a href="https://oreil.ly/90h4R">Windows docs</a>), and <span class="code"><em>address</em></span> is the address of the counterparty socket that sent the data (if the socket is connected, this value is undefined, but the sender can be determined from the socket).</td>
</tr>
<tr>
<td><span class="code">send</span></td>
<td><span class="code">send(<em>bytes</em>[,</span> <span class="code"><em>flags</em></span><span class="code">])</span><br/>
			Sends the given data <span class="code"><em>bytes</em></span> over the socket, which must already be connected to a remote endpoint. Returns the number of bytes sent, which you should check: the call may not transmit all data, in which case transmission of the remainder will have to be separately requested.</td>
</tr>
<tr>
<td><span class="code">sendall</span></td>
<td><span class="code">sendall(<em>bytes</em>[,</span> <span class="code"><em>flags</em></span><span class="code">])</span><br/>
			Sends all the given data <span class="code"><em>bytes</em></span> over the socket, which must already be connected to a remote endpoint. The socket’s timeout value applies to the transmission of all the data, even if multiple transmissions are needed.</td>
</tr>
<tr>
<td><span class="code">sendfile</span></td>
<td><span class="code">sendfile(</span><span class="code"><em>file,</em></span> <span class="code">offset=0, count=<strong>None</strong>)</span><br/>
			Send the contents of file object <span class="code"><em>file</em></span> (which must be open in binary mode) to the connected endpoint. On platforms where <span class="code">os.sendfile</span> is available, it’s used; otherwise, the <span class="code">send</span> call is used. <span class="code">offset</span>, if any, determines the starting byte position in the file from which transmission begins; <span class="code">count</span> sets the maximum number of bytes to transmit. Returns the total number of bytes transmitted.</td>
</tr>
<tr>
<td><span class="code">sendmsg</span></td>
<td><span class="code">sendmsg(<em>buffers</em>[,</span> <span class="code"><em>ancdata</em></span><span class="code">[,</span> <span class="code"><em>flags</em></span><span class="code">[,</span> <span class="code"><em>address</em></span><span class="code">]]])</span><br/>
			Sends normal and ancillary (out-of-band) data to the connected endpoint. <span class="code"><em>buffers</em></span> should be an iterable of bytes-like objects. The <span class="code"><em>ancdata</em></span> argument should be an iterable of <span class="code">(<em>data, ancdata, msg_flags, address</em>)</span> tuples representing the ancillary data. <span class="code"><em>msg_flags</em></span> are flags documented on the Unix manual page for the <span class="code">send(2)</span> system call or in the <a href="https://oreil.ly/90h4R">Windows docs</a>. <span class="code"><em>address</em></span> should only be provided for an unconnected socket, and determines the endpoint to which the data is sent.</td>
</tr>
<tr>
<td><span class="code">sendto</span></td>
<td><span class="code">sendto(<em>bytes</em>,[<em>flags</em>,]<em>address</em>)</span><br/>
			Transmits the <span class="code"><em>bytes</em></span> (<span class="code"><em>s</em></span> must not be connected) to the given socket address, and returns the number of bytes sent. The optional <span class="code"><em>flags</em></span> argument has the same meaning as for <span class="code">recv</span>.</td>
</tr>
<tr>
<td><span class="code">setblocking</span></td>
<td><span class="code">setblocking(<em>flag</em>)</span><br/>
			Determines whether <span class="code"><em>s</em></span> operates in blocking mode (see <a data-type="xref" href="#socket_objects">“Socket Objects”</a>), according to the truth value of <span class="code"><em>flag</em></span><em>.</em> <span class="code"><em>s</em></span><span class="code">.setblocking(<strong>True</strong>)</span> works like <span class="code"><em>s</em></span><span class="code">.settimeout(<strong>None</strong>)</span>; <span class="code"><em>s</em></span><span class="code">.set_blocking(<strong>False</strong>)</span> works like <span class="code"><em>s</em></span><span class="code">.settimeout(0.0)</span>.</td>
</tr>
<tr>
<td><span class="code">s⁠e⁠t⁠_​i⁠n⁠h⁠e⁠r⁠i⁠t⁠a⁠b⁠l⁠e</span></td>
<td><span class="code">set_inheritable(<em>flag</em>)</span><br/>
			Determines whether the socket gets inherited by child processes, according to the truth value of <span class="code"><em>flag</em></span>.</td>
</tr>
<tr>
<td><span class="code">settimeout</span></td>
<td><span class="code">settimeout(<em>timeout</em>)</span><br/>
			Establishes the mode of <span class="code"><em>s</em></span> (see <a data-type="xref" href="#socket_objects">“Socket Objects”</a>) according to the value of <span class="code"><em>timeout</em></span>.</td>
</tr>
<tr>
<td><span class="code">shutdown</span></td>
<td><span class="code">shutdown(<em>how</em>)</span><br/>
			Shuts down one or both halves of a socket connection according to the value of the <span class="code"><em>how</em></span> argument, as detailed here:
			<dl>
<dt class="plain"><span class="code">socket.SHUT_RD</span></dt>
<dd>No further receive operations can be performed on <span class="code"><em>s</em></span>.</dd>
<dt class="plain"><span class="code">socket.SHUT_RDWR</span></dt>
<dd>No further receive or send operations can be performed on <span class="code"><em>s</em></span>.</dd>
<dt class="plain"><span class="code">socket.SHUT_WR</span></dt>
<dd>No further send operations can be performed on <span class="code"><em>s</em></span>.</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>A socket object <span class="code"><em>s</em></span> also has the attributes <span class="code">family</span> (<span class="code"><em>s</em></span>’s socket family) and <span class="code">type</span> (<span class="code"><em>s</em></span>’s socket type).<a contenteditable="false" data-primary="" data-startref="BSIsobj18" data-type="indexterm" id="idm44924489880096"/><a contenteditable="false" data-primary="" data-startref="sockobj18" data-type="indexterm" id="idm44924489878720"/></p>
</div></section>
<section data-pdf-bookmark="A Connectionless Socket Client" data-type="sect2"><div class="sect2" id="a_connectionless_socket_client">
<h2>A Connectionless Socket Client</h2>
<p>Consider<a contenteditable="false" data-primary="Berkeley socket interface" data-secondary="socket clients" data-tertiary="connectionless" data-type="indexterm" id="idm44924489875760"/><a contenteditable="false" data-primary="connectionless socket clients" data-type="indexterm" id="idm44924489874112"/><a contenteditable="false" data-primary="sockets" data-secondary="socket clients" data-tertiary="connectionless" data-type="indexterm" id="idm44924489872992"/> a simplistic packet-echo service, where a client sends text encoded in UTF-8 to a server, which sends the same information back to the client. In a connectionless service, all the client has to do is send each chunk of data to the defined server endpoint:</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">socket</code><code>
</code><code>
</code><code class="n">UDP_IP</code><code> </code><code class="o">=</code><code> </code><code class="s1">'</code><code class="s1">localhost</code><code class="s1">'</code><code>
</code><code class="n">UDP_PORT</code><code> </code><code class="o">=</code><code> </code><code class="mi">8883</code><code>
</code><code class="n">MESSAGE</code><code> </code><code class="o">=</code><code> </code><code class="s2">"""</code><code class="se">\
</code><code class="s2">This is a bunch of lines, each</code><code class="s2">
</code><code class="s2">of which will be sent in a single</code><code class="s2">
</code><code class="s2">UDP datagram. No error detection</code><code class="s2">
</code><code class="s2">or correction will occur.</code><code class="s2">
</code><code class="s2">Crazy bananas! £€ should go through.</code><code class="s2">"""</code><code>
</code><code>
</code><code class="n">server</code><code> </code><code class="o">=</code><code> </code><code class="n">UDP_IP</code><code class="p">,</code><code> </code><code class="n">UDP_PORT</code><code>
</code><code class="n">encoding</code><code> </code><code class="o">=</code><code> </code><code class="s1">'</code><code class="s1">utf-8</code><code class="s1">'</code><code>
</code><strong><code class="k">with</code></strong><code> </code><code class="n">socket</code><code class="o">.</code><code class="n">socket</code><code class="p">(</code><code class="n">socket</code><code class="o">.</code><code class="n">AF_INET</code><code class="p">,</code><code>    </code><em><code class="c1"># IPv4</code></em><code>
</code><code>                   </code><code class="n">socket</code><code class="o">.</code><code class="n">SOCK_DGRAM</code><code class="p">,</code><code> </code><em><code class="c1"># UDP</code></em><code>
</code><code>                  </code><code class="p">)</code><code> </code><strong><code class="k">as</code></strong><code> </code><code class="n">sock</code><code class="p">:</code><code>
</code><strong><code>    </code><code class="k">for</code></strong><code> </code><code class="n">line</code><code> </code><strong><code class="ow">in</code></strong><code> </code><code class="n">MESSAGE</code><code class="o">.</code><code class="n">splitlines</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="n">data</code><code> </code><code class="o">=</code><code> </code><code class="n">line</code><code class="o">.</code><code class="n">encode</code><code class="p">(</code><code class="n">encoding</code><code class="p">)</code><code>
</code><code>        </code><code class="n">bytes_sent</code><code> </code><code class="o">=</code><code> </code><code class="n">sock</code><code class="o">.</code><code class="n">sendto</code><code class="p">(</code><code class="n">data</code><code class="p">,</code><code> </code><code class="n">server</code><code class="p">)</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="s1">SENT </code><code class="si">{</code><code class="n">data</code><code class="si">!r}</code><code class="s1"> (</code><code class="si">{</code><code class="n">bytes_sent</code><code class="si">}</code><code class="s1"> of </code><code class="si">{</code><code class="nb">len</code><code class="p">(</code><code class="n">data</code><code class="p">)</code><code class="si">}</code><code class="s1">)</code><code class="s1">'</code><code>
</code><code>		      </code><code class="sa">f</code><code class="s1">'</code><code class="s1"> to </code><code class="si">{</code><code class="n">server</code><code class="si">}</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>        </code><code class="n">response</code><code class="p">,</code><code> </code><code class="n">address</code><code> </code><code class="o">=</code><code> </code><code class="n">sock</code><code class="o">.</code><code class="n">recvfrom</code><code class="p">(</code><code class="mi">1024</code><code class="p">)</code><code>  </code><em><code class="c1"># buffer size: 1024</code></em><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="s1">RCVD </code><code class="si">{</code><code class="n">response</code><code class="o">.</code><code class="n">decode</code><code class="p">(</code><code class="n">encoding</code><code class="p">)</code><code class="si">!r}</code><code class="s1">'</code><code>
</code><code>              </code><code class="sa">f</code><code class="s1">'</code><code class="s1"> from </code><code class="si">{</code><code class="n">address</code><code class="si">}</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>
</code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">Disconnected from server</code><code class="s1">'</code><code class="p">)</code></pre>
<p>Note that the server only performs a bytes-oriented echo function. The client, therefore, encodes its Unicode data into bytestrings, and decodes the bytestring responses received from the server back into Unicode text using the same encoding.</p>
</div></section>
<section data-pdf-bookmark="A Connectionless Socket Server" data-type="sect2"><div class="sect2" id="a_connectionless_socket_server">
<h2>A Connectionless Socket Server</h2>
<p>A<a contenteditable="false" data-primary="connectionless socket servers" data-type="indexterm" id="idm44924489679312"/><a contenteditable="false" data-primary="Berkeley socket interface" data-secondary="socket servers" data-tertiary="connectionless" data-type="indexterm" id="idm44924489683680"/><a contenteditable="false" data-primary="sockets" data-secondary="socket servers" data-tertiary="connectionless" data-type="indexterm" id="idm44924489682128"/> server for the packet-echo service described in the previous section is also quite simple. It binds to its endpoint, receives packets (datagrams) at that endpoint, and returns to the client sending each datagram a packet with exactly the same data. The server treats all clients equally and does not need to use any kind of concurrency (though this last handy characteristic might not hold for a service where request handling takes more time).</p>
<p>The following server works, but offers no way to terminate the service other than by interrupting it (typically from the keyboard, with Ctrl-C or Ctrl-Break):</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">socket</code><code>
</code><code>
</code><code class="n">UDP_IP</code><code> </code><code class="o">=</code><code> </code><code class="s1">'</code><code class="s1">localhost</code><code class="s1">'</code><code>
</code><code class="n">UDP_PORT</code><code> </code><code class="o">=</code><code> </code><code class="mi">8883</code><code>
</code><code class="k">with</code><code> </code><code class="n">socket</code><code class="o">.</code><code class="n">socket</code><code class="p">(</code><code class="n">socket</code><code class="o">.</code><code class="n">AF_INET</code><code class="p">,</code><code>    </code><em><code class="c1"># IPv4</code></em><code>
</code><code>                   </code><code class="n">socket</code><code class="o">.</code><code class="n">SOCK_DGRAM</code><code>  </code><em><code class="c1"># UDP</code></em><code>
</code><code>                   </code><code class="p">)</code><code> </code><code class="k">as</code><code> </code><code class="n">sock</code><code class="p">:</code><code>
</code><code>    </code><code class="n">sock</code><code class="o">.</code><code class="n">bind</code><code class="p">(</code><code class="p">(</code><code class="n">UDP_IP</code><code class="p">,</code><code> </code><code class="n">UDP_PORT</code><code class="p">)</code><code class="p">)</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="s1">Serving at </code><code class="si">{</code><code class="n">UDP_IP</code><code class="si">}</code><code class="s1">:</code><code class="si">{</code><code class="n">UDP_PORT</code><code class="si">}</code><code class="s1">'</code><code class="p">)</code><code>
</code><strong><code>    </code><code class="k">while</code><code> </code><code class="kc">True</code></strong><code class="p">:</code><code>
</code><code>        </code><code class="n">data</code><code class="p">,</code><code> </code><code class="n">sender_addr</code><code> </code><code class="o">=</code><code> </code><code class="n">sock</code><code class="o">.</code><code class="n">recvfrom</code><code class="p">(</code><code class="mi">1024</code><code class="p">)</code><code>  </code><em><code class="c1"># 1024-byte buffer</code></em><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="s1">RCVD </code><code class="si">{</code><code class="n">data</code><code class="si">!r}</code><code class="s1">) from </code><code class="si">{</code><code class="n">sender_addr</code><code class="si">}</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>        </code><code class="n">bytes_sent</code><code> </code><code class="o">=</code><code> </code><code class="n">sock</code><code class="o">.</code><code class="n">sendto</code><code class="p">(</code><code class="n">data</code><code class="p">,</code><code> </code><code class="n">sender_addr</code><code class="p">)</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="s1">SENT </code><code class="si">{</code><code class="n">data</code><code class="si">!r}</code><code class="s1"> (</code><code class="si">{</code><code class="n">bytes_sent</code><code class="si">}</code><code class="s1">/</code><code class="si">{</code><code class="nb">len</code><code class="p">(</code><code class="n">data</code><code class="p">)</code><code class="si">}</code><code class="s1">)</code><code class="s1">'</code><code>
</code><code>              </code><code class="sa">f</code><code class="s1">'</code><code class="s1"> to </code><code class="si">{</code><code class="n">sender_addr</code><code class="si">}</code><code class="s1">'</code><code class="p">)</code></pre>
<p>Neither is there any mechanism to handle dropped packets and similar network problems; this is often acceptable in simple services.</p>
<p>You can run the same programs using IPv6: simply replace the socket type <span class="code">AF_INET</span> with <span class="code">AF_INET6</span>.</p>
</div></section>
<section class="pagebreak-before" data-pdf-bookmark="A Connection-Oriented Socket Client" data-type="sect2"><div class="sect2" id="a_connection_oriented_socket_client">
<h2 class="less_space">A Connection-Oriented Socket Client</h2>
<p>Now<a contenteditable="false" data-primary="Berkeley socket interface" data-secondary="socket clients" data-tertiary="connection-oriented" data-type="indexterm" id="idm44924489517136"/><a contenteditable="false" data-primary="sockets" data-secondary="socket clients" data-tertiary="connection-oriented" data-type="indexterm" id="idm44924489515488"/><a contenteditable="false" data-primary="connection-oriented socket clients" data-type="indexterm" id="idm44924489513840"/> consider a simplistic connection-oriented “echo-like” protocol: a server lets clients connect to its listening socket, receives arbitrary bytes from them, and sends back to each client the same bytes that client sent to the server, until the client closes the connection. Here’s an example of an elementary test client:<sup><a data-type="noteref" href="ch18.xhtml#ch01fn138" id="ch01fn138-marker">3</a></sup></p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">socket</code><code>
</code><code>
</code><code class="n">IP_ADDR</code><code> </code><code class="o">=</code><code> </code><code class="s1">'</code><code class="s1">localhost</code><code class="s1">'</code><code>
</code><code class="n">IP_PORT</code><code> </code><code class="o">=</code><code> </code><code class="mi">8881</code><code>
</code><code class="n">MESSAGE</code><code> </code><code class="o">=</code><code> </code><code class="s2">"""</code><code class="se">\
</code><code class="s2">A few lines of text</code><code class="s2">
</code><code class="s2">including non-ASCII characters: €£</code><code class="s2">
</code><code class="s2">to test the operation</code><code class="s2">
</code><code class="s2">of both server</code><code class="s2">
</code><code class="s2">and client.</code><code class="s2">"""</code><code>
</code><code>
</code><code class="n">encoding</code><code> </code><code class="o">=</code><code> </code><code class="s1">'</code><code class="s1">utf-8</code><code class="s1">'</code><code>
</code><strong><code class="k">with</code></strong><code> </code><code class="n">socket</code><code class="o">.</code><code class="n">socket</code><code class="p">(</code><code class="n">socket</code><code class="o">.</code><code class="n">AF_INET</code><code class="p">,</code><code>     </code><em><code class="c1"># IPv4</code></em><code>
</code><code>                   </code><code class="n">socket</code><code class="o">.</code><code class="n">SOCK_STREAM</code><code>  </code><em><code class="c1"># TCP</code></em><code>
</code><code>                   </code><code class="p">)</code><code> </code><strong><code class="k">as</code></strong><code> </code><code class="n">sock</code><code class="p">:</code><code>
</code><code>    </code><code class="n">sock</code><code class="o">.</code><code class="n">connect</code><code class="p">(</code><code class="p">(</code><code class="n">IP_ADDR</code><code class="p">,</code><code> </code><code class="n">IP_PORT</code><code class="p">)</code><code class="p">)</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="s1">Connected to server </code><code class="si">{</code><code class="n">IP_ADDR</code><code class="si">}</code><code class="s1">:</code><code class="si">{</code><code class="n">IP_PORT</code><code class="si">}</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>    </code><strong><code class="k">for</code></strong><code> </code><code class="n">line</code><code> </code><strong><code class="ow">in</code></strong><code> </code><code class="n">MESSAGE</code><code class="o">.</code><code class="n">splitlines</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>        </code><code class="n">data</code><code> </code><code class="o">=</code><code> </code><code class="n">line</code><code class="o">.</code><code class="n">encode</code><code class="p">(</code><code class="n">encoding</code><code class="p">)</code><code>
</code><code>        </code><code class="n">sock</code><code class="o">.</code><code class="n">sendall</code><code class="p">(</code><code class="n">data</code><code class="p">)</code><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="s1">SENT </code><code class="si">{</code><code class="n">data</code><code class="si">!r}</code><code class="s1"> (</code><code class="si">{</code><code class="nb">len</code><code class="p">(</code><code class="n">data</code><code class="p">)</code><code class="si">}</code><code class="s1">)</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>        </code><code class="n">response</code><code class="p">,</code><code> </code><code class="n">address</code><code> </code><code class="o">=</code><code> </code><code class="n">sock</code><code class="o">.</code><code class="n">recvfrom</code><code class="p">(</code><code class="mi">1024</code><code class="p">)</code><code>  </code><em><code class="c1"># buffer size: 1024</code></em><code>
</code><code>        </code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="s1">RCVD </code><code class="si">{</code><code class="n">response</code><code class="o">.</code><code class="n">decode</code><code class="p">(</code><code class="n">encoding</code><code class="p">)</code><code class="si">!r}</code><code class="s1">'</code><code>
</code><code>              </code><code class="sa">f</code><code class="s1">'</code><code class="s1"> (</code><code class="si">{</code><code class="nb">len</code><code class="p">(</code><code class="n">response</code><code class="p">)</code><code class="si">}</code><code class="s1">) from </code><code class="si">{</code><code class="n">address</code><code class="si">}</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>
</code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">Disconnected from server</code><code class="s1">'</code><code class="p">)</code></pre>
<p>Note that the data is text, so it must be encoded with a suitable representation. We chose the usual suspect, UTF-8. The server works in terms of bytes (since it is bytes, aka octets, that travel on the network); the received bytes object gets decoded with UTF-8 back into Unicode text before printing. Any other suitable codec could be used instead: the key point is that text must be encoded before transmission and decoded after reception. The server, working in terms of bytes, does not even need to know which encoding is being used, except maybe for logging purposes.</p>
</div></section>
<section class="pagebreak-before" data-pdf-bookmark="A Connection-Oriented Socket Server" data-type="sect2"><div class="sect2" id="a_connection_oriented_socket_server">
<h2 class="less_space">A Connection-Oriented Socket Server</h2>
<p>Here<a contenteditable="false" data-primary="Berkeley socket interface" data-secondary="socket servers" data-tertiary="connection-oriented" data-type="indexterm" id="idm44924489273168"/><a contenteditable="false" data-primary="sockets" data-secondary="socket servers" data-tertiary="connection-oriented" data-type="indexterm" id="idm44924489271712"/><a contenteditable="false" data-primary="connection-oriented socket servers" data-type="indexterm" id="idm44924489295920"/> is a simplistic server corresponding to the testing client shown in the previous section, using multithreading via <span class="code">concurrent.futures</span> (covered in <a data-type="xref" href="ch15.xhtml#the_concurrentdotfutures_module">“The concurrent.futures Module”</a>):</p>
<pre data-code-language="python" data-type="programlisting">
<strong><code class="kn">import</code></strong><code> </code><code class="nn">concurrent</code><code>
</code><strong><code class="kn">import</code></strong><code> </code><code class="nn">socket</code><code>
</code><code>
</code><code class="n">IP_ADDR</code><code> </code><code class="o">=</code><code> </code><code class="s1">'</code><code class="s1">localhost</code><code class="s1">'</code><code>
</code><code class="n">IP_PORT</code><code> </code><code class="o">=</code><code> </code><code class="mi">8881</code><code>
</code><code>
</code><strong><code class="k">def</code></strong><code> </code><code class="nf">handle</code><code class="p">(</code><code class="n">new_sock</code><code class="p">,</code><code> </code><code class="n">address</code><code class="p">)</code><code class="p">:</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="s1">'</code><code class="s1">Connected from</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">address</code><code class="p">)</code><code>
</code><code>    </code><strong><code class="k">with</code></strong><code> </code><code class="n">new_sock</code><code class="p">:</code><code>
</code><code>        </code><strong><code class="k">while</code></strong><code> </code><code class="kc">True</code><code class="p">:</code><code>
</code><code>            </code><code class="n">received</code><code> </code><code class="o">=</code><code> </code><code class="n">new_sock</code><code class="o">.</code><code class="n">recv</code><code class="p">(</code><code class="mi">1024</code><code class="p">)</code><code>
</code><code>            </code><strong><code class="k">if</code></strong><code> </code><strong><code class="ow">not</code></strong><code> </code><code class="n">received</code><code class="p">:</code><code>
</code><code>                </code><strong><code class="k">break</code></strong><code>
</code><code>            </code><code class="n">s</code><code> </code><code class="o">=</code><code> </code><code class="n">received</code><code class="o">.</code><code class="n">decode</code><code class="p">(</code><code class="s1">'</code><code class="s1">utf-8</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">errors</code><code class="o">=</code><code class="s1">'</code><code class="s1">replace</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>            </code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="s1">Recv: </code><code class="si">{</code><code class="n">s</code><code class="si">!r}</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>            </code><code class="n">new_sock</code><code class="o">.</code><code class="n">sendall</code><code class="p">(</code><code class="n">received</code><code class="p">)</code><code>
</code><code>            </code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="s1">Echo: </code><code class="si">{</code><code class="n">s</code><code class="si">!r}</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="s1">Disconnected from </code><code class="si">{</code><code class="n">address</code><code class="si">}</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>
</code><strong><code class="k">with</code></strong><code> </code><code class="n">socket</code><code class="o">.</code><code class="n">socket</code><code class="p">(</code><code class="n">socket</code><code class="o">.</code><code class="n">AF_INET</code><code class="p">,</code><code>     </code><code class="c1"># IPv4 </code><code>
</code><code>                   </code><code class="n">socket</code><code class="o">.</code><code class="n">SOCK_STREAM</code><code>  </code><code class="c1"># TCP</code><code>
</code><code>                   </code><code class="p">)</code><code> </code><strong><code class="k">as</code></strong><code> </code><code class="n">servsock</code><code class="p">:</code><code>
</code><code>    </code><code class="n">servsock</code><code class="o">.</code><code class="n">bind</code><code class="p">(</code><code class="p">(</code><code class="n">IP_ADDR</code><code class="p">,</code><code> </code><code class="n">IP_PORT</code><code class="p">)</code><code class="p">)</code><code>
</code><code>    </code><code class="n">servsock</code><code class="o">.</code><code class="n">listen</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code><code>
</code><code>    </code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s1">'</code><code class="s1">Serving at </code><code class="si">{</code><code class="n">servsock</code><code class="o">.</code><code class="n">getsockname</code><code class="p">(</code><code class="p">)</code><code class="si">}</code><code class="s1">'</code><code class="p">)</code><code>
</code><code>    </code><strong><code class="k">with</code></strong><code> </code><code class="n">cconcurrent</code><code class="o">.</code><code class="n">futures</code><code class="o">.</code><code class="n">ThreadPoolExecutor</code><code class="p">(</code><code class="mi">20</code><code class="p">)</code><code> </code><strong><code class="k">as</code></strong><code> </code><code class="n">e</code><code class="p">:</code><code>
</code><code>        </code><strong><code class="k">while</code></strong><code> </code><code class="kc">True</code><code class="p">:</code><code>
</code><code>            </code><code class="n">new_sock</code><code class="p">,</code><code> </code><code class="n">address</code><code> </code><code class="o">=</code><code> </code><code class="n">servsock</code><code class="o">.</code><code class="n">accept</code><code class="p">(</code><code class="p">)</code><code>
</code><code>            </code><code class="n">e</code><code class="o">.</code><code class="n">submit</code><code class="p">(</code><code class="n">handle</code><code class="p">,</code><code> </code><code class="n">new_sock</code><code class="p">,</code><code> </code><code class="n">address</code><code class="p">)</code></pre>
<p>This server has its limits. In particular, it runs only 20 threads, so it cannot simultaneously serve more than 20 clients; any further client trying to connect while 20 others are already being served waits in <span class="code">servsock</span>’s listening queue. Should that queue fill up with five clients waiting to be accepted, further clients attempting connection get rejected outright. This server is intended just as an elementary example for demonstration purposes, not as a solid, scalable, or secure system.</p>
<p>As before, the same programs can be run using IPv6 by replacing the socket type <span class="code">AF_INET</span> with <span class="code">AF_INET6</span>.<a contenteditable="false" data-primary="" data-startref="NBbsocket18" data-type="indexterm" id="idm44924489008192"/></p>
</div></section>
</div></section>
<section class="pagebreak-before" data-pdf-bookmark="Transport Layer Security" data-type="sect1"><div class="sect1" id="transport_layer_security">
<h1 class="less_space">Transport Layer Security</h1>
<p>Transport Layer Security (TLS), the<a contenteditable="false" data-primary="networking basics" data-secondary="transport layer security (TLS)" data-type="indexterm" id="idm44924489004624"/><a contenteditable="false" data-primary="transport layer security (TLS)" data-type="indexterm" id="idm44924489030160"/><a contenteditable="false" data-primary="TLS (transport layer security)" data-type="indexterm" id="idm44924489029184"/> successor of<a contenteditable="false" data-primary="Secure Sockets Layer (SSL)" data-type="indexterm" id="idm44924489027984"/><a contenteditable="false" data-primary="SSL (Secure Sockets Layer)" data-type="indexterm" id="idm44924489026880"/> Secure Sockets Layer (SSL), provides privacy and data integrity over TCP/IP, helping you defend against server impersonation, eavesdropping on the bytes being exchanged, and malicious alteration of those bytes. For an introduction to TLS, we recommend the extensive <a href="https://oreil.ly/EzLWt">Wikipedia entry</a>.</p>
<p>In Python, you can use TLS via the <span class="code">ssl</span> module of the standard library. To use <span class="code">ssl</span> well, you need a good grasp of its rich <a href="https://oreil.ly/2EGr0">online docs</a>, as well as a deep and broad understanding of TLS itself (the Wikipedia article, excellent and vast as it is, can only begin to cover this large, difficult subject). In particular, you must study and thoroughly understand the <a href="https://oreil.ly/ohqtT">security considerations section of the online docs</a>, as well as all the materials found at the many links helpfully offered in that section.</p>
<p>If these warnings make it sound as though a perfect implementation of security precautions is a daunting task, that’s because it <em>is.</em> In security, you’re pitting your wits and skills against those of sophisticated attackers who may be more familiar with the nooks and crannies of the problems involved: they specialize in finding workarounds and breaking in, while (usually) your focus is not exclusively on such issues—rather, you’re trying to provide some useful services in your code. It’s risky to see security as an afterthought or a secondary point—it <em>has</em> to be front and center throughout, to win said battle of skills and wits.</p>
<p>That said, we strongly recommend that all readers undertake the study of TLS mentioned above—the better all developers understand security considerations, the better off we all are (except, we guess, the security-breaker wannabes!).</p>
<p>Unless you have acquired a really deep and broad understanding of TLS and Python’s <span class="code">ssl</span> module (in which case, you’ll know what exactly to do—better than we possibly could!), we recommend using an <span class="code">SSLContext</span> instance to hold all the details of your use of TLS. Build that instance with the <span class="code">ssl.create_default_context</span> function, add your certificate if needed (it <em>is</em> needed if you’re writing a secure server), then use the instance’s <span class="code">wrap_socket</span> method to wrap (almost<sup><a data-type="noteref" href="ch18.xhtml#ch01fn139" id="ch01fn139-marker">4</a></sup>) every <span class="code">socket.socket</span> instance you make into an instance of <span class="code">ssl.SSLSocket</span>—behaving almost identically to the socket object it wraps, but nearly transparently adding security checks and validation “on the side.”</p>
<p>The default TLS contexts strike a good compromise between security and broad usability, and we recommend you stick with them (unless you’re knowledgeable enough to fine-tune and tighten security for special needs). If you need to support outdated counterparts that are unable to use the most recent, most secure implementations of TLS, you may feel tempted to learn just enough to relax your security demands. Do that at your own risk—we most definitely <em>don’t</em> recommend wandering into such territory!</p>
<p>In the following sections, we cover the minimal subset of <span class="code">ssl</span> you need to be familiar with if you just want to follow our recommendations. But even if that is the case, <em>please</em> also read up on TLS and <span class="code">ssl</span>, just to gain some background knowledge about the intricate issues involved. It may stand you in good stead one day!</p>
</div></section>
<section data-pdf-bookmark="SSLContext" data-type="sect1"><div class="sect1" id="sslcontext">
<h1>SSLContext</h1>
<p>The<a contenteditable="false" data-primary="networking basics" data-secondary="SSLContext class" data-type="indexterm" id="idm44924488936848"/><a contenteditable="false" data-primary="ssl module" data-type="indexterm" id="idm44924488935632"/><a contenteditable="false" data-primary="SSLContext class (ssl module)" data-type="indexterm" id="idm44924488934656"/><a contenteditable="false" data-primary="standard library modules" data-secondary="ssl" data-type="indexterm" id="idm44924488933680"/> <span class="code">ssl</span> module supplies an <span class="code">ssl.SSLContext</span> class, whose instances hold information about TLS configuration (including certificates and private keys) and offer many methods to set, change, check, and use that information. If you know exactly what you’re doing, you can manually instantiate, set up, and use your own <span class="code">SSLContext</span> instances for your own specialized purposes.</p>
<p>However, we recommend instead that you instantiate an <span class="code">SSLContext</span> using the <span class="keep-together">well-tuned</span> function <span class="code">ssl.create_default_context</span>, with a single argument: <span class="code keep-together">ssl.Purpose.CLIENT_AUTH</span> if your code is a server (and thus may need to authenticate clients), or <span class="code">ssl.Purpose.SERVER_AUTH</span> if your code is a client (and thus definitely needs to authenticate servers). If your code is both a client to some servers and a server to other clients (as, for example, some internet proxies are), then you’ll need two instances of <span class="code">SSLContext</span>, one for each purpose.</p>
<p>For most client-side uses, your <span class="code">SSLContext</span> is ready. If you’re coding a server, or a client for one of the rare servers that require TLS authentication of the clients, you need to have a certificate file and a key file (see the <a href="https://oreil.ly/mBPJ0">online docs</a> to learn how to obtain these files). Add them to the <span class="code">SSLContext</span> instance (so that counterparties can verify your identity) by passing the paths to the certificate and key files to the <span class="code">load_cert_chain</span> method with code like the following:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">ctx</code> <code class="o">=</code> <code class="n">ssl</code><code class="o">.</code><code class="n">create_default_context</code><code class="p">(</code><code class="n">ssl</code><code class="o">.</code><code class="n">Purpose</code><code class="o">.</code><code class="n">CLIENT_AUTH</code><code class="p">)</code>
<code class="n">ctx</code><code class="o">.</code><code class="n">load_cert_chain</code><code class="p">(</code><code class="n">certfile</code><code class="o">=</code><code class="s1">'mycert.pem'</code><code class="p">,</code> <code class="n">keyfile</code><code class="o">=</code><code class="s1">'mykey.key'</code><code class="p">)</code></pre>
<p>Once your context instance <span class="code"><em>ctx</em></span> is ready, if you’re coding a client, just call <span class="code"><em>ctx</em></span><span class="code">.wrap_socket</span> to wrap any socket you’re about to connect to a server, and use the wrapped result (an instance of <span class="code">ssl.SSLSocket</span>) instead of the socket you just wrapped. For example:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">sock</code><code> </code><code class="o">=</code><code> </code><code class="n">socket</code><code class="o">.</code><code class="n">socket</code><code class="p">(</code><code class="n">socket</code><code class="o">.</code><code class="n">AF_INET</code><code class="p">)</code><code>
</code><code class="n">sock</code><code> </code><code class="o">=</code><code> </code><code class="n">ctx</code><code class="o">.</code><code class="n">wrap_socket</code><code class="p">(</code><code class="n">sock</code><code class="p">,</code><code> </code><code class="n">server_hostname</code><code class="o">=</code><code class="s1">'</code><code class="s1">www.example.com</code><code class="s1">'</code><code class="p">)</code><code>
</code><code class="n">sock</code><code class="o">.</code><code class="n">connect</code><code class="p">(</code><code class="p">(</code><code class="s1">'</code><code class="s1">www.example.com</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="mi">443</code><code class="p">)</code><code class="p">)</code><code>  </code><code>
</code><em><code class="c1"># use 'sock' normally from here on</code></em></pre>
<p>Note that, in the client case, you should also pass <span class="code">wrap_socket</span> a <span class="code">server_hostname</span> argument corresponding to the server you’re about to connect to; this way, the connection can verify that the identity of the server you end up connecting to is indeed correct, an absolutely crucial security step.</p>
<p class="pagebreak-before">Server-side, <em>don’t</em> wrap the socket that you are binding to an address, listening on, or accepting connections on; just wrap the new socket that <span class="code">accept</span> returns. For example:</p>
<pre data-code-language="python" data-type="programlisting">
<code class="n">sock</code><code> </code><code class="o">=</code><code> </code><code class="n">socket</code><code class="o">.</code><code class="n">socket</code><code class="p">(</code><code class="n">socket</code><code class="o">.</code><code class="n">AF_INET</code><code class="p">)</code><code>
</code><code class="n">sock</code><code class="o">.</code><code class="n">bind</code><code class="p">(</code><code class="p">(</code><code class="s1">'</code><code class="s1">www.example.com</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="mi">443</code><code class="p">)</code><code class="p">)</code><code>
</code><code class="n">sock</code><code class="o">.</code><code class="n">listen</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code><code>
</code><strong><code class="k">while</code><code> </code><code class="kc">True</code><code class="p">:</code></strong><code>
</code><code>    </code><code class="n">newsock</code><code class="p">,</code><code> </code><code class="n">fromaddr</code><code> </code><code class="o">=</code><code> </code><code class="n">sock</code><code class="o">.</code><code class="n">accept</code><code class="p">(</code><code class="p">)</code><code>
</code><code>    </code><code class="n">newsock</code><code> </code><code class="o">=</code><code> </code><code class="n">ctx</code><code class="o">.</code><code class="n">wrap_socket</code><code class="p">(</code><code class="n">newsock</code><code class="p">,</code><code> </code><code class="n">server_side</code><code class="o">=</code><strong><code class="kc">True</code></strong><code class="p">)</code><code>
</code><code>    </code><em><code class="c1"># deal with 'newsock' as usual; shut down, then close it, when done</code></em></pre>
<p>In this case, you need to pass <span class="code">wrap_socket</span> the argument <span class="code">server_side=</span><span class="code"><strong>True</strong></span> so it knows that you’re on the server side of things.</p>
<p>Again, we recommend consulting the online docs—particularly the <a href="https://oreil.ly/r6hQ7">examples</a>—for better understanding, even if you stick to just this simple subset of <span class="code">ssl</span> operations.</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="ch01fn136"><sup><a href="ch18.xhtml#ch01fn136-marker">1</a></sup> When you code an application program, you normally use sockets through higher-abstraction layers, such as those covered in <a data-type="xref" href="ch19.xhtml#client_side_network_protocol_modules">Chapter 19</a>.</p><p data-type="footnote" id="ch01fn137"><sup><a href="ch18.xhtml#ch01fn137-marker">2</a></sup> And the relatively newfangled multiplexed connections transport protocol <a href="https://oreil.ly/1XwoM">QUIC</a>, supported in Python by third-party <a href="https://oreil.ly/uh_1O"><span class="code">aioquic</span></a>.</p><p data-type="footnote" id="ch01fn138"><sup><a href="ch18.xhtml#ch01fn138-marker">3</a></sup> This client example isn’t secure; see <a data-type="xref" href="#transport_layer_security">“Transport Layer Security”</a> for an introduction to making it secure.</p><p data-type="footnote" id="ch01fn139"><sup><a href="ch18.xhtml#ch01fn139-marker">4</a></sup> We say “almost” because, when you code a server, you don’t wrap the socket you bind, listen on, and accept connections from.</p></div></div></section></div></body></html>