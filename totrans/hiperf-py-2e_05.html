<html><head></head><body><div id="sbo-rt-content" class="calibre2"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. Iterators and Generators" class="calibre3"><div class="preface" id="section-iterators-generators">
<h1 class="calibre23"><span class="publishername">Chapter 5. </span>Iterators and Generators</h1>

<aside data-type="sidebar" epub:type="sidebar" class="calibre40"><div class="sidebar" id="idm46122424223976">
<h5 class="calibre41">Questions You’ll Be Able to Answer After This Chapter</h5>
<ul class="printings">
<li class="calibre21">
<p class="calibre42">How do generators save memory?</p>
</li>
<li class="calibre21">
<p class="calibre42">When is the best time to use a generator?</p>
</li>
<li class="calibre21">
<p class="calibre42">How can I use <code class="calibre26">itertools</code> to create complex generator workflows?</p>
</li>
<li class="calibre21">
<p class="calibre42">When is lazy evaluation beneficial, and when is it not?</p>
</li>
</ul>
</div></aside>

<p class="author1"><a data-type="indexterm" data-primary="generators and iterators" id="gi_ch" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="iterators and generators" id="ig_ch" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>When many people with experience in another language start learning Python, they are taken
aback by the difference in <code class="calibre26">for</code> loop notation.  That is to say, instead of 
<span class="publishername">writing</span></p>
<pre data-type="programlisting" data-code-language="c" class="calibre50"><em class="calibre66"><code class="cp">#</code><code class="cp"> Other languages</code></em><code class="cp1">
</code><code class="kn">for</code><code class="calibre26"> </code><code class="p">(</code><code class="n">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code><code class="calibre26"> </code><code class="n">i</code><code class="o">&lt;</code><code class="n">N</code><code class="p">;</code><code class="calibre26"> </code><code class="n">i</code><code class="o">+</code><code class="o">+</code><code class="p">)</code><code class="calibre26"> </code><code class="p">{</code><code class="calibre26">
</code><code class="calibre26">    </code><code class="n">do_work</code><code class="p">(</code><code class="n">i</code><code class="p">)</code><code class="p">;</code><code class="calibre26">
</code><code class="p">}</code></pre>

<p class="author1">they are introduced to a new function called <code class="calibre26">range</code>:</p>
<pre data-type="programlisting" data-code-language="python" class="calibre50"><em class="calibre66"><code class="c1"># Python</code></em><code class="calibre26">
</code><code class="kn">for</code><code class="calibre26"> </code><code class="n">i</code><code class="calibre26"> </code><code class="ow">in</code><code class="calibre26"> </code><code class="nb">range</code><code class="p">(</code><code class="n">N</code><code class="p">)</code><code class="p">:</code><code class="calibre26">
</code><code class="calibre26">    </code><code class="n">do_work</code><code class="p">(</code><code class="n">i</code><code class="p">)</code></pre>

<p class="author1">It seems that in the Python code sample we are calling a function, <code class="calibre26">range</code>,
which creates all of the data we need for the <code class="calibre26">for</code> loop to continue. Intuitively,
this can be quite a time-consuming process—if we are trying to loop over the
numbers 1 through 100,000,000, then we need to spend a lot of time creating that
array! However, this is where <em class="hyperlink">generators</em> come into play: they essentially allow us to
lazily evaluate these sorts of functions so we can have the
code-readability of these special-purpose functions without the performance
impacts.</p>

<p class="author1">To understand this concept, let’s implement a function that
calculates several Fibonacci numbers both by filling a list and by using a
generator:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre50"><code class="kn">def</code><code class="calibre26"> </code><code class="nf">fibonacci_list</code><code class="p">(</code><code class="n">num_items</code><code class="p">)</code><code class="p">:</code><code class="calibre26">
</code><code class="calibre26">    </code><code class="n">numbers</code><code class="calibre26"> </code><code class="o">=</code><code class="calibre26"> </code><code class="p">[</code><code class="p">]</code><code class="calibre26">
</code><code class="calibre26">    </code><code class="n">a</code><code class="p">,</code><code class="calibre26"> </code><code class="n">b</code><code class="calibre26"> </code><code class="o">=</code><code class="calibre26"> </code><code class="mi">0</code><code class="p">,</code><code class="calibre26"> </code><code class="mi">1</code><code class="calibre26">
</code><code class="calibre26">    </code><code class="kn">while</code><code class="calibre26"> </code><code class="nb">len</code><code class="p">(</code><code class="n">numbers</code><code class="p">)</code><code class="calibre26"> </code><code class="o">&lt;</code><code class="calibre26"> </code><code class="n">num_items</code><code class="p">:</code><code class="calibre26">
</code><code class="calibre26">        </code><code class="n">numbers</code><code class="o">.</code><code class="n">append</code><code class="p">(</code><code class="n">a</code><code class="p">)</code><code class="calibre26">
</code><code class="calibre26">        </code><code class="n">a</code><code class="p">,</code><code class="calibre26"> </code><code class="n">b</code><code class="calibre26"> </code><code class="o">=</code><code class="calibre26"> </code><code class="n">b</code><code class="p">,</code><code class="calibre26"> </code><code class="n">a</code><code class="o">+</code><code class="n">b</code><code class="calibre26">
</code><code class="calibre26">    </code><code class="kn">return</code><code class="calibre26"> </code><code class="n">numbers</code><code class="calibre26">
</code><code class="calibre26">
</code><code class="kn">def</code><code class="calibre26"> </code><code class="nf">fibonacci_gen</code><code class="p">(</code><code class="n">num_items</code><code class="p">)</code><code class="p">:</code><code class="calibre26">
</code><code class="calibre26">    </code><code class="n">a</code><code class="p">,</code><code class="calibre26"> </code><code class="n">b</code><code class="calibre26"> </code><code class="o">=</code><code class="calibre26"> </code><code class="mi">0</code><code class="p">,</code><code class="calibre26"> </code><code class="mi">1</code><code class="calibre26">
</code><code class="calibre26">    </code><code class="kn">while</code><code class="calibre26"> </code><code class="n">num_items</code><code class="p">:</code><code class="calibre26">
</code><code class="calibre26">        </code><code class="kn">yield</code><code class="calibre26"> </code><code class="n">a</code><code class="calibre26">  </code><a class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6" id="co_iterators_and_generators_CO1-1" href="#callout_iterators_and_generators_CO1-1"><img src="Images/1.png" alt="1" class="calibre74"/></a><code class="calibre26">
</code><code class="calibre26">        </code><code class="n">a</code><code class="p">,</code><code class="calibre26"> </code><code class="n">b</code><code class="calibre26"> </code><code class="o">=</code><code class="calibre26"> </code><code class="n">b</code><code class="p">,</code><code class="calibre26"> </code><code class="n">a</code><code class="o">+</code><code class="n">b</code><code class="calibre26">
</code><code class="calibre26">        </code><code class="n">num_items</code><code class="calibre26"> </code><code class="o">-</code><code class="o">=</code><code class="calibre26"> </code><code class="mi">1</code></pre>
<dl class="calibre28">
<dt class="calibre29"><a class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6" id="callout_iterators_and_generators_CO1-1" href="#co_iterators_and_generators_CO1-1"><img src="Images/1.png" alt="1" class="calibre74"/></a></dt>
<dd class="calibre75"><p class="calibre76">This function will <code class="calibre26">yield</code> many values instead of returning one value.  This turns this regular-looking function into a generator that can be polled repeatedly for the next available value.</p></dd>
</dl>

<p class="author1"><a data-type="indexterm" data-primary="Fibonacci series" id="idm46122424003288" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>The first thing to note is that the<a data-type="indexterm" data-primary="fibonacci_list function" id="idm46122424002200" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <code class="calibre26">fibonacci_list</code> implementation must create
and store the list of all the relevant Fibonacci numbers.  So if we want to
have 10,000 numbers of the sequence, the function will do 10,000 appends to the
<code class="calibre26">numbers</code> list (which, as we discussed in <a data-type="xref" href="ch03.xhtml#chapter-lists-tuples" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Chapter 3</a>, has overhead
associated with it) and then return it.</p>

<p class="author1">On the other hand, the generator is able to “return” many values.  Every time
the code gets to the <code class="calibre26">yield</code>, the function emits its value, and when another
value is requested, the function resumes running (maintaining its previous state)
and emits the new value.  When the function reaches its end, a<a data-type="indexterm" data-primary="StopIteration exception" id="idm46122424006312" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <code class="calibre26">StopIteration</code>
exception is thrown, indicating that the given generator has no more values.  As
a result, even though both functions must, in the end, do the same number of
calculations, the <code class="calibre26">fibonacci_list</code> version of the preceding loop uses 10,000×
more memory (or <code class="calibre26">num_items</code> times more memory).</p>

<p class="author1">With this code in mind, we can decompose the<a data-type="indexterm" data-primary="for loops" id="idm46122424012136" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <code class="calibre26">for</code>
loops that use our implementations of <code class="calibre26">fibonacci_list</code> and<a data-type="indexterm" data-primary="fibonacci_gen function" id="idm46122424019096" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <code class="calibre26">fibonacci_gen</code>.  In
Python, <code class="calibre26">for</code> loops require that the object we are looping over supports
iteration.  This means that we must be able to create an iterator out of the
object we want to loop over.  To create an iterator from almost any object, we
can use Python’s built-in <code class="calibre26">iter</code> function.  This function, for lists,<a data-type="indexterm" data-primary="iter property" id="idm46122424016088" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> tuples,
dictionaries, and sets, returns an iterator over the items or keys in the
object.  For more complex objects, <code class="calibre26">iter</code> returns the result of the <code class="calibre26">__iter__</code>
property of the object.  Since <code class="calibre26">fibonacci_gen</code> already returns an iterator,
calling <code class="calibre26">iter</code> on it is a trivial operation, and it returns the original object
(so <code class="calibre26">type(fibonacci_gen(10)) == type(iter(fibonacci_gen(10)))</code>).  However, since
<code class="calibre26">fibonacci_list</code> returns a list, we must create a new object, a list iterator,
that will iterate over all values in the list. In general, once an iterator is
created, we call the <a data-type="indexterm" data-primary="next() function" id="idm46122424023448" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><code class="calibre26">next()</code> function with it, retrieving new values until a
<code class="calibre26">StopIteration</code> exception is thrown.  This gives us a good deconstructed view of
<code class="calibre26">for</code> loops, as illustrated in <a data-type="xref" href="#iter_py_for" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 5-1</a>.</p>
<div id="iter_py_for" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 5-1. </span>Python <code class="calibre26">for</code> loop deconstructed</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="c"># The Python loop</code>
<code class="kn">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="nb">object</code><code class="p">:</code>
    <code class="n">do_work</code><code class="p">(</code><code class="n">i</code><code class="p">)</code>

<code class="c"># Is equivalent to</code>
<code class="n">object_iterator</code> <code class="o">=</code> <code class="nb">iter</code><code class="p">(</code><code class="nb">object</code><code class="p">)</code>
<code class="kn">while</code> <code class="nb">True</code><code class="p">:</code>
    <code class="kn">try</code><code class="p">:</code>
        <code class="n">i</code> <code class="o">=</code> <code class="nb">next</code><code class="p">(</code><code class="n">object_iterator</code><code class="p">)</code>
    <code class="kn">except</code> <code class="ne">StopIteration</code><code class="p">:</code>
        <code class="kn">break</code>
    <code class="kn">else</code><code class="p">:</code>
        <code class="n">do_work</code><code class="p">(</code><code class="n">i</code><code class="p">)</code></pre></div>

<p class="author1">The <code class="calibre26">for</code> loop code shows that we are doing extra work calling <code class="calibre26">iter</code> when using
<code class="calibre26">fibonacci_list</code> instead of <code class="calibre26">fibonacci_gen</code>.  When using <code class="calibre26">fibonacci_gen</code>, we
create a generator that is trivially transformed into an iterator (since it is
already an iterator!); however, for <code class="calibre26">fibonacci_list</code> we need to allocate a new list and
precompute its values, and then we still must create an iterator.</p>

<p class="author1">More importantly, precomputing the <code class="calibre26">fibonacci_list</code> list requires allocating
enough space for the full dataset and setting each element to the correct value,
even though we always require only one value at a time.  This also makes the list
allocation useless.  In fact, it may even make the loop unrunnable, because it
may be trying to allocate more memory than is available (<code class="calibre26">fibonacci_list(100_000_000)</code>
would create a list 3.1 GB large!). By timing the results, we can see this very
explicitly:</p>

<pre data-type="programlisting" data-code-language="python3" class="calibre50"><code class="kn">def</code> <code class="nf">test_fibonacci_list</code><code class="p">():</code>
    <code class="sd">"""</code>
<code class="sd">    &gt;&gt;&gt; %timeit test_fibonacci_list()</code>
<code class="sd">    332 ms ± 13.1 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)</code>

<code class="sd">    &gt;&gt;&gt; %memit test_fibonacci_list()</code>
<code class="sd">    peak memory: 492.82 MiB, increment: 441.75 MiB</code>
<code class="sd">    """</code>
    <code class="kn">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="n">fibonacci_list</code><code class="p">(</code><code class="mi">100</code><code class="n">_000</code><code class="p">):</code>
        <code class="kn">pass</code>


<code class="kn">def</code> <code class="nf">test_fibonacci_gen</code><code class="p">():</code>
    <code class="sd">"""</code>
<code class="sd">    &gt;&gt;&gt; %timeit test_fibonacci_gen()</code>
<code class="sd">    126 ms ± 905 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)</code>

<code class="sd">    &gt;&gt;&gt; %memit test_fibonacci_gen()</code>
<code class="sd">    peak memory: 51.13 MiB, increment: 0.00 MiB</code>
<code class="sd">    """</code>
    <code class="kn">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="n">fibonacci_gen</code><code class="p">(</code><code class="mi">100</code><code class="n">_000</code><code class="p">):</code>
        <code class="kn">pass</code></pre>

<p class="author1">As we can see, the generator version is over twice as fast and requires no
measurable memory as compared to the <code class="calibre26">fibonacci_list</code>’s 441 MB. It may seem at
this point that you should use generators everywhere in place of creating lists,
but that would create many complications.</p>

<p class="author1">What if, for example, you needed to reference the list of Fibonacci numbers
multiple times? In this case, <code class="calibre26">fibonacci_list</code> would provide a precomputed list
of these digits, while <code class="calibre26">fibonacci_gen</code> would have to recompute them over and
over again. In general, changing to using generators instead of precomputed
arrays requires <a data-type="indexterm" data-primary="algorithms" id="idm46122423822936" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="online algorithms" id="idm46122423822264" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="single pass algorithms" id="idm46122423821592" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>algorithmic changes that are sometimes not so easy to
understand.<sup class="calibre44"><a data-type="noteref" id="idm46122423820792-marker" href="ch05.xhtml#idm46122423820792" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">1</a></sup></p>
<div data-type="note" epub:type="note" class="calibre35"><h6 class="calibre36">Note</h6>
<p class="author1">An important choice that must be made when architecting your code is
whether you are going to optimize CPU speed or memory efficiency.
In some cases, using extra memory so that you have values precalculated and
ready for future reference will save in overall speed. Other times, memory may
be so constrained that the only solution is to recalculate values as opposed to
saving them in memory. Every problem has its own considerations for this
CPU/memory trade-off.</p>
</div>

<p class="author1">One simple example of this that is often seen in source code is using a
generator to create a sequence of numbers, only to use list comprehension to calculate the length of the result:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre50"><code class="n">divisible_by_three</code> <code class="o">=</code> <code class="nb">len</code><code class="p">([</code><code class="n">n</code> <code class="kn">for</code> <code class="n">n</code> <code class="ow">in</code> <code class="n">fibonacci_gen</code><code class="p">(</code><code class="mi">100</code><code class="n">_000</code><code class="p">)</code> <code class="kn">if</code> <code class="n">n</code> <code class="o">%</code> <code class="mi">3</code> <code class="o">==</code> <code class="mi">0</code><code class="p">])</code></pre>

<p class="author1">While we are still using <code class="calibre26">fibonacci_gen</code> to generate the Fibonacci sequence as a
generator, we are then saving all values divisible by 3 into an array, only to
take the length of that array and then throw away the data. In the process,
we’re consuming 86 MB of data for no reason.<sup class="calibre44"><a data-type="noteref" id="idm46122423727656-marker" href="ch05.xhtml#idm46122423727656" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">2</a></sup> In fact, if we were
doing this for a long enough 
<span class="publishername">Fibonacci</span> sequence, the preceding code wouldn’t be able
to run because of memory issues, even though the calculation itself is quite
simple!</p>

<p class="author1">Recall that we can create a list comprehension using a statement of the form
<span class="publishername">[<em class="hyperlink"><code class="calibre34">&lt;value&gt;</code></em></span> <code class="calibre26">for</code> <em class="hyperlink"><code class="calibre34">&lt;item&gt;</code></em> <code class="calibre26">in</code> <em class="hyperlink"><code class="calibre34">&lt;sequence&gt;</code></em> <code class="calibre26">if</code> <em class="hyperlink"><code class="calibre34">&lt;condition&gt;</code></em><code class="calibre26">]</code>.  This will create a list of
all the <em class="hyperlink"><code class="calibre34">&lt;value&gt;</code></em> items.  Alternatively, we can use similar syntax to create a
generator of the <em class="hyperlink"><code class="calibre34">&lt;value&gt;</code></em> items instead of a list with <code class="calibre26">(</code><em class="hyperlink"><code class="calibre34">&lt;value&gt;</code></em> <code class="calibre26">for</code> <em class="hyperlink"><code class="calibre34">&lt;item&gt;</code></em>
<code class="calibre26">in</code> <em class="hyperlink"><code class="calibre34">&lt;sequence&gt;</code></em> <code class="calibre26">if</code> <em class="hyperlink"><code class="calibre34">&lt;condition&gt;</code></em><code class="calibre26">)</code>.</p>

<p class="author1">Using this subtle difference between list comprehension and generator
comprehension, we can optimize the preceding code for <code class="calibre26">divisible_by_three</code>.
However, generators do not have a <code class="calibre26">length</code> property.  As a result, we will have to
be a bit clever:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre50"><code class="n">divisible_by_three</code> <code class="o">=</code> <code class="nb">sum</code><code class="p">(</code><code class="mi">1</code> <code class="kn">for</code> <code class="n">n</code> <code class="ow">in</code> <code class="n">fibonacci_gen</code><code class="p">(</code><code class="mi">100</code><code class="n">_000</code><code class="p">)</code> <code class="kn">if</code> <code class="n">n</code> <code class="o">%</code> <code class="mi">3</code> <code class="o">==</code> <code class="mi">0</code><code class="p">)</code></pre>

<p class="author1">Here, we have a generator that emits a value of <code class="calibre26">1</code> whenever it encounters a
number divisible by 3, and nothing otherwise.  By summing all elements in this
generator, we are essentially doing the same as the list comprehension version
and consuming no significant memory.</p>
<div data-type="note" epub:type="note" class="calibre35"><h6 class="calibre36">Note</h6>
<p class="author1">Many of Python’s built-in functions that operate on sequences are generators
themselves (albeit sometimes a special type of generator). For example,<a data-type="indexterm" data-primary="range function" id="idm46122423684136" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <code class="calibre26">range</code>
returns a generator of values as opposed to the actual list of numbers within
the specified range. Similarly,<a data-type="indexterm" data-primary="map function" id="idm46122423682360" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="zip function" id="idm46122423681656" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="filter function" id="idm46122423680984" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="reversed function" id="idm46122423680312" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="enumerate function" id="idm46122423679640" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <code class="calibre26">map</code>, <code class="calibre26">zip</code>, <code class="calibre26">filter</code>, <code class="calibre26">reversed</code>, and
<code class="calibre26">enumerate</code> all perform the calculation as needed and don’t store the full
result. This means that the operation <code class="calibre26">zip(range(100_000), range(100_000))</code> will
always have only two numbers in memory in order to return its corresponding
values, instead of precalculating the result for the entire range beforehand.</p>
</div>

<p class="author1">The performance of the two versions of this code is almost equivalent for these
smaller sequence lengths, but the memory impact of the generator version is far
less than that of the list comprehension. Furthermore, we transform the list
version into a generator, because all that matters for each element of the list
is its current value—either the number is divisible by 3 or it is not; it
doesn’t matter where its placement is in the list of numbers or what the
previous/next values are.  More complex functions can also be transformed into
generators, but depending on their reliance on state, this can become a
difficult thing to do.</p>






<section data-type="sect1" data-pdf-bookmark="Iterators for Infinite Series" class="calibre3"><div class="preface" id="iterators_inf">
<h1 class="calibre25">Iterators for Infinite Series</h1>

<p class="author1"><a data-type="indexterm" data-primary="generators and iterators" data-secondary="for infinite series" id="gi_is" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="infinite series, iterators for" id="is_ab" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="iterators and generators" data-secondary="for infinite series" id="ig_is" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>Instead of calculating a known number of Fibonacci numbers, what if we instead
attempted to calculate all of them?</p>

<pre data-type="programlisting" data-code-language="python" class="calibre50"><code class="kn">def</code> <code class="nf">fibonacci</code><code class="p">():</code>
    <code class="n">i</code><code class="p">,</code> <code class="n">j</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code>
    <code class="kn">while</code> <code class="nb">True</code><code class="p">:</code>
        <code class="kn">yield</code> <code class="n">j</code>
        <code class="n">i</code><code class="p">,</code> <code class="n">j</code> <code class="o">=</code> <code class="n">j</code><code class="p">,</code> <code class="n">i</code> <code class="o">+</code> <code class="n">j</code></pre>

<p class="author1">In this code we are doing something that wouldn’t be possible with the previous<a data-type="indexterm" data-primary="fibonacci_list function" id="idm46122423631560" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>
<code class="calibre26">fibonacci_list</code> code: we are encapsulating an infinite series of numbers into a
function. This allows us to take as many values as we’d like from this stream
and terminate when our code thinks it has had enough.</p>

<p class="author1">One reason generators aren’t used as much as they could be is that a lot of
the logic within them can be encapsulated in your logic code. Generators are really a way of organizing your code and having smarter loops.
For example, we could answer the question “How many Fibonacci numbers below 5,000
are odd?” in multiple ways:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre50"><code class="kn">def</code> <code class="nf">fibonacci_naive</code><code class="p">():</code>
    <code class="n">i</code><code class="p">,</code> <code class="n">j</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code>
    <code class="n">count</code> <code class="o">=</code> <code class="mi">0</code>
    <code class="kn">while</code> <code class="n">j</code> <code class="o">&lt;=</code> <code class="mi">5000</code><code class="p">:</code>
        <code class="kn">if</code> <code class="n">j</code> <code class="o">%</code> <code class="mi">2</code><code class="p">:</code>
            <code class="n">count</code> <code class="o">+=</code> <code class="mi">1</code>
        <code class="n">i</code><code class="p">,</code> <code class="n">j</code> <code class="o">=</code> <code class="n">j</code><code class="p">,</code> <code class="n">i</code> <code class="o">+</code> <code class="n">j</code>
    <code class="kn">return</code> <code class="n">count</code>

<code class="kn">def</code> <code class="nf">fibonacci_transform</code><code class="p">():</code>
    <code class="n">count</code> <code class="o">=</code> <code class="mi">0</code>
    <code class="kn">for</code> <code class="n">f</code> <code class="ow">in</code> <code class="n">fibonacci</code><code class="p">():</code>
        <code class="kn">if</code> <code class="n">f</code> <code class="o">&gt;</code> <code class="mi">5000</code><code class="p">:</code>
            <code class="kn">break</code>
        <code class="kn">if</code> <code class="n">f</code> <code class="o">%</code> <code class="mi">2</code><code class="p">:</code>
            <code class="n">count</code> <code class="o">+=</code> <code class="mi">1</code>
    <code class="kn">return</code> <code class="n">count</code>

<code class="kn">from</code> <code class="nn">itertools</code> <code class="kn">import</code> <code class="n">takewhile</code>
<code class="kn">def</code> <code class="nf">fibonacci_succinct</code><code class="p">():</code>
    <code class="n">first_5000</code> <code class="o">=</code> <code class="n">takewhile</code><code class="p">(</code><code class="kn">lambda</code> <code class="n">x</code><code class="p">:</code> <code class="n">x</code> <code class="o">&lt;=</code> <code class="mi">5000</code><code class="p">,</code>
                           <code class="n">fibonacci</code><code class="p">())</code>
    <code class="kn">return</code> <code class="nb">sum</code><code class="p">(</code><code class="mi">1</code> <code class="kn">for</code> <code class="n">x</code> <code class="ow">in</code> <code class="n">first_5000</code>
               <code class="kn">if</code> <code class="n">x</code> <code class="o">%</code> <code class="mi">2</code><code class="p">)</code></pre>

<p class="author1">All of these methods have similar runtime properties (as measured by their
memory footprint and runtime performance), but the<a data-type="indexterm" data-primary="fibonacci_transform function" id="idm46122423620632" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <code class="calibre26">fibonacci_transform</code>
function benefits from several things. First, it is much more verbose than<a data-type="indexterm" data-primary="fibonacci_succint function" id="idm46122423619512" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>
<code class="calibre26">fibonacci_succinct</code>, which means it will be easy for another developer to debug
and understand. The latter mainly stands as a warning for the next section,
where we cover some common workflows using <code class="calibre26">itertools</code>—while the module
greatly simplifies many simple actions with iterators, it can also quickly make
Python code very un-Pythonic. Conversely, <a data-type="indexterm" data-primary="fibonacci_naive function" id="idm46122423466504" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><code class="calibre26">fibonacci_naive</code> is doing multiple
things at a time, which hides the actual calculation it is doing! While it is
obvious in the generator function that we are iterating over the Fibonacci
numbers, we are not overencumbered by the actual calculation. Last,
<code class="calibre26">fibonacci_transform</code> is more generalizable.  This function could be renamed
<code class="calibre26">num_odd_under_5000</code> and take in the generator by argument, and thus work over
any series.</p>

<p class="author1">One additional benefit of the <code class="calibre26">fibonacci_transform</code> and <code class="calibre26">fibonacci_succinct</code> functions
is that they support the notion that in computation there are two phases:
generating data and transforming data.  These functions are very clearly
performing a transformation on data, while the <code class="calibre26">fibonacci</code> function generates
it. This demarcation adds extra clarity and functionality: we can move a
transformative function to work on a new set of data, or perform multiple
transformations on existing data. This paradigm has always been important when
creating complex programs; however, generators facilitate this clearly by making
generators responsible for creating the data and normal functions responsible
for acting on the generated data.<a data-type="indexterm" data-primary="" data-startref="gi_is" id="idm46122423462120" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="is_ab" id="idm46122423461144" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="ig_is" id="idm46122423460200" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/></p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Lazy Generator Evaluation" class="calibre3"><div class="preface" id="idm46122423459128">
<h1 class="calibre25">Lazy Generator Evaluation</h1>

<p class="author1"><a data-type="indexterm" data-primary="generators and iterators" data-secondary="itertools" id="gi_its" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="generators and iterators" data-secondary="lazy evaluation" id="gi_le" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="iterators and generators" data-secondary="itertools" id="ig_its" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="iterators and generators" data-secondary="lazy evaluation" id="ig_le" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="lazy generator evaluation" id="le_abt" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>As touched on previously, the way we get the memory
benefits with a generator is by dealing only with the current values of
interest. At any point in our calculation with a generator, we have only the
current value and cannot reference any other items in the sequence (algorithms
that perform this way are generally called <em class="hyperlink">single pass</em> or <em class="hyperlink">online</em>). This
can sometimes make generators more difficult to use, but many modules
and functions can help.</p>

<p class="author1">The main library of interest is <code class="calibre26">itertools</code>, in the standard library. It supplies
many other useful functions, including these:</p>
<dl class="calibre28">
<dt class="calibre29"><code class="calibre26">islice</code></dt>
<dd class="calibre30">
<p class="calibre31"><a data-type="indexterm" data-primary="islice function" id="idm46122423447704" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>Allows slicing a potentially infinite generator</p>
</dd>
<dt class="calibre29"><code class="calibre26">chain</code></dt>
<dd class="calibre30">
<p class="calibre31"><a data-type="indexterm" data-primary="chain function" id="idm46122423445592" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>Chains together multiple generators</p>
</dd>
<dt class="calibre29"><code class="calibre26">takewhile</code></dt>
<dd class="calibre30">
<p class="calibre31"><a data-type="indexterm" data-primary="takewhile function" id="idm46122423443480" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>Adds a condition that will end a generator</p>
</dd>
<dt class="calibre29"><code class="calibre26">cycle</code></dt>
<dd class="calibre30">
<p class="calibre31"><a data-type="indexterm" data-primary="cycle function" id="idm46122423441368" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>Makes a finite generator infinite by constantly repeating it</p>
</dd>
</dl>

<p class="author1">Let’s build up an example of using generators to analyze a large
dataset. Let’s say we’ve had an analysis routine going over temporal data, one
piece of data per second, for the last 20 years—that’s 631,152,000 data points! The
data is stored in a file, one second per line, and we cannot load the entire
dataset into memory. As a result, if we wanted to do some simple anomaly
detection, we’d have to use generators to save memory!</p>

<p class="author1">The problem will be: Given a datafile of the form “timestamp, value,” find days
whose values differ from normal distribution.  We start by writing the code that
will read the file, line by line, and output each line’s value as a Python
object. We will also create a <code class="calibre26">read_fake_data</code> generator to generate fake data that
we can test our algorithms with. For this function we still take the argument
<code class="calibre26">filename</code>, so as to have the same function signature as <code class="calibre26">read_data</code>; however,
we will simply disregard it. These two functions, shown in <a data-type="xref" href="#iter_read_data" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 5-2</a>,
are indeed lazily evaluated—we read the next line in the file, or generate
new fake data, only when the<a data-type="indexterm" data-primary="next() function" id="idm46122423436232" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <code class="calibre26">next()</code> function is called.</p>
<div id="iter_read_data" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 5-2. </span>Lazily reading data</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="kn">from</code> <code class="nn">random</code> <code class="kn">import</code> <code class="n">normalvariate</code><code class="p">,</code> <code class="n">randint</code>
<code class="kn">from</code> <code class="nn">itertools</code> <code class="kn">import</code> <code class="n">count</code>
<code class="kn">from</code> <code class="nn">datetime</code> <code class="kn">import</code> <code class="n">datetime</code>

<code class="kn">def</code> <code class="nf">read_data</code><code class="p">(</code><code class="n">filename</code><code class="p">):</code>
    <code class="kn">with</code> <code class="nb">open</code><code class="p">(</code><code class="n">filename</code><code class="p">)</code> <code class="kn">as</code> <code class="n">fd</code><code class="p">:</code>
        <code class="kn">for</code> <code class="n">line</code> <code class="ow">in</code> <code class="n">fd</code><code class="p">:</code>
            <code class="n">data</code> <code class="o">=</code> <code class="n">line</code><code class="o">.</code><code class="n">strip</code><code class="p">()</code><code class="o">.</code><code class="n">split</code><code class="p">(</code><code class="s">','</code><code class="p">)</code>
            <code class="n">timestamp</code><code class="p">,</code> <code class="n">value</code> <code class="o">=</code> <code class="nb">map</code><code class="p">(</code><code class="nb">int</code><code class="p">,</code> <code class="n">data</code><code class="p">)</code>
            <code class="kn">yield</code> <code class="n">datetime</code><code class="o">.</code><code class="n">fromtimestamp</code><code class="p">(</code><code class="n">timestamp</code><code class="p">),</code> <code class="n">value</code>

<code class="kn">def</code> <code class="nf">read_fake_data</code><code class="p">(</code><code class="n">filename</code><code class="p">):</code>
    <code class="kn">for</code> <code class="n">timestamp</code> <code class="ow">in</code> <code class="n">count</code><code class="p">():</code>
        <code class="c">#  We insert an anomalous data point approximately once a week</code>
        <code class="kn">if</code> <code class="n">randint</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">7</code> <code class="o">*</code> <code class="mi">60</code> <code class="o">*</code> <code class="mi">60</code> <code class="o">*</code> <code class="mi">24</code> <code class="o">-</code> <code class="mi">1</code><code class="p">)</code> <code class="o">==</code> <code class="mi">1</code><code class="p">:</code>
            <code class="n">value</code> <code class="o">=</code> <code class="n">normalvariate</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">)</code>
        <code class="kn">else</code><code class="p">:</code>
            <code class="n">value</code> <code class="o">=</code> <code class="mi">100</code>
        <code class="kn">yield</code> <code class="n">datetime</code><code class="o">.</code><code class="n">fromtimestamp</code><code class="p">(</code><code class="n">timestamp</code><code class="p">),</code> <code class="n">value</code></pre></div>

<p class="author1">Now we’d like to create a function that outputs groups of data that occur in
the same day. For this, we can use the<a data-type="indexterm" data-primary="groupby function" id="idm46122423430680" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/> <code class="calibre26">groupby</code> function in <a data-type="indexterm" data-primary="itertools" id="idm46122423429560" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><code class="calibre26">itertools</code>
(<a data-type="xref" href="#iter_day_grouper" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 5-3</a>). This function works by taking in a sequence of items
and a key used to group these items. The output is a generator that produces
tuples whose items are the key for the group and a generator for the items in
the group. As our key function, we will output the calendar day that the data
was recorded. This <a data-type="indexterm" data-primary="key function" id="idm46122423292568" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>“key” function could be anything—we could group our data by
hour, by year, or by some property in the actual value. The only limitation is
that groups will be formed only for data that is sequential. So if we had the
input <code class="calibre26">A A A A B B A A</code> and had <code class="calibre26">groupby</code> group by the letter, we would get
three groups: <code class="calibre26">(A, [A, A, A, A])</code>, <code class="calibre26">(B, [B, B])</code>, and <code class="calibre26">(A, [A, A])</code>.</p>
<div id="iter_day_grouper" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 5-3. </span>Grouping our data</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="kn">from</code> <code class="nn">itertools</code> <code class="kn">import</code> <code class="n">groupby</code>

<code class="kn">def</code> <code class="nf">groupby_day</code><code class="p">(</code><code class="n">iterable</code><code class="p">):</code>
    <code class="n">key</code> <code class="o">=</code> <code class="kn">lambda</code> <code class="n">row</code><code class="p">:</code> <code class="n">row</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="o">.</code><code class="n">day</code>
    <code class="kn">for</code> <code class="n">day</code><code class="p">,</code> <code class="n">data_group</code> <code class="ow">in</code> <code class="n">groupby</code><code class="p">(</code><code class="n">iterable</code><code class="p">,</code> <code class="n">key</code><code class="p">):</code>
        <code class="kn">yield</code> <code class="nb">list</code><code class="p">(</code><code class="n">data_group</code><code class="p">)</code></pre></div>

<p class="author1">Now to do the actual <a data-type="indexterm" data-primary="anomaly detection" id="idm46122423152136" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>anomaly detection. We do this in <a data-type="xref" href="#iter_anomaly" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 5-4</a> by creating a function that, given one group of data, returns whether it
follows the normal distribution (using <code class="calibre26">scipy.stats.normaltest</code>). We can use
this check with <code class="calibre26">itertools.filterfalse</code> to filter down the full dataset only to
inputs that <em class="hyperlink">don’t</em> pass the test. These inputs are what we consider to be
anomalous.</p>
<div data-type="note" epub:type="note" class="calibre35"><h6 class="calibre36">Note</h6>
<p class="author1">In <a data-type="xref" href="#iter_day_grouper" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 5-3</a>, we cast <code class="calibre26">data_group</code> into a list, even though it is
provided to us as an iterator. This is because the <a data-type="indexterm" data-primary="normaltest function" id="idm46122423261336" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><code class="calibre26">normaltest</code> function
requires an array-like object. We could, however, write our own <code class="calibre26">normaltest</code>
function that is “one-pass” and could operate on a single view of the data. This
could be done without too much trouble by using<a data-type="indexterm" data-primary="Welford's online averaging algorithm" id="idm46122423259688" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/>
<a href="https://oreil.ly/p2g8Q" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Welford’s
online averaging algorithm</a> to calculate the skew and kurtosis of the numbers.
This would save us even more memory by always storing only a single value of the
dataset in memory at once instead of storing a full day at a time. However,
performance time regressions and development time should be taken into
consideration: is storing one day of data in memory at a time sufficient for
this problem, or does it need to be further 
<span class="publishername">optimized</span>?</p>
</div>
<div id="iter_anomaly" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 5-4. </span>Generator-based anomaly detection</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="kn">from</code> <code class="nn">scipy.stats</code> <code class="kn">import</code> <code class="n">normaltest</code>
<code class="kn">from</code> <code class="nn">itertools</code> <code class="kn">import</code> <code class="n">filterfalse</code>

<code class="kn">def</code> <code class="nf">is_normal</code><code class="p">(</code><code class="n">data</code><code class="p">,</code> <code class="n">threshold</code><code class="o">=</code><code class="mi">1e-3</code><code class="p">):</code>
    <code class="n">_</code><code class="p">,</code> <code class="n">values</code> <code class="o">=</code> <code class="nb">zip</code><code class="p">(</code><code class="o">*</code><code class="n">data</code><code class="p">)</code>
    <code class="n">k2</code><code class="p">,</code> <code class="n">p_value</code> <code class="o">=</code> <code class="n">normaltest</code><code class="p">(</code><code class="n">values</code><code class="p">)</code>
    <code class="kn">if</code> <code class="n">p_value</code> <code class="o">&lt;</code> <code class="n">threshold</code><code class="p">:</code>
        <code class="kn">return</code> <code class="nb">False</code>
    <code class="kn">return</code> <code class="nb">True</code>

<code class="kn">def</code> <code class="nf">filter_anomalous_groups</code><code class="p">(</code><code class="n">data</code><code class="p">):</code>
    <code class="kn">yield from</code> <code class="n">filterfalse</code><code class="p">(</code><code class="n">is_normal</code><code class="p">,</code> <code class="n">data</code><code class="p">)</code></pre></div>

<p class="author1">Finally, we can put together the chain of generators to get the days that had
anomalous data (<a data-type="xref" href="#iter_chaining_generators" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 5-5</a>).</p>
<div id="iter_chaining_generators" data-type="example" class="calibre56">
<h5 class="calibre58"><span class="publishername">Example 5-5. </span>Chaining together our generators</h5>

<pre data-type="programlisting" data-code-language="python" class="calibre59"><code class="kn">from</code> <code class="nn">itertools</code> <code class="kn">import</code> <code class="n">islice</code>


<code class="kn">def</code> <code class="nf">filter_anomalous_data</code><code class="p">(</code><code class="n">data</code><code class="p">):</code>
    <code class="n">data_group</code> <code class="o">=</code> <code class="n">groupby_day</code><code class="p">(</code><code class="n">data</code><code class="p">)</code>
    <code class="kn">yield from</code> <code class="n">filter_anomalous_groups</code><code class="p">(</code><code class="n">data_group</code><code class="p">)</code>

<code class="n">data</code> <code class="o">=</code> <code class="n">read_data</code><code class="p">(</code><code class="n">filename</code><code class="p">)</code>
<code class="n">anomaly_generator</code> <code class="o">=</code> <code class="n">filter_anomalous_data</code><code class="p">(</code><code class="n">data</code><code class="p">)</code>
<code class="n">first_five_anomalies</code> <code class="o">=</code> <code class="n">islice</code><code class="p">(</code><code class="n">anomaly_generator</code><code class="p">,</code> <code class="mi">5</code><code class="p">)</code>

<code class="kn">for</code> <code class="n">data_anomaly</code> <code class="ow">in</code> <code class="n">first_five_anomalies</code><code class="p">:</code>
    <code class="n">start_date</code> <code class="o">=</code> <code class="n">data_anomaly</code><code class="p">[</code><code class="mi">0</code><code class="p">][</code><code class="mi">0</code><code class="p">]</code>
    <code class="n">end_date</code> <code class="o">=</code> <code class="n">data_anomaly</code><code class="p">[</code><code class="o">-</code><code class="mi">1</code><code class="p">][</code><code class="mi">0</code><code class="p">]</code>
    <code class="kn">print</code><code class="p">(</code><code class="n">f</code><code class="s">"Anomaly from {start_date} - {end_date}"</code><code class="p">)</code></pre>

<pre data-type="programlisting" class="calibre59"># Output of above code using "read_fake_data"
Anomaly from 1970-01-10 00:00:00 - 1970-01-10 23:59:59
Anomaly from 1970-01-17 00:00:00 - 1970-01-17 23:59:59
Anomaly from 1970-01-18 00:00:00 - 1970-01-18 23:59:59
Anomaly from 1970-01-23 00:00:00 - 1970-01-23 23:59:59
Anomaly from 1970-01-29 00:00:00 - 1970-01-29 23:59:59</pre></div>

<p class="author1">This method allows us to get the list of days that are anomalous without
having to load the entire dataset. Only enough data is read to generate
the first five anomalies. Additionally, the <code class="calibre26">anomaly_generator</code> object can be
read further to continue retrieving anomalous data  This is called <em class="hyperlink">lazy
evaluation</em>—only the calculations that are explicitly requested are performed,
which can drastically reduce overall runtime if there is an early termination
condition.</p>

<p class="author1">Another nicety about organizing analysis this way is it allows us to do more
expansive calculations easily, without having to rework large parts of the code.
For example, if we want to have a moving window of one day instead of chunking
up by days, we can replace the <code class="calibre26">groupby_day</code> in <a data-type="xref" href="#iter_day_grouper" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Example 5-3</a> with
something like this:</p>

<pre data-type="programlisting" data-code-language="python" class="calibre50"><code class="kn">from</code> <code class="nn">datetime</code> <code class="kn">import</code> <code class="n">datetime</code>

<code class="kn">def</code> <code class="nf">groupby_window</code><code class="p">(</code><code class="n">data</code><code class="p">,</code> <code class="n">window_size</code><code class="o">=</code><code class="mi">3600</code><code class="p">):</code>
    <code class="n">window</code> <code class="o">=</code> <code class="nb">tuple</code><code class="p">(</code><code class="n">islice</code><code class="p">(</code><code class="n">data</code><code class="p">,</code> <code class="n">window_size</code><code class="p">))</code>
    <code class="kn">for</code> <code class="n">item</code> <code class="ow">in</code> <code class="n">data</code><code class="p">:</code>
        <code class="kn">yield</code> <code class="n">window</code>
        <code class="n">window</code> <code class="o">=</code> <code class="n">window</code><code class="p">[</code><code class="mi">1</code><code class="p">:]</code> <code class="o">+</code> <code class="p">(</code><code class="n">item</code><code class="p">,)</code></pre>

<p class="author1">In this version, we also see very explicitly the memory guarantee of this and the
previous method—it will store only the window’s worth of data as state (in both
cases, one day, or 3,600 data points). Note that the first item retrieved by the
<code class="calibre26">for</code> loop is the <code class="calibre26">window_size</code>-th value. This is because <code class="calibre26">data</code> is an iterator, and
in the previous line we consumed the first <code class="calibre26">window_size</code> values.</p>

<p class="author1">A final note: in the <a data-type="indexterm" data-primary="groupby_window() function" id="idm46122422865400" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><code class="calibre26">groupby_window</code> function, we are constantly creating new
tuples, filling them with data, and yielding them to the caller.  We can greatly
optimize this by using the <code class="calibre26">deque</code> object in the <code class="calibre26">collections</code> module.  This
object gives us <code class="calibre26">O(1)</code> appends and removals to and from the beginning or end of
a list (while normal lists are <code class="calibre26">O(1)</code> for appends or removals to/from the end of
the list and <code class="calibre26">O(n)</code> for the same operations at the beginning of the list).
Using the <code class="calibre26">deque</code> object, we can <code class="calibre26">append</code> the new data to the right (or end)
of the list and use <a data-type="indexterm" data-primary="deque.popleft() function" id="idm46122422948584" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><code class="calibre26">deque.popleft()</code> to delete data from the left (or
beginning) of the list without having to allocate more space or perform long
<code class="calibre26">O(n)</code> operations. However, we would have to work on the <code class="calibre26">deque</code> object in-place
and destroy previous views to the rolling window (see <a data-type="xref" href="ch06_split_000.xhtml#SEC-numpy-inplace" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">“Memory Allocations and In-Place Operations”</a> for
more about in-place operations). The only way around this would be to copy the
data into a tuple before yielding it back to the caller, which gets rid of any
benefit of the change!<a data-type="indexterm" data-primary="" data-startref="gi_its" id="idm46122422945464" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="gi_le" id="idm46122422944520" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="ig_its" id="idm46122422943576" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="ig_le" id="idm46122422942632" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="le_abt" id="idm46122422941688" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/></p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Wrap-Up" class="calibre3"><div class="preface" id="idm46122423458664">
<h1 class="calibre25">Wrap-Up</h1>

<p class="author1">By formulating our anomaly-finding algorithm with iterators, we can
process much more data than could fit into memory.  What’s more, we can
do it faster than if we had used lists, since we avoid all the costly <code class="calibre26">append</code>
operations.</p>

<p class="author1">Since iterators are a primitive type in Python, this should always be a go-to
method for trying to reduce the memory footprint of an application.  The
benefits are that results are lazily evaluated, so you process only the
data you need, and memory is saved since we don’t store previous results unless
explicitly required to.  In <a data-type="xref" href="ch11_split_000.xhtml#chapter-lessram" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">Chapter 11</a>, we will talk about other
methods that can be used for more specific problems and introduce some new ways
of looking at problems when RAM is an issue.</p>

<p class="author1">Another benefit of solving problems using iterators is that it prepares your
code to be used on multiple CPUs or multiple computers, as we will see in
Chapters <a href="ch09_split_000.xhtml#multiprocessing" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">9</a> and <a href="ch10.xhtml#clustering" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">10</a>.  As we discussed in
<a data-type="xref" href="#iterators_inf" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6">“Iterators for Infinite Series”</a>, when working with iterators, you must always think about the
various states that are necessary for your algorithm to work.  Once you figure
out how to package the state necessary for the algorithm to run, it doesn’t
matter where it runs.  We can see this sort of paradigm, for example, with the
<code class="calibre26">multiprocessing</code> and <code class="calibre26">ipython</code> modules, both of which use a <code class="calibre26">map</code>-like
function to launch parallel tasks.<a data-type="indexterm" data-primary="" data-startref="gi_ch" id="idm46122422932568" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/><a data-type="indexterm" data-primary="" data-startref="ig_ch" id="idm46122422931592" class="pcalibre2 pcalibre pcalibre3 pcalibre1 calibre6"/></p>
</div></section>







<div data-type="footnotes" class="calibre52"><p data-type="footnote" id="idm46122423820792" class="calibre53"><sup class="calibre54"><a href="ch05.xhtml#idm46122423820792-marker" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">1</a></sup> In general, algorithms that are <em class="hyperlink">online</em> or <em class="hyperlink">single pass</em> are a great fit for generators. However, when making the switch you have to ensure your algorithm can still function without being able to reference the data more than once.</p><p data-type="footnote" id="idm46122423727656" class="calibre53"><sup class="calibre54"><a href="ch05.xhtml#idm46122423727656-marker" class="pcalibre2 pcalibre calibre45 pcalibre3 pcalibre1">2</a></sup> Calculated with <code class="calibre26">%memit
len([n for n in fibonacci_gen(100_000) if n % 3 == 0])</code>.</p></div></div></section></div>



  </body></html>