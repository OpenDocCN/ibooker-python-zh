- en: Appendix A. Hardware and Software for Beginning Programmers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A. 初学者的硬件和软件
- en: Some things make intuitive sense. Some we see in nature, and others are human
    inventions such as the wheel or pizza.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有些东西是直观的。有些我们在自然界中看到，而其他的是人类的发明，如轮子或披萨。
- en: Others require more of a leap of faith. How does a television convert some invisible
    wiggles in the air into sounds and moving images?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 其他需要更大的信仰跳跃。电视是如何将空中的看不见的摇晃转换成声音和动态图像的？
- en: A computer is one of these hard-to-accept ideas. How can you type something
    and get a machine to do what you want?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机是一个难以接受的想法之一。你怎么能够输入东西，然后让机器按照你的意愿去做呢？
- en: 'When I was learning to program, it was hard to find answers to some basic questions.
    For example: some books explain computer memory with the analogy of books on a
    library shelf. I wondered, if you *read from memory*, the analogy implies you’re
    taking a book from the shelf. So, does that erase it from memory? Actually, no.
    It’s more like getting a *copy* of the book from the shelf.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当我学习编程时，有些基本问题的答案很难找到。例如：一些书籍用图书馆书架上的书的类比来解释计算机存储器。我曾想知道，如果你*从内存中读取*，类比意味着你从书架上取出一本书。那么，这会把它从内存中删除吗？实际上不会。更像是从书架上复制一本书。
- en: This appendix is a short review of computer hardware and software, if you’re
    relatively new to programming. I try to explain the things that become “obvious”
    eventually but may be sticking points at the start.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是相对新手，本附录简要回顾了计算机硬件和软件。我尝试解释那些最终变得“显而易见”的事物，但可能在一开始时会成为障碍。
- en: Hardware
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件
- en: Caveman Computers
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 穴居人的计算机
- en: When the cavemen Og and Thog returned from hunting, they would each add a rock
    to their own pile for each mammoth they slew. But they couldn’t do much with the
    piles, other than gain bragging rights if one was noticeably larger than the other.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当穴居人Og和Thog从狩猎归来时，他们每杀死一头猛犸象，就会在自己的堆里加一块石头。但除了比谁的堆显著更大，他们不能做什么。
- en: Distant descendents of Og (Thog got stomped by a mammoth one day, trying to
    add to his pile) would learn to count, and write, and use an abacus. But some
    leaps of imagination and technology were needed to get beyond these tools to the
    concept of a computer. The first necessary technology was electricity.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Og的远裔（Thog有一天被猛犸象踩死，试图增加他的堆），学会了数数、写字和使用算盘。但要超越这些工具，进入计算机的概念，需要一些想象力和技术的飞跃。第一个必要的技术是电力。
- en: Electricity
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电力
- en: Ben Franklin thought that electricity was a flow of some invisible fluid from
    a place with more fluid (*positive*) to a place with less (*negative*). He was
    right, but got the terms backwards. Electrons flow from his “negative” to “positive,”
    but electrons weren’t discovered until much later—too late to change the terminology.
    So, ever since we’ve needed to remember that electrons flow one way and *current*
    is defined as flowing the other way.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本杰明·富兰克林认为电是一种从流体量较多的地方（*正极*）流向量较少的地方（*负极*）的流动的某种看不见的液体。他是对的，但术语搞反了。电子从他的“负极”流向“正极”，但电子直到后来才被发现
    —— 太迟了，不能改变术语。因此，自那时起，我们一直需要记住电子流动的方向和*电流*定义的流动方式是相反的。
- en: We’re all familiar with natural electrical phenomena like static electricity
    and lightning. After people discovered how to push electrons through conducting
    wires to make electrical *circuits*, we got one step closer to making computers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都熟悉自然电现象，如静电和闪电。在人们发现如何通过导线推动电子形成电路后，我们离制造计算机又近了一步。
- en: 'I used to think that electric current in a wire was caused by jazzed electrons
    doing laps around the track. It’s actually quite different. Electrons jump from
    one atom to another. They behave a little like ball bearings in a tube (or tapioca
    balls in a bubble tea straw). When you push a ball at one end, it pushes its neighbor,
    and so on until the ball at the other end is pushed out. Although an average electron
    moves slowly (*drift speed* in a wire is only about three inches/hour), this almost-simultaneous
    bumping causes the generated electromagetic wave to propagate very quickly: 50
    to 99% the speed of light, depending on the conductor.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经以为电线中的电流是由兴奋的电子在轨道上做圈圈引起的。实际情况大不相同。电子会从一个原子跳到另一个原子。它们的行为有点像管子中的球轴承（或者珍珠奶茶吸管中的珍珠）。当你在一端推动一颗球时，它会推动它的邻居，依此类推，直到另一端的球被推出来。虽然一个普通电子的移动速度很慢（电线中的漂移速度仅约为每小时三英寸），但这种几乎同时的撞击使得生成的电磁波传播非常迅速：速度达到光速的50%到99%，取决于导体。
- en: Inventions
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发明
- en: 'We still needed:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要：
- en: A way to remember things
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记忆事物的一种方法
- en: A way to do stuff with the things that we remembered
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种方法是利用我们记住的东西进行操作
- en: 'One memory concept was a *switch*: something that’s either on or off, and stays
    as it is until something flips it to the other state. An electrical switch works
    by opening or closing a circuit, allowing electrons to flow or blocking them.
    We use switches all the time to control lights and other electrical devices. What
    was needed was a way to control the switch itself by electricity.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个存储概念是*开关*：一种只能处于开或关状态，并且保持不变直到有东西将其翻转到另一状态的物品。电开关通过打开或关闭电路来工作，允许电子流动或阻止电子流动。我们经常使用开关来控制灯和其他电气设备。需要的是一种能够通过电来控制开关本身的方法。
- en: 'The earliest computers (and televisions) used vacuum tubes for this purpose,
    but these were big and often burned out. The single key invention that led to
    modern computers was the *transistor*: smaller, more efficient, and more reliable.
    The final key step was to make transistors much smaller and connect them in *integrated
    circuits*. For many years, computers got faster and ridiculously cheaper as they
    became smaller and smaller. Signals move faster when the components are closer
    together.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最早的计算机（和电视）使用真空管来实现这一目的，但它们又大又经常烧坏。导致现代计算机出现的单一关键发明是*晶体管*：它更小、更高效、更可靠。最后的关键步骤是将晶体管做得更小，并将它们连接成*集成电路*。多年来，随着计算机变得越来越小，它们变得越来越快速和价格越来越低廉。当组件越接近时，信号传输速度更快。
- en: But there’s a limit to how small we can stuff things together. This electron
    friskiness encounters *resistance*, which generates heat. We reached that lower
    limit more than 10 years ago, and manufacturers have compensated by putting multiple
    “chips” on the same board. This has increased the demand for *distributed computing*,
    which I discuss in a bit.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们能够将东西放得越来越小的极限是有限的。这种电子的调皮会遇到*电阻*，产生热量。我们在超过10年前达到了这个下限，制造商通过在同一板上放置多个“芯片”来补偿。这增加了*分布式计算*的需求，我稍后会讨论。
- en: 'Regardless of these details, with these inventions we have been able to construct
    *computers*: machines that can remember things and so something with them.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 不管这些细节如何，有了这些发明，我们已经能够构建*计算机*：能够记住事物并对其进行处理的机器。
- en: An Idealized Computer
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理想化的计算机
- en: Real computers have lots of complex features. Let’s focus on the essential parts.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的计算机有许多复杂的功能。让我们专注于关键部分。
- en: A circuit “board” contains the CPU, memory, and wires connecting them to each
    other and to plugs for external devices.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 电路“板”包含CPU、存储器和连接它们彼此以及外部设备插头的电线。
- en: The CPU
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPU
- en: 'The *CPU* (Central Processing Unit), or “chip,” does the actual “computing”:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*CPU*（中央处理单元）或“芯片”执行实际的“计算”：'
- en: Mathematical tasks like addition
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学任务如加法
- en: Comparing values
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较值
- en: Memory and Caches
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储器和高速缓存
- en: '*RAM* (Random Access Memory) does the “remembering.” It’s fast, but *volatile*
    (loses its data if power is lost).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*RAM*（随机存取存储器）进行“记忆”。它速度快，但是*易失性*（如果断电则会丢失数据）。'
- en: 'CPUs have been getting ever faster than memory, so computer designers have
    been adding *caches*: smaller, faster memory between the CPU and main memory.
    When your CPU tries to read some bytes from memory, it first tries the closest
    cache (called an *L1* cache), then the next (*L2*), and eventually to main RAM.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: CPU比内存速度更快，因此计算机设计者一直在添加*缓存*：位于CPU和主内存之间的较小、更快的内存。当CPU尝试从内存读取一些字节时，它首先尝试最接近的缓存（称为*L1*缓存），然后是下一个（*L2*），最后到主RAM。
- en: Storage
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储
- en: Because main memory loses its data, we also need *nonvolatile* storage. Such
    devices are cheaper than memory and hold much more data, but are also much slower.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因为主存储器会丢失数据，我们还需要*非易失性*存储。这些设备比内存便宜，能够存储更多数据，但速度也慢得多。
- en: 'The traditional storage method has been “spinning rust”: *magnetic disks* (or
    *hard drives* or *HDD*) with movable read-write heads, a little like vinyl records
    and a stylus.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的存储方法是“旋转锈”：*磁盘*（或*硬盘*或*HDD*）带有可移动读写头，有点像黑胶唱片和唱针。
- en: A hybrid technology called *SSD* (Solid State Drive) is made of semiconductors
    like RAM, but is nonvolatile like magnetic disks. Price and speed falls between
    the two.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一种称为*固态硬盘*（Solid State Drive，SSD）的混合技术是由类似RAM的半导体组成，但像磁盘一样是非易失性的。价格和速度介于这两者之间。
- en: Inputs
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入
- en: How do you get data into the computer? For people, the main choices are keyboards,
    mice, and touchscreens.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将数据输入计算机？对于人类来说，主要选择是键盘、鼠标和触摸屏。
- en: Outputs
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出
- en: People generally see computer output with displays and printers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 人们通常通过显示器和打印机看到计算机的输出。
- en: Relative Access Times
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相对访问时间
- en: The amount of time it takes to get data to and from any of these components
    varies tremendously. This has big practical implications, For example, software
    needs to run in memory and access data there, but it also needs to store data
    safely on nonvolatile devices like disks. The problem is that disks are thousands
    of times slower, and networks are even slower. This means that programmers spend
    a lot of time trying to make the best trade-offs between speed and cost.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从任何这些组件获取数据并将数据传输出去所需的时间差异巨大。这对实际应用有着重大的影响，例如，软件需要在内存中运行并访问数据，但它还需要将数据安全地存储在像磁盘这样的非易失性设备上。问题在于磁盘慢了成千上万倍，网络甚至更慢。这意味着程序员花费了大量时间来在速度和成本之间进行最佳权衡。
- en: In [Computer Latency at a Human Scale](https://oreil.ly/G36qD), David Jeppesen
    compares them. I’ve derived [Table A-1](#tableA1) from his numbers and others.
    The last columns—Ratio, Relative Time (CPU = one second) and Relative Distance
    (CPU = one inch)—are easier for us to relate to than the specific timings.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [《人类尺度下的计算机延迟》](https://oreil.ly/G36qD) 中，大卫·杰普森对它们进行了比较。我从他的数据和其他数据推导出了 [表
    A-1](#tableA1)。最后三列——比率、相对时间（CPU = 一秒）和相对距离（CPU = 一英寸）——比具体的时间更容易理解。
- en: Table A-1\. Relative access times
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 表 A-1\. 相对访问时间
- en: '| Location | Time | Ratio | Relative Time | Relative Distance |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 地点 | 时间 | 比率 | 相对时间 | 相对距离 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| CPU | 0.4 ns | 1 | 1 sec | 1 in |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| CPU | 0.4 纳秒 | 1 | 1 秒 | 1 英寸 |'
- en: '| L1 cache | 0.9 ns | 2 | 2 sec | 2 in |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| L1 缓存 | 0.9 纳秒 | 2 | 2 秒 | 2 英寸 |'
- en: '| L2 cache | 2.8 ns | 7 | 7 sec | 7 in |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| L2 缓存 | 2.8 纳秒 | 7 | 7 秒 | 7 英寸 |'
- en: '| L3 cache | 28 ns | 70 | 1 min | 6 ft |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| L3 缓存 | 28 纳秒 | 70 | 1 分钟 | 6 英尺 |'
- en: '| RAM | 100 ns | 250 | 4 min | 20 ft |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| RAM | 100 纳秒 | 250 | 4 分钟 | 20 英尺 |'
- en: '| SSD | 100 µs | 250,000 | 3 days | 4 miles |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| SSD | 100 微秒 | 250,000 | 3 天 | 4 英里 |'
- en: '| Mag disk | 10 ms | 25,000,000 | 9 months | 400 miles |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 磁盘 | 10 毫秒 | 25,000,000 | 9 个月 | 400 英里 |'
- en: '| Internet: SF→NY | 65 ms | 162,500,000 | 5 years | 2,500 miles |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 互联网：SF→NY | 65 毫秒 | 162,500,000 | 5 年 | 2,500 英里 |'
- en: It’s a good thing that a CPU instruction actually takes less than a nanosecond
    instead of a whole second, or else you could have a baby in the time it takes
    to access a magnetic disk. Because disk and network times are so much slower than
    CPU and RAM, it helps to do as much work in memory as you can. And since the CPU
    itself is so much faster than RAM, it makes sense to keep data contiguous, so
    the bytes can be served by the faster (but smaller) caches closer to the CPU.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 庆幸的是，CPU 指令实际上只需要不到一纳秒的时间，而不是整整一秒，否则你可能在访问磁盘的时间里生个孩子。因为磁盘和网络的时间比 CPU 和 RAM 慢得多，所以尽可能多地在内存中进行工作是有帮助的。而且由于
    CPU 本身比 RAM 快得多，所以将数据保持连续是有意义的，这样字节就可以由更快（但更小）的缓存服务，靠近 CPU。
- en: Software
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件
- en: Given all this computer hardware, how would we control it? First, we have both
    *instructions* (stuff that tells the CPU what to do) and *data* (inputs and outputs
    for the instructions). In the *stored-program computer*, everything could be treated
    as data, which simplified the design. But how do you represent instructions and
    data? What is it that you save in one place and process in another? The far-flung
    descendants of caveman Og wanted to know.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于所有这些计算机硬件，我们将如何控制它？首先，我们既有*指令*（告诉 CPU 要做什么的东西），也有*数据*（指令的输入和输出）。在*存储程序计算机*中，一切都可以被视为数据，这简化了设计。但是如何表示指令和数据呢？什么是你在一个地方保存并在另一个地方处理的东西？遥远的原始人
    Og 的后代们想知道。
- en: In the Beginning Was the Bit
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 起初是比特
- en: 'Let’s go back to the idea of a *switch*: something that maintains one of two
    values. These could be on or off, high or low voltage, positive or negative—just
    something that can be set, won’t forget, and can later provide its value to anyone
    who asks. Integrated circuits gave us a way to integrate and connect billions
    of little switches into small chips.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新思考一下*开关*的概念：维持两个值之一的东西。这些值可以是开或关、高或低电压、正或负——只要是可以设置的东西，不会忘记，并且以后可以向任何要求它的人提供其值的东西。集成电路给了我们一种将数十亿个小开关集成和连接到小芯片中的方法。
- en: If a switch can have just two values, it can be used to represent a *bit*, or
    binary digit. This could be treated as the tiny integers `0` and `1`, yes and
    no, true and false, or anything we want.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个开关只能有两个值，它可以用来表示一个*比特*，或二进制位。这可以被视为微小的整数 `0` 和 `1`，是和否、真和假，或者任何我们想要的东西。
- en: However, bits are too small for anything beyond `0` and `1`. How can we convince
    bits to represent bigger things?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于 `0` 和 `1` 以外的任何东西来说，比特都太小了。我们怎么能说服比特表示更大的事物呢？
- en: For an answer, look at your fingers. We use only 10 digits (0 through 9) in
    our daily lives, but we make numbers much bigger than 9 by *positional notation*.
    If I add `1` to the number `38`, the `8` becomes a `9` and the whole value is
    now `39`. If I add another `1`, the `9` turns into a `0` and I *carry the one*
    to the left, incrementing the `3` to a `4` and getting the final number `40`.
    The far-right number is in the “one’s column,” the one to its left is the “ten’s
    column,” and so on to the left, multiplying by 10 each time. With three decimal
    digits, you can represent a thousand (10 * 10 * 10) numbers, from `000` to `999`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得答案，请看您的手指。我们在日常生活中只使用 10 个数字（0 到 9），但通过*位的位置表示法*可以创建比 9 更大的数字。如果我给数字`38`加`1`，则`8`变成`9`，整个值现在是`39`。如果我再加`1`，则`9`变成`0`，我*向左进位*，将`3`增加到`4`，得到最终的数字`40`。最右边的数字在“个位”，左边的在“十位”，依此类推向左乘以
    10。使用三个十进制数字，可以表示一千（10 * 10 * 10）个数字，从`000`到`999`。
- en: We can use positional notation with bits to make larger collections of them.
    A *byte* has eight bits, with 2⁸ (256) possible bit combinations. You can use
    a byte to store, for example, small integers `0` to `255` (you need to save room
    for a zero in positional notation).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用位的位置表示法来组合更大的位集合。*字节*由八位组成，有 2⁸（256）种可能的位组合。例如，您可以使用一个字节存储小整数`0`到`255`（在位的位置表示法中需要为零保留空间）。
- en: A byte looks like eight bits in a row, each bit with a value of either `0` (or
    off, or false) or `1` (or on, or true). The bit on the far right is the *least
    significant*, and the leftmost one is the *most significant*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字节看起来像是一排八个位，每个位的值要么是`0`（关闭或假），要么是`1`（打开或真）。最右边的位是*最低有效位*，最左边的是*最高有效位*。
- en: Machine Language
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机器语言
- en: Each computer CPU is designed with an *instruction set* of bit patterns (also
    called *opcodes*) that it understands. Each opcode performs a certain function,
    with input values from one place and output values to another place. CPUs have
    special internal places called *registers* to store these opcodes and values.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每台计算机的CPU都设计有一组位模式（也称为操作码）的*指令集*，它理解这些指令。每个操作码执行特定的功能，从一个地方获取输入值并将输出值传输到另一个地方。CPU有称为*寄存器*的特殊内部位置来存储这些操作码和值。
- en: 'Let’s use an simplified computer that works only with bytes, and has four byte-sized
    registers called `A`, `B`, `C`, and `D`. Assume that:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个仅处理字节的简化计算机，它有四个字节大小的寄存器，分别称为`A`、`B`、`C`和`D`。假设：
- en: The command opcode goes into register `A`
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令的操作码放入寄存器`A`中。
- en: The command gets its byte inputs from registers `B` and `C`
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该指令从寄存器`B`和`C`获取其字节输入。
- en: The command stores its byte result in register `D`
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该指令将其字节结果存储在寄存器`D`中。
- en: (Adding two bytes could *overflow* a single byte result, but I’m ignoring that
    here to show what happens where.)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: （两个字节相加可能会*溢出*到一个字节的结果，但这里我忽略了这一点，以展示发生了什么。）
- en: 'Say that:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 假设
- en: 'Register `A` contains the opcode for *add two integers*: a decimal `1` (binary
    `00000001`).'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器`A`包含*加两个整数*的操作码：十进制`1`（二进制`00000001`）。
- en: Register `B` has the decimal value `5` (binary `00000101`).
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器`B`中有十进制值`5`（二进制`00000101`）。
- en: Register `C` has the decimal value `3` (binary `00000011`).
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器`C`中有十进制值`3`（二进制`00000011`）。
- en: The CPU sees that an instruction has arrived in register `A`. It decodes and
    runs that instruction, reading values from registers `B` and `C` and passing them
    to internal hardware circuits that can add bytes. When it’s done, we should see
    the decimal value `8` (binary `00001000`) in register `D`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 发现指令已经到达寄存器`A`。它解码并执行该指令，从寄存器`B`和`C`读取值，并将它们传递给内部硬件电路，可以添加字节。完成后，我们应该在寄存器`D`中看到十进制值`8`（二进制`00001000`）。
- en: The CPU does addition, and other mathematical functions, using registers in
    this way. It *decodes* the opcode and directs control to specific circuits within
    the CPU. It can also compare things, such as “Is the value in `B` larger than
    the value in `C`?” Importantly, it also *fetches* values from memory to CPU and
    *stores* values from CPU to memory.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: CPU使用寄存器进行加法和其他数学功能。它*解码*操作码并将控制传递给CPU内特定的电路。它还可以比较事物，比如“寄存器`B`中的值是否大于寄存器`C`中的值？”重要的是，它还从内存中*获取*值到CPU，从CPU中*存储*值到内存。
- en: The computer stores *programs* (machine-language instructions and data) in memory
    and handles feeding instructions and data to and from the CPU.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机将*程序*（机器语言指令和数据）存储在内存中，并处理将指令和数据输入到CPU，并从CPU中读取指令和数据。
- en: Assembler
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 汇编器
- en: It’s hard to program in machine language. You have to get specify every bit
    perfectly, which is very time consuming. So, people came up with a slightly more
    readable level of languages called *assembly language*, or just *assembler*. These
    languages are specific to a CPU design and let you use things like variable names
    to define your instruction flow and data.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 用机器语言编程很难。你必须精确指定每一位，这非常耗时。因此，人们提出了一种稍微可读性更高的语言级别，称为*汇编语言*，或者简称*汇编器*。这些语言特定于CPU设计，并允许你使用变量名来定义指令流和数据。
- en: Higher-Level Languages
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级语言
- en: Assembler is still a painstaking endeavor, so people designed *higher-level
    languages* that were even easier for people to use. These languages would be translated
    into assembler by a program called a *compiler*, or run directly by an *interpreter*.
    Among the oldest of these languages are FORTRAN, LISP, and C—wildly different
    in design and intended use, but similar in their place in computer architecture.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编仍然是一项繁琐的工作，所以人们设计了更高级别的语言，更容易供人们使用。这些语言将由称为*编译器*的程序转换为汇编语言，或者由*解释器*直接运行。其中最早的语言包括FORTRAN、LISP和C——在设计和预期使用方面大相径庭，但在计算机架构中的位置相似。
- en: 'In real jobs you tend to see distinct software “stacks”:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际工作中，你往往会看到不同的软件“堆栈”：
- en: Mainframe
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 大型计算机
- en: IBM, COBOL, FORTRAN, and others
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: IBM，COBOL，FORTRAN和其他语言
- en: Microsoft
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 微软
- en: Windows, ASP, C#, SQL Server
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Windows，ASP，C＃，SQL Server
- en: JVM
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: JVM
- en: Java, Scala, Groovy
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Java，Scala，Groovy
- en: Open source
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 开源软件
- en: Linux, languages(Python, PHP, Perl, C, C++, Go), databases (MySQL, PostgreSQL),
    web (apache, nginx)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Linux，语言（Python，PHP，Perl，C，C++，Go），数据库（MySQL，PostgreSQL），Web（apache，nginx）
- en: Programmers tend to stay in one of these worlds, using the languages and tools
    within it. Some technologies, such as TCP/IP and the web, allow intercommunication
    between stacks.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员倾向于留在这些世界中的一个，使用其中的语言和工具。一些技术，如TCP/IP和Web，允许不同堆栈之间的互联。
- en: Operating Systems
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作系统
- en: Each innovation was built on those before it, and generally we don’t know or
    care how the lower levels even work. Tools build tools to build even more tools,
    and we take them for granted.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个创新都是在前面的基础上构建的，通常我们不知道也不关心更底层的工作原理。工具构建工具，进而构建更多工具，我们习以为常。
- en: 'Tha major operating systems are:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的操作系统有：
- en: Windows (Microsoft)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Windows（微软）
- en: Commercial, many versions
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 商业软件，多个版本
- en: macOS (Apple)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: macOS（苹果）
- en: Commercial
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 商业软件
- en: Linux
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Linux
- en: Open source
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 开源软件
- en: Unix
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Unix
- en: Many commercial versions, largely replaced by Linux
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 许多商业版本，大部分已被Linux取代
- en: 'An operating system contains:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统包含：
- en: A kernel
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 内核
- en: Schedules and controls programs and I/O
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 调度和控制程序和I/O
- en: Device drivers
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 设备驱动程序
- en: Used by the kernel to access RAM, disk, and other devices
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 被内核用于访问RAM、磁盘和其他设备
- en: Libraries
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 库
- en: Source and binary files for use by developers
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员使用的源代码和二进制文件
- en: Applications
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序
- en: Standalone programs
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 独立程序
- en: The same computer hardware can support more than one operating system, but only
    one at a time. When an operating system starts up, it’s called *booting*,^([1](app01.html#idm45794959685624))
    so *rebooting* is restarting it. These terms have even appeared in movie marketing,
    as studios “reboot” previous unsuccessful attempts. You can *dual-boot* your computer
    by installing more than one operating system, side by side, but only one can be
    fired up and run at a time.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 同一台计算机硬件可以支持多个操作系统，但一次只能运行一个。当一个操作系统启动时，称为*启动*，^([1](app01.html#idm45794959685624))
    因此*重新启动*是重新启动它。这些术语甚至出现在电影营销中，因为制片厂会“重启”之前未成功的尝试。你可以通过安装多个操作系统并排运行来*双重启动*你的计算机，但一次只能启动和运行一个。
- en: If you see the phrase *bare metal*, it means a single computer running an operating
    system. In the next few sections, we step up from bare metal.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到术语*裸金属*，它指的是单台运行操作系统的计算机。在接下来的几节中，我们将从裸金属中逐步升级。
- en: Virtual Machines
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟机
- en: An operating system is sort of a big program, so eventually someone figured
    out how to run foreign operating systems as *virtual machines* (guest programs)
    on *host* machines. So you could have Microsoft Windows running on your PC, but
    fire up a Linux virtual machine atop it at the same time, without having to buy
    a second computer or dual-boot it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统有点像一个大程序，所以最终有人想出了如何在*主机*机器上作为*虚拟机*（客户程序）运行外部操作系统。所以你可以在你的PC上运行Microsoft
    Windows，同时又在其上启动一个Linux虚拟机，而无需购买第二台计算机或双重启动。
- en: Containers
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器
- en: A more recent idea is the *container*—a way to run multiple operating systems
    at the same time, as long as they share the same kernel. This idea was popularized
    by [Docker](https://www.docker.com), which took some little-known Linux kernel
    features and added useful management features. Their analogy to shipping containers
    (which revolutionized shipping and saved money for all of us) was clear and appealing.
    By releasing the code as open-source, Docker enabled containers to be adopted
    very quickly throughout the computer industry.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更近期的概念是*容器*——一种同时运行多个操作系统的方式，只要它们共享相同的内核。这个想法是由[Docker](https://www.docker.com)推广的，它利用了一些鲜为人知的Linux内核功能并增加了有用的管理功能。他们对运输集装箱的类比（它们彻底改变了运输业，并为我们所有人节省了金钱）是清晰而吸引人的。通过将代码作为开源发布，Docker使容器能够在整个计算机行业中迅速被采用。
- en: Google and other cloud providers had been quietly adding the underlying kernel
    support to Linux for years, and using containers in their data centers. Containers
    use fewer resources than virtual machines, letting you pack more programs into
    each physical computer box.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌和其他云提供商多年来一直悄悄地在Linux中添加基础内核支持，并在他们的数据中心中使用容器。容器使用的资源比虚拟机少，让你能够在每个物理计算机箱中装更多的程序。
- en: Distributed Computing and Networks
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布式计算与网络
- en: When businesses first started using personal computers, they needed ways to
    make them talk to each other as well as to devices like printers. Proprietary
    networking software, such as Novell’s, was originally used, but was eventually
    replaced by TCP/IP as the internet emerged in the mid- to late 90s. Microsoft
    grabbed its TCP/IP stack from a free Unix variant called *BSD*.^([2](app01.html#idm45794959667080))
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当企业开始使用个人电脑时，它们需要一种使它们互相交流以及与打印机等设备通信的方式。最初使用专有的网络软件，如诺维尔（Novell）的，但随着因特网在90年代中期到90年代末的出现，最终被TCP/IP所取代。微软从一种名为*BSD*的免费Unix变体中获取了它的TCP/IP堆栈。^([2](app01.html#idm45794959667080))
- en: 'One effect of the internet boom was a demand for *servers*: machines and software
    to run all those web, chat, and email services. The old style of *sysadmin* (system
    administration) was to install and manage all the hardware and software manually.
    Before long, it became clear to everyone that automation was needed. In 2006,
    Bill Baker at Microsoft came up with the *pets versus cattle* analogy for server
    management, and it has since become an industry meme (sometimes as *pets versus
    livestock*, to be more generic); see [Table A-2](#tableA2).'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因互联网繁荣而带来的一个影响是对*服务器*的需求：运行所有那些网络、聊天和电子邮件服务的机器和软件。旧式的*系统管理员*（系统管理）是手动安装和管理所有硬件和软件。不久之后，很明显地对每个人来说都需要自动化。2006年，微软的比尔·贝克尔提出了关于服务器管理的*宠物与牛*的类比，自那时起它已经成为一个行业迷因（有时更通用地称为*宠物与牲畜*）；见[表A-2](#tableA2)。
- en: Table A-2\. Pets versus livestock
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 表A-2\. 宠物与牲畜
- en: '| Pets | Livestock |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 宠物 | 牲畜 |'
- en: '| --- | --- |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Individually named | Automatically numbered |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 分别命名 | 自动编号 |'
- en: '| Customized care | Standardized |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 定制关怀 | 标准化 |'
- en: '| Nurse back to health | Replace |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 护理至健康 | 替换 |'
- en: 'You’ll often see, as a successor to “sysadmin,” the term *DevOps*: development
    plus operations, a mixture of techniques to support rapid changes to services
    without blowing them up. Cloud services are extremely large and complex, and even
    the big companies like Amazon and Google have outages now and then.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 作为“系统管理员”的继任者，您经常会看到术语*DevOps*：开发加运维，一种支持对服务进行快速更改而不会炸掉的技术混合。云服务非常庞大和复杂，即使像亚马逊和谷歌这样的大公司也偶尔会出现故障。
- en: The Cloud
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云
- en: 'People had been building computer *clusters* for a number of years, using many
    technologies. One early concept was a *Beowulf cluster*: identical commodity computers
    (Dell or something similar, instead of workstations like Sun or HP), linked by
    a local network.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，人们一直在建立计算机*集群*，使用许多技术。一个早期的概念是*贝奥武夫集群*：由相同的商用计算机（戴尔或类似的，而不是太阳或惠普等工作站）通过本地网络连接起来。
- en: The term *cloud computing* means using the computers in data centers to perform
    computing jobs and store data—but not just for the company that owned these backend
    resources. The services are provided to anyone, with fees based on CPU time, disk
    storage amounts, and so on. Amazon and its *AWS* (Amazon Web Services) is the
    most prominent, but *Azure* (Microsoft) and *Google Cloud* are also biggies.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*云计算*意味着使用数据中心中的计算机来执行计算任务和存储数据——但不仅仅是为拥有这些后端资源的公司。这些服务向任何人提供，费用基于CPU时间、磁盘存储量等。亚马逊及其*AWS*（亚马逊网络服务）是最突出的，但*Azure*（微软）和*Google
    Cloud*也是大公司。
- en: Behind the scenes, these clouds use bare metal, virtual machines, and containers—all
    treated as livestock, not pets.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，这些云使用裸金属、虚拟机和容器——全部被视为家畜，而非宠物。
- en: Kubernetes
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes
- en: 'Companies that needed to manage huge clusters of computers in many data centers—like
    Google, Amazon, and Facebook—have all borrowed or built solutions to help them
    scale:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 需要管理多个数据中心中的大型计算机集群的公司，如谷歌、亚马逊和Facebook，都借用或构建了帮助它们扩展的解决方案：
- en: Deployment
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 部署
- en: How do you make new computing hardware and software available? How do you replace
    them when they fail?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使新的计算硬件和软件可用？它们失败时如何替换？
- en: Configuration
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 配置
- en: How should these systems run? They need things like the names and addresses
    of other computers, passwords, and security settings.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这些系统应该如何运行？它们需要诸如其他计算机的名称和地址、密码和安全设置等内容。
- en: Orchestration
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 编排
- en: How do you manage all these computers, virtual machines, and containers? Can
    you scale up or down to adjust to load changes?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如何管理所有这些计算机、虚拟机和容器？您能根据负载变化进行扩展或收缩吗？
- en: Service Discovery
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 服务发现
- en: How do you find out who does what, and where it is?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何找出谁在做什么，以及它在哪里？
- en: Some competing solutions were built by Docker and others. But just in the past
    few years, it looks like the battle has been won by [Kubernetes](http://kubernetes.io).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一些竞争解决方案由Docker和其他公司开发。但在过去几年中，看起来[Kubernetes](http://kubernetes.io)已经获胜。
- en: Google had developed large internal management frameworks, codenamed Borg and
    Omega. When employees brought up the idea of open sourcing these “crown jewels,”
    management had to think about it a bit, but they took the leap. Google released
    Kubernetes version 1.0 in 2015, and its ecosystem and influence have grown ever
    since.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌开发了大型内部管理框架，代号为Borg和Omega。当员工们提出开源这些“皇家珍宝”的想法时，管理层需要考虑一下，但他们迈出了这一步。谷歌在2015年发布了Kubernetes
    1.0版本，其生态系统和影响力自那时以来不断增长。
- en: ^([1](app01.html#idm45794959685624-marker)) This refers to “Lifting yourself
    by your own bootstraps,” which seems just as improbable as a computer.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](app01.html#idm45794959685624-marker)) 这指的是“通过自己的靴带提升自己”，这似乎和一台计算机一样不可能。
- en: ^([2](app01.html#idm45794959667080-marker)) You can still see the copyright
    notices for the University of California in some Microsoft files.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](app01.html#idm45794959667080-marker)) 您仍然可以在一些微软文件中看到加州大学的版权声明。
