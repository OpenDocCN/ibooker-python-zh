- en: Chapter 5\. Managing Projects with Poetry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding chapters introduced the building blocks for publishing production-quality
    Python packages. So far, you’ve written a *pyproject.toml* for a project; created
    an environment and installed dependencies with uv, pip, or pip-tools; and built
    and published packages with `build` and Twine.
  prefs: []
  type: TYPE_NORMAL
- en: 'By standardizing project metadata and build backends, *pyproject.toml* broke
    the setuptools monopoly (see [“The Evolution of Python Project Managers”](#sidebar_poetry_evolution))
    and brought diversity to the packaging ecosystem. Defining a Python package got
    easier, too: a single well-specified file with great tooling support replaces
    the legacy boilerplate of *setup.py* and untold configuration files.'
  prefs: []
  type: TYPE_NORMAL
- en: Yet, some problems remain.
  prefs: []
  type: TYPE_NORMAL
- en: Before you can work on a *pyproject.toml*-based project, you need to research
    packaging workflows, configuration files, and associated tooling. You have to
    choose one of a number of available build backends ([Table 3-2](ch03.html#table_packages_build_backends))—and
    many people don’t know what those are, let alone how to choose them. Important
    aspects of Python packages remain unspecified—​for example, how project sources
    are laid out and which files should go into the packaging artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency and environment management could be easier, too. You need to handcraft
    your dependency specifications and compile them with pip-tools, cluttering your
    project with requirements files. And it can be hard to keep track of the many
    Python environments on a typical developer system.
  prefs: []
  type: TYPE_NORMAL
- en: The Python project manager Poetry was addressing these problems before some
    of the standards governing *pyproject.toml* took shape. Its friendly command-line
    interface lets you perform most tasks related to packaging, dependencies, and
    environments. Poetry brings its own standards-compliant build backend, `poetry.core`—but
    you can remain blissfully unaware of this fact. It also comes with a strict dependency
    resolver and locks all dependencies by default, behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Why learn about packaging standards and low-level plumbing if Poetry abstracts
    away many of these details? Because, while Poetry ventures into new territory,
    it still works within the framework defined by packaging standards. Mechanisms
    like dependency specifications and virtual environments power its central features.
    Interoperability standards let Poetry interact with package repositories as well
    as other build backends and package installers.
  prefs: []
  type: TYPE_NORMAL
- en: An understanding of these underlying mechanisms helps you debug situations where
    Poetry’s convenient abstractions break down—​for example, when a misconfiguration
    or a bug causes a package to end up in the wrong environment. Finally, the experience
    of past decades teaches us that tools come and go, while standards and algorithms
    are here to stay.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Poetry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install Poetry globally using pipx, to keep its dependencies isolated from
    the rest of the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A single Poetry installation works with multiple Python versions. However,
    Poetry uses its own interpreter as the default Python version. For this reason,
    it’s worthwhile to install Poetry on the latest stable Python release. When installing
    a new feature release of Python, reinstall Poetry like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can omit the `--python` option if pipx already uses the new Python version
    (see [“Configuring Pipx”](ch02.html#section_environments_pipx_configuration)).
  prefs: []
  type: TYPE_NORMAL
- en: 'When a prerelease of Poetry becomes available, you can install it side-by-side
    with the stable version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Above, I’ve used the `--suffix` option to rename the command so you can invoke
    it as `poetry@preview`, while keeping `poetry` as the stable version. The `--pip-args`
    option lets you pass options to pip, like `--pre` for including prereleases.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Poetry also comes with an [official installer](https://python-poetry.org/docs/#installing-with-the-official-installer),
    which you can download and run with Python. It’s not as flexible as pipx, but
    it provides a readily available alternative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Upgrade Poetry periodically to receive improvements and bugfixes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Type `poetry` on its own to check your installation of Poetry. Poetry prints
    its version and usage to the terminal, including a useful listing of all available
    subcommands.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Having successfully installed Poetry, you may want to enable tab completion
    for your shell. Use the command `poetry help completions` for shell-specific instructions.
    For example, the following commands enable tab completion in the Bash shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Restart your shell for the changes to take effect.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can create a new project using the command `poetry new`. As an example,
    I’ll use the `random-wikipedia-article` project from previous chapters. Run the
    following command in the parent directory where you want to keep your new project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After running this command, you’ll see that Poetry created a project directory
    named *random-wikipedia-article*, with the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `--src` option instructs Poetry to place the import package in a subdirectory
    named *src* rather than directly in the project directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the generated *pyproject.toml* ([Example 5-1](#example_poetry_pyproject_toml)):'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-1\. A pyproject.toml file for Poetry
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Poetry has created a standard `build-system` table with its build backend,
    `poetry.core`. This means anybody can install your project from source using pip
    or uv—​no need to set up, or even know about, the Poetry project manager. Similarly,
    you can build packages using any standard build frontend, such as `build`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The Project Metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may be surprised to see the project metadata appear under `tool.poetry`
    instead of the familiar `project` table (see [“Project Metadata”](ch03.html#section_packages_project_metadata)).
    The Poetry project plans to support the project metadata standard in its next
    major release.^([1](ch05.html#id284)) As you can see in [Table 5-1](#table_poetry_metadata),
    most fields have the same name and a similar syntax and meaning.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 5-2](#example_poetry_metadata) fills in the metadata for the project.
    I’ve highlighted some differences from [Example 3-4](ch03.html#example_packages_pyproject_toml_large).
    (You’ll use the command-line interface to add the dependencies later.)'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-2\. Metadata for a Poetry project
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_managing_projects_with_poetry_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `license` field is a string with a SPDX identifier, not a table.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_managing_projects_with_poetry_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `authors` field contains strings in the format `"name <email>"`, not tables.
    Poetry pre-populates the field with your name and email from Git.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_managing_projects_with_poetry_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `readme` field is a string with the file path. You can also specify multiple
    files as an array of strings, such as *README.md* and *CHANGELOG.md*. Poetry concatenates
    them with a blank line in between.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_managing_projects_with_poetry_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Poetry has dedicated fields for some project URLs, namely its homepage, repository,
    and documentation; for other URLs, there’s also a generic `urls` table.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_managing_projects_with_poetry_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The `python` entry in `dependencies` lets you declare compatible Python versions.
    For this project, you require Python 3.10 or later.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-1\. Metadata fields in `tool.poetry`
  prefs: []
  type: TYPE_NORMAL
- en: '| Field | Type | Description | `project` field |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | string | The project name | `name` |'
  prefs: []
  type: TYPE_TB
- en: '| `version` | string | The version of the project | `version` |'
  prefs: []
  type: TYPE_TB
- en: '| `description` | string | A short description of the project | `description`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `keywords` | array of strings | A list of keywords for the project | `keywords`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `readme` | string or array of strings | A file or list of files with the
    project description | `readme` |'
  prefs: []
  type: TYPE_TB
- en: '| `license` | string | A SPDX license identifier, or “Proprietary” | `license`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `authors` | array of strings | The list of authors | `authors` |'
  prefs: []
  type: TYPE_TB
- en: '| `maintainers` | array of strings | The list of maintainers | `maintainers`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `classifiers` | array of strings | A list of classifiers describing the project
    | `classifiers` |'
  prefs: []
  type: TYPE_TB
- en: '| `homepage` | string | The URL of the project homepage | `urls` |'
  prefs: []
  type: TYPE_TB
- en: '| `repository` | string | The URL of the project repository | `urls` |'
  prefs: []
  type: TYPE_TB
- en: '| `documentation` | string | The URL of the project documentation | `urls`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `urls` | table of strings | The project URLs | `urls` |'
  prefs: []
  type: TYPE_TB
- en: '| `dependencies` | array of strings or tables | The list of required third-party
    packages | `dependencies` |'
  prefs: []
  type: TYPE_TB
- en: '| `extras` | table of arrays of strings | Named lists of optional third-party
    packages | `optional-dependencies` |'
  prefs: []
  type: TYPE_TB
- en: '| `groups` | table of arrays of strings | Named lists of development dependencies
    | *none* |'
  prefs: []
  type: TYPE_TB
- en: '| `scripts` | table of strings or tables | Entry-point scripts | `scripts`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `plugins` | table of tables of strings | Entry point groups | `entry-points`
    |'
  prefs: []
  type: TYPE_TB
- en: 'Some `project` fields have no direct equivalent under `tool.poetry`:'
  prefs: []
  type: TYPE_NORMAL
- en: There’s no `requires-python` field; instead, you specify the required Python
    version in the `dependencies` table, using the `python` key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s no dedicated field for GUI scripts; use `plugins.gui_scripts` instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s no `dynamic` field—​all metadata is Poetry-specific, so declaring dynamic
    fields wouldn’t make much sense.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we move on, let’s check that the *pyproject.toml* file is valid. Poetry
    provides a convenient command to validate the TOML file against its configuration
    schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The Package Contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Poetry allows you to specify which files and directories to include in the distribution—​a
    feature still missing from the *pyproject.toml* standards ([Table 5-2](#table_poetry_contents)).
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-2\. Package content fields in `tool.poetry`
  prefs: []
  type: TYPE_NORMAL
- en: '| Field | Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `packages` | array of tables | Patterns for modules to include in the distribution
    |'
  prefs: []
  type: TYPE_TB
- en: '| `include` | array of strings or tables | Patterns for files to include in
    the distribution |'
  prefs: []
  type: TYPE_TB
- en: '| `exclude` | array of strings or tables | Patterns for files to exclude from
    the distribution |'
  prefs: []
  type: TYPE_TB
- en: Each table under `packages` has an `include` key with a file or directory. You
    can use `*` and `**` wildcards in their names and paths, respectively. The `from`
    key allows you to include modules from subdirectories such as *src*. Finally,
    you can use the `format` key to restrict modules to a specific distribution format;
    valid values are `sdist` and `wheel`.
  prefs: []
  type: TYPE_NORMAL
- en: The `include` and `exclude` fields allow you to list other files to include
    in, or exclude from, the distribution. Poetry seeds the `exclude` field using
    the *.gitignore* file, if present. Instead of a string, you can also use a table
    with `path` and `format` keys for sdist-only or wheel-only files. [Example 5-3](#example_poetry_sdist_with_tests)
    shows how to include the test suite in source distributions.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-3\. Including the test suite in source distributions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The Source Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Copy the contents of [Example 5-4](#example_poetry_wikipedia_full) into the
    *__init__.py* file in the new project.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-4\. The source code for `random-wikipedia-article`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You’ve declared an entry-point script in the `scripts` section in *pyproject.toml*,
    so users can invoke the application as `random-wikipedia-article`. If you’d like
    to also allow users to invoke the program with `py -m random_wikipedia_article`,
    create a *__main__.py* module next to *__init__.py* as shown in [Example 3-3](ch03.html#example_packages_main).
  prefs: []
  type: TYPE_NORMAL
- en: Managing Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s add the dependencies for `random-wikipedia-article`, starting with Rich,
    the console output library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you inspect *pyproject.toml* after running this command, you’ll find that
    Poetry has added Rich to the `dependencies` table ([Example 5-5](#example_poetry_dependencies_rich)):'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-5\. The `dependencies` table after adding Rich
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Poetry also installs the package into an environment for the project. If you
    already have a virtual environment in *.venv*, Poetry uses that. Otherwise, it
    creates a virtual environment in a shared location (see [“Managing Environments”](#section_poetry_environments)).
  prefs: []
  type: TYPE_NORMAL
- en: Caret Constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The caret (`^`) is a Poetry-specific extension to version specifiers, borrowed
    from npm, the package manager for Node.js. *Caret constraints* allow releases
    with the given minimum version, except those that may contain breaking changes
    according to the [Semantic Versioning](https://semver.org) standard. After `1.0.0`,
    a caret constraint allows patch and minor releases, but no major releases. Before
    `1.0.0`, only patch releases are allowed—​in the `0.*` era, minor releases are
    allowed to introduce breaking changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Caret constraints are similar to *tilde constraints* (see [“Version Specifiers”](ch04.html#section_dependencies_version_specifiers)),
    but the latter only allow the last version segment to increase. For example, the
    following constraints are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, tilde constraints typically exclude minor releases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Caret constraints put an upper bound on the version. As explained in [“Upper
    Version Bounds in Python”](ch04.html#sidebar_dependencies_upper_version_bounds),
    you should avoid upper bounds if you can. Add Rich with only a lower bound instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can use this command to remove upper bounds from existing caret constraints,
    as well.^([2](ch05.html#id285)) If you specified extras or markers when you first
    added the dependency, you’ll need to specify them again.
  prefs: []
  type: TYPE_NORMAL
- en: Extras and Environment Markers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s add the other dependency of `random-wikipedia-article`, the HTTP client
    library `httpx`. Like in [Chapter 4](ch04.html#chapter_dependencies), you’ll activate
    the `http2` extra for HTTP/2 support.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Poetry updates the *pyproject.toml* file accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The project requires a recent Python version, so it doesn’t require the `importlib-metadata`
    backport. If you had to support Python versions before 3.8, here’s how you’d add
    the library for those versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides `--python`, the `poetry add` command supports a `--platform` option
    to restrict dependencies to a specific operating system, such as Windows. This
    option accepts a platform identifier in the format used by the standard `sys.platform`
    attribute: `linux`, `darwin`, `win32`. For other environment markers, edit *pyproject.toml*
    and use the `markers` property in the TOML table for the dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The Lock File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Poetry records the current version of each dependency in a file named *poetry.lock*,
    including SHA256 hashes for its packaging artifacts. If you take a peek inside
    the file, you’ll notice TOML stanzas for `rich` and `httpx`, as well as their
    direct and indirect dependencies. [Example 5-6](#example_poetry_lockfile_rich)
    shows a simplified version of Rich’s lock entry.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-6\. The TOML stanza for Rich in *poetry.lock* (simplified)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the command `poetry show` to display the locked dependencies in the terminal.
    Here’s what the output looked like after I added Rich:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also display the dependencies as a tree to visualize their relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you edit *pyproject.toml* yourself, remember to update the lock file to
    reflect your changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Without the `--no-update` option, Poetry upgrades each locked dependency to
    the latest version covered by its constraint.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check if the *poetry.lock* file is consistent with *pyproject.toml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Resolving dependencies up front lets you deploy applications in a reliable and
    reproducible manner. It also gives developers in a team a common baseline and
    makes checks more deterministic—​avoiding surprises in continuous integration
    (CI). You should commit *poetry.lock* to source control to reap these benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Poetry’s lock file is designed to work across operating systems and Python interpreters.
    Having a single environment-independent, or “universal”, lock file is beneficial
    if your code must run in diverse environments, or if you’re an open source maintainer
    with contributors from all over the world.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, compiled requirements files quickly become unwieldy. If your project
    supports Windows, macOS, and Linux on the four most recent feature versions of
    Python, you’ll need to manage a dozen requirements files. Adding another processor
    architecture or Python implementation only makes things worse.
  prefs: []
  type: TYPE_NORMAL
- en: 'Universal lock files come at a price, however. Poetry re-resolves dependencies
    when it installs the packages into an environment. Its lock file is essentially
    a shrunken world view: it records every package the project might require in a
    given environment. By contrast, compiled requirements are an exact image of an
    environment. This makes them more amenable to auditing and more attractive for
    secure deployments.'
  prefs: []
  type: TYPE_NORMAL
- en: Updating Dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can update all dependencies in the lock file to their latest versions using
    a single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also provide a specific direct or indirect dependency to update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `poetry update` command doesn’t modify the project metadata in *pyproject.toml*.
    It only updates dependencies within the compatible version range. If you need
    to update the version range, use `poetry add` with the new constraint, including
    any extras and markers. Alternatively, edit *pyproject.toml* and refresh the lock
    file with `poetry lock --no-update`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you no longer need a package for your project, remove it with `poetry remove`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Managing Environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Poetry’s `add`, `update`, and `remove` commands don’t just update dependencies
    in the *pyproject.toml* and *poetry.lock* files. They also synchronize the project
    environment with the lock file by installing, updating, or removing packages.
    Poetry creates the virtual environment for the project on demand.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Poetry stores the environments for all projects in a shared folder.
    Configure Poetry to keep the environment in a *.venv* directory inside the project
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This setting makes the environment discoverable for other tools in the ecosystem,
    such as `py` and `uv`. Having the directory in the project is convenient when
    you need to examine its contents. Although the setting restricts you to a single
    environment, this limitation is seldom a concern. Tools like Nox and tox are tailor-made
    for testing across multiple environments (see [Chapter 8](ch08.html#chapter_nox)).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check the location of the current environment using the command `poetry
    env info --path`. If you want to create a clean slate for your project, use the
    following commands to remove existing environments and create a new one using
    the specified Python version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You can re-run the second command to re-create the environment on a different
    interpreter. Instead of a version like `3.12`, you can also pass a command like
    `pypy3` for the PyPy interpreter or a full path like `/usr/bin/python3` for the
    system Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you use the environment, you should install the project. Poetry performs
    editable installs, so the environment reflects any code changes immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the project environment by launching a shell session with `poetry shell`.
    Poetry activates the virtual environment using the activation script for your
    current shell. With the environment activated, you can run the application from
    the shell prompt. Just exit the shell session when you’re done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also run the application in your current shell session, using the command
    `poetry run`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The command is also handy for starting an interactive Python session in the
    project environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When you run a program with `poetry run`, Poetry activates the virtual environment
    without launching a shell. This works by adding the environment to the program’s
    `PATH` and `VIRTUAL_ENV` variables (see [“Activation scripts”](ch02.html#section_environments_activation)).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Just type `py` to get a Python session for your Poetry project on Linux and
    macOS. This requires the Python Launcher for Unix, and you must configure Poetry
    to use in-project environments.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Poetry allows you to declare development dependencies, organized in dependency
    groups. Dependency groups aren’t part of the project metadata and are invisible
    to end users. Let’s add the dependency groups from [“Development Dependencies”](ch04.html#section_dependencies_development):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Poetry adds the dependency groups under the `group` table in *pyproject.toml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Dependency groups are installed into the project environment by default. You
    can mark a group as optional using its `optional` key, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Don’t specify the `--optional` flag when you add a dependency group with `poetry
    add`—it doesn’t mark the group as optional. The option designates optional dependencies
    that are behind an extra; it has no valid use in the context of dependency groups.
  prefs: []
  type: TYPE_NORMAL
- en: The `poetry install` command has several options that provide finer-grained
    control over which dependencies are installed into the project environment ([Table 5-3](#table_poetry_install_options)).
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-3\. Installing dependencies with `poetry install`
  prefs: []
  type: TYPE_NORMAL
- en: '| Option | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `--with=*<group>*` | Include a dependency group in the installation. |'
  prefs: []
  type: TYPE_TB
- en: '| `--without=*<group>*` | Exclude a dependency group from the installation.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `--only=*<group>*` | Exclude all other dependency groups from the installation.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `--no-root` | Exclude the project itself from the installation. |'
  prefs: []
  type: TYPE_TB
- en: '| `--only-root` | Exclude all dependencies from the installation. |'
  prefs: []
  type: TYPE_TB
- en: '| `--sync` | Remove packages from the environment unless scheduled for installation.
    |'
  prefs: []
  type: TYPE_TB
- en: You can specify a single group or multiple groups (separated by commas). The
    special group `main` refers to packages listed in the `tool.poetry.dependencies`
    table. Use the option `--only=main` to exclude all development dependencies from
    an installation. Similarly, the option `--without=main` lets you restrict an installation
    to development dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Package Repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Poetry lets you upload your packages to the Python Package Index (PyPI) and
    other package repositories. It also lets you configure the repositories from which
    you add packages to your project. This section looks at both the publisher and
    the consumer sides of interacting with package repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you’re following along in this section, please don’t upload the example project
    to PyPI. Use the TestPyPI repository instead—​it’s a playground for testing, learning,
    and experimentation.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing Packages to Package Repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you can upload packages to PyPI, you need an account and an API token
    to authenticate with the repository, as explained in [“Uploading Packages with
    Twine”](ch03.html#section_packages_twine). Next, add the API token to Poetry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create packages for a Poetry project using standard tooling like `build`
    or with Poetry’s command-line interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Like `build`, Poetry places the packages in the *dist* directory. You can publish
    the packages in *dist* using `poetry publish`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also collapse the two commands into one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s upload the example project to TestPyPI, a separate instance of the Python
    Package Index for testing distributions. If you want to upload packages to a repository
    other than PyPI, you need to add the repository to your Poetry configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'First, create an account and an API token on TestPyPI. Next, configure Poetry
    to use that token when uploading to TestPyPI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now specify the repository when publishing your project. Feel free
    to try this out with your own version of the example project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Some package repositories use HTTP basic authentication with a username and
    password. You can configure the credentials for such a repository like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The command prompts you for the password and stores it in the system keyring,
    if available, or in the *auth.toml* file on disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can also configure a repository via environment variables
    (replace `*<REPO>*` with the repository name in uppercase, such as `PYPI`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Poetry also supports repositories that are secured by mutual TLS or use a custom
    certificate authority; see the [official documentation](https://python-poetry.org/docs/repositories/)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching Packages from Package Sources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Above, you’ve seen how to upload your package to repositories other than PyPI.
    Poetry also supports alternate repositories on the consumer side: you can add
    packages to your project from sources other than PyPI. While upload targets are
    a user setting and stored in the Poetry configuration, package sources are a project
    setting, stored in *pyproject.toml*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a package source using the command `poetry source add`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Poetry searches supplemental sources if the package wasn’t found on PyPI. If
    you want to disable PyPI, configure a primary source instead (the default priority):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You configure credentials for package sources just like you do for repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now add packages from the alternate source:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command lists the package sources for the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Specify the source when adding packages from supplemental sources. Otherwise,
    Poetry searches all sources when looking up a package. An attacker could upload
    a malicious package to PyPI with the same name as your internal package (*dependency
    confusion attack*).
  prefs: []
  type: TYPE_NORMAL
- en: Extending Poetry with Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Poetry comes with a plugin system that lets you extend its functionality. Use
    pipx to inject the plugin into Poetry’s environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Replace `*<plugin>*` with the name of the plugin on PyPI.
  prefs: []
  type: TYPE_NORMAL
- en: If the plugin affects the build stage of your project, add it to the build dependencies
    in *pyproject.toml*, as well. See [“The Dynamic Versioning Plugin”](#section_poetry_dynamic_versioning)
    for an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, pipx upgrades applications without the injected packages. Use the
    option `--include-injected` to also upgrade application plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If you no longer need the plugin, remove it from the injected packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re no longer sure which plugins you have installed, list them like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In this section, I’ll introduce you to three useful plugins for Poetry:'
  prefs: []
  type: TYPE_NORMAL
- en: '`poetry-plugin-export` allows you to generate requirements and constraints
    files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`poetry-plugin-bundle` lets you deploy the project to a virtual environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`poetry-dynamic-versioning` populates the project version from the VCS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating Requirements Files with the Export Plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Poetry’s lock file is great to ensure that everybody on your team, and every
    deployment environment, ends up with the same dependencies. But what do you do
    if you can’t use Poetry in some context? For example, you may need to deploy your
    project on a system that only has a Python interpreter and the bundled pip.
  prefs: []
  type: TYPE_NORMAL
- en: As of this writing, there’s no lock file standard in the wider Python world;
    each packaging tool that supports lock files implements its own format.^([3](ch05.html#id287))
    None of these lock file formats has support in pip. But we do have requirements
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements files let you pin packages to an exact version, require their artifacts
    to match cryptographic hashes, and use environment markers to restrict packages
    to specific Python versions and platforms. Wouldn’t it be nice if you could generate
    one from your *poetry.lock*, for interoperability with non-Poetry environments?
    This is precisely what the export plugin achieves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the plugin with pipx:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The plugin powers the `poetry export` command, which sports a `--format` option
    to specify the output format. By default, the command writes to the standard output
    stream; use the `--output` option to specify a destination file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Distribute the requirements file to the target system and use pip to install
    the dependencies (typically followed by installing a wheel of your project).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Exporting to requirements format is useful beyond deploying. Many tools work
    with requirements files as the de-facto industry standard. For example, you can
    scan a requirements file for dependencies with known security vulnerabilities
    using a tool like [safety](https://pyup.io/safety/).
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Environments with the Bundle Plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, you saw how to deploy your project on a system without
    Poetry. If you do have Poetry available, you might be wondering: can you just
    deploy with `poetry install`? You could, but Poetry performs an editable install
    of your project—​you’ll be running your application from the source tree. That
    may not be acceptable in a production environment. Editable installs also limit
    your ability to ship the virtual environment to another destination.'
  prefs: []
  type: TYPE_NORMAL
- en: The bundle plugin allows you to deploy your project and locked dependencies
    to a virtual environment of your choosing. It creates the environment, installs
    the dependencies from the lock file, then builds and installs a wheel of your
    project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the plugin with pipx:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: After installation, you’ll see a new `poetry bundle` subcommand. Let’s use that
    to bundle the project into a virtual environment in a directory named *app*. Use
    the `--python` option to specify the interpreter for the environment, and the
    option `--only=main` to exclude development dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Test the environment by running the entry-point script for the application.^([4](ch05.html#id288))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: You can use the bundle plugin to create a minimal Docker image for production.
    Docker supports *multi-stage builds*, where the first stage builds the application
    in a full-fledged build environment, and the second stage copies the build artifacts
    over into a minimal runtime environment. This allows you to ship slim images to
    production, speeding up deployments and reducing bloat and potential vulnerabilities
    in your production environments.
  prefs: []
  type: TYPE_NORMAL
- en: In [Example 5-7](#example_docker_poetry_bundle), the first stage installs Poetry
    and the bundle plugin, copies the Poetry project, and bundles it into a self-contained
    virtual environment. The second stage copies the virtual environment into a minimal
    Python image.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-7\. Multi-stage Dockerfile with Poetry
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_managing_projects_with_poetry_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The first `FROM` directive introduces the build stage, where you build and install
    your project. The base image is a slim variant of the Debian stable release.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_managing_projects_with_poetry_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second `FROM` directive defines the image that you deploy to production.
    The base image is a *distroless* Python image for Debian stable: Python language
    support minus the operating system.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_managing_projects_with_poetry_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `COPY` directive allows you to copy the virtual environment over from the
    build stage.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_managing_projects_with_poetry_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `ENTRYPOINT` directive lets you run the entry-point script when users invoke
    `docker run` with the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have Docker installed, you can try this out. First, create a *Dockerfile*
    in your project with the contents from [Example 5-7](#example_docker_poetry_bundle).
    Next, build and run the Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: You should see the output from `random-wikipedia-article` in your terminal.
  prefs: []
  type: TYPE_NORMAL
- en: The Dynamic Versioning Plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The dynamic versioning plugin populates the version in the project metadata
    from a Git tag. Keeping the version in a single place reduces churn (see [“Single-sourcing
    the project version”](ch03.html#section_packages_single_sourcing_the_version)).
    The plugin is based on Dunamai, a Python library for deriving standards-compliant
    version strings from tags in your version control system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the plugin with pipx and enable it for your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The second step enables the plugin in the `tool` section of *pyproject.toml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Remember that you have installed the Poetry plugin globally. The explicit opt-in
    ensures that you don’t accidentally start overwriting the version field in unrelated
    Poetry projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build frontends like pip and `build` need the plugin when they build your project.
    For this reason, enabling the plugin also adds it to the build dependencies in
    *pyproject.toml*. The plugin brings its own build backend, which wraps the one
    provided by Poetry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Poetry still requires the `version` field in its own section. Set the field
    to `"0.0.0"` to indicate that it’s unused.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now add a Git tag to set your project version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The plugin also replaces `__version__` attributes in Python modules. This mostly
    works out of the box, but you need to declare *src* layout if you use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s add a `--version` option to the application. Edit *__init__.py* in the
    package to add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Before proceeding, commit your changes, but without adding another Git tag.
    Let’s try the option in a fresh installation of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the plugin rewrote the `__version__` attribute during the build.
    Since you didn’t tag the commit, Dunamai marked the version as a developmental
    post-release of `1.0.0` and appended the commit hash using a local version identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Poetry provides a unified workflow to manage packaging, dependencies and environments.
    Poetry projects are interoperable with standard tooling: you can build them with
    `build` and upload them to PyPI with Twine. But the Poetry command-line interface
    also provides convenient shorthands for these tasks and many more.'
  prefs: []
  type: TYPE_NORMAL
- en: Poetry records the precise working set of packages in its lock file, giving
    you deterministic deployments and checks, as well as a consistent experience when
    collaborating with others. Poetry can track development dependencies; it organizes
    them in dependency groups that you can install separately or together. You can
    extend Poetry with plugins—​for example, to deploy the project into a virtual
    environment or to derive the version number from Git.
  prefs: []
  type: TYPE_NORMAL
- en: If you need reproducible deployments for an application, if your team develops
    on multiple operating systems, or if you just feel that standard tooling adds
    too much overhead to your workflows, you should give Poetry a try.
  prefs: []
  type: TYPE_NORMAL
- en: '^([1](ch05.html#id284-marker)) Sébastien Eustace: [“Support for PEP 621,”](https://github.com/python-poetry/roadmap/issues/3)
    November 6, 2020.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch05.html#id285-marker)) The command also keeps your lock file and project
    environment up-to-date. If you edit the constraint in *pyproject.toml*, you’ll
    need to do this yourself. Read on to learn more about lock files and environments.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch05.html#id287-marker)) Apart from Poetry’s own *poetry.lock* and the
    closely related PDM lock file format, there’s pipenv’s *Pipfile.lock* and the
    `conda-lock` format for Conda environments.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch05.html#id288-marker)) Replace *bin* with *Scripts* if you’re on Windows.
  prefs: []
  type: TYPE_NORMAL
