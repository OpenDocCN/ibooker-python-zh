- en: Chapter 7\. Modules and Packages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 模块和包
- en: A typical Python program is made up of several source files. Each source file
    is a *module*, grouping code and data for reuse. Modules are normally independent
    of each other, so that other programs can reuse the specific modules they need.
    Sometimes, to manage complexity, developers group together related modules into
    a *package*—a hierarchical, tree-like structure of related modules and subpackages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的Python程序由多个源文件组成。每个源文件都是一个*模块*，用于重复使用代码和数据。模块通常彼此独立，以便其他程序可以重复使用它们需要的特定模块。有时，为了管理复杂性，开发人员将相关模块组合成一个*包*——这是一个相关模块和子包的层次化树状结构。
- en: A module explicitly establishes dependencies upon other modules by using **import**
    or **from** statements. In some programming languages, global variables provide
    a hidden conduit for coupling between modules. In Python, global variables are
    not global to all modules, but rather are attributes of a single module object.
    Thus, Python modules always communicate in explicit and maintainable ways, clarifying
    the couplings between them by making them explicit.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块通过使用**import**或**from**语句显式地建立对其他模块的依赖关系。在某些编程语言中，全局变量提供了模块之间的隐藏通道。在Python中，全局变量不是所有模块的全局变量，而是单个模块对象的属性。因此，Python模块始终以显式和可维护的方式通信，通过显式地澄清它们之间的耦合关系。
- en: Python also supports *extension modules*—modules coded in other languages such
    as C, C++, Java, C#, or Rust. For the Python code importing a module, it does
    not matter whether the module is pure Python or an extension. You can always start
    by coding a module in Python. Should you need more speed later, you can refactor
    and recode some parts of your module in lower-level languages, without changing
    the client code that uses the module. [Chapter 25](ch25.xhtml#extending_and_embedding_classic_python)
    (available [online](https://oreil.ly/python-nutshell-25)) shows how to write extensions
    in C and Cython.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python还支持*扩展模块*——用其他语言如C、C++、Java、C#或Rust编写的模块。对于导入模块的Python代码来说，无论模块是纯Python还是扩展模块，都无关紧要。你始终可以先用Python编写一个模块。如果以后需要更快的速度，可以重构和重写模块的某些部分为更低级别的语言，而不需要改变使用该模块的客户端代码。[第25章](ch25.xhtml#extending_and_embedding_classic_python)（在线版本[链接](https://oreil.ly/python-nutshell-25)）展示了如何用C和Cython编写扩展。
- en: This chapter discusses module creation and loading. It also covers grouping
    modules into packages, using [setuptools](https://oreil.ly/c4JWE) to install packages,
    and how to prepare packages for distribution; this latter subject is more thoroughly
    covered in [Chapter 24](ch24.xhtml#packaging_programs_and_extensions) (also available
    [online](https://oreil.ly/python-nutshell-24)). We close this chapter with a discussion
    of how best to manage your Python environment(s) .
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了模块的创建和加载。还涵盖了如何将模块分组成包、使用[setuptools](https://oreil.ly/c4JWE)来安装包以及如何准备包用于分发；后者更详细地在[第24章](ch24.xhtml#packaging_programs_and_extensions)（在线版本[链接](https://oreil.ly/python-nutshell-24)）中介绍。我们在本章结尾讨论了如何最好地管理你的Python环境。
- en: Module Objects
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块对象
- en: In Python, a module is an object with arbitrarily named attributes that you
    can bind and reference. Modules in Python are handled like other objects. Thus,
    you can pass a module as an argument in a call to a function. Similarly, a function
    can return a module as the result of a call. A module, just like any other object,
    can be bound to a variable, an item in a container, or an attribute of an object.
    Modules can be keys or values in a dictionary, and can be members of a set. For
    example, the sys.modules dictionary, discussed in [“Module Loading”](#module_loading),
    holds module objects as its values. The fact that modules can be treated like
    other values in Python is often expressed by saying that modules are *first-class*
    objects.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，模块是一个具有任意命名属性的对象，你可以绑定和引用这些属性。Python中的模块与其他对象一样处理。因此，你可以将一个模块作为参数传递给函数调用。类似地，函数可以返回一个模块作为调用的结果。一个模块，就像任何其他对象一样，可以绑定到一个变量、容器中的一个项目或对象的属性。模块可以是字典中的键或值，并且可以是集合的成员。例如，sys.modules字典讨论在[“模块加载”](#module_loading)中，保存模块对象作为其值。Python中模块能像其他值一样对待的事实，经常被表达为模块是*一等*对象。
- en: The import Statement
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入语句
- en: 'The Python code for a module named *aname* usually lives in a file named *aname.py*,
    as covered in [“Searching the Filesystem for a Module”](#searching_the_filesystem_for_a_module).
    You can use any Python source file^([1](ch07.xhtml#ch01fn81)) as a module by executing
    an **import** statement in another Python source file. **import** has the following
    syntax:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 名为*aname*的模块的Python代码通常存储在名为*aname.py*的文件中，如[“在文件系统中搜索模块”](#searching_the_filesystem_for_a_module)中所述。您可以通过在另一个Python源文件中执行**import**语句来使用任何Python源文件^([1](ch07.xhtml#ch01fn81))作为模块。**import**具有以下语法：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After the **import** keyword come one or more module specifiers separated by
    commas. In the simplest, most common case, a module specifier is just *modname*,
    an identifier—a variable that Python binds to the module object when the **import**
    statement finishes. In this case, Python looks for the module of the same name
    to satisfy the **import** request. For example, this statement:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**import**关键字后面跟着一个或多个由逗号分隔的模块说明符。在最简单、最常见的情况下，模块说明符只是*modname*，一个标识符—Python在**import**语句完成时将其绑定到模块对象的变量。在这种情况下，Python会寻找相同名称的模块以满足**import**请求。例如，这个语句：'
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: looks for the module named mymodule and binds the variable named mymodule in
    the current scope to the module object. *modname* can also be a sequence of identifiers
    separated by dots (.) to name a module contained in a package, as covered in [“Packages”](#packages).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找名为mymodule的模块，并将当前作用域中的变量名mymodule绑定到模块对象。 *modname*也可以是由点（.）分隔的标识符序列，用于命名包中包含的模块，如[“包”](#packages)中所述。
- en: 'When **as** *varname* is part of a module specifier, Python looks for a module
    named *modname* and binds the module object to the variable *varname*. For example,
    this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当**as** *varname*是模块说明符的一部分时，Python会寻找名为*modname*的模块，并将模块对象绑定到变量*varname*。例如，这样：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: looks for the module named mymodule and binds the module object to the variable
    *alias* in the current scope. *varname* must always be a simple identifier.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找名为mymodule的模块，并将模块对象绑定到当前作用域中的变量*alias*。 *varname*必须始终是一个简单的标识符。
- en: The module body
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块体
- en: The *body* of a module is the sequence of statements in the module’s source
    file. There is no special syntax required to indicate that a source file is a
    module; as mentioned previously, you can use any valid Python source file as a
    module. A module’s body executes immediately the first time a given run of a program
    imports it. When the body starts executing, the module object has already been
    created, with an entry in sys.modules already bound to the module object. The
    module’s (global) namespace is gradually populated as the module’s body executes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的*body*是模块源文件中的语句序列。没有特殊的语法用于指示源文件是一个模块；如前所述，您可以使用任何有效的Python源文件作为模块。模块的body在程序的给定运行第一次导入它时立即执行。当body开始执行时，模块对象已经被创建，已经在sys.modules中绑定到模块对象。模块的（全局）命名空间随着模块的body执行而逐渐填充。
- en: Attributes of module objects
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块对象的属性
- en: 'An **import** statement creates a new namespace containing all the attributes
    of the module. To access an attribute in this namespace, use the name or alias
    of the module as a prefix:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**import**语句创建一个新的命名空间，其中包含模块的所有属性。要访问此命名空间中的属性，请使用模块的名称或别名作为前缀：'
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'or:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This reduces the time it takes to import the module and ensures that only those
    applications that use that module incur the overhead of creating it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以减少导入模块所需的时间，并确保只有使用该模块的应用程序才会承担创建模块的开销。
- en: Normally, it is the statements in the module body that bind the attributes of
    a module object. When a statement in the module body binds a (global) variable,
    what gets bound is an attribute of the module object.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，是模块体中的语句绑定模块对象的属性。当模块体中的语句绑定（全局）变量时，绑定的是模块对象的属性。
- en: A Module Body Exists to Bind the Module’s Attributes
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块体存在以绑定模块的属性
- en: 'The normal purpose of a module body is to create the module’s attributes: **def**
    statements create and bind functions, **class** statements create and bind classes,
    and assignment statements can bind attributes of any type. For clarity and cleanliness
    in your code, be wary about doing anything else in the top logical level of the
    module’s body *except* binding the module’s attributes.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 模块体的正常目的是创建模块的属性：**def**语句创建和绑定函数，**class**语句创建和绑定类，赋值语句可以绑定任何类型的属性。为了使代码清晰易懂，请注意在模块体的顶层逻辑级别之外不要做任何其他事情，*除了*绑定模块的属性。
- en: 'A __getattr__ function defined at module scope can dynamically create new module
    attributes. One possible reason for doing so would be to lazily define attributes
    that are time-consuming to create; defining them in a module-level __getattr__
    function defers the creation of the attributes until they are actually referenced,
    if ever. For instance, this code could be added to *mymodule.py* to defer the
    creation of a list containing the first million prime numbers, which can take
    some time to compute:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块范围定义的__getattr__函数可以动态创建新的模块属性。这样做的一个可能原因是延迟定义创建时间较长的属性；在模块级别的__getattr__函数中定义它们将推迟属性的创建，直到它们实际被引用为止。例如，可以将以下代码添加到*mymodule.py*中，以推迟创建包含前一百万个质数的列表，这需要一些时间来计算：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using a module-level __getattr__ function has only a small impact on the time
    to import *mymodule.py*, and only those applications that actually use mymodule.first_million_primes
    will incur the overhead of creating it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块级别的__getattr__函数对导入*mymodule.py*的时间影响很小，只有那些实际使用mymodule.first_million_primes的应用程序会产生创建它的开销。
- en: You can also bind module attributes in code outside the body (i.e., in other
    modules); just assign a value to the attribute reference syntax *M.name* (where
    *M* is any expression whose value is the module, and the identifier *name* is
    the attribute name). For clarity, however, it’s best to bind module attributes
    only in the module’s own body.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在代码主体外绑定模块属性（即在其他模块中）；只需将值分配给属性引用语法*M.name*（其中*M*是任何表达式，其值为模块，*name*是属性名称）。然而，为了清晰起见，最好只在模块自身的主体中绑定模块属性。
- en: The **import** statement binds some module attributes as soon as it creates
    the module object, before the module’s body executes. The __dict__ attribute is
    the dict object that the module uses as the namespace for its attributes. Unlike
    other attributes of the module, __dict__ is not available to code in the module
    as a global variable. All other attributes in the module are items in __dict__
    and are available to code in the module as global variables. The __name__ attribute
    is the module’s name, and __file__ is the filename from which the module was loaded;
    other dunder-named attributes hold other module metadata. (See also [“Special
    Attributes of Package Objects”](#special_attributes_of_package_objects) for details
    on the attribute __path__, in packages only.)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**import**语句在创建模块对象后立即绑定一些模块属性，而不是在模块主体执行之前。__dict__属性是模块用作其属性命名空间的字典对象。与模块的其他属性不同，__dict__在模块中不作为全局变量提供给代码使用。模块中的所有其他属性都是__dict__中的项，并且可以作为全局变量供模块中的代码使用。__name__属性是模块的名称，__file__是加载模块的文件名；其他dunder名称属性包含其他模块元数据。（另请参阅[“Package
    Objects的特殊属性”](#special_attributes_of_package_objects)了解属性__path__的详细信息，仅适用于包）。'
- en: For any module object *M*, any object *x*, and any identifier string *S* (except
    __dict__), binding *M.S = x* is equivalent to binding *M*.__dict__['*S*'] = *x*.
    An attribute reference such as *M.S* is also substantially equivalent to *M.__dict__*['*S*'].
    The only difference is that, when *S* is not a key in *M*.__dict__, accessing
    *M*.__dict__['*S*'] raises KeyError, while accessing *M.S* raises AttributeError.
    Module attributes are also available to all code in the module’s body as global
    variables. In other words, within the module body, *S* used as a global variable
    is equivalent to *M.S* (i.e., *M*.__dict__['*S*']) for both binding and reference
    (when *S* is *not* a key in *M*.__dict__, however, referring to *S* as a global
    variable raises NameError).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何模块对象*M*，任何对象*x*，以及任何标识符字符串*S*（除了__dict__），绑定*M.S = x*等同于绑定*M*.__dict__['*S*']
    = *x*。像*M.S*这样的属性引用也基本等同于*M*.__dict__['*S*']。唯一的区别在于，当*S*不是*M*.__dict__的键时，访问*M*.__dict__['*S*']会引发KeyError，而访问*M.S*会引发AttributeError。模块属性也可在模块主体中的所有代码中作为全局变量使用。换句话说，在模块主体中，作为全局变量使用的*S*等同于*M.S*（即*M*.__dict__['*S*']），无论是绑定还是引用（然而，当*S*不是*M*.__dict__的键时，将*S*作为全局变量引用会引发NameError）。
- en: Python built-ins
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python内置函数
- en: Python supplies many built-in objects (covered in [Chapter 8](ch08.xhtml#core_built_ins_and_standard_library_mod)).
    All built-in objects are attributes of a preloaded module named builtins. When
    Python loads a module, the module automatically gets an extra attribute named
    __builtins__, which refers either to the module builtins or to its dictionary.
    Python may choose either, so don’t rely on __builtins__. If you need to access
    the module builtins directly (a rare need), use an **import** builtins statement.
    When you access a variable found neither in the local namespace nor in the global
    namespace of the current module, Python looks for the identifier in the current
    module’s __builtins__ before raising NameError.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了许多内置对象（在 [第 8 章](ch08.xhtml#core_built_ins_and_standard_library_mod)
    中介绍）。所有内置对象都是预加载模块 builtins 的属性。当 Python 加载一个模块时，该模块会自动获得一个额外的属性 __builtins__，它指向模块
    builtins 或其字典。Python 可能选择其中之一，因此不要依赖于 __builtins__。如果需要直接访问模块 builtins（这种情况很少见），请使用
    **import** builtins 语句。当您访问当前模块的本地命名空间和全局命名空间中都找不到的变量时，Python 会在当前模块的 __builtins__
    中查找该标识符，然后引发 NameError。
- en: 'The lookup is the only mechanism that Python uses to let your code access built-ins.
    Your own code can use the access mechanism directly (do so in moderation, however,
    or your program’s clarity and simplicity will suffer). The built-ins’ names are
    not reserved, nor are they hardwired in Python itself—you can add your own built-ins
    or substitute your functions for the normal built-in ones, in which case all modules
    see the added or replaced ones. Since Python accesses built-ins only when it cannot
    resolve a name in the local or module namespace, it is usually sufficient to define
    a replacement in one of those namespaces. The following toy example shows how
    you can wrap a built-in function with your own function, allowing abs to take
    a string argument (and return a rather arbitrary mangling of the string):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 查找是 Python 唯一用来让您的代码访问内置的机制。您自己的代码可以直接使用访问机制（但请适度使用，否则会影响程序的清晰度和简洁性）。内置的名称不是保留的，也不是硬编码在
    Python 本身中的——您可以添加自己的内置或替换正常的内置函数，在这种情况下，所有模块都会看到添加或替换的内置函数。由于 Python 仅在无法解析本地或模块命名空间中的名称时才访问内置，因此通常在其中一个命名空间中定义替代项就足够了。以下简单示例展示了如何使用您自己的函数包装内置函数，使
    abs 函数接受一个字符串参数（并返回一个相当任意的字符串变形）：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Module documentation strings
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块文档字符串
- en: If the first statement in the module body is a string literal, Python binds
    that string as the module’s documentation string attribute, named __doc__. For
    more information on documentation strings, see [“Docstrings”](ch03.xhtml#docstrings).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模块体中的第一条语句是一个字符串文字，Python 将该字符串绑定为模块的文档字符串属性，命名为 __doc__。有关文档字符串的更多信息，请参见
    [“文档字符串”](ch03.xhtml#docstrings)。
- en: Module-private variables
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块私有变量
- en: No variable of a module is truly private. However, by convention, every identifier
    starting with a single underscore (_), such as _secret, is *meant* to be private.
    In other words, the leading underscore communicates to client-code programmers
    that they should not access the identifier directly.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 模块中没有真正私有的变量。然而，按照约定，每个以单个下划线（_）开头的标识符，例如 _secret，*意味着*是私有的。换句话说，前导下划线告诉客户端代码的程序员不应直接访问该标识符。
- en: Development environments and other tools rely on the leading underscore naming
    convention to discern which attributes of a module are public (i.e., part of the
    module’s interface) and which are private (i.e., to be used only within the module).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 开发环境和其他工具依赖于以下划线开头的命名惯例来区分模块中哪些属性是公共的（即模块的接口的一部分），哪些是私有的（即仅在模块内部使用）。
- en: Respect the “Leading Underscore Means Private” Convention
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遵守“前导下划线表示私有”惯例
- en: 'It’s important to respect the convention that a leading underscore means private,
    particularly when you write client code that uses modules written by others. Avoid
    using any attributes in such modules whose names start with _. Future releases
    of the modules will strive to maintain their public interface, but are quite likely
    to change private implementation details: private attributes are meant exactly
    for such details.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写使用他人编写的模块的客户端代码时，尊重前导下划线表示私有的约定非常重要。避免在这些模块中使用任何以 _ 开头的属性。未来版本的模块将致力于保持其公共接口，但很可能会更改私有实现细节：私有属性正是为此类细节而设的。
- en: The from Statement
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**from** 语句'
- en: 'Python’s **from** statement lets you import specific attributes from a module
    into the current namespace. **from** has two syntax variants:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 **from** 语句允许您将模块中的特定属性导入到当前命名空间中。 **from** 有两种语法变体：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A **from** statement specifies a module name, followed by one or more attribute
    specifiers separated by commas. In the simplest and most common case, an attribute
    specifier is just an identifier *attrname*, which is a variable that Python binds
    to the attribute of the same name in the module named *modname*. For example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 **from** 语句指定一个模块名，后跟一个或多个用逗号分隔的属性说明符。在最简单和最常见的情况下，属性说明符只是一个标识符 *attrname*，它是
    Python 绑定到模块 *modname* 中同名属性的变量。例如：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*modname* can also be a sequence of identifiers separated by dots (.) to name
    a module within a package, as covered in [“Packages”](#packages).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*modname* 也可以是由点（.）分隔的标识符序列，用于指定包内的模块，如[“包”](#packages)中所述。'
- en: 'When **as** *varname* is part of an attribute specifier, Python gets the value
    of the attribute *attrname* from the module and binds it to the variable *varname*.
    For example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当 **as** *varname* 是属性说明符的一部分时，Python 从模块获取属性 *attrname* 的值，并将其绑定到变量 *varname*。例如：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*attrname* and *varname* are always simple identifiers.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*attrname* 和 *varname* 始终是简单标识符。'
- en: 'You may optionally enclose in parentheses all the attribute specifiers that
    follow the keyword **import** in a **from** statement. This can be useful when
    you have many attribute specifiers, in order to split the single logical line
    of the **from** statement into multiple logical lines more elegantly than by using
    backslashes (\):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择在 **from** 语句中关键字 **import** 后面的所有属性说明符周围加上括号。当您有许多属性说明符时，这样做可以更优雅地将 **from**
    语句的单个逻辑行分成多个逻辑行，而不是使用反斜杠 (\)：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: from...import *
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: from...import *
- en: 'Code that is directly inside a module body (not in the body of a function or
    class) may use an asterisk (*) in a **from** statement:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 直接位于模块体（而不是函数或类体）中的代码可以在 **from** 语句中使用星号 (*)：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The * requests that “all” attributes of module *modname* be bound as global
    variables in the importing module. When module *modname* has an attribute named
    __all__, the attribute’s value is the list of the attribute names that this type
    of **from** statement binds. Otherwise, this type of **from** statement binds
    all attributes of *modname* except those beginning with underscores.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '* 请求将模块 *modname* 的“所有”属性作为全局变量绑定到导入模块中。当模块 *modname* 具有名为 __all__ 的属性时，该属性的值是此类
    **from** 语句绑定的属性名称列表。否则，此类 **from** 语句会绑定 *modname* 的所有属性，但排除以下划线开头的属性。'
- en: Beware Using “from M import *” in Your Code
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谨慎使用“from M import *”在您的代码中
- en: Since **from** *M* **import** * may bind an arbitrary set of global variables,
    it can have unforeseen, undesired side effects, such as hiding built-ins and rebinding
    variables you still need. Use the * form of **from** very sparingly, if at all,
    and only to import modules that are explicitly documented as supporting such usage.
    Your code is most likely better off *never* using this form, which is meant mostly
    as a convenience for occasional use in interactive Python sessions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 **from** *M* **import** * 可以绑定任意一组全局变量，它可能会产生意想不到的、不希望的副作用，比如隐藏内建变量并重新绑定你仍然需要的变量。几乎不要或者根本不要使用
    **from** 的 * 形式，并且仅在明确文档支持这种用法的模块中使用。你的代码最好完全避免使用这种形式，这种形式主要是为了便于在交互式 Python 会话中偶尔使用。
- en: from versus import
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: from 与 import
- en: The **import** statement is often a better choice than the **from** statement.
    When you always access module *M* with the statement **import** *M*, and always
    access *M*’s attributes with the explicit syntax *M.A*, your code is slightly
    less concise but far clearer and more readable. One good use of **from** is to
    import specific modules from a package, as we discuss in [“Packages”](#packages).
    In most other cases, **import** is better style than **from**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**import** 语句通常比 **from** 语句更好。当你总是使用 **import** *M* 来访问模块 *M*，并且总是使用显式语法 *M.A*
    来访问 *M* 的属性时，你的代码可能会略显冗长，但更加清晰和可读。**from** 的一个好用法是从包中导入特定的模块，正如我们在[“包”](#packages)中所讨论的。在大多数其他情况下，**import**
    比 **from** 更好。'
- en: Handling import failures
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理导入失败
- en: 'If you are importing a module that is not part of standard Python and wish
    to handle import failures, you can do so by catching the ImportError exception.
    For instance, if your code does optional output formatting using the third-party
    rich module, but falls back to regular output if that module has not been installed,
    you would import the module using:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在导入不属于标准Python的模块，并希望处理导入失败，可以通过捕获ImportError异常来实现。例如，如果您的代码使用第三方的rich模块进行可选的输出格式化，但如果该模块未安装，则回退到常规输出，您可以这样导入模块：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, in the output portion of your program, you would write:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在程序的输出部分，您可以写：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Module Loading
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块加载
- en: Module-loading operations rely on attributes of the built-in sys module (covered
    in [“The sys Module”](ch08.xhtml#the_sys_module)) and are implemented in the built-in
    function __import__. Your code could call __import__ directly, but this is strongly
    discouraged in modern Python; rather, **import** importlib and call importlib.import_module
    with the module name string as the argument. import_module returns the module
    object or, should the import fail, raises ImportError. However, it’s best to have
    a clear understanding of the semantics of __import__, because import_module and
    **import** statements both depend on it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 模块加载操作依赖于内置 sys 模块的属性（在 [“The sys Module”](ch08.xhtml#the_sys_module) 中有介绍），并且是通过内置函数
    __import__ 实现的。您的代码可以直接调用 __import__，但这在现代Python中被强烈不推荐；相反，最好使用 **import** importlib
    并调用 importlib.import_module，其参数为模块名称字符串。import_module 返回模块对象或者，如果导入失败，则引发 ImportError。然而，最好对
    __import__ 的语义有清楚的理解，因为 import_module 和 **import** 语句都依赖于它。
- en: To import a module named *M*, __import__ first checks the dictionary sys.modules,
    using the string *M* as the key. When the key *M* is in the dictionary, __import__
    returns the corresponding value as the requested module object. Otherwise, __import__
    binds sys.modules[*M*] to a new empty module object with a __name__ of *M*, then
    looks for the right way to initialize (load) the module, as covered in the upcoming
    section on searching the filesystem for a module.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入名为 *M* 的模块，__import__ 首先检查字典 sys.modules，使用字符串 *M* 作为键。当键 *M* 在字典中时，__import__
    返回相应值作为请求的模块对象。否则，__import__ 将 sys.modules[*M*] 绑定到一个具有名称 *M* 的新空模块对象，然后查找正确的初始化（加载）模块的方法，如下一节中关于搜索文件系统的部分所述。
- en: 'Thanks to this mechanism, the relatively slow loading operation takes place
    only the first time a module is imported in a given run of the program. When a
    module is imported again, the module is not reloaded, since __import__ rapidly
    finds and returns the module’s entry in sys.modules. Thus, all imports of a given
    module after the first one are very fast: they’re just dictionary lookups. (To
    *force* a reload, see [“Reloading Modules”](#reloading_modules).)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种机制，相对较慢的加载操作仅在程序的给定运行中第一次导入模块时发生。当再次导入模块时，由于 __import__ 快速找到并返回模块在 sys.modules
    中的条目，因此模块不会重新加载。因此，在第一次导入后的所有给定模块的导入都非常快速：它们只是字典查找。（要 *强制* 重新加载，请参见 [“Reloading
    Modules”](#reloading_modules)。）
- en: Built-in Modules
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置模块
- en: When a module is loaded, __import__ first checks whether the module is a built-in.
    The tuple sys.builtin_module_names names all built-in modules, but rebinding that
    tuple does not affect module loading. When it loads a built-in module, as when
    it loads any other extension, Python calls the module’s initialization function.
    The search for built-in modules also looks for modules in platform-specific locations,
    such as the Registry in Windows.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当加载一个模块时，__import__ 首先检查该模块是否为内置模块。元组 sys.builtin_module_names 列出所有内置模块的名称，但重新绑定该元组不会影响模块加载。当加载内置模块时，就像加载任何其他扩展一样，Python
    调用模块的初始化函数。搜索内置模块还会在特定于平台的位置（例如 Windows 的注册表）中查找模块。
- en: Searching the Filesystem for a Module
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索文件系统中的模块
- en: If module *M* is not a built-in, __import__ looks for *M*’s code as a file on
    the filesystem. __import__ looks at the items of the list sys.path, which are
    strings, in order. Each item is the path of a directory, or the path of an archive
    file in the popular [ZIP format](https://oreil.ly/QrFfL). sys.path is initialized
    at program startup, using the environment variable PYTHONPATH (covered in [“Environment
    Variables”](ch02.xhtml#environment_variables)), if present. The first item in
    sys.path is always the directory from which the main program is loaded. An empty
    string in sys.path indicates the current directory.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模块*M*不是内置模块，__import__将其代码作为文件在文件系统上查找。__import__按顺序查看sys.path列表的项，这些项是字符串。每个项是目录的路径，或者是流行的[ZIP格式](https://oreil.ly/QrFfL)中的存档文件的路径。sys.path在程序启动时使用环境变量PYTHONPATH进行初始化（在[“Environment
    Variables”](ch02.xhtml#environment_variables)中有介绍），如果存在。sys.path中的第一个项始终是加载主程序的目录。sys.path中的空字符串表示当前目录。
- en: Your code can mutate or rebind sys.path, and such changes affect which directories
    and ZIP archives __import__ searches to load modules. Changing sys.path does *not*
    affect modules that are already loaded (and thus already recorded in sys.modules).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码可以更改或重新绑定sys.path，这些更改会影响__import__搜索以加载模块的目录和ZIP存档。更改sys.path不会影响已加载的模块（因此已在sys.modules中记录的模块）。
- en: 'If there is a text file with the extension *.pth* in the PYTHONHOME directory
    at startup, Python adds the file’s contents to sys.path, one item per line. *.pth*
    files can contain blank lines and comment lines starting with the character #;
    Python ignores any such lines. *.pth* files can also contain **import** statements
    (which Python executes before your program starts to execute), but no other kinds
    of statements.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在启动时PYTHONHOME目录中存在带有*.pth*扩展名的文本文件，Python将文件内容逐行添加到sys.path中。*.pth*文件可以包含空行和以字符#开头的注释行；Python会忽略这些行。*.pth*文件还可以包含**import**语句（Python在程序开始执行之前执行），但不能包含其他类型的语句。
- en: 'When looking for the file for module *M* in each directory and ZIP archive
    along sys.path, Python considers the following extensions in this order:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个目录和sys.path沿途的ZIP存档中查找模块*M*的文件时，Python按以下顺序考虑这些扩展名：
- en: '*.pyd* and *.dll* (Windows) or *.so* (most Unix-like platforms), which indicate
    Python extension modules. (Some Unix dialects use different extensions; e.g.,
    *.sl* on HP-UX.) On most platforms, extensions cannot be loaded from a ZIP archive—only
    source or bytecode-compiled Python modules can.'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*.pyd*和*.dll*（Windows）或*.so*（大多数类Unix平台），指示Python扩展模块。（某些Unix方言使用不同的扩展名；例如HP-UX上的*.sl*。）在大多数平台上，无法从ZIP存档中加载扩展—只能从源或字节码编译的Python模块中加载。'
- en: '*.py*, which indicates Python source modules.'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*.py*，指示Python源模块。'
- en: '*.pyc*, which indicates bytecode-compiled Python modules.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*.pyc*，指示字节码编译的Python模块。'
- en: When it finds a *.py* file, Python also looks for a directory called *__pycache__*.
    If it finds such a directory, Python looks in that directory for the extension
    *.<tag>.pyc*, where *<tag>* is a string specific to the version of Python that
    is looking for the module.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当发现*.py*文件时，Python还会查找名为*__pycache__*的目录。如果找到这样的目录，Python会在该目录中寻找扩展为*.<tag>.pyc*的文件，其中*<tag>*是查找模块的Python版本特定的字符串。
- en: 'One last path in which Python looks for the file for module *M* is *M**/**__init__.py*:
    a file named *__init__.py* in a directory named *M*, as covered in [“Packages”](#packages).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Python寻找模块*M*文件的最后一个路径是*M**/**__init__.py*：一个名为*M*的目录中名为*__init__.py*的文件，如[“Packages”](#packages)中所述。
- en: Upon finding the source file *M.py*, Python compiles it to *M.<tag>.pyc*, unless
    the bytecode file is already present, is newer than *M.py*, and was compiled by
    the same version of Python. If *M.py* is compiled from a writable directory, Python
    creates a *__pycache__* subdirectory if necessary and saves the bytecode file
    to the filesystem in that subdirectory so that future runs won’t needlessly recompile
    it. When the bytecode file is newer than the source file (based on an internal
    timestamp in the bytecode file, not on trusting the date as recorded in the filesystem),
    Python does not recompile the module.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 找到源文件*M.py*后，Python会将其编译成*M.<tag>.pyc*，除非字节码文件已经存在且比*M.py*新，并且是由相同版本的Python编译的。如果*M.py*是从可写目录编译的，Python会在需要时创建一个*__pycache__*子目录，并将字节码文件保存到该子目录中，以便将来的运行不会不必要地重新编译它。当字节码文件新于源文件（基于字节码文件内部的时间戳，而不是文件系统中记录的日期）时，Python不会重新编译模块。
- en: Once Python has the bytecode, whether built anew by compilation or read from
    the filesystem, Python executes the module body to initialize the module object.
    If the module is an extension, Python calls the module’s initialization function.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Python 获得了字节码，无论是通过重新编译还是从文件系统中读取，Python 都会执行模块主体来初始化模块对象。如果模块是一个扩展，Python
    将调用模块的初始化函数。
- en: Be Careful About Naming Your Project’s .py Files
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谨慎命名项目的 .py 文件
- en: A common problem for beginners occurs when programmers writing their first few
    projects accidentally name one of their *.py* files with the same name as an imported
    package, or a module in the standard library (stdlib). For example, an easy mistake
    when learning the turtle module is to name your program *turtle.py*. When Python
    then tries to import the turtle module from the stdlib, it will load the local
    module instead, and usually raise some unexpected AttributeErrors shortly thereafter
    (since the local module does not include all the classes, functions, and variables
    defined in the stdlib module). Do not name your project *.py* files the same as
    imported or stdlib modules!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对初学者来说，一个常见的问题是，在编写他们的前几个项目时，他们会意外地将一个 *.py* 文件命名为已导入包或标准库（stdlib）中的同名模块。例如，学习
    turtle 模块时很容易犯的一个错误是将程序命名为 *turtle.py*。然后当 Python 尝试从stdlib导入 turtle 模块时，它将加载本地模块而不是stdlib模块，并且通常会在此后不久引发一些意外的
    AttributeErrors（因为本地模块不包含stdlib模块中定义的所有类、函数和变量）。不要将项目的 *.py* 文件命名为已导入或stdlib模块的同名文件！
- en: You can check whether a module name already exists using a command of the form
    **python -m** ***testname***. If the message 'no module *testname*' is displayed,
    then you should be safe to name your module *testname.py*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用形如 **python -m** ***testname*** 的命令来检查模块名是否已存在。如果显示消息 'no module *testname*'，那么你可以安全地将模块命名为
    *testname.py*。
- en: In general, as you become familiar with the modules in the stdlib and common
    package names, you will come to know what names to avoid.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，当你熟悉stdlib中的模块和常见包名时，你会知道要避免使用哪些名称。
- en: The Main Program
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主程序
- en: Execution of a Python application starts with a top-level script (known as the
    *main program*), as explained in [“The python Program”](ch02.xhtml#the_python_program).
    The main program executes like any other module being loaded, except that Python
    keeps the bytecode in memory, not saving it to disk. The module name for the main
    program is '__main__', both as the __name__ variable (module attribute) and as
    the key in sys.modules.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Python 应用程序的执行始于顶级脚本（称为*主程序*），如 [“python程序”](ch02.xhtml#the_python_program)中所解释的。主程序像加载任何其他模块一样执行，只是
    Python 将字节码保存在内存中，而不是保存到磁盘上。主程序的模块名称是 '__main__'，既是 __name__ 变量（模块属性），也是 sys.modules
    中的键。
- en: Don’t Import the .py File You’re Using as the Main Program
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要将正在使用的 .py 文件作为主程序导入
- en: You should not import the same *.py* file that is the main program. If you do,
    Python loads the module again, and the body executes again in a separate module
    object with a different __name__.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 不要导入与主程序相同的 *.py* 文件。如果这样做，Python 将重新加载模块，并在一个不同的模块对象中执行主体，其 __name__ 也不同。
- en: 'Code in a Python module can test if the module is being used as the main program
    by checking if the global variable __name__ has the value ''__main__''. The idiom:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Python 模块中的代码可以通过检查全局变量 __name__ 是否具有值 '__main__' 来测试模块是否被用作主程序的方式。惯用法是：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: is often used to guard some code so that it executes only when the module runs
    as the main program. If a module is meant only to be imported, it should normally
    execute unit tests when run as the main program, as covered in [“Unit Testing
    and System Testing”](ch17.xhtml#unit_testing_and_system_testing).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 经常用来保护某些代码，以便仅在模块作为主程序运行时执行。如果一个模块仅用于导入，通常在作为主程序运行时执行单元测试，详见 [“单元测试和系统测试”](ch17.xhtml#unit_testing_and_system_testing)。
- en: Reloading Modules
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新加载模块
- en: Python loads a module only the first time you import the module during a program
    run. When you develop interactively, you need to *reload* your modules after editing
    them (some development environments provide automatic reloading).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在程序运行期间仅加载模块一次。在交互式开发中，编辑模块后需要 *重新加载* 模块（一些开发环境提供自动重新加载功能）。
- en: To reload a module, pass the module object (*not* the module name) as the only
    argument to the function reload from the importlib module. importlib.reload(*M*)
    ensures the reloaded version of *M* is used by client code that relies on import
    *M* and accesses attributes with the syntax *M.A*. However, importlib.reload(*M*)
    has no effect on other existing references bound to previous values of *M*’s attributes
    (e.g., with a **from** statement). In other words, already-bound variables remain
    bound as they were, unaffected by reload. reload’s inability to rebind such variables
    is a further incentive to use **import** rather than **from**.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要重新加载模块，请将模块对象（*而不是*模块名称）作为 importlib 模块的 reload 函数的唯一参数传递。importlib.reload(*M*)
    确保客户端代码使用重新加载的 *M* 版本，该代码依赖于 import *M* 并使用 *M.A* 语法访问属性。但是，importlib.reload(*M*)
    对绑定到 *M* 属性先前值的其他现有引用（例如，使用 **from** 语句）没有影响。换句话说，已绑定的变量保持原样，不受重新加载的影响。reload
    无法重新绑定这些变量是使用 **import** 而不是 **from** 的进一步动机。
- en: 'reload is not recursive: when you reload module *M*, this does not imply that
    other modules imported by *M* get reloaded in turn. You must reload, by explicit
    calls to reload, every module you have modified. Be sure to take into account
    any module reference dependencies, so that reloads are done in the proper order.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: reload 不是递归的：当重新加载模块 *M* 时，这并不意味着通过 *M* 导入的其他模块也会被重新加载。您必须通过显式调用 reload 来重新加载您修改过的每个模块。一定要考虑任何模块引用依赖关系，以便按正确的顺序进行重新加载。
- en: Circular Imports
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环导入
- en: Python lets you specify circular imports. For example, you can write a module
    *a.py* that contains **import** b, while module *b.py* contains **import** a.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许您指定循环导入。例如，可以编写一个包含 **import** b 的模块 *a.py*，而模块 *b.py* 包含 **import**
    a。
- en: If you decide to use a circular import for some reason, you need to understand
    how circular imports work in order to avoid errors in your code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果因某种原因决定使用循环导入，则需要了解循环导入的工作原理，以避免代码中的错误。
- en: Avoid Circular Imports
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免循环导入
- en: In practice, you are nearly always better off avoiding circular imports, since
    circular dependencies are fragile and hard to manage.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，几乎总是更好地避免循环导入，因为循环依赖是脆弱且难以管理的。
- en: Say that the main script executes **import** a. As discussed earlier, this **import**
    statement creates a new empty module object as sys.modules['a'], then the body
    of module a starts executing. When a executes **import** b, this creates a new
    empty module object as sys.modules['b'], and then the body of module b starts
    executing. a’s module body cannot proceed until b’s module body finishes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 假设主脚本执行 **import** a。如前所述，此 **import** 语句在 sys.modules['a'] 中创建一个新的空模块对象，然后模块
    a 的体开始执行。当 a 执行 **import** b 时，这将在 sys.modules['b'] 中创建一个新的空模块对象，然后模块 b 的体开始执行。直到
    b 的模块体完成，a 的模块体才能继续执行。
- en: Now, when b executes **import** a, the **import** statement finds sys.modules['a']
    already bound, and therefore binds global variable a in module b to the module
    object for module a. Since the execution of a’s module body is currently blocked,
    module a is usually only partly populated at this time. Should the code in b’s
    module body try to access some attribute of module a that is not yet bound, an
    error results.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当 b 执行 **import** a 时，**import** 语句发现 sys.modules['a'] 已经绑定，因此将模块 b 中的全局变量
    a 绑定到模块 a 的模块对象。由于当前阻塞了 a 的模块体执行，模块 a 此时通常只部分填充。如果 b 的模块体中的代码尝试访问尚未绑定的模块 a 的某个属性，将导致错误。
- en: If you keep a circular import, you must carefully manage the order in which
    each module binds its own globals, imports other modules, and accesses globals
    of other modules. You get greater control over the sequence in which things happen
    by grouping your statements into functions, and calling those functions in a controlled
    order, rather than just relying on sequential execution of top-level statements
    in module bodies. Removing circular dependencies (for example, by moving an import
    away from module scope and into a referencing function) is easier than ensuring
    bombproof ordering to deal with circular dependencies.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果保留循环导入，必须仔细管理每个模块绑定其自己全局变量的顺序，导入其他模块并访问其他模块的全局变量。通过将语句分组到函数中，并按照受控顺序调用这些函数，而不是仅仅依赖模块体顶层语句的顺序执行，可以更好地控制发生的顺序。通过移动导入远离模块范围并进入引用函数，而不是确保用于处理循环依赖的防爆顺序，更容易去除循环依赖。
- en: sys.modules Entries
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sys.modules 条目
- en: __import__ never binds anything other than a module object as a value in sys.modules.
    However, if __import__ finds an entry already in sys.modules, it returns that
    value, whatever type it may be. **import** and **from** statements rely on __import__,
    so they too can use objects that are not modules.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: __import__从不绑定除模块对象以外的任何值到sys.modules中。但是，如果__import__在sys.modules中找到一个已有的条目，则返回该值，无论它是什么类型。**import**和**from**语句依赖于__import__，因此它们也可以使用非模块对象。
- en: Custom Importers
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义导入器
- en: Another advanced, rarely needed functionality that Python offers is the ability
    to change the semantics of some or all **import** and **from** statements.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供的另一种高级且不经常需要的功能是能够更改某些或所有**import**和**from**语句的语义。
- en: Rebinding __import__
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新绑定__import__
- en: You can rebind the __import__ attribute of the builtin module to your own custom
    importer function—for example, one using the generic built-in-wrapping technique
    shown in [“Python built-ins”](#python_built_ins). Such a rebinding affects all
    **import** and **from** statements that execute after the rebinding and thus can
    have an undesired global impact. A custom importer built by rebinding __import__
    must implement the same interface and semantics as the built-in __import__, and,
    in particular, it is responsible for supporting the correct use of sys.modules.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以重新绑定内置模块的__import__属性到您自己的自定义导入器函数，例如使用在[“Python内置”](#python_built_ins)中显示的通用内置包装技术。这样的重新绑定会影响所有在重新绑定之后执行的**import**和**from**语句，因此可能会产生不希望的全局影响。通过重新绑定__import__构建的自定义导入器必须实现与内置__import__相同的接口和语义，特别是负责支持sys.modules的正确使用。
- en: Avoid Rebinding the Built-in __import__
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免重新绑定内置的__import__
- en: While rebinding __import__ may initially look like an attractive approach, in
    most cases where custom importers are necessary, you’re better off implementing
    them via *import hooks* (discussed next).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然重新绑定__import__可能最初看起来是一种有吸引力的方法，但在大多数需要自定义导入器的情况下，通过*import hooks*（接下来讨论）实现它们会更好。
- en: Import hooks
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入钩子
- en: Python offers rich support for selectively changing the details of imports’
    behavior. Custom importers are an advanced and rarely called for technique, yet
    some applications may need them for purposes such as importing code from archives
    other than ZIP files, databases, network servers, and so on.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了丰富的支持，可以选择性地更改导入行为的细节。自定义导入器是一种高级且不经常调用的技术，但某些应用可能需要它们，例如从ZIP文件以外的存档、数据库、网络服务器等导入代码。
- en: The most suitable approach for such highly advanced needs is to record *importer
    factory* callables as items in the meta_path and/or path_hooks attributes of the
    module sys, as detailed in [PEP 451](https://oreil.ly/9Wd9A). This is how Python
    hooks up the standard library module zipimport to allow seamless importing of
    modules from ZIP files, as previously mentioned. A full study of the details of
    PEP 451 is indispensable for any substantial use of sys.path_hooks and friends,
    but here’s a toy-level example to help understand the possibilities, should you
    ever need them.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种高度高级的需求，最合适的方法是将*importer factory*可调用项记录为模块sys的meta_path和/或path_hooks属性中的项目，详细信息请参见[PEP
    451](https://oreil.ly/9Wd9A)。这是Python如何连接标准库模块zipimport以允许无缝导入来自ZIP文件的模块的方式，如前所述。要实现对sys.path_hooks和相关属性的实质性使用，必须全面研究PEP
    451的详细内容，但以下是一个玩具级别的示例，可帮助理解可能的用途，如果您曾经需要的话。
- en: 'Suppose that, while developing the first outline of some program, we want to
    be able to use **import** statements for modules that we haven’t written yet,
    getting just messages (and empty modules) as a consequence. We can obtain such
    functionality (leaving aside the complexities connected with packages, and dealing
    with simple modules only) by coding a custom importer module as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在开发某个程序的首个大纲时，希望能够使用尚未编写的模块的**import**语句，只会得到消息（以及空模块）作为结果。我们可以通过编写一个自定义导入器模块来实现这样的功能（暂且不考虑与包相关的复杂性，仅处理简单模块）：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We just wrote trivial versions of create_module (which in this case just returns
    None, asking the system to create the module object in the “default way”) and
    exec_module (which receives the module object already initialized with dunder
    attributes, and whose task would normally be to populate it appropriately).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚编写了create_module的简单版本（在本例中仅返回None，请求系统以“默认方式”创建模块对象）和exec_module的简单版本（接收已初始化带有dunder属性的模块对象，其任务通常是适当地填充它）。
- en: We could, alternatively, have used the powerful new *module spec* concept, as
    detailed in PEP 451\. However, that requires the standard library module importlib;
    for this toy example, we don’t need all that extra power. Therefore, we chose
    instead to implement the method find_module, which, although now deprecated, still
    works fine for backward compatibility.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代方案，我们还可以使用强大的新模块规范概念，详见PEP 451。然而，这需要标准库模块importlib；对于这个玩具示例，我们不需要额外的功能。因此，我们选择实现find_module方法，虽然现在已经被弃用，但仍然可以用于向后兼容。
- en: Packages
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包
- en: As mentioned at the beginning of this chapter, a *package* is a module containing
    other modules. Some or all of the modules in a package may be *subpackages*, resulting
    in a hierarchical tree-like structure. A package named *P* typically resides in
    a subdirectory, also called *P*, of some directory in sys.path. Packages can also
    live in ZIP files; in this section we explain the case in which the package lives
    on the filesystem, but the case in which a package is in a ZIP file is similar,
    relying on the hierarchical filesystem-like structure within the ZIP file.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章开头所提到的，*包* 是包含其他模块的模块。包中的一些或所有模块可以是*子包*，形成一个分层的树形结构。包 *P* 通常位于sys.path中某个目录的名为
    *P* 的子目录中。包也可以存在于ZIP文件中；在本节中，我们解释了包存在于文件系统中的情况，但包存在于ZIP文件中的情况类似，依赖于ZIP文件内部的分层文件系统结构。
- en: The module body of *P* is in the file *P/__init__.py*. This file *must* exist
    (except in the case of namespace packages, described in [PEP 420](https://oreil.ly/cVzGw)),
    even if it’s empty (representing an empty module body), in order to tell Python
    that directory *P* is indeed a package. Python loads the module body of a package
    when you first import the package (or any of the package’s modules), just like
    with any other Python module. The other *.py* files in the directory *P* are the
    modules of package *P*. Subdirectories of *P* containing *__init__.py* files are
    subpackages of *P*. Nesting can proceed to any depth.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 包 *P* 的模块体在文件 *P/__init__.py* 中。此文件*必须*存在（除了在[PEP 420](https://oreil.ly/cVzGw)中描述的命名空间包的情况下），即使它是空的（代表空的模块体），以便告诉Python目录
    *P* 确实是一个包。当你首次导入包（或包的任何模块）时，Python会加载包的模块体，就像加载任何其他Python模块一样。目录 *P* 中的其他 *.py*
    文件是包 *P* 的模块。包含 *__init__.py* 文件的 *P* 的子目录是 *P* 的子包。嵌套可以无限进行。
- en: You can import a module named *M* in package *P* as *P.M**.* More dots let you
    navigate a hierarchical package structure. (A package’s module body always loads
    *before* any module in the package.) If you use the syntax **import** *P.M*, the
    variable *P* is bound to the module object of package *P*, and the attribute *M*
    of object *P* is bound to the module *P.M**.* If you use the syntax **import**
    *P.M* as *V*, the variable *V* is bound directly to the module *P.M*.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在包 *P* 中，你可以将名为 *M* 的模块导入为 *P.M**.*。更多的点号可以让你在层次化的包结构中导航。（一个包的模块体总是在任何包中的模块之前加载。）如果你使用
    **import** *P.M* 的语法，变量 *P* 将绑定到包 *P* 的模块对象，并且对象 *P* 的属性 *M* 绑定到模块 *P.M*。如果你使用
    **import** *P.M* as *V* 的语法，变量 *V* 直接绑定到模块 *P.M*。
- en: 'Using **from** *P* **import** *M* to import a specific module *M* from package
    *P* is a perfectly acceptable and indeed highly recommended practice: the **from**
    statement is specifically OK in this case. **from** *P* **import** *M* **as**
    *V* is also just fine, and exactly equivalent to **import** *P.M* **as** *V*.
    You can also use *relative* paths: that is, module *M* in package *P* can import
    its “sibling” module *X* (also in package *P*) with **from** . **import** X.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **from** *P* **import** *M* 来从包 *P* 导入特定模块 *M* 是一种完全可以接受的、而且确实是非常推荐的做法：在这种情况下，**from**
    语句是完全OK的。**from** *P* **import** *M* **as** *V* 也是可以的，与 **import** *P.M* **as**
    *V* 完全等效。你也可以使用*相对*路径：也就是说，包 *P* 中的模块 *M* 可以使用 **from** . **import** X 导入它的“兄弟”模块
    *X*（也在包 *P* 中）。
- en: Sharing Objects Among Modules in a Package
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在包中的模块之间共享对象
- en: The simplest, cleanest way to share objects (e.g., functions or constants) among
    modules in a package *P* is to group the shared objects in a module conventionally
    named *common.py*. That way, you can use **from** . **import** common in every
    module in the package that needs to access some of the common objects, and then
    refer to the objects as common.*f*, common.*K*, and so on.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在包 *P* 中，最简单、最清晰的共享对象（例如函数或常量）的方法是将共享对象分组到一个传统上命名为 *common.py* 的模块中。这样，你可以在包中的每个模块中使用
    **from** . **import** common 来访问一些共享对象，然后引用这些对象为 common.*f*、common.*K* 等。
- en: Special Attributes of Package Objects
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包对象的特殊属性
- en: A package *P*’s __file__ attribute is the string that is the path of *P*’s module
    body—that is, the path of the file *P/__init__.py*. *P*’s __package__ attribute
    is the name of *P*’s package.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 包 *P* 的 __file__ 属性是一个字符串，表示 *P* 的模块主体的路径，即文件 *P/__init__.py* 的路径。*P* 的 __package__
    属性是 *P* 的包名。
- en: A package *P*’s module body—that is, the Python source that is in the file *P/__init__.py*—can
    optionally set a global variable named __all__ (just like any other module can)
    to control what happens if some other Python code executes the statement **from**
    *P* **import** *. In particular, if __all__ is not set, **from** *P* **import**
    * does not import *P*’s modules, but only names that are set in *P*’s module body
    and lack a leading _. In any case, this is *not* recommended usage.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 包 *P* 的模块主体 - 即文件 *P/__init__.py* 中的 Python 源代码 - 可以选择性地设置一个名为 __all__ 的全局变量（就像任何其他模块一样），以控制如果其他
    Python 代码执行语句 **from** *P* **import** * 会发生什么。特别是，如果未设置 __all__，**from** *P* **import**
    * 不会导入 *P* 的模块，而只会导入在 *P* 的模块主体中设置的没有前导 _ 的名称。无论如何，这都*不*推荐使用。
- en: 'A package *P*’s __path__ attribute is the list of strings that are the paths
    to the directories from which *P*’s modules and subpackages are loaded. Initially,
    Python sets __path__ to a list with a single element: the path of the directory
    containing the file *__init__.py* that is the module body of the package. Your
    code can modify this list to affect future searches for modules and subpackages
    of this package. This advanced technique is rarely necessary, but can be useful
    when you want to place a package’s modules in multiple directories (a namespace
    package is, however, the usual way to accomplish this goal).'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 包 *P* 的 __path__ 属性是一个字符串列表，其中包含加载 *P* 的模块和子包的目录路径。最初，Python 将 __path__ 设置为一个列表，其中仅有一个元素：包含文件
    *__init__.py* 的目录的路径，该文件是包的模块主体。您的代码可以修改此列表，以影响对此包的模块和子包的未来搜索。这种高级技术很少必要，但在您想要将包的模块放置在多个目录中时可能会很有用（然而，命名空间包是实现此目标的通常方法）。
- en: Absolute Versus Relative Imports
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绝对导入与相对导入
- en: As mentioned previously, an **import** statement normally expects to find its
    target somewhere on sys.path—a behavior known as an *absolute* import. Alternatively,
    you can explicitly use a *relative* import, meaning an import of an object from
    within the current package. Using relative imports can make it easier for you
    to refactor or restructure the subpackages within your package. Relative imports
    use module or package names beginning with one or more dots, and are only available
    within the **from** statement. **from** . **import** *X* looks for the module
    or object named *X* in the current package; **from** .*X* **import** *y* looks
    in module or subpackage *X* within the current package for the module or object
    named *y*. If your package has subpackages, their code can access higher-up objects
    in the package by using multiple dots at the start of the module or subpackage
    name you place between **from** and **import**. Each additional dot ascends the
    directory hierarchy one level. Getting too fancy with this feature can easily
    damage your code’s clarity, so use it with care, and only when necessary.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，**import** 语句通常期望在 sys.path 的某处找到其目标，这种行为称为*绝对*导入。或者，您可以显式使用*相对*导入，意味着从当前包中导入对象。使用相对导入可以使您更轻松地重构或重新组织包中的子包。相对导入使用以一个或多个点开头的模块或包名称，并且仅在
    **from** 语句中可用。**from** . **import** *X* 在当前包中查找名为 *X* 的模块或对象；**from** .*X* **import**
    *y* 在当前包的模块或子包 *X* 中查找名为 *y* 的模块或对象。如果您的包有子包，它们的代码可以通过在 **from** 和 **import**
    之间放置的模块或子包名称的起始处使用多个点来访问包中的更高级对象。每一个额外的点都会提升目录层次结构一级。对这个特性的过度使用可能会损害您代码的清晰度，因此请谨慎使用，只在必要时使用。
- en: Distribution Utilities (distutils) and setuptools
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发工具（distutils）和 setuptools
- en: 'Python modules, extensions, and applications can be packaged and distributed
    in several forms:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Python 模块、扩展和应用可以以多种形式打包和分发：
- en: Compressed archive files
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩归档文件
- en: Generally *.zip*, *.tar.gz* (aka *.tgz*), *.tar.bz2*, or *.tar.xz* files—all
    these forms are portable, and many other forms of compressed archives of trees
    of files and directories exist
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通常的 *.zip*、*.tar.gz*（也称为 *.tgz*）、*.tar.bz2* 或 *.tar.xz* 文件 - 所有这些形式都是可移植的，还有许多其他形式的文件和目录树的压缩归档存在
- en: Self-unpacking or self-installing executables
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 自解包或自安装的可执行文件
- en: Normally *.exe* for Windows
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通常用于 Windows 的 *.exe* 文件
- en: Self-contained, ready-to-run executables that require no installation
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 自包含、即时运行的可执行文件，无需安装
- en: For example, *.exe* for Windows, ZIP archives with a short script prefix on
    Unix, *.app* for the Mac, and so on
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于 Windows 是*.exe*，在 Unix 上是带有短脚本前缀的 ZIP 存档文件，对于 Mac 是*.app*，等等
- en: Platform-specific installers
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 平台特定的安装程序
- en: For example, *.rpm* and *.srpm* on many Linux distributions, *.deb* on Debian
    GNU/Linux and Ubuntu, *.pkg* on macOS
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在许多 Linux 发行版上是*.rpm*和*.srpm*，在 Debian GNU/Linux 和 Ubuntu 上是*.deb*，在 macOS
    上是*.pkg*。
- en: Python wheels
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Python Wheels
- en: Popular third-party extensions, covered in the following note
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的第三方扩展，详见下文
- en: Python Wheels
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python Wheels
- en: A Python *wheel* is an archive file including structured metadata as well as
    Python code. Wheels offer an excellent way to package and distribute your Python
    packages, and setuptools (with the wheel extension, easily installed with **pip
    install wheel**) works seamlessly with them. Read all about them at [PythonWheels.com](http://pythonwheels.com)
    and in [Chapter 24](ch24.xhtml#packaging_programs_and_extensions) (available [online](https://oreil.ly/python-nutshell-24)).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Python *wheel* 是一个包含结构化元数据和 Python 代码的存档文件。Wheels 提供了一个出色的方式来打包和分发你的 Python
    包，而且 setuptools（通过**pip install wheel** 轻松安装 wheel 扩展）与它们无缝配合。在[PythonWheels.com](http://pythonwheels.com)和[第
    24 章](ch24.xhtml#packaging_programs_and_extensions)（在线版本[在此](https://oreil.ly/python-nutshell-24)）了解更多信息。
- en: When you distribute a package as a self-installing executable or platform-specific
    installer, a user simply runs the installer. How to run such a program depends
    on the platform, but it doesn’t matter which language the program was written
    in. We cover building self-contained, runnable executables for various platforms
    in [Chapter 24](https://oreil.ly/python-nutshell-24).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个包作为一个自安装可执行文件或平台特定的安装程序进行分发时，用户只需运行安装程序。如何运行这样的程序取决于平台，但程序是用哪种语言编写的并不重要。我们在[第
    24 章](https://oreil.ly/python-nutshell-24)中介绍了为各种平台构建自包含可运行可执行文件的方法。
- en: 'When you distribute a package as an archive file or as an executable that unpacks
    but does not install itself, it *does* matter that the package was coded in Python.
    In this case, the user must first unpack the archive file into some appropriate
    directory, say *C:\Temp\MyPack* on a Windows machine or *~/MyPack* on a Unix-like
    machine. Among the extracted files there should be a script, conventionally named
    *setup.py*, that uses the Python facility known as the *distribution utilities*
    (the now deprecated, but still functioning, standard library package distutils^([2](ch07.xhtml#ch01fn82)))
    or, better, the more popular, modern, and powerful third-party package [setuptools](https://oreil.ly/MHZby).
    The distributed package is then almost as easy to install as a self-installing
    executable; the user simply opens a command prompt window, changes to the directory
    into which the archive is unpacked, then runs, for example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个包作为一个存档文件或一个解压但不安装自身的可执行文件进行分发时，重要的是这个包是用 Python 编写的。在这种情况下，用户必须首先将存档文件解压到某个适当的目录中，比如在
    Windows 机器上是 *C:\Temp\MyPack*，在类 Unix 机器上是 *~/MyPack*。在提取的文件中应该有一个脚本，按照惯例命名为 *setup.py*，它使用
    Python 设施称为 *distribution utilities*（现在已经被弃用，但仍然有效的标准库包 distutils^([2](ch07.xhtml#ch01fn82)））或者更好的是，更流行、现代和强大的第三方包
    [setuptools](https://oreil.ly/MHZby)。然后，分发的包几乎和自安装可执行文件一样容易安装；用户只需打开一个命令提示窗口，切换到解压存档文件的目录，然后运行，例如：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '(Another, often preferable, option is to use pip; we’ll describe that momentarily.)
    The *setup.py* script run with this **install** command installs the package as
    a part of the user’s Python installation, according to the options specified by
    the package’s author in the setup script. Of course, the user needs appropriate
    permissions to write into the directories of the Python installation, so permission-raising
    commands such as sudo may also be needed; or, better yet, you can install into
    a *virtual environment*, as described in the next section. distutils and setuptools,
    by default, print some information when the user runs *setup.py*. Including the
    option **--quiet** right before the **install** command hides most details (the
    user still sees error messages, if any). The following command gives detailed
    help on distutils or setuptools, depending on which toolset the package author
    used in their *setup.py*:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: （另一种常用的选择是使用 pip；我们将立即描述它。）运行此 **install** 命令的 *setup.py* 脚本会根据包的作者在设置脚本中指定的选项将包安装为用户的
    Python 安装的一部分。当然，用户需要适当的权限才能写入 Python 安装目录的目录，因此可能也需要像 sudo 这样提高权限的命令；或者更好的做法是，您可以安装到虚拟环境中，如下一节所述。distutils
    和 setuptools 在用户运行 *setup.py* 时，默认会打印一些信息。在 **install** 命令之前包含 **--quiet** 选项可以隐藏大部分详细信息（用户仍然可以看到错误消息，如果有的话）。以下命令可以详细了解
    distutils 或 setuptools，具体取决于包作者在其 *setup.py* 中使用的工具集：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: An alternative to this process, and the preferred way to install packages nowadays,
    is to use the excellent installer pip that comes with Python. pip—a recursive
    acronym for “pip installs packages”—is copiously documented [online](https://oreil.ly/G7zMK),
    yet very simple to use in most cases. **pip install** ***package*** finds the
    online version of *package* (usually in the huge [PyPI](https://oreil.ly/PGIim)
    repository, hosting more than 400,000 packages at the time of this writing), downloads
    it, and installs it for you (in a virtual environment, if one is active; see the
    next section for details). This books’ authors have been using that simple, powerful
    approach for well over 90% of their installs for quite a while now.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的另一个选择，也是现在安装包的首选方式，是使用与 Python 随附的优秀安装程序 pip。pip——“pip installs packages”的递归缩写——在大多数情况下使用起来非常简单，但[在线](https://oreil.ly/G7zMK)有大量文档支持。**pip
    install** ***package*** 会查找*package*的在线版本（通常在巨大的 [PyPI](https://oreil.ly/PGIim)
    仓库中，在撰写本文时托管了超过 400,000 个包），下载并为您安装它（如果已激活虚拟环境，则在其中安装；有关详细信息，请参阅下一节）。这本书的作者已经使用这种简单而强大的方法安装了超过
    90% 的安装已经相当长时间了。
- en: 'Even if you have downloaded the package locally (say to */tmp/mypack*), for
    whatever reason (maybe it’s not on PyPI, or you’re trying out an experimental
    version that is not yet there), pip can still install it for you: just run **pip
    install --no-index --find-links=/tmp/mypack** and pip does the rest.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您已经将包本地下载（比如到 */tmp/mypack*），出于任何原因（也许它不在 PyPI 上，或者您正在尝试一个尚未发布的实验版本），pip 仍然可以为您安装它：只需运行
    **pip install --no-index --find-links=/tmp/mypack**，pip 将完成其余操作。
- en: Python Environments
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 环境
- en: A typical Python programmer works on several projects concurrently, each with
    its own list of dependencies (typically, third-party libraries and data files).
    When the dependencies for all projects are installed into the same Python interpreter,
    it is very difficult to determine which projects use which dependencies, and impossible
    to handle projects with conflicting versions of certain dependencies.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的 Python 程序员同时在多个项目上工作，每个项目都有自己的依赖列表（通常是第三方库和数据文件）。当所有项目的依赖项都安装到同一个 Python
    解释器时，很难确定哪些项目使用了哪些依赖项，并且无法处理使用某些依赖项冲突版本的项目。
- en: Early Python interpreters were built on the assumption that each computer system
    would have “a Python interpreter” installed on it, to be used to run any Python
    program on that system. Operating system distributions soon started to include
    Python in their base installations, but, because Python has always been under
    active development, users often complained that they would like to use a more
    up-to-date version of the language than the one their operating system provided.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的 Python 解释器是基于这样的假设构建的：每台计算机系统都安装有“一个 Python 解释器”，用于在该系统上运行任何 Python 程序。操作系统发行版很快开始将
    Python 包含在它们的基础安装中，但由于 Python 一直在积极开发中，用户经常抱怨他们希望使用比其操作系统提供的更更新的语言版本。
- en: Techniques arose to let multiple versions of the language be installed on a
    system, but installation of third-party software remained nonstandard and intrusive.
    This problem was eased by the introduction of the *site-packages* directory as
    the repository for modules added to a Python installation, but it was still not
    possible to maintain multiple projects with conflicting requirements using the
    same interpreter.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 出现了让系统安装多个版本的语言的技术，但第三方软件的安装仍然是非标准和具有侵入性的。通过引入*site-packages*目录作为添加到 Python
    安装的模块的存储库来缓解这个问题，但仍然不可能使用相同的解释器维护具有冲突要求的多个项目。
- en: Programmers accustomed to command-line operations are familiar with the concept
    of a *shell environment*. A shell program running in a process has a current directory,
    variables that you can set with shell commands (very similar to a Python namespace),
    and various other pieces of process-specific state data. Python programs have
    access to the shell environment through os.environ.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 习惯于命令行操作的程序员熟悉*shell 环境*的概念。在进程中运行的 shell 程序有一个当前目录，您可以使用 shell 命令设置变量（与 Python
    命名空间非常相似），以及各种其他进程特定状态数据。Python 程序可以通过 os.environ 访问 shell 环境。
- en: Various aspects of the shell environment affect Python’s operation, as mentioned
    in [“Environment Variables”](ch02.xhtml#environment_variables). For example, the
    PATH environment variable determines which program, exactly, executes in response
    to **python** and other commands. You can think of those aspects of your shell
    environment that affect Python’s operation as your *Python environment*. By modifying
    it you can determine which Python interpreter runs in response to the **python**
    command, which packages and modules are available under certain names, and so
    on.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如[“环境变量”](ch02.xhtml#environment_variables)中所述，shell 环境的各个方面都会影响 Python 的运行。例如，PATH
    环境变量决定了哪个程序会对**python**和其他命令做出响应。你可以把影响 Python 运行的 shell 环境的各个方面称为你的*Python 环境*。通过修改它，你可以确定哪个
    Python 解释器会对**python**命令做出响应，哪些包和模块在特定名称下可用，等等。
- en: Leave the System’s Python to the System
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要将系统的 Python 用于系统
- en: We recommend taking control of your Python environment. In particular, do not
    build applications on top of a system-distributed Python. Instead, install another
    Python distribution independently, and adjust your shell environment so that the
    **python** command runs your locally installed Python rather than the system’s
    Python.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议控制你的 Python 环境。特别是，不要在系统分发的 Python 上构建应用程序。相反，独立安装另一个 Python 发行版，并调整你的 shell
    环境，以便**python**命令运行你本地安装的 Python，而不是系统的 Python。
- en: Enter the Virtual Environment
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进入虚拟环境
- en: The introduction of the pip utility created a simple way to install (and, for
    the first time, to uninstall) packages and modules in a Python environment. Modifying
    the system Python’s *site-packages* still requires administrative privileges,
    and hence so does pip (although it can optionally install somewhere other than
    *site-packages*). Modules installed in the central *site-packages* are visible
    to all programs.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: pip 实用程序的引入为在 Python 环境中安装（并且首次卸载）包和模块提供了一种简单的方法。修改系统 Python 的*site-packages*仍然需要管理员权限，因此
    pip 也需要（虽然它可以选择安装到*site-packages*之外的地方）。安装在中央*site-packages*中的模块对所有程序都可见。
- en: The missing piece is the ability to make controlled changes to the Python environment,
    to direct the use of a specific interpreter and a specific set of Python libraries.
    That functionality is just what *virtual environments* (*virtualenvs*) give you.
    Creating a virtualenv based on a specific Python interpreter copies or links to
    components from that interpreter’s installation. Critically, though, each one
    has its own *site-packages* directory, into which you can install the Python resources
    of your choice.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 缺失的部分是能够对 Python 环境进行受控更改，以指导使用特定的解释器和一组特定的 Python 库。这正是*虚拟环境*（*virtualenvs*）所提供的功能。基于特定
    Python 解释器创建的虚拟环境会复制或链接到该解释器安装的组件。关键是，每个虚拟环境都有自己的*site-packages*目录，你可以将你选择的 Python
    资源安装到其中。
- en: Creating a virtualenv is *much* simpler than installing Python, and requires
    far less system resources (a typical newly created virtualenv takes up less than
    20 MB). You can easily create and activate virtualenvs on demand, and deactivate
    and destroy them just as easily. You can activate and deactivate a virtualenv
    as many times as you like during its lifetime, and if necessary use pip to update
    the installed resources. When you are done with it, removing its directory tree
    reclaims all storage occupied by the virtualenv. A virtualenv’s lifetime can span
    minutes or months.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 创建虚拟环境比安装 Python *简单得多*，并且需要的系统资源远远少于后者（典型的新创建的虚拟环境占用不到 20 MB）。您可以随时轻松创建和激活虚拟环境，并且同样轻松地取消激活和销毁它们。在其生命周期内，您可以任意次数地激活和取消激活虚拟环境，并且必要时使用
    pip 来更新已安装的资源。当您完成时，删除其目录树会回收虚拟环境占用的所有存储空间。虚拟环境的生命周期可以是几分钟或几个月。
- en: What Is a Virtual Environment?
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是虚拟环境？
- en: A virtualenv is essentially a self-contained subset of your Python environment
    that you can switch in or out on demand. For a Python 3.*x* interpreter it includes,
    among other things, a *bin* directory containing a Python 3.*x* interpreter, and
    a *lib/python3.x/site-packages* directory containing preinstalled versions of
    easy-install, pip, pkg_resources, and setuptools. Maintaining separate copies
    of these important distribution-related resources lets you update them as necessary
    rather than forcing you to rely on the base Python distribution.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境本质上是您的 Python 环境的一个自包含子集，您可以根据需要随时切换。对于 Python 3.*x* 解释器，它包括，除其他外，一个包含 Python
    3.*x* 解释器的 *bin* 目录，以及一个包含预安装版本的 easy-install、pip、pkg_resources 和 setuptools 的
    *lib/python3.x/site-packages* 目录。维护这些重要的分发相关资源的独立副本使您可以根据需要更新它们，而不是强迫您依赖基本 Python
    发行版。
- en: A virtualenv has its own copies of (on Windows) or symbolic links to (on other
    platforms) Python distribution files. It adjusts the values of sys.prefix and
    sys.exec_prefix, from which the interpreter and various installation utilities
    determine the locations of some libraries. This means that pip can install dependencies
    in isolation from other environments, in the virtualenv’s *site-packages* directory.
    In effect, the virtualenv redefines which interpreter runs when you run the **python**
    command and which libraries are available to it, but leaves most aspects of your
    Python environment (such as the PYTHONPATH and PYTHONHOME variables) alone. Since
    its changes affect your shell environment, they also affect any subshells in which
    you run commands.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境在（在 Windows 上）或符号链接到（在其他平台上）Python 发行文件上有其自己的副本。它调整了 sys.prefix 和 sys.exec_prefix
    的值，从而解释器和各种安装工具确定了一些库的位置。这意味着 pip 可以将依赖项安装在与其他环境隔离的情况下，在虚拟环境的 *site-packages*
    目录中。实际上，虚拟环境重新定义了运行 **python** 命令时的解释器以及可用于解释器的大多数库，但保留了 Python 环境的大多数方面（如 PYTHONPATH
    和 PYTHONHOME 变量）。由于其更改会影响您的 shell 环境，因此它们也会影响您运行命令的任何子 shell。
- en: With separate virtualenvs you can, for example, test two different versions
    of the same library with a project, or test your project with multiple versions
    of Python. You can also add dependencies to your Python projects without needing
    any special privileges, since you normally create your virtualenvs somewhere you
    have write permission.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单独的虚拟环境，您可以例如，测试项目中相同库的两个不同版本，或者使用多个 Python 版本测试您的项目。您还可以为您的 Python 项目添加依赖项，而无需任何特殊权限，因为您通常在您具有写权限的地方创建您的虚拟环境。
- en: 'The modern way to deal with virtualenvs is with the venv module of the standard
    library: just run **python -m venv** *envpath*.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 处理虚拟环境的现代方法是使用标准库的 venv 模块：只需运行 **python -m venv** *envpath*。
- en: Creating and Deleting Virtual Environments
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和删除虚拟环境
- en: The command **python -m venv** *envpath* creates a virtual environment (in the
    *envpath* directory, which it also creates if necessary) based on the Python interpreter
    used to run the command. You can give multiple directory arguments to create,
    with a single command, several virtual environments (running the same Python interpreter);
    you can then install different sets of dependencies in each virtualenv. venv can
    take a number of options, as shown in [Table 7-1](#venv_options).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 命令 **python -m venv** *envpath* 创建一个基于运行该命令的 Python 解释器的虚拟环境（在必要时还会创建 *envpath*
    目录）。您可以提供多个目录参数来创建多个虚拟环境（使用相同的 Python 解释器），然后可以在每个虚拟环境中安装不同的依赖项集。venv 可以接受多个选项，如[表 7-1](#venv_options)所示。
- en: Table 7-1\. venv options
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-1\. venv 选项
- en: '| Option | Purpose |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 目的 |'
- en: '| --- | --- |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| **--clear** | Removes any existing directory content before installing the
    virtual environment |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| **--clear** | 在安装虚拟环境之前移除任何现有目录内容 |'
- en: '| **--copies** | Installs files by copying on the Unix-like platforms where
    using symbolic links is the default |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| **--copies** | 在类 Unix 平台上使用复制方式安装文件，这是默认使用符号链接的系统 |'
- en: '| **--h** or **--help** | Prints out a command-line summary and a list of available
    options |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| **--h** 或 **--help** | 打印出命令行摘要和可用选项列表 |'
- en: '| **--symlinks** | Installs files by using symbolic links on platforms where
    copying is the system default |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| **--symlinks** | 在平台上使用符号链接安装文件，这是默认复制的系统 |'
- en: '| **--system-site-packages** | Adds the standard system *site-packages* directory
    to the environment’s search path, making modules already installed in the base
    Python available inside the environment |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| **--system-site-packages** | 将标准系统 *site-packages* 目录添加到环境的搜索路径中，使基础 Python
    中已安装的模块在环境内可用 |'
- en: '| **--upgrade** | Installs the running Python in the virtual environment, replacing
    whichever version had originally created the environment |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| **--upgrade** | 在虚拟环境中安装当前正在运行的 Python，替换最初创建环境的版本 |'
- en: '| **--without-pip** | Inhibits the usual behavior of calling ensurepip to bootstrap
    the pip installer utility into the environment |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| **--without-pip** | 阻止调用 ensurepip 来将 pip 安装器引导到环境中的常规行为 |'
- en: Know Which Python You’re Running
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 知道您正在使用哪个 Python
- en: When you enter the command **python** at the command line, your shell has rules
    (which differ among Windows, Linux, and macOS) that determine which program you
    run. If you are clear on those rules, you always know which interpreter you are
    using.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在命令行输入 **python** 命令时，您的 shell 有一些规则（在 Windows、Linux 和 macOS 中有所不同），决定您运行的程序。如果您清楚这些规则，您就始终知道您正在使用哪个解释器。
- en: 'Using **python -m venv** *directory_path* to create a virtual environment guarantees
    that it’s based on the same Python version as the interpreter used to create it.
    Similarly, using **python -m pip** *package_name* will install the package for
    the interpreter associated with the **python** command. Activating a virtual environment
    changes the association with the **python** command: this is the simplest way
    to ensure packages are installed into the virtual environment.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **python -m venv** *directory_path* 命令创建虚拟环境可以保证它基于与创建时所用解释器相同的 Python 版本。类似地，使用
    **python -m pip** *package_name* 将为与 **python** 命令关联的解释器安装包。激活虚拟环境会改变与 **python**
    命令的关联：这是确保包安装到虚拟环境中的最简单方法。
- en: The following Unix terminal session shows the creation of a virtualenv and the
    structure of the created directory tree. The listing of the *bin* subdirectory
    shows that this particular user, by default, uses an interpreter installed in
    */usr/local/bin*.^([3](ch07.xhtml#ch01fn83))
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 Unix 终端会话显示了虚拟环境的创建及创建的目录结构。*bin* 子目录的列表显示了这个特定用户默认使用的解释器安装在 */usr/local/bin*
    中。^([3](ch07.xhtml#ch01fn83))
- en: '[PRE18]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Deleting a virtualenv is as simple as removing the directory in which it resides
    (and all subdirectories and files in the tree: **rm -rf** *envpath* in Unix-like
    systems). Ease of removal is a helpful aspect of using virtualenvs.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 删除虚拟环境就像删除它所在的目录一样简单（以及树中的所有子目录和文件：在类 Unix 系统中使用 **rm -rf** *envpath*）。易于删除是使用虚拟环境的一个有用方面。
- en: The venv module includes features to help the programmed creation of tailored
    environments (e.g., by preinstalling certain modules in the environment or performing
    other post-creation steps). It is comprehensively documented [online](https://oreil.ly/DVwfT);
    we do not cover the API further in this book.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: venv 模块包括一些功能，帮助编程创建定制环境（例如，在环境中预安装某些模块或执行其他创建后步骤）。在线文档提供了详细说明 [online](https://oreil.ly/DVwfT)；我们在本书中不再详细介绍
    API。
- en: Working with Virtual Environments
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用虚拟环境
- en: To use a virtualenv, you *activate* it from your normal shell environment. Only
    one virtualenv can be active at a time—activations don’t “stack” like function
    calls. Activation tells your Python environment to use the virtualenv’s Python
    interpreter and *site-packages* (along with the interpreter’s full standard library).
    When you want to stop using those dependencies, deactivate the virtualenv, and
    your standard Python environment is once again available. The virtualenv directory
    tree continues to exist until deleted, so you can activate and deactivate it at
    will.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用虚拟环境，需要在正常的shell环境中 *activate* 它。一次只能激活一个虚拟环境，激活不像函数调用那样可以“堆叠”。激活告诉你的Python环境使用虚拟环境的Python解释器和
    *site-packages*（以及解释器的完整标准库）。当你想要停止使用这些依赖时，取消激活虚拟环境，你的标准Python环境将再次可用。虚拟环境目录树继续存在，直到被删除，因此可以随意激活和取消激活。
- en: 'Activating a virtualenv in Unix-based environments requires using the **source**
    shell command so that the commands in the activation script make changes to the
    current shell environment. Simply running the script would mean its commands were
    executed in a subshell, and the changes would be lost when the subshell terminated.
    For bash, zsh, and similar shells, you activate an environment located at path
    *envpath* with the command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix-based环境中激活虚拟环境需要使用 **source** shell命令，以便激活脚本中的命令可以修改当前的shell环境。简单运行脚本会导致其命令在子shell中执行，当子shell终止时，更改将会丢失。对于bash、zsh和类似的shell，你可以使用以下命令激活位于路径
    *envpath* 的环境：
- en: '[PRE19]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'or:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE20]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Users of other shells are supported by the scripts *activate.csh* and *activate.fish*,
    located in the same directory. On Windows systems, use *activate.bat* (or, if
    using Powershell, *Activate.ps1*):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 其他shell的用户可以使用同一目录中的 *activate.csh* 和 *activate.fish* 脚本来获得支持。在Windows系统上，使用
    *activate.bat*（或者如果使用Powershell，则使用 *Activate.ps1*）：
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Activation does many things. Most importantly, it:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 激活会执行许多操作。最重要的是：
- en: Adds the virtualenv’s *bin* directory at the beginning of the shell’s PATH environment
    variable, so its commands get run in preference to anything of the same name already
    on the PATH
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将虚拟环境的 *bin* 目录添加到shell的PATH环境变量的开头，这样它的命令优先于已存在于PATH中同名的任何内容。
- en: Defines a deactivate command to remove all effects of activation and return
    the Python environment to its former state
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义了一个deactivate命令，用于取消激活的所有效果，并将Python环境恢复到其原始状态。
- en: Modifies the shell prompt to include the virtualenv’s name at the start
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改shell提示符，在开头包含虚拟环境的名称。
- en: Defines a VIRTUAL_ENV environment variable as the path to the virtualenv’s root
    directory (scripts can use this to introspect the virtualenv)
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义了一个VIRTUAL_ENV环境变量，指向虚拟环境的根目录（脚本可以使用此变量来检查虚拟环境）。
- en: As a result of these actions, once a virtualenv is activated, the **python**
    command runs the interpreter associated with that virtualenv. The interpreter
    sees the libraries (modules and packages) installed in that environment, and pip—now
    the one from the virtualenv, since installing the module also installed the command
    in the virtualenv’s *bin* directory—by default installs new packages and modules
    in the environment’s *site-packages* directory.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些操作的结果，一旦激活了虚拟环境，**python** 命令将运行与该虚拟环境关联的解释器。解释器可以看到安装在该环境中的库（模块和包），而pip——现在是虚拟环境中的pip，因为安装模块也安装了命令到虚拟环境的
    *bin* 目录——默认将新的包和模块安装到环境的 *site-packages* 目录中。
- en: Those new to virtualenvs should understand that a virtualenv is not tied to
    any project directory. It’s perfectly possible to work on several projects, each
    with its own source tree, using the same virtualenv. Activate it, then move around
    your filesystem as necessary to accomplish your programming tasks, with the same
    libraries available (because the virtualenv determines the Python environment).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于刚接触虚拟环境的人来说，需要理解虚拟环境与任何项目目录都无关。完全可以在同一个虚拟环境中处理多个项目，每个项目都有自己的源代码树。激活虚拟环境后，你可以根据需要在文件系统中移动，完成编程任务，使用相同的库（因为虚拟环境确定了Python环境）。
- en: 'When you want to disable the virtualenv and stop using that set of resources,
    simply issue the command **deactivate**. This undoes the changes made on activation,
    removing the virtualenv’s *bin* directory from your PATH, so the **python** command
    once again runs your usual interpreter. As long as you don’t delete it, the virtualenv
    remains available for future use: just repeat the command to activate it.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要禁用虚拟环境并停止使用那组资源时，只需执行命令 **deactivate**。这将撤销激活时所做的更改，将虚拟环境的 *bin* 目录从你的 PATH
    中移除，因此 **python** 命令将再次运行你通常的解释器。只要不删除它，虚拟环境将保持可用状态供将来使用：只需重复执行命令来激活它。
- en: Do Not Use py –3.x in a Virtualenv on Windows
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要在 Windows 的虚拟环境中使用 py –3.x
- en: 'The Windows py launcher provides mixed support for virtualenvs. It makes it
    very easy to define a virtualenv using a specific Python version, using a command
    like the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Windows py 启动器对虚拟环境的支持提供了混合支持。它使得使用特定 Python 版本定义虚拟环境变得非常简单，例如使用以下命令：
- en: '[PRE22]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This creates a new virtualenv, running the installed Python 3.7.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的虚拟环境，运行已安装的 Python 3.7 版本。
- en: Once activated, you can run the Python interpreter in the virtualenv using either
    the **python** command or the bare **py** command with no version specified. However,
    if you specify the **py** command using a version option, even if it is the same
    version used to construct the virtualenv, you will *not* run the *virtualenv*
    Python. Instead, you will run the corresponding *system-installed* version of
    Python.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦激活，你可以使用 **python** 命令或不指定版本的裸露 **py** 命令在虚拟环境中运行 Python 解释器。然而，如果你使用版本选项指定
    **py** 命令，即使它是用来构建虚拟环境的相同版本，你也将不会运行 *virtualenv* Python。相反，你将运行相应的系统安装版本的 Python。
- en: Managing Dependency Requirements
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理依赖要求
- en: 'Since virtualenvs were designed to complement installation with pip, it should
    come as no surprise that pip is the preferred way to maintain dependencies in
    a virtualenv. Because pip is already extensively documented, we mention only enough
    here to demonstrate its advantages in virtual environments. Having created a virtualenv,
    activated it, and installed dependencies, you can use the **pip freeze** command
    to learn the exact versions of those dependencies:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 由于虚拟环境设计为与 pip 安装相辅相成，因此不足为奇，pip 是在虚拟环境中维护依赖项的首选方式。由于 pip 已经有了广泛的文档，我们在这里只提到足够展示它在虚拟环境中的优势。创建了虚拟环境、激活了它并安装了依赖项后，你可以使用
    **pip freeze** 命令来了解这些依赖项的确切版本：
- en: '[PRE23]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you redirect the output of this command to a file called *filename*, you
    can re-create the same set of dependencies in a different virtualenv with the
    command **pip** **install** **-r** *filename*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此命令的输出重定向到一个名为 *filename* 的文件中，你可以使用命令 **pip install -r** *filename* 在另一个虚拟环境中重新创建相同的依赖项集。
- en: When distributing code for use by others, Python developers conventionally include
    a *requirements.txt* file listing the necessary dependencies. pip installs any
    indicated dependencies along with the packages you request when you install software
    from PyPI. While you’re developing software it’s also convenient to have a requirements
    file, as you can use it to add the necessary dependencies to the active virtualenv
    (unless they are already installed) with a simple **pip install -r requirements.txt**.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在为他人使用的代码分发时，Python 开发人员通常包含一个列出必要依赖项的 *requirements.txt* 文件。当从 PyPI 安装软件时，pip
    会安装任何指示的依赖项以及你请求的包。在开发软件时，拥有一个要求文件也很方便，因为你可以使用它向活跃的虚拟环境添加必要的依赖项（除非它们已经安装），只需简单地执行
    **pip install -r requirements.txt**。
- en: 'To maintain the same set of dependencies in several virtualenvs, use the same
    requirements file to add dependencies to each one. This is a convenient way to
    develop projects to run on multiple Python versions: create virtualenvs based
    on each of your required versions, then install from the same requirements file
    in each. While the preceding example uses exactly versioned dependency specifications
    as produced by **pip freeze**, in practice you can specify dependencies and version
    requirements in quite complex ways; see the [documentation](https://oreil.ly/wB9LB)
    for details.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要在多个虚拟环境中保持相同的依赖关系集，使用同一个要求文件向每个虚拟环境添加依赖项。这是一个方便的方法来开发可以在多个 Python 版本上运行的项目：为每个所需版本创建基于的虚拟环境，然后在每个环境中从同一个要求文件安装。虽然前面的示例使用了由
    **pip freeze** 生成的精确版本化的依赖规范，但在实践中，你可以以非常复杂的方式指定依赖关系和版本要求；详细信息请参阅 [文档](https://oreil.ly/wB9LB)。
- en: Other Environment Management Solutions
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他环境管理解决方案
- en: Python virtual environments are focused on providing an isolated Python interpreter,
    into which you can install dependencies for one or more Python applications. The
    [virtualenv](https://oreil.ly/bUfe0) package was the original way to create and
    manage virtualenvs. It has extensive facilities, including the ability to create
    environments from any available Python interpreter. Now maintained by the Python
    Packaging Authority team, a subset of its functionality has been extracted as
    the standard library venv module covered earlier, but virtualenv is worth learning
    about if you need more control.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Python 虚拟环境专注于提供一个隔离的 Python 解释器，你可以在其中为一个或多个 Python 应用程序安装依赖项。最初创建和管理 virtualenv
    的方式是使用 [virtualenv](https://oreil.ly/bUfe0) 包。它具有广泛的功能，包括从任何可用的 Python 解释器创建环境的能力。现在由
    Python Packaging Authority 团队维护，其部分功能已提取为标准库 venv 模块，但如果需要更多控制，还是值得了解 virtualenv。
- en: The [pipenv](https://oreil.ly/vfi9I) package is another dependency manager for
    Python environments. It maintains virtual environments whose contents are recorded
    in a file named *Pipfile*. Much in the manner of similar JavaScript tools, it
    provides deterministic environments through the use of a *Pipfile.lock* file,
    allowing the exact same dependencies to be deployed as in the original installation.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[pipenv](https://oreil.ly/vfi9I) 包是另一个用于 Python 环境的依赖管理器。它维护虚拟环境，其内容记录在名为 *Pipfile*
    的文件中。类似于类似的 JavaScript 工具，通过 *Pipfile.lock* 文件提供确定性环境，允许部署与原始安装完全相同的依赖项。'
- en: conda, mentioned in [“Anaconda and Miniconda”](ch01.xhtml#anaconda_and_miniconda),
    has a rather broader scope and can provide package, environment, and dependency
    management for any language. conda is written in Python, and installs its own
    Python interpreter in the base environment. Whereas a standard Python virtualenv
    normally uses the Python interpreter with which it was created; in conda, Python
    itself (when it is included in the environment) is simply another dependency.
    This makes it practical to update the version of Python used in the environment,
    if necessary. You can also, if you wish, use pip to install packages in a Python-based
    conda environment. conda can dump an environment’s contents as a YAML file, and
    you can use the file to replicate the environment elsewhere.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: conda，在 [“Anaconda and Miniconda”](ch01.xhtml#anaconda_and_miniconda) 中提到，具有更广泛的范围，可以为任何语言提供包、环境和依赖管理。conda
    使用 Python 编写，在基础环境中安装自己的 Python 解释器。而标准的 Python virtualenv 通常使用创建时的 Python 解释器；在
    conda 中，Python 本身（当其包含在环境中时）只是另一个依赖项。这使得在需要时更新环境中使用的 Python 版本成为可能。如果愿意，你也可以在基于
    Python 的 conda 环境中使用 pip 安装软件包。conda 可以将环境内容转储为 YAML 文件，你可以使用该文件在其他地方复制环境。
- en: Because of its additional flexibility, coupled with comprehensive open source
    support led by its originator, Anaconda, Inc. (formerly Continuum), conda is widely
    used in academic environments, particularly in data science and engineering, artificial
    intelligence, and financial analytics. It installs software from what it calls
    *channels*. The default channel maintained by Anaconda contains a wide range of
    packages, and third parties maintain specialized channels (such as the *bioconda*
    channel for bioinformatics software). There is also a community-based [*conda-forge*
    channel](https://oreil.ly/fEBZo), open to anyone who wants to join up and add
    software. Signing up for an account on [Anaconda.org](https://anaconda.org) lets
    you create your own channel and distribute software through the *conda-forge*
    channel.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因其额外的灵活性，加上由其创始者 Anaconda, Inc.（前身为 Continuum）主导的全面开源支持，conda 在学术环境中被广泛使用，特别是在数据科学与工程、人工智能和金融分析领域。它从所谓的
    *channels* 安装软件。Anaconda 维护的默认 channel 包含各种软件包，第三方维护专门的 channel（如生物信息学软件的 *bioconda*
    channel）。还有一个基于社区的 [*conda-forge* channel](https://oreil.ly/fEBZo)，欢迎任何希望加入并添加软件的人。在
    [Anaconda.org](https://anaconda.org) 注册账户可以让你创建自己的 channel 并通过 *conda-forge* channel
    分发软件。
- en: Best Practices with Virtualenvs
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用虚拟环境的最佳实践
- en: 'There is remarkably little advice on how best to manage your work with virtualenvs,
    though there are several sound tutorials: any good search engine will give you
    access to the most current ones. We can, however, offer a modest amount of advice
    that we hope will help you to get the most out of virtual environments.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何最佳管理虚拟环境的建议非常少，但有几个 sound tutorials：任何一个好的搜索引擎都可以让你访问到最新的教程。不过，我们可以提供一些希望能帮助你充分利用虚拟环境的简单建议。
- en: When you are working with the same dependencies in multiple Python versions,
    it is useful to indicate the version in the environment name and use a common
    prefix. So, for the project *mutex* you might maintain environments called *mutex_39*
    and *mutex_310* for development under two different versions of Python. When it’s
    obvious which Python is involved (remember, you see the environment name in your
    shell prompt), there’s less risk of testing with the wrong version. You can maintain
    dependencies using common requirements to control resource installation in both.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在多个Python版本中使用相同的依赖关系时，在环境名称中指示版本并使用共同的前缀是有用的。因此，对于项目*mutex*，您可以维护称为*mutex_39*和*mutex_310*的环境，以在两个不同版本的Python下进行开发。当环境名称在您的shell提示符中显而易见时（记住，您可以看到环境名称），测试使用错误版本的风险较小。您可以使用共同的需求来维护依赖项，以控制在两者中的资源安装。
- en: Keep the requirements file(s) under source control, not the whole environment.
    Given the requirements file it’s easy to re-create a virtualenv, which depends
    only on the Python release and the requirements. You distribute your project,
    and let your users decide which version(s) of Python to run it on and create the
    appropriate virtual environment(s).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 将需求文件保留在源代码控制下，而不是整个环境。有了需求文件，重新创建虚拟环境很容易，它仅依赖于Python版本和需求。您可以分发您的项目，并让用户决定在哪些Python版本上运行它并创建适当的虚拟环境。
- en: Keep your virtualenvs outside your project directories. This avoids the need
    to explicitly force source code control systems to ignore them. It really doesn’t
    matter where else you store them.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的虚拟环境保持在项目目录之外。这样可以避免显式强制源代码控制系统忽略它们。它们存储在哪里真的无关紧要。
- en: Your Python environment is independent of your projects’ locations in the filesystem.
    You can activate a virtual environment and then switch branches and move around
    a change-controlled source tree to use it wherever is convenient.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Python环境独立于文件系统中项目的位置。您可以激活一个虚拟环境，然后切换分支并在变更控制的源代码树中移动以在任何方便的地方使用它。
- en: To investigate a new module or package, create and activate a new virtualenv
    and then **pip install** the resources that interest you. You can play with this
    new environment to your heart’s content, confident in the knowledge that you won’t
    be installing unwanted dependencies into other projects.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要调查一个新的模块或包，创建并激活一个新的虚拟环境，然后**pip install**您感兴趣的资源。您可以尽情地在这个新环境中玩耍，确信您不会将不需要的依赖项安装到其他项目中。
- en: 'You may find that experiments in a virtualenv require installation of resources
    that aren’t currently project requirements. Rather than “pollute” your development
    environment, fork it: create a new virtualenv from the same requirements plus
    the testing functionality. Later, to make these changes permanent, use change
    control to merge your source and requirements changes back in from the forked
    branch.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟环境中进行实验可能需要安装不是当前项目需求的资源。与其“污染”您的开发环境，不如分叉它：从相同的需求创建一个新的虚拟环境，再加上测试功能。稍后，为了使这些更改永久化，使用变更控制从分叉分支合并您的源代码和需求更改回来。
- en: If you are so inclined, you can create virtual environments based on debug builds
    of Python, giving you access to a wealth of information about the performance
    of your Python code (and, of course, of the interpreter itself).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您可以基于Python的调试版本创建虚拟环境，从而可以访问关于您的Python代码性能（当然还有解释器本身）的丰富信息。
- en: Developing a virtual environment also requires change control, and the ease
    of virtualenv creation helps here too. Suppose that you recently released version
    4.3 of a module, and you want to test your code with new versions of two of its
    dependencies. You *could*, with sufficient skill, persuade pip to replace the
    existing copies of dependencies in your existing virtualenv. It’s much easier,
    though, to branch your project using source control tools, update the requirements,
    and create an entirely new virtual environment based on the updated requirements.
    The original virtualenv remains intact, and you can switch between virtualenvs
    to investigate specific aspects of any migration issues that might arise. Once
    you have adjusted your code so that all tests pass with the updated dependencies,
    you can check in your code *and* requirement changes and merge into version 4.4
    to complete the update, advising your colleagues that your code is now ready for
    the updated versions of the dependencies.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 开发虚拟环境还需要变更控制，而虚拟环境创建的便利性在这方面也起到了帮助作用。假设你最近发布了模块的 4.3 版本，并且你想要用其两个依赖项的新版本来测试你的代码。如果你足够有技巧，可以说服
    pip 替换现有虚拟环境中的依赖项副本。不过，更简单的方法是使用源代码控制工具分支你的项目，更新依赖项，并基于更新后的需求创建一个全新的虚拟环境。原始虚拟环境保持不变，你可以在不同的虚拟环境之间切换，以调查可能出现的任何迁移问题的特定方面。一旦调整了代码，使所有测试都通过了更新的依赖项，你就可以提交你的代码和需求更改，并合并到版本
    4.4 完成更新，通知同事你的代码已准备好使用更新的依赖版本。
- en: 'Virtual environments won’t solve all of a Python programmer’s problems: tools
    can always be made more sophisticated, or more general. But, by golly, virtualenvs
    work, and we should take all the advantage of them that we can.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境并不能解决所有 Python 程序员的问题：工具总是可以变得更复杂，或者更通用。但是，天哪，虚拟环境确实有效，我们应该尽可能充分利用它们。
- en: ^([1](ch07.xhtml#ch01fn81-marker)) One of our tech reviewers reports that *.pyw*
    files on Windows are an exception to this.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch07.xhtml#ch01fn81-marker)) 我们的一位技术审阅员报告说在 Windows 上的 *.pyw* 文件是一个例外。
- en: ^([2](ch07.xhtml#ch01fn82-marker)) distutils is scheduled for deletion in Python
    3.12.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch07.xhtml#ch01fn82-marker)) 在 Python 3.12 中，计划删除 distutils。
- en: ^([3](ch07.xhtml#ch01fn83-marker)) When running these commands on reduced-footprint
    Linux distributions, you may need to separately install venv or other supporting
    packages first.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch07.xhtml#ch01fn83-marker)) 在运行这些命令时，如果使用减少了占用空间的 Linux 发行版，可能需要单独安装
    venv 或其他支持包。
