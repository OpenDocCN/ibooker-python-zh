- en: Chapter 2\. Introduction to Python Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To write maintainable Python, you must be aware of the nature of types and be
    deliberate about using them. I’ll start by talking about what a type actually
    is and why that matters. I’ll then move on to how the Python language’s decisions
    about its type system affects the robustness of your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: What’s in a Type?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I want you to pause and answer a question: without mentioning numbers, strings,
    text, or Booleans, how would you explain what a type is?'
  prefs: []
  type: TYPE_NORMAL
- en: It’s not a simple answer for everyone. It’s even harder to explain what the
    benefits are, especially in a language like Python where you do not have to explicitly
    declare types of variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'I consider a type to have a very simple definition: a communication method.
    Types convey information. They provide a representation that users and computers
    can reason about. I break the representation down into two different facets:'
  prefs: []
  type: TYPE_NORMAL
- en: Mechanical representation
  prefs: []
  type: TYPE_NORMAL
- en: Types communicate behaviors and constraints to the Python language itself.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic representation
  prefs: []
  type: TYPE_NORMAL
- en: Types communicate behaviors and constraints to other developers.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go learn a little more about each representation.
  prefs: []
  type: TYPE_NORMAL
- en: Mechanical Representation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At its core, computers are all about binary code. Your processor doesn’t speak
    Python; all it sees is the presence or absence of electrical current on circuits
    going through it. Same goes for what’s in your computer memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose your memory looked like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Looks like a bunch of gibberish. Let’s zoom in on the middle part there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no way to tell exactly what this number means by itself. Depending
    on computer architecture it is plausible that this could represent the number
    5259604 or 5521744\. It could also be the string “PAT.” Without any sort of context,
    you can’t know for certain. This is why Python needs types. Type information gives
    Python what it needs to know to make sense of all the ones and zeroes. Let’s see
    it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I am running CPython 3.9.0 on a little-endian machine, so if you see different
    results, don’t worry, there are subtle things that can change your answers. (This
    code is not guaranteed to run on other Python implementations such as Jython or
    PyPy.)
  prefs: []
  type: TYPE_NORMAL
- en: These hex strings display the contents of the memory containing a Python object.
    You’ll find pointers to the next and previous object in a linked list (for garbage
    collection purposes), a reference count, a type, and the actual data itself. You
    can see the bytes at the end of each returned value to see the number or string
    (look for the bytes `0x544150` or `0x504154`). The important part of this is that
    there is a type encoded into that memory. When Python looks at a variable, it
    knows exactly what type everything is at runtime (just as when you use the `type()`
    function.)
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s easy to think that this is the only reason for types—the computer needs
    to know how to interpret various blobs of memory. It is important to be aware
    of how Python uses types, as it has some implications for writing robust code,
    but even more important is the second representation: semantic representation.'
  prefs: []
  type: TYPE_NORMAL
- en: Semantic Representation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the first definition of types is great for lower-level programming, it’s
    the second definition that applies to every developer. Types, in addition to having
    a mechanical representation, also manifest a semantic representation. A semantic
    representation is a communication tool; the types you choose communicate information
    across time and space to a future developer.
  prefs: []
  type: TYPE_NORMAL
- en: Types tell a user what behaviors they can expect when interacting with that
    entity. In this context, “behaviors” are the operations that you associate with
    that type (plus any preconditions or postconditions). They are the boundaries,
    constraints, and freedoms that a user interacts with whenever they use that type.
    Types used correctly have low barriers to understanding; they become natural to
    use. Conversely, types used poorly are a hindrance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the lowly `int`. Take a minute to think about what behaviors an integer
    has in Python. Here’s a quick (noncomprehensive) list I came up with:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructible from integers, floats, or strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mathematical operations such as addition, subtraction, division, multiplication,
    exponentiation, and negation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational comparison such as <, >, ==, and !=
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitwise operations (manipulating individual bits of a number) such as &, |,
    ^, ~, and shifting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convertible to a string using `str` or `repr` functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Able to be rounded through `ceil`, `floor`, and `round` methods (even though
    they return the integer itself, these are supported methods)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `int` has many behaviors. You can view the full list if you if you type `help(int)`
    into your interactive Python console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider a `datetime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A `datetime` is not that different from an `int`. Typically, it’s represented
    as a number of seconds or milliseconds from some epoch of time (such as January
    1, 1970). But think about the behaviors a `datetime` has (I’ve italicized the
    differences in behavior from an integer):'
  prefs: []
  type: TYPE_NORMAL
- en: Constructible from a *string, or a set of integers representing day/month/year/etc*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mathematical operations such as addition and subtraction of *time deltas*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*No bitwise operations available*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convertible to a string using `str` or `repr` functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Is not* able to be rounded through `ceil`, `floor`, or `round` methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `datetime` supports addition and subtraction, but not of other datetimes.
    We only add time deltas (such as adding a day or subtracting a year). Multiplying
    and dividing really don’t make sense for a `datetime`. Similarly, rounding dates
    is not a supported operation in the standard library. However, `datetime`s do
    offer comparison and string formatting operations with similar semantics to an
    integer. So even though `datetime` is at heart an integer, it contains a constrained
    subset of operations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '*Semantics* refers to the meaning of an operation. While `str(int)` and `str(datetime.datetime.now())`
    will return differently formatted strings, the meaning is the same: I am creating
    a string from a value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Datetimes also support their own behaviors, to further distinguish them from
    integers. These include:'
  prefs: []
  type: TYPE_NORMAL
- en: Changing values based on time zones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being able to control the format of strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding what weekday it is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, if you’d like a full list of behaviors, type `import datetime; help(date⁠time.datetime)`
    into your REPL.
  prefs: []
  type: TYPE_NORMAL
- en: A `datetime` is more specific than an `int`. It conveys a more specific use
    case than just a plain old number. When you choose to use a more specific type,
    you are telling future contributors that there are operations that are possible
    and constraints to be aware of that aren’t present in the less specific type.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive into how this ties into robust code. Say you inherit a codebase that
    handles the opening and closing of a completely automated kitchen. You need to
    add in functionality to be able to change closing time (say, for extending a kitchen’s
    hours on holidays).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You know you need to be operating on `point_in_time`, but how do you get started?
    What type are you even dealing with? Is it a `str`, `int`, `datetime`, or some
    custom class? What operations are you allowed to perform on `point_in_time`? You
    didn’t write this code, and you have no history with it. The same problems exist
    if you want to call the code as well. You have no idea what is legal to pass into
    this function.
  prefs: []
  type: TYPE_NORMAL
- en: If you make an incorrect assumption one way or the other, and that code makes
    it to production, you will have made the code less robust. Maybe that code doesn’t
    lie on a codepath that is executed often. Maybe some other bug is hiding this
    code from being run. Maybe there aren’t a whole lot of tests around this piece
    of code, and it becomes a runtime error later on. No matter what, there is a bug
    lurking in the code, and you’ve decreased maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Responsible developers do their best not to have bugs hit production. They
    will search for tests, documentation (with a grain of salt, of course—documentation
    can go out of date quickly), or calling code. They will look at `closing_time()`
    and `log_time_closed()` to see what types they expect or provide, and plan accordingly.
    This is a correct path in this case, but I still consider it a suboptimal path.
    While an error won’t reach production, they are still expending time in looking
    through the code, which prevents value from being delivered as quickly. With such
    a small example, you would be forgiven for thinking that this isn’t that big a
    problem if it happens once. But beware of death by a thousand cuts: any one slice
    isn’t too detrimental on its own, but thousands piled up and strewn across a codebase
    will leave you limping along, trying to deliver code.'
  prefs: []
  type: TYPE_NORMAL
- en: The root cause is that the semantic representation was not clear for the parameter.
    As you write code, do what you can to express your intent through types. You can
    do it as a comment where needed, but I recommend using type annotations (supported
    in Python 3.5+) to explain parts of your code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'All I need to do is put in a `: <type>` after my parameters. Most code examples
    in this book will utilize type annotations to make it clear what type the code
    expects.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, as developers come across this code, they will know what’s expected of
    `point_in_time`. They don’t have to look through other methods, tests, or documentation
    to know how to manipulate the variable. They have a crystal clear clue on what
    to do, and they can get right to work performing the modifications they need to
    do. You are conveying semantic representation to future developers, without ever
    directly talking to them.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, as developers use a type more and more, they become familiar with
    it. They won’t need to look up documentation or `help()` to use that type when
    they come across it. You begin to create a vocabulary of well-known types across
    your codebase. This lessens the burden of maintenance. When a developer is modifying
    existing code, they want to focus on the changes they need to make without getting
    bogged down.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic representation of a type is extremely important, and the rest of [Part I](part0004.html#part_1)
    will be dedicated to covering how you can use types to your advantage. Before
    I move on, though, I need to walk through some fundamental structural elements
    of Python as a language, and how they impact codebase robustness.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion Topic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Think about types used in your codebase. Pick a few and ask yourself what their
    semantic representations are. Enumerate their constraints, use cases, and behaviors.
    Could you be using these types in more places? Are there places where you are
    misusing types?
  prefs: []
  type: TYPE_NORMAL
- en: Typing Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed earlier in the chapter, a type system aims to give a user some
    way to model the behaviors and constraints in the language. Programming languages
    set expectations about how their specific type systems work, both during code
    construction and runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Strong Versus Weak
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Typing systems are classified on a spectrum from weak to strong. Languages toward
    the stronger side of the spectrum tend to restrict the use of operations to the
    types that support them. In other words, if you break the semantic representation
    of the type, you are told (sometimes quite loudly) through a compiler error or
    a runtime error. Languages such as Haskell, TypeScript, and Rust are all considered
    strongly typed. Proponents advocate strongly typed languages because errors are
    more apparent when building or running code.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, languages toward the weaker side of the spectrum will not restrict
    the use of operations to the types that support them. Types are often coerced
    into a different type to make sense of an operation. Languages such as JavaScript,
    Perl, and older versions of C are weakly typed. Proponents advocate the speed
    with which developers can quickly iterate on code without fighting language along
    the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python falls toward the stronger side of the spectrum. There are very few implicit
    conversions that happen between types. It is noticeable when you perform illegal
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Contrast that with a weakly typed language, such as JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In terms of robustness, a strongly typed language such as Python certainly helps
    us out. While errors still will show up at runtime instead of at development time,
    they still will show up in an obvious `TypeError` exception. This reduces the
    time taken to debug issues significantly, again allowing you to deliver incremental
    value more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Are Weakly Typed Languages Inherently Not Robust?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Codebases in weakly typed languages can absolutely be robust; by no means am
    I dumping on those languages. Consider the sheer amount of production-grade JavaScript
    that the world runs on. However, a weakly typed language requires extra care to
    be robust. It’s easy to mistake the type of a variable and make incorrect assumptions.
    Developers come to rely very heavily on linters, tests, and other tools to improve
    maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Versus Static
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is another typing spectrum I need to discuss: static versus dynamic typing.
    This is fundamentally a difference in handling mechanical representation of types.'
  prefs: []
  type: TYPE_NORMAL
- en: Languages that offer static typing embed their typing information in variables
    during build time. Developers may explicitly add type information to variables,
    or some tool such as a compiler infers types for the developer. Variables do not
    change their type at runtime (hence, “static”). Proponents of static typing tout
    the ability to write safe code out of the gate and to benefit from a strong safety
    net.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic typing, on the other hand, embeds type information with the value or
    variable itself. Variables can change types at runtime quite easily, because there
    is no type information tied to that variable. Proponents of dynamic typing advocate
    the flexibility and speed that it takes to develop; there’s nowhere near as much
    fighting with compilers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python is a dynamically typed language. As you saw during the discussion about
    mechanical representation, there was type information embedded inside the values
    of a variable. Python has no qualms about changing the type of a variable at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, the ability to change types at runtime is a hindrance to robust
    code in many cases. You cannot make strong assumptions about a variable throughout
    its lifetime. As assumptions are broken, it’s easy to write unstable assumptions
    on top of them, leading to a ticking logic bomb in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Are Dynamically Typed Languages Inherently Not Robust?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like weakly typed languages, it is still absolutely possible to write robust
    code in a dynamically typed language. You just have to work a little harder for
    it. You will have to make more deliberate decisions to make your codebase more
    maintainable. On the flip side, being statically typed doesn’t guarantee robustness
    either; one can do the bare minimum with types and see little benefit.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things worse, the type annotations I showed earlier have no effect
    on this behavior at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: No errors, no warnings, no anything. But hope is not lost, and you have plenty
    of strategies to make code more robust (otherwise, this would be quite the short
    book). We will discuss one last thing as a contributor to robust code, and then
    start diving into the meat of improving our codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Duck Typing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is perhaps an unwritten law that whenever someone mentions duck typing,
    someone must reply with:'
  prefs: []
  type: TYPE_NORMAL
- en: If it walks like a duck and it quacks like a duck, then it must be a duck.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: My problem with this saying is that I find it completely unhelpful for explaining
    what duck typing actually is. It’s catchy, concise, and, crucially, only comprehensible
    to those who already understand duck typing. When I was younger, I just nodded
    politely, afraid that I was missing something profound in this simple phrase.
    It wasn’t until later on that I truly understood the power of duck typing.
  prefs: []
  type: TYPE_NORMAL
- en: '*Duck typing* is the ability to use objects and entities in a programming language
    as long as they adhere to some interface. It is a wonderful thing in Python, and
    most people use it without even knowing it. Let’s look at a simple example to
    illustrate what I’m talking about:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In all three invocations of `print_items`, we loop through the collection and
    print each item. Think about how this works. `print_items` has absolutely no knowledge
    of what type it will receive. It just receives a type at runtime and operates
    upon it. It’s not introspecting each argument and deciding to do different things
    based on the type. The truth is much simpler. Instead, all `print_items` is doing
    is checking that whatever is passed in can be iterated upon (by calling an `__iter__`
    method). If the attribute `__iter__` exists, it’s called and the returned iterator
    is looped over.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can verify this with a simple code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Duck typing is what makes this possible. As long as a type supports the variables
    and methods used by a function, you can use that type in that function freely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It doesn’t matter that we’re passing an integer in one place or a string in
    another; both support the + operator, so either will work just fine. Any object
    that supports the + operator can be passed in. We can even do it with a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: So how does this play into robustness? It turns out that duck typing is a double-edged
    sword. It can increase robustness because it increases composability (we’ll learn
    more about composability in [Chapter 17](part0022_split_000.html#composability)).
    Building up a library of solid abstractions able to handle a multitude of types
    lessens the need for complex special cases. However, if duck typing is overused,
    you start to break down assumptions that a developer can rely upon. When updating
    code, it’s not simple enough to just make the changes; you must look at all calling
    code and make sure that the types passed into your function satisfy your new changes
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all this in mind, it might be best to reword the idiom earlier in this
    section as such:'
  prefs: []
  type: TYPE_NORMAL
- en: If it walks like a duck and quacks like a duck, and you are looking for things
    that walk and quack like ducks, then you can treat it as if it were a duck.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Doesn’t roll off the tongue as well, does it?
  prefs: []
  type: TYPE_NORMAL
- en: Discussion Topic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do you use duck typing in your codebase? Are there places where you can pass
    in types that don’t match what the code is looking for, but things still work?
    Do you think these increase or decrease robustness for your use cases?
  prefs: []
  type: TYPE_NORMAL
- en: Closing Thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Types are a pillar of clean, maintainable code and serve as a communication
    tool to other developers. If you take care with types, you communicate a great
    deal, creating less burden for future maintainers. The rest of [Part I](part0004.html#part_1)
    will show you how to use types to enhance a codebase’s robustness.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, Python is dynamically and strongly typed. The strongly typed nature
    will be a boon for us; Python will notify us about errors when we use incompatible
    types. But its dynamically typed nature is something we will have to overcome
    in order to write better code. These language choices shape how Python code is
    written and you should keep them in mind as you write your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we’re going to talk about type annotations, which is how
    we can be explicit about the type we use. Type annotations serve a crucial role:
    our primary communication method of behaviors to future developers. They help
    overcome the limitations of a dynamically typed language and allow you to enforce
    intentions throughout a codebase.'
  prefs: []
  type: TYPE_NORMAL
