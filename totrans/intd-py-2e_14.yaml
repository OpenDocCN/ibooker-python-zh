- en: Chapter 12\. Wrangle and Mangle Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you torture the data enough, nature will always confess.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Ronald Coase
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Up to this point, we’ve talked mainly about the Python language itself—its data
    types, code structures, syntax, and so on. The rest of this book is about application
    of these to real-world problems.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn many practical techniques for taming data. Sometimes,
    this is called *data munging*, or the more businesslike *ETL* (extract/transform/load)
    of the database world. Although programming books usually don’t cover the topic
    explicitly, programmers spend a lot of time trying to mold data into the right
    shape for their purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The specialty called *data science* has become very popular in the past few
    years. A *Harvard Business Review* article called data scientist the “sexiest
    job of the 21st century.” If this meant in demand and well paying, then okay,
    but there’s also more than enough drudgery. Data science goes beyond the ETL requirements
    of databases, often involving *machine learning* to unearth insights that were
    not visible to human eyes.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll start with basic data formats and then work up to the most useful new tools
    for data science.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data formats fall roughly into two categories: *text* and *binary*. Python
    *strings* are used for text data, and this chapter includes string information
    that we’ve skipped so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Unicode* characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Regular expression* pattern matching.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we jump to binary data, and two more of Python’s built-in types:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Bytes* for immutable eight-bit values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Bytearrays* for mutable ones'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Text Strings: Unicode'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You saw the basics of Python strings in [Chapter 5](ch05.html#ch_strings). Now
    it’s time to really dig into Unicode.
  prefs: []
  type: TYPE_NORMAL
- en: Python 3 strings are Unicode character sequences, not byte arrays. This is,
    by far, the single largest language change from Python 2.
  prefs: []
  type: TYPE_NORMAL
- en: All of the text examples in this book thus far have been plain old ASCII (American
    Standard Code for Information Interchange). ASCII was defined in the 1960s, before
    mullets roamed the earth. Computers then were the size of refrigerators, and only
    slightly smarter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic unit of computer storage is the *byte*, which can store 256 unique
    values in its eight *bits*. For various reasons, ASCII used only seven bits (128
    unique values): 26 uppercase letters, 26 lowercase letters, 10 digits, some punctuation
    symbols, some spacing characters, and some nonprinting control codes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the world has more letters than ASCII provides. You could have
    a hot dog at a diner, but never a Gewürztraminer^([1](ch12.html#idm45794991539400))
    at a café. Many attempts have been made to cram more letters and symbols into
    eight bits, and you’ll see them at times. Just a couple of those include:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Latin-1*, or *ISO 8859-1*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows code page *1252*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these uses all eight bits, but even that’s not enough, especially when
    you need non-European languages. *Unicode* is an ongoing international standard
    to define the characters of all the world’s languages, plus symbols from mathematics
    and other fields. And emojis!
  prefs: []
  type: TYPE_NORMAL
- en: Unicode provides a unique number for every character, no matter what the platform,
    no matter what the program, no matter what the language.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Unicode Consortium
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The [Unicode Code Charts page](http://www.unicode.org/charts) has links to all
    the currently defined character sets with images. The latest version (12.0) defines
    more than 137,000 characters, each with a unique name and identification number.
    Python 3.8 handles all of these. The characters are divided into eight-bit sets
    called *planes*. The first 256 planes are the *basic multilingual planes*. See
    the Wikipedia page about [Unicode planes](http://bit.ly/unicode-plane) for details.
  prefs: []
  type: TYPE_NORMAL
- en: Python 3 Unicode Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you know the Unicode ID or name for a character, you can use it in a Python
    string. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: A `\u` followed by *four* hex numbers^([2](ch12.html#idm45794991521032)) specifies
    a character in one of Unicode’s 256 basic multilingual planes. The first two are
    the plane number (`00` to `FF`), and the next two are the index of the character
    within the plane. Plane `00` is good old ASCII, and the character positions within
    that plane are the same as ASCII.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For characters in the higher planes, we need more bits. The Python escape sequence
    for these is `\U` followed by *eight* hex characters; the leftmost ones need to
    be `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For all characters, ``\N{*`name`*}`` lets you specify it by its standard *name*.
    The [Unicode Character Name Index page](http://www.unicode.org/charts/charindex.html)
    lists these.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Python `unicodedata` module has functions that translate in both directions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lookup()`—Takes a case-insensitive name and returns a Unicode character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name()`—Takes a Unicode character and returns an uppercase name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following example, we’ll write a test function that takes a Python Unicode
    character, looks up its name, and looks up the character again from the name (it
    should match the original character):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try some characters, beginning with a plain ASCII letter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'ASCII punctuation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A Unicode currency character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Another Unicode currency character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The only problem you could potentially run into is limitations in the font
    you’re using to display text. Few fonts have images for all Unicode characters,
    and might display some placeholder character for missing ones. For instance, here’s
    the Unicode symbol for `SNOWMAN`, like symbols in dingbat fonts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose that we want to save the word `café` in a Python string. One way is
    to copy and paste it from a file or website and hope that it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This worked because I copied and pasted from a source that used UTF-8 encoding
    (which we look at in a few pages) for its text.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we specify that final `é` character? If you look at the character index
    for [E](http://bit.ly/e-index), you see that the name `E WITH ACUTE,` `LATIN SMALL
    LETTER` has the value `00E9`. Let’s check with the `name()` and `lookup()` functions
    that we were just playing with. First give the code to get the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, give the name to look up the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The names listed on the Unicode Character Name Index page were reformatted
    to make them sort nicely for display. To convert them to their real Unicode names
    (the ones that Python uses), remove the comma and move the part of the name that
    was after the comma to the beginning. Accordingly, change `E WITH ACUTE, LATIN
    SMALL LETTER` to `LATIN SMALL LETTER E WITH ACUTE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can specify the string `café` by code or by name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we inserted the é directly in the string, but we
    can also build a string by appending:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The string `len()` function counts Unicode *characters*, not bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you know the Unicode numeric ID, you can use the standard `ord()` and `chr()`
    functions to quickly convert between integer IDs and single-character Unicode
    strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: UTF-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You don’t need to worry about how Python stores each Unicode character when
    you do normal string processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, when you exchange data with the outside world, you need a couple of
    things:'
  prefs: []
  type: TYPE_NORMAL
- en: A way to *encode* character strings to bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A way to *decode* bytes to character strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there were fewer than 65,536 characters in Unicode, we could stuff each Unicode
    character ID into two bytes. Unfortunately, there are more. We could encode every
    ID into four bytes, but that would increase the memory and disk storage space
    needs for common text strings by four times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ken Thompson and Rob Pike, whose names will be familiar to Unix developers,
    designed the *UTF-8* dynamic encoding scheme one night on a placemat in a New
    Jersey diner. It uses one to four bytes per Unicode character:'
  prefs: []
  type: TYPE_NORMAL
- en: One byte for ASCII
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two bytes for most Latin-derived (but not Cyrillic) languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three bytes for the rest of the basic multilingual plane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Four bytes for the rest, including some Asian languages and symbols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UTF-8 is the standard text encoding in Python, Linux, and HTML. It’s fast, complete,
    and works well. If you use UTF-8 encoding throughout your code, life will be much
    easier than trying to hop in and out of various encodings.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you create a Python string by copying and pasting from another source such
    as a web page, be sure the source is encoded in the UTF-8 format. It’s *very*
    common to see text that was encoded as Latin-1 or Windows 1252 copied into a Python
    string, which causes an exception later with an invalid byte sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Encode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You *encode* a *string* to *bytes*. The string `encode()` function’s first argument
    is the encoding name. The choices include those presented in [Table 12-1](#table_12-1).
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-1\. Encodings
  prefs: []
  type: TYPE_NORMAL
- en: '| Encoding name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `''ascii''` | Good old seven-bit ASCII |'
  prefs: []
  type: TYPE_TB
- en: '| `''utf-8''` | Eight-bit variable-length encoding, and what you almost always
    want to use |'
  prefs: []
  type: TYPE_TB
- en: '| `''latin-1''` | Also known as ISO 8859-1 |'
  prefs: []
  type: TYPE_TB
- en: '| `''cp-1252''` | A common Windows encoding |'
  prefs: []
  type: TYPE_TB
- en: '| `''unicode-escape''` | Python Unicode literal format, `\u`*xxxx* or `\U`*xxxxxxxx*
    |'
  prefs: []
  type: TYPE_TB
- en: 'You can encode anything as UTF-8. Let’s assign the Unicode string `''\u2603''`
    to the name `snowman`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`snowman` is a Python Unicode string with a single character, regardless of
    how many bytes might be needed to store it internally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s encode this Unicode character to a sequence of bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As I mentioned earlier, UTF-8 is a variable-length encoding. In this case,
    it used three bytes to encode the single `snowman` Unicode character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, `len()` returns the number of bytes (3) because `ds` is a `bytes` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use encodings other than UTF-8, but you’ll get errors if the Unicode
    string can’t be handled by the encoding. For example, if you use the `ascii` encoding,
    it will fail unless your Unicode characters happen to be valid ASCII characters,
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `encode()` function takes a second argument to help you avoid encoding
    exceptions. Its default value, which you can see in the previous example, is `''strict''`;
    it raises a `UnicodeEncodeError` if it sees a non-ASCII character. There are other
    encodings. Use `''ignore''` to throw away anything that won’t encode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `''replace''` to substitute `?` for unknown characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `''backslashreplace''` to produce a Python Unicode character string, like
    `unicode-escape`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You would use this if you needed a printable version of the Unicode escape sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `''xmlcharrefreplace''` to make HTML-safe strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: I provide more details on HTML conversion in [“HTML Entities”](#html_entities).
  prefs: []
  type: TYPE_NORMAL
- en: Decode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We *decode* byte strings to Unicode text strings. Whenever we get text from
    some external source (files, databases, websites, network APIs, and so on), it’s
    encoded as byte strings. The tricky part is knowing which encoding was actually
    used, so we can *run it backward* and get Unicode strings.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that nothing in the byte string itself says what encoding was
    used. I mentioned the perils of copying and pasting from websites earlier. You’ve
    probably visited websites with odd characters where plain old ASCII characters
    should be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a Unicode string called `place` with the value `''café''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Encode it in UTF-8 format in a `bytes` variable called `place_bytes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that `place_bytes` has five bytes. The first three are the same as ASCII
    (a strength of UTF-8), and the final two encode the `''é''`. Now let’s decode
    that byte string back to a Unicode string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This worked because we encoded to UTF-8 and decoded from UTF-8. What if we told
    it to decode from some other encoding?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The ASCII decoder threw an exception because the byte value `0xc3` is illegal
    in ASCII. There are some 8-bit character set encodings in which values between
    128 (hex `80`) and 255 (hex `FF`) are legal but not the same as UTF-8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Urk.
  prefs: []
  type: TYPE_NORMAL
- en: 'The moral of this story: whenever possible, use UTF-8 encoding. It works, is
    supported everywhere, can express every Unicode character, and is quickly decoded
    and encoded.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Even though you can specify any Unicode character, that doesn’t mean that your
    computer will display all of them. That depends on the *font* that you’re using,
    which may display nothing or some fill-in image for many characters. Apple created
    the [Last Resort Font](https://oreil.ly/q5EZD) for the Unicode Consortium, and
    uses it in its own operating systems. This [Wikipedia page](https://oreil.ly/Zm_uZ)
    has a few more details. Another font with everything between `\u0000` and `\uffff`,
    and a few more, is [Unifont](https://oreil.ly/APKlj).
  prefs: []
  type: TYPE_NORMAL
- en: HTML Entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python 3.4 added another way to convert to and from Unicode but using HTML
    *character entities*.^([3](ch12.html#idm45794990473800)) This may be easier to
    use than looking up Unicode names, especially if you’re working on the web:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This conversion also works with numbered entities, decimal or hex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even import the named entity translations as a dictionary and do the
    conversion yourself. Drop the initial `''&''` for the dictionary key (you can
    also drop the final `'';''`, but it seems to work either way):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To go the other direction (from a single Python Unicode character to an HTML
    entity name), first get the decimal value of the character with `ord()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'For Unicode strings with more than one character, use this two-step conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The expression `place.encode('ascii', 'xmlcharrefreplace')` returned ASCII characters
    but as type `bytes` (because it *en*coded). The following `byte_value.decode()`
    is needed to convert `byte_value` to an HTML-compatible string.
  prefs: []
  type: TYPE_NORMAL
- en: Normalization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some Unicode characters can be represented by more than one Unicode encoding.
    They’ll look the same, but won’t compare the same because they have different
    internal byte sequences. For example, take the acute accented `''é''` in `''café''`.
    Let’s make a single-character `''é''` in multiple ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Try a few sanity checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s make an accented `e` by combining a plain `e` with an acute accent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We built a Unicode character from two characters, and it looks the same as
    the original `''é''`. But as they say on Sesame Street, one of these things is
    not like the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If you had two different Unicode text strings from different sources, one using
    `eacute1` and another `eacute_combined1`, they would appear the same, but would
    mysteriously not act the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can fix this with the `normalize()` function in the `unicodedata` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: That `'NFC'` means *normal form, composed*.
  prefs: []
  type: TYPE_NORMAL
- en: For More Information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you would like to learn more about Unicode, these links are particularly
    helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Unicode HOWTO](http://bit.ly/unicode-howto)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Pragmatic Unicode](http://bit.ly/pragmatic-uni)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Absolute Minimum Every Software Developer Absolutely, Positively Must
    Know About Unicode and Character Sets (No Excuses!)](http://bit.ly/jspolsky)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Text Strings: Regular Expressions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.html#ch_strings) discussed simple string operations. Armed
    with that introductory information, you’ve probably used simple “wildcard” patterns
    on the command line, such as the UNIX command `ls *.py`, which means *list all
    filenames ending in .py*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s time to explore more complex pattern matching by using *regular expressions*.
    These are provided in the standard module `re`, which we’ll import. You define
    a string *pattern* that you want to match, and the *source* string to match against.
    For simple matches, usage looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, `'You'` is the *pattern* we’re looking for, and `'Young Frankenstein'`
    is the *source* (the string we want to search). `match()` checks whether the *source*
    begins with the *pattern*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more complex matches, you can *compile* your pattern first to speed up
    the match later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can perform your match against the compiled pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Because this is a common Python gotcha, I’ll say it again here: `match()` only
    matches a pattern starting at the *beginning* of the source. `search()` matches
    a pattern *anywhere* in the source.'
  prefs: []
  type: TYPE_NORMAL
- en: '`match()` is not the only way to compare the pattern and source. Here are several
    other methods you can use (we discuss each in the following sections):'
  prefs: []
  type: TYPE_NORMAL
- en: '`search()` returns the first match, if any.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findall()` returns a list of all non-overlapping matches, if any.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`split()` splits *source* at matches with *pattern* and returns a list of the
    string pieces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sub()` takes another *replacement* argument, and changes all parts of *source*
    that are matched by *pattern* to *replacement*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Most of the regular expression examples here use ASCII, but Python’s string
    functions, including regular expressions, work with any Python string and any
    Unicode characters.
  prefs: []
  type: TYPE_NORMAL
- en: Find Exact Beginning Match with match()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Does the string `''Young Frankenstein''` begin with the word `''You''`? Here’s
    some code with comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: How about `'Frank'`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This time, `match()` returned nothing, so the `if` did not run the `print` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I mentioned in [“New: I Am the Walrus”](ch04.html#walrus), in Python 3.8
    you can shorten this example with the so-called *walrus operator*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, now let’s use `search()` to see whether `''Frank''` is anywhere in the
    source string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s change the pattern and try a beginning match with `match()` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a brief explanation of how our new `''.*Frank''` pattern works:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.` means *any single character*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` means *zero or more of the preceding thing*. Together, `.*` mean *any number
    of characters* (even zero).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Frank` is the phrase that we wanted to match, somewhere.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`match()` returned the string that matched `.*Frank`: `''Young Frank''`.'
  prefs: []
  type: TYPE_NORMAL
- en: Find First Match with search()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use `search()` to find the pattern `''Frank''` anywhere in the source
    string `''Young Frankenstein''`, without the need for the `.*` wildcards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Find All Matches with findall()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding examples looked for one match only. But what if you want to know
    how many instances of the single-letter string `'n'` are in the string?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: How about `'n'` followed by any character?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that it did not match that final `''n''`. We need to say that the character
    after `''n''` is optional, with `?`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Split at Matches with split()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next example shows you how to split a string into a list by a pattern rather
    than a simple string (as the normal string `split()` method would do):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Replace at Matches with sub()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is like the string `replace()` method, but for patterns rather than literal
    strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Patterns: Special Characters'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many descriptions of regular expressions start with all the details of how to
    define them. I think that’s a mistake. Regular expressions are a not-so-little
    language in their own right, with too many details to fit in your head at once.
    They use so much punctuation that they look like cartoon characters swearing.
  prefs: []
  type: TYPE_NORMAL
- en: With these expressions (`match()`, `search()`, `findall()`, and `sub()`) under
    your belt, let’s get into the details of building them. The patterns you make
    apply to any of these functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve seen the basics:'
  prefs: []
  type: TYPE_NORMAL
- en: Literal matches with any nonspecial characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any single character except `\n` with `.`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any number of the preceding character (including zero) with `*`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional (zero or one) of the preceding character with `?`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, special characters are shown in [Table 12-2](#specialchartable).
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-2\. Special characters
  prefs: []
  type: TYPE_NORMAL
- en: '| Pattern | Matches |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `\d` | A single digit |'
  prefs: []
  type: TYPE_TB
- en: '| `\D` | A single nondigit |'
  prefs: []
  type: TYPE_TB
- en: '| `\w` | An alphanumeric character |'
  prefs: []
  type: TYPE_TB
- en: '| `\W` | A non-alphanumeric character |'
  prefs: []
  type: TYPE_TB
- en: '| `\s` | A whitespace character |'
  prefs: []
  type: TYPE_TB
- en: '| `\S` | A nonwhitespace character |'
  prefs: []
  type: TYPE_TB
- en: '| `\b` | A word boundary (between a `\w` and a `\W`, in either order) |'
  prefs: []
  type: TYPE_TB
- en: '| `\B` | A nonword boundary |'
  prefs: []
  type: TYPE_TB
- en: 'The Python `string` module has predefined string constants that we can use
    for testing. Let’s use `printable`, which contains 100 printable ASCII characters,
    including letters in both cases, digits, space characters, and punctuation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Which characters in `printable` are digits?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Which characters are digits, letters, or an underscore?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Which are spaces?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In order, those were: plain old space, tab, newline, carriage return, vertical
    tab, and form feed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Regular expressions are not confined to ASCII. A `\d` will match whatever Unicode
    calls a digit, not just ASCII characters `''0''` through `''9''`. Let’s add two
    non-ASCII lowercase letters from [FileFormat.info](http://bit.ly/unicode-letter):'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this test, we’ll throw in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Three ASCII letters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three punctuation symbols that should *not* match a `\w`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Unicode *LATIN SMALL LETTER E WITH CIRCUMFLEX* (\u00ea)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Unicode *LATIN SMALL LETTER E WITH BREVE* (\u0115)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, this pattern found only the letters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Patterns: Using Specifiers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s make “punctuation pizza,” using the main pattern specifiers for regular
    expressions, which are presented in [Table 12-3](#table_12-4).
  prefs: []
  type: TYPE_NORMAL
- en: In the table, *expr* and the other italicized words mean any valid regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-3\. Pattern specifiers
  prefs: []
  type: TYPE_NORMAL
- en: '| Pattern | Matches |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `abc` | Literal `abc` |'
  prefs: []
  type: TYPE_TB
- en: '| `(` *expr* `)` | *expr* |'
  prefs: []
  type: TYPE_TB
- en: '| *expr1* `&#124;` *expr2* | *expr1* or *expr2* |'
  prefs: []
  type: TYPE_TB
- en: '| `.` | Any character except `\n` |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Start of source string |'
  prefs: []
  type: TYPE_TB
- en: '| `$` | End of source string |'
  prefs: []
  type: TYPE_TB
- en: '| *prev* `?` | Zero or one *prev* |'
  prefs: []
  type: TYPE_TB
- en: '| *prev* `*` | Zero or more *prev*, as many as possible |'
  prefs: []
  type: TYPE_TB
- en: '| *prev* `*?` | Zero or more *prev*, as few as possible |'
  prefs: []
  type: TYPE_TB
- en: '| *prev* `+` | One or more *prev*, as many as possible |'
  prefs: []
  type: TYPE_TB
- en: '| *prev* `+?` | One or more *prev*, as few as possible |'
  prefs: []
  type: TYPE_TB
- en: '| *prev* `{` *m* `}` | *m* consecutive *prev* |'
  prefs: []
  type: TYPE_TB
- en: '| *prev* `{` *m*, *n* `}` | *m* to *n* consecutive *prev*, as many as possible
    |'
  prefs: []
  type: TYPE_TB
- en: '| *prev* `{` *m*, *n* `}?` | *m* to *n* consecutive *prev*, as few as possible
    |'
  prefs: []
  type: TYPE_TB
- en: '| `[` *abc* `]` | `a` or `b` or `c` (same as `a&#124;b&#124;c`) |'
  prefs: []
  type: TYPE_TB
- en: '| `[^` *abc* `]` | *not* (`a` or `b` or `c`) |'
  prefs: []
  type: TYPE_TB
- en: '| *prev* `(?=` *next* `)` | *prev* if followed by *next* |'
  prefs: []
  type: TYPE_TB
- en: '| *prev* `(?!` *next* `)` | *prev* if *not* followed by *next* |'
  prefs: []
  type: TYPE_TB
- en: '| `(?<=` *prev* `)` *next* | *next* if preceded by *prev* |'
  prefs: []
  type: TYPE_TB
- en: '| `(?<!` *prev* `)` *next* | *next* if *not* preceded by *prev* |'
  prefs: []
  type: TYPE_TB
- en: 'Your eyes might cross permanently when trying to read these examples. First,
    let’s define our source string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Now we apply different regular expression pattern strings to try to match something
    in the `source` string.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the following examples, I use plain quoted strings for the patterns. A little
    later in this section I show how a raw pattern string (`r` before the initial
    quote) helps avoid some conflicts between Python’s normal string escapes and regular
    expression ones. So, to be safest, the first argument in all the following examples
    should actually be a raw string.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, find `wish` anywhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, find `wish` or `fish` anywhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Find `wish` at the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Find `I wish` at the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Find `fish` at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, find `fish tonight.` at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The characters `^` and `$` are called *anchors*: `^` anchors the search to
    the beginning of the search string, and `$` anchors it to the end. `.$` matches
    any character at the end of the line, including a period, so that worked. To be
    more precise, we should escape the dot to match it literally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Begin by finding `w` or `f` followed by `ish`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Find one or more runs of `w`, `s`, or `h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Find `ght` followed by a non-alphanumeric:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Find `I` followed by `wish`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'And last, `wish` preceded by `I`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'I mentioned earlier that there are a few cases in which the regular expression
    pattern rules conflict with the Python string rules. The following pattern should
    match any word that begins with `fish`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Why doesn’t it? As is discussed in [Chapter 5](ch05.html#ch_strings), Python
    employs a few special *escape characters* for strings. For example, `\b` means
    backspace in strings, but in the mini-language of regular expressions it means
    the beginning of a word. Avoid the accidental use of escape characters by using
    Python’s *raw strings* when you define your regular expression string. Always
    put an `r` character before your regular expression pattern string, and Python
    escape characters will be disabled, as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Patterns: Specifying match() Output'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using `match()` or `search()`, all matches are returned from the result
    object `m` as `m.group()`. If you enclose a pattern in parentheses, the match
    will be saved to its own group, and a tuple of them will be available as `m.groups()`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use this pattern `(?P<` *`name`* `>` *`expr`* `)`, it will match *`expr`*,
    saving the match in group *`name`*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Binary Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Text data can be challenging, but binary data can be, well, interesting. You
    need to know about concepts such as *endianness* (how your computer’s processor
    breaks data into bytes) and *sign bits* for integers. You might need to delve
    into binary file formats or network packets to extract or even change data. This
    section shows you the basics of binary data wrangling in Python.
  prefs: []
  type: TYPE_NORMAL
- en: bytes and bytearray
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python 3 introduced the following sequences of eight-bit integers, with possible
    values from 0 to 255, in two types:'
  prefs: []
  type: TYPE_NORMAL
- en: '*bytes* is immutable, like a tuple of bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*bytearray* is mutable, like a list of bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Beginning with a list called `blist`, this next example creates a `bytes` variable
    called `the_bytes` and a `bytearray` variable called `the_byte_array`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The representation of a `bytes` value begins with a `b` and a quote character,
    followed by hex sequences such as `\x02` or ASCII characters, and ends with a
    matching quote character. Python converts the hex sequences or ASCII characters
    to little integers, but shows byte values that are also valid ASCII encodings
    as ASCII characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'This next example demonstrates that you can’t change a `bytes` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'But a `bytearray` variable is mellow and mutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these would create a 256-element result, with values from 0 to 255:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'When printing `bytes` or `bytearray` data, Python uses `\x`*`xx`* for nonprintable
    bytes and their ASCII equivalents for printable ones (plus some common escape
    characters, such as `\n` instead of `\x0a`). Here’s the printed representation
    of `the_bytes` (manually reformatted to show 16 bytes per line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: This can be confusing, because they’re bytes (teeny integers), not characters.
  prefs: []
  type: TYPE_NORMAL
- en: Convert Binary Data with struct
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you’ve seen, Python has many tools for manipulating text. Tools for binary
    data are much less prevalent. The standard library contains the `struct` module,
    which handles data similar to *structs* in C and C++. Using `struct`, you can
    convert binary data to and from Python data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how this works with data from a PNG file—a common image format that
    you’ll see along with GIF and JPEG files. We’ll write a small program that extracts
    the width and height of an image from some PNG data.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the O’Reilly logo—the little bug-eyed tarsier shown in [Figure 12-1](#fig_12-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![inp2 1201](assets/inp2_1201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-1\. The O’Reilly tarsier
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The PNG file for this image is available on [Wikipedia](http://bit.ly/orm-logo).
    I don’t show how to read files until [Chapter 14](ch14.html#ch_files), so I downloaded
    this file, wrote a little program to print its values as bytes, and just typed
    the values of the first 30 bytes into a Python `bytes` variable called `data`
    for the example that follows. (The PNG format specification says that the width
    and height are stored within the first 24 bytes, so we don’t need more than that
    for now.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what this code does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`data` contains the first 30 bytes from the PNG file. To fit on the page, I
    joined two byte strings with `+` and the continuation character (`\`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`valid_png_header` contains the eight-byte sequence that marks the start of
    a valid PNG file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`width` is extracted from bytes 16–19, and `height` from bytes 20–23.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `>LL` is the format string that instructs `unpack()` how to interpret its
    input byte sequences and assemble them into Python data types. Here’s the breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: The `>` means that integers are stored in *big-endian* format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each `L` specifies a four-byte unsigned long integer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can examine each four-byte value directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Big-endian integers have the most significant bytes to the left. Because the
    width and height are each less than 255, they fit into the last byte of each sequence.
    You can verify that these hex values match the expected decimal values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'When you want to go in the other direction and convert Python data to bytes,
    use the `struct` `pack()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Tables [12-4](#struct_endian_table) and [12-5](#struct_specifier_table) show
    the format specifiers for `pack()` and `unpack()`.
  prefs: []
  type: TYPE_NORMAL
- en: The endian specifiers go first in the format string.
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-4\. Endian specifiers
  prefs: []
  type: TYPE_NORMAL
- en: '| Specifier | Byte order |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `<` | Little endian |'
  prefs: []
  type: TYPE_TB
- en: '| `>` | Big endian |'
  prefs: []
  type: TYPE_TB
- en: Table 12-5\. Format specifiers
  prefs: []
  type: TYPE_NORMAL
- en: '| Specifier | Description | Bytes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `x` | Skip a byte | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `b` | Signed byte | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `B` | Unsigned byte | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `h` | Signed short integer | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `H` | Unsigned short integer | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `i` | Signed integer | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| `I` | Unsigned integer | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| `l` | Signed long integer | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| `L` | Unsigned long integer | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| `Q` | Unsigned long long integer | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| `f` | Single-precision float | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| `d` | Double-precision float | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| `p` | *count* and characters | 1 + *count* |'
  prefs: []
  type: TYPE_TB
- en: '| `s` | Characters | *count* |'
  prefs: []
  type: TYPE_TB
- en: The type specifiers follow the endian character. Any specifier may be preceded
    by a number that indicates the *`count`*; `5B` is the same as `BBBBB`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use a *`count`* prefix instead of `>LL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'We used the slice `data[16:24]` to grab the interesting bytes directly. We
    could also use the `x` specifier to skip the uninteresting parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'This means:'
  prefs: []
  type: TYPE_NORMAL
- en: Use big-endian integer format (`>`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skip 16 bytes (`16x`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read eight bytes—two unsigned long integers (`2L`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skip the final six bytes (`6x`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other Binary Data Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some third-party open source packages offer the following, more-declarative
    ways of defining and extracting binary data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[bitstring](http://bit.ly/py-bitstring)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[construct](http://bit.ly/py-construct)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[hachoir](https://pypi.org/project/hachoir)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[binio](http://spika.net/py/binio)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[kaitai struct](http://kaitai.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Appendix B](app02.html#app_install) has details on how to download and install
    external packages such as these. For the next example, you need to install `construct`.
    Here’s all you need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how to extract the PNG dimensions from our `data` bytestring by using
    `construct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Convert Bytes/Strings with binascii()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The standard `binascii` module has functions to convert between binary data
    and various string representations: hex (base 16), base 64, uuencoded, and others.
    For example, in the next snippet, let’s print that eight-byte PNG header as a
    sequence of hex values, instead of the mixture of ASCII and `\x` *xx* escapes
    that Python uses to display *bytes* variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Hey, this thing works backward, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Bit Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python provides bit-level integer operators, similar to those in the C language.
    [Table 12-6](#bit_operator_table) summarizes them and includes examples with the
    integer variables `x` (decimal `5`, binary `0b0101`) and `y` (decimal `1`, binary
    `0b0001`).
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-6\. Bit-level integer operators
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Description | Example | Decimal result | Binary result |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `&` | And | `x & y` | `1` | `0b0001` |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | Or | `x &#124; y` | `5` | `0b0101` |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Exclusive or | `x ^ y` | `4` | `0b0100` |'
  prefs: []
  type: TYPE_TB
- en: '| `~` | Flip bits | `~x` | `-6` | *binary representation depends on int size*
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<<` | Left shift | `x << 1` | `10` | `0b1010` |'
  prefs: []
  type: TYPE_TB
- en: '| `>>` | Right shift | `x >> 1` | `2` | `0b0010` |'
  prefs: []
  type: TYPE_TB
- en: These operators work something like the set operators in [Chapter 8](ch08.html#ch_dicts).
    The `&` operator returns bits that are the same in both arguments, and `|` returns
    bits that are set in either of them. The `^` operator returns bits that are in
    one or the other, but not both. The `~` operator reverses all the bits in its
    single argument; this also reverses the sign because an integer’s highest bit
    indicates its sign (`1` = negative) in *two’s complement* arithmetic, used in
    all modern computers. The `<<` and `>>` operators just move bits to the left or
    right. A left shift of one bit is the same as multiplying by two, and a right
    shift is the same as dividing by two.
  prefs: []
  type: TYPE_NORMAL
- en: A Jewelry Analogy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unicode strings are like charm bracelets, and bytes are like strands of beads.
  prefs: []
  type: TYPE_NORMAL
- en: Coming Up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next is another practical chapter: how to handle dates and times.'
  prefs: []
  type: TYPE_NORMAL
- en: Things to Do
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 12.1 Create a Unicode string called `mystery` and assign it the value `'\U0001f984'`.
    Print `mystery` and its Unicode name.
  prefs: []
  type: TYPE_NORMAL
- en: 12.2 Encode `mystery`, this time using UTF-8, into the `bytes` variable `pop_bytes`.
    Print `pop_bytes`.
  prefs: []
  type: TYPE_NORMAL
- en: 12.3 Using UTF-8, decode `pop_bytes` into the string variable `pop_string`.
    Print `pop_string`. Is `pop_string` equal to `mystery`?
  prefs: []
  type: TYPE_NORMAL
- en: 12.4 When you’re working with text, regular expressions come in very handy.
    We’ll apply them in a number of ways to our featured text sample. It’s a poem
    titled “Ode on the Mammoth Cheese,” written by James McIntyre in 1866 in homage
    to a seven-thousand-pound cheese that was crafted in Ontario and sent on an international
    tour. If you’d rather not type all of it, use your favorite search engine and
    cut and paste the words into your Python program, or just grab it from [Project
    Gutenberg](http://bit.ly/mcintyre-poetry). Call the text string `mammoth`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-1\. mammoth.txt
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 12.5 Import the `re` module to use Python’s regular expression functions. Use
    the `re.findall()` to print all the words that begin with `c`.
  prefs: []
  type: TYPE_NORMAL
- en: 12.6 Find all four-letter words that begin with `c`.
  prefs: []
  type: TYPE_NORMAL
- en: 12.7 Find all the words that end with `r`.
  prefs: []
  type: TYPE_NORMAL
- en: 12.8 Find all words that contain exactly three vowels in a row.
  prefs: []
  type: TYPE_NORMAL
- en: '12.9 Use `unhexlify` to convert this hex string (combined from two strings
    to fit on a page) to a `bytes` variable called `gif`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 12.10 The bytes in `gif` define a one-pixel transparent GIF file, one of the
    most common graphics file formats. A legal GIF starts with the ASCII characters
    *GIF89a*. Does `gif` match this?
  prefs: []
  type: TYPE_NORMAL
- en: 12.11 The pixel width of a GIF is a 16-bit little-endian integer beginning at
    byte offset 6, and the height is the same size, starting at offset 8. Extract
    and print these values for `gif`. Are they both `1`?
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch12.html#idm45794991539400-marker)) This wine has an umlaut in Germany,
    but loses it in Alsace on the way to France.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch12.html#idm45794991521032-marker)) Base 16, specified with characters
    `0`-`9` and `A`-`F`.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch12.html#idm45794990473800-marker)) See the HTML5 named-character reference
    [chart](https://oreil.ly/pmBWO).
  prefs: []
  type: TYPE_NORMAL
