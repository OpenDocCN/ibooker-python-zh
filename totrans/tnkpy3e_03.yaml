- en: 1\. Programming as a way of thinking#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://allendowney.github.io/ThinkPython/chap01.html](https://allendowney.github.io/ThinkPython/chap01.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The first goal of this book is to teach you how to program in Python. But learning
    to program means learning a new way to think, so the second goal of this book
    is to help you think like a computer scientist. This way of thinking combines
    some of the best features of mathematics, engineering, and natural science. Like
    mathematicians, computer scientists use formal languages to denote ideas – specifically
    computations. Like engineers, they design things, assembling components into systems
    and evaluating trade-offs among alternatives. Like scientists, they observe the
    behavior of complex systems, form hypotheses, and test predictions.
  prefs: []
  type: TYPE_NORMAL
- en: We will start with the most basic elements of programming and work our way up.
    In this chapter, we’ll see how Python represents numbers, letters, and words.
    And you’ll learn to perform arithmetic operations.
  prefs: []
  type: TYPE_NORMAL
- en: You will also start to learn the vocabulary of programming, including terms
    like operator, expression, value, and type. This vocabulary is important – you
    will need it to understand the rest of the book, to communicate with other programmers,
    and to use and understand virtual assistants.
  prefs: []
  type: TYPE_NORMAL
- en: 1.1\. Arithmetic operators[#](#arithmetic-operators "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An **arithmetic operator** is a symbol that represents an arithmetic computation.
    For example, the plus sign, `+`, performs addition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The minus sign, `-`, is the operator that performs subtraction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The asterisk, `*`, performs multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And the forward slash, `/`, performs division:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the result of the division is `42.0` rather than `42`. That’s because
    there are two types of numbers in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '**integers**, which represent numbers with no fractional or decimal part, and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**floating-point numbers**, which represent integers and numbers with a decimal
    point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you add, subtract, or multiply two integers, the result is an integer. But
    if you divide two integers, the result is a floating-point number. Python provides
    another operator, `//`, that performs **integer division**. The result of integer
    division is always an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Integer division is also called “floor division” because it always rounds down
    (toward the “floor”).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the operator `**` performs exponentiation; that is, it raises a number
    to a power:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In some other languages, the caret, `^`, is used for exponentiation, but in
    Python it is a bitwise operator called XOR. If you are not familiar with bitwise
    operators, the result might be unexpected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: I won’t cover bitwise operators in this book, but you can read about them at
    [http://wiki.python.org/moin/BitwiseOperators](http://wiki.python.org/moin/BitwiseOperators).
  prefs: []
  type: TYPE_NORMAL
- en: 1.2\. Expressions[#](#expressions "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A collection of operators and numbers is called an **expression**. An expression
    can contain any number of operators and numbers. For example, here’s an expression
    that contains two operators.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that exponentiation happens before addition. Python follows the order
    of operations you might have learned in a math class: exponentiation happens before
    multiplication and division, which happen before addition and subtraction.'
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, multiplication happens before addition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you want the addition to happen first, you can use parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Every expression has a **value**. For example, the expression `6 * 7` has the
    value `42`.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3\. Arithmetic functions[#](#arithmetic-functions "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the arithmetic operators, Python provides a few **functions**
    that work with numbers. For example, the `round` function takes a floating-point
    number and rounds it off to the nearest integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `abs` function computes the absolute value of a number. For a positive number,
    the absolute value is the number itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: For a negative number, the absolute value is positive.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When we use a function like this, we say we’re **calling** the function. An
    expression that calls a function is a **function call**.
  prefs: []
  type: TYPE_NORMAL
- en: When you call a function, the parentheses are required. If you leave them out,
    you get an error message.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can ignore the first line of this message; it doesn’t contain any information
    we need to understand right now. The second line is the code that contains the
    error, with a caret (`^`) beneath it to indicate where the error was discovered.
  prefs: []
  type: TYPE_NORMAL
- en: The last line indicates that this is a **syntax error**, which means that there
    is something wrong with the structure of the expression. In this example, the
    problem is that a function call requires parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if you leave out the parentheses *and* the value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: A function name all by itself is a legal expression that has a value. When it’s
    displayed, the value indicates that `abs` is a function, and it includes some
    additional information I’ll explain later.
  prefs: []
  type: TYPE_NORMAL
- en: 1.4\. Strings[#](#strings "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to numbers, Python can also represent sequences of letters, which
    are called **strings** because the letters are strung together like beads on a
    necklace. To write a string, we can put a sequence of letters inside straight
    quotation marks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It is also legal to use double quotation marks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Double quotes make it easy to write a string that contains an apostrophe, which
    is the same symbol as a straight quote.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Strings can also contain spaces, punctuation, and digits.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `+` operator works with strings; it joins two strings into a single string,
    which is called **concatenation**
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `*` operator also works with strings; it makes multiple copies of a string
    and concatenates them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The other arithmetic operators don’t work with strings.
  prefs: []
  type: TYPE_NORMAL
- en: Python provides a function called `len` that computes the length of a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `len` counts the letters between the quotes, but not the quotes.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a string, be sure to use straight quotes. The back quote, also
    known as a backtick, causes a syntax error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Smart quotes, also known as curly quotes, are also illegal.
  prefs: []
  type: TYPE_NORMAL
- en: 1.5\. Values and types[#](#values-and-types "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far we’ve seen three kinds of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`2` is an integer,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`42.0` is a floating-point number, and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''Hello''` is a string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A kind of value is called a **type**. Every value has a type – or we sometimes
    say it “belongs to” a type.
  prefs: []
  type: TYPE_NORMAL
- en: Python provides a function called `type` that tells you the type of any value.
    The type of an integer is `int`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The type of a floating-point number is `float`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: And the type of a string is `str`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The types `int`, `float`, and `str` can be used as functions. For example, `int`
    can take a floating-point number and convert it to an integer (always rounding
    down).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: And `float` can convert an integer to a floating-point value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Now, here’s something that can be confusing. What do you get if you put a sequence
    of digits in quotes?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: It looks like a number, but it is actually a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: If you try to use it like a number, you might get an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This example generates a `TypeError`, which means that the values in the expression,
    which are called **operands**, have the wrong type. The error message indicates
    that the `/` operator does not support the types of these values, which are `str`
    and `int`.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a string that contains digits, you can use `int` to convert it to
    an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: If you have a string that contains digits and a decimal point, you can use `float`
    to convert it to a floating-point number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: When you write a large integer, you might be tempted to use commas between groups
    of digits, as in `1,000,000`. This is a legal expression in Python, but the result
    is not an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Python interprets `1,000,000` as a comma-separated sequence of integers. We’ll
    learn more about this kind of sequence later.
  prefs: []
  type: TYPE_NORMAL
- en: You can use underscores to make large numbers easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 1.6\. Formal and natural languages[#](#formal-and-natural-languages "Link to
    this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Natural languages** are the languages people speak, like English, Spanish,
    and French. They were not designed by people; they evolved naturally.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Formal languages** are languages that are designed by people for specific
    applications. For example, the notation that mathematicians use is a formal language
    that is particularly good at denoting relationships among numbers and symbols.
    Similarly, programming languages are formal languages that have been designed
    to express computations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although formal and natural languages have some features in common there are
    important differences:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ambiguity: Natural languages are full of ambiguity, which people deal with
    by using contextual clues and other information. Formal languages are designed
    to be nearly or completely unambiguous, which means that any program has exactly
    one meaning, regardless of context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Redundancy: In order to make up for ambiguity and reduce misunderstandings,
    natural languages use redundancy. As a result, they are often verbose. Formal
    languages are less redundant and more concise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Literalness: Natural languages are full of idiom and metaphor. Formal languages
    mean exactly what they say.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because we all grow up speaking natural languages, it is sometimes hard to adjust
    to formal languages. Formal languages are more dense than natural languages, so
    it takes longer to read them. Also, the structure is important, so it is not always
    best to read from top to bottom, left to right. Finally, the details matter. Small
    errors in spelling and punctuation, which you can get away with in natural languages,
    can make a big difference in a formal language.
  prefs: []
  type: TYPE_NORMAL
- en: 1.7\. Debugging[#](#debugging "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programmers make mistakes. For whimsical reasons, programming errors are called
    **bugs** and the process of tracking them down is called **debugging**.
  prefs: []
  type: TYPE_NORMAL
- en: Programming, and especially debugging, sometimes brings out strong emotions.
    If you are struggling with a difficult bug, you might feel angry, sad, or embarrassed.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for these reactions might help you deal with them. One approach is
    to think of the computer as an employee with certain strengths, like speed and
    precision, and particular weaknesses, like lack of empathy and inability to grasp
    the big picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your job is to be a good manager: find ways to take advantage of the strengths
    and mitigate the weaknesses. And find ways to use your emotions to engage with
    the problem, without letting your reactions interfere with your ability to work
    effectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Learning to debug can be frustrating, but it is a valuable skill that is useful
    for many activities beyond programming. At the end of each chapter there is a
    section, like this one, with my suggestions for debugging. I hope they help!
  prefs: []
  type: TYPE_NORMAL
- en: 1.8\. Glossary[#](#glossary "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**arithmetic operator:** A symbol, like `+` and `*`, that denotes an arithmetic
    operation like addition or multiplication.'
  prefs: []
  type: TYPE_NORMAL
- en: '**integer:** A type that represents numbers with no fractional or decimal part.'
  prefs: []
  type: TYPE_NORMAL
- en: '**floating-point:** A type that represents integers and numbers with decimal
    parts.'
  prefs: []
  type: TYPE_NORMAL
- en: '**integer division:** An operator, `//`, that divides two numbers and rounds
    down to an integer.'
  prefs: []
  type: TYPE_NORMAL
- en: '**expression:** A combination of variables, values, and operators.'
  prefs: []
  type: TYPE_NORMAL
- en: '**value:** An integer, floating-point number, or string – or one of other kinds
    of values we will see later.'
  prefs: []
  type: TYPE_NORMAL
- en: '**function:** A named sequence of statements that performs some useful operation.
    Functions may or may not take arguments and may or may not produce a result.'
  prefs: []
  type: TYPE_NORMAL
- en: '**function call:** An expression – or part of an expression – that runs a function.
    It consists of the function name followed by an argument list in parentheses.'
  prefs: []
  type: TYPE_NORMAL
- en: '**syntax error:** An error in a program that makes it impossible to parse –
    and therefore impossible to run.'
  prefs: []
  type: TYPE_NORMAL
- en: '**string:** A type that represents sequences of characters.'
  prefs: []
  type: TYPE_NORMAL
- en: '**concatenation:** Joining two strings end-to-end.'
  prefs: []
  type: TYPE_NORMAL
- en: '**type:** A category of values. The types we have seen so far are integers
    (type `int`), floating-point numbers (type `float`), and strings (type `str`).'
  prefs: []
  type: TYPE_NORMAL
- en: '**operand:** One of the values on which an operator operates.'
  prefs: []
  type: TYPE_NORMAL
- en: '**natural language:** Any of the languages that people speak that evolved naturally.'
  prefs: []
  type: TYPE_NORMAL
- en: '**formal language:** Any of the languages that people have designed for specific
    purposes, such as representing mathematical ideas or computer programs. All programming
    languages are formal languages.'
  prefs: []
  type: TYPE_NORMAL
- en: '**bug:** An error in a program.'
  prefs: []
  type: TYPE_NORMAL
- en: '**debugging:** The process of finding and correcting errors.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.9\. Exercises[#](#exercises "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 1.9.1\. Ask a virtual assistant[#](#ask-a-virtual-assistant "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you work through this book, there are several ways you can use a virtual
    assistant or chatbot to help you learn.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to learn more about a topic in the chapter, or anything is unclear,
    you can ask for an explanation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are having a hard time with any of the exercises, you can ask for help.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In each chapter, I’ll suggest exercises you can do with a virtual assistant,
    but I encourage you to try things on your own and see what works for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some topics you could ask a virtual assistant about:'
  prefs: []
  type: TYPE_NORMAL
- en: Earlier I mentioned bitwise operators but I didn’t explain why the value of
    `7 ^ 2` is 5\. Try asking “What are the bitwise operators in Python?” or “What
    is the value of `7 XOR 2`?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I also mentioned the order of operations. For more details, ask “What is the
    order of operations in Python?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `round` function, which we used to round a floating-point number to the
    nearest integer, can take a second argument. Try asking “What are the arguments
    of the round function?” or “How do I round pi off to three decimal places?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s one more arithmetic operator I didn’t mention; try asking “What is the
    modulus operator in Python?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most virtual assistants know about Python, so they answer questions like this
    pretty reliably. But remember that these tools make mistakes. If you get code
    from a chatbot, test it!
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.2\. Exercise[#](#exercise "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might wonder what `round` does if a number ends in `0.5`. The answer is
    that it sometimes rounds up and sometimes rounds down. Try these examples and
    see if you can figure out what rule it follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: If you are curious, ask a virtual assistant, “If a number ends in 0.5, does
    Python round up or down?”
  prefs: []
  type: TYPE_NORMAL
- en: 1.9.3\. Exercise[#](#id1 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you learn about a new feature, you should try it out and make mistakes
    on purpose. That way, you learn the error messages, and when you see them again,
    you will know what they mean. It is better to make mistakes now and deliberately
    than later and accidentally.
  prefs: []
  type: TYPE_NORMAL
- en: You can use a minus sign to make a negative number like `-2`. What happens if
    you put a plus sign before a number? What about `2++2`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens if you have two values with no operator between them, like `4 2`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you call a function like `round(42.5)`, what happens if you leave out one
    or both parentheses?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 1.9.4\. Exercise[#](#id2 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recall that every expression has a value, every value has a type, and we can
    use the `type` function to find the type of any value.
  prefs: []
  type: TYPE_NORMAL
- en: What is the type of the value of the following expressions? Make your best guess
    for each one, and then use `type` to find out.
  prefs: []
  type: TYPE_NORMAL
- en: '`765`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2.718`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''2 pi''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abs(-7)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abs(-7.0)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`abs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.9.5\. Exercise[#](#id3 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following questions give you a chance to practice writing arithmetic expressions.
  prefs: []
  type: TYPE_NORMAL
- en: How many seconds are there in 42 minutes 42 seconds?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'How many miles are there in 10 kilometers? Hint: there are 1.61 kilometers
    in a mile.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you run a 10 kilometer race in 42 minutes 42 seconds, what is your average
    pace in seconds per mile?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is your average pace in minutes and seconds per mile?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is your average speed in miles per hour?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you already know about variables, you can use them for this exercise. If
    you don’t, you can do the exercise without them – and then we’ll see them in the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[Think Python: 3rd Edition](https://allendowney.github.io/ThinkPython/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Copyright 2024 [Allen B. Downey](https://allendowney.com)
  prefs: []
  type: TYPE_NORMAL
- en: 'Code license: [MIT License](https://mit-license.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Text license: [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
  prefs: []
  type: TYPE_NORMAL
