- en: 14\. Classes and Functions#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://allendowney.github.io/ThinkPython/chap14.html](https://allendowney.github.io/ThinkPython/chap14.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: At this point you know how to use functions to organize code and how to use
    built-in types to organize data. The next step is **object-oriented programming**,
    which uses programmer-defined types to organize both code and data.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming is a big topic, so we will proceed gradually. In
    this chapter, we’ll start with code that is not idiomatic – that is, it is not
    the kind of code experienced programmers write – but it is a good place to start.
    In the next two chapters, we will use additional features to write more idiomatic
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 14.1\. Programmer-defined types[#](#programmer-defined-types "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have used many of Python’s built-in types – now we will define a new type.
    As a first example, we’ll create a type called `Time` that represents a time of
    day. A programmer-defined type is also called a **class**. A class definition
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The header indicates that the new class is called `Time`. The body is a docstring
    that explains what the class is for. Defining a class creates a **class object**.
  prefs: []
  type: TYPE_NORMAL
- en: The class object is like a factory for creating objects. To create a `Time`
    object, you call `Time` as if it were a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The result is a new object whose type is `__main__.Time`, where `__main__` is
    the name of the module where `Time` is defined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When you print an object, Python tells you what type it is and where it is stored
    in memory (the prefix `0x` means that the following number is in hexadecimal).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Creating a new object is called **instantiation**, and the object is an **instance**
    of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 14.2\. Attributes[#](#attributes "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An object can contain variables, which are called **attributes** and pronounced
    with the emphasis on the first syllable, like “AT-trib-ute”, rather than the second
    syllable, like “a-TRIB-ute”. We can create attributes using dot notation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This example creates attributes called `hour`, `minute`, and `second`, which
    contain the hours, minutes, and seconds of the time `11:59:01`, which is lunch
    time as far as I am concerned.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram shows the state of `lunch` and its attributes after these
    assignments.
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/79b2dbc2a66bedacd471711c8756ef7145d45b5c0d6850b443c583976fa3b41f.png](../Images/77ecdbb368a95f38f325abb612a85465.png)'
  prefs: []
  type: TYPE_IMG
- en: The variable `lunch` refers to a `Time` object, which contains three attributes.
    Each attribute refers to an integer. A state diagram like this – which shows an
    object and its attributes – is called an **object diagram**.
  prefs: []
  type: TYPE_NORMAL
- en: You can read the value of an attribute using the dot operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can use an attribute as part of any expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: And you can use the dot operator in an expression in an f-string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: But notice that the previous example is not in the standard format. To fix it,
    we have to print the `minute` and `second` attributes with a leading zero. We
    can do that by extending the expressions in curly braces with a **format specifier**.
    In the following example, the format specifiers indicate that `minute` and `second`
    should be displayed with at least two digits and a leading zero if needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We’ll use this f-string to write a function that displays the value of a `Time`object.
    You can pass an object as an argument in the usual way. For example, the following
    function takes a `Time` object as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When we call it, we can pass `lunch` as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 14.3\. Objects as return values[#](#objects-as-return-values "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions can return objects. For example, `make_time` takes parameters called
    `hour`, `minute`, and `second`, stores them as attributes in a `Time` object,
    and returns the new object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It might be surprising that the parameters have the same names as the attributes,
    but that’s a common way to write a function like this. Here’s how we use `make_time`
    to create a `Time` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 14.4\. Objects are mutable[#](#objects-are-mutable "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose you are going to a screening of a movie, like *Monty Python and the
    Holy Grail*, which starts at `9:20 PM` and runs for `92` minutes, which is one
    hour `32` minutes. What time will the movie end?
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll create a `Time` object that represents the start time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: To find the end time, we can modify the attributes of the `Time` object, adding
    the duration of the movie.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The movie will be over at 10:52 PM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s encapsulate this computation in a function and generalize it to take
    the duration of the movie in three parameters: `hours`, `minutes`, and `seconds`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here is an example that demonstrates the effect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The following stack diagram shows the state of the program just before `increment_time`
    modifies the object.
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/ec55f16021188c53e3422f59671281ee881bbcc825c63d318957ce747f8e27e1.png](../Images/9d23255e2fd43eab2ce7769453b1414b.png)'
  prefs: []
  type: TYPE_IMG
- en: Inside the function, `time` is an alias for `start`, so when `time` is modified,
    `start` changes.
  prefs: []
  type: TYPE_NORMAL
- en: This function works, but after it runs, we’re left with a variable named `start`
    that refers to an object that represents the *end* time, and we no longer have
    an object that represents the start time. It would be better to leave `start`
    unchanged and make a new object to represent the end time. We can do that by copying
    `start` and modifying the copy.
  prefs: []
  type: TYPE_NORMAL
- en: 14.5\. Copying[#](#copying "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `copy` module provides a function called `copy` that can duplicate any object.
    We can import it like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: To see how it works, let’s start with a new `Time` object that represents the
    start time of the movie.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: And make a copy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now `start` and `end` contain the same data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: But the `is` operator confirms that they are not the same object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Let’s see what the `==` operator does.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You might expect `==` to yield `True` because the objects contain the same data.
    But for programmer-defined classes, the default behavior of the `==` operator
    is the same as the `is` operator – it checks identity, not equivalence.
  prefs: []
  type: TYPE_NORMAL
- en: 14.6\. Pure functions[#](#pure-functions "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can use `copy` to write pure functions that don’t modify their parameters.
    For example, here’s a function that takes a `Time` object and a duration in hours,
    minutes and seconds. It makes a copy of the original object, uses `increment_time`
    to modify the copy, and returns it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here’s how we use it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The return value is a new object representing the end time of the movie. And
    we can confirm that `start` is unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`add_time` is a **pure function** because it does not modify any of the objects
    passed to it as arguments and its only effect is to return a value.'
  prefs: []
  type: TYPE_NORMAL
- en: Anything that can be done with impure functions can also be done with pure functions.
    In fact, some programming languages only allow pure functions. Programs that use
    pure functions might be less error-prone, but impure functions are sometimes convenient
    and can be more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: In general, I suggest you write pure functions whenever it is reasonable and
    resort to impure functions only if there is a compelling advantage. This approach
    might be called a **functional programming style**.
  prefs: []
  type: TYPE_NORMAL
- en: 14.7\. Prototype and patch[#](#prototype-and-patch "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example, `increment_time` and `add_time` seem to work, but if
    we try another example, we’ll see that they are not quite correct.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you arrive at the theater and discover that the movie starts at `9:40`,
    not `9:20`. Here’s what happens when we compute the updated end time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The result is not a valid time. The problem is that `increment_time` does not
    deal with cases where the number of seconds or minutes adds up to more than `60`.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an improved version that checks whether `second` exceeds or equals `60`
    – if so, it increments `minute` – then checks whether `minute` exceeds or equals
    `60` – if so, it increments `hour`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Fixing `increment_time` also fixes `add_time`, which uses it. So now the previous
    example works correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: But this function is still not correct, because the arguments might be bigger
    than `60`. For example, suppose we are given the run time as `92` minutes, rather
    than `1` hours and `32` minutes. We might call `add_time` like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The result is not a valid time. So let’s try a different approach, using the
    `divmod` function. We’ll make a copy of `start` and modify it by incrementing
    the `minute` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now `minute` is `132`, which is `2` hours and `12` minutes. We can use `divmod`
    to divide by `60` and return the number of whole hours and the number of minutes
    left over.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now `minute` is correct, and we can add the hours to `hour`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The result is a valid time. We can do the same thing with `hour` and `second`,
    and encapsulate the whole process in a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: With this version of `increment_time`, `add_time` works correctly, even if the
    arguments exceed `60`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This section demonstrates a program development plan I call **prototype and
    patch**. We started with a simple prototype that worked correctly for the first
    example. Then we tested it with more difficult examples – when we found an error,
    we modified the program to fix it, like putting a patch on tire with a puncture.
  prefs: []
  type: TYPE_NORMAL
- en: This approach can be effective, especially if you don’t yet have a deep understanding
    of the problem. But incremental corrections can generate code that is unnecessarily
    complicated – since it deals with many special cases – and unreliable – since
    it is hard to know if you have found all the errors.
  prefs: []
  type: TYPE_NORMAL
- en: 14.8\. Design-first development[#](#design-first-development "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alternative plan is **design-first development**, which involves more planning
    before prototyping. In a design-first process, sometimes a high-level insight
    into the problem makes the programming much easier.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the insight is that we can think of a `Time` object as a three-digit
    number in base 60 – also known as sexagesimal. The `second` attribute is the “ones
    column”, the `minute` attribute is the “sixties column”, and the `hour` attribute
    is the “thirty-six hundreds column”. When we wrote `increment_time`, we were effectively
    doing addition in base 60, which is why we had to carry from one column to the
    next.
  prefs: []
  type: TYPE_NORMAL
- en: This observation suggests another approach to the whole problem – we can convert
    `Time` objects to integers and take advantage of the fact that Python knows how
    to do integer arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a function that converts from a `Time` to an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The result is the number of seconds since the beginning of the day. For example,
    `01:01:01` is `1` hour, `1` minute and `1` second from the beginning of the day,
    which is the sum of `3600` seconds, `60` seconds, and `1` second.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: And here’s a function that goes in the other direction – converting an integer
    to a `Time` object – using the `divmod` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We can test it by converting the previous example back to a `Time`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Using these functions, we can write a more concise version of `add_time`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The first line converts the arguments to a `Time` object called `duration`.
    The second line converts `time` and `duration` to seconds and adds them. The third
    line converts the sum to a `Time` object and returns it.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s how it works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In some ways, converting from base 60 to base 10 and back is harder than just
    dealing with times. Base conversion is more abstract; our intuition for dealing
    with time values is better.
  prefs: []
  type: TYPE_NORMAL
- en: But if we have the insight to treat times as base 60 numbers – and invest the
    effort to write the conversion functions `time_to_int` and `int_to_time` – we
    get a program that is shorter, easier to read and debug, and more reliable.
  prefs: []
  type: TYPE_NORMAL
- en: It is also easier to add features later. For example, imagine subtracting two
    `Time` objects to find the duration between them. The naive approach is to implement
    subtraction with borrowing. Using the conversion functions is easier and more
    likely to be correct.
  prefs: []
  type: TYPE_NORMAL
- en: Ironically, sometimes making a problem harder – or more general – makes it easier,
    because there are fewer special cases and fewer opportunities for error.
  prefs: []
  type: TYPE_NORMAL
- en: '## 14.9\. Debugging[#](#debugging "Link to this heading")'
  prefs: []
  type: TYPE_NORMAL
- en: Python provides several built-in functions that are useful for testing and debugging
    programs that work with objects. For example, if you are not sure what type an
    object is, you can ask.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: You can also use `isinstance` to check whether an object is an instance of a
    particular class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: If you are not sure whether an object has a particular attribute, you can use
    the built-in function `hasattr`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: To get all of the attributes, and their values, in a dictionary, you can use
    `vars`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The `structshape` module, which we saw in [Chapter 11](chap11.html#section-debugging-11),
    also works with programmer-defined types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 14.10\. Glossary[#](#glossary "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**object-oriented programming:** A style of programming that uses objects to
    organize code and data.'
  prefs: []
  type: TYPE_NORMAL
- en: '**class:** A programmer-defined type. A class definition creates a new class
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: '**class object:** An object that represents a class – it is the result of a
    class definition.'
  prefs: []
  type: TYPE_NORMAL
- en: '**instantiation:** The process of creating an object that belongs to a class.'
  prefs: []
  type: TYPE_NORMAL
- en: '**instance:** An object that belongs to a class.'
  prefs: []
  type: TYPE_NORMAL
- en: '**attribute:** A variable associated with an object, also called an instance
    variable.'
  prefs: []
  type: TYPE_NORMAL
- en: '**object diagram:** A graphical representation of an object, its attributes,
    and their values.'
  prefs: []
  type: TYPE_NORMAL
- en: '**format specifier:** In an f-string, a format specifier determines how a value
    is converted to a string.'
  prefs: []
  type: TYPE_NORMAL
- en: '**pure function:** A function that does not modify its parameters or have any
    effect other than returning a value.'
  prefs: []
  type: TYPE_NORMAL
- en: '**functional programming style:** A way of programming that uses pure functions
    whenever possible.'
  prefs: []
  type: TYPE_NORMAL
- en: '**prototype and patch:** A way of developing programs by starting with a rough
    draft and gradually adding features and fixing bugs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**design-first development:** A way of developing programs with more careful
    planning that prototype and patch.'
  prefs: []
  type: TYPE_NORMAL
- en: 14.11\. Exercises[#](#exercises "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 14.11.1\. Ask a virtual assistant[#](#ask-a-virtual-assistant "Link to this
    heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is a lot of new vocabulary in this chapter. A conversation with a virtual
    assistant can help solidify your understanding. Consider asking:'
  prefs: []
  type: TYPE_NORMAL
- en: “What is the difference between a class and a type?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “What is the difference between an object and an instance?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “What is the difference between a variable and an attribute?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “What are the pros and cons of pure functions compared to impure functions?”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because we are just getting started with object oriented programming, the code
    in this chapter is not idiomatic – it is not the kind of code experienced programmers
    write. If you ask a virtual assistant for help with the exercises, you will probably
    see features we have not covered yet. In particular, you are likely to see a method
    called `__init__` used to initialize the attributes of an instance.
  prefs: []
  type: TYPE_NORMAL
- en: If these features make sense to you, go ahead and use them. But if not, be patient
    – we will get there soon. In the meantime, see if you can solve the following
    exercises using only the features we have covered so far.
  prefs: []
  type: TYPE_NORMAL
- en: Also, in this chapter we saw one example of a format specifier. For more information,
    ask “What format specifiers can be used in a Python f-string?”
  prefs: []
  type: TYPE_NORMAL
- en: 14.11.2\. Exercise[#](#exercise "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Write a function called `subtract_time` that takes two `Time` objects and returns
    the interval between them in seconds – assuming that they are two times during
    the same day.
  prefs: []
  type: TYPE_NORMAL
- en: 14.11.3\. Exercise[#](#id1 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Write a function called `is_after` that takes two `Time` objects and returns
    `True` if the first time is later in the day than the second, and `False` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 14.11.4\. Exercise[#](#id2 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here’s a definition for a `Date` class that represents a date – that is, a year,
    month, and day of the month.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Write a function called `make_date` that takes `year`, `month`, and `day` as
    parameters, makes a `Date` object, assigns the parameters to attributes, and returns
    the result the new object. Create an object that represents June 22, 1933.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a function called `print_date` that takes a `Date` object, uses an f-string
    to format the attributes, and prints the result. If you test it with the `Date`
    you created, the result should be `1933-06-22`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a function called `is_after` that takes two `Date` objects as parameters
    and returns `True` if the first comes after the second. Create a second object
    that represents September 17, 1933, and check whether it comes after the first
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hint: You might find it useful to write a function called `date_to_tuple` that
    takes a `Date` object and returns a tuple that contains its attributes in year,
    month, day order.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Think Python: 3rd Edition](https://allendowney.github.io/ThinkPython/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Copyright 2024 [Allen B. Downey](https://allendowney.com)
  prefs: []
  type: TYPE_NORMAL
- en: 'Code license: [MIT License](https://mit-license.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Text license: [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
  prefs: []
  type: TYPE_NORMAL
