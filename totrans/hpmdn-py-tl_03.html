<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Python Environments"><div class="chapter" id="chapter_environments">
<h1><span class="label">Chapter 2. </span>Python Environments</h1>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id248">
<h1>A Note for Early Release Readers</h1>
<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>

<p>This will be the second chapter of the final book. Please note that the GitHub repo will be made active later on.</p>

<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the author at <a href="mailto:mail@claudiojolowicz.com">mail@claudiojolowicz.com</a>.</p>
</div></aside>

<p>At its core, every Python installation consists of two things: an interpreter
and modules. The modules, in turn, come from the standard library and from
third-party packages, if you’ve installed any. Together, these provide the
essential components you need to execute a Python program: a <em>Python
environment</em> (<a data-type="xref" href="#figure_environment">Figure 2-1</a>).</p>

<p>Python installations aren’t the only kind of Python environment. <em>Virtual
environments</em> are stripped-down environments that share the interpreter and the
standard library with a full installation. You use them to install third-party
packages for a specific project or application while keeping the system-wide
environment pristine.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>This book uses <em>Python environment</em> as an umbrella term that includes both
system-wide installations and virtual environments. Beware that some people only
use the term for project-specific environments, like virtual environments or
Conda environments.</p>
</div>

<figure><div id="figure_environment" class="figure">
<img src="assets/hmpt_0201.png" alt="Python environments consist of an interpreter and modules." width="2520" height="800"/>
<h6><span class="label">Figure 2-1. </span>Python environments consist of an interpreter and modules. Virtual environments share the interpreter and the standard library with their parent environment.</h6>
</div></figure>

<p>Managing environments is a crucial aspect of Python development. You’ll want to
make sure your code works on your users’ systems, particularly across the
language versions you support, and possibly across major versions of an
important third-party package. A Python environment can only contain a single
version of each third-party package—​if two projects require different versions
of the same package, they can’t be installed side-by-side. That’s why it’s
considered good practice to install every Python application, and every project
you work on, in a dedicated virtual environment.</p>

<p>In this chapter, you’ll build a deeper understanding of what Python environments
are and how they work. The chapter has three parts:</p>

<ul>
<li>
<p>The first part introduces the three kinds of Python environments—​Python
installations, the per-user environment, and virtual environments—​as well two
fundamental tools: the Python package installer pip and the standard <code>venv</code>
module.</p>
</li>
<li>
<p>The second part introduces two modern tools that let you manage environments
more efficiently: pipx, an installer for Python applications, and uv, a
drop-in replacement for Python packaging tools written in Rust.</p>
</li>
<li>
<p>The final part of this chapter dives deep into how and where Python finds the
modules you import—​feel free to skip it unless you’re curious how this works.</p>
</li>
</ul>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>This chapter uses the Python Launcher to invoke the interpreter (see
<a data-type="xref" href="ch01.html#section_python_launcher_windows">“The Python Launcher for Windows”</a> and <a data-type="xref" href="ch01.html#section_python_launcher_unix">“The Python Launcher for Unix”</a>). If
you don’t have it installed, replace <code>py</code> with <code>python3</code> when running the
examples.</p>
</div>






<section data-type="sect1" data-pdf-bookmark="A Tour of Python Environments"><div class="sect1" id="id63">
<h1>A Tour of Python Environments</h1>

<p>Every Python program runs “inside” a Python environment: the interpreter in the
environment executes the program’s code, and <code>import</code> statements load modules
from the environment. You select the environment by launching its interpreter.</p>

<p>Python offers two mechanisms for running a program on an interpreter. You can
pass a Python script as an argument:</p>
<pre data-type="programlisting">$ <strong>py hello.py</strong></pre>

<p>Alternatively, you can pass a module with the <code>-m</code> option, provided that the
interpreter can import the module:</p>
<pre data-type="programlisting">$ <strong>py -m hello</strong></pre>

<p>Most commonly, the interpreter imports <em>hello.py</em> from the environment—​but for
the sake of this example, placing it in the current directory will also work.</p>

<p>Additionally, many Python applications install an entry-point script in your
<code>PATH</code> (see <a data-type="xref" href="#section_environments_scripts">“Entry-point scripts”</a>). This mechanism allows you to
launch the application without specifying an interpreter. Entry-point scripts
always use the interpreter from the environment in which they’re installed:</p>
<pre data-type="programlisting">$ <strong>hello</strong></pre>

<p>This method is convenient, but there’s also a drawback: If you’ve installed the
program in multiple environments, the first environment on <code>PATH</code> “wins”. In
such a scenario, the form <code>py -m hello</code> offers you more control.</p>

<p>“The interpreter determines the environment.” As mentioned above, this rule
applies when you import modules. It also applies in the complementary situation:
when you install a package into an environment. Pip, the Python package
installer, installs packages into its own environment by default. In other
words, you select the target environment for a package by running pip on the
interpreter in that environment.</p>

<p>For this reason, the canonical way to install a package with pip uses the <code>-m</code>
form:</p>
<pre data-type="programlisting">$ <strong>py -m pip install <em>&lt;package&gt;</em></strong></pre>

<p>Alternatively, you can provide a virtual environment or interpreter to pip using
its <code>--python</code> option:</p>
<pre data-type="programlisting">$ <strong>pip --python=<em>&lt;env&gt;</em> install <em>&lt;package&gt;</em></strong></pre>

<p>The second method has the advantage of not requiring pip in every environment.</p>








<section data-type="sect2" data-pdf-bookmark="Python Installations"><div class="sect2" id="id64">
<h2>Python Installations</h2>

<p>This section takes you on a tour of a Python installation. Feel free to follow
along on your own system. <a data-type="xref" href="#table_environments_roots">Table 2-1</a> shows the most common
locations—​replace 3.<em>x</em> and 3<em>x</em> with the Python
feature version, such as <code>3.12</code> and <code>312</code>.</p>
<table id="table_environments_roots">
<caption><span class="label">Table 2-1. </span>Locations of Python installations</caption>
<thead>
<tr>
<th>Platform</th>
<th>Python installation</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Windows (single-user)</p></td>
<td><p><em>%LocalAppData%\Programs\Python\Python3x</em></p></td>
</tr>
<tr>
<td><p>Windows (multi-user)</p></td>
<td><p><em>%ProgramFiles%\Python3x</em></p></td>
</tr>
<tr>
<td><p>macOS (Homebrew)</p></td>
<td><p><em>/opt/homebrew/Frameworks/Python.framework/Versions/3.x</em><sup><a data-type="noteref" id="id249-marker" href="ch02.html#id249">a</a></sup></p></td>
</tr>
<tr>
<td><p>macOS (python.org)</p></td>
<td><p><em>/Library/Frameworks/Python.framework/Versions/3.x</em></p></td>
</tr>
<tr>
<td><p>Linux (generic)</p></td>
<td><p><em>/usr/local</em></p></td>
</tr>
<tr>
<td><p>Linux (package manager)</p></td>
<td><p><em>/usr</em></p></td>
</tr>
</tbody>
<tbody><tr class="footnotes"><td colspan="2"><p data-type="footnote" id="id249"><sup><a href="ch02.html#id249-marker">a</a></sup> Homebrew on macOS Intel uses <em>/usr/local</em> instead of <em>/opt/homebrew</em>.</p></td></tr></tbody></table>

<p>An installation might be cleanly separated from the rest of your system, but not
necessarily. On Linux, it goes into a shared location like <em>/usr</em> or
<em>/usr/local</em>, with its files scattered across the filesystem. Windows systems,
on the other hand, keep all files in a single place. Framework builds on macOS
are similarly self-contained, although distributions may also install symbolic
links into the traditional Unix locations.</p>

<p>In the following sections, you’ll take a closer look at the core parts of Python
installations—​the interpreter and the modules, as well as some other components
such as entry-point scripts and shared libraries.</p>

<p>The layout of Python installations varies quite a bit from system to system. The
good news is, you rarely have to care—​a Python interpreter knows its
environment. For reference, <a data-type="xref" href="#table_environments_layouts">Table 2-2</a> provides a baseline
for installation layouts on the major platforms. All paths are relative to the
installation root.</p>
<table id="table_environments_layouts">
<caption><span class="label">Table 2-2. </span>Layout of Python installations</caption>
<thead>
<tr>
<th>Files</th>
<th>Windows</th>
<th>Linux and macOS</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>interpreter</p></td>
<td><p><em>python.exe</em></p></td>
<td><p><em>bin/python3.x</em></p></td>
<td/>
</tr>
<tr>
<td><p>standard library</p></td>
<td><p><em>Lib</em> and <em>DLLs</em></p></td>
<td><p><em>lib/python3.x</em></p></td>
<td><p>Extension modules are located under <em>DLLs</em> on Windows.<br/>Fedora places the standard library under <em>lib64</em> instead of <em>lib</em>.</p></td>
</tr>
<tr>
<td><p>third-party packages</p></td>
<td><p><em>Lib\site-packages</em></p></td>
<td><p><em>lib/python3.x/site-packages</em></p></td>
<td><p>Debian and Ubuntu put packages in <em>dist-packages</em>.<br/>Fedora places extension modules under <em>lib64</em> instead of <em>lib</em>.</p></td>
</tr>
<tr>
<td><p>entry-point scripts</p></td>
<td><p><em>Scripts</em></p></td>
<td><p><em>bin</em></p></td>
<td/>
</tr>
</tbody>
</table>










<section data-type="sect3" data-pdf-bookmark="The interpreter"><div class="sect3" id="id65">
<h3>The interpreter</h3>

<p>The executable that runs Python programs is named <em>python.exe</em> on Windows and
located at the root of a full installation.<sup><a data-type="noteref" id="id250-marker" href="ch02.html#id250">1</a></sup> On Linux and macOS, the interpreter is named <em>python3.x</em> and
stored in the <em>bin</em> directory with a <em>python3</em> symbolic link.</p>

<p>The Python interpreter ties the environment to three things:</p>

<ul>
<li>
<p>a specific version of the Python language</p>
</li>
<li>
<p>a specific implementation of Python</p>
</li>
<li>
<p>a specific build of the interpreter</p>
</li>
</ul>

<p>The implementation might be <a href="https://github.com/python/cpython">CPython</a>, the
reference implementation of Python, but it could also be any of a number of
alternative implementations—​such as <a href="https://www.pypy.org/">PyPy</a>, a fast
interpreter with just-in-time compilation, written in Python itself, or
<a href="https://www.graalvm.org/python/">GraalPy</a>, a highly performant implementation
with Java interoperability, using the GraalVM development kit.</p>

<p>Builds differ in their CPU architecture—​for example, 32-bit versus 64-bit, or
Intel versus Apple Silicon—​and their build configuration, which determines
things like compile-time optimizations or the installation layout.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_environments_sys">
<h1>Querying the interpreter about the Python environment</h1>
<p>In an interactive session, import the <code>sys</code> module and inspect the following
variables:</p>
<dl>
<dt><code>sys.version_info</code></dt>
<dd>
<p>The version of the Python language, represented as a <em>named tuple</em> with the
major, minor, and micro versions, as well as the release level and serial
number for prereleases</p>
</dd>
<dt><code>sys.implementation.name</code></dt>
<dd>
<p>The implementation of Python, such as <code>"cpython"</code> or <code>"pypy"</code></p>
</dd>
<dt><code>sys.implementation.version</code></dt>
<dd>
<p>The version of the implementation, same as <code>sys.version_info</code> for CPython</p>
</dd>
<dt><code>sys.executable</code></dt>
<dd>
<p>The location of the Python interpreter</p>
</dd>
<dt><code>sys.prefix</code></dt>
<dd>
<p>The location of the Python environment</p>
</dd>
<dt><code>sys.path</code></dt>
<dd>
<p>The list of directories searched when importing Python modules</p>
</dd>
</dl>

<p>The command <code>py -m sysconfig</code> prints a great deal of metadata compiled into the
Python interpreter, such as the instruction set architecture, the build
configuration, and the installation layout.</p>
</div></aside>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Python modules"><div class="sect3" id="section_environments_modules">
<h3>Python modules</h3>

<p>Modules are containers of Python objects that you load via the <code>import</code>
statement. They’re organized below <em>Lib</em> (Windows) or <em>lib/python3.x</em> (Linux and
macOS) with some platform-dependent variations. Third-party packages go into a
subdirectory named <em>site-packages</em>.</p>

<p>Modules come in various forms and shapes. If you’ve worked with Python, you’ve
likely used most of them already. Let’s go over the different kinds:</p>
<dl>
<dt>Simple modules</dt>
<dd>
<p>In the simplest case, a <em>module</em> is a single file containing Python source
code. The statement <code>import string</code> executes the code in <em>string.py</em> and binds
the result to the name <code>string</code> in the local scope.</p>
</dd>
<dt>Packages</dt>
<dd>
<p>Directories with <em>__init__.py</em> files are known as <em>packages</em>—they allow
you to organize modules in a hierarchy. The statement <code>import email.message</code>
loads the <code>message</code> module from the <code>email</code> package.</p>
</dd>
<dt>Namespace packages</dt>
<dd>
<p>Directories with modules but no <em>__init__.py</em> are known as <em>namespace
packages</em>. You use them to organize modules in a common namespace such as a
company name (say <code>acme.unicycle</code> and <code>acme.rocketsled</code>). Unlike with regular
packages, you can distribute each module in a namespace package separately.</p>
</dd>
<dt>Extension modules</dt>
<dd>
<p>Extension modules, such as the <code>math</code> module, contain native code compiled
from low-level languages like C. They’re shared libraries<sup><a data-type="noteref" id="id251-marker" href="ch02.html#id251">2</a></sup>
with a special entry point that lets you import them as modules from Python.
People write them for performance reasons or to make existing C libraries
available as Python modules. Their names end in <em>.pyd</em> on Windows, <em>.dylib</em> on
macOS, and <em>.so</em> on Linux.</p>
</dd>
<dt>Built-in modules</dt>
<dd>
<p>Some modules from the standard library, such as the <code>sys</code> and <code>builtins</code>
modules, are compiled into the interpreter. The variable
<code>sys.builtin_module_names</code> lists all of these modules.</p>
</dd>
<dt>Frozen modules</dt>
<dd>
<p>Some modules from the standard library are written in Python but have their
bytecode embedded in the interpreter. Originally, only core parts of
<code>importlib</code> got this treatment. Recent versions of Python freeze every module
that’s imported during interpreter startup, such as <code>os</code> and <code>io</code>.</p>
</dd>
</dl>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The term <em>package</em> carries some ambiguity in the Python world. It refers both to
modules and to the artifacts used for distributing modules, also known as
<em>distributions</em>. Unless stated otherwise, this book uses <em>package</em> as a synonym
for <em>distribution</em>.</p>
</div>

<p><em>Bytecode</em> is an intermediate representation of Python code that is
platform-independent and optimized for fast execution. The interpreter compiles
pure Python modules to bytecode when it loads them for the first time. Bytecode
modules are cached in the environment in <em>.pyc</em> files under <em>__pycache__</em>
directories.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_environments_importlib">
<h1>Inspecting modules and packages with importlib</h1>
<p>You can find out where a module comes from using <code>importlib</code> from the standard
library. Every module has an associated <code>ModuleSpec</code> object whose <code>origin</code>
attribute contains the location of the source file or dynamic library for the
module, or a fixed string like <code>"built-in"</code> or <code>"frozen"</code>. The <code>cached</code>
attribute stores the location of the bytecode for a pure Python module.
<a data-type="xref" href="#example_environments_importlib_origin">Example 2-1</a> shows the origin of each module in the
standard library.</p>
<div id="example_environments_importlib_origin" data-type="example">
<h5><span class="label">Example 2-1. </span>Listing standard library modules and their origin</h5>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code> <code class="nn">importlib.util</code>
<code class="kn">import</code> <code class="nn">sys</code>

<code class="k">for</code> <code class="n">name</code> <code class="ow">in</code> <code class="nb">sorted</code><code class="p">(</code><code class="n">sys</code><code class="o">.</code><code class="n">stdlib_module_names</code><code class="p">):</code>
    <code class="k">if</code> <code class="n">spec</code> <code class="o">:=</code> <code class="n">importlib</code><code class="o">.</code><code class="n">util</code><code class="o">.</code><code class="n">find_spec</code><code class="p">(</code><code class="n">name</code><code class="p">):</code>
        <code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s2">"</code><code class="si">{</code><code class="n">name</code><code class="si">:</code><code class="s2">30</code><code class="si">}</code><code class="s2"> </code><code class="si">{</code><code class="n">spec</code><code class="o">.</code><code class="n">origin</code><code class="si">}</code><code class="s2">"</code><code class="p">)</code></pre></div>

<p>Environments also store metadata about installed third-party packages, such as
their authors, licenses, and versions.
<a data-type="xref" href="#example_environments_importlib_metadata">Example 2-2</a> shows the version of each package in
the environment using <code>importlib.metadata</code> from the standard library.</p>
<div id="example_environments_importlib_metadata" data-type="example">
<h5><span class="label">Example 2-2. </span>Listing packages installed in the environment</h5>

<pre data-type="programlisting" data-code-language="python"><code class="kn">import</code> <code class="nn">importlib.metadata</code>

<code class="n">distributions</code> <code class="o">=</code> <code class="n">importlib</code><code class="o">.</code><code class="n">metadata</code><code class="o">.</code><code class="n">distributions</code><code class="p">()</code>
<code class="k">for</code> <code class="n">distribution</code> <code class="ow">in</code> <code class="nb">sorted</code><code class="p">(</code><code class="n">distributions</code><code class="p">,</code> <code class="n">key</code><code class="o">=</code><code class="k">lambda</code> <code class="n">d</code><code class="p">:</code> <code class="n">d</code><code class="o">.</code><code class="n">name</code><code class="p">):</code>
    <code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s2">"</code><code class="si">{</code><code class="n">distribution</code><code class="o">.</code><code class="n">name</code><code class="si">:</code><code class="s2">30</code><code class="si">}</code><code class="s2"> </code><code class="si">{</code><code class="n">distribution</code><code class="o">.</code><code class="n">version</code><code class="si">}</code><code class="s2">"</code><code class="p">)</code></pre></div>
</div></aside>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Entry-point scripts"><div class="sect3" id="section_environments_scripts">
<h3>Entry-point scripts</h3>

<p>An <em>entry-point script</em> is an executable file in <em>Scripts</em> (Windows) or <em>bin</em>
(Linux and macOS) with a single purpose: it launches a Python application by
importing the module with its entry-point function and calling that function.</p>

<p>This mechanism has two key benefits. First, you can launch the application in a
shell by running a simple command—​say, <code>pydoc3</code> for Python’s built-in
documentation browser.<sup><a data-type="noteref" id="id252-marker" href="ch02.html#id252">3</a></sup> Second,
entry-point scripts use the interpreter and modules from their environment,
sparing you surprises about wrong Python versions or missing third-party
packages.</p>

<p>Package installers, like pip, can generate entry-point scripts for third-party
packages they install. Package authors only need to designate the function that
the script should invoke. This is a handy method to provide an executable for a
Python application (see <a data-type="xref" href="ch03.html#section_packages_entrypoint_scripts">“Entry-point Scripts”</a>).</p>

<p>Platforms differ in how they let you execute entry-point scripts directly. On
Linux and macOS, they’re regular Python files with <em>execute</em> permission, such as
the one shown in <a data-type="xref" href="#example_environments_pydoc">Example 2-3</a>. Windows embeds the Python code
in a binary file in the Portable Executable (PE) format—​more commonly known as
a <em>.exe</em> file. The binary launches the interpreter with the embedded code.</p>
<div id="example_environments_pydoc" data-type="example">
<h5><span class="label">Example 2-3. </span>The entry-point script <code>pydoc3</code> from a Linux installation</h5>

<pre data-type="programlisting" data-code-language="python"><code class="ch">#!/usr/local/bin/python3.12 </code><a class="co" id="co_python_environments_CO1-1" href="#callout_python_environments_CO1-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a><code>
</code><code class="kn">import</code><code> </code><code class="nn">pydoc</code><code> </code><a class="co" id="co_python_environments_CO1-2" href="#callout_python_environments_CO1-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a><code>
</code><code class="k">if</code><code> </code><code class="vm">__name__</code><code> </code><code class="o">==</code><code> </code><code class="s2">"</code><code class="s2">__main__</code><code class="s2">"</code><code class="p">:</code><code> </code><a class="co" id="co_python_environments_CO1-3" href="#callout_python_environments_CO1-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a><code>
</code><code>    </code><code class="n">pydoc</code><code class="o">.</code><code class="n">cli</code><code class="p">(</code><code class="p">)</code><code> </code><a class="co" id="co_python_environments_CO1-4" href="#callout_python_environments_CO1-4"><img src="assets/4.png" alt="4" width="12" height="12"/></a></pre></div>
<dl class="calloutlist">
<dt><a class="co" id="callout_python_environments_CO1-1" href="#co_python_environments_CO1-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Request the interpreter from the current environment.</p></dd>
<dt><a class="co" id="callout_python_environments_CO1-2" href="#co_python_environments_CO1-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Load the module containing the designated entry-point function.</p></dd>
<dt><a class="co" id="callout_python_environments_CO1-3" href="#co_python_environments_CO1-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>Check that the script wasn’t imported from another module.</p></dd>
<dt><a class="co" id="callout_python_environments_CO1-4" href="#co_python_environments_CO1-4"><img src="assets/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>Finally, call the entry-point function to start up the program.</p></dd>
</dl>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The <code>#!</code> line is known as a <em>shebang</em> on Unix-like operating systems. When you
run the script, the program loader uses the line to locate and launch the
interpreter. The <em>program loader</em> is the part of the operating system that loads
a program into main memory.</p>
</div>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Other components"><div class="sect3" id="id68">
<h3>Other components</h3>

<p>Besides the interpreter, modules, and scripts, Python environments can include
some additional components:</p>
<dl>
<dt>Shared libraries</dt>
<dd>
<p>Python environments sometimes contain shared libraries that aren’t extension
modules, named <em>.dll</em> on Windows, <em>.dylib</em> on macOS, and <em>.so</em> on Linux.
Third-party packages may bundle shared libraries they use so you don’t need to
install them separately. Python installations may also bundle shared
libraries—​for example, the standard <code>ssl</code> module uses OpenSSL, an open source
library for secure communication.</p>
</dd>
<dt>Header Files</dt>
<dd>
<p>Python installations contain header files for the <em>Python/C API</em>, an
application programming interface for writing extension modules or embedding
Python as a component in a larger application. They’re located under <em>Include</em>
(Windows) or <em>include/python3.x</em> (Linux and macOS).</p>
</dd>
<dt>Static data</dt>
<dd>
<p>Python installations also contain static data in various locations. This
includes configuration files, documentation, and any resource files shipped
with third-party packages.</p>
</dd>
<dt>Tcl/Tk</dt>
<dd>
<p>By default, Python installations also include <em>Tcl/Tk</em>, a toolkit for creating
graphical user interfaces (GUIs) written in Tcl. The standard <code>tkinter</code> module
allows you to use this toolkit from Python.</p>
</dd>
</dl>
</div></section>
</div></section>








<section data-type="sect2" data-pdf-bookmark="The Per-User Environment"><div class="sect2" id="section_environments_peruser">
<h2>The Per-User Environment</h2>

<p>The <em>per-user environment</em> allows you to install third-party packages for a
single user. It offers two main benefits over installing packages system-wide:
You don’t need administrative privileges to install packages, and you don’t
affect other users on a multi-user system.</p>

<p>The per-user environment is located in the home directory on Linux and macOS and
in the app data directory on Windows (see <a data-type="xref" href="#table_environments_peruser">Table 2-3</a>). It
contains a <em>site-packages</em> directory for every Python version. Entry-point
scripts are shared across Python versions, except on macOS, where the entire
per-user installation is kept under a version-specific directory.<sup><a data-type="noteref" id="id253-marker" href="ch02.html#id253">4</a></sup></p>
<table id="table_environments_peruser">
<caption><span class="label">Table 2-3. </span>Location of per-user directories</caption>
<thead>
<tr>
<th>Platform</th>
<th>Third-party packages</th>
<th>Entry-point scripts</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Windows</p></td>
<td><p><em>%AppData%\Python\Python3x\site-packages</em></p></td>
<td><p><em>%AppData%\Python\Scripts</em></p></td>
</tr>
<tr>
<td><p>macOS</p></td>
<td><p><em>~/Library/Python/3.x/lib/python/site-packages</em></p></td>
<td><p><em>~/Library/Python/3.x/bin</em></p></td>
</tr>
<tr>
<td><p>Linux</p></td>
<td><p><em>~/.local/lib/python3.x/site-packages</em><sup><a data-type="noteref" id="id254-marker" href="ch02.html#id254">a</a></sup></p></td>
<td><p><em>~/.local/bin</em></p></td>
</tr>
</tbody>
<tbody><tr class="footnotes"><td colspan="3"><p data-type="footnote" id="id254"><sup><a href="ch02.html#id254-marker">a</a></sup> Fedora places extension modules under <em>lib64</em>.</p></td></tr></tbody></table>

<p>You install a package into the per-user environment using <code>py -m pip
install --user <em>&lt;package&gt;</em></code>. If you invoke <code>pip</code> outside of
a virtual environment and pip finds that it can’t write to the system-wide
installation, it will also default to this location. If the per-user environment
doesn’t exist yet, pip creates it for you.</p>
<div data-type="tip"><h6>Tip</h6>
<p>The per-user script directory may not be on <code>PATH</code> by default. If you install
applications into the per-user environment, remember to edit your shell profile
to update the search path. Pip issues a friendly reminder when it detects this
situation.</p>
</div>

<p>Per-user environments have an important shortcoming: by design, they’re not
isolated from the global environment. You can still import system-wide site
packages if they’re not shadowed by per-user modules with the same name.
Applications in the per-user environment also aren’t isolated from each
other—​in particular, they can’t depend on incompatible versions of another
package. Even applications in the system-wide environment can import modules
from the per-user environment.</p>

<p>And there’s another drawback: you can’t install packages into the per-user
environment if the Python installation is marked as <em>externally managed</em>—for
example, if you installed Python using the package manager of your distribution.</p>

<p>In <a data-type="xref" href="#section_environments_pipx">“Installing Applications with Pipx”</a>, I’ll introduce pipx, which lets you install
applications in isolated environments. It uses the per-user script directory to
put applications onto your search path, but relies on virtual environments under
the hood.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Virtual Environments"><div class="sect2" id="section_environments_venv">
<h2>Virtual Environments</h2>

<p>When you’re working on a Python project that uses third-party packages, it’s
usually a bad idea to install these packages into the system-wide or per-user
environments. First, you’re polluting a global namespace. Testing and debugging
your projects gets a lot easier when you run them in isolated and reproducible
environments. Second, if two projects depend on conflicting versions of the same
package, a single environment isn’t even an option. Third, as mentioned in the
previous section, you can’t install packages into environments marked as
<em>externally managed</em>.<sup><a data-type="noteref" id="id255-marker" href="ch02.html#id255">5</a></sup></p>

<p>Virtual environments were invented to solve these problems. They’re isolated
from the system-wide installation and from each other. Under the hood, a virtual
environment is a lightweight Python environment that stores third-party packages
and delegates most other things to a full installation. Packages in virtual
environments are only visible to the interpreter in the environment.</p>

<p>You create a virtual environment with the command <code>py -m venv
<em>&lt;directory&gt;</em></code>. The last argument is the location where
you want the environment to exist—​its root directory—​and conventionally named
<em>.venv</em>.</p>

<p>The directory tree of a virtual environment looks much like a Python
installation, except that some files are missing, most notably the entire
standard library. <a data-type="xref" href="#table_environments_venv">Table 2-4</a> shows the standard locations
within a virtual environment.</p>
<table id="table_environments_venv">
<caption><span class="label">Table 2-4. </span>Layout of a virtual environment</caption>
<thead>
<tr>
<th>Files</th>
<th>Windows</th>
<th>Linux and macOS</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>interpreter</p></td>
<td><p><em>Scripts</em></p></td>
<td><p><em>bin</em></p></td>
</tr>
<tr>
<td><p>entry-point scripts</p></td>
<td><p><em>Scripts</em></p></td>
<td><p><em>bin</em></p></td>
</tr>
<tr>
<td><p>third-party packages</p></td>
<td><p><em>Lib\site-packages</em></p></td>
<td><p><em>lib/python3.x/site-packages</em><sup><a data-type="noteref" id="id256-marker" href="ch02.html#id256">a</a></sup></p></td>
</tr>
<tr>
<td><p>environment configuration</p></td>
<td><p><em>pyvenv.cfg</em></p></td>
<td><p><em>pyvenv.cfg</em></p></td>
</tr>
</tbody>
<tbody><tr class="footnotes"><td colspan="3"><p data-type="footnote" id="id256"><sup><a href="ch02.html#id256-marker">a</a></sup> Fedora places third-party extension modules under <em>lib64</em> instead of <em>lib</em>.</p></td></tr></tbody></table>

<p>Virtual environments have their own <code>python</code> command, which is located next to
the entry-point scripts. On Linux and macOS, the command is a symbolic link to
the interpreter you used to create the environment. On Windows, it’s a small
wrapper executable that launches the parent interpreter.<sup><a data-type="noteref" id="id257-marker" href="ch02.html#id257">6</a></sup></p>










<section data-type="sect3" data-pdf-bookmark="Installing packages"><div class="sect3" id="id71">
<h3>Installing packages</h3>

<p>Virtual environments include pip as a means to install packages into
them.<sup><a data-type="noteref" id="id258-marker" href="ch02.html#id258">7</a></sup> Let’s create a virtual environment, install <code>httpx</code> (an HTTP client
library), and launch an interactive session. On Windows, enter the commands
below.</p>
<pre data-type="programlisting">&gt; <strong>py -m venv .venv</strong>
&gt; <strong>.venv\Scripts\python -m pip install httpx</strong>
&gt; <strong>.venv\Scripts\python</strong></pre>

<p>On Linux and macOS, enter the commands below. There’s no need to spell out the
path to the interpreter if the environment uses the well-known name <em>.venv</em>. The
Python Launcher for Unix selects its interpreter by default.</p>
<pre data-type="programlisting">$ <strong>py -m venv .venv</strong>
$ <strong>py -m pip install httpx</strong>
$ <strong>py</strong></pre>

<p>In the interactive session, use <code>httpx.get</code> to perform a <code>GET</code> request to a web
host:</p>
<pre data-type="programlisting">&gt;&gt;&gt; <strong>import httpx</strong>
&gt;&gt;&gt; <strong>httpx.get("https://example.com/")</strong>
&lt;Response [200 OK]&gt;</pre>

<p>Virtual environments come with the version of pip that was current when Python
was released. This can be a problem when you’re working with an old Python
release. Create the environment with the option <code>--upgrade-deps</code> to ensure you
get the latest pip release from the Python Package Index.</p>

<p>You can also create a virtual environment without pip using the option
<code>--without-pip</code> and install packages with an external installer. If you have pip
installed globally, you can pass the target environment using its <code>--python</code>
option, like this:</p>
<pre data-type="programlisting">$ <strong>pip --python=.venv install httpx</strong></pre>

<p>It’s easy to install a package into the Python installation or per-user
environment by accident—​especially if you’re used to invoking <code>pip</code> directly.
If your Python installation isn’t marked as externally managed, you may not even
notice. Fortunately, you can configure pip to always require a virtual
environment when installing packages:</p>
<pre data-type="programlisting">$ <strong>pip config set global.require-virtualenv true</strong></pre>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Activation scripts"><div class="sect3" id="section_environments_activation">
<h3>Activation scripts</h3>

<p>Virtual environments come with <em>activation scripts</em> in the <em>bin</em> or <em>Scripts</em>
directory—​these scripts make it more convenient to use a virtual environment
from the command line, and they’re provided for a number of supported shells and
command interpreters. Here’s the Windows example again, this time using the
activation script:</p>
<pre data-type="programlisting">&gt; <strong>py -m venv .venv</strong>
&gt; <strong>.venv\Scripts\activate</strong>
(.venv) &gt; <strong>py -m pip install httpx</strong>
(.venv) &gt; <strong>py</strong></pre>

<p>Activation scripts bring three features to your shell session:</p>

<ul>
<li>
<p>They prepend the script directory to the <code>PATH</code> variable. This allows you to
invoke <code>python</code>, <code>pip</code>, and entry-point scripts without prefixing them with
the path to the environment.</p>
</li>
<li>
<p>They set the <code>VIRTUAL_ENV</code> environment variable to the location of the virtual
environment. Tools like the Python Launcher use this variable to detect that
the environment is active.</p>
</li>
<li>
<p>They update your shell prompt to provide a visual reference which environment
is active, if any. By default, the prompt uses the name of the directory where
the environment is located.</p>
</li>
</ul>
<div data-type="tip"><h6>Tip</h6>
<p>You can provide a custom prompt using the option <code>--prompt</code> when creating the
environment. The special value <code>.</code> designates the current directory; it’s
particularly useful when you’re inside a project repository.</p>
</div>

<p>On macOS and Linux, you need to <em>source</em> the activation script to allow it to
affect your current shell session. Here’s an example for Bash and similar
shells:</p>
<pre data-type="programlisting">$ <strong>source .venv/bin/activate</strong></pre>

<p>Environments come with activation scripts for some other shells, as well. For
example, if you use the Fish shell, source the supplied <em>activate.fish</em> script
instead.</p>

<p>On Windows, you can invoke the activation script directly. There’s an
<em>Activate.ps1</em> script for PowerShell and an <em>activate.bat</em> script for <em>cmd.exe</em>.
You don’t need to provide the file extension; each shell selects the script
appropriate for it.</p>
<pre data-type="programlisting">&gt; <strong>.venv\Scripts\activate</strong></pre>

<p>PowerShell on Windows doesn’t allow you to execute scripts by default, but you
can change the execution policy to something more suited to development: The
<code>RemoteSigned</code> policy allows scripts written on the local machine or signed by a
trusted publisher. On Windows servers, this policy is already the default. You
only need to do this once—​the setting is stored in the registry.</p>
<pre data-type="programlisting">&gt; <strong>Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser</strong></pre>

<p>Activation scripts provide you with a <code>deactivate</code> command to revert the changes
to your shell environment. It’s usually implemented as a shell function, and
works the same on Windows, macOS, and Linux.</p>
<pre data-type="programlisting">$ <strong>deactivate</strong></pre>
</div></section>










<section data-type="sect3" data-pdf-bookmark="A look under the hood"><div class="sect3" id="id73">
<h3>A look under the hood</h3>

<p>How does Python know to import a third-party package like <code>httpx</code> from the
virtual environment instead of the Python installation? The location can’t be
hardcoded in the interpreter binary, given that virtual environments share the
interpreter with the Python installation. Instead, Python looks at the location
of the <code>python</code> command you used to launch the interpreter. If its parent
directory contains a <em>pyvenv.cfg</em> file, Python treats that file as a <em>landmark</em>
for a virtual environment and imports third-party modules from the
<em>site-packages</em> directory beneath.</p>

<p>This explains how you import third-party modules from the virtual environment,
but how does Python find modules from the standard library? After all, they’re
neither copied nor linked into the virtual environment. Again, the answer lies
in the <em>pyvenv.cfg</em> file: When you create a virtual environment, the interpreter
records its own location under the <code>home</code> key in this file. If it later finds
itself in a virtual environment, it looks for the standard library relative to
that <code>home</code> directory.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The name <em>pyvenv.cfg</em> is a remnant of the <code>pyvenv</code> script which used to ship
with Python. The <code>py -m venv</code> form makes it clearer which interpreter you use to
create the virtual environment—​and thus which interpreter the environment
itself will use.</p>
</div>

<p>While the virtual environment has access to the standard library in the
system-wide environment, it’s isolated from its third-party modules. (Although
not recommended, you can give the environment access to those modules as well,
using the <code>--system-site-packages</code> option when creating the environment.)</p>

<p>How does pip know where to install packages? The short answer is that pip asks
the interpreter it’s running on, and the interpreter derives the location from
its own path—​just like when you import a module.<sup><a data-type="noteref" id="id259-marker" href="ch02.html#id259">8</a></sup> This is why it’s best to run pip with an explicit interpreter using
the <code>py -m pip</code> idiom. If you invoke <code>pip</code> directly, the system searches your
<code>PATH</code> and may come up with the entry-point script from a different environment.</p>
</div></section>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Installing Applications with Pipx"><div class="sect1" id="section_environments_pipx">
<h1>Installing Applications with Pipx</h1>

<p>In <a data-type="xref" href="#section_environments_venv">“Virtual Environments”</a>, you saw why it makes good sense to install
your projects in separate virtual environments: unlike system-wide and per-user
environments, virtual environments isolate your projects, avoiding dependency
conflicts.</p>

<p>The same reasoning applies when you install third-party Python
applications—​say, a code formatter like Black or a packaging manager like
Hatch. Applications tend to depend on more packages than libraries, and they can
be quite picky about the versions of their dependencies.</p>

<p>Unfortunately, managing and activating a separate virtual environment for every
application is cumbersome and confusing—​and it limits you to using only a
single application at a time. Wouldn’t it be great if we could confine
applications to virtual environments and still have them available globally?</p>

<p>That’s precisely what <a href="https://pypa.github.io/pipx/">pipx</a> does, and it leverages
a simple idea to make it possible: it copies or symlinks the entry-point script
for the application from its virtual environment into a directory on your search
path. Entry-point scripts contain the full path to the environment’s
interpreter, so you can copy them anywhere you want, and they’ll still work.</p>








<section data-type="sect2" data-pdf-bookmark="Pipx in a Nutshell"><div class="sect2" id="id75">
<h2>Pipx in a Nutshell</h2>

<p>Let me show you how this works in a nutshell—​the commands below are for Linux
or macOS. First, you create a shared directory for the entry-point scripts of
your applications and add it to your <code>PATH</code> environment variable:</p>
<pre data-type="programlisting">$ <strong>mkdir -p ~/.local/bin</strong>
$ <strong>export PATH="$HOME/.local/bin:$PATH"</strong></pre>

<p>Next, you install an application in a dedicated virtual environment—​I’ve chosen
the Black code formatter as an example:</p>
<pre data-type="programlisting">$ <strong>py -m venv black</strong>
$ <strong>black/bin/python -m pip install black</strong></pre>

<p>Finally, you copy the entry-point script into the directory you created in the
first step—​that would be a script named <code>black</code> in the <em>bin</em> directory of the
environment:</p>
<pre data-type="programlisting">$ <strong>cp black/bin/black ~/.local/bin</strong></pre>

<p>Now you can invoke <code>black</code> even though the virtual environment is not active:</p>
<pre data-type="programlisting">$ <strong>black --version</strong>
black, 24.2.0 (compiled: yes)
Python (CPython) 3.12.2</pre>

<p>On top of this simple idea, the pipx project has built a cross-platform package
manager for Python applications with a great developer experience.</p>
<div data-type="tip"><h6>Tip</h6>
<p>If there’s a single Python application that you should install on a development
machine, pipx is probably it. It lets you install, run, and manage all the other
Python applications in a way that’s convenient and avoids trouble.</p>
</div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Installing Pipx"><div class="sect2" id="id76">
<h2>Installing Pipx</h2>

<p>If your system package manager distributes pipx as a package, I recommend using
that as the preferred installation method, as it’s more likely to provide good
integration out-of-the-box:</p>
<pre data-type="programlisting">$ <strong>apt install pipx</strong>
$ <strong>brew install pipx</strong>
$ <strong>dnf install pipx</strong></pre>

<p>As a post-installation step, update your <code>PATH</code> environment variable to include
the shared script directory, using the <code>ensurepath</code> subcommand. (If you’ve
modified your <code>PATH</code> variable when running the commands above, open a new
terminal first.)</p>
<pre data-type="programlisting">$ <strong>pipx ensurepath</strong></pre>

<p>On Windows, and if your system package manager doesn’t distribute pipx, I
recommend installing pipx into the per-user environment, like this:</p>
<pre data-type="programlisting">$ <strong>py -m pip install --user pipx</strong>
$ <strong>py -m pipx ensurepath</strong></pre>

<p>The second step also puts the <code>pipx</code> command itself on your search path.</p>

<p>If you don’t already have shell completion for pipx, activate it by following
the instructions for your shell, which you can print with this command:</p>
<pre data-type="programlisting">$ <strong>pipx completions</strong></pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Managing Applications with Pipx"><div class="sect2" id="id77">
<h2>Managing Applications with Pipx</h2>

<p>With pipx installed on your system, you can use it to install and manage
applications from the Python Package Index (PyPI). For example, here’s how you
would install Black with pipx:</p>
<pre data-type="programlisting">$ <strong>pipx install black</strong></pre>

<p>You can also use pipx to upgrade an application to a new release, reinstall it,
or uninstall it from your system:</p>
<pre data-type="programlisting">$ <strong>pipx upgrade black</strong>
$ <strong>pipx reinstall black</strong>
$ <strong>pipx uninstall black</strong></pre>

<p>As a package manager, pipx keeps track of the applications it installs and lets
you perform bulk operations across all of them. This is particularly useful to
keep your development tools updated to the latest version and to reinstall them
on a new version of Python.</p>
<pre data-type="programlisting">$ <strong>pipx upgrade-all</strong>
$ <strong>pipx reinstall-all</strong>
$ <strong>pipx uninstall-all</strong></pre>

<p>You can also list the applications you’ve installed previously:</p>
<pre data-type="programlisting">$ <strong>pipx list</strong></pre>

<p>Some applications support plugins that extend their functionality. These plugins
must be installed in the same environment as the application. For example, the
packaging managers Hatch and Poetry both come with plugin systems. Here’s how
you would install Hatch with a plugin that determines the package version from
the version control system (see
<a data-type="xref" href="ch03.html#section_packages_single_sourcing_the_version">“Single-sourcing the project version”</a>):</p>
<pre data-type="programlisting">$ <strong>pipx install hatch</strong>
$ <strong>pipx inject hatch hatch-vcs</strong>
</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Running Applications with Pipx"><div class="sect2" id="id78">
<h2>Running Applications with Pipx</h2>

<p>The commands above provide all the primitives to manage global developer tools
efficiently, but it gets better. Most of the time, you just want to use recent
versions of your developer tools. You don’t want the responsibility of keeping
the tools updated, reinstalling them on new Python versions, or removing them
when you no longer need them. Pipx allows you to run an application directly
from PyPI without an explicit installation step. Let’s use the classic Cowsay
app to try it:</p>
<pre data-type="programlisting">$ <strong>pipx run cowsay moo</strong>
  ___
| moo |
  ===
   \
    \
      ^__^
      (oo)\_______
      (__)\       )\/\
          ||----w |
          ||     ||
</pre>

<p>Behind the scenes, pipx installs Cowsay in a temporary virtual environment and
runs it with the arguments you’ve provided. It keeps the environment around for
a while,<sup><a data-type="noteref" id="id260-marker" href="ch02.html#id260">9</a></sup> so you don’t end up reinstalling applications on
every run. Use the <code>--no-cache</code> option to force pipx to create a new environment
and reinstall the latest version.</p>

<p>You may have noticed an implicit assumption in the <code>run</code> command: that the PyPI
package must have the same name as the command it provides. This may seem a
reasonable expectation—​but what if a Python package provides multiple commands?
For example, the pip-tools package (see <a data-type="xref" href="ch04.html#section_dependencies_piptools">“Compiling Requirements with pip-tools and uv”</a>)
provides commands named <code>pip-compile</code> and <code>pip-sync</code>.</p>

<p>If you find yourself in this situation, provide the PyPI name using the <code>--spec</code>
option, like this:</p>
<pre data-type="programlisting">$ <strong>pipx run --spec pip-tools pip-sync</strong></pre>
<div data-type="tip"><h6>Tip</h6>
<p>Use <code>pipx run <em>&lt;app&gt;</em></code> as the default method to
install and run developer tools from PyPI. Use <code>pipx install
<em>&lt;app&gt;</em></code> if you need more control over application
environments, for example if you need to install plugins. (Replace
<code><em>&lt;app&gt;</em></code> with the name of the app.)</p>
</div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Configuring Pipx"><div class="sect2" id="section_environments_pipx_configuration">
<h2>Configuring Pipx</h2>

<p>By default, pipx installs applications on the same Python version that it runs
on itself. This may not be the latest stable version, particularly if you
installed pipx using a system package manager like APT. I recommend setting the
environment variable <code>PIPX_DEFAULT_PYTHON</code> to the latest stable Python if that’s
the case. Many developer tools you run with pipx create their own virtual
environments; for example, virtualenv, Nox, tox, Poetry, and Hatch all do. It’s
worthwhile to ensure that all downstream environments use a recent Python
version by default.</p>
<pre data-type="programlisting">$ <strong>export PIPX_DEFAULT_PYTHON=python3.12</strong> # Linux and macOS
&gt; <strong>setx PIPX_DEFAULT_PYTHON python3.12</strong>   # Windows
</pre>

<p>Under the hood, pipx uses pip as a package installer. This means that any
configuration you have for pip also carries over to pipx. A common use case is
installing Python packages from a private index instead of PyPI, such as a
company-wide package repository.</p>

<p>You can use <code>pip config</code> to set the URL of your preferred package index
persistently:</p>
<pre data-type="programlisting">$ <strong>pip config set global.index-url https://example.com</strong></pre>

<p>Alternatively, you can set the package index for the current shell session only.
Most pip options are also available as environment variables:</p>
<pre data-type="programlisting">$ <strong>export PIP_INDEX_URL=https://example.com</strong></pre>

<p>Both methods cause pipx to install applications from the specified index.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Managing Environments with uv"><div class="sect1" id="section_environments_uv">
<h1>Managing Environments with uv</h1>

<p>The tool <code>uv</code> is a drop-in replacement for core Python packaging tools, written
in the Rust programming language. It offers order-of-magnitude performance
improvements over the Python tools it replaces, in a single static binary
without dependencies. While its <code>uv venv</code> and <code>uv pip</code> subcommands aim for
compatibility with virtualenv and pip, uv also embraces evolving best practices,
such as operating in a virtual environment by default.</p>

<p>Install uv with pipx:</p>
<pre data-type="programlisting">$ <strong>pipx install uv</strong></pre>

<p>By default, uv creates a virtual environment using the well-known name <em>.venv</em>
(you can pass another location as an argument):</p>
<pre data-type="programlisting">$ <strong>uv venv</strong></pre>

<p>Specify the interpreter for the virtual environment using the <code>--python</code> option
with a specification like <code>3.12</code> or <code>python3.12</code>; a full path to an interpreter
also works. Uv discovers available interpreters by scanning your <code>PATH</code>. On
Windows, it also inspects the output of <code>py --list-paths</code>. If you don’t specify
an interpreter, uv defaults to <code>python3</code> on Linux and macOS, and <code>python.exe</code> on
Windows.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Despite its name, <code>uv venv</code> emulates the Python tool virtualenv, not the
built-in <code>venv</code> module. Virtualenv creates environments with any Python
interpreter on your system. It combines interpreter discovery with aggressive
caching to make this fast and flawless.</p>
</div>

<p>By default, uv installs packages into the environment named <em>.venv</em> in the
current directory or one of its parent directories (using the same logic as the
Python Launcher for Unix):</p>
<pre data-type="programlisting">$ <strong>uv pip install httpx</strong></pre>

<p>You can install packages into another environment by activating it—​this works
for both virtual environments (<code>VIRTUAL_ENV</code>) and Conda environments
(<code>CONDA_PREFIX</code>). If there’s neither an active environment nor a <em>.venv</em>
directory, uv bails out with an error. It will never install or uninstall
packages from your global environment, unless you explicitly ask it to do so
using the <code>--system</code> option.</p>

<p>While uv’s initial development has focused on providing drop-in replacements for
standard Python tooling, its ultimate goal is to grow into that one unified
packaging tool that has eluded Python for so long—​with the kind of developer
experience that Rust developers love about Cargo. Even at this early stage, uv
gives you a unified and streamlined workflow, thanks to a cohesive feature set
with good defaults. And it’s blazingly fast.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Finding Python Modules"><div class="sect1" id="id81">
<h1>Finding Python Modules</h1>

<p>Python environments consist, first and foremost, of a Python interpreter and
Python modules. Consequently, there are two mechanisms that play a key role in
linking a Python program to an environment: interpreter discovery and module
import.</p>

<p><em>Interpreter discovery</em> is the process of locating the Python interpreter to
execute a program. You’ve already seen the most important methods for locating
interpreters:</p>

<ul>
<li>
<p>Entry-point scripts reference the interpreter in their environment directly,
using a shebang or a wrapper executable (see <a data-type="xref" href="#section_environments_scripts">“Entry-point scripts”</a>).</p>
</li>
<li>
<p>Shells locate the interpreter by searching directories on <code>PATH</code> for commands
like <code>python</code>, <code>python3</code>, or <code>python3.x</code> (see <a data-type="xref" href="ch01.html#section_path">“Locating Python Interpreters”</a>).</p>
</li>
<li>
<p>The Python Launcher locates interpreters using the Windows Registry, <code>PATH</code>
(on Linux and macOS), and the <code>VIRTUAL_ENV</code> variable (see
<a data-type="xref" href="ch01.html#section_python_launcher_windows">“The Python Launcher for Windows”</a> and <a data-type="xref" href="ch01.html#section_python_launcher_unix">“The Python Launcher for Unix”</a>).</p>
</li>
<li>
<p>When you activate a virtual environment, the activation script puts its
interpreter and entry-point scripts on <code>PATH</code>. It also sets the <code>VIRTUAL_ENV</code>
variable for the Python Launcher and other tools (see
<a data-type="xref" href="#section_environments_venv">“Virtual Environments”</a>).</p>
</li>
</ul>

<p>This section takes a deep dive into the other mechanism that links programs to
an environment: <em>module import</em>, which is the process of locating and loading
Python modules for a program.</p>
<div data-type="tip"><h6>Tip</h6>
<p>In a nutshell, just like the shell searches <code>PATH</code> for executables, Python
searches <code>sys.path</code> for modules. This variable holds a list of locations from
where Python can load modules—​most commonly, directories on the local
filesystem.</p>
</div>

<p>The machinery behind the <code>import</code> statement lives in <code>importlib</code> from the
standard library (see <a data-type="xref" href="#sidebar_environments_importlib">“Inspecting modules and packages with importlib”</a>). The interpreter
translates every use of the <code>import</code> statement into an invocation of the
<code>__import__</code> function from <code>importlib</code>. The <code>importlib</code> module also exposes an
<code>import_module</code> function that allows you to import modules whose names are only
known at runtime.</p>

<p>Having the import system in the standard library lets you inspect and customize
the import mechanism from within Python. For example, the import system supports
loading modules from directories and from zip archives out of the box. But
entries on <code>sys.path</code> can be anything really—​say, a URL or a database query—​as
long as you register a function in <code>sys.path_hooks</code> that knows how to find and
load modules from these path entries.</p>








<section data-type="sect2" data-pdf-bookmark="Module Objects"><div class="sect2" id="id82">
<h2>Module Objects</h2>

<p>When you import a module, the import system returns a <em>module object</em>, an object
of type <code>types.ModuleType</code>. Any global variable defined by the imported module
becomes an attribute of the module object. This allows you to access the module
variable in dotted notation (<code>module.var</code>) from the importing code.</p>

<p>Under the hood, module variables are stored in a dictionary in the <code>__dict__</code>
attribute of the module object. (This is the standard mechanism used to store
attributes of any Python object.) When the import system loads a module, it
creates a module object and executes the module’s code using <code>__dict__</code> as the
global namespace. To simplify somewhat, it invokes the built-in <code>exec</code> function
like this:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">exec</code><code class="p">(</code><code class="n">code</code><code class="p">,</code> <code class="n">module</code><code class="o">.</code><code class="vm">__dict__</code><code class="p">)</code></pre>

<p>Additionally, module objects have some special attributes. For instance, the
<code>__name__</code> attribute holds the fully-qualified name of the module, like
<code>email.message</code>. The <code>__spec__</code> module holds the <em>module spec</em>, which I’ll talk
about shortly. Packages also have a <code>__path__</code> attribute, which contains
locations to search for submodules.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Most commonly, the <code>__path__</code> attribute of a package contains a single entry:
the directory holding its <em>__init__.py</em> file. Namespace packages, on the
other hand, can be distributed across multiple directories.</p>
</div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="The Module Cache"><div class="sect2" id="section_environments_module_cache">
<h2>The Module Cache</h2>

<p>When you first import a module, the import system stores the module object in
the <code>sys.modules</code> dictionary, using its fully-qualified name as a key.
Subsequent imports return the module object directly from <code>sys.modules</code>. This
mechanism brings a number of benefits:</p>
<dl>
<dt>Performance</dt>
<dd>
<p>Imports are expensive because the import system loads most modules from disk.
Importing a module also involves executing its code, which can further
increase startup time. The <code>sys.modules</code> dictionary functions as a cache to
speed things up.</p>
</dd>
<dt>Idempotency</dt>
<dd>
<p>Importing modules can have side effects, for example when executing
module-level statements. Caching modules in <code>sys.modules</code> ensures that these
side effects happen only once. The import system also uses locks to ensure
that multiple threads can safely import the same module.</p>
</dd>
<dt>Recursion</dt>
<dd>
<p>Modules can end up importing themselves recursively. A common case is
<em>circular imports</em>, where module <code>a</code> imports module <code>b</code>, and <code>b</code> imports <code>a</code>.
The import system supports this by adding modules to <code>sys.modules</code> <em>before</em>
they’re executed. When <code>b</code> imports <code>a</code>, the import system returns the
(partially initialized) module <code>a</code> from the <code>sys.modules</code> dictionary, thereby
preventing an infinite loop.</p>
</dd>
</dl>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Module Specs"><div class="sect2" id="id84">
<h2>Module Specs</h2>

<p>Conceptually, Python imports a module in two steps: <em>finding</em> and <em>loading</em>.
First, given the fully-qualified name of a module, the import system locates the
module and produces a module spec (<code>importlib.machinery.ModuleSpec</code>). Second,
the import system creates a module object from the module spec and executes the
module’s code.</p>

<p>The module spec is the link between those two steps. A <em>module spec</em> contains
metadata about a module such as its name and location, as well as an appropriate
loader for the module (<a data-type="xref" href="#table_environments_module_spec">Table 2-5</a>). You can also access
most of the metadata from the module spec using special attributes directly on
the module object.</p>
<table id="table_environments_module_spec">
<caption><span class="label">Table 2-5. </span>Attributes of Module Specs and Module Objects</caption>
<thead>
<tr>
<th>Spec Attribute</th>
<th>Module attribute</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>name</code></p></td>
<td><p><code>__name__</code></p></td>
<td><p>The fully-qualified name of the module.</p></td>
</tr>
<tr>
<td><p><code>loader</code></p></td>
<td><p><code>__loader__</code></p></td>
<td><p>A loader object that knows how to execute the module’s code.</p></td>
</tr>
<tr>
<td><p><code>origin</code></p></td>
<td><p><code>__file__</code></p></td>
<td><p>The location of the module.</p></td>
</tr>
<tr>
<td><p><code>submodule_search_locations</code></p></td>
<td><p><code>__path__</code></p></td>
<td><p>Where to search for submodules, if the module is a package.</p></td>
</tr>
<tr>
<td><p><code>cached</code></p></td>
<td><p><code>__cached__</code></p></td>
<td><p>The location of the compiled bytecode for the module.</p></td>
</tr>
<tr>
<td><p><code>parent</code></p></td>
<td><p><code>__package__</code></p></td>
<td><p>The fully-qualified name of the containing package.</p></td>
</tr>
</tbody>
</table>

<p>The <code>__file__</code> attribute of a module typically holds the filename of the Python
module. In special cases, it’s a fixed string, like <code>"builtin"</code> for built-in
modules, or <code>None</code> for namespace packages (which don’t have a single location).</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Finders and Loaders"><div class="sect2" id="id85">
<h2>Finders and Loaders</h2>

<p>The import system finds and loads modules using two kinds of objects. <em>Finders</em>
(<code>importlib.abc.MetaPathFinder</code>) are responsible for locating modules given
their fully-qualified names. When successful, their <code>find_spec</code> method returns a
module spec with a loader; otherwise, it returns <code>None</code>. <em>Loaders</em>
(<code>importlib.abc.Loader</code>) are objects with an <code>exec_module</code> function which load
and execute the module’s code. The function takes a module object and uses it as
a namespace when executing the module. The finder and loader can be the same
object, which is then known as an <em>importer</em>.</p>

<p>Finders are registered in the <code>sys.meta_path</code> variable, and the import system
tries each finder in turn. When a finder has returned a module spec with a
loader, the import system creates and initializes a module object, then passes
it to the loader for execution.</p>

<p>By default, the <code>sys.meta_path</code> variable contains three finders, which handle
different kinds of modules (see <a data-type="xref" href="#section_environments_modules">“Python modules”</a>):</p>

<ul>
<li>
<p><code>importlib.machinery.BuiltinImporter</code> for built-in modules</p>
</li>
<li>
<p><code>importlib.machinery.FrozenImporter</code> for frozen modules</p>
</li>
<li>
<p><code>importlib.machinery.PathFinder</code> to search modules on <code>sys.path</code></p>
</li>
</ul>

<p>The <code>PathFinder</code> is the central hub of the import machinery. It’s responsible
for every module that’s not embedded into the interpreter, and searches
<code>sys.path</code> to locate it.<sup><a data-type="noteref" id="id261-marker" href="ch02.html#id261">10</a></sup> The path
finder uses a second level of finder objects known as <em>path entry finders</em>
(<code>importlib.abc.PathEntryFinder</code>), each of which finds modules under a specific
location on <code>sys.path</code>. The standard library provides two types of path entry
finders, registered under <code>sys.path_hooks</code>:</p>

<ul>
<li>
<p><code>zipimport.zipimporter</code> to import modules from zip archives</p>
</li>
<li>
<p><code>importlib.machinery.FileFinder</code> to import modules from a directory</p>
</li>
</ul>

<p>Typically, modules are stored in directories on the filesystem, so <code>PathFinder</code>
delegates its work to a <code>FileFinder</code>. The latter scans the directory for the
module, and uses its file extension to determine the appropriate loader. There
are three loaders for the different kinds of modules:</p>

<ul>
<li>
<p><code>importlib.machinery.SourceFileLoader</code> for pure Python modules</p>
</li>
<li>
<p><code>importlib.machinery.SourcelessFileLoader</code> for bytecode modules</p>
</li>
<li>
<p><code>importlib.machinery.ExtensionFileLoader</code> for binary extension modules</p>
</li>
</ul>

<p>The zip importer works similarly, except that it doesn’t support extension
modules, because current operating systems don’t allow loading dynamic libraries
from a zip archive.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="The Module Path"><div class="sect2" id="id86">
<h2>The Module Path</h2>

<p>When your program can’t find a specific module, or imports the wrong version of
a module, it can help to take a look at <code>sys.path</code>, the module path. But where
do the entries on <code>sys.path</code> come from in the first place? Let’s unravel some of
the mysteries of the module path.</p>

<p>When the interpreter starts up, it constructs the module path in two steps.
First, it builds an initial module path using some built-in logic. Most
importantly, this initial path includes the standard library. Second, the
interpreter imports the <code>site</code> module from the standard library. The <code>site</code>
module extends the module path to include the site packages from the current
environment.</p>

<p>In this section, we’ll take a look at how the interpreter constructs the initial
module path with the standard library. The next section explains how the <code>site</code>
module appends directories with site packages.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You can find the built-in logic for constructing <code>sys.path</code> in
<em>Modules/getpath.py</em> in the CPython source code. Despite appearances, this is
not an ordinary module. When you build Python, its code is frozen to bytecode
and embedded in the executable.</p>
</div>

<p>The locations on the initial module path fall into three categories, and they
occur in the order given below:</p>
<ol>
<li>
<p>The current directory or the directory containing the Python script (if any)</p>
</li>
<li>
<p>The locations in the <code>PYTHONPATH</code> environment variable (if set)</p>
</li>
<li>
<p>The locations of the standard library</p>
</li>

</ol>

<p>Let’s look at each in more detail.</p>










<section data-type="sect3" data-pdf-bookmark="The current directory or the directory containing the script"><div class="sect3" id="id87">
<h3>The current directory or the directory containing the script</h3>

<p>The first item on <code>sys.path</code> can be any of the following:</p>

<ul>
<li>
<p>If you ran <code>py <em>&lt;script&gt;</em></code>, the directory where
the script is located</p>
</li>
<li>
<p>If you ran <code>py -m <em>&lt;module&gt;</em></code>, the current
directory</p>
</li>
<li>
<p>Otherwise, the empty string, which also denotes the current directory</p>
</li>
</ul>

<p>Traditionally, this mechanism has long provided a convenient way to structure an
application: Just put the main entry-point script and all application modules in
the same directory. During development, launch the interpreter from within that
directory for interactive debugging, and your imports will still work.</p>

<p>Unfortunately, having the working directory on <code>sys.path</code> is quite unsafe, as an
attacker (or you, mistakenly) can override the standard library by placing
Python files in the victim’s directory. To avoid this, starting with Python
3.11, you can use the <code>-P</code> interpreter option or the <code>PYTHONSAFEPATH</code>
environment variable to omit the current directory from <code>sys.path</code>. If you
invoke the interpreter with a script, this option also omits the directory where
the script is located.</p>

<p>Installing your application into a virtual environment is a safer and more
flexible approach than putting its modules in the current directory. This
requires packaging the application, which is the topic of <a data-type="xref" href="ch03.html#chapter_packages">Chapter 3</a>.</p>
</div></section>










<section data-type="sect3" data-pdf-bookmark="The PYTHONPATH variable"><div class="sect3" id="id88">
<h3>The PYTHONPATH variable</h3>

<p>The <code>PYTHONPATH</code> environment variable provides another way to add locations
before the standard library on <code>sys.path</code>. It uses the same syntax as the <code>PATH</code>
variable. Avoid this mechanism for the same reasons as the current working
directory and use a virtual environment instead.</p>
</div></section>










<section data-type="sect3" data-pdf-bookmark="The standard library"><div class="sect3" id="id89">
<h3>The standard library</h3>

<p><a data-type="xref" href="#table_environments_stdlib_path">Table 2-6</a> shows the remaining entries on the initial
module path, which are dedicated to the standard library. Locations are prefixed
with the path to the installation, and may differ in details on some platforms.
Notably, Fedora places the standard library under <em>lib64</em> instead of <em>lib</em>.</p>
<table id="table_environments_stdlib_path">
<caption><span class="label">Table 2-6. </span>The standard library on <code>sys.path</code></caption>
<thead>
<tr>
<th>Windows</th>
<th>Linux and macOS</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><em>python3x.zip</em></p></td>
<td><p><em>lib/python3x.zip</em></p></td>
<td><p>For compactness, the standard library can be installed as a zip archive. This entry is present even if the archive doesn’t exist (which it normally doesn’t).</p></td>
</tr>
<tr>
<td><p><em>Lib</em></p></td>
<td><p><em>lib/python3.x</em></p></td>
<td><p>Pure Python modules</p></td>
</tr>
<tr>
<td><p><em>DLLs</em></p></td>
<td><p><em>lib/python3.x/lib-dynload</em></p></td>
<td><p>Binary extension modules</p></td>
</tr>
</tbody>
</table>

<p>The location of the standard library is not hardcoded in the interpreter (see
<a data-type="xref" href="#section_environments_venv">“Virtual Environments”</a>). Rather, Python looks for landmark files on
the path to its own executable, and uses them to locate the current environment
(<code>sys.prefix</code>) and the Python installation (<code>sys.base_prefix</code>). One such
landmark file is <em>pyvenv.cfg</em>, which marks a virtual environment and points to
its parent installation via the <code>home</code> key. Another landmark is <em>os.py</em>, the
file containing the standard <code>os</code> module: Python uses <em>os.py</em> to discover the
prefix outside of a virtual environment, and to locate the standard library
itself.</p>
</div></section>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Site Packages"><div class="sect2" id="section_environments_site_packages">
<h2>Site Packages</h2>

<p>The interpreter constructs the initial <code>sys.path</code> early on during initialization
using a fairly fixed process. By contrast, the remaining locations on
<code>sys.path</code>—known as <em>site packages</em>—are highly customizable and under the
responsibility of a Python module named <code>site</code>.</p>

<p>The <code>site</code> module adds the following path entries if they exist on the
filesystem:</p>
<dl>
<dt>User site packages</dt>
<dd>
<p>This directory holds third-party packages from the per-user environment. It’s
in a fixed location that depends on the OS (see
<a data-type="xref" href="#section_environments_peruser">“The Per-User Environment”</a>). On Fedora and some other systems, there are
two path entries: for pure Python modules and extension modules, respectively.</p>
</dd>
<dt>Site packages</dt>
<dd>
<p>This directory holds third-party packages from the current environment, which
is either a virtual environment or a system-wide installation. On Fedora and
some other systems, pure Python modules and extension modules are in separate
directories. Many Linux systems also separate distribution-owned site packages
under <em>/usr</em> from local site packages under <em>/usr/local</em>.</p>
</dd>
</dl>

<p>In the general case, the site packages are in a subdirectory of the standard
library named <em>site-packages</em>. If the <code>site</code> module finds a <em>pyvenv.cfg</em> file on
the interpreter path, it uses the same relative path as in a system
installation, but starts from the virtual environment marked by that file. The
<code>site</code> module also modifies <code>sys.prefix</code> to point to the virtual environment.</p>

<p>The <code>site</code> module provides a few hooks for customization:</p>
<dl>
<dt><em>.pth</em> files</dt>
<dd>
<p>Within site packages directories, any file with a <em>.pth</em> extension can list
additional directories for <code>sys.path</code>, one directory per line. This works
similar to <code>PYTHONPATH</code>, except that modules in these directories will never
shadow the standard library. Additionally, <em>.pth</em> files can import modules
directly—​the <code>site</code> module executes any line starting with <code>import</code> as Python
code. Third-party packages can ship <em>.pth</em> files to configure <code>sys.path</code> in an
environment. Some packaging tools use <em>.pth</em> files behind the scenes to
implement editable installs. An <em>editable install</em> places the source directory
of your project on <code>sys.path</code>, making code changes instantly visible inside
the environment.</p>
</dd>
<dt>The <code>sitecustomize</code> module</dt>
<dd>
<p>After setting up <code>sys.path</code> as described above, the <code>site</code> module attempts to
import the <code>sitecustomize</code> module, typically located in the <em>site-packages</em>
directory. This provides a hook for the system administrator to run
site-specific customizations when the interpreter starts up.</p>
</dd>
<dt>The <code>usercustomize</code> module</dt>
<dd>
<p>If there is a per-user environment, the <code>site</code> module also attempts to import
the <code>usercustomize</code> module, typically located in the user <em>site-packages</em>
directory. You can use this module to run user-specific customizations when
the interpreter starts up. Contrast this with the <code>PYTHONSTARTUP</code> environment
variable, which allows you to specify a Python script to run before
interactive sessions, within the same namespace as the session.</p>
</dd>
</dl>

<p>If you run the <code>site</code> module as a command, it prints out your current module
path, as well as some information about the per-user environment:</p>
<pre data-type="programlisting">$ <strong>py -m site</strong>
sys.path = [
    '/home/user',
    '/usr/local/lib/python312.zip',
    '/usr/local/lib/python3.12',
    '/usr/local/lib/python3.12/lib-dynload',
    '/home/user/.local/lib/python3.12/site-packages',
    '/usr/local/lib/python3.12/site-packages',
]
USER_BASE: '/home/user/.local' (exists)
USER_SITE: '/home/user/.local/lib/python3.12/site-packages' (exists)
ENABLE_USER_SITE: True
</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Back to the Basics"><div class="sect2" id="id91">
<h2>Back to the Basics</h2>

<p>If you’ve read this far, the module path may almost seem a little—<em>byzantine</em>?</p>

<p>Here’s a good, solid intuition of how Python locates a module: The interpreter
searches the directories on <code>sys.path</code> for the module—​first the directories
that contain the modules of the standard library, then the <em>site-packages</em>
directory with third-party packages. An interpreter in a virtual environment
uses the <em>site-packages</em> directory from that environment.</p>

<p>As you’ve seen in this section, the truth is far more complex than that simple
story. But I’ve got good news for you: Python lets you <em>make</em> that story true.
The <code>-P</code> interpreter option omits the directory containing your script from the
module path (or the current directory, if you’re running your program with
<code>py -m <em>&lt;module&gt;</em></code>). The <code>-I</code> interpreter option
omits the per-user environment from the module path, as well as any directories
set with <code>PYTHONPATH</code>. Use both options when running your Python programs if you
want a more predictable module path.</p>

<p>If you re-run the <code>site</code> module with the <code>-I</code> and <code>-P</code> options, the module path
is cut down to just the standard library and site packages:</p>
<pre data-type="programlisting">$ <strong>py -IPm site</strong>
sys.path = [
    '/usr/local/lib/python312.zip',
    '/usr/local/lib/python3.12',
    '/usr/local/lib/python3.12/lib-dynload',
    '/usr/local/lib/python3.12/site-packages',
]
USER_BASE: '/home/user/.local' (exists)
USER_SITE: '/home/user/.local/lib/python3.12/site-packages' (exists)
ENABLE_USER_SITE: False
</pre>

<p>The current directory no longer appears on the module path, and the per-user
site packages are gone, too—​even though the directory exists on this system.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="id92">
<h1>Summary</h1>

<p>In this chapter, you’ve learned what Python environments are, where to find
them, and how they look on the inside. At the core, a Python environment
consists of the Python interpreter and Python modules, as well as entry-point
scripts to run Python applications. Environments are tied to a specific version
of the Python language.</p>

<p>There are three kinds of Python environments. <em>Python installations</em> are
complete, stand-alone environments with an interpreter and the full standard
library. <em>Per-user environments</em> are annexes to an installation where you can
install modules and scripts for a single user. <em>Virtual environments</em> are
lightweight environments for project-specific modules and entry-point scripts,
which reference their parent environment via a <em>pyvenv.cfg</em> file. They come with
an interpreter, which is typically a symbolic link or small wrapper for the
parent interpreter, and with activation scripts for shell integration. You
create a virtual environment using the command <code>py -m venv</code>.</p>

<p>Install Python applications with pipx to make them available globally while
keeping them in separate virtual environments. You can install and run an
application using a single command, such as <code>pipx run black</code>. Set the
<code>PIPX_DEFAULT_PYTHON</code> variable to ensure pipx installs tools on the current
Python release.</p>

<p>Uv is a blazingly fast drop-in replacement for virtualenv and pip with better
defaults. Use <code>uv venv</code> to create a virtual environment, and <code>uv pip</code> to install
packages into it. Both commands use the <em>.venv</em> directory by default, just like
the <code>py</code> tool on Unix. The <code>--python</code> option lets you select the Python version
for the environment.</p>

<p>In the final section of this chapter, you’ve learned how Python uses <code>sys.path</code>
to locate modules when you import them, and how the module path is constructed
during interpreter startup. You’ve also learned how module import works under
the hood, using finders and loaders as well as the module cache. Interpreter
discovery and module import are the key mechanisms that link Python programs to
an environment at runtime.</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="id250"><sup><a href="ch02.html#id250-marker">1</a></sup> There’s also a <em>pythonw.exe</em> executable that runs programs without a console window, like GUI applications.</p><p data-type="footnote" id="id251"><sup><a href="ch02.html#id251-marker">2</a></sup> A <em>shared library</em> is a file with executable code that multiple programs can use at runtime. The operating system only keeps a single copy of the code in memory.</p><p data-type="footnote" id="id252"><sup><a href="ch02.html#id252-marker">3</a></sup> Windows installations don’t include an entry-point script for <code>pydoc</code>—launch it using <code>py -m pydoc</code> instead.</p><p data-type="footnote" id="id253"><sup><a href="ch02.html#id253-marker">4</a></sup> Historically, macOS framework builds pioneered per-user installation before it became a standard in 2008.</p><p data-type="footnote" id="id255"><sup><a href="ch02.html#id255-marker">5</a></sup> This is a good thing: installing and uninstalling Python packages behind your package manager’s back introduces a real chance of breaking your system.</p><p data-type="footnote" id="id257"><sup><a href="ch02.html#id257-marker">6</a></sup> You could force the use of symbolic links on Windows via the <code>--symlinks</code> option—​but don’t. There are subtle differences in the way these work on Windows. For example, the File Explorer resolves the symbolic link before it launches Python, which prevents the interpreter from detecting the virtual environment.</p><p data-type="footnote" id="id258"><sup><a href="ch02.html#id258-marker">7</a></sup> Before Python 3.12, the <code>venv</code> module also pre-installed <code>setuptools</code> for the benefit of legacy packages that don’t declare it as a build dependency.</p><p data-type="footnote" id="id259"><sup><a href="ch02.html#id259-marker">8</a></sup> Internally, pip queries the <code>sysconfig</code> module for an appropriate <em>installation scheme</em>—a Python environment layout. This module constructs the installation scheme using the build configuration of Python and the location of the interpreter in the filesystem.</p><p data-type="footnote" id="id260"><sup><a href="ch02.html#id260-marker">9</a></sup> At the time of writing in 2024, pipx caches temporary environments for 14 days.</p><p data-type="footnote" id="id261"><sup><a href="ch02.html#id261-marker">10</a></sup> For modules located within a package, the <code>__path__</code> attribute of the package takes the place of <code>sys.path</code>.</p></div></div></section></div>
</div>
</body></html>