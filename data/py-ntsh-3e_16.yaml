- en: Chapter 16\. Numeric Processing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章 数值处理
- en: 'You can perform some numeric computations with operators (covered in [“Numeric
    Operations”](ch03.xhtml#numeric_operations)) and built-in functions (covered in
    [“Built-in Functions”](ch08.xhtml#built_in_functions)). Python also provides modules
    that support additional numeric computations, covered in this chapter: math and
    cmath, statistics, operator, random and secrets, fractions, and decimal. Numeric
    processing often requires, more specifically, the processing of *arrays* of numbers;
    this topic is covered in [“Array Processing”](#array_processing), focusing on
    the standard library module array and popular third-party extension NumPy. Finally,
    [“Additional numeric packages”](#additional_numeric_packages) lists several additional
    numeric processing packages produced by the Python community. Most examples in
    this chapter assume you’ve imported the appropriate module; **import** statements
    are only included where the situation might be unclear.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用运算符（见[“数值操作”](ch03.xhtml#numeric_operations)）和内置函数（见[“内置函数”](ch08.xhtml#built_in_functions)）执行一些数值计算。Python
    还提供了支持额外数值计算的模块，本章详细介绍：math 和 cmath、statistics、operator、random 和 secrets、fractions
    和 decimal。数值处理经常需要更具体地处理数字*数组*；这个主题在[“数组处理”](#array_processing)中有所涉及，重点介绍标准库模块
    array 和流行的第三方扩展 NumPy。最后，[“额外的数值包”](#additional_numeric_packages)列出了 Python 社区生产的几个额外数值处理包。本章大多数示例假定您已经导入了适当的模块；**import**
    语句仅在情况不明确时包含。
- en: Floating-Point Values
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浮点数值
- en: Python represents real numeric values (that is, those that are not integers)
    using variables of type float. Unlike integers, computers can rarely represent
    floats exactly, due to their internal implementation as a fixed-size binary integer
    *significand* (often incorrectly called “mantissa”) and a fixed-size binary integer
    exponent. floats have several limitations (some of which can lead to unexpected
    results).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python 用类型为 float 的变量表示实数值（即非整数）。与整数不同，由于其内部实现为固定大小的二进制整数*尾数*（通常错误地称为“尾数”）和固定大小的二进制整数指数，计算机很少能够精确表示浮点数。浮点数有几个限制（其中一些可能导致意外结果）。
- en: 'For most everyday applications, floats are sufficient for arithmetic, but they
    are limited in the number of decimal places they can represent:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数日常应用程序，浮点数足以进行算术运算，但它们在能够表示的小数位数上有限：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'They are also limited in the range of integer values they can accurately store
    (in the sense of being able to distinguish one from the next largest or smallest
    integer value):'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在能够精确存储的整数值范围上也有限制（即能够区分下一个最大或最小整数值）：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Always keep in mind that floats are not entirely precise, due to their internal
    representation in the computer. The same consideration applies to complex numbers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 请始终记住，由于其在计算机中的内部表示，浮点数并不完全精确。对复数的考虑也是同样。
- en: Don’t Use == Between Floating-Point or Complex Numbers
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要在浮点数或复数之间使用 == 运算符
- en: Given that floating-point numbers and operations only approximate the behavior
    of mathematical “real numbers,” it seldom makes sense to check two floats *x*
    and *y* for exact equality. Tiny variations in how each was computed can easily
    result in unexpected differences.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于浮点数和运算只能近似地模拟数学中的“实数”行为，几乎没有必要检查两个浮点数 *x* 和 *y* 是否完全相等。每个数的计算方式微小的差异很容易导致意外的差异。
- en: 'For testing floating-point or complex numbers for equality, use the function
    isclose exported by the built-in module math. The following code illustrates why:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试浮点数或复数是否相等，请使用内置模块 math 导出的函数 isclose。以下代码说明了原因：
- en: '[PRE8]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For some values, you may have to set the tolerance value explicitly (this is
    *always* necessary when you’re comparing with 0):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些值，您可能需要显式设置容差值（这总是*必需*当您与 0 进行比较时）：
- en: '[PRE14]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can also use isclose for safe looping.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `isclose` 来进行安全的循环。
- en: Don’t Use a float as a Loop Control Variable
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要将浮点数用作循环控制变量
- en: A common error is to use a floating-point value as the control variable of a
    loop, assuming that it will eventually equal some ending value, such as 0. Instead,
    it most likely will end up looping forever.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 常见错误是将浮点值用作循环的控制变量，假设它最终会等于某个结束值，如 0。相反，它很可能最终将永远循环。
- en: 'The following loop, expected to loop five times and then end, will in fact
    loop forever:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下循环预期循环五次然后结束，但实际上将永远循环：
- en: '[PRE18]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Even though f started as an int, it’s now a float. This code shows why:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 f 最初是一个整数，现在它是一个浮点数。这段代码展示了为什么：
- en: '[PRE19]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Even using the inequality operator > results in incorrect behavior, looping
    six times instead of five (since the residual float value is still greater than
    0):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用不等操作符 > 也会导致不正确的行为，循环六次而不是五次（因为剩余的浮点值仍然大于0）：
- en: '[PRE21]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If instead you use math.isclose for comparing *f* with 0, the **for** loop
    repeats the correct number of times:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用math.isclose来比较*f*与0，**for**循环将重复正确的次数：
- en: '[PRE23]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In general, try to use an int for a loop’s control variable, rather than a float.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，尽量使用int作为循环控制变量，而不是float。
- en: 'Finally, mathematical operations that result in very large floats will often
    cause an OverflowError, or Python may return them as inf (infinity). The maximum
    float value usable on your computer is sys.float_info.max: on 64-bit computers,
    it’s 1.7976931348623157e+308. This may cause unexpected results when doing math
    using very large numbers. When you need to work with very large numbers, we recommend
    using the decimal module or third-party [gmpy](https://oreil.ly/JWoAx) instead.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，导致非常大的浮点数的数学运算通常会引发OverflowError，或者Python可能会将它们返回为inf（无穷大）。在您的计算机上可用的最大浮点数值是sys.float_info.max：在64位计算机上，它是1.7976931348623157e+308。当处理非常大的数时，这可能导致意外的结果。当您需要处理非常大的数时，我们建议使用decimal模块或第三方[gmpy](https://oreil.ly/JWoAx)。
- en: The math and cmath Modules
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: math和cmath模块
- en: The math module supplies mathematical functions for working with floating-point
    numbers; the cmath module supplies equivalent functions for complex numbers. For
    example, math.sqrt(-1) raises an exception, but cmath.sqrt(-1) returns 1j.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: math模块提供了用于处理浮点数的数学函数；cmath模块提供了处理复数的等效函数。例如，math.sqrt(-1)会引发异常，但cmath.sqrt(-1)会返回1j。
- en: Just like for any other module, the cleanest, most readable way to use these
    is to have, for example, **import** math at the top of your code, and explicitly
    call, say, math.sqrt afterward. However, if your code includes a large number
    of calls to the modules’ well-known mathematical functions, you might (though
    it may lose some clarity and readability) either use **from** math **import**
    *, or use **from** math **import** sqrt, and afterward just call sqrt.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 就像对于任何其他模块一样，使用这些模块的最干净、最易读的方法是在代码顶部**import** math，并明确调用，例如math.sqrt。然而，如果您的代码包含大量调用模块的已知数学函数，您可以（尽管可能会失去一些清晰度和可读性）要么使用**from**
    math **import** *，要么使用**from** math **import** sqrt，然后仅调用sqrt。
- en: Each module exposes three float attributes bound to the values of fundamental
    mathematical constants, e, pi, and [tau](https://oreil.ly/2Sbrf), and a variety
    of functions, including those shown in [Table 16-1](#methods_and_attributes_of_the_math_and).
    The math and cmath modules are not fully symmetric, so for each method the table
    indicates whether it is in math, cmath, or both. All examples assume you have
    imported the appropriate module.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块都公开了三个浮点属性，绑定到基本数学常数e、pi和[tau](https://oreil.ly/2Sbrf)，以及各种函数，包括[表16-1](#methods_and_attributes_of_the_math_and)中显示的函数。math和cmath模块并非完全对称，因此表格中每个方法都指示它是在math、cmath还是两者中。所有示例假定您已导入适当的模块。
- en: Table 16-1\. Methods and attributes of the math and cmath modules
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 表16-1。math和cmath模块的方法和属性
- en: '|   |   | math | cmath |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '|   |   | math | cmath |'
- en: '| --- | --- | --- | --- |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| acos, asin, atan, cos, sin, tan | acos(*x*), etc. Return the trigonometric
    functions arccosine, arcsine, arctangent, cosine, sine, or tangent, respectively,
    of *x*, given in radians. | ✓ | ✓ |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| acos, asin, atan, cos, sin, tan | acos(*x*)等，返回*x*的反三角函数，余弦、正弦、正切，单位为弧度。
    | ✓ | ✓ |'
- en: '| acosh, asinh, atanh, cosh, sinh, tanh | acosh(*x*), etc. Return the arc hyperbolic
    cosine, arc hyperbolic sine, arc hyperbolic tangent, hyperbolic cosine, hyperbolic
    sine, or hyperbolic tangent, respectively, of *x*, given in radians. | ✓ | ✓ |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| acosh, asinh, atanh, cosh, sinh, tanh | acosh(*x*)等，返回*x*的反双曲余弦、反双曲正弦、反双曲正切、双曲余弦、双曲正弦或双曲正切的值，单位为弧度。
    | ✓ | ✓ |'
- en: '| atan2 | atan2(*y, x*) Like atan(*y*/*x*), except that atan2 properly takes
    into account the signs of both arguments. For example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '| atan2 | atan2(*y, x*) 类似于atan(*y*/*x*），但atan2正确考虑了两个参数的符号。例如：'
- en: '[PRE25]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When *x* equals 0, atan2 returns π/2, while dividing by *x* would raise ZeroDivisionError.
    | ✓ |   |
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当*x*等于0时，atan2返回π/2，而除以*x*会引发ZeroDivisionError。 | ✓ |   |
- en: '| cbrt | cbrt(x) 3.11+ Returns the cube root of *x*. | ✓ |   |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| cbrt | cbrt(x) 3.11+ 返回*x*的立方根。 | ✓ |   |'
- en: '| ceil | ceil(*x*) Returns float(*i*), where *i* is the smallest integer such
    that *i*>=*x*. | ✓ |   |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| ceil | ceil(*x*) 返回不小于*x*的最小整数*i*的浮点数*i*。 | ✓ |   |'
- en: '| comb | comb(*n*, *k*) 3.8+ Returns the number of *combinations* of *n* items
    taken *k* items at a time, regardless of order. When counting the number of combinations
    taken from three items *A*, *B*, and *C*, two at a time, comb(3, 2) returns 3
    because, for example, *A*-*B* and *B*-*A* are considered the *same* combination
    (contrast this with perm, later in this table). Raises ValueError when *k* or
    *n* is negative; raises TypeError when *k* or *n* is not an int. When *k*>*n*,
    just returns 0, raising no exceptions. | ✓ |   |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| comb | comb(*n*, *k*) 3.8+ Returns the number of *combinations* of *n* items
    taken *k* items at a time, regardless of order. When counting the number of combinations
    taken from three items *A*, *B*, and *C*, two at a time, comb(3, 2) returns 3
    because, for example, *A*-*B* and *B*-*A* are considered the *same* combination
    (contrast this with perm, later in this table). Raises ValueError when *k* or
    *n* is negative; raises TypeError when *k* or *n* is not an int. When *k*>*n*,
    just returns 0, raising no exceptions. | ✓ |   |'
- en: '| copysign | copysign(*x*, *y*) Returns the absolute value of *x* with the
    sign of *y*. | ✓ |   |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| copysign | copysign(*x*, *y*) Returns the absolute value of *x* with the
    sign of *y*. | ✓ |   |'
- en: '| degrees | degrees(*x*) Returns the degree measure of the angle *x* given
    in radians. | ✓ |   |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| degrees | degrees(*x*) Returns the degree measure of the angle *x* given
    in radians. | ✓ |   |'
- en: '| dist | dist(*pt0*, *pt1*) 3.8+ Returns the Euclidean distance between two
    *n*-dimensional points, where each point is represented as a sequence of values
    (coordinates). Raises ValueError if *pt0* and *pt1* are sequences of different
    lengths. | ✓ |   |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| dist | dist(*pt0*, *pt1*) 3.8+ Returns the Euclidean distance between two
    *n*-dimensional points, where each point is represented as a sequence of values
    (coordinates). Raises ValueError if *pt0* and *pt1* are sequences of different
    lengths. | ✓ |   |'
- en: '| e | The mathematical constant *e* (2.718281828459045). | ✓ | ✓ |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| e | The mathematical constant *e* (2.718281828459045). | ✓ | ✓ |'
- en: '| erf | erf(*x*) Returns the error function of *x* as used in statistical calculations.
    | ✓ |   |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| erf | erf(*x*) Returns the error function of *x* as used in statistical calculations.
    | ✓ |   |'
- en: '| erfc | erfc(*x*) Returns the complementary error function at *x*, defined
    as 1.0 - erf(*x*). | ✓ |   |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| erfc | erfc(*x*) Returns the complementary error function at *x*, defined
    as 1.0 - erf(*x*). | ✓ |   |'
- en: '| exp | exp(*x*) Returns eˣ. | ✓ | ✓ |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| exp | exp(*x*) Returns eˣ. | ✓ | ✓ |'
- en: '| exp2 | exp2(*x*) 3.11+ Returns 2ˣ. | ✓ |   |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| exp2 | exp2(*x*) 3.11+ Returns 2ˣ. | ✓ |   |'
- en: '| expm1 | expm1(*x*) Returns eˣ - 1. Inverse of log1p. | ✓ |   |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| expm1 | expm1(*x*) Returns eˣ - 1. Inverse of log1p. | ✓ |   |'
- en: '| fabs | fabs(*x*) Returns the absolute value of *x*. Always returns a float,
    even if *x* is an int (unlike the built-in abs function). | ✓ |   |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| fabs | fabs(*x*) Returns the absolute value of *x*. Always returns a float,
    even if *x* is an int (unlike the built-in abs function). | ✓ |   |'
- en: '| factorial | factorial(*x*) Returns the factorial of *x*. Raises ValueError
    when *x* is negative, and TypeError when *x* is not integral. | ✓ |   |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| factorial | factorial(*x*) Returns the factorial of *x*. Raises ValueError
    when *x* is negative, and TypeError when *x* is not integral. | ✓ |   |'
- en: '| floor | floor(*x*) Returns float(*i*), where *i* is the greatest integer
    such that *i*<=*x*. | ✓ |   |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| floor | floor(*x*) Returns float(*i*), where *i* is the greatest integer
    such that *i*<=*x*. | ✓ |   |'
- en: '| fmod | fmod(*x, y*) Returns the float *r*, with the same sign as *x*, such
    that *r*==*x*-*n***y* for some integer *n*, and abs(*r*)<abs(*y*). Like *x*%*y*,
    except that, when *x* and *y* differ in sign, *x%y* has the same sign as *y*,
    not the same sign as *x*. | ✓ |   |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| fmod | fmod(*x, y*) Returns the float *r*, with the same sign as *x*, such
    that *r*==*x*-*n***y* for some integer *n*, and abs(*r*)<abs(*y*). Like *x*%*y*,
    except that, when *x* and *y* differ in sign, *x%y* has the same sign as *y*,
    not the same sign as *x*. | ✓ |   |'
- en: '| frexp | frexp(*x*) Returns a pair (*m*, *e*) where *m* is a floating-point
    number and *e* is an integer such that *x*==*m**(2**e) and 0.5<=abs(*m*)<1,^([a](ch16.xhtml#ch01fn120))
    except that frexp(0) returns (0.0, 0). | ✓ |   |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| frexp | frexp(*x*) Returns a pair (*m*, *e*) where *m* is a floating-point
    number and *e* is an integer such that *x*==*m**(2**e) and 0.5<=abs(*m*)<1,^([a](ch16.xhtml#ch01fn120))
    except that frexp(0) returns (0.0, 0). | ✓ |   |'
- en: '| fsum | fsum(*iterable*) Returns the floating-point sum of the values in *iterable*
    to greater precision than the sum built-in function. | ✓ |   |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| fsum | fsum(*iterable*) Returns the floating-point sum of the values in *iterable*
    to greater precision than the sum built-in function. | ✓ |   |'
- en: '| gamma | gamma(*x*) Returns the Gamma function evaluated at *x*. | ✓ |   |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| gamma | gamma(*x*) Returns the Gamma function evaluated at *x*. | ✓ |   |'
- en: '| gcd | gcd(*x, y*) Returns the greatest common divisor of *x* and *y*. When
    *x* and *y* are both zero, returns 0. (3.9+ gcd can accept any number of values;
    gcd() without arguments returns 0.) | ✓ |   |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| gcd | gcd(*x, y*) Returns the greatest common divisor of *x* and *y*. When
    *x* and *y* are both zero, returns 0. (3.9+ gcd can accept any number of values;
    gcd() without arguments returns 0.) | ✓ |   |'
- en: '| hypot | hypot(*x, y*) Returns sqrt(*x***x*+*y***y*). (3.8+ hypot can accept
    any number of values, to compute a hypotenuse length in *n* dimensions.) | ✓ |
      |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| hypot | hypot(*x, y*) Returns sqrt(*x***x*+*y***y*). (3.8+ hypot can accept
    any number of values, to compute a hypotenuse length in *n* dimensions.) | ✓ |
      |'
- en: '| inf | A floating-point positive infinity, like float(''inf''). | ✓ | ✓ |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| inf | A floating-point positive infinity, like float(''inf''). | ✓ | ✓ |'
- en: '| infj | A complex imaginary infinity, equal to complex(0, float(''inf'')).
    |   | ✓ |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| infj | 一个复数的无穷虚数，等于complex(0, float(''inf''))。 |   | ✓ |'
- en: '| isclose | isclose(*x*, *y*, rel_tol=1e-09, abs_tol=0.0) Returns **True**
    when *x* and *y* are approximately equal, within relative tolerance rel_tol, with
    minimum absolute tolerance of abs_tol; otherwise, returns **False**. Default is
    rel_tol within nine decimal digits. rel_tol must be greater than 0. abs_tol is
    used for comparisons near zero: it must be at least 0.0. NaN is not considered
    close to any value (including NaN itself); each of -inf and inf is only considered
    close to itself. Except for behavior at +/– inf, isclose is like:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '| isclose | isclose(*x*, *y*, rel_tol=1e-09, abs_tol=0.0) 返回当*x*和*y*在相对容差rel_tol内近似相等时为**True**，最小绝对容差abs_tol为0.0；否则返回**False**。默认情况下，rel_tol是九位小数。rel_tol必须大于0。abs_tol用于接近零的比较：必须至少为0.0。NaN不被认为接近任何值（包括NaN本身）；+/-
    inf除外，isclose类似于： |   |   |'
- en: '[PRE29]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '| ✓ | ✓ |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| ✓ | ✓ |'
- en: '| isfinite | isfinite(*x*) Returns **True** when *x* (in cmath, both the real
    and imaginary parts of *x*) is neither infinity nor NaN; otherwise, returns **False**.
    | ✓ | ✓ |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| isfinite | isfinite(*x*) 返回当*x*（在cmath中，*x*的实部和虚部）既不是无穷大也不是NaN时为**True**；否则返回**False**。
    | ✓ | ✓ |'
- en: '| isinf | isinf(*x*) Returns **True** when *x* (in cmath, either the real or
    imaginary part of *x*, or both) is positive or negative infinity; otherwise, returns
    **False**. | ✓ | ✓ |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| isinf | isinf(*x*) 返回当*x*（在cmath中，*x*的实部或虚部，或两者）是正无穷大或负无穷大时为**True**；否则返回**False**。
    | ✓ | ✓ |'
- en: '| isnan | isnan(*x*) Returns **True** when *x* (in cmath, either the real or
    imaginary part of *x*, or both) is NaN; otherwise, returns **False**. | ✓ | ✓
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| isnan | isnan(*x*) 返回当*x*（在cmath中，*x*的实部或虚部，或两者）是NaN时为**True**；否则返回**False**。
    | ✓ | ✓ |'
- en: '| isqrt | isqrt(*x*) 3.8+ Returns int(sqrt(*x*)). | ✓ |   |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| isqrt | isqrt(*x*) 3.8+ 返回int(sqrt(*x*))。 | ✓ |   |'
- en: '| lcm | lcm(*x*, ...) 3.9+ Returns the least common multiple of the given ints.
    If not all values are ints, raises TypeError. | ✓ |   |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| lcm | lcm(*x*, ...) 3.9+ 返回给定整数的最小公倍数。如果不是所有值都是整数，则引发TypeError。 | ✓ |   |'
- en: '| ldexp | ldexp(*x, i*) Returns *x**(*2****i*) (*i* must be an int; when *i*
    is a float, ldexp raises TypeError). Inverse of frexp. | ✓ |   |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| ldexp | ldexp(*x, i*) 返回*x*乘以*2****i*（*i*必须是整数；当*i*为浮点数时，ldexp引发TypeError）。是frexp的反函数。
    | ✓ |   |'
- en: '| lgamma | lgamma(*x*) Returns the natural logarithm of the absolute value
    of the Gamma function evaluated at *x*. | ✓ |   |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| lgamma | lgamma(*x*) 返回Gamma函数在*x*处的绝对值的自然对数。 | ✓ |   |'
- en: '| log | log(*x*) Returns the natural logarithm of *x*. | ✓ | ✓ |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| log | log(*x*) 返回*x*的自然对数。 | ✓ | ✓ |'
- en: '| log10 | log10(*x*) Returns the base-10 logarithm of *x*. | ✓ | ✓ |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| log10 | log10(*x*) 返回*x*的以10为底的对数。 | ✓ | ✓ |'
- en: '| log1p | log1p(*x*) Returns the natural logarithm of 1+*x*. Inverse of expm1.
    | ✓ |   |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| log1p | log1p(*x*) 返回1+*x*的自然对数。是expm1的反函数。 | ✓ |   |'
- en: '| log2 | log2(*x*) Returns the base-2 logarithm of *x*. | ✓ |   |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| log2 | log2(*x*) 返回*x*的以2为底的对数。 | ✓ |   |'
- en: '| modf | modf(*x*) Returns a pair (*f*, *i*) with the fractional and integer
    parts of *x*, meaning two floats with the same sign as *x* such that *i*==int(*i*)
    and *x*==*f*+*i*. | ✓ |   |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| modf | modf(*x*) 返回一个由*x*的小数部分和整数部分组成的元组(*f*, *i*)，即两个浮点数，其符号与*x*相同，使得*i*==int(*i*)且*x*==*f*+*i*。
    | ✓ |   |'
- en: '| nan | nan A floating-point “Not a Number” (NaN) value, like float(''nan'')
    or complex(''nan''). | ✓ | ✓ |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| nan | nan 一个浮点数“非数字”（NaN）值，类似于float(''nan'')或complex(''nan'')。 | ✓ | ✓ |'
- en: '| nanj | A complex number with a 0.0 real part and floating-point “Not a Number”
    (NaN) imaginary part. |   | ✓ |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| nanj | 一个实部为0.0且虚部为浮点数“非数字”（NaN）的复数。 |   | ✓ |'
- en: '| nextafter | nextafter(*a*, *b*) 3.9+ Returns the next higher or lower float
    value from *a* in the direction of *b*. | ✓ |   |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| nextafter | nextafter(*a*, *b*) 3.9+ 返回从*a*开始向*b*方向上的下一个更高或更低的浮点值。 | ✓ |
      |'
- en: '| perm | perm(*n*, *k*) 3.8+ Returns the number of *permutations* of *n* items
    taken *k* items at a time, where selections of the same items but in differing
    order are counted separately. When counting the number of permutations of three
    items *A*, *B*, and *C*, taken two at a time, perm(3, 2) returns 6, because, for
    example, *A*-*B* and *B*-*A* are considered to be different permutations (contrast
    this with comb, earlier in this table). Raises ValueError when *k* or *n* is negative;
    raises TypeError when *k* or *n* is not an int. | ✓ |   |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| perm | perm(*n*, *k*) 3.8+ 返回从*n*个项目中取*k*个项目的排列数，其中相同项目的不同顺序选择被单独计算。例如，对于三个项目*A*、*B*和*C*，取两个项目的排列数为perm(3,
    2)，返回6，因为例如*A*-*B*和*B*-*A*被视为不同的排列（与此表中较早的comb相对比）。当*k*或*n*为负时引发ValueError；当*k*或*n*不是整数时引发TypeError。
    | ✓ |   |'
- en: '| pi | The mathematical constant *π*, 3.141592653589793. | ✓ | ✓ |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| π | 数学常数*π*，3.141592653589793。 | ✓ | ✓ |'
- en: '| phase | phase(*x*) Returns the *phase* of *x*, a float in the range (*–π*,
    *π*)*.* Like math.atan2(*x*.imag, *x*.real). See “Conversions to and from polar
    coordinates” in the [online docs](https://oreil.ly/gXdbT) for details. |   | ✓
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 相位 | phase(*x*) 返回*x*的相位，为一个范围在(*–π*, *π*)的浮点数。类似于 math.atan2(*x*.imag, *x*.real)。详见[在线文档](https://oreil.ly/gXdbT)。
    |   | ✓ |'
- en: '| polar | polar(*x*) Returns the polar coordinate representation of *x*, as
    a pair (*r*, *phi*) where *r* is the modulus of *x* and *phi* is the phase of
    *x*. Like (abs(*x*), cmath.phase(*x*)). See “Conversions to and from polar coordinates”
    in the [online docs](https://oreil.ly/gXdbT) for details. |   | ✓ |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 极坐标 | polar(*x*) 返回复数*x*的极坐标表示，即一对(*r*, *phi*)，其中*r*为*x*的模，*phi*为*x*的相位。类似于(abs(*x*),
    cmath.phase(*x*))。详见[在线文档](https://oreil.ly/gXdbT)。 |   | ✓ |'
- en: '| pow | pow(*x, y*) Returns float(*x*)**float(*y*). For large int values of
    *x* and *y*, to avoid OverflowError exceptions, use *x****y* or the pow built-in
    function instead (which does not convert to floats). | ✓ |   |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| pow | pow(*x, y*) 返回float(*x*)的float(*y*)次幂。对于大整数值的*x*和*y*，为避免OverflowError异常，请使用*x****y*或不转换为浮点数的内置pow函数。
    | ✓ |   |'
- en: '| prod | prod(*seq*, start=1) 3.8+ Returns the product of all values in the
    sequence, beginning with the given start value, which defaults to 1. If *seq*
    is empty, returns the start value. | ✓ |   |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| prod | prod(*seq*, start=1) 3.8+ 返回序列中所有值的乘积，从给定的起始值（默认为1）开始。如果*seq*为空，则返回起始值。
    | ✓ |   |'
- en: '| radians | radians(*x*) Returns the radian measure of the angle *x* given
    in degrees. | ✓ |   |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| radians | radians(*x*) 返回角度*x*的弧度值。 | ✓ |   |'
- en: '| rect | rect(*r*, *phi*) Returns the complex value representing the polar
    coordinates (*r*, *phi*) converted to rectangular coordinates as (*x* + *yj*).
    |   | ✓ |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| rect | rect(*r*, *phi*) 返回以极坐标(*r*, *phi*)表示的复数值，转换为矩形坐标形式为(*x* + *yj*)。
    |   | ✓ |'
- en: '| remainder | remainder(*x*, *y*) Returns the signed remainder from dividing
    *x*/*y* (the result may be negative if *x* or *y* is negative). | ✓ |   |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| remainder | remainder(*x*, *y*) 返回*x*/*y*的有符号余数（如果*x*或*y*为负，则结果可能为负）。 | ✓
    |   |'
- en: '| sqrt | sqrt(*x*) Returns the square root of *x*. | ✓ | ✓ |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| sqrt | sqrt(*x*) 返回*x*的平方根。 | ✓ | ✓ |'
- en: '| tau | The mathematical constant *τ* = 2*π*, or 6.283185307179586. | ✓ | ✓
    |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| τ | 数学常数*τ* = 2*π*，即6.283185307179586。 | ✓ | ✓ |'
- en: '| trunc | trunc(*x*) Returns *x* truncated to an int. | ✓ |   |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| trunc | trunc(*x*) 返回被截断为整数的*x*。 | ✓ |   |'
- en: '| ulp | ulp(*x*) 3.9+ Returns the least significant bit of floating-point value
    *x*. For positive values, equals math.nextafter(*x*, *x*+1) - x. For negative
    values, equals ulp(-*x*). If *x* is NaN or inf, returns *x*. ulp stands for [*unit
    of least precision*](https://oreil.ly/6cN99). | ✓ |   |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| ulp | ulp(*x*) 3.9+ 返回浮点数*x*的最低有效位。对于正值，等同于 math.nextafter(*x*, *x*+1) -
    x。对于负值，等同于 ulp(-*x*)。如果*x*为NaN或inf，则返回*x*。ulp代表[*最小精度单位*](https://oreil.ly/6cN99)。
    | ✓ |   |'
- en: '| ^([a](ch16.xhtml#ch01fn120-marker)) Formally, *m* is the significand, and
    *e* is the exponent. Used to render a cross-platform portable representation of
    a floating-point value. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch16.xhtml#ch01fn120-marker)) 形式上，*m*为尾数，*e*为指数。用于渲染浮点值的跨平台可移植表示。 |'
- en: The statistics Module
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统计模块
- en: The statistics module supplies the class NormalDist to perform distribution
    analytics, and the functions listed in [Table 16-2](#functions_of_the_statistics_module)
    to compute common statistics.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 统计模块提供了NormalDist类用于执行分布分析，并提供了[表 16-2](#functions_of_the_statistics_module)中列出的函数来计算常见统计数据。
- en: Table 16-2\. Functions of the statistics module (with functions added in versions
    3.8 and 3.10)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 表 16-2\. 统计模块的函数（包括版本3.8和3.10新增的函数）
- en: '|   | 3.8+ | 3.10+ |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|   | 3.8+ | 3.10+ |'
- en: '| --- | --- | --- |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| harmonic_mean mean'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '| harmonic_mean mean'
- en: median
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 中位数
- en: median_grouped
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 中位数（分组）
- en: median_high
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 中位数（高）
- en: median_low
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 中位数（低）
- en: mode
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 众数
- en: pstdev
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 总体标准差
- en: pvariance
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 总体方差
- en: stdev
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 标准差
- en: variance | fmean geometric_mean
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '| 方差 | fmean geometric_mean'
- en: multimode
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 多模态
- en: quantiles
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 分位数
- en: NormalDist | correlation covariance
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: NormalDist | 相关性 协方差
- en: linear_regression |
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 线性回归 |
- en: The [online docs](https://oreil.ly/CY8Pi) contain detailed information on the
    signatures and use of these functions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[在线文档](https://oreil.ly/CY8Pi)详细介绍了这些函数的签名和用法。'
- en: The operator Module
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符模块
- en: 'The operator module supplies functions that are equivalent to Python’s operators.
    These functions are handy in cases where callables must be stored, passed as arguments,
    or returned as function results. The functions in operator have the same names
    as the corresponding special methods (covered in [“Special Methods”](ch04.xhtml#special_methods)).
    Each function is available with two names, with and without “dunder” (leading
    and trailing double underscores): for example, both operator.add(*a*, *b*) and
    operator.__add__(*a*, *b*) return *a + b*.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符模块提供了一些等效于 Python 操作符的函数。这些函数在需要存储可调用对象、作为参数传递或作为函数结果返回的情况下非常方便。运算符模块中的函数与相应的特殊方法（在[“特殊方法”](ch04.xhtml#special_methods)中介绍）具有相同的名称。每个函数都有两个名称，一个带有“dunder”（前导和尾随双下划线）和一个不带有：“例如，operator.add(*a*,
    *b*)和operator.__add__(*a*, *b*)都返回*a + b*。
- en: Matrix multiplication support has been added for the infix operator @, but you
    must implement it by defining your own __matmul__, __rmatmul__, and/or __imatmul__
    methods; NumPy currently supports @ (but, as of this writing, not yet @=) for
    matrix multiplication.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了用于中缀运算符 @ 的矩阵乘法支持，但必须通过定义自己的 __matmul__、__rmatmul__ 和/或 __imatmul__ 方法来实现它；NumPy
    目前支持 @（但在撰写本文时尚未支持 @=）进行矩阵乘法。
- en: '[Table 16-3](#functions_supplied_by_the_operator_modu) lists some of the functions
    supplied by the operator module. For detailed information on these functions and
    their use, see the [online docs](https://oreil.ly/WrtUH).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 16-3](#functions_supplied_by_the_operator_modu) 列出了运算符模块提供的一些函数。有关这些函数及其用法的详细信息，请参阅[在线文档](https://oreil.ly/WrtUH)。'
- en: Table 16-3\. Functions supplied by the operator module
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 表 16-3\. 运算符模块提供的函数
- en: '| Function | Signature | Behaves like |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| Function | Signature | 行为类似 |'
- en: '| --- | --- | --- |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| abs | abs(*a*) | abs(*a*) |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| abs | abs(*a*) | abs(*a*) |'
- en: '| add | add(*a*, *b*) | *a* + *b* |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| add | add(*a*, *b*) | *a* + *b* |'
- en: '| and_ | and_(*a*, *b*) | *a* & *b* |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| and_ | and_(*a*, *b*) | *a* & *b* |'
- en: '| concat | concat(*a*, *b*) | *a* + *b* |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| concat | concat(*a*, *b*) | *a* + *b* |'
- en: '| contains | contains(*a*, *b*) | *b* **in** *a* |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| contains | contains(*a*, *b*) | *b* **在** *a* 中 |'
- en: '| countOf | countOf(*a*, *b*) | *a*.count(*b*) |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| countOf | countOf(*a*, *b*) | *a*.count(*b*) |'
- en: '| delitem | delitem(*a*, *b*) | **del** *a*[*b*] |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| delitem | delitem(*a*, *b*) | **del** *a*[*b*] |'
- en: '| delslice | delslice(*a*, *b*, *c*) | **del** *a*[*b*:*c*] |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| delslice | delslice(*a*, *b*, *c*) | **del** *a*[*b*:*c*] |'
- en: '| eq | eq(*a*, *b*) | *a* == *b* |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| eq | eq(*a*, *b*) | *a* == *b* |'
- en: '| floordiv | floordiv(*a*, *b*) | *a* // *b* |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| floordiv | floordiv(*a*, *b*) | *a* // *b* |'
- en: '| ge | ge(*a*, *b*) | *a* >= *b* |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| ge | ge(*a*, *b*) | *a* >= *b* |'
- en: '| getitem | getitem(*a*, *b*) | *a*[*b*] |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| getitem | getitem(*a*, *b*) | *a*[*b*] |'
- en: '| getslice | getslice(*a*, *b*, *c*) | *a*[*b*:*c*] |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| getslice | getslice(*a*, *b*, *c*) | *a*[*b*:*c*] |'
- en: '| gt | gt(*a*, *b*) | *a* > *b* |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| gt | gt(*a*, *b*) | *a* > *b* |'
- en: '| index | index(*a*) | *a*.__index__() |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| index | index(*a*) | *a*.__index__() |'
- en: '| indexOf | indexOf(*a*, *b*) | *a*.index(*b*) |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| indexOf | indexOf(*a*, *b*) | *a*.index(*b*) |'
- en: '| invert, inv | invert(*a*)*,* inv(*a*) | ~*a* |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| invert, inv | invert(*a*)*,* inv(*a*) | ~*a* |'
- en: '| is_ | is_(*a*, *b*) | *a* **is** *b* |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| is_ | is_(*a*, *b*) | *a* **是** *b* |'
- en: '| is_not | is_not(*a*, *b*) | *a* **is not** *b* |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| is_not | is_not(*a*, *b*) | *a* **不是** *b* |'
- en: '| le | le(*a*, *b*) | *a* <= *b* |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| le | le(*a*, *b*) | *a* <= *b* |'
- en: '| lshift | lshift(*a*, *b*) | *a* << *b* |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| lshift | lshift(*a*, *b*) | *a* << *b* |'
- en: '| lt | lt(*a*, *b*) | *a* < *b* |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| lt | lt(*a*, *b*) | *a* < *b* |'
- en: '| matmul | matmul(*m1*, *m2*) | *m1* @ *m2* |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| matmul | matmul(*m1*, *m2*) | *m1* @ *m2* |'
- en: '| mod | mod(*a*, *b*) | *a* % *b* |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| mod | mod(*a*, *b*) | *a* % *b* |'
- en: '| mul | mul(*a*, *b*) | *a* * *b* |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| mul | mul(*a*, *b*) | *a* * *b* |'
- en: '| ne | ne(*a*, *b*) | *a* != *b* |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| ne | ne(*a*, *b*) | *a* != *b* |'
- en: '| neg | neg(*a*) | *-a* |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| neg | neg(*a*) | *-a* |'
- en: '| not_ | not_(*a*) | **not** *a* |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| not_ | not_(*a*) | **not** *a* |'
- en: '| or_ | or_(*a*, *b*) | *a* &#124; *b* |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| or_ | or_(*a*, *b*) | *a* &#124; *b* |'
- en: '| pos | pos(*a*) | +*a* |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| pos | pos(*a*) | +*a* |'
- en: '| pow | pow(*a*, *b*) | a ** b |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| pow | pow(*a*, *b*) | a ** b |'
- en: '| repeat | repeat(*a*, *b*) | *a* * *b* |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| repeat | repeat(*a*, *b*) | *a* * *b* |'
- en: '| rshift | rshift(*a*, *b*) | *a* >> *b* |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| rshift | rshift(*a*, *b*) | *a* >> *b* |'
- en: '| setitem | setitem(*a*, *b*, *c*) | *a*[*b*] = *c* |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| setitem | setitem(*a*, *b*, *c*) | *a*[*b*] = *c* |'
- en: '| setslice | setslice(*a*, *b*, *c*, *d*) | *a*[*b*:*c*] = *d* |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| setslice | setslice(*a*, *b*, *c*, *d*) | *a*[*b*:*c*] = *d* |'
- en: '| sub | sub(*a*, *b*) | *a* - *b* |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| sub | sub(*a*, *b*) | *a* - *b* |'
- en: '| truediv | truediv(*a*, *b*) | *a/b* *# no truncation* |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| truediv | truediv(*a*, *b*) | *a/b* *# 不截断* |'
- en: '| truth | truth(*a*) | bool(*a*), **not not** a |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| truth | truth(*a*) | bool(*a*), **非非** a |'
- en: '| xor | xor(*a*, *b*) | *a* ^ *b* |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| xor | xor(*a*, *b*) | *a* ^ *b* |'
- en: The operator module also supplies additional higher-order functions, listed
    in [Table 16-4](#higher_order_functions_supplied_by_the). Three of these functions,
    attrgetter, itemgetter, and methodcaller, return functions suitable for passing
    as named argument key to the sort method of lists, the sorted, min, and max built-in
    functions, and several functions in standard library modules, such as heapq and
    itertools (discussed in [Chapter 8](ch08.xhtml#core_built_ins_and_standard_library_mod)).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: operator模块还提供了其他额外的高阶函数，列在[表 16-4](#higher_order_functions_supplied_by_the)中。其中三个函数，attrgetter、itemgetter和methodcaller，返回适合作为命名参数键传递给列表的sort方法、内置函数sorted、min和max，以及标准库模块（例如heapq和itertools中讨论的[第8章](ch08.xhtml#core_built_ins_and_standard_library_mod)中的几个函数）的函数的函数。
- en: Table 16-4\. Higher-order functions supplied by the operator module
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 表 16-4\. operator模块提供的高阶函数
- en: '| attrgetter | attrgetter(*attr*), attrgetter(**attrs*)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '| attrgetter | attrgetter(*attr*), attrgetter(**attrs*)'
- en: 'Returns a callable *f* such that *f*(*o*) is the same as getattr(*o*, *attr*).
    The string *attr* can include dots (.), in which case the callable result of attrgetter
    calls getattr repeatedly. For example, operator.attrgetter(''a.b'') is equivalent
    to **lambda** *o*: getattr(getattr(*o*, ''a''), ''b'').'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '返回一个可调用对象*f*，使得*f*(*o*)与getattr(*o*, *attr*)相同。字符串*attr*可以包含点号(.)，在这种情况下，attrgetter的可调用结果会重复调用getattr。例如，operator.attrgetter(''a.b'')等效于**lambda**
    *o*: getattr(getattr(*o*, ''a''), ''b'')。'
- en: When you call attrgetter with multiple arguments, the resulting callable extracts
    each attribute thus named and returns the resulting tuple of values. |
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用多个参数调用attrgetter时，生成的可调用对象将提取每个命名的属性并返回结果值的元组。 |
- en: '| itemgetter | itemgetter(*key*), itemgetter(**keys*)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '| itemgetter | itemgetter(*key*), itemgetter(**keys*)'
- en: Returns a callable *f* such that *f*(*o*) is the same as getitem(*o*, *key*).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个可调用对象*f*，使得*f*(*o*)与getitem(*o*, *key*)相同。
- en: When you call itemgetter with multiple arguments, the resulting callable extracts
    each item thus keyed and returns the resulting tuple of values.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用多个参数调用itemgetter时，生成的可调用对象将提取每个以此方式键入的项目，并返回结果值的元组。
- en: 'For example, say that *L* is a list of lists, with each sublist at least three
    items long: you want to sort *L*, in place, based on the third item of each sublist,
    with sublists having equal third items sorted by their first items. The simplest
    way to do this is:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设*L*是一个至少三项的子列表列表：您希望基于每个子列表的第三项对*L*进行原地排序，对于具有相同第三项的子列表，则按其第一项排序。这样做的最简单方法是：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '|'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| length_hint | length_hint(*iterable*, default=0) Used to try to preallocate
    storage for items in *iterable*. Calls object *iterable*’s __len__ method to try
    to get an exact length. If __len__ is not implemented, then Python tries calling
    *iterable*’s __length_hint__ method. If this is also not implemented, length_hint
    returns the given default. Any mistake in using this “hint” helper may result
    in a performance issue, but not in silent, incorrect behavior. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| length_hint | length_hint(*iterable*, default=0) 用于尝试预分配*iterable*中项目的存储空间。调用对象*iterable*的__len__方法尝试获取准确长度。如果__len__未实现，则Python尝试调用*iterable*的__length_hint__方法。如果这也未实现，length_hint返回给定的默认值。在使用此“提示”助手时出现任何错误可能会导致性能问题，但不会导致静默的错误行为。
    |'
- en: '| met⁠h⁠o⁠d​c⁠a⁠l⁠ler | methodcaller(*methodname*, args...) Returns a callable
    *f* such that *f*(*o*) is the same as o.*methodname*(args, ...). The optional
    args may be given as positional or named arguments. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| methodcaller | methodcaller(*methodname*, args...) 返回一个可调用对象*f*，使得*f*(*o*)与o.*methodname*(args,
    ...)相同。可选的args可以作为位置参数或命名参数传递。 |'
- en: Random and Pseudorandom Numbers
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机数与伪随机数
- en: The random module of the standard library generates pseudorandom numbers with
    various distributions. The underlying uniform pseudorandom generator uses the
    powerful, popular [Mersenne Twister algorithm](https://oreil.ly/AcAgG), with a
    (huge!) period of length 2^(19937)-1.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库的随机模块使用各种分布生成伪随机数。底层均匀伪随机生成器采用强大且流行的[Mersenne Twister算法](https://oreil.ly/AcAgG)，周期长度为2^(19937)-1（巨大！）。
- en: The random Module
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机模块
- en: All functions of the random module are methods of one hidden global instance
    of the class random.Random. You can instantiate Random explicitly to get multiple
    generators that do not share state. Explicit instantiation is advisable if you
    require random numbers in multiple threads (threads are covered in [Chapter 15](ch15.xhtml#concurrency_threads_and_processes)).
    Alternatively, instantiate SystemRandom if you require higher-quality random numbers
    (see the following section for details). [Table 16-5](#useful_functions_supplied_by_the_random)
    documents the most frequently used functions exposed by the random module.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 随机模块的所有函数都是 random.Random 类的一个隐藏全局实例的方法。您可以显式实例化 Random 以获取不共享状态的多个生成器。如果需要在多个线程中使用随机数（线程在
    [第 15 章](ch15.xhtml#concurrency_threads_and_processes) 中讨论），则建议显式实例化。或者，如果需要更高质量的随机数，请实例化
    SystemRandom（有关详细信息，请参阅下一节）。[Table 16-5](#useful_functions_supplied_by_the_random)
    记录了随机模块提供的最常用函数。
- en: Table 16-5\. Useful functions supplied by the random module
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Table 16-5\. 随机模块提供的实用函数
- en: '| choice | choice(*seq*) Returns a random item from nonempty sequence *seq*.
    |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| choice | choice(*seq*) 从非空序列 *seq* 中返回一个随机项。 |'
- en: '| choices | choices(*seq*, *weights*=**None**, *, cum_weights=**None**, k=1)
    Returns k elements from nonempty sequence *seq*, with replacement. By default,
    elements are chosen with equal probability. If the optional *weights*, or the
    named argument cum_weights, is passed (as a list of floats or ints), then the
    respective choices are weighted by that amount during choosing. The cum_weights
    argument accepts a list of floats or ints as would be returned by itertools.accumulate(*weights*);
    e.g., if *weights* for a *seq* containing three items were [1, 2, 1], then the
    corresponding cum_weights would be [1, 3, 4]. (Only one of *weights* or cum_weights
    may be specified, and must be the same length as *seq*. If used, cum_weights and
    k must be given as named arguments.) |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| choices | choices(*seq*, *weights*=**None**, *, cum_weights=**None**, k=1)
    从非空序列 *seq* 中返回 k 个元素（可重复选择）。默认情况下，元素以相等概率被选择。如果传递了可选的 *weights* 或命名参数 cum_weights（作为浮点数或整数列表），则在选择过程中将按照相应的权重进行加权。cum_weights
    参数接受一个浮点数或整数列表，如 itertools.accumulate(*weights*) 返回的那样；例如，如果 *seq* 包含三个项目的 *weights*
    为 [1, 2, 1]，则相应的 cum_weights 将为 [1, 3, 4]。（只能指定 *weights* 或 cum_weights 中的一个，并且必须与
    *seq* 长度相同。如果使用，cum_weights 和 k 必须作为命名参数给出。） |'
- en: '| getrandbits | getrandbits(*k*) Returns an int >= 0 with *k* random bits,
    like randrange(2 ** *k*) (but faster, and with no problems for large *k*). |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| getrandbits | getrandbits(*k*) 返回一个大于等于 0 的整数，具有 *k* 个随机位，类似于 randrange(2
    ** *k*)（但更快，并且对于大 *k* 没有问题）。 |'
- en: '| getstate | getstate() Returns a hashable and pickleable object *S* representing
    the current state of the generator. You can later pass *S* to the function setstate
    to restore the generator’s state. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| getstate | getstate() 返回一个可散列且可pickle的对象 *S*，表示生成器的当前状态。稍后可以将 *S* 传递给 setstate
    函数以恢复生成器的状态。 |'
- en: '| jumpahead | jumpahead(*n*) Advances the generator state as if *n* random
    numbers had been generated. This is faster than generating and ignoring *n* random
    numbers. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| jumpahead | jumpahead(*n*) 将生成器状态推进，仿佛已生成 *n* 个随机数。这比生成和忽略 *n* 个随机数要快。 |'
- en: '| randbytes | randbytes(*k*) 3.9+ Generates *k* random bytes. To generate bytes
    for secure or cryptographic applications, use secrets.randbits(*k* * 8), then
    unpack the int it returns into *k* bytes, using int.to_bytes(*k*, ''big''). |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| randbytes | randbytes(*k*) 3.9+ 生成 *k* 个随机字节。要为安全或加密应用生成字节，请使用 secrets.randbits(*k*
    * 8)，然后将其返回的整数解包成 *k* 个字节，使用 int.to_bytes(*k*, ''big'')。'
- en: '| randint | randint(*start*, *stop*) Returns a random int *i* from a uniform
    distribution such that *start* <= *i* <= *stop*. Both endpoints are included:
    this is quite unnatural in Python, so you would normally prefer randrange. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| randint | randint(*start*, *stop*) 返回一个随机整数 *i*，满足 *start* <= *i* <= *stop*
    的均匀分布。两个端点都包括在内：在Python中这很不自然，因此通常会优先选择 randrange。 |'
- en: '| random | random() Returns a random float *r* from a uniform distribution,
    0 <= *r* < 1. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| random | random() 返回一个来自均匀分布的随机浮点数 *r*，满足 0 <= *r* < 1。 |'
- en: '| randrange | randrange([*start*,]*stop*[,*step*]) Like choice(range(*start*,
    *stop*, *step*)), but much faster. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| randrange | randrange([*start*,]*stop*[,*step*]) 类似于 choice(range(*start*,
    *stop*, *step*))，但速度更快。 |'
- en: '| sample | sample(*seq*, *k*) Returns a new list whose *k* items are unique
    items randomly drawn from *seq*. The list is in random order, so that any slice
    of it is an equally valid random sample. *seq* may contain duplicate items. In
    this case, each occurrence of an item is a candidate for selection in the sample,
    and the sample may also contain such duplicates. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| sample | sample(*seq*, *k*) 返回一个新列表，其中的*k*个项是从*seq*中随机抽取的唯一项。列表是随机排序的，因此它的任何片段都是同样有效的随机样本。*seq*可能包含重复项。在这种情况下，每个项的每次出现都可能被选为样本的候选项，因此样本中也可能包含这些重复项。
    |'
- en: '| seed | seed(*x*=**None**) Initializes the generator state. *x* can be any
    int, float, str, bytes, or bytearray. When *x* is **None**, and when the module
    random is first loaded, seed uses the current system time (or some platform-specific
    source of randomness, if any) to get a seed. *x* is normally an int up to 2^(256),
    a float, or a str, bytes, or bytearray up to 32 bytes in size.^([a](ch16.xhtml#ch01fn121))
    Larger *x* values are accepted, but may produce the same generator state as smaller
    ones. seed is useful in simulation or modeling for repeatable runs, or to write
    tests that require a reproducible sequence of random values. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| seed | seed(*x*=**None**) 初始化生成器状态。*x*可以是任何int、float、str、bytes或bytearray类型。当*x*为**None**时，在第一次加载random模块时，seed使用当前系统时间（或某些特定于平台的随机源，如果有的话）获取种子。通常情况下，*x*是一个最多为2^(256)的int、一个float或最多32字节大小的str、bytes或bytearray。接受更大的*x*值，但可能产生与较小值相同的生成器状态。seed在仿真或建模中很有用，用于可重复运行的运行或编写需要可重复随机值序列的测试。'
- en: '| setstate | setstate(*S*) Restores the generator state. *S* must be the result
    of a previous call to getstate (such a call may have occurred in another program,
    or in a previous run of this program, as long as object *S* has correctly been
    transmitted, or saved and restored). |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| setstate | setstate(*S*) 恢复生成器的状态。*S*必须是先前调用getstate的结果（这样的调用可能发生在另一个程序中，或者在本程序的上一次运行中，只要对象*S*已经正确地被传输或保存并恢复）。
    |'
- en: '| shuffle | shuffle(*seq*) Shuffles, in place, mutable sequence *seq*. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| shuffle | shuffle(*seq*) 就地对可变序列*seq*进行洗牌。 |'
- en: '| uniform | uniform(*a, b*) Returns a random floating-point number *r* from
    a uniform distribution such that *a* <= *r* < *b*. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| uniform | uniform(*a, b*) 返回一个从均匀分布中取出的随机浮点数*r*，使得*a* <= *r* < *b*。 |'
- en: '| ^([a](ch16.xhtml#ch01fn121-marker)) As defined in the Python language specification.
    Specific Python implementations may support larger seed values for generating
    unique random number sequences. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch16.xhtml#ch01fn121-marker)) 如Python语言规范定义的那样。特定的Python实现可能支持更大的种子值以生成唯一的随机数序列。
    |'
- en: The random module also supplies several other functions that generate pseudorandom
    floating-point numbers from other probability distributions (Beta, Gamma, exponential,
    Gauss, Pareto, etc.) by internally calling random.random as their source of randomness.
    See the [online docs](https://oreil.ly/2n8wP) for details.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: random 模块还提供了几个其他函数，用于从其他概率分布（Beta、Gamma、指数、高斯、帕累托等）生成伪随机浮点数，内部调用random.random作为它们的随机源。详细信息请参见[在线文档](https://oreil.ly/2n8wP)。
- en: 'Crypto-Quality Random Numbers: The secrets Module'
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密码质量随机数：secrets 模块
- en: Pseudorandom numbers provided by the random module, while sufficient for simulation
    and modeling, are not of cryptographic quality. To get random numbers and sequences
    for use in security and cryptography applications, use the functions defined in
    the secrets module. These functions use the random.SystemRandom class, which in
    turn calls os.urandom. os.urandom returns random bytes, read from physical sources
    of random bits such as */dev/urandom* on older Linux releases, or the **getrandom()**
    syscall on Linux 3.17 and above. On Windows, os.urandom uses cryptographical-strength
    sources such as the CryptGenRandom API. If no suitable source exists on the current
    system, os.urandom raises NotImplementedError.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: random 模块提供的伪随机数虽然足以用于仿真和建模，但不具有密码学质量。要获取用于安全和密码学应用的随机数和序列，请使用secrets模块中定义的函数。这些函数使用random.SystemRandom类，该类又调用os.urandom。os.urandom返回从物理随机位源（例如旧版Linux上的/dev/urandom或Linux
    3.17及以上版本上的getrandom()系统调用）读取的随机字节。在Windows上，os.urandom使用像CryptGenRandom API这样的密码强度源。如果当前系统上没有合适的源，则os.urandom会引发NotImplementedError异常。
- en: secrets Functions Cannot Be Run with a Known Seed
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: secrets 函数不能使用已知的种子运行
- en: Unlike the random module, which includes a seed function to support generation
    of repeatable sequences of random values, the secrets module has no such capability.
    To write tests dependent on specific sequences of random values generated by the
    secrets module functions, developers must emulate those functions with their own
    mock versions.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 与 random 模块不同，后者包括一个种子函数来支持生成可重复的随机值序列，secrets 模块没有这样的功能。要编写依赖于 secrets 模块函数生成特定随机值序列的测试，开发人员必须使用自己的模拟版本来模拟这些函数。
- en: The secrets module supplies the functions listed in [Table 16-6](#functions_of_the_secrets_module).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: secrets 模块提供了 [表 16-6](#functions_of_the_secrets_module) 中列出的函数。
- en: Table 16-6\. Functions of the secrets module
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 表 16-6\. secrets 模块的函数
- en: '| choice | choice(*seq*) Returns a randomly selected item from nonempty sequence
    *seq*. |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| choice | choice(*seq*) 从非空序列 *seq* 中随机选择一个项目。 |'
- en: '| randbelow | randbelow(*n*) Returns a random int *x* in the range 0 <= *x*
    < *n*. |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| randbelow | randbelow(*n*) 返回一个范围在 0 <= *x* < *n* 的随机整数 *x*。|'
- en: '| randbits | randbits(*k*) Returns an int with *k* random bits. |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| randbits | randbits(*k*) 返回一个具有 *k* 个随机位的整数。|'
- en: '| token_bytes | token_bytes(*n*) Returns a bytes object of *n* random bytes.
    When you omit *n*, uses a default value, usually 32. |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| token_bytes | token_bytes(*n*) 返回一个包含 *n* 个随机字节的 bytes 对象。当省略 *n* 时，使用默认值，通常为
    32。|'
- en: '| token_hex | token_hex(*n*) Returns a string of hexadecimal characters from
    *n* random bytes, with two characters per byte. When you omit *n*, uses a default
    value, usually 32. |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| token_hex | token_hex(*n*) 返回一个由 *n* 个随机字节的十六进制字符组成的字符串，每字节两个字符。当省略 *n* 时，使用默认值，通常为
    32。|'
- en: '| token_urlsafe | token_urlsafe(*n*) Returns a string of Base64-encoded characters
    from *n* random bytes; the resulting string’s length is approximately 1.3 times
    *n*. When you omit *n*, uses a default value, usually 32. |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| token_urlsafe | token_urlsafe(*n*) 返回一个由 *n* 个随机字节的 Base64 编码字符组成的字符串；结果字符串的长度约为
    *n* 的 1.3 倍。当省略 *n* 时，使用默认值，通常为 32。|'
- en: Additional recipes and best cryptographic practices are provided in Python’s
    [online documentation](https://oreil.ly/Yxh4k).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 [在线文档](https://oreil.ly/Yxh4k) 提供了额外的示例和最佳的加密实践。
- en: Alternative sources of physically random numbers are available online, e.g.
    from [Fourmilab](https://oreil.ly/uNAfT).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 其他来源的物理随机数可以在线获取，例如来自 [Fourmilab](https://oreil.ly/uNAfT)。
- en: The fractions Module
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fractions 模块
- en: The fractions module supplies a rational number class, Fraction, whose instances
    you can construct from a pair of integers, another rational number, or a str.
    Fraction class instances have read-only attributes numerator and denominator.
    You can pass a pair of (optionally signed) ints as the *numerator* and *denominator*.
    A denominator of 0 raises ZeroDivisionError. A string can be of the form '3.14',
    or can include an optionally signed numerator, a slash (/) , and a denominator,
    such as '-22/7'.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: fractions 模块提供了一个有理数类 Fraction，其实例可以由一对整数、另一个有理数或字符串构造。Fraction 类实例具有只读属性 numerator
    和 denominator。您可以传递一对（可选带符号的）整数作为 *numerator* 和 *denominator*。如果 denominator 是
    0，则会引发 ZeroDivisionError。字符串可以是形如 '3.14' 的形式，或者可以包括一个可选带符号的分子，一个斜杠 (/)，和一个分母，例如
    '-22/7'。
- en: Fraction Reduces to Lowest Terms
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fraction 分数化简至最低项
- en: Fraction reduces the fraction to the lowest terms—for example, f = Fraction(226,
    452) builds an instance f equal to one built by Fraction(1, 2). The specific numerator
    and denominator originally passed to Fraction are not recoverable from the resulting
    instance.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Fraction 将分数化简至最低项——例如，f = Fraction(226, 452) 创建一个与 Fraction(1, 2) 等效的实例 f。无法从生成的实例中恢复最初传递给
    Fraction 的特定分子和分母。
- en: Fraction also supports construction from decimal.Decimal instances, and from
    floats (the latter may not provide the results you expect, given floats’ bounded
    precision). Here are some examples of using Fraction with various inputs.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Fraction 还支持从 decimal.Decimal 实例和浮点数构造（后者可能由于浮点数的有限精度而提供您不期望的结果）。以下是使用不同输入使用
    Fraction 的一些示例。
- en: '[PRE31]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The Fraction class supplies methods including limit_denominator, which allows
    you to create a rational approximation of a float—for example, Fraction(0.0999).limit_denominator(10)
    returns Fraction(1, 10). Fraction instances are immutable and can be keys in dicts
    or members of sets, as well as being usable in arithmetic operations with other
    numbers. See the [online docs](https://oreil.ly/xyS7U) for complete coverage.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Fraction 类提供了包括 limit_denominator 在内的方法，允许您创建浮点数的有理数近似——例如，Fraction(0.0999).limit_denominator(10)
    返回 Fraction(1, 10)。Fraction 实例是不可变的，可以作为字典的键或集合的成员，以及与其他数字进行算术运算。完整内容请参阅 [在线文档](https://oreil.ly/xyS7U)。
- en: The fractions module also supplies a function gcd that’s just like math.gcd,
    covered in [Table 16-1](#methods_and_attributes_of_the_math_and).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: fractions模块还提供了一个与math.gcd完全相同的函数gcd，详细介绍在[表16-1](#methods_and_attributes_of_the_math_and)中。
- en: The decimal Module
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 十进制模块
- en: A Python float is a binary floating-point number, normally according to the
    standard known as IEEE 754 implemented in hardware in modern computers. An excellent,
    concise, practical introduction to floating-point arithmetic and its issues can
    be found in David Goldberg’s paper [“What Every Computer Scientist Should Know
    About Floating-Point Arithmetic”](https://oreil.ly/kmCAq). A Python-focused essay
    on the same issues is part of the [tutorial](https://oreil.ly/0SQ-H) in the Python
    docs; another excellent summary (not focused on Python), Bruce Bush’s “The Perils
    of Floating Point,” is also available [online](https://oreil.ly/d8HJE).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Python浮点数是二进制浮点数，通常根据现代计算机硬件上实现的IEEE 754标准。关于浮点运算及其问题的出色、简洁、实用介绍可以在David Goldberg的论文[“计算机科学家应该知道的浮点运算”](https://oreil.ly/kmCAq)中找到。关于相同问题的针对Python的专题论文是Python文档中的[教程](https://oreil.ly/0SQ-H)；另一篇出色的摘要（不专注于Python），Bruce
    Bush的“The Perils of Floating Point”，也可在[线上](https://oreil.ly/d8HJE)找到。
- en: 'Often, particularly for money-related computations, you may prefer to use *decimal*
    floating-point numbers. Python supplies an implementation of the standard known
    as IEEE 854,^([1](ch16.xhtml#ch01fn122)) for base 10, in the standard library
    module decimal. The module has excellent [documentation](https://oreil.ly/3np33):
    there, you can find complete reference material, pointers to the applicable standards,
    a tutorial, and advocacy for decimal. Here, we cover only a small subset of decimal’s
    functionality, the most frequently used parts of the module.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 经常情况下，特别是对于与货币相关的计算，您可能更喜欢使用*十进制*浮点数。Python提供了一个符合IEEE 854标准的实现，适用于十进制，在标准库模块decimal中。该模块有很好的[文档](https://oreil.ly/3np33)：在那里，您可以找到完整的参考资料、适用标准的指针、教程以及关于十进制的宣传。在这里，我们仅涵盖了该模块功能的一个小子集，即模块的最常用部分。
- en: The decimal module supplies a Decimal class (whose immutable instances are decimal
    numbers), exception classes, and classes and functions to deal with the *arithmetic
    context*, which specifies such things as precision, rounding, and which computational
    anomalies (such as division by zero, overflow, underflow, and so on) raise exceptions
    when they occur. In the default context, precision is 28 decimal digits, rounding
    is “half-even” (round results to the closest representable decimal number; when
    a result is exactly halfway between two such numbers, round to the one whose last
    digit is even), and the anomalies that raise exceptions are invalid operation,
    division by zero, and overflow.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: decimal模块提供了Decimal类（其不可变实例是十进制数）、异常类以及处理*算术上下文*的类和函数，该上下文指定精度、四舍五入以及在发生诸如零除以、溢出、下溢等计算异常时引发的异常。在默认上下文中，精度为28位小数数字，四舍五入为“银行家舍入”（将结果四舍五入为最接近的可表示十进制数；当结果恰好在两个这样的数中间时，舍入到最后一位是偶数的数），引发异常的异常包括无效操作、零除以及溢出。
- en: 'To build a decimal number, call Decimal with one argument: an int, float, str,
    or tuple. If you start with a float, Python converts it losslessly to the exact
    decimal equivalent (which may require 53 digits or more of precision):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建十进制数，请使用一个参数调用Decimal：一个int、float、str或元组。如果以浮点数开始，Python会无损地将其转换为精确的十进制等效值（可能需要53位或更多的精度）：
- en: '[PRE45]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If this is not the behavior you want, you can pass the float as a str; for
    example:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这不是您想要的行为，则可以将浮点数作为str传递；例如：
- en: '[PRE47]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You can easily write a factory function for ease of interactive experimentation
    with decimal:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以轻松地编写一个工厂函数，以便通过十进制进行交互式实验：
- en: '[PRE49]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now dfs(0.1) is just the same thing as Decimal(str(0.1)), or Decimal('0.1'),
    but more concise and handier to write.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在dfs(0.1)与Decimal(str(0.1))或Decimal('0.1')完全相同，但更简洁和更方便书写。
- en: 'Alternatively, you may use the quantize method of Decimal to construct a new
    decimal by rounding a float to the number of significant digits you specify:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用Decimal的quantize方法来通过指定的有效数字四舍五入一个浮点数以构造一个新的十进制数：
- en: '[PRE50]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If you start with a tuple, you need to provide three arguments: the sign (0
    for positive, 1 for negative), a tuple of digits, and the integer exponent:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以元组开始，则需要提供三个参数：符号（0表示正数，1表示负数），数字的元组和整数指数：
- en: '[PRE52]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Once you have instances of Decimal, you can compare them, including comparison
    with floats (use math.isclose for this); pickle and unpickle them; and use them
    as keys in dictionaries and as members of sets. You may also perform arithmetic
    among them, and with integers, but not with floats (to avoid unexpected loss of
    precision in the results), as shown here:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有 Decimal 的实例，你可以对它们进行比较，包括与浮点数的比较（使用 math.isclose 进行比较）；对它们进行 pickle 和 unpickle
    操作；并将它们用作字典的键和集合的成员。你还可以在它们之间进行算术运算，以及与整数进行运算，但不能与浮点数进行运算（以避免结果中意外丢失精度），如下所示：
- en: '[PRE54]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The [online docs](https://oreil.ly/MygnC) include useful [recipes](https://oreil.ly/9KnLa)
    for monetary formatting, some trigonometric functions, and a list of FAQs.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '[在线文档](https://oreil.ly/MygnC)包括有用的[配方](https://oreil.ly/9KnLa)，用于货币格式化、一些三角函数以及常见问题解答。'
- en: Array Processing
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组处理
- en: You can represent what most languages call arrays, or vectors, with lists (covered
    in [“Lists”](ch03.xhtml#list)), as well as with the array standard library module
    (covered in the following subsection). You can manipulate arrays with loops, indexing
    and slicing, list comprehensions, iterators, generators, and genexps (all covered
    in [Chapter 3](ch03.xhtml#the_python_language)); built-ins such as map, reduce,
    and filter (all covered in [“Built-in Functions”](ch08.xhtml#built_in_functions));
    and standard library modules such as itertools (covered in [“The itertools Module”](ch08.xhtml#the_itertools_module)).
    If you only need a lightweight, one-dimensional array of instances of a simple
    type, stick with array. However, to process large arrays of numbers, such functions
    may be slower and less convenient than third-party extensions such as NumPy and
    SciPy (covered in [“Extensions for Numeric Array Computation”](#extensions_for_numeric_array_computatio)).
    When you’re doing data analysis and modeling, Pandas, which is built on top of
    NumPy (but not discussed in this book), might be most suitable.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数语言称为数组或向量的内容，你可以使用列表（在 [“列表”](ch03.xhtml#list) 中介绍）或者使用数组标准库模块（在后续小节中介绍）。你可以使用循环、索引和切片、列表推导式、迭代器、生成器和生成表达式（在
    [第 3 章](ch03.xhtml#the_python_language) 中介绍）来操作数组；使用诸如 map、reduce 和 filter 等内置函数（在
    [“内置函数”](ch08.xhtml#built_in_functions) 中介绍）；以及标准库模块如 itertools（在 [“itertools
    模块”](ch08.xhtml#the_itertools_module) 中介绍）。如果你只需要一个简单类型的轻量级、一维数组的实例，请使用数组。然而，要处理大量的数字数组，这些函数可能比
    NumPy 和 SciPy 等第三方扩展更慢、不太方便（在 [“用于数值数组计算的扩展”](#extensions_for_numeric_array_computatio)
    中介绍）。在进行数据分析和建模时，建议使用 Pandas，它是建立在 NumPy 之上的（但本书未讨论），可能更合适。
- en: The array Module
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组模块
- en: 'The array module supplies a type, also called array, whose instances are mutable
    sequences, like lists. An array *a* is a one-dimensional sequence whose items
    can be only characters, or only numbers of one specific numeric type, fixed when
    you create *a*. The constructor for array is:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 数组模块提供了一种类型，也称为数组，其实例是可变序列，类似于列表。数组 *a* 是一个一维序列，其项可以是字符，或者仅限于你创建 *a* 时指定的某种具体数值类型。数组的构造函数为：
- en: '| array | **class** array(*typecode, init*='''', /) Creates and returns an
    array object *a* with the given *typecode**.* *init* can be a string (a bytestring,
    except for *typecode* ''u'') whose length is a multiple of itemsize: the string’s
    bytes, interpreted as machine values, directly initialize *a*’s items. Alternatively,
    *init* can be an iterable (of characters when *typecode* is ''u'', otherwise of
    numbers): each item of the iterable initializes one item of *a*. |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| array | **类** array(*typecode, init*='''', /) 创建并返回一个具有给定 *typecode* 的数组对象
    *a*。*init* 可以是一个字符串（字节串，除了 *typecode* 为 ''u'' 外），其长度是 itemsize 的倍数：字符串的字节直接初始化
    *a* 的项。另外，*init* 可以是可迭代的对象（当 *typecode* 为 ''u'' 时是字符，否则是数字）：迭代对象的每一项初始化 *a* 的一项。
    |'
- en: array.array’s advantage is that, compared to a list, it can save memory when
    you need to hold a sequence of objects all of the same (numeric or character)
    type. An array object *a* has a one-character, read-only attribute *a*.typecode,
    set on creation, which specifies the type of *a*’s items. [Table 16-7](#type_codes_for_the_array_module)
    shows the possible typecode values for array.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: array.array 的优势在于，与列表相比，当你需要保存一系列对象，而这些对象都是同一类型（数值或字符）时，它可以节省内存。数组对象 *a* 在创建时具有一个字符的只读属性
    *a*.typecode，用于指定 *a* 的项的类型。[表 16-7](#type_codes_for_the_array_module) 展示了数组的可能
    typecode 值。
- en: Table 16-7\. Type codes for the array module
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 表 16-7\. 数组模块的类型代码
- en: '| typecode | C type | Python type | Minimum size |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| typecode | C 类型 | Python 类型 | 最小大小 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| ''b'' | char | int | 1 byte |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| ''b'' | char | int | 1 字节 |'
- en: '| ''B'' | unsigned char | int | 1 byte |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| ''B'' | 无符号 char | int | 1 字节 |'
- en: '| ''u'' | unicode char | str (length 1) | See note |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| ''u'' | Unicode 字符 | 字符串（长度为 1）| 参见注释 |'
- en: '| ''h'' | short | int | 2 bytes |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| ''h'' | short | int | 2 bytes |'
- en: '| ''H'' | unsigned short | int | 2 bytes |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| ''H'' | unsigned short | int | 2 bytes |'
- en: '| ''i'' | int | int | 2 bytes |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| ''i'' | int | int | 2 bytes |'
- en: '| ''I'' | unsigned int | int | 2 bytes |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| ''I'' | unsigned int | int | 2 bytes |'
- en: '| ''l'' | long | int | 4 bytes |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| ''l'' | long | int | 4 bytes |'
- en: '| ''L'' | unsigned long | int | 4 bytes |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| ''L'' | unsigned long | int | 4 bytes |'
- en: '| ''q'' | long long | int | 8 bytes |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| ''q'' | long long | int | 8 bytes |'
- en: '| ''Q'' | unsigned long long | int | 8 bytes |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| ''Q'' | unsigned long long | int | 8 bytes |'
- en: '| ''f'' | float | float | 4 bytes |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| ''f'' | float | float | 4 bytes |'
- en: '| ''d'' | double | float | 8 bytes |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| ''d'' | double | float | 8 bytes |'
- en: Minimum Size of typecode ‘u’
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型码 'u' 的最小大小
- en: '''u'' has an item size of 2 on a few platforms (notably, Windows) and 4 on
    just about every other platform. You can check the build type of a Python interpreter
    by using array.array(''u'').itemsize.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '''u'' 在一些平台（特别是 Windows）上的项大小为 2，在几乎所有其他平台上为 4。可以通过使用 array.array(''u'').itemsize
    检查 Python 解释器的构建类型。'
- en: The size, in bytes, of each item of an array *a* may be larger than the minimum,
    depending on the machine’s architecture, and is available as the read-only attribute
    *a*.itemsize.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 数组 *a* 中每个项的字节大小可能大于最小值，取决于机器的体系结构，并且可作为只读属性 *a*.itemsize 获取。
- en: Array objects expose all methods and operations of mutable sequences (as covered
    in [“Sequence Operations”](ch03.xhtml#sequence_operations)), except sort. Concatenation
    with + or +=, and slice assignment, require both operands to be arrays with the
    same typecode; in contrast, the argument to *a*.extend can be any iterable with
    items acceptable to *a*. In addition to the methods of mutable sequences (append,
    extend, insert, pop, etc.), an array object *a* exposes the methods and properties
    listed in [Table 16-8](#methods_and_properties_of_an_array_obje).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Array 对象暴露了所有可变序列的方法和操作（如[“序列操作”](ch03.xhtml#sequence_operations)中所述），但不包括排序。使用
    + 或 += 进行连接以及切片赋值，要求两个操作数都是具有相同类型码的数组；相反，*a*.extend 的参数可以是任何可迭代对象，其项可被 *a* 接受。除了可变序列的方法（append、extend、insert、pop
    等），数组对象 *a* 还公开了[表 16-8](#methods_and_properties_of_an_array_obje)中列出的方法和属性。
- en: Table 16-8\. Methods and properties of an array object a
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 表 16-8\. 数组对象 *a* 的方法和属性
- en: '| buffer_info | *a*.buffer_info() Returns a two-item tuple (*address*, *array_length*),
    where *array_length* is the number of items that you can store in *a*. The size
    of *a* in bytes is *a*.buffer_info()[1] * *a*.itemsize. |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| buffer_info | *a*.buffer_info() 返回一个二元元组（*address*，*array_length*），其中 *array_length*
    是 *a* 中可以存储的项数。*a* 的大小（以字节为单位）为 *a*.buffer_info()[1] * *a*.itemsize。'
- en: '| byteswap | *a*.byteswap() Swaps the byte order of each item of *a*. |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| byteswap | *a*.byteswap() 交换 *a* 中每个项的字节顺序。'
- en: '| frombytes | *a*.frombytes(*s*) Appends to *a* the bytes, interpreted as machine
    values, of bytes *s*. len(*s*) must be an exact multiple of *a*.itemsize. |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| frombytes | *a*.frombytes(*s*) 将字节串 *s*（以机器值解释）附加到 *a*。*s* 的长度必须正好是 *a*.itemsize
    的整数倍。'
- en: '| fromfile | *a*.fromfile(*f*, *n*) Reads *n* items, taken as machine values,
    from file object *f* and appends the items to *a*. *f* should be open for reading
    in binary mode—typically, mode ''rb'' (see [“Creating a File Object with open”](ch11.xhtml#creating_a_file_object_with_open)).
    When fewer than *n* items are available in *f*, fromfile raises EOFError after
    appending the items that are available (so, be sure to catch this in a **try**/**except**,
    if that’s OK in your app!). |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| fromfile | *a*.fromfile(*f*, *n*) 从文件对象 *f* 中读取 *n* 个项（以机器值形式），并将这些项附加到 *a*。*f*
    应该以二进制模式打开进行读取——通常是 ''rb'' 模式（参见[“使用 open 创建文件对象”](ch11.xhtml#creating_a_file_object_with_open)）。当
    *f* 中的项少于 *n* 时，fromfile 在附加可用项后引发 EOFError（因此，在您的应用程序中如果可以，请务必捕获此异常！）。'
- en: '| fromlist | *a*.fromlist(*L*) Appends to *a* all items of list *L*. |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| fromlist | *a*.fromlist(*L*) 将列表 *L* 的所有项附加到 *a*。'
- en: '| fromunicode | *a*.fromunicode(*s*) Appends to *a* all characters from string
    *s*. *a* must have typecode ''u''; otherwise, Python raises ValueError. |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| fromunicode | *a*.fromunicode(*s*) 将字符串 *s* 的所有字符附加到 *a*。*a* 必须具有类型码 ''u''；否则，Python
    将引发 ValueError。'
- en: '| itemsize | *a*.itemsize Property that returns the size, in bytes, of each
    item in *a*. |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| itemsize | *a*.itemsize 返回 *a* 中每个项的字节大小。'
- en: '| tobytes | *a*.tobytes() tobytes returns the bytes representation of the items
    in a. For any *a*, len(*a*.tobytes()) == len(*a*)**a*.itemsize. *f*.write(*a*.tobytes())
    is the same as *a*.tofile(*f*). |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| tobytes | *a*.tobytes() tobytes 返回数组 *a* 中项的字节表示。对于任何 *a*，len(*a*.tobytes())
    == len(*a*)**a*.itemsize。*f*.write(*a*.tobytes()) 等同于 *a*.tofile(*f*)。'
- en: '| tofile | *a*.tofile(*f*) Writes all items of *a*, taken as machine values,
    to file object *f*. Note that *f* should be open for writing in binary mode—for
    example, with mode ''wb''. |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| tofile | *a*.tofile(*f*) 将 *a* 的所有项目作为机器值写入文件对象 *f*。请注意 *f* 应该以二进制写入模式打开，例如使用模式
    ''wb''。 |'
- en: '| tolist | *a*.tolist() Creates and returns a list object with the same items
    as *a*, like list(*a*). |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| tolist | *a*.tolist() 创建并返回一个与 *a* 中项目相同的列表对象，类似于 list(*a*)。 |'
- en: '| tounicode | *a*.tounicode() Creates and returns a string with the same items
    as *a*, like ''''.join(*a*). *a* must have typecode ''u''; otherwise, Python raises
    ValueError. |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| tounicode | *a*.tounicode() 创建并返回一个与 *a* 中项目相同的字符串，类似于 ''''.join(*a*)。*a*
    必须有类型码 ''u''，否则 Python 会引发 ValueError。'
- en: '| typecode | *a*.typecode Property that returns the typecode used to create
    a*.* |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| typecode | *a*.typecode 返回用于创建 a 的类型码的属性。 |'
- en: Extensions for Numeric Array Computation
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数值数组计算的扩展
- en: As you’ve seen, Python has great built-in support for numeric processing. The
    third-party library [SciPy](https://scipy.org), and many, *many* other packages,
    such as [NumPy](https://numpy.org), [Matplotlib](https://matplotlib.org), [SymPy](https://oreil.ly/oVs_S),
    [Numba](https://numba.pydata.org), [Pandas](https://pandas.pydata.org), [PyTorch](https://pytorch.org),
    [CuPy](https://cupy.dev), and [TensorFlow](https://www.tensorflow.org), provide
    even more tools. We introduce NumPy here, then provide a brief description of
    SciPy and some other packages, with pointers to their documentation.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，Python 在数值处理方面有很好的内置支持。第三方库 [SciPy](https://scipy.org)，以及许多其他库，如 [NumPy](https://numpy.org)，[Matplotlib](https://matplotlib.org)，[SymPy](https://oreil.ly/oVs_S)，[Numba](https://numba.pydata.org)，[Pandas](https://pandas.pydata.org)，[PyTorch](https://pytorch.org)，[CuPy](https://cupy.dev)
    和 [TensorFlow](https://www.tensorflow.org)，提供了更多工具。我们在这里介绍 NumPy，然后简要描述了 SciPy
    和其他一些库，并提供指向它们文档的链接。
- en: NumPy
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NumPy
- en: If you need a lightweight, one-dimensional array of numbers, the standard library’s
    array module may suffice. If your work involves scientific computing, image processing,
    multidimensional arrays, linear algebra, or other applications involving large
    amounts of data, the popular third-party NumPy package meets your needs. Extensive
    documentation is available [online](https://docs.scipy.org/doc); a free PDF of
    Travis Oliphant’s [*Guide to NumPy*](https://oreil.ly/QA2xJ) is also available.^([2](ch16.xhtml#ch01fn123))
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个轻量级的一维数值数组，标准库中的 array 模块可能足够了。如果你的工作涉及科学计算、图像处理、多维数组、线性代数或其他涉及大量数据的应用程序，流行的第三方
    NumPy 包能够满足你的需求。在线文档详尽可查看 [这里](https://docs.scipy.org/doc)；Travis Oliphant 的 [*Guide
    to NumPy*](https://oreil.ly/QA2xJ) 也提供免费的 PDF 下载。^([2](ch16.xhtml#ch01fn123))
- en: NumPy or numpy?
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NumPy 还是 numpy？
- en: The docs variously refer to the package as NumPy or Numpy; however, in coding,
    the package is called numpy, and you usually import it with **import** numpy **as**
    np. This section follows those conventions.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 文档中有时将该包称为 NumPy 或 Numpy；但在编码中，该包通常称为 numpy，并使用 **import** numpy **as** np 导入。本节遵循这些约定。
- en: NumPy provides the class ndarray, which you can [subclass](https://oreil.ly/FK9qK)
    to add functionality for your particular needs. An ndarray object has *n* dimensions
    of homogeneous items (items can include containers of heterogeneous types). Each
    ndarray object *a* has a certain number of dimensions (aka *axes*), known as its
    *rank*. A *scalar* (i.e., a single number) has rank 0, a *vector* has rank 1,
    a *matrix* has rank 2, and so forth. An ndarray object also has a *shape*, which
    can be accessed as property shape. For example, for a matrix *m* with 2 columns
    and 3 rows, *m*.shape is (3,2).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 提供了 ndarray 类，你可以 [派生子类](https://oreil.ly/FK9qK) 来添加特定需求的功能。一个 ndarray
    对象包含 *n* 维同类项（项可能包括异类类型的容器）。每个 ndarray 对象 *a* 有一定数量的维度（也称为 *轴*），称为其 *秩*。一个 *标量*（即单个数）的秩为
    0，一个 *向量* 的秩为 1，一个 *矩阵* 的秩为 2，依此类推。ndarray 对象还有一个 *shape* 属性，可以通过属性 shape 访问。例如，对于一个有
    2 列 3 行的矩阵 *m*，*m*.shape 是 (3,2)。
- en: NumPy supports a wider range of [numeric types](https://oreil.ly/HPxtV) (instances
    of dtype) than Python; the default numerical types are bool_ (1 byte), int_ (either
    int64 or int32, depending on your platform), float_ (short for float64), and complex_
    (short for complex128).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 支持比 Python 更广泛的 [数值类型](https://oreil.ly/HPxtV)（dtype 实例）；默认数值类型为 bool_（1
    字节）、int_（根据平台为 int64 或 int32）、float_（float64 的简写）和 complex_（complex128 的简写）。
- en: Creating a NumPy array
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 NumPy 数组
- en: 'There are several ways to create an array in NumPy. Among the most common are:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方式可以在 NumPy 中创建数组。最常见的包括：
- en: With the factory function np.array, from a sequence (often a nested one), with
    *type inference* or by explicitly specifying *dtype*
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工厂函数np.array，从序列（通常是嵌套序列）中进行数组创建，可以进行*type inference*或显式指定*dtype*
- en: With factory functions np.zeros, np.ones, or np.empty, which default to *dtype*
    float64
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工厂函数np.zeros、np.ones或np.empty，默认使用*dtype*为float64
- en: With factory function np.indices, which defaults to *dtype* int64
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工厂函数np.indices，默认使用*dtype*为int64
- en: With factory functions np.random.uniform, np.random.normal, np.random.binomial,
    etc., which default to *dtype* float64
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工厂函数np.random.uniform、np.random.normal、np.random.binomial等，默认使用*dtype*为float64
- en: With factory function np.arange (with the usual *start*, *stop*, *stride*),
    or with factory function np.linspace (with *start*, *stop*, *quantity*) for better
    floating-point behavior
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工厂函数np.arange（通常是*start*、*stop*、*stride*）、或者使用工厂函数np.linspace（*start*、*stop*、*quantity*）以获得更好的浮点行为
- en: By reading data from files with other np functions (e.g., CSV with np.genfromtxt)
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用其他np函数从文件中读取数据（例如，使用np.genfromtxt读取CSV文件）
- en: 'Here are some examples of creating an array using the various techniques just
    described:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用刚才描述的各种技术创建数组的一些示例：
- en: '[PRE64]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Shape, indexing, and slicing
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 形状、索引和切片
- en: Each ndarray object *a* has an attribute *a*.shape, which is a tuple of ints.
    len(*a*.shape) is *a*’s *rank*; for example, a one-dimensional array of numbers
    (also known as a *vector*) has rank 1, and *a*.shape has just one item. More generally,
    each item of *a*.shape is the length of the corresponding dimension of *a*. *a*’s
    number of elements, known as its *size*, is the product of all items of *a*.shape
    (also available as property *a*.size). Each dimension of *a* is also known as
    an *axis*. Axis indices are from 0 and up, as usual in Python. Negative axis indices
    are allowed and count from the right, so -1 is the last (rightmost) axis.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 每个ndarray对象*a*都有一个属性*a*.shape，它是一个整数元组。len(*a*.shape)是*a*的秩；例如，一个一维数字数组（也称为*vector*）的秩为1，*a*.shape只有一个项目。更一般地，*a*.shape的每个项目是*a*相应维度的长度。*a*的元素数量，称为其*size*，是*a*.shape所有项目的乘积（也可以作为属性*a*.size获得）。*a*的每个维度也称为一个*axis*。轴索引从0开始，如Python中通常所见。负轴索引是允许的，并且从右边计数，因此-1是最后（最右边）的轴。
- en: 'Each array *a* (except a scalar, meaning an array of rank 0) is a Python sequence.
    Each item *a*[*i*] of *a* is a subarray of *a*, meaning it is an array with a
    rank one less than *a*’s: *a*[*i*].shape == *a*.shape[1:]. For example, if *a*
    is a two-dimensional matrix (*a* is of rank 2), *a*[*i*], for any valid index
    *i*, is a one-dimensional subarray of *a* that corresponds to one row of the matrix.
    When *a*’s rank is 1 or 0, *a*’s items are *a*’s elements (just one element, for
    rank 0 arrays). Since *a* is a sequence, you can index *a* with normal indexing
    syntax to access or change *a*’s items. Note that *a*’s items are *a*’s subarrays;
    only for an array of rank 1 or 0 are the array’s *items* the same thing as the
    array’s *elements*.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数组*a*（除了标量，即秩为0的数组）都是Python序列。*a*的每个项*a*[*i*]是*a*的子数组，意味着它的秩比*a*低一级：*a*[*i*].shape
    == *a*.shape[1:]。例如，如果*a*是一个二维矩阵（*a*的秩为2），对于任何有效的索引*i*，*a*[*i*]是*a*的一个一维子数组，对应于矩阵的一行。当*a*的秩为1或0时，*a*的项是*a*的元素（对于秩为0的数组，只有一个元素）。由于*a*是一个序列，您可以使用常规索引语法对*a*进行索引以访问或更改*a*的项。请注意，*a*的项是*a*的子数组；只有对于秩为1或0的数组，数组的*items*才与数组的*elements*相同。
- en: As with any other sequence, you can also *slice* *a*. After *b* = *a*[*i*:*j*],
    *b* has the same rank as *a*, and *b*.shape equals *a*.shape except that *b*.shape[0]
    is the length of the slice *a*[*i*:*j*], (i.e., when *a*.shape[0] > *j* >= *i*
    >= 0, the length of the slice is *j* - *i*, as described in [“Slicing a sequence”](ch03.xhtml#slicing_a_sequence)).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他序列一样，您也可以对*a*进行*slice*操作。在*b* = *a*[*i*:*j*]之后，*b*与*a*具有相同的秩，且*b*.shape等于*a*.shape，除了*b*.shape[0]是切片*a*[*i*:*j*]的长度（即当*a*.shape[0]
    > *j* >= *i* >= 0时，切片的长度为*j* - *i*，如[“切片序列”](ch03.xhtml#slicing_a_sequence)中所述）。
- en: 'Once you have an array *a*, you can call *a*.reshape (or, equivalently, np.reshape
    with *a* as the first argument). The resulting shape must match *a*.size: when
    *a*.size is 12, you can call *a*.reshape(3, 4) or *a*.reshape(2, 6), but *a*.reshape(2,
    5) raises ValueError. Note that reshape does not work in place: you must explicitly
    bind or rebind the array, for example, *a* = *a*.reshape(*i*, *j*) or *b* = *a*.reshape(*i*,
    *j*).'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了数组*a*，您可以调用*a*.reshape（或等效地，使用*a*作为第一个参数调用np.reshape）。结果的形状必须与*a*.size相匹配：当*a*.size为12时，您可以调用*a*.reshape(3,
    4)或*a*.reshape(2, 6)，但*a*.reshape(2, 5)会引发ValueError。请注意，reshape不会在原地工作：您必须显式地绑定或重新绑定数组，例如，*a*
    = *a*.reshape(*i*, *j*)或*b* = *a*.reshape(*i*, *j*)。
- en: 'You can also loop on (nonscalar) *a* with **for**, just as you can with any
    other sequence. For example, this:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以像处理任何其他序列一样，使用 **for** 对（非标量）*a* 进行循环。例如，这样：
- en: '[PRE96]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'means the same thing as:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 意思与以下相同：
- en: '[PRE97]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: In these examples, each item *x* of *a* in the **for** loop is a subarray of
    *a*. For example, if *a* is a two-dimensional matrix, each *x* in either of these
    loops is a one-dimensional subarray of *a* that corresponds to a row of the matrix.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，循环中的每个 *x* 都是 *a* 的子数组。例如，如果 *a* 是二维矩阵，则在任何一个循环中，每个 *x* 都是对应于矩阵行的一维子数组。
- en: 'You can also index or slice *a* by a tuple. For example, when *a*’s rank is
    >= 2, you can write *a*[*i*][*j*] as *a*[*i*, *j*], for any valid *i* and *j*,
    for rebinding as well as for access; tuple indexing is faster and more convenient.
    *Do not put parentheses* inside the brackets to indicate that you are indexing
    *a* by a tuple: just write the indices one after the other, separated by commas.
    *a*[*i*, *j*] means exactly the same thing as *a*[(*i*, *j*)], but the form without
    parentheses is more readable.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过元组对 *a* 进行索引或切片。例如，当 *a* 的秩 >= 2 时，你可以将 *a*[*i*][*j*] 写为 *a*[*i*, *j*]，用于重新绑定和访问；元组索引更快更方便。*不要在括号内*使用括号来指示你正在通过元组对
    *a* 进行索引：只需将索引逐个写出，用逗号分隔。*a*[*i*, *j*] 和 *a*[(*i*, *j*)] 的意思完全相同，但没有括号的形式更易读。
- en: An indexing is a slicing in which one or more of the tuple’s items are slices,
    or (at most once per slicing) the special form ... (the Python built-in Ellipsis).
    ... expands into as many all-axis slices (:) as needed to “fill” the rank of the
    array you’re slicing. For example, *a*[1,...,2] is like *a*[1,:,:,2] when *a*’s
    rank is 4, but like *a*[1,:,:,:,:,2] when *a*’s rank is 6.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 索引是一种切片，其中元组的一个或多个项是切片，或者（每个切片最多一次）是特殊形式 ...（Python 内置的省略号）。... 扩展为尽可能多的全轴切片（:），以“填充”你正在切片的数组的秩。例如，*a*[1,...,2]
    当 *a* 的秩是 4 时，相当于 *a*[1,:,:,2]，但当 *a* 的秩是 6 时，相当于 *a*[1,:,:,:,:,2]。
- en: 'The following snippets show looping, indexing, and slicing:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码段展示了循环、索引和切片：
- en: '[PRE98]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Matrix operations in NumPy
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 NumPy 中的矩阵操作
- en: 'As mentioned in [“The operator Module”](#the_operator_module), NumPy implements
    the operator @ for matrix multiplication of arrays. *a1* @ *a2* is like np.matmul(*a1*,
    *a2*). When both matrices are two-dimensional, they’re treated as conventional
    matrices. When one argument is a vector, you conceptually promote it to a two-dimensional
    array, as if by temporarily appending or prepending a 1, as needed, to its shape.
    Do not use @ with a scalar; use * instead. Matrices also allow addition (using
    +) with a scalar, as well as with vectors and other matrices of compatible shapes.
    Dot product is also available for matrices, using np.dot(*a1*, *a2*). A few simple
    examples of these operators follow:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[“运算符模块”](#the_operator_module)中提到的，NumPy 使用运算符 @ 来实现数组的矩阵乘法。*a1* @ *a2*
    就像 np.matmul(*a1*, *a2*)。当两个矩阵是二维的时，它们被视为传统的矩阵。当一个参数是向量时，你可以概念上将其提升为二维数组，方法是根据需要临时添加或预置
    1 到其形状。不要使用 @ 来与标量相乘；请使用 *。矩阵还可以与标量以及具有兼容形状的向量和其他矩阵进行加法（使用 +）。矩阵的点积也可使用 np.dot(*a1*,
    *a2*)。下面是几个这些运算符的简单示例：
- en: '[PRE110]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: NumPy is rich and powerful enough to warrant whole books of its own; we have
    only touched on a few details. See the NumPy [documentation](https://oreil.ly/UceLt)
    for extensive coverage of its many, many features.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 强大而丰富到足以值得整本书来详细讨论；我们只是浅尝辄止。请参阅 NumPy 的[文档](https://oreil.ly/UceLt)以深入了解其众多特性。
- en: SciPy
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SciPy
- en: Whereas NumPy contains classes and functions for handling arrays, the SciPy
    library supports more advanced numeric computation. For example, while NumPy provides
    a few linear algebra methods, SciPy provides advanced decomposition methods and
    supports more advanced functions, such as allowing a second matrix argument for
    solving generalized eigenvalue problems. In general, when you are doing advanced
    numeric computation, it’s a good idea to install both SciPy and NumPy.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 NumPy 包含用于处理数组的类和函数，但 SciPy 库支持更高级的数值计算。例如，虽然 NumPy 提供了一些线性代数方法，但 SciPy 提供了高级分解方法，并支持更高级的函数，例如允许第二个矩阵参数来解决广义特征值问题。一般来说，当进行高级数值计算时，安装
    SciPy 和 NumPy 是个好主意。
- en: '[SciPy.org](https://oreil.ly/WO3ON) also hosts [docs](https://oreil.ly/zf6-O)
    for a number of other packages, which are integrated with SciPy and NumPy, including
    [Matplotlib](https://matplotlib.org), which provides 2D plotting support; [SymPy](https://oreil.ly/fbfld),
    which supports symbolic mathematics; [Jupyter Notebook](http://jupyter.org), a
    powerful interactive console shell and web application kernel; and [Pandas](https://pandas.pydata.org),
    which supports data analysis and modeling. You may also want to take a look at
    [mpmath](https://mpmath.org), for arbitrary precision, and [sagemath](https://www.sagemath.org),
    for even richer functionality.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '[SciPy.org](https://oreil.ly/WO3ON) 也托管了许多其他包的[文档](https://oreil.ly/zf6-O)，这些包与SciPy和NumPy集成，包括提供2D绘图支持的[Matplotlib](https://matplotlib.org)；支持符号数学的[SymPy](https://oreil.ly/fbfld)；强大的交互式控制台和Web应用内核[Jupyter
    Notebook](http://jupyter.org)；以及支持数据分析和建模的[Pandas](https://pandas.pydata.org)。您可能还想看一看用于任意精度的[mpmath](https://mpmath.org)，以及用于更丰富功能的[sagemath](https://www.sagemath.org)。'
- en: Additional numeric packages
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 额外的数值处理包
- en: 'The Python community has produced many more packages in the field of numeric
    processing. A few of them are:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: Python社区在数值处理领域产生了更多的包。其中一些包括：
- en: '[Anaconda](https://www.anaconda.com)'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '[Anaconda](https://www.anaconda.com)'
- en: A consolidated environment that simplifies the installation of Pandas, NumPy,
    and many related numerical processing, analytical, and visualization packages,
    and provides package management via its own conda package installer.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 一个整合环境，简化了Pandas、NumPy和许多相关数值处理、分析和可视化包的安装，并通过其自己的conda包安装程序提供包管理。
- en: '[gmpy2](https://pypi.org/project/gmpy2)'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '[gmpy2](https://pypi.org/project/gmpy2)'
- en: A module^([3](ch16.xhtml#ch01fn124)) that supports the GMP/MPIR, MPFR, and MPC
    libraries, to extend and accelerate Python’s abilities for multiple-precision
    arithmetic.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模块^([3](ch16.xhtml#ch01fn124))，支持GMP/MPIR、MPFR和MPC库，以扩展和加速Python在多精度算术方面的能力。
- en: '[Numba](https://numba.pydata.org)'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '[Numba](https://numba.pydata.org)'
- en: A just-in-time compiler to convert Numba-decorated Python functions and NumPy
    code to LLVM. Numba-compiled numerical algorithms in Python can approach the speeds
    of C or FORTRAN.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 一个即时编译器，用于将Numba装饰的Python函数和NumPy代码转换为LLVM。Python中使用Numba编译的数值算法可以接近C或FORTRAN的速度。
- en: '[PyTorch](https://pytorch.org)'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '[PyTorch](https://pytorch.org)'
- en: An open source machine learning framework.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 一个开源机器学习框架。
- en: '[TensorFlow](https://www.tensorflow.org/api_docs/python)'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '[TensorFlow](https://www.tensorflow.org/api_docs/python)'
- en: A comprehensive machine learning platform that operates at large scale and in
    mixed environments, using dataflow graphs to represent computation, shared state,
    and state manipulation operations. TensorFlow supports processing across multiple
    machines in a cluster, and within-machine across multicore CPUs, GPUs, and custom-designed
    ASICs. TensorFlow’s main API uses Python.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 一个全面的机器学习平台，可以在大规模和混合环境中运行，使用数据流图来表示计算、共享状态和状态操作。TensorFlow支持在集群中跨多台机器进行处理，在单台机器上跨多核CPU、GPU和定制ASIC进行处理。TensorFlow的主要API使用Python。
- en: ^([1](ch16.xhtml#ch01fn122-marker)) Superseded, technically, by the more recent,
    very similar standard [754-2008](https://oreil.ly/qL5nI), but practically still
    useful!
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch16.xhtml#ch01fn122-marker)) 在技术上被更近期的、非常相似的标准[754-2008](https://oreil.ly/qL5nI)取代，但在实际中仍然有用！
- en: ^([2](ch16.xhtml#ch01fn123-marker)) Python and the NumPy project have worked
    closely together for many years, with Python introducing language features specifically
    for NumPy (such as the @ operator and extended slicing) even though such novel
    language features are not (yet?) used anywhere in the Python standard library.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch16.xhtml#ch01fn123-marker)) Python和NumPy项目多年来密切合作，Python引入了专门为NumPy引入的语言特性（如@操作符和扩展切片），尽管这些新颖的语言特性（至今？）尚未在Python标准库的任何地方使用。
- en: ^([3](ch16.xhtml#ch01fn124-marker)) Originally derived from the work of one
    of this book’s authors.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch16.xhtml#ch01fn124-marker)) 最初来源于本书的一位作者的工作。
