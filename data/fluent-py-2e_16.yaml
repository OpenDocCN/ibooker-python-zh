- en: Chapter 13\. Interfaces, Protocols, and ABCs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 13 章。接口、协议和 ABCs
- en: Program to an interface, not an implementation.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 针对接口编程，而不是实现。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Gamma, Helm, Johnson, Vlissides, First Principle of Object-Oriented Design^([1](ch13.html#idm46582423423920))
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Gamma、Helm、Johnson、Vlissides，《面向对象设计的第一原则》^([1](ch13.html#idm46582423423920))
- en: Object-oriented programming is all about interfaces. The best approach to understanding
    a type in Python is knowing the methods it provides—its interface—as discussed
    in [“Types Are Defined by Supported Operations”](ch08.html#types_defined_by_ops_sec)
    ([Chapter 8](ch08.html#type_hints_in_def_ch)).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程关乎接口。在 Python 中理解类型的最佳方法是了解它提供的方法——即其接口——如 [“类型由支持的操作定义”](ch08.html#types_defined_by_ops_sec)（[第
    8 章](ch08.html#type_hints_in_def_ch)）中所讨论的。
- en: 'Depending on the programming language, we have one or more ways of defining
    and using interfaces. Since Python 3.8, we have four ways. They are depicted in
    the *Typing Map* ([Figure 13-1](#type_systems_described)). We can summarize them
    like this:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 根据编程语言的不同，我们有一种或多种定义和使用接口的方式。自 Python 3.8 起，我们有四种方式。它们在 *类型映射*（[图 13-1](#type_systems_described)）中有所描述。我们可以总结如下：
- en: Duck typing
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 鸭子类型
- en: Python’s default approach to typing from the beginning. We’ve been studying
    duck typing since [Chapter 1](ch01.html#data_model).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python 从一开始就采用的类型化方法。我们从 [第 1 章](ch01.html#data_model) 开始学习鸭子类型。
- en: Goose typing
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 鹅式类型
- en: The approach supported by abstract base classes (ABCs) since Python 2.6, which
    relies on runtime checks of objects against ABCs. *Goose typing* is a major subject
    in this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Python 2.6 起由抽象基类（ABCs）支持的方法，依赖于对象与 ABCs ��运行时检查。*鹅式类型* 是本章的一个重要主题。
- en: Static typing
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型
- en: The traditional approach of statically-typed languages like C and Java; supported
    since Python 3.5 by the `typing` module, and enforced by external type checkers
    compliant with [PEP 484—Type Hints](https://fpy.li/pep484). This is not the theme
    of this chapter. Most of [Chapter 8](ch08.html#type_hints_in_def_ch) and the upcoming
    [Chapter 15](ch15.html#more_types_ch) are about static typing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 类似 C 和 Java 这样的静态类型语言的传统方法；自 Python 3.5 起由 `typing` 模块支持，并由符合 [PEP 484—类型提示](https://fpy.li/pep484)
    的外部类型检查器强制执行。这不是本章的主题。[第 8 章](ch08.html#type_hints_in_def_ch)的大部分内容以及即将到来的 [第
    15 章](ch15.html#more_types_ch) 关于静态类型。
- en: Static duck typing
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 静态鸭子类型
- en: An approach made popular by the Go language; supported by subclasses of `typing.Protocol`—new
    in Python 3.8—also enforced by external type checkers. We first saw this in [“Static
    Protocols”](ch08.html#protocols_in_fn) ([Chapter 8](ch08.html#type_hints_in_def_ch)).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Go 语言推广的一种方法；由 `typing.Protocol` 的子类支持——Python 3.8 中新增——也由外部类型检查器强制执行。我们首次在
    [“静态协议”](ch08.html#protocols_in_fn)（[第 8 章](ch08.html#type_hints_in_def_ch)）中看到这一点。
- en: The Typing Map
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型映射
- en: 'The four typing approaches depicted in [Figure 13-1](#type_systems_described)
    are complementary: they have different pros and cons. It doesn’t make sense to
    dismiss any of them.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-1](#type_systems_described) 中描述的四种类型化方法是互补的：它们各有优缺点。不应该否定其中任何一种。'
- en: '![Four approaches to type checking](assets/flpy_1301.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![四种类型检查方法](assets/flpy_1301.png)'
- en: 'Figure 13-1\. The top half describes runtime type checking approaches using
    just the Python interpreter; the bottom requires an external static type checker
    such as MyPy or an IDE like PyCharm. The left quadrants cover typing based on
    the object’s structure— i.e., the methods provided by the object, regardless of
    the name of its class or superclasses; the right quadrants depend on objects having
    explicitly named types: the name of the object’s class, or the name of its superclasses.'
  id: totrans-17
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 13-1。上半部分描述了仅使用 Python 解释器进行运行时类型检查的方法；下半部分需要外部静态类型检查器，如 MyPy 或 PyCharm 这样的
    IDE。左侧象限涵盖基于对象结构的类型化——即对象提供的方法，而不考虑其类或超类的名称；右侧象限依赖于对象具有明确定义的类型：对象的类名或其超类的名称。
- en: Each of these four approaches rely on interfaces to work, but static typing
    can be done—poorly—using only concrete types instead of interface abstractions
    like protocols and abstract base classes. This chapter is about duck typing, goose
    typing, and static duck typing—typing disciplines that revolve around interfaces.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这四种方法都依赖于接口来工作，但静态类型可以通过仅使用具体类型而不是接口抽象，如协议和抽象基类，来实现——这样做效果不佳。本章讨论了鸭子类型、鹅式类型和静态鸭子类型——围绕接口展开的类型学科。
- en: 'This chapter is split in four main sections, addressing three of the four quadrants
    in the Typing Map ([Figure 13-1](#type_systems_described)):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为四个主要部分，涵盖了类型映射中四个象限中的三个：[图 13-1](#type_systems_described)。
- en: '[“Two Kinds of Protocols”](#two_kinds_protocols_sec) compares the two forms
    of structural typing with protocols—i.e., the lefthand side of the Typing Map.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“两种类型协议”](#two_kinds_protocols_sec) 比较了两种结构类型与协议的形式——即类型映射的左侧。'
- en: '[“Programming Ducks”](#prog_ducks_sec) dives deeper into Python’s usual duck
    typing, including how to make it safer while preserving its major strength: flexibility.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“编程鸭子”](#prog_ducks_sec) 深入探讨了 Python 的常规鸭子类型，包括如何使其更安全，同时保持其主要优势：灵活性。'
- en: '[“Goose Typing”](#goose_typing_sec) explains the use of ABCs for stricter runtime
    type checking. This is the longest section, not because it’s more important, but
    because there are more sections about duck typing, static duck typing, and static
    typing elsewhere in the book.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“鹅式类型”](#goose_typing_sec) 解释了使用 ABCs 进行更严格的运行时类型检查。这是最长的部分，不是因为它更重要，而是因为书中其他地方有更多关于鸭子类型、静态鸭子类型和静态类型的部分。'
- en: '[“Static Protocols”](#static_protocols_sec) covers usage, implementation, and
    design of `typing.Protocol` subclasses—useful for static and runtime type checking.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“静态协议”](#static_protocols_sec) 涵盖了 `typing.Protocol` 子类的用法、实现和设计——对于静态和运行时类型检查很有用。'
- en: What’s New in This Chapter
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章的新内容
- en: 'This chapter was heavily edited and is about 24% longer than the corresponding
    Chapter 11 in the first edition of *Fluent Python*. Although some sections and
    many paragraphs are the same, there’s a lot of new content. These are the highlights:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章经过大幅编辑，比第一版《流畅的Python》中对应的第11章长约24%。虽然有些部分和许多段落是相同的，但也有很多新内容。以下是亮点：
- en: The chapter introduction and the Typing Map ([Figure 13-1](#type_systems_described))
    are new. That’s the key to most new content in this chapter—and all other chapters
    related to typing in Python ≥ 3.8.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的介绍和类型映射（[图13-1](#type_systems_described)）是新内容。这是本章和所有涉及Python ≥ 3.8中类型的其他章节中大部分新内容的关键。
- en: '[“Two Kinds of Protocols”](#two_kinds_protocols_sec) explains the similarities
    and differences between dynamic and static protocols.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“两种类型的协议”](#two_kinds_protocols_sec)解释了动态协议和静态协议之间的相似之处和不同之处。'
- en: '[“Defensive Programming and ‘Fail Fast’”](#defensive_duck_prog_sec) mostly
    reproduces content from the first edition, but was updated and now has a section
    title to highlight its importance.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“防御性编程和‘快速失败’”](#defensive_duck_prog_sec) 主要复制了第一版的内容，但进行了更新，现在有一个部分标题以突出其重要性。'
- en: '[“Static Protocols”](#static_protocols_sec) is all new. It builds on the initial
    presentation in [“Static Protocols”](ch08.html#protocols_in_fn) ([Chapter 8](ch08.html#type_hints_in_def_ch)).'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“静态协议”](#static_protocols_sec)是全新的。它在[“静态协议”](ch08.html#protocols_in_fn)（[第8章](ch08.html#type_hints_in_def_ch)）的初始介绍基础上进行了扩展。'
- en: Updated class diagrams of `collections.abc` in Figures [13-2](#sequence_uml_repeat),
    [13-3](#mutablesequence_uml), and [13-4](#collections_uml) to include the `Collection`
    ABC, from Python 3.6.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图[13-2](#sequence_uml_repeat)、[13-3](#mutablesequence_uml)和[13-4](#collections_uml)中更新了`collections.abc`的类图，包括Python
    3.6中的`Collection` ABC。
- en: The first edition of *Fluent Python* had a section encouraging use of the `numbers`
    ABCs for goose typing. In [“The numbers ABCs and Numeric Protocols”](#numbers_abc_proto_sec),
    I explain why you should use numeric static protocols from the `typing` module
    instead, if you plan to use static type checkers as well as runtime checks in
    the style of goose typing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 《流畅的Python》第一版中有一节鼓励使用`numbers` ABCs进行鹅式类型化。在[“数字ABC和数值协议”](#numbers_abc_proto_sec)中，我解释了为什么如果您计划同时使用静态类型检查器和鹅式类型检查器的运行时检查，应该使用`typing`模块中的数值静态协议。
- en: Two Kinds of Protocols
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 两种类型的协议
- en: 'The word *protocol* has different meanings in computer science depending on
    context. A network protocol such as HTTP specifies commands that a client can
    send to a server, such as `GET`, `PUT`, and `HEAD`. We saw in [“Protocols and
    Duck Typing”](ch12.html#protocol_duck_section) that an object protocol specifies
    methods which an object must provide to fulfill a role. The `FrenchDeck` example
    in [Chapter 1](ch01.html#data_model) demonstrated one object protocol, the sequence
    protocol: the methods that allow a Python object to behave as a sequence.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上下文，计算机科学中的“协议”一词有不同的含义。诸如HTTP之类的网络协议指定了客户端可以发送给服务器的命令，例如`GET`、`PUT`和`HEAD`。我们在[“协议和鸭子类型”](ch12.html#protocol_duck_section)中看到，对象协议指定了对象必须提供的方法以履行某种角色。[第1章](ch01.html#data_model)中的`FrenchDeck`示例演示了一个对象协议，即序列协议：允许Python对象表现为序列���方法。
- en: Implementing a full protocol may require several methods, but often it is OK
    to implement only part of it. Consider the `Vowels` class in [Example 13-1](#ex_minimal_sequence).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 实现完整的协议可能需要多个方法，但通常只实现部分也是可以的。考虑一下[示例13-1](#ex_minimal_sequence)中的`Vowels`类。
- en: Example 13-1\. Partial sequence protocol implementation with `__getitem__`
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例13-1。使用`__getitem__`部分实现序列协议
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Implementing `__getitem__` is enough to allow retrieving items by index, and
    also to support iteration and the `in` operator. The `__getitem__` special method
    is really the key to the sequence protocol. Take a look at this entry from the
    [*Python/C API Reference Manual*](https://fpy.li/13-1), [“Sequence Protocol” section](https://fpy.li/13-2):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`__getitem__`足以允许按索引检索项目，并支持迭代和`in`运算符。`__getitem__`特殊方法实际上是序列协议的关键。查看[*Python/C
    API参考手册*](https://fpy.li/13-1)中的这篇文章，[“序列协议”部分](https://fpy.li/13-2)。
- en: '`int PySequence_Check(PyObject *o)`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`int PySequence_Check(PyObject *o)`'
- en: Return `1` if the object provides sequence protocol, and `0` otherwise. Note
    that it returns `1` for Python classes with a `__getitem__()` method unless they
    are `dict` subclasses […].
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象提供序列协议，则返回`1`，否则返回`0`。请注意，对于具有`__getitem__()`方法的Python类，除非它们是`dict`子类[...]，否则它将返回`1`。
- en: We expect a sequence to also support `len()`, by implementing `__len__`. `Vowels`
    has no `__len__` method, but it still behaves as a sequence in some contexts.
    And that may be enough for our purposes. That is why I like to say that a protocol
    is an “informal interface.” That is also how protocols are understood in Smalltalk,
    the first object-oriented programming environment to use that term.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望序列还支持`len()`，通过实现`__len__`来实现。`Vowels`没有`__len__`方法，但在某些情况下仍然表现为序列。这对我们的目的可能已经足够了。这就是为什么我喜欢说协议是一种“非正式接口”。这也是Smalltalk中对协议的理解方式，这是第一个使用该术语的面向对象编程环境。
- en: Except in pages about network programming, most uses of the word “protocol”
    in the Python documentation refer to these informal interfaces.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了关于网络编程的页面外，Python文档中“协议”一词的大多数用法指的是这些非正式接口。
- en: 'Now, with the adoption of [PEP 544—Protocols: Structural subtyping (static
    duck typing)](https://fpy.li/pep544) in Python 3.8, the word “protocol” has another
    meaning in Python—closely related, but different. As we saw in [“Static Protocols”](ch08.html#protocols_in_fn)
    ([Chapter 8](ch08.html#type_hints_in_def_ch)), PEP 544 allows us to create subclasses
    of `typing.Protocol` to define one or more methods that a class must implement
    (or inherit) to satisfy a static type checker.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着Python 3.8中采纳了[PEP 544—协议：结构子类型（静态鸭子类型）](https://fpy.li/pep544)，在Python中，“协议”一词有了另一层含义——与之密切相关，但又不同。正如我们在[“静态协议”](ch08.html#protocols_in_fn)（[第8章](ch08.html#type_hints_in_def_ch)）中看到的，PEP
    544允许我们创建`typing.Protocol`的子类来定义一个或多个类必须实现（或继承）以满足静态类型检查器的方法。
- en: 'When I need to be specific, I will adopt these terms:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我需要具体说明时，我会采用这些术语：
- en: Dynamic protocol
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 动态协议
- en: The informal protocols Python always had. Dynamic protocols are implicit, defined
    by convention, and described in the documentation. Python’s most important dynamic
    protocols are supported by the interpreter itself, and are documented in the [“Data
    Model” chapter](https://fpy.li/dtmodel) of *The Python Language Reference*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Python 一直拥有的非正式协议。动态协议是隐式的，按照约定定义，并在文档中描述。Python 最重要的动态协议由解释器本身支持，并在《Python
    语言参考》的[“数据模型”章节](https://fpy.li/dtmodel)中有详细说明。
- en: Static protocol
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 静态协议
- en: 'A protocol as defined by [PEP 544—Protocols: Structural subtyping (static duck
    typing)](https://fpy.li/pep544), since Python 3.8. A static protocol has an explicit
    definition: a `typing.Protocol` subclass.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由 [PEP 544—协议：结构子类型（静态鸭子类型）](https://fpy.li/pep544) 定义的协议，自 Python 3.8 起。静态协议有明确的定义：`typing.Protocol`
    的子类。
- en: 'There are two key differences between them:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 它们之间有两个关键区别：
- en: An object may implement only part of a dynamic protocol and still be useful;
    but to fulfill a static protocol, the object must provide every method declared
    in the protocol class, even if your program doesn’t need them all.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个对象可能只实现动态协议的一部分仍然是有用的；但为了满足静态协议，对象必须提供协议类中声明的每个方法，即使你的程序并不需要它们。
- en: Static protocols can be verified by static type checkers, but dynamic protocols
    can’t.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态协议可以被静态类型检查器验证，但动态协议不能。
- en: Both kinds of protocols share the essential characteristic that a class never
    needs to declare that it supports a protocol by name, i.e., by inheritance.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种协议共享一个重要特征，即类永远不需要声明支持某个协议，即通过继承来支持。
- en: 'In addition to static protocols, Python provides another way of defining an
    explicit interface in code: an abstract base class (ABC).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 除了静态协议，Python 还提供了另一种在代码中定义显式接口的方式：抽象基类（ABC）。
- en: The rest of this chapter covers dynamic and static protocols, as well as ABCs.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分涵盖了动态和静态协议，以及 ABC。
- en: Programming Ducks
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程鸭
- en: 'Let’s start our discussion of dynamic protocols with two of the most important
    in Python: the sequence and iterable protocols. The interpreter goes out of its
    way to handle objects that provide even a minimal implementation of those protocols,
    as the next section explains.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Python 中两个最重要的动态协议开始讨论：序列和可迭代协议。解释器会尽最大努力处理提供了即使是最简单实现的对象，下一节将解释这一点。
- en: Python Digs Sequences
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 探究序列
- en: The philosophy of the Python Data Model is to cooperate with essential dynamic
    protocols as much as possible. When it comes to sequences, Python tries hard to
    work with even the simplest implementations.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Python 数据模型的哲学是尽可能与基本的动态协议合作。在处理序列时，Python 会尽最大努力与即使是最简单的实现一起工作。
- en: '[Figure 13-2](#sequence_uml_repeat) shows how the `Sequence` interface is formalized
    as an ABC. The Python interpreter and built-in sequences like `list`, `str`, etc.,
    do not rely on that ABC at all. I am using it only to describe what a full-fledged
    `Sequence` is expected to support.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-2](#sequence_uml_repeat) 显示了 `Sequence` 接口如何被正式化为一个 ABC。Python 解释器和内置序列如
    `list`、`str` 等根本不依赖于该 ABC。我只是用它来描述一个完整的 `Sequence` 预期支持的内容。'
- en: '![UML class diagram for `Sequence`](assets/flpy_1302.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![`Sequence` 的 UML 类图](assets/flpy_1302.png)'
- en: Figure 13-2\. UML class diagram for the `Sequence` ABC and related abstract
    classes from `collections.abc`. Inheritance arrows point from a subclass to its
    superclasses. Names in italic are abstract methods. Before Python 3.6, there was
    no `Collection` ABC—`Sequence` was a direct subclass of `Container`, `Iterable`,
    and `Sized`.
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 13-2\. `Sequence` ABC 和 `collections.abc` 中相关抽象类的 UML 类图。继承箭头从子类指向其超类。斜体字体的名称是抽象方法。在
    Python 3.6 之前，没有 `Collection` ABC——`Sequence` 是 `Container`、`Iterable` 和 `Sized`
    的直接子类。
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Most ABCs in the `collections.abc` module exist to formalize interfaces that
    are implemented by built-in objects and are implicitly supported by the interpreter—both
    of which predate the ABCs themselves. The ABCs are useful as starting points for
    new classes, and to support explicit type checking at runtime (a.k.a. *goose typing*)
    as well as type hints for static type checkers.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections.abc` 模块中的大多数 ABC 存在的目的是为了正式化由内置对象实现并被解释器隐式支持的接口——这两者都早于 ABC 本身。这些
    ABC 对于新类是有用的起点，并支持运行时的显式类型检查（又称为 *鹅式类型化*）以及静态类型检查器的类型提示。'
- en: Studying [Figure 13-2](#sequence_uml_repeat), we see that a correct subclass
    of `Sequence` must implement `__getitem__` and `__len__` (from `Sized`). All the
    other methods in `Sequence` are concrete, so subclasses can inherit their implementations—or
    provide better ones.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 研究 [图 13-2](#sequence_uml_repeat)，我们看到 `Sequence` 的正确子类必须实现 `__getitem__` 和
    `__len__`（来自 `Sized`）。`Sequence` 中的所有其他方法都是具体的，因此子类可以继承它们的实现——或提供更好的实现。
- en: Now, recall the `Vowels` class in [Example 13-1](#ex_minimal_sequence). It does
    not inherit from `abc.Sequence` and it only implements `__getitem__`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回想一下 [示例 13-1](#ex_minimal_sequence) 中的 `Vowels` 类。它没有继承自 `abc.Sequence`，只实现了
    `__getitem__`。
- en: 'There is no `__iter__` method, yet `Vowels` instances are iterable because—as
    a fallback—if Python finds a `__getitem__` method, it tries to iterate over the
    object by calling that method with integer indexes starting with `0`. Because
    Python is smart enough to iterate over `Vowels` instances, it can also make the
    `in` operator work even when the `__contains__` method is missing: it does a sequential
    scan to check if an item is present.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 没有 `__iter__` 方法，但 `Vowels` 实例是可迭代的，因为——作为后备——如果 Python 发现 `__getitem__` 方法，它会尝试通过调用从
    `0` 开始的整数索引的方法来迭代对象。因为 Python 足够聪明以迭代 `Vowels` 实例，所以即使缺少 `__contains__` 方法，它也可以使
    `in` 运算符正常工作：它会进行顺序扫描以检查项目是否存在。
- en: In summary, given the importance of sequence-like data structures, Python manages
    to make iteration and the `in` operator work by invoking `__getitem__` when `__iter__`
    and `__contains__` are unavailable.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，鉴于类似序列的数据结构的重要性，Python 通过在 `__iter__` 和 `__contains__` 不可用时调用 `__getitem__`
    来使迭代和 `in` 运算符正常工作。
- en: 'The original `FrenchDeck` from [Chapter 1](ch01.html#data_model) does not subclass
    `abc.Sequence` either, but it does implement both methods of the sequence protocol:
    `__getitem__` and `__len__`. See [Example 13-2](#ex_pythonic_deck_repeat).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html#data_model)中的原始`FrenchDeck`也没有继承`abc.Sequence`，但它实现了序列协议的两种方法：`__getitem__`和`__len__`。参见[示例13-2](#ex_pythonic_deck_repeat)。'
- en: Example 13-2\. A deck as a sequence of cards (same as [Example 1-1](ch01.html#ex_pythonic_deck))
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例13-2。一叠卡片的序列（与[示例1-1](ch01.html#ex_pythonic_deck)相同）
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Several of the examples in [Chapter 1](ch01.html#data_model) work because of
    the special treatment Python gives to anything vaguely resembling a sequence.
    The iterable protocol in Python represents an extreme form of duck typing: the
    interpreter tries two different methods to iterate over objects.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html#data_model)中的几个示例之所以有效，是因为Python对任何类似序列的东西都给予了特殊处理。Python中的可迭代协议代表了鸭子类型的极端形式：解释器尝试两种不同的方法来迭代对象。'
- en: To be clear, the behaviors I described in this section are implemented in the
    interpreter itself, mostly in C. They do not depend on methods from the `Sequence`
    ABC. For example, the concrete methods `__iter__` and `__contains__` in the `Sequence`
    class emulate the built-in behaviors of the Python interpreter. If you are curious,
    check the source code of these methods in [*Lib/_collections_abc.py*](https://fpy.li/13-3).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确起见，我在本节中描述的行为是在解释器本身中实现的，主要是用C语言编写的。它们不依赖于`Sequence` ABC中的方法。例如，`Sequence`类中的具体方法`__iter__`和`__contains__`模拟了Python解释器的内置行为。如果你感兴趣，请查看[*Lib/_collections_abc.py*](https://fpy.li/13-3)中这些方法的源代码。
- en: Now let’s study another example emphasizing the dynamic nature of protocols—and
    why static type checkers have no chance of dealing with them.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们研究另一个例子，强调协议的动态性，以及为什么静态类型检查器无法处理它们。
- en: 'Monkey Patching: Implementing a Protocol at Runtime'
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Monkey Patching：在运行时实现协议
- en: Monkey patching is dynamically changing a module, class, or function at runtime,
    to add features or fix bugs. For example, the gevent networking library monkey
    patches parts of Python’s standard library to allow lightweight concurrency without
    threads or `async`/`await`.^([2](ch13.html#idm46582424482224))
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Monkey patching是在运行时动态更改模块、类或函数，以添加功能或修复错误。例如，gevent网络库对Python的标准库的部分进行了monkey
    patching，以允许轻量级并发而无需线程或`async`/`await`。^([2](ch13.html#idm46582424482224))
- en: 'The `FrenchDeck` class from [Example 13-2](#ex_pythonic_deck_repeat) is missing
    an essential feature: it cannot be shuffled. Years ago when I first wrote the
    `FrenchDeck` example, I did implement a `shuffle` method. Later I had a Pythonic
    insight: if a `FrenchDeck` acts like a sequence, then it doesn’t need its own
    `shuffle` method because there is already `random.shuffle`, [documented](https://fpy.li/13-6)
    as “Shuffle the sequence *x* in place.”'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 来自[示例13-2](#ex_pythonic_deck_repeat)的`FrenchDeck`类缺少一个重要特性：它无法被洗牌。几年前，当我第一次编写`FrenchDeck`示例时，我确实实现了一个`shuffle`方法。后来我有了一个Pythonic的想法：如果`FrenchDeck`像一个序列一样工作，那么它就不需要自己的`shuffle`方法，因为已经有了`random.shuffle`，[文档](https://fpy.li/13-6)中描述为“原地洗牌序列*x*”。
- en: 'The standard `random.shuffle` function is used like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的`random.shuffle`函数的使用方式如下：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: When you follow established protocols, you improve your chances of leveraging
    existing standard library and third-party code, thanks to duck typing.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当遵循已建立的协议时，你提高了利用现有标准库和第三方代码的机会，这要归功于鸭子类型。
- en: However, if we try to shuffle a `FrenchDeck` instance, we get an exception,
    as in [Example 13-3](#ex_unshuffable).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试对`FrenchDeck`实例进行洗牌，就会出现异常，就像[示例13-3](#ex_unshuffable)中一样。
- en: Example 13-3\. `random.shuffle` cannot handle `FrenchDeck`
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例13-3。`random.shuffle`无法处理`FrenchDeck`
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The error message is clear: `''FrenchDeck'' object does not support item assignment`.
    The problem is that `shuffle` operates *in place*, by swapping items inside the
    collection, and `FrenchDeck` only implements the *immutable* sequence protocol.
    Mutable sequences must also provide a `__setitem__` method.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息很明确：`'FrenchDeck'对象不支持项目赋值`。问题在于`shuffle`是*原地*操作，通过在集合内部交换项目，而`FrenchDeck`只实现了*不可变*序列协议。可变序列还必须提供`__setitem__`方法。
- en: Because Python is dynamic, we can fix this at runtime, even at the interactive
    console. [Example 13-4](#ex_monkey_patch) shows how to do it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Python是动态的，我们可以在运行时修复这个问题，甚至在交互式控制台中也可以。[示例13-4](#ex_monkey_patch)展示了如何做到这一点。
- en: Example 13-4\. Monkey patching `FrenchDeck` to make it mutable and compatible
    with `random.shuffle` (continuing from [Example 13-3](#ex_unshuffable))
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例13-4。Monkey patching `FrenchDeck`使其可变并与`random.shuffle`兼容（继续自[示例13-3](#ex_unshuffable)）
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO1-1)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO1-1)'
- en: Create a function that takes `deck`, `position`, and `card` as arguments.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个以`deck`, `position`, 和`card`为参数的函数。
- en: '[![2](assets/2.png)](#co_interfaces__protocols__and_abcs_CO1-2)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_interfaces__protocols__and_abcs_CO1-2)'
- en: Assign that function to an attribute named `__setitem__` in the `FrenchDeck`
    class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将该函数分配给`FrenchDeck`类中名为`__setitem__`的属性。
- en: '[![3](assets/3.png)](#co_interfaces__protocols__and_abcs_CO1-3)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_interfaces__protocols__and_abcs_CO1-3)'
- en: '`deck` can now be shuffled because I added the necessary method of the mutable
    sequence protocol.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`deck`可以被洗牌了，因为我添加了可变序列协议的必要方法。
- en: The signature of the `__setitem__` special method is defined in *The Python
    Language Reference* in [“3.3.6\. Emulating container types”](https://fpy.li/13-7).
    Here I named the arguments `deck, position, card`—and not `self, key, value` as
    in the language reference—to show that every Python method starts life as a plain
    function, and naming the first argument `self` is merely a convention. This is
    OK in a console session, but in a Python source file it’s much better to use `self`,
    `key`, and `value` as documented.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`__setitem__`特殊方法的签名在*Python语言参考*中的[“3.3.6\. 模拟容器类型”](https://fpy.li/13-7)中定义。这里我将参数命名为`deck,
    position, card`，而不是语言参考中的`self, key, value`，以显示每个Python方法都是作为普通函数开始的，将第一个参数命名为`self`只是一种约定。在控制台会话中这样做没问题，但在Python源文件中最好使用文档中记录的`self`,
    `key`, 和`value`。'
- en: 'The trick is that `set_card` knows that the `deck` object has an attribute
    named `_cards`, and `_cards` must be a mutable sequence. The `set_card` function
    is then attached to the `FrenchDeck` class as the `__setitem__` special method.
    This is an example of *monkey patching*: changing a class or module at runtime,
    without touching the source code. Monkey patching is powerful, but the code that
    does the actual patching is very tightly coupled with the program to be patched,
    often handling private and undocumented attributes.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 诀窍在于`set_card`知道`deck`对象有一个名为`_cards`的属性，而`_cards`必须是一个可变序列。然后，`set_card`函数被附加到`FrenchDeck`类作为`__setitem__`特殊方法。这是*猴子补丁*的一个例子：在运行时更改类或模块，而不触及源代码。猴子补丁很强大，但实际打补丁的代码与要打补丁的程序非常紧密耦合，通常处理私有和未记录的属性。
- en: 'Besides being an example of monkey patching, [Example 13-4](#ex_monkey_patch)
    highlights the dynamic nature of protocols in dynamic duck typing: `random.shuffle`
    doesn’t care about the class of the argument, it only needs the object to implement
    methods from the mutable sequence protocol. It doesn’t even matter if the object
    was “born” with the necessary methods or if they were somehow acquired later.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 除了是猴子补丁的一个例子，[示例 13-4](#ex_monkey_patch)突显了动态鸭子类型协议的动态性：`random.shuffle`不关心参数的类，它只需要对象实现可变序列协议的方法。甚至不用在意对象是否“出生”时就具有必要的方法，或者后来某种方式获得了这些方法。
- en: Duck typing doesn’t need to be wildly unsafe or hard to debug. The next section
    shows some useful code patterns to detect dynamic protocols without resorting
    to explicit checks.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 鸭子类型不需要非常不安全或难以调试。下一节将展示一些有用的代码模式，以检测动态协议，而不需要显式检查。
- en: Defensive Programming and “Fail Fast”
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防御性编程和“快速失败”
- en: 'Defensive programming is like defensive driving: a set of practices to enhance
    safety even when faced with careless programmers—or drivers.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 防御性编程就像防御性驾驶：一套增强安全性的实践，即使面对粗心的程序员或驾驶员。
- en: Many bugs cannot be caught except at runtime—even in mainstream statically typed
    languages.^([3](ch13.html#idm46582424129520)) In a dynamically typed language,
    “fail fast” is excellent advice for safer and easier-to-maintain programs. Failing
    fast means raising runtime errors as soon as possible, for example, rejecting
    invalid arguments right a the beginning of a function body.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 许多错误只能在运行时捕获——即使在主流的静态类型语言中也是如此。^([3](ch13.html#idm46582424129520))在动态类型语言中，“快速失败”是更安全、更易于维护的程序的极好建议。快速失败意味着尽快引发运行时错误，例如，在函数体的开头立即拒绝无效参数。
- en: 'Here is one example: when you write code that accepts a sequence of items to
    process internally as a `list`, don’t enforce a `list` argument by type checking.
    Instead, take the argument and immediately build a `list` from it. One example
    of this code pattern is the `__init__` method in [Example 13-10](#ex_lotto), later
    in this chapter:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有���个例子：当你编写接受要在内部处理的项目序列的代码时，不要通过类型检查强制要求一个`list`参数。相反，接受参数并立即从中构建一个`list`。这种代码模式的一个例子是本章后面的[示例
    13-10](#ex_lotto)中的`__init__`方法：
- en: '[PRE5]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That way you make your code more flexible, because the `list()` constructor
    handles any iterable that fits in memory. If the argument is not iterable, the
    call will fail fast with a very clear `TypeError` exception, right when the object
    is initialized. If you want to be more explict, you can wrap the `list()` call
    with `try/except` to customize the error message—but I’d use that extra code only
    on an external API, because the problem would be easy to see for maintainers of
    the codebase. Either way, the offending call will appear near the end of the traceback,
    making it straightforward to fix. If you don’t catch the invalid argument in the
    class constructor, the program will blow up later, when some other method of the
    class needs to operate on `self._balls` and it is not a `list`. Then the root
    cause will be harder to find.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以使你的代码更灵活，因为`list()`构造函数处理任何适合内存的可迭代对象。如果参数不可迭代，调用将立即失败，并显示一个非常清晰的`TypeError`异常，就在对象初始化时。如果想更明确，可以用`try/except`包装`list()`调用以自定义错误消息——但我只会在外部API上使用这些额外的代码，因为问题对于代码库的维护者来说很容易看到。无论哪种方式，有问题的调用将出现在回溯的最后，使得修复问题变得直截了当。如果在类构造函数中没有捕获无效参数，程序将在稍后的某个时刻崩溃，当类的其他方法需要操作`self._balls`时，而它不是一个`list`。那么根本原因将更难找到。
- en: Of course, calling `list()` on the argument would be bad if the data shouldn’t
    be copied, either because it’s too large or because the function, by design, needs
    to change it in place for the benefit of the caller, like `random.shuffle` does.
    In that case, a runtime check like `isinstance(x, abc.MutableSequence)` would
    be the way to go.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据不应该被复制时，例如因为数据太大或者函数设计需要在原地更改数据以使调用者受益时，调用`list()`会很糟糕。在这种情况下，像`isinstance(x,
    abc.MutableSequence)`这样的运行时检查将是一个好方法。
- en: If you are afraid to get an infinite generator—not a common issue—you can begin
    by calling `len()` on the argument. This would reject iterators, while safely
    dealing with tuples, arrays, and other existing or future classes that fully implement
    the `Sequence` interface. Calling `len()` is usually very cheap, and an invalid
    argument will raise an error immediately.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你担心得到一个无限生成器——这不是一个常见问题——你可以先调用`len()`来检查参数。这将拒绝迭代器，同时安全地处理元组、数组和其他现有或将来完全实现`Sequence`接口的类。调用`len()`通常非常便宜，而无效的参数将立即引发错误。
- en: 'On the other hand, if any iterable is acceptable, then call `iter(x)` as soon
    as possible to obtain an iterator, as we’ll see in [“Why Sequences Are Iterable:
    The iter Function”](ch17.html#iter_func_sec). Again, if `x` is not iterable, this
    will fail fast with an easy-to-debug exception.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果任何可迭代对象都可以接受，那么尽快调用`iter(x)`以获得一个迭代器，正如我们将在[“为什么序列可迭代：iter函数”](ch17.html#iter_func_sec)中看到的。同样，如果`x`不可迭代，这将快速失败，并显示一个易于调试的异常。
- en: In the cases I just described, a type hint could catch some problems earlier,
    but not all problems. Recall that the type `Any` is *consistent-with* every other
    type. Type inference may cause a variable to be tagged with the `Any` type. When
    that happens, the type checker is in the dark. In addition, type hints are not
    enforced at runtime. Fail fast is the last line of defense.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我刚刚描述的情况下，类型提示可以更早地捕捉一些问题，但并非所有问题。请记住，类型`Any`与其他任何类型都是*一致的*。类型推断可能导致变量被标记为`Any`类型。当发生这种情况时，类型检查器就会一头雾水。此外，类型提示在运行时不会被强制执行。快速失败是最后的防线。
- en: Defensive code leveraging duck types can also include logic to handle different
    types without using `isinstance()` or `hasattr()` tests.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 利用鸭子类型的防御性代码也可以包含处理不同类型的逻辑，而无需使用`isinstance()`或`hasattr()`测试。
- en: 'One example is how we might emulate the handling of the `field_names` argument
    in [`collections.namedtuple`](https://fpy.li/13-8): `field_names` accepts a single
    string with identifiers separated by spaces or commas, or a sequence of identifiers.
    [Example 13-5](#ex_duck_typing_str_list) shows how I’d do it using duck typing.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是我们如何模拟[`collections.namedtuple`](https://fpy.li/13-8)中的`field_names`参数处理：`field_names`接受一个由空格或逗号分隔的标识符组成的单个字符串，或者一组标识符。[示例 13-5](#ex_duck_typing_str_list)展示了我如何使用鸭子类型来实现它。
- en: Example 13-5\. Duck typing to handle a string or an iterable of strings
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-5\. 鸭子类型处理字符串或字符串可迭代对象
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO2-1)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO2-1)'
- en: Assume it’s a string (EAFP = it’s easier to ask forgiveness than permission).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 假设它是一个字符串（EAFP = 宁愿请求原谅，也不要事先获准）。
- en: '[![2](assets/2.png)](#co_interfaces__protocols__and_abcs_CO2-2)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_interfaces__protocols__and_abcs_CO2-2)'
- en: Convert commas to spaces and split the result into a list of names.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将逗号转换为空格并将结果拆分为��称列表。
- en: '[![3](assets/3.png)](#co_interfaces__protocols__and_abcs_CO2-3)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_interfaces__protocols__and_abcs_CO2-3)'
- en: 'Sorry, `field_names` doesn’t quack like a `str`: it has no `.replace`, or it
    returns something we can’t `.split`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 抱歉，`field_names`不像一个`str`那样嘎嘎叫：它没有`.replace`，或者返回我们无法`.split`的东西。
- en: '[![4](assets/4.png)](#co_interfaces__protocols__and_abcs_CO2-4)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_interfaces__protocols__and_abcs_CO2-4)'
- en: If `AttributeError` was raised, then `field_names` is not a `str` and we assume
    it was already an iterable of names.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果引发了`AttributeError`，那么`field_names`不是一个`str`，我们假设它已经是一个名称的可迭代对象。
- en: '[![5](assets/5.png)](#co_interfaces__protocols__and_abcs_CO2-5)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_interfaces__protocols__and_abcs_CO2-5)'
- en: To make sure it’s an iterable and to keep our own copy, create a tuple out of
    what we have. A `tuple` is more compact than `list`, and it also prevents my code
    from changing the names by mistake.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保它是可迭代的并保留我们自己的副本，将我们拥有的内容创建为一个元组。`tuple`比`list`更紧凑，还可以防止我的代码误改名称。
- en: '[![6](assets/6.png)](#co_interfaces__protocols__and_abcs_CO2-6)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_interfaces__protocols__and_abcs_CO2-6)'
- en: Use `str.isidentifier` to ensure every name is valid.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`str.isidentifier`来确保每个名称都是有效的。
- en: '[Example 13-5](#ex_duck_typing_str_list) shows one situation where duck typing
    is more expressive than static type hints. There is no way to spell a type hint
    that says “`field_names` must be a string of identifiers separated by spaces or
    commas.” This is the relevant part of the `namedtuple` signature on typeshed (see
    the full source at [*stdlib/3/collections/__init__.pyi*](https://fpy.li/13-9)):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13-5](#ex_duck_typing_str_list)展示了一种情况，鸭子类型比静态类型提示更具表现力。没有办法拼写一个类型提示，说“`field_names`必须是由空格或逗号分隔的标识符字符串”。这是`namedtuple`在typeshed上的签名的相关部分（请查看[*stdlib/3/collections/__init__.pyi*](https://fpy.li/13-9)的完整源代码）：'
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, `field_names` is annotated as `Union[str, Iterable[str]]`, which
    is OK as far as it goes, but is not enough to catch all possible problems.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`field_names`被注释为`Union[str, Iterable[str]]`，就目前而言是可以的，但不足以捕捉所有可能的问题。
- en: 'After reviewing dynamic protocols, we move to a more explicit form of runtime
    type checking: goose typing.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查动态协议后，我们转向更明确的运行时类型检查形式：鹅式类型检查。
- en: Goose Typing
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鹅式类型检查
- en: An abstract class represents an interface.
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 抽象类代表一个接口。
- en: ''
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Bjarne Stroustrup, creator of C++^([4](ch13.html#idm46582424233376))
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: C++的创始人Bjarne Stroustrup^([4](ch13.html#idm46582424233376))
- en: Python doesn’t have an `interface` keyword. We use abstract base classes (ABCs)
    to define interfaces for explicit type checking at runtime—also supported by static
    type checkers.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Python没有`interface`关键字。我们使用抽象基类（ABCs）来定义接口，以便在运行时进行显式类型检查，同时也受到静态类型检查器的支持。
- en: 'The *Python Glossary* entry for [abstract base class](https://fpy.li/13-10)
    has a good explanation of the value they bring to duck-typed languages:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python术语表*中关于[抽象基类](https://fpy.li/13-10)的条目对它们为鸭子类型语言带来的价值有很好的解释：'
- en: Abstract base classes complement duck typing by providing a way to define interfaces
    when other techniques like `hasattr()` would be clumsy or subtly wrong (for example,
    with magic methods). ABCs introduce virtual subclasses, which are classes that
    don’t inherit from a class but are still recognized by `isinstance()` and `issubclass()`;
    see the `abc` module documentation.^([5](ch13.html#idm46582424062480))
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 抽象基类通过提供一种定义接口的方式来补充鸭子类型，当其他技术（如`hasattr()`）显得笨拙或微妙错误时（例如，使用魔术方法）。ABCs引入虚拟子类，这些子类不继承自一个类，但仍然被`isinstance()`和`issubclass()`所识别；请参阅`abc`模块文档。^([5](ch13.html#idm46582424062480))
- en: Goose typing is a runtime type checking approach that leverages ABCs. I will
    let Alex Martelli explain in [“Waterfowl and ABCs”](#waterfowl_essay).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 鹅式类型检查是一种利用ABCs的运行时类型检查方法。我将让Alex Martelli在[“水禽和ABCs”](#waterfowl_essay)中解释。
- en: Note
  id: totrans-135
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: I am very grateful to my friends Alex Martelli and Anna Ravenscroft. I showed
    them the first outline of *Fluent Python* at OSCON 2013, and they encouraged me
    to submit it for publication with O’Reilly. Both later contributed with thorough
    tech reviews. Alex was already the most cited person in this book, and then he
    offered to write this essay. Take it away, Alex!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常感谢我的朋友Alex Martelli和Anna Ravenscroft。我在2013年的OSCON上向他们展示了*Fluent Python*的第一个大纲，他们鼓励我将其提交给O’Reilly出版。两人后来进行了彻底的技术审查。Alex已经是本书中被引用最多的人，然后他提出要写这篇文章。请开始，Alex！
- en: 'To summarize, *goose typing* entails:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，*鹅打字*包括：
- en: Subclassing from ABCs to make it explict that you are implementing a previously
    defined interface.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从ABC继承以明确表明你正在实现先前定义的接口。
- en: Runtime type checking using ABCs instead of concrete classes as the second argument
    for `isinstance` and `issubclass`.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时使用ABC而不是具体类作为`isinstance`和`issubclass`的第二个参数进行类型检查。
- en: 'Alex makes the point that inheriting from an ABC is more than implementing
    the required methods: it’s also a clear declaration of intent by the developer.
    That intent can also be made explicit through registering a virtual subclass.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Alex指出，从ABC继承不仅仅是实现所需的方法：开发人员的意图也是明确声明的。这种意图也可以通过注册虚拟子类来明确表示。
- en: Note
  id: totrans-141
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Details of using `register` are covered in [“A Virtual Subclass of an ABC”](#virtual_subclass_sec),
    later in this chapter. For now, here is a brief example: given the `FrenchDeck`
    class, if I want it to pass a check like `issubclass(FrenchDeck, Sequence)`, I
    can make it a *virtual subclass* of the `Sequence` ABC with these lines:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`register`的详细信息在[“ABC的虚拟子类”](#virtual_subclass_sec)中有介绍，本章后面会详细介绍。现在，这里是一个简短的示例：给定`FrenchDeck`类，如果我希望它通过类似`issubclass(FrenchDeck,
    Sequence)`的检查，我可以通过以下代码将其作为`Sequence` ABC的*虚拟子类*：
- en: '[PRE8]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The use of `isinstance` and `issubclass` becomes more acceptable if you are
    checking against ABCs instead of concrete classes. If used with concrete classes,
    type checks limit polymorphism—an essential feature of object-oriented programming.
    But with ABCs these tests are more flexible. After all, if a component does not
    implement an ABC by subclassing—but does implement the required methods—it can
    always be registered after the fact so it passes those explicit type checks.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查ABC而不是具体类，那么使用`isinstance`和`issubclass`会更加可接受。如果与具体类一起使用，类型检查会限制多态性——这是面向对象编程的一个重要特征。但是对于ABCs，这些测试更加灵活。毕竟，如果一个组件没有通过子类化实现ABC，但确实实现了所需的方法，那么它总是可以在事后注册，以便通过这些显式类型检查。
- en: However, even with ABCs, you should beware that excessive use of `isinstance`
    checks may be a *code smell*—a symptom of bad OO design.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使使用ABCs，你也应该注意，过度使用`isinstance`检查可能是*代码异味*的表现——这是OO设计不佳的症状。
- en: 'It’s usually *not* OK to have a chain of `if/elif/elif` with `isinstance` checks
    performing different actions depending on the type of object: you should be using
    polymorphism for that—i.e., design your classes so that the interpreter dispatches
    calls to the proper methods, instead of you hardcoding the dispatch logic in `if/elif/elif`
    blocks.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，使用`isinstance`检查的`if/elif/elif`链执行不同操作取决于对象类型通常是*不*可以的：你应该使用多态性来实现这一点——即，设计你的类使解释器分派调用到正确的方法，而不是在`if/elif/elif`块中硬编码分派逻辑。
- en: 'On the other hand, it’s OK to perform an `isinstance` check against an ABC
    if you must enforce an API contract: “Dude, you have to implement this if you
    want to call me,” as technical reviewer Lennart Regebro put it. That’s particularly
    useful in systems that have a plug-in architecture. Outside of frameworks, duck
    typing is often simpler and more flexible than type checks.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果必须强制执行API契约，则对ABC执行`isinstance`检查是可以的：“伙计，如果你想调用我，你必须实现这个”，正如技术审查员Lennart
    Regebro所说。这在具有插件架构的系统中特别有用。在框架之外，鸭子类型通常比类型检查更简单、更灵活。
- en: 'Finally, in his essay, Alex reinforces more than once the need for restraint
    in the creation of ABCs. Excessive use of ABCs would impose ceremony in a language
    that became popular because it is practical and pragmatic. During the *Fluent
    Python* review process, Alex wrote in an e-mail:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在他的文章中，Alex多次强调了在创建ABCs时需要克制的必要性。过度使用ABCs会在一门因其实用性和实用性而流行的语言中引入仪式感。在*流畅的Python*审查过程中，Alex在一封电子邮件中写道：
- en: ABCs are meant to encapsulate very general concepts, abstractions, introduced
    by a framework—things like “a sequence” and “an exact number.” [Readers] most
    likely don’t need to write any new ABCs, just use existing ones correctly, to
    get 99.9% of the benefits without serious risk of misdesign.
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ABCs旨在封装由框架引入的非常一般的概念、抽象概念——诸如“一个序列”和“一个确切的数字”。[读者]很可能不需要编写任何新的ABCs，只需正确使用现有的ABCs，就可以获得99.9%的好处，而不会严重风险设计错误。
- en: Now let’s see goose typing in practice.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看鹅打字的实践。
- en: Subclassing an ABC
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从ABC继承
- en: Following Martelli’s advice, we’ll leverage an existing ABC, `collections.MutableSequence`,
    before daring to invent our own. In [Example 13-6](#ex_pythonic_deck2), `FrenchDeck2`
    is explicitly declared a subclass of `collections.MutableSequence`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循Martelli的建议，在大胆发明自己之前，我们将利用现有的ABC，`collections.MutableSequence`。在[示例13-6](#ex_pythonic_deck2)中，`FrenchDeck2`明确声明为`collections.MutableSequence`的子类。
- en: 'Example 13-6\. frenchdeck2.py: `FrenchDeck2`, a subclass of `collections.MutableSequence`'
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例13-6\. frenchdeck2.py：`FrenchDeck2`，`collections.MutableSequence`的子类
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO3-1)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO3-1)'
- en: '`__setitem__` is all we need to enable shuffling…'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`__setitem__`是我们启用洗牌所需的全部…'
- en: '[![2](assets/2.png)](#co_interfaces__protocols__and_abcs_CO3-2)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_interfaces__protocols__and_abcs_CO3-2)'
- en: …but subclassing `MutableSequence` forces us to implement `__delitem__`, an
    abstract method of that ABC.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: …但是从`MutableSequence`继承会强制我们实现`__delitem__`，该ABC的一个抽象方法。
- en: '[![3](assets/3.png)](#co_interfaces__protocols__and_abcs_CO3-3)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_interfaces__protocols__and_abcs_CO3-3)'
- en: We are also required to implement `insert`, the third abstract method of `MutableSequence`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要实现`insert`，`MutableSequence`的第三个抽象方法。
- en: 'Python does not check for the implementation of the abstract methods at import
    time (when the *frenchdeck2.py* module is loaded and compiled), but only at runtime
    when we actually try to instantiate `FrenchDeck2`. Then, if we fail to implement
    any of the abstract methods, we get a `TypeError` exception with a message such
    as `"Can''t instantiate`` abstract class FrenchDeck2 with abstract methods __delitem__,
    insert"`. That’s why we must implement `__delitem__` and `insert`, even if our
    `FrenchDeck2` examples do not need those behaviors: the `MutableSequence` ABC
    demands them.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在导入时不会检查抽象方法的实现（当加载和编译 *frenchdeck2.py* 模块时），而是在运行时当我们尝试实例化 `FrenchDeck2`
    时才会检查。然后，如果我们未实现任何抽象方法，我们将收到一个 `TypeError` 异常，其中包含类似于 `"Can't instantiate`` abstract
    class FrenchDeck2 with abstract methods __delitem__, insert"` 的消息。这就是为什么我们必须实现
    `__delitem__` 和 `insert`，即使我们的 `FrenchDeck2` 示例不需要这些行为：因为 `MutableSequence` ABC
    要求它们。
- en: As [Figure 13-3](#mutablesequence_uml) shows, not all methods of the `Sequence`
    and `MutableSequence` ABCs are abstract.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 13-3](#mutablesequence_uml) 所示，`Sequence` 和 `MutableSequence` ABCs 中并非所有方法都是抽象的。
- en: '![UML class diagram for `Sequence` and `MutableSequence`](assets/flpy_1303.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![`Sequence` 和 `MutableSequence` 的 UML 类图](assets/flpy_1303.png)'
- en: Figure 13-3\. UML class diagram for the `MutableSequence` ABC and its superclasses
    from `collections.abc` (inheritance arrows point from subclasses to ancestors;
    names in italic are abstract classes and abstract methods).
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 13-3\. `MutableSequence` ABC 及其来自 `collections.abc` 的超类的 UML 类图（继承箭头从子类指向祖先类；斜体名称是抽象类和抽象方法）。
- en: 'To write `FrenchDeck2` as a subclass of `MutableSequence`, I had to pay the
    price of implementing `__delitem__` and `insert`, which my examples did not require.
    In return, `FrenchDeck2` inherits five concrete methods from `Sequence`: `__contains__`,
    `__iter__`, `__reversed__`, `index`, and `count`. From `MutableSequence`, it gets
    another six methods: `append`, `reverse`, `extend`, `pop`, `remove`, and `__iadd__`—which
    supports the `+=` operator for in place concatenation.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `FrenchDeck2` 写为 `MutableSequence` 的子类，我必须付出实现 `__delitem__` 和 `insert` 的代价，而我的示例并不需要这些。作为回报，`FrenchDeck2`
    从 `Sequence` 继承了五个具体方法：`__contains__`, `__iter__`, `__reversed__`, `index`, 和
    `count`。从 `MutableSequence` 中，它还获得了另外六个方法：`append`, `reverse`, `extend`, `pop`,
    `remove`, 和 `__iadd__`—它支持用于原地连接的 `+=` 运算符。
- en: The concrete methods in each `collections.abc` ABC are implemented in terms
    of the public interface of the class, so they work without any knowledge of the
    internal structure of instances.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `collections.abc` ABC 中的具体方法都是根据类的公共接口实现的，因此它们可以在不了解实例内部结构的情况下工作。
- en: Tip
  id: totrans-167
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: As the coder of a concrete subclass, you may be able to override methods inherited
    from ABCs with more efficient implementations. For example, `__contains__` works
    by doing a sequential scan of the sequence, but if your concrete sequence keeps
    its items sorted, you can write a faster `__contains__` that does a binary search
    using the [`bisect`](https://fpy.li/13-13) function from the standard library.
    See [“Managing Ordered Sequences with Bisect”](https://fpy.li/bisect) at [*fluentpython.com*](
    http://fluentpython.com) to learn more about it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 作为具体子类的编码者，您可能能够用更高效的实现覆盖从 ABCs 继承的方法。例如，`__contains__` 通过对序列进行顺序扫描来工作，但如果您的具体序列保持其项目排序，您可以编写一个更快的
    `__contains__`，它使用标准库中的 [`bisect`](https://fpy.li/13-13) 函数进行二分搜索。请查看 [*fluentpython.com*](
    http://fluentpython.com) 上的 [“使用 Bisect 管理有序序列”](https://fpy.li/bisect) 了解更多信息。
- en: To use ABCs well, you need to know what’s available. We’ll review the `collections`
    ABCs next.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要很好地使用 ABCs，您需要了解可用的内容。接下来我们将回顾 `collections` 中的 ABCs。
- en: ABCs in the Standard Library
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准库中的 ABCs
- en: Since Python 2.6, the standard library provides several ABCs. Most are defined
    in the `collections.abc` module, but there are others. You can find ABCs in the
    `io` and `numbers` packages, for example. But the most widely used are in `collections.abc`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Python 2.6 起，标准库提供了几个 ABCs。大多数在 `collections.abc` 模块中定义，但也有其他的。例如，您可以在 `io`
    和 `numbers` 包中找到 ABCs。但最常用的在 `collections.abc` 中。
- en: Tip
  id: totrans-172
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: There are two modules named `abc` in the standard library. Here we are talking
    about `collections.abc`. To reduce loading time, since Python 3.4 that module
    is implemented outside of the `collections` package—in [*Lib/_collections_abc.py*](https://fpy.li/13-14)—so
    it’s imported separately from `collections`. The other `abc` module is just `abc`
    (i.e., [*Lib/abc.py*](https://fpy.li/13-15)) where the `abc.ABC` class is defined.
    Every ABC depends on the `abc` module, but we don’t need to import it ourselves
    except to create a brand-new ABC.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中有两个名为 `abc` 的模块。这里我们谈论的是 `collections.abc`。为了减少加载时间，自 Python 3.4 起，该模块是在
    `collections` 包之外实现的—在 [*Lib/_collections_abc.py*](https://fpy.li/13-14)—因此它是单独从
    `collections` 导入的。另一个 `abc` 模块只是 `abc`（即 [*Lib/abc.py*](https://fpy.li/13-15)），其中定义了
    `abc.ABC` 类。每个 ABC 都依赖于 `abc` 模块，但我们不需要自己导入它，除非要创建全新的 ABC。
- en: '[Figure 13-4](#collections_uml) is a summary UML class diagram (without attribute
    names) of 17 ABCs defined in `collections.abc`. The documentation of `collections.abc`
    has [a nice table](https://fpy.li/13-16) summarizing the ABCs, their relationships,
    and their abstract and concrete methods (called “mixin methods”). There is plenty
    of multiple inheritance going on in [Figure 13-4](#collections_uml). We’ll devote
    most of [Chapter 14](ch14.html#inheritance) to multiple inheritance, but for now
    it’s enough to say that it is usually not a problem when ABCs are concerned.^([7](ch13.html#idm46582425220368))'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-4](#collections_uml) 是在 `collections.abc` 中定义的 17 个 ABCs 的摘要 UML 类图（不包括属性名称）。`collections.abc`
    的文档中有一个很好的表格总结了这些 ABCs，它们之间的关系以及它们的抽象和具体方法（称为“mixin 方法”）。在 [图 13-4](#collections_uml)
    中有大量的多重继承。我们将在 [第 14 章](ch14.html#inheritance) 中专门讨论多重继承，但现在只需说当涉及到 ABCs 时，通常不是问题。^([7](ch13.html#idm46582425220368))'
- en: '![UML for collections.abc](assets/flpy_1304.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![collections.abc 的 UML](assets/flpy_1304.png)'
- en: Figure 13-4\. UML class diagram for ABCs in `collections.abc`.
  id: totrans-176
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 13-4\. `collections.abc` 中 ABCs 的 UML 类图。
- en: 'Let’s review the clusters in [Figure 13-4](#collections_uml):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下 [图 13-4](#collections_uml) 中的聚类：
- en: '`Iterable`, `Container`, `Sized`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterable`, `Container`, `Sized`'
- en: Every collection should either inherit from these ABCs or implement compatible
    protocols. `Iterable` supports iteration with `__iter__`, `Container` supports
    the `in` operator with `__contains__`, and `Sized` supports `len()` with `__len__`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 每个集合应该继承这些 ABC 或实现兼容的协议。`Iterable` 支持 `__iter__` 迭代，`Container` 支持 `__contains__`
    中的 `in` 运算符，`Sized` 支持 `__len__` 中的 `len()`。
- en: '`Collection`'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collection`'
- en: This ABC has no methods of its own, but was added in Python 3.6 to make it easier
    to subclass from `Iterable`, `Container`, and `Sized`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 ABC 没有自己的方法，但在 Python 3.6 中添加了它，以便更容易从 `Iterable`、`Container` 和 `Sized` 继承。
- en: '`Sequence`, `Mapping`, `Set`'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sequence`、`Mapping`、`Set`'
- en: These are the main immutable collection types, and each has a mutable subclass.
    A detailed diagram for `MutableSequence` is in [Figure 13-3](#mutablesequence_uml);
    for `MutableMapping` and `MutableSet`, see Figures [3-1](ch03.html#mapping_uml)
    and [3-2](ch03.html#set_uml) in [Chapter 3](ch03.html#dicts-a-to-z).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是主要的不可变集合类型，每种类型都有一个可变的子类。`MutableSequence` 的详细图表在 [图13-3](#mutablesequence_uml)
    中；对于 `MutableMapping` 和 `MutableSet`，请参见 [第3章](ch03.html#dicts-a-to-z) 中的图 [3-1](ch03.html#mapping_uml)
    和 [3-2](ch03.html#set_uml)。
- en: '`MappingView`'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`MappingView`'
- en: In Python 3, the objects returned from the mapping methods `.items()`, `.keys()`,
    and `.values()` implement the interfaces defined in `ItemsView`, `KeysView`, and
    `ValuesView`, respectively. The first two also implement the rich interface of
    `Set`, with all the operators we saw in [“Set Operations”](ch03.html#set_op_section).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3 中，从映射方法 `.items()`、`.keys()` 和 `.values()` 返回的对象分别实现了 `ItemsView`、`KeysView`
    和 `ValuesView` 中定义的接口。前两者还实现了 `Set` 的丰富接口，其中包含我们在 [“集合操作”](ch03.html#set_op_section)
    中看到的所有运算符。
- en: '`Iterator`'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterator`'
- en: Note that iterator subclasses `Iterable`. We discuss this further in [Chapter 17](ch17.html#iterables2generators).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，迭代器子类 `Iterable`。我们在 [第17章](ch17.html#iterables2generators) 中进一步讨论这一点。
- en: '`Callable`, `Hashable`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`Callable`、`Hashable`'
- en: These are not collections, but `collections.abc` was the first package to define
    ABCs in the standard library, and these two were deemed important enough to be
    included. They support type checking objects that must be callable or hashable.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这些不是集合，但 `collections.abc` 是第一个在标准库中定义 ABC 的包，这两个被认为是足够重要以被包含在内。它们支持对必须是可调用或可哈希的对象进行类型检查。
- en: For callable detection, the `callable(obj)` built-in function is more convenient
    than `insinstance(obj, Callable)`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可调用检测，内置函数 `callable(obj)` 比 `insinstance(obj, Callable)` 更方便。
- en: If `insinstance(obj, Hashable)` returns `False`, you can be certain that `obj`
    is not hashable. But if the return is `True`, it may be a false positive. The
    next box explains.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `insinstance(obj, Hashable)` 返回 `False`，则可以确定 `obj` 不可哈希。但如果返回值为 `True`，可能是一个误报。下一个框解释了这一点。
- en: After looking at some existing ABCs, let’s practice goose typing by implementing
    an ABC from scratch and putting it to use. The goal here is not to encourage everyone
    to start creating ABCs left and right, but to learn how to read the source code
    of the ABCs you’ll find in the standard library and other packages.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看一些现有的 ABC 后，让我们通过从头开始实现一个 ABC 并将其投入使用来练习鹅子打字。这里的目标不是鼓励每个人开始左右创建 ABC，而是学习如何阅读标准库和其他包中找到的
    ABC 的源代码。
- en: Defining and Using an ABC
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和使用 ABC
- en: 'This warning appeared in the “Interfaces” chapter of the first edition of *Fluent
    Python*:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个警告出现在第一版 *Fluent Python* 的“接口”章节中：
- en: ABCs, like descriptors and metaclasses, are tools for building frameworks. Therefore,
    only a small minority of Python developers can create ABCs without imposing unreasonable
    limitations and needless work on fellow programmers.
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ABC，就像描述符和元类一样，是构建框架的工具。因此，只有少数 Python 开发人员可以创建 ABC，而不会对其他程序员施加不合理的限制和不必要的工作。
- en: Now ABCs have more potential use cases in type hints to support static typing.
    As discussed in [“Abstract Base Classes”](ch08.html#type_hint_abc_sec), using
    ABCs instead of concrete types in function argument type hints gives more flexibility
    to the caller.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 ABC 在类型提示中有更多潜在用途，以支持静态类型。如 [“抽象基类”](ch08.html#type_hint_abc_sec) 中所讨论的，使用
    ABC 而不是具体类型在函数参数类型提示中给调用者更多的灵活性。
- en: 'To justify creating an ABC, we need to come up with a context for using it
    as an extension point in a framework. So here is our context: imagine you need
    to display advertisements on a website or a mobile app in random order, but without
    repeating an ad before the full inventory of ads is shown. Now let’s assume we
    are building an ad management framework called `ADAM`. One of its requirements
    is to support user-provided nonrepeating random-picking classes.^([8](ch13.html#idm46582423844320))
    To make it clear to `ADAM` users what is expected of a “nonrepeating random-picking”
    component, we’ll define an ABC.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明创建一个 ABC 的合理性，我们需要为在框架中使用它作为扩展点提供一个上下文。因此，这是我们的背景：想象一下你需要在网站或移动应用程序上以随机顺序显示广告，但在显示完整广告库之前不重复显示广告。现在让我们假设我们正在构建一个名为
    `ADAM` 的广告管理框架。其要求之一是支持用户提供的非重复随机选择类。^([8](ch13.html#idm46582423844320)) 为了让 `ADAM`
    用户清楚地知道“非重复随机选择”组件的期望，我们将定义一个 ABC。
- en: 'In the literature about data structures, “stack” and “queue” describe abstract
    interfaces in terms of physical arrangements of objects. I will follow suit and
    use a real-world metaphor to name our ABC: bingo cages and lottery blowers are
    machines designed to pick items at random from a finite set, without repeating,
    until the set is exhausted.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于数据结构的文献中，“栈”和“队列”描述了抽象接口，以物理对象的实际排列为基础。我将效仿并使用一个现实世界的隐喻来命名我们的 ABC：宾果笼和彩票吹风机是设计用来从有限集合中随机挑选项目，直到集合耗尽而不重��的机器。
- en: The ABC will be named `Tombola`, after the Italian name of bingo and the tumbling
    container that mixes the numbers.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ABC 将被命名为 `Tombola`，以宾果的意大利名称和混合数字的翻转容器命名。
- en: 'The `Tombola` ABC has four methods. The two abstract methods are:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tombola` ABC 有四个方法。两个抽象方法是：'
- en: '`.load(…)`'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`.load(…)`'
- en: Put items into the container.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 将项目放入容器中。
- en: '`.pick()`'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`.pick()`'
- en: Remove one item at random from the container, returning it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 从容器中随机移除一个项目，并返回它。
- en: 'The concrete methods are:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 具体方法是：
- en: '`.loaded()`'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`.loaded()`'
- en: Return `True` if there is at least one item in the container.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器中至少有一个项目，则返回`True`。
- en: '`.inspect()`'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`.inspect()`'
- en: Return a `tuple` built from the items currently in the container, without changing
    its contents (the internal ordering is not preserved).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个从容器中当前项目构建的`tuple`，而不更改其内容（内部排序不保留）。
- en: '[Figure 13-5](#tombola_uml) shows the `Tombola` ABC and three concrete implementations.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 13-5](#tombola_uml)展示了`Tombola` ABC和三个具体实现。'
- en: '![UML for Tombola](assets/flpy_1305.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![Tombola 的 UML](assets/flpy_1305.png)'
- en: Figure 13-5\. UML diagram for an ABC and three subclasses. The name of the `Tombola`
    ABC and its abstract methods are written in *italics*, per UML conventions. The
    dashed arrow is used for interface implementation—here I am using it to show that
    `TomboList` not only implements the `Tombola` interface, but is also registered
    as *virtual subclass* of `Tombola`—as we will see later in this chapter.^([9](ch13.html#idm46582423825920))
  id: totrans-212
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 13-5\. ABC和三个子类的UML图。`Tombola` ABC的名称和其抽象方法以*斜体*书写，符合UML约定。虚线箭头用于接口实现——这里我用它来显示`TomboList`不仅实现了`Tombola`接口，而且还注册为`Tombola`的*虚拟子类*—正如我们将在本章后面看到的。^([9](ch13.html#idm46582423825920))
- en: '[Example 13-7](#ex_tombola_abc) shows the definition of the `Tombola` ABC.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13-7](#ex_tombola_abc)展示了`Tombola` ABC的定义。'
- en: 'Example 13-7\. tombola.py: `Tombola` is an ABC with two abstract methods and
    two concrete methods'
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-7\. tombola.py：`Tombola`是一个具有两个抽象方法和两个具体方法的ABC
- en: '[PRE10]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO4-1)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO4-1)'
- en: To define an ABC, subclass `abc.ABC`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个ABC，需要继承`abc.ABC`。
- en: '[![2](assets/2.png)](#co_interfaces__protocols__and_abcs_CO4-2)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_interfaces__protocols__and_abcs_CO4-2)'
- en: An abstract method is marked with the `@abstractmethod` decorator, and often
    its body is empty except for a docstring.^([10](ch13.html#idm46582425152848))
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象方法使用`@abstractmethod`装饰器标记，通常其主体除了文档字符串外是空的。^([10](ch13.html#idm46582425152848))
- en: '[![3](assets/3.png)](#co_interfaces__protocols__and_abcs_CO4-3)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_interfaces__protocols__and_abcs_CO4-3)'
- en: The docstring instructs implementers to raise `LookupError` if there are no
    items to pick.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串指示实现者在没有项目可挑选时引发`LookupError`。
- en: '[![4](assets/4.png)](#co_interfaces__protocols__and_abcs_CO4-4)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_interfaces__protocols__and_abcs_CO4-4)'
- en: An ABC may include concrete methods.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一个ABC可以包含具体方法。
- en: '[![5](assets/5.png)](#co_interfaces__protocols__and_abcs_CO4-5)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_interfaces__protocols__and_abcs_CO4-5)'
- en: Concrete methods in an ABC must rely only on the interface defined by the ABC
    (i.e., other concrete or abstract methods or properties of the ABC).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ABC中的具体方法必须仅依赖于ABC定义的接口（即ABC的其他具体或抽象方法或属性）。
- en: '[![6](assets/6.png)](#co_interfaces__protocols__and_abcs_CO4-6)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_interfaces__protocols__and_abcs_CO4-6)'
- en: We can’t know how concrete subclasses will store the items, but we can build
    the `inspect` result by emptying the `Tombola` with successive calls to `.pick()`…
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法知道具体子类将如何存储项目，但我们可以通过连续调用`.pick()`来构建`inspect`结果来清空`Tombola`…
- en: '[![7](assets/7.png)](#co_interfaces__protocols__and_abcs_CO4-7)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_interfaces__protocols__and_abcs_CO4-7)'
- en: …then use `.load(…)` to put everything back.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: …然后使用`.load(…)`将所有东西放回去。
- en: Tip
  id: totrans-230
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: An abstract method can actually have an implementation. Even if it does, subclasses
    will still be forced to override it, but they will be able to invoke the abstract
    method with `super()`, adding functionality to it instead of implementing from
    scratch. See the [`abc` module documentation](https://fpy.li/13-18) for details
    on `@abstractmethod` usage.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象方法实际上可以有一个实现。即使有，子类仍将被强制重写它，但他们可以使用`super()`调用抽象方法，为其添加功能而不是从头开始实现。有关`@abstractmethod`用法的详细信息，请参阅[`abc`模块文档](https://fpy.li/13-18)。
- en: The code for the `.inspect()` method in [Example 13-7](#ex_tombola_abc) is silly,
    but it shows that we can rely on `.pick()` and `.load(…)` to inspect what’s inside
    the `Tombola` by picking all items and loading them back—without knowing how the
    items are actually stored. The point of this example is to highlight that it’s
    OK to provide concrete methods in ABCs, as long as they only depend on other methods
    in the interface. Being aware of their internal data structures, concrete subclasses
    of `Tombola` may always override `.inspect()` with a smarter implementation, but
    they don’t have to.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`.inspect()` 方法的代码在[示例 13-7](#ex_tombola_abc)中有些愚蠢，但它表明我们可以依赖`.pick()`和`.load(…)`来检查`Tombola`中的内容——通过挑选所有项目并将它们加载回去，而不知道项目实际上是如何存储的。这个示例的重点是强调在抽象基类（ABCs）中提供具体方法是可以的，只要它们仅依赖于接口中的其他方法。了解它们的内部数据结构后，`Tombola`的具体子类可以始终用更智能的实现覆盖`.inspect()`，但他们不必这样做。'
- en: 'The `.loaded()` method in [Example 13-7](#ex_tombola_abc) has one line, but
    it’s expensive: it calls `.inspect()` to build the `tuple` just to apply `bool()`
    on it. This works, but a concrete subclass can do much better, as we’ll see.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13-7](#ex_tombola_abc)中的`.loaded()`方法只有一行，但很昂贵：它调用`.inspect()`来构建`tuple`，然后对其应用`bool()`。这样做是有效的，但具体子类可以做得更好，我们将看到。'
- en: Note that our roundabout implementation of `.inspect()` requires that we catch
    a `LookupError` thrown by `self.pick()`. The fact that `self.pick()` may raise
    `LookupError` is also part of its interface, but there is no way to make this
    explicit in Python, except in the documentation (see the docstring for the abstract
    `pick` method in [Example 13-7](#ex_tombola_abc)).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们对`.inspect()`的绕道实现要求我们捕获`self.pick()`抛出的`LookupError`。`self.pick()`可能引发`LookupError`也是其接口的一部分，但在Python中无法明确表示这一点，除非在文档中（参见[示例
    13-7](#ex_tombola_abc)中抽象`pick`方法的文档字符串）。
- en: I chose the `LookupError` exception because of its place in the Python hierarchy
    of exceptions in relation to `IndexError` and `KeyError`, the most likely exceptions
    to be raised by the data structures used to implement a concrete `Tombola`. Therefore,
    implementations can raise `LookupError`, `IndexError`, `KeyError`, or a custom
    subclass of `LookupError` to comply. See [Figure 13-6](#exc_tree_part).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择了`LookupError`异常，因为它在Python异常层次结构中与`IndexError`和`KeyError`的关系，这是实现具体`Tombola`时最有可能引发的异常。因此，实现可以引发`LookupError`、`IndexError`、`KeyError`或`LookupError`的自定义子类以符合要求。参见[图 13-6](#exc_tree_part)。
- en: '![Upside-down tree diagram with BaseException at the top, and 4 main branches
    including Exception.](assets/flpy_1306.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![倒置树状图，BaseException位于顶部，包括Exception在内的4个主要分支。](assets/flpy_1306.png)'
- en: Figure 13-6\. Part of the `Exception` class hierarchy.^([11](ch13.html#idm46582425060256))
  id: totrans-237
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 13-6。`Exception`类层次结构的一部分。^([11](ch13.html#idm46582425060256))
- en: '![1](assets/1.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![1](assets/1.png)'
- en: '`LookupError` is the exception we handle in `Tombola.inspect`.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`LookupError`是我们在`Tombola.inspect`中处理的异常。'
- en: '![2](assets/2.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![2](assets/2.png)'
- en: '`IndexError` is the `LookupError` subclass raised when we try to get an item
    from a sequence with an index beyond the last position.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`IndexError`是我们尝试从序列中获取超出最后位置的索引时引发的`LookupError`子类。'
- en: '![3](assets/3.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![3](assets/3.png)'
- en: '`KeyError` is raised when we use a nonexistent key to get an item from a mapping.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用不存在的键从映射中获取项时，会引发`KeyError`。
- en: We now have our very own `Tombola` ABC. To witness the interface checking performed
    by an ABC, let’s try to fool `Tombola` with a defective implementation in [Example 13-8](#fake_tombola_ex).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了自己的`Tombola` ABC。为了见证ABC执行的接口检查，让我们尝试用一个有缺陷的实现来愚弄`Tombola`，参见[示例 13-8](#fake_tombola_ex)。
- en: Example 13-8\. A fake `Tombola` doesn’t go undetected
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-8。一个虚假的`Tombola`不会被发现
- en: '[PRE11]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO5-1)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO5-1)'
- en: Declare `Fake` as a subclass of `Tombola`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Fake`声明为`Tombola`的子类。
- en: '[![2](assets/2.png)](#co_interfaces__protocols__and_abcs_CO5-2)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_interfaces__protocols__and_abcs_CO5-2)'
- en: The class was created, no errors so far.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 类已创建，目前没有错误。
- en: '[![3](assets/3.png)](#co_interfaces__protocols__and_abcs_CO5-3)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_interfaces__protocols__and_abcs_CO5-3)'
- en: '`TypeError` is raised when we try to instantiate `Fake`. The message is very
    clear: `Fake` is considered abstract because it failed to implement `load`, one
    of the abstract methods declared in the `Tombola` ABC.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试实例化`Fake`时，会引发`TypeError`。消息非常清楚：`Fake`被视为抽象，因为它未能实现`Tombola` ABC中声明的抽象方法之一`load`。
- en: So we have our first ABC defined, and we put it to work validating a class.
    We’ll soon subclass the `Tombola` ABC, but first we must cover some ABC coding
    rules.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 所��我们定义了我们的第一个ABC，并让它验证一个类的工作。我们很快将子类化`Tombola` ABC，但首先我们必须了解一些ABC编码规则。
- en: ABC Syntax Details
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ABC语法细节
- en: The standard way to declare an ABC is to subclass `abc.ABC` or any other ABC.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 声明ABC的标准方式是继承`abc.ABC`或任何其他ABC。
- en: 'Besides the `ABC` base class, and the `@abstractmethod` decorator, the `abc`
    module defines the `@abstractclassmethod`, `@abstractstaticmethod`, and `@abstractproperty`
    decorators. However, these last three were deprecated in Python 3.3, when it became
    possible to stack decorators on top of `@abstractmethod`, making the others redundant.
    For example, the preferred way to declare an abstract class method is:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`ABC`基类和`@abstractmethod`装饰器外，`abc`模块还定义了`@abstractclassmethod`、`@abstractstaticmethod`和`@abstractproperty`装饰器。然而，在Python
    3.3中，这三个装饰器已被弃用，因为现在可以在`@abstractmethod`之上堆叠装饰器，使其他装饰器变得多余。例如，声明抽象类方法的首选方式是：
- en: '[PRE12]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Warning
  id: totrans-258
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'The order of stacked function decorators matters, and in the case of `@abstractmethod`,
    the documentation is explicit:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 堆叠函数装饰器的顺序很重要，在`@abstractmethod`的情况下，文档是明确的：
- en: When abstractmethod() is applied in combination with other method descriptors,
    it should be applied as the innermost decorator…^([12](ch13.html#idm46582424907136))
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当`abstractmethod()`与其他方法描述符结合使用时，应将其应用为最内层的装饰器…^([12](ch13.html#idm46582424907136))
- en: In other words, no other decorator may appear between `@abstractmethod` and
    the `def` statement.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，在`@abstractmethod`和`def`语句之间不得出现其他装饰器。
- en: Now that we’ve got these ABC syntax issues covered, let’s put `Tombola` to use
    by implementing two concrete descendants of it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了这些ABC语法问题，让我们通过实现两个具体的子类来使用`Tombola`。
- en: Subclassing an ABC
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ABC的子类化
- en: Given the `Tombola` ABC, we’ll now develop two concrete subclasses that satisfy
    its interface. These classes were pictured in [Figure 13-5](#tombola_uml), along
    with the virtual subclass to be discussed in the next section.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于`Tombola` ABC，我们现在将开发两个满足其接口的具体子类。这些类在[图 13-5](#tombola_uml)中有所描述，以及下一节将讨论的虚拟子类。
- en: The `BingoCage` class in [Example 13-9](#ex_tombola_bingo) is a variation of
    [Example 7-8](ch07.html#ex_bingo_callable) using a better randomizer. This `BingoCage`
    implements the required abstract methods `load` and `pick`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13-9](#ex_tombola_bingo)中的`BingoCage`类是[示例 7-8](ch07.html#ex_bingo_callable)的变体，使用了更好的随机化程序。这个`BingoCage`实现了所需的抽象方法`load`和`pick`。'
- en: 'Example 13-9\. bingo.py: `BingoCage` is a concrete subclass of `Tombola`'
  id: totrans-266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-9。bingo.py：`BingoCage`是`Tombola`的具体子类
- en: '[PRE13]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO6-1)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO6-1)'
- en: This `BingoCage` class explicitly extends `Tombola`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`BingoCage`类明确扩展了`Tombola`。
- en: '[![2](assets/2.png)](#co_interfaces__protocols__and_abcs_CO6-2)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_interfaces__protocols__and_abcs_CO6-2)'
- en: Pretend we’ll use this for online gaming. `random.SystemRandom` implements the
    `random` API on top of the `os.urandom(…)` function, which provides random bytes
    “suitable for cryptographic use,” according to the [`os` module docs](https://fpy.li/13-21).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将用于在线游戏。`random.SystemRandom`在`os.urandom(…)`函数之上实现了`random` API，该函数提供了“适用于加密用途”的随机字节，根据[`os`模块文档](https://fpy.li/13-21)。
- en: '[![3](assets/3.png)](#co_interfaces__protocols__and_abcs_CO6-3)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_interfaces__protocols__and_abcs_CO6-3)'
- en: Delegate initial loading to the `.load(…)` method.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 将初始加载委托给`.load(…)`方法。
- en: '[![4](assets/4.png)](#co_interfaces__protocols__and_abcs_CO6-4)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_interfaces__protocols__and_abcs_CO6-4)'
- en: Instead of the plain `random.shuffle()` function, we use the `.shuffle()` method
    of our `SystemRandom` instance.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用我们的`SystemRandom`实例的`.shuffle()`方法，而不是普通的`random.shuffle()`函数。
- en: '[![5](assets/5.png)](#co_interfaces__protocols__and_abcs_CO6-5)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_interfaces__protocols__and_abcs_CO6-5)'
- en: '`pick` is implemented as in [Example 7-8](ch07.html#ex_bingo_callable).'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`pick`的实现如[示例 7-8](ch07.html#ex_bingo_callable)中所示。'
- en: '[![6](assets/6.png)](#co_interfaces__protocols__and_abcs_CO6-6)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_interfaces__protocols__and_abcs_CO6-6)'
- en: '`__call__` is also from [Example 7-8](ch07.html#ex_bingo_callable). It’s not
    needed to satisfy the `Tombola` interface, but there’s no harm in adding extra
    methods.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`__call__`也来自[示例 7-8](ch07.html#ex_bingo_callable)。虽然不需要满足`Tombola`接口，但添加额外的方法也没有坏处。'
- en: '`BingoCage` inherits the expensive `loaded` and the silly `inspect` methods
    from `Tombola`. Both could be overridden with much faster one-liners, as in [Example 13-10](#ex_lotto).
    The point is: we can be lazy and just inherit the suboptimal concrete methods
    from an ABC. The methods inherited from `Tombola` are not as fast as they could
    be for `BingoCage`, but they do provide correct results for any `Tombola` subclass
    that correctly implements `pick` and `load`.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`BingoCage`继承了`Tombola`的昂贵`loaded`和愚蠢的`inspect`方法。都可以用快得多的一行代码重写，就像[示例 13-10](#ex_lotto)中那样。关键是：我们可以懒惰并只继承来自ABC的次优具体方法。从`Tombola`继承的方法对于`BingoCage`来说并不像它们本应该的那样快，但对于任何正确实现`pick`和`load`的`Tombola`子类，它们确实提供了正确的结果。'
- en: '[Example 13-10](#ex_lotto) shows a very different but equally valid implementation
    of the `Tombola` interface. Instead of shuffling the “balls” and popping the last,
    `LottoBlower` pops from a random position.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13-10](#ex_lotto)展示了`Tombola`接口的一个非常不同但同样有效的实现。`LottoBlower`不是洗“球”并弹出最后一个，而是从随机位置弹出。'
- en: 'Example 13-10\. lotto.py: `LottoBlower` is a concrete subclass that overrides
    the `inspect` and `loaded` methods from `Tombola`'
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-10。lotto.py：`LottoBlower`是一个具体子类，覆盖了`Tombola`的`inspect`和`loaded`方法。
- en: '[PRE14]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO7-1)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO7-1)'
- en: 'The initializer accepts any iterable: the argument is used to build a list.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化程序接受任何可迭代对象：该参数用于构建一个列表。
- en: '[![2](assets/2.png)](#co_interfaces__protocols__and_abcs_CO7-2)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_interfaces__protocols__and_abcs_CO7-2)'
- en: The `random.randrange(…)` function raises `ValueError` if the range is empty,
    so we catch that and throw `LookupError` instead, to be compatible with `Tombola`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`random.randrange(…)`函数在范围为空时会引发`ValueError`，因此我们捕获并抛出`LookupError`，以便与`Tombola`兼容。'
- en: '[![3](assets/3.png)](#co_interfaces__protocols__and_abcs_CO7-3)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_interfaces__protocols__and_abcs_CO7-3)'
- en: Otherwise the randomly selected item is popped from `self._balls`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，随机选择的项目将从`self._balls`中弹出。
- en: '[![4](assets/4.png)](#co_interfaces__protocols__and_abcs_CO7-4)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_interfaces__protocols__and_abcs_CO7-4)'
- en: Override `loaded` to avoid calling `inspect` (as `Tombola.loaded` does in [Example 13-7](#ex_tombola_abc)).
    We can make it faster by working with `self._balls` directly—no need to build
    a whole new `tuple`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 重写`loaded`以避免调用`inspect`（就像[示例 13-7](#ex_tombola_abc)中的`Tombola.loaded`一样）。通过直接使用`self._balls`来工作，我们可以使其更快—不需要构建一个全新的`tuple`。
- en: '[![5](assets/5.png)](#co_interfaces__protocols__and_abcs_CO7-5)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_interfaces__protocols__and_abcs_CO7-5)'
- en: Override `inspect` with a one-liner.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 用一行代码重写`inspect`。
- en: '[Example 13-10](#ex_lotto) illustrates an idiom worth mentioning: in `__init__`,
    `self._balls` stores `list(iterable)` and not just a reference to `iterable` (i.e.,
    we did not merely assign `self._balls = iterable`, aliasing the argument). As
    mentioned in [“Defensive Programming and ‘Fail Fast’”](#defensive_duck_prog_sec),
    this makes our `LottoBlower` flexible because the `iterable` argument may be any
    iterable type. At the same time, we make sure to store its items in a `list` so
    we can `pop` items. And even if we always get lists as the `iterable` argument,
    `list(iterable)` produces a copy of the argument, which is a good practice considering
    we will be removing items from it and the client might not expect that the provided
    list will be changed.^([13](ch13.html#idm46582421692528))'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13-10](#ex_lotto)展示了一个值得一提的习惯用法：在`__init__`中，`self._balls`存储`list(iterable)`而不仅仅是`iterable`的引用（即，我们并没有简单地赋值`self._balls
    = iterable`，从而给参数起了个别名）。正如在[“防御性编程和‘快速失败’”](#defensive_duck_prog_sec)中提到的，这使得我们的`LottoBlower`灵活，因为`iterable`参数可以是任何可迭代类型。同时，我们确保将其项存储在`list`中，这样我们就可以`pop`项。即使我们总是得到列表作为`iterable`参数，`list(iterable)`也会产生参数的副本，这是一个很好的做法，考虑到我们将从中删除项目，而客户端可能不希望提供的列表被更改。^([13](ch13.html#idm46582421692528))'
- en: 'We now come to the crucial dynamic feature of goose typing: declaring virtual
    subclasses with the `register` method.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到鹅类型的关键动态特性：使用`register`方法声明虚拟子类。
- en: A Virtual Subclass of an ABC
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个ABC的虚拟子类
- en: An essential characteristic of goose typing—and one reason why it deserves a
    waterfowl name—is the ability to register a class as a *virtual subclass* of an
    ABC, even if it does not inherit from it. When doing so, we promise that the class
    faithfully implements the interface defined in the ABC—and Python will believe
    us without checking. If we lie, we’ll be caught by the usual runtime exceptions.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 鹅类型的一个重要特征——也是为什么它值得一个水禽名字的原因之一——是能够将一个类注册为ABC的*虚拟子类*，即使它没有继承自它。这样做时，我们承诺该类忠实地实现了ABC中定义的接口——Python会相信我们而不进行检查。如果我们撒谎，我们将被通常的运行时异常捕获。
- en: This is done by calling a `register` class method on the ABC. The registered
    class then becomes a virtual subclass of the ABC, and will be recognized as such
    by `issubclass`, but it does not inherit any methods or attributes from the ABC.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过在ABC上调用`register`类方法来完成的。注册的类然后成为ABC的虚拟子类，并且将被`issubclass`识别为这样，但它不会继承ABC的任何方法或属性。
- en: Warning
  id: totrans-299
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Virtual subclasses do not inherit from their registered ABCs, and are not checked
    for conformance to the ABC interface at any time, not even when they are instantiated.
    Also, static type checkers can’t handle virtual subclasses at this time. For details,
    see [Mypy issue 2922—ABCMeta.register support](https://fpy.li/13-22).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟子类不会从其注册的 ABC 继承，并且在任何时候都不会检查其是否符合 ABC 接口，即使在实例化时也是如此。此外，静态类型检查器目前无法处理虚拟子类。详情请参阅[Mypy
    issue 2922—ABCMeta.register support](https://fpy.li/13-22)。
- en: The `register` method is usually invoked as a plain function (see [“Usage of
    register in Practice”](#register_usage)), but it can also be used as a decorator.
    In [Example 13-11](#ex_tombolist), we use the decorator syntax and implement `TomboList`,
    a virtual subclass of `Tombola`, depicted in [Figure 13-7](#tombolist_uml).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`register`方法通常作为一个普通函数调用（参见[“实践中的 register 用法”](#register_usage)），但也可以用作装饰器。在[示例
    13-11](#ex_tombolist)中，我们使用装饰器语法并实现`TomboList`，`Tombola`的虚拟子类，如[图 13-7](#tombolist_uml)所示。'
- en: '![UML for TomboList](assets/flpy_1307.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![TomboList 的 UML](assets/flpy_1307.png)'
- en: Figure 13-7\. UML class diagram for the `TomboList`, a real subclass of `list`
    and a virtual subclass of `Tombola`.
  id: totrans-303
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 13-7\. `TomboList`的 UML 类图，`list`的真实子类和`Tombola`的虚拟子类。
- en: 'Example 13-11\. tombolist.py: class `TomboList` is a virtual subclass of `Tombola`'
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-11\. tombolist.py：类`TomboList`是`Tombola`的虚拟子类
- en: '[PRE15]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO8-1)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO8-1)'
- en: '`Tombolist` is registered as a virtual subclass of `Tombola`.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tombolist`被注册为`Tombola`的虚拟子类。'
- en: '[![2](assets/2.png)](#co_interfaces__protocols__and_abcs_CO8-2)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_interfaces__protocols__and_abcs_CO8-2)'
- en: '`Tombolist` extends `list`.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tombolist`扩展了`list`。'
- en: '[![3](assets/3.png)](#co_interfaces__protocols__and_abcs_CO8-3)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_interfaces__protocols__and_abcs_CO8-3)'
- en: '`Tombolist` inherits its boolean behavior from `list`, and that returns `True`
    if the list is not empty.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tombolist`从`list`继承其布尔行为，如果列表不为空则返回`True`。'
- en: '[![4](assets/4.png)](#co_interfaces__protocols__and_abcs_CO8-4)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_interfaces__protocols__and_abcs_CO8-4)'
- en: Our `pick` calls `self.pop`, inherited from `list`, passing a random item index.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`pick`调用`self.pop`，从`list`继承，传递一个随机的项目索引。
- en: '[![5](assets/5.png)](#co_interfaces__protocols__and_abcs_CO8-5)'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_interfaces__protocols__and_abcs_CO8-5)'
- en: '`Tombolist.load` is the same as `list.extend`.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tombolist.load`与`list.extend`相同。'
- en: '[![6](assets/6.png)](#co_interfaces__protocols__and_abcs_CO8-6)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_interfaces__protocols__and_abcs_CO8-6)'
- en: '`loaded` delegates to `bool`.^([14](ch13.html#idm46582421486032))'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`loaded`委托给`bool`。^([14](ch13.html#idm46582421486032))'
- en: '[![7](assets/7.png)](#co_interfaces__protocols__and_abcs_CO8-7)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_interfaces__protocols__and_abcs_CO8-7)'
- en: It’s always possible to call `register` in this way, and it’s useful to do so
    when you need to register a class that you do not maintain, but which does fulfill
    the interface.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 总是可以以这种方式调用`register`，当你需要注册一个你不维护但符合接口的类时，这样做是很有用的。
- en: 'Note that because of the registration, the functions `issubclass` and `isinstance`
    act as if `TomboList` is a subclass of `Tombola`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于注册，函数`issubclass`和`isinstance`的行为就好像`TomboList`是`Tombola`的子类一样：
- en: '[PRE16]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'However, inheritance is guided by a special class attribute named `__mro__`—the
    Method Resolution Order. It basically lists the class and its superclasses in
    the order Python uses to search for methods.^([15](ch13.html#idm46582421408448))
    If you inspect the `__mro__` of `TomboList`, you’ll see that it lists only the
    “real” superclasses—`list` and `object`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，继承受到一个特殊的类属性`__mro__`的指导——方法解析顺序。它基本上按照 Python 用于搜索方法的顺序列出了类及其超类。^([15](ch13.html#idm46582421408448))
    如果你检查`TomboList`的`__mro__`，你会看到它只列出了“真正”的超类——`list`和`object`：
- en: '[PRE17]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`Tombola` is not in `Tombolist.__mro__`, so `Tombolist` does not inherit any
    methods from `Tombola`.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tombola`不在`Tombolist.__mro__`中，所以`Tombolist`不会从`Tombola`继承任何方法。'
- en: This concludes our `Tombola` ABC case study. In the next section, we’ll address
    how the `register` ABC function is used in the wild.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们的`Tombola`ABC案例研究。在下一节中，我们将讨论`register`ABC函数在实际中的使用方式。
- en: Usage of register in Practice
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实践中的 register 用法
- en: 'In [Example 13-11](#ex_tombolist), we used `Tombola.register` as a class decorator.
    Prior to Python 3.3, `register` could not be used like that—it had to be called
    as a plain function after the class definition, as suggested by the comment at
    the end of [Example 13-11](#ex_tombolist). However, even now, it’s more widely
    deployed as a function to register classes defined elsewhere. For example, in
    the [source code](https://fpy.li/13-24) for the `collections.abc` module, the
    built-in types `tuple`, `str`, `range`, and `memoryview` are registered as virtual
    subclasses of `Sequence`, like this:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 13-11](#ex_tombolist)中，我们使用`Tombola.register`作为一个类装饰器。在 Python 3.3 之前，`register`
    不能像那样使用——它必须在类定义之后作为一个普通函数调用，就像[示例 13-11](#ex_tombolist)末尾的注释建议的那样。然而，即使现在，它更广泛地被用作一个函数来注册在其他地方定义的类。例如，在`collections.abc`模块的[源代码](https://fpy.li/13-24)中，内置类型`tuple`、`str`、`range`和`memoryview`被注册为`Sequence`的虚拟子类，就像这样：
- en: '[PRE18]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Several other built-in types are registered to ABCs in *_collections_abc.py*.
    Those registrations happen only when that module is imported, which is OK because
    you’ll have to import it anyway to get the ABCs. For example, you need to import
    `MutableMapping` from `collections.abc` to perform a check like `isinstance(my_dict,
    MutableMapping)`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 其他几种内置类型在*_collections_abc.py*中被注册为 ABC。这些注册只会在导入该模块时发生，这是可以接受的，因为你无论如何都需要导入它来获取
    ABC。例如，你需要从`collections.abc`导入`MutableMapping`来执行类似`isinstance(my_dict, MutableMapping)`的检查。
- en: Subclassing an ABC or registering with an ABC are both explicit ways of making
    our classes pass `issubclass` checks—as well as `isinstance` checks, which also
    rely on `issubclass`. But some ABCs support structural typing as well. The next
    section explains.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 对 ABC 进行子类化或向 ABC 注册都是显式使我们的类通过`issubclass`检查的方法，以及依赖于`issubclass`的`isinstance`检查。但有些
    ABC 也支持结构化类型。下一节将解释。
- en: Structural Typing with ABCs
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有 ABCs 的结构化类型
- en: ABCs are mostly used with nominal typing. When a class `Sub` explicitly inherits
    from `AnABC`, or is registered with `AnABC`, the name of `AnABC` is linked to
    the `Sub` class—and that’s how at runtime, `issubclass(AnABC, Sub)` returns `True`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ABC主要与名义类型一起使用。当类`Sub`明确从`AnABC`继承，或者与`AnABC`注册时，`AnABC`的名称与`Sub`类关联起来—这就是在运行时，`issubclass(AnABC,
    Sub)`返回`True`的原因。
- en: 'In contrast, structural typing is about looking at the structure of an object’s
    public interface to determine its type: an object is *consistent-with* a type
    if it implements the methods defined in the type.^([16](ch13.html#idm46582421332336))
    Dynamic and static duck typing are two approaches to structural typing.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，结构类型是通过查看对象的公共接口结构来确定其类型的：如果一个对象实现了类型定义中定义的方法，则它与该类型*一致*。动态和静态鸭子类型是结构类型的两种方法。
- en: 'It turns out that some ABCs also support structural typing. In his essay, [“Waterfowl
    and ABCs”](#waterfowl_essay), Alex shows that a class can be recognized as a subclass
    of an ABC even without registration. Here is his example again, with an added
    test using `issubclass`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，一些ABC也支持结构类型。在他的文章[“水禽和ABC”](#waterfowl_essay)中，Alex表明一个类即使没有注册也可以被识别为ABC的子类。以下是他的例子，增加了使用`issubclass`的测试：
- en: '[PRE19]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Class `Struggle` is considered a subclass of `abc.Sized` by the `issubclass`
    function (and, consequently, by `isinstance` as well) because `abc.Sized` implements
    a special class method named `__subclasshook__`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 类`Struggle`被`issubclass`函数认为是`abc.Sized`的子类（因此，也被`isinstance`认为是）因为`abc.Sized`实现了一个名为`__subclasshook__`的特殊类方法。
- en: The `__subclasshook__` for `Sized` checks whether the class argument has an
    attribute named `__len__`. If it does, then it is considered a virtual subclass
    of `Sized`. See [Example 13-12](#sized_source_code).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sized`的`__subclasshook__`检查类参数是否有名为`__len__`的属性。如果有，那么它被视为`Sized`的虚拟子类。参见[示例
    13-12](#sized_source_code)。'
- en: Example 13-12\. Definition of `Sized` from the source code of [Lib/_collections_abc.py](https://fpy.li/13-25)
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-12。来自[Lib/_collections_abc.py](https://fpy.li/13-25)源代码中`Sized`的定义
- en: '[PRE20]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO9-1)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO9-1)'
- en: If there is an attribute named `__len__` in the `__dict__` of any class listed
    in `C.__mro__` (i.e., `C` and its superclasses)…
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`C.__mro__`中列出的任何类（即`C`及其超类）的`__dict__`中有名为`__len__`的属性…
- en: '[![2](assets/2.png)](#co_interfaces__protocols__and_abcs_CO9-2)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_interfaces__protocols__and_abcs_CO9-2)'
- en: …return `True`, signaling that `C` is a virtual subclass of `Sized`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: …返回`True`，表示`C`是`Sized`的虚拟子类。
- en: '[![3](assets/3.png)](#co_interfaces__protocols__and_abcs_CO9-3)'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_interfaces__protocols__and_abcs_CO9-3)'
- en: Otherwise return `NotImplemented` to let the subclass check proceed.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 否则返回`NotImplemented`以让子类检查继续进行。
- en: Note
  id: totrans-346
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are interested in the details of the subclass check, see the source
    code for the `ABCMeta.__subclasscheck__` method in Python 3.6: [*Lib/abc.py*](https://fpy.li/13-26).
    Beware: it has lots of ifs and two recursive calls. In Python 3.7, Ivan Levkivskyi
    and Inada Naoki rewrote in C most of the logic for the `abc` module, for better
    performance. See [Python issue #31333](https://fpy.li/13-27). The current implementation
    of `ABCMeta.__subclasscheck__` simply calls `_abc_subclasscheck`. The relevant
    C source code is in [*cpython/Modules/_abc.c#L605*](https://fpy.li/13-28).'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你对子类检查的细节感兴趣，请查看Python 3.6中`ABCMeta.__subclasscheck__`方法的源代码：[*Lib/abc.py*](https://fpy.li/13-26)。注意：它有很多的if语句和两次递归调用。在Python
    3.7中，Ivan Levkivskyi和Inada Naoki为了更好的性能，用C重写了`abc`模块的大部分逻辑。参见[Python问题 #31333](https://fpy.li/13-27)。当前的`ABCMeta.__subclasscheck__`实现只是调用了`_abc_subclasscheck`。相关的C源代码在[*cpython/Modules/_abc.c#L605*](https://fpy.li/13-28)中。'
- en: That’s how `__subclasshook__` allows ABCs to support structural typing. You
    can formalize an interface with an ABC, you can make `isinstance` checks against
    that ABC, and still have a completely unrelated class pass an `issubclass` check
    because it implements a certain method (or because it does whatever it takes to
    convince a `__subclasshook__` to vouch for it).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`__subclasshook__`如何使ABC支持结构类型。你可以用ABC规范化一个接口，可以对该ABC进行`isinstance`检查，而仍然可以让一个完全不相关的类通过`issubclass`检查，因为它实现了某个方法（或者因为它做了足够的事情来说服`__subclasshook__`为它背书）。
- en: Is it a good idea to implement `__subclasshook__` in our own ABCs? Probably
    not. All the implementations of `__subclasshook__` I’ve seen in the Python source
    code are in ABCs like `Sized` that declare just one special method, and they simply
    check for that special method name. Given their “special” status, you can be pretty
    sure that any method named `__len__` does what you expect. But even in the realm
    of special methods and fundamental ABCs, it can be risky to make such assumptions.
    For example, mappings implement `__len__`, `__getitem__`, and `__iter__`, but
    they are rightly not considered subtypes of `Sequence`, because you can’t retrieve
    items using integer offsets or slices. That’s why the [`abc.Sequence`](https://fpy.li/13-29)
    class does not implement `__subclasshook__`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们自己的ABC中实现`__subclasshook__`是个好主意吗？可能不是。我在Python源代码中看到的所有`__subclasshook__`的实现都在像`Sized`这样声明了一个特殊方法的ABC中，它们只是检查那个特殊方法的名称。鉴于它们的“特殊”地位，你可以非常确定任何名为`__len__`的方法都会按照你的期望工作。但即使在特殊方法和基本ABC的领域，做出这样的假设也是有风险的。例如，映射实现了`__len__`、`__getitem__`和`__iter__`，但它们被正确地不认为是`Sequence`的子类型，因为你不能使用整数偏移或切片检索项目。这就是为什么[`abc.Sequence`](https://fpy.li/13-29)类不实现`__subclasshook__`。
- en: For ABCs that you and I may write, a `__subclasshook__` would be even less dependable.
    I am not ready to believe that any class named `Spam` that implements or inherits
    `load`, `pick`, `inspect`, and `loaded` is guaranteed to behave as a `Tombola`.
    It’s better to let the programmer affirm it by subclassing `Spam` from `Tombola`,
    or registering it with `Tombola.register(Spam)`. Of course, your `__subclasshook__`
    could also check method signatures and other features, but I just don’t think
    it’s worthwhile.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你和我可能编写的ABCs，`__subclasshook__`可能会更不可靠。我不准备相信任何实现或继承`load`、`pick`、`inspect`和`loaded`的`Spam`类都能保证像`Tombola`一样行为。最好让程序员通过将`Spam`从`Tombola`继承或使用`Tombola.register(Spam)`来确认。当然，你的`__subclasshook__`也可以检查方法签名和其他特性，但我认为这并不值得。
- en: Static Protocols
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态协议
- en: Note
  id: totrans-352
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Static protocols were introduced in [“Static Protocols”](ch08.html#protocols_in_fn)
    ([Chapter 8](ch08.html#type_hints_in_def_ch)). I considered delaying all coverage
    of protocols until this chapter, but decided that the initial presentation of
    type hints in functions had to include protocols because duck typing is an essential
    part of Python, and static type checking without protocols doesn’t handle Pythonic
    APIs very well.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 静态协议是在[“静态协议”](ch08.html#protocols_in_fn)（[第8章](ch08.html#type_hints_in_def_ch)）中引入的。我考虑延迟对协议的所有覆盖，直到本章，但决定最初在函数中的类型提示的介绍中包括协���，因为鸭子类型是Python的一个重要部分，而没有协议的静态类型检查无法很好地处理Pythonic
    API。
- en: We will wrap up this chapter by illustrating static protocols with two simple
    examples, and a discussion of numeric ABCs and protocols. Let’s start by showing
    how a static protocol makes it possible to annotate and type check the `double()`
    function we first saw in [“Types Are Defined by Supported Operations”](ch08.html#types_defined_by_ops_sec).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过两个简单示例和对数字ABCs和协议的讨论来结束本章。让我们首先展示静态协议如何使得我们可以对我们在[“类型由支持的操作定义”](ch08.html#types_defined_by_ops_sec)中首次看到的`double()`函数进行注释和类型检查。
- en: The Typed double Function
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有类型的double函数
- en: 'When introducing Python to programmers more used to statically typed languages,
    one of my favorite examples is this simple `double` function:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 当向更习惯于静态类型语言的程序员介绍Python时，我最喜欢的一个例子就是这个简单的`double`函数：
- en: '[PRE21]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Before static protocols were introduced, there was no practical way to add type
    hints to `double` without limiting its possible uses.^([17](ch13.html#idm46582420998240))
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入静态协议之前，没有实际的方法可以为`double`添加类型提示，而不限制其可能的用途。^([17](ch13.html#idm46582420998240))
- en: 'Thanks to duck typing, `double` works even with types from the future, such
    as the enhanced `Vector` class that we’ll see in [“Overloading * for Scalar Multiplication”](ch16.html#overloading_mul)
    ([Chapter 16](ch16.html#operator_overloading)):'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 由于鸭子类型的存在，`double`甚至可以与未来的类型一起使用，比如我们将在[“为标量乘法重载 *”](ch16.html#overloading_mul)（[第16章](ch16.html#operator_overloading)）中看到的增强`Vector`类：
- en: '[PRE22]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The initial implementation of type hints in Python was a nominal type system:
    the name of a type in an annotation had to match the name of the type of the actual
    arguments—or the name of one of its superclasses. Since it’s impossible to name
    all types that implement a protocol by supporting the required operations, duck
    typing could not be described by type hints before Python 3.8.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Python中类型提示的初始实现是一种名义类型系统：注释中的类型名称必须与实际参数的类型名称或其超类的名称匹配。由于不可能命名所有支持所需操作的协议的类型，因此在Python
    3.8之前无法通过类型提示描述鸭子类型。
- en: Now, with `typing.Protocol` we can tell Mypy that `double` takes an argument
    `x` that supports `x * 2`. [Example 13-13](#repeatable_protocol_ex) shows how.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过`typing.Protocol`，我们可以告诉Mypy，`double`接受一个支持`x * 2`的参数`x`。[示例13-13](#repeatable_protocol_ex)展示了如何实现。
- en: 'Example 13-13\. *double_protocol.py*: definition of `double` using a `Protocol`'
  id: totrans-363
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '示例 13-13\. *double_protocol.py*: 使用`Protocol`定义`double`的定义'
- en: '[PRE23]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO10-1)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO10-1)'
- en: We’ll use this `T` in the `__mul__` signature.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`__mul__`签名中使用这个`T`。
- en: '[![2](assets/2.png)](#co_interfaces__protocols__and_abcs_CO10-2)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_interfaces__protocols__and_abcs_CO10-2)'
- en: '`__mul__` is the essence of the `Repeatable` protocol. The `self` parameter
    is usually not annotated—its type is assumed to be the class. Here we use `T`
    to make sure the result type is the same as the type of `self`. Also, note that
    `repeat_count` is limited to `int` in this protocol.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`__mul__`是`Repeatable`协议的本质。`self`参数通常不会被注释，其类型被假定为类。在这里，我们使用`T`来确保结果类型与`self`的类型相同。此外，请注意，此协议中的`repeat_count`限制为`int`。'
- en: '[![3](assets/3.png)](#co_interfaces__protocols__and_abcs_CO10-3)'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_interfaces__protocols__and_abcs_CO10-3)'
- en: 'The `RT` type variable is bounded by the `Repeatable` protocol: the type checker
    will require that the actual type implements `Repeatable`.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`RT`类型变量受`Repeatable`协议的约束：类型检查器将要求实际类型实现`Repeatable`。'
- en: '[![4](assets/4.png)](#co_interfaces__protocols__and_abcs_CO10-4)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_interfaces__protocols__and_abcs_CO10-4)'
- en: Now the type checker is able to verify that the `x` parameter is an object that
    can be multiplied by an integer, and the return value has the same type as `x`.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在类型检查器能够验证`x`参数是一个可以乘以整数的对象，并且返回值与`x`的类型相同。
- en: 'This example shows why [PEP 544](https://fpy.li/pep544) is titled “Protocols:
    Structural subtyping (static duck typing).” The nominal type of the actual argument
    `x` given to `double` is irrelevant as long as it quacks—that is, as long as it
    implements `__mul__`.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例说明了为什么[PEP 544](https://fpy.li/pep544)的标题是“协议：结构子类型（静态鸭子类型）”。给定给`double`的实际参数`x`的名义类型是无关紧要的，只要它呱呱叫，也就是说，只要它实现了`__mul__`。
- en: Runtime Checkable Static Protocols
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可运行时检查的静态协议
- en: In the Typing Map ([Figure 13-1](#type_systems_described)), `typing.Protocol`
    appears in the static checking area—the bottom half of the diagram. However, when
    defining a `typing.Protocol` subclass, you can use the `@runtime_checkable` decorator
    to make that protocol support `isinstance/issubclass` checks at runtime. This
    works because `typing.Protocol` is an ABC, therefore it supports the `__subclasshook__`
    we saw in [“Structural Typing with ABCs”](#subclasshook_sec).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型映射中（[图 13-1](#type_systems_described)），`typing.Protocol`出现在静态检查区域—图表的下半部分。然而，当定义`typing.Protocol`子类时，您可以使用`@runtime_checkable`装饰器使该协议支持运行时的`isinstance/issubclass`检查。这是因为`typing.Protocol`是一个ABC，因此支持我们在[“使用ABC进行结构化类型检查”](#subclasshook_sec)中看到的`__subclasshook__`。
- en: 'As of Python 3.9, the `typing` module includes seven ready-to-use protocols
    that are runtime checkable. Here are two of them, quoted directly from the [`typing`
    documentation](https://fpy.li/13-30):'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Python 3.9，`typing`模块包含了七个可供直接使用的运行时可检查的协议。以下是其中两个，直接引用自[`typing`文档](https://fpy.li/13-30)：
- en: '`class typing.SupportsComplex`'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`class typing.SupportsComplex`'
- en: An ABC with one abstract method, `__complex__`.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有一个抽象方法`__complex__`的ABC。
- en: '`class typing.SupportsFloat`'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`class typing.SupportsFloat`'
- en: An ABC with one abstract method, `__float__`.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有一个抽象方法`__float__`的ABC。
- en: 'These protocols are designed to check numeric types for “convertibility”: if
    an object `o` implements `__complex__`, then you should be able to get a `complex`
    by invoking `complex(o)`—because the `__complex__` special method exists to support
    the `complex()` built-in function.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这些协议旨在检查数值类型的“可转换性”：如果一个对象`o`实现了`__complex__`，那么您应该能够通过调用`complex(o)`来获得一个`complex`——因为`__complex__`特殊方法存在是为了支持`complex()`内置函数。
- en: '[Example 13-14](#supportscomplex_ex) shows the [source code](https://fpy.li/13-31)
    for the `typing.SupportsComplex` protocol.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13-14](#supportscomplex_ex)展示了`typing.SupportsComplex`协议的[源代码](https://fpy.li/13-31)。'
- en: Example 13-14\. `typing.SupportsComplex` protocol source code
  id: totrans-383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-14\. `typing.SupportsComplex`协议源代码
- en: '[PRE24]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The key is the `__complex__` abstract method.^([18](ch13.html#idm46582420703648))
    During static type checking, an object will be considered *consistent-with* the
    `SupportsComplex` protocol if it implements a `__complex__` method that takes
    only `self` and returns a `complex`.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于`__complex__`抽象方法。^([18](ch13.html#idm46582420703648)) 在静态类型检查期间，如果一个对象实现了只接受`self`并返回`complex`的`__complex__`方法，则该对象将被视为与`SupportsComplex`协议*一致*。
- en: Thanks to the `@runtime_checkable` class decorator applied to `SupportsComplex`,
    that protocol can also be used with `isinstance` checks in [Example 13-15](#repeatable_protocol_demo_ex).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`@runtime_checkable`类装饰器应用于`SupportsComplex`，因此该协议也可以与`isinstance`检查一起在[示例
    13-15](#repeatable_protocol_demo_ex)中使用。
- en: Example 13-15\. Using `SupportsComplex` at runtime
  id: totrans-387
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-15\. 在运行时使用`SupportsComplex`
- en: '[PRE25]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO11-1)'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO11-1)'
- en: '`complex64` is one of five complex number types provided by NumPy.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`complex64`是 NumPy 提供的五种复数类型之一。'
- en: '[![2](assets/2.png)](#co_interfaces__protocols__and_abcs_CO11-2)'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_interfaces__protocols__and_abcs_CO11-2)'
- en: None of the NumPy complex types subclass the built-in `complex`.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 的任何复数类型都不是内置的`complex`的子类。
- en: '[![3](assets/3.png)](#co_interfaces__protocols__and_abcs_CO11-3)'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_interfaces__protocols__and_abcs_CO11-3)'
- en: But NumPy’s complex types implement `__complex__`, so they comply with the `SupportsComplex`
    protocol.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 但 NumPy 的复数类型实现了`__complex__`，因此它们符合`SupportsComplex`协议。
- en: '[![4](assets/4.png)](#co_interfaces__protocols__and_abcs_CO11-4)'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_interfaces__protocols__and_abcs_CO11-4)'
- en: Therefore, you can create built-in `complex` objects from them.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以从中创建内置的`complex`对象。
- en: '[![5](assets/5.png)](#co_interfaces__protocols__and_abcs_CO11-5)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_interfaces__protocols__and_abcs_CO11-5)'
- en: Sadly, the `complex` built-in type does not implement `__complex__`, although
    `complex(c)` works fine if `c` is a `complex`.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，`complex`内置类型不实现`__complex__`，尽管如果`c`是`complex`，那么`complex(c)`可以正常工作。
- en: 'As a result of that last point, if you want to test whether an object `c` is
    a `complex` or `SupportsComplex`, you can provide a tuple of types as the second
    argument to `isinstance`, like this:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上述最后一点，如果您想测试对象`c`是否为`complex`或`SupportsComplex`，您可以将类型元组作为`isinstance`的第二个参数提供，就像这样：
- en: '[PRE26]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'An alternative would be to use the `Complex` ABC, defined in the `numbers`
    module. The built-in `complex` type and the NumPy `complex64` and `complex128`
    types are all registered as virtual subclasses of `numbers.Complex`, therefore
    this works:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`numbers`模块中定义的`Complex` ABC。内置的`complex`类型和 NumPy 的`complex64`和`complex128`类型都注册为`numbers.Complex`的虚拟子类，因此这样可以工作：
- en: '[PRE27]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: I recommended using the `numbers` ABCs in the first edition of *Fluent Python*,
    but now that’s no longer good advice, because those ABCs are not recognized by
    the static type checkers, as we’ll see in [“The numbers ABCs and Numeric Protocols”](#numbers_abc_proto_sec).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一版的*流畅的Python*中，我推荐使用`numbers` ABCs，但现在这不再是一个好建议，因为这些ABCs不被静态类型检查器识别，正如我们将在[“数字ABC和数值协议”](#numbers_abc_proto_sec)中看到的那样。
- en: In this section I wanted to demonstrate that a runtime checkable protocol works
    with `isinstance`, but it turns out this is example not a particularly good use
    case of `isinstance`, as the sidebar [“Duck Typing Is Your Friend”](#duck_typing_friend_box)
    explains.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我想演示一个运行时可检查的协议如何与`isinstance`一起工作，但事实证明这个示例并不是`isinstance`的一个特别好的用例，因为侧边栏[“鸭子类型是你的朋友”](#duck_typing_friend_box)解释了这一点。
- en: Tip
  id: totrans-405
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you’re using an external type checker, there is one advantage of explict
    `isinstance` checks: when you write an `if` statement where the condition is `isinstance(o,
    MyType)`, then Mypy can infer that inside the `if` block, the type of the `o`
    object is *consistent-with* `MyType`.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用外部类型检查器，那么显式的`isinstance`检查有一个优点：当您编写一个条件为`isinstance(o, MyType)`的`if`语句时，那么
    Mypy 可以推断在`if`块内，`o`对象的类型与`MyType`*一致*。
- en: Now that we’ve seen how to use static protocols at runtime with preexisting
    types like `complex` and `numpy.complex64`, we need to discuss the limitations
    of runtime checkable protocols.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到如何在运行时使用静态协议与预先存在的类型如`complex`和`numpy.complex64`，我们需要讨论运行时可检查协议的限制。
- en: Limitations of Runtime Protocol Checks
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时协议检查的限制
- en: We’ve seen that type hints are generally ignored at runtime, and this also affects
    the use of `isinstance` or `issubclass` checks against static protocols.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到类型提示通常在运行时被忽略，这也影响了对静态协议进行`isinstance`或`issubclass`检查。
- en: For example, any class with a `__float__` method is considered—at runtime—a
    virtual subclass of `SupportsFloat`, even if the `__float__` method does not return
    a `float`.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，任何具有`__float__`方法的类在运行时被认为是`SupportsFloat`的虚拟子类，即使`__float__`方法不返回`float`。
- en: 'Check out this console session:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 查看这个控制台会话：
- en: '[PRE28]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In Python 3.9, the `complex` type does have a `__float__` method, but it exists
    only to raise a `TypeError` with an explicit error message. If that `__float__`
    method had annotations, the return type would be `NoReturn`—which we saw in [“NoReturn”](ch08.html#noreturn_sec).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3.9 中，`complex`类型确实有一个`__float__`方法，但它只是为了引发一个带有明确错误消息的`TypeError`。如果那个`__float__`方法有注释，返回��型将是`NoReturn`，我们在[“NoReturn”](ch08.html#noreturn_sec)中看到过。
- en: But type hinting `complex.__float__` on *typeshed* would not solve this problem
    because Python’s runtime generally ignores type hints—and can’t access the *typeshed*
    stub files anyway.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 但在*typeshed*上对`complex.__float__`进行类型提示不会解决这个问题，因为 Python 的运行时通常会忽略类型提示，并且无法访问*typeshed*存根文件。
- en: 'Continuing from the previous Python 3.9 session:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前面的 Python 3.9 会话：
- en: '[PRE29]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'So we have misleading results: the runtime checks against `SupportsFloat` suggest
    that you can convert a `complex` to `float`, but in fact that raises a type error.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 因此我们有了误导性的结果：针对`SupportsFloat`的运行时检查表明你可以将`complex`转换为`float`，但实际上会引发类型错误。
- en: Warning
  id: totrans-418
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The specific isssue with the `complex` type is fixed in Python 3.10.0b4 with
    the removal of the `complex.__float__` method.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.10.0b4 中修复了`complex`类型的特定问题，移除了`complex.__float__`方法。
- en: 'But the overall issue remains: `isinstance`/`issubclass` checks only look at
    the presence or absence of methods, without checking their signatures, much less
    their type annotations. And this is not about to change, because such type checks
    at runtime would have an unacceptable performance cost.^([19](ch13.html#idm46582420198656))'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 但总体问题仍然存在：`isinstance`/`issubclass`检查只关注方法的存在或不存在，而不检查它们的签名，更不用说它们的类型注释了。而且这不太可能改变，因为这样的运行时类型检查会带来无法接受的性能成本。^([19](ch13.html#idm46582420198656))
- en: Now let’s see how to implement a static protocol in a user-defined class.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何在用户定义的类中实现静态协议。
- en: Supporting a Static Protocol
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持静态协议
- en: Recall the `Vector2d` class we built in [Chapter 11](ch11.html#pythonic_objects).
    Given that a `complex` number and a `Vector2d` instance both consist of a pair
    of floats, it makes sense to support conversion from `Vector2d` to `complex`.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们在[第11章](ch11.html#pythonic_objects)中构建的`Vector2d`类。考虑到`complex`数和`Vector2d`实例都由一对浮点数组成，支持从`Vector2d`到`complex`的转换是有意义的。
- en: '[Example 13-16](#ex_vector2d_complex_v4) shows the implementation of the `__complex__`
    method to enhance the last version of `Vector2d` we saw in [Example 11-11](ch11.html#ex_vector2d_v3_full).
    For completeness, we can support the inverse operation with a `fromcomplex` class
    method to build a `Vector2d` from a `complex`.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13-16](#ex_vector2d_complex_v4)展示了`__complex__`方法的实现，以增强我们在[示例 11-11](ch11.html#ex_vector2d_v3_full)中看到的`Vector2d`的最新版本。为了完整起见，我们可以通过一个`fromcomplex`类方法支持反向操作，从`complex`构建一个`Vector2d`。'
- en: 'Example 13-16\. *vector2d_v4.py*: methods for converting to and from `complex`'
  id: totrans-425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '示例 13-16\. *vector2d_v4.py*: 转换为和从`complex`的方法'
- en: '[PRE30]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO12-1)'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO12-1)'
- en: This assumes that `datum` has `.real` and `.imag` attributes. We’ll see a better
    implementation in [Example 13-17](#ex_vector2d_complex_v5).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设`datum`有`.real`和`.imag`属性。我们将在[示例 13-17](#ex_vector2d_complex_v5)中看到一个更好的实现。
- en: 'Given the preceding code, and the `__abs__` method the `Vector2d` already had
    in [Example 11-11](ch11.html#ex_vector2d_v3_full), we get these features:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于前面的代码，以及`Vector2d`在[示例 11-11](ch11.html#ex_vector2d_v3_full)中已经有的`__abs__`方法，我们得到了这些特性：
- en: '[PRE31]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: For runtime type checking, [Example 13-16](#ex_vector2d_complex_v4) is fine,
    but for better static coverage and error reporting with Mypy, the `__abs__`, `__complex__`,
    and `fromcomplex` methods should get type hints, as shown in [Example 13-17](#ex_vector2d_complex_v5).
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 对于运行时类型检查，[示例 13-16](#ex_vector2d_complex_v4) 是可以的，但为了更好的静态覆盖和使用 Mypy 进行错误报告，`__abs__`，`__complex__`
    和 `fromcomplex` 方法应该得到类型提示，如[示例 13-17](#ex_vector2d_complex_v5)所示。
- en: 'Example 13-17\. *vector2d_v5.py*: adding annotations to the methods under study'
  id: totrans-432
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '示例 13-17\. *vector2d_v5.py*: 为研究中的方法添加注释'
- en: '[PRE32]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO13-1)'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO13-1)'
- en: The `float` return annotation is needed, otherwise Mypy infers `Any`, and doesn’t
    check the body of the method.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 需要`float`返回注释，否则 Mypy 推断为`Any`，并且不检查方法体。
- en: '[![2](assets/2.png)](#co_interfaces__protocols__and_abcs_CO13-2)'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_interfaces__protocols__and_abcs_CO13-2)'
- en: Even without the annotation, Mypy was able to infer that this returns a `complex`.
    The annotation prevents a warning, depending on your Mypy configuration.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有注释，Mypy也能推断出这返回一个`complex`。根据您的 Mypy 配置，注释可以避免警告。
- en: '[![3](assets/3.png)](#co_interfaces__protocols__and_abcs_CO13-3)'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_interfaces__protocols__and_abcs_CO13-3)'
- en: Here `SupportsComplex` ensures the `datum` is convertible.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`SupportsComplex`确保`datum`是可转换的。
- en: '[![4](assets/4.png)](#co_interfaces__protocols__and_abcs_CO13-4)'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_interfaces__protocols__and_abcs_CO13-4)'
- en: This explicit conversion is necessary, because the `SupportsComplex` type does
    not declare `.real` and `.imag` attributes, used in the next line. For example,
    `Vector2d` doesn’t have those attributes, but implements `__complex__`.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这种显式转换是必要的，因为`SupportsComplex`类型没有声明`.real`和`.imag`属性，这在下一行中使用。例如，`Vector2d`没有这些属性，但实现了`__complex__`。
- en: 'The return type of `fromcomplex` can be `Vector2d` if `from __future__ import
    annotations` appears at the top of the module. That import causes type hints to
    be stored as strings, without being evaluated at import time, when function definitions
    are evaluated. Without the `__future__` import of `annotations`, `Vector2d` is
    an invalid reference at this point (the class is not fully defined yet) and should
    be written as a string: `''Vector2d''`, as if it were a forward reference. This
    `__future__` import was introduced in [PEP 563—Postponed Evaluation of Annotations](https://fpy.li/pep563),
    implemented in Python 3.7. That behavior was scheduled to become default in 3.10,
    but the change was delayed to a later version.^([20](ch13.html#idm46582419823216))
    When that happens, the import will be redundant, but harmless.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在模块顶部出现`from __future__ import annotations`，`fromcomplex`的返回类型可以是`Vector2d`。这个导入会导致类型提示被存储为字符串，而不会在导入时被评估，当函数定义被评估时。没有`__future__`导入`annotations`，此时`Vector2d`是一个无效的引用（类尚未完全定义），应该写成字符串：`'Vector2d'`，就好像它是一个前向引用一样。这个`__future__`导入是在[PEP
    563—注解的延迟评估](https://fpy.li/pep563)中引入的，实现在Python 3.7中。这种行为原计划在3.10中成为默认值，但该更改被推迟到以后的版本。^([20](ch13.html#idm46582419823216))
    当这种情况发生时，这个导入将是多余的，但无害的。
- en: Next, let’s see how to create—and later, extend—a new static protocol.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何创建——以及稍后扩展——一个新的静态协议。
- en: Designing a Static Protocol
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计一个静态协议
- en: While studying goose typing, we saw the `Tombola` ABC in [“Defining and Using
    an ABC”](#defining_using_abc_sec). Here we’ll see how to define a similar interface
    using a static protocol.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习鹅类型时，我们在[“定义和使用ABC”](#defining_using_abc_sec)中看到了`Tombola` ABC。在这里，我们将看到如何使用静态协议定义一个类似的接口。
- en: 'The `Tombola` ABC specifies two methods: `pick` and `load`. We could define
    a static protocol with these two methods as well, but I learned from the Go community
    that single-method protocols make static duck typing more useful and flexible.
    The Go standard library has several interfaces like `Reader`, an interface for
    I/O that requires just a `read` method. After a while, if you realize a more complete
    protocol is required, you can combine two or more protocols to define a new one.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tombola` ABC指定了两种方法：`pick`和`load`。我们也可以定义一个具有这两种方法的静态协议，但我从Go社区中学到，单方法协议使得静态鸭子类型更有用和灵活。Go标准库有几个类似`Reader`的接口，这是一个仅需要`read`方法的I/O接口。过一段时间，如果你意识到需要一个更完整的协议，你可以将两个或更多的协议组合起来定义一个新的协议。'
- en: Using a container that picks items at random may or may not require reloading
    the container, but it certainly needs a method to do the actual pick, so that’s
    the method I will choose for the minimal `RandomPicker` protocol. The code for
    that protocol is in [Example 13-18](#ex_randompick_protocol), and its use is demonstrated
    by tests in [Example 13-19](#ex_randompick_protocol_demo).
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 使用随机选择项目的容器可能需要重新加载容器，也可能不需要，但肯定需要一种方法来实际选择，因此这就是我选择最小`RandomPicker`协议的方法。该协议的代码在[示例
    13-18](#ex_randompick_protocol)中，其使用由[示例 13-19](#ex_randompick_protocol_demo)中的测试演示。
- en: 'Example 13-18\. *randompick.py*: definition of `RandomPicker`'
  id: totrans-448
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-18。*randompick.py*：`RandomPicker`的定义
- en: '[PRE33]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-450
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `pick` method returns `Any`. In [“Implementing a Generic Static Protocol”](ch15.html#implementing_generic_static_proto_sec),
    we will see how to make `RandomPicker` a generic type with a parameter to let
    users of the protocol specify the return type of the `pick` method.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '`pick`方法返回`Any`。在[“实现通用静态协议”](ch15.html#implementing_generic_static_proto_sec)中，我们将看到如何使`RandomPicker`成为一个带有参数的通用类型，让协议的使用者指定`pick`方法的返回类型。'
- en: 'Example 13-19\. *randompick_test.py*: `RandomPicker` in use'
  id: totrans-452
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 13-19。*randompick_test.py*：`RandomPicker`的使用
- en: '[PRE34]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO14-1)'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO14-1)'
- en: It’s not necessary to import the static protocol to define a class that implements
    it. Here I imported `RandomPicker` only to use it on `test_isinstance` later.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 定义实现它的类时，不需要导入静态协议。这里我只导入`RandomPicker`是为了稍后在`test_isinstance`中使用它。
- en: '[![2](assets/2.png)](#co_interfaces__protocols__and_abcs_CO14-2)'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)](#co_interfaces__protocols__and_abcs_CO14-2)'
- en: '`SimplePicker` implements `RandomPicker`—but it does not subclass it. This
    is static duck typing in action.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimplePicker`实现了`RandomPicker`——但它并没有继承它。这就是静态鸭子类型的作用。'
- en: '[![3](assets/3.png)](#co_interfaces__protocols__and_abcs_CO14-3)'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '![3](assets/3.png)](#co_interfaces__protocols__and_abcs_CO14-3)'
- en: '`Any` is the default return type, so this annotation is not strictly necessary,
    but it does make it more clear that we are implementing the `RandomPicker` protocol
    as defined in [Example 13-18](#ex_randompick_protocol).'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '`Any`是默认返回类型，因此此注释并不是严格必要的，但它确实使我们正在实现[示例 13-18](#ex_randompick_protocol)中定义的`RandomPicker`协议更清晰。'
- en: '[![4](assets/4.png)](#co_interfaces__protocols__and_abcs_CO14-4)'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '![4](assets/4.png)](#co_interfaces__protocols__and_abcs_CO14-4)'
- en: Don’t forget to add `-> None` hints to your tests if you want Mypy to look at
    them.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望Mypy查看测试，请不要忘记为你的测试添加`-> None`提示。
- en: '[![5](assets/5.png)](#co_interfaces__protocols__and_abcs_CO14-5)'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '![5](assets/5.png)](#co_interfaces__protocols__and_abcs_CO14-5)'
- en: I added a type hint for the `popper` variable to show that Mypy understands
    that `SimplePicker` is *consistent-with*.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我为`popper`变量添加了一个类型提示，以显示Mypy理解`SimplePicker`是*与之一致*的。
- en: '[![6](assets/6.png)](#co_interfaces__protocols__and_abcs_CO14-6)'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '![6](assets/6.png)](#co_interfaces__protocols__and_abcs_CO14-6)'
- en: This test proves that an instance of `SimplePicker` is also an instance of `RandomPicker`.
    This works because of the `@runtime_checkable` decorator applied to `RandomPicker`,
    and because `SimplePicker` has a `pick` method as required.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试证明了`SimplePicker`的一个实例也是`RandomPicker`的一个实例。这是因为`@runtime_checkable`装饰器应用于`RandomPicker`，并且`SimplePicker`有一个所需的`pick`方法。
- en: '[![7](assets/7.png)](#co_interfaces__protocols__and_abcs_CO14-7)'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '![7](assets/7.png)](#co_interfaces__protocols__and_abcs_CO14-7)'
- en: This test invokes the `pick` method from a `SimplePicker`, verifies that it
    returns one of the items given to `SimplePicker`, and then does static and runtime
    checks on the returned item.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试调用了`SimplePicker`的`pick`方法，验证它是否返回了给`SimplePicker`的项目之一，然后对返回的项目进行了静态和运行时检查。
- en: '[![8](assets/8.png)](#co_interfaces__protocols__and_abcs_CO14-8)'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_interfaces__protocols__and_abcs_CO14-8)'
- en: This line generates a note in the Mypy output.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码会在Mypy输出中生成一个注释。
- en: As we saw in [Example 8-22](ch08.html#top_protocol_test), `reveal_type` is a
    “magic” function recognized by Mypy. That’s why it is not imported and we can
    only call it inside `if` blocks protected by `typing.TYPE_CHECKING`, which is
    only `True` in the eyes of a static type checker, but is `False` at runtime.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[示例 8-22](ch08.html#top_protocol_test)中看到的，`reveal_type`是Mypy识别的“魔术”函数。这就是为什么它不被导入，我们只能在`typing.TYPE_CHECKING`保护的`if`块内调用它，这个块只有在静态类型检查器的眼中才是`True`，但在运行时是`False`。
- en: 'Both tests in [Example 13-19](#ex_randompick_protocol_demo) pass. Mypy does
    not see any errors in that code either, and shows the result of the `reveal_type`
    on the `item` returned by `pick`:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 13-19](#ex_randompick_protocol_demo)中的两个测试都通过了。Mypy在该代码中没有看到任何错误，并显示了`pick`返回的`item`上`reveal_type`的结果：'
- en: '[PRE35]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Having created our first protocol, let’s study some advice on the matter.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了我们的第一个协议后，让我们研究一些相关建议。
- en: Best Practices for Protocol Design
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议设计的最佳实践
- en: After 10 years of experience with static duck typing in Go, it is clear that
    narrow protocols are more useful—often such protocols have a single method, rarely
    more than a couple of methods. Martin Fowler wrote a post defining [*role interface*](https://fpy.li/13-33),
    a useful idea to keep in mind when designing protocols.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Go中的静态鸭子类型10年后，很明显，窄协议更有用——通常这样的协议只有一个方法，很少有超过两个方法。Martin Fowler撰写了一篇定义[*角色接口*](https://fpy.li/13-33)的文章，在设计协议时要记住这个有用的概念。
- en: Also, sometimes you see a protocol defined near the function that uses it—that
    is, defined in “client code” instead of being defined in a library. This is makes
    it easy to create new types to call that function, which is good for extensibility
    and testing with mocks.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你会看到一个协议在使用它的函数附近定义——也就是说，在“客户端代码”中定义，而不是在库中定义。这样做可以轻松创建新类型来调用该函数，这对于可扩展性和使用模拟进行测试是有益的。
- en: The practices of narrow protocols and client-code protocols both avoid unnecessary
    tight coupling, in line with the [Interface Segregation Principle](https://fpy.li/13-34),
    which we can summarize as “Clients should not be forced to depend upon interfaces
    that they do not use.”
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 窄协议和客户端代码协议的实践都避免了不必要的紧密耦合，符合[接口隔离原则](https://fpy.li/13-34)，我们可以总结为“客户端不应被迫依赖于他们不使用的接口”。
- en: 'The page [“Contributing to typeshed”](https://fpy.li/13-35) recommends this
    naming convention for static protocols (the following three points are quoted
    verbatim):'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 页面[“贡献给typeshed”](https://fpy.li/13-35)推荐了这种静态协议的命名约定（以下三点引用原文）：
- en: Use plain names for protocols that represent a clear concept (e.g., `Iterator`,
    `Container`).
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于代表清晰概念的协议，请使用简单名称（例如，`Iterator`，`Container`）。
- en: Use `SupportsX` for protocols that provide callable methods (e.g., `SupportsInt`,
    `SupportsRead`, `SupportsReadSeek`).^([21](ch13.html#idm46582419461792))
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于提供可调用方法的协议，请使用`SupportsX`（例如，`SupportsInt`，`SupportsRead`，`SupportsReadSeek`）。^([21](ch13.html#idm46582419461792))
- en: Use `HasX` for protocols that have readable and/or writable attributes or getter/setter
    methods (e.g., `HasItems`, `HasFileno`).
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于具有可读和/或可写属性或getter/setter方法的协议，请使用`HasX`（例如，`HasItems`，`HasFileno`）。
- en: 'The Go standard library has a naming convention that I like: for single method
    protocols, if the method name is a verb, append “-er” or “-or” to make it a noun.
    For example, instead of `SupportsRead`, have `Reader`. More examples include `Formatter`,
    `Animator`, and `Scanner`. For inspiration, see [“Go (Golang) Standard Library
    Interfaces (Selected)”](https://fpy.li/13-36) by Asuka Kenji.'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库有一个我喜欢的命名约定：对于单方法协议，如果方法名是动词，可以添加“-er”或“-or”以使其成为名词。例如，不要使用`SupportsRead`，而是使用`Reader`。更多示例包括`Formatter`，`Animator`和`Scanner`。有关灵感，请参阅Asuka
    Kenji的[“Go（Golang）标准库接口（精选）”](https://fpy.li/13-36)。
- en: One good reason to create minimalistic protocols is the ability to extend them
    later, if needed. We’ll now see that it’s not hard to create a derived protocol
    with an additional method.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 创建简约协议的一个好理由是以后可以根据需要扩展它们。我们现在将看到创建一个带有额外方法的派生协议并不困难。
- en: Extending a Protocol
  id: totrans-484
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展协议
- en: As I mentioned at the start of the previous section, Go developers advocate
    to err on the side of minimalism when defining interfaces—their name for static
    protocols. Many of the most widely used Go interfaces have a single method.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在上一节开始时提到的，Go开发人员在定义接口时倾向于保持最小主义——他们称之为静态协议。许多最广泛使用的Go接口只有一个方法。
- en: When practice reveals that a protocol with more methods is useful, instead of
    adding methods to the original protocol, it’s better to derive a new protocol
    from it. Extending a static protocol in Python has a few caveats, as [Example 13-20](#ex_randompickload_protocol)
    shows.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 当实践表明一个具有更多方法的协议是有用的时候，与其向原始协议添加方法，不如从中派生一个新协议。在Python中扩展静态协议有一些注意事项，正如[示例 13-20](#ex_randompickload_protocol)所示。
- en: 'Example 13-20\. *randompickload.py*: extending `RandomPicker`'
  id: totrans-487
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '示例 13-20\. *randompickload.py*: 扩展`RandomPicker`'
- en: '[PRE36]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO15-1)'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_interfaces__protocols__and_abcs_CO15-1)'
- en: If you want the derived protocol to be runtime checkable, you must apply the
    decorator again—its behavior is not inherited.^([22](ch13.html#idm46582419384400))
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 如果希望派生协议可以进行运行时检查，必须再次应用装饰器——其行为不会被继承。^([22](ch13.html#idm46582419384400))
- en: '[![2](assets/2.png)](#co_interfaces__protocols__and_abcs_CO15-2)'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_interfaces__protocols__and_abcs_CO15-2)'
- en: Every protocol must explicitly name `typing.Protocol` as one of its base classes
    in addition to the protocol we are extending. This is different from the way inheritance
    works in Python.^([23](ch13.html#idm46582419380128))
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 每个协议必须明确将`typing.Protocol`命名为其基类之一，除了我们正在扩展的协议。这与Python中继承的方式不同。^([23](ch13.html#idm46582419380128))
- en: '[![3](assets/3.png)](#co_interfaces__protocols__and_abcs_CO15-3)'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_interfaces__protocols__and_abcs_CO15-3)'
- en: 'Back to “regular” object-oriented programming: we only need to declare the
    method that is new in this derived protocol. The `pick` method declaration is
    inherited from `RandomPicker`.'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 回到“常规”面向对象编程：我们只需要声明这个派生协议中新增的方法。`pick`方法声明是从`RandomPicker`继承的。
- en: This concludes the final example of defining and using a static protocol in
    this chapter.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了本章中定义和使用静态协议的最终示例。
- en: To wrap the chapter, we’ll go over numeric ABCs and their possible replacement
    with numeric protocols.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束本章，我们将讨论数字ABCs及其可能被数字协议替代的情况。
- en: The numbers ABCs and Numeric Protocols
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字ABCs和数字协议
- en: As we saw in [“The fall of the numeric tower”](ch08.html#numeric_tower_warning),
    the ABCs in the `numbers` package of the standard library work fine for runtime
    type checking.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[“数字塔的崩塌”](ch08.html#numeric_tower_warning)中看到的，标准库中`numbers`包中的ABCs对于运行时类型检查效果很好。
- en: If you need to check for an integer, you can use `isinstance(x, numbers.Integral)`
    to accept `int`, `bool` (which subclasses `int`) or other integer types that are
    provided by external libraries that register their types as virtual subclasses
    of the `numbers` ABCs. For example, NumPy has [21 integer types](https://fpy.li/13-39)—as
    well as several variations of floating-point types registered as `numbers.Real`,
    and complex numbers with various bit widths registered as `numbers.Complex`.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要检查整数，可以使用`isinstance(x, numbers.Integral)`来接受`int`、`bool`（它是`int`的子类）或其他由外部库提供并将其类型注册为`numbers`
    ABCs虚拟子类的整数类型。例如，NumPy有[21种整数类型](https://fpy.li/13-39)——以及几种浮点类型注册为`numbers.Real`，以及以不同位宽注册为`numbers.Complex`的复数。
- en: Tip
  id: totrans-500
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Somewhat surprisingly, `decimal.Decimal` is not registered as a virtual subclass
    of `numbers.Real`. The reason is that, if you need the precision of `Decimal`
    in your program, then you want to be protected from accidental mixing of decimals
    with floating-point numbers that are less precise.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，`decimal.Decimal`并未注册为`numbers.Real`的虚拟子类。原因是，如果您的程序需要`Decimal`的精度，那么您希望受到保护，以免将精度较低的浮点数与`Decimal`混合。
- en: 'Sadly, the numeric tower was not designed for static type checking. The root
    ABC—`numbers.Number`—has no methods, so if you declare `x: Number`, Mypy will
    not let you do arithmetic or call any methods on `x`.'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '遗憾的是，数字塔并不适用于静态类型检查。根ABC——`numbers.Number`——没有方法，因此如果声明`x: Number`，Mypy将不允许您在`x`上进行算术运算或调用任何方法。'
- en: If the `numbers` ABCs are not supported, what are the options?
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不支持`numbers` ABCs，那么还有哪些选项？
- en: 'A good place to look for typing solutions is the *typeshed* project. As part
    of the Python standard library, the `statistics` module has a corresponding [*statistics.pyi*](https://fpy.li/13-40)
    stub file with type hints for on *typeshed*. There you’ll find the following definitions,
    which are used to annotate several functions:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找类型解决方案的好地方是*typeshed*项目。作为Python标准库的一部分，`statistics`模块有一个对应的[*statistics.pyi*](https://fpy.li/13-40)存根文件，其中包含了对*typeshed*上几个函数进行类型提示的定义。在那里，您会找到以下定义，用于注释几个函数：
- en: '[PRE37]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: That approach is correct, but limited. It does not support numeric types outside
    of the standard library, which the `numbers` ABCs do support at runtime—when the
    numeric types are registered as virtual subclasses.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是正确的，但有限。它不支持标准库之外的数字类型，而`numbers` ABCs在运行时支持这些数字类型——当数字类型被注册为虚拟子类时。
- en: The current trend is to recommend the numeric protocols provided by the `typing`
    module, which we discussed in [“Runtime Checkable Static Protocols”](#runtime_checkable_proto_sec).
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的趋势是推荐`typing`模块提供的数字协议，我们在[“可运行时检查的静态协议”](#runtime_checkable_proto_sec)中讨论过。
- en: 'Unfortunately, at runtime, the numeric protocols may let you down. As mentioned
    in [“Limitations of Runtime Protocol Checks”](#protocol_type_hints_ignored), the
    `complex` type in Python 3.9 implements `__float__`, but the method exists only
    to raise `TypeError` with an explicit message: “can’t convert complex to float.”
    It implements `__int__` as well, for the same reason. The presence of those methods
    makes `isinstance` return misleading results in Python 3.9\. In Python 3.10, the
    methods of `complex` that unconditionally raised `TypeError` were removed.^([24](ch13.html#idm46582419293312))'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在运行时，数字协议可能会让您失望。正如在[“运行时协议检查的限制”](#protocol_type_hints_ignored)中提到的，Python
    3.9中的`complex`类型实现了`__float__`，但该方法仅存在于引发`TypeError`并附带明确消息“无法将复数转换为浮点数”：同样的原因，它也实现了`__int__`。这些方法的存在使得在Python
    3.9中`isinstance`返回误导性的结果。在Python 3.10中，那些无条件引发`TypeError`的`complex`方法被移除了。^([24](ch13.html#idm46582419293312))
- en: 'On the other hand, NumPy’s complex types implement `__float__` and `__int__`
    methods that work, only issuing a warning when each of them is used for the first
    time:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，NumPy的复数类型实现了`__float__`和`__int__`方法，只有在第一次使用每个方法时才会发出警告：
- en: '[PRE38]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The opposite problem also happens: built-ins `complex`, `float`, and `int`,
    and also `numpy.float16` and `numpy.uint8`, don’t have a `__complex__` method,
    so `isinstance(x, SupportsComplex)` returns `False` for them.^([25](ch13.html#idm46582419200480))
    The NumPy complex types, such as `np.complex64`, do implement `__complex__` to
    convert to a built-in `complex`.'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 相反的问题也会发生：内置���`complex`、`float`和`int`，以及`numpy.float16`和`numpy.uint8`，都没有`__complex__`方法，因此对于它们，`isinstance(x,
    SupportsComplex)`返回`False`。^([25](ch13.html#idm46582419200480)) NumPy的复数类型，如`np.complex64`，确实实现了`__complex__`以转换为内置的`complex`。
- en: 'However, in practice, the `complex()` built-in constructor handles instances
    of all these types with no errors or warnings:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实践中，`complex()`内置构造函数处理所有这些类型的实例都没有错误或警告：
- en: '[PRE39]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This shows that `isinstance` checks against `SupportsComplex` suggest that those
    conversions to `complex` would fail, but they all succeed. In the typing-sig mailing
    list, Guido van Rossum pointed out that the built-in `complex` accepts a single
    argument, and that’s why those conversions work.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明`isinstance`检查对`SupportsComplex`的转换表明这些转换为`complex`将失败，但它们都成功了。在typing-sig邮件列表中，Guido
    van Rossum指出，内置的`complex`接受一个参数，这就是为什么这些转换起作用的原因。
- en: 'On the other hand, Mypy accepts arguments of all those six types in a call
    to a `to_complex()` function defined like this:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Mypy 在定义如下的`to_complex()`函数时接受这六种类型的所有参数：
- en: '[PRE40]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As I write this, NumPy has no type hints, so its number types are all `Any`.^([26](ch13.html#idm46582419068928))
    On the other hand, Mypy is somehow “aware” that the built-in `int` and `float`
    can be converted to `complex`, even though on *typeshed* only the built-in `complex`
    class has a `__complex__` method.^([27](ch13.html#idm46582419065296))
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 在我写这篇文章时，NumPy 没有类型提示，因此其数值类型都是`Any`。^([26](ch13.html#idm46582419068928)) 另一方面，Mypy
    在某种程度上“意识到”内置的`int`和`float`可以转换为`complex`，尽管在 *typeshed* 中只有内置的`complex`类有一个`__complex__`方法。^([27](ch13.html#idm46582419065296))
- en: 'In conclusion, although numeric types should not be hard to type check, the
    current situation is this: the type hints PEP 484 [eschews](https://fpy.li/cardxvi)
    the numeric tower and implicitly recommends that type checkers hardcode the subtype
    relationships among built-in `complex`, `float`, and `int`. Mypy does that, and
    it also pragmatically accepts that `int` and `float` are *consistent-with* `SupportsComplex`,
    even though they don’t implement `__complex__`.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，尽管数值类型不应该难以进行类型检查，但目前的情况是：类型提示 PEP 484 [避开](https://fpy.li/cardxvi)了数值塔，并隐含地建议类型检查器硬编码内置`complex`、`float`和`int`之间的子类型关系。Mypy
    这样做了，并且还实用地接受`int`和`float`与`SupportsComplex`*一致*，尽管它们没有实现`__complex__`。
- en: Tip
  id: totrans-519
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: I only found unexpected results when using `isinstance` checks with numeric
    `Supports*` protocols while experimenting with conversions to or from `complex`.
    If you don’t use complex numbers, you can rely on those protocols instead of the
    `numbers` ABCs.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 当我尝试将数值`Supports*`协议与`complex`进行转换时，使用`isinstance`检查时我只发现了意外结果。如果你不使用复数，你可以依赖这些协议而不是`numbers`
    ABCs。
- en: 'The main takeaways for this section are:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的主要要点是：
- en: The `numbers` ABCs are fine for runtime type checking, but unsuitable for static
    typing.
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numbers` ABCs 适用于运行时类型检查，但不适用于静态类型检查。'
- en: The numeric static protocols `SupportsComplex`, `SupportsFloat`, etc. work well
    for static typing, but are unreliable for runtime type checking when complex numbers
    are involved.
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数值静态协议`SupportsComplex`、`SupportsFloat`等在静态类型检查时效果很好，但在涉及复数时在运行时类型检查时不可靠。
- en: We are now ready for a quick review of what we saw in this chapter.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备快速回顾本章内容。
- en: Chapter Summary
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节总结
- en: The Typing Map ([Figure 13-1](#type_systems_described)) is the key to making
    sense of this chapter. After a brief introduction to the four approaches to typing,
    we contrasted dynamic and static protocols, which respectively support duck typing
    and static duck typing. Both kinds of protocols share the essential characteristic
    that a class is never required to explicitly declare support for any specific
    protocol. A class supports a protocol simply by implementing the necessary methods.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘映射（[图 13-1](#type_systems_described)）是理解本章内容的关键。在简要介绍了四种类型方法后，我们对比了动态和静态协议，分别支持鸭子类型和静态鸭子类型。这两种类型的协议共享一个基本特征，即类永远不需要明确声明支持任何特定协议。一个类通过实现必要的方法来支持一个协议。
- en: The next major section was [“Programming Ducks”](#prog_ducks_sec), where we
    explored the lengths to which the Python interpreter goes to make the sequence
    and iterable dynamic protocols work, including partial implementations of both.
    We then saw how a class can be made to implement a protocol at runtime through
    the addition of extra methods via monkey patching. The duck typing section ended
    with hints for defensive programming, including detection of structural types
    without explicit `isinstance` or `hasattr` checks using `try/except` and failing
    fast.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的主要部分是[“编程鸭子”](#prog_ducks_sec)，我们探讨了 Python 解释器为使序列和可迭代动态协议工作所做的努力，包括部分实现两者。然后我们看到一个类如何通过动态添加额外方法来在运行时实现一个协议，通过猴子补丁。鸭子类型部分以防御性编程的提示结束，包括使用`try/except`检测结构类型而无需显式的`isinstance`或`hasattr`检查，并快速失败。
- en: After Alex Martelli introduced goose typing in [“Waterfowl and ABCs”](#waterfowl_essay),
    we saw how to subclass existing ABCs, surveyed important ABCs in the standard
    library, and created an ABC from scratch, which we then implemented by traditional
    subclassing and by registration. To close this section, we saw how the `__subclasshook__`
    special method enables ABCs to support structural typing by recognizing unrelated
    classes that provide methods fulfilling the interface defined in the ABC.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Alex Martelli 介绍鹅类型之后[“水禽和 ABCs”](#waterfowl_essay)，我们看到如何对现有的 ABCs 进行子类化，调查了标准库中重要的
    ABCs，并从头开始创建了一个 ABC，然后通过传统的子类化和注册来实现。为了结束这一部分，我们看到`__subclasshook__`特殊方法如何使 ABCs
    能够通过识别提供符合 ABC 中定义接口的方法的不相关类来支持结构类型。
- en: 'The last major section was [“Static Protocols”](#static_protocols_sec), where
    we resumed coverage of static duck typing, which started in [Chapter 8](ch08.html#type_hints_in_def_ch),
    in [“Static Protocols”](ch08.html#protocols_in_fn). We saw how the `@runtime_checkable`
    decorator also leverages `__subclasshook__` to support structural typing at runtime—even
    though the best use of static protocols is with static type checkers, which can
    take into account type hints to make structural typing more reliable. Next we
    talked about the design and coding of a static protocol and how to extend it.
    The chapter ended with [“The numbers ABCs and Numeric Protocols”](#numbers_abc_proto_sec),
    which tells the sad story of the derelict state of the numeric tower and a few
    existing shortcomings of the proposed alternative: the numeric static protocols
    such as `SupportsFloat` and others added to the `typing` module in Python 3.8.'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个重要部分是[“静态协议”](#static_protocols_sec)，我们在这里恢复了静态鸭子类型的覆盖范围，这始于[第8章](ch08.html#type_hints_in_def_ch)，在[“静态协议”](ch08.html#protocols_in_fn)中。我们看到`@runtime_checkable`装饰器如何利用`__subclasshook__`来支持运行时的结构化类型，尽管最佳使用静态协议的方式是与静态类型检查器一起使用，这样可以考虑类型提示以使结构化类型更可靠。接下来，我们讨论了静态协议的设计和编码以及如何扩展它。本章以[“数字
    ABCs 和数字协议”](#numbers_abc_proto_sec)结束，讲述了数字塔的荒废状态以及提出的替代方案存在的一些缺陷：Python 3.8中添加到`typing`模块的数字静态协议，如`SupportsFloat`等。
- en: The main message of this chapter is that we have four complementary ways of
    programming with interfaces in modern Python, each with different advantages and
    drawbacks. You are likely to find suitable use cases for each typing scheme in
    any modern Python codebase of significant size. Rejecting any one of these approaches
    will make your work as a Python programmer harder than it needs to be.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要信息是我们在现代Python中有四种互补的接口编程方式，每种方式都有不同的优势和缺点。在任何规模较大的现代Python代码库中，您可能会发现每种类型方案都有适用的用例。拒绝这些方法中的任何一种都会使您作为Python程序员的工作变得比必要的更加困难。
- en: Having said that, Python achieved widespread popularity while supporting only
    duck typing. Other popular languages such as JavaScript, PHP, and Ruby, as well
    as Lisp, Smalltalk, Erlang, and Clojure—not popular but very influential—are all
    languages that had and still have tremendous impact by leveraging the power and
    simplicity of duck typing.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，Python在仅支持鸭子类型的情况下取得了广泛的流行。其他流行的语言，如JavaScript、PHP和Ruby，以及Lisp、Smalltalk、Erlang和Clojure等不那么流行但非常有影响力的语言，都通过利用鸭子类型的力量和简单性产生了巨大影响。
- en: Further Reading
  id: totrans-532
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For a quick look at typing pros and cons, as well as the importance of `typing.Protocol`
    for the health of statically checked codebases, I highly recommend Glyph Lefkowitz’s
    post [“I Want A New Duck: `typing.Protocol` and the future of duck typing”](https://fpy.li/13-42).
    I also learned a lot from his post [“Interfaces and Protocols”](https://fpy.li/13-43),
    comparing `typing.Protocol` and `zope.interface`—an earlier mechanism for defining
    interfaces in loosely coupled plug-in systems, used by the [Plone CMS](https://fpy.li/13-44),
    the [Pyramid web framework](https://fpy.li/13-45), and the [Twisted](https://fpy.li/13-46)
    asynchronous programming framework, a project founded by Glyph.^([28](ch13.html#idm46582418994048))'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速了解类型的利弊，以及`typing.Protocol`对于静态检查代码库健康的重要性，我强烈推荐Glyph Lefkowitz的帖子[“我想要一个新的鸭子：`typing.Protocol`和鸭子类型的未来”](https://fpy.li/13-42)。我还从他的帖子[“接口和协议”](https://fpy.li/13-43)中学到了很多，比较了`typing.Protocol`和`zope.interface`——一种早期用于在松散耦合的插件系统中定义接口的机制，被[Plone
    CMS](https://fpy.li/13-44)、[Pyramid web framework](https://fpy.li/13-45)和[Twisted](https://fpy.li/13-46)异步编程框架等项目使用，这是Glyph创建的一个项目。^([28](ch13.html#idm46582418994048))
- en: 'Great books about Python have—almost by definition—great coverage of duck typing.
    Two of my favorite Python books had updates released after the first edition of
    *Fluent Python*: *The Quick Python Book*, 3rd ed., (Manning), by Naomi Ceder;
    and [*Python in a Nutshell*, 3rd ed.,](https://fpy.li/pynut3) by Alex Martelli,
    Anna Ravenscroft, and Steve Holden (O’Reilly).'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Python的优秀书籍几乎可以定义为对鸭子类型的广泛覆盖。我最喜欢的两本Python书籍在*Fluent Python*第一版之后发布了更新：Naomi
    Ceder的*The Quick Python Book*第3版（Manning）和Alex Martelli、Anna Ravenscroft和Steve
    Holden（O’Reilly）的[*Python in a Nutshell*第3版](https://fpy.li/pynut3)。
- en: 'For a discussion of the pros and cons of dynamic typing, see Guido van Rossum’s
    interview with Bill Venners in [“Contracts in Python: A Conversation with Guido
    van Rossum, Part IV”](https://fpy.li/13-47). An insightful and balanced take on
    this debate is Martin Fowler’s post [“Dynamic Typing”](https://fpy.li/13-48).
    He also wrote [“Role Interface”](https://fpy.li/13-33), which I mentioned in [“Best
    Practices for Protocol Design”](#best_protocol_design_sec). Although it is not
    about duck typing, that post is highly relevant for Python protocol design, as
    he contrasts narrow role interfaces with the broader public interfaces of classes
    in general.'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 有关动态类型的利弊讨论，请参阅Guido van Rossum与Bill Venners的访谈[“Python中的合同：与Guido van Rossum的对话，第四部分”](https://fpy.li/13-47)。Martin
    Fowler在他的帖子[“动态类型”](https://fpy.li/13-48)中对这场辩论进行了深入而平衡的探讨。他还写了[“角色接口”](https://fpy.li/13-33)，我在[“最佳协议设计实践”](#best_protocol_design_sec)中提到过。尽管这不是关于鸭子类型的，但这篇文章对Python协议设计非常相关，因为他对比了狭窄的角色接口与一般类的更广泛的公共接口。
- en: The Mypy documentation is often the best source of information for anything
    related to static typing in Python, including static duck typing, addressed in
    their [“Protocols and structural subtyping” chapter](https://fpy.li/13-50).
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy文档通常是与Python中静态类型相关的任何信息的最佳来源，包括他们在[“协议和结构子类型”章节](https://fpy.li/13-50)中讨论的静态鸭子类型。
- en: The remaining references are all about goose typing. Beazley and Jones’s *[Python
    Cookbook](https://fpy.li/pycook3)*, 3rd ed. (O’Reilly) has a section about defining
    an ABC (Recipe 8.12). The book was written before Python 3.4, so they don’t use
    the now preferred syntax of declaring ABCs by subclassing from `abc.ABC` (instead,
    they use the `metaclass` keyword, which we’ll only really need in [Chapter 24](ch24.html#class_metaprog)).
    Apart from this small detail, the recipe covers the major ABC features very well.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的参考资料都是关于鹅类型的。Beazley和Jones的*[Python Cookbook](https://fpy.li/pycook3)*，第3版（O’Reilly）有一节关于定义ABC（Recipe
    8.12）。这本书是在Python 3.4之前编写的，所以他们没有使用现在更受欢迎的通过从`abc.ABC`子类化来声明ABC的语法（相反，他们使用了`metaclass`关键字，我们只在[第24章](ch24.html#class_metaprog)中真正需要它）。除了这个小细节，这个配方很好地涵盖了主要的ABC特性。
- en: '*The Python Standard Library by Example* by Doug Hellmann (Addison-Wesley),
    has a chapter about the `abc` module. It’s also available on the web in Doug’s
    excellent [*PyMOTW*—Python Module of the Week](https://fpy.li/13-51). Hellmann
    also uses the old style of ABC declaration: `PluginBase(metaclass=abc.ABCMeta)`
    instead of the simpler `PluginBase(abc.ABC)` available since Python 3.4.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: Doug Hellmann的*Python标准库示例*（Addison-Wesley）中有一章关于`abc`模块。它也可以在Doug出色的[*PyMOTW*—Python本周模块](https://fpy.li/13-51)网站上找到。Hellmann还使用了旧式的ABC声明方式：`PluginBase(metaclass=abc.ABCMeta)`，而不是自Python
    3.4起可用的更简单的`PluginBase(abc.ABC)`。
- en: When using ABCs, multiple inheritance is not only common but practically inevitable,
    because each of the fundamental collection ABCs—`Sequence`, `Mapping`, and `Set`—extends
    `Collection`, which in turn extends multiple ABCs (see [Figure 13-4](#collections_uml)).
    Therefore, [Chapter 14](ch14.html#inheritance) is an important follow-up to this
    one.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用ABCs时，多重继承不仅很常见，而且几乎是不可避免的，因为每个基本集合ABCs—`Sequence`、`Mapping`和`Set`—都扩展了`Collection`，而`Collection`又扩展了多个ABCs（参见[图13-4](#collections_uml)）。因此，[第14章](ch14.html#inheritance)是本章的一个重要后续。
- en: '[PEP 3119—Introducing Abstract Base Classes](https://fpy.li/13-52) gives the
    rationale for ABCs. [PEP 3141—A Type Hierarchy for Numbers](https://fpy.li/13-53)
    presents the ABCs of the [`numbers` module](https://fpy.li/13-54), but the discussion
    in the Mypy issue [#3186 “int is not a Number?”](https://fpy.li/13-55) includes
    some arguments about why the numeric tower is unsuitable for static type checking.
    Alex Waygood wrote a [comprehensive answer on StackOverflow](https://fpy.li/13-56),
    discussing ways to annotate numeric types. I’ll keep watching Mypy issue [#3186](https://fpy.li/13-55)
    for the next chapters of this saga, hoping for a happy ending that will make static
    typing and goose typing compatible—as they should be.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '[PEP 3119—引入抽象基类](https://fpy.li/13-52) 提供了ABC的理由。[PEP 3141—数字类型的类型层次结构](https://fpy.li/13-53)
    展示了[`numbers`模块](https://fpy.li/13-54)的ABC，但在Mypy问题[#3186 “int is not a Number?”](https://fpy.li/13-55)的讨论中包含了一些关于为什么数字塔不适合静态类型检查的论点。Alex
    Waygood在StackOverflow上写了一个[全面的答案](https://fpy.li/13-56)，讨论了注释数字类型的方法。我将继续关注Mypy问题[#3186](https://fpy.li/13-55)，期待这个传奇的下一章有一个让静态类型和鹅类型兼容的美好结局——因为它们应该是兼容的。'
- en: '^([1](ch13.html#idm46582423423920-marker)) *Design Patterns: Elements of Reusable
    Object-Oriented Software*, “Introduction,” p. 18.'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch13.html#idm46582423423920-marker)) *设计模式：可复用面向对象软件的元素*，“介绍”，p. 18。
- en: ^([2](ch13.html#idm46582424482224-marker)) The [“Monkey patch”](https://fpy.li/13-4)
    article on Wikipedia has a funny example in Python.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch13.html#idm46582424482224-marker)) Wikipedia上的[“猴子补丁”](https://fpy.li/13-4)文章中有一个有趣的Python示例。
- en: ^([3](ch13.html#idm46582424129520-marker)) That’s why automated testing is necessary.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch13.html#idm46582424129520-marker)) 这就是为什么自动化测试是必要的。
- en: ^([4](ch13.html#idm46582424233376-marker)) Bjarne Stroustrup, *The Design and
    Evolution of C++*, p. 278 (Addison-Wesley).
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch13.html#idm46582424233376-marker)) Bjarne Stroustrup, *C++的设计与演化*, p.
    278 (Addison-Wesley)。
- en: ^([5](ch13.html#idm46582424062480-marker)) Retrieved October 18, 2020.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch13.html#idm46582424062480-marker)) 检索日期为2020年10月18日。
- en: ^([6](ch13.html#idm46582423988704-marker)) You can also, of course, define your
    own ABCs—but I would discourage all but the most advanced Pythonistas from going
    that route, just as I would discourage them from defining their own custom metaclasses…and
    even for said “most advanced Pythonistas,” those of us sporting deep mastery of
    every fold and crease in the language, these are not tools for frequent use. Such
    “deep metaprogramming,” if ever appropriate, is intended for authors of broad
    frameworks meant to be independently extended by vast numbers of separate development
    teams…less than 1% of “most advanced Pythonistas” may ever need that! — *A.M.*
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch13.html#idm46582423988704-marker)) 当然，你也可以定义自己的ABCs，但我会劝阻除了最高级的Pythonista之外的所有人这样做，就像我会劝阻他们定义自己的自定义元类一样……即使对于那些拥有对语言的每一个折叠和褶皱深度掌握的“最高级的Pythonista”来说，这些都不是经常使用的工具。这种“深度元编程”，如果适用的话，是为了那些打算由大量独立开发团队扩展的广泛框架的作者而设计的……不到“最高级的Pythonista”的1%可能会需要这个！ — *A.M.*
- en: '^([7](ch13.html#idm46582425220368-marker)) Multiple inheritance was *considered
    harmful* and excluded from Java, except for interfaces: Java interfaces can extend
    multiple interfaces, and Java classes can implement multiple interfaces.'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch13.html#idm46582425220368-marker)) 多重继承被认为是有害的，并且在Java中被排除，除了接口：Java接口可以扩展多个接口，Java类可以实现多个接口。
- en: ^([8](ch13.html#idm46582423844320-marker)) Perhaps the client needs to audit
    the randomizer; or the agency wants to provide a rigged one. You never know…
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch13.html#idm46582423844320-marker)) 或许客户需要审计随机器；或者机构想提供一个作弊的随机器。你永远不知道……
- en: ^([9](ch13.html#idm46582423825920-marker)) «registered» and «virtual subclass»
    are not standard UML terms. I am using them to represent a class relationship
    that is specific to Python.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch13.html#idm46582423825920-marker)) “注册”和“虚拟子类”不是标准的UML术语。我使用它们来表示一个特定于Python的类关系。
- en: ^([10](ch13.html#idm46582425152848-marker)) Before ABCs existed, abstract methods
    would raise `NotImplementedError` to signal that subclasses were responsible for
    their implementation. In Smalltalk-80, abstract method bodies would invoke `subclassResponsibility`,
    a method inherited from `object` that would produce an error with the message,
    “My subclass should have overridden one of my messages.”
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch13.html#idm46582425152848-marker)) 在抽象基类存在之前，抽象方法会引发`NotImplementedError`来表示子类负责实现���们。在
    Smalltalk-80 中，抽象方法体会调用`subclassResponsibility`，这是从`object`继承的一个方法，它会产生一个带有消息“我的子类应该重写我的消息之一”的错误。
- en: ^([11](ch13.html#idm46582425060256-marker)) The complete tree is in section
    “5.4\. Exception hierarchy” of *The Python Standard Library* docs.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch13.html#idm46582425060256-marker)) 完整的树在《Python 标准库》文档的“5.4\. 异常层次结构”部分中。
- en: ^([12](ch13.html#idm46582424907136-marker)) The [`@abc.abstractmethod`](https://fpy.li/13-19)
    entry in the [`abc` module documentation](https://fpy.li/13-20).
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: ^([12](ch13.html#idm46582424907136-marker)) [`@abc.abstractmethod`](https://fpy.li/13-19)在[`abc`模块文档](https://fpy.li/13-20)中的条目。
- en: ^([13](ch13.html#idm46582421692528-marker)) [“Defensive Programming with Mutable
    Parameters”](ch06.html#defensive_argument) in [Chapter 6](ch06.html#mutability_and_references)
    was devoted to the aliasing issue we just avoided here.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: ^([13](ch13.html#idm46582421692528-marker)) [第 6 章](ch06.html#mutability_and_references)中的[“使用可变参数进行防御性编程”](ch06.html#defensive_argument)专门讨论了我们刚刚避免的别名问题。
- en: ^([14](ch13.html#idm46582421486032-marker)) The same trick I used with `load()`
    doesn’t work with `loaded()`, because the `list` type does not implement `__bool__`,
    the method I’d have to bind to `loaded`. The `bool()` built-in doesn’t need `__bool__`
    to work because it can also use `__len__`. See [“4.1\. Truth Value Testing”](https://fpy.li/13-23)
    in the “Built-in Types” chapter of the Python documentation.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: ^([14](ch13.html#idm46582421486032-marker)) 我用`load()`的相同技巧无法用于`loaded()`，因为`list`类型没有实现`__bool__`，我必须绑定到`loaded`的方法。`bool()`
    内置不需要`__bool__`就能工作，因为它也可以使用`__len__`。请参阅 Python 文档的“内置类型”章节中的[“4.1\. 真值测试”](https://fpy.li/13-23)。
- en: ^([15](ch13.html#idm46582421408448-marker)) There is a whole section explaining
    the `__mro__` class attribute in [“Multiple Inheritance and Method Resolution
    Order”](ch14.html#mro_section). Right now, this quick explanation will do.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: ^([15](ch13.html#idm46582421408448-marker)) 在[“多重继承和方法解析顺序”](ch14.html#mro_section)中有一个完整的解释`__mro__`类属性的部分。现在，这个简短的解释就够了。
- en: ^([16](ch13.html#idm46582421332336-marker)) The concept of type consistency
    was explained in [“Subtype-of versus consistent-with”](ch08.html#consistent_with_sec).
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: ^([16](ch13.html#idm46582421332336-marker)) 类型一致性的概念在[“子类型与一致性”](ch08.html#consistent_with_sec)中有解释。
- en: ^([17](ch13.html#idm46582420998240-marker)) OK, `double()` is not very useful,
    except as an example. But the Python standard library has many functions that
    could not be properly annotated before static protocols were added in Python 3.8\.
    I helped fix a couple of bugs in *typeshed* by adding type hints using protocols.
    For example, the pull request that fixed [“Should Mypy warn about potential invalid
    arguments to `max`?”](https://fpy.li/shed4051) leveraged a `_SupportsLessThan`
    protocol, which I used to enhance the annotations for `max`, `min`, `sorted`,
    and `list.sort`.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: ^([17](ch13.html#idm46582420998240-marker)) 好吧，`double()` 并不是很有用，除了作为一个例子。但是在
    Python 3.8 添加静态协议之前，Python 标准库有许多函数无法正确注释。我通过使用协议添加类型提示来帮助修复了 *typeshed* 中的一些错误。例如，修复[“Mypy
    是否应该警告可能无效的 `max` 参数？”](https://fpy.li/shed4051)的拉取请求利用了一个 `_SupportsLessThan`
    协议，我用它增强了 `max`、`min`、`sorted` 和 `list.sort` 的注释。
- en: ^([18](ch13.html#idm46582420703648-marker)) The `__slots__` attribute is irrelevant
    to the current discussion—it’s an optimization we covered in [“Saving Memory with
    __slots__”](ch11.html#slots_section).
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: ^([18](ch13.html#idm46582420703648-marker)) `__slots__` 属性与当前讨论无关—这是我们在[“使用
    __slots__ 节省内存”](ch11.html#slots_section)中讨论的优化。
- en: '^([19](ch13.html#idm46582420198656-marker)) Thanks to Ivan Levkivskyi, coauthor
    of [PEP 544](https://fpy.li/pep544) (on Protocols), for pointing out that type
    checking is not just a matter of checking whether the type of `x` is `T`: it’s
    about determining that the type of `x` is *consistent-with* `T`, which may be
    expensive. It’s no wonder that Mypy takes a few seconds to type check even short
    Python scripts.'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: ^([19](ch13.html#idm46582420198656-marker)) 感谢 [PEP 544](https://fpy.li/pep544)（关于协议）的合著者伊万·列夫基夫斯基指出，类型检查不仅仅是检查`x`的类型是否为`T`：它是关于确定`x`的类型与`T`是*一致的*，这可能是昂贵的。难怪
    Mypy 即使对短小的 Python 脚本进行类型检查也需要几秒钟的时间。
- en: ^([20](ch13.html#idm46582419823216-marker)) Read the Python Steering Council
    [decision](https://fpy.li/13-32) on python-dev.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: ^([20](ch13.html#idm46582419823216-marker)) 阅读 Python Steering Council 在 python-dev
    上的[决定](https://fpy.li/13-32)。
- en: ^([21](ch13.html#idm46582419461792-marker)) Every method is callable, so this
    guideline doesn’t say much. Perhaps “provide one or two methods”? Anyway, it’s
    a guideline, not a strict rule.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: ^([21](ch13.html#idm46582419461792-marker)) 每个方法都是可调用的，所以这个准则并没有说太多。也许“提供一个或两个方法”？无论如何，这只是一个指导方针，不是一个严格的规则。
- en: '^([22](ch13.html#idm46582419384400-marker)) For details and rationale, please
    see the section about [`@runtime_checkable`](https://fpy.li/13-37) in PEP 544—Protocols:
    Structural subtyping (static duck typing).'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: ^([22](ch13.html#idm46582419384400-marker)) 有关详细信息和原理，请参阅 PEP 544 中关于[`@runtime_checkable`](https://fpy.li/13-37)的部分—协议：结构子类型（静态鸭子类型）。
- en: ^([23](ch13.html#idm46582419380128-marker)) Again, please read [“Merging and
    extending protocols”](https://fpy.li/13-38) in PEP 544 for details and rationale.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: ^([23](ch13.html#idm46582419380128-marker)) 再次，请阅读 PEP 544 中关于[“合并和扩展协议”](https://fpy.li/13-38)的详细信息和原理。
- en: '^([24](ch13.html#idm46582419293312-marker)) See [Issue #41974—Remove `complex.__float__`,
    `complex.__floordiv__`, etc](https://fpy.li/13-41).'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '^([24](ch13.html#idm46582419293312-marker)) 请参阅[Issue #41974—删除 `complex.__float__`、`complex.__floordiv__`
    等](https://fpy.li/13-41)。'
- en: ^([25](ch13.html#idm46582419200480-marker)) I did not test all the other float
    and integer variants NumPy offers.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: ^([25](ch13.html#idm46582419200480-marker)) 我没有测试 NumPy 提供的所有其他浮点数和整数变体。
- en: ^([26](ch13.html#idm46582419068928-marker)) The NumPy number types are all registered
    against the appropriate `numbers` ABCs, which Mypy ignores.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: ^([26](ch13.html#idm46582419068928-marker)) NumPy的数字类型都已注册到相应的`numbers` ABCs中，但Mypy忽略了这一点。
- en: '^([27](ch13.html#idm46582419065296-marker)) That’s a well-meaning lie on the
    part of typeshed: as of Python 3.9, the built-in `complex` type does not actually
    have a `__complex__` method.'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: ^([27](ch13.html#idm46582419065296-marker)) 这是 typeshed 的一种善意的谎言：截至 Python 3.9，内置的`complex`类型实际上并没有`__complex__`方法。
- en: ^([28](ch13.html#idm46582418994048-marker)) Thanks to tech reviewer Jürgen Gmach
    for recommending the “Interfaces and Protocols” post.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: ^([28](ch13.html#idm46582418994048-marker)) 感谢技术审阅者Jürgen Gmach推荐“接口和协议”文章。
