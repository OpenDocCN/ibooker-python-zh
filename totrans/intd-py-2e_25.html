<html><head></head><body><section data-pdf-bookmark="Appendix A. Hardware and Software for Beginning Programmers" data-type="appendix" epub:type="appendix"><div class="appendix" id="app_computers">&#13;
<h1><span class="label">Appendix A. </span>Hardware and Software for <span class="keep-together">Beginning Programmers</span></h1>&#13;
&#13;
&#13;
<p>Some things make intuitive sense.&#13;
Some we see in nature,&#13;
and others are human inventions&#13;
such as the wheel or pizza.</p>&#13;
&#13;
<p>Others require more of a leap of faith.&#13;
How does a television convert some invisible wiggles in the air&#13;
into sounds and moving images?</p>&#13;
&#13;
<p>A computer is one of these hard-to-accept ideas.&#13;
How can you type something and get a machine to&#13;
do what you want?</p>&#13;
&#13;
<p>When I was learning to program,&#13;
it was hard to find answers to some basic questions.&#13;
For example: some books explain&#13;
computer memory with the analogy&#13;
of books on a library shelf.&#13;
I wondered, if you <em>read from memory</em>,&#13;
the analogy implies you’re taking a book from the shelf.&#13;
So, does that erase it from memory?&#13;
Actually, no.&#13;
It’s more like getting a <em>copy</em> of the book from the shelf.</p>&#13;
&#13;
<p>This appendix is a short review of computer hardware&#13;
and software, if you’re relatively new to programming.&#13;
I try to explain the things that become “obvious”&#13;
eventually but may be sticking points at the start.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Hardware" data-type="sect1"><div class="sect1" id="idm45794959859400">&#13;
<h1>Hardware</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Caveman Computers" data-type="sect2"><div class="sect2" id="idm45794959858088">&#13;
<h2>Caveman Computers</h2>&#13;
&#13;
<p><a data-primary="hardware, evolution of computing and" data-type="indexterm" id="ix_appA-computers-asciidoc0"/>When the cavemen Og and Thog returned from hunting,&#13;
they would each add a rock to their own pile&#13;
for each mammoth they slew.&#13;
But they couldn’t do much with the piles,&#13;
other than gain bragging rights if one was noticeably&#13;
larger than the other.</p>&#13;
&#13;
<p>Distant descendents of Og&#13;
(Thog got stomped by a mammoth one day,&#13;
trying to add to his pile)&#13;
would learn to count, and write,&#13;
and use an abacus.&#13;
But some leaps of imagination and technology&#13;
were needed to get beyond&#13;
these tools to the concept of a computer.&#13;
The first necessary technology was electricity.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Electricity" data-type="sect2"><div class="sect2" id="idm45794959854600">&#13;
<h2>Electricity</h2>&#13;
&#13;
<p><a data-primary="electricity, basics of" data-type="indexterm" id="idm45794959853400"/>Ben Franklin thought that electricity was a flow&#13;
of some invisible fluid from a place&#13;
with more fluid (<em>positive</em>) to a place with less (<em>negative</em>).&#13;
He was right, but got the terms backwards.&#13;
Electrons flow from his “negative” to “positive,”&#13;
but electrons weren’t discovered until much later—too late to change the terminology.&#13;
So, ever since we’ve needed to remember that electrons flow one&#13;
way and <em>current</em> is defined as flowing the other way.</p>&#13;
&#13;
<p>We’re all familiar with natural&#13;
electrical phenomena like static electricity and lightning.&#13;
After people discovered how to push electrons&#13;
through conducting wires to make electrical <em>circuits</em>,&#13;
we got one step closer to making computers.</p>&#13;
&#13;
<p>I used to think that&#13;
electric current in a wire&#13;
was caused by jazzed electrons doing laps&#13;
around the track.&#13;
It’s actually quite different.&#13;
Electrons jump from one atom to another.&#13;
They behave a little like ball bearings in a tube&#13;
(or tapioca balls in a bubble tea straw).&#13;
When you push a ball at one end,&#13;
it pushes its neighbor,&#13;
and so on until&#13;
the ball at the other end is pushed out.&#13;
Although an average electron moves slowly&#13;
(<em>drift speed</em> in a wire is only about three inches/hour),&#13;
this almost-simultaneous&#13;
bumping causes the generated electromagetic wave&#13;
to propagate very quickly:&#13;
50 to 99% the speed of light,&#13;
depending on the conductor.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Inventions" data-type="sect2"><div class="sect2" id="idm45794959847992">&#13;
<h2>Inventions</h2>&#13;
&#13;
<p>We still needed:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A way to remember things</p>&#13;
</li>&#13;
<li>&#13;
<p>A way to do stuff with the things that we remembered</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>One memory concept was a <em>switch</em>: something that’s either&#13;
on or off, and stays as it is until something flips&#13;
it to the other state.&#13;
An electrical switch works by opening or closing a circuit,&#13;
allowing electrons to flow or blocking them.&#13;
We use switches all the time to control lights and other&#13;
electrical devices.&#13;
What was needed was a way to control the switch itself&#13;
by electricity.</p>&#13;
&#13;
<p>The earliest computers (and televisions)&#13;
used vacuum tubes for this purpose,&#13;
but these were big and often burned out.&#13;
The single key invention that led to modern computers&#13;
was the <em>transistor</em>:&#13;
smaller,&#13;
more efficient,&#13;
and more reliable.&#13;
The final key step was to make transistors much smaller&#13;
and connect them in <em>integrated circuits</em>.&#13;
For many years,&#13;
computers got faster and ridiculously cheaper&#13;
as they became smaller and smaller.&#13;
Signals move faster when the components are closer together.</p>&#13;
&#13;
<p>But there’s a limit to how small we can stuff things together.&#13;
This electron friskiness encounters <em>resistance</em>,&#13;
which generates heat.&#13;
We reached that lower limit more than 10 years ago,&#13;
and manufacturers have compensated by putting&#13;
multiple “chips” on the same board.&#13;
This has increased the demand for <em>distributed computing</em>,&#13;
which I discuss in a bit.</p>&#13;
&#13;
<p>Regardless of these details,&#13;
with these inventions&#13;
we have been able to construct&#13;
<em>computers</em>: machines&#13;
that can remember things and so something with them.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="An Idealized Computer" data-type="sect2"><div class="sect2" id="idm45794959838632">&#13;
<h2>An Idealized Computer</h2>&#13;
&#13;
<p>Real computers have lots of complex features.&#13;
Let’s focus on the essential parts.</p>&#13;
&#13;
<p>A circuit “board” contains the CPU,&#13;
memory,&#13;
and wires connecting them to each other&#13;
and to plugs for external devices.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The CPU" data-type="sect2"><div class="sect2" id="idm45794959836312">&#13;
<h2>The CPU</h2>&#13;
&#13;
<p><a data-primary="CPU (central processing unit)" data-type="indexterm" id="idm45794959835112"/>The <em>CPU</em> (Central Processing Unit), or “chip,”&#13;
does the actual “computing”:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Mathematical tasks like addition</p>&#13;
</li>&#13;
<li>&#13;
<p>Comparing values</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Memory and Caches" data-type="sect2"><div class="sect2" id="idm45794959831128">&#13;
<h2>Memory and Caches</h2>&#13;
&#13;
<p><a data-primary="caches" data-type="indexterm" id="idm45794959829896"/><a data-primary="memory" data-type="indexterm" id="idm45794959829192"/><a data-primary="RAM (Random Access Memory)" data-type="indexterm" id="idm45794959828520"/><em>RAM</em> (Random Access Memory)&#13;
does the “remembering.”&#13;
It’s fast, but <em>volatile</em>&#13;
(loses its data if power is lost).</p>&#13;
&#13;
<p>CPUs have been getting ever faster than memory,&#13;
so computer designers have been adding <em>caches</em>:&#13;
smaller, faster memory between the CPU and main memory.&#13;
When your CPU tries to read some bytes from memory, it&#13;
first tries the closest cache&#13;
(called an <em>L1</em> cache),&#13;
then the next (<em>L2</em>),&#13;
and eventually to main RAM.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Storage" data-type="sect2"><div class="sect2" id="idm45794959824712">&#13;
<h2>Storage</h2>&#13;
&#13;
<p><a data-primary="nonvolatile storage" data-type="indexterm" id="idm45794959823512"/><a data-primary="persistent storage" data-secondary="nonvolatile" data-type="indexterm" id="idm45794959822808"/>Because main memory loses its data,&#13;
we also need <em>nonvolatile</em> storage.&#13;
Such devices are cheaper than memory and&#13;
hold much more data,&#13;
but are also much slower.</p>&#13;
&#13;
<p><a data-primary="hard drives (HDD)" data-type="indexterm" id="idm45794959820888"/><a data-primary="magnetic disks" data-type="indexterm" id="idm45794959820184"/>The traditional storage method has been&#13;
“spinning rust”:&#13;
<em>magnetic disks</em> (or <em>hard drives</em> or <em>HDD</em>)&#13;
with movable read-write heads,&#13;
a little like vinyl records and a stylus.</p>&#13;
&#13;
<p><a data-primary="SSD (Solid State Drive)" data-type="indexterm" id="idm45794959817736"/>A hybrid technology called&#13;
<em>SSD</em> (Solid State Drive) is&#13;
made of semiconductors like RAM,&#13;
but is nonvolatile like magnetic disks.&#13;
Price and speed falls between the two.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Inputs" data-type="sect2"><div class="sect2" id="idm45794959815976">&#13;
<h2>Inputs</h2>&#13;
&#13;
<p>How do you get data into the computer?&#13;
For people, the main choices are&#13;
keyboards, mice, and touchscreens.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Outputs" data-type="sect2"><div class="sect2" id="idm45794959814264">&#13;
<h2>Outputs</h2>&#13;
&#13;
<p>People generally see computer output&#13;
with displays and printers.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Relative Access Times" data-type="sect2"><div class="sect2" id="idm45794959812680">&#13;
<h2>Relative Access Times</h2>&#13;
&#13;
<p><a data-primary="relative access times" data-type="indexterm" id="idm45794959811224"/>The amount of time it takes to get data to and from&#13;
any of these components varies tremendously.&#13;
This has big practical implications,&#13;
For example, software needs to run in memory&#13;
and access data there,&#13;
but it also needs to store data safely on nonvolatile&#13;
devices like disks.&#13;
The problem is that disks are thousands of times slower,&#13;
and networks are even slower.&#13;
This means that programmers spend a lot of time&#13;
trying to make the best trade-offs between speed and cost.</p>&#13;
&#13;
<p>In&#13;
<a href="https://oreil.ly/G36qD">Computer Latency at a Human Scale</a>,&#13;
David Jeppesen compares them.&#13;
I’ve derived <a data-type="xref" href="#tableA1">Table A-1</a> from his numbers&#13;
and others.&#13;
The last columns—Ratio,&#13;
Relative Time (CPU = one second)&#13;
and Relative Distance (CPU = one inch)—are easier for us to relate to than the specific timings.</p>&#13;
<table id="tableA1">&#13;
<caption><span class="label">Table A-1. </span>Relative access times</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Location</th>&#13;
<th>Time</th>&#13;
<th>Ratio</th>&#13;
<th>Relative Time</th>&#13;
<th>Relative Distance</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>CPU</p></td>&#13;
<td><p>0.4 ns</p></td>&#13;
<td><p>1</p></td>&#13;
<td><p>1 sec</p></td>&#13;
<td><p>1 in</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>L1 cache</p></td>&#13;
<td><p>0.9 ns</p></td>&#13;
<td><p>2</p></td>&#13;
<td><p>2 sec</p></td>&#13;
<td><p>2 in</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>L2 cache</p></td>&#13;
<td><p>2.8 ns</p></td>&#13;
<td><p>7</p></td>&#13;
<td><p>7 sec</p></td>&#13;
<td><p>7 in</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>L3 cache</p></td>&#13;
<td><p>28 ns</p></td>&#13;
<td><p>70</p></td>&#13;
<td><p>1 min</p></td>&#13;
<td><p>6 ft</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>RAM</p></td>&#13;
<td><p>100 ns</p></td>&#13;
<td><p>250</p></td>&#13;
<td><p>4 min</p></td>&#13;
<td><p>20 ft</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>SSD</p></td>&#13;
<td><p>100 µs</p></td>&#13;
<td><p>250,000</p></td>&#13;
<td><p>3 days</p></td>&#13;
<td><p>4 miles</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Mag disk</p></td>&#13;
<td><p>10 ms</p></td>&#13;
<td><p>25,000,000</p></td>&#13;
<td><p>9 months</p></td>&#13;
<td><p>400 miles</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Internet: SF→NY</p></td>&#13;
<td><p>65 ms</p></td>&#13;
<td><p>162,500,000</p></td>&#13;
<td><p>5 years</p></td>&#13;
<td><p>2,500 miles</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>It’s a good thing that a CPU instruction&#13;
actually takes less than a nanosecond&#13;
instead of a whole second,&#13;
or else&#13;
you could have a baby in the time it takes&#13;
to access a magnetic disk.&#13;
Because disk and network times are so much slower&#13;
than CPU and RAM,&#13;
it helps to do as much work in memory as you can.&#13;
And since the CPU itself is so much faster than RAM,&#13;
it makes sense to keep data contiguous,&#13;
so the bytes can be served by the faster (but smaller) caches&#13;
closer to the CPU.<a data-startref="ix_appA-computers-asciidoc0" data-type="indexterm" id="idm45794959774536"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Software" data-type="sect1"><div class="sect1" id="idm45794959858808">&#13;
<h1>Software</h1>&#13;
&#13;
<p><a data-primary="software (generally)" data-secondary="basics" data-type="indexterm" id="ix_appA-computers-asciidoc1"/>Given all this computer hardware, how would we control it?&#13;
First, we have both&#13;
<em>instructions</em>&#13;
(stuff that tells the CPU what to do)&#13;
and <em>data</em> (inputs and outputs for the instructions).&#13;
In the&#13;
<em>stored-program computer</em>,&#13;
everything could be treated as data,&#13;
which simplified the design.&#13;
But how do you represent instructions and data?&#13;
What is it that you save in one place&#13;
and process in another?&#13;
The far-flung descendants of caveman Og wanted to know.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="In the Beginning Was the Bit" data-type="sect2"><div class="sect2" id="idm45794959769288">&#13;
<h2>In the Beginning Was the Bit</h2>&#13;
&#13;
<p><a data-primary="software (generally)" data-secondary="bits/bytes" data-type="indexterm" id="idm45794959767944"/>Let’s go back to the idea of a <em>switch</em>:&#13;
something that maintains one of two values.&#13;
These could be on or off,&#13;
high or low voltage,&#13;
positive or negative—just something that can be set, won’t forget,&#13;
and can later provide its value to anyone who asks.&#13;
Integrated circuits gave us a way to integrate&#13;
and connect billions&#13;
of little switches into small chips.</p>&#13;
&#13;
<p><a data-primary="bits" data-type="indexterm" id="idm45794959765832"/>If a switch can have just two values, it can be used to represent&#13;
a <em>bit</em>, or binary digit.&#13;
This could be treated as the tiny integers <code>0</code> and <code>1</code>,&#13;
yes and no, true and false, or anything we want.</p>&#13;
&#13;
<p>However, bits are too small for anything beyond <code>0</code> and <code>1</code>.&#13;
How can we convince bits to represent bigger things?</p>&#13;
&#13;
<p>For an answer, look at your fingers.&#13;
We use only 10 digits (0 through 9) in&#13;
our daily lives, but we make numbers much bigger than 9&#13;
by <em>positional notation</em>.&#13;
If I add <code>1</code> to the number <code>38</code>, the <code>8</code> becomes a <code>9</code>&#13;
and the whole value is now <code>39</code>.&#13;
If I add another <code>1</code>, the <code>9</code> turns into a <code>0</code>&#13;
and I <em>carry the one</em> to the left,&#13;
incrementing the <code>3</code> to a <code>4</code>&#13;
and getting the final number <code>40</code>.&#13;
The far-right number is in the “one’s column,”&#13;
the one to its left is the “ten’s column,”&#13;
and so on to the left,&#13;
multiplying by 10 each time.&#13;
With three decimal digits, you can represent&#13;
a thousand (10 * 10 * 10)&#13;
numbers, from <code>000</code> to <code>999</code>.</p>&#13;
&#13;
<p>We can use positional notation with bits to make&#13;
larger collections of them.&#13;
<a data-primary="bytes" data-type="indexterm" id="idm45794959754056"/>A <em>byte</em> has eight bits, with 2<sup>8</sup> (256) possible bit combinations.&#13;
You can use a byte to store,&#13;
for example,&#13;
small integers <code>0</code> to <code>255</code>&#13;
(you need to save room for a zero in positional <span class="keep-together">notation).</span></p>&#13;
&#13;
<p>A byte looks like eight bits in a row,&#13;
each bit with a value of either <code>0</code> (or off, or false)&#13;
or <code>1</code> (or on, or true).&#13;
The bit on the far right is the <em>least significant</em>,&#13;
and the leftmost one is the <em>most significant</em>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Machine Language" data-type="sect2"><div class="sect2" id="idm45794959748376">&#13;
<h2>Machine Language</h2>&#13;
&#13;
<p><a data-primary="instruction set" data-type="indexterm" id="idm45794959746840"/><a data-primary="machine language" data-type="indexterm" id="idm45794959745912"/><a data-primary="opcodes" data-type="indexterm" id="idm45794959745240"/><a data-primary="software (generally)" data-secondary="machine language" data-type="indexterm" id="idm45794959744568"/>Each computer CPU is designed with an <em>instruction set</em>&#13;
of bit patterns (also called <em>opcodes</em>)&#13;
that it understands.&#13;
Each opcode performs a certain function,&#13;
with input values from one place&#13;
and output values to another place.&#13;
CPUs have special internal places called <em>registers</em>&#13;
to store these opcodes and values.</p>&#13;
&#13;
<p>Let’s use an simplified computer that&#13;
works only with bytes, and has four byte-sized&#13;
registers called <code>A</code>, <code>B</code>, <code>C</code>, and <code>D</code>.&#13;
Assume that:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The command opcode goes into register <code>A</code></p>&#13;
</li>&#13;
<li>&#13;
<p>The command gets its byte inputs from registers <code>B</code> and <code>C</code></p>&#13;
</li>&#13;
<li>&#13;
<p>The command stores its byte result in register <code>D</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>(Adding two bytes could <em>overflow</em> a single byte result,&#13;
but I’m ignoring that here to show what happens where.)</p>&#13;
&#13;
<p>Say that:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Register <code>A</code> contains the opcode for&#13;
<em>add two integers</em>: a decimal <code>1</code>&#13;
(binary <code>00000001</code>).</p>&#13;
</li>&#13;
<li>&#13;
<p>Register <code>B</code> has the decimal value <code>5</code>&#13;
(binary <code>00000101</code>).</p>&#13;
</li>&#13;
<li>&#13;
<p>Register <code>C</code> has the decimal value <code>3</code>&#13;
(binary <code>00000011</code>).</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The CPU sees that an instruction has arrived in register <code>A</code>.&#13;
It decodes and runs that instruction,&#13;
reading values from registers <code>B</code> and <code>C</code>&#13;
and passing them to internal hardware circuits that&#13;
can add bytes.&#13;
When it’s done,&#13;
we should see the decimal value <code>8</code>&#13;
(binary <code>00001000</code>)&#13;
in register <code>D</code>.</p>&#13;
&#13;
<p>The CPU does addition, and other mathematical functions,&#13;
using registers in this way.&#13;
It <em>decodes</em> the opcode and directs control&#13;
to specific circuits within the CPU.&#13;
It can also compare things,&#13;
such as “Is the value in <code>B</code> larger than the value in <code>C</code>?”&#13;
Importantly, it also&#13;
<em>fetches</em> values from memory to CPU&#13;
and <em>stores</em> values from CPU to memory.</p>&#13;
&#13;
<p>The computer stores <em>programs</em> (machine-language instructions&#13;
and data) in memory and handles feeding instructions and data&#13;
to and from the CPU.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Assembler" data-type="sect2"><div class="sect2" id="idm45794959747752">&#13;
<h2>Assembler</h2>&#13;
&#13;
<p><a data-primary="assembly language" data-type="indexterm" id="idm45794959717976"/><a data-primary="software (generally)" data-secondary="assembler" data-type="indexterm" id="idm45794959717272"/>It’s hard to program in machine language.&#13;
You have to get specify every bit perfectly,&#13;
which is very time consuming.&#13;
So, people came up with a slightly more readable&#13;
level of languages called <em>assembly language</em>,&#13;
or just <em>assembler</em>.&#13;
These languages are specific to a CPU design&#13;
and let you use things like variable names&#13;
to define your instruction flow and data.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Higher-Level Languages" data-type="sect2"><div class="sect2" id="idm45794959714760">&#13;
<h2>Higher-Level Languages</h2>&#13;
&#13;
<p><a data-primary="higher-level languages" data-type="indexterm" id="idm45794959713384"/><a data-primary="software (generally)" data-secondary="higher-level languages" data-type="indexterm" id="idm45794959712680"/>Assembler is still a painstaking endeavor,&#13;
so people designed <em>higher-level languages</em>&#13;
that were even easier for people to use.&#13;
These languages would be translated into assembler&#13;
by a program called a <em>compiler</em>,&#13;
or run directly by an <em>interpreter</em>.&#13;
Among the oldest of these languages are&#13;
FORTRAN, LISP, and C—wildly different in design and intended use,&#13;
but similar in their place in computer architecture.</p>&#13;
&#13;
<p>In real jobs you tend to see distinct software “stacks”:</p>&#13;
<dl>&#13;
<dt>Mainframe</dt>&#13;
<dd>&#13;
<p>IBM, COBOL, FORTRAN, and others</p>&#13;
</dd>&#13;
<dt>Microsoft</dt>&#13;
<dd>&#13;
<p>Windows, ASP, C#, SQL Server</p>&#13;
</dd>&#13;
<dt>JVM</dt>&#13;
<dd>&#13;
<p>Java, Scala, Groovy</p>&#13;
</dd>&#13;
<dt>Open source</dt>&#13;
<dd>&#13;
<p>Linux, languages(Python, PHP, Perl, C, C++, Go), databases (MySQL, PostgreSQL), web (apache, nginx)</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Programmers tend to stay in one of these worlds,&#13;
using the languages and tools within it.&#13;
Some technologies, such as TCP/IP and the web,&#13;
allow intercommunication between stacks.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Operating Systems" data-type="sect2"><div class="sect2" id="idm45794959702872">&#13;
<h2>Operating Systems</h2>&#13;
&#13;
<p><a data-primary="operating systems (generally)" data-type="indexterm" id="idm45794959701496"/><a data-primary="software (generally)" data-secondary="operating systems" data-type="indexterm" id="idm45794959700824"/>Each innovation was built&#13;
on those before it,&#13;
and generally we don’t know or care how the lower levels&#13;
even work.&#13;
Tools build tools to build even more tools,&#13;
and we take them for granted.</p>&#13;
&#13;
<p>Tha major operating systems are:</p>&#13;
<dl>&#13;
<dt>Windows (Microsoft)</dt>&#13;
<dd>&#13;
<p>Commercial, many versions</p>&#13;
</dd>&#13;
<dt>macOS (Apple)</dt>&#13;
<dd>&#13;
<p>Commercial</p>&#13;
</dd>&#13;
<dt>Linux</dt>&#13;
<dd>&#13;
<p>Open source</p>&#13;
</dd>&#13;
<dt>Unix</dt>&#13;
<dd>&#13;
<p>Many commercial versions, largely replaced by Linux</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p class="pagebreak-before">An operating system contains:</p>&#13;
<dl>&#13;
<dt>A kernel</dt>&#13;
<dd>&#13;
<p>Schedules and controls programs and I/O</p>&#13;
</dd>&#13;
<dt>Device drivers</dt>&#13;
<dd>&#13;
<p>Used by the kernel to access RAM, disk, and other devices</p>&#13;
</dd>&#13;
<dt>Libraries</dt>&#13;
<dd>&#13;
<p>Source and binary files for use by developers</p>&#13;
</dd>&#13;
<dt>Applications</dt>&#13;
<dd>&#13;
<p>Standalone programs</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>The same computer hardware can support more than one&#13;
operating system, but only one at a time.&#13;
When an operating system starts up,&#13;
it’s called <em>booting</em>,<sup><a data-type="noteref" href="app01.html#idm45794959685624" id="idm45794959685624-marker">1</a></sup>&#13;
so <em>rebooting</em> is restarting it.&#13;
These terms have even appeared in movie marketing,&#13;
as studios “reboot” previous unsuccessful attempts.&#13;
You can <em>dual-boot</em> your computer by installing&#13;
more than one operating system, side by side,&#13;
but only one can be fired up&#13;
and run at a time.</p>&#13;
&#13;
<p><a data-primary="bare metal" data-type="indexterm" id="idm45794959683336"/>If you see the phrase <em>bare metal</em>,&#13;
it means a single computer running an operating system.&#13;
In the next few sections, we step up from bare metal.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Virtual Machines" data-type="sect2"><div class="sect2" id="idm45794959681832">&#13;
<h2>Virtual Machines</h2>&#13;
&#13;
<p><a data-primary="software (generally)" data-secondary="virtual machines" data-type="indexterm" id="idm45794959680632"/><a data-primary="virtual machines" data-type="indexterm" id="idm45794959679656"/>An operating system is sort of a big program,&#13;
so eventually someone figured out how to run&#13;
foreign operating systems as&#13;
<em>virtual machines</em> (guest programs) on <em>host</em> machines.&#13;
So you could have Microsoft Windows running on your PC,&#13;
but fire up a Linux virtual machine atop it at the same time,&#13;
without having to buy a second computer or dual-boot it.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Containers" data-type="sect2"><div class="sect2" id="idm45794959677416">&#13;
<h2>Containers</h2>&#13;
&#13;
<p><a data-primary="containers" data-type="indexterm" id="idm45794959676184"/><a data-primary="software (generally)" data-secondary="containers" data-type="indexterm" id="idm45794959675480"/>A more recent idea is the <em>container</em>—a way to run multiple operating systems at the&#13;
same time, as long as they share the same kernel.&#13;
This idea was popularized by&#13;
<a href="https://www.docker.com">Docker</a>,&#13;
which took some little-known Linux kernel features and&#13;
added useful management features.&#13;
Their analogy to shipping containers&#13;
(which revolutionized shipping and saved money for all of us)&#13;
was clear and appealing.&#13;
By releasing the code as open-source,&#13;
Docker enabled containers to be adopted very quickly&#13;
throughout the computer industry.</p>&#13;
&#13;
<p>Google and other cloud providers had been quietly&#13;
adding the underlying kernel support to Linux for years,&#13;
and using containers in their data centers.&#13;
Containers use fewer resources than&#13;
virtual machines, letting you pack more programs into&#13;
each physical computer box.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Distributed Computing and Networks" data-type="sect2"><div class="sect2" id="idm45794959671880">&#13;
<h2>Distributed Computing and Networks</h2>&#13;
&#13;
<p><a data-primary="distributed computing" data-type="indexterm" id="idm45794959670536"/><a data-primary="networks/networking" data-secondary="basics" data-type="indexterm" id="idm45794959669832"/><a data-primary="software (generally)" data-secondary="distributed computing/networks" data-type="indexterm" id="idm45794959668888"/>When businesses first started using personal computers,&#13;
they needed ways to make them talk to each other as well as to devices like printers.&#13;
Proprietary networking software, such as Novell’s,&#13;
was originally used,&#13;
but was eventually replaced by TCP/IP as the internet&#13;
emerged in the mid- to late 90s.&#13;
Microsoft grabbed its TCP/IP stack from a free Unix variant&#13;
called&#13;
<em>BSD</em>.<sup><a data-type="noteref" href="app01.html#idm45794959667080" id="idm45794959667080-marker">2</a></sup></p>&#13;
&#13;
<p><a data-primary="servers" data-type="indexterm" id="idm45794959666120"/>One effect of the internet boom was a demand for <em>servers</em>:&#13;
machines and software to run all those web, chat,&#13;
and email services.&#13;
The old style of <em>sysadmin</em> (system administration)&#13;
was to install and manage all the hardware and software&#13;
manually.&#13;
Before long, it became clear to everyone that automation&#13;
was needed.&#13;
In 2006, Bill Baker at Microsoft came up with&#13;
the <em>pets versus cattle</em> analogy for server management,&#13;
and it has since&#13;
become an industry meme&#13;
(sometimes as <em>pets versus livestock</em>, to be more generic); see <a data-type="xref" href="#tableA2">Table A-2</a>.</p>&#13;
<table id="tableA2">&#13;
<caption><span class="label">Table A-2. </span>Pets versus livestock</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Pets</th>&#13;
<th>Livestock</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Individually named</p></td>&#13;
<td><p>Automatically numbered</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Customized care</p></td>&#13;
<td><p>Standardized</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Nurse back to health</p></td>&#13;
<td><p>Replace</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>You’ll often see, as a successor to “sysadmin,”&#13;
the term <em>DevOps</em>: development&#13;
plus operations, a mixture of techniques to support&#13;
rapid changes to services without blowing them up.&#13;
Cloud services are extremely large and complex,&#13;
and even the big companies like Amazon and Google&#13;
have outages now and then.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Cloud" data-type="sect2"><div class="sect2" id="idm45794959652632">&#13;
<h2>The Cloud</h2>&#13;
&#13;
<p><a data-primary="cloud computing" data-type="indexterm" id="idm45794959651432"/><a data-primary="clusters" data-type="indexterm" id="idm45794959650728"/><a data-primary="software (generally)" data-secondary="cloud computing" data-type="indexterm" id="idm45794959650056"/>People had been building computer <em>clusters</em> for a number&#13;
of years, using many technologies.&#13;
<a data-primary="Beowulf cluster" data-type="indexterm" id="idm45794959648536"/>One early concept was a <em>Beowulf cluster</em>:&#13;
identical commodity computers (Dell or something similar,&#13;
instead of workstations like Sun or HP),&#13;
linked by a local network.</p>&#13;
&#13;
<p>The term <em>cloud computing</em> means using the computers&#13;
in data centers to perform computing jobs and store data—but not just for the company that owned these backend resources.&#13;
The services are provided to anyone, with fees based&#13;
on CPU time, disk storage amounts, and so on.&#13;
Amazon and its <em>AWS</em> (Amazon Web Services) is the most prominent,&#13;
but <em>Azure</em> (Microsoft) and <em>Google Cloud</em> are&#13;
also biggies.</p>&#13;
&#13;
<p>Behind the scenes, these clouds use bare metal,&#13;
virtual machines, and containers—all treated as livestock, not pets.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Kubernetes" data-type="sect2"><div class="sect2" id="idm45794959643848">&#13;
<h2>Kubernetes</h2>&#13;
&#13;
<p><a data-primary="Kubernetes" data-type="indexterm" id="idm45794959642472"/><a data-primary="software (generally)" data-secondary="Kubernetes" data-type="indexterm" id="idm45794959641768"/>Companies that needed to manage huge clusters&#13;
of computers in many data centers—like Google, Amazon, and Facebook—have all borrowed or built solutions to help them scale:</p>&#13;
<dl>&#13;
<dt>Deployment</dt>&#13;
<dd>&#13;
<p>How do you make new computing hardware and software available?&#13;
How do you replace them when they fail?</p>&#13;
</dd>&#13;
<dt>Configuration</dt>&#13;
<dd>&#13;
<p>How should these systems run?&#13;
They need things like the names and addresses&#13;
of other computers, passwords, and security settings.</p>&#13;
</dd>&#13;
<dt>Orchestration</dt>&#13;
<dd>&#13;
<p>How do you manage all these computers, virtual machines,&#13;
and containers?&#13;
Can you scale up or down to adjust to load changes?</p>&#13;
</dd>&#13;
<dt>Service Discovery</dt>&#13;
<dd>&#13;
<p>How do you find out who does what, and where it is?</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Some competing solutions were built by Docker and others.&#13;
But just in the past few years,&#13;
it looks like the battle has been won by&#13;
<a href="http://kubernetes.io">Kubernetes</a>.</p>&#13;
&#13;
<p>Google had developed large internal management frameworks,&#13;
codenamed&#13;
Borg and Omega.&#13;
When employees brought up the idea of open sourcing&#13;
these “crown jewels,”&#13;
management had to think about it a bit,&#13;
but they took the leap.&#13;
Google released Kubernetes version 1.0 in 2015,&#13;
and its ecosystem and influence have grown ever since.<a data-startref="ix_appA-computers-asciidoc1" data-type="indexterm" id="idm45794959632232"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45794959685624"><sup><a href="app01.html#idm45794959685624-marker">1</a></sup> This refers to “Lifting yourself by your own bootstraps,” which seems just as improbable as a computer.</p><p data-type="footnote" id="idm45794959667080"><sup><a href="app01.html#idm45794959667080-marker">2</a></sup> You can still see the copyright notices for the University of California in some Microsoft files.</p></div></div></section></body></html>