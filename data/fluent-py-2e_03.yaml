- en: Chapter 2\. An Array of Sequences
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章：序列之阵
- en: As you may have noticed, several of the operations mentioned work equally for
    texts, lists and tables. Texts, lists and tables together are called ‘trains’.
    [...] The `FOR` command also works generically on trains.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可能已经注意到，提到的几个操作同样适用于文本、列表和表格。文本、列表和表格统称为 "序列"。[...] `FOR` 命令也可以通用地作用于序列。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Leo Geurts, Lambert Meertens, and Steven Pembertonm, *ABC Programmer’s Handbook*^([1](ch02.html#idm46582497439616))
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Leo Geurts、Lambert Meertens 和 Steven Pembertonm，*ABC Programmer's Handbook*^([1](ch02.html#idm46582497439616))
- en: 'Before creating Python, Guido was a contributor to the ABC language—a 10-year
    research project to design a programming environment for beginners. ABC introduced
    many ideas we now consider “Pythonic”: generic operations on different types of
    sequences, built-in tuple and mapping types, structure by indentation, strong
    typing without variable declarations, and more. It’s no accident that Python is
    so user-friendly.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 Python 之前，Guido 曾是 ABC 语言的贡献者——一个为初学者设计编程环境的 10 年研究项目。ABC 引入了许多我们现在认为 "Pythonic"
    的想法：对不同类型序列的通用操作、内置元组和映射类型、缩进结构、无需变量声明的强类型等等。Python 如此用户友好并非偶然。
- en: Python inherited from ABC the uniform handling of sequences. Strings, lists,
    byte sequences, arrays, XML elements, and database results share a rich set of
    common operations, including iteration, slicing, sorting, and concatenation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Python 从 ABC 继承了对序列的统一处理。字符串、列表、字节序列、数组、XML 元素和数据库结果共享一组丰富的通用操作，包括迭代、切片、排序和连接。
- en: Understanding the variety of sequences available in Python saves us from reinventing
    the wheel, and their common interface inspires us to create APIs that properly
    support and leverage existing and future sequence types.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 Python 中可用的各种序列可以节省我们重复发明轮子的时间，它们的通用接口激励我们创建正确支持和利用现有和未来序列类型的 API。
- en: Most of the discussion in this chapter applies to sequences in general, from
    the familiar `list` to the `str` and `bytes` types added in Python 3. Specific
    topics on lists, tuples, arrays, and queues are also covered here, but the specifics
    of Unicode strings and byte sequences appear in [Chapter 4](ch04.html#strings_bytes_files).
    Also, the idea here is to cover sequence types that are ready to use. Creating
    your own sequence types is the subject of [Chapter 12](ch12.html#user_defined_sequences).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章大部分讨论适用于一般的序列，从熟悉的 `list` 到 Python 3 中新增的 `str` 和 `bytes` 类型。这里还涵盖了列表、元组、数组和队列的具体主题，但
    Unicode 字符串和字节序列的详细信息出现在 [第 4 章](ch04.html#strings_bytes_files)。此外，这里的想法是涵盖已准备好使用的序列类型。创建你自己的序列类型是
    [第 12 章](ch12.html#user_defined_sequences) 的主题。
- en: 'These are the main topics this chapter will cover:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将主要涵盖以下主题：
- en: List comprehensions and the basics of generator expressions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表推导式和生成器表达式基础
- en: Using tuples as records versus using tuples as immutable lists
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将元组用作记录与将元组用作不可变列表
- en: Sequence unpacking and sequence patterns
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列解包和序列模式
- en: Reading from slices and writing to slices
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从切片读取和向切片写入
- en: Specialized sequence types, like arrays and queues
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专门的序列类型，如数组和队列
- en: What’s New in This Chapter
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章的更新内容
- en: The most important update in this chapter is [“Pattern Matching with Sequences”](#sequence_patterns_sec).
    That’s the first time the new pattern matching feature of Python 3.10 appears
    in this second edition.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最重要的更新是 ["使用序列进行模式匹配"](#sequence_patterns_sec)。这是 Python 3.10 的新模式匹配特性在第二版中首次出现。
- en: 'Other changes are not updates but improvements over the first edition:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 其他变化不是更新，而是对第一版的改进：
- en: New diagram and description of the internals of sequences, contrasting containers
    and flat sequences
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列内部结构的新图和描述，对比容器和扁平序列
- en: Brief comparison of the performance and storage characteristics of `list` versus
    `tuple`
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简要比较 `list` 和 `tuple` 的性能和存储特性
- en: Caveats of tuples with mutable elements, and how to detect them if needed
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含可变元素的元组的注意事项，以及如何在需要时检测它们
- en: I moved coverage of named tuples to [“Classic Named Tuples”](ch05.html#classic_named_tuples_sec)
    in [Chapter 5](ch05.html#data_class_ch), where they are compared to `typing.NamedTuple`
    and `@dataclass`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我将命名元组的介绍移至 [第 5 章](ch05.html#data_class_ch) 的 ["经典命名元组"](ch05.html#classic_named_tuples_sec)，在那里它们与
    `typing.NamedTuple` 和 `@dataclass` 进行了比较。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: To make room for new content and keep the page count within reason, the section
    “Managing Ordered Sequences with Bisect” from the first edition is now a [post](https://fpy.li/bisect)
    in the [*fluentpython.com*](http://fluentpython.com) companion website.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给新内容腾出空间并将页数控制在合理范围内，第一版中的 "使用 Bisect 管理有序序列" 一节现在是 [*fluentpython.com*](http://fluentpython.com)
    配套网站中的一篇[文章](https://fpy.li/bisect)。
- en: Overview of Built-In Sequences
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置序列概述
- en: 'The standard library offers a rich selection of sequence types implemented
    in C:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了丰富的用 C 实现的序列类型选择：
- en: Container sequences
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 容器序列
- en: 'Can hold items of different types, including nested containers. Some examples:
    `list`, `tuple`, and `collections.deque`.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可以容纳不同类型的项目，包括嵌套容器。一些示例：`list`、`tuple` 和 `collections.deque`。
- en: Flat sequences
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 扁平序列
- en: 'Hold items of one simple type. Some examples: `str`, `bytes`, and `array.array`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 持有一种简单类型的项目。一些示例：`str`、`bytes` 和 `array.array`。
- en: A *container sequence* holds references to the objects it contains, which may
    be of any type, while a *flat sequence* stores the value of its contents in its
    own memory space, not as distinct Python objects. See [Figure 2-1](#container_v_flat_img).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*容器序列*存储对其所包含的对象的引用，这些对象可以是任何类型，而*扁平序列*则在其自身的内存空间中存储其内容的值，而不是作为独立的 Python 对象。参见[图
    2-1](#container_v_flat_img)。'
- en: '![Simplified memory diagram of an `array` and a `tuple`](assets/flpy_0201.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![`array` 和 `tuple` 的简化内存图](assets/flpy_0201.png)'
- en: Figure 2-1\. Simplified memory diagrams for a `tuple` and an `array`, each with
    three items. Gray cells represent the in-memory header of each Python object—not
    drawn to proportion. The `tuple` has an array of references to its items. Each
    item is a separate Python object, possibly holding references to other Python
    objects, like that two-item list. In contrast, the Python `array` is a single
    object, holding a C language array of three doubles.
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. 一个`tuple`和一个`array`的简化内存图，每个包含三个项目。灰色单元格表示每个 Python 对象的内存头——没有按比例绘制。`tuple`有一个对其项目的引用数组。每个项目都是一个单独的
    Python 对象，可能包含对其他 Python 对象的引用，比如那个两个项目的列表。相比之下，Python `array`是一个单一的对象，包含一个 C
    语言的三个 double 数组。
- en: Thus, flat sequences are more compact, but they are limited to holding primitive
    machine values like bytes, integers, and floats.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，扁平序列更紧凑，但它们仅限于保存字节、整数和浮点数等原始机器值。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Every Python object in memory has a header with metadata. The simplest Python
    object, a `float`, has a value field and two metadata fields:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 内存中的每个 Python 对象都有一个带有元数据的头部。最简单的 Python 对象`float`有一个值字段和两个元数据字段：
- en: '`ob_refcnt`: the object’s reference count'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ob_refcnt`：对象的引用计数'
- en: '`ob_type`: a pointer to the object’s type'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ob_type`：指向对象类型的指针'
- en: '`ob_fval`: a C `double` holding the value of the `float`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ob_fval`：一个 C `double`，用于保存`float`的值'
- en: 'On a 64-bit Python build, each of those fields takes 8 bytes. That’s why an
    array of floats is much more compact than a tuple of floats: the array is a single
    object holding the raw values of the floats, while the tuple consists of several
    objects—the tuple itself and each `float` object contained in it.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 64 位 Python 构建中，这些字段中的每一个都占用 8 个字节。这就是为什么一个浮点数组比一个浮点元组更紧凑：数组是一个单一的对象，包含浮点数的原始值，而元组由多个对象组成——元组本身和其中包含的每个`float`对象。
- en: 'Another way of grouping sequence types is by mutability:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对序列类型进行分组的另一种方式是按可变性：
- en: Mutable sequences
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可变序列
- en: For example, `list`, `bytearray`, `array.array`, and `collections.deque`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，`list`、`bytearray`、`array.array`和`collections.deque`。  '
- en: Immutable sequences
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变序列
- en: For example, `tuple`, `str`, and `bytes`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`tuple`、`str`和`bytes`。
- en: '[Figure 2-2](#sequence_uml) helps visualize how mutable sequences inherit all
    methods from immutable sequences, and implement several additional methods. The
    built-in concrete sequence types do not actually subclass the `Sequence` and `MutableSequence`
    abstract base classes (ABCs), but they are *virtual subclasses* registered with
    those ABCs—as we’ll see in [Chapter 13](ch13.html#ifaces_prot_abc). Being virtual
    subclasses, `tuple` and `list` pass these tests:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-2](#sequence_uml)有助于可视化可变序列如何继承不可变序列的所有方法，并实现几个额外的方法。内置的具体序列类型实际上并没有子类化`Sequence`和`MutableSequence`抽象基类（ABC），但它们是注册到这些
    ABC 的*虚拟子类*——我们将在[第 13 章](ch13.html#ifaces_prot_abc)中看到。作为虚拟子类，`tuple`和`list`通过了这些测试：'
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![UML class diagram for `Sequence` and `MutableSequence`](assets/flpy_0202.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![`Sequence`和`MutableSequence`的 UML 类图](assets/flpy_0202.png)'
- en: Figure 2-2\. Simplified UML class diagram for some classes from collections.abc
    (superclasses are on the left; inheritance arrows point from subclasses to superclasses;
    names in italic are abstract classes and abstract methods).
  id: totrans-47
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-2\.collections.abc 中一些类的简化 UML 类图（超类在左侧；继承箭头从子类指向超类；斜体名称是抽象类和抽象方法）。
- en: 'Keep in mind these common traits: mutable versus immutable; container versus
    flat. They are helpful to extrapolate what you know about one sequence type to
    others.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这些共同特征：可变与不可变；容器与扁平。它们有助于将你对一种序列类型的了解推广到其他类型。
- en: 'The most fundamental sequence type is the `list`: a mutable container. I expect
    you are very familiar with lists, so we’ll jump right into list comprehensions,
    a powerful way of building lists that is sometimes underused because the syntax
    may look unusual at first. Mastering list comprehensions opens the door to generator
    expressions, which—among other uses—can produce elements to fill up sequences
    of any type. Both are the subject of the next section.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的序列类型是`list`：一个可变容器。我希望你非常熟悉列表，所以我们将直接进入列表推导式，这是一种构建列表的强大方式，但有时会因为语法一开始看起来不寻常而被低估。掌握列表推导式为生成器表达式打开了大门，生成器表达式除了其他用途外，还可以生成元素来填充任何类型的序列。这两者都是下一节的主题。
- en: List Comprehensions and Generator Expressions
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表推导式和生成器表达式
- en: A quick way to build a sequence is using a list comprehension (if the target
    is a `list`) or a generator expression (for other kinds of sequences). If you
    are not using these syntactic forms on a daily basis, I bet you are missing opportunities
    to write code that is more readable and often faster at the same time.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 构建序列的一个快速方法是使用列表推导式（如果目标是`list`）或生成器表达式（对于其他类型的序列）。如果你没有每天使用这些语法形式，我敢打赌你正在错失编写更易读且通常更快的代码的机会。
- en: If you doubt my claim that these constructs are “more readable,” read on. I’ll
    try to convince you.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你怀疑我声称这些构造"更具可读性"，请继续阅读。我会试着说服你。
- en: Tip
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: For brevity, many Python programmers refer to list comprehensions as *listcomps*,
    and generator expressions as *genexps*. I will use these words as well.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，许多 Python 程序员将列表推导式称为*listcomps*，将生成器表达式称为*genexps*。我也会使用这些词。
- en: List Comprehensions and Readability
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表推导式和可读性
- en: 'Here is a test: which do you find easier to read, [Example 2-1](#ex_build_list)
    or [Example 2-2](#ex_listcomp0)?'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个测试：你觉得[示例 2-1](#ex_build_list)和[示例 2-2](#ex_listcomp0)哪个更易读？
- en: Example 2-1\. Build a list of Unicode code points from a string
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-1\. 从字符串构建 Unicode 码点列表
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Example 2-2\. Build a list of Unicode code points from a string, using a listcomp
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-2\. 使用列表推导式从字符串构建 Unicode 码点列表
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Anybody who knows a little bit of Python can read [Example 2-1](#ex_build_list).
    However, after learning about listcomps, I find [Example 2-2](#ex_listcomp0) more
    readable because its intent is explicit.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 任何稍微了解 Python 的人都可以读懂[示例 2-1](#ex_build_list)。然而，在学习了列表推导式之后，我发现[示例 2-2](#ex_listcomp0)更具可读性，因为它的意图很明确。
- en: 'A `for` loop may be used to do lots of different things: scanning a sequence
    to count or pick items, computing aggregates (sums, averages), or any number of
    other tasks. The code in [Example 2-1](#ex_build_list) is building up a list.
    In contrast, a listcomp is more explicit. Its goal is always to build a new list.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环可用于执行许多不同的事情：扫描序列以计数或选择项目、计算聚合（总和、平均值）或任何其他任务。[示例2-1](#ex_build_list)中的代码正在构建一个列表。相比之下，列表推导式更加明确。它的目标总是构建一个新列表。'
- en: 'Of course, it is possible to abuse list comprehensions to write truly incomprehensible
    code. I’ve seen Python code with listcomps used just to repeat a block of code
    for its side effects. If you are not doing something with the produced list, you
    should not use that syntax. Also, try to keep it short. If the list comprehension
    spans more than two lines, it is probably best to break it apart or rewrite it
    as a plain old `for` loop. Use your best judgment: for Python, as for English,
    there are no hard-and-fast rules for clear writing.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也可能滥用列表推导式来编写真正难以理解的代码。我见过Python代码，其中列表推导式仅用于重复代码块以产生副作用。如果你不对生成的列表做任何事情，就不应该使用该语法。此外，尽量保持简短。如果列表推导式跨越两行以上，最好将其拆开或重写为普通的`for`循环。运用你的最佳判断：对于Python，就像对于英语一样，没有明确的清晰写作规则。
- en: Syntax Tip
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法提示
- en: In Python code, line breaks are ignored inside pairs of `[]`, `{}`, or `()`.
    So you can build multiline lists, listcomps, tuples, dictionaries, etc., without
    using the `\` line continuation escape, which doesn’t work if you accidentally
    type a space after it. Also, when those delimiter pairs are used to define a literal
    with a comma-separated series of items, a trailing comma will be ignored. So,
    for example, when coding a multiline list literal, it is thoughtful to put a comma
    after the last item, making it a little easier for the next coder to add one more
    item to that list, and reducing noise when reading diffs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python代码中，在`[]`、`{}`或`()`对之间的换行符会被忽略。因此，你可以构建多行列表、列表推导式、元组、字典等，而无需使用`\`换行转义符，如果不小心在其后键入空格，它将不起作用。此外，当这些分隔符对用于定义包含以逗号分隔的一系列项的字面量时，尾随逗号将被忽略。因此，例如，在编写多行列表字面量时，在最后一项后面加上逗号是很周到的，这会让下一个编码者更容易向该列表添加一个项目，并在阅读差异时减少噪音。
- en: List comprehensions build lists from sequences or any other iterable type by
    filtering and transforming items. The `filter` and `map` built-ins can be composed
    to do the same, but readability suffers, as we will see next.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式通过过滤和转换项目从序列或任何其他可迭代类型构建列表。内置的`filter`和`map`可以组合起来做同样的事情，但可读性会受到影响，我们接下来会看到。
- en: Listcomps Versus map and filter
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列表推导式与map和filter的对比
- en: Listcomps do everything the `map` and `filter` functions do, without the contortions
    of the functionally challenged Python `lambda`. Consider [Example 2-3](#ex_listcomp_x_filter_map).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '列表推导式可以完成`map`和`filter`函数所做的一切，而无需功能受限的Python `lambda`的扭曲。考虑[示例2-3](#ex_listcomp_x_filter_map)。  '
- en: Example 2-3\. The same list built by a listcomp and a map/filter composition
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例2-3. 通过列表推导式和map/filter组合构建的相同列表
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I used to believe that `map` and `filter` were faster than the equivalent listcomps,
    but Alex Martelli pointed out that’s not the case—at least not in the preceding
    examples. The [*02-array-seq/listcomp_speed.py*](https://fpy.li/2-1) script in
    [the *Fluent Python* code repository](https://fpy.li/code) is a simple speed test
    comparing listcomp with `filter/map`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经认为`map`和`filter`比等效的列表推导式更快，但Alex Martelli指出事实并非如此——至少在前面的示例中不是。[*Fluent
    Python*代码仓库](https://fpy.li/code)中的[*02-array-seq/listcomp_speed.py*](https://fpy.li/2-1)脚本是一个简单的速度测试，比较了列表推导式与`filter/map`。
- en: 'I’ll have more to say about `map` and `filter` in [Chapter 7](ch07.html#functions_as_objects).
    Now we turn to the use of listcomps to compute Cartesian products: a list containing
    tuples built from all items from two or more lists.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html#functions_as_objects)中，我将对`map`和`filter`进行更多说明。现在我们来看看如何使用列表推导式计算笛卡尔积：一个包含由两个或多个列表中所有项构建的元组的列表。
- en: Cartesian Products
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 笛卡尔积
- en: Listcomps can build lists from the Cartesian product of two or more iterables.
    The items that make up the Cartesian product are tuples made from items from every
    input iterable. The resulting list has a length equal to the lengths of the input
    iterables multiplied. See [Figure 2-3](#cartesian_product_fig).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式可以从两个或多个可迭代对象的笛卡尔积构建列表。构成笛卡尔积的项是由每个输入可迭代对象的项构成的元组。结果列表的长度等于输入可迭代对象的长度相乘。参见[图2-3](#cartesian_product_fig)。
- en: '![Cartesian product diagram](assets/flpy_0203.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![笛卡尔积示意图](assets/flpy_0203.png)  '
- en: Figure 2-3\. The Cartesian product of 3 card ranks and 4 suits is a sequence
    of 12 pairings.
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-3. 3个牌面和4个花色的笛卡尔积是由12对组成的序列。
- en: For example, imagine you need to produce a list of T-shirts available in two
    colors and three sizes. [Example 2-4](#ex_listcomp_cartesian) shows how to produce
    that list using a listcomp. The result has six items.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你需要生成一个包含两种颜色和三种尺寸的T恤列表。[示例2-4](#ex_listcomp_cartesian)展示了如何使用列表推导式生成该列表。结果有六个项目。
- en: Example 2-4\. Cartesian product using a list comprehension
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例2-4. 使用列表推导式的笛卡尔积
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_an_array_of_sequences_CO2-1)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_an_array_of_sequences_CO2-1)'
- en: This generates a list of tuples arranged by color, then size.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这会生成一个按颜色再按大小排列的元组列表。
- en: '[![2](assets/2.png)](#co_an_array_of_sequences_CO2-2)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_an_array_of_sequences_CO2-2)'
- en: Note how the resulting list is arranged as if the `for` loops were nested in
    the same order as they appear in the listcomp.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意结果列表的排列方式，就好像`for`循环按照它们在列表推导式中出现的顺序嵌套一样。
- en: '[![3](assets/3.png)](#co_an_array_of_sequences_CO2-3)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_an_array_of_sequences_CO2-3)'
- en: To get items arranged by size, then color, just rearrange the `for` clauses;
    adding a line break to the listcomp makes it easier to see how the result will
    be ordered.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要按大小再按颜色排列项目，只需重新排列`for`子句；在列表推导式中添加一个换行，可以更容易地看出结果的排序方式。
- en: 'In [Example 1-1](ch01.html#ex_pythonic_deck) ([Chapter 1](ch01.html#data_model)),
    I used the following expression to initialize a card deck with a list made of
    52 cards from all 13 ranks of each of the 4 suits, sorted by suit, then rank:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 1-1](ch01.html#ex_pythonic_deck)（[第 1 章](ch01.html#data_model)）中，我使用以下表达式初始化一副由
    4 种花色的 13 种牌面组成的 52 张牌的扑克牌，按花色和点数排序：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listcomps are a one-trick pony: they build lists. To generate data for other
    sequence types, a genexp is the way to go. The next section is a brief look at
    genexps in the context of building sequences that are not lists.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式是一招鲜吃遍天：它们构建列表。要为其他序列类型生成数据，生成器表达式是不二之选。下一节将简要介绍在构建非列表序列的上下文中使用生成器表达式。
- en: Generator Expressions
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器表达式
- en: To initialize tuples, arrays, and other types of sequences, you could also start
    from a listcomp, but a genexp (generator expression) saves memory because it yields
    items one by one using the iterator protocol instead of building a whole list
    just to feed another constructor.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化元组、数组和其他类型的序列，你也可以从列表推导式开始，但生成器表达式可以节省内存，因为它使用迭代器协议一个接一个地产生项目，而不是构建一个完整的列表来馈送另一个构造函数。
- en: Genexps use the same syntax as listcomps, but are enclosed in parentheses rather
    than brackets.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式使用与列表推导式相同的语法，但用括号括起来，而不是方括号。
- en: '[Example 2-5](#ex_genexp_load) shows basic usage of genexps to build a tuple
    and an array.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2-5](#ex_genexp_load) 展示了使用生成器表达式构建元组和数组的基本用法。'
- en: Example 2-5\. Initializing a tuple and an array from a generator expression
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-5. 从生成器表达式初始化元组和数组
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_an_array_of_sequences_CO3-1)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_an_array_of_sequences_CO3-1)'
- en: If the generator expression is the single argument in a function call, there
    is no need to duplicate the enclosing parentheses.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果生成器表达式是函数调用中的唯一参数，则不需要复制括号。
- en: '[![2](assets/2.png)](#co_an_array_of_sequences_CO3-2)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_an_array_of_sequences_CO3-2)'
- en: The `array` constructor takes two arguments, so the parentheses around the generator
    expression are mandatory. The first argument of the `array` constructor defines
    the storage type used for the numbers in the array, as we’ll see in [“Arrays”](#arrays_sec).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`array` 构造函数接受两个参数，因此生成器表达式周围的括号是必需的。`array` 构造函数的第一个参数定义了用于数组中数字的存储类型，我们将在["数组"](#arrays_sec)中看到。'
- en: '[Example 2-6](#ex_genexp_cartesian) uses a genexp with a Cartesian product
    to print out a roster of T-shirts of two colors in three sizes. In contrast with
    [Example 2-4](#ex_listcomp_cartesian), here the six-item list of T-shirts is never
    built in memory: the generator expression feeds the `for` loop producing one item
    at a time. If the two lists used in the Cartesian product had a thousand items
    each, using a generator expression would save the cost of building a list with
    a million items just to feed the `for` loop.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2-6](#ex_genexp_cartesian) 使用笛卡尔积中的生成器表达式打印出三种尺寸两种颜色的T恤衫名册。与[示例 2-4](#ex_listcomp_cartesian)
    相比，这里从未在内存中构建六个T恤衫的列表：生成器表达式每次产生一个项目来馈送 `for` 循环。如果笛卡尔积中使用的两个列表每个都有一千个项目，使用生成器表达式就可以节省构建一个包含一百万个项目的列表的成本，而这个列表只是用来馈送
    `for` 循环。'
- en: Example 2-6\. Cartesian product in a generator expression
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-6. 生成器表达式中的笛卡尔积
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_an_array_of_sequences_CO4-1)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_an_array_of_sequences_CO4-1) '
- en: The generator expression yields items one by one; a list with all six T-shirt
    variations is never produced in this example.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式一个接一个地产生项目；在此示例中，从未生成包含所有六种T恤衫变体的列表。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '[Chapter 17](ch17.html#iterables2generators) explains how generators work in
    detail. Here the idea was just to show the use of generator expressions to initialize
    sequences other than lists, or to produce output that you don’t need to keep in
    memory.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 17 章](ch17.html#iterables2generators)详细解释了生成器的工作原理。这里的想法只是展示如何使用生成器表达式来初始化列表以外的序列，或生成不需要保存在内存中的输出。'
- en: 'Now we move on to the other fundamental sequence type in Python: the tuple.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们继续讨论 Python 中另一个基本的序列类型：元组。
- en: Tuples Are Not Just Immutable Lists
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组不仅仅是不可变的列表
- en: 'Some introductory texts about Python present tuples as “immutable lists,” but
    that is short selling them. Tuples do double duty: they can be used as immutable
    lists and also as records with no field names. This use is sometimes overlooked,
    so we will start with that.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一些介绍 Python 的入门文本将元组描述为"不可变的列表"，但这并没有充分利用它们。元组具有双重功能：它们可以用作不可变列表，也可以用作没有字段名的记录。这种用法有时会被忽略，所以我们将从这里开始。
- en: Tuples as Records
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组作为记录
- en: 'Tuples hold records: each item in the tuple holds the data for one field, and
    the position of the item gives its meaning.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 元组保存记录：元组中的每一项保存一个字段的数据，项目的位置赋予了它含义。
- en: If you think of a tuple just as an immutable list, the quantity and the order
    of the items may or may not be important, depending on the context. But when using
    a tuple as a collection of fields, the number of items is usually fixed and their
    order is always important.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将元组视为不可变列表，则根据上下文，项目的数量和顺序可能重要，也可能不重要。但是在将元组用作字段集合时，项目的数量通常是固定的，它们的顺序始终很重要。
- en: '[Example 2-7](#ex_tuples_as_records) shows tuples used as records. Note that
    in every expression, sorting the tuple would destroy the information because the
    meaning of each field is given by its position in the tuple.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2-7](#ex_tuples_as_records) 显示了用作记录的元组。请注意，在每个表达式中，对元组进行排序都会破坏信息，因为每个字段的含义由其在元组中的位置给出。'
- en: Example 2-7\. Tuples used as records
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-7. 元组用作记录
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_an_array_of_sequences_CO5-1)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_an_array_of_sequences_CO5-1)'
- en: Latitude and longitude of the Los Angeles International Airport.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 洛杉矶国际机场的纬度和经度。
- en: '[![2](assets/2.png)](#co_an_array_of_sequences_CO5-2)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_an_array_of_sequences_CO5-2)'
- en: 'Data about Tokyo: name, year, population (thousands), population change (%),
    and area (km²).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 关于东京的数据：名称、年份、人口（千人）、人口变化（%）和面积（平方公里）。
- en: '[![3](assets/3.png)](#co_an_array_of_sequences_CO5-3)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_an_array_of_sequences_CO5-3)'
- en: A list of tuples of the form `(country_code, passport_number)`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 形式为 `(country_code, passport_number)` 的元组列表。
- en: '[![4](assets/4.png)](#co_an_array_of_sequences_CO5-4)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_an_array_of_sequences_CO5-4)'
- en: As we iterate over the list, `passport` is bound to each tuple.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遍历列表时，`passport`绑定到每个元组。
- en: '[![5](assets/5.png)](#co_an_array_of_sequences_CO5-5)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_an_array_of_sequences_CO5-5)'
- en: The `%` formatting operator understands tuples and treats each item as a separate
    field.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`%`格式化运算符理解元组，并将每个项视为单独的字段。'
- en: '[![6](assets/6.png)](#co_an_array_of_sequences_CO5-6)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_an_array_of_sequences_CO5-6)  '
- en: The `for` loop knows how to retrieve the items of a tuple separately—this is
    called “unpacking.” Here we are not interested in the second item, so we assign
    it to `_`, a dummy variable.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环知道如何分别检索元组的项，这称为"解包"。这里我们对第二个项不感兴趣，所以将其赋值给虚拟变量`_`。  '
- en: Tip
  id: totrans-127
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: In general, using `_` as a dummy variable is just a convention. It’s just a
    strange but valid variable name. However, in a `match/case` statement, `_` is
    a wildcard that matches any value but is not bound to a value. See [“Pattern Matching
    with Sequences”](#sequence_patterns_sec). And in the Python console, the result
    of the preceding command is assigned to `_`—unless the result is `None`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用`_`作为虚拟变量只是一种约定。它只是一个奇怪但有效的变量名。但是，在`match/case`语句中，`_`是一个通配符，可以匹配任何值，但不会绑定到一个值。参见["使用序列进行模式匹配"](#sequence_patterns_sec)。在Python控制台中，前一个命令的结果被赋值给`_`，除非结果是`None`。
- en: We often think of records as data structures with named fields. [Chapter 5](ch05.html#data_class_ch)
    presents two ways of creating tuples with named fields.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常认为记录是具有命名字段的数据结构。[第5章](ch05.html#data_class_ch)介绍了两种创建具有命名字段的元组的方法。
- en: But often, there’s no need to go through the trouble of creating a class just
    to name the fields, especially if you leverage unpacking and avoid using indexes
    to access the fields. In [Example 2-7](#ex_tuples_as_records), we assigned `('Tokyo',
    2003, 32_450, 0.66, 8014)` to `city, year, pop, chg, area` in a single statement.
    Then, the `%` operator assigned each item in the `passport` tuple to the corresponding
    slot in the format string in the `print` argument. Those are two examples of *tuple
    unpacking*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 但通常没有必要费力创建一个类来命名字段，尤其是如果你利用解包并避免使用索引访问字段。在[示例2-7](#ex_tuples_as_records)中，我们在一条语句中将`('Tokyo',
    2003, 32_450, 0.66, 8014)`赋值给`city, year, pop, chg, area`。然后，`%`运算符将`passport`元组中的每一项分配给`print`参数中格式字符串的相应位置。这是*元组解包*的两个例子。
- en: Note
  id: totrans-131
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The term *tuple unpacking* is widely used by Pythonistas, but *iterable unpacking*
    is gaining traction, as in the title of [PEP 3132 — Extended Iterable Unpacking](https://fpy.li/2-2).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*元组解包*被Pythonista广泛使用，但*可迭代解包*正在获得关注，如[PEP 3132 — 扩展可迭代解包](https://fpy.li/2-2)的标题所示。
- en: '[“Unpacking Sequences and Iterables”](#iterable_unpacking_sec) presents a lot
    more about unpacking not only tuples, but sequences and iterables in general.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '["解包序列和可迭代对象"](#iterable_unpacking_sec)不仅详细介绍了元组的解包，还包括序列和可迭代对象的解包。'
- en: Now let’s consider the `tuple` class as an immutable variant of the `list` class.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将`tuple`类视为`list`类的不可变变体。
- en: Tuples as Immutable Lists
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组作为不可变列表
- en: 'The Python interpreter and standard library make extensive use of tuples as
    immutable lists, and so should you. This brings two key benefits:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Python解释器和标准库广泛使用元组作为不可变列表，你也应该这样做。这带来了两个主要好处：
- en: Clarity
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰度
- en: When you see a `tuple` in code, you know its length will never change.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在代码中看到`tuple`时，你知道它的长度永远不会改变。
- en: Performance
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 性能
- en: A `tuple` uses less memory than a `list` of the same length, and it allows Python
    to do some optimizations.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与相同长度的`list`相比，`tuple`使用更少的内存，并允许Python进行一些优化。
- en: However, be aware that the immutability of a `tuple` only applies to the references
    contained in it. References in a tuple cannot be deleted or replaced. But if one
    of those references points to a mutable object, and that object is changed, then
    the value of the `tuple` changes. The next snippet illustrates this point by creating
    two tuples—`a` and `b`—which are initially equal. [Figure 2-4](#tuple_mutable)
    represents the initial layout of the `b` tuple in memory.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意`tuple`的不可变性仅适用于它所包含的引用。元组中的引用不能被删除或替换。但是，如果其中一个引用指向一个可变对象，并且该对象发生了变化，那么`tuple`的值就会改变。下面的代码片段通过创建两个最初相等的元组`a`和`b`来说明这一点。[图2-4](#tuple_mutable)表示内存中`b`元组的初始布局。
- en: '![Reference diagram for a tuple with three items](assets/flpy_0204.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![包含三个元素的元组的引用图](assets/flpy_0204.png) '
- en: Figure 2-4\. The content of the tuple itself is immutable, but that only means
    the references held by the tuple will always point to the same objects. However,
    if one of the referenced objects is mutable—like a list—its content may change.
  id: totrans-143
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-4。元组本身的内容是不可变的，但这只意味着元组持有的引用将始终指向相同的对象。但是，如果其中一个引用对象是可变的（如列表），其内容可能会发生变化。
- en: 'When the last item in `b` is changed, `b` and `a` become different:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当`b`中的最后一项发生变化时，`b`和`a`变得不同：
- en: '[PRE9]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tuples with mutable items can be a source of bugs. As we’ll see in [“What Is
    Hashable”](ch03.html#what_is_hashable), an object is only hashable if its value
    cannot ever change. An unhashable tuple cannot be inserted as a `dict` key, or
    a `set` element.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '包含可变项的元组可能是bug的根源。正如我们将在["什么是可哈希的"](ch03.html#what_is_hashable)中看到的，一个对象只有在其值不能改变时才是可哈希的。不可哈希的元组不能插入为`dict`键或`set`元素。 '
- en: 'If you want to determine explicitly if a tuple (or any object) has a fixed
    value, you can use the `hash` built-in to create a `fixed` function like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想明确确定一个元组（或任何对象）是否具有固定值，可以使用内置的`hash`创建一个`fixed`函数，如下所示：
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We explore this issue further in [“The Relative Immutability of Tuples”](ch06.html#tuple-relative-immutable).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在["元组的相对不可变性"](ch06.html#tuple-relative-immutable)中进一步探讨了这个问题。  '
- en: 'Despite this caveat, tuples are widely used as immutable lists. They offer
    some performance advantages explained by Python core developer Raymond Hettinger
    in a StackOverflow answer to the question: [“Are tuples more efficient than lists
    in Python?”](https://fpy.li/2-3). To summarize, Hettinger wrote:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这个警告，元组仍然被广泛用作不可变列表。Python核心开发者Raymond Hettinger在StackOverflow回答["在Python中元组比列表更高效吗？"](https://fpy.li/2-3)时解释了元组提供的一些性能优势。总结一下，Hettinger写道：
- en: To evaluate a tuple literal, the Python compiler generates bytecode for a tuple
    constant in one operation; but for a list literal, the generated bytecode pushes
    each element as a separate constant to the data stack, and then builds the list.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了评估元组字面量，Python编译器在一个操作中为元组常量生成字节码；但是对于列表字面量，生成的字节码将每个元素作为单独的常量推送到数据栈，然后构建列表。
- en: Given a tuple `t`, `tuple(t)` simply returns a reference to the same `t`. There’s
    no need to copy. In contrast, given a list `l`, the `list(l)` constructor must
    create a new copy of `l`.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定元组`t`，`tuple(t)`只是返回对同一个`t`的引用。没有必要复制。相比之下，给定列表`l`，`list(l)`构造函数必须创建`l`的新副本。
- en: Because of its fixed length, a `tuple` instance is allocated the exact memory
    space it needs. Instances of `list`, on the other hand, are allocated with room
    to spare, to amortize the cost of future appends.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于具有固定长度，`tuple`实例分配它需要的确切内存空间。另一方面，`list`的实例分配时会留有余地，以分摊将来追加的成本。
- en: The references to the items in a tuple are stored in an array in the tuple struct,
    while a list holds a pointer to an array of references stored elsewhere. The indirection
    is necessary because when a list grows beyond the space currently allocated, Python
    needs to reallocate the array of references to make room. The extra indirection
    makes CPU caches less effective.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组中元素的引用存储在元组结构中的数组中，而列表在其他地方保存指向引用数组的指针。当列表增长超过当前分配的空间时，Python需要重新分配引用数组以腾出空间，因此需要间接寻址。额外的间接寻址使CPU缓存效率降低。
- en: Comparing Tuple and List Methods
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较元组和列表方法
- en: When using a tuple as an immutable variation of `list`, it is good to know how
    similar their APIs are. As you can see in [Table 2-1](#list_x_tuple_attrs_tbl),
    `tuple` supports all `list` methods that do not involve adding or removing items,
    with one exception—`tuple` lacks the `__reversed__` method. However, that is just
    for optimization; `reversed(my_tuple)` works without it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用元组作为`list`的不可变变体时，了解它们的API有多相似是很好的。如[表2-1](#list_x_tuple_attrs_tbl)所示，除了一个例外，`tuple`支持所有不涉及添加或删除元素的`list`方法——`tuple`缺少`__reversed__`方法。但是，这只是为了优化；`reversed(my_tuple)`可以在没有它的情况下工作。
- en: Table 2-1\. Methods and attributes found in `list` or `tuple` (methods implemented
    by object are omitted for brevity)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-1. 在`list`或`tuple`中找到的方法和属性（为简洁起见，省略了对象实现的方法）
- en: '|  | list | tuple |   |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|  | list | tuple |   |'
- en: '| --- | --- | --- | --- |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `s.__add__(s2)` | ● | ● | `s + s2`—concatenation |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `s.__add__(s2)` | ● | ● | `s + s2`—连接 |'
- en: '| `s.__iadd__(s2)` | ● |  | `s += s2`—in-place concatenation |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `s.__iadd__(s2)` | ● |  | `s += s2`—原地连接 |'
- en: '| `s.append(e)` | ● |  | Append one element after last |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `s.append(e)` | ● |  | 在最后追加一个元素 |'
- en: '| `s.clear()` | ● |  | Delete all items |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `s.clear()` | ● |  | 删除所有元素 |'
- en: '| `s.__contains__(e)` | ● | ● | `e in s` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `s.__contains__(e)` | ● | ● | `e in s` |'
- en: '| `s.copy()` | ● |  | Shallow copy of the list |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `s.copy()` | ● |  | 列表的浅拷贝 |'
- en: '| `s.count(e)` | ● | ● | Count occurrences of an element |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `s.count(e)` | ● | ● | 计算元素出现的次数 |'
- en: '| `s.__delitem__(p)` | ● |  | Remove item at position `p` |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `s.__delitem__(p)` | ● |  | 移除位置`p`处的元素 |'
- en: '| `s.extend(it)` | ● |  | Append items from iterable `it` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `s.extend(it)` | ● |  | 从可迭代对象`it`追加元素 |'
- en: '| `s.__getitem__(p)` | ● | ● | `s[p]`—get item at position |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `s.__getitem__(p)` | ● | ● | `s[p]`—获取位置`p`处的元素 |'
- en: '| `s.__getnewargs__()` |  | ● | Support for optimized serialization with `pickle`
    |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `s.__getnewargs__()` |  | ● | 支持使用`pickle`进行优化的序列化 |'
- en: '| `s.index(e)` | ● | ● | Find position of first occurrence of `e` |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `s.index(e)` | ● | ● | 查找`e`第一次出现的位置 |'
- en: '| `s.insert(p, e)` | ● |  | Insert element `e` before the item at position
    `p` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `s.insert(p, e)` | ● |  | 在位置`p`的元素之前插入元素`e` |'
- en: '| `s.__iter__()` | ● | ● | Get iterator |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `s.__iter__()` | ● | ● | 获取迭代器 |'
- en: '| `s.__len__()` | ● | ● | `len(s)`—number of items |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `s.__len__()` | ● | ● | `len(s)`—元素的数量 |'
- en: '| `s.__mul__(n)` | ● | ● | `s * n`—repeated concatenation |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `s.__mul__(n)` | ● | ● | `s * n`—重复连接 |'
- en: '| `s.__imul__(n)` | ● |  | `s *= n`—in-place repeated concatenation |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `s.__imul__(n)` | ● |  | `s *= n`—原地重复连接 |'
- en: '| `s.__rmul__(n)` | ● | ● | `n * s`—reversed repeated concatenation^([a](ch02.html#idm46582502610224))
    |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `s.__rmul__(n)` | ● | ● | `n * s`—反向重复连接^([a](ch02.html#idm46582502610224))
    |'
- en: '| `s.pop([p])` | ● |  | Remove and return last item or item at optional position
    `p` |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `s.pop([p])` | ● |  | 移除并返回最后一个元素或位置`p`处的可选元素 |'
- en: '| `s.remove(e)` | ● |  | Remove first occurrence of element `e` by value |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `s.remove(e)` | ● |  | 按值移除元素`e`的第一次出现 |'
- en: '| `s.reverse()` | ● |  | Reverse the order of the items in place |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `s.reverse()` | ● |  | 原地反转元素的顺序 |'
- en: '| `s.__reversed__()` | ● |  | Get iterator to scan items from last to first
    |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `s.__reversed__()` | ● |  | 获取从最后到第一个元素的迭代器 |'
- en: '| `s.__setitem__(p, e)` | ● |  | `s[p] = e`—put `e` in position `p`, overwriting
    existing item^([b](ch02.html#idm46582502593888)) |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `s.__setitem__(p, e)` | ● |  | `s[p] = e`—将`e`放在位置`p`，覆盖现有元素^([b](ch02.html#idm46582502593888))
    |'
- en: '| `s.sort([key], [reverse])` | ● |  | Sort items in place with optional keyword
    arguments `key` and `reverse` |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `s.sort([key], [reverse])` | ● |  | 原地排序，可选关键字参数`key`和`reverse` |'
- en: '| ^([a](ch02.html#idm46582502610224-marker)) Reversed operators are explained
    in [Chapter 16](ch16.html#operator_overloading).^([b](ch02.html#idm46582502593888-marker))
    Also used to overwrite a subsequence. See [“Assigning to Slices”](#assigning_to_slices).
    |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch02.html#idm46582502610224-marker))反向运算符在[第16章](ch16.html#operator_overloading)中解释。^([b](ch02.html#idm46582502593888-marker))也用于覆盖子序列。参见["赋值给切片"](#assigning_to_slices)。
    |'
- en: 'Now let’s switch to an important subject for idiomatic Python programming:
    tuple, list, and iterable unpacking.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们切换到Python编程中一个重要的主题：元组、列表和可迭代对象解包。
- en: Unpacking Sequences and Iterables
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解包序列和可迭代对象
- en: Unpacking is important because it avoids unnecessary and error-prone use of
    indexes to extract elements from sequences. Also, unpacking works with any iterable
    object as the data source—including iterators, which don’t support index notation
    (`[]`). The only requirement is that the iterable yields exactly one item per
    variable in the receiving end, unless you use a star (`*`) to capture excess items,
    as explained in [“Using * to Grab Excess Items”](#tuple_star).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 解包很重要，因为它避免了不必要的和容易出错的使用索引从序列中提取元素。此外，解包可以与任何可迭代对象作为数据源一起使用，包括不支持索引表示法(`[]`)的迭代器。唯一的要求是，可迭代对象在接收端为每个变量只产生一个项，除非你使用星号(`*`)来捕获多余的项，如["使用*捕获多余的项"](#tuple_star)中所解释的。
- en: 'The most visible form of unpacking is *parallel assignment*; that is, assigning
    items from an iterable to a tuple of variables, as you can see in this example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 解包最明显的形式是*并行赋值*；也就是说，将可迭代对象中的项赋值给一个元组变量，如下例所示：
- en: '[PRE11]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'An elegant application of unpacking is swapping the values of variables without
    using a temporary variable:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 解包的一个优雅应用是在不使用临时变量的情况下交换变量的值：
- en: '[PRE12]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Another example of unpacking is prefixing an argument with `*` when calling
    a function:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 解包的另一个例子是在调用函数时在参数前面加上`*`：
- en: '[PRE13]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code shows another use of unpacking: allowing functions to return
    multiple values in a way that is convenient to the caller. As another example,
    the `os.path.split()` function builds a tuple `(path, last_part)` from a filesystem
    path:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码展示了解包的另一个用途：允许函数以一种对调用者很方便的方式返回多个值。另一个例子是，`os.path.split()`函数从文件系统路径构建一个元组`(path,
    last_part)`：
- en: '[PRE14]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Another way of using just some of the items when unpacking is to use the `*`
    syntax, as we’ll see right away.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种在解包时只使用部分项的方式是使用`*`语法，我们马上就会看到。
- en: Using * to Grab Excess Items
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用*捕获多余的项
- en: Defining function parameters with `*args` to grab arbitrary excess arguments
    is a classic Python feature.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`*args`定义函数参数以捕获任意多余的参数是Python的一个经典特性。
- en: 'In Python 3, this idea was extended to apply to parallel assignment as well:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3中，这个想法也被扩展到并行赋值：
- en: '[PRE15]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the context of parallel assignment, the `*` prefix can be applied to exactly
    one variable, but it can appear in any position:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在并行赋值的上下文中，`*`前缀只能应用于一个变量，但它可以出现在任何位置：
- en: '[PRE16]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Unpacking with * in Function Calls and Sequence Literals
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在函数调用和序列字面量中使用*解包
- en: '[PEP 448—Additional Unpacking Generalizations](https://fpy.li/pep448) introduced
    more flexible syntax for iterable unpacking, best summarized in [“What’s New In
    Python 3.5”](https://fpy.li/2-4).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[PEP 448—Additional Unpacking Generalizations](https://fpy.li/pep448)引入了更灵活的可迭代对象解包语法，在["What''s
    New In Python 3.5"](https://fpy.li/2-4)中总结得最好。'
- en: 'In function calls, we can use `*` multiple times:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数调用中，我们可以多次使用`*`：
- en: '[PRE17]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `*` can also be used when defining `list`, `tuple`, or `set` literals,
    as shown in these examples from [“What’s New In Python 3.5”](https://fpy.li/2-4):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义`list`、`tuple`或`set`字面量时也可以使用`*`，如["What's New In Python 3.5"](https://fpy.li/2-4)中的这些例子所示：
- en: '[PRE18]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: PEP 448 introduced similar new syntax for `**`, which we’ll see in [“Unpacking
    Mappings”](ch03.html#dict_unpacking_sec).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 448为`**`引入了类似的新语法，我们将在["Unpacking Mappings"](ch03.html#dict_unpacking_sec)中看到。
- en: Finally, a powerful feature of tuple unpacking is that it works with nested
    structures.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，元组解包的一个强大功能是它可以与嵌套结构一起使用。
- en: Nested Unpacking
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套解包
- en: The target of an unpacking can use nesting, e.g., `(a, b, (c, d))`. Python will
    do the right thing if the value has the same nesting structure. [Example 2-8](#ex_nested_tuple)
    shows nested unpacking in action.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 解包的目标可以使用嵌套，例如`(a, b, (c, d))`。如果值具有相同的嵌套结构，Python会做正确的事情。[示例2-8](#ex_nested_tuple)展示了嵌套解包的实际应用。
- en: Example 2-8\. Unpacking nested tuples to access the longitude
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例2-8\.解包嵌套元组以访问经度
- en: '[PRE19]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](assets/1.png)](#co_an_array_of_sequences_CO6-1)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_an_array_of_sequences_CO6-1) '
- en: Each tuple holds a record with four fields, the last of which is a coordinate
    pair.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元组都包含一个有四个字段的记录，最后一个字段是一对坐标。
- en: '[![2](assets/2.png)](#co_an_array_of_sequences_CO6-2)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_an_array_of_sequences_CO6-2)'
- en: By assigning the last field to a nested tuple, we unpack the coordinates.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将最后一个字段赋值给嵌套元组，我们解包了坐标。
- en: '[![3](assets/3.png)](#co_an_array_of_sequences_CO6-3)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_an_array_of_sequences_CO6-3)'
- en: The `lon <= 0:` test selects only cities in the Western hemisphere.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`lon <= 0:`测试只选择西半球的城市。'
- en: 'The output of [Example 2-8](#ex_nested_tuple) is:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例2-8](#ex_nested_tuple)的输出是：'
- en: '[PRE20]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The target of an unpacking assignment can also be a list, but good use cases
    are rare. Here is the only one I know: if you have a database query that returns
    a single record (e.g., the SQL code has a `LIMIT 1` clause), then you can unpack
    and at the same time make sure there’s only one result with this code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 解包赋值的目标也可以是一个列表，但好的用例很少见。这是我知道的唯一一个：如果你有一个数据库查询只返回一条记录（例如，SQL代码中有一个`LIMIT 1`子句），那么你可以解包并同时确保只有一个结果，代码如下：
- en: '[PRE21]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If the record has only one field, you can get it directly, like this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果记录只有一个字段，你可以直接获取它，像这样：
- en: '[PRE22]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Both of these could be written with tuples, but don’t forget the syntax quirk
    that single-item tuples must be written with a trailing comma. So the first target
    would be `(record,)` and the second `((field,),)`. In both cases you get a silent
    bug if you forget a comma.^([3](ch02.html#idm46582496405424))
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种情况都可以用元组来写，但不要忘记单项元组必须用尾随逗号来写的语法怪癖。所以第一个目标应该是`(record,)`，第二个应该是`((field,),)`。在这两种情况下，如果你忘记了逗号，你会得到一个无声的错误。^([3](ch02.html#idm46582496405424))
- en: Now let’s study pattern matching, which supports even more powerful ways to
    unpack sequences.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们研究模式匹配，它支持更强大的序列解包方式。
- en: Pattern Matching with Sequences
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列模式匹配
- en: 'The most visible new feature in Python 3.10 is pattern matching with the `match/case`
    statement proposed in [PEP 634—Structural Pattern Matching: Specification](https://fpy.li/pep634).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 'Python 3.10中最明显的新特性是[PEP 634—Structural Pattern Matching: Specification](https://fpy.li/pep634)中提议的带有`match/case`语句的模式匹配。'
- en: Note
  id: totrans-231
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Python core developer Carol Willing wrote the excellent introduction to pattern
    matching in the [“Structural Pattern Matching”](https://fpy.li/2-6) section of
    [“What’s New In Python 3.10”](https://fpy.li/2-7). You may want to read that quick
    overview. In this book, I chose to split the coverage of pattern matching over
    different chapters, depending on the pattern types: [“Pattern Matching with Mappings”](ch03.html#pattern_matching_mappings_sec)
    and [“Pattern Matching Class Instances”](ch05.html#pattern_instances_sec). An
    extended example is in [“Pattern Matching in lis.py: A Case Study”](ch18.html#pattern_matching_case_study_sec).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 'Python 核心开发者 Carol Willing 在 ["What''s New In Python 3.10"](https://fpy.li/2-7)
    的 ["Structural Pattern Matching"](https://fpy.li/2-6) 部分中写了关于模式匹配的精彩介绍。你可能需要阅读那个快速概述。在本书中，我选择根据模式类型将模式匹配的内容分散在不同的章节中：["Pattern
    Matching with Mappings"](ch03.html#pattern_matching_mappings_sec) 和 ["Pattern
    Matching Class Instances"](ch05.html#pattern_instances_sec)。一个扩展示例在 ["Pattern
    Matching in lis.py: A Case Study"](ch18.html#pattern_matching_case_study_sec)
    中。'
- en: 'Here is a first example of `match/case` handling sequences. Imagine you are
    designing a robot that accepts commands sent as sequences of words and numbers,
    like `BEEPER 440 3`. After splitting into parts and parsing the numbers, you’d
    have a message like `[''BEEPER'', 440, 3]`. You could use a method like this to
    handle such messages:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 `match/case` 处理序列的第一个例子。想象你正在设计一个机器人，它接受以单词和数字序列发送的命令，如 `BEEPER 440 3`。在分割成部分并解析数字后，你会得到一条像
    `['BEEPER', 440, 3]` 这样的消息。你可以使用如下方法来处理这样的消息：
- en: Example 2-9\. Method from an imaginary `Robot` class
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-9\. 一个虚构的 `Robot` 类的方法
- en: '[PRE23]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](assets/1.png)](#co_an_array_of_sequences_CO7-1)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_an_array_of_sequences_CO7-1)'
- en: The expression after the `match` keyword is the *subject*. The subject is the
    data that Python will try to match to the patterns in each `case` clause.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`match` 关键字后面的表达式是*主题*。主题是 Python 将尝试与每个 `case` 子句中的模式匹配的数据。'
- en: '[![2](assets/2.png)](#co_an_array_of_sequences_CO7-2)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_an_array_of_sequences_CO7-2)'
- en: This pattern matches any subject that is a sequence with three items. The first
    item must be the string `'BEEPER'`. The second and third item can be anything,
    and they will be bound to the variables `frequency` and `times`, in that order.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式匹配任何包含三个元素的序列主题。第一个元素必须是字符串 `'BEEPER'`。第二个和第三个元素可以是任何内容，它们将按顺序绑定到变量 `frequency`
    和 `times`。
- en: '[![3](assets/3.png)](#co_an_array_of_sequences_CO7-3)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_an_array_of_sequences_CO7-3)'
- en: This matches any subject with two items, the first being `'NECK'`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这将匹配任何包含两个元素的主题，第一个元素是 `'NECK'`。
- en: '[![4](assets/4.png)](#co_an_array_of_sequences_CO7-4)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_an_array_of_sequences_CO7-4)'
- en: This will match a subject with three items starting with `'LED'`. If the number
    of items does not match, Python proceeds to the next `case`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这将匹配一个以 `'LED'` 开头的三个元素的主题。如果元素数量不匹配，Python 将继续执行下一个 `case`。
- en: '[![5](assets/5.png)](#co_an_array_of_sequences_CO7-5)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_an_array_of_sequences_CO7-5)'
- en: Another sequence pattern starting with `'LED'`, now with five items—including
    the `'LED'` constant.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个以 `'LED'` 开头的序列模式，现在有五个元素，包括常量 `'LED'`。
- en: '[![6](assets/6.png)](#co_an_array_of_sequences_CO7-6)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_an_array_of_sequences_CO7-6)'
- en: This is the default `case`. It will match any subject that did not match a previous
    pattern. The `_` variable is special, as we’ll soon see.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这是默认的 `case`。它将匹配任何没有匹配前面模式的主题。`_` 变量是特殊的，我们很快就会看到。
- en: On the surface, `match/case` may look like the `switch/case` statement from
    the C language—but that’s only half the story.^([4](ch02.html#idm46582506122016))
    One key improvement of `match` over `switch` is *destructuring*—a more advanced
    form of unpacking. Destructuring is a new word in the Python vocabulary, but it
    is commonly used in the documentation of languages that support pattern matching—like
    Scala and Elixir.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 从表面上看，`match/case` 可能类似于 C 语言中的 `switch/case` 语句 —— 但那只是故事的一半。^([4](ch02.html#idm46582506122016))
    `match` 相对于 `switch` 的一个关键改进是*解构* —— 一种更高级的解包形式。解构是 Python 词汇表中的一个新词，但在支持模式匹配的语言（如
    Scala 和 Elixir）的文档中常用。
- en: As a first example of destructuring, [Example 2-10](#ex_nested_tuple_match)
    shows part of [Example 2-8](#ex_nested_tuple) rewritten with `match/case`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 作为解构的第一个示例，[示例 2-10](#ex_nested_tuple_match) 展示了用 `match/case` 重写的 [示例 2-8](#ex_nested_tuple)
    的一部分。
- en: Example 2-10\. Destructuring nested tuples—requires Python ≥ 3.10
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-10\. 解构嵌套元组 —— 需要 Python ≥ 3.10
- en: '[PRE24]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[![1](assets/1.png)](#co_an_array_of_sequences_CO8-1)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_an_array_of_sequences_CO8-1)'
- en: The subject of this `match` is `record`— i.e., each of the tuples in `metro_areas`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `match` 的主题是 `record`，即 `metro_areas` 中的每个元组。
- en: '[![2](assets/2.png)](#co_an_array_of_sequences_CO8-2)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_an_array_of_sequences_CO8-2)'
- en: 'A `case` clause has two parts: a pattern and an optional guard with the `if`
    keyword.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`case` 子句有两个部分：一个模式和一个可选的带有 `if` 关键字的守卫。'
- en: 'In general, a sequence pattern matches the subject if:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，序列模式在以下情况下匹配主题：
- en: The subject is a sequence *and*;
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主题是一个序列*并且*；
- en: The subject and the pattern have the same number of items *and*;
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主题和模式具有相同数量的元素*并且*；
- en: Each corresponding item matches, including nested items.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个对应的元素都匹配，包括嵌套元素。
- en: For example, the pattern `[name, _, _, (lat, lon)]` in [Example 2-10](#ex_nested_tuple_match)
    matches a sequence with four items, and the last item must be a two-item sequence.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[示例 2-10](#ex_nested_tuple_match) 中的模式 `[name, _, _, (lat, lon)]` 匹配一个包含四个元素的序列，最后一个元素必须是一个包含两个元素的序列。
- en: 'Sequence patterns may be written as tuples or lists or any combination of nested
    tuples and lists, but it makes no difference which syntax you use: in a sequence
    pattern, square brackets and parentheses mean the same thing. I wrote the pattern
    as a list with a nested 2-tuple just to avoid repeating brackets or parentheses
    in [Example 2-10](#ex_nested_tuple_match).'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 序列模式可以写成元组或列表，或者任何嵌套元组和列表的组合，但使用哪种语法并不重要：在序列模式中，方括号和括号的含义相同。我将模式写成带有嵌套 2 元组的列表，只是为了避免在
    [示例 2-10](#ex_nested_tuple_match) 中重复使用括号。
- en: A sequence pattern can match instances of most actual or virtual subclasses
    of `collections.abc.Sequence`, with the exception of `str`, `bytes`, and `bytearray`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 序列模式可以匹配`collections.abc.Sequence`的大多数实际或虚拟子类的实例，但`str`、`bytes`和`bytearray`除外。
- en: Warning
  id: totrans-263
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'Instances of `str`, `bytes`, and `bytearray` are not handled as sequences in
    the context of `match/case`. A `match` subject of one of those types is treated
    as an “atomic” value—like the integer 987 is treated as one value, not a sequence
    of digits. Treating those three types as sequences could cause bugs due to unintended
    matches. If you want to treat an object of those types as a sequence subject,
    convert it in the `match` clause. For example, see `tuple(phone)` in the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在`match/case`的上下文中，`str`、`bytes`和`bytearray`的实例不会被处理为序列。这些类型的`match`主题被视为"原子"值——就像整数987被视为一个值，而不是一个数字序列。将这三种类型视为序列可能会因意外匹配而导致错误。如果要将这些类型的对象视为序列主题，请在`match`子句中进行转换。例如，请参见以下内容中的`tuple(phone)`：
- en: '[PRE25]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the standard library, these types are compatible with sequence patterns:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准库中，这些类型与序列模式兼容：
- en: '[PRE26]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Unlike unpacking, patterns don’t destructure iterables that are not sequences
    (such as iterators).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 与解包不同，模式不会解构非序列的可迭代对象（如迭代器）。
- en: 'The `_` symbol is special in patterns: it matches any single item in that position,
    but it is never bound to the value of the matched item. Also, the `_` is the only
    variable that can appear more than once in a pattern.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`_`符号在模式中很特殊：它匹配该位置的任何单个项，但永远不会绑定到匹配项的值。此外，`_`是唯一可以在模式中多次出现的变量。'
- en: 'You can bind any part of a pattern with a variable using the `as` keyword:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`as`关键字将模式的任何部分绑定到一个变量：
- en: '[PRE27]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Given the subject `[''Shanghai'', ''CN'', 24.9, (31.1, 121.3)]`, the preceding
    pattern will match, and set the following variables:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 给定主题`['Shanghai', 'CN', 24.9, (31.1, 121.3)]`，前面的模式将匹配，并设置以下变量：
- en: '| Variable | Set Value |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 设置值 |'
- en: '| --- | --- |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `name` | `''Shanghai''` |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `name` | `''Shanghai''` |'
- en: '| `lat` | `31.1` |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `lat` | `31.1` |'
- en: '| `lon` | `121.3` |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `lon` | `121.3` |'
- en: '| `coord` | `(31.1, 121.3)` |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `coord` | `(31.1, 121.3)` |'
- en: 'We can make patterns more specific by adding type information. For example,
    the following pattern matches the same nested sequence structure as the previous
    example, but the first item must be an instance of `str`, and both items in the
    2-tuple must be instances of `float`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加类型信息来使模式更具体。例如，以下模式匹配与前面示例相同的嵌套序列结构，但第一项必须是`str`的实例，而2元组中的两个项都必须是`float`的实例：
- en: '[PRE28]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Tip
  id: totrans-281
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'The expressions `str(name)` and `float(lat)` look like constructor calls, which
    we’d use to convert `name` and `lat` to `str` and `float`. But in the context
    of a pattern, that syntax performs a runtime type check: the preceding pattern
    will match a four-item sequence in which item 0 must be a `str`, and item 3 must
    be a pair of floats. Additionally, the `str` in item 0 will be bound to the `name`
    variable, and the floats in item 3 will be bound to `lat` and `lon`, respectively.
    So, although `str(name)` borrows the syntax of a constructor call, the semantics
    are completely different in the context of a pattern. Using arbitrary classes
    in patterns is covered in [“Pattern Matching Class Instances”](ch05.html#pattern_instances_sec).'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`str(name)`和`float(lat)`看起来像构造函数调用，我们会用它们将`name`和`lat`转换为`str`和`float`。但在模式的上下文中，该语法执行运行时类型检查：前面的模式将匹配一个四项序列，其中第0项必须是`str`，第3项必须是一对浮点数。此外，第0项中的`str`将绑定到`name`变量，第3项中的浮点数将分别绑定到`lat`和`lon`。所以，尽管`str(name)`借用了构造函数调用的语法，但在模式的上下文中，语义完全不同。在["模式匹配类实例"](ch05.html#pattern_instances_sec)中介绍了在模式中使用任意类。
- en: 'On the other hand, if we want to match any subject sequence starting with a
    `str`, and ending with a nested sequence of two floats, we can write:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们想匹配任何以`str`开头并以两个浮点数的嵌套序列结尾的主题序列，我们可以这样写：
- en: '[PRE29]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `*_` matches any number of items, without binding them to a variable. Using
    `*extra` instead of `*_` would bind the items to `extra` as a `list` with 0 or
    more items.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`*_`匹配任意数量的项，而不将它们绑定到变量。使用`*extra`而不是`*_`会将项绑定到`extra`作为一个包含0个或多个项的`list`。'
- en: 'The optional guard clause starting with `if` is evaluated only if the pattern
    matches, and can reference variables bound in the pattern, as in [Example 2-10](#ex_nested_tuple_match):'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的以`if`开头的保护子句只在模式匹配时求值，并且可以引用模式中绑定的变量，如[示例2-10](#ex_nested_tuple_match)所示：
- en: '[PRE30]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The nested block with the `print` statement runs only if the pattern matches
    and the guard expression is *truthy*.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在模式匹配且保护表达式为*真*时，才会运行包含`print`语句的嵌套块。
- en: Tip
  id: totrans-289
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Destructuring with patterns is so expressive that sometimes a `match` with a
    single `case` can make code simpler. Guido van Rossum has a collection of `case/match`
    examples, including one that he titled [“A very deep iterable and type match with
    extraction”](https://fpy.li/2-10).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模式进行解构是如此富有表现力，以至于有时只有一个`case`的`match`就可以使代码更简单。Guido van Rossum有一个`case/match`示例集合，其中有一个他标题为["一个非常深层的可迭代对象和类型匹配与提取"](https://fpy.li/2-10)。
- en: '[Example 2-10](#ex_nested_tuple_match) is not an improvement over [Example 2-8](#ex_nested_tuple).
    It’s just an example to contrast two ways of doing the same thing. The next example
    shows how pattern matching contributes to clear, concise, and effective code.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例2-10](#ex_nested_tuple_match)并不比[示例2-8](#ex_nested_tuple)有改进。它只是一个示例，用于对比做同一件事的两种方式。下一个示例展示了模式匹配如何有助于清晰、简洁和有效的代码。'
- en: Pattern Matching Sequences in an Interpreter
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释器中的序列模式匹配
- en: 'Peter Norvig of Stanford University wrote [*lis.py*](https://fpy.li/2-11):
    an interpreter for a subset of the Scheme dialect of the Lisp programming language
    in 132 lines of beautiful and readable Python code. I took Norvig’s MIT-licensed
    source and updated it to Python 3.10 to showcase pattern matching. In this section,
    we’ll compare a key part of Norvig’s code—which uses `if/elif` and unpacking—with
    a rewrite using `match/case`.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 斯坦福大学的 Peter Norvig 编写了[*lis.py*](https://fpy.li/2-11)：一个 Lisp 编程语言的 Scheme
    方言子集的解释器，用 132 行优美、易读的 Python 代码实现。我采用了 Norvig 的 MIT 许可源代码，并将其更新到 Python 3.10，以展示模式匹配。在本节中，我们将比较
    Norvig 代码的一个关键部分（使用`if/elif`和解包）与使用`match/case`重写的版本。
- en: 'The two main functions of *lis.py* are `parse` and `evaluate`.^([5](ch02.html#idm46582509473312))
    The parser takes Scheme parenthesized expressions and returns Python lists. Here
    are two examples:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '*lis.py*的两个主要函数是`parse`和`evaluate`。^([5](ch02.html#idm46582509473312)) 解析器接受
    Scheme 的括号表达式并返回 Python 列表。这里有两个例子：'
- en: '[PRE31]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The evaluator takes lists like these and executes them. The first example is
    calling a `gcd` function with `18` and `45` as arguments. When evaluated, it computes
    the greatest common divisor of the arguments: 9. The second example is defining
    a function named `double` with a parameter `n`. The body of the function is the
    expression `(* n 2)`. The result of calling a function in Scheme is the value
    of the last expression in its body.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '求值器接受这样的列表并执行它们。第一个例子是用`18`和`45`作为参数调用`gcd`函数。求值时，它计算参数的最大公约数：9。第二个例子是定义一个名为`double`的函数，带有一个参数`n`。函数体是表达式`(*
    n 2)`。在 Scheme 中调用函数的结果是函数体中最后一个表达式的值。 '
- en: 'Our focus here is destructuring sequences, so I will not explain the evaluator
    actions. See [“Pattern Matching in lis.py: A Case Study”](ch18.html#pattern_matching_case_study_sec)
    to learn more about how *lis.py* works.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里重点关注序列的解构，所以我不会解释求值器的动作。想了解更多关于*lis.py*如何工作的信息，请参阅["lis.py 中的模式匹配：一个案例研究"](ch18.html#pattern_matching_case_study_sec)。
- en: '[Example 2-11](#ex_norvigs_eval) shows Norvig’s evaluator with minor changes,
    abbreviated to show only the sequence patterns.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2-11](#ex_norvigs_eval) 显示了 Norvig 的求值器，经过略微修改，仅显示序列模式。 '
- en: Example 2-11\. Matching patterns without `match/case`
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-11\. 不使用`match/case`匹配模式
- en: '[PRE32]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note how each `elif` clause checks the first item of the list, and then unpacks
    the list, ignoring the first item. The extensive use of unpacking suggests that
    Norvig is a fan of pattern matching, but he wrote that code originally for Python
    2 (though it now works with any Python 3).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个`elif`子句是如何检查列表的第一个元素，然后解包列表，忽略第一个元素的。广泛使用解包表明 Norvig 是模式匹配的粉丝，但他最初是为 Python
    2 编写那段代码的（尽管它现在适用于任何 Python 3）。
- en: Using `match/case` in Python ≥ 3.10, we can refactor `evaluate` as shown in
    [Example 2-12](#ex_match_eval).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python ≥ 3.10 中的`match/case`，我们可以重构`evaluate`，如[示例 2-12](#ex_match_eval)
    所示。
- en: Example 2-12\. Pattern matching with `match/case`—requires Python ≥ 3.10
  id: totrans-303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '示例 2-12\. 使用`match/case`进行模式匹配——需要 Python ≥ 3.10 '
- en: '[PRE33]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[![1](assets/1.png)](#co_an_array_of_sequences_CO9-1)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_an_array_of_sequences_CO9-1)'
- en: Match if subject is a two-item sequence starting with `'quote'`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配是否是以`'quote'`开头的两元素序列。
- en: '[![2](assets/2.png)](#co_an_array_of_sequences_CO9-2)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_an_array_of_sequences_CO9-2)'
- en: Match if subject is a four-item sequence starting with `'if'`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配是否是以`'if'`开头的四元素序列。
- en: '[![3](assets/3.png)](#co_an_array_of_sequences_CO9-3)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_an_array_of_sequences_CO9-3)'
- en: Match if subject is a sequence of three or more items starting with `'lambda'`.
    The guard ensures that `body` is not empty.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配是否是以`'lambda'`开头的三个或更多元素的序列。guard 确保`body`不为空。
- en: '[![4](assets/4.png)](#co_an_array_of_sequences_CO9-4)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_an_array_of_sequences_CO9-4)'
- en: Match if subject is a three-item sequence starting with `'define'`, followed
    by an instance of `Symbol`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配是否是以`'define'`开头的三元素序列，后面跟着一个`Symbol`的实例。
- en: '[![5](assets/5.png)](#co_an_array_of_sequences_CO9-5)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_an_array_of_sequences_CO9-5)'
- en: It is good practice to have a catch-all `case`. In this example, if `exp` doesn’t
    match any of the patterns, the expression is malformed, and I raise `SyntaxError`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有的`case`语句写一个兜底是一个很好的实践。在这个例子中，如果`exp`不匹配任何模式，表达式就是有问题的，我会抛出`SyntaxError`。
- en: Without a catch-all, the whole `match` statement does nothing when a subject
    does not match any case—and this can be a silent failure.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有兜底语句，当主体不匹配任何 case 时，整个`match`语句都不会执行任何操作——而这可能是一个静默的失败。
- en: Norvig deliberately avoided error checking in *lis.py* to keep the code easy
    to understand. With pattern matching, we can add more checks and still keep it
    readable. For example, in the `'define'` pattern, the original code does not ensure
    that `name` is an instance of `Symbol`—that would require an `if` block, an `isinstance`
    call, and more code. [Example 2-12](#ex_match_eval) is shorter and safer than
    [Example 2-11](#ex_norvigs_eval).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Norvig 故意避免在*lis.py*中进行错误检查，以保持代码易于理解。使用模式匹配，我们可以添加更多检查，同时保持可读性。例如，在`'define'`模式中，原始代码不确保`name`是`Symbol`的实例——这需要一个`if`块、一个`isinstance`调用和更多代码。[示例
    2-12](#ex_match_eval) 比[示例 2-11](#ex_norvigs_eval) 更简洁、更安全。
- en: Alternative patterns for lambda
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: lambda 的替代模式
- en: 'This is the syntax of `lambda` in Scheme, using the syntactic convention that
    the suffix `…` means the element may appear zero or more times:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Scheme 中`lambda`的语法，使用语法约定：后缀`…`表示元素可能出现零次或多次：
- en: '[PRE34]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A simple pattern for the lambda case `''lambda''` would be this:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: lambda case `'lambda'`的一个简单模式是：
- en: '[PRE35]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'However, that matches any value in the `parms` position, including the first
    `''x''` in this invalid subject:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这会匹配`parms`位置的任何值，包括这个无效主体中的第一个`'x'`：
- en: '[PRE36]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The nested list after the `lambda` keyword in Scheme holds the names of the
    formal parameters for the function, and it must be a list even if it has only
    one element. It may also be an empty list, if the function takes no parameters—like
    Python’s `random.random()`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme 中`lambda`关键字后面的嵌套列表包含函数的形式参数名称，即使它只有一个元素也必须是一个列表。如果函数不接受任何参数，它也可以是一个空列表——就像
    Python 的`random.random()`。
- en: 'In [Example 2-12](#ex_match_eval), I made the `''lambda''` pattern safer using
    a nested sequence pattern:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 2-12](#ex_match_eval) 中，我使用嵌套序列模式使 `'lambda'` 模式更加安全：
- en: '[PRE37]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In a sequence pattern, `*` can appear only once per sequence. Here we have
    two sequences: the outer and the inner.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在序列模式中，`*` 在每个序列中只能出现一次。这里我们有两个序列：外部序列和内部序列。
- en: Adding the characters `[*]` around `parms` made the pattern look more like the
    Scheme syntax it handles, and gave us an additional structural check.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `parms` 周围添加 `[*]` 字符使模式看起来更像它所处理的 Scheme 语法，并为我们提供了额外的结构检查。
- en: Shortcut syntax for function definition
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数定义的简写语法
- en: 'Scheme has an alternative `define` syntax to create a named function without
    using a nested `lambda`. This is the syntax:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Scheme 有一种替代的 `define` 语法，可以在不使用嵌套 `lambda` 的情况下创建命名函数。语法如下：
- en: '[PRE38]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `define` keyword is followed by a list with the `name` of the new function
    and zero or more parameter names. After that list comes the function body with
    one or more expressions.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`define` 关键字后面跟着一个列表，其中包含新函数的 `name` 以及零个或多个参数名称。在该列表之后是函数体，其中包含一个或多个表达式。'
- en: 'Adding these two lines to the `match` takes care of the implementation:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两行添加到 `match` 中就可以完成实现：
- en: '[PRE39]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'I’d place that `case` after the other `define` case in [Example 2-12](#ex_match_eval).
    The order between the `define` cases is irrelevant in this example because no
    subject can match both of these patterns: the second element must be a `Symbol`
    in the original `define` case, but it must be a sequence starting with a `Symbol`
    in the `define` shortcut for function definition.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我会将该 `case` 放在 [示例 2-12](#ex_match_eval) 中另一个 `define` case 之后。在这个示例中，`define`
    case 的顺序无关紧要，因为没有主体可以同时匹配这两个模式：在原始的 `define` case 中第二个元素必须是 `Symbol`，但在用于函数定义的
    `define` 简写中，它必须是以 `Symbol` 开头的序列。
- en: Now consider how much work we’d have adding support for this second `define`
    syntax without the help of pattern matching in [Example 2-11](#ex_norvigs_eval).
    The `match` statement does a lot more than the `switch` in C-like languages.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一下，如果没有 [示例 2-11](#ex_norvigs_eval) 中模式匹配的帮助，为第二个 `define` 语法添加支持需要做多少工作。`match`
    语句比类 C 语言中的 `switch` 做的事情要多得多。
- en: 'Pattern matching is an example of declarative programming: the code describes
    “what” you want to match, instead of “how” to match it. The shape of the code
    follows the shape of the data, as [Table 2-2](#syntax_and_pattern_tbl) illustrates.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配是声明式编程的一个例子：代码描述了你想要匹配的"什么"，而不是"如何"匹配。代码的形状遵循数据的形状，如 [表 2-2](#syntax_and_pattern_tbl)
    所示。
- en: Table 2-2\. Some Scheme syntactic forms and `case` patterns to handle them
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-2\. 一些 Scheme 语法形式和用于处理它们的 `case` 模式
- en: '| Scheme syntax | Sequence pattern |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| Scheme 语法 | 序列模式 |'
- en: '| --- | --- |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `(quote exp)` | `[''quote'', exp]` |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| `(quote exp)` | `[''quote'', exp]` |'
- en: '| `(if test conseq alt)` | `[''if'', test, conseq, alt]` |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| `(if test conseq alt)` | `[''if'', test, conseq, alt]` |'
- en: '| `(lambda (parms…) body1 body2…)` | `[''lambda'', [*parms], *body] if body`
    |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| `(lambda (parms…) body1 body2…)` | `[''lambda'', [*parms], *body] if body`
    |'
- en: '| `(define name exp)` | `[''define'', Symbol() as name, exp]` |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| `(define name exp)` | `[''define'', Symbol() as name, exp]` |'
- en: '| `(define (name parms…) body1 body2…)` | `[''define'', [Symbol() as name,
    *parms], *body] if body` |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| `(define (name parms…) body1 body2…)` | `[''define'', [Symbol() as name,
    *parms], *body] if body` |'
- en: I hope this refactoring of Norvig’s `evaluate` with pattern matching convinced
    you that `match/case` can make your code more readable and safer.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望用模式匹配重构 Norvig 的 `evaluate` 能让你相信 `match/case` 可以使你的代码更具可读性和安全性。
- en: Note
  id: totrans-347
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'We’ll see more of *lis.py* in [“Pattern Matching in lis.py: A Case Study”](ch18.html#pattern_matching_case_study_sec),
    when we’ll review the complete `match/case` example in `evaluate`. If you want
    to learn more about Norvig’s *lis.py*, read his wonderful post [“(How to Write
    a (Lisp) Interpreter (in Python))”](https://fpy.li/2-12).'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在["lis.py 中的模式匹配：案例研究"](ch18.html#pattern_matching_case_study_sec)一节中，当我们回顾
    `evaluate` 中完整的 `match/case` 示例时，我们将看到更多关于 *lis.py* 的内容。如果你想了解更多关于 Norvig 的 *lis.py*，请阅读他精彩的文章["（如何用
    Python 编写一个 Lisp 解释器）"](https://fpy.li/2-12)。
- en: This concludes our first tour of unpacking, destructuring, and pattern matching
    with sequences. We’ll cover other types of patterns in later chapters.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 以上就是我们对序列解包、解构和模式匹配的首次介绍。我们将在后面的章节中介绍其他类型的模式。
- en: Every Python programmer knows that sequences can be sliced using the `s[a:b]`
    syntax. We now turn to some less well-known facts about slicing.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Python 程序员都知道可以使用 `s[a:b]` 语法对序列进行切片。我们现在来看一些关于切片的鲜为人知的事实。
- en: Slicing
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片
- en: A common feature of `list`, `tuple`, `str`, and all sequence types in Python
    is the support of slicing operations, which are more powerful than most people
    realize.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中 `list`、`tuple`、`str` 以及所有序列类型的一个共同特性是支持切片操作，其功能比大多数人意识到的要强大得多。
- en: In this section, we describe the *use* of these advanced forms of slicing. Their
    implementation in a user-defined class will be covered in [Chapter 12](ch12.html#user_defined_sequences),
    in keeping with our philosophy of covering ready-to-use classes in this part of
    the book, and creating new classes in [Part III](part03.html#classes_protocols_part).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们描述了这些高级切片形式的*使用*。它们在用户定义类中的实现将在 [第 12 章](ch12.html#user_defined_sequences)中介绍，这与我们在本书这一部分中介绍现成可用的类，并在
    [第 III 部分](part03.html#classes_protocols_part)中创建新类的理念保持一致。
- en: Why Slices and Ranges Exclude the Last Item
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么切片和范围要排除最后一项
- en: 'The Pythonic convention of excluding the last item in slices and ranges works
    well with the zero-based indexing used in Python, C, and many other languages.
    Some convenient features of the convention are:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python、C 语言以及许多其他语言中使用的基于0的索引，与 Python 中切片和范围排除最后一项的约定能够很好地配合。这个约定有一些方便的特性：
- en: 'It’s easy to see the length of a slice or range when only the stop position
    is given: `range(3)` and `my_list[:3]` both produce three items.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当只给出停止位置时，很容易看出切片或范围的长度：`range(3)` 和 `my_list[:3]` 都会产生三个项目。
- en: 'It’s easy to compute the length of a slice or range when start and stop are
    given: just subtract `stop - start`.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当给出起始位置和停止位置时，计算切片或范围的长度很容易：只需计算 `stop - start`。
- en: 'It’s easy to split a sequence in two parts at any index `x`, without overlapping:
    simply get `my_list[:x]` and `my_list[x:]`. For example:'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任意索引`x`处轻松将序列分为两部分，不重叠：只需获取`my_list[:x]`和`my_list[x:]`。例如：
- en: '[PRE40]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The best arguments for this convention were written by the Dutch computer scientist
    Edsger W. Dijkstra (see the last reference in [“Further Reading”](#array_fur_reading_sec)).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这种约定的最佳论据是由荷兰计算机科学家Edsger W. Dijkstra撰写的（请参阅[“进一步阅读”](#array_fur_reading_sec)中的最后一个参考文献）。
- en: Now let’s take a close look at how Python interprets slice notation.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们仔细看看Python如何解释切片表示法。
- en: Slice Objects
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片对象
- en: 'This is no secret, but worth repeating just in case: `s[a:b:c]` can be used
    to specify a stride or step `c`, causing the resulting slice to skip items. The
    stride can also be negative, returning items in reverse. Three examples make this
    clear:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是秘密，但值得重复一遍：`s[a:b:c]`可用于指定步长或步进`c`，导致生成的切片跳过项目。步长也可以是负数，返回相反顺序的项目。三个示例清楚地说明了这一点：
- en: '[PRE41]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Another example was shown in [Chapter 1](ch01.html#data_model) when we used
    `deck[12::13]` to get all the aces in the unshuffled deck:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个示例在[第1章](ch01.html#data_model)中展示，当我们使用`deck[12::13]`来获取未洗牌牌组中的所有A时：
- en: '[PRE42]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The notation `a:b:c` is only valid within `[]` when used as the indexing or
    subscript operator, and it produces a slice object: `slice(a, b, c)`. As we will
    see in [“How Slicing Works”](ch12.html#how_slicing_works), to evaluate the expression
    `seq[start:stop:step]`, Python calls `seq.__getitem__(slice(start, stop, step))`.
    Even if you are not implementing your own sequence types, knowing about slice
    objects is useful because it lets you assign names to slices, just like spreadsheets
    allow naming of cell ranges.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 符号`a:b:c`仅在作为索引或下标运算符使用时在`[]`内有效，并产生一个切片对象：`slice(a, b, c)`。正如我们将在[“切片工作原理”](ch12.html#how_slicing_works)中看到的，为了评估表达式`seq[start:stop:step]`，Python调用`seq.__getitem__(slice(start,
    stop, step))`。即使您不是在实现自己的序列类型，了解切片对象也是有用的，因为它允许您为切片分配名称，就像电子表格允许命名单元格范围一样。
- en: Suppose you need to parse flat-file data like the invoice shown in [Example 2-13](#flat_file_invoce).
    Instead of filling your code with hardcoded slices, you can name them. See how
    readable this makes the `for` loop at the end of the example.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您需要解析像[示例2-13](#flat_file_invoce)中显示的发票那样的平面文件数据。您可以为它们命名，而不是在代码中填充硬编码切片。看看这如何使示例末尾的`for`循环变得更易读。
- en: Example 2-13\. Line items from a flat-file invoice
  id: totrans-369
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例2-13。来自平面文件发票的行项目
- en: '[PRE43]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We’ll come back to `slice` objects when we discuss creating your own collections
    in [“Vector Take #2: A Sliceable Sequence”](ch12.html#sliceable_sequence). Meanwhile,
    from a user perspective, slicing includes additional features such as multidimensional
    slices and ellipsis (`...`) notation. Read on.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论在[“向量接收器#2：可切片序列”](ch12.html#sliceable_sequence)中创建自己的集合时，我们将回到`slice`对象。与此同时，从用户角度来看，切片包括额外的功能，如多维切片和省略号（`...`）表示法。继续阅读。
- en: Multidimensional Slicing and Ellipsis
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多维切片和省略号
- en: The `[]` operator can also take multiple indexes or slices separated by commas.
    The `__getitem__` and `__setitem__` special methods that handle the `[]` operator
    simply receive the indices in `a[i, j]` as a tuple. In other words, to evaluate
    `a[i, j]`, Python calls `a.__getitem__((i, j))`.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`[]`运算符还可以接受用逗号分隔的多个索引或切片。处理`[]`运算符的`__getitem__`和`__setitem__`特殊方法简单地将`a[i,
    j]`中的索引作为元组接收。换句话说，为了评估`a[i, j]`，Python调用`a.__getitem__((i, j))`。 '
- en: This is used, for instance, in the external NumPy package, where items of a
    two-dimensional `numpy.ndarray` can be fetched using the syntax `a[i, j]` and
    a two-dimensional slice obtained with an expression like `a[m:n, k:l]`. [Example 2-22](#ex_numpy_array)
    later in this chapter shows the use of this notation.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在外部NumPy包中使用，可以使用语法`a[i, j]`获取二维`numpy.ndarray`的项目，并使用表达式`a[m:n, k:l]`获取二维切片。本章后面的[示例2-22](#ex_numpy_array)展示了此表示法的用法。
- en: Except for `memoryview`, the built-in sequence types in Python are one-dimensional,
    so they support only one index or slice, and not a tuple of them.^([6](ch02.html#idm46582493669184))
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`memoryview`，Python中的内置序列类型是一维的，因此它们仅支持一个索引或切片，而不是它们的元组。^([6](ch02.html#idm46582493669184))
- en: The ellipsis—written with three full stops (`...`) and not `…` (Unicode U+2026)—is
    recognized as a token by the Python parser. It is an alias to the `Ellipsis` object,
    the single instance of the `ellipsis` class.^([7](ch02.html#idm46582493663648))
    As such, it can be passed as an argument to functions and as part of a slice specification,
    as in `f(a, ..., z)` or `a[i:...]`. NumPy uses `...` as a shortcut when slicing
    arrays of many dimensions; for example, if `x` is a four-dimensional array, `x[i,
    ...]` is a shortcut for `x[i, :, :, :,]`. See [“NumPy quickstart”](https://fpy.li/2-13)
    to learn more about this.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 省略号——用三个完整的句号（`...`）而不是`…`（Unicode U+2026）编写——被Python解析器识别为一个标记。它是`Ellipsis`对象的别名，`ellipsis`类的单个实例。^([7](ch02.html#idm46582493663648))因此，它可以作为参数传递给函数，并作为切片规范的一部分，如`f(a,
    ..., z)`或`a[i:...]`。NumPy在对许多维度的数组进行切片时使用`...`作为快捷方式；例如，如果`x`是一个四维数组，则`x[i, ...]`是`x[i,
    :, :, :,]`的快捷方式。查看[“NumPy快速入门”](https://fpy.li/2-13)以了解更多信息。
- en: At the time of this writing, I am unaware of uses of `Ellipsis` or multidimensional
    indexes and slices in the Python standard library. If you spot one, let me know.
    These syntactic features exist to support user-defined types and extensions such
    as NumPy.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，我不知道Python标准库中使用`Ellipsis`或多维索引和切片的用途。如果您发现了，请告诉我。这些语法特性存在是为了支持用户定义的类型和扩展，如NumPy。
- en: Slices are not just useful to extract information from sequences; they can also
    be used to change mutable sequences in place—that is, without rebuilding them
    from scratch.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 切片不仅有助于从序列中提取信息；它们还可以用于就地更改可变序列，即不需要从头开始重建它们。
- en: Assigning to Slices
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配到切片
- en: 'Mutable sequences can be grafted, excised, and otherwise modified in place
    using slice notation on the lefthand side of an assignment statement or as the
    target of a `del` statement. The next few examples give an idea of the power of
    this notation:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 可变序列可以通过在赋值语句的左侧使用切片表示法或作为`del`语句的目标来进行嫁接、切除和其他修改。接下来的几个示例展示了这种表示法的强大之处：
- en: '[PRE44]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[![1](assets/1.png)](#co_an_array_of_sequences_CO10-1)'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_an_array_of_sequences_CO10-1)'
- en: When the target of the assignment is a slice, the righthand side must be an
    iterable object, even if it has just one item.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 当赋值的目标是一个切片时，右侧必须是一个可迭代对象，即使它只有一个项目。
- en: Every coder knows that concatenation is a common operation with sequences. Introductory
    Python tutorials explain the use of `+` and `*` for that purpose, but there are
    some subtle details on how they work, which we cover next.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 每个程序员都知道连接序列是一种常见操作。Python入门教程解释了如何使用`+`和`*`来实现这一目的，但它们的工作原理有一些微妙之处，我们接下来会详细介绍。
- en: Using + and * with Sequences
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用+和*处理序列
- en: Python programmers expect that sequences support `+` and `*`. Usually both operands
    of `+` must be of the same sequence type, and neither of them is modified, but
    a new sequence of that same type is created as result of the concatenation.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序员期望序列支持`+`和`*`。通常，`+`的两个操作数必须是相同的序列类型，并且它们都不会被修改，但作为连接结果会创建一个相同类型的新序列。
- en: 'To concatenate multiple copies of the same sequence, multiply it by an integer.
    Again, a new sequence is created:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接同一序列的多个副本，可以将其乘以一个整数。同样，会创建一个新序列：
- en: '[PRE45]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Both `+` and `*` always create a new object, and never change their operands.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`+`和`*`都会创建一个新对象，并且不会改变它们的操作数。'
- en: Warning
  id: totrans-390
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Beware of expressions like `a * n` when `a` is a sequence containing mutable
    items, because the result may surprise you. For example, trying to initialize
    a list of lists as `my_list = [[]] * 3` will result in a list with three references
    to the same inner list, which is probably not what you want.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 当包含可变项的序列`a`尝试执行`a * n`时要小心，因为结果可能会让你感到惊讶。例如，尝试将一个列表的列表初始化为`my_list = [[]] *
    3`将导致一个包含对同一内部列表的三个引用的列表，这可能不是你想要的。
- en: The next section covers the pitfalls of trying to use `*` to initialize a list
    of lists.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将介绍尝试使用`*`初始化列表的陷阱。
- en: Building Lists of Lists
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建列表的列表
- en: Sometimes we need to initialize a list with a certain number of nested lists—for
    example, to distribute students in a list of teams or to represent squares on
    a game board. The best way of doing so is with a list comprehension, as in [Example 2-14](#ex_list_of_lists_ok).
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要使用一定数量的嵌套列表来初始化一个列表，例如，将学生分配到团队列表中或表示游戏棋盘上的方块。最好的方法是使用列表推导式，就像[示例2-14](#ex_list_of_lists_ok)中那样。
- en: Example 2-14\. A list with three lists of length 3 can represent a tic-tac-toe
    board
  id: totrans-395
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-14. 一个包含三个长度为3的列表的列表可以表示一个井字棋棋盘
- en: '[PRE46]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[![1](assets/1.png)](#co_an_array_of_sequences_CO11-1)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_an_array_of_sequences_CO11-1)'
- en: Create a list of three lists of three items each. Inspect the structure.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含三个每个三个项目的列表的列表。检查结构。
- en: '[![2](assets/2.png)](#co_an_array_of_sequences_CO11-2)'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_an_array_of_sequences_CO11-2)'
- en: Place a mark in row 1, column 2, and check the result.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1行第2列放置一个标记，然后查看结果。
- en: A tempting, but wrong, shortcut is doing it like [Example 2-15](#ex_list_of_lists_wrong).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 一个诱人但错误的快捷方式是像[示例2-15](#ex_list_of_lists_wrong)那样做。
- en: Example 2-15\. A list with three references to the same list is useless
  id: totrans-402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例2-15. 一个包含对同一列表的三个引用的列表是无用的
- en: '[PRE47]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[![1](assets/1.png)](#co_an_array_of_sequences_CO12-1)'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_an_array_of_sequences_CO12-1)'
- en: The outer list is made of three references to the same inner list. While it
    is unchanged, all seems right.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 外部列表由三个对同一内部列表的引用组成。当它保持不变时，一切似乎都正确。
- en: '[![2](assets/2.png)](#co_an_array_of_sequences_CO12-2)'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_an_array_of_sequences_CO12-2)'
- en: Placing a mark in row 1, column 2, reveals that all rows are aliases referring
    to the same object.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1行第2列放置一个标记，揭示所有行都是指向同一对象的别名。
- en: 'The problem with [Example 2-15](#ex_list_of_lists_wrong) is that, in essence,
    it behaves like this code:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例2-15](#ex_list_of_lists_wrong)的问题在于，本质上它的行为类似于以下代码：'
- en: '[PRE48]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[![1](assets/1.png)](#co_an_array_of_sequences_CO13-1)'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_an_array_of_sequences_CO13-1)'
- en: The same `row` is appended three times to `board`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的`row`被三次附加到`board`上。
- en: 'On the other hand, the list comprehension from [Example 2-14](#ex_list_of_lists_ok)
    is equivalent to this code:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，来自[示例2-14](#ex_list_of_lists_ok)的列表推导式等同于以下代码：
- en: '[PRE49]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[![1](assets/1.png)](#co_an_array_of_sequences_CO14-1)'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_an_array_of_sequences_CO14-1)'
- en: Each iteration builds a new `row` and appends it to `board`.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 每次迭代都会构建一个新的`row`并将其附加到`board`上。
- en: '[![2](assets/2.png)](#co_an_array_of_sequences_CO14-2)'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_an_array_of_sequences_CO14-2)'
- en: Only row 2 is changed, as expected.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 只有第2行被更改，这是预期的结果。
- en: Tip
  id: totrans-418
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If either the problem or the solution in this section is not clear to you, relax.
    [Chapter 6](ch06.html#mutability_and_references) was written to clarify the mechanics
    and pitfalls of references and mutable objects.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如果本节中的问题或解决方案对您来说不清楚，请放心。[第6章](ch06.html#mutability_and_references)旨在澄清引用和可变对象的机制和陷阱。
- en: So far we have discussed the use of the plain `+` and `*` operators with sequences,
    but there are also the `+=` and `*=` operators, which produce very different results,
    depending on the mutability of the target sequence. The following section explains
    how that works.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了在序列中使用普通的`+`和`*`运算符，但还有`+=`和`*=`运算符，它们会根据目标序列的可变性产生非常不同的结果。接下来的部分将解释其工作原理。
- en: Augmented Assignment with Sequences
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列的增强赋值
- en: The augmented assignment operators `+=` and `*=` behave quite differently, depending
    on the first operand. To simplify the discussion, we will focus on augmented addition
    first (`+=`), but the concepts also apply to `*=` and to other augmented assignment
    operators.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 增强赋值运算符`+=`和`*=`的行为取决于第一个操作数。为了简化讨论，我们将首先关注增强加法(`+=`)，但这些概念也适用于`*=`和其他增强赋值运算符。
- en: The special method that makes `+=` work is `__iadd__` (for “in-place addition”).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 使 `+=` 生效的特殊方法是 `__iadd__`（代表“就地加法”）。
- en: 'However, if `__iadd__` is not implemented, Python falls back to calling `__add__`.
    Consider this simple expression:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果未实现 `__iadd__`，Python 将退而求其次调用 `__add__`。考虑这个简单的表达式：
- en: '[PRE50]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If `a` implements `__iadd__`, that will be called. In the case of mutable sequences
    (e.g., `list`, `bytearray`, `array.array`), `a` will be changed in place (i.e.,
    the effect will be similar to `a.extend(b)`). However, when `a` does not implement
    `__iadd__`, the expression `a += b` has the same effect as `a = a + b`: the expression
    `a + b` is evaluated first, producing a new object, which is then bound to `a`.
    In other words, the identity of the object bound to `a` may or may not change,
    depending on the availability of `__iadd__`.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `a` 实现了 `__iadd__`，那么将会调用它。对于可变序列（例如 `list`、`bytearray`、`array.array`），`a`
    将会就地更改（即效果类似于 `a.extend(b)`）。然而，当 `a` 没有实现 `__iadd__` 时，表达式 `a += b` 的效果与 `a =
    a + b` 相同：首先计算表达式 `a + b`，产生一个新对象，然后将其绑定到 `a`。换句话说，取决于是否有 `__iadd__`，绑定到 `a` 的对象的标识可能会改变或不会改变。
- en: In general, for mutable sequences, it is a good bet that `__iadd__` is implemented
    and that `+=` happens in place. For immutable sequences, clearly there is no way
    for that to happen.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，对于可变序列，可以肯定会实现 `__iadd__`，并且 `+=` 会就地发生。对于不可变序列，显然不可能发生这种情况。
- en: 'What I just wrote about `+=` also applies to `*=`, which is implemented via
    `__imul__`. The `__iadd__` and `__imul__` special methods are discussed in [Chapter 16](ch16.html#operator_overloading).
    Here is a demonstration of `*=` with a mutable sequence and then an immutable
    one:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚刚写的关于 `+=` 的内容也适用于 `*=`，它是通过 `__imul__` 实现的。`__iadd__` 和 `__imul__` 特殊方法在
    [第 16 章](ch16.html#operator_overloading) 中有讨论。这里展示了对可变序列和不可变序列使用 `*=` 的演示：
- en: '[PRE51]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[![1](assets/1.png)](#co_an_array_of_sequences_CO15-1)'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_an_array_of_sequences_CO15-1)'
- en: ID of the initial list.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 初始列表的 ID。
- en: '[![2](assets/2.png)](#co_an_array_of_sequences_CO15-2)'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_an_array_of_sequences_CO15-2)'
- en: After multiplication, the list is the same object, with new items appended.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 经过乘法运算后，列表仍然是同一个对象，只是附加了新项。
- en: '[![3](assets/3.png)](#co_an_array_of_sequences_CO15-3)'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_an_array_of_sequences_CO15-3)'
- en: ID of the initial tuple.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 初始元组的 ID。
- en: '[![4](assets/4.png)](#co_an_array_of_sequences_CO15-4)'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_an_array_of_sequences_CO15-4)'
- en: After multiplication, a new tuple was created.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 经过乘法运算后，创建了一个新的元组。
- en: Repeated concatenation of immutable sequences is inefficient, because instead
    of just appending new items, the interpreter has to copy the whole target sequence
    to create a new one with the new items concatenated.^([8](ch02.html#idm46582507630144))
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 对不可变序列的重复连接是低效的，因为解释器不仅仅是附加新项，还必须复制整个目标序列，以创建一个新的序列，其中包含新附加的项。^([8](ch02.html#idm46582507630144))
- en: We’ve seen common use cases for `+=`. The next section shows an intriguing corner
    case that highlights what “immutable” really means in the context of tuples.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 `+=` 的常见用法。下一节将展示一个引人入胜的特殊情况，突显了在元组上“不可变”在实际中意味着什么。
- en: A += Assignment Puzzler
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A += 赋值谜题
- en: 'Try to answer without using the console: what is the result of evaluating the
    two expressions in [Example 2-16](#ex_aug_item_assign_question)?^([9](ch02.html#idm46582507624544))'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在不使用控制台的情况下回答：评估 [示例 2-16](#ex_aug_item_assign_question) 中的两个表达式的结果是什么？^([9](ch02.html#idm46582507624544))
- en: Example 2-16\. A riddle
  id: totrans-442
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-16\. 一个谜题
- en: '[PRE52]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'What happens next? Choose the best answer:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来会发生什么？选择最佳答案： '
- en: '`t` becomes `(1, 2, [30, 40, 50, 60])`.'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`t` 变成了 `(1, 2, [30, 40, 50, 60])`。'
- en: '`TypeError` is raised with the message `''tuple'' object does not support item
    assignment`.'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引发 `TypeError`，消息为 `'tuple' object does not support item assignment`。
- en: Neither.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无。
- en: Both A and B.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A 和 B 都是。
- en: When I saw this, I was pretty sure the answer was B, but it’s actually D, “Both
    A and B”! [Example 2-17](#ex_aug_item_assign_solution) is the actual output from
    a Python 3.9 console.^([10](ch02.html#idm46582507593808))
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 当我看到这个时，我非常确定答案是 B，但实际上是 D，“A 和 B 都是”！[示例 2-17](#ex_aug_item_assign_solution)
    是来自 Python 3.9 控制台的实际输出。^([10](ch02.html#idm46582507593808))
- en: 'Example 2-17\. The unexpected result: item t2 is changed *and* an exception
    is raised'
  id: totrans-450
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-17\. 意外结果：项目 t2 被更改 *并且* 引发异常
- en: '[PRE53]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[Online Python Tutor](https://fpy.li/2-14) is an awesome online tool to visualize
    how Python works in detail. [Figure 2-5](#aug_item_assign_tutor) is a composite
    of two screenshots showing the initial and final states of the tuple `t` from
    [Example 2-17](#ex_aug_item_assign_solution).'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '[在线 Python Tutor](https://fpy.li/2-14) 是一个很棒的在线工具，可以详细展示 Python 的工作原理。[图 2-5](#aug_item_assign_tutor)
    是两个截图的组合，显示了来自 [示例 2-17](#ex_aug_item_assign_solution) 的元组 `t` 的初始状态和最终状态。'
- en: '![References diagram](assets/flpy_0205.png)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
  zh: '![参考图表](assets/flpy_0205.png)'
- en: Figure 2-5\. Initial and final state of the tuple assignment puzzler (diagram
    generated by Online Python Tutor).
  id: totrans-454
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-5\. 元组赋值谜题的初始状态和最终状态（由在线 Python Tutor 生成的图表）。
- en: If you look at the bytecode Python generates for the expression `s[a] += b`
    ([Example 2-18](#ex_aug_item_assign_bytecode)), it becomes clear how that happens.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查看 Python 为表达式 `s[a] += b` 生成的字节码时（[示例 2-18](#ex_aug_item_assign_bytecode)），就会清楚这是如何发生的。
- en: Example 2-18\. Bytecode for the expression `s[a] += b`
  id: totrans-456
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-18\. 表达式 `s[a] += b` 的字节码
- en: '[PRE54]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[![1](assets/1.png)](#co_an_array_of_sequences_CO16-1)'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_an_array_of_sequences_CO16-1)'
- en: Put the value of `s[a]` on `TOS` (Top Of Stack).
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `s[a]` 的值放在 `TOS`（栈顶）上。
- en: '[![2](assets/2.png)](#co_an_array_of_sequences_CO16-2)'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_an_array_of_sequences_CO16-2)'
- en: Perform `TOS += b`. This succeeds if `TOS` refers to a mutable object (it’s
    a list, in [Example 2-17](#ex_aug_item_assign_solution)).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 `TOS += b`。如果 `TOS` 指向一个可变对象（就像在 [示例 2-17](#ex_aug_item_assign_solution)
    中的列表），那么这将成功。
- en: '[![3](assets/3.png)](#co_an_array_of_sequences_CO16-3)'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_an_array_of_sequences_CO16-3)'
- en: Assign `s[a] = TOS`. This fails if `s` is immutable (the `t` tuple in [Example 2-17](#ex_aug_item_assign_solution)).
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `s[a] = TOS`。如果 `s` 是不可变的（例如 [示例 2-17](#ex_aug_item_assign_solution) 中的元组
    `t`），则此操作失败。
- en: This example is quite a corner case—in 20 years using Python, I have never seen
    this strange behavior actually bite somebody.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是一个非常特殊的情况，在使用 Python 20 年中，我从未见过这种奇怪的行为实际上影响到任何人。
- en: 'I take three lessons from this:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 我从中得到了三个教训：
- en: Avoid putting mutable items in tuples.
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免将可变项放入元组中。
- en: Augmented assignment is not an atomic operation—we just saw it throwing an exception
    after doing part of its job.
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强赋值不是一个原子操作——我们刚刚看到它在完成部分工作后抛出异常。
- en: Inspecting Python bytecode is not too difficult, and can be helpful to see what
    is going on under the hood.
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查Python字节码并不太困难，而且可以帮助我们了解底层发生了什么。
- en: 'After witnessing the subtleties of using `+` and `*` for concatenation, we
    can change the subject to another essential operation with sequences: sorting.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在见识了使用`+`和`*`进行连接的微妙之后，我们可以将话题转向另一个与序列相关的重要操作：排序。
- en: list.sort Versus the sorted Built-In
  id: totrans-470
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`list.sort`与内置的`sorted`的比较'
- en: 'The `list.sort` method sorts a list in place—that is, without making a copy.
    It returns `None` to remind us that it changes the receiver^([11](ch02.html#idm46582495279600))
    and does not create a new list. This is an important Python API convention: functions
    or methods that change an object in place should return `None` to make it clear
    to the caller that the receiver was changed, and no new object was created. Similar
    behavior can be seen, for example, in the `random.shuffle(s)` function, which
    shuffles the mutable sequence `s` in place, and returns `None`.'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '`list.sort`方法原地对列表进行排序，即不创建副本。它返回`None`以提醒我们它改变了接收者^([11](ch02.html#idm46582495279600))，并且没有创建新列表。这是一个重要的Python
    API约定：在原地更改对象的函数或方法应该返回`None`，以明确告诉调用者接收者已被更改，没有创建新对象。例如，`random.shuffle(s)`函数也表现出类似的行为，它原地对可变序列`s`进行洗牌，并返回`None`。'
- en: Note
  id: totrans-472
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The convention of returning `None` to signal in-place changes has a drawback:
    we cannot cascade calls to those methods. In contrast, methods that return new
    objects (e.g., all `str` methods) can be cascaded in the fluent interface style.
    See Wikipedia’s [“Fluent interface” entry](https://fpy.li/2-15) for further description
    of this topic.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`None`以表示原地更改的约定存在一个缺点：我们无法级联调用这些方法。相反，返回新对象的方法（例如，所有`str`方法）可以以流畅接口风格级联。请参阅维基百科的[“流畅接口”条目](https://fpy.li/2-15)以进一步描述这个主题。
- en: In contrast, the built-in function `sorted` creates a new list and returns it.
    It accepts any iterable object as an argument, including immutable sequences and
    generators (see [Chapter 17](ch17.html#iterables2generators)). Regardless of the
    type of iterable given to `sorted`, it always returns a newly created list.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，内置函数`sorted`创建一个新列表并返回它。它接受任何可迭代对象作为参数，包括不可变序列和生成器（参见[第17章](ch17.html#iterables2generators)）。无论给`sorted`的可迭代对象的类型是什么，它总是返回一个新创建的列表。
- en: 'Both `list.sort` and `sorted` take two optional, keyword-only arguments:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '`list.sort`和`sorted`都接受两个可选的、仅限关键字的参数：'
- en: '`reverse`'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverse`'
- en: If `True`, the items are returned in descending order (i.e., by reversing the
    comparison of the items). The default is `False`.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为`True`，则按降序（即，通过反转项目的比较）返回项目。默认值为`False`。
- en: '`key`'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '`key`'
- en: A one-argument function that will be applied to each item to produce its sorting
    key. For example, when sorting a list of strings, `key=str.lower` can be used
    to perform a case-insensitive sort, and `key=len` will sort the strings by character
    length. The default is the identity function (i.e., the items themselves are compared).
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 一个参数函数，将被应用于每个项目以生成其排序键。例如，当对字符串列表进行排序时，可以使用`key=str.lower`执行不区分大小写的排序，`key=len`将按字符长度对字符串进行排序。默认是恒等函数（即，比较项目本身）。
- en: Tip
  id: totrans-480
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You can also use the optional keyword parameter `key` with the `min()` and `max()`
    built-ins and with other functions from the standard library (e.g., `itertools.groupby()`
    and `heapq.nlargest()`).
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在`min()`和`max()`内置函数以及标准库中的其他函数（例如`itertools.groupby()`和`heapq.nlargest()`）中使用可选的关键字参数`key`。
- en: Here are a few examples to clarify the use of these functions and keyword arguments.
    The examples also demonstrate that Python’s sorting algorithm is stable (i.e.,
    it preserves the relative ordering of items that compare equally):^([12](ch02.html#idm46582495259904))
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例来澄清这些函数和关键字参数的使用。这些示例还演示了Python的排序算法是稳定的（即，它保留了相等比较的项目的相对顺序）：^([12](ch02.html#idm46582495259904))
- en: '[PRE55]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[![1](assets/1.png)](#co_an_array_of_sequences_CO17-1)'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_an_array_of_sequences_CO17-1)'
- en: This produces a new list of strings sorted alphabetically.^([13](ch02.html#idm46582495143296))
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: ���将产生一个按字母顺序排序的新字符串列表。^([13](ch02.html#idm46582495143296))
- en: '[![2](assets/2.png)](#co_an_array_of_sequences_CO17-2)'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_an_array_of_sequences_CO17-2)'
- en: Inspecting the original list, we see it is unchanged.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 检查原始列表，我们看到它没有改变。
- en: '[![3](assets/3.png)](#co_an_array_of_sequences_CO17-3)'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_an_array_of_sequences_CO17-3)'
- en: This is the previous “alphabetical” ordering, reversed.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 这是之前的“字母顺序”，但是反转了。
- en: '[![4](assets/4.png)](#co_an_array_of_sequences_CO17-4)'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_an_array_of_sequences_CO17-4)'
- en: A new list of strings, now sorted by length. Because the sorting algorithm is
    stable, “grape” and “apple,” both of length 5, are in the original order.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 一个按长度排序的新字符串列表。由于排序算法是稳定的，“葡萄”和“苹果”，长度均为5，按原始顺序排列。
- en: '[![5](assets/5.png)](#co_an_array_of_sequences_CO17-5)'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_an_array_of_sequences_CO17-5)'
- en: These are the strings sorted by length in descending order. It is not the reverse
    of the previous result because the sorting is stable, so again “grape” appears
    before “apple.”
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是按长度降序排序的字符串。这不是前一个结果的反转，因为排序是稳定的，所以“葡萄”再次出现在“苹果”之前。
- en: '[![6](assets/6.png)](#co_an_array_of_sequences_CO17-6)'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_an_array_of_sequences_CO17-6)'
- en: So far, the ordering of the original `fruits` list has not changed.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，原始`fruits`列表的顺序没有改变。
- en: '[![7](assets/7.png)](#co_an_array_of_sequences_CO17-7)'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_an_array_of_sequences_CO17-7)'
- en: This sorts the list in place, and returns `None` (which the console omits).
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 这会原地对列表进行排序，并返回`None`（控制台省略了这一点）。
- en: '[![8](assets/8.png)](#co_an_array_of_sequences_CO17-8)'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_an_array_of_sequences_CO17-8)'
- en: Now `fruits` is sorted.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`fruits`已经排序。
- en: Warning
  id: totrans-500
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: By default, Python sorts strings lexicographically by character code. That means
    ASCII uppercase letters will come before lowercase letters, and non-ASCII characters
    are unlikely to be sorted in a sensible way. [“Sorting Unicode Text”](ch04.html#sorting_unicode_sec)
    covers proper ways of sorting text as humans would expect.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Python按字符代码按字典顺序对字符串进行排序。这意味着ASCII大写字母将排在小写字母之前，非ASCII字符不太可能以合理的方式排序。[“对Unicode文本进行排序”](ch04.html#sorting_unicode_sec)介绍了按人类期望的方式对文本进行排序的正确方法。
- en: Once your sequences are sorted, they can be very efficiently searched. A binary
    search algorithm is already provided in the `bisect` module of the Python standard
    library. That module also includes the `bisect.insort` function, which you can
    use to make sure that your sorted sequences stay sorted. You’ll find an illustrated
    introduction to the `bisect` module in the [“Managing Ordered Sequences with Bisect”](https://fpy.li/bisect)
    post in the [*fluentpython.com*](http://fluentpython.com) companion website.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的序列被排序，它们可以被非常高效地搜索。Python标准库的`bisect`模块中已经提供了二分搜索算法。该模块还包括`bisect.insort`函数，您可以使用它来确保您的排序序列保持排序。您可以在[*fluentpython.com*](http://fluentpython.com)伴随网站的[“使用Bisect管理有序序列”](https://fpy.li/bisect)文章中找到`bisect`模块的图解介绍。
- en: Much of what we have seen so far in this chapter applies to sequences in general,
    not just lists or tuples. Python programmers sometimes overuse the `list` type
    because it is so handy—I know I’ve done it. For example, if you are processing
    large lists of numbers, you should consider using arrays instead. The remainder
    of the chapter is devoted to alternatives to lists and tuples.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中所��到的大部分内容都适用于一般序列，而不仅仅是列表或元组。Python程序员有时会过度使用`list`类型，因为它非常方便——我知道我曾经这样做过。例如，如果您正在处理大量数字列表，应考虑改用数组。本章的其余部分致力于列表和元组的替代方案。
- en: When a List Is Not the Answer
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当列表不是答案时
- en: The `list` type is flexible and easy to use, but depending on specific requirements,
    there are better options. For example, an `array` saves a lot of memory when you
    need to handle millions of floating-point values. On the other hand, if you are
    constantly adding and removing items from opposite ends of a list, it’s good to
    know that a `deque` (double-ended queue) is a more efficient FIFO^([14](ch02.html#idm46582495074352))
    data structure.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`类型灵活且易于使用，但根据具体要求，有更好的选择。例如，当需要处理数百万个浮点值时，`array`可以节省大量内存。另一方面，如果您不断地向列表的两端添加和删除项目，那么了解`deque`（双端队列）是一种更高效的FIFO^([14](ch02.html#idm46582495074352))数据结构是很有用的。'
- en: Tip
  id: totrans-506
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If your code frequently checks whether an item is present in a collection (e.g.,
    `item in my_collection`), consider using a `set` for `my_collection`, especially
    if it holds a large number of items. Sets are optimized for fast membership checking.
    They are also iterable, but they are not sequences because the ordering of set
    items is unspecified. We cover them in [Chapter 3](ch03.html#dicts-a-to-z).
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的代码经常检查集合中是否存在某个项目（例如，`item in my_collection`），请考虑使用`set`代替`my_collection`，特别是如果它包含大量项目。集合针对快速成员检查进行了优化。它们也是可迭代的，但它们不是序列，因为集合项的顺序是未指定的。我们将在[第3章](ch03.html#dicts-a-to-z)中介绍它们。
- en: For the remainder of this chapter, we discuss mutable sequence types that can
    replace lists in many cases, starting with arrays.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分中，我们将讨论可以在许多情况下替代列表的可变序列类型，从数组开始。
- en: Arrays
  id: totrans-509
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: If a list only contains numbers, an `array.array` is a more efficient replacement.
    Arrays support all mutable sequence operations (including `.pop`, `.insert`, and
    `.extend`), as well as additional methods for fast loading and saving, such as
    `.frombytes` and `.tofile`.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列表只包含数字，`array.array`是更高效的替代品。数组支持所有可变序列操作（包括`.pop`、`.insert`和`.extend`），以及用于快速加载和保存的附加方法，如`.frombytes`和`.tofile`。
- en: A Python array is as lean as a C array. As shown in [Figure 2-1](#container_v_flat_img),
    an `array` of `float` values does not hold full-fledged `float` instances, but
    only the packed bytes representing their machine values—similar to an array of
    `double` in the C language. When creating an `array`, you provide a typecode,
    a letter to determine the underlying C type used to store each item in the array.
    For example, `b` is the typecode for what C calls a `signed char`, an integer
    ranging from –128 to 127. If you create an `array('b')`, then each item will be
    stored in a single byte and interpreted as an integer. For large sequences of
    numbers, this saves a lot of memory. And Python will not let you put any number
    that does not match the type for the array.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: Python数组与C数组一样精简。如[图 2-1](#container_v_flat_img)所示，`float`值的`array`不保存完整的`float`实例，而只保存代表其机器值的打包字节——类似于C语言中的`double`数组。创建`array`时，您提供一个类型码，一个用于确定数组中每个项目存储的基础C类型的字母。例如，`b`是C中称为`signed
    char`的类型码，一个范围从-128到127的整数。如果创建一个`array('b')`，那么每个项目将存储在一个字节中，并解释为整数。对于大量数字序列，这可以节省大量内存。Python不会让您放入与数组类型不匹配的任何数字。
- en: '[Example 2-19](#ex_array_io) shows creating, saving, and loading an array of
    10 million floating-point random numbers.'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2-19](#ex_array_io)展示了创建、保存和加载一个包含1000万个浮点随机数的数组。'
- en: Example 2-19\. Creating, saving, and loading a large array of floats
  id: totrans-513
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例2-19\. 创建、保存和加载大量浮点数的数组
- en: '[PRE56]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[![1](assets/1.png)](#co_an_array_of_sequences_CO18-1)'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_an_array_of_sequences_CO18-1)'
- en: Import the `array` type.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 导入`array`类型。
- en: '[![2](assets/2.png)](#co_an_array_of_sequences_CO18-2)'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_an_array_of_sequences_CO18-2)'
- en: Create an array of double-precision floats (typecode `'d'`) from any iterable
    object—in this case, a generator expression.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 从任何可迭代对象（在本例中是生成器表达式）创建双精度浮点数（类型码`'d'`）的数组。
- en: '[![3](assets/3.png)](#co_an_array_of_sequences_CO18-3)'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_an_array_of_sequences_CO18-3)'
- en: Inspect the last number in the array.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 检查数组中的最后一个数字。
- en: '[![4](assets/4.png)](#co_an_array_of_sequences_CO18-4)'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_an_array_of_sequences_CO18-4)'
- en: Save the array to a binary file.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 将数组保存到二进制文件。
- en: '[![5](assets/5.png)](#co_an_array_of_sequences_CO18-5)'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_an_array_of_sequences_CO18-5)'
- en: Create an empty array of doubles.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个空的双精度数组。
- en: '[![6](assets/6.png)](#co_an_array_of_sequences_CO18-6)'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_an_array_of_sequences_CO18-6)'
- en: Read 10 million numbers from the binary file.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 从二进制文件中读取1000万个数字。
- en: '[![7](assets/7.png)](#co_an_array_of_sequences_CO18-7)'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_an_array_of_sequences_CO18-7)'
- en: Inspect the last number in the array.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 检查数组中的最后一个数字。
- en: '[![8](assets/8.png)](#co_an_array_of_sequences_CO18-8)'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_an_array_of_sequences_CO18-8)'
- en: Verify that the contents of the arrays match.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 验证数组内容是否匹配。
- en: As you can see, `array.tofile` and `array.fromfile` are easy to use. If you
    try the example, you’ll notice they are also very fast. A quick experiment shows
    that it takes about 0.1 seconds for `array.fromfile` to load 10 million double-precision
    floats from a binary file created with `array.tofile`. That is nearly 60 times
    faster than reading the numbers from a text file, which also involves parsing
    each line with the `float` built-in. Saving with `array.tofile` is about seven
    times faster than writing one float per line in a text file. In addition, the
    size of the binary file with 10 million doubles is 80,000,000 bytes (8 bytes per
    double, zero overhead), while the text file has 181,515,739 bytes for the same
    data.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`array.tofile`和`array.fromfile`非常易于使用。如果尝试示例，您会注意到它们也非常快速。一个快速实验显示，`array.fromfile`从使用`array.tofile`创建的二进制文件中加载1000万个双精度浮点数大约需要0.1秒。这几乎比从文本文件中读取数字快60倍，后者还涉及使用内置的`float`解析每一行。使用`array.tofile`保存的速度大约比在文本文件中每行写一个浮点数快七倍。此外，具有1000万个双精度浮点数的二进制文件的大小为80000000字节（每个双精度浮点数8字节，零开销），而相同数据的文本文件大小为181515739字节。
- en: For the specific case of numeric arrays representing binary data, such as raster
    images, Python has the `bytes` and `bytearray` types discussed in [Chapter 4](ch04.html#strings_bytes_files).
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 对于表示二进制数据的数字数组的特定情况，例如光栅图像，Python 中有`bytes`和`bytearray`类型，详见[第4章](ch04.html#strings_bytes_files)。
- en: We wrap up this section on arrays with [Table 2-3](#list_x_array_attrs_tbl),
    comparing the features of `list` and `array.array`.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过[表2-3](#list_x_array_attrs_tbl)总结了数组部分，比较了`list`和`array.array`的特性。
- en: Table 2-3\. Methods and attributes found in `list` or `array` (deprecated array
    methods and those also implemented by object are omitted for brevity)
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-3。`list`或`array`中找到的方法和属性（为简洁起见，省略了已弃用的数组方法和对象也实现的方法）
- en: '|  | list | array |   |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
  zh: '|  | 列表 | 数组 |   |'
- en: '| --- | --- | --- | --- |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `s.__add__(s2)` | ● | ● | `s + s2`—concatenation |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
  zh: '| `s.__add__(s2)` | ● | ● | `s + s2`—连接 |'
- en: '| `s.__iadd__(s2)` | ● | ● | `s += s2`—in-place concatenation |'
  id: totrans-538
  prefs: []
  type: TYPE_TB
  zh: '| `s.__iadd__(s2)` | ● | ● | `s += s2`—原地连接 |'
- en: '| `s.append(e)` | ● | ● | Append one element after last |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '| `s.append(e)` | ● | ● | 在最后一个元素后追加一个元素 |'
- en: '| `s.byteswap()` |  | ● | Swap bytes of all items in array for endianness conversion
    |'
  id: totrans-540
  prefs: []
  type: TYPE_TB
  zh: '| `s.byteswap()` |  | ● | 交换数组中所有项目的字节以进行字节顺序转换 |'
- en: '| `s.clear()` | ● |  | Delete all items |'
  id: totrans-541
  prefs: []
  type: TYPE_TB
  zh: '| `s.clear()` | ● |  | 删除所有项目 |'
- en: '| `s.__contains__(e)` | ● | ● | `e in s` |'
  id: totrans-542
  prefs: []
  type: TYPE_TB
  zh: '| `s.__contains__(e)` | ● | ● | `e in s` |'
- en: '| `s.copy()` | ● |  | Shallow copy of the list |'
  id: totrans-543
  prefs: []
  type: TYPE_TB
  zh: '| `s.copy()` | ● |  | 列表的浅拷贝 |'
- en: '| `s.__copy__()` |  | ● | Support for `copy.copy` |'
  id: totrans-544
  prefs: []
  type: TYPE_TB
  zh: '| `s.__copy__()` |  | ● | 支持`copy.copy` |'
- en: '| `s.count(e)` | ● | ● | Count occurrences of an element |'
  id: totrans-545
  prefs: []
  type: TYPE_TB
  zh: '| `s.count(e)` | ● | ● | 计算元素的出现次数 |'
- en: '| `s.__deepcopy__()` |  | ● | Optimized support for `copy.deepcopy` |'
  id: totrans-546
  prefs: []
  type: TYPE_TB
  zh: '| `s.__deepcopy__()` |  | ● | 优化支持`copy.deepcopy` |'
- en: '| `s.__delitem__(p)` | ● | ● | Remove item at position `p` |'
  id: totrans-547
  prefs: []
  type: TYPE_TB
  zh: '| `s.__delitem__(p)` | ● | ● | 移除位置`p`处的项目 |'
- en: '| `s.extend(it)` | ● | ● | Append items from iterable `it` |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
  zh: '| `s.extend(it)` | ● | ● | 从可迭代对象`it`中追加项目 |'
- en: '| `s.frombytes(b)` |  | ● | Append items from byte sequence interpreted as
    packed machine values |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '| `s.frombytes(b)` |  | ● | 从字节序列中解释为打包的机器值追加项目 |'
- en: '| `s.fromfile(f, n)` |  | ● | Append `n` items from binary file `f` interpreted
    as packed machine values |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '| `s.fromfile(f, n)` |  | ● | 从解释为打包的机器值的二进制文件`f`追加`n`个项目 |'
- en: '| `s.fromlist(l)` |  | ● | Append items from list; if one causes `TypeError`,
    none are appended |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
  zh: '| `s.fromlist(l)` |  | ● | 从列表追加项目；如果一个导致`TypeError`，则不追加任何项目 |'
- en: '| `s.__getitem__(p)` | ● | ● | `s[p]`—get item or slice at position |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '| `s.__getitem__(p)` | ● | ● | `s[p]`—获取位置处的项目或切片 |'
- en: '| `s.index(e)` | ● | ● | Find position of first occurrence of `e` |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '| `s.index(e)` | ● | ● | 查找`e`的第一个出现位置 |'
- en: '| `s.insert(p, e)` | ● | ● | Insert element `e` before the item at position
    `p` |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
  zh: '| `s.insert(p, e)` | ● | ● | 在位置`p`的项目之前插入元素`e` |'
- en: '| `s.itemsize` |  | ● | Length in bytes of each array item |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '| `s.itemsize` |  | ● | 每个数组项的字节长度 |'
- en: '| `s.__iter__()` | ● | ● | Get iterator |'
  id: totrans-556
  prefs: []
  type: TYPE_TB
  zh: '| `s.__iter__()` | ● | ● | 获取迭代器 |'
- en: '| `s.__len__()` | ● | ● | `len(s)`—number of items |'
  id: totrans-557
  prefs: []
  type: TYPE_TB
  zh: '| `s.__len__()` | ● | ● | `len(s)`—项目数 |'
- en: '| `s.__mul__(n)` | ● | ● | `s * n`—repeated concatenation |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '| `s.__mul__(n)` | ● | ● | `s * n`—重复连接 |'
- en: '| `s.__imul__(n)` | ● | ● | `s *= n`—in-place repeated concatenation |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '| `s.__imul__(n)` | ● | ● | `s *= n`—原地重复连接 |'
- en: '| `s.__rmul__(n)` | ● | ● | `n * s`—reversed repeated concatenation^([a](ch02.html#idm46582494751072))
    |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '| `s.__rmul__(n)` | ● | ● | `n * s`—反向重复连接^([a](ch02.html#idm46582494751072))
    |'
- en: '| `s.pop([p])` | ● | ● | Remove and return item at position `p` (default: last)
    |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '| `s.pop([p])` | ● | ● | 移除并返回位置`p`处的项目（默认为最后一个） |'
- en: '| `s.remove(e)` | ● | ● | Remove first occurrence of element `e` by value |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '| `s.remove(e)` | ● | ● | 通过值删除元素`e`的第一个出现 |'
- en: '| `s.reverse()` | ● | ● | Reverse the order of the items in place |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '| `s.reverse()` | ● | ● | 原地反转项目的顺序 |'
- en: '| `s.__reversed__()` | ● |  | Get iterator to scan items from last to first
    |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '| `s.__reversed__()` | ● |  | 获取从最后到第一个扫描项目的迭代器 |'
- en: '| `s.__setitem__(p, e)` | ● | ● | `s[p] = e`—put `e` in position `p`, overwriting
    existing item or slice |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '| `s.__setitem__(p, e)` | ● | ● | `s[p] = e`—将`e`放在位置`p`，覆盖现有项��或切片 |'
- en: '| `s.sort([key], [reverse])` | ● |  | Sort items in place with optional keyword
    arguments `key` and `reverse` |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
  zh: '| `s.sort([key], [reverse])` | ● |  | 使用可选关键字参数`key`和`reverse`原地对项目进行排序 |'
- en: '| `s.tobytes()` |  | ● | Return items as packed machine values in a `bytes`
    object |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
  zh: '| `s.tobytes()` |  | ● | 以`bytes`对象的形式返回打包的机器值 |'
- en: '| `s.tofile(f)` |  | ● | Save items as packed machine values to binary file
    `f` |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '| `s.tofile(f)` |  | ● | 将项目保存为打包的机器值到二进制文件`f` |'
- en: '| `s.tolist()` |  | ● | Return items as numeric objects in a `list` |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
  zh: '| `s.tolist()` |  | ● | 以`list`中的数值对象形式返回项目 |'
- en: '| `s.typecode` |  | ● | One-character string identifying the C type of the
    items |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
  zh: '| `s.typecode` |  | ● | 用于标识项目的C类型的单字符字符串 |'
- en: '| ^([a](ch02.html#idm46582494751072-marker)) Reversed operators are explained
    in [Chapter 16](ch16.html#operator_overloading). |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch02.html#idm46582494751072-marker)) 反向运算符在 [第 16 章](ch16.html#operator_overloading)
    中有解释。 |'
- en: Tip
  id: totrans-572
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'As of Python 3.10, the `array` type does not have an in-place `sort` method
    like `list.sort()`. If you need to sort an array, use the built-in `sorted` function
    to rebuild the array:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Python 3.10，`array` 类型没有像 `list.sort()` 那样的原地 `sort` 方法。如果需要对数组进行排序，请使用内置的
    `sorted` 函数重新构建数组：
- en: '[PRE57]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: To keep a sorted array sorted while adding items to it, use the [`bisect.insort`](https://fpy.li/2-16)
    function.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 要在向数组添加项目时保持已排序数组的排序，请使用 [`bisect.insort`](https://fpy.li/2-16) 函数。
- en: If you do a lot of work with arrays and don’t know about `memoryview`, you’re
    missing out. See the next topic.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您经常使用数组并且不了解 `memoryview`，那么您会错过很多。请看下一个主题。
- en: Memory Views
  id: totrans-577
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存视图
- en: 'The built-in `memoryview` class is a shared-memory sequence type that lets
    you handle slices of arrays without copying bytes. It was inspired by the NumPy
    library (which we’ll discuss shortly in [“NumPy”](#numpy_sec)). Travis Oliphant,
    lead author of NumPy, answers the question, [“When should a memoryview be used?”](https://fpy.li/2-17)
    like this:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 `memoryview` ���是一个共享内存序列类型，允许您处理数组的切片而无需复制字节。它受到 NumPy 库的启发（我们将在 [“NumPy”](#numpy_sec)
    中讨论）。NumPy 的首席作者 Travis Oliphant 对于何时应该使用 `memoryview` 的问题的回答是这样的：[“何时应该使用 memoryview？”](https://fpy.li/2-17)
- en: A memoryview is essentially a generalized NumPy array structure in Python itself
    (without the math). It allows you to share memory between data-structures (things
    like PIL images, SQLite databases, NumPy arrays, etc.) without first copying.
    This is very important for large data sets.
  id: totrans-579
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 内存视图本质上是 Python 中的一个广义 NumPy 数组结构（不涉及数学）。它允许您在不复制字节的情况下在数据结构之间共享内存（例如 PIL 图像、SQLite
    数据库、NumPy 数组等）。这对于大型数据集非常重要。
- en: Using notation similar to the `array` module, the `memoryview.cast` method lets
    you change the way multiple bytes are read or written as units without moving
    bits around. `memoryview.cast` returns yet another `memoryview` object, always
    sharing the same memory.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似于 `array` 模块的符号，`memoryview.cast` 方法允许您更改多个字节的读取或写入方式，而无需移动位。`memoryview.cast`
    总是返���另一个共享相同内存的 `memoryview` 对象。
- en: '[Example 2-20](#ex_memoryview_demo) shows how to create alternate views on
    the same array of 6 bytes, to operate on it as a 2×3 matrix or a 3×2 matrix.'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2-20](#ex_memoryview_demo) 展示了如何在相同的 6 个字节数组上创建替代视图，以便将其视为 2×3 矩阵或 3×2
    矩阵进行操作。'
- en: Example 2-20\. Handling 6 bytes of memory as 1×6, 2×3, and 3×2 views
  id: totrans-582
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-20\. 将 6 个字节的内存处理为 1×6、2×3 和 3×2 视图
- en: '[PRE58]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[![1](assets/1.png)](#co_an_array_of_sequences_CO19-1)'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_an_array_of_sequences_CO19-1)'
- en: Build array of 6 bytes (typecode `'B'`).
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 构建包含 6 个字节的数组（类型码为 `'B'`）。
- en: '[![2](assets/2.png)](#co_an_array_of_sequences_CO19-2)'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_an_array_of_sequences_CO19-2)'
- en: Build `memoryview` from that array, then export it as a list.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 从该数组构建 `memoryview`，然后将其导出为列表。
- en: '[![3](assets/3.png)](#co_an_array_of_sequences_CO19-3)'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_an_array_of_sequences_CO19-3)'
- en: Build new `memoryview` from that previous one, but with `2` rows and `3` columns.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 从先前的 `memoryview` 创建新的 `memoryview`，但具有 `2` 行和 `3` 列。
- en: '[![4](assets/4.png)](#co_an_array_of_sequences_CO19-4)'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_an_array_of_sequences_CO19-4)'
- en: Yet another `memoryview`, now with `3` rows and `2` columns.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 `memoryview`，现在有 `3` 行和 `2` 列。
- en: '[![5](assets/5.png)](#co_an_array_of_sequences_CO19-5)'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_an_array_of_sequences_CO19-5)'
- en: Overwrite byte in `m2` at row `1`, column `1` with `22`.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `m2` 的第 `1` 行、第 `1` 列覆盖字节为 `22`。
- en: '[![6](assets/6.png)](#co_an_array_of_sequences_CO19-6)'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_an_array_of_sequences_CO19-6)'
- en: Overwrite byte in `m3` at row `1`, column `1` with `33`.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `m3` 的第 `1` 行、第 `1` 列覆盖字节为 `33`。
- en: '[![7](assets/7.png)](#co_an_array_of_sequences_CO19-7)'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_an_array_of_sequences_CO19-7)'
- en: Display original array, proving that the memory was shared among `octets`, `m1`,
    `m2`, and `m3`.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 显示原始数组，证明内存在 `octets`、`m1`、`m2` 和 `m3` 之间共享。
- en: The awesome power of `memoryview` can also be used to corrupt. [Example 2-21](#ex_memoryview_evil_demo)
    shows how to change a single byte of an item in an array of 16-bit integers.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '`memoryview` 的强大之处也可以用来损坏。[示例 2-21](#ex_memoryview_evil_demo) 展示了如何更改 16 位整数数组中一个项目的单个字节。'
- en: Example 2-21\. Changing the value of a 16-bit integer array item by poking one
    of its bytes
  id: totrans-599
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-21\. 通过修改一个字节来更改 16 位整数数组项的值
- en: '[PRE59]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[![1](assets/1.png)](#co_an_array_of_sequences_CO20-1)'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_an_array_of_sequences_CO20-1)'
- en: Build `memoryview` from array of 5 16-bit signed integers (typecode `'h'`).
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 从包含 5 个 16 位有符号整数的数组（类型码为 `'h'`）构建 `memoryview`。
- en: '[![2](assets/2.png)](#co_an_array_of_sequences_CO20-2)'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_an_array_of_sequences_CO20-2)'
- en: '`memv` sees the same 5 items in the array.'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '`memv` 在数组中看到相同的 5 个项目。'
- en: '[![3](assets/3.png)](#co_an_array_of_sequences_CO20-3)'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_an_array_of_sequences_CO20-3)'
- en: Create `memv_oct` by casting the elements of `memv` to bytes (typecode `'B'`).
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `memv` 的元素转换为字节（类型码为 `'B'`）来创建 `memv_oct`。
- en: '[![4](assets/4.png)](#co_an_array_of_sequences_CO20-4)'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_an_array_of_sequences_CO20-4)'
- en: Export elements of `memv_oct` as a list of 10 bytes, for inspection.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `memv_oct` 的元素导出为包含 10 个字节的列表，以供检查。
- en: '[![5](assets/5.png)](#co_an_array_of_sequences_CO20-5)'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_an_array_of_sequences_CO20-5)'
- en: Assign value `4` to byte offset `5`.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 将值 `4` 分配给字节偏移 `5`。
- en: '[![6](assets/6.png)](#co_an_array_of_sequences_CO20-6)'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_an_array_of_sequences_CO20-6)'
- en: 'Note the change to `numbers`: a `4` in the most significant byte of a 2-byte
    unsigned integer is `1024`.'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `numbers` 的变化：2 字节无符号整数的最高有效字节中的 `4` 是 `1024`。
- en: Note
  id: totrans-613
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'You’ll find an example of inspecting `memoryview` with the `struct` package
    at [*fluentpython.com*](http://fluentpython.com): [“Parsing binary records with
    struct”](https://fpy.li/2-18).'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在 [*fluentpython.com*](http://fluentpython.com) 上找到使用 `struct` 包检查 `memoryview`
    的示例：[“使用 struct 解析二进制记录”](https://fpy.li/2-18)。
- en: Meanwhile, if you are doing advanced numeric processing in arrays, you should
    be using the NumPy libraries. We’ll take a brief look at them right away.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，如果您在数组中进行高级数值处理，应该使用 NumPy 库。我们将立即简要介绍它们。
- en: NumPy
  id: totrans-616
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NumPy
- en: Throughout this book, I make a point of highlighting what is already in the
    Python standard library so you can make the most of it. But NumPy is so awesome
    that a detour is warranted.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我强调了Python标准库中已经存在的内容，以便您能充分利用它。但是NumPy如此强大，值得一提。
- en: For advanced array and matrix operations, NumPy is the reason why Python became
    mainstream in scientific computing applications. NumPy implements multi-dimensional,
    homogeneous arrays and matrix types that hold not only numbers but also user-defined
    records, and provides efficient element-wise operations.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高级的数组和矩阵操作，NumPy是Python在科学计算应用中变得流行的原因。NumPy实现了多维、同质数组和矩阵类型，不仅保存数字，还保存用户定义的记录，并提供高效的逐元素操作。
- en: 'SciPy is a library, written on top of NumPy, offering many scientific computing
    algorithms from linear algebra, numerical calculus, and statistics. SciPy is fast
    and reliable because it leverages the widely used C and Fortran codebase from
    the [Netlib Repository](https://fpy.li/2-19). In other words, SciPy gives scientists
    the best of both worlds: an interactive prompt and high-level Python APIs, together
    with industrial-strength number-crunching functions optimized in C and Fortran.'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy是一个库，建立在NumPy之上，提供许多来自线性代数、数值微积分和统计学的科学计算算法。SciPy快速可靠，因为它利用了来自[Netlib Repository](https://fpy.li/2-19)的广泛使用的C和Fortran代码库。换句话说，SciPy为科学家提供了最佳的两种选择：交互式提示符和高级Python
    API，以及在C和Fortran中优化的工业强度数值计算函数。
- en: As a very brief NumPy demo, [Example 2-22](#ex_numpy_array) shows some basic
    operations with two-dimensional arrays.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个非常简短的NumPy演示，[示例2-22](#ex_numpy_array)展示了一些关于二维数组的基本操作。
- en: Example 2-22\. Basic operations with rows and columns in a `numpy.ndarray`
  id: totrans-621
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例2-22。在`numpy.ndarray`中进行行和列的基本操作
- en: '[PRE60]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[![1](assets/1.png)](#co_an_array_of_sequences_CO21-1)'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_an_array_of_sequences_CO21-1)'
- en: Import NumPy, after installing (it’s not in the Python standard library). Conventionally,
    `numpy` is imported as `np`.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 导入NumPy，在安装后（不在Python标准库中）。按照惯例，将`numpy`导入为`np`。
- en: '[![2](assets/2.png)](#co_an_array_of_sequences_CO21-2)'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_an_array_of_sequences_CO21-2)'
- en: Build and inspect a `numpy.ndarray` with integers `0` to `11`.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并检查一个包含整数`0`到`11`的`numpy.ndarray`。
- en: '[![3](assets/3.png)](#co_an_array_of_sequences_CO21-3)'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_an_array_of_sequences_CO21-3)'
- en: 'Inspect the dimensions of the array: this is a one-dimensional, 12-element
    array.'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 检查数组的维度：这是一个一维的，包含12个元素的数组。
- en: '[![4](assets/4.png)](#co_an_array_of_sequences_CO21-4)'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_an_array_of_sequences_CO21-4)'
- en: Change the shape of the array, adding one dimension, then inspecting the result.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 改变数组的形状，增加一个维度，然后检查结果。
- en: '[![5](assets/5.png)](#co_an_array_of_sequences_CO21-5)'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_an_array_of_sequences_CO21-5)'
- en: Get row at index `2`.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 获取索引为`2`的行。
- en: '[![6](assets/6.png)](#co_an_array_of_sequences_CO21-6)'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_an_array_of_sequences_CO21-6)'
- en: Get element at index `2, 1`.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 获取索引为`2, 1`的元素。
- en: '[![7](assets/7.png)](#co_an_array_of_sequences_CO21-7)'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_an_array_of_sequences_CO21-7)'
- en: Get column at index `1`.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 获取索引为`1`的列。
- en: '[![8](assets/8.png)](#co_an_array_of_sequences_CO21-8)'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_an_array_of_sequences_CO21-8)'
- en: Create a new array by transposing (swapping columns with rows).
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 通过转置（交换列和行）创建一个新的数组。
- en: 'NumPy also supports high-level operations for loading, saving, and operating
    on all elements of a `numpy.ndarray`:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy还支持用于加载、保存和操作`numpy.ndarray`的高级操作：
- en: '[PRE61]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[![1](assets/1.png)](#co_an_array_of_sequences_CO22-1)'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_an_array_of_sequences_CO22-1)'
- en: Load 10 million floating-point numbers from a text file.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 从文本文件中加载1000万个浮点数。
- en: '[![2](assets/2.png)](#co_an_array_of_sequences_CO22-2)'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_an_array_of_sequences_CO22-2)'
- en: Use sequence slicing notation to inspect the last three numbers.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 使用序列切片表示法检查最后三个数字。
- en: '[![3](assets/3.png)](#co_an_array_of_sequences_CO22-3)'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_an_array_of_sequences_CO22-3)'
- en: Multiply every element in the `floats` array by `.5` and inspect the last three
    elements again.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 将`floats`数组中的每个元素乘以`.5`，然后再次检查最后三个元素。
- en: '[![4](assets/4.png)](#co_an_array_of_sequences_CO22-4)'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_an_array_of_sequences_CO22-4)'
- en: Import the high-resolution performance measurement timer (available since Python
    3.3).
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 导入高分辨率性能测量计时器（自Python 3.3起可用）。
- en: '[![5](assets/5.png)](#co_an_array_of_sequences_CO22-5)'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_an_array_of_sequences_CO22-5)'
- en: Divide every element by `3`; the elapsed time for 10 million floats is less
    than 40 milliseconds.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个元素除以`3`；对于1000万个浮点数，经过的时间不到40毫秒。
- en: '[![6](assets/6.png)](#co_an_array_of_sequences_CO22-6)'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_an_array_of_sequences_CO22-6)'
- en: Save the array in a *.npy* binary file.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 将数组保存为*.npy*二进制文件。
- en: '[![7](assets/7.png)](#co_an_array_of_sequences_CO22-7)'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_an_array_of_sequences_CO22-7)'
- en: Load the data as a memory-mapped file into another array; this allows efficient
    processing of slices of the array even if it does not fit entirely in memory.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据作为内存映射文件加载到另一个数组中；这允许对数组的切片进行高效处理，即使它不能完全放入内存中。
- en: '[![8](assets/8.png)](#co_an_array_of_sequences_CO22-8)'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_an_array_of_sequences_CO22-8)'
- en: Inspect the last three elements after multiplying every element by `6`.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个元素乘以`6`后，检查最后三个元素。
- en: This was just an appetizer.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个开胃菜。
- en: NumPy and SciPy are formidable libraries, and are the foundation of other awesome
    tools such as the [Pandas](https://fpy.li/2-20)—which implements efficient array
    types that can hold nonnumeric data and provides import/export functions for many
    different formats, like *.csv*, *.xls*, SQL dumps, HDF5, etc.—and [scikit-learn](https://fpy.li/2-21),
    currently the most widely used Machine Learning toolset. Most NumPy and SciPy
    functions are implemented in C or C++, and can leverage all CPU cores because
    they release Python’s GIL (Global Interpreter Lock). The [Dask](https://fpy.li/dask)
    project supports parallelizing NumPy, Pandas, and scikit-learn processing across
    clusters of machines. These packages deserve entire books about them. This is
    not one of those books. But no overview of Python sequences would be complete
    without at least a quick look at NumPy arrays.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 和 SciPy 是强大的库，是其他出色工具的基础，比如 [Pandas](https://fpy.li/2-20) — 实现了可以容纳非数值数据的高效数组类型，并提供了许多不同格式的导入/导出功能，如
    *.csv*、*.xls*、SQL dumps、HDF5 等 — 以及 [scikit-learn](https://fpy.li/2-21)，目前是最广泛使用的机器学习工具集。大多数
    NumPy 和 SciPy 函数是用 C 或 C++ 实现的，并且可以利用所有 CPU 核心，因为它们释放了 Python 的 GIL（全局解释器锁）。[Dask](https://fpy.li/dask)
    项目支持在机器群集上并行处理 NumPy、Pandas 和 scikit-learn。这些包值得写一整本书来介绍。但这不是那本书。但是，没有至少简要介绍 NumPy
    数组的 Python 序列概述是不完整的。
- en: 'Having looked at flat sequences—standard arrays and NumPy arrays—we now turn
    to a completely different set of replacements for the plain old `list`: queues.'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看了平面序列 — 标准数组和 NumPy 数组之后，我们现在转向一组完全不同的替代品，用于替代普通的 `list`：队列。
- en: Deques and Other Queues
  id: totrans-660
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Deques 和其他队列
- en: The `.append` and `.pop` methods make a `list` usable as a stack or a queue
    (if you use `.append` and `.pop(0)`, you get FIFO behavior). But inserting and
    removing from the head of a list (the 0-index end) is costly because the entire
    list must be shifted in memory.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '`.append` 和 `.pop` 方法使得 `list` 可以用作堆栈或队列（如果使用 `.append` 和 `.pop(0)`，则获得 FIFO
    行为）。但是，在列表头部（0 索引端）插入和删除是昂贵的，因为整个列表必须在内存中移动。'
- en: The class `collections.deque` is a thread-safe double-ended queue designed for
    fast inserting and removing from both ends. It is also the way to go if you need
    to keep a list of “last seen items” or something of that nature, because a `deque`
    can be bounded—i.e., created with a fixed maximum length. If a bounded `deque`
    is full, when you add a new item, it discards an item from the opposite end. [Example 2-23](#ex_deque)
    shows some typical operations performed on a `deque`.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `collections.deque` 是一个线程安全的双端队列，旨在快速从两端插入和删除。如果需要保留“最近看到的项目”列表或类似内���，`deque`
    也是一个不错的选择，因为 `deque` 可以是有界的 — 即，创建时具有固定的最大长度。如果有界 `deque` 已满，在添加新项目时，它会从相反端丢弃一个项目。[示例 2-23](#ex_deque)
    展示了在 `deque` 上执行的一些典型操作。
- en: Example 2-23\. Working with a `deque`
  id: totrans-663
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-23\. 使用 `deque`
- en: '[PRE62]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[![1](assets/1.png)](#co_an_array_of_sequences_CO23-1)'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_an_array_of_sequences_CO23-1)'
- en: The optional `maxlen` argument sets the maximum number of items allowed in this
    instance of `deque`; this sets a read-only `maxlen` instance attribute.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的 `maxlen` 参数设置了此 `deque` 实例中允许的最大项目数；这将设置一个只读的 `maxlen` 实例属性。
- en: '[![2](assets/2.png)](#co_an_array_of_sequences_CO23-2)'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_an_array_of_sequences_CO23-2)'
- en: Rotating with `n > 0` takes items from the right end and prepends them to the
    left; when `n < 0` items are taken from left and appended to the right.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `n > 0` 旋转会从右端获取项目并将其前置到左端；当 `n < 0` 时，项目从左端获取并附加到右端。
- en: '[![3](assets/3.png)](#co_an_array_of_sequences_CO23-3)'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_an_array_of_sequences_CO23-3)'
- en: Appending to a `deque` that is full (`len(d) == d.maxlen`) discards items from
    the other end; note in the next line that the `0` is dropped.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 向已满的 `deque`（`len(d) == d.maxlen`）添加元素会丢弃另一端的项目；请注意下一行中的 `0` 被丢弃了。
- en: '[![4](assets/4.png)](#co_an_array_of_sequences_CO23-4)'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_an_array_of_sequences_CO23-4)'
- en: Adding three items to the right pushes out the leftmost `-1`, `1`, and `2`.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 向右侧添加三个项目会推出最左侧的 `-1`、`1` 和 `2`。
- en: '[![5](assets/5.png)](#co_an_array_of_sequences_CO23-5)'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_an_array_of_sequences_CO23-5)'
- en: Note that `extendleft(iter)` works by appending each successive item of the
    `iter` argument to the left of the `deque`, therefore the final position of the
    items is reversed.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`extendleft(iter)` 的工作方式是将 `iter` 参数的每个连续项目附加到 `deque` 的左侧，因此项目的最终位置是反转的。
- en: '[Table 2-4](#list_x_deque_methods_tbl) compares the methods that are specific
    to `list` and `deque` (removing those that also appear in `object`).'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '[Table 2-4](#list_x_deque_methods_tbl) 比较了 `list` 和 `deque` 中特定的方法（删除了也出现在
    `object` 中的方法）。'
- en: 'Note that `deque` implements most of the `list` methods, and adds a few that
    are specific to its design, like `popleft` and `rotate`. But there is a hidden
    cost: removing items from the middle of a `deque` is not as fast. It is really
    optimized for appending and popping from the ends.'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`deque` 实现了大多数 `list` 方法，并添加了一些特定于其设计的方法，如 `popleft` 和 `rotate`。但是存在隐藏成本：从
    `deque` 中间删除项目不够快。它真正优化于从两端附加和弹出。
- en: The `append` and `popleft` operations are atomic, so `deque` is safe to use
    as a FIFO queue in multithreaded applications without the need for locks.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '`append` 和 `popleft` 操作是原子性的，因此在多线程应用程序中，`deque` 可以安全地用作 FIFO 队列，无需使用锁。'
- en: Table 2-4\. Methods implemented in `list` or `deque` (those that are also implemented
    by `object` are omitted for brevity)
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-4\. 在 `list` 或 `deque` 中实现的方法（省略了那些也由 `object` 实现的方法）
- en: '|  | list | deque |   |'
  id: totrans-679
  prefs: []
  type: TYPE_TB
  zh: '|  | list | deque |   |'
- en: '| --- | --- | --- | --- |'
  id: totrans-680
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `s.__add__(s2)` | ● |  | `s + s2`—concatenation |'
  id: totrans-681
  prefs: []
  type: TYPE_TB
  zh: '| `s.__add__(s2)` | ● |  | `s + s2`—连接 |'
- en: '| `s.__iadd__(s2)` | ● | ● | `s += s2`—in-place concatenation |'
  id: totrans-682
  prefs: []
  type: TYPE_TB
  zh: '| `s.__iadd__(s2)` | ● | ● | `s += s2`—原地连接 |'
- en: '| `s.append(e)` | ● | ● | Append one element to the right (after last) |'
  id: totrans-683
  prefs: []
  type: TYPE_TB
  zh: '| `s.append(e)` | ● | ● | 向右侧附加一个元素（在最后之后） |'
- en: '| `s.appendleft(e)` |  | ● | Append one element to the left (before first)
    |'
  id: totrans-684
  prefs: []
  type: TYPE_TB
  zh: '| `s.appendleft(e)` |  | ● | 向左侧附加一个元素（在第一个之前） |'
- en: '| `s.clear()` | ● | ● | Delete all items |'
  id: totrans-685
  prefs: []
  type: TYPE_TB
  zh: '| `s.clear()` | ● | ● | 删除所有项目 |'
- en: '| `s.__contains__(e)` | ● |  | `e in s` |'
  id: totrans-686
  prefs: []
  type: TYPE_TB
  zh: '| `s.__contains__(e)` | ● |  | `e in s` |'
- en: '| `s.copy()` | ● |  | Shallow copy of the list |'
  id: totrans-687
  prefs: []
  type: TYPE_TB
  zh: '| `s.copy()` | ● |  | 列表的浅复制 |'
- en: '| `s.__copy__()` |  | ● | Support for `copy.copy` (shallow copy) |'
  id: totrans-688
  prefs: []
  type: TYPE_TB
  zh: '| `s.__copy__()` |  | ● | 支持 `copy.copy`（浅复制） |'
- en: '| `s.count(e)` | ● | ● | Count occurrences of an element |'
  id: totrans-689
  prefs: []
  type: TYPE_TB
  zh: '| `s.count(e)` | ● | ● | 计算元素出现的次数 |'
- en: '| `s.__delitem__(p)` | ● | ● | Remove item at position `p` |'
  id: totrans-690
  prefs: []
  type: TYPE_TB
  zh: '| `s.__delitem__(p)` | ● | ● | 删除位置 `p` 处的项目 |'
- en: '| `s.extend(i)` | ● | ● | Append items from iterable `i` to the right |'
  id: totrans-691
  prefs: []
  type: TYPE_TB
  zh: '| `s.extend(i)` | ● | ● | 将可迭代对象 `i` 中的项目添加到右侧 |'
- en: '| `s.extendleft(i)` |  | ● | Append items from iterable `i` to the left |'
  id: totrans-692
  prefs: []
  type: TYPE_TB
  zh: '| `s.extendleft(i)` |  | ● | 将可迭代对象 `i` 中的项目添加到左侧 |'
- en: '| `s.__getitem__(p)` | ● | ● | `s[p]`—get item or slice at position |'
  id: totrans-693
  prefs: []
  type: TYPE_TB
  zh: '| `s.__getitem__(p)` | ● | ● | `s[p]`—获取位置处的项目或切片 |'
- en: '| `s.index(e)` | ● |  | Find position of first occurrence of `e` |'
  id: totrans-694
  prefs: []
  type: TYPE_TB
  zh: '| `s.index(e)` | ● |  | 查找第一个出现的 `e` 的位置 |'
- en: '| `s.insert(p, e)` | ● |  | Insert element `e` before the item at position
    `p` |'
  id: totrans-695
  prefs: []
  type: TYPE_TB
  zh: '| `s.insert(p, e)` | ● |  | 在位置 `p` 的项目之前插入元素 `e` |'
- en: '| `s.__iter__()` | ● | ● | Get iterator |'
  id: totrans-696
  prefs: []
  type: TYPE_TB
  zh: '| `s.__iter__()` | ● | ● | 获取迭代器 |'
- en: '| `s.__len__()` | ● | ● | `len(s)`—number of items |'
  id: totrans-697
  prefs: []
  type: TYPE_TB
  zh: '| `s.__len__()` | ● | ● | `len(s)`—项目数量 |'
- en: '| `s.__mul__(n)` | ● |  | `s * n`—repeated concatenation |'
  id: totrans-698
  prefs: []
  type: TYPE_TB
  zh: '| `s.__mul__(n)` | ● |  | `s * n`—重复连接 |'
- en: '| `s.__imul__(n)` | ● |  | `s *= n`—in-place repeated concatenation |'
  id: totrans-699
  prefs: []
  type: TYPE_TB
  zh: '| `s.__imul__(n)` | ● |  | `s *= n`—原地重复连接 |'
- en: '| `s.__rmul__(n)` | ● |  | `n * s`—reversed repeated concatenation^([a](ch02.html#idm46582499545088))
    |'
  id: totrans-700
  prefs: []
  type: TYPE_TB
  zh: '| `s.__rmul__(n)` | ● |  | `n * s`—反向重复连接 |'
- en: '| `s.pop()` | ● | ● | Remove and return last item^([b](ch02.html#idm46582499540784))
    |'
  id: totrans-701
  prefs: []
  type: TYPE_TB
  zh: '| `s.pop()` | ● | ● | 移除并返回最后一个项目 |'
- en: '| `s.popleft()` |  | ● | Remove and return first item |'
  id: totrans-702
  prefs: []
  type: TYPE_TB
  zh: '| `s.popleft()` |  | ● | 移除并返回第一个项目 |'
- en: '| `s.remove(e)` | ● | ● | Remove first occurrence of element `e` by value |'
  id: totrans-703
  prefs: []
  type: TYPE_TB
  zh: '| `s.remove(e)` | ● | ● | 按值删除第一个出现的元素 `e` |'
- en: '| `s.reverse()` | ● | ● | Reverse the order of the items in place |'
  id: totrans-704
  prefs: []
  type: TYPE_TB
  zh: '| `s.reverse()` | ● | ● | 原地反转项目顺序 |'
- en: '| `s.__reversed__()` | ● | ● | Get iterator to scan items from last to first
    |'
  id: totrans-705
  prefs: []
  type: TYPE_TB
  zh: '| `s.__reversed__()` | ● | ● | 获取迭代器以从后向前扫描项目 |'
- en: '| `s.rotate(n)` |  | ● | Move `n` items from one end to the other |'
  id: totrans-706
  prefs: []
  type: TYPE_TB
  zh: '| `s.rotate(n)` |  | ● | 将 `n` 个项目从一端移动到另一端 |'
- en: '| `s.__setitem__(p, e)` | ● | ● | `s[p] = e`—put `e` in position `p`, overwriting
    existing item or slice |'
  id: totrans-707
  prefs: []
  type: TYPE_TB
  zh: '| `s.__setitem__(p, e)` | ● | ● | `s[p] = e`—将 `e` 放在位置 `p`，覆盖现有的项目或切片 |'
- en: '| `s.sort([key], [reverse])` | ● |  | Sort items in place with optional keyword
    arguments `key` and `reverse` |'
  id: totrans-708
  prefs: []
  type: TYPE_TB
  zh: '| `s.sort([key], [reverse])` | ● |  | 使用可选关键字参数 `key` 和 `reverse` 原地对项目进行排序
    |'
- en: '| ^([a](ch02.html#idm46582499545088-marker)) Reversed operators are explained
    in [Chapter 16](ch16.html#operator_overloading).^([b](ch02.html#idm46582499540784-marker))
    `a_list.pop(p)` allows removing from position `p`, but `deque` does not support
    that option. |'
  id: totrans-709
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch02.html#idm46582499545088-marker)) 反向操作符在 [第16章](ch16.html#operator_overloading)
    中有解释。^([b](ch02.html#idm46582499540784-marker)) `a_list.pop(p)` 允许从位置 `p` 处移除项目，但
    `deque` 不支持该选项。 |'
- en: 'Besides `deque`, other Python standard library packages implement queues:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `deque`，其他 Python 标准库包实现了队列：
- en: '`queue`'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue`'
- en: This provides the synchronized (i.e., thread-safe) classes `SimpleQueue`, `Queue`,
    `LifoQueue`, and `PriorityQueue`. These can be used for safe communication between
    threads. All except `SimpleQueue` can be bounded by providing a `maxsize` argument
    greater than 0 to the constructor. However, they don’t discard items to make room
    as `deque` does. Instead, when the queue is full, the insertion of a new item
    blocks—i.e., it waits until some other thread makes room by taking an item from
    the queue, which is useful to throttle the number of live threads.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了同步（即线程安全）的类 `SimpleQueue`、`Queue`、`LifoQueue` 和 `PriorityQueue`。这些可以用于线程之间的安全通信。除了
    `SimpleQueue` 外，通过向构造函数提供大于 0 的 `maxsize` 参数，其他队列都可以被限制大小。然而，它们不会像 `deque` 那样丢弃项目以腾出空间。相反，当队列已满时，插入新项目会被阻塞—即等待直到其他线程通过从队列中取出项目来腾出空间，这对于限制活动线程数量很有用。
- en: '`multiprocessing`'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing`'
- en: Implements its own unbounded `SimpleQueue` and bounded `Queue`, very similar
    to those in the `queue` package, but designed for interprocess communication.
    A specialized `multiprocessing.JoinableQueue` is provided for task management.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了自己的无界 `SimpleQueue` 和有界 `Queue`，与 `queue` 包中的类非常相似，但设计用于进程间通信。提供了专门的 `multiprocessing.JoinableQueue`
    用于任务管理。
- en: '`asyncio`'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio`'
- en: Provides `Queue`, `LifoQueue`, `PriorityQueue`, and `JoinableQueue` with APIs
    inspired by the classes in the `queue` and `multiprocessing` modules, but adapted
    for managing tasks in asynchronous programming.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了受 `queue` 和 `multiprocessing` 模块中类启发的 `Queue`、`LifoQueue`、`PriorityQueue`
    和 `JoinableQueue`，但适用于管理异步编程中的任务。
- en: '`heapq`'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '`heapq`'
- en: In contrast to the previous three modules, `heapq` does not implement a queue
    class, but provides functions like `heappush` and `heappop` that let you use a
    mutable sequence as a heap queue or priority queue.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 与前三个模块不同，`heapq` 不实现队列类，而是提供函数如 `heappush` 和 `heappop`，让您可以使用可变序列作为堆队列或优先队列。
- en: This ends our overview of alternatives to the `list` type, and also our exploration
    of sequence types in general—except for the particulars of `str` and binary sequences,
    which have their own chapter ([Chapter 4](ch04.html#strings_bytes_files)).
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对 `list` 类型的替代品以及对序列类型的一般探索—除了 `str` 和二进制序列的细节，它们有自己的章节（[第4章](ch04.html#strings_bytes_files)）。
- en: Chapter Summary
  id: totrans-720
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节总结
- en: Mastering the standard library sequence types is a prerequisite for writing
    concise, effective, and idiomatic Python code.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 精通标准库的序列类型是编写简洁、高效和惯用的 Python 代码的先决条件。
- en: 'Python sequences are often categorized as mutable or immutable, but it is also
    useful to consider a different axis: flat sequences and container sequences. The
    former are more compact, faster, and easier to use, but are limited to storing
    atomic data such as numbers, characters, and bytes. Container sequences are more
    flexible, but may surprise you when they hold mutable objects, so you need to
    be careful to use them correctly with nested data structures.'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: Python 序列通常被归类为可变或不可变，但考虑一个不同的维度也是有用的：扁平序列和容器序列。前者更紧凑、更快速、更易于使用，但仅限于存储数字、字符和字节等原子数据。容器序列更灵活，但当它们持有可变对象时可能会让您感到惊讶，因此您需要小心地在嵌套数据结构中正确使用它们。
- en: 'Unfortunately, Python has no foolproof immutable container sequence type: even
    “immutable” tuples can have their values changed when they contain mutable items
    like lists or user-defined objects.'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Python 没有绝对可靠的不可变容器序列类型：即使“不可变”元组中包含可变项（如列表或用户定义对象），其值也可能被更改。
- en: List comprehensions and generator expressions are powerful notations to build
    and initialize sequences. If you are not yet comfortable with them, take the time
    to master their basic usage. It is not hard, and soon you will be hooked.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导和生成器表达式是构建和初始化序列的强大表示法。如果您尚未熟悉它们，请花时间掌握它们的基本用法。这并不难，很快您就会上瘾。
- en: 'Tuples in Python play two roles: as records with unnamed fields and as immutable
    lists. When using a tuple as an immutable list, remember that a tuple value is
    only guaranteed to be fixed if all the items in it are also immutable. Calling
    `hash(t)` on a tuple is a quick way to assert that its value is fixed. A `TypeError`
    will be raised if `t` contains mutable items.'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，元组扮演两个角色：作为具有未命名字段的记录和作为不可变列表。当将元组用作不可变列表时，请记住，仅当其中所有项也是不可变时，元组值才被保证固定。在元组上调用
    `hash(t)` 是一种快速断言其值固定的方法。如果 `t` 包含可变项，则会引发 `TypeError`。
- en: When a tuple is used as a record, tuple unpacking is the safest, most readable
    way of extracting the fields of the tuple. Beyond tuples, `*` works with lists
    and iterables in many contexts, and some of its use cases appeared in Python 3.5
    with [PEP 448—Additional Unpacking Generalizations](https://fpy.li/pep448). Python
    3.10 introduced pattern matching with `match/case`, supporting more powerful unpacking,
    known as destructuring.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 当元组用作记录时，元组解包是提取元组字段的最安全、最可读的方式。除了元组外，`*` 在许多上下文中与列表和可迭代对象一起使用，并且在 Python 3.5
    中出现了一些用例，其中包括 [PEP 448—Additional Unpacking Generalizations](https://fpy.li/pep448)。Python
    3.10 引入了带有 `match/case` 的模式匹配，支持更强大的解包，称为解构。
- en: Sequence slicing is a favorite Python syntax feature, and it is even more powerful
    than many realize. Multidimensional slicing and ellipsis (`...`) notation, as
    used in NumPy, may also be supported by user-defined sequences. Assigning to slices
    is a very expressive way of editing mutable sequences.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 序列切片是 Python 中一个受欢迎的语法特性，比许多人意识到的要更强大。多维切片和省略号（`...`）符号，如 NumPy 中使用的方式，也可能受到用户定义序列的支持。对切片赋值是编辑可变序列的一种非常表达性的方式。
- en: Repeated concatenation as in `seq * n` is convenient and, with care, can be
    used to initialize lists of lists containing immutable items. Augmented assignment
    with `+=` and `*=` behaves differently for mutable and immutable sequences. In
    the latter case, these operators necessarily build new sequences. But if the target
    sequence is mutable, it is usually changed in place—but not always, depending
    on how the sequence is implemented.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 如 `seq * n` 中的重复连接很方便，并且经过小心处理，可以用于初始化包含不可变项的列表列表。对于可变和不可变序列，使用 `+=` 和 `*=`
    的增强赋值行为不同。在后一种情况下，这些运算符必然构建新序列。但如果目标序列是可变的，则通常会就地更改它，但并非总是，这取决于序列的实现方式。
- en: 'The `sort` method and the `sorted` built-in function are easy to use and flexible,
    thanks to the optional `key` argument: a function to calculate the ordering criterion.
    By the way, `key` can also be used with the `min` and `max` built-in functions.'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort` 方法和 `sorted` 内置函数易于使用且灵活，这要归功于可选的 `key` 参数：用于计算排序标准的函数。顺便说一句，`key` 也可以与
    `min` 和 `max` 内置函数一起使用。'
- en: Beyond lists and tuples, the Python standard library provides `array.array`.
    Although NumPy and SciPy are not part of the standard library, if you do any kind
    of numerical processing on large sets of data, studying even a small part of these
    libraries can take you a long way.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 除了列表和元组外，Python 标准库还提供了 `array.array`。虽然 NumPy 和 SciPy 不是标准库的一部分，但如果您对大量数据进行任何类型的数值处理，学习这些库的一小部分甚至可以让您走得更远。
- en: We closed by visiting the versatile and thread-safe `collections.deque`, comparing
    its API with that of `list` in [Table 2-4](#list_x_deque_methods_tbl) and mentioning
    other queue implementations in the standard library.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后讨论了多才多艺且线程安全的 `collections.deque`，将其 API 与 `list` 在[表 2-4](#list_x_deque_methods_tbl)中进行了比较，并提到了标准库中的其他队列实现。
- en: Further Reading
  id: totrans-732
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Chapter 1, “Data Structures,” of the [*Python Cookbook*, 3rd ed.](https://fpy.li/pycook3)
    (O’Reilly) by David Beazley and Brian K. Jones, has many recipes focusing on sequences,
    including “Recipe 1.11. Naming a Slice,” from which I learned the trick of assigning
    slices to variables to improve readability, illustrated in our [Example 2-13](#flat_file_invoce).
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 第1章“数据结构”来自[*Python Cookbook*，第3版](https://fpy.li/pycook3)（O’Reilly），作者是David
    Beazley和Brian K. Jones，其中包含许多关于序列的技巧，包括“Recipe 1.11. 命名切片”，我从中学到了将切片赋值给变量以提高可读性的技巧，在我们的[示例
    2-13](#flat_file_invoce)中有所展示。
- en: The second edition of the *Python Cookbook* was written for Python 2.4, but
    much of its code works with Python 3, and a lot of the recipes in Chapters 5 and
    6 deal with sequences. The book was edited by Alex Martelli, Anna Ravenscroft,
    and David Ascher, and it includes contributions by dozens of Pythonistas. The
    third edition was rewritten from scratch, and focuses more on the semantics of
    the language—particularly what has changed in Python 3—while the older volume
    emphasizes pragmatics (i.e., how to apply the language to real-world problems).
    Even though some of the second edition solutions are no longer the best approach,
    I honestly think it is worthwhile to have both editions of the *Python Cookbook*
    on hand.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python Cookbook* 的第二版是为 Python 2.4 编写的，但其中的许多代码也适用于 Python 3，并且第 5 章和第 6 章中的许多技巧涉及序列。该书由
    Alex Martelli、Anna Ravenscroft 和 David Ascher 编辑，其中包括数十位 Python 爱好者的贡献。第三版是从头开始重写的，更侧重于语言的语义，特别是
    Python 3 中发生了什么变化，而旧版则更强调实用性（即如何将语言应用于实际问题）。尽管第二版的一些解决方案不再是最佳方法，但我真诚地认为值得同时拥有*Python
    Cookbook* 的两个版��。'
- en: The official Python [“Sorting HOW TO”](https://fpy.li/2-22) has several examples
    of advanced tricks for using `sorted` and `list.sort`.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 官方 Python [“排序 HOW TO”](https://fpy.li/2-22) 中有几个关于使用 `sorted` 和 `list.sort`
    的高级技巧示例。
- en: '[PEP 3132—Extended Iterable Unpacking](https://fpy.li/2-2) is the canonical
    source to read about the new use of `*extra` syntax on the lefthand side of parallel
    assignments. If you’d like a glimpse of Python evolving, [“Missing *-unpacking
    generalizations”](https://fpy.li/2-24) is a bug tracker issue proposing enhancements
    to the iterable unpacking notation. [PEP 448—Additional Unpacking Generalizations](https://fpy.li/pep448)
    resulted from the discussions in that issue.'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '[PEP 3132—扩展可迭代解包](https://fpy.li/2-2)是阅读关于在并行赋值的左侧使用`*extra`语法的新用法的权威来源。如果你想一窥Python的发展，[“缺失*-解包泛化”](https://fpy.li/2-24)是一个提出增强可迭代解包符号的bug跟踪器问题。[PEP
    448—额外解包泛化](https://fpy.li/pep448)是从该问题的讨论中产生的。'
- en: 'As I mentioned in [“Pattern Matching with Sequences”](#sequence_patterns_sec),
    Carol Willing’s [“Structural Pattern Matching”](https://fpy.li/2-6) section of
    [“What’s New In Python 3.10”](https://fpy.li/2-7) is a great introduction to this
    major new feature in about 1,400 words (that’s less than 5 pages when Firefox
    makes a PDF from the HTML). [PEP 636—Structural Pattern Matching: Tutorial](https://fpy.li/pep636)
    is also good, but longer. The same PEP 636 includes [“Appendix A—Quick Intro”](https://fpy.li/2-27).
    It is shorter than Willing’s intro because it omits high-level considerations
    about why pattern matching is good for you. If you need more arguments to convince
    yourself or others that pattern matching is good for Python, read the 22-page
    [PEP 635—Structural Pattern Matching: Motivation and Rationale](https://fpy.li/pep635).'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[“使用序列进行模式匹配”](#sequence_patterns_sec)中提到的，Carol Willing的[“结构化模式匹配”](https://fpy.li/2-6)部分在[“Python
    3.10有什么新特性”](https://fpy.li/2-7)中是对这一重要新功能的很好介绍，大约有1400字（当Firefox从HTML生成PDF时，这不到5页）。[PEP
    636—结构化模式匹配：教程](https://fpy.li/pep636)也不错，但更长。同样的PEP 636包括[“附录A—快速介绍”](https://fpy.li/2-27)。它比Willing的介绍短，因为它省略了关于为什么模式匹配对你有好处的高层考虑。如果你需要更多论据来说服自己或他人模式匹配对Python有好处，那么阅读22页的[PEP
    635—结构化模式匹配：动机和原理](https://fpy.li/pep635)。
- en: Eli Bendersky’s blog post [“Less copies in Python with the buffer protocol and
    memoryviews”](https://fpy.li/2-28) includes a short tutorial on `memoryview`.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: Eli Bendersky的博客文章[“使用缓冲区协议和memoryviews在Python中减少拷贝”](https://fpy.li/2-28)包含了关于`memoryview`的简短教程。
- en: There are numerous books covering NumPy in the market, and many don’t mention
    “NumPy” in the title. Two examples are the open access [*Python Data Science Handbook*](https://fpy.li/2-29)
    by Jake VanderPlas, and the second edition of Wes McKinney’s [*Python for Data
    Analysis*](https://fpy.li/2-30).
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有许多涵盖NumPy的书籍，许多书名中并未提及“NumPy”。两个例子是Jake VanderPlas的开放获取书籍[*Python数据科学手册*](https://fpy.li/2-29)，以及Wes
    McKinney的第二版[*Python数据分析*](https://fpy.li/2-30)。
- en: “NumPy is all about vectorization.” That is the opening sentence of Nicolas
    P. Rougier’s open access book [*From Python to NumPy*](https://fpy.li/2-31). Vectorized
    operations apply mathematical functions to all elements of an array without an
    explicit loop written in Python. They can operate in parallel, using special vector
    instructions in modern CPUs, leveraging multiple cores or delegating to the GPU,
    depending on the library. The first example in Rougier’s book shows a speedup
    of 500 times after refactoring a nice Pythonic class using a generator method,
    into a lean and mean function calling a couple of NumPy vector functions.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: “NumPy的全部内容都关乎向量化。”这是Nicolas P. Rougier的开放获取书籍[*从Python到NumPy*](https://fpy.li/2-31)的开篇语句。向量化操作将数学函数应用于数组的所有元素，而无需在Python中编写显式循环。它们可以并行操作，使用现代CPU中的特殊向量指令，利用多个核心或委托给GPU，具体取决于库。Rougier的书中的第一个例子展示了通过将一个漂亮的Python类使用生成器方法重构为调用几个NumPy向量函数的精简函数后，速度提高了500倍。
- en: To learn how to use `deque` (and other collections), see the examples and practical
    recipes in [“Container datatypes”](https://fpy.li/collec) in the Python documentation.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习如何使用`deque`（以及其他集合），请参阅Python文档中[“容器数据类型”](https://fpy.li/collec)中的示例和实用配方。
- en: The best defense of the Python convention of excluding the last item in ranges
    and slices was written by Edsger W. Dijkstra himself, in a short memo titled [“Why
    Numbering Should Start at Zero”](https://fpy.li/2-32). The subject of the memo
    is mathematical notation, but it’s relevant to Python because Dijkstra explains
    with rigor and humor why a sequence like 2, 3, …, 12 should always be expressed
    as 2 ≤ i < 13. All other reasonable conventions are refuted, as is the idea of
    letting each user choose a convention. The title refers to zero-based indexing,
    but the memo is really about why it is desirable that `'ABCDE'[1:3]` means `'BC'`
    and not `'BCD'` and why it makes perfect sense to write `range(2, 13)` to produce
    2, 3, 4, …, 12. By the way, the memo is a handwritten note, but it’s beautiful
    and totally readable. Dijkstra’s handwriting is so clear that someone created
    a [font](https://fpy.li/2-33) out of his notes.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: Python惯例中排除范围和切片中的最后一项的最佳辩护是由Edsger W. Dijkstra亲自撰写的，标题为[“为什么编号应该从零开始”](https://fpy.li/2-32)的短备忘录。备忘录的主题是数学符号，但与Python相关，因为Dijkstra以严谨和幽默解释了为什么像2,
    3, …, 12这样的序列应该始终表示为2 ≤ i < 13。所有其他合理的惯例都被驳斥，以及让每个用户选择惯例的想法。标题指的是基于零的索引，但备忘录实际上是关于为什么`'ABCDE'[1:3]`意味着`'BC'`而不是`'BCD'`，以及为什么写`range(2,
    13)`来生成2, 3, 4, …, 12是完全合理的。顺便说一句，备忘录是一张手写的便条，但它非常漂亮且完全可读。Dijkstra的笔迹非常清晰，以至于有人根据他的笔记创建了一个[字体](https://fpy.li/2-33)。
- en: ^([1](ch02.html#idm46582497439616-marker)) Leo Geurts, Lambert Meertens, and
    Steven Pemberton, *ABC Programmer’s Handbook*, p. 8\. (Bosko Books).
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.html#idm46582497439616-marker)) Leo Geurts，Lambert Meertens和Steven
    Pemberton，*ABC程序员手册*，第8页。 (Bosko Books)。
- en: ^([2](ch02.html#idm46582497167712-marker)) Thanks to reader Tina Lapine for
    pointing this out.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch02.html#idm46582497167712-marker)) 感谢读者Tina Lapine指出这一点。
- en: ^([3](ch02.html#idm46582496405424-marker)) Thanks to tech reviewer Leonardo
    Rochael for this example.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch02.html#idm46582496405424-marker)) 感谢技术审阅员Leonardo Rochael提供此示例。
- en: ^([4](ch02.html#idm46582506122016-marker)) In my view, a sequence of `if/elif/elif/.../else`
    blocks is a fine replacement for `switch/case`. It doesn’t suffer from the [fallthrough](https://fpy.li/2-8)
    and [dangling else](https://fpy.li/2-9) problems that some language designers
    irrationally copied from C—decades after they were widely known as the cause of
    countless bugs.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch02.html#idm46582506122016-marker)) 在我看来，一系列的`if/elif/elif/.../else`块是对`switch/case`的一个很好的替代。它不会受到一些语言设计者在几十年后仍然无谓地从C语言中复制的[贯穿](https://fpy.li/2-8)和[悬空else](https://fpy.li/2-9)问题的困扰，这些问题已经被广泛认为是导致无数错误的原因。
- en: ^([5](ch02.html#idm46582509473312-marker)) The latter is named `eval` in Norvig’s
    code; I renamed it to avoid confusion with Python’s `eval` built-in.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch02.html#idm46582509473312-marker)) 后者在Norvig的代码中被命名为`eval`；我将其重命名以避免与Python的`eval`内置函数混淆。
- en: ^([6](ch02.html#idm46582493669184-marker)) In [“Memory Views”](#memoryview_sec)
    we show that specially constructed memory views can have more than one dimension.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch02.html#idm46582493669184-marker)) 在[“内存视图”](#memoryview_sec)中，我们展示了特别构造的内存视图可以具有多个维度。
- en: '^([7](ch02.html#idm46582493663648-marker)) No, I did not get this backwards:
    the `ellipsis` class name is really all lowercase, and the instance is a built-in
    named `Ellipsis`, just like `bool` is lowercase but its instances are `True` and
    `False`.'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch02.html#idm46582493663648-marker)) 不，我没有搞错：`ellipsis`类名确实全小写，而实例是一个名为`Ellipsis`的内置对象，就像`bool`是小写但其实例是`True`和`False`一样。
- en: ^([8](ch02.html#idm46582507630144-marker)) `str` is an exception to this description.
    Because string building with `+=` in loops is so common in real codebases, CPython
    is optimized for this use case. Instances of `str` are allocated in memory with
    extra room, so that concatenation does not require copying the whole string every
    time.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch02.html#idm46582507630144-marker)) `str`是这个描述的一个例外。因为在实际代码库中，在循环中使用`+=`进行字符串构建是如此普遍，CPython对这种用例进行了优化。`str`的实例在内存中分配了额外的空间，因此连接不需要每次都复制整个字符串。
- en: ^([9](ch02.html#idm46582507624544-marker)) Thanks to Leonardo Rochael and Cesar
    Kawakami for sharing this riddle at the 2013 PythonBrasil Conference.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch02.html#idm46582507624544-marker)) 感谢Leonardo Rochael和Cesar Kawakami在2013年PythonBrasil大会上分享这个谜题。
- en: ^([10](ch02.html#idm46582507593808-marker)) Readers suggested that the operation
    in the example can be done with `t[2].extend([50,60])`, without errors. I am aware
    of that, but my intent is to show the strange behavior of the `+=` operator in
    this case.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch02.html#idm46582507593808-marker)) 读者建议在示例中的操作可以用`t[2].extend([50,60])`来完成，而不会出错。我知道这一点，但我的目的是展示在这种情况下`+=`运算符的奇怪行为。
- en: ^([11](ch02.html#idm46582495279600-marker)) Receiver is the target of a method
    call, the object bound to `self` in the method body.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch02.html#idm46582495279600-marker)) 接收者是方法调用的目标，是方法体中绑定到`self`的对象。
- en: ^([12](ch02.html#idm46582495259904-marker)) Python’s main sorting algorithm
    is named Timsort after its creator, Tim Peters. For a bit of Timsort trivia, see
    the [“Soapbox”](#sequences_soapbox).
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: ^([12](ch02.html#idm46582495259904-marker)) Python的主要排序算法以其创造者Tim Peters命名为Timsort。有关Timsort的一些趣闻，参见[“讲台”](#sequences_soapbox)。
- en: ^([13](ch02.html#idm46582495143296-marker)) The words in this example are sorted
    alphabetically because they are 100% made of lowercase ASCII characters. See the
    warning after the example.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: ^([13](ch02.html#idm46582495143296-marker)) 这个例子中的单词按字母顺序排序，因为它们完全由小写ASCII字符组成。请参见示例后的警告。
- en: ^([14](ch02.html#idm46582495074352-marker)) First in, first out—the default
    behavior of queues.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: ^([14](ch02.html#idm46582495074352-marker)) 先进先出——队列的默认行为。
