- en: 13\. Files and Databases#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13\. 文件与数据库#
- en: 原文：[https://allendowney.github.io/ThinkPython/chap13.html](https://allendowney.github.io/ThinkPython/chap13.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://allendowney.github.io/ThinkPython/chap13.html](https://allendowney.github.io/ThinkPython/chap13.html)
- en: Most of the programs we have seen so far are **ephemeral** in the sense that
    they run for a short time and produce output, but when they end, their data disappears.
    Each time you run an ephemeral program, it starts with a clean slate.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止看到的大多数程序都是**临时的**，因为它们运行时间很短，生成输出，但当它们结束时，它们的数据会消失。每次运行临时程序时，它都会从一个干净的状态开始。
- en: 'Other programs are **persistent**: they run for a long time (or all the time);
    they keep at least some of their data in long-term storage; and if they shut down
    and restart, they pick up where they left off.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 其他程序是**持久的**：它们运行时间很长（或者一直运行）；它们将至少一部分数据保存在长期存储中；如果它们关闭并重新启动，它们会从上次停止的地方继续。
- en: A simple way for programs to maintain their data is by reading and writing text
    files. A more versatile alternative is to store data in a database. Databases
    are specialized files that can be read and written more efficiently than text
    files, and they provide additional capabilities.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 程序保持数据的一种简单方式是通过读取和写入文本文件。一个更通用的替代方案是将数据存储在数据库中。数据库是专门的文件，比文本文件更高效地读取和写入，并且提供了额外的功能。
- en: In this chapter, we’ll write programs that read and write text files and databases,
    and as an exercise you’ll write a program that searches a collection of photos
    for duplicates. But before you can work with a file, you have to find it, so we’ll
    start with file names, paths, and directories.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写读取和写入文本文件及数据库的程序，并且作为一个练习，你将编写一个程序，搜索照片集中的重复文件。但在你可以操作文件之前，首先要找到它，因此我们将从文件名、路径和目录开始。
- en: 13.1\. Filenames and paths[#](#filenames-and-paths "Link to this heading")
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1\. 文件名和路径[#](#filenames-and-paths "Link to this heading")
- en: Files are organized into **directories**, also called “folders”. Every running
    program has a **current working directory**, which is the default directory for
    most operations. For example, when you open a file, Python looks for it in the
    current working directory.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 文件被组织成**目录**，也叫做“文件夹”。每个正在运行的程序都有一个**当前工作目录**，这是大多数操作的默认目录。例如，当你打开一个文件时，Python
    会在当前工作目录中查找它。
- en: The `os` module provides functions for working with files and directories (“os”
    stands for “operating system”). It provides a function called `getcwd` that gets
    the name of the current working directory.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`os`模块提供了用于操作文件和目录的函数（“os”代表“操作系统”）。它提供了一个名为`getcwd`的函数，用于获取当前工作目录的名称。'
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The result in this example is the home directory of a user named `dinsdale`.
    A string like `'/home/dinsdale'` that identifies a file or directory is called
    a **path**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中的结果是一个名为`dinsdale`的用户的主目录。像`'/home/dinsdale'`这样的字符串，它标识了一个文件或目录，称为**路径**。
- en: A simple filename like `'memo.txt'` is also considered a path, but it is a **relative
    path** because it specifies a file name relative to the current directory. In
    this example, the current directory is `/home/dinsdale`, so `'memo.txt'` is equivalent
    to the complete path `'/home/dinsdale/memo.txt'`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 像`'memo.txt'`这样的简单文件名也被视为路径，但它是一个**相对路径**，因为它指定了相对于当前目录的文件名。在本例中，当前目录是`/home/dinsdale`，所以`'memo.txt'`等同于完整路径`'/home/dinsdale/memo.txt'`。
- en: A path that begins with `/` does not depend on the current directory – it is
    called an **absolute path**. To find the absolute path to a file, you can use
    `abspath`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以`/`开头的路径不依赖于当前目录——它被称为**绝对路径**。要找到文件的绝对路径，可以使用`abspath`。
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `os` module provides other functions for working with filenames and paths.
    `listdir` returns a list of the contents of the given directory, including files
    and other directories. Here’s an example that lists the contents of a directory
    named `photos`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`os`模块还提供了其他用于操作文件名和路径的函数。`listdir`返回给定目录的内容列表，包括文件和其他目录。下面是列出名为`photos`目录内容的示例。'
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This directory contains a text file named `notes.txt` and three directories.
    The directories contain image files in the JPEG format.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个目录包含一个名为`notes.txt`的文本文件和三个目录。目录中包含 JPEG 格式的图像文件。
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To check whether a file or directory exists, we can use `os.path.exists`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查文件或目录是否存在，可以使用`os.path.exists`。
- en: '[PRE8]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To check whether a path refers to a file or directory, we can use `isdir`, which
    return `True` if a path refers to a directory.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查路径是否指向文件或目录，我们可以使用`isdir`，它返回`True`如果路径指向一个目录。
- en: '[PRE12]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: And `isfile` which returns `True` if a path refers to a file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`isfile`，如果路径指向一个文件，它返回`True`。
- en: '[PRE14]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: One challenge of working with paths is that they look different on different
    operating systems. On macOS and UNIX systems like Linux, the directory and file
    names in a path are separated by a forward slash, `/`. Windows uses a backward
    slash, `\`. So, if you you run these examples on Windows, you will see backward
    slashes in the paths, and you’ll have to replace the forward slashes in the examples.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 处理路径的一个挑战是，不同操作系统上的路径表示不同。在 macOS 和类似 Linux 的 UNIX 系统中，路径中的目录和文件名是由正斜杠`/`分隔的。Windows
    使用反斜杠`\`。因此，如果你在 Windows 上运行这些示例，你会看到路径中的反斜杠，并且你需要将示例中的正斜杠替换为反斜杠。
- en: Or, to write code that works on both systems, you can use `os.path.join`, which
    joins directory and filenames into a path using a forward or backward slash, depending
    on which operating system you are using.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，为了编写在两个系统上都能运行的代码，可以使用`os.path.join`，它将目录和文件名连接成一个路径，使用正斜杠或反斜杠，具体取决于你使用的操作系统。
- en: '[PRE16]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Later in this chapter we’ll use these functions to search a set of directories
    and find all of the image files.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章稍后，我们将使用这些函数来搜索一组目录并找到所有图像文件。
- en: 13.2\. f-strings[#](#f-strings "Link to this heading")
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2\. f-strings[#](#f-strings "Link to this heading")
- en: One way for programs to store data is to write it to a text file. For example,
    suppose you are a camel spotter, and you want to record the number of camels you
    have seen during a period of observation. And suppose that in one and a half years,
    you have spotted `23` camels. The data in your camel-spotting book might look
    like this.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 程序存储数据的一种方式是将其写入文本文件。例如，假设你是一个骆驼观察员，想要记录在一段观察期内看到的骆驼数量。假设在一年半的时间里，你已经观察到`23`只骆驼。你在骆驼观察本中的数据可能看起来是这样的。
- en: '[PRE18]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To write this data to a file, you can use the `write` method, which we saw in
    Chapter 8. The argument of `write` has to be a string, so if we want to put other
    values in a file, we have to convert them to strings. The easiest way to do that
    is with the built-in function `str`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这些数据写入文件，可以使用`write`方法，我们在第8章中见过。`write`的参数必须是一个字符串，因此如果我们想将其他值放入文件中，就必须将它们转换为字符串。最简单的方式是使用内置函数`str`。
- en: 'Here’s what that looks like:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来是这样的：
- en: '[PRE19]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That works, but `write` doesn’t add a space or newline unless you include it
    explicitly. If we read back the file, we see that the two numbers are run together.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这有效，但`write`不会添加空格或换行，除非你明确地包含它。如果我们重新读取文件，会发现两个数字被连在一起。
- en: '[PRE20]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: At the very least, we should add whitespace between the numbers. And while we’re
    at it, let’s add some explanatory text.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，我们应该在数字之间添加空格。顺便提一下，让我们添加一些说明文字。
- en: To write a combination of strings and other values, we can use an **f-string**,
    which is a string that has the letter `f` before the opening quotation mark, and
    contains one or more Python expressions in curly braces. The following f-string
    contains one expression, which is a variable name.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个字符串和其他值的组合，可以使用**f-string**，它是一个在开头有字母`f`的字符串，并且包含一个或多个用大括号括起来的 Python
    表达式。以下的 f-string 包含一个表达式，即一个变量名。
- en: '[PRE22]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The result is a string where the expression has been evaluated and replaced
    with the result. There can be more than one expression.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个字符串，其中的表达式已被求值并替换为结果。可以有多个表达式。
- en: '[PRE24]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: And the expressions can contain operators and function calls.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 而且这些表达式可以包含运算符和函数调用。
- en: '[PRE26]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: So we could write the data to a text file like this.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们可以像这样将数据写入文本文件。
- en: '[PRE28]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Both f-strings end with the sequence `\n`, which adds a newline character.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 f-string 都以序列`\n`结尾，这会添加一个换行符。
- en: 'We can read the file back like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样读取文件：
- en: '[PRE29]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In an f-string, an expression in curly brace is converted to a string, so you
    can include lists, dictionaries, and other types.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 f-string 中，大括号中的表达式会被转换为字符串，因此你可以包含列表、字典和其他类型。
- en: '[PRE31]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 13.3\. YAML[#](#yaml "Link to this heading")
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3\. YAML[#](#yaml "Link to this heading")
- en: One of the reasons programs read and write files is to store **configuration
    data**, which is information that specifies what the program should do and how.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 程序读取和写入文件的原因之一是存储**配置信息**，这是一种指定程序应该做什么以及如何做的数据信息。
- en: For example, in a program that searches for duplicate photos, we might have
    a dictionary called `config` that contains the name of the directory to search,
    the name of another directory where it should store the results, and a list of
    file extensions it should use to identify image files.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个搜索重复照片的程序中，我们可能有一个名为`config`的字典，它包含了要搜索的目录名称、另一个目录的名称（用于存储结果），以及识别图片文件所用的文件扩展名列表。
- en: 'Here’s what it might look like:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像这样：
- en: '[PRE33]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To write this data in a text file, we could use f-strings, as in the previous
    section. But it is easier to use a module called `yaml` that is designed for just
    this sort of thing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这些数据写入文本文件，我们可以像上一节那样使用f-string。但使用一个名为`yaml`的模块会更方便，它专为处理这类事情而设计。
- en: The `yaml` module provides functions to work with YAML files, which are text
    files formatted to be easy for humans *and* programs to read and write.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`yaml`模块提供了用于处理YAML文件的函数，YAML文件是格式化为便于人类*和*程序阅读和写入的文本文件。'
- en: Here’s an example that uses the `dump` function to write the `config` dictionary
    to a YAML file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，使用`dump`函数将`config`字典写入YAML文件。
- en: '[PRE34]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If we read back the contents of the file, we can see what the YAML format looks
    like.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们读取文件的内容，我们可以看到YAML格式的样子。
- en: '[PRE35]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, we can use `safe_load` to read back the YAML file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`safe_load`来读取回YAML文件。
- en: '[PRE37]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The result is new dictionary that contains the same information as the original,
    but it is not the same dictionary.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个包含与原始字典相同信息的新字典，但它不是同一个字典。
- en: '[PRE39]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Converting an object like a dictionary to a string is called **serialization**.
    Converting the string back to an object is called **deserialization**. If you
    serialize and then deserialize an object, the result should be equivalent to the
    original.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 将字典之类的对象转换为字符串称为**序列化**。将字符串转换回对象称为**反序列化**。如果你先序列化再反序列化一个对象，结果应该与原始对象等效。
- en: 13.4\. Shelve[#](#shelve "Link to this heading")
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.4\. Shelve[#](#shelve "Link to this heading")
- en: So far we’ve been reading and writing text files – now let’s consider databases.
    A **database** is a file that is organized for storing data. Some databases are
    organized like a table with rows and columns of information. Others are organized
    like a dictionary that maps from keys to values; they are sometimes called **key-value
    stores**.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在读取和写入文本文件——现在让我们来考虑数据库。**数据库**是一个用于存储数据的组织化文件。有些数据库像表格一样，包含行和列的信息。其他的则像字典一样，通过键映射到值，它们有时被称为**键值存储**。
- en: The `shelve` module provides functions for creating and updating a key-value
    store called a “shelf”. As an example, we’ll create a shelf to contain captions
    for the figures in the `photos` directory. We’ll use the `config` dictionary to
    get the name of the directory where we should put the shelf.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`shelve`模块提供了创建和更新称为“shelf”的键值存储的功能。作为示例，我们将创建一个shelf来存储`photos`目录中图片的标题。我们将使用`config`字典来获取应该放置shelf的目录名称。'
- en: '[PRE41]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We can use `os.makedirs` to create this directory, if it doesn’t already exist.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目录不存在，我们可以使用`os.makedirs`来创建这个目录。
- en: '[PRE43]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: And `os.path.join` to make a path that includes the name of the directory and
    the name of the shelf file, `captions`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以及使用`os.path.join`来创建一个包含目录名称和shelf文件名称`captions`的路径。
- en: '[PRE44]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now we can use `shelve.open` to open the shelf file. The argument `c` indicates
    that the file should be created if necessary.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`shelve.open`打开shelf文件。参数`c`表示如果文件不存在，则创建该文件。
- en: '[PRE46]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The return value is officially a `DbfilenameShelf` object, more casually called
    a shelf object.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值官方称为`DbfilenameShelf`对象，更通俗地称为shelf对象。
- en: The shelf object behaves in many ways like a dictionary. For example, we can
    use the bracket operator to add an item, which is a mapping from a key to a value.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: shelf对象在许多方面像字典。例如，我们可以使用括号操作符添加一个条目，它是一个从键到值的映射。
- en: '[PRE48]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this example, the key is the path to an image file and the value is a string
    that describes the image.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，键是图像文件的路径，值是描述图像的字符串。
- en: We also use the bracket operator to look up a key and get the corresponding
    value.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用括号操作符来查找一个键并获取对应的值。
- en: '[PRE49]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If you make another assignment to an existing key, `shelve` replaces the old
    value.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对现有的键进行重新赋值，`shelve`会替换旧值。
- en: '[PRE51]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Some dictionary methods, like `keys`, `values` and `items`, also work with shelf
    objects.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一些字典方法，如`keys`、`values`和`items`，也适用于shelf对象。
- en: '[PRE53]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We can use the `in` operator to check whether a key appears in the shelf.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`in`操作符检查一个键是否出现在shelf中。
- en: '[PRE57]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: And we can use a `for` statement to loop through the keys.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`for`语句来遍历键。
- en: '[PRE59]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As with other files, you should close the database when you are done.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他文件一样，使用完数据库后，应该关闭它。
- en: '[PRE61]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now if we list the contents of the data directory, we see two files.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们列出数据目录的内容，我们会看到两个文件。
- en: '[PRE62]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '`captions.dat` contains the data we just stored. `captions.dir` contains information
    about the organization of the database that makes it more efficient to access.
    The suffix `dir` stands for “directory”, but it has nothing to do with the directories
    we’ve been working with that contain files.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`captions.dat`包含我们刚刚存储的数据。`captions.dir`包含有关数据库组织的信息，这使得访问更高效。后缀`dir`代表“目录”，但它与我们之前处理的包含文件的目录无关。'
- en: '## 13.5\. Storing data structures[#](#storing-data-structures "Link to this
    heading")'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '## 13.5\. 存储数据结构[#](#storing-data-structures "Link to this heading")'
- en: In the previous example, the keys and values in the shelf are strings. But we
    can also use a shelf to contain data structures like lists and dictionaries.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，架子中的键和值是字符串。但我们也可以使用架子来存储像列表和字典这样的数据结构。
- en: As an example, let’s revisit the anagram example from an exercise in [Chapter
    11](chap11.html#section-exercise-11). Recall that we made a dictionary that maps
    from a sorted string of letters to the list of words that can be spelled with
    those letters. For example, the key `'opst'` maps to the list `['opts', 'post',
    'pots', 'spot', 'stop', 'tops']`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，让我们重新回顾一下[第11章](chap11.html#section-exercise-11)练习中的字谜例子。回想一下，我们创建了一个字典，它将字母的排序字符串映射到可以用这些字母拼写出来的单词列表。例如，键`'opst'`映射到列表`['opts',
    'post', 'pots', 'spot', 'stop', 'tops']`。
- en: We’ll use the following function to sort the letters in a word.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下函数来排序一个单词中的字母。
- en: '[PRE64]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: And here’s an example.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子。
- en: '[PRE65]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Now let’s open a shelf called `anagram_map`. The argument `'n'` means we should
    always create a new, empty shelf, even if one already exists.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们打开一个名为`anagram_map`的架子。参数`'n'`意味着我们应该始终创建一个新的空架子，即使已经存在一个。
- en: '[PRE67]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now we can add an item to the shelf like this.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以像这样向架子中添加一个项目。
- en: '[PRE68]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In this item, the key is a string and the value is a list of strings.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个条目中，键是一个字符串，值是一个字符串列表。
- en: Now suppose we find another word that contains the same letters, like `tops`
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们找到另一个包含相同字母的单词，比如`tops`。
- en: '[PRE70]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The key is the same as in the previous example, so we want to append a second
    word to the same list of strings. Here’s how we would do it if `db` were a dictionary.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个键与之前的例子相同，所以我们想将第二个单词附加到同一个字符串列表中。如果`db`是一个字典，下面就是我们如何做的。
- en: '[PRE72]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: But if we run that and then look up the key in the shelf, it looks like it has
    not been updated.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们运行它并查看架子中的键，它看起来没有被更新。
- en: '[PRE73]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Here’s the problem: when we look up the key, we get a list of strings, but
    if we modify the list of strings, it does not affect the shelf. If we want to
    update the shelf, we have to read the old value, update it, and then write the
    new value back to the shelf.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是问题：当我们查找键时，我们得到的是一个字符串列表，但如果我们修改这个字符串列表，它并不会影响架子。如果我们想要更新架子，必须先读取旧值，更新它，然后将新值写回架子。
- en: '[PRE75]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Now the value in the shelf is updated.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在架子中的值已更新。
- en: '[PRE76]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'As an exercise, you can finish this example by reading the word list and storing
    all of the anagrams in a shelf.  ## 13.6\. Checking for equivalent files[#](#checking-for-equivalent-files
    "Link to this heading")'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，你可以通过读取单词列表并将所有的字谜存储到一个架子中来完成这个例子。## 13.6\. 检查等效文件[#](#checking-for-equivalent-files
    "Link to this heading")
- en: 'Now let’s get back to the goal of this chapter: searching for different files
    that contain the same data. One way to check is to read the contents of both files
    and compare.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到本章的目标：搜索包含相同数据的不同文件。检查的一种方法是读取两个文件的内容并进行比较。
- en: If the files contain images, we have to open them with mode `'rb'`, where `'r'`
    means we want to read the contents and `'b'` indicates **binary mode**. In binary
    mode, the contents are not interpreted as text – they are treated as a sequence
    of bytes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件包含图像，我们必须以`'rb'`模式打开它们，其中`'r'`表示我们想要读取内容，而`'b'`表示**二进制模式**。在二进制模式下，内容不会被解释为文本，而是作为字节序列处理。
- en: Here’s an example that opens and reads an image file.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个打开并读取图像文件的例子。
- en: '[PRE78]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The result from `read` is a `bytes` object – as the name suggests, it contains
    a sequence of bytes.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`的结果是一个`bytes`对象——顾名思义，它包含一个字节序列。'
- en: In general the contents of an image file and not human-readable. But if we read
    the contents from a second file, we can use the `==` operator to compare.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，图像文件的内容是不可读的。但如果我们从第二个文件中读取内容，我们可以使用`==`运算符进行比较。
- en: '[PRE80]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: These two files are not equivalent.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个文件并不相等。
- en: Let’s encapsulate what we have so far in a function.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将目前为止的内容封装成一个函数。
- en: '[PRE82]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: If we have only two files, this function is a good option. But suppose we have
    a large number of files and we want to know whether any two of them contain the
    same data. It would be inefficient to compare every pair of files.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只有两个文件，这个函数是一个不错的选择。但假设我们有大量的文件，并且想知道是否有任何两个文件包含相同的数据。逐一比较每对文件将是低效的。
- en: An alternative is to use a **hash function**, which takes the contents of a
    file and computes a **digest**, which is usually a large integer. If two files
    contain the same data, they will have the same digest. If two files differ, they
    will *almost always* have different digests.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用**哈希函数**，它接受文件内容并计算一个**摘要**，通常是一个大整数。如果两个文件包含相同的数据，它们将有相同的摘要。如果两个文件不同，它们*几乎总是*会有不同的摘要。
- en: The `hashlib` module provides several hash functions – the one we’ll use is
    called `md5`. We’ll start by using `hashlib.md5` to create a `HASH` object.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`hashlib`模块提供了几种哈希函数——我们将使用的叫做`md5`。我们将通过使用`hashlib.md5`来创建一个`HASH`对象。'
- en: '[PRE83]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The `HASH` object provides an `update` method that takes the contents of the
    file as an argument.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`HASH`对象提供了一个`update`方法，该方法以文件内容作为参数。'
- en: '[PRE85]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Now we can use `hexdigest` to get the digest as a string of hexadecimal digits
    that represent an integer in base 16.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`hexdigest`来获取摘要，作为一个十六进制数字的字符串，表示一个基数为16的整数。
- en: '[PRE86]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The following function encapsulates these steps.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数封装了这些步骤。
- en: '[PRE88]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: If we hash the contents of a different file, we can confirm that we get a different
    digest.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对不同文件的内容进行哈希处理，我们可以确认我们得到的是不同的摘要。
- en: '[PRE89]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now we have almost everything we need to find equivalent files. The last step
    is to search a directory and find all of the images files.  ## 13.7\. Walking
    directories[#](#walking-directories "Link to this heading")'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们几乎拥有了找到等效文件所需的所有内容。最后一步是搜索一个目录并找到所有的图片文件。 ## 13.7\. 遍历目录[#](#walking-directories
    "Link to this heading")'
- en: The following function takes as an argument the directory we want to search.
    It uses `listdir` to loop through the contents of the directory. When it finds
    a file, it prints its complete path. When it finds a directory, it calls itself
    recursively to search the subdirectory.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数以我们想要搜索的目录作为参数。它使用`listdir`循环遍历目录的内容。当它找到一个文件时，它打印出完整路径。当它找到一个目录时，它递归调用自己以搜索子目录。
- en: '[PRE91]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We can use it like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样使用它：
- en: '[PRE92]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The order of the results depends on details of the operating system.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的顺序取决于操作系统的具体细节。
- en: 13.8\. Debugging[#](#debugging "Link to this heading")
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.8\. 调试[#](#debugging "Link to this heading")
- en: When you are reading and writing files, you might run into problems with whitespace.
    These errors can be hard to debug because whitespace characters are normally invisible.
    For example, here’s a string that contains spaces, a tab represented by the sequence
    `\t`, and a newline represented by the sequence `\n`. When we print it, we don’t
    see the whitespace characters.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在读取和写入文件时，可能会遇到空白字符的问题。这些错误可能很难调试，因为空白字符通常是不可见的。例如，这里有一个包含空格、由序列`\t`表示的制表符和由序列`\n`表示的新行的字符串。当我们打印它时，看不见空白字符。
- en: '[PRE94]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The built-in function `repr` can help. It takes any object as an argument and
    returns a string representation of the object. For strings, it represents whitespace
    characters with backslash sequences.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 内置函数`repr`可以提供帮助。它接受任何对象作为参数，并返回该对象的字符串表示。对于字符串，它用反斜杠序列表示空白字符。
- en: '[PRE96]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This can be helpful for debugging.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这对调试很有帮助。
- en: One other problem you might run into is that different systems use different
    characters to indicate the end of a line. Some systems use a newline, represented
    `\n`. Others use a return character, represented `\r`. Some use both. If you move
    files between different systems, these inconsistencies can cause problems.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个你可能遇到的问题是，不同的系统使用不同的字符来表示行结束。有些系统使用换行符，表示为`\n`。其他系统使用回车符，表示为`\r`。有些系统同时使用这两者。如果你在不同系统之间移动文件，这些不一致可能会导致问题。
- en: File name capitalization is another issue you might encounter if you work with
    different operating systems. In macOS and UNIX, file names can contain lowercase
    and uppercase letters, digits, and most symbols. But many Windows applications
    ignore the difference between lowercase and uppercase letters, and several symbols
    that are allowed in macOS and UNIX are not allowed in Windows.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名大小写是你在处理不同操作系统时可能遇到的另一个问题。在macOS和UNIX中，文件名可以包含小写字母、大写字母、数字和大多数符号。但是许多Windows应用程序忽略大小写字母之间的区别，而且在macOS和UNIX中允许的几个符号在Windows中不允许。
- en: 13.9\. Glossary[#](#glossary "Link to this heading")
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.9\. 术语表[#](#glossary "链接到这个标题")
- en: '**ephemeral:** An ephemeral program typically runs for a short time and, when
    it ends, its data are lost.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**短暂的：** 短暂程序通常运行一段时间，结束时，其数据会丢失。'
- en: '**persistent:** A persistent program runs indefinitely and keeps at least some
    of its data in permanent storage.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**持久的：** 持久程序可以无限期运行，并将至少一部分数据保存在永久存储中。'
- en: '**directory:** A collection of files and other directories.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**目录：** 一组文件和其他目录的集合。'
- en: '**current working directory:** The default directory used by a program unless
    another directory is specified.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**当前工作目录：** 程序使用的默认目录，除非指定了其他目录。'
- en: '**path:** A string that specifies a sequence of directories, often leading
    to a file.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**路径：** 指定一系列目录的字符串，通常指向一个文件。'
- en: '**relative path:** A path that starts from the current working directory, or
    some other specified directory.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**相对路径：** 从当前工作目录或某个其他指定目录开始的路径。'
- en: '**absolute path:** A path that does not depend on the current directory.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**绝对路径：** 不依赖于当前目录的路径。'
- en: '**f-string:** A string that has the letter `f` before the opening quotation
    mark, and contains one or more expressions in curly braces.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**f-string：** 在开头有字母`f`的字符串，其中包含一个或多个用大括号括起来的表达式。'
- en: '**configuration data:** Data, often stored in a file, that specifies what a
    program should do and how.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**配置数据：** 通常存储在文件中，指定程序应该做什么以及如何做的数据。'
- en: '**serialization:** Converting an object to a string.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**序列化：** 将对象转换为字符串。'
- en: '**deserialization:** Converting a string to an object.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**反序列化：** 将字符串转换为对象。'
- en: '**database:** A file whose contents are organized to perform certain operations
    efficiently.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据库：** 一个文件，其内容被组织成能够高效执行特定操作的形式。'
- en: '**key-value stores:** A database whose contents are organized like a dictionary
    with keys that correspond to values.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**键值存储：** 一种数据库，其内容像字典一样组织，键对应着值。'
- en: '**binary mode:** A way of opening a file so the contents are interpreted as
    sequence of bytes rather than a sequence of characters.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**二进制模式：** 打开文件的一种方式，使得文件内容被解释为字节序列而不是字符序列。'
- en: '**hash function:** A function that takes and object and computes an integer,
    which is sometimes called a digest.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希函数：** 一个接受对象并计算出整数的函数，这个整数有时被称为摘要。'
- en: '**digest:** The result of a hash function, especially when it is used to check
    whether two objects are the same.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**摘要：** 哈希函数的结果，尤其是在用来检查两个对象是否相同时。'
- en: 13.10\. Exercises[#](#exercises "Link to this heading")
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.10\. 练习[#](#exercises "链接到这个标题")
- en: '[PRE98]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 13.10.1\. Ask a virtual assistant[#](#ask-a-virtual-assistant "Link to this
    heading")
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.10.1\. 向虚拟助手提问[#](#ask-a-virtual-assistant "链接到这个标题")
- en: There are several topics that came up in this chapter that I did not explain
    in detail. Here are some questions you can ask a virtual assistant to get more
    information.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中出现了几个我没有详细解释的主题。以下是一些你可以向虚拟助手提问的问题，获取更多信息。
- en: “What are the differences between ephemeral and persistent programs?”
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “短暂程序和持久程序有什么区别？”
- en: “What are some examples of persistent programs?”
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “什么是持久程序的例子？”
- en: “What’s the difference between a relative path and an absolute path?”
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “相对路径和绝对路径有什么区别？”
- en: “Why does the `yaml` module have functions called `load` and `safe_load`?”
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “为什么`yaml`模块有名为`load`和`safe_load`的函数？”
- en: “When I write a Python shelf, what are the files with suffixes `dat` and `dir`?”
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “当我写一个Python shelf时，`dat`和`dir`后缀的文件是什么？”
- en: “Other than key-values stores, what other kinds of databases are there?”
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “除了键值存储，还有哪些类型的数据库？”
- en: “When I read a file, what’s the difference between binary mode and text mode?”
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “当我读取一个文件时，二进制模式和文本模式有什么区别？”
- en: “What are the differences between a bytes object and a string?”
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “字节对象和字符串有什么区别？”
- en: “What is a hash function?”
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “什么是哈希函数？”
- en: “What is an MD5 digest?”
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “什么是MD5摘要？”
- en: As always, if you get stuck on any of the following exercises, consider asking
    a VA for help. Along with your question, you might want to paste in the relevant
    functions from this chapter.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，如果你在以下练习中遇到困难，可以考虑向虚拟助手求助。除了提问之外，你可能还想粘贴本章中的相关函数。
- en: 13.10.2\. Exercise[#](#exercise "Link to this heading")
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.10.2\. 练习[#](#exercise "链接到这个标题")
- en: Write a function called `replace_all` that takes as arguments a pattern string,
    a replacement string, and two filenames. It should read the first file and write
    the contents into the second file (creating it if necessary). If the pattern string
    appears anywhere in the contents, it should be replaced with the replacement string.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个名为`replace_all`的函数，该函数接受一个模式字符串、一个替换字符串和两个文件名作为参数。它应该读取第一个文件，并将内容写入第二个文件（如果需要，创建它）。如果模式字符串出现在内容中的任何位置，它应被替换为替换字符串。
- en: Here’s an outline of the function to get you started.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个函数的概要，帮助你入门。
- en: '[PRE100]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: To test your function, read the file `photos/notes.txt`, replace `'photos'`
    with `'images'`, and write the result to the file `photos/new_notes.txt`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试你的函数，读取文件`photos/notes.txt`，将`'photos'`替换为`'images'`，并将结果写入文件`photos/new_notes.txt`。
- en: 13.10.3\. Exercise[#](#id1 "Link to this heading")
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.10.3\. 练习[#](#id1 "跳转到此标题")
- en: In [a previous section](#section-storing-data-structure), we used the `shelve`
    module to make a key-value store that maps from a sorted string of letters to
    a list of anagrams. To finish the example, write a function called `add_word`
    that takes as arguments a string and a shelf object.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在[前一节](#section-storing-data-structure)中，我们使用了`shelve`模块创建了一个键值存储，将排序后的字母字符串映射到一个变位词的列表。为了完成示例，编写一个名为`add_word`的函数，该函数接受一个字符串和一个架子对象作为参数。
- en: It should sort the letters of the word to make a key, then check whether the
    key is already in the shelf. If not, it should make a list that contains the new
    word and add it to the shelf. If so, it should append the new word to the existing
    value.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该对单词的字母进行排序以生成一个键，然后检查该键是否已存在于架子中。如果不存在，它应该创建一个包含新单词的列表并将其添加到架子中。如果存在，它应该将新单词附加到现有值的列表中。
- en: 13.10.4\. Exercise[#](#id2 "Link to this heading")
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.10.4\. 练习[#](#id2 "跳转到此标题")
- en: In a large collection of files, there may be more than one copy of the same
    file, stored in different directories or with different file names. The goal of
    this exercise is to search for duplicates. As an example, we’ll work with image
    files in the `photos` directory.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个大型文件集合中，可能存在多个相同文件的副本，存储在不同的目录或使用不同的文件名。这个练习的目标是搜索重复文件。作为示例，我们将处理`photos`目录中的图像文件。
- en: 'Here’s how it will work:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是它的工作原理：
- en: We’ll use the `walk` function from [Walking directories](#section-walking-directories)
    to search this directory for files that end with one of the extensions in `config['extensions']`.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用来自[遍历目录](#section-walking-directories)的`walk`函数来搜索该目录中的文件，这些文件扩展名与`config['extensions']`中的某个扩展名匹配。
- en: For each file, we’ll use `md5_digest` from [Checking for equivalent files](#section-md5-digest)
    to compute a digest of the contents.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个文件，我们将使用来自[检查等效文件](#section-md5-digest)的`md5_digest`来计算内容的摘要。
- en: Using a shelf, we’ll make a mapping from each digest to a list of paths with
    that digest.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用架子，我们将从每个摘要映射到包含该摘要的路径列表。
- en: Finally, we’ll search the shelf for any digests that map to multiple files.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将搜索架子，查找映射到多个文件的任何摘要。
- en: If we find any, we’ll use `same_contents` to confirm that the files contain
    the same data.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找到任何匹配项，我们将使用`same_contents`来确认文件是否包含相同的数据。
- en: I’ll suggest some functions to write first, then we’ll bring it all together.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先建议编写一些函数，然后我们将把所有内容结合在一起。
- en: 'To identify image files, write a function called `is_image` that takes a path
    and a list of file extensions, and returns `True` if the path ends with one of
    the extensions in the list. Hint: Use `os.path.splitext` – or ask a virtual assistant
    to write this function for you.'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了识别图像文件，编写一个名为`is_image`的函数，该函数接受一个路径和一个文件扩展名列表，并在路径以列表中的某个扩展名结尾时返回`True`。提示：使用`os.path.splitext`，或者让虚拟助手为你编写这个函数。
- en: Write a function called `add_path` that takes as arguments a path and a shelf.
    It should use `md5_digest` to compute a digest of the file contents. Then it should
    update the shelf, either creating a new item that maps from the digest to a list
    containing the path, or appending the path to the list if it exists.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`add_path`的函数，该函数接受一个路径和一个架子作为参数。它应该使用`md5_digest`来计算文件内容的摘要。然后，它应该更新架子，要么创建一个新的项，将摘要映射到包含路径的列表，要么将路径附加到已存在的列表中。
- en: Write a version of `walk` called `walk_images` that takes a directory and walks
    through the files in the directory and its subdirectories. For each file, it should
    use `is_image` to check whether it’s an image file and `add_path` to add it to
    the shelf.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`walk_images`的`walk`函数变体，它接受一个目录并遍历该目录及其子目录中的文件。对于每个文件，它应使用`is_image`来检查它是否是图像文件，并使用`add_path`将其添加到架子中。
- en: When everything is working, you can use the following program to create the
    shelf, search the `photos` directory and add paths to the shelf, and then check
    whether there are multiple files with the same digest.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切正常时，你可以使用以下程序来创建书架，搜索`photos`目录并将路径添加到书架中，然后检查是否有多个文件具有相同的摘要。
- en: '[PRE101]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: You should find one pair of files that have the same digest. Use `same_contents`
    to check whether they contain the same data.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该找到一对具有相同摘要的文件。使用`same_contents`来检查它们是否包含相同的数据。
- en: '[Think Python: 3rd Edition](https://allendowney.github.io/ThinkPython/index.html)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[Think Python: 第3版](https://allendowney.github.io/ThinkPython/index.html)'
- en: Copyright 2024 [Allen B. Downey](https://allendowney.com)
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 版权 2024 [Allen B. Downey](https://allendowney.com)
- en: 'Code license: [MIT License](https://mit-license.org/)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 代码许可：[MIT 许可](https://mit-license.org/)
- en: 'Text license: [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 文本许可：[创意共享署名-非商业性使用-相同方式共享 4.0 国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/)
