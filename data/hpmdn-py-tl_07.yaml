- en: Chapter 5\. Managing Projects with Poetry
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 管理使用Poetry的项目
- en: The preceding chapters introduced the building blocks for publishing production-quality
    Python packages. So far, you’ve written a *pyproject.toml* for a project; created
    an environment and installed dependencies with uv, pip, or pip-tools; and built
    and published packages with `build` and Twine.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章介绍了发布高质量Python包的基础模块。到目前为止，你为项目编写了一个*pyproject.toml*；创建了一个环境，并使用uv、pip或pip-tools安装了依赖；并使用`build`和Twine构建并发布了软件包。
- en: 'By standardizing project metadata and build backends, *pyproject.toml* broke
    the setuptools monopoly (see [“The Evolution of Python Project Managers”](#sidebar_poetry_evolution))
    and brought diversity to the packaging ecosystem. Defining a Python package got
    easier, too: a single well-specified file with great tooling support replaces
    the legacy boilerplate of *setup.py* and untold configuration files.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过标准化项目元数据和构建后端，*pyproject.toml*打破了setuptools的垄断（见[“Python项目管理器的演变”](#sidebar_poetry_evolution)），并为打包生态系统带来了多样性。定义Python包也变得更简单：一个明确定义的文件配合优秀的工具支持，取代了*setup.py*及不计其数的配置文件的传统模板。
- en: Yet, some problems remain.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，仍然存在一些问题。
- en: Before you can work on a *pyproject.toml*-based project, you need to research
    packaging workflows, configuration files, and associated tooling. You have to
    choose one of a number of available build backends ([Table 3-2](ch03.html#table_packages_build_backends))—and
    many people don’t know what those are, let alone how to choose them. Important
    aspects of Python packages remain unspecified—​for example, how project sources
    are laid out and which files should go into the packaging artifacts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可以开始处理基于*pyproject.toml*的项目之前，你需要研究打包工作流程、配置文件以及相关工具。你必须从多个可用的构建后端中选择一个（见[表 3-2](ch03.html#table_packages_build_backends)）—而很多人不知道这些是什么，更不用说如何选择了。Python包的重要方面仍然未指明—例如，项目源代码的布局及哪些文件应包含在打包工件中。
- en: Dependency and environment management could be easier, too. You need to handcraft
    your dependency specifications and compile them with pip-tools, cluttering your
    project with requirements files. And it can be hard to keep track of the many
    Python environments on a typical developer system.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖和环境管理也可以更简单。你需要手工制作你的依赖规范，并使用pip-tools编译它们，使你的项目混乱不堪。在典型的开发者系统上跟踪多个Python环境可能很困难。
- en: The Python project manager Poetry was addressing these problems before some
    of the standards governing *pyproject.toml* took shape. Its friendly command-line
    interface lets you perform most tasks related to packaging, dependencies, and
    environments. Poetry brings its own standards-compliant build backend, `poetry.core`—but
    you can remain blissfully unaware of this fact. It also comes with a strict dependency
    resolver and locks all dependencies by default, behind the scenes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在*pyproject.toml*的标准规范制定之前，Python项目管理器Poetry已经在解决这些问题。它友好的命令行界面让你可以执行大多数与打包、依赖和环境相关的任务。Poetry带来了符合标准的构建后端`poetry.core`—但你可以毫不知情地继续使用。它还配备了严格的依赖解析器，并默认锁定所有依赖项，所有这些都在幕后进行。
- en: Why learn about packaging standards and low-level plumbing if Poetry abstracts
    away many of these details? Because, while Poetry ventures into new territory,
    it still works within the framework defined by packaging standards. Mechanisms
    like dependency specifications and virtual environments power its central features.
    Interoperability standards let Poetry interact with package repositories as well
    as other build backends and package installers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Poetry在很大程度上将这些细节抽象化掉，为什么要学习打包标准和底层管道？因为虽然Poetry在新领域中大展拳脚，但它仍在打包标准定义的框架内运作。像依赖规范和虚拟环境这样的机制支持其核心功能。互操作性标准使Poetry能够与软件包存储库以及其他构建后端和包安装程序进行交互。
- en: An understanding of these underlying mechanisms helps you debug situations where
    Poetry’s convenient abstractions break down—​for example, when a misconfiguration
    or a bug causes a package to end up in the wrong environment. Finally, the experience
    of past decades teaches us that tools come and go, while standards and algorithms
    are here to stay.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些底层机制的理解有助于你调试情况，例如Poetry方便的抽象出现问题时—例如，当配置错误或错误导致软件包进入错误的环境时。最后，过去几十年的经验告诉我们，工具来了又走，而标准和算法却是长存的。
- en: Installing Poetry
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Poetry
- en: 'Install Poetry globally using pipx, to keep its dependencies isolated from
    the rest of the system:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pipx全局安装Poetry，以使其依赖与系统其余部分隔离开来：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A single Poetry installation works with multiple Python versions. However,
    Poetry uses its own interpreter as the default Python version. For this reason,
    it’s worthwhile to install Poetry on the latest stable Python release. When installing
    a new feature release of Python, reinstall Poetry like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 单个 Poetry 安装可以与多个 Python 版本一起使用。但是，Poetry 默认使用其自己的解释器作为默认 Python 版本。因此，建议在最新稳定的
    Python 发行版上安装 Poetry。安装新的 Python 功能版本时，请像这样重新安装 Poetry：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can omit the `--python` option if pipx already uses the new Python version
    (see [“Configuring Pipx”](ch02.html#section_environments_pipx_configuration)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 pipx 已经使用新的 Python 版本，请忽略 `--python` 选项（见[“配置 Pipx”](ch02.html#section_environments_pipx_configuration)）。
- en: 'When a prerelease of Poetry becomes available, you can install it side-by-side
    with the stable version:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Poetry 的预发行版可用时，您可以将其与稳定版本并行安装：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Above, I’ve used the `--suffix` option to rename the command so you can invoke
    it as `poetry@preview`, while keeping `poetry` as the stable version. The `--pip-args`
    option lets you pass options to pip, like `--pre` for including prereleases.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例中，我使用了 `--suffix` 选项来重命名命令，因此您可以将其称为 `poetry@preview`，同时保持 `poetry` 为稳定版本。`--pip-args`
    选项允许您将选项传递给 pip，例如用于包括预发行版的 `--pre`。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Poetry also comes with an [official installer](https://python-poetry.org/docs/#installing-with-the-official-installer),
    which you can download and run with Python. It’s not as flexible as pipx, but
    it provides a readily available alternative:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Poetry 还提供了一个[官方安装程序](https://python-poetry.org/docs/#installing-with-the-official-installer)，您可以使用
    Python 下载并运行。虽然不像 pipx 那样灵活，但提供了一个现成的替代方案：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Upgrade Poetry periodically to receive improvements and bugfixes:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 定期升级 Poetry 以获取改进和错误修复：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Type `poetry` on its own to check your installation of Poetry. Poetry prints
    its version and usage to the terminal, including a useful listing of all available
    subcommands.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端上输入 `poetry` 来检查 Poetry 的安装情况。Poetry 会打印其版本和用法，包括所有可用子命令的有用列表。
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Having successfully installed Poetry, you may want to enable tab completion
    for your shell. Use the command `poetry help completions` for shell-specific instructions.
    For example, the following commands enable tab completion in the Bash shell:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 成功安装 Poetry 后，您可能希望为您的 shell 启用选项卡完成。使用命令 `poetry help completions` 获取特定于 shell
    的说明。例如，以下命令在 Bash shell 中启用选项卡完成：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Restart your shell for the changes to take effect.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 重启您的 shell 以使更改生效。
- en: Creating a Project
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目
- en: 'You can create a new project using the command `poetry new`. As an example,
    I’ll use the `random-wikipedia-article` project from previous chapters. Run the
    following command in the parent directory where you want to keep your new project:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用命令 `poetry new` 创建一个新项目。作为示例，我将使用前几章中的 `random-wikipedia-article` 项目。在您想要保存新项目的父目录中运行以下命令：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After running this command, you’ll see that Poetry created a project directory
    named *random-wikipedia-article*, with the following structure:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，您将看到 Poetry 创建了一个名为 *random-wikipedia-article* 的项目目录，其结构如下：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `--src` option instructs Poetry to place the import package in a subdirectory
    named *src* rather than directly in the project directory.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`--src` 选项指示 Poetry 将导入包放置在名为 *src* 的子目录中，而不是直接放在项目目录中。'
- en: 'Let’s take a look at the generated *pyproject.toml* ([Example 5-1](#example_poetry_pyproject_toml)):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看生成的 *pyproject.toml* 文件（[示例 5-1](#example_poetry_pyproject_toml)）：
- en: Example 5-1\. A pyproject.toml file for Poetry
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-1\. Poetry 的 pyproject.toml 文件
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Poetry has created a standard `build-system` table with its build backend,
    `poetry.core`. This means anybody can install your project from source using pip
    or uv—​no need to set up, or even know about, the Poetry project manager. Similarly,
    you can build packages using any standard build frontend, such as `build`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Poetry 使用其构建后端 `poetry.core` 创建了一个标准的 `build-system` 表。这意味着任何人都可以使用 pip 或 uv
    从源代码安装您的项目，无需设置或了解 Poetry 项目管理器。同样，您可以使用任何标准的构建前端（例如 `build`）构建包：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The Project Metadata
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目元数据
- en: You may be surprised to see the project metadata appear under `tool.poetry`
    instead of the familiar `project` table (see [“Project Metadata”](ch03.html#section_packages_project_metadata)).
    The Poetry project plans to support the project metadata standard in its next
    major release.^([1](ch05.html#id284)) As you can see in [Table 5-1](#table_poetry_metadata),
    most fields have the same name and a similar syntax and meaning.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶地看到项目元数据出现在`tool.poetry`下，而不是熟悉的`project`表（参见[“项目元数据”](ch03.html#section_packages_project_metadata)）。Poetry项目计划在其下一个主要发布版中支持项目元数据标准。^([1](ch05.html#id284))
    正如您在[表格 5-1](#table_poetry_metadata)中所见，大多数字段具有相同的名称、类似的语法和含义。
- en: '[Example 5-2](#example_poetry_metadata) fills in the metadata for the project.
    I’ve highlighted some differences from [Example 3-4](ch03.html#example_packages_pyproject_toml_large).
    (You’ll use the command-line interface to add the dependencies later.)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-2](#example_poetry_metadata) 填写了项目的元数据。我突出了与[示例 3-4](ch03.html#example_packages_pyproject_toml_large)的一些不同之处。（稍后您将使用命令行界面添加依赖项。）'
- en: Example 5-2\. Metadata for a Poetry project
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-2\. Poetry项目的元数据
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_managing_projects_with_poetry_CO1-1)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_managing_projects_with_poetry_CO1-1)'
- en: The `license` field is a string with a SPDX identifier, not a table.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`license`字段是一个带有SPDX标识符的字符串，而不是表格。'
- en: '[![2](assets/2.png)](#co_managing_projects_with_poetry_CO1-2)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_managing_projects_with_poetry_CO1-2)'
- en: The `authors` field contains strings in the format `"name <email>"`, not tables.
    Poetry pre-populates the field with your name and email from Git.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`authors`字段包含格式为`"name <email>"`的字符串，而不是表格。Poetry会从Git中预填充此字段的姓名和电子邮件地址。'
- en: '[![3](assets/3.png)](#co_managing_projects_with_poetry_CO1-3)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_managing_projects_with_poetry_CO1-3)'
- en: The `readme` field is a string with the file path. You can also specify multiple
    files as an array of strings, such as *README.md* and *CHANGELOG.md*. Poetry concatenates
    them with a blank line in between.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`readme`字段是一个字符串，其中包含文件路径。您还可以将多个文件指定为字符串数组，例如*README.md*和*CHANGELOG.md*。Poetry将它们之间用空行连接起来。'
- en: '[![4](assets/4.png)](#co_managing_projects_with_poetry_CO1-4)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_managing_projects_with_poetry_CO1-4)'
- en: Poetry has dedicated fields for some project URLs, namely its homepage, repository,
    and documentation; for other URLs, there’s also a generic `urls` table.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Poetry专门为一些项目URL提供了字段，即其主页、存储库和文档；对于其他URL，还有一个通用的`urls`表。
- en: '[![5](assets/5.png)](#co_managing_projects_with_poetry_CO1-5)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_managing_projects_with_poetry_CO1-5)'
- en: The `python` entry in `dependencies` lets you declare compatible Python versions.
    For this project, you require Python 3.10 or later.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`dependencies`中的`python`条目允许您声明兼容的Python版本。对于这个项目，您需要Python 3.10或更高版本。'
- en: Table 5-1\. Metadata fields in `tool.poetry`
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 5-1\. `tool.poetry`中的元数据字段
- en: '| Field | Type | Description | `project` field |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 字段 | 类型 | 描述 | `project`字段 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `name` | string | The project name | `name` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `name` | string | 项目名称 | `name` |'
- en: '| `version` | string | The version of the project | `version` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `version` | string | 项目的版本号 | `version` |'
- en: '| `description` | string | A short description of the project | `description`
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `description` | string | 项目的简要描述 | `description` |'
- en: '| `keywords` | array of strings | A list of keywords for the project | `keywords`
    |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `keywords` | 字符串数组 | 项目的关键词列表 | `keywords` |'
- en: '| `readme` | string or array of strings | A file or list of files with the
    project description | `readme` |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `readme` | string或字符串数组 | 项目描述文件或文件列表 | `readme` |'
- en: '| `license` | string | A SPDX license identifier, or “Proprietary” | `license`
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `license` | string | SPDX许可证标识符，或“Proprietary” | `license` |'
- en: '| `authors` | array of strings | The list of authors | `authors` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `authors` | 字符串数组 | 作者列表 | `authors` |'
- en: '| `maintainers` | array of strings | The list of maintainers | `maintainers`
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `maintainers` | 字符串数组 | 维护者列表 | `maintainers` |'
- en: '| `classifiers` | array of strings | A list of classifiers describing the project
    | `classifiers` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `classifiers` | 字符串数组 | 描述项目的分类器列表 | `classifiers` |'
- en: '| `homepage` | string | The URL of the project homepage | `urls` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `homepage` | string | 项目主页的URL | `urls` |'
- en: '| `repository` | string | The URL of the project repository | `urls` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `repository` | string | 项目存储库的URL | `urls` |'
- en: '| `documentation` | string | The URL of the project documentation | `urls`
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `documentation` | string | 项目文档的URL | `urls` |'
- en: '| `urls` | table of strings | The project URLs | `urls` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `urls` | 字符串表格 | 项目的URL列表 | `urls` |'
- en: '| `dependencies` | array of strings or tables | The list of required third-party
    packages | `dependencies` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `dependencies` | 字符串或表格的数组 | 所需第三方包的列表 | `dependencies` |'
- en: '| `extras` | table of arrays of strings | Named lists of optional third-party
    packages | `optional-dependencies` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `extras` | 字符串或表的数组的表 | 可选的第三方包的命名列表 | `optional-dependencies` |'
- en: '| `groups` | table of arrays of strings | Named lists of development dependencies
    | *none* |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `groups` | 字符串或表的数组的表 | 开发依赖项的命名列表 | *none* |'
- en: '| `scripts` | table of strings or tables | Entry-point scripts | `scripts`
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `scripts` | 字符串或表的数组的表 | 入口点脚本 | `scripts` |'
- en: '| `plugins` | table of tables of strings | Entry point groups | `entry-points`
    |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `plugins` | 表的表的字符串 | 入口点组 | `entry-points` |'
- en: 'Some `project` fields have no direct equivalent under `tool.poetry`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`tool.poetry` 下的一些 `project` 字段没有直接等价项：'
- en: There’s no `requires-python` field; instead, you specify the required Python
    version in the `dependencies` table, using the `python` key.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有 `requires-python` 字段；相反，您可以使用 `dependencies` 表中的 `python` 键指定所需的 Python 版本。
- en: There’s no dedicated field for GUI scripts; use `plugins.gui_scripts` instead.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有专门的 GUI 脚本字段；请改用 `plugins.gui_scripts`。
- en: There’s no `dynamic` field—​all metadata is Poetry-specific, so declaring dynamic
    fields wouldn’t make much sense.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有 `dynamic` 字段—​所有元数据都是特定于 Poetry 的，因此声明动态字段没有多大意义。
- en: 'Before we move on, let’s check that the *pyproject.toml* file is valid. Poetry
    provides a convenient command to validate the TOML file against its configuration
    schema:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们确保 *pyproject.toml* 文件是有效的。Poetry 提供了一个方便的命令，可以针对其配置模式验证 TOML 文件：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The Package Contents
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包内容
- en: Poetry allows you to specify which files and directories to include in the distribution—​a
    feature still missing from the *pyproject.toml* standards ([Table 5-2](#table_poetry_contents)).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Poetry 允许您指定要包含在分发中的文件和目录，这是 *pyproject.toml* 标准中仍然缺失的功能（[表 5-2](#table_poetry_contents)）。
- en: Table 5-2\. Package content fields in `tool.poetry`
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-2\. `tool.poetry` 中的包内容字段
- en: '| Field | Type | Description |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| Field | Type | Description |'
- en: '| --- | --- | --- |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `packages` | array of tables | Patterns for modules to include in the distribution
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `packages` | 表的数组 | 分发中要包含的模块的模式 |'
- en: '| `include` | array of strings or tables | Patterns for files to include in
    the distribution |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `include` | 字符串或表的数组 | 分发中要包含的文件的模式 |'
- en: '| `exclude` | array of strings or tables | Patterns for files to exclude from
    the distribution |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `exclude` | 字符串或表的数组 | 分发中要排除的文件的模式 |'
- en: Each table under `packages` has an `include` key with a file or directory. You
    can use `*` and `**` wildcards in their names and paths, respectively. The `from`
    key allows you to include modules from subdirectories such as *src*. Finally,
    you can use the `format` key to restrict modules to a specific distribution format;
    valid values are `sdist` and `wheel`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`packages` 下的每个表都有一个 `include` 键，指定文件或目录。您可以在名称和路径中使用 `*` 和 `**` 通配符。 `from`
    键允许您包含来自子目录（如 *src*）的模块。最后，您可以使用 `format` 键限制模块到特定的分发格式；有效值为 `sdist` 和 `wheel`。'
- en: The `include` and `exclude` fields allow you to list other files to include
    in, or exclude from, the distribution. Poetry seeds the `exclude` field using
    the *.gitignore* file, if present. Instead of a string, you can also use a table
    with `path` and `format` keys for sdist-only or wheel-only files. [Example 5-3](#example_poetry_sdist_with_tests)
    shows how to include the test suite in source distributions.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`include` 和 `exclude` 字段允许您列出要包含在分发中或从分发中排除的其他文件。如果存在 *.gitignore* 文件，Poetry
    将使用该文件填充 `exclude` 字段。除了字符串外，还可以使用带有 `path` 和 `format` 键的表，仅适用于 sdist 或 wheel
    文件。 [示例 5-3](#example_poetry_sdist_with_tests) 展示了如何在源分发中包含测试套件。'
- en: Example 5-3\. Including the test suite in source distributions
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-3\. 将测试套件包含在源分发中
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The Source Code
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源代码
- en: Copy the contents of [Example 5-4](#example_poetry_wikipedia_full) into the
    *__init__.py* file in the new project.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将 [示例 5-4](#example_poetry_wikipedia_full) 的内容复制到新项目的 *__init__.py* 文件中。
- en: Example 5-4\. The source code for `random-wikipedia-article`
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-4\. `random-wikipedia-article` 的源代码
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You’ve declared an entry-point script in the `scripts` section in *pyproject.toml*,
    so users can invoke the application as `random-wikipedia-article`. If you’d like
    to also allow users to invoke the program with `py -m random_wikipedia_article`,
    create a *__main__.py* module next to *__init__.py* as shown in [Example 3-3](ch03.html#example_packages_main).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *pyproject.toml* 的 `scripts` 部分中声明了一个入口点脚本，因此用户可以使用 `random-wikipedia-article`
    调用应用程序。如果您希望用户还可以使用 `py -m random_wikipedia_article` 调用程序，请像 [示例 3-3](ch03.html#example_packages_main)
    中显示的那样，创建一个与 *__init__.py* 并列的 *__main__.py* 模块。
- en: Managing Dependencies
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理依赖项
- en: 'Let’s add the dependencies for `random-wikipedia-article`, starting with Rich,
    the console output library:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`random-wikipedia-article`添加依赖项，首先是控制台输出库Rich：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you inspect *pyproject.toml* after running this command, you’ll find that
    Poetry has added Rich to the `dependencies` table ([Example 5-5](#example_poetry_dependencies_rich)):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个命令后检查*pyproject.toml*，你会发现Poetry已经将Rich添加到`dependencies`表中（见[示例 5-5](#example_poetry_dependencies_rich)）：
- en: Example 5-5\. The `dependencies` table after adding Rich
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-5\. 添加Rich后的`dependencies`表
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Poetry also installs the package into an environment for the project. If you
    already have a virtual environment in *.venv*, Poetry uses that. Otherwise, it
    creates a virtual environment in a shared location (see [“Managing Environments”](#section_poetry_environments)).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Poetry还会将包安装到项目的环境中。如果你已经有一个名为*.venv*的虚拟环境，Poetry会使用它。否则，它会在一个共享位置创建一个虚拟环境（参见[“管理环境”](#section_poetry_environments)）。
- en: Caret Constraints
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脱字符约束
- en: The caret (`^`) is a Poetry-specific extension to version specifiers, borrowed
    from npm, the package manager for Node.js. *Caret constraints* allow releases
    with the given minimum version, except those that may contain breaking changes
    according to the [Semantic Versioning](https://semver.org) standard. After `1.0.0`,
    a caret constraint allows patch and minor releases, but no major releases. Before
    `1.0.0`, only patch releases are allowed—​in the `0.*` era, minor releases are
    allowed to introduce breaking changes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 脱字符（`^`）是版本指定器的Poetry特定扩展，从Node.js的包管理器npm借鉴而来。*脱字符约束*允许以给定的最低版本发布，除了可能包含破坏性更改的版本，符合[语义化版本规范](https://semver.org)。在`1.0.0`之后，脱字符约束允许补丁版本和次要版本的发布，但不允许主要版本的发布。在`0.*`时代之前，只允许补丁版本的发布——次要版本允许引入破坏性更改。
- en: 'Caret constraints are similar to *tilde constraints* (see [“Version Specifiers”](ch04.html#section_dependencies_version_specifiers)),
    but the latter only allow the last version segment to increase. For example, the
    following constraints are equivalent:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 脱字符约束类似于*波浪线约束*（见[“版本指定器”](ch04.html#section_dependencies_version_specifiers)），但后者只允许最后一个版本段增加。例如，以下约束是等效的：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'On the other hand, tilde constraints typically exclude minor releases:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，波浪线约束通常排除次要版本：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Caret constraints put an upper bound on the version. As explained in [“Upper
    Version Bounds in Python”](ch04.html#sidebar_dependencies_upper_version_bounds),
    you should avoid upper bounds if you can. Add Rich with only a lower bound instead:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 脱字符约束对版本设置了一个上限。如[“Python中的上限版本边界”](ch04.html#sidebar_dependencies_upper_version_bounds)中所解释的那样，如果可能的话，应避免上限。只添加Rich的下限：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can use this command to remove upper bounds from existing caret constraints,
    as well.^([2](ch05.html#id285)) If you specified extras or markers when you first
    added the dependency, you’ll need to specify them again.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个命令从现有的脱字符约束中移除上限。如果你在第一次添加依赖时指定了额外的内容或标记，你需要再次指定它们。^([2](ch05.html#id285))
- en: Extras and Environment Markers
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 额外和环境标记
- en: Let’s add the other dependency of `random-wikipedia-article`, the HTTP client
    library `httpx`. Like in [Chapter 4](ch04.html#chapter_dependencies), you’ll activate
    the `http2` extra for HTTP/2 support.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加`random-wikipedia-article`的另一个依赖项，HTTP客户端库`httpx`。就像在[第4章](ch04.html#chapter_dependencies)中一样，你将激活`http2`的额外功能以支持HTTP/2。
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Poetry updates the *pyproject.toml* file accordingly:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Poetry相应地更新了*pyproject.toml*文件：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The project requires a recent Python version, so it doesn’t require the `importlib-metadata`
    backport. If you had to support Python versions before 3.8, here’s how you’d add
    the library for those versions:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目需要较新的Python版本，因此不需要`importlib-metadata`的后移版本。如果你需要支持Python 3.8之前的版本，可以按以下方式为这些版本添加库：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Besides `--python`, the `poetry add` command supports a `--platform` option
    to restrict dependencies to a specific operating system, such as Windows. This
    option accepts a platform identifier in the format used by the standard `sys.platform`
    attribute: `linux`, `darwin`, `win32`. For other environment markers, edit *pyproject.toml*
    and use the `markers` property in the TOML table for the dependency:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`--python`，`poetry add`命令还支持`--platform`选项，用于限制依赖关系到特定操作系统，比如Windows。这个选项接受一个平台标识符，格式与标准的`sys.platform`属性相同：`linux`、`darwin`、`win32`。对于其他环境标记，编辑*pyproject.toml*并在依赖关系的TOML表中使用`markers`属性：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The Lock File
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锁文件
- en: Poetry records the current version of each dependency in a file named *poetry.lock*,
    including SHA256 hashes for its packaging artifacts. If you take a peek inside
    the file, you’ll notice TOML stanzas for `rich` and `httpx`, as well as their
    direct and indirect dependencies. [Example 5-6](#example_poetry_lockfile_rich)
    shows a simplified version of Rich’s lock entry.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Poetry 在名为 *poetry.lock* 的文件中记录了每个依赖项的当前版本，包括它们的打包工件的 SHA256 哈希值。如果你打开文件看一眼，你会注意到
    `rich` 和 `httpx` 的 TOML 段落，以及它们的直接和间接依赖项。[示例 5-6](#example_poetry_lockfile_rich)
    展示了 Rich 的锁定条目的简化版本。
- en: Example 5-6\. The TOML stanza for Rich in *poetry.lock* (simplified)
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-6\. Rich 在 *poetry.lock* 中的 TOML 段落（简化版）
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Use the command `poetry show` to display the locked dependencies in the terminal.
    Here’s what the output looked like after I added Rich:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令 `poetry show` 在终端中显示锁定的依赖项。这是我添加 Rich 后的输出：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can also display the dependencies as a tree to visualize their relationship:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将依赖项显示为树形结构以可视化它们的关系：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you edit *pyproject.toml* yourself, remember to update the lock file to
    reflect your changes:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你手动编辑了 *pyproject.toml*，请记得更新锁定文件以反映你的更改：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Without the `--no-update` option, Poetry upgrades each locked dependency to
    the latest version covered by its constraint.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 没有 `--no-update` 选项，Poetry 将每个锁定的依赖项升级到其约束范围内的最新版本。
- en: 'You can check if the *poetry.lock* file is consistent with *pyproject.toml*:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以检查 *poetry.lock* 文件是否与 *pyproject.toml* 保持一致：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Resolving dependencies up front lets you deploy applications in a reliable and
    reproducible manner. It also gives developers in a team a common baseline and
    makes checks more deterministic—​avoiding surprises in continuous integration
    (CI). You should commit *poetry.lock* to source control to reap these benefits.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 提前解决依赖关系可以让你以可靠和可重复的方式部署应用程序。它还为团队中的开发人员提供了一个共同的基线，并使检查更加确定性——避免在持续集成（CI）中出现意外情况。你应该将
    *poetry.lock* 提交到源代码控制中以获得这些好处。
- en: Poetry’s lock file is designed to work across operating systems and Python interpreters.
    Having a single environment-independent, or “universal”, lock file is beneficial
    if your code must run in diverse environments, or if you’re an open source maintainer
    with contributors from all over the world.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Poetry 的锁定文件设计用于跨操作系统和 Python 解释器工作。如果你的代码必须在不同环境中运行，或者如果你是一个开源维护者，有来自世界各地的贡献者，拥有一个单一的环境无关或“通用”的锁定文件是有益的。
- en: By contrast, compiled requirements files quickly become unwieldy. If your project
    supports Windows, macOS, and Linux on the four most recent feature versions of
    Python, you’ll need to manage a dozen requirements files. Adding another processor
    architecture or Python implementation only makes things worse.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，编译的需求文件很快变得难以管理。如果你的项目支持 Python 的最近四个主要版本上的 Windows、macOS 和 Linux，你将需要管理十几个需求文件。添加另一个处理器架构或
    Python 实现只会让情况变得更糟。
- en: 'Universal lock files come at a price, however. Poetry re-resolves dependencies
    when it installs the packages into an environment. Its lock file is essentially
    a shrunken world view: it records every package the project might require in a
    given environment. By contrast, compiled requirements are an exact image of an
    environment. This makes them more amenable to auditing and more attractive for
    secure deployments.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通用的锁定文件却并非没有代价。Poetry 在安装包到环境中时会重新解决依赖关系。其锁定文件本质上是一种缩小的世界观：它记录了项目在特定环境中可能需要的每个包。相比之下，编译的需求文件是环境的精确镜像。这使得它们更易于审计，更适合安全部署。
- en: Updating Dependencies
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新依赖项
- en: 'You can update all dependencies in the lock file to their latest versions using
    a single command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用单个命令将锁定文件中的所有依赖项更新到它们的最新版本：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can also provide a specific direct or indirect dependency to update:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以提供一个特定的直接或间接依赖项来进行更新：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `poetry update` command doesn’t modify the project metadata in *pyproject.toml*.
    It only updates dependencies within the compatible version range. If you need
    to update the version range, use `poetry add` with the new constraint, including
    any extras and markers. Alternatively, edit *pyproject.toml* and refresh the lock
    file with `poetry lock --no-update`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`poetry update` 命令不会修改 *pyproject.toml* 中的项目元数据。它只会更新兼容版本范围内的依赖项。如果需要更新版本范围，请使用带有新约束的
    `poetry add`，包括任何额外的和标记。或者，编辑 *pyproject.toml* 并使用 `poetry lock --no-update` 刷新锁定文件。'
- en: 'If you no longer need a package for your project, remove it with `poetry remove`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不再需要一个包用于你的项目，使用 `poetry remove` 将其移除：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Managing Environments
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理环境
- en: Poetry’s `add`, `update`, and `remove` commands don’t just update dependencies
    in the *pyproject.toml* and *poetry.lock* files. They also synchronize the project
    environment with the lock file by installing, updating, or removing packages.
    Poetry creates the virtual environment for the project on demand.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Poetry 的 `add`、`update` 和 `remove` 命令不仅会更新 *pyproject.toml* 和 *poetry.lock*
    文件中的依赖关系。它们还通过安装、更新或删除软件包，将项目环境与锁定文件同步。Poetry 根据需要为项目创建虚拟环境。
- en: 'By default, Poetry stores the environments for all projects in a shared folder.
    Configure Poetry to keep the environment in a *.venv* directory inside the project
    instead:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Poetry 将所有项目的环境存储在共享文件夹中。配置 Poetry 将环境保存在项目内的 *.venv* 目录中：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This setting makes the environment discoverable for other tools in the ecosystem,
    such as `py` and `uv`. Having the directory in the project is convenient when
    you need to examine its contents. Although the setting restricts you to a single
    environment, this limitation is seldom a concern. Tools like Nox and tox are tailor-made
    for testing across multiple environments (see [Chapter 8](ch08.html#chapter_nox)).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此设置使得环境在生态系统中的其他工具（如 `py` 和 `uv`）中可发现，当您需要检查其内容时，在项目中具有该目录非常方便。尽管此设置将您限制为单个环境，但这种限制很少是一个问题。像
    Nox 和 tox 这样的工具专门用于跨多个环境进行测试（参见 [第 8 章](ch08.html#chapter_nox)）。
- en: 'You can check the location of the current environment using the command `poetry
    env info --path`. If you want to create a clean slate for your project, use the
    following commands to remove existing environments and create a new one using
    the specified Python version:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用命令 `poetry env info --path` 检查当前环境的位置。如果您想为项目创建一个干净的状态，请使用以下命令删除现有环境并使用指定的
    Python 版本创建新环境：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can re-run the second command to re-create the environment on a different
    interpreter. Instead of a version like `3.12`, you can also pass a command like
    `pypy3` for the PyPy interpreter or a full path like `/usr/bin/python3` for the
    system Python.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以重新运行第二条命令以在不同的解释器上重新创建环境。您不仅可以使用类似 `3.12` 的版本，还可以为 PyPy 解释器传递类似 `pypy3` 的命令，或者为系统
    Python 传递类似 `/usr/bin/python3` 的完整路径。
- en: 'Before you use the environment, you should install the project. Poetry performs
    editable installs, so the environment reflects any code changes immediately:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用环境之前，您应该安装项目。Poetry 执行可编辑安装，因此环境会立即反映任何代码更改：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Enter the project environment by launching a shell session with `poetry shell`.
    Poetry activates the virtual environment using the activation script for your
    current shell. With the environment activated, you can run the application from
    the shell prompt. Just exit the shell session when you’re done:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `poetry shell` 启动一个 shell 会话来进入项目环境。Poetry 使用当前 shell 的激活脚本激活虚拟环境。在环境激活后，您可以从
    shell 提示符中运行应用程序。完成后，只需退出 shell 会话：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can also run the application in your current shell session, using the command
    `poetry run`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在当前的 shell 会话中运行应用程序，使用命令 `poetry run`：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The command is also handy for starting an interactive Python session in the
    project environment:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令还适用于在项目环境中启动交互式 Python 会话：
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When you run a program with `poetry run`, Poetry activates the virtual environment
    without launching a shell. This works by adding the environment to the program’s
    `PATH` and `VIRTUAL_ENV` variables (see [“Activation scripts”](ch02.html#section_environments_activation)).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `poetry run` 运行程序时，Poetry 会激活虚拟环境，而不启动 shell。这通过将环境添加到程序的 `PATH` 和 `VIRTUAL_ENV`
    变量中实现（参见 [“激活脚本”](ch02.html#section_environments_activation)）。
- en: Tip
  id: totrans-165
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Just type `py` to get a Python session for your Poetry project on Linux and
    macOS. This requires the Python Launcher for Unix, and you must configure Poetry
    to use in-project environments.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在 Linux 和 macOS 上输入 `py`，即可为您的 Poetry 项目获取 Python 会话。这需要 Unix 上的 Python 启动器，并且您必须配置
    Poetry 以使用项目内的环境。
- en: Dependency Groups
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖组
- en: 'Poetry allows you to declare development dependencies, organized in dependency
    groups. Dependency groups aren’t part of the project metadata and are invisible
    to end users. Let’s add the dependency groups from [“Development Dependencies”](ch04.html#section_dependencies_development):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Poetry 允许您声明开发依赖项，这些依赖项组织在依赖组中。依赖组不是项目元数据的一部分，对最终用户不可见。让我们从 [“开发依赖项”](ch04.html#section_dependencies_development)
    中添加依赖组：
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Poetry adds the dependency groups under the `group` table in *pyproject.toml*:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Poetry 在 *pyproject.toml* 的 `group` 表下添加依赖组：
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Dependency groups are installed into the project environment by default. You
    can mark a group as optional using its `optional` key, like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，依赖组会安装到项目环境中。您可以使用其 `optional` 键将组标记为可选，例如：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Warning
  id: totrans-174
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Don’t specify the `--optional` flag when you add a dependency group with `poetry
    add`—it doesn’t mark the group as optional. The option designates optional dependencies
    that are behind an extra; it has no valid use in the context of dependency groups.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `poetry add` 添加依赖组时，请勿指定 `--optional` 标志，因为它不会将组标记为可选。该选项用于指定作为额外项的可选依赖项；在依赖组的上下文中，它没有有效用途。
- en: The `poetry install` command has several options that provide finer-grained
    control over which dependencies are installed into the project environment ([Table 5-3](#table_poetry_install_options)).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`poetry install` 命令有几个选项，可更精细地控制哪些依赖项安装到项目环境中（[表 5-3](#table_poetry_install_options)）。'
- en: Table 5-3\. Installing dependencies with `poetry install`
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-3\. 使用 `poetry install` 安装依赖项
- en: '| Option | Description |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `--with=*<group>*` | Include a dependency group in the installation. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `--with=*<group>*` | 将一个依赖组包含在安装中。 |'
- en: '| `--without=*<group>*` | Exclude a dependency group from the installation.
    |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `--without=*<group>*` | 从安装中排除一个依赖组。 |'
- en: '| `--only=*<group>*` | Exclude all other dependency groups from the installation.
    |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `--only=*<group>*` | 从安装中排除所有其他依赖组。 |'
- en: '| `--no-root` | Exclude the project itself from the installation. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `--no-root` | 从安装中排除项目本身。 |'
- en: '| `--only-root` | Exclude all dependencies from the installation. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `--only-root` | 从安装中排除所有依赖项。 |'
- en: '| `--sync` | Remove packages from the environment unless scheduled for installation.
    |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `--sync` | 从环境中删除除安装计划外的包。 |'
- en: You can specify a single group or multiple groups (separated by commas). The
    special group `main` refers to packages listed in the `tool.poetry.dependencies`
    table. Use the option `--only=main` to exclude all development dependencies from
    an installation. Similarly, the option `--without=main` lets you restrict an installation
    to development dependencies.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以指定单个组或多个组（用逗号分隔）。特殊组 `main` 指的是在 `tool.poetry.dependencies` 表中列出的包。使用选项 `--only=main`
    可以从安装中排除所有开发依赖项。类似地，选项 `--without=main` 可让您限制安装到开发依赖项。
- en: Package Repositories
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包仓库
- en: Poetry lets you upload your packages to the Python Package Index (PyPI) and
    other package repositories. It also lets you configure the repositories from which
    you add packages to your project. This section looks at both the publisher and
    the consumer sides of interacting with package repositories.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Poetry 允许您将包上传到 Python 包索引（PyPI）和其他包仓库。它还允许您配置从中添加包到项目的仓库。本节同时涵盖与包仓库的互动的发布者和使用者两方面。
- en: Note
  id: totrans-189
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re following along in this section, please don’t upload the example project
    to PyPI. Use the TestPyPI repository instead—​it’s a playground for testing, learning,
    and experimentation.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在本节中跟随进行，请不要将示例项目上传到 PyPI。请使用 TestPyPI 仓库，它是一个用于测试、学习和实验的游乐场。
- en: Publishing Packages to Package Repositories
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布包到包仓库
- en: 'Before you can upload packages to PyPI, you need an account and an API token
    to authenticate with the repository, as explained in [“Uploading Packages with
    Twine”](ch03.html#section_packages_twine). Next, add the API token to Poetry:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以上传包到 PyPI 之前，您需要一个帐户和 API 令牌来验证仓库，如 [“使用 Twine 上传包”](ch03.html#section_packages_twine)
    中所述。接下来，将 API 令牌添加到 Poetry：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can create packages for a Poetry project using standard tooling like `build`
    or with Poetry’s command-line interface:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用标准工具（如 `build`）或 Poetry 的命令行界面为 Poetry 项目创建包：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Like `build`, Poetry places the packages in the *dist* directory. You can publish
    the packages in *dist* using `poetry publish`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `build` 类似，Poetry 将包放置在 *dist* 目录中。您可以使用 `poetry publish` 发布 *dist* 中的包：
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can also collapse the two commands into one:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将这两个命令合并为一个：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let’s upload the example project to TestPyPI, a separate instance of the Python
    Package Index for testing distributions. If you want to upload packages to a repository
    other than PyPI, you need to add the repository to your Poetry configuration:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将示例项目上传到 TestPyPI，这是 Python 包索引的一个单独实例，用于测试发布。如果您想将包上传到 PyPI 之外的仓库，需要将该仓库添加到
    Poetry 配置中：
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'First, create an account and an API token on TestPyPI. Next, configure Poetry
    to use that token when uploading to TestPyPI:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在 TestPyPI 上创建一个帐户和 API 令牌。接下来，配置 Poetry 使用该令牌上传到 TestPyPI：
- en: '[PRE46]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You can now specify the repository when publishing your project. Feel free
    to try this out with your own version of the example project:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以在发布项目时指定存储库。请随意尝试将其应用于您自己版本的示例项目：
- en: '[PRE47]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Some package repositories use HTTP basic authentication with a username and
    password. You can configure the credentials for such a repository like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 某些包存储库使用带有用户名和密码的 HTTP 基本身份验证。您可以像这样配置此类存储库的凭据：
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The command prompts you for the password and stores it in the system keyring,
    if available, or in the *auth.toml* file on disk.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令提示您输入密码，并将其存储在系统密钥环中（如果可用），或者存储在磁盘上的 *auth.toml* 文件中。
- en: 'Alternatively, you can also configure a repository via environment variables
    (replace `*<REPO>*` with the repository name in uppercase, such as `PYPI`):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您还可以通过环境变量配置存储库（将 `*<REPO>*` 替换为大写的存储库名称，例如 `PYPI`）：
- en: '[PRE49]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Poetry also supports repositories that are secured by mutual TLS or use a custom
    certificate authority; see the [official documentation](https://python-poetry.org/docs/repositories/)
    for details.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 诗歌还支持通过相互 TLS 安全保护或使用自定义证书颁发机构的存储库；详细信息请参阅[官方文档](https://python-poetry.org/docs/repositories/)。
- en: Fetching Packages from Package Sources
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从包源获取包
- en: 'Above, you’ve seen how to upload your package to repositories other than PyPI.
    Poetry also supports alternate repositories on the consumer side: you can add
    packages to your project from sources other than PyPI. While upload targets are
    a user setting and stored in the Poetry configuration, package sources are a project
    setting, stored in *pyproject.toml*.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在上文中，您已经了解了如何将您的包上传到除 PyPI 外的存储库。Poetry 还支持消费端的备用存储库：您可以从非 PyPI 的来源向项目添加包。虽然上传目标是用户设置并存储在
    Poetry 配置中，但包源是项目设置，并存储在 *pyproject.toml* 中。
- en: 'Add a package source using the command `poetry source add`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令 `poetry source add` 添加包源：
- en: '[PRE50]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Poetry searches supplemental sources if the package wasn’t found on PyPI. If
    you want to disable PyPI, configure a primary source instead (the default priority):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要禁用 PyPI 并希望从主要来源配置，请在这里配置补充源（默认优先级）：
- en: '[PRE51]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You configure credentials for package sources just like you do for repositories:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像配置存储库一样为包源配置凭据：
- en: '[PRE52]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You can now add packages from the alternate source:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以从备用来源添加包：
- en: '[PRE53]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The following command lists the package sources for the project:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的命令列出了项目的包源：
- en: '[PRE54]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Warning
  id: totrans-224
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Specify the source when adding packages from supplemental sources. Otherwise,
    Poetry searches all sources when looking up a package. An attacker could upload
    a malicious package to PyPI with the same name as your internal package (*dependency
    confusion attack*).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加来自辅助来源的包时，请指定来源。否则，Poetry 在查找包时会搜索所有来源。攻击者可以向 PyPI 上传与您内部包相同名称的恶意包（*依赖混淆攻击*）。
- en: Extending Poetry with Plugins
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用插件扩展 Poetry
- en: 'Poetry comes with a plugin system that lets you extend its functionality. Use
    pipx to inject the plugin into Poetry’s environment:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Poetry 提供了一个插件系统，可以扩展其功能。使用 pipx 将插件注入到 Poetry 的环境中：
- en: '[PRE55]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Replace `*<plugin>*` with the name of the plugin on PyPI.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 用 `*<plugin>*` 替换 PyPI 上插件的名称。
- en: If the plugin affects the build stage of your project, add it to the build dependencies
    in *pyproject.toml*, as well. See [“The Dynamic Versioning Plugin”](#section_poetry_dynamic_versioning)
    for an example.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果插件影响项目的构建阶段，请在 *pyproject.toml* 中的构建依赖项中添加它。例如，请参阅[“动态版本插件”](#section_poetry_dynamic_versioning)。
- en: 'By default, pipx upgrades applications without the injected packages. Use the
    option `--include-injected` to also upgrade application plugins:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，pipx 在没有注入包的情况下升级应用程序。使用选项 `--include-injected` 也升级应用程序插件。
- en: '[PRE56]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you no longer need the plugin, remove it from the injected packages:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不再需要该插件，请从注入的包中移除它：
- en: '[PRE57]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If you’re no longer sure which plugins you have installed, list them like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定已安装了哪些插件，请像这样列出它们：
- en: '[PRE58]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In this section, I’ll introduce you to three useful plugins for Poetry:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将为您介绍 Poetry 的三个有用插件：
- en: '`poetry-plugin-export` allows you to generate requirements and constraints
    files'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`poetry-plugin-export` 允许您生成需求和约束文件'
- en: '`poetry-plugin-bundle` lets you deploy the project to a virtual environment'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`poetry-plugin-bundle` 允许您将项目部署到虚拟环境中'
- en: '`poetry-dynamic-versioning` populates the project version from the VCS'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`poetry-dynamic-versioning` 从版本控制系统中填充项目版本'
- en: Generating Requirements Files with the Export Plugin
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用导出插件生成需求文件
- en: Poetry’s lock file is great to ensure that everybody on your team, and every
    deployment environment, ends up with the same dependencies. But what do you do
    if you can’t use Poetry in some context? For example, you may need to deploy your
    project on a system that only has a Python interpreter and the bundled pip.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Poetry 的锁定文件非常适合确保您团队中的每个人和每个部署环境都使用相同的依赖关系。但是如果您在某些情况下无法使用 Poetry 该怎么办？例如，您可能需要在仅具有
    Python 解释器和捆绑的 pip 的系统上部署项目。
- en: As of this writing, there’s no lock file standard in the wider Python world;
    each packaging tool that supports lock files implements its own format.^([3](ch05.html#id287))
    None of these lock file formats has support in pip. But we do have requirements
    files.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前为止，在更广泛的 Python 世界中没有锁定文件标准；支持锁定文件的每个打包工具都实现了自己的格式。^([3](ch05.html#id287))
    这些锁定文件格式都不受 pip 支持。但是我们确实有要求文件。
- en: Requirements files let you pin packages to an exact version, require their artifacts
    to match cryptographic hashes, and use environment markers to restrict packages
    to specific Python versions and platforms. Wouldn’t it be nice if you could generate
    one from your *poetry.lock*, for interoperability with non-Poetry environments?
    This is precisely what the export plugin achieves.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要求文件允许您将软件包固定到确切的版本，要求其构件与加密哈希匹配，并使用环境标记将软件包限制在特定的 Python 版本和平台上。如果您可以从 *poetry.lock*
    生成一个要求文件以与非 Poetry 环境进行互操作，那会很好吗？这正是导出插件所实现的。
- en: 'Install the plugin with pipx:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pipx 安装插件：
- en: '[PRE59]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The plugin powers the `poetry export` command, which sports a `--format` option
    to specify the output format. By default, the command writes to the standard output
    stream; use the `--output` option to specify a destination file.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件为 `poetry export` 命令提供动力，该命令具有 `--format` 选项以指定输出格式。默认情况下，该命令写入标准输出流；使用 `--output`
    选项指定目标文件。
- en: '[PRE60]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Distribute the requirements file to the target system and use pip to install
    the dependencies (typically followed by installing a wheel of your project).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将要求文件分发到目标系统并使用 pip 安装依赖项（通常是安装您项目的 wheel 之后）。
- en: '[PRE61]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Exporting to requirements format is useful beyond deploying. Many tools work
    with requirements files as the de-facto industry standard. For example, you can
    scan a requirements file for dependencies with known security vulnerabilities
    using a tool like [safety](https://pyup.io/safety/).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 将导出为 requirements 格式对部署之外的用途也很有用。许多工具都使用 requirements 文件作为事实上的行业标准。例如，您可以使用像
    [safety](https://pyup.io/safety/) 这样的工具扫描具有已知安全漏洞的依赖关系的要求文件。
- en: Deploying Environments with the Bundle Plugin
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Bundle 插件部署环境
- en: 'In the previous section, you saw how to deploy your project on a system without
    Poetry. If you do have Poetry available, you might be wondering: can you just
    deploy with `poetry install`? You could, but Poetry performs an editable install
    of your project—​you’ll be running your application from the source tree. That
    may not be acceptable in a production environment. Editable installs also limit
    your ability to ship the virtual environment to another destination.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您看到了如何在没有 Poetry 的系统上部署项目。如果您确实有 Poetry 可用，您可能会想知道：是否可以只使用 `poetry install`
    部署？您可以，但是 Poetry 执行的是可编辑安装您的项目—​您将从源代码树运行应用程序。这在生产环境中可能不可接受。可编辑安装还限制了将虚拟环境发送到另一个目的地的能力。
- en: The bundle plugin allows you to deploy your project and locked dependencies
    to a virtual environment of your choosing. It creates the environment, installs
    the dependencies from the lock file, then builds and installs a wheel of your
    project.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Bundle 插件允许您将项目和已锁定的依赖项部署到您选择的虚拟环境中。它创建环境，从锁定文件安装依赖项，然后构建并安装您项目的 wheel。
- en: 'Install the plugin with pipx:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pipx 安装插件：
- en: '[PRE62]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: After installation, you’ll see a new `poetry bundle` subcommand. Let’s use that
    to bundle the project into a virtual environment in a directory named *app*. Use
    the `--python` option to specify the interpreter for the environment, and the
    option `--only=main` to exclude development dependencies.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，您将看到一个新的 `poetry bundle` 子命令。让我们使用它将项目捆绑到名为 *app* 的虚拟环境中。使用 `--python` 选项指定环境的解释器，并使用
    `--only=main` 选项排除开发依赖关系。
- en: '[PRE63]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Test the environment by running the entry-point script for the application.^([4](ch05.html#id288))
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行应用程序的入口点脚本来测试环境。^([4](ch05.html#id288))
- en: '[PRE64]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: You can use the bundle plugin to create a minimal Docker image for production.
    Docker supports *multi-stage builds*, where the first stage builds the application
    in a full-fledged build environment, and the second stage copies the build artifacts
    over into a minimal runtime environment. This allows you to ship slim images to
    production, speeding up deployments and reducing bloat and potential vulnerabilities
    in your production environments.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 bundle 插件为生产环境创建一个精简的 Docker 镜像。Docker 支持 *多阶段构建*，第一阶段在全功能的构建环境中构建应用程序，第二阶段将构建产物复制到精简的运行时环境中。这使您能够在生产环境中快速部署、减少冗余并降低潜在漏洞的风险。
- en: In [Example 5-7](#example_docker_poetry_bundle), the first stage installs Poetry
    and the bundle plugin, copies the Poetry project, and bundles it into a self-contained
    virtual environment. The second stage copies the virtual environment into a minimal
    Python image.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 5-7](#example_docker_poetry_bundle) 中，第一个阶段安装 Poetry 和 bundle 插件，复制 Poetry
    项目，并将其打包成一个自包含的虚拟环境。第二个阶段将虚拟环境复制到一个精简的 Python 镜像中。
- en: Example 5-7\. Multi-stage Dockerfile with Poetry
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-7\. 使用 Poetry 的多阶段 Dockerfile
- en: '[PRE65]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[![1](assets/1.png)](#co_managing_projects_with_poetry_CO2-1)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_managing_projects_with_poetry_CO2-1)'
- en: The first `FROM` directive introduces the build stage, where you build and install
    your project. The base image is a slim variant of the Debian stable release.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个 `FROM` 指令定义了部署到生产环境的镜像。基础镜像是 *distroless* Python 镜像，适用于 Debian 稳定版：提供 Python
    语言支持但不包括操作系统。
- en: '[![2](assets/2.png)](#co_managing_projects_with_poetry_CO2-2)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_managing_projects_with_poetry_CO2-2)'
- en: 'The second `FROM` directive defines the image that you deploy to production.
    The base image is a *distroless* Python image for Debian stable: Python language
    support minus the operating system.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `FROM` 指令定义了构建阶段的基础镜像，用于构建和安装项目。基础镜像是 Debian 稳定版的精简变体。
- en: '[![3](assets/3.png)](#co_managing_projects_with_poetry_CO2-3)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_managing_projects_with_poetry_CO2-3)'
- en: The `COPY` directive allows you to copy the virtual environment over from the
    build stage.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY` 指令允许您从构建阶段复制虚拟环境过来。'
- en: '[![4](assets/4.png)](#co_managing_projects_with_poetry_CO2-4)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_managing_projects_with_poetry_CO2-4)'
- en: The `ENTRYPOINT` directive lets you run the entry-point script when users invoke
    `docker run` with the image.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT` 指令允许您在用户使用该镜像运行 `docker run` 时运行入口点脚本。'
- en: 'If you have Docker installed, you can try this out. First, create a *Dockerfile*
    in your project with the contents from [Example 5-7](#example_docker_poetry_bundle).
    Next, build and run the Docker image:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已安装 Docker，则可以尝试此操作。首先，在项目中创建一个 *Dockerfile*，内容来自 [示例 5-7](#example_docker_poetry_bundle)。接下来，构建并运行
    Docker 镜像：
- en: '[PRE66]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You should see the output from `random-wikipedia-article` in your terminal.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在终端中看到 `random-wikipedia-article` 的输出。
- en: The Dynamic Versioning Plugin
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态版本插件
- en: The dynamic versioning plugin populates the version in the project metadata
    from a Git tag. Keeping the version in a single place reduces churn (see [“Single-sourcing
    the project version”](ch03.html#section_packages_single_sourcing_the_version)).
    The plugin is based on Dunamai, a Python library for deriving standards-compliant
    version strings from tags in your version control system.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 动态版本插件从 Git 标签中填充项目元数据中的版本信息。将版本信息集中管理可减少变更（参见 [“Single-sourcing the project
    version”](ch03.html#section_packages_single_sourcing_the_version)）。该插件基于 Dunamai，一个用于从版本控制系统标签中派生符合标准的版本字符串的
    Python 库。
- en: 'Install the plugin with pipx and enable it for your project:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pipx 安装插件并为您的项目启用它：
- en: '[PRE67]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The second step enables the plugin in the `tool` section of *pyproject.toml*:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步在 *pyproject.toml* 的 `tool` 部分启用插件：
- en: '[PRE68]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Remember that you have installed the Poetry plugin globally. The explicit opt-in
    ensures that you don’t accidentally start overwriting the version field in unrelated
    Poetry projects.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您已全局安装了 Poetry 插件。显式选择加入确保您不会意外地开始在不相关的 Poetry 项目中重写版本字段。
- en: 'Build frontends like pip and `build` need the plugin when they build your project.
    For this reason, enabling the plugin also adds it to the build dependencies in
    *pyproject.toml*. The plugin brings its own build backend, which wraps the one
    provided by Poetry:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 前端构建工具如 pip 和 `build` 在构建项目时需要该插件。因此，启用插件还将其添加到 *pyproject.toml* 中作为构建依赖项。该插件提供了自己的构建后端，用于包装
    Poetry 提供的构建系统：
- en: '[PRE69]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Poetry still requires the `version` field in its own section. Set the field
    to `"0.0.0"` to indicate that it’s unused.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Poetry 仍然要求在其自己的部分中有 `version` 字段。将该字段设置为 `"0.0.0"` 表示未使用该字段。
- en: '[PRE70]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'You can now add a Git tag to set your project version:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以添加一个 Git 标签来设置你的项目版本：
- en: '[PRE71]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The plugin also replaces `__version__` attributes in Python modules. This mostly
    works out of the box, but you need to declare *src* layout if you use it:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 插件还会替换 Python 模块中的 `__version__` 属性。这在大多数情况下都可以直接使用，但如果你使用它，你需要声明 *src* 布局：
- en: '[PRE72]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Let’s add a `--version` option to the application. Edit *__init__.py* in the
    package to add the following lines:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为应用程序添加一个 `--version` 选项。编辑包中的 *__init__.py* 文件，添加以下几行：
- en: '[PRE73]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Before proceeding, commit your changes, but without adding another Git tag.
    Let’s try the option in a fresh installation of the project:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请提交你的更改，但不要添加另一个 Git 标签。让我们在项目的新安装中尝试这个选项：
- en: '[PRE74]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: As you can see, the plugin rewrote the `__version__` attribute during the build.
    Since you didn’t tag the commit, Dunamai marked the version as a developmental
    post-release of `1.0.0` and appended the commit hash using a local version identifier.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，插件在构建过程中重写了 `__version__` 属性。由于你没有给提交打标签，Dunamai 将版本标记为 `1.0.0` 的开发后发布，并使用本地版本标识符附加提交哈希。
- en: Summary
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Poetry provides a unified workflow to manage packaging, dependencies and environments.
    Poetry projects are interoperable with standard tooling: you can build them with
    `build` and upload them to PyPI with Twine. But the Poetry command-line interface
    also provides convenient shorthands for these tasks and many more.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Poetry 提供了统一的工作流来管理打包、依赖和环境。Poetry 项目与标准工具兼容：你可以使用 `build` 构建它们，并使用 Twine 将它们上传到
    PyPI。但是 Poetry 命令行界面还提供了这些任务和更多任务的便捷缩写。
- en: Poetry records the precise working set of packages in its lock file, giving
    you deterministic deployments and checks, as well as a consistent experience when
    collaborating with others. Poetry can track development dependencies; it organizes
    them in dependency groups that you can install separately or together. You can
    extend Poetry with plugins—​for example, to deploy the project into a virtual
    environment or to derive the version number from Git.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Poetry 在其锁文件中记录了精确的软件包工作集，为你提供确定性的部署和检查，以及与他人合作时一致的体验。Poetry 可以跟踪开发依赖项；它将它们组织在你可以单独或一起安装的依赖组中。你可以使用插件扩展
    Poetry，例如将项目部署到虚拟环境或从 Git 派生版本号。
- en: If you need reproducible deployments for an application, if your team develops
    on multiple operating systems, or if you just feel that standard tooling adds
    too much overhead to your workflows, you should give Poetry a try.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要为一个应用程序进行可复制的部署，如果你的团队在多个操作系统上开发，或者如果你觉得标准的工具链给你的工作流增加了太多负担，那么你应该试试 Poetry。
- en: '^([1](ch05.html#id284-marker)) Sébastien Eustace: [“Support for PEP 621,”](https://github.com/python-poetry/roadmap/issues/3)
    November 6, 2020.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '^([1](ch05.html#id284-marker)) Sébastien Eustace: [“PEP 621 的支持”，](https://github.com/python-poetry/roadmap/issues/3)
    2020 年 11 月 6 日。'
- en: ^([2](ch05.html#id285-marker)) The command also keeps your lock file and project
    environment up-to-date. If you edit the constraint in *pyproject.toml*, you’ll
    need to do this yourself. Read on to learn more about lock files and environments.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch05.html#id285-marker)) 这个命令还会保持你的锁文件和项目环境保持更新。如果你编辑了 *pyproject.toml*
    中的约束条件，你需要自己做这些。继续阅读以了解有关锁文件和环境的更多信息。
- en: ^([3](ch05.html#id287-marker)) Apart from Poetry’s own *poetry.lock* and the
    closely related PDM lock file format, there’s pipenv’s *Pipfile.lock* and the
    `conda-lock` format for Conda environments.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch05.html#id287-marker)) 除了 Poetry 自己的 *poetry.lock* 和密切相关的 PDM 锁文件格式外，还有
    pipenv 的 *Pipfile.lock* 和 Conda 环境的 `conda-lock` 格式。
- en: ^([4](ch05.html#id288-marker)) Replace *bin* with *Scripts* if you’re on Windows.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch05.html#id288-marker)) 如果你在 Windows 上，将 *bin* 替换为 *Scripts*。
