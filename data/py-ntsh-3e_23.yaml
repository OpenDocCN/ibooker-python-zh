- en: 'Chapter 23\. Structured Text: XML'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第23章。结构化文本：XML
- en: XML, the *eXtensible Markup Language*, is a widely used data interchange format.
    On top of XML itself, the XML community (in good part within the World Wide Web
    Consortium, or W3C) has standardized many other technologies, such as schema languages,
    namespaces, XPath, XLink, XPointer, and XSLT.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: XML，即 *可扩展标记语言*，是广泛使用的数据交换格式。除了 XML 本身外，XML 社区（主要在万维网联盟（W3C）内）还标准化了许多其他技术，如模式语言、命名空间、XPath、XLink、XPointer
    和 XSLT。
- en: Industry consortia have additionally defined industry-specific markup languages
    on top of XML for data exchange among applications in their respective fields.
    XML, XML-based markup languages, and other XML-related technologies are often
    used for inter-application, cross-language, cross-platform data interchange in
    specific fields.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 行业联盟还定义了基于 XML 的行业特定标记语言，用于其各自领域应用程序之间的数据交换。XML、基于 XML 的标记语言和其他与 XML 相关的技术经常用于特定领域中的应用程序间、跨语言、跨平台的数据交换。
- en: Python’s standard library, for historical reasons, has multiple modules supporting
    XML under the xml package, with overlapping functionality; this book does not
    cover them all, but interested readers can find details in the [online documentation](https://oreil.ly/nHs5w).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 出于历史原因，Python 标准库在 xml 包下支持多个支持 XML 的模块，具有重叠的功能；本书并未覆盖所有内容，但感兴趣的读者可以在 [在线文档](https://oreil.ly/nHs5w)
    中找到详细信息。
- en: 'This book (and, specifically, this chapter) covers only the most Pythonic approach
    to XML processing: ElementTree, created by the [deeply missed Fredrik Lundh](https://oreil.ly/FjHRs),
    best known as “the effbot.”^([1](ch23.xhtml#ch01fn160)) Its elegance, speed, generality,
    multiple implementations, and Pythonic architecture make this the package of choice
    for Python XML applications. For tutorials and complete details on the xml.etree.ElementTree
    module beyond what this chapter provides, see the [online docs](https://oreil.ly/pPDh8).
    This book takes for granted some elementary knowledge of XML itself; if you need
    to learn more about XML, we recommend [*XML in a Nutshell*](http://shop.oreilly.com/product/9780596007645.do)
    by Elliotte Rusty Harold and W. Scott Means (O’Reilly).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本书（特别是本章）仅涵盖了处理 XML 的最 Pythonic 方法：ElementTree，由[我们深感怀念的 Fredrik Lundh](https://oreil.ly/FjHRs)，即“effbot”创建。它的优雅、速度、通用性、多种实现和Pythonic架构使其成为Python
    XML 应用程序的首选包。有关 xml.etree.ElementTree 模块的教程和完整详情，超出了本章提供的内容，请参阅[在线文档](https://oreil.ly/pPDh8)。本书默认读者具有一些关于
    XML 本身的基础知识；如果你需要了解更多关于 XML 的知识，我们推荐 [*XML in a Nutshell*](http://shop.oreilly.com/product/9780596007645.do)
    由 Elliotte Rusty Harold 和 W. Scott Means（O’Reilly）编写。
- en: Parsing XML from untrusted sources puts your application at risk of many possible
    attacks. We do not cover this issue specifically, but the [online documentation](https://oreil.ly/jiWUx)
    recommends third-party modules to help safeguard your application if you do have
    to parse XML from sources you can’t fully trust. In particular, if you need an
    ElementTree implementation with safeguards against parsing untrusted sources,
    consider [defusedxml.ElementTree](https://oreil.ly/dl21V).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从不受信任的源解析 XML 会使你的应用程序面临许多可能的攻击风险。我们并未专门讨论这个问题，但 [在线文档](https://oreil.ly/jiWUx)
    建议使用第三方模块来帮助保护你的应用程序，如果你确实需要从无法完全信任的源解析 XML。特别是，如果你需要具有针对解析不受信任源的安全防护的 ElementTree
    实现，请考虑使用 [defusedxml.ElementTree](https://oreil.ly/dl21V)。
- en: ElementTree
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ElementTree
- en: Python and third-party add-ons offer several alternative implementations of
    the ElementTree functionality; the one you can always rely on in the standard
    library is the module xml.etree.ElementTree. Just importing xml.etree.ElementTree
    gets you the fastest implementation available in your Python installation’s standard
    library. The third-party package defusedxml, mentioned in this chapter’s introduction,
    offers slightly slower but safer implementations if you ever need to parse XML
    from untrusted sources; another third-party package, [lxml](http://lxml.de), gets
    you faster performance, and some extra functionality, via [lxml.etree](http://lxml.de/api.xhtml).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python 和第三方插件提供了几种 ElementTree 功能的替代实现；你始终可以依赖的是标准库中的模块 xml.etree.ElementTree。只需导入
    xml.etree.ElementTree，即可获得你的 Python 安装中标准库中最快的实现。本章介绍的第三方包 defusedxml，提供了略慢但更安全的实现，如果你需要从不受信任的源解析
    XML；另一个第三方包 [lxml](http://lxml.de) 则提供了更快的性能和一些额外的功能，通过 [lxml.etree](http://lxml.de/api.xhtml)。
- en: 'Traditionally, you get whatever available implementation of ElementTree you
    prefer using a **from**...**import**...**as** statement such as this:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，您可以使用类似以下的 **from**...**import**...**as** 语句获取您喜欢使用的 ElementTree 实现：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or this, which tries to import lxml and, if unable, falls back to the version
    provided in the standard library:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 或者尝试导入 lxml，并在无法导入时退回到标准库中提供的版本：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once you succeed in importing an implementation, use it as et (some prefer the
    uppercase variant, ET) in the rest of your code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 成功导入实现后，将其作为 et 使用（有些人喜欢大写变体 ET）在您的代码的其余部分中使用它。
- en: 'ElementTree supplies one fundamental class representing a *node* within the
    *tree* that naturally maps an XML document: the class Element. ElementTree also
    supplies other important classes, chiefly the one representing the whole tree,
    with methods for input and output and many convenience classes equivalent to ones
    on its Element *root*—that’s the class ElementTree. In addition, the ElementTree
    module supplies several utility functions, and auxiliary classes of lesser importance.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ElementTree 提供了一个表示 XML 文档中节点的基本类：Element 类。ElementTree 还提供了其他重要的类，主要是代表整个树的类，具有输入和输出方法以及许多方便的类，等效于其
    Element *root* 上的类——即 ElementTree 类。此外，ElementTree 模块提供了几个实用函数和次要重要的辅助类。
- en: The Element Class
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Element 类
- en: The Element class represents a node in the tree that maps an XML document, and
    it’s the core of the whole ElementTree ecosystem. Each element is a bit like a
    mapping, with *attributes* that map string keys to string values, and also a bit
    like a sequence, with *children* that are other elements (sometimes referred to
    as the element’s “subelements”). In addition, each element offers a few extra
    attributes and methods. Each Element instance *e* has four data attributes or
    properties, detailed in [Table 23-1](#attributes_of_an_element_instance_e).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Element 类代表了 XML 文档中的一个节点，是整个 ElementTree 生态系统的核心。每个元素有点像映射，具有将字符串键映射到字符串值的*属性*，也有点像序列，具有其他元素（有时称为元素的“子元素”）的*子节点*。此外，每个元素还提供了一些额外的属性和方法。每个
    Element 实例 *e* 有四个数据属性或属性，详见 [Table 23-1](#attributes_of_an_element_instance_e)。
- en: Table 23-1\. Attributes of an Element instance e
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Table 23-1\. Element 实例 e 的属性
- en: '| attrib | A dict containing all of the XML node’s attributes, with strings,
    the attributes’ names, as its keys (and, usually, strings as corresponding values
    as well). For example, parsing the XML fragment <a x="y">b</a>c, you get an *e*
    whose *e*.attrib is {''x'': ''y''}.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '| attrib | 包含 XML 节点所有属性的字典，以字符串为键（通常相应的值也是字符串）。例如，解析 XML 片段 <a x="y">b</a>c，得到一个
    *e* 其中 *e*.attrib 是 {''x'': ''y''}。'
- en: Avoid Accessing attrib on Element Instances
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免访问 Element 实例上的 attrib
- en: It’s normally best to avoid accessing *e*.attrib when possible, because the
    implementation might need to build it on the fly when you access it. *e* itself
    offers some typical mapping methods (listed in [Table 23-2](#mapping_like_methods_of_an_element_inst))
    that you might otherwise want to call on *e*.attrib; going through *e*’s own methods
    allows an implementation to optimize things for you, compared to the performance
    you’d get via the actual dict *e*.attrib.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，最好避免访问 *e*.attrib，因为实现可能需要在访问时动态构建它。*e* 本身提供了一些典型的映射方法（列在 [Table 23-2](#mapping_like_methods_of_an_element_inst)
    中），您可能希望在 *e*.attrib 上调用这些方法；通过 *e* 自己的方法让实现可以为您优化性能，而不是通过实际的字典 *e*.attrib 获得的性能。
- en: '|'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| tag | The XML tag of the node: a string, sometimes also known as the element’s
    *type*. For example, parsing the XML fragment <a x="y">b</a>c, you get an *e*
    with *e*.tag set to ''a''. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| tag | 节点的 XML 标签：一个字符串，有时也称为元素的*类型*。例如，解析 XML 片段 <a x="y">b</a>c，得到一个 *e*
    其中 *e*.tag 设置为 ''a''。 |'
- en: '| tail | Arbitrary data (a string) immediately “following” the element. For
    example, parsing the XML fragment <a x="y">b</a>c, you get an *e* with *e*.tail
    set to ''c''. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| tail | 紧随元素之后的任意数据（字符串）。例如，解析 XML 片段 <a x="y">b</a>c，得到一个 *e* 其中 *e*.tail
    设置为 ''c''。 |'
- en: '| text | Arbitrary data (a string) directly “within” the element. For example,
    parsing the XML fragment <a x="y">b</a>c, you get an *e* with *e*.text set to
    ''b''. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| text | 直接“在”元素内的任意数据（字符串）。例如，解析 XML 片段 <a x="y">b</a>c，得到一个 *e* 其中 *e*.text
    设置为 ''b''。 |'
- en: '*e* has some methods that are mapping-like and avoid the need to explicitly
    ask for the *e*.attrib dict. These are listed in [Table 23-2](#mapping_like_methods_of_an_element_inst).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*e* 有一些类似映射的方法，避免了需要显式请求 *e*.attrib 字典。这些方法在 [Table 23-2](#mapping_like_methods_of_an_element_inst)
    中列出。'
- en: Table 23-2\. Mapping-like methods of an Element instance e
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 表 23-2\. Element 实例 *e* 的类似映射方法
- en: '| clear | *e*.clear() Leaves *e* “empty,” except for its tag, removing all
    attributes and children, and setting text and tail to **None**. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| clear | *e*.clear() “清空” *e*，除了其标签外，移除所有属性和子元素，并将文本和尾部设置为 **None**。'
- en: '| get | *e*.get(*key*, default=**None**) Like *e*.attrib.get(*key*, *default*),
    but potentially much faster. You cannot use *e*[*key*], since indexing on *e*
    is used to access children, not attributes. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| get | *e*.get(*key*, default=**None**) 类似于 *e*.attrib.get(*key*, *default*)，但可能更快。不能使用
    *e*[*key*]，因为在 *e* 上进行索引用于访问子元素，而不是属性。'
- en: '| items | *e*.items() Returns the list of (*name*, *value*) tuples for all
    attributes, in arbitrary order. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| items | *e*.items() 返回所有属性的 (*name*, *value*) 元组列表，顺序任意。'
- en: '| keys | *e*.keys() Returns the list of all attribute names, in arbitrary order.
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| keys | *e*.keys() 返回所有属性名的列表，顺序任意。'
- en: '| set | *e*.set(*key*, *value*) Sets the value of the attribute named *key*
    to *value*. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| set | *e*.set(*key*, *value*) 将名为 *key* 的属性设置为 *value*。'
- en: The other methods of *e* (including methods for indexing with the *e*[i] syntax
    and for getting the length, as in len(*e*)) deal with all of *e*’s children as
    a sequence, or in some cases—indicated in the rest of this section—with all descendants
    (elements in the subtree rooted at *e*, also known as subelements of *e*).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*e* 的其他方法（包括使用 *e*[i] 语法进行索引和获取长度的方法，如 len(*e*)）处理 *e* 的所有子元素作为一个序列，或者在某些情况下——如本节其余部分所示——处理
    *e* 的所有后代（以 *e* 为根的子树中的元素，也称为 *e* 的子元素）。'
- en: Don’t Rely on Implicit bool Conversion of an Element
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要依赖于 Element 的隐式布尔转换
- en: 'In all versions up through Python 3.11, an Element instance *e* evaluates as
    false if *e* has no children, following the normal rule for Python containers’
    implicit bool conversion. However, it is documented that this behavior may change
    in some future version of Python. For future compatibility, if you want to check
    whether *e* has no children, explicitly check **if** len(*e*) == 0: instead of
    using the normal Python idiom **if** **not** *e*:.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '在所有 Python 3.11 及之前的版本中，如果 Element 实例 *e* 没有子元素，*e* 的布尔值为假，这遵循了 Python 容器隐式布尔转换的常规规则。然而，文档记录表明，这种行为可能会在未来的某个版本中发生变化。为了未来的兼容性，如果你想检查
    *e* 是否没有子元素，请显式地检查 **if** len(*e*) == 0: 而不是使用通常的 Python 习惯用法 **if** **not** *e*:。'
- en: 'The named methods of *e* dealing with children or descendants are listed in
    [Table 23-3](#methods_of_an_element_instance_e_dealin) (we do not cover XPath
    in this book: see the [online docs](https://oreil.ly/6E174) for information on
    that topic). Many of the following methods take an optional argument namespaces,
    defaulting to **None**. When present, namespaces is a mapping with XML namespace
    prefixes as keys and corresponding XML namespace full names as values.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*e* 的命名方法处理子元素或后代的详细信息列在 [表 23-3](#methods_of_an_element_instance_e_dealin)
    中（本书不涵盖 XPath：有关该主题的信息，请参阅 [在线文档](https://oreil.ly/6E174)）。许多以下方法接受一个可选参数 namespaces，默认为
    **None**。当存在时，namespaces 是一个映射，XML 命名空间前缀作为键，相应的 XML 命名空间全名作为值。'
- en: Table 23-3\. Methods of an Element instance e dealing with children or descendants
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 表 23-3\. Element 实例 *e* 处理子元素或后代的方法
- en: '| append | *e*.append(*se*) Adds subelement *se* (which must be an Element)
    at the end of *e*’s children. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| append | *e*.append(*se*) 在 *e* 的子元素末尾添加子元素 *se*（*se* 必须是一个 Element）。'
- en: '| extend | *e*.extend(*ses*) Adds each item of iterable *ses* (every item must
    be an Element) at the end of *e*’s children. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| extend | *e*.extend(*ses*) 将可迭代对象 *ses* 中的每个元素（每个元素必须是一个 Element）添加到 *e*
    的子元素末尾。'
- en: '| find | *e*.find(*match*, namespaces=**None**) Returns the first descendant
    matching *match*, which may be a tag name or an XPath expression within the subset
    supported by the current implementation of ElementTree. Returns **None** if no
    descendant matches *match.* |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| find | *e*.find(*match*, namespaces=**None**) 返回第一个匹配 *match* 的后代元素，*match*
    可以是标签名或 XPath 表达式（在当前 ElementTree 实现支持的子集内）。如果没有后代元素匹配 *match*，则返回 **None**。'
- en: '| findall | *e*.findall(*match*, namespaces=**None**) Returns the list of all
    descendants matching *match*, which may be a tag name or an XPath expression within
    the subset supported by the current implementation of ElementTree. Returns []
    if no descendants match *match*. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| findall | *e*.findall(*match*, namespaces=**None**) 返回匹配 *match* 的所有后代元素列表，*match*
    可以是标签名或 XPath 表达式（在当前 ElementTree 实现支持的子集内）。如果没有后代元素匹配 *match*，则返回 []。'
- en: '| findtext | *e*.findtext(*match*, default=**None**, namespaces=**None**) Returns
    the text of the first descendant matching *match*, which may be a tag name or
    an XPath expression within the subset supported by the current implementation
    of ElementTree. The result may be an empty string, '''', if the first descendant
    matching *match* has no text. Returns default if no descendant matches *match*.
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| findtext | *e*.findtext(*match*, default=**None**, namespaces=**None**) 返回匹配
    *match* 的第一个后代的文本，*match* 可以是标签名或当前 ElementTree 实现支持的 XPath 表达式的子集。如果匹配的第一个后代没有文本，则结果可能是空字符串
    ''''。如果没有后代匹配 *match*，则返回 default。 |'
- en: '| insert | *e*.insert(*index*, *se*) Adds subelement *se* (which must be an
    Element) at index *index* within the sequence of *e*’s children. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| insert | *e*.insert(*index*, *se*) 在 *e* 的子元素序列中的索引 *index* 处添加子元素 *se*（*se*
    必须是 Element 类型）。'
- en: '| iter | *e*.iter(*tag*=''*'') Returns an iterator walking in depth-first order
    over all of *e*’s descendants. When *tag* is not ''*'', only yields subelements
    whose tag equals *tag.* Don’t modify the subtree rooted at *e* while you’re looping
    on *e*.iter. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| iter | *e*.iter(*tag*=''*'') 返回一个迭代器，按深度优先顺序遍历所有 *e* 的后代。当 *tag* 不为 ''*''
    时，仅产生标签等于 *tag* 的子元素。在循环 *e*.iter 时，请不要修改以 *e* 为根的子树。 |'
- en: '| iterfind | *e*.iterfind(*match*, namespaces=**None**) Returns an iterator
    over all descendants, in depth-first order, matching *match*, which may be a tag
    name or an XPath expression within the subset supported by the current implementation
    of ElementTree. The resulting iterator is empty when no descendants match *match*.
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| iterfind | *e*.iterfind(*match*, namespaces=**None**) 返回一个迭代器，按深度优先顺序遍历所有匹配
    *match* 的后代，*match* 可以是标签名或当前 ElementTree 实现支持的 XPath 表达式的子集。当没有后代匹配 *match* 时，结果迭代器为空。
    |'
- en: '| itertext | *e*.itertext(*match*, namespaces=**None**) Returns an iterator
    over the text (not the tail) attribute of all descendants, in depth-first order,
    matching *match*, which may be a tag name or an XPath expression within the subset
    supported by the current implementation of ElementTree. The resulting iterator
    is empty when no descendants match *match*. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| itertext | *e*.itertext(*match*, namespaces=**None**) 返回一个迭代器，按深度优先顺序遍历所有匹配
    *match* 的后代的文本（不包括尾部），*match* 可以是标签名或当前 ElementTree 实现支持的 XPath 表达式的子集。当没有后代匹配
    *match* 时，结果迭代器为空。 |'
- en: '| remove | *e*.remove(*se*) Removes the descendant that **is** element *se*
    (as covered in [Table 3-4](ch03.xhtml#operator_precedence_in_expressions)). |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| remove | *e*.remove(*se*) 删除元素 *se*（如在 [表 3-4](ch03.xhtml#operator_precedence_in_expressions)
    中所述）。 |'
- en: The ElementTree Class
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**ElementTree 类**'
- en: The ElementTree class represents a tree that maps an XML document. The core
    added value of an instance *et* of ElementTree is to have methods for wholesale
    parsing (input) and writing (output) of a whole tree. These methods are described
    in [Table 23-4](#elementtree_instance_parsing_and_writin).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ElementTree 类表示映射 XML 文档的树。ElementTree 实例 *et* 的核心附加值是具有用于整体解析（输入）和写入（输出）整个树的方法。这些方法在
    [表 23-4](#elementtree_instance_parsing_and_writin) 中描述。
- en: Table 23-4\. ElementTree instance parsing and writing methods
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 表 23-4\. ElementTree 实例解析和写入方法
- en: '| parse | *et*.parse(*source*, parser=**None**) *source* can be a file open
    for reading, or the name of a file to open and read (to parse a string, wrap it
    in io.StringIO, covered in [“In-Memory Files: io.StringIO and io.BytesIO”](ch11.xhtml#in_memory_files_iodotstringio_and_iodot)),
    containing XML text. *et*.parse parses that text, builds its tree of Elements
    as the new content of *et* (discarding the previous content of *et*, if any),
    and returns the root element of the tree. parser is an optional parser instance;
    by default, *et*.parse uses an instance of class XMLParser supplied by the ElementTree
    module (this book does not cover XMLParser; see the [online docs](https://oreil.ly/TXwf5)).
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| parse | *et*.parse(*source*, parser=**None**) *source* 可以是打开以供读取的文件，或要打开并读取的文件名（要解析字符串，请将其包装在
    io.StringIO 中，如 [“内存文件：io.StringIO 和 io.BytesIO”](ch11.xhtml#in_memory_files_iodotstringio_and_iodot)
    中所述），其中包含 XML 文本。*et*.parse 解析该文本，构建其元素树作为 *et* 的新内容（丢弃 *et* 的先前内容（如果有）），并返回树的根元素。parser
    是一个可选的解析器实例；默认情况下，*et*.parse 使用由 ElementTree 模块提供的 XMLParser 类的实例（本书不涵盖 XMLParser；请参阅
    [在线文档](https://oreil.ly/TXwf5)）。 |'
- en: '| write | *et*.write(*file*, encoding=''us-ascii'', xml_declaration=**None**,
    default_namespace=**None**, method=''xml'', short_empty_elements=True) *file*
    can be a file open for writing, or the name of a file to open and write (to write
    into a string, pass as *file* an instance of io.StringIO, covered in [“In-Memory
    Files: io.StringIO and io.BytesIO”](ch11.xhtml#in_memory_files_iodotstringio_and_iodot)).
    *et*.write writes into that file the text representing the XML document for the
    tree that is the content of *et*. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| write | *et*.write(*file*, encoding=''us-ascii'', xml_declaration=**None**,
    default_namespace=**None**, method=''xml'', short_empty_elements=True) *file*
    可以是已打开并用于写入的文件，或要打开并写入的文件名称（要写入字符串，请将 *file* 作为 io.StringIO 的实例传递，详见 [“内存文件：io.StringIO
    和 io.BytesIO”](ch11.xhtml#in_memory_files_iodotstringio_and_iodot)）。*et*.write
    将文本写入该文件，表示树的 XML 文档内容，该树是 *et* 的内容。 |'
- en: '| write *(cont.)* | *encoding* should be spelled according to the [standard](https://oreil.ly/Vlj0C),
    not by using common “nicknames”—for example, ''iso-8859-1'', not ''latin-1'',
    even though Python itself accepts both spellings for this encoding, and similarly
    ''utf-8'', with the dash, not ''utf8'', without it. The best choice often is to
    pass encoding as ''unicode''. This outputs text (Unicode) strings, when *file*.write
    accepts such strings; otherwise, *file*.write must accept bytestrings, and that
    will be the type of strings that *et*.write outputs, using XML character references
    for characters not in the encoding—for example, with the default US-ASCII encoding,
    “e with an acute accent,” é, is output as &#233;. You can pass xml_declaration
    as **False** to not have the declaration in the resulting text, or as **True**
    to have it; the default is to have the declaration in the result only when encoding
    is not one of ''us-ascii'', ''utf-8'', or ''unicode''.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '| write *(续)* | *encoding* 应该按照 [标准](https://oreil.ly/Vlj0C) 拼写，而不是使用常见的“昵称”
    — 例如，''iso-8859-1''，而不是 ''latin-1''，尽管 Python 本身接受这两种编码拼写方式，并且类似地，''utf-8'' 带有破折号，而不是
    ''utf8'' 没有破折号。通常最好选择将 encoding 传递为 ''unicode''。当 *file*.write 接受这样的字符串时，这会输出文本（Unicode）字符串；否则，*file*.write
    必须接受字节串，而 *et*.write 输出的字符串类型将是这种类型，对于不在编码中的字符，将使用 XML 字符引用输出 — 例如，默认的 US-ASCII
    编码，“带重音符的 e”，é，将输出为 &#233;。您可以将 xml_declaration 传递为 **False** 以避免在生成的文本中包含声明，或者传递为
    **True** 以包含声明；默认情况下，仅在编码不是 ''us-ascii''、''utf-8'' 或 ''unicode'' 之一时才包含声明。'
- en: You can optionally pass default_namespace to set the default namespace for xmlns
    constructs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择性地传递 default_namespace 来设置 xmlns 结构的默认命名空间。
- en: You can pass method as 'text' to output only the text and tail of each node
    (no tags). You can pass method as 'html' to output the document in HTML format
    (which, for example, omits end tags not needed in HTML, such as </br>). The default
    is 'xml', to output in XML format.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将 method 传递为 'text' 以仅输出每个节点的文本和尾部（无标记）。您可以将 method 传递为 'html' 以 HTML 格式输出文档（例如，在
    HTML 中不需要的结束标记，如 </br> 将被省略）。默认为 'xml'，以 XML 格式输出。
- en: You can optionally (only by name, not positionally) pass short_empty_elements
    as **False** to always use explicit start and end tags, even for elements that
    have no text or subelements; the default is to use the XML short form for such
    empty elements. For example, an empty element with tag a is output as <a/> by
    default, or as <a></a> if you pass short_empty_elements as **False**. |
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过名称（而不是位置）选择性地将 short_empty_elements 传递为 **False**，以始终使用显式的开始和结束标记，即使对于没有文本或子元素的元素也是如此；默认情况下，对于这种空元素使用
    XML 简短形式。例如，默认情况下，具有标签 a 的空元素将输出为 <a/>，如果将 short_empty_elements 传递为 **False**，则将输出为
    <a></a>。 |
- en: In addition, an instance *et* of ElementTree supplies the method getroot (to
    return the root of the tree) and the convenience methods find, findall, findtext,
    iter, and iterfind, each exactly equivalent to calling the same method on the
    root of the tree—that is, on the result of *et*.getroot.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，ElementTree 的一个实例 *et* 提供了方法 getroot（返回树的根）和便利方法 find、findall、findtext、iter
    和 iterfind，每个方法与在树的根上调用相同的方法完全等效，也就是说，在 *et*.getroot 的结果上调用。
- en: Functions in the ElementTree Module
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ElementTree 模块中的函数
- en: The ElementTree module also supplies several functions, described in [Table 23-5](#elementtree_functions).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ElementTree 模块还提供了几个函数，详见 [表 23-5](#elementtree_functions)。
- en: Table 23-5\. ElementTree functions
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 表 23-5\. ElementTree 函数
- en: '| Comment | Comment(text=**None**) Returns an Element that, once inserted as
    a node in an ElementTree, will be output as an XML comment with the given text
    string enclosed between ''<!--'' and ''-->''. XMLParser skips XML comments in
    any document it parses, so this function is the only way to insert comment nodes.
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| Comment | Comment(text=**None**) 返回一个元素，在插入 ElementTree 作为节点后，将作为 XML 注释输出，注释文本字符串被封闭在''<!--''和''-->''之间。XMLParser
    跳过任何文档中的 XML 注释，因此这个函数是插入注释节点的唯一方法。'
- en: '| dump | dump(*e*) Writes e, which can be an Element or an ElementTree, as
    XML to sys.stdout. This function is meant only for debugging purposes. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| dump | dump(*e*) 将 e（可以是 Element 或 ElementTree）以 XML 形式写入 sys.stdout。此函数仅用于调试目的。'
- en: '| fromstring | fromstring(*text*, parser=**None**) Parses XML from the *text*
    string and returns an Element, just like the XML function just covered. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| fromstring | fromstring(*text*, parser=**None**) 从 *text* 字符串解析 XML 并返回一个
    Element，就像刚刚介绍的 XML 函数一样。'
- en: '| fromstringlist | fromstringlist(*sequence*, parser=**None**) Just like fromstring(''''.join(*sequence*)),
    but can be a bit faster by avoiding the join. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| fromstringlist | fromstringlist(*sequence*, parser=**None**) 就像 fromstring(''''.join(*sequence*))，但通过避免连接，可能会更快一些。'
- en: '| iselement | iselement(*e*) Returns **True** if *e* is an Element; otherwise,
    returns **False**. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| iselement | iselement(*e*) 如果 *e* 是一个 Element，则返回 **True**；否则返回 **False**。'
- en: '| iterparse | iterparse(*source*, events=[''end''], parser=**None**) Parses
    an XML document and incrementally builds the corresponding ElementTree. *source*
    can be a file open for reading, or the name of a file to open and read, containing
    an XML document as text. iterparse returns an iterator yielding two-item tuples
    (*event*, *element*), where *event* is one of the strings listed in the argument
    events (each string must be ''start'', ''end'', ''start-ns'', or ''end-ns''),
    as the parsing progresses. *element* is an Element for events ''start'' and ''end'',
    **None** for event ''end-ns'', and a tuple of two strings (*namespace_prefix*,
    *namespace_uri*) for event ''start-ns''. parser is an optional parser instance;
    by default, iterparse uses an instance of the class XMLParser supplied by the
    ElementTree module (see the [online docs](https://oreil.ly/wG429) for details
    on the XMLParser class).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '| iterparse | iterparse(*source*, events=[''end''], parser=**None**) 解析 XML
    文档并逐步构建相应的 ElementTree。*source* 可以是打开进行读取的文件，或要打开并读取的文件名，包含 XML 文档作为文本。iterparse
    返回一个迭代器，产生两项元组 (*event*, *element*)，其中 *event* 是参数 events 中列出的字符串之一（每个字符串必须是 ''start''、''end''、''start-ns''
    或 ''end-ns''），随着解析的进行而变化。*element* 是 ''start'' 和 ''end'' 事件的 Element，''end-ns''
    事件的 **None**，以及 ''start-ns'' 事件的两个字符串元组（*namespace_prefix*, *namespace_uri*）。parser
    是一个可选的解析器实例；默认情况下，iterparse 使用 ElementTree 模块提供的 XMLParser 类的实例（有关 XMLParser 类的详细信息，请参阅[在线文档](https://oreil.ly/wG429)）。'
- en: The purpose of iterparse is to let you iteratively parse a large XML document,
    without holding all of the resulting ElementTree in memory at once, whenever feasible.
    We cover iterparse in more detail in [“Parsing XML Iteratively”](#parsing_xml_iteratively).
    |
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: iterparse 的目的是在可行的情况下，允许你逐步解析一个大型 XML 文档，而不必一次性将所有生成的 ElementTree 存储在内存中。我们在[“逐步解析
    XML”](#parsing_xml_iteratively)中详细讨论了 iterparse。
- en: '| parse | parse(*source*, parser=**None**) Just like the parse method of ElementTree,
    covered in [Table 23-4](#elementtree_instance_parsing_and_writin), except that
    it returns the ElementTree instance it creates. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| parse | parse(*source*, parser=**None**) 就像 ElementTree 的 parse 方法，在[表 23-4](#elementtree_instance_parsing_and_writin)中介绍的一样，但它返回它创建的
    ElementTree 实例。'
- en: '| P⁠r⁠o⁠c⁠e⁠s⁠s⁠i⁠n⁠g​I⁠n⁠s⁠t⁠r⁠u⁠c⁠t⁠i⁠o⁠n | ProcessingInstruction(*target*,
    text=**None**) Returns an Element that, once inserted as a node in an ElementTree,
    will be output as an XML processing instruction with the given *target* and text
    strings enclosed between ''<?'' and ''?>''. XMLParser skips XML processing instructions
    in any document it parses, so this function is the only way to insert processing
    instruction nodes. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| P⁠r⁠o⁠c⁠e⁠s⁠s⁠i⁠n⁠g​I⁠n⁠s⁠t⁠r⁠u⁠c⁠t⁠i⁠o⁠n | ProcessingInstruction(*target*,
    text=**None**) 返回一个元素，在插入 ElementTree 作为节点后，将作为 XML 处理指令输出，目标和文本字符串被封闭在''<?''和''?>''之间。XMLParser
    跳过任何文档中的 XML 处理指令，因此这个函数是插入处理指令节点的唯一方法。'
- en: '| r⁠e⁠g⁠i⁠s⁠t⁠e⁠r⁠_​n⁠a⁠m⁠e⁠s⁠p⁠a⁠c⁠e | register_namespace(*prefix*, *uri*)
    Registers the string *prefix* as the namespace prefix for the string *uri*; elements
    in the namespace get serialized with this prefix. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| r⁠e⁠g⁠i⁠s⁠t⁠e⁠r⁠_​n⁠a⁠m⁠e⁠s⁠p⁠a⁠c⁠e | register_namespace(*prefix*, *uri*)
    将字符串 *prefix* 注册为字符串 *uri* 的命名空间前缀；命名空间中的元素将使用此前缀进行序列化。'
- en: '| SubElement | SubElement(*parent*, *tag*, attrib={}, ***extra*) Creates an
    Element with the given *tag*, attributes from dict attrib, and others passed as
    named arguments in *extra*, and appends it as the rightmost child of Element *parent*;
    returns the Element it has created. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| SubElement | SubElement(*parent*, *tag*, attrib={}, ***extra*) 创建一个带有给定*tag*和来自字典attrib的属性以及作为额外命名参数传递的其他内容的Element，并将其作为Element
    *parent*的最右边子节点添加；返回它创建的Element。 |'
- en: '| tostring | tostring(*e*, encoding=''us-ascii, method=''xml'', short_empty_elements=**True**)
    Returns a string with the XML representation of the subtree rooted at Element
    *e*. Arguments have the same meaning as for the write method of ElementTree, covered
    in [Table 23-4](#elementtree_instance_parsing_and_writin). |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| tostring | tostring(*e*, encoding=''us-ascii'', method=''xml'', short_empty_elements=**True**)
    返回一个字符串，其中包含以Element *e*为根的子树的XML表示。参数的含义与ElementTree的write方法相同，见[表23-4](#elementtree_instance_parsing_and_writin)。
    |'
- en: '| tostringlist | tostringlist(*e,* encoding=''us-ascii'', method=''xml'', short_empty_elements=**True**)
    Returns a list of strings with the XML representation of the subtree rooted at
    Element *e*. Arguments have the same meaning as for the write method of ElementTree,
    covered in [Table 23-4](#elementtree_instance_parsing_and_writin). |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| tostringlist | tostringlist(*e*, encoding=''us-ascii'', method=''xml'', short_empty_elements=**True**)
    返回一个字符串列表，其中包含以Element *e*为根的子树的XML表示。参数的含义与ElementTree的write方法相同，见[表23-4](#elementtree_instance_parsing_and_writin)。
    |'
- en: '| XML | XML(*text*, parser=**None**) Parses XML from the *text* string and
    returns an Element. parser is an optional parser instance; by default, XML uses
    an instance of the class XMLParser supplied by the ElementTree module (this book
    does not cover the XMLParser class; see the [online docs](https://oreil.ly/wG429)
    for details). |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| XML | XML(*text*, parser=**None**) 从文本字符串*text*解析XML并返回一个Element。parser是可选的解析器实例；默认情况下，XML使用由ElementTree模块提供的XMLParser类的实例（本书不涵盖XMLParser类；详见[在线文档](https://oreil.ly/wG429)）。
    |'
- en: '| XMLID | XMLID(*text*, parser=**None**) Parses XML from the *text* string
    and returns a tuple with two items: an Element and a dict mapping id attributes
    to the only Element having each (XML forbids duplicate ids). parser is an optional
    parser instance; by default, XMLID uses an instance of the class XMLParser supplied
    by the ElementTree module (this book does not cover the XMLParser class; see the
    [online docs](https://oreil.ly/wG429) for details). |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| XMLID | XMLID(*text*, parser=**None**) 从文本字符串*text*解析XML并返回一个包含两个条目的元组：一个Element和一个将id属性映射到每个唯一Element的字典（XML禁止重复id）。parser是可选的解析器实例；默认情况下，XMLID使用由ElementTree模块提供的XMLParser类的实例（本书不涵盖XMLParser类；详见[在线文档](https://oreil.ly/wG429)）。
    |'
- en: The ElementTree module also supplies the classes QName, TreeBuilder, and XMLParser,
    which we do not cover in this book, and the class XMLPullParser, covered in [“Parsing
    XML Iteratively”](#parsing_xml_iteratively).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ElementTree模块还提供了QName、TreeBuilder和XMLParser类，这些我们在本书中不涵盖，以及XMLPullParser类，见[“迭代解析XML”](#parsing_xml_iteratively)。
- en: Parsing XML with ElementTree.parse
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ElementTree.parse解析XML
- en: In everyday use, the most common way to make an ElementTree instance is by parsing
    it from a file or file-like object, usually with the module function parse or
    with the method parse of instances of the class ElementTree.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常使用中，创建ElementTree实例最常见的方法是从文件或类似文件的对象中解析它，通常使用模块函数parse或ElementTree类实例的方法parse。
- en: 'For the examples in the remainder of this chapter, we use the simple XML file
    found at [*http://www.w3schools.com/xml/simple.xml*](http://www.w3schools.com/xml/simple.xml);
    its root tag is ''breakfast_menu'', and the root’s children are elements with
    the tag ''food''. Each ''food'' element has a child with the tag ''name'', whose
    text is the food’s name, and a child with the tag ''calories'', whose text is
    the string representation of the integer number of calories in a portion of that
    food. In other words, a simplified representation of that XML file’s content of
    interest to the examples is:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章剩余的示例中，我们使用在[*http://www.w3schools.com/xml/simple.xml*](http://www.w3schools.com/xml/simple.xml)找到的简单XML文件；它的根标记是'breakfast_menu'，根的子节点是标记为'food'的元素。每个'food'元素都有一个标记为'name'的子元素，其文本是食物的名称，以及一个标记为'calories'的子元素，其文本是该食物一份中的卡路里数的整数表示。换句话说，对于示例感兴趣的XML文件内容的简化表示如下：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Since the XML document lives at a WWW URL, you start by obtaining a file-like
    object with that content, and passing it to parse; the simplest way uses the urllib.request
    module:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因为XML文档位于WWW URL上，所以首先获取一个具有该内容的类似文件的对象，并将其传递给parse；最简单的方法使用urllib.request模块：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Selecting Elements from an ElementTree
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从ElementTree中选择元素
- en: 'Let’s say that we want to print on standard output the calories and names of
    the various foods, in order of increasing calories, with ties broken alphabetically.
    Here’s the code for this task:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要在标准输出上打印出各种食物的卡路里和名称，按升序卡路里排序，按字母顺序打破平局。以下是此任务的代码：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When run, this prints:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '当运行时，这将打印： '
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Editing an ElementTree
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑 ElementTree
- en: 'Once an ElementTree is built (be that via parsing, or otherwise), you can “edit”
    it—inserting, deleting, and/or altering nodes (elements)—via various methods of
    the ElementTree and Element classes, and module functions. For example, suppose
    our program is reliably informed that a new food has been added to the menu—buttered
    toast, two slices of white bread toasted and buttered, 180 calories—while any
    food whose name contains “berry,” case insensitive, has been removed. The “editing
    the tree” part for these specs can be coded as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 构建好一个 ElementTree（无论是通过解析还是其他方式），你可以通过 ElementTree 和 Element 类的各种方法以及模块函数来“编辑”它——插入、删除和/或修改节点（元素）。例如，假设我们的程序可靠地通知我们菜单上添加了一种新食物——涂了黄油的烤面包，两片白面包烤过涂了黄油，含有“berry”字样的食物已被删除（不区分大小写）。针对这些规格的“编辑树”部分可以编码如下：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once we insert these “editing” steps between the code parsing the tree and
    the code selectively printing from it, the latter prints:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在解析树的代码和从中选择性打印的代码之间插入这些“编辑”步骤，后者将打印：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The ease of editing an ElementTree can sometimes be a crucial consideration,
    making it worth your while to keep it all in memory.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，编辑 ElementTree 的便捷性可能是一个关键考虑因素，值得你将其全部保留在内存中。
- en: Building an ElementTree from Scratch
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从头开始构建 ElementTree
- en: 'Sometimes, your task doesn’t start from an existing XML document: rather, you
    need to make an XML document from data your code gets from a different source,
    such as a CSV file or some kind of database.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你的任务并不是从现有 XML 文档开始：相反，你需要根据代码从不同来源（如 CSV 文件或某种类型的数据库）获得的数据制作一个 XML 文档。
- en: The code for such tasks is similar to the code we showed for editing an existing
    ElementTree—just add a little snippet to build an initially empty tree.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这类任务的代码类似于我们展示的用于编辑现有 ElementTree 的代码——只需添加一个小片段来构建一个最初为空的树。
- en: 'For example, suppose you have a CSV file, *menu.csv*, whose two comma-separated
    columns are the calories and names of various foods, one food per row. Your task
    is to build an XML file, *menu.xml*, similar to the one we parsed in the previous
    examples. Here’s one way you could do that:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个 CSV 文件，*menu.csv*，其中两列逗号分隔的是各种食物的卡路里和名称，每行一种食物。你的任务是构建一个 XML 文件，*menu.xml*，与我们在之前示例中解析过的类似。下面是你可以这样做的一种方式：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Parsing XML Iteratively
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逐步解析 XML
- en: For tasks focused on selecting elements from an existing XML document, sometimes
    you don’t need to build the whole ElementTree in memory—a consideration that’s
    particularly important if the XML document is very large (not the case for the
    tiny example document we’ve been dealing with, but stretch your imagination and
    visualize a similar menu-focused document that lists millions of different foods).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 针对从现有 XML 文档中选择元素的任务，有时你不需要将整个 ElementTree 构建在内存中——这一点特别重要，如果 XML 文档非常大时（对于我们处理的微小示例文档不适用，但可以想象类似的以菜单为中心的文档，列出了数百万种不同的食物）。
- en: Suppose we have such a large document, and we want to print on standard output
    the calories and names of the 10 lowest-calorie foods, in order of increasing
    calories, with ties broken alphabetically. Our *menu.xml* file, which for simplicity’s
    sake we’ll assume is now a local file, lists millions of foods, so we’d rather
    not keep it all in memory (obviously, we don’t need complete access to all of
    it at once).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有这样一个大型文档，并且我们想要在标准输出上打印出卡路里最低的 10 种食物的卡路里和名称，按升序卡路里排序，按字母顺序打破平局。我们的 *menu.xml*
    文件现在是一个本地文件，假设它列出了数百万种食物，因此我们宁愿不将其全部保存在内存中（显然，我们不需要一次性完全访问所有内容）。
- en: 'The following code represents a naive attempt to parse without building the
    whole structure in memory:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码代表了一种无需在内存中构建整个结构的简单尝试来解析：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This approach does indeed work, but unfortunately it consumes just about as
    much memory as an approach based on a full et.parse would! This is because iterparse
    builds up a whole ElementTree in memory, even though it only communicates back
    events such as (and by default only) 'end', meaning “I just finished parsing this
    element.”
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法确实有效，但不幸的是，它消耗的内存几乎与基于完整 et.parse 的方法相同！这是因为 iterparse 在内存中逐步构建了整个 ElementTree，尽管它仅仅回传事件，如（默认情况下仅）'end'，意味着“我刚刚完成了对这个元素的解析”。
- en: To actually save memory, we can at least toss all the contents of each element
    as soon as we’re done processing it—that is, right after the **yield**, we can
    add elem.clear() to make the just-processed element empty.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正节省内存，我们至少可以在处理完元素后立即丢弃每个元素的所有内容——也就是说，在 **yield** 后，我们可以添加 elem.clear() 使刚处理过的元素为空。
- en: 'This approach would indeed save some memory—but not all of it, because the
    tree’s root would still end up with a huge list of empty child nodes. To be really
    frugal in memory consumption, we need to get ''start'' events as well, so we can
    get hold of the root of the ElementTree being built and remove each element from
    it as it’s used, rather than just clearing the element. That is, we want to change
    the generator into:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法确实可以节省一些内存，但并非全部，因为树的根仍然会有一个巨大的空子节点列表。要真正节省内存，我们需要获取'开始'事件，以便获取正在构建的 ElementTree
    的根，并在使用每个元素后从中移除每个元素，而不仅仅是清除元素。也就是说，我们希望将生成器改为：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This approach saves as much memory as feasible, and still gets the task done!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法尽可能地节省内存，同时完成任务！
- en: Parsing XML Within an Asynchronous Loop
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在异步循环中解析 XML
- en: 'While iterparse, used correctly, can save memory, it’s still not good enough
    to use within an asynchronous loop. That’s because iterparse makes blocking read
    calls to the file object passed as its first argument: such blocking calls are
    a no-no in async processing.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 iterparse 在正确使用时可以节省内存，但仍不足以在异步循环中使用。这是因为 iterparse 对传递给它的文件对象进行阻塞读取调用：在异步处理中这种阻塞调用是不可取的。
- en: ElementTree offers the class XMLPullParser to help with this issue; see the
    [online docs](https://oreil.ly/WxMoH) for the class’s usage pattern.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ElementTree 提供了 XMLPullParser 类来解决这个问题；请参阅[在线文档](https://oreil.ly/WxMoH)了解该类的使用模式。
- en: ^([1](ch23.xhtml#ch01fn160-marker)) Alex is far too modest to mention it, but
    from around 1995 to 2005 both he and Fredrik were, along with Tim Peters, *the*
    Python bots. Known as such for their encyclopedic and detailed knowledge of the
    language, the effbot, the martellibot, and the timbot have created software and
    documentation that are of immense value to millions of people.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch23.xhtml#ch01fn160-marker)) Alex太谦虚了，不过从1995年到2005年，他和Fredrik以及Tim Peters一起，*都是*
    Python 的权威。他们以其对语言的百科全书式和详细的了解而闻名，effbot、martellibot 和 timbot 创建的软件和文档对数百万人至关重要。
