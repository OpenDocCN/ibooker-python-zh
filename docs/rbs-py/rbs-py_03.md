# 第二章：介绍 Python 类型

要编写可维护的 Python 代码，你必须了解类型的本质，并有意识地使用它们。我将首先讨论类型实际上是什么，以及为什么这很重要。然后我将进一步探讨 Python 语言关于其类型系统的决策如何影响代码库的健壮性。

# 类型的含义是什么？

我希望你停下来回答一个问题：不提及数字、字符串、文本或布尔值，你如何解释什么是类型？

对每个人来说，这都不是一个简单的答案。尤其是在 Python 这样的语言中，你不必显式声明变量的类型，更难解释其好处。

我认为类型有一个非常简单的定义：一种通信方法。类型传递信息。它们提供了一个用户和计算机可以推理的表示。我将表示分解为两个不同的方面：

机械表示

类型向 Python 语言本身传达行为和约束。

语义表示

类型向其他开发者传达行为和约束。

让我们更深入地了解每种表示。

## 机械表示

从本质上讲，计算机都是关于二进制代码的。你的处理器不会讲 Python；它只看到电路中的电流存在或不存在。同样的情况也适用于你计算机内存中的内容。

假设你的内存看起来像下面这样：

```py
0011001010001001000101001001000100100010000010101
0010101010101000000111111110010010100111110100100
0100100010010100101011101111011010101010101010101

010100000100000101010100

10100100100100010101000101001001010101001001001001
00011110101011010110100101011100000000000000000111
```

看起来像一堆胡言乱语。让我们放大其中的中间部分：

```py
01010000 01000001 01010100
```

没有办法准确地告诉这个数字本身意味着什么。根据计算机架构，这可能表示数字 5259604 或 5521744。它也可以是字符串“PAT”。没有任何上下文，你不能确定。这就是为什么 Python 需要类型的原因。类型信息提供了 Python 需要了解的一切来理解所有的二进制数据。让我们看看它如何运作：

```py
from ctypes import string_at
from sys import getsizeof
from binascii import hexlify

a = 0b01010000_01000001_01010100
print(a)
>>> 5259604

# prints out the memory of the variable
print(hexlify(string_at(id(a), getsizeof(a))))
>>> b'0100000000000000607c054995550000010000000000000054415000'

text = "PAT"
print(hexlify(string_at(id(text), getsizeof(text))))
>>>b'0100000000000000a00f0649955500000300000000000000375c9f1f02'
   b'acdbe4e5379218b77f0000000000000000000050415400'
```

###### 注意

我在一台小端机器上运行 CPython 3.9.0，所以如果你看到不同的结果，不要担心，有些微妙的东西可能会改变你的答案。（这段代码不能保证在其他 Python 实现如 Jython 或 PyPy 上运行。）

这些十六进制字符串显示了包含 Python 对象的内存内容。你会在链表中找到指向下一个和上一个对象的指针（用于垃圾收集），一个引用计数，一个类型，以及实际的数据本身。你可以看到每个返回值的末尾字节，以查看数字或字符串（寻找字节`0x544150`或`0x504154`）。其中重要的部分是内存中编码了一个类型。当 Python 查看一个变量时，它知道运行时每个东西的类型（就像当你使用`type()`函数时一样）。

很容易认为这是类型的唯一原因——计算机需要知道如何解释各种各样的内存块。了解 Python 如何使用类型是很重要的，因为它对编写健壮代码有一些影响，但更重要的是第二种表示法：语义表示。

## 语义表示

虽然类型的第一个定义对于底层编程非常有用，但第二个定义适用于每个开发人员。除了具有机械表示之外，类型还具有语义表示。语义表示是一种沟通工具；您选择的类型将信息跨越时间和空间传递给未来的开发人员。

类型告诉用户他们可以期望在与该实体交互时看到什么行为。在这个上下文中，“行为”是您与该类型关联的操作（加上任何前提条件或后置条件）。它们是用户在每次使用该类型时与之交互的边界、约束和自由。正确使用的类型具有低的理解障碍；它们变得自然而易用。相反，错误使用的类型是一种阻碍。

考虑一下低劣的`int`。花一分钟思考 Python 中整数具有什么行为。以下是我想到的一个快速（非详尽）列表：

+   可以由整数、浮点数或字符串构建

+   数学操作，如加法、减法、除法、乘法、指数和取反

+   关系比较，如<、>、==和!=

+   位操作（操作数字的各个位）如&、|、^、~和移位

+   使用`str`或`repr`函数转换为字符串

+   可以通过`ceil`、`floor`和`round`方法进行四舍五入（即使它们返回整数本身，这些方法也是支持的）

一个`int`有很多行为。如果你在交互式 Python 控制台中键入`help(int)`，你可以查看完整列表。

现在考虑一个`datetime`：

```py
>>>import datetime
>>>datetime.datetime.now()
datetime.datetime(2020, 9, 8, 22, 19, 28, 838667)
```

`datetime`与`int`并没有太大的区别。通常，它被表示为距离某个时间纪元（如 1970 年 1 月 1 日）的秒数或毫秒数。但是想想一个`datetime`具有的行为（我已经用斜体标出与整数不同的行为）：

+   可以由*字符串或代表日/月/年等的整数集合*构建。

+   数学操作，如*时间增量*的加法和减法

+   关系比较

+   *没有可用的位操作*

+   使用`str`或`repr`函数转换为字符串

+   *不能通过`ceil`、`floor`或`round`方法进行四舍五入*

`datetime`支持加法和减法，但不支持其他`datetime`类型。我们只能添加时间差（如添加一天或减去一年）。在标准库中，乘法和除法对`datetime`来说并没有意义。同样地，在标准库中，日期的四舍五入也不是一个支持的操作。然而，`datetime`提供了与整数类似语义的比较和字符串格式化操作。因此，尽管`datetime`本质上是一个整数，但它包含了一组受限制的操作。

###### 注意

*语义*指的是操作的意义。虽然`str(int)`和`str(datetime.datetime.now())`返回的字符串格式不同，但意义相同：我正在从一个值创建一个字符串。

`datetime`还支持它们自己的行为，以进一步将它们与整数区分开来。这些行为包括：

+   基于时区更改值

+   能够控制字符串的格式

+   找出今天是星期几

如果你想要获取所有行为的完整列表，请在你的 REPL 中输入`import datetime; help(datetime.datetime)`。

`datetime`比`int`更为具体。它传达了比普通数字更具体的使用情况。当你选择使用更具体的类型时，你在告诉未来的贡献者存在一些可能的操作和需注意的约束条件，这些在不太具体的类型中是不存在的。

让我们深入探讨这如何与健壮代码相关联。假设你继承了一个处理完全自动化厨房开关的代码库。你需要添加能够更改关闭时间的功能（例如，在假期延长厨房的营业时间）。

```py
def close_kitchen_if_past_cutoff_time(point_in_time):
    if point_in_time >= closing_time():
        close_kitchen()
        log_time_closed(point_in_time)
```

你知道你需要操作的是`point_in_time`，但如何开始？你到底在处理什么类型？是`str`、`int`、`datetime`还是一些自定义类？你可以在`point_in_time`上执行哪些操作？你没有编写这段代码，也没有它的历史记录。如果你想要调用这段代码，同样的问题也存在。你不知道什么是合法的传递给这个函数的内容。

如果你做出了错误的假设，不论朝什么方向，而这段代码又进入了生产环境，你将使代码变得不够健壮。也许这段代码并不经常执行。也许其他某个错误隐藏了这段代码的运行。也许这段代码周围的测试不多，这会在以后导致运行时错误。无论如何，代码中潜藏着一个错误，你降低了可维护性。

负责任的开发者尽力避免错误进入生产环境。他们会寻找测试、文档（当然，要带着一点谨慎——文档可能很快过时），或者调用代码。他们会查看`closing_time()`和`log_time_closed()`来查看它们期望或提供的类型，并相应地计划。在这种情况下这是正确的路径，但我仍认为这是一条次优路径。虽然错误不会达到生产环境，但他们仍然花时间浏览代码，这阻碍了价值的快速交付。在这样一个小例子中，如果发生一次，你可能会原谅这不是个大问题。但要警惕千刀万剐：任何一次切割单独看不会太糟，但堆积成千上万在代码库中散落，将使你跋涉前行，试图交付代码。

根本原因在于参数的语义表达不清晰。当你编写代码时，尽力通过类型来表达你的意图。可以在需要时将其作为注释，但我建议使用类型注解（Python 3.5+支持）来解释代码的部分。

```py
def close_kitchen_if_past_cutoff_time(point_in_time: datetime.datetime):
    if point_in_time >= closing_time():
        close_kitchen()
        log_time_closed(point_in_time)
```

我所需要做的就是在我的参数后面放一个`：<type>`。本书中的大多数代码示例将利用类型注解来清晰地表达代码期望的类型。

现在，当开发者们遇到这段代码时，他们会知道`point_in_time`的预期行为。他们不需要查看其他方法、测试或文档来了解如何操作这个变量。他们清楚地知道该做什么，并可以直接开始执行他们需要做的修改。你向未来的开发者传达了语义上的表示，而无需直接与他们交流。

此外，随着开发者对某种类型的使用越来越多，他们会变得熟悉它。当他们遇到它时，他们不需要查找文档或使用`help()`来使用该类型。你开始在代码库中创建一个众所周知的类型词汇表。这减少了维护的负担。当开发者修改现有代码时，他们希望专注于他们需要进行的更改，而不会陷入细节之中。

类型的语义表示极为重要，第一部分的其余部分将专门讨论如何利用类型为你所用。在继续之前，我需要介绍 Python 语言作为一种语言的一些基本结构元素，以及它们如何影响代码库的健壮性。

# 讨论主题

考虑一下代码库中使用的类型。选择几种类型，并问自己它们的语义表示是什么。列举它们的约束、用例和行为。你是否可以在更多地方使用这些类型？是否有地方你在误用类型？

# 类型系统

正如本章前面讨论的那样，类型系统旨在为用户提供一种模拟语言中的行为和约束的方法。编程语言对其特定类型系统在代码构建和运行时的工作方式有所期望。

## 强弱之分

类型系统按从弱到强的光谱进行分类。光谱较强一侧的语言倾向于限制对支持它们的类型的操作。换句话说，如果您违反了类型的语义表示，您将得到提示（有时会相当响亮），通过编译器错误或运行时错误。像 Haskell、TypeScript 和 Rust 这样的语言都被认为是强类型的。支持者主张强类型语言，因为在构建或运行代码时更容易发现错误。

相反，光谱较弱一侧的语言不会限制对支持它们的类型的操作。类型通常会被强制转换为不同的类型以理解操作。像 JavaScript、Perl 和较早版本的 C 这样的语言是弱类型的。支持者主张开发人员可以快速迭代代码而不必与语言作斗争。

Python 属于光谱的强一侧。在类型之间几乎没有发生隐式转换。当您执行非法操作时，这是显而易见的：

```py
>>>[] + {}
TypeError: can only concatenate list (not "dict") to list

>>> {} + []
TypeError: unsupported operand type(s) for +: 'dict' and list
```

与弱类型语言相比，如 JavaScript：

```py
>>> [] + {}
"[object Object]"

>>> {} + []
0
```

在健壮性方面，诸如 Python 之类的强类型语言确实帮助了我们。虽然错误仍然会在运行时而不是在开发时出现，但它们仍然会以明显的`TypeError`异常显示出来。这显著减少了调试问题所需的时间，再次使您能够更快地交付增量值。

# 弱类型语言固有不稳定吗？

弱类型语言的代码库绝对可以是健壮的；我绝不是在诋毁这些语言。考虑一下全球运行的大量生产级 JavaScript。但是，弱类型语言需要额外的注意才能健壮。很容易误解变量的类型并做出不正确的假设。开发人员非常依赖于 linters、测试和其他工具来提高可维护性。

## 动态与静态

还有另一个我需要讨论的类型光谱：静态与动态类型。这在处理类型的机械表示方面根本上是一种不同。

提供静态类型的语言在构建时将其类型信息嵌入变量中。开发人员可以显式向变量添加类型信息，或者一些工具（如编译器）可以为开发人员推断类型。变量在运行时不会改变其类型（因此称为“静态”）。静态类型的支持者吹嘘能够从一开始就编写安全的代码，并从强大的安全网中受益。

另一方面，动态类型将类型信息嵌入到值或变量本身。变量在运行时可以很容易地改变类型，因为该变量没有与之绑定的类型信息。动态类型的支持者主张开发的灵活性和速度；与编译器的战斗远远没有这么多。

Python 是一种动态类型语言。正如你在关于机械表示的讨论中看到的那样，变量的值内嵌了类型信息。Python 并不介意在运行时改变变量的类型：

```py
>>> a = 5
>>> a = "string"
>>> a
"string"

>>> a = tuple()
>>> a
()
```

不幸的是，在许多情况下，运行时更改类型的能力对于编写健壮的代码是一种阻碍。你不能对变量的整个生命周期做出强烈的假设。随着假设的破灭，很容易在其上写出不稳定的假设，导致你的代码中存在一个滴答作响的逻辑炸弹。

# 动态类型语言本质上不具备健壮性吗？

就像弱类型语言一样，在动态类型语言中编写健壮的代码绝对是可能的。你只需要更努力一些。你将不得不做出更多有意识的决策，使你的代码库更易维护。另一方面，静态类型也不能保证健壮性；只能最低限度地使用类型并看到很少的好处。

更糟糕的是，我之前展示的类型注释对运行时的这种行为没有影响：

```py
>>> a: int = 5
>>> a = "string"
>>> a
"string"
```

没有错误，没有警告，没有任何提示。但是希望并没有消失，你有很多策略可以使代码更加健壮（否则，这本书会非常简短）。我们将讨论最后一个有助于编写健壮代码的因素，然后开始深入研究如何改进我们的代码库。

## 鸭子类型

或许这是一个不成文的法则，每当有人提到鸭子类型时，总会有人回答：

> 如果它走起来像鸭子，嘎嘎叫起来像鸭子，那么它一定是鸭子。

我对这句话的问题是，我发现它完全没有帮助解释鸭子类型到底是什么。这句话很有吸引力，简洁明了，但关键是，只有那些已经理解鸭子类型的人才能理解。当我年轻的时候，我只是礼貌地点头，担心自己在这个简单的短语中错过了什么深刻的东西。直到后来我才真正理解了鸭子类型的威力。

*鸭子类型* 是使用编程语言中的对象和实体的能力，只要它们遵循某种接口。在 Python 中，这是一件很棒的事情，大多数人在不知不觉中都在使用它。让我们看一个简单的例子来说明我在说什么：

```py
from typing import Iterable
def print_items(items: Iterable):
    for item in items:
        print(item)

print_items([1,2,3])
print_items({4, 5, 6})
print_items({"A": 1, "B": 2, "C": 3})
```

在`print_items`的所有三次调用中，我们都遍历集合并打印每个项。想一想这是如何工作的。`print_items`根本不知道它将接收什么类型。它只是在运行时接收一个类型并对其进行操作。它不会检查每个参数并根据类型决定做不同的事情。事实上，情况要简单得多。`print_items`只是检查传递进来的东西是否可以迭代（通过调用`__iter__`方法）。如果属性`__iter__`存在，就调用它并循环遍历返回的迭代器。

我们可以通过一个简单的代码示例来验证这一点：

```py
>>> print_items(5)

Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in print_items
TypeError: 'int' object is not iterable

>>> '__iter__' in dir(int)
False
>>> '__iter__' in dir(list)
True
```

Duck typing（鸭子类型）使这一切成为可能。只要某个类型支持函数所使用的变量和方法，你就可以在该函数中自由地使用该类型。

这里有另一个例子：

```py
>>>def double_value(value):
>>>    return value + value

>>>double_value(5)
10

>>>double_value("abc")
"abcabc"
```

在某个地方传递整数，在另一个地方传递字符串并不重要；两者都支持+运算符，因此都可以正常工作。任何支持+运算符的对象都可以传递进来。我们甚至可以用列表来做：

```py
>>>double_value([1, 2, 3])
[1, 2, 3, 1, 2, 3]
```

那么这如何影响健壮性呢？事实证明，鸭子类型是一把双刃剑。它可以增加健壮性，因为它增加了组合性（我们将在第十七章中学到更多关于组合性的内容）。建立一个能够处理多种类型的坚实抽象库，可以减少复杂特殊情况的需求。然而，如果滥用鸭子类型，你开始打破开发者可以依赖的假设。在更新代码时，不仅仅是简单地进行更改；你必须查看所有调用代码，并确保传递给函数的类型也满足你的新更改。

总结所有这些，最好重述本节早期的成语如下：

> 如果它像鸭子一样走路、像鸭子一样嘎嘎叫，而你正在寻找走路和嘎嘎叫的东西，那么你可以把它当作是一只鸭子。

语言表达不太流畅，对吧？

# 讨论话题

在你的代码库中是否使用鸭子类型？是否有可以传递不匹配代码所寻找的类型的地方，但事情仍然正常工作？你认为这些对你的用例增加了还是减少了健壮性？

# 总结思路

类型是干净、可维护的代码的支柱，并且作为与其他开发人员交流的工具。如果你在类型上下功夫，就能传达很多信息，为未来的维护者减轻负担。第一部分 的其余内容将展示如何利用类型来增强代码库的健壮性。

请记住，Python 是动态和强类型的。强类型的特性对我们来说是一种福音；当我们使用不兼容的类型时，Python 会通知我们错误。但它的动态类型特性是我们需要克服的，以便编写更好的代码。这些语言选择决定了 Python 代码的编写方式，你在编写代码时应该牢记这些选择。

在接下来的章节中，我们将讨论类型注解，这是我们如何明确使用的类型。类型注解发挥着至关重要的作用：是我们向未来开发者传达行为的主要方式。它们帮助克服动态类型语言的局限性，并允许您在整个代码库中强化意图。
