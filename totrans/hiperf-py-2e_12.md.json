["```py\nimport numpy as np\nfrom numba import jit\n\n@jit(nopython=True)  # simply add the jit decorator\ndef primes(N=100000):\n    numbers = np.ones(N, dtype=np.uint8)  # initialize the boolean array\n    for i in range(2, N):\n        if numbers[i] == 0:  # has previously been crossed off\n            continue\n        else:  # it is a prime, cross off all multiples\n            x = i + i\n            while x < N:\n                numbers[x] = 0\n                x += i\n    # return all primes, as indicated by all boolean positions that are one\n    return np.nonzero(numbers)[0][2:]\n```", "```py\nIn [1]: from sieve import primes\n\nIn [2]: primes()  # run it once to make sure it is compiled\nOut[2]: array([    2,     3,     5, ..., 99971, 99989, 99991])\n\nIn [3]: %timeit primes.py_func()  # 'py_func' contains\n                                  # the original Python implementation\n145 ms ± 1.86 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)\n\nIn [4]: %timeit primes()  # this benchmarks the Numba compiled version\n340 µs ± 3.98 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)\n```", "```py\nfrom numba import njit, objmode\n\n@njit()\ndef foo():\n    for i in range(1000000):\n        # do compute\n        if i % 100000 == 0:\n            with objmode:  # to escape to object-mode\n                           # using 'format' is permissible here\n                print(\"epoch: {}\".format(i))\n\nfoo()\n```", "```py\nfrom numba import njit\nfrom numba.typed import List\n\n@njit\ndef foo(x):\n    \"\"\" Copy x, append 11 to the result. \"\"\"\n    result = x.copy()\n    result.append(11)\n    return result\n\na = List() # Create a new typed-list\nfor i in (2, 3, 5, 7):\n    # Add the content to the typed-list,\n    # the type is inferred from the first item added.\n    a.append(i)\nb = foo(a) # make the call, append 11; this list will go to eleven\n```", "```py\nfrom numba import njit\n\n@njit\ndef numpy_func(a):\n    # uses Numba's implementation of NumPy's sum, will also be fast in\n    # Python\n    return a.sum()\n\n@njit\ndef for_loop(a):\n    # uses a simple for-loop over the array\n    acc = 0\n    for i in a:\n        acc += i\n    return acc\n```", "```py\nIn [1]: ... # import the above functions\n\nIn [2]: import numpy as np\n\nIn [3]: a = np.arange(1000000, dtype=np.int64)\n\nIn [4]: numpy_func(a)  # sanity check and compile\nOut[4]: 499999500000\n\nIn [5]: for_loop(a)  # sanity check and compile\nOut[5]: 499999500000\n\nIn [6]: %timeit numpy_func(a)  # Compiled version of the NumPy func\n174 µs ± 3.05 µs per loop (mean ± std. dev. of 7 runs, 10000 loops each)\n\nIn [7]: %timeit for_loop(a)    # Compiled version of the for-loop\n186 µs ± 7.59 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)\n\nIn [8]: %timeit numpy_func.py_func(a)  # Pure NumPy func\n336 µs ± 6.72 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)\n\nIn [9]: %timeit for_loop.py_func(a)    # Pure Python for-loop\n156 ms ± 3.07 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)\n```", "```py\nfrom numba import njit\n\n@njit\ndef loop_fused(a, b):\n    return a * b - 4.1 * a > 2.5 * b\n\nIn [1]: ... # import the example\n\nIn [2]: import numpy as np\n\nIn [3]: a, b = np.arange(1e6), np.arange(1e6)\n\nIn [4]: loop_fused(a, b)  # compile the function\nOut[4]: array([False, False, False, ...,  True,  True,  True])\n\nIn [5]: %timeit loop_fused(a, b)\n643 µs ± 18 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)\n\nIn [6]: %timeit loop_fused.py_func(a, b)\n5.2 ms ± 205 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)\n```", "```py\nimport numpy as np\nfrom numba import njit\n\n@njit\ndef manual_loop_fused(a, b):\n    N = len(a)\n    result = np.empty(N, dtype=np.bool_)\n    for i in range(N):\n        a_i, b_i = a[i], b[i]\n        result[i] = a_i * b_i - 4.1 * a_i > 2.5 * b_i\n    return result\n```", "```py\nIn [1]: %timeit manual_loop_fused(a, b)\n636 µs ± 49.1 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)\n```"]