- en: Chapter 17\. Iterators, Generators, and Classic Coroutines
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第17章。迭代器、生成器和经典协程
- en: When I see patterns in my programs, I consider it a sign of trouble. The shape
    of a program should reflect only the problem it needs to solve. Any other regularity
    in the code is a sign, to me at least, that I’m using abstractions that aren’t
    powerful enough—often that I’m generating by hand the expansions of some macro
    that I need to write.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当我在我的程序中看到模式时，我认为这是一个麻烦的迹象。程序的形状应该只反映它需要解决的问题。代码中的任何其他规律性对我来说都是一个迹象，至少对我来说，这表明我使用的抽象不够强大——通常是我手动生成我需要编写的某个宏的扩展。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Paul Graham, Lisp hacker and venture capitalist^([1](ch17.html#idm46582406895680))
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Paul Graham，Lisp 程序员和风险投资家^([1](ch17.html#idm46582406895680))
- en: 'Iteration is fundamental to data processing: programs apply computations to
    data series, from pixels to nucleotides. If the data doesn’t fit in memory, we
    need to fetch the items *lazily*—one at a time and on demand. That’s what an iterator
    does. This chapter shows how the *Iterator* design pattern is built into the Python
    language so you never need to code it by hand.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代对于数据处理是基础的：程序将计算应用于数据系列，从像素到核苷酸。如果数据不适合内存，我们需要*惰性*地获取项目——一次一个，并按需获取。这就是迭代器的作用。本章展示了*迭代器*设计模式是如何内置到
    Python 语言中的，因此您永远不需要手动编写它。
- en: 'Every standard collection in Python is *iterable*. An *iterable* is an object
    that provides an *iterator*, which Python uses to support operations like:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的每个标准集合都是*可迭代*的。*可迭代*是提供*迭代器*的对象，Python 使用它来支持诸如：
- en: '`for` loops'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`循环'
- en: List, dict, and set comprehensions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表、字典和集合推导
- en: Unpacking assignments
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解包赋值
- en: Construction of collection instances
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合实例的构建
- en: 'This chapter covers the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵���以下主题：
- en: How Python uses the `iter()` built-in function to handle iterable objects
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 如何使用`iter()`内置函数处理可迭代对象
- en: How to implement the classic Iterator pattern in Python
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Python 中实现经典迭代器模式
- en: How the classic Iterator pattern can be replaced by a generator function or
    generator expression
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经典迭代器模式如何被生成器函数或生成器表达式替代
- en: How a generator function works in detail, with line-by-line descriptions
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细介绍生成器函数的工作原理，逐行描述
- en: Leveraging the general-purpose generator functions in the standard library
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用标准库中的通用生成器函数
- en: Using `yield from` expressions to combine generators
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`yield from`表达式组合生成器
- en: Why generators and classic coroutines look alike but are used in very different
    ways and should not be mixed
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么生成器和经典协程看起来相似但用法却截然不同，不应混合使用
- en: What’s New in This Chapter
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章的新内容
- en: '[“Subgenerators with yield from”](#yield_from_sec0) grew from one to six pages.
    It now includes simpler experiments demonstrating the behavior of generators with
    `yield from`, and an example of traversing a tree data structure, developed step-by-step.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[“使用 yield from 的子生成器”](#yield_from_sec0) 从一页发展到六页。现在它包括了演示使用`yield from`生成器行为的更简单实验，以及逐步开发树数据结构遍历的示例。'
- en: New sections explain the type hints for `Iterable`, `Iterator`, and `Generator`
    types.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 新的部分解释了`Iterable`、`Iterator`和`Generator`类型的类型提示。
- en: The last major section of this chapter, [“Classic Coroutines”](#classic_coroutines_sec),
    is a 9-page introduction to a topic that filled a 40-page chapter in the first
    edition. I updated and moved the [“Classic Coroutines”](https://fpy.li/oldcoro)
    chapter to a [post in the companion website](https://fpy.li/oldcoro) because it
    was the most challenging chapter for readers, but its subject matter is less relevant
    after Python 3.5 introduced native coroutines—which we’ll study in [Chapter 21](ch21.html#async_ch).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一个重要部分，[“经典协程”](#classic_coroutines_sec)，是对一个主题的介绍，第一版中占据了一个40页的章节。我更新并将[“经典协程”](https://fpy.li/oldcoro)章节移至[伴随网站的帖子](https://fpy.li/oldcoro)，因为这是读者最具挑战性的章节，但在
    Python 3.5 引入原生协程后，其主题的相关性较小，我们将在[第21章](ch21.html#async_ch)中学习。
- en: We’ll get started studying how the `iter()` built-in function makes sequences
    iterable.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始学习`iter()`内置函数如何使序列可迭代。
- en: A Sequence of Words
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一系列单词
- en: 'We’ll start our exploration of iterables by implementing a `Sentence` class:
    you give its constructor a string with some text, and then you can iterate word
    by word. The first version will implement the sequence protocol, and it’s iterable
    because all sequences are iterable—as we’ve seen since [Chapter 1](ch01.html#data_model).
    Now we’ll see exactly why.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过实现一个`Sentence`类来开始探索可迭代对象：你可以将一些文本传递给它的构造函数，然后逐个单词进行迭代。第一个版本将实现序列协议，并且它是可迭代的，因为所有序列都是可迭代的——正如我们在[第1章](ch01.html#data_model)中所看到的。现在我们将看到确切的原因。
- en: '[Example 17-1](#ex_sentence0) shows a `Sentence` class that extracts words
    from a text by index.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 17-1](#ex_sentence0) 展示了一个从文本中提取单词的`Sentence`类。'
- en: 'Example 17-1\. sentence.py: a `Sentence` as a sequence of words'
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-1。sentence.py：一个将文本按单词索引提取的`Sentence`类
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO1-1)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO1-1)'
- en: '`.findall` returns a list with all nonoverlapping matches of the regular expression,
    as a list of strings.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`.findall` 返回一个字符串列表，其中包含正则表达式的所有非重叠匹配。'
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO1-2)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO1-2)'
- en: '`self.words` holds the result of `.findall`, so we simply return the word at
    the given index.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.words`保存了`.findall`的结果，因此我们只需返回给定索引处的单词。'
- en: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO1-3)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO1-3)'
- en: To complete the sequence protocol, we implement `__len__` although it is not
    needed to make an iterable.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成序列协议，我们实现了`__len__`，尽管不需要使其可迭代。
- en: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO1-4)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO1-4)'
- en: '`reprlib.repr` is a utility function to generate abbreviated string representations
    of data structures that can be very large.^([2](ch17.html#idm46582406680288))'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`reprlib.repr`是一个实用函数，用于生成数据结构的缩写字符串表示，这些数据结构可能非常庞大。^([2](ch17.html#idm46582406680288))'
- en: By default, `reprlib.repr` limits the generated string to 30 characters. See
    the console session in [Example 17-2](#demo_sentence0) to see how `Sentence` is
    used.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`reprlib.repr`将生成的字符串限制为30个字符。查看[示例17-2](#demo_sentence0)中的控制台会话，了解如何使用`Sentence`。
- en: Example 17-2\. Testing iteration on a `Sentence` instance
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例17-2。在`Sentence`实例上测试迭代
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO2-1)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO2-1)'
- en: A sentence is created from a string.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从字符串创建一个句子。
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO2-2)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO2-2)'
- en: Note the output of `__repr__` using `...` generated by `reprlib.repr`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`reprlib.repr`生成的`__repr__`输出中的`...`。
- en: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO2-3)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO2-3)'
- en: '`Sentence` instances are iterable; we’ll see why in a moment.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sentence`实例是可迭代的；我们马上就会看到原因。'
- en: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO2-4)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO2-4)'
- en: Being iterable, `Sentence` objects can be used as input to build lists and other
    iterable types.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 作为可迭代对象，`Sentence`对象可用作构建列表和其他可迭代类型的输入。
- en: 'In the following pages, we’ll develop other `Sentence` classes that pass the
    tests in [Example 17-2](#demo_sentence0). However, the implementation in [Example 17-1](#ex_sentence0)
    is different from the others because it’s also a sequence, so you can get words
    by index:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的页面中，我们将开发其他通过[示例17-2](#demo_sentence0)中测试的`Sentence`类。然而，[示例17-1](#ex_sentence0)中的实现与其他实现不同，因为它也是一个序列，所以你可以通过索引获取单词：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Python programmers know that sequences are iterable. Now we’ll see precisely
    why.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序员知道序列是可迭代的。现在我们将看到具体原因。
- en: 'Why Sequences Are Iterable: The iter Function'
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么序列是可迭代的：iter函数
- en: Whenever Python needs to iterate over an object `x`, it automatically calls
    `iter(x)`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每当Python需要对对象`x`进行迭代时，它会自动调用`iter(x)`。
- en: 'The `iter` built-in function:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`iter`内置函数：'
- en: Checks whether the object implements `__iter__`, and calls that to obtain an
    iterator.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查对象是否实现了`__iter__`，并调用它以获取迭代器。
- en: If `__iter__` is not implemented, but `__getitem__` is, then `iter()` creates
    an iterator that tries to fetch items by index, starting from 0 (zero).
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果未实现`__iter__`，但实现了`__getitem__`，那么`iter()`会创建一个迭代器，尝试从0（零）开始按索引获取项目。
- en: If that fails, Python raises `TypeError`, usually saying `'C' object is not
    iterable`, where `C` is the class of the target object.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果失败，Python会引发`TypeError`，通常会显示`'C'对象不可迭代`，其中`C`是目标对象的类。
- en: 'That is why all Python sequences are iterable: by definition, they all implement
    `__getitem__`. In fact, the standard sequences also implement `__iter__`, and
    yours should too, because iteration via `__getitem__` exists for backward compatibility
    and may be gone in the future—although it is not deprecated as of Python 3.10,
    and I doubt it will ever be removed.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么所有的Python序列都是可迭代的：根据定义，它们都实现了`__getitem__`。事实上，标准序列也实现了`__iter__`，你的序列也应该实现，因为通过`__getitem__`进行迭代是为了向后兼容，可能在未来会被移除——尽管在Python
    3.10中尚未被弃用，我怀疑它会被移除。
- en: 'As mentioned in [“Python Digs Sequences”](ch13.html#python_digs_seq_sec), this
    is an extreme form of duck typing: an object is considered iterable not only when
    it implements the special method `__iter__`, but also when it implements `__getitem__`.
    Take a look:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如[“Python挖掘序列”](ch13.html#python_digs_seq_sec)中所述，这是一种极端的鸭子类型：一个对象被视为可迭代对象不仅当它实现了特殊方法`__iter__`，还当它实现了`__getitem__`。看一下：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If a class provides `__getitem__`, the `iter()` built-in accepts an instance
    of that class as iterable and builds an iterator from the instance. Python’s iteration
    machinery will call `__getitem__` with indexes starting from 0, and will take
    an `IndexError` as a signal that there are no more items.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类提供了`__getitem__`，则`iter()`内置函数接受该类的实例作为可迭代对象，并从实例构建迭代器。Python的迭代机制将从0开始调用`__getitem__`，并将`IndexError`作为没有更多项目的信号。
- en: Note that although `spam_can` is iterable (its `__getitem__` could provide items),
    it is not recognized as such by an `isinstance` against `abc.Iterable`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管`spam_can`是可迭代的（其`__getitem__`可以提供项目），但它不被`isinstance`识别为`abc.Iterable`。
- en: 'In the goose-typing approach, the definition for an iterable is simpler but
    not as flexible: an object is considered iterable if it implements the `__iter__`
    method. No subclassing or registration is required, because `abc.Iterable` implements
    the `__subclasshook__`, as seen in [“Structural Typing with ABCs”](ch13.html#subclasshook_sec).
    Here is a demonstration:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在鹅类型方法中，可迭代对象的定义更简单但不够灵活：如果一个对象实现了`__iter__`方法，则被视为可迭代对象。不需要子类化或注册，因为`abc.Iterable`实现了`__subclasshook__`，如[“使用ABC进行结构化类型”](ch13.html#subclasshook_sec)中所示。以下是一个演示：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: As of Python 3.10, the most accurate way to check whether an object `x` is iterable
    is to call `iter(x)` and handle a `TypeError` exception if it isn’t. This is more
    accurate than using `isinstance(x, abc.Iterable)`, because `iter(x)` also considers
    the legacy `__getitem__` method, while the `Iterable` ABC does not.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 截至Python 3.10，检查对象`x`是否可迭代的最准确方法是调用`iter(x)`，如果不可迭代则处理`TypeError`异常。这比使用`isinstance(x,
    abc.Iterable)`更准确，因为`iter(x)`还考虑了传统的`__getitem__`方法，而`Iterable` ABC则不考虑。
- en: 'Explicitly checking whether an object is iterable may not be worthwhile if
    right after the check you are going to iterate over the object. After all, when
    the iteration is attempted on a noniterable, the exception Python raises is clear
    enough: `TypeError: ''C'' object is not iterable`. If you can do better than just
    raising `TypeError`, then do so in a `try/except` block instead of doing an explicit
    check. The explicit check may make sense if you are holding on to the object to
    iterate over it later; in this case, catching the error early makes debugging
    easier.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '明确检查对象是否可迭代可能不值得，如果在检查之后立即对对象进行迭代。毕竟，当尝试在不可迭代对象上进行迭代时，Python引发的异常足够清晰：`TypeError:
    ''C'' object is not iterable`。如果你可以比简单地引发`TypeError`更好，那么在`try/except`块中这样做而不是进行显式检查。显式检查可能在稍后持有对象以进行迭代时是有意义的；在这种情况下，尽早捕获错误会使调试更容易。'
- en: The `iter()` built-in is more often used by Python itself than by our own code.
    There’s a second way we can use it, but it’s not widely known.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`iter()`内置函数更常被Python自身使用，而不是我们自己的代码。我们可以用第二种方式使用它，但这并不是广为人知的。'
- en: Using iter with a Callable
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用可调用对象调用iter
- en: 'We can call `iter()` with two arguments to create an iterator from a function
    or any callable object. In this usage, the first argument must be a callable to
    be invoked repeatedly (with no arguments) to produce values, and the second argument
    is a [*sentinel*](https://fpy.li/17-2): a marker value which, when returned by
    the callable, causes the iterator to raise `StopIteration` instead of yielding
    the sentinel.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用两个参数调用`iter()`来从函数或任何可调用对象创建迭代器。在这种用法中，第一个参数必须是一个可调用对象，以便重复调用（不带参数）以产生值，第二个参数是一个[*sentinel*](https://fpy.li/17-2)：一个标记值，当可调用对象返回该值时，迭代器会引发`StopIteration`而不是产生该标记值。
- en: 'The following example shows how to use `iter` to roll a six-sided die until
    a `1` is rolled:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何使用`iter`来掷一个六面骰子，直到掷出`1`：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that the `iter` function here returns a `callable_iterator`. The `for`
    loop in the example may run for a very long time, but it will never display `1`,
    because that is the sentinel value. As usual with iterators, the `d6_iter` object
    in the example becomes useless once exhausted. To start over, we must rebuild
    the iterator by invoking `iter()` again.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里的`iter`函数返回一个`callable_iterator`。示例中的`for`循环可能运行很长时间，但永远不会显示`1`，因为那是标记值。与迭代器一样，示例中的`d6_iter`对象在耗尽后变得无用。要重新开始，我们必须通过再次调用`iter()`来重新构建迭代器。
- en: 'The [documentation for `iter`](https://fpy.li/17-3) includes the following
    explanation and example code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[`iter`的文档](https://fpy.li/17-3)包括以下解释和示例代码：'
- en: 'One useful application of the second form of `iter()` is to build a block-reader.
    For example, reading fixed-width blocks from a binary database file until the
    end of file is reached:'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`iter()`第二种形式的一个���用应用是构建块读取器。例如，从二进制数据库文件中读取固定宽度的块，直到达到文件末尾：'
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For clarity, I’ve added the `read64` assignment, which is not in the [original
    example](https://fpy.li/17-3). The `partial()` function is necessary because the
    callable given to `iter()` must not require arguments. In the example, an empty
    `bytes` object is the sentinel, because that’s what `f.read` returns when there
    are no more bytes to read.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，我添加了`read64`赋值，这在[原始示例](https://fpy.li/17-3)中没有。`partial()`函数是必需的，因为传递给`iter()`的可调用对象不应该需要参数。在示例中，一个空的`bytes`对象是标记值，因为这就是`f.read`在没有更多字节可读时返回的值。
- en: The next section details the relationship between iterables and iterators.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节详细介绍了可迭代对象和迭代器之间的关系。
- en: Iterables Versus Iterators
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可迭代对象与迭代器
- en: 'From the explanation in [“Why Sequences Are Iterable: The iter Function”](#iter_func_sec)
    we can extrapolate a definition:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从[“为什么序列是可迭代的：iter函数”](#iter_func_sec)中的解释，我们可以推断出一个定义：
- en: iterable
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可迭代的
- en: Any object from which the `iter` built-in function can obtain an iterator. Objects
    implementing an `__iter__` method returning an *iterator* are iterable. Sequences
    are always iterable, as are objects implementing a `__getitem__` method that accepts
    0-based indexes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 任何`iter`内置函数可以获取迭代器的对象。实现返回*迭代器*的`__iter__`方法的对象是可迭代的。序列始终是可迭代的，实现接受基于0的索引的`__getitem__`方法的对象也是可迭代的。
- en: 'It’s important to be clear about the relationship between iterables and iterators:
    Python obtains iterators from iterables.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要清楚可迭代对象和迭代器之间的关系：Python从可迭代对象获取迭代器。
- en: 'Here is a simple `for` loop iterating over a `str`. The `str` `''ABC''` is
    the iterable here. You don’t see it, but there is an iterator behind the curtain:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的`for`循环，遍历一个`str`。这里的可迭代对象是`str` `'ABC'`。你看不到它，但幕后有一个迭代器：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If there was no `for` statement and we had to emulate the `for` machinery by
    hand with a `while` loop, this is what we’d have to write:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有`for`语句，我们必须用`while`循环手动模拟`for`机制，那么我们需要写下面的代码：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO3-1)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO3-1)'
- en: Build an iterator `it` from the iterable.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从可迭代对象构建迭代器`it`。
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO3-2)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO3-2)'
- en: Repeatedly call `next` on the iterator to obtain the next item.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 反复调用迭代器上的`next`以获取下一个项目。
- en: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO3-3)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO3-3)'
- en: The iterator raises `StopIteration` when there are no further items.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有更多项目时，迭代器会引发`StopIteration`。
- en: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO3-4)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO3-4)'
- en: Release reference to `it`—the iterator object is discarded.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 释放对`it`的引用——迭代器对象被丢弃。
- en: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO3-5)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO3-5)'
- en: Exit the loop.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 退出循环。
- en: '`StopIteration` signals that the iterator is exhausted. This exception is handled
    internally by the `iter()` built-in that is part of the logic of `for` loops and
    other iteration contexts like list comprehensions, iterable unpacking, etc.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`StopIteration` 表示迭代器已耗尽。这个异常由`iter()`内置处理，它是`for`循环和其他迭代上下文（如列表推导、可迭代解包等）逻辑的一部分。'
- en: 'Python’s standard interface for an iterator has two methods:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Python的迭代器标准接口有两个方法：
- en: '`__next__`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`__next__`'
- en: Returns the next item in the series, raising `StopIteration` if there are no
    more.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 返回系列中的下一个项目，如果没有更多，则引发`StopIteration`。
- en: '`__iter__`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`__iter__`'
- en: Returns `self`; this allows iterators to be used where an iterable is expected,
    for example, in a `for` loop.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`self`；这允许迭代器在期望可迭代对象的地方使用，例如在`for`循环中。
- en: That interface is formalized in the `collections.abc.Iterator` ABC, which declares
    the `__next__` abstract method, and subclasses `Iterable`—where the abstract `__iter__`
    method is declared. See [Figure 17-1](#iterable_fig).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口在`collections.abc.Iterator` ABC中得到规范化，它声明了`__next__`抽象方法，并且子类化`Iterable`——在那里声明了抽象的`__iter__`方法。参见[图17-1](#iterable_fig)。
- en: '![Iterable UML diagram](assets/flpy_1701.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![可迭代UML图](assets/flpy_1701.png)'
- en: Figure 17-1\. The `Iterable` and `Iterator` ABCs. Methods in italic are abstract.
    A concrete `Iterable.__iter__` should return a new `Iterator` instance. A concrete
    `Iterator` must implement `__next__`. The `Iterator.__iter__` method just returns
    the instance itself.
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图17-1。`Iterable`和`Iterator` ABCs。斜体的方法是抽象的。一个具体的`Iterable.__iter__`应返回一个新的`Iterator`实例。一个具体的`Iterator`必须实现`__next__`。`Iterator.__iter__`方法只返回实例本身。
- en: The source code for `collections.abc.Iterator` is in [Example 17-3](#abc_iterator_src).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections.abc.Iterator`的源代码在[示例17-3](#abc_iterator_src)中。'
- en: Example 17-3\. `abc.Iterator` class; extracted from [*Lib/_collections_abc.py*](https://fpy.li/17-5)
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例17-3。`abc.Iterator`类；从[*Lib/_collections_abc.py*](https://fpy.li/17-5)中提取
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO4-1)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO4-1)'
- en: '`__subclasshook__` supports structural type checks with `isinstance` and `issubclass`.
    We saw it in [“Structural Typing with ABCs”](ch13.html#subclasshook_sec).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`__subclasshook__`支持使用`isinstance`和`issubclass`进行结构类型检查。我们在[“使用ABC进行结构类型检查”](ch13.html#subclasshook_sec)中看到了它。'
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO4-2)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO4-2)'
- en: '`_check_methods` traverses the `__mro__` of the class to check whether the
    methods are implemented in its base classes. It’s defined in that same *Lib/_collections_abc.py*
    module. If the methods are implemented, the `C` class will be recognized as a
    virtual subclass of `Iterator`. In other words, `issubclass(C, Iterable)` will
    return `True`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`_check_methods` 遍历类的`__mro__`以检查方法是否在其基类中实现。它在同一*Lib/_collections_abc.py*模块中定义。如果方法已实现，则`C`类将被识别为`Iterator`的虚拟子类。换句话说，`issubclass(C,
    Iterable)`将返回`True`。'
- en: Warning
  id: totrans-112
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'The `Iterator` ABC abstract method is `it.__next__()` in Python 3 and `it.next()`
    in Python 2\. As usual, you should avoid calling special methods directly. Just
    use the `next(it)`: this built-in function does the right thing in Python 2 and
    3—which is useful for those migrating codebases from 2 to 3.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterator` ABC的抽象方法在Python 3中是`it.__next__()`，在Python 2中是`it.next()`。通常情况下，应避免直接调用特殊方法。只需使用`next(it)`：这个内置函数在Python
    2和3中都会执行正确的操作，这对于那些从2迁移到3的代码库很有用。'
- en: 'The [*Lib/types.py*](https://fpy.li/17-6) module source code in Python 3.9
    has a comment that says:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.9中[*Lib/types.py*](https://fpy.li/17-6)模块源代码中有一条注释说：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In fact, that’s exactly what the `__subclasshook__` method of the `abc.Iterator`
    ABC does.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`abc.Iterator`的`__subclasshook__`方法就是这样做的。
- en: Tip
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Given the advice from *Lib/types.py* and the logic implemented in *Lib/_collections_abc.py*,
    the best way to check if an object `x` is an iterator is to call `isinstance(x,
    abc.Iterator)`. Thanks to `Iterator.__subclasshook__`, this test works even if
    the class of `x` is not a real or virtual subclass of `Iterator`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 根据*Lib/types.py*中的建议和*Lib/_collections_abc.py*中实现的逻辑，检查对象`x`是否为迭代器的最佳方法是调用`isinstance(x,
    abc.Iterator)`。由于`Iterator.__subclasshook__`，即使`x`的类不是`Iterator`的真实或虚拟子类，此测试也有效。
- en: 'Back to our `Sentence` class from [Example 17-1](#ex_sentence0), you can clearly
    see how the iterator is built by `iter()` and consumed by `next()` using the Python
    console:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`Sentence`类，从[示例17-1](#ex_sentence0)中，您可以清楚地看到迭代器是如何通过Python控制台由`iter()`构建并由`next()`消耗的：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO5-1)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO5-1)'
- en: Create a sentence `s3` with three words.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含三个单词的句子`s3`。
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO5-2)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO5-2)'
- en: Obtain an iterator from `s3`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从`s3`获取一个迭代器。
- en: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO5-3)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO5-3)'
- en: '`next(it)` fetches the next word.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`next(it)` 获取下一个单词。'
- en: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO5-4)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO5-4)'
- en: There are no more words, so the iterator raises a `StopIteration` exception.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 没有更多的单词了，所以迭代器会引发`StopIteration`异常。
- en: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO5-5)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO5-5)'
- en: Once exhausted, an iterator will always raise `StopIteration`, which makes it
    look like it’s empty.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦耗尽，迭代器将始终引发`StopIteration`，这使其看起来像是空的。
- en: '[![6](assets/6.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO5-6)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO5-6)'
- en: To go over the sentence again, a new iterator must be built.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要再次遍历句子，必须构建一个新的迭代器。
- en: Because the only methods required of an iterator are `__next__` and `__iter__`,
    there is no way to check whether there are remaining items, other than to call
    `next()` and catch `StopIteration`. Also, it’s not possible to “reset” an iterator.
    If you need to start over, you need to call `iter()` on the iterable that built
    the iterator in the first place. Calling `iter()` on the iterator itself won’t
    help either, because—as mentioned—`Iterator.__iter__` is implemented by returning
    `self`, so this will not reset a depleted iterator.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因为迭代器所需的唯一方法是`__next__`和`__iter__`，所以没有办法检查是否还有剩余的项，除非调用`next()`并捕获`StopIteration`。此外，无法“重置”迭代器。如果需要重新开始，必须在第一次构建迭代器的可迭代对象上调用`iter()`。在迭代器本身上调用`iter()`也不会有帮助，因为正如前面提到的，`Iterator.__iter__`是通过返回`self`来实现的，因此这不会重置已耗尽的迭代器。
- en: That minimal interface is sensible, because in reality not all iterators are
    resettable. For example, if an iterator is reading packets from the network, there’s
    no way to rewind it.^([3](ch17.html#idm46582405697760))
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这种最小接口是合理的，因为实际上，并非所有迭代器都可以重置。例如，如果一个迭代器正在从网络中读取数据包，就无法倒带。^([3](ch17.html#idm46582405697760))
- en: The first version of `Sentence` from [Example 17-1](#ex_sentence0) was iterable
    thanks to the special treatment the `iter()` built-in gives to sequences. Next,
    we will implement `Sentence` variations that implement `__iter__` to return iterators.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 来自[Example 17-1](#ex_sentence0)的第一个`Sentence`版本之所以可迭代，是因为`iter()`内置函数对序列的特殊处理。接下来，我们将实现`Sentence`的变体，这些变体实现了`__iter__`以返回迭代器。
- en: Sentence Classes with __iter__
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有`__iter__`的句子类
- en: The next variations of `Sentence` implement the standard iterable protocol,
    first by implementing the Iterator design pattern, and then with generator functions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个`Sentence`的变体实现了标准的可迭代协议，首先通过实现迭代器设计模式，然后使用生成器函数。
- en: 'Sentence Take #2: A Classic Iterator'
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '句子接收 #2: 经典迭代器'
- en: The next `Sentence` implementation follows the blueprint of the classic Iterator
    design pattern from the *Design Patterns* book. Note that it is not idiomatic
    Python, as the next refactorings will make very clear. But it is useful to show
    the distinction between an iterable collection and an iterator that works with
    it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个`Sentence`实现遵循*设计模式*书中经典迭代器设计模式的蓝图。请注意，这不是 Python 的惯用写法，因为接下来的重构将非常清楚地表明。但是，展示可迭代集合和与之一起使用的迭代器之间的区别是有用的。
- en: The `Sentence` class in [Example 17-4](#ex_sentence1) is iterable because it
    implements the `__iter__` special method, which builds and returns a `SentenceIterator`.
    That’s how an iterable and an iterator are related.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 17-4](#ex_sentence1)中的`Sentence`类是可迭代的，因为它实现了`__iter__`特殊方法，该方法构建并返回一个`SentenceIterator`。这就是可迭代对象和迭代器之间的关系。'
- en: 'Example 17-4\. sentence_iter.py: `Sentence` implemented using the Iterator
    pattern'
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '示例 17-4\. sentence_iter.py: 使用迭代器模式实现的`Sentence`'
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO6-1)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO6-1)'
- en: The `__iter__` method is the only addition to the previous `Sentence` implementation.
    This version has no `__getitem__`, to make it clear that the class is iterable
    because it implements `__iter__`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`__iter__`方法是对先前`Sentence`实现的唯一补充。这个版本没有`__getitem__`，以明确表明该类之所以可迭代是因为它实现了`__iter__`。'
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO6-2)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO6-2)'
- en: '`__iter__` fulfills the iterable protocol by instantiating and returning an
    iterator.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`__iter__` 通过实例化并返回一个迭代器来实现可迭代协议。'
- en: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO6-3)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO6-3)'
- en: '`SentenceIterator` holds a reference to the list of words.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`SentenceIterator` 持有对单词列表的引用。'
- en: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO6-4)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO6-4)'
- en: '`self.index` determines the next word to fetch.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`self.index` 确定下一个要获取的单词。'
- en: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO6-5)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO6-5)'
- en: Get the word at `self.index`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 获取`self.index`处的单词。
- en: '[![6](assets/6.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO6-6)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO6-6)'
- en: If there is no word at `self.index`, raise `StopIteration`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`self.index`处没有单词，则引发`StopIteration`。
- en: '[![7](assets/7.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO6-7)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO6-7)'
- en: Increment `self.index`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 增加 `self.index`。
- en: '[![8](assets/8.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO6-8)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO6-8)'
- en: Return the word.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 返回单词。
- en: '[![9](assets/9.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO6-9)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO6-9)'
- en: Implement `self.__iter__`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `self.__iter__`。
- en: The code in [Example 17-4](#ex_sentence1) passes the tests in [Example 17-2](#demo_sentence0).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 17-4](#ex_sentence1)中的代码通过[Example 17-2](#demo_sentence0)中的测试。'
- en: 'Note that implementing `__iter__` in `SentenceIterator` is not actually needed
    for this example to work, but it is the right thing to do: iterators are supposed
    to implement both `__next__` and `__iter__`, and doing so makes our iterator pass
    the `issubclass(SentenceIterator, abc.Iterator)` test. If we had subclassed `SentenceIterator`
    from `abc.Iterator`, we’d inherit the concrete `abc.Iterator.__iter__` method.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个示例中，实际上并不需要在`SentenceIterator`中实现`__iter__`，但这样做是正确的：迭代器应该同时实现`__next__`和`__iter__`，这样做可以使我们的迭代器通过`issubclass(SentenceIterator,
    abc.Iterator)`测试。如果我们从`abc.Iterator`继承`SentenceIterator`，我们将继承具体的`abc.Iterator.__iter__`方法。
- en: That is a lot of work (for us spoiled Python programmers, anyway). Note how
    most code in `SentenceIterator` deals with managing the internal state of the
    iterator. Soon we’ll see how to avoid that bookkeeping. But first, a brief detour
    to address an implementation shortcut that may be tempting, but is just wrong.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一项繁重的工作（对于我们这些被宠坏的 Python 程序员来说）。请注意，`SentenceIterator` 中的大部分代码都涉及管理迭代器的内部状态。很快我们将看到如何避免这种繁琐的工作。但首先，让我们简要地讨论一下可能会诱人但却是错误的实现快捷方式。
- en: Don’t Make the Iterable an Iterator for Itself
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要将可迭代对象作为自身的迭代器。
- en: 'A common cause of errors in building iterables and iterators is to confuse
    the two. To be clear: iterables have an `__iter__` method that instantiates a
    new iterator every time. Iterators implement a `__next__` method that returns
    individual items, and an `__iter__` method that returns `self`.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建可迭代对象和迭代器时常见的错误是混淆两者。明确一点：可迭代对象具有一个 `__iter__` 方法，每次实例化一个新的迭代器。迭代器实现了一个返回单个项的
    `__next__` 方法，以及一个返回 `self` 的 `__iter__` 方法。
- en: Therefore, iterators are also iterable, but iterables are not iterators.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，迭代器也是可迭代的，但可迭代的对象不是迭代器。
- en: It may be tempting to implement `__next__` in addition to `__iter__` in the
    `Sentence` class, making each `Sentence` instance at the same time an iterable
    and iterator over itself. But this is rarely a good idea. It’s also a common antipattern,
    according to Alex Martelli who has a lot of experience reviewing Python code at
    Google.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会诱人在 `Sentence` 类中实现 `__next__` 以及 `__iter__`，使每个 `Sentence` 实例同时成为自身的可迭代器和迭代器。但这很少是一个好主意。根据在
    Google 审查 Python 代码方面拥有丰富经验的 Alex Martelli 的说法，这也是一个常见的反模式。
- en: 'The “Applicability” section about the Iterator design pattern in the *Design
    Patterns* book says:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*设计模式* 书中关于迭代器设计模式的“适用性”部分说：'
- en: Use the Iterator pattern
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用迭代器模式
- en: ''
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: to access an aggregate object’s contents without exposing its internal representation.
  id: totrans-171
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问聚合对象的内容而不暴露其内部表示。
- en: ''
  id: totrans-172
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-173
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: to support multiple traversals of aggregate objects.
  id: totrans-174
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以支持聚合对象的多次遍历。
- en: ''
  id: totrans-175
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-176
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: to provide a uniform interface for traversing different aggregate structures
    (that is, to support polymorphic iteration).
  id: totrans-177
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为不同的聚合结构提供统一的遍历接口（即支持多态迭代）。
- en: To “support multiple traversals,” it must be possible to obtain multiple independent
    iterators from the same iterable instance, and each iterator must keep its own
    internal state, so a proper implementation of the pattern requires each call to
    `iter(my_iterable)` to create a new, independent, iterator. That is why we need
    the `SentenceIterator` class in this example.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要“支持多次遍历”，必须能够从同一个可迭代实例中获取多个独立的迭代器，并且每个迭代器必须保持自己的内部状态，因此模式的正确实现要求每次调用 `iter(my_iterable)`
    都会创建一个新的独立迭代器。这就是为什么在这个例子中我们需要 `SentenceIterator` 类。
- en: Now that the classic Iterator pattern is properly demonstrated, we can let it
    go. Python incorporated the `yield` keyword from Barbara Liskov’s [CLU language](https://fpy.li/17-7),
    so we don’t need to “generate by hand” the code to implement iterators.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在经典的迭代器模式已经得到了正确的演示，我们可以放手了。Python 从 Barbara Liskov 的 [CLU 语言](https://fpy.li/17-7)
    中引入了 `yield` 关键字，因此我们不需要手动“生成”代码来实现迭代器。
- en: The next sections present more idiomatic versions of `Sentence`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节将呈现更符合 Python 习惯的 `Sentence` 版本。
- en: 'Sentence Take #3: A Generator Function'
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'Sentence Take #3：生成器函数'
- en: A Pythonic implementation of the same functionality uses a generator, avoiding
    all the work to implement the `SentenceIterator` class. A proper explanation of
    the generator comes right after [Example 17-5](#ex_sentence2).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 同样功能的 Python 实现使用了生成器，避免了实现 `SentenceIterator` 类的所有工作。生成器的正确解释就在 [Example 17-5](#ex_sentence2)
    之后。
- en: 'Example 17-5\. sentence_gen.py: `Sentence` implemented using a generator'
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 17-5\. sentence_gen.py：使用生成器实现的 `Sentence`
- en: '[PRE13]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO7-1)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO7-1)'
- en: Iterate over `self.words`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历 `self.words`。
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO7-2)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO7-2)'
- en: Yield the current `word`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 产出当前的 `word`。
- en: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO7-3)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO7-3)'
- en: 'Explicit `return` is not necessary; the function can just “fall through” and
    return automatically. Either way, a generator function doesn’t raise `StopIteration`:
    it simply exits when it’s done producing values.^([4](ch17.html#idm46582405269920))'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 明确的 `return` 不是必需的；函数可以“顺利执行”并自动返回。无论哪种方式，生成器函数不会引发 `StopIteration`：当完成生成值时，它只是退出。
- en: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO7-4)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO7-4)'
- en: No need for a separate iterator class!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要单独的迭代器类！
- en: Here again we have a different implementation of `Sentence` that passes the
    tests in [Example 17-2](#demo_sentence0).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们再次看到了一个不同的 `Sentence` 实现，通过了 [Example 17-2](#demo_sentence0) 中的测试。
- en: Back in the `Sentence` code in [Example 17-4](#ex_sentence1), `__iter__` called
    the `SentenceIterator` constructor to build an iterator and return it. Now the
    iterator in [Example 17-5](#ex_sentence2) is in fact a generator object, built
    automatically when the `__iter__` method is called, because `__iter__` here is
    a generator function.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 [Example 17-4](#ex_sentence1) 中的 `Sentence` 代码，`__iter__` 调用了 `SentenceIterator`
    构造函数来构建一个迭代器并返回它。现在 [Example 17-5](#ex_sentence2) 中的迭代器实际上是一个生成器对象，在调用 `__iter__`
    方法时会自动构建，因为这里的 `__iter__` 是一个生成器函数。
- en: A full explanation of generators follows.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 紧随其后是对生成器的全面解释。
- en: How a Generator Works
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器的工作原理
- en: 'Any Python function that has the `yield` keyword in its body is a generator
    function: a function which, when called, returns a generator object. In other
    words, a generator function is a generator factory.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 任何在其主体中具有 `yield` 关键字的 Python 函数都是一个生成器函数：一个在调用时返回生成器对象的函数。换句话说，生成器函数是一个生成器工厂。
- en: Tip
  id: totrans-198
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The only syntax distinguishing a plain function from a generator function is
    the fact that the latter has a `yield` keyword somewhere in its body. Some argued
    that a new keyword like `gen` should be used instead of `def` to declare generator
    functions, but Guido did not agree. His arguments are in [PEP 255 — Simple Generators](https://fpy.li/pep255).^([5](ch17.html#idm46582405203104))
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 区分普通函数和生成器函数的唯一语法是后者的函数体中有一个`yield`关键字。有人认为应该使用新关键字`gen`来声明生成器函数，而不是`def`，但Guido不同意。他的论点在[PEP
    255 — Simple Generators](https://fpy.li/pep255)中。^([5](ch17.html#idm46582405203104))
- en: '[Example 17-6](#gen-func-ex-three-yield) shows the behavior of a simple generator
    function.^([6](ch17.html#idm46582405200304))'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 17-6](#gen-func-ex-three-yield)展示了一个简单生成器函数的行为。^([6](ch17.html#idm46582405200304))'
- en: Example 17-6\. A generator function that yields three numbers
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-6\. 一个生成三个数字的生成器函数
- en: '[PRE14]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO8-1)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO8-1)'
- en: The body of a generator function often has `yield` inside a loop, but not necessarily;
    here I just repeat `yield` three times.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数的函数体通常在循环中有`yield`，但不一定；这里我只是重复了三次`yield`。
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO8-2)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO8-2)'
- en: Looking closely, we see `gen_123` is a function object.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，我们可以看到`gen_123`是一个函数对象。
- en: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO8-3)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO8-3)'
- en: But when invoked, `gen_123()` returns a generator object.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当调用`gen_123()`时，会返回一个生成器对象。
- en: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO8-4)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO8-4)'
- en: Generator objects implement the `Iterator` interface, so they are also iterable.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器对象实现了`Iterator`接口，因此它们也是可迭代的。
- en: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO8-5)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO8-5)'
- en: We assign this new generator object to `g`, so we can experiment with it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个新的生成器对象赋给`g`，这样我们就可以对其进行实验。
- en: '[![6](assets/6.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO8-6)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO8-6)'
- en: Because `g` is an iterator, calling `next(g)` fetches the next item produced
    by `yield`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`g`是一个迭代器，调用`next(g)`会获取`yield`产生的下一个项目。
- en: '[![7](assets/7.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO8-7)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO8-7)'
- en: When the generator function returns, the generator object raises `StopIteration`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当生成器函数返回时，生成器对象会引发`StopIteration`。
- en: A generator function builds a generator object that wraps the body of the function.
    When we invoke `next()` on the generator object, execution advances to the next
    `yield` in the function body, and the `next()` call evaluates to the value yielded
    when the function body is suspended. Finally, the enclosing generator object created
    by Python raises `StopIteration` when the function body returns, in accordance
    with the `Iterator` protocol.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数构建一个包装函数体的生成器对象。当我们在生成器对象上调用`next()`时，执行会前进到函数体中的下一个`yield`，而`next()`调用会评估在函数体暂停时产生的值。最后，由Python创建的封闭生成器对象在函数体返回时引发`StopIteration`，符合`Iterator`协议。
- en: Tip
  id: totrans-218
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'I find it helpful to be rigorous when talking about values obtained from a
    generator. It’s confusing to say a generator “returns” values. Functions return
    values. Calling a generator function returns a generator. A generator yields values.
    A generator doesn’t “return” values in the usual way: the `return` statement in
    the body of a generator function causes `StopIteration` to be raised by the generator
    object. If you `return x` in the generator, the caller can retrieve the value
    of `x` from the `StopIteration` exception, but usually that is done automatically
    using the `yield from` syntax, as we’ll see in [“Returning a Value from a Coroutine”](#coro_return_sec).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现在谈论从生成器获得的值时严谨是有帮助的。说生成器“返回”值是令人困惑的。函数返回值。调用生成器函数返回一个生成器。生成器产生值。生成器不以通常的方式“返回”值：生成器函数体中的`return`语句会导致生成器对象引发`StopIteration`。如果在生成器中`return
    x`，调用者可以从`StopIteration`异常中检索到`x`的值，但通常使用`yield from`语法会自动完成，我们将在[“从协程返回值”](#coro_return_sec)中看到。
- en: '[Example 17-7](#ex_gen_ab) makes the interaction between a `for` loop and the
    body of the function more explicit.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 17-7](#ex_gen_ab)使`for`循环和函数体之间的交互更加明确。'
- en: Example 17-7\. A generator function that prints messages when it runs
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-7\. 一个在运行时打印消息的生成器函数
- en: '[PRE15]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO9-1)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO9-1)'
- en: The first implicit call to `next()` in the `for` loop at ![4](assets/4.png)
    will print `'start'` and stop at the first `yield`, producing the value `'A'`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环中对![4](assets/4.png)的第一次隐式调用`next()`将打印`'start'`并在第一个`yield`处停止，产生值`'A'`。
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO9-2)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO9-2)'
- en: The second implicit call to `next()` in the `for` loop will print `'continue'`
    and stop at the second `yield`, producing the value `'B'`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环中第二次隐式调用`next()`将打印`''continue''`并在第二个`yield`处停止，产生值`''B''`。'
- en: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO9-3)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO9-3)'
- en: The third call to `next()` will print `'end.'` and fall through the end of the
    function body, causing the generator object to raise `StopIteration`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 第三次调用`next()`将打印`'end.'`并穿过函数体的末尾，导致生成器对象引发`StopIteration`。
- en: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO9-4)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO9-4)'
- en: To iterate, the `for` machinery does the equivalent of `g = iter(gen_AB())`
    to get a generator object, and then `next(g)` at each iteration.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了迭代，`for`机制执行等效于`g = iter(gen_AB())`以获取一个生成器对象，然后在每次迭代时执行`next(g)`。
- en: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO9-5)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO9-5)'
- en: The loop prints `-->` and the value returned by `next(g)`. This output will
    appear only after the output of the `print` calls inside the generator function.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 循环打印`-->`和`next(g)`返回的值。这个输出只会在生成器函数内部的`print`调用输出之后出现。
- en: '[![6](assets/6.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO9-6)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO9-6)'
- en: The text `start` comes from `print('start')` in the generator body.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 文本`start`来自生成器体中的`print('start')`。
- en: '[![7](assets/7.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO9-7)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO9-7)'
- en: '`yield ''A''` in the generator body yields the value *A* consumed by the `for`
    loop, which gets assigned to the `c` variable and results in the output `--> A`.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器体中的`yield 'A'`产生值*A*，被`for`循环消耗，赋给变量`c`，导致输出`--> A`。
- en: '[![8](assets/8.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO9-8)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO9-8)'
- en: Iteration continues with a second call to `next(g)`, advancing the generator
    body from `yield 'A'` to `yield 'B'`. The text `continue` is output by the second
    `print` in the generator body.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代继续，第二次调用`next(g)`，将生成器体从`yield 'A'`推进到`yield 'B'`。第二个`print`在生成器体中输出`continue`。
- en: '[![9](assets/9.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO9-9)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO9-9)'
- en: '`yield ''B''` yields the value *B* consumed by the `for` loop, which gets assigned
    to the `c` loop variable, so the loop prints `--> B`.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield ''B''`产生值*B*，被`for`循环消耗，赋给循环变量`c`，因此循环打印`--> B`。'
- en: '[![10](assets/10.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO9-10)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](assets/10.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO9-10)'
- en: Iteration continues with a third call to `next(it)`, advancing to the end of
    the body of the function. The text `end.` appears in the output because of the
    third `print` in the generator body.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代继续，第三次调用`next(it)`，推进到函数体的末尾。由于生成器体中的第三个`print`，输出中出现了`end.`。
- en: '[![11](assets/11.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO9-11)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[![11](assets/11.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO9-11)'
- en: When the generator function runs to the end, the generator object raises `StopIteration`.
    The `for` loop machinery catches that exception, and the loop terminates cleanly.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当生成器函数运行到末尾时，生成器对象会引发`StopIteration`异常。`for`循环机制捕获该异常，循环干净地终止。
- en: 'Now hopefully it’s clear how `Sentence.__iter__` in [Example 17-5](#ex_sentence2)
    works: `__iter__` is a generator function which, when called, builds a generator
    object that implements the `Iterator` interface, so the `SentenceIterator` class
    is no longer needed.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在希望清楚了[示例17-5](#ex_sentence2)中的`Sentence.__iter__`是如何工作的：`__iter__`是一个生成器函数，当调用时，会构建一个实现`Iterator`接口的生成器对象，因此不再需要`SentenceIterator`类。
- en: That second version of `Sentence` is more concise than the first, but it’s not
    as lazy as it could be. Nowadays, laziness is considered a good trait, at least
    in programming languages and APIs. A lazy implementation postpones producing values
    to the last possible moment. This saves memory and may avoid wasting CPU cycles,
    too.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`Sentence`版本比第一个更简洁，但不像它可以那样懒惰。如今，懒惰被认为是一个好特性，至少在编程语言和API中是这样。懒惰的实现将产生值推迟到最后可能的时刻。这样可以节省内存，也可能避免浪费CPU周期。
- en: We’ll build lazy `Sentence` classes next.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建懒惰的`Sentence`类。
- en: Lazy Sentences
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒惰的句子
- en: The final variations of `Sentence` are lazy, taking advantage of a lazy function
    from the `re` module.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sentence`的最终变体是懒惰的，利用了`re`模块中的懒惰函数。'
- en: 'Sentence Take #4: Lazy Generator'
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 句子第四次尝试：懒惰生成器
- en: 'The `Iterator` interface is designed to be lazy: `next(my_iterator)` yields
    one item at a time. The opposite of lazy is eager: lazy evaluation and eager evaluation
    are technical terms in programming language theory.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterator`接口被设计为懒惰的：`next(my_iterator)`每次产生一个项目。懒惰的相反是急切：懒惰评估和急切评估是编程语言理论中的技术术语。'
- en: Our `Sentence` implementations so far have not been lazy because the `__init__`
    eagerly builds a list of all words in the text, binding it to the `self.words`
    attribute. This requires processing the entire text, and the list may use as much
    memory as the text itself (probably more; it depends on how many nonword characters
    are in the text). Most of this work will be in vain if the user only iterates
    over the first couple of words. If you wonder, “Is there a lazy way of doing this
    in Python?” the answer is often “Yes.”
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的`Sentence`实现并不懒惰，因为`__init__`急切地构建了文本中所有单词的列表，并将其绑定到`self.words`属性。这需要处理整个文本，而且列表可能使用的内存和文本本身一样多（可能更多；这取决于文本中有多少非单词字符）。如果用户只迭代前几个单词，大部分工作将是徒劳的。如果你想知道，“在Python中有没有一种懒惰的方法？”答案通常是“是的”。
- en: 'The `re.finditer` function is a lazy version of `re.findall`. Instead of a
    list, `re.finditer` returns a generator yielding `re.MatchObject` instances on
    demand. If there are many matches, `re.finditer` saves a lot of memory. Using
    it, our third version of `Sentence` is now lazy: it only reads the next word from
    the text when it is needed. The code is in [Example 17-8](#ex_sentence3).'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`re.finditer`函数是`re.findall`的惰性版本。`re.finditer`返回一个生成器，按需产生`re.MatchObject`实例，而不是一个列表。如果有很多匹配，`re.finditer`可以节省大量内存。使用它，我们的第三个`Sentence`版本现在是惰性的：只有在需要时才从文本中读取下一个单词。代码在[示例 17-8](#ex_sentence3)中。'
- en: 'Example 17-8\. sentence_gen2.py: `Sentence` implemented using a generator function
    calling the `re.finditer` generator function'
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '示例 17-8\. sentence_gen2.py: 使用调用`re.finditer`生成器函数实现的`Sentence`'
- en: '[PRE16]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO10-1)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO10-1)'
- en: No need to have a `words` list.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要有一个`words`列表。
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO10-2)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO10-2)'
- en: '`finditer` builds an iterator over the matches of `RE_WORD` on `self.text`,
    yielding `MatchObject` instances.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`finditer`在`self.text`上的`RE_WORD`匹配中构建一个迭代器，产生`MatchObject`实例。'
- en: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO10-3)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO10-3)'
- en: '`match.group()` extracts the matched text from the `MatchObject` instance.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`match.group()`从`MatchObject`实例中提取匹配的文本。'
- en: Generators are a great shortcut, but the code can be made even more concise
    with a generator expression.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是一个很好的快捷方式，但可以用生成器表达式进一步简化代码。
- en: 'Sentence Take #5: Lazy Generator Expression'
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第五种句子：惰性生成器表达式
- en: We can replace simple generator functions like the one in the previous `Sentence`
    class ([Example 17-8](#ex_sentence3)) with a generator expression. As a list comprehension
    builds lists, a generator expression builds generator objects. [Example 17-9](#ex_gen_ab_genexp)
    contrasts their behavior.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用生成器表达式替换前一个`Sentence`类中的简单生成器函数（[示例 17-8](#ex_sentence3)）。就像列表推导式构建列表一样，生成器表达式构建生成器对象。[示例 17-9](#ex_gen_ab_genexp)对比了它们的行为。
- en: Example 17-9\. The `gen_AB` generator function is used by a list comprehension,
    then by a generator expression
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-9\. `gen_AB`生成器函数被列表推导式使用，然后被生成器表达式使用
- en: '[PRE17]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO11-1)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO11-1)'
- en: This is the same `gen_AB` function from [Example 17-7](#ex_gen_ab).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这是与[示例 17-7](#ex_gen_ab)中相同的`gen_AB`函数。
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO11-2)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO11-2)'
- en: 'The list comprehension eagerly iterates over the items yielded by the generator
    object returned by `gen_AB()`: `''A''` and `''B''`. Note the output in the next
    lines: `start`, `continue`, `end.`'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式急切地迭代由`gen_AB()`返回的生成器对象产生的项目：`'A'`和`'B'`。注意下面行中的输出：`start`，`continue`，`end.`
- en: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO11-3)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO11-3)'
- en: This `for` loop iterates over the `res1` list built by the list comprehension.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`for`循环迭代由列表推导式构建的`res1`列表。
- en: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO11-4)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO11-4)'
- en: The generator expression returns `res2`, a generator object. The generator is
    not consumed here.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式返回`res2`，一个生成器对象。这里生成器没有被消耗。
- en: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO11-5)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO11-5)'
- en: Only when the `for` loop iterates over `res2`, this generator gets items from
    `gen_AB`. Each iteration of the `for` loop implicitly calls `next(res2)`, which
    in turn calls `next()` on the generator object returned by `gen_AB()`, advancing
    it to the next `yield`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当`for`循环迭代`res2`时，这个生成器才从`gen_AB`获取项目。`for`循环的每次迭代隐式调用`next(res2)`，进而调用`gen_AB()`返回的生成器对象上的`next()`，将其推进到下一个`yield`。
- en: '[![6](assets/6.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO11-6)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO11-6)'
- en: Note how the output of `gen_AB()` interleaves with the output of the `print`
    in the `for` loop.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`gen_AB()`的输出如何与`for`循环中的`print`输出交错。
- en: We can use a generator expression to further reduce the code in the `Sentence`
    class. See [Example 17-10](#ex_sentence4).
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用生成器表达式进一步减少`Sentence`类中的代码量。参见[示例 17-10](#ex_sentence4)。
- en: 'Example 17-10\. sentence_genexp.py: `Sentence` implemented using a generator
    expression'
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '示例 17-10\. sentence_genexp.py: 使用生成器表达式实现的`Sentence`'
- en: '[PRE18]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The only difference from [Example 17-8](#ex_sentence3) is the `__iter__` method,
    which here is not a generator function (it has no `yield`) but uses a generator
    expression to build a generator and then returns it. The end result is the same:
    the caller of `__iter__` gets a generator object.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 与[示例 17-8](#ex_sentence3)唯一的区别是`__iter__`方法，在这里不是一个生成器函数（没有`yield`），而是使用生成器表达式构建一个生成器，然后返回它。最终结果是一样的：`__iter__`的调用者得到一个生成器对象。
- en: 'Generator expressions are syntactic sugar: they can always be replaced by generator
    functions, but sometimes are more convenient. The next section is about generator
    expression usage.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式是一种语法糖：它们总是可以被生成器函数替代，但有时更加方便。下一节将介绍生成器表达式的用法。
- en: When to Use Generator Expressions
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用生成器表达式
- en: 'I used several generator expressions when implementing the `Vector` class in
    [Example 12-16](ch12.html#ex_vector_v5). Each of these methods has a generator
    expression: `__eq__`, `__hash__`, `__abs__`, `angle`, `angles`, `format`, `__add__`,
    and `__mul__`. In all those methods, a list comprehension would also work, at
    the cost of using more memory to store the intermediate list values.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现[示例12-16](ch12.html#ex_vector_v5)中的`Vector`类时，我使用了几个生成器表达式。这些方法中的每一个都有一个生成器表达式：`__eq__`、`__hash__`、`__abs__`、`angle`、`angles`、`format`、`__add__`和`__mul__`。在所有这些方法中，列表推导也可以工作，但会使用更多内存来存储中间列表值。
- en: 'In [Example 17-10](#ex_sentence4), we saw that a generator expression is a
    syntactic shortcut to create a generator without defining and calling a function.
    On the other hand, generator functions are more flexible: we can code complex
    logic with multiple statements, and we can even use them as *coroutines*, as we’ll
    see in [“Classic Coroutines”](#classic_coroutines_sec).'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例17-10](#ex_sentence4)中，我们看到生成器表达式是一种创建生成器的语法快捷方式，而无需定义和调用函数。另一方面，生成器函数更加灵活：我们可以使用多个语句编写复杂逻辑，甚至可以将它们用作*协程*，正如我们将在[“经典协程”](#classic_coroutines_sec)中看到的那样。
- en: For the simpler cases, a generator expression is easier to read at a glance,
    as the `Vector` example shows.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更简单的情况，一目了然的生成器表达式更易于阅读，就像`Vector`示例所示。
- en: 'My rule of thumb in choosing the syntax to use is simple: if the generator
    expression spans more than a couple of lines, I prefer to code a generator function
    for the sake of readability.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我在选择要使用的语法时的经验法则很简单：如果生成器表达式跨越多行，我更倾向于出于可读性考虑编写生成器函数。
- en: Syntax Tip
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法提示
- en: 'When a generator expression is passed as the single argument to a function
    or constructor, you don’t need to write a set of parentheses for the function
    call and another to enclose the generator expression. A single pair will do, like
    in the `Vector` call from the `__mul__` method in [Example 12-16](ch12.html#ex_vector_v5),
    reproduced here:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当将生成器表达式作为函数或构造函数的单个参数传递时，您无需为函数调用编写一组括号，然后再为生成器表达式加上另一组括号。只需一对即可，就像在[示例12-16](ch12.html#ex_vector_v5)中`Vector`调用`__mul__`方法时一样，如下所示：
- en: '[PRE19]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: However, if there are more function arguments after the generator expression,
    you need to enclose it in parentheses to avoid a `SyntaxError`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果在生成器表达式之后还有更多的函数参数，您需要将其括在括号中，以避免`SyntaxError`。
- en: 'The `Sentence` examples we’ve seen demonstrate generators playing the role
    of the classic Iterator pattern: retrieving items from a collection. But we can
    also use generators to yield values independent of a data source. The next section
    shows an example.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的`Sentence`示例演示了生成器扮演经典迭代器模式的角色：从集合中检索项。但是，我们也可以使用生成器产生独立于数据源的值。下一节将展示一个示例。
- en: But first, a short discussion on the overlapping concepts of *iterator* and
    *generator*.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们简要讨论*迭代器*和*生成器*之间重叠概念。
- en: An Arithmetic Progression Generator
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算术级数生成器
- en: 'The classic Iterator pattern is all about traversal: navigating some data structure.
    But a standard interface based on a method to fetch the next item in a series
    is also useful when the items are produced on the fly, instead of retrieved from
    a collection. For example, the `range` built-in generates a bounded arithmetic
    progression (AP) of integers. What if you need to generate an AP of numbers of
    any type, not only integers?'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的迭代器模式完全关乎遍历：导航某些数据结构。但是，基于一种方法来获取系列中的下一个项的标准接口在项是实时生成的情况下也很有用，而不是从集合中检索。例如，`range`内置函数生成整数的有界算术级数（AP）。如果您需要生成任何类型的数字的算术级数，而不仅仅是整数，该怎么办？
- en: '[Example 17-11](#ap_class_demo) shows a few console tests of an `ArithmeticProgression`
    class we will see in a moment. The signature of the constructor in [Example 17-11](#ap_class_demo)
    is `ArithmeticProgression(begin, step[, end])`. The complete signature of the
    `range` built-in is `range(start, stop[, step])`. I chose to implement a different
    signature because the `step` is mandatory but `end` is optional in an arithmetic
    progression. I also changed the argument names from `start/stop` to `begin/end`
    to make it clear that I opted for a different signature. In each test in [Example 17-11](#ap_class_demo),
    I call `list()` on the result to inspect the generated values.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例17-11](#ap_class_demo)展示了我们马上将看到的`ArithmeticProgression`类的一些控制台测试。[示例17-11](#ap_class_demo)中构造函数的签名是`ArithmeticProgression(begin,
    step[, end])`。`range`内置函数的完整签名是`range(start, stop[, step])`。我选择实现不同的签名，因为在算术级数中`step`是必需的，但`end`是可选的。我还将参数名称从`start/stop`更改为`begin/end`，以明确表明我选择了不同的签名。在[示例17-11](#ap_class_demo)的每个测试中，我对结果调用`list()`以检查生成的值。'
- en: Example 17-11\. Demonstration of an `ArithmeticProgression` class
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例17-11。`ArithmeticProgression`类演示
- en: '[PRE20]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that the type of the numbers in the resulting arithmetic progression follows
    the type of `begin + step`, according to the numeric coercion rules of Python
    arithmetic. In [Example 17-11](#ap_class_demo), you see lists of `int`, `float`,
    `Fraction`, and `Decimal` numbers. [Example 17-12](#ex_ap_class) lists the implementation
    of the `ArithmeticProgression` class.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，生成的算术级数中的数字类型遵循Python算术的��字强制转换规则，即`begin + step`的类型。在[示例17-11](#ap_class_demo)中，您会看到`int`、`float`、`Fraction`和`Decimal`数字的列表。[示例17-12](#ex_ap_class)列出了`ArithmeticProgression`类的实现。
- en: Example 17-12\. The `ArithmeticProgression` class
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例17-12。`ArithmeticProgression`类
- en: '[PRE21]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO12-1)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO12-1)'
- en: '`__init__` requires two arguments: `begin` and `step`; `end` is optional, if
    it’s `None`, the series will be unbounded.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__`需要两个参数：`begin`和`step`；如果`end`是`None`，则序列将是无界的。'
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO12-2)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO12-2)'
- en: Get the type of adding `self.begin` and `self.step`. For example, if one is
    `int` and the other is `float`, `result_type` will be `float`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 获取`self.begin`和`self.step`的添加类型。例如，如果一个是`int`，另一个是`float`，`result_type`将是`float`。
- en: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO12-3)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO12-3)'
- en: This line makes a `result` with the same numeric value of `self.begin`, but
    coerced to the type of the subsequent additions.^([7](ch17.html#idm46582403863072))
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行创建了一个`result`，其数值与`self.begin`相同，但被强制转换为后续加法的类型。^([7](ch17.html#idm46582403863072))
- en: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO12-4)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO12-4)'
- en: For readability, the `forever` flag will be `True` if the `self.end` attribute
    is `None`, resulting in an unbounded series.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可读性，如果`self.end`属性为`None`，`forever`标志将为`True`，导致一个无界系列。
- en: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO12-5)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO12-5)'
- en: This loop runs `forever` or until the result matches or exceeds `self.end`.
    When this loop exits, so does the function.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环运行`forever`，或直到结果匹配或超过`self.end`。当这个循环退出时，函数也会退出。
- en: '[![6](assets/6.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO12-6)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO12-6)'
- en: The current `result` is produced.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的`result`被生成。
- en: '[![7](assets/7.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO12-7)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO12-7)'
- en: The next potential result is calculated. It may never be yielded, because the
    `while` loop may terminate.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个潜在的结果被计算。它可能永远不会被产生，因为`while`循环可能终止。
- en: 'In the last line of [Example 17-12](#ex_ap_class), instead of adding `self.step`
    to the previous `result` each time around the loop, I opted to ignore the previous
    `result` and each new `result` by adding `self.begin` to `self.step` multiplied
    by `index`. This avoids the cumulative effect of floating-point errors after successive
    additions. These simple experiments make the difference clear:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 17-12](#ex_ap_class)的最后一行，我选择忽略每次循环中将`self.step`添加到前一个`result`中，而是选择忽略前一个`result`，并通过将`self.begin`添加到`self.step`乘以`index`来添加每个新的`result`。这避免了连续添加后浮点错误的累积效应。这些简单的实验使差异变得明显：
- en: '[PRE22]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `ArithmeticProgression` class from [Example 17-12](#ex_ap_class) works as
    intended, and is a another example of using a generator function to implement
    the `__iter__` special method. However, if the whole point of a class is to build
    a generator by implementing `__iter__`, we can replace the class with a generator
    function. A generator function is, after all, a generator factory.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 来自[示例 17-12](#ex_ap_class)的`ArithmeticProgression`类按预期工作，并且是使用生成器函数实现`__iter__`特殊方法的另一个示例。然而，如果一个类的整个目的是通过实现`__iter__`来构建一个生成器，我们可以用生成器函数替换类。毕竟，生成器函数本质上是一个生成器工厂。
- en: '[Example 17-13](#ex_ap_genfunc1) shows a generator function called `aritprog_gen`
    that does the same job as `ArithmeticProgression` but with less code. The tests
    in [Example 17-11](#ap_class_demo) all pass if you just call `aritprog_gen` instead
    of `ArithmeticProgression`.^([8](ch17.html#idm46582403808176))'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 17-13](#ex_ap_genfunc1)展示了一个名为`aritprog_gen`的生成器函数，它与`ArithmeticProgression`执行相同的工作，但代码更少。如果只调用`aritprog_gen`而不是`ArithmeticProgression`，则[示例 17-11](#ap_class_demo)中的所有测试都会通过。^([8](ch17.html#idm46582403808176))'
- en: Example 17-13\. The `aritprog_gen` generator function
  id: totrans-321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-13\. `aritprog_gen`生成器函数
- en: '[PRE23]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[Example 17-13](#ex_ap_genfunc1) is elegant, but always remember: there are
    plenty of ready-to-use generators in the standard library, and the next section
    will show a shorter implementation using the `itertools` module.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 17-13](#ex_ap_genfunc1) 非常优雅，但请记住：标准库中有大量现成的生成器可供使用，下一节将展示使用`itertools`模块的更短实现。'
- en: Arithmetic Progression with itertools
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`itertools`的算术进度
- en: The `itertools` module in Python 3.10 has 20 generator functions that can be
    combined in a variety of interesting ways.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.10中的`itertools`模块有20个生成器函数，可以以各种有趣的方式组合。
- en: 'For example, the `itertools.count` function returns a generator that yields
    numbers. Without arguments, it yields a series of integers starting with `0`.
    But you can provide optional `start` and `step` values to achieve a result similar
    to our `aritprog_gen` functions:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`itertools.count` 函数返回一个生成器，产生数字。没有参数时，它产生以`0`开头的一系列整数。但是你可以提供可选的`start`和`step`值来实现类似于我们的`aritprog_gen`函数的结果：
- en: '[PRE24]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Warning
  id: totrans-328
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: '`itertools.count` never stops, so if you call `list(count())`, Python will
    try to build a `list` that would fill all the memory chips ever made. In practice,
    your machine will become very grumpy long before the call fails.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools.count`永远不会停止，因此如果调用`list(count())`，Python将尝试构建一个填满所有已制造的内存芯片的`list`。实际上，在调用失败之前，您的机器会变得非常不高兴。'
- en: 'On the other hand, there is the `itertools.takewhile` function: it returns
    a generator that consumes another generator and stops when a given predicate evaluates
    to `False`. So we can combine the two and write this:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有`itertools.takewhile`函数：它返回一个消耗另一个生成器并在给定谓词评估为`False`时停止的生成器。因此，我们可以将两者结合起来写成这样：
- en: '[PRE25]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Leveraging `takewhile` and `count`, [Example 17-14](#ex_almost_aritprog) is
    even more concise.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 利用`takehwhile`和`count`，[示例 17-14](#ex_almost_aritprog)更加简洁。
- en: 'Example 17-14\. aritprog_v3.py: this works like the previous `aritprog_gen`
    functions'
  id: totrans-333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-14\. aritprog_v3.py：这与之前的`aritprog_gen`函数相同
- en: '[PRE26]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that `aritprog_gen` in [Example 17-14](#ex_almost_aritprog) is not a generator
    function: it has no `yield` in its body. But it returns a generator, just as a
    generator function does.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[示例 17-14](#ex_almost_aritprog)中的`aritprog_gen`不是一个生成器函数：它的主体中没有`yield`。但它返回一个生成器，就像生成器函数一样。
- en: However, recall that `itertools.count` adds the `step` repeatedly, so the floating-point
    series it produces are not as precise as [Example 17-13](#ex_ap_genfunc1).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请记住，`itertools.count`会重复添加`step`，因此它生成的浮点数序列不像[示例17-13](#ex_ap_genfunc1)那样精确。
- en: 'The point of [Example 17-14](#ex_almost_aritprog) is: when implementing generators,
    know what is available in the standard library, otherwise there’s a good chance
    you’ll reinvent the wheel. That’s why the next section covers several ready-to-use
    generator functions.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例17-14](#ex_almost_aritprog)的要点是：在实现生成器时，要了解标准库中提供了什么，否则很可能会重复造轮子。这就是为什么下一节涵盖了几个可直接使用的生成器函数。'
- en: Generator Functions in the Standard Library
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准库中的生成器函数
- en: The standard library provides many generators, from plain-text file objects
    providing line-by-line iteration, to the awesome [`os.walk`](https://fpy.li/17-12)
    function, which yields filenames while traversing a directory tree, making recursive
    filesystem searches as simple as a `for` loop.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了许多生成器，从提供逐行迭代的纯文本文件对象，到令人惊叹的[`os.walk`](https://fpy.li/17-12)函数，该函数在遍历目录树时产生文件名，使递归文件系统搜索就像一个`for`循环一样简单。
- en: The `os.walk` generator function is impressive, but in this section I want to
    focus on general-purpose functions that take arbitrary iterables as arguments
    and return generators that yield selected, computed, or rearranged items. In the
    following tables, I summarize two dozen of them, from the built-in, `itertools`,
    and `functools` modules. For convenience, I grouped them by high-level functionality,
    regardless of where they are defined.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.walk`生成器函数令人印象深刻，但在本节中，我想专注于以任意可迭代对象作为参数并返回生成器的通用函数，这些生成器产生选定的、计算的或重新排列的项目。在下面的表格中，我总结了两打这样的函数，来自内置的`itertools`和`functools`模块。为方便起见，我根据高级功能对它们进行了分组，而不管它们在哪里定义。'
- en: 'The first group contains the filtering generator functions: they yield a subset
    of items produced by the input iterable, without changing the items themselves.
    Like `takewhile`, most functions listed in [Table 17-1](#filter_genfunc_tbl) take
    a `predicate`, which is a one-argument Boolean function that will be applied to
    each item in the input to determine whether the item is included in the output.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组包含过滤生成器函数：它们产生输入可迭代对象生成的项目子集，而不改变项目本身。像`takewhile`一样，[表17-1](#filter_genfunc_tbl)中列出的大多数函数都接受一个`predicate`，这是一个一参数布尔函数，将应用于输入中的每个项目，以确定是否将项目包含在输出中。
- en: Table 17-1\. Filtering generator functions
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 表17-1\. 过滤生成器函数
- en: '| Module | Function | Description |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| 模块 | 函数 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `itertools` | `compress(it, selector_it)` | Consumes two iterables in parallel;
    yields items from `it` whenever the corresponding item in `selector_it` is truthy
    |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| `itertools` | `compress(it, selector_it)` | 并行消耗两个可迭代对象；每当`selector_it`中对应的项目为真时，从`it`中产生项目
    |'
- en: '| `itertools` | `dropwhile(predicate, it)` | Consumes `it`, skipping items
    while `predicate` computes truthy, then yields every remaining item (no further
    checks are made) |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| `itertools` | `dropwhile(predicate, it)` | 消耗`it`，跳过`predicate`计算为真时的项目，然后产生所有剩余项目（不再进行进一步检查）
    |'
- en: '| (built-in) | `filter(predicate, it)` | Applies `predicate` to each item of
    `iterable`, yielding the item if `predicate(item)` is truthy; if `predicate` is
    `None`, only truthy items are yielded |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| (内置) | `filter(predicate, it)` | 对`iterable`的每个项目应用`predicate`，如果`predicate(item)`为真，则产生该项目；如果`predicate`为`None`，则只产生真值项目
    |'
- en: '| `itertools` | `filterfalse(predicate, it)` | Same as `filter`, with the `predicate`
    logic negated: yields items whenever `predicate` computes falsy |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| `itertools` | `filterfalse(predicate, it)` | 与`filter`相同，但`predicate`逻辑取反：每当`predicate`计算为假时产生项目
    |'
- en: '| `itertools` | `islice(it, stop) or islice(it, start, stop, step=1)` | Yields
    items from a slice of `it`, similar to `s[:stop]` or `s[start:stop:step]` except
    `it` can be any iterable, and the operation is lazy |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| `itertools` | `islice(it, stop) or islice(it, start, stop, step=1)` | 从`it`的切片中产生项目，类似于`s[:stop]`或`s[start:stop:step]`，除了`it`可以是任何可迭代对象，且操作是惰性的
    |'
- en: '| `itertools` | `takewhile(predicate, it)` | Yields items while `predicate`
    computes truthy, then stops and no further checks are made |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| `itertools` | `takewhile(predicate, it)` | 当`predicate`计算为真时产生项目，然后停止，不再进行进一步检查
    |'
- en: The console listing in [Example 17-15](#demo_filter_genfunc) shows the use of
    all the functions in [Table 17-1](#filter_genfunc_tbl).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例17-15](#demo_filter_genfunc)中的控制台列表显示了[表17-1](#filter_genfunc_tbl)中所有函数的使用。'
- en: Example 17-15\. Filtering generator functions examples
  id: totrans-352
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例17-15\. 过滤生成器函数示例
- en: '[PRE27]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The next group contains the mapping generators: they yield items computed from
    each individual item in the input iterable—or iterables, in the case of `map`
    and `starmap`.^([9](ch17.html#idm46582403237584)) The generators in [Table 17-2](#mapping_genfunc_tbl)
    yield one result per item in the input iterables. If the input comes from more
    than one iterable, the output stops as soon as the first input iterable is exhausted.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 下一组包含映射生成器：它们产生从输入可迭代对象的每个单独项目计算得到的项目，或者在`map`和`starmap`的情况下，产生自输入可迭代对象的项目。[表17-2](#mapping_genfunc_tbl)中的生成器每个输入可迭代对象产生一个结果。如���输入来自多个可迭代对象，则一旦第一个输入可迭代对象耗尽，输出就会停止。
- en: Table 17-2\. Mapping generator functions
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 表17-2\. 映射生成器函数
- en: '| Module | Function | Description |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| 模块 | 函数 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `itertools` | `accumulate(it, [func])` | Yields accumulated sums; if `func`
    is provided, yields the result of applying it to the first pair of items, then
    to the first result and next item, etc. |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| `itertools` | `accumulate(it, [func])` | 产生累积和；如果提供了`func`，则产生将其应用于第一对项目的结果，然后应用于第一个结果和下一个项目等的结果
    |'
- en: '| (built-in) | `enumerate(iterable, start=0)` | Yields 2-tuples of the form
    `(index, item)`, where `index` is counted from `start`, and `item` is taken from
    the `iterable` |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| (内置) | `enumerate(iterable, start=0)` | 产生形式为`(index, item)`的2元组，其中`index`从`start`计数，`item`取自`iterable`
    |'
- en: '| (built-in) | `map(func, it1, [it2, …, itN])` | Applies `func` to each item
    of `it`, yielding the result; if N iterables are given, `func` must take N arguments
    and the iterables will be consumed in parallel |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| (内置) | `map(func, it1, [it2, …, itN])` | 将`func`应用于`it`的每个项目，产生结果；如果给出了N个可迭代对象，则`func`必须接受N个参数，并且可迭代对象将并行消耗
    |'
- en: '| `itertools` | `starmap(func, it)` | Applies `func` to each item of `it`,
    yielding the result; the input iterable should yield iterable items `iit`, and
    `func` is applied as `func(*iit)` |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| `itertools` | `starmap(func, it)` | 将`func`应用于`it`的每个项目，产生结果；输入可迭代对象应产生可迭代对象`iit`，并且`func`被应用为`func(*iit)`
    |'
- en: '[Example 17-16](#demo_accumulate_genfunc) demonstrates some uses of `itertools.accumulate`.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 17-16](#demo_accumulate_genfunc)演示了`itertools.accumulate`的一些用法。'
- en: Example 17-16\. `itertools.accumulate` generator function examples
  id: totrans-363
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例17-16。`itertools.accumulate`生成器函数示例
- en: '[PRE28]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO13-1)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO13-1)'
- en: Running sum.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 运行总和。
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO13-2)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO13-2)'
- en: Running minimum.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 运行最小值。
- en: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO13-3)'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO13-3)'
- en: Running maximum.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 运行最大值。
- en: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO13-4)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO13-4)'
- en: Running product.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 运行乘积。
- en: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO13-5)'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO13-5)'
- en: Factorials from `1!` to `10!`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 从`1!`到`10!`的阶乘。
- en: The remaining functions of [Table 17-2](#mapping_genfunc_tbl) are shown in [Example 17-17](#demo_mapping_genfunc).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '[Table 17-2](#mapping_genfunc_tbl)的其余函数显示在[Example 17-17](#demo_mapping_genfunc)中。'
- en: Example 17-17\. Mapping generator function examples
  id: totrans-376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例17-17。映射生成器函数示例
- en: '[PRE29]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO14-1)'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO14-1)'
- en: Number the letters in the word, starting from `1`.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 从`1`开始对单词中的字母编号。
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO14-2)'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO14-2)'
- en: Squares of integers from `0` to `10`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 从`0`到`10`的整数的平方。
- en: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO14-3)'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO14-3)'
- en: 'Multiplying numbers from two iterables in parallel: results stop when the shortest
    iterable ends.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 并行从两个可迭代对象中相乘的数字：当最短的可迭代���象结束时，结果停止。
- en: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO14-4)'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO14-4)'
- en: This is what the `zip` built-in function does.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`zip`内置函数的作用。
- en: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO14-5)'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO14-5)'
- en: Repeat each letter in the word according to its place in it, starting from `1`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 根据���词中的位置重复��个字母，从`1`开始。
- en: '[![6](assets/6.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO14-6)'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO14-6)'
- en: Running average.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 运行平均值。
- en: Next, we have the group of merging generators—all of these yield items from
    multiple input iterables. `chain` and `chain.from_iterable` consume the input
    iterables sequentially (one after the other), while `product`, `zip`, and `zip_longest`
    consume the input iterables in parallel. See [Table 17-3](#merging_genfunc_tbl).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有合并生成器组 - 所有这些都从多个输入可迭代对象中产生项目。`chain`和`chain.from_iterable`按顺序消耗输入可迭代对象（一个接一个地），而`product`、`zip`和`zip_longest`并行消耗输入可迭代对象。参见[Table 17-3](#merging_genfunc_tbl)。
- en: Table 17-3\. Generator functions that merge multiple input iterables
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: Table 17-3。合并多个输入可迭代对象的生成器函数
- en: '| Module | Function | Description |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| 模块 | 函数 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `itertools` | `chain(it1, …, itN)` | Yields all items from `it1`, then from
    `it2`, etc., seamlessly |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| `itertools` | `chain(it1, …, itN)` | 从`it1`，然后从`it2`等无缝地产生所有项目 |'
- en: '| `itertools` | `chain.from_iterable(it)` | Yields all items from each iterable
    produced by `it`, one after the other, seamlessly; `it` will be an iterable where
    the items are also iterables, for example, a list of tuples |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| `itertools` | `chain.from_iterable(it)` | 从`it`生成的每个可迭代对象中产生所有项目，一个接一个地无缝地；`it`将是一个可迭代对象，其中项目也是可迭代对象，例如，元组列表
    |'
- en: '| `itertools` | `product(it1, …, itN, repeat=1)` | Cartesian product: yields
    N-tuples made by combining items from each input iterable, like nested `for` loops
    could produce; `repeat` allows the input iterables to be consumed more than once
    |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| `itertools` | `product(it1, …, itN, repeat=1)` | 笛卡尔积：通过组合来自每个输入可迭代对象的项目生成N元组，就像嵌套的`for`循环可以产生的那样；`repeat`允许多次消耗输入可迭代对象
    |'
- en: '| (built-in) | `zip(it1, …, itN, strict=False)` | Yields N-tuples built from
    items taken from the iterables in parallel, silently stopping when the first iterable
    is exhausted, unless `strict=True` is given^([a](ch17.html#idm46582402726080))
    |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| (内置) | `zip(it1, …, itN, strict=False)` | 从并行获取的每个项目构建N元组，默默地在第一个可迭代对象耗尽时停止，除非给出`strict=True`^([a](ch17.html#idm46582402726080))
    |'
- en: '| `itertools` | `zip_longest(it1, …, itN, fillvalue=None)` | Yields N-tuples
    built from items taken from the iterables in parallel, stopping only when the
    last iterable is exhausted, filling the blanks with the `fillvalue` |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| `itertools` | `zip_longest(it1, …, itN, fillvalue=None)` | 从并行获取的每个项目构建N元组，仅在最后一个可迭代对象耗尽时停止，用`fillvalue`填充空白
    |'
- en: '| ^([a](ch17.html#idm46582402726080-marker)) The `strict` keyword-only argument
    is new in Python 3.10\. When `strict=True`, `ValueError` is raised if any iterable
    has a different length. The default is `False`, for backward compatibility. |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch17.html#idm46582402726080-marker)) `strict`关键字参数是Python 3.10中的新参数。当`strict=True`时，如果任何可迭代对象的长度不同，则会引发`ValueError`。默认值为`False`，以确保向后兼容性。
    |'
- en: '[Example 17-18](#demo_merging_genfunc) shows the use of the `itertools.chain`
    and `zip` generator functions and their siblings. Recall that the `zip` function
    is named after the zip fastener or zipper (no relation to compression). Both `zip`
    and `itertools.zip_longest` were introduced in [“The Awesome zip”](ch12.html#zip_box).'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 17-18](#demo_merging_genfunc)展示了`itertools.chain`和`zip`生成器函数及其相关函数的使用。请记住，`zip`函数是以拉链拉链（与压缩无关）命名的。`zip`和`itertools.zip_longest`都是在[“神奇的zip”](ch12.html#zip_box)中引入的。'
- en: Example 17-18\. Merging generator function examples
  id: totrans-401
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-18\. 合并生成器函数示例
- en: '[PRE30]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO15-1)'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO15-1)'
- en: '`chain` is usually called with two or more iterables.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用两个或更多可迭代对象调用`chain`。
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO15-2)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO15-2)'
- en: '`chain` does nothing useful when called with a single iterable.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用单个可迭代对象调用`chain`时，它不会产生任何有用的效果。
- en: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO15-3)'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO15-3)'
- en: But `chain.from_iterable` takes each item from the iterable, and chains them
    in sequence, as long as each item is itself iterable.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 但是`chain.from_iterable`从可迭代对象中获取每个项目，并按顺序链接它们，只要每个项目本身是可迭代的。
- en: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO15-4)'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO15-4)'
- en: Any number of iterables can be consumed by `zip` in parallel, but the generator
    always stops as soon as the first iterable ends. In Python ≥ 3.10, if the `strict=True`
    argument is given and an iterable ends before the others, `ValueError` is raised.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip`可以并行消耗任意数量的可迭代对象，但是生成器总是在第一个可迭代对象结束时停止。在Python ≥ 3.10中，如果给定`strict=True`参数并且一个可迭代对象在其他可迭代对象之前结束，则会引发`ValueError`。'
- en: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO15-5)'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO15-5)'
- en: '`itertools.zip_longest` works like `zip`, except it consumes all input iterables
    to the end, padding output tuples with `None`, as needed.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools.zip_longest`的工作原理类似于`zip`，只是它会消耗所有输入的可迭代对象，根据需要用`None`填充输出元组。'
- en: '[![6](assets/6.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO15-6)'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO15-6)'
- en: The `fillvalue` keyword argument specifies a custom padding value.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`fillvalue`关键字参数指定自定义填充值。'
- en: The `itertools.product` generator is a lazy way of computing Cartesian products,
    which we built using list comprehensions with more than one `for` clause in [“Cartesian
    Products”](ch02.html#cartesian_product_sec). Generator expressions with multiple
    `for` clauses can also be used to produce Cartesian products lazily. [Example 17-19](#demo_product_genfunc)
    demonstrates `itertools.product`.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools.product`生成器是计算笛卡尔积的一种懒惰方式，我们在[“笛卡尔积”](ch02.html#cartesian_product_sec)中使用了多个`for`子句的列表推导式构建。具有多个`for`子句的生成器表达式也可以用于懒惰地生成笛卡尔积。[示例 17-19](#demo_product_genfunc)演示了`itertools.product`。'
- en: Example 17-19\. `itertools.product` generator function examples
  id: totrans-416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-19\. `itertools.product`生成器函数示例
- en: '[PRE31]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO16-1)'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO16-1)'
- en: The Cartesian product of a `str` with three characters and a `range` with two
    integers yields six tuples (because `3 * 2` is `6`).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有三个字符的`str`和一个具有两个整数的`range`的笛卡尔积产生六个元组（因为`3 * 2`是`6`）。
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO16-2)'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO16-2)'
- en: The product of two card ranks (`'AK'`) and four suits is a series of eight tuples.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 两个卡片等级（`'AK'`）和四个花色的乘积是一系列八元组。
- en: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO16-3)'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO16-3)'
- en: Given a single iterable, `product` yields a series of one-tuples—not very useful.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个单个可迭代对象，`product`生成一系列单元组，不是很有用。
- en: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO16-4)'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO16-4)'
- en: The `repeat=N` keyword argument tells the product to consume each input iterable
    `N` times.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat=N`关键字参数告诉产品消耗每个输入可迭代对象`N`次。'
- en: Some generator functions expand the input by yielding more than one value per
    input item. They are listed in [Table 17-4](#expanding_genfunc_tbl).
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 一些生成器函数通过产生每个输入项多个值来扩展输入。它们在[表17-4](#expanding_genfunc_tbl)中列出。
- en: Table 17-4\. Generator functions that expand each input item into multiple output
    items
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 表17-4\. 将每个输入项扩展为多个输出项的生成器函数
- en: '| Module | Function | Description |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| 模块 | 函数 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `itertools` | `combinations(it, out_len)` | Yields combinations of `out_len`
    items from the items yielded by `it` |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| `itertools` | `combinations(it, out_len)` | 从`it`产生的项目中产生`out_len`个项目的组合
    |'
- en: '| `itertools` | `combinations_with_replacement(it, out_len)` | Yields combinations
    of `out_len` items from the items yielded by `it`, including combinations with
    repeated items |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| `itertools` | `combinations_with_replacement(it, out_len)` | 从`it`产生的项目中产生`out_len`个项目的组合，包括重复的项目的组合
    |'
- en: '| `itertools` | `count(start=0, step=1)` | Yields numbers starting at `start`,
    incremented by `step`, indefinitely |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| `itertools` | `count(start=0, step=1)` | 从`start`开始，按`step`递增，无限地产生数字 |'
- en: '| `itertools` | `cycle(it)` | Yields items from `it`, storing a copy of each,
    then yields the entire sequence repeatedly, indefinitely |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| `itertools` | `cycle(it)` | 从`it`中产生项目，存储每个项目的副本，然后无限地重复产生整个序列 |'
- en: '| `itertools` | `pairwise(it)` | Yields successive overlapping pairs taken
    from the input iterable^([a](ch17.html#idm46582402272512)) |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| `itertools` | `pairwise(it)` | 从输入可迭代对象中获取连续的重叠对^([a](ch17.html#idm46582402272512))
    |'
- en: '| `itertools` | `permutations(it, out_len=None)` | Yields permutations of `out_len`
    items from the items yielded by `it`; by default, `out_len` is `len(list(it))`
    |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| `itertools` | `permutations(it, out_len=None)` | 从`it`产生的项目中产生`out_len`个项目的排列；默认情况下，`out_len`为`len(list(it))`
    |'
- en: '| `itertools` | `repeat(item, [times])` | Yields the given item repeatedly,
    indefinitely unless a number of `times` is given |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| `itertools` | `repeat(item, [times])` | 重复产生给定的项目，除非给定了`times`次数 |'
- en: '| ^([a](ch17.html#idm46582402272512-marker)) `itertools.pairwise` was added
    in Python 3.10. |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch17.html#idm46582402272512-marker)) `itertools.pairwise`在Python 3.10中添加。
    |'
- en: 'The `count` and `repeat` functions from `itertools` return generators that
    conjure items out of nothing: neither of them takes an iterable as input. We saw
    `itertools.count` in [“Arithmetic Progression with itertools”](#ap_itertools_sec).
    The `cycle` generator makes a backup of the input iterable and yields its items
    repeatedly. [Example 17-20](#demo_count_repeat_genfunc) illustrates the use of
    `count`, `cycle`, `pairwise`, and `repeat`.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools`中的`count`和`repeat`函数返回生成器，从无中生有地产生项目：它们都不接受可迭代对象作为输入。我们在[“使用itertools进行算术进度”](#ap_itertools_sec)中看到了`itertools.count`。`cycle`生成器备份输入可迭代对象并重复产生其项目。[示例17-20](#demo_count_repeat_genfunc)演示了`count`、`cycle`、`pairwise`和`repeat`的用法。'
- en: Example 17-20\. `count`, `cycle`, `pairwise`, and `repeat`
  id: totrans-439
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例17-20。`count`、`cycle`、`pairwise`和`repeat`
- en: '[PRE32]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO17-1)'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO17-1)'
- en: Build a `count` generator `ct`.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个`count`生成器`ct`。
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO17-2)'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO17-2)'
- en: Retrieve the first item from `ct`.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 从`ct`中检索第一个项目。
- en: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO17-3)'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO17-3)'
- en: I can’t build a `list` from `ct`, because `ct` never stops, so I fetch the next
    three items.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法从`ct`中构建一个`list`，因为`ct`永远不会停止，所以我获取了接下来的三个项目。
- en: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO17-4)'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO17-4)'
- en: I can build a `list` from a `count` generator if it is limited by `islice` or
    `takewhile`.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`count`生成器由`islice`或`takewhile`限制，我可以构建一个`list`。
- en: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO17-5)'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO17-5)'
- en: Build a `cycle` generator from `'ABC'` and fetch its first item, `'A'`.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 从'ABC'构建一个`cycle`生成器，并获取其第一个项目，'A'。
- en: '[![6](assets/6.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO17-6)'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO17-6)'
- en: A `list` can only be built if limited by `islice`; the next seven items are
    retrieved here.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 只有通过`islice`限制，才能构建一个`list`；这里检索了接下来的七个项目。
- en: '[![7](assets/7.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO17-7)'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO17-7)'
- en: For each item in the input, `pairwise` yields a 2-tuple with that item and the
    next—if there is a next item. Available in Python ≥ 3.10.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 对于输入中的每个项目，`pairwise`产生一个包含该项目和下一个项目（如果有下一个项目）的2元组。在Python ≥ 3.10中可用。
- en: '[![8](assets/8.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO17-8)'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO17-8)'
- en: Build a `repeat` generator that will yield the number `7` forever.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个`repeat`生成器，永远产生数字`7`。
- en: '[![9](assets/9.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO17-9)'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO17-9)'
- en: 'A `repeat` generator can be limited by passing the `times` argument: here the
    number `8` will be produced `4` times.'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递`times`参数，可以限制`repeat`生成器：这里数字`8`将产生`4`次。
- en: '[![10](assets/10.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO17-10)'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](assets/10.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO17-10)'
- en: 'A common use of `repeat`: providing a fixed argument in `map`; here it provides
    the `5` multiplier.'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat`的常见用法：在`map`中提供一个固定参数；这里提供了`5`的倍数。'
- en: The `combinations`, `combinations_with_replacement`, and `permutations` generator
    functions—together with `product`—are called the *combinatorics generators* in
    the [`itertools` documentation page](https://fpy.li/17-13). There is a close relationship
    between `itertools.product` and the remaining *combinatoric* functions as well,
    as [Example 17-21](#demo_conbinatoric_genfunc) shows.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '`combinations`、`combinations_with_replacement`和`permutations`生成器函数——连同`product`——在[`itertools`文档页面](https://fpy.li/17-13)中被称为*组合生成器*。`itertools.product`与其余*组合*函数之间也有密切关系，正如[示例17-21](#demo_conbinatoric_genfunc)所示。'
- en: Example 17-21\. Combinatoric generator functions yield multiple values per input
    item
  id: totrans-462
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例17-21。组合生成器函数从每个输入项目中产生多个值
- en: '[PRE33]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO18-1)'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO18-1)'
- en: All combinations of `len()==2` from the items in `'ABC'`; item ordering in the
    generated tuples is irrelevant (they could be sets).
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 从'ABC'中的项目中生成`len()==2`的所有组合；生成的元组中的项目顺序无关紧要（它们可以是集合）。
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO18-2)'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO18-2)'
- en: All combinations of `len()==2` from the items in `'ABC'`, including combinations
    with repeated items.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 从'ABC'中的项目中生成`len()==2`的所有组合，包括重复项目的组合。
- en: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO18-3)'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO18-3)'
- en: All permutations of `len()==2` from the items in `'ABC'`; item ordering in the
    generated tuples is relevant.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 从'ABC'中的项目中生成`len()==2`的所有排列；生成的元组中的项目顺序是相关的。
- en: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO18-4)'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO18-4)'
- en: Cartesian product from `'ABC'` and `'ABC'` (that’s the effect of `repeat=2`).
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 从'ABC'和'ABC'中的笛卡尔积（这是`repeat=2`的效果）。
- en: 'The last group of generator functions we’ll cover in this section are designed
    to yield all items in the input iterables, but rearranged in some way. Here are
    two functions that return multiple generators: `itertools.groupby` and `itertools.tee`.
    The other generator function in this group, the `reversed` built-in, is the only
    one covered in this section that does not accept any iterable as input, but only
    sequences. This makes sense: because `reversed` will yield the items from last
    to first, it only works with a sequence with a known length. But it avoids the
    cost of making a reversed copy of the sequence by yielding each item as needed.
    I put the `itertools.product` function together with the *merging* generators
    in [Table 17-3](#merging_genfunc_tbl) because they all consume more than one iterable,
    while the generators in [Table 17-5](#expanding_genfunc_tbl2) all accept at most
    one input iterable.'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中介绍的最后一组生成器函数旨在以某种方式重新排列输入可迭代对象中的所有项目。以下是返回多个生成器的两个函数：`itertools.groupby`和`itertools.tee`。该组中的另一个生成器函数，`reversed`内置函数，是本节中唯一一个不接受任何可迭代对象作为输入的函数，而只接受序列。这是有道理的：因为`reversed`将从最后到第一个产生项目，所以它只能与已知长度的序列一起使用。但它通过根据需要产生每个项目来避免制作反转副本的成本。我将`itertools.product`函数与[表17-3](#merging_genfunc_tbl)中的*合并*生成器放在一起，因为它们都消耗多个可迭代对象，而[表17-5](#expanding_genfunc_tbl2)中的生成器最多只接受一个输入可迭代对象。
- en: Table 17-5\. Rearranging generator functions
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 表17-5\. 重新排列生成器函数
- en: '| Module | Function | Description |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| 模块 | 函数 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `itertools` | `groupby(it, key=None)` | Yields 2-tuples of the form `(key,
    group)`, where `key` is the grouping criterion and `group` is a generator yielding
    the items in the group |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| `itertools` | `groupby(it, key=None)` | 产生形式为`(key, group)`的2元组，其中`key`是分组标准，`group`是产生组中项目的生成器
    |'
- en: '| (built-in) | `reversed(seq)` | Yields items from `seq` in reverse order,
    from last to first; `seq` must be a sequence or implement the `__reversed__` special
    method |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| (内置) | `reversed(seq)` | 以从最后到第一个的顺序从`seq`中产生项目；`seq`必须是一个序列或实现`__reversed__`特殊方法
    |'
- en: '| `itertools` | `tee(it, n=2)` | Yields a tuple of *n* generators, each yielding
    the items of the input iterable independently |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '| `itertools` | `tee(it, n=2)` | 产生一个元组，其中包含*n*个独立产生输入可迭代对象的项目的生成器 |'
- en: '[Example 17-22](#demo_groupby_reversed_genfunc) demonstrates the use of `itertools.groupby`
    and the `reversed` built-in. Note that `itertools.groupby` assumes that the input
    iterable is sorted by the grouping criterion, or at least that the items are clustered
    by that criterion—even if not completely sorted. Tech reviewer Miroslav Šedivý
    suggested this use case: you can sort the `datetime` objects chronologically,
    then `groupby` weekday to get a group of Monday data, followed by Tuesday data,
    etc., and then by Monday (of the next week) again, and so on.'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 17-22](#demo_groupby_reversed_genfunc)演示了`itertools.groupby`和`reversed`内置函数的使用。请注意，`itertools.groupby`假定输入可迭代对象按分组标准排序，或者至少按照该标准对项目进行了分组，即使不完全排序。技术审阅者Miroslav
    Šedivý建议了这种用例：您可以按时间顺序对`datetime`对象进行排序，然后按星期几进行分组，以获取星期一数据组，接着是星期二数据组，依此类推，然后再次是下周的星期一数据组，依此类推。'
- en: Example 17-22\. `itertools.groupby`
  id: totrans-480
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-22\. `itertools.groupby`
- en: '[PRE34]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO19-1)'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO19-1)'
- en: '`groupby` yields tuples of `(key, group_generator)`.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupby`产生`(key, group_generator)`的元组。'
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO19-2)'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO19-2)'
- en: 'Handling `groupby` generators involves nested iteration: in this case, the
    outer `for` loop and the inner `list` constructor.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 处理`groupby`生成器涉及嵌套迭代：在这种情况下，外部`for`循环和内部`list`构造函数。
- en: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO19-3)'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO19-3)'
- en: Sort `animals` by length.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 按长度对`animals`进行排序。
- en: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO19-4)'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO19-4)'
- en: Again, loop over the `key` and `group` pair, to display the `key` and expand
    the `group` into a `list`.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 再次循环遍历`key`和`group`对，以显示`key`并将`group`扩展为`list`。
- en: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO19-5)'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO19-5)'
- en: Here the `reverse` generator iterates over `animals` from right to left.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`reverse`生成器从右到左迭代`animals`。
- en: 'The last of the generator functions in this group is `iterator.tee`, which
    has a unique behavior: it yields multiple generators from a single input iterable,
    each yielding every item from the input. Those generators can be consumed independently,
    as shown in [Example 17-23](#demo_tee_genfunc).'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 该组中最后一个生成器函数是`iterator.tee`，具有独特的行为：它从单个输入可迭代对象产生多个生成器，每个生成器都从输入中产生每个项目。这些生成器可以独立消耗，如[示例 17-23](#demo_tee_genfunc)所示。
- en: Example 17-23\. `itertools.tee` yields multiple generators, each yielding every
    item of the input generator
  id: totrans-493
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例17-23\. `itertools.tee`生成多个生成器，每个生成器都生成输入生成器的每个项目
- en: '[PRE35]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Note that several examples in this section used combinations of generator functions.
    This is a great feature of these functions: because they take generators as arguments
    and return generators, they can be combined in many different ways.'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，本节中的几个示例使用了生成器函数的组合。这些函数的一个很好的特性是：因为它们接受生成器作为参数并返回生成器，所以它们可以以许多不同的方式组合在一起。
- en: Now we’ll review another group of iterable-savvy functions in the standard library.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将回顾标准库中另一组对可迭代对象敏感的函数。
- en: Iterable Reducing Functions
  id: totrans-497
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可迭代对象减少函数
- en: 'The functions in [Table 17-6](#tbl_iter_reducing) all take an iterable and
    return a single result. They are known as “reducing,” “folding,” or “accumulating”
    functions. We can implement every one of the built-ins listed here with `functools.reduce`,
    but they exist as built-ins because they address some common use cases more easily.
    A longer explanation about `functools.reduce` appeared in [“Vector Take #4: Hashing
    and a Faster ==”](ch12.html#multi_hashing).'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '[表17-6](#tbl_iter_reducing)中的函数都接受一个可迭代对象并返回一个单一结果。它们被称为“reducing”、“folding”或“accumulating”函数。我们可以使用`functools.reduce`实现这里列出的每一个内置函数，但它们作为内置函数存在是因为它们更容易地解决了一些常见的用例。有关`functools.reduce`的更长解释出现在[“向量取#4：哈希和更快的==”](ch12.html#multi_hashing)中。'
- en: 'In the case of `all` and `any`, there is an important optimization `functools.reduce`
    does not support: `all` and `any` short-circuit—i.e., they stop consuming the
    iterator as soon as the result is determined. See the last test with `any` in
    [Example 17-24](#all_any_demo).'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在`all`和`any`的情况下，有一个重要的优化`functools.reduce`不支持：`all`和`any`短路——即，它们在确定结果后立即停止消耗迭代器。请参见[示例17-24](#all_any_demo)中`any`的最后一个测试。
- en: Table 17-6\. Built-in functions that read iterables and return single values
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 表17-6\. 读取可迭代对象并返回单个值的内置函数
- en: '| Module | Function | Description |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '| 模块 | 函数 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| (built-in) | `all(it)` | Returns `True` if all items in `it` are truthy,
    otherwise `False`; `all([])` returns `True` |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
  zh: '| (内置) | `all(it)` | 如果`it`中所有项目都为真，则返回`True`，否则返回`False`；`all([])`返回`True`
    |'
- en: '| (built-in) | `any(it)` | Returns `True` if any item in `it` is truthy, otherwise
    `False`; `any([])` returns `False` |'
  id: totrans-504
  prefs: []
  type: TYPE_TB
  zh: '| (内置) | `any(it)` | 如果`it`中有任何项目为真，则返回`True`，否则返回`False`；`any([])`返回`False`
    |'
- en: '| (built-in) | `max(it, [key=,] [default=])` | Returns the maximum value of
    the items in `it`;^([a](ch17.html#idm46582401427632)) `key` is an ordering function,
    as in `sorted`; `default` is returned if the iterable is empty |'
  id: totrans-505
  prefs: []
  type: TYPE_TB
  zh: '| (内置) | `max(it, [key=,] [default=])` | 返回`it`中项目的最大值；^([a](ch17.html#idm46582401427632))
    `key`是一个排序函数，就像`sorted`中一样；如果可迭代对象为空，则返回`default` |'
- en: '| (built-in) | `min(it, [key=,] [default=])` | Returns the minimum value of
    the items in `it`.^([b](ch17.html#idm46582401422464)) `key` is an ordering function,
    as in `sorted`; `default` is returned if the iterable is empty |'
  id: totrans-506
  prefs: []
  type: TYPE_TB
  zh: '| (内置) | `min(it, [key=,] [default=])` | 返回`it`中项目的最小值。^([b](ch17.html#idm46582401422464))
    `key`是一个排序函数，就像`sorted`中一样；如果可迭代对象为空，则返回`default` |'
- en: '| `functools` | `reduce(func, it, [initial])` | Returns the result of applying
    `func` to the first pair of items, then to that result and the third item, and
    so on; if given, `initial` forms the initial pair with the first item |'
  id: totrans-507
  prefs: []
  type: TYPE_TB
  zh: '| `functools` | `reduce(func, it, [initial])` | 返回将`func`应用于第一对项目的结果，然后应用于该结果和第三个项目，依此类推；如果给定，`initial`将与第一个项目形成初始对
    |'
- en: '| (built-in) | `sum(it, start=0)` | The sum of all items in `it`, with the
    optional `start` value added (use `math.fsum` for better precision when adding
    floats) |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
  zh: '| (内置) | `sum(it, start=0)` | `it`中所有项目的总和，加上可选的`start`值（在添加浮点数时使用`math.fsum`以获得更好的精度）
    |'
- en: '| ^([a](ch17.html#idm46582401427632-marker)) May also be called as `max(arg1,
    arg2, …, [key=?])`, in which case the maximum among the arguments is returned.^([b](ch17.html#idm46582401422464-marker))
    May also be called as `min(arg1, arg2, …, [key=?])`, in which case the minimum
    among the arguments is returned. |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch17.html#idm46582401427632-marker)) 也可以称为`max(arg1, arg2, …, [key=?])`，在这种情况下，返回参数中的最大值。^([b](ch17.html#idm46582401422464-marker))
    也可以称为`min(arg1, arg2, …, [key=?])`，在这种情况下，返回参数中的最小值。 |'
- en: The operation of `all` and `any` is exemplified in [Example 17-24](#all_any_demo).
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '`all`和`any`的操作在[示例17-24](#all_any_demo)中有所体现。'
- en: Example 17-24\. Results of `all` and `any` for some sequences
  id: totrans-511
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-24\. 对一些序列使用`all`和`any`的结果
- en: '[PRE36]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO20-1)'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO20-1)'
- en: '`any` iterated over `g` until `g` yielded `7`; then `any` stopped and returned
    `True`.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '`any`在`g`上迭代直到`g`产生`7`；然后`any`停止并返回`True`。'
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO20-2)'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO20-2)'
- en: That’s why `8` was still remaining.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么`8`仍然保留着。
- en: Another built-in that takes an iterable and returns something else is `sorted`.
    Unlike `reversed`, which is a generator function, `sorted` builds and returns
    a new `list`. After all, every single item of the input iterable must be read
    so they can be sorted, and the sorting happens in a `list`, therefore `sorted`
    just returns that `list` after it’s done. I mention `sorted` here because it does
    consume an arbitrary iterable.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个接受可迭代对象并返回其他内容的内置函数是`sorted`。与生成器函数`reversed`不同，`sorted`构建并返回一个新的`list`。毕竟，必须读取输入可迭代对象的每个单个项目以便对它们进行排序，排序发生在一个`list`中，因此`sorted`在完成后只返回该`list`。我在这里提到`sorted`是因为它消耗任意可迭代对象。
- en: Of course, `sorted` and the reducing functions only work with iterables that
    eventually stop. Otherwise, they will keep on collecting items and never return
    a result.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`sorted`和减少函数只适用于最终会停止的可迭代对象。否则，它们将继续收集项目并永远不会返回结果。
- en: Note
  id: totrans-519
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you’ve gotten this far, you’ve seen the most important and useful content
    of this chapter. The remaining sections cover advanced generator features that
    most of us don’t see or need very often, such as the `yield from` construct and
    classic coroutines.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经看到了本章节最重要和最有用的内容，剩下的部分涵盖了大多数人不经常看到或需要的高级生成器功能，比如`yield from`结构和经典协程。
- en: There are also sections about type hinting iterables, iterators, and classic
    coroutines.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 还有关于类型提示可迭代对象、迭代器和经典协程的部分。
- en: The `yield from` syntax provides a new way of combining generators. That’s next.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield from`语法提供了一种组合生成器的新方法。接下来是这个。'
- en: Subgenerators with yield from
  id: totrans-523
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`yield from`的子生成器
- en: The `yield from` expression syntax was introduced in Python 3.3 to allow a generator
    to delegate work to a subgenerator.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield from`表达式语法在 Python 3.3 中引入，允许生成器将工作委托给子生成器。'
- en: 'Before `yield from` was introduced, we used a `for` loop when a generator needed
    to yield values produced from another generator:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入`yield from`之前，当生成器需要产生另一个生成器生成的值时，我们使用`for`循环：
- en: '[PRE37]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can get the same result using `yield from`, as you can see in [Example 17-25](#ex_simple_yield_from).
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`yield from`得到相同的结果，就像你在[示例 17-25](#ex_simple_yield_from)中看到的那样。
- en: Example 17-25\. Test-driving `yield from`
  id: totrans-528
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-25\. 测试驱动`yield from`
- en: '[PRE38]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In [Example 17-25](#ex_simple_yield_from), the `for` loop is the *client code*,
    `gen` is the *delegating generator*, and `sub_gen` is the *subgenerator*. Note
    that `yield from` pauses `gen`, and `sub_gen` takes over until it is exhausted.
    The values yielded by `sub_gen` pass through `gen` directly to the client `for`
    loop. Meanwhile, `gen` is suspended and cannot see the values passing through
    it. Only when `sub_gen` is done, `gen` resumes.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 17-25](#ex_simple_yield_from)中，`for`循环是*客户端代码*，`gen`是*委托生成器*，`sub_gen`是*子生成器*。请注意，`yield
    from`会暂停`gen`，`sub_gen`接管直到耗尽。由`sub_gen`生成的值直接通过`gen`传递给客户端`for`循环。同时，`gen`被挂起，无法看到通过它传递的值。只有当`sub_gen`完成时，`gen`才会恢复。
- en: When the subgenerator contains a `return` statement with a value, that value
    can be captured in the delegating generator by using `yield from` as part of an
    expression. [Example 17-26](#ex_simple_yield_from_return) demonstrates.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 当子生成器包含带有值的`return`语句时，该值可以通过在表达式中使用`yield from`在委托生成器中捕获。[示例 17-26](#ex_simple_yield_from_return)演示了这一点。
- en: Example 17-26\. `yield from` gets the return value of the subgenerator
  id: totrans-532
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-26\. `yield from` 获取子生成器的返回值
- en: '[PRE39]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now that we’ve seen the basics of `yield from`, let’s study a couple of simple
    but practical examples of its use.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`yield from`的基础知识，让我们研究一些简单但实用的用法示例。
- en: Reinventing chain
  id: totrans-535
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重塑链
- en: We saw in [Table 17-3](#merging_genfunc_tbl) that `itertools` provides a `chain`
    generator that yields items from several iterables, iterating over the first,
    then the second, and so on up to the last. This is a homemade implementation of
    `chain` with nested `for` loops in Python:^([10](ch17.html#idm46582401008976))
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[表 17-3](#merging_genfunc_tbl)中看到，`itertools`提供了一个`chain`生成器，从多个可迭代对象中产生项目，首先迭代第一个，然后迭代第二个，依此类推，直到最后一个。这是在
    Python 中使用嵌套`for`循环实现的`chain`的自制版本：^([10](ch17.html#idm46582401008976))
- en: '[PRE40]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `chain` generator in the preceding code is delegating to each iterable
    `it` in turn, by driving each `it` in the inner `for` loop. That inner loop can
    be replaced with a `yield from` expression, as shown in the next console listing:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`chain`生成器依次委托给每个可迭代对象`it`，通过驱动内部`for`循环中的每个`it`。该内部循环可以用`yield from`表达式替换，如下一个控制台列表所示：
- en: '[PRE41]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The use of `yield from` in this example is correct, and the code reads better,
    but it seems like syntactic sugar with little real gain. Now let’s develop a more
    interesting example.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中使用`yield from`是正确的，代码读起来更好，但似乎只是一点点语法糖而已。���在让我们开发一个更有趣的示例。
- en: Traversing a Tree
  id: totrans-541
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历树
- en: In this section, we’ll see `yield from` in a script to traverse a tree structure.
    I will build it in baby steps.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到在脚本中使用`yield from`来遍历树结构。我将逐步构建它。
- en: The tree structure for this example is Python’s [exception hierarchy](https://fpy.li/17-14).
    But the pattern can be adapted to show a directory tree or any other tree structure.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的树结构是 Python 的[异常层次结构](https://fpy.li/17-14)。但是该模式可以适应显示目录树或任何其他树结构。
- en: Starting from `BaseException` at level zero, the exception hierarchy is five
    levels deep as of Python 3.10\. Our first baby step is to show level zero.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 3.10 开始，异常层次结构从零级的`BaseException`开始，深达五级。我们的第一步是展示零级。
- en: Given a root class, the `tree` generator in [Example 17-27](#ex_tree_step0)
    yields its name and stops.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个根类，在[示例 17-27](#ex_tree_step0)中的`tree`生成器会生成其名称并停止。
- en: 'Example 17-27\. tree/step0/tree.py: yield the name of the root class and stop'
  id: totrans-546
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-27\. tree/step0/tree.py：生成根类的名称并停止
- en: '[PRE42]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output of [Example 17-27](#ex_tree_step0) is just one line:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 17-27](#ex_tree_step0)的输出只有一行：'
- en: '[PRE43]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The next baby step takes us to level 1. The `tree` generator will yield the
    name of the root class and the names of each direct subclass. The names of the
    subclasses are indented to reveal the hierarchy. This is the output we want:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个小步骤将我们带到第 1 级。`tree`生成器将生成根类的名称和每个直接子类的名称。子类的名称缩进以显示层次结构。这是我们想要的输出：
- en: '[PRE44]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[Example 17-28](#ex_tree_step1) produces that output.'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 17-28](#ex_tree_step1)产生了该输出。'
- en: 'Example 17-28\. tree/step1/tree.py: yield the name of root class and direct
    subclasses'
  id: totrans-553
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-28\. tree/step1/tree.py：生成根类和直接子类的名称
- en: '[PRE45]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO21-1)'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO21-1)'
- en: To support the indented output, yield the name of the class and its level in
    the hierarchy.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持缩进输出，生成类的名称和其在层次结构中的级别。
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO21-2)'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO21-2)'
- en: Use the `__subclasses__` special method to get a list of subclasses.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`__subclasses__`特殊方法获取子类列表。
- en: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO21-3)'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO21-3)'
- en: Yield name of subclass and level 1.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 产出子类和第 1 级的名称。
- en: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO21-4)'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO21-4)'
- en: Build indentation string of `4` spaces times `level`. At level zero, this will
    be an empty string.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 构建缩进字符串，为 `level` 乘以 `4` 个空格。在零级时，这将是一个空字符串。
- en: In [Example 17-29](#ex_tree_step2), I refactor `tree` to separate the special
    case of the root class from the subclasses, which are now handled in the `sub_tree`
    generator. At `yield from`, the `tree` generator is suspended, and `sub_tree`
    takes over yielding values.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 17-29](#ex_tree_step2) 中，���重构了 `tree`，将根类的特殊情况与子类分开处理，现在在 `sub_tree`
    生成器中处理。在 `yield from` 处，`tree` 生成器被挂起，`sub_tree` 接管产出值。
- en: 'Example 17-29\. tree/step2/tree.py: `tree` yields the root class name, then
    delegates to `sub_tree`'
  id: totrans-564
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '示例 17-29\. tree/step2/tree.py: `tree` 产出根类名称，然后委托给 `sub_tree`'
- en: '[PRE46]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO22-1)'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO22-1)'
- en: Delegate to `sub_tree` to yield the names of the subclasses.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 委托给 `sub_tree` 产出子类的名称。
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO22-2)'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO22-2)'
- en: Yield the name of each subclass and level 1\. Because of the `yield from sub_tree(cls)`
    inside `tree`, these values bypass the `tree` generator function completely…
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 产出每个子类和第 1 级的名称。由于 `tree` 内部有 `yield from sub_tree(cls)`，这些值完全绕过了 `tree` 生成器函数…
- en: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO22-3)'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO22-3)'
- en: … and are received directly here.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: … 并直接在这里接收。
- en: In keeping with the baby steps method, I’ll write the simplest code I can imagine
    to reach level 2. For [depth-first](https://fpy.li/17-15) tree traversal, after
    yielding each node in level 1, I want to yield the children of that node in level
    2, before resuming level 1. A nested `for` loop takes care of that, as in [Example 17-30](#ex_tree_step3).
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行 [深度优先](https://fpy.li/17-15) 树遍历，在产出第 1 级的每个节点后，我想要产出该节点的第 2 级子节点，然后继续第
    1 级。一个嵌套的 `for` 循环负责处理这个问题，就像 [示例 17-30](#ex_tree_step3) 中一样。
- en: 'Example 17-30\. tree/step3/tree.py: `sub_tree` traverses levels 1 and 2 depth-first'
  id: totrans-573
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '示例 17-30\. tree/step3/tree.py: `sub_tree` 深度优先遍历第 1 和第 2 级'
- en: '[PRE47]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This is the result of running *step3/tree.py* from [Example 17-30](#ex_tree_step3):'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从 [示例 17-30](#ex_tree_step3) 运行 *step3/tree.py* 的结果：
- en: '[PRE48]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You may already know where this is going, but I will stick to baby steps one
    more time: let’s reach level 3 by adding yet another nested `for` loop. The rest
    of the program is unchanged, so [Example 17-31](#ex_tree_step4) shows only the
    `sub_tree` generator.'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经知道这将会发生什么，但我将再次坚持小步慢走：让我们通过添加另一个嵌套的 `for` 循环来达到第 3 级。程序的其余部分没有改变，因此 [示例
    17-31](#ex_tree_step4) 仅显示了 `sub_tree` 生成器。
- en: Example 17-31\. `sub_tree` generator from *tree/step4/tree.py*
  id: totrans-578
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-31\. *tree/step4/tree.py* 中的 `sub_tree` 生成器
- en: '[PRE49]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: There is a clear pattern in [Example 17-31](#ex_tree_step4). We do a `for` loop
    to get the subclasses of level *N*. Each time around the loop, we yield a subclass
    of level *N*, then start another `for` loop to visit level *N*+1.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 17-31](#ex_tree_step4) 中有一个明显的模式。我们使用 `for` 循环获取第 *N* 级的子类。每次循环，我们产出第
    *N* 级的一个子类，然后开始另一个 `for` 循环访问第 *N*+1 级。
- en: In [“Reinventing chain”](#reinventing_chain_sec), we saw how we can replace
    a nested `for` loop driving a generator with `yield from` on the same generator.
    We can apply that idea here, if we make `sub_tree` accept a `level` parameter,
    and `yield from` it recursively, passing the current subclass as the new root
    class with the next level number. See [Example 17-32](#ex_tree_step5).
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“重新发明链”](#reinventing_chain_sec) 中，我们看到如何用相同的生成器上的 `yield from` 替换驱动生成器的嵌套
    `for` 循环。如果我们使 `sub_tree` 接受一个 `level` 参数，并递归地 `yield from` 它，将当前子类作为新的根类和下一个级别编号传递。参见
    [示例 17-32](#ex_tree_step5)。
- en: 'Example 17-32\. tree/step5/tree.py: recursive `sub_tree` goes as far as memory
    allows'
  id: totrans-582
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '示例 17-32\. tree/step5/tree.py: 递归的 `sub_tree` 走到内存允许的极限'
- en: '[PRE50]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[Example 17-32](#ex_tree_step5) can traverse trees of any depth, limited only
    by Python’s recursion limit. The default limit allows 1,000 pending functions.'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 17-32](#ex_tree_step5) 可以遍历任意深度的树，仅受 Python 递归限制。默认限制允许有 1,000 个待处理函数。'
- en: 'Any good tutorial about recursion will stress the importance of having a base
    case to avoid infinite recursion. A base case is a conditional branch that returns
    without making a recursive call. The base case is often implemented with an `if`
    statement. In [Example 17-32](#ex_tree_step5), `sub_tree` has no `if`, but there
    is an implicit conditional in the `for` loop: if `cls.__subclasses__()` returns
    an empty list, the body of the loop is not executed, therefore no recursive call
    happens. The base case is when the `cls` class has no subclasses. In that case,
    `sub_tree` yields nothing. It just returns.'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 任何关于递归的好教程都会强调有一个基本情况以避免无限递归的重要性。基本情况是一个有条件返回而不进行递归调用的条件分支。基本情况通常使用 `if` 语句实现。在
    [示例 17-32](#ex_tree_step5) 中，`sub_tree` 没有 `if`，但在 `for` 循环中有一个隐式条件：如果 `cls.__subclasses__()`
    返回一个空列表，则循环体不会执行，因此不会发生递归调用。基本情况是当 `cls` 类没有子类时。在这种情况下，`sub_tree` 不产出任何内容。它只是返回。
- en: '[Example 17-32](#ex_tree_step5) works as intended, but we can make it more
    concise by recalling the pattern we observed when we reached level 3 ([Example 17-31](#ex_tree_step4)):
    we yield a subclass with level *N*, then start a nested for loop to visit level
    *N*+1. In [Example 17-32](#ex_tree_step5) we replaced that nested loop with `yield
    from`. Now we can merge `tree` and `sub_tree` into a single generator. [Example 17-33](#ex_tree_step6)
    is the last step for this example.'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 17-32](#ex_tree_step5)按预期工作，但我们可以通过回顾我们在达到第 3 级时观察到的模式来使其更简洁（[示例 17-31](#ex_tree_step4)）：我们产生一个带有级别*N*的子类，然后开始一个嵌套的循环以访问级别*N*+1。在[示例
    17-32](#ex_tree_step5)中，我们用`yield from` 替换了该嵌套循环。现在我们可以将`tree` 和`sub_tree` 合并为一个单一的生成器。[示例
    17-33](#ex_tree_step6)是此示例的最后一步。'
- en: 'Example 17-33\. tree/step6/tree.py: recursive calls of `tree` pass an incremented
    `level` argument'
  id: totrans-587
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-33\. tree/step6/tree.py：`tree` 的递归调用传递了一个递增的`level` 参数
- en: '[PRE51]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: At the start of [“Subgenerators with yield from”](#yield_from_sec0), we saw
    how `yield from` connects the subgenerator directly to the client code, bypassing
    the delegating generator. That connection becomes really important when generators
    are used as coroutines and not only produce but also consume values from the client
    code, as we’ll see in [“Classic Coroutines”](#classic_coroutines_sec).
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“使用 yield from 的子生成器”](#yield_from_sec0)开头，我们看到`yield from` 如何将子生成器直接连接到客户端代码，绕过委托生成器。当生成器用作协程并且不仅产生而且从客户端代码消耗值时，这种连接变得非常重要，正如我们将在[“经典协程”](#classic_coroutines_sec)中看到的那样。
- en: After this first encounter with `yield from`, let’s turn to type hinting iterables
    and iterators.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次遇到`yield from` 后，让我们转向对可迭代和迭代器进行类型提示。
- en: Generic Iterable Types
  id: totrans-591
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用可迭代类型
- en: Python’s standard library has many functions that accept iterable arguments.
    In your code, such functions can be annotated like the `zip_replace` function
    we saw in [Example 8-15](ch08.html#replacer_ex), using `collections.abc.Iterable`
    (or `typing.Iterable` if you must support Python 3.8 or earlier, as explained
    in [“Legacy Support and Deprecated Collection Types”](ch08.html#legacy_deprecated_typing_box)).
    See [Example 17-34](#replacer_iterable_ex).
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: Python 标准库有许多接受可迭代参数的函数。在您的代码中，这些函数可以像我们在[示例 8-15](ch08.html#replacer_ex)中看到的`zip_replace`
    函数一样进行注释，使用`collections.abc.Iterable`（或者如果必须支持 Python 3.8 或更早版本，则使用`typing.Iterable`，如[“遗留支持和已弃用的集合类型”](ch08.html#legacy_deprecated_typing_box)中所解释的那样）。参见[示例
    17-34](#replacer_iterable_ex)。
- en: Example 17-34\. replacer.py returns an iterator of tuples of strings
  id: totrans-593
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-34\. replacer.py 返回一个字符串元组的迭代器
- en: '[PRE52]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO23-1)'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO23-1)'
- en: 'Define type alias; not required, but makes the next type hint more readable.
    Starting with Python 3.10, `FromTo` should have a type hint of `typing.TypeAlias`
    to clarify the reason for this line: `FromTo: TypeAlias = tuple[str, str]`.'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '定义类型别名；虽然不是必需的，但可以使下一个类型提示更易读。从 Python 3.10 开始，`FromTo` 应该具有类型提示`typing.TypeAlias`，以阐明此行的原因：`FromTo:
    TypeAlias = tuple[str, str]`。'
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO23-2)'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO23-2)'
- en: Annotate `changes` to accept an `Iterable` of `FromTo` tuples.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 注释`changes` 以接受`FromTo` 元组的`Iterable`。
- en: '`Iterator` types don’t appear as often as `Iterable` types, but they are also
    simple to write. [Example 17-35](#fibo_gen_annot_ex) shows the familiar Fibonacci
    generator, annotated.'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterator` 类型出现的频率不如`Iterable` 类型高，但编写起来也很简单。[示例 17-35](#fibo_gen_annot_ex)展示了熟悉的斐波那契生成器，并加上了注释。'
- en: 'Example 17-35\. *fibo_gen.py*: `fibonacci` returns a generator of integers'
  id: totrans-600
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-35\. *fibo_gen.py*：`fibonacci` 返回一个整数生成器
- en: '[PRE53]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note that the type `Iterator` is used for generators coded as functions with
    `yield`, as well as iterators written “by hand” as classes with `__next__`. There
    is also a `collections.abc.Generator` type (and the corresponding deprecated `typing.Generator`)
    that we can use to annotate generator objects, but it is needlessly verbose for
    generators used as iterators.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，类型`Iterator` 用于使用`yield`编写的函数生成器，以及手动编写的作为类的迭代器，具有`__next__`。还有一个`collections.abc.Generator`
    类型（以及相应的已弃用`typing.Generator`），我们可以用它来注释生成器对象，但对于用作迭代器的生成器来说，这显得冗长。
- en: '[Example 17-36](#iter_gen_type_ex), when checked with Mypy, reveals that the
    `Iterator` type is really a simplified special case of the `Generator` type.'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 17-36](#iter_gen_type_ex)，经过 Mypy 检查后，发现`Iterator` 类型实际上是`Generator` 类型的一个简化特例。'
- en: 'Example 17-36\. itergentype.py: two ways to annotate iterators'
  id: totrans-604
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-36\. itergentype.py：注释迭代器的两种方法
- en: '[PRE54]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO24-1)'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO24-1)'
- en: Generator expression that yields Python keywords with less than `5` characters.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器表达式，产生长度小于`5`个字符的 Python 关键字。
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO24-2)'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO24-2)'
- en: 'Mypy infers: `typing.Generator[builtins.str*, None, None]`.^([11](ch17.html#idm46582399629568))'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: Mypy 推断：`typing.Generator[builtins.str*, None, None]`。^([11](ch17.html#idm46582399629568))
- en: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO24-3)'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO24-3)'
- en: This also yields strings, but I added an explicit type hint.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 这也产生字符串，但我添加了一个明确的类型提示。
- en: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO24-4)'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO24-4)'
- en: 'Revealed type: `typing.Iterator[builtins.str]`.'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 显式类型：`typing.Iterator[builtins.str]`。
- en: '`abc.Iterator[str]` is *consistent-with* `abc.Generator[str, None, None]`,
    therefore Mypy issues no errors for type checking in [Example 17-36](#iter_gen_type_ex).'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '`abc.Iterator[str]` 与`abc.Generator[str, None, None]` 一致，因此 Mypy 在[示例 17-36](#iter_gen_type_ex)的类型检查中不会发出��误。'
- en: '`Iterator[T]` is a shortcut for `Generator[T, None, None]`. Both annotations
    mean “a generator that yields items of type `T`, but that does not consume or
    return values.” Generators able to consume and return values are coroutines, our
    next topic.'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '`Iterator[T]` 是 `Generator[T, None, None]` 的快捷方式。这两个注释都表示“生成器产生类型为 `T` 的项目，但不消耗或返���值。”
    能够消耗和返回值的生成器是协程，我们下一个主题。'
- en: Classic Coroutines
  id: totrans-616
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经典协程
- en: Note
  id: totrans-617
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '[PEP 342—Coroutines via Enhanced Generators](https://fpy.li/pep342) introduced
    the `.send()` and other features that made it possible to use generators as coroutines.
    PEP 342 uses the word “coroutine” with the same meaning I am using here.'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '[PEP 342—通过增强生成器实现协程](https://fpy.li/pep342) 引入了 `.send()` 和其他功能，使得可以将生成器用作协程。PEP
    342 使用的“协程”一词与我在此处使用的含义相同。'
- en: It is unfortunate that Python’s official documentation and standard library
    now use inconsistent terminology to refer to generators used as coroutines, forcing
    me to adopt the “classic coroutine” qualifier to contrast with the newer “native
    coroutine” objects.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Python 的官方文档和标准库现在使用不一致的术语来指代用作协程的生成器，迫使我采用“经典协程”限定词以与较新的“本机协程”对象形成对比。
- en: After Python 3.5 came out, the trend is to use “coroutine” as a synonym for
    “native coroutine.” But PEP 342 is not deprecated, and classic coroutines still
    work as originally designed, although they are no longer supported by `asyncio`.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.5 之后，使用“协程”作为“本机协程”的同义词成为趋势。但 PEP 342 并未被弃用，经典协程仍按最初设计的方式工作，尽管它们不再受
    `asyncio` 支持。
- en: Understanding classic coroutines in Python is confusing because they are actually
    generators used in a different way. So let’s step back and consider another feature
    of Python that can be used in two ways.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中理解经典协程很令人困惑，因为它们实际上是以不同方式使用的生成器。因此，让我们退一步考虑 Python 中另一个可以以两种方式使用的特性。
- en: 'We saw in [“Tuples Are Not Just Immutable Lists”](ch02.html#tuples_more_than_lists_sec)
    that we can use `tuple` instances as records or as immutable sequences. When used
    as a record, a tuple is expected to have a specific number of items, and each
    item may have a different type. When used as immutable lists, a tuple can have
    any length, and all items are expected to have the same type. That’s why there
    are two different ways to annotate tuples with type hints:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [“元组不仅仅是不可变列表”](ch02.html#tuples_more_than_lists_sec) 中看到，我们可以将 `tuple`
    实例用作记录或不可变序列。当用作记录时，预期元组具有特定数量的项目，并且每个项目可能具有不同的类型。当用作不可变列表时，元组可以具有任意长度，并且所有项目都预期具有相同的类型。这就是为什么有两种不同的方式使用类型提示注释元组的原因：
- en: '[PRE55]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Something similar happens with generators. They are commonly used as iterators,
    but they can also be used as coroutines. A *coroutine* is really a generator function,
    created with the `yield` keyword in its body. And a *coroutine object* is physically
    a generator object. Despite sharing the same underlying implementation in C, the
    use cases of generators and coroutines in Python are so different that there are
    two ways to type hint them:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 与生成器类似的情况也发生在生成器上。它们通常用作迭代器，但也可以用作协程。*协程* 实际上是一个生成器函数，在其主体中使用 `yield` 关键字创建。*协程对象*
    在物理上是一个生成器对象。尽管在 C 中共享相同的底层实现，但在 Python 中生成器和协程的用例是如此不同，以至于有两种方式对它们进行类型提示：
- en: '[PRE56]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Adding to the confusion, the `typing` module authors decided to name that type
    `Generator`, when in fact it describes the API of a generator object intended
    to be used as a coroutine, while generators are more often used as simple iterators.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 使人困惑的是，`typing` 模块的作者决定将该类型命名为 `Generator`，而实际上它描述了旨在用作协程的生成器对象的 API，而生成器更常用作简单的迭代器。
- en: 'The [`typing` documentation](https://fpy.li/17-17) describes the formal type
    parameters of `Generator` like this:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '[`typing` 文档](https://fpy.li/17-17)描述了 `Generator` 的形式类型参数如下：'
- en: '[PRE57]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `SendType` is only relevant when the generator is used as a coroutine. That
    type parameter is the type of `x` in the call `gen.send(x)`. It is an error to
    call `.send()` on a generator that was coded to behave as an iterator instead
    of a coroutine. Likewise, `ReturnType` is only meaningful to annotate a coroutine,
    because iterators don’t return values like regular functions. The only sensible
    operation on a generator used as an iterator is to call `next(it)` directly or
    indirectly via `for` loops and other forms of iteration. The `YieldType` is the
    type of the value returned by a call to `next(it)`.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 当生成器用作协程时，`SendType` 才相关。该类型参数是调用 `gen.send(x)` 中的 `x` 的类型。在对被编码为迭代器而不是协程的生成器调用
    `.send()` 是错误的。同样，`ReturnType` 仅对协程进行注释有意义，因为迭代器不像常规函数那样返回值。将生成器用作迭代器的唯一明智操作是直接或间接通过
    `for` 循环和其他形式的迭代调用 `next(it)`。`YieldType` 是调用 `next(it)` 返回的值的类型。
- en: 'The `Generator` type has the same type parameters as [`typing.Coroutine`](https://fpy.li/typecoro):'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '`Generator` 类型具有与 [`typing.Coroutine`](https://fpy.li/typecoro) 相同的类型参数：'
- en: '[PRE58]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The [`typing.Coroutine` documentation](https://fpy.li/typecoro) actually says:
    “The variance and order of type variables correspond to those of `Generator`.”
    But `typing.Coroutine` (deprecated) and `collections.abc.Coroutine` (generic since
    Python 3.9) are intended to annotate only native coroutines, not classic coroutines.
    If you want to use type hints with classic coroutines, you’ll suffer through the
    confusion of annotating them as `Generator[YieldType, SendType, ReturnType]`.'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '[`typing.Coroutine` 文档](https://fpy.li/typecoro)实际上说：“类型变量的方差和顺序与 `Generator`
    相对应。”但 `typing.Coroutine`（已弃用）和 `collections.abc.Coroutine`（自 Python 3.9 起为通用）旨在仅注释本机协程，而不是经典协程。如果要在经典协程中使用类型提示，您将遭受将它们注释为
    `Generator[YieldType, SendType, ReturnType]` 的困惑。'
- en: 'David Beazley created some of the best talks and most comprehensive workshops
    about classic coroutines. In his [PyCon 2009 course handout](https://fpy.li/17-18),
    he has a slide titled “Keeping It Straight,” which reads:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: David Beazley 创建了一些关于经典协程的最佳演讲和最全面的研讨会。在他的 [PyCon 2009 课程手册](https://fpy.li/17-18)
    中，有一张幻灯片标题为“Keeping It Straight”，内容如下：
- en: Generators produce data for iteration
  id: totrans-634
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器产生用于迭代的数据
- en: ''
  id: totrans-635
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-636
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Coroutines are consumers of data
  id: totrans-637
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程是数据的消费者
- en: ''
  id: totrans-638
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-639
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: To keep your brain from exploding, don’t mix the two concepts together
  id: totrans-640
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了避免大脑爆炸，请不要混淆这两个概念。
- en: ''
  id: totrans-641
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-642
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Coroutines are not related to iteration
  id: totrans-643
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程与迭代无关。
- en: ''
  id: totrans-644
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-645
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note: There is a use of having `yield` produce a value in a coroutine, but
    it’s not tied to iteration.^([12](ch17.html#idm46582399407296))'
  id: totrans-646
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意：在协程中使用`yield`产生一个值是有用的，但它与迭代无关。^([12](ch17.html#idm46582399407296))
- en: Now let’s see how classic coroutines work.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看经典协程是如何工作的。
- en: 'Example: Coroutine to Compute a Running Average'
  id: totrans-648
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：计算移动平均值的协程
- en: While discussing closures in [Chapter 9](ch09.html#closures_and_decorators),
    we studied objects to compute a running average. [Example 9-7](ch09.html#ex_average_oo)
    shows a class and [Example 9-13](ch09.html#ex_average_fixed) presents a higher-order
    function returning a function that keeps the `total` and `count` variables across
    invocations in a closure. [Example 17-37](#ex_coroaverager) shows how to do the
    same with a coroutine.^([13](ch17.html#idm46582399396160))
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论闭包时，我们在[第9章](ch09.html#closures_and_decorators)中研究了用于计算移动平均值的对象。[示例9-7](ch09.html#ex_average_oo)展示了一个类，而[示例9-13](ch09.html#ex_average_fixed)则展示了一个返回函数的高阶函数，该函数在闭包中跨调用保留`total`和`count`变量。[示例17-37](#ex_coroaverager)展示了如何使用协程实现相同的功能。^([13](ch17.html#idm46582399396160))
- en: 'Example 17-37\. coroaverager.py: coroutine to compute a running average'
  id: totrans-650
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例17-37\. coroaverager.py：计算移动平均值的协程。
- en: '[PRE59]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO25-1)'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO25-1)'
- en: This function returns a generator that yields `float` values, accepts `float`
    values via `.send()`, and does not return a useful value.^([14](ch17.html#idm46582399308016))
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回一个生成器，产生`float`值，通过`.send()`接受`float`值，并不返回有用的值。^([14](ch17.html#idm46582399308016))
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO25-2)'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO25-2)'
- en: This infinite loop means the coroutine will keep on yielding averages as long
    as the client code sends values.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 这个无限循环意味着只要客户端代码发送值，协程就会继续产生平均值。
- en: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO25-3)'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO25-3)'
- en: The `yield` statement here suspends the coroutine, yields a result to the client,
    and—later—gets a value sent by the caller to the coroutine, starting another iteration
    of the infinite loop.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`yield`语句暂停协程，向客户端产生一个结果，然后—稍后—接收调用者发送给协程的值，开始无限循环的另一个迭代。
- en: 'In a coroutine, `total` and `count` can be local variables: no instance attributes
    or closures are needed to keep the context while the coroutine is suspended waiting
    for the next `.send()`. That’s why coroutines are attractive replacements for
    callbacks in asynchronous programming—they keep local state between activations.'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 在协程中，`total`和`count`可以是局部变量：不需要实例属性或闭包来在协程在等待下一个`.send()`时保持上下文。这就是为什么协程在异步编程中是回调的有吸引力替代品——它们在激活之间保持本地状态。
- en: '[Example 17-38](#ex_coroaverager_test) runs doctests to show the `averager`
    coroutine in operation.'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例17-38](#ex_coroaverager_test)运行doctests以展示`averager`协程的运行情况。'
- en: 'Example 17-38\. coroaverager.py: doctest for the running average coroutine
    in [Example 17-37](#ex_coroaverager)'
  id: totrans-660
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例17-38\. coroaverager.py：运行平均值协程的doctest，参见[示例17-37](#ex_coroaverager)。
- en: '[PRE60]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO26-1)'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO26-1)'
- en: Create the coroutine object.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 创建协程对象。
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO26-2)'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO26-2)'
- en: 'Start the coroutine. This yields the initial value of `average`: 0.0.'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 启动协程。这会产生`average`的初始值：0.0。
- en: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO26-3)'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO26-3)'
- en: 'Now we are in business: each call to `.send()` yields the current average.'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始了：每次调用`.send()`都会产生当前的平均值。
- en: In [Example 17-38](#ex_coroaverager_test), the call `next(coro_avg)` makes the
    coroutine advance to the `yield`, yielding the initial value for `average`. You
    can also start the coroutine by calling `coro_avg.send(None)`—this is actually
    what the `next()` built-in does. But you can’t send any value other than `None`,
    because the coroutine can only accept a sent value when it is suspended at a `yield`
    line. Calling `next()` or `.send(None)` to advance to the first `yield` is known
    as “priming the coroutine.”
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例17-38](#ex_coroaverager_test)中，调用`next(coro_avg)`使协程前进到`yield`，产生`average`的初始值。您也可以通过调用`coro_avg.send(None)`来启动协程——这实际上就是`next()`内置函数的作用。但是您不能发送除`None`之外的任何值，因为协程只能在`yield`行处暂停时接受发送的值。调用`next()`或`.send(None)`以前进到第一个`yield`的操作称为“激活协程”。
- en: After each activation, the coroutine is suspended precisely at the `yield` keyword,
    waiting for a value to be sent. The line `coro_avg.send(10)` provides that value,
    causing the coroutine to activate. The `yield` expression resolves to the value
    10, assigning it to the `term` variable. The rest of the loop updates the `total`,
    `count`, and `average` variables. The next iteration in the `while` loop yields
    the `average`, and the coroutine is again suspended at the `yield` keyword.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 每次激活后，协程都会在`yield`关键字处精确地暂停，等待发送值。`coro_avg.send(10)`这一行提供了该值，导致协程激活。`yield`表达式解析为值10，并将其赋给`term`变量。循环的其余部分更新`total`、`count`和`average`变量。`while`循环中的下一次迭代会产生`average`，协程再次在`yield`关键字处暂停。
- en: The attentive reader may be anxious to know how the execution of an `averager`
    instance (e.g., `coro_avg`) may be terminated, because its body is an infinite
    loop. We don’t usually need to terminate a generator, because it is garbage collected
    as soon as there are no more valid references to it. If you need to explicitly
    terminate it, use the `.close()` method, as shown in [Example 17-39](#ex_coroaverager_test_cont).
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 细心的读者可能急于知道如何终止 `averager` 实例（例如 `coro_avg`）的执行，因为它的主体是一个无限循环。通常我们不需要终止生成器，因为一旦没有更多有效引用，它就会被垃圾回收。如果需要显式终止它，请使用
    `.close()` 方法，如 [示例 17-39](#ex_coroaverager_test_cont) 中所示。
- en: 'Example 17-39\. coroaverager.py: continuing from [Example 17-38](#ex_coroaverager_test)'
  id: totrans-671
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-39\. coroaverager.py：从 [示例 17-38](#ex_coroaverager_test) 继续
- en: '[PRE61]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO27-1)'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO27-1)'
- en: '`coro_avg` is the instance created in [Example 17-38](#ex_coroaverager_test).'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '`coro_avg` 是在 [示例 17-38](#ex_coroaverager_test) 中创建的实例。'
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO27-2)'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO27-2)'
- en: The `.close()` method raises `GeneratorExit` at the suspended `yield` expression.
    If not handled in the coroutine function, the exception terminates it. `GeneratorExit`
    is caught by the generator object that wraps the coroutine—that’s why we don’t
    see it.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '`.close()` 方法在挂起的 `yield` 表达式处引发 `GeneratorExit`。如果在协程函数中未处理，异常将终止它。`GeneratorExit`
    被包装协程的生成器对象捕获，这就是我们看不到它的原因。'
- en: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO27-3)'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO27-3)'
- en: Calling `.close()` on a previously closed coroutine has no effect.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 对先前关闭的协程调用 `.close()` 没有任何效果。
- en: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO27-4)'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO27-4)'
- en: Trying `.send()` on a closed coroutine raises `StopIteration`.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在已关闭的协程上使用 `.send()` 会引发 `StopIteration`。
- en: Besides the `.send()` method, [PEP 342—Coroutines via Enhanced Generators](https://fpy.li/pep342)
    also introduced a way for a coroutine to return a value. The next section shows
    how.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `.send()` 方法，[PEP 342—通过增强生成器实现协程](https://fpy.li/pep342) 还介绍了一种协程返回值的方法。下一节将展示如何实现。
- en: Returning a Value from a Coroutine
  id: totrans-682
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从协程返回一个值
- en: 'We’ll now study another coroutine to compute an average. This version will
    not yield partial results. Instead, it returns a tuple with the number of terms
    and the average. I’ve split the listing in two parts: [Example 17-40](#ex_returning_averager_top)
    and [Example 17-41](#ex_returning_averager_coro).'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将学习另一个用于计算平均值的协程。这个版本不会产生部分结果，而是返回一个包含项数和平均值的元组。我将列表分成两部分：[示例 17-40](#ex_returning_averager_top)
    和 [示例 17-41](#ex_returning_averager_coro)。
- en: 'Example 17-40\. coroaverager2.py: top of the file'
  id: totrans-684
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-40\. coroaverager2.py：文件顶部
- en: '[PRE62]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO28-1)'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO28-1)'
- en: The `averager2` coroutine in [Example 17-41](#ex_returning_averager_coro) will
    return an instance of `Result`.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 17-41](#ex_returning_averager_coro) 中的 `averager2` 协程将返回一个 `Result` 实例。'
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO28-2)'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO28-2)'
- en: 'The `Result` is actually a subclass of `tuple`, which has a `.count()` method
    that I don’t need. The `# type: ignore` comment prevents Mypy from complaining
    about having a `count` field.^([15](ch17.html#idm46582398943024))'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '`Result` 实际上是 `tuple` 的一个子类，它有一个我不需要的 `.count()` 方法。`# type: ignore` 注释防止 Mypy
    抱怨有一个 `count` 字段。^([15](ch17.html#idm46582398943024))'
- en: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO28-3)'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO28-3)'
- en: A class to make a sentinel value with a readable `__repr__`.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于创建具有可读 `__repr__` 的哨兵值的类。
- en: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO28-4)'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO28-4)'
- en: The sentinel value that I’ll use to make the coroutine stop collecting data
    and return a result.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用的哨兵值来使协程停止收集数据并返回结果。
- en: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO28-5)'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO28-5)'
- en: I’ll use this type alias for the second type parameter of the coroutine `Generator`
    return type, the `SendType` parameter.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 我将用这个类型别名作为协程 `Generator` 返回类型的第二个类型参数，即 `SendType` 参数。
- en: 'The `SendType` definition also works in Python 3.10, but if you don’t need
    to support earlier versions, it is better to write it like this, after importing
    `TypeAlias` from `typing`:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '`SendType` 定义在 Python 3.10 中也有效，但如果不需要支持早期版本，最好在导入 `typing` 后像这样写：'
- en: '[PRE63]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Using `|` instead of `typing.Union` is so concise and readable that I’d probably
    not create that type alias, but instead I’d write the signature of `averager2`
    like this:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `|` 而不是 `typing.Union` 如此简洁易读，以至于我可能不会创建该类型别名，而是会像这样编写 `averager2` 的签名：
- en: '[PRE64]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Now, let’s study the coroutine code itself ([Example 17-41](#ex_returning_averager_coro)).
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们研究协程代码本身（[示例 17-41](#ex_returning_averager_coro)）。
- en: 'Example 17-41\. coroaverager2.py: a coroutine that returns a result value'
  id: totrans-701
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-41\. coroaverager2.py：返回结果值的协程
- en: '[PRE65]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO29-1)'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO29-1)'
- en: For this coroutine, the yield type is `None` because it does not yield data.
    It receives data of the `SendType` and returns a `Result` tuple when done.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个协程，yield 类型是 `None`，因为它不产生数据。它接收 `SendType` 的数据，并在完成时返回一个 `Result` 元组。
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO29-2)'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO29-2)'
- en: Using `yield` like this only makes sense in coroutines, which are designed to
    consume data. This yields `None`, but receives a `term` from `.send(term)`.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样使用`yield`只在协程中有意义，它们被设计用来消耗数据。这里产生`None`，但从`.send(term)`接收一个`term`。
- en: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO29-3)'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO29-3)'
- en: If the `term` is a `Sentinel`, break from the loop. Thanks to this `isinstance`
    check…
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`term`是一个`Sentinel`，就从循环中退出。多亏了这个`isinstance`检查…
- en: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO29-4)'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO29-4)'
- en: …Mypy allows me to add `term` to the `total` without flagging an error that
    I can’t add a `float` to an object that may be a `float` or a `Sentinel`.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: …Mypy允许我将`term`添加到`total`中，而不会出现错误，即我无法将`float`添加到可能是`float`或`Sentinel`的对象中。
- en: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO29-5)'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO29-5)'
- en: This line will be reached only if a `Sentinel` is sent to the coroutine.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当`Sentinel`被发送到协程时，这行才会被执行。
- en: Now let’s see how we can use this coroutine, starting with a simple example
    that doesn’t actually produce a result ([Example 17-42](#ex_coro_averager2_demo_1)).
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何使用这个协程，从一个简单的例子开始，实际上并不产生结果（[示例 17-42](#ex_coro_averager2_demo_1)）。
- en: 'Example 17-42\. coroaverager2.py: doctest showing `.cancel()`'
  id: totrans-714
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-42\. coroaverager2.py：展示`.cancel()`
- en: '[PRE66]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO30-1)'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO30-1)'
- en: Recall that `averager2` does not yield partial results. It yields `None`, which
    Python’s console omits.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住`averager2`不会产生部分结果。它产生`None`，Python控制台会忽略它。
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO30-2)'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO30-2)'
- en: Calling `.close()` in this coroutine makes it stop but does not return a result,
    because the `GeneratorExit` exception is raised at the `yield` line in the coroutine,
    so the `return` statement is never reached.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个协程中调用`.close()`会使其停止，但不会返回结果，因为在协程的`yield`行引发了`GeneratorExit`异常，所以`return`语句永远不会被执行。
- en: Now let’s make it work in [Example 17-43](#ex_coro_averager2_demo_2).
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在[示例 17-43](#ex_coro_averager2_demo_2)中使其工作。
- en: 'Example 17-43\. coroaverager2.py: doctest showing `StopIteration` with a `Result`'
  id: totrans-721
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-43\. coroaverager2.py：展示带有`Result`的`StopIteration`的doctest
- en: '[PRE67]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO31-1)'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO31-1)'
- en: Sending the `STOP` sentinel makes the coroutine break from the loop and return
    a `Result`. The generator object that wraps the coroutine then raises `StopIteration`.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 发送`STOP`标记使协程退出循环并返回一个`Result`。包装协程的生成器对象然后引发`StopIteration`。
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO31-2)'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO31-2)'
- en: The `StopIteration` instance has a `value` attribute bound to the value of the
    `return` statement that terminated the coroutine.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '`StopIteration`实例有一个`value`属性，绑定到终止协程的`return`语句的值。'
- en: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO31-3)'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO31-3)'
- en: Believe it or not!
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你！
- en: This idea of “smuggling” the return value out of the coroutine wrapped in a
    `StopIteration` exception is a bizarre hack. Nevertheless, this bizarre hack is
    part of [PEP 342—Coroutines via Enhanced Generators](https://fpy.li/pep342), and
    is documented with the [`StopIteration` exception](https://fpy.li/17-22), and
    in the [“Yield expressions”](https://fpy.li/17-23) section of Chapter 6 of [*The
    Python Language Reference*](https://fpy.li/17-24).
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 将返回值“偷运”出协程并包装在`StopIteration`异常中的这个想法是一个奇怪的技巧。尽管如此，这个奇怪的技巧是[PEP 342—通过增强生成器实现协程](https://fpy.li/pep342)的一部分，并且在[`StopIteration`异常](https://fpy.li/17-22)和[*Python语言参考*](https://fpy.li/17-24)第6章的[“Yield表达式”](https://fpy.li/17-23)部分有记录。
- en: A delegating generator can get the return value of a coroutine directly using
    the `yield from` syntax, as shown in [Example 17-44](#ex_coro_averager2_demo_3).
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 一个委托生成器可以直接使用`yield from`语法获取协程的返回值，如[示例 17-44](#ex_coro_averager2_demo_3)所示。
- en: 'Example 17-44\. coroaverager2.py: doctest showing `StopIteration` with a `Result`'
  id: totrans-731
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-44\. coroaverager2.py：展示带有`Result`的`StopIteration`的doctest
- en: '[PRE68]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO32-1)'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO32-1)'
- en: '`res` will collect the return value of `averager2`; the `yield from` machinery
    retrieves the return value when it handles the `StopIteration` exception that
    marks the termination of the coroutine. When `True`, the `verbose` parameter makes
    the coroutine print the value received, to make its operation visible.'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '`res`将收集`averager2`的返回值；`yield from`机制在处理标记协程终止的`StopIteration`异常时检索返回值。当`True`时，`verbose`参数使协程打印接收到的值，以便使其操作可见。'
- en: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO32-2)'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO32-2)'
- en: Keep an eye out for the output of this line when this generator runs.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个生成器运行时，请留意这行的输出。
- en: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO32-3)'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO32-3)'
- en: Return the result. This will also be wrapped in `StopIteration`.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 返回结果。这也将被包装在`StopIteration`中。
- en: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO32-4)'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO32-4)'
- en: Create the delegating coroutine object.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 创建委托协程对象。
- en: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO32-5)'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO32-5)'
- en: This loop will drive the delegating coroutine.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环将驱动委托协程。
- en: '[![6](assets/6.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO32-6)'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO32-6)'
- en: First value sent is `None`, to prime the coroutine; last is the sentinel to
    stop it.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个发送的值是`None`，用于启动协程；最后一个是停止它的标志。
- en: '[![7](assets/7.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO32-7)'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO32-7)'
- en: Catch `StopIteration` to fetch the return value of `compute`.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获`StopIteration`以获取`compute`的返回值。
- en: '[![8](assets/8.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO32-8)'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_iterators__generators____span_class__keep_together__and_classic_coroutines__span__CO32-8)'
- en: After the lines output by `averager2` and `compute`, we get the `Result` instance.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 在`averager2`和`compute`输出的行之后，我们得到`Result`实例。
- en: Even though the examples here don’t do much, the code is hard to follow. Driving
    the coroutine with `.send()` calls and retrieving results is complicated, except
    with `yield from`—but we can only use that syntax inside a delegating generator/coroutine,
    which must ultimately be driven by some nontrivial code, as shown in [Example 17-44](#ex_coro_averager2_demo_3).
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这里的示例并没有做太多事情，但代码很难理解。使用`.send()`调用驱动协程并检索结果是复杂的，除非使用`yield from`—但我们只能在委托生成器/协程内部使用该语法，最终必须由一些非平凡的代码驱动，如[示例
    17-44](#ex_coro_averager2_demo_3)所示。
- en: The previous examples show that using coroutines directly is cumbersome and
    confusing. Add exception handling and the coroutine `.throw()` method, and examples
    become even more convoluted. I won’t cover `.throw()` in this book because—like
    `.send()`—it is only useful to drive coroutines “by hand,” but I don’t recommend
    doing that, unless you are creating a new coroutine-based framework from scratch.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例表明直接使用协程是繁琐和令人困惑的。添加异常处理和协程`.throw()`方法，示例变得更加复杂。我不会在本书中涵盖`.throw()`，因为—就像`.send()`一样—它只对手动驱动协程有用，但我不建议这样做，除非你正在从头开始创建一个基于协程的新框架。
- en: Note
  id: totrans-751
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you are interested in deeper coverage of classic coroutines—including the
    `.throw()` method—please check out [“Classic Coroutines”](https://fpy.li/oldcoro)
    at the [*fluentpython.com*](http://fluentpython.com) companion website. That post
    includes Python-like pseudocode detailing how `yield from` drives generators and
    coroutines, as well as a a small discrete event simulation demonstrating a form
    of concurrency using coroutines without an asynchronous programming framework.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对经典协程有更深入的了解—包括`.throw()`方法—请查看[*fluentpython.com*](http://fluentpython.com)伴随网站上的[“经典协程”](https://fpy.li/oldcoro)。该文章包括类似Python的伪代码，详细说明了`yield
    from`如何驱动生成器和协程，以及一个小的离散事件模拟，演示了在没有异步编程框架的情况下使用协程实现并发的形式。
- en: In practice, productive work with coroutines requires the support of a specialized
    framework. That is what `asyncio` provided for classic coroutines way back in
    Python 3.3. With the advent of native coroutines in Python 3.5, the Python core
    developers are gradually phasing out support for classic coroutines in `asyncio`.
    But the underlying mechanisms are very similar. The `async def` syntax makes native
    coroutines easier to spot in code, which is a great benefit. Inside, native coroutines
    use `await` instead of `yield from` to delegate to other coroutines. [Chapter 21](ch21.html#async_ch)
    is all about that.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，与协程一起进行有效的工作需要专门框架的支持。这就是Python 3.3中`asyncio`为经典协程提供的支持。随着Python 3.5中本地协程的出现，Python核心开发人员正在逐渐淘汰`asyncio`中对经典协程的支持。但底层机制非常相似。`async
    def`语法使本地协程在代码中更容易识别，这是一个很大的好处。在内部，本地协程使用`await`而不是`yield from`来委托给其他协程。[第 21
    章](ch21.html#async_ch)就是关于这个的。
- en: Now let’s wrap up the chapter with a mind-bending section about covariance and
    contravariance in type hints for coroutines.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用一个关于协变和逆变的类型提示对协程进行总结。
- en: Generic Type Hints for Classic Coroutines
  id: totrans-755
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经典协程的通用类型提示
- en: Back in [“Contravariant types”](ch15.html#contravariant_types_sec), I mentioned
    `typing.Generator` as one of the few standard library types with a contravariant
    type parameter. Now that we’ve studied classic coroutines, we are ready to make
    sense of this generic type.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[“逆变类型”](ch15.html#contravariant_types_sec)，我提到`typing.Generator`是少数几个具有逆变类型参数的标准库类型之一。现在我们已经学习了经典协程，我们准备理解这种通用类型。
- en: Here is how `typing.Generator` was [declared](https://fpy.li/17-25) in the *typing.py*
    module of Python 3.6:^([16](ch17.html#idm46582398105520))
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`typing.Generator`在Python 3.6的*typing.py*模块中是如何[声明的](https://fpy.li/17-25)的：^([16](ch17.html#idm46582398105520))
- en: '[PRE69]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'That generic type declaration means that a `Generator` type hint requires those
    three type parameters we’ve seen before:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 通用类型声明意味着`Generator`类型提示需要我们之前看到的那三个类型参数：
- en: '[PRE70]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: From the type variables in the formal parameters, we see that `YieldType` and
    `ReturnType` are covariant, but `SendType` is contravariant. To understand why,
    consider that `YieldType` and `ReturnType` are “output” types. Both describe data
    that comes out of the coroutine object—i.e., the generator object when used as
    a coroutine object.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 从形式参数中的类型变量中，我们看到`YieldType`和`ReturnType`是协变的，但`SendType`是逆变的。要理解原因，考虑到`YieldType`和`ReturnType`是“输出”类型。两者描述了从协程对象—即作为协程对象使用时的生成器对象—输出的数据。
- en: It makes sense that these are covariant, because any code expecting a coroutine
    that yields floats can use a coroutine that yields integers. That’s why `Generator`
    is covariant on its `YieldType` parameter. The same reasoning applies to the `ReturnType`
    parameter—also covariant.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 这是合理的，因为任何期望一个产生浮点数的协程的代码可以使用一个产生整数的协程。这就是为什么`Generator`在其`YieldType`参数上是协变的。相同的推理也适用于`ReturnType`参数—也是协变的。
- en: 'Using the notation introduced in [“Covariant types”](ch15.html#covariant_types_sec),
    the covariance of the first and third parameters is expressed by the `:>` symbols
    pointing in the same direction:'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在[“协变类型”](ch15.html#covariant_types_sec)中介绍的符号，第一个和第三个参数的协变性由指向相同方向的`:>`符号表示：
- en: '[PRE71]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`YieldType` and `ReturnType` are examples of the first rule of [“Variance rules
    of thumb”](ch15.html#variance_rules_sec):'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: '`YieldType`和`ReturnType`是[“方差法则的基本原则”](ch15.html#variance_rules_sec)的第一个规则的例子：'
- en: If a formal type parameter defines a type for data that comes out of the object,
    it can be covariant.
  id: totrans-766
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个形式类型参数定义了对象中出来的数据的类型，它可以是协变的。
- en: 'On the other hand, `SendType` is an “input” parameter: it is the type of the
    `value` argument for the `.send(value)` method of the coroutine object. Client
    code that needs to send floats to a coroutine cannot use a coroutine with `int`
    as the `SendType` because `float` is not a subtype of `int`. In other words, `float`
    is not *consistent-with* `int`. But the client can use a coroutine with `complex`
    as the `SendType`, because `float` is a subtype of `complex`, therefore `float`
    is *consistent-with* `complex`.'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`SendType`是一个“输入”参数：它是协程对象的`.send(value)`方法的`value`参数的类型。需要向协程发送浮点数的客户端代码不能使用具有`int`作为`SendType`的协程，因为`float`不是`int`的子类型。换句话说，`float`不与`int`*一致*。但客户端可以使用具有`complex`作为`SendType`的协程，因为`float`是`complex`的子类型，因此`float`与`complex`*一致*。
- en: 'The `:>` notation makes the contravariance of the second parameter visible:'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '`:>`符号使得第二个参数的逆变性可见：'
- en: '[PRE72]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This is an example of the second Variance Rule of Thumb:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二个方差法则的一个例子：
- en: If a formal type parameter defines a type for data that goes into the object
    after its initial construction, it can be contravariant.
  id: totrans-771
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个形式类型参数定义了对象在初始构造之后进入的数据的类型，它可以是逆变的。
- en: This merry discussion of variance completes the longest chapter in the book.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关于方差的欢快讨论完成了本书中最长的章节。
- en: Chapter Summary
  id: totrans-773
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节总结
- en: Iteration is so deeply embedded in the language that I like to say that Python
    groks iterators.^([17](ch17.html#idm46582397961488)) The integration of the Iterator
    pattern in the semantics of Python is a prime example of how design patterns are
    not equally applicable in all programming languages. In Python, a classic Iterator
    implemented “by hand” as in [Example 17-4](#ex_sentence1) has no practical use,
    except as a didactic example.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代在语言中是如此深入，以至于我喜欢说 Python 理解迭代器。[^17] 在 Python 语义中集成迭代器模式是设计模式在所有编程语言中并非都适用的一个主要例子。在
    Python 中，一个经典的手动实现的迭代器，如[示例 17-4](#ex_sentence1)，除了作为教学示例外，没有实际用途。
- en: In this chapter, we built a few versions of a class to iterate over individual
    words in text files that may be very long. We saw how Python uses the `iter()`
    built-in to create iterators from sequence-like objects. We build a classic iterator
    as a class with `__next__()`, and then we used generators to make each successive
    refactoring of the `Sentence` class more concise and readable.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了几个版本的一个类，用于迭代可能非常长的文本文件中的单词。我们看到 Python 如何使用`iter()`内置函数从类似序列的对象创建迭代器。我们构建了一个经典的迭代器作为一个带有`__next__()`的类，然后我们使用生成器使得`Sentence`类的每次重构更加简洁和可读。
- en: We then coded a generator of arithmetic progressions and showed how to leverage
    the `itertools` module to make it simpler. An overview of most general-purpose
    generator functions in the standard library followed.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们编写了一个算术级数的生成器，并展示了如何利用`itertools`模块使其更简单。随后是标准库中大多数通用生成器函数的概述。
- en: We then studied `yield from` expressions in the context of simple generators
    with the `chain` and `tree` examples.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在简单生成器的上下文中研究了`yield from`表达式，使用了`chain`和`tree`示例。
- en: The last major section was about classic coroutines, a topic of waning importance
    after native coroutines were added in Python 3.5. Although difficult to use in
    practice, classic coroutines are the foundation of native coroutines, and the
    `yield from` expression is the direct precursor of `await`.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个主要部分是关于经典协程的，这是在 Python 3.5 中添加原生协程后逐渐失去重要性的一个主题。尽管在实践中难以使用，经典协程是原生协程的基础，而`yield
    from`表达式是`await`的直接前身。
- en: Also covered were type hints for `Iterable`, `Iterator`, and `Generator` types—with
    the latter providing a concrete and rare example of a contravariant type parameter.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 还涵盖了`Iterable`、`Iterator`和`Generator`类型的类型提示—其中后者提供了一个具体且罕见的逆变类型参数的例子。
- en: Further Reading
  id: totrans-780
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: A detailed technical explanation of generators appears in *The Python Language
    Reference* in [“6.2.9\. Yield expressions”](https://fpy.li/17-27). The PEP where
    generator functions were defined is [PEP 255—Simple Generators](https://fpy.li/pep255).
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器的详细技术解释出现在*Python 语言参考*中的[“6.2.9\. Yield expressions”](https://fpy.li/17-27)。定义生成器函数的
    PEP 是[PEP 255—Simple Generators](https://fpy.li/pep255)。
- en: The [`itertools` module documentation](https://fpy.li/17-28) is excellent because
    of all the examples included. Although the functions in that module are implemented
    in C, the documentation shows how some of them would be written in Python, often
    by leveraging other functions in the module. The usage examples are also great;
    for instance, there is a snippet showing how to use the `accumulate` function
    to amortize a loan with interest, given a list of payments over time. There is
    also an [“Itertools Recipes”](https://fpy.li/17-29) section with additional high-performance
    functions that use the `itertools` functions as building blocks.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 由于包含了所有示例，[`itertools`模块文档](https://fpy.li/17-28)非常出色。尽管该模块中的函数是用C实现的，但文档展示了如何用Python编写其中一些函数，通常是通过利用模块中的其他函数。用法示例也很棒；例如，有一个片段展示如何使用`accumulate`函数根据时间给定的付款列表摊销贷款利息。还有一个[“Itertools
    Recipes”](https://fpy.li/17-29)部分，其中包含使用`itertools`函数作为构建块的其他高性能函数。
- en: Beyond Python’s standard library, I recommend the [More Itertools](https://fpy.li/17-30)
    package, which follows the fine `itertools` tradition in providing powerful generators
    with plenty of examples and some useful recipes.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Python标准库之外，我推荐使用[More Itertools](https://fpy.li/17-30)包，它遵循了`itertools`传统，提供了强大的生成器，并附带大量示例和一些有用的技巧。
- en: Chapter 4, “Iterators and Generators,” of *Python Cookbook*, 3rd ed., by David
    Beazley and Brian K. Jones (O’Reilly), has 16 recipes covering this subject from
    many different angles, focusing on practical applications. It includes some illuminating
    recipes with `yield from`.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: David Beazley和Brian K. Jones（O’Reilly）合著的第三版*Python Cookbook*的第4章“迭代器和生成器”涵盖了这个主题的16个配方，从许多不同角度着重于实际应用。其中包括一些使用`yield
    from`的启发性配方。
- en: 'Sebastian Rittau—currently a top contributor of *typeshed*—explains why iterators
    should be iterable, as he noted in 2006 that, [“Java: Iterators are not Iterable”](https://fpy.li/17-31).'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: Sebastian Rittau，目前是*typeshed*的顶级贡献者，解释了为什么迭代器应该是可迭代的，正如他在2006年指出的那样，[“Java：迭代器不可迭代”](https://fpy.li/17-31)。
- en: The `yield from` syntax is explained with examples in the “What’s New in Python
    3.3” section of [PEP 380—Syntax for Delegating to a Subgenerator](https://fpy.li/17-32).
    My post [“Classic Coroutines”](https://fpy.li/oldcoro) at [*fluentpython.com*](http://fluentpython.com)
    explains `yield from` in depth, including Python pseudocode of its implementation
    in C.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: “Python 3.3中的新功能”部分在[PEP 380—委托给子生成器的语法](https://fpy.li/17-32)中用示例解释了`yield
    from`语法。我在[*fluentpython.com*](http://fluentpython.com)上的文章[“经典协程”](https://fpy.li/oldcoro)深入解释了`yield
    from`，包括其在C中实现的Python伪代码。
- en: 'David Beazley is the ultimate authority on Python generators and coroutines.
    The *[Python Cookbook](https://fpy.li/pycook3)*, 3rd ed., (O’Reilly) he coauthored
    with Brian Jones has numerous recipes with coroutines. Beazley’s PyCon tutorials
    on the subject are famous for their depth and breadth. The first was at PyCon
    US 2008: [“Generator Tricks for Systems Programmers”](https://fpy.li/17-33). PyCon
    US 2009 saw the legendary [“A Curious Course on Coroutines and Concurrency”](https://fpy.li/17-34)
    (hard-to-find video links for all three parts: [part 1](https://fpy.li/17-35),
    [part 2](https://fpy.li/17-36), and [part 3](https://fpy.li/17-37)). His tutorial
    from PyCon 2014 in Montréal was [“Generators: The Final Frontier”](https://fpy.li/17-38),
    in which he tackles more concurrency examples—so it’s really more about topics
    in [Chapter 21](ch21.html#async_ch). Dave can’t resist making brains explode in
    his classes, so in the last part of “The Final Frontier,” coroutines replace the
    classic Visitor pattern in an arithmetic expression evaluator.'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: David Beazley是Python生成器和协程的最高权威。他与Brian Jones合著的第三版*[Python Cookbook](https://fpy.li/pycook3)*（O’Reilly）中有许多关于协程的示例。Beazley在PyCon上关于这个主题的教程以其深度和广度而闻名。第一个是在PyCon
    US 2008上的[“系统程序员的生成器技巧”](https://fpy.li/17-33)。PyCon US 2009看到了传奇的[“协程和并发的奇特课程”](https://fpy.li/17-34)（所有三部分的难以找到的视频链接：[part
    1](https://fpy.li/17-35)，[part 2](https://fpy.li/17-36)和[part 3](https://fpy.li/17-37)）。他在2014年蒙特利尔PyCon的教程是[“生成器：最终前沿”](https://fpy.li/17-38)，其中他处理了更多并发示例，因此实际上更多关于[第21章](ch21.html#async_ch)中的主题。Dave无法抵制在他的课堂上让大脑爆炸，因此在“最终前沿”的最后部分，协程取代了经典的访问者模式在算术表达式求值器中。
- en: Coroutines allow new ways of organizing code, and just as recursion or polymorphism
    (dynamic dispatch), it takes some time getting used to their possibilities. An
    interesting example of classic algorithm rewritten with coroutines is in the post
    [“Greedy algorithm with coroutines”](https://fpy.li/17-39), by James Powell.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 协程允许以新的方式组织代码，就像递归或多态（动态分派）一样，需要一些时间来适应它们的可能性。一个有趣的经典算法被用协程重写的例子在James Powell的文章[“使用协程的贪婪算法”](https://fpy.li/17-39)中。
- en: 'Brett Slatkin’s [*Effective Python*, 1st ed.](https://fpy.li/17-40) (Addison-Wesley)
    has an excellent short chapter titled “Consider Coroutines to Run Many Functions
    Concurrently.” That chapter is not in the second edition of *Effective Python*,
    but it is still [available online as a sample chapter](https://fpy.li/17-41).
    Slatkin presents the best example of driving coroutines with `yield from` that
    I’ve seen: an implementation of John Conway’s [Game of Life](https://fpy.li/17-42)
    in which coroutines manage the state of each cell as the game runs. I refactored
    the code for the Game of Life example—separating the functions and classes that
    implement the game from the testing snippets used in Slatkin’s original code.
    I also rewrote the tests as doctests, so you can see the output of the various
    coroutines and classes without running the script. The [refactored example](https://fpy.li/17-43)
    is posted as a [GitHub gist](https://fpy.li/17-44).'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: Brett Slatkin的[*Effective Python*，第1版](https://fpy.li/17-40)（Addison-Wesley）有一章标题为“考虑使用协程并发运行多个函数”的精彩短章。该章节不在*Effective
    Python*的第二版中，但仍然可以作为[在线示例章节](https://fpy.li/17-41)获得。Slatkin提供了我见过的最好的使用`yield
    from`驱动协程的示例：约翰·康威的[生命游戏](https://fpy.li/17-42)的实现，其中协程管理游戏运行时每个单元格的状态。我重构了生命游戏示例的代码——将实现游戏的函数和类与Slatkin原始代码中使用的测试片段分开。我还将测试重写为文档测试，这样您就可以查看各个协程和类的输出而无需运行脚本。[重构后的示例](https://fpy.li/17-43)发布在[GitHub
    gist](https://fpy.li/17-44)上。
- en: ^([1](ch17.html#idm46582406895680-marker)) From [“Revenge of the Nerds”](https://fpy.li/17-1),
    a blog post.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch17.html#idm46582406895680-marker)) 来自[“书呆子的复仇”](https://fpy.li/17-1)，一篇博客文章。
- en: '^([2](ch17.html#idm46582406680288-marker)) We first used `reprlib` in [“Vector
    Take #1: Vector2d Compatible”](ch12.html#vector_take1_sec).'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: '^([2](ch17.html#idm46582406680288-marker)) 我们首次在[“向量 Take #1：Vector2d 兼容”](ch12.html#vector_take1_sec)中使用了`reprlib`。'
- en: ^([3](ch17.html#idm46582405697760-marker)) Thanks to tech reviewer Leonardo
    Rochael for this fine example.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch17.html#idm46582405697760-marker)) 感谢技术审阅员Leonardo Rochael提供这个很好的例子。
- en: '^([4](ch17.html#idm46582405269920-marker)) When reviewing this code, Alex Martelli
    suggested the body of this method could simply be `return iter(self.words)`. He
    is right: the result of calling `self.words.__iter__()` would also be an iterator,
    as it should be. However, I used a `for` loop with `yield` here to introduce the
    syntax of a generator function, which requires the `yield` keyword, as we’ll see
    in the next section. During review of the second edition of this book, Leonardo
    Rochael suggested yet another shortcut for the body of `__iter__`: `yield from
    self.words`. We’ll also cover `yield from` later in this chapter.'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch17.html#idm46582405269920-marker)) 在审查这段代码时，Alex Martelli建议这个方法的主体可以简单地是`return
    iter(self.words)`。他是对的：调用`self.words.__iter__()`的结果也将是一个迭代器，正如应该的那样。然而，在这里我使用了一个带有`yield`的`for`循环来介绍生成器函数的语法，这需要使用`yield`关键字，我们将在下一节中看到。在审查本书第二版时，Leonardo
    Rochael建议`__iter__`的主体还有另一个快捷方式：`yield from self.words`。我们稍后也会介绍`yield from`。
- en: '^([5](ch17.html#idm46582405203104-marker)) Sometimes I add a `gen` prefix or
    suffix when naming generator functions, but this is not a common practice. And
    you can’t do that if you’re implementing an iterable, of course: the necessary
    special method must be named `__iter__`.'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch17.html#idm46582405203104-marker)) 有时在命名生成器函数时我会添加`gen`前缀或后缀，但这不是一种常见做法。当然，如果您正在实现一个可迭代对象，那么您不能这样做：必需的特殊方法必须命名为`__iter__`。
- en: ^([6](ch17.html#idm46582405200304-marker)) Thanks to David Kwast for suggesting
    this example.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch17.html#idm46582405200304-marker)) 感谢David Kwast提出这个例子。
- en: ^([7](ch17.html#idm46582403863072-marker)) In Python 2, there was a `coerce()`
    built-in function, but it’s gone in Python 3\. It was deemed unnecessary because
    the numeric coercion rules are implicit in the arithmetic operator methods. So
    the best way I could think of to coerce the initial value to be of the same type
    as the rest of the series was to perform the addition and use its type to convert
    the result. I asked about this in the Python-list and got an excellent [response
    from Steven D’Aprano](https://fpy.li/17-11).
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch17.html#idm46582403863072-marker)) 在Python 2中，有一个名为`coerce()`的内置函数，但在Python
    3中已经消失了。这被认为是不必要的，因为数值强制转换规则在算术运算符方法中是隐含的。因此，我能想到的将初始值强制转换为与系列其余部分相同类型的最佳方法是执行加法并使用其类型来转换结果。我在Python-list中询问了这个问题，并从Steven
    D’Aprano那里得到了一个很好的[回答](https://fpy.li/17-11)。
- en: ^([8](ch17.html#idm46582403808176-marker)) The *17-it-generator/* directory
    in the [*Fluent Python* code repository](https://fpy.li/code) includes doctests
    and a script, *aritprog_runner.py*, which runs the tests against all variations
    of the *aritprog*.py* scripts.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch17.html#idm46582403808176-marker)) [*流畅的Python*代码库](https://fpy.li/code)中的*17-it-generator/*目录包含了文档测试和一个名为*aritprog_runner.py*的脚本，该脚本针对*aritprog*.py*脚本的所有变体运行测试。
- en: ^([9](ch17.html#idm46582403237584-marker)) Here, the term “mapping” is unrelated
    to dictionaries, but has to do with the `map` built-in.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch17.html#idm46582403237584-marker)) 这里，“映射”一词与字典无关，而是与`map`内置函数有关。
- en: ^([10](ch17.html#idm46582401008976-marker)) `chain` and most `itertools` functions
    are written in C.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch17.html#idm46582401008976-marker)) `chain`和大多数`itertools`函数是用C编写的。
- en: ^([11](ch17.html#idm46582399629568-marker)) As of version 0.910, Mypy still
    uses the deprecated `typing` types.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch17.html#idm46582399629568-marker)) 截至��本0.910，Mypy仍在使用已弃用的`typing`类型。
- en: ^([12](ch17.html#idm46582399407296-marker)) Slide 33, “Keeping It Straight,”
    in [“A Curious Course on Coroutines and Concurrency”](https://fpy.li/17-18).
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: ^([12](ch17.html#idm46582399407296-marker)) [“关于协程和并发的一门奇特课程”](https://fpy.li/17-18)中的幻灯片33，“保持直线”。
- en: '^([13](ch17.html#idm46582399396160-marker)) This example is inspired by a snippet
    from Jacob Holm in the Python-ideas list, message titled [“Yield-From: Finalization
    guarantees”](https://fpy.li/17-20). Some variations appear later in the thread,
    and Holm further explains his thinking in [message 003912](https://fpy.li/17-21).'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '^([13](ch17.html#idm46582399396160-marker)) 这个例子受到Python-ideas列表中Jacob Holm的一段代码片段的启发，标题为[“Yield-From:
    Finalization guarantees”](https://fpy.li/17-20)。稍后的线程中出现了一些变体，Holm在[消息003912](https://fpy.li/17-21)中进一步解释了他的想法。'
- en: ^([14](ch17.html#idm46582399308016-marker)) In fact, it never returns unless
    some exception breaks the loop. Mypy 0.910 accepts both `None` and `typing​.NoReturn`
    as the generator return type parameter—but it also accepts `str` in that position,
    so apparently it can’t fully analyze the coroutine code at this time.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: ^([14](ch17.html#idm46582399308016-marker)) 实际上，除非某个异常中断循环，否则它永远不会返回。Mypy 0.910
    接受 `None` 和 `typing.NoReturn` 作为生成器返回类型参数，但它还接受 `str` 在该位置，因此显然它目前无法完全分析协程代码。
- en: '^([15](ch17.html#idm46582398943024-marker)) I considered renaming the field,
    but `count` is the best name for the local variable in the coroutine, and is the
    name I used for this variable in similar examples in the book, so it makes sense
    to use the same name in the `Result` field. I don’t hesitate to use `# type: ignore`
    to avoid the limitations and annoyances of static type checkers when submission
    to the tool would make the code worse or needlessly complicated.'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '^([15](ch17.html#idm46582398943024-marker)) 我考虑过更改字段的名称，但 `count` 是协程中局部变量的最佳名称，并且在书中的类似示例中我也使用了这个变量的名称，因此在
    `Result` 字段中使用相同的名称是有道理的。我毫不犹豫地使用 `# type: ignore` 来避免静态类型检查器的限制和烦恼，当提交到工具时会使代码变得更糟或不必要复杂时。'
- en: ^([16](ch17.html#idm46582398105520-marker)) Since Python 3.7, `typing.Generator`
    and other types that correspond to ABCs in `collections.abc` were refactored with
    a wrapper around the corresponding ABC, so their generic parameters aren’t visible
    in the *typing.py* source file. That’s why I refer to Python 3.6 source code here.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: ^([16](ch17.html#idm46582398105520-marker)) 自 Python 3.7 起，`typing.Generator`
    和其他与 `collections.abc` 中的 ABCs 对应的类型被重构，使用了对应 ABC 的包装器，因此它们的泛型参数在 *typing.py*
    源文件中不可见。这就是为什么我在这里引用 Python 3.6 源代码的原因。
- en: ^([17](ch17.html#idm46582397961488-marker)) According to the [Jargon file](https://fpy.li/17-26),
    to *grok* is not merely to learn something, but to absorb it so “it becomes part
    of you, part of your identity.”
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: ^([17](ch17.html#idm46582397961488-marker)) 根据[Jargon 文件](https://fpy.li/17-26)，*grok*
    不仅仅是学习某事，而是吸收它，使其“成为你的一部分，成为你身份的一部分”。
- en: '^([18](ch17.html#idm46582397910656-marker)) Gamma et. al., *Design Patterns:
    Elements of Reusable Object-Oriented Software*, p. 261.'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: ^([18](ch17.html#idm46582397910656-marker)) Gamma 等人，《设计模式：可复用面向对象软件的元素》，第 261
    页。
- en: ^([19](ch17.html#idm46582397894560-marker)) The code is in Python 2 because
    one of its optional dependencies is a Java library named *Bruma*, which we can
    import when we run the script with Jython—which does not yet support Python 3.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: ^([19](ch17.html#idm46582397894560-marker)) 代码是用 Python 2 编写的，因为其中一个可选依赖项是名为
    *Bruma* 的 Java 库，我们可以在使用 Jython 运行脚本时导入它——而 Jython 尚不支持 Python 3。
- en: ^([20](ch17.html#idm46582397884176-marker)) The library used to read the complex
    *.mst* binary is actually written in Java, so this functionality is only available
    when *isis2json.py* is executed with the Jython interpreter, version 2.5 or newer.
    For further details, see the [*README.rst*](https://fpy.li/17-47) file in the
    repository. The dependencies are imported inside the generator functions that
    need them, so the script can run even if only one of the external libraries is
    available.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: ^([20](ch17.html#idm46582397884176-marker)) 用于读取复杂的 *.mst* 二进制文件的库实际上是用 Java
    编写的，因此只有在使用 Jython 解释器（版本为 2.5 或更新版本）执行 *isis2json.py* 时才能使用此功能。有关更多详细信息，请参阅存储库中的
    [*README.rst*](https://fpy.li/17-47) 文件。依赖项是在需要它们的生成器函数内导入的，因此即使只有一个外部库可用，脚本也可以运行。
