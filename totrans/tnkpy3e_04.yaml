- en: 2\. Variables and Statements#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://allendowney.github.io/ThinkPython/chap02.html](https://allendowney.github.io/ThinkPython/chap02.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the previous chapter, we used operators to write expressions that perform
    arithmetic computations.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn about variables and statements, the `import` statement,
    and the `print` function. And I’ll introduce more of the vocabulary we use to
    talk about programs, including “argument” and “module”.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1\. Variables[#](#variables "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **variable** is a name that refers to a value. To create a variable, we can
    write a **assignment statement** like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'An assignment statement has three parts: the name of the variable on the left,
    the equals operator, `=`, and an expression on the right. In this example, the
    expression is an integer. In the following example, the expression is a floating-point
    number.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: And in the following example, the expression is a string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run an assignment statement, there is no output. Python creates the
    variable and gives it a value, but the assignment statement has no visible effect.
    However, after creating a variable, you can use it as an expression. So we can
    display the value of `message` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can also use a variable as part of an expression with arithmetic operators.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: And you can use a variable when you call a function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 2.2\. State diagrams[#](#state-diagrams "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common way to represent variables on paper is to write the name with an arrow
    pointing to its value.
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/54319c437cca81caa5fa9ee52a1edfb01810e693b7ebd67c56de713f1d132655.png](../Images/137875fd94efd00be105057fca45cab8.png)'
  prefs: []
  type: TYPE_IMG
- en: This kind of figure is called a **state diagram** because it shows what state
    each of the variables is in (think of it as the variable’s state of mind). We’ll
    use state diagrams throughout the book to represent a model of how Python stores
    variables and their values.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3\. Variable names[#](#variable-names "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variable names can be as long as you like. They can contain both letters and
    numbers, but they can’t begin with a number. It is legal to use uppercase letters,
    but it is conventional to use only lower case for variable names.
  prefs: []
  type: TYPE_NORMAL
- en: The only punctuation that can appear in a variable name is the underscore character,
    `_`. It is often used in names with multiple words, such as `your_name` or `airspeed_of_unladen_swallow`.
  prefs: []
  type: TYPE_NORMAL
- en: If you give a variable an illegal name, you get a syntax error. The name `million!`
    is illegal because it contains punctuation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`76trombones` is illegal because it starts with a number.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`class` is also illegal, but it might not be obvious why.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It turns out that `class` is a **keyword**, which is a special word used to
    specify the structure of a program. Keywords can’t be used as variable names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a complete list of Python’s keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You don’t have to memorize this list. In most development environments, keywords
    are displayed in a different color; if you try to use one as a variable name,
    you’ll know.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4\. The import statement[#](#the-import-statement "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to use some Python features, you have to **import** them. For example,
    the following statement imports the `math` module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: A **module** is a collection of variables and functions. The math module provides
    a variable called `pi` that contains the value of the mathematical constant denoted
    \(\pi\). We can display its value like this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: To use a variable in a module, you have to use the **dot operator** (`.`) between
    the name of the module and the name of the variable.
  prefs: []
  type: TYPE_NORMAL
- en: The math module also contains functions. For example, `sqrt` computes square
    roots.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: And `pow` raises one number to the power of a second number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point we’ve seen two ways to raise a number to a power: we can use
    the `math.pow` function or the exponentiation operator, `**`. Either one is fine,
    but the operator is used more often than the function.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.5\. Expressions and statements[#](#expressions-and-statements "Link to this
    heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve seen a few kinds of expressions. An expression can be a single
    value, like an integer, floating-point number, or string. It can also be a collection
    of values and operators. And it can include variable names and function calls.
    Here’s an expression that includes several of these elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We have also seen a few kind of statements. A **statement** is a unit of code
    that has an effect, but no value. For example, an assignment statement creates
    a variable and gives it a value, but the statement itself has no value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, an import statement has an effect – it imports a module so we can
    use the variables and functions it contains – but it has no visible effect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Computing the value of an expression is called **evaluation**. Running a statement
    is called **execution**.
  prefs: []
  type: TYPE_NORMAL
- en: 2.6\. The print function[#](#the-print-function "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you evaluate an expression, the result is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: But if you evaluate more than one expression, only the value of the last one
    is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: To display more than one value, you can use the `print` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: It also works with floating-point numbers and strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You can also use a sequence of expressions separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `print` function puts a space between the values.
  prefs: []
  type: TYPE_NORMAL
- en: 2.7\. Arguments[#](#arguments "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you call a function, the expression in parenthesis is called an **argument**.
    Normally I would explain why, but in this case the technical meaning of a term
    has almost nothing to do with the common meaning of the word, so I won’t even
    try.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the functions we’ve seen so far take only one argument, like `int`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Some take two, like `math.pow`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Some can take additional arguments that are optional. For example, `int` can
    take a second argument that specifies the base of the number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The sequence of digits `101` in base 2 represents the number 5 in base 10.
  prefs: []
  type: TYPE_NORMAL
- en: '`round` also takes an optional second argument, which is the number of decimal
    places to round off to.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Some functions can take any number of arguments, like `print`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: If you call a function and provide too many arguments, that’s a `TypeError`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If you provide too few arguments, that’s also a `TypeError`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: And if you provide an argument with a type the function can’t handle, that’s
    a `TypeError`, too.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This kind of checking can be annoying when you are getting started, but it helps
    you detect and correct errors.
  prefs: []
  type: TYPE_NORMAL
- en: 2.8\. Comments[#](#comments "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As programs get bigger and more complicated, they get more difficult to read.
    Formal languages are dense, and it is often difficult to look at a piece of code
    and figure out what it is doing and why.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, it is a good idea to add notes to your programs to explain
    in natural language what the program is doing. These notes are called **comments**,
    and they start with the `#` symbol.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the comment appears on a line by itself. You can also put comments
    at the end of a line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Everything from the `#` to the end of the line is ignored—it has no effect on
    the execution of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Comments are most useful when they document non-obvious features of the code.
    It is reasonable to assume that the reader can figure out *what* the code does;
    it is more useful to explain *why*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This comment is redundant with the code and useless:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This comment contains useful information that is not in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Good variable names can reduce the need for comments, but long names can make
    complex expressions hard to read, so there is a tradeoff.
  prefs: []
  type: TYPE_NORMAL
- en: 2.9\. Debugging[#](#debugging "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Three kinds of errors can occur in a program: syntax errors, runtime errors,
    and semantic errors. It is useful to distinguish between them in order to track
    them down more quickly.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Syntax error**: “Syntax” refers to the structure of a program and the rules
    about that structure. If there is a syntax error anywhere in your program, Python
    does not run the program. It displays an error message immediately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime error**: If there are no syntax errors in your program, it can start
    running. But if something goes wrong, Python displays an error message and stops.
    This type of error is called a runtime error. It is also called an **exception**
    because it indicates that something exceptional has happened.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Semantic error**: The third type of error is “semantic”, which means related
    to meaning. If there is a semantic error in your program, it runs without generating
    error messages, but it does not do what you intended. Identifying semantic errors
    can be tricky because it requires you to work backward by looking at the output
    of the program and trying to figure out what it is doing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we’ve seen, an illegal variable name is a syntax error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: If you use an operator with a type it doesn’t support, that’s a runtime error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here’s an example of a semantic error. Suppose we want to compute
    the average of `1` and `3`, but we forget about the order of operations and write
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: When this expression is evaluated, it does not produce an error message, so
    there is no syntax error or runtime error. But the result is not the average of
    `1` and `3`, so the program is not correct. This is a semantic error because the
    program runs but it doesn’t do what’s intended.
  prefs: []
  type: TYPE_NORMAL
- en: 2.10\. Glossary[#](#glossary "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**variable:** A name that refers to a value.'
  prefs: []
  type: TYPE_NORMAL
- en: '**assignment statement:** A statement that assigns a value to a variable.'
  prefs: []
  type: TYPE_NORMAL
- en: '**state diagram:** A graphical representation of a set of variables and the
    values they refer to.'
  prefs: []
  type: TYPE_NORMAL
- en: '**keyword:** A special word used to specify the structure of a program.'
  prefs: []
  type: TYPE_NORMAL
- en: '**import statement:** A statement that reads a module file so we can use the
    variables and functions it contains.'
  prefs: []
  type: TYPE_NORMAL
- en: '**module:** A file that contains Python code, including function definitions
    and sometimes other statements.'
  prefs: []
  type: TYPE_NORMAL
- en: '**dot operator:** The operator, `.`, used to access a function in another module
    by specifying the module name followed by a dot and the function name.'
  prefs: []
  type: TYPE_NORMAL
- en: '**evaluate:** Perform the operations in an expression in order to compute a
    value.'
  prefs: []
  type: TYPE_NORMAL
- en: '**statement:** One or more lines of code that represent a command or action.'
  prefs: []
  type: TYPE_NORMAL
- en: '**execute:** Run a statement and do what it says.'
  prefs: []
  type: TYPE_NORMAL
- en: '**argument:** A value provided to a function when the function is called.'
  prefs: []
  type: TYPE_NORMAL
- en: '**comment:** Text included in a program that provides information about the
    program but has no effect on its execution.'
  prefs: []
  type: TYPE_NORMAL
- en: '**runtime error:** An error that causes a program to display an error message
    and exit.'
  prefs: []
  type: TYPE_NORMAL
- en: '**exception:** An error that is detected while the program is running.'
  prefs: []
  type: TYPE_NORMAL
- en: '**semantic error:** An error that causes a program to do the wrong thing, but
    not to display an error message.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.11\. Exercises[#](#exercises "Link to this heading")
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 2.11.1\. Ask a virtual assistant[#](#ask-a-virtual-assistant "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Again, I encourage you to use a virtual assistant to learn more about any of
    the topics in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If you are curious about any of keywords I listed, you could ask “Why is class
    a keyword?” or “Why can’t variable names be keywords?”
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that `int`, `float`, and `str` are not Python keywords.
    They are variables that represent types, and they can be used as functions. So
    it is *legal* to have a variable or function with one of those names, but it is
    strongly discouraged. Ask an assistant “Why is it bad to use int, float, and str
    as variable names?”
  prefs: []
  type: TYPE_NORMAL
- en: Also ask, “What are the built-in functions in Python?” If you are curious about
    any of them, ask for more information.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we imported the `math` module and used some of the variable
    and functions it provides. Ask an assistant, “What variables and functions are
    in the math module?” and “Other than math, what modules are considered core Python?”
  prefs: []
  type: TYPE_NORMAL
- en: 2.11.2\. Exercise[#](#exercise "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Repeating my advice from the previous chapter, whenever you learn a new feature,
    you should make errors on purpose to see what goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen that `n = 17` is legal. What about `17 = n`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How about `x = y = 1`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some languages every statement ends with a semi-colon (`;`). What happens
    if you put a semi-colon at the end of a Python statement?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What if you put a period at the end of a statement?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if you spell the name of a module wrong and try to import `maath`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2.11.3\. Exercise[#](#id1 "Link to this heading")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Practice using the Python interpreter as a calculator:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part 1.** The volume of a sphere with radius \(r\) is \(\frac{4}{3} \pi r^3\).
    What is the volume of a sphere with radius 5? Start with a variable named `radius`
    and then assign the result to a variable named `volume`. Display the result. Add
    comments to indicate that `radius` is in centimeters and `volume` in cubic centimeters.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Part 2.** A rule of trigonometry says that for any value of \(x\), \((\cos
    x)^2 + (\sin x)^2 = 1\). Let’s see if it’s true for a specific value of \(x\)
    like 42.'
  prefs: []
  type: TYPE_NORMAL
- en: Create a variable named `x` with this value. Then use `math.cos` and `math.sin`
    to compute the sine and cosine of \(x\), and the sum of their squared.
  prefs: []
  type: TYPE_NORMAL
- en: The result should be close to 1\. It might not be exactly 1 because floating-point
    arithmetic is not exact—it is only approximately correct.
  prefs: []
  type: TYPE_NORMAL
- en: '**Part 3.** In addition to `pi`, the other variable defined in the `math` module
    is `e`, which represents the base of the natural logarithm, written in math notation
    as \(e\). If you are not familiar with this value, ask a virtual assistant “What
    is `math.e`?” Now let’s compute \(e^2\) three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `math.e` and the exponentiation operator (`**`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `math.pow` to raise `math.e` to the power `2`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `math.exp`, which takes as an argument a value, \(x\), and computes \(e^x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might notice that the last result is slightly different from the other two.
    See if you can find out which is correct.
  prefs: []
  type: TYPE_NORMAL
- en: '[Think Python: 3rd Edition](https://allendowney.github.io/ThinkPython/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Copyright 2024 [Allen B. Downey](https://allendowney.com)
  prefs: []
  type: TYPE_NORMAL
- en: 'Code license: [MIT License](https://mit-license.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Text license: [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)'
  prefs: []
  type: TYPE_NORMAL
