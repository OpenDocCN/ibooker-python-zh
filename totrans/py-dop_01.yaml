- en: Chapter 1\. Python Essentials for DevOps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章。DevOps 的 Python 基础知识
- en: DevOps, the combination of software development with information technology
    operations, has been a hot field during the last decade. Traditional boundaries
    among software development, deployment, maintenance, and quality assurance have
    been broken, enabling more integrated teams. Python has been a popular language
    both in traditional IT operations and in DevOps due to its combination of flexibility,
    power, and ease of use.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 是软件开发与信息技术运营相结合的领域，在过去的十年中非常热门。传统的软件开发、部署、维护和质量保证之间的界限已经被打破，使得团队更加整合。Python
    在传统 IT 运营和 DevOps 中都非常流行，因为它兼具灵活性、强大性和易用性。
- en: The Python programming language was publicly released in the early 1990s for
    use in system administration. It has been a great success in this area and has
    gained wide adoption. Python is a general-purpose programming language used in
    just about every domain. The visual effects and the motion picture industries
    embraced it. More recently, it has become the de facto language of data science
    and machine learning (ML). It has been used across industries from aviation to
    bioinformatics. Python has an extensive arsenal of tools to cover the wide-ranging
    needs of its users. Learning the whole Python Standard Library (the capabilities
    that come with any Python installation) would be a daunting task. Trying to learn
    all the third-party packages that enliven the Python ecosystem would be an immense
    undertaking. The good news is that you don’t need to do those things. You can
    become a powerful DevOps practitioner by learning only a small subset of Python.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python 编程语言于 1990 年代初公开发布，用于系统管理。在这一领域取得了巨大成功，并广泛应用。Python 是一种通用编程语言，几乎在所有领域都有使用。视觉效果和电影行业都采用了它。最近，它已成为数据科学和机器学习（ML）的事实标准语言。它已经被应用于从航空到生物信息学的各个行业。Python
    拥有丰富的工具库，以满足用户广泛的需求。学习整个 Python 标准库（任何 Python 安装都带有的功能）将是一项艰巨的任务。试图学习所有为 Python
    生态系统注入活力的第三方包将是一项巨大的工程。好消息是，您不需要做这些事情。通过学习 Python 的一个小子集，您可以成为强大的 DevOps 实践者。
- en: In this chapter, we draw on our decades of Python DevOps experience to teach
    only the elements of the language that you need. These are the parts of Python
    DevOps that are used daily. They form the essential toolbox to get things done.
    Once you have these core concepts down, you can add more complicated tools, as
    you’ll see in later chapters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们利用几十年的 Python DevOps 经验，仅教授您需要的语言元素。这些是日常使用的 Python DevOps 部分。它们构成了完成工作的基本工具箱。一旦掌握了这些核心概念，您可以添加更复杂的工具，正如您将在后续章节中看到的那样。
- en: Installing and Running Python
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和运行 Python
- en: 'If you want to try the code in this overview, you need Python 3.7 or later
    installed (the latest release is 3.8.0 as of this writing) and access to a shell.
    In macOS X, Windows, and most Linux distributions, you can open the terminal application
    to access a shell. To see what version of Python you are using, open a shell,
    and type `python` `--version`:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想尝试本概述中的代码，则需要安装 Python 3.7 或更高版本（截至本文撰写时的最新版本为 3.8.0），并且可以访问一个 shell。在 macOS
    X、Windows 和大多数 Linux 发行版中，您可以打开终端应用程序以访问 shell。要查看正在使用的 Python 版本，请打开 shell 并键入
    `python` `--version`：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Python installers can be downloaded directly from the [Python.org website](https://www.python.org/downloads).
    Alternatively, you can use a package manager such as Apt, RPM, MacPorts, Homebrew,
    Chocolatey, or many others.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python 安装程序可以直接从 [Python.org 网站](https://www.python.org/downloads) 下载。或者，您可以使用像
    Apt、RPM、MacPorts、Homebrew、Chocolatey 或其他许多包管理器。
- en: The Python Shell
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python Shell
- en: The simplest way to run Python is to use the built-in interactive interpreter.
    Just type `python` in a shell. You can then interactively run Python statements.
    Type `exit()` to exit the shell.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Python 的最简单方式是使用内置的交互式解释器。只需在 shell 中键入 `python`。然后可以交互地运行 Python 语句。输入 `exit()`
    来退出 shell。
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Python scripts
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 脚本
- en: 'Python code runs from a file with the *.py* extension:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python 代码通过 *.py* 扩展名的文件运行：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Save this code to a file named *hello.py*. To invoke the script, in a shell
    run `python` followed by the filename:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码保存到名为*hello.py*的文件中。要调用脚本，在 shell 中运行`python`，然后是文件名：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Python scripts are how most production Python code runs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Python 脚本是大多数生产 Python 代码的运行方式。
- en: IPython
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPython
- en: 'Besides the built-in interactive shell, several third-party interactive shells
    run Python code. One of the most popular is [IPython](https://ipython.org). IPython
    offers *introspection* (the ability to dynamically get information about objects),
    syntax highlighting, special *magic* commands (which we touch on later in this
    chapter), and many more features, making it a pleasure to use for exploring Python.
    To install IPython, use the Python package manager, `pip`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内置的交互式 shell 外，还有几个第三方交互式 shell 可以运行 Python 代码。其中最受欢迎的之一是 [IPython](https://ipython.org)。IPython
    提供*内省*（动态获取对象信息的能力）、语法高亮、特殊的*魔术*命令（我们稍后在本章介绍），以及许多其他功能，使其成为探索 Python 的乐趣所在。要安装
    IPython，请使用 Python 包管理器 `pip`：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Running is similar to running the built-in interactive shell described in the
    previous section:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 运行类似于在上一节中描述的内置交互式 shell 运行：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Jupyter Notebooks
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jupyter 笔记本
- en: 'A spin-off from the iPython project, the Jupyter project allows documents containing
    text, code, and visualizations. These documents are powerful tools for combining
    running code, output, and formatted text. Jupyter enables the delivery of documentation
    along with the code. It has achieved widespread popularity, especially in the
    data science world. Here is how to install and run Jupyter notebooks:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: iPython 项目的一个分支，Jupyter 项目允许包含文本、代码和可视化的文档。这些文档是结合运行代码、输出和格式化文本的强大工具。Jupyter
    使得可以将文档与代码一起交付。它在数据科学领域尤其广受欢迎。以下是安装和运行 Jupyter 笔记本的方法：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This command opens a web browser tab showing the current working directory.
    From here, you can open existing notebooks in the current project or create new
    ones.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令打开一个网页浏览器标签，显示当前工作目录。从这里，您可以打开当前项目中的现有笔记本或创建新的笔记本。
- en: Procedural Programming
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过程式编程
- en: 'If you’ve been around programming at all, you’ve probably heard terms like
    object-oriented programming (OOP) and functional programming. These are different
    architectural paradigms used to organize programs. One of the most basic paradigms,
    procedural programming, is an excellent place to start. *Procedural programming*
    is the issuing of instructions to a computer in an ordered sequence:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对编程有所了解，可能已经听说过面向对象编程（OOP）和函数式编程等术语。这些是用于组织程序的不同架构范式。其中最基本的范式之一，过程式编程，是一个很好的起点。*过程式编程*是按顺序向计算机发出指令：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see in this example, there are three statements that are executed
    in order from the first line to the last. Each statement uses the state produced
    by the previous ones. In this case, the first statement assigns the value 3 to
    a variable named `i`. In the second statement, this variable’s value is used to
    assign a value to a variable named `j`, and in the third statement, the values
    from both variables are added together. Don’t worry about the details of these
    statements yet; notice that they are executed in order and rely on the state created
    by the previous statements.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在此示例中看到的那样，有三个语句按顺序执行，从第一行到最后一行。每个语句都使用前面语句产生的状态。在本例中，第一个语句将值 3 分配给名为 `i`
    的变量。在第二个语句中，使用此变量的值将一个值分配给名为 `j` 的变量，在第三个语句中，从两个变量中的值相加。暂时不用担心这些语句的细节；请注意它们按顺序执行并依赖于前面语句创建的状态。
- en: Variables
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: 'A variable is a name that points to some value. In the previous example, the
    variables are `i` and `j` . Variables in Python can be assigned to new values:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是指向某个值的名称。在前面的例子中，变量是 `i` 和 `j`。Python 中的变量可以分配新值：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Python variables use dynamic typing. In practice, this means that they can
    be reassigned to values of different types or classes:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Python 变量使用动态类型。实际上，这意味着它们可以被重新分配给不同类型或类的值：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here the same variable is set to a string, a number, and a dictionary. Variables
    can be reassigned to values of any type.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，同一个变量分别设置为字符串、数字和字典。变量可以重新分配为任何类型的值。
- en: Basic Math
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本数学
- en: 'Basic math operations such as addition, subtraction, multiplication, and division
    can all be performed using built-in math operators:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 可使用内置数学运算符执行基本的数学运算，如加法、减法、乘法和除法：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that a `//` symbol is for integer division. The symbol `**` creates an
    exponent, and `%` is the modulo operator:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`//` 符号用于整数除法。符号 `**` 表示指数运算，`%` 是取模运算符：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Comments
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: 'Comments are text ignored by the Python interpreter. They are useful for documentation
    of code and can be mined by some services to provide standalone documentation.
    Single-line comments are delineated by prepending with `#`. A single-line comment
    can start at the beginning of a line, or at any point thereafter. Everything after
    the `#` is part of the comment until a new line break occurs:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注释是Python解释器忽略的文本。它们对代码的文档化很有用，可以被某些服务用来提供独立的文档。单行注释以`#`开头。单行注释可以从行的开头开始，或者之后的任何地方开始。`#`之后的所有内容都是注释，直到新的换行符出现为止。
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Multiline comments are enclosed themselves in blocks beginning and ending with
    either `"""` or `''''''`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释本身被封闭在以`"""`或`'''`开头和结尾的块中：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Built-in Functions
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置函数
- en: Functions are statements grouped as a unit. You invoke a function by typing
    the function name, followed by parentheses. If the function takes arguments, the
    arguments appear within the parentheses. Python has many built-in functions. Two
    of the most widely used built-in functions are `print` and `range`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是作为一个单元分组的语句。通过键入函数名，后跟括号来调用函数。如果函数带有参数，则参数出现在括号内。Python有许多内置函数。其中两个最常用的内置函数是`print`和`range`。
- en: Print
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打印
- en: 'The `print` function produces output that a user of a program can view. It
    is less relevant in interactive environments but is a fundamental tool when writing
    Python scripts. In the previous example, the argument to the `print` function
    is written as output when the script runs:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`print`函数生成用户程序可以查看的输出。在交互式环境中它不太相关，但在编写Python脚本时是一种基本工具。在前面的示例中，`print`函数的参数在脚本运行时作为输出写入：'
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`print` can be used to see the value of a variable or to give feedback as to
    the state of a program. `print` generally outputs the standard output stream and
    is visible as program output in a shell.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`print`可以用于查看变量的值或提供程序状态的反馈。`print`通常将标准输出流输出，并在shell中作为程序输出可见。'
- en: Range
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围
- en: Though `range` is a built-in function, it is technically not a function at all.
    It is a type representing a sequence of numbers. When calling the `range()` constructor,
    an object representing a sequence of numbers is returned. Range objects count
    through a sequence of numbers. The `range` function takes up to three integer
    arguments. If only one argument appears, then the sequence is represented by the
    numbers from zero up to, but not including, that number. If a second argument
    appears, it represents the starting point, rather than the default of starting
    from 0\. The third argument can be used to specify the step distance, and it defaults
    to 1.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`range`是一个内置函数，但技术上它根本不是一个函数。它是表示数字序列的类型。调用`range()`构造函数时，会返回一个表示数字序列的对象。范围对象逐个数字计数。`range`函数最多接受三个整数参数。如果只有一个参数出现，则序列由从零到该数字（但不包括该数字）的数字表示。如果出现第二个参数，则表示起始点，而不是从0开始的默认值。第三个参数可用于指定步长距离，默认为1。
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`range` maintains a small memory footprint, even over extended sequences, as
    it only stores the start, stop, and step values. The `range` function can iterate
    through long sequences of numbers without performance constraints.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`range`维护一个小的内存占用，即使在长序列中也是如此，因为它只存储起始、停止和步长值。`range`函数可以迭代长序列的数字而不受性能约束。'
- en: Execution Control
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行控制
- en: Python has many constructs to control the flow of statement execution. You can
    group statements you wish to run together as a block of code. These blocks can
    be run multiple times using `for` and `while` loops or only run under certain
    conditions using `if` statements, `while` loops, or `try-except` blocks. Using
    these constructs is the first step to taking advantage of the power of programming.
    Different languages demarcate blocks of code using different conventions. Many
    languages with syntax similar to the C language (a very influential language used
    in writing Unix) use curly brackets around a group of statements to define a block.
    In Python, indentation is used to indicate a block. Statements are grouped by
    indentation into blocks that execute as a unit.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Python有许多构造来控制语句执行的流程。你可以将希望一起运行的语句组成一个代码块。这些代码块可以使用`for`和`while`循环多次运行，或者仅在某些条件下运行，例如`if`语句、`while`循环或`try-except`块。使用这些构造是利用编程力量的第一步。不同的语言使用不同的约定来标记代码块。许多类似C语言（Unix中使用的一种非常有影响力的语言）的语法的语言，使用花括号来定义一组语句的块。在Python中，缩进用来表示一个代码块。语句通过缩进分组成为一个执行单元的块。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The Python interpreter does not care if you use tabs or spaces to indent, as
    long as you are consistent. The Python style guide, [PEP-8](https://oreil.ly/b5yU4),
    however, recommends using four whitespaces for each level of indentation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Python解释器不在乎您是使用制表符还是空格缩进，只要您保持一致即可。然而，Python样式指南[PEP-8](https://oreil.ly/b5yU4)建议每级缩进使用四个空格。
- en: if/elif/else
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if/elif/else
- en: '`if/elif/else` statements are common ways to branch between decisions in code.
    A block directly after an `if` statement runs if that statement evaluates to `True`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`if/elif/else`语句是在代码中做出决策分支的常见方式。直接跟在`if`语句后面的代码块会在该语句评估为`True`时运行：'
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here we used the `==` operator, which returns `True` if items are equal and
    `False` if not. Optionally, this block can follow an `elif` or `else` statement
    with an accompanying block. In the case of an `elif` statement, this block only
    executes if the `elif` evaluates to `True`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`==`运算符，如果项目相等则返回`True`，否则返回`False`。可选地，此代码块可以在伴随着`elif`或`else`语句的情况下跟随。对于`elif`语句，只有在`elif`评估为`True`时才会执行此代码块：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Multiple `elif` loops can append together. If you are familiar with `switch`
    statements in other languages, this simulates that same behavior of choosing from
    multiple choices. Adding an `else` statement at the end runs a block if none of
    the other conditions evaluate as `True`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 多个`elif`循环可以连接在一起。如果您熟悉其他语言中的`switch`语句，则这模拟了从多个选择中选择的相同行为。在末尾添加`else`语句会在没有其他条件评估为`True`时运行一个代码块：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can nest `if` statements, creating blocks containing `if` statements that
    only execute if an outer `if` statement is `True`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以嵌套`if`语句，创建包含仅在外部`if`语句为`True`时才执行的`if`语句的代码块：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: for Loops
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for循环
- en: '`for` loops allow you to repeat a block of statements (a code block) once for
    each member of a *sequence* (ordered group of items). As you iterate through the
    sequence, the current item can be accessed by the code block. One of most common
    uses of loops is to iterate through a `range` object to do a task a set number
    of times:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环允许您重复执行一组语句（代码块），每个成员的*序列*（有序的项目组）一次。当您迭代序列时，当前项目可以通过代码块访问。循环的最常见用途之一是通过`range`对象迭代来执行固定次数的任务：'
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this example, our block of code is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们的代码块如下所示：
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We repeat this code 10 times, each time assigning the variable `i` to the next
    number in the sequence of integers from 0–9\. `for` loops can be used to iterate
    through any of the Python sequence types. You will see these later in this chapter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重复这段代码10次，每次将变量`i`分配给从0到9的整数序列中的下一个数字。`for`循环可用于迭代Python中的任何序列类型。您将在本章后面看到这些内容。
- en: continue
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: continue
- en: 'The `continue` statement skips a step in a loop, jumping to the next item in
    the sequence:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`语句跳过循环中的一步，直接跳到序列中的下一个项目：'
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: while Loops
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: while循环
- en: '`while` loops repeat a block as long as a condition evaluates to `True`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环会在条件评估为`True`时重复执行一个代码块：'
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It is essential to define a way for your loop to end. Otherwise, you will be
    stuck in the loop until your program crashes. One way to handle this is to define
    your conditional statement such that it eventually evaluates to `False`. An alternative
    pattern uses the `break` statement to exit a loop using a nested conditional:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 定义循环结束的方法至关重要。否则，您将陷入循环直到程序崩溃。处理这种情况的一种方法是定义条件语句，使其最终评估为`False`。另一种模式使用`break`语句来使用嵌套条件退出循环：
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Handling Exceptions
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异常
- en: 'Exceptions are a type of error causing your program to crash if not handled
    (caught). Catching them with a `try-except` block allows the program to continue.
    These blocks are created by indenting the block in which the exception might be
    raised, putting a `try` statement before it and an `except` statement after it,
    followed by a code block that should run when the error occurs:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是一种导致程序崩溃的错误类型，如果不进行处理（捕获），程序将崩溃。使用`try-except`块捕获它们允许程序继续运行。通过在可能引发异常的块中缩进，放置`try`语句在其前面并在其后放置`except`语句，后跟应在错误发生时运行的代码块创建这些块：
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There are many built-in exceptions, such as `IOError`, `KeyError`, and `ImportError`.
    Many third-party packages also define their own exception classes. They indicate
    that something has gone very wrong, so it only pays to catch them if you are confident
    that the problem won’t be fatal to your software. You can specify explicitly which
    exception type you will catch. Ideally, you should catch the exact exception type
    (in our example, this was the exception `IndexError`).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多内置异常，如`IOError`、`KeyError`和`ImportError`。许多第三方包还定义了它们自己的异常类。它们指示出现了严重问题，因此只有在确信问题对软件不会致命时才值得捕获它们。您可以明确指定将捕获的异常类型。理想情况下，应捕获确切的异常类型（在我们的示例中，这是异常`IndexError`）。
- en: Built-in Objects
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置对象
- en: In this overview, we will not be covering OOP. The Python language, however,
    comes with quite a few built-in classes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在此概述中，我们不会涉及面向对象编程。然而，Python语言提供了许多内置类。
- en: What Is an Object?
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是对象？
- en: In OOP, data or state and functionality appear together. The essential concepts
    to understand when working with objects are *class instantiation* (creating objects
    from classes) and *dot syntax* (the syntax for accessing an object’s attributes
    and methods). A class defines attributes and methods shared by its objects. Think
    of it as the technical drawing of a car model. The class can then be instantiated
    to create an instance. The instance, or object, is a single car built based on
    those drawings.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，数据或状态与功能一起出现。在使用对象时需要理解的基本概念包括*类实例化*（从类创建对象）和*点语法*（访问对象属性和方法的语法）。类定义了其对象共享的属性和方法，可以将其视为汽车模型的技术图纸。然后可以实例化类以创建实例。实例或对象是基于这些图纸构建的单个汽车。
- en: '[PRE26]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You don’t need to worry about creating your own classes at this point. Just
    understand that each object is an instantiation of a class.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您在这一点上不需要担心创建自己的类。只需理解每个对象都是类的实例化。
- en: Object Methods and Attributes
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象方法和属性
- en: Objects store data in attributes. These attributes are variables attached to
    the object or object class. Objects define functionality in *object methods* (methods
    defined for all objects in a class) and *class methods* (methods attached to a
    class and shared by all objects in the class), which are functions attached to
    the object.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对象将数据存储在属性中。这些属性是附加到对象或对象类的变量。对象使用*对象方法*（为类中所有对象定义的方法）和*类方法*（附加到类并由类中所有对象共享的方法）定义功能，这些方法是附加到对象的函数。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In Python documentation, functions attached to objects and classes are referred
    to as methods.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python文档中，附加到对象和类的函数称为方法。
- en: 'These functions have access to the object’s attributes and can modify and use
    the object’s data. To call an object’s method or access one of its attributes,
    we use dot syntax:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数可以访问对象的属性并修改和使用对象的数据。要调用对象的方法或访问其属性之一，使用点语法：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: So here our `FancyCar` class defines a method called `driveFast` and an attribute
    `wheels`. When you instantiate an instance of `FancyCar` named `my_car`, you can
    access the attribute and invoke the method using the dot syntax.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的`FancyCar`类中定义了一个名为`driveFast`的方法和一个名为`wheels`的属性。当您实例化名为`my_car`的`FancyCar`实例时，可以使用点语法访问属性并调用方法。
- en: Sequences
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列
- en: Sequences are a family of built-in types, including the *list*, *tuple*, *range*,
    *string*, and *binary* types. Sequences represent ordered and finite collections
    of items.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 序列是一组内置类型，包括*列表*、*元组*、*范围*、*字符串*和*二进制*类型。序列表示有序且有限的项目集合。
- en: Sequence operations
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 序列操作
- en: There are many operations that work across all of the types of sequences. We
    cover some of the most commonly used operations here.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多操作适用于所有类型的序列。我们在此处介绍了一些最常用的操作。
- en: 'You can use the `in` and `not in` operators to test whether or not an item
    exists in a sequence:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`in`和`not in`运算符可以测试序列中是否存在某个项：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can reference the contents of a sequence by using its index number. To
    access the item at some index, use square brackets with the index number as an
    argument. The first item indexed is at position 0, the second at 1, and so forth
    up to the number one less than the number of items:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用其索引号引用序列的内容。要访问某个索引处的项，请使用带有索引号的方括号作为参数。第一个索引的项在位置0，第二个在1，依此类推，直到比项数少一个的数字：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Indexing can appear from the end of a sequence rather than from the front using
    negative numbers. The last item has the index of –1, the second to last has the
    index of –2, and so forth:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用负数从序列的末尾而不是从前面进行索引。最后一项的索引为-1，倒数第二项的索引为-2，依此类推：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The index of an item results from the `index` method. By default, it returns
    the index of the first occurrence of the item, but optional arguments can define
    a subrange in which to search:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 项目的索引来自`index`方法。默认情况下，它返回项目的第一次出现的索引，但可选参数可以定义要搜索的子范围：
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can produce a new sequence from a sequence using slicing. A slice appears
    by invoking a sequence with brackets containing optional `start`, `stop`, and
    `step` arguments:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用切片从序列生成新序列。切片通过在方括号中调用带有可选的`start`、`stop`和`step`参数来显示：
- en: '[PRE32]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`start` is the index of the first item to use in the new sequence, `stop` the
    first index beyond that point, and `step`, the distance between items. These arguments
    are all optional and are replaced with default values if omitted. This statement
    produces a copy of the original sequence. The default value for `start` is 0,
    for `stop` is the length of the sequence, and for `step` is 1\. Note that if the
    step does not appear, the corresponding *:* can also be dropped:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`是新序列中要使用的第一项的索引，`stop`是超出该点的第一个索引，`step`是项之间的距离。这些参数都是可选的，如果省略则替换为默认值。此语句生成原始序列的副本。`start`的默认值为0，`stop`的默认值为序列的长度，`step`的默认值为1。注意，如果步骤未显示，则相应的*:*也可以省略：'
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Negative numbers can be used to index backward:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 负数可用于向后索引：
- en: '[PRE34]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Sequences share many operations for getting information about them and their
    contents. `len` returns the length of the sequence, `min` the smallest member,
    `max` the largest, and `count` the number of a particular item. `min` and `max`
    work only on sequences with items that are comparable. Remember that these work
    with any sequence type:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 序列共享许多操作以获取有关它们及其内容的信息。`len`返回序列的长度，`min`返回最小成员，`max`返回最大成员，`count`返回特定项的数量。`min`和`max`仅适用于具有可比较项的序列。请记住，这些操作适用于任何序列类型：
- en: '[PRE35]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Lists
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表
- en: Lists, one of the most commonly used Python data structures, represent an ordered
    collection of items of any type. The use of square brackets indicates a list syntax.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是Python中最常用的数据结构之一，表示任何类型的有序集合。使用方括号表示列表语法。
- en: 'The function `list()` can be used to create an empty list or a list based on
    another finite iterable object (such as another sequence):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`list()`可用于创建空列表或基于另一个有限可迭代对象（如另一个序列）的列表：
- en: '[PRE36]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Lists created by using square brackets directly are the most common form. Items
    in the list need to be enumerated explicitly in this case. Remember that the items
    in a list can be of different types:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用方括号创建的列表是最常见的形式。在这种情况下，列表中的项需要显式枚举。请记住，列表中的项可以是不同类型的：
- en: '[PRE37]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The most efficient way to add a single item to a list is to `append` the item
    to the end of the list. A less efficient method, `insert`, allows you to insert
    an item at the index position of your choice:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 向列表中添加单个项目的最有效方法是将项目`append`到列表的末尾。一种效率较低的方法`insert`允许您在选择的索引位置插入项目：
- en: '[PRE38]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The contents of one list can be added to another using the `extend` method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一个列表的内容可以使用`extend`方法添加到另一个列表中：
- en: '[PRE39]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The most efficient and common way of removing the last item from a list and
    returning its value is to `pop` it. An index argument can be supplied to this
    method, removing and returning the item at that index. This technique is less
    efficient, as the list needs to be re-indexed:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从列表中删除最后一项并返回其值的最有效和常见方法是将其`pop`出来。此方法可以提供一个索引参数，从而删除并返回该索引处的项目。这种技术效率较低，因为需要重新索引列表：
- en: '[PRE40]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: There is also a `remove` method, which removes the first occurrence of an item.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`remove`方法，用于删除一个项目的第一次出现。
- en: '[PRE41]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'One of the most potent and idiomatic Python features, list comprehensions,
    allows you to use the functionality of a `for` loop in a single line. Let’s look
    at a simple example, starting with a `for` loop squaring all of the numbers from
    0–9 and appending them to a list:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最有效和成语化的Python功能之一，列表推导允许您在一行中使用`for`循环的功能。让我们看一个简单的例子，从一个`for`循环开始，将0-9的所有数字平方，并将它们附加到列表中：
- en: '[PRE42]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In order to replace this with a list comprehension, we do the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了用列表推导式替换它，我们做以下操作：
- en: '[PRE43]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Note that the functionality of the inner block is put first, followed by the
    `for` statement. You can also add conditionals to list comprehensions, filtering
    the results:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意内部代码块的功能先被描述，接着是 `for` 语句。你也可以在列表推导式中加入条件语句，过滤结果：
- en: '[PRE44]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Other techniques for list comprehensions include nesting them and using multiple
    variables, but the more straightforward form shown here is the most common.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式的其他技巧包括嵌套和使用多个变量，但这里展示的更为简单的形式是最常见的。
- en: Strings
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串
- en: The string sequence type is a collection of ordered characters surrounded by
    quotation marks. As of Python 3, strings default to using *UTF-8* encoding.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串序列类型是一组由引号包围的有序字符集。Python 3 默认使用 *UTF-8* 编码。
- en: 'You can create strings either by using the string constructor method, `str(),`
    or by directly enclosing the text in quotation marks:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用字符串构造方法 `str()` 或直接用引号将文本包裹来创建字符串：
- en: '[PRE45]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The string constructor can be used to make strings from other objects:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串构造方法可以从其他对象创建字符串：
- en: '[PRE46]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You can create multiline strings by using triple quotes around the content:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在内容周围使用三重引号来创建多行字符串：
- en: '[PRE47]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In addition to the methods shared by all sequences, strings have quite a few
    methods distinct to their class.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有序列共享的方法之外，字符串还有一些特定于其类别的方法。
- en: 'It is relatively common for user text to have trailing or leading whitespace.
    If someone types " yes " in a form instead of “yes” you usually want to treat
    them the same. Python strings have a `strip` method just for this case. It returns
    a string with the whitespace removed from the beginning and end. There are also
    methods to remove the whitespace from only the right or left side of the string:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 用户文本通常会有末尾或开头的空白字符。如果有人在表单中输入 " yes " 而不是 “yes”，通常希望将它们视为相同。Python 字符串提供了专门的
    `strip` 方法来处理这种情况。它返回一个去掉开头和结尾空白的字符串。还有方法仅移除字符串左侧或右侧的空白：
- en: '[PRE48]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'On the other hand, if you want to add padding to a string, you can use the
    `ljust` or `rjust` methods. Either one pads with whitespace by default, or takes
    a character argument:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你想要给字符串添加填充，可以使用 `ljust` 或 `rjust` 方法。默认情况下，它们使用空格进行填充，也可以指定一个字符作为填充：
- en: '[PRE49]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Sometimes you want to break a string up into a list of substrings. Perhaps
    you have a sentence you want to turn into a list of words, or a string of words
    separated by commas. The `split` method breaks a string into a list of strings.
    By default, it uses whitespace as the token to make the breaks. An optional argument
    can be used to add in another character where the split can break:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你想要将一个字符串分割成子字符串列表。也许你有一个句子想要变成单词列表，或者有一串用逗号分隔的单词字符串。`split` 方法可以将一个字符串分割成多个子字符串的列表。默认情况下，它使用空白作为分隔符。还可以用一个可选的参数来指定其他字符作为分隔符：
- en: '[PRE50]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can easily create a new string from a sequence of strings and `join` them
    into a single string. This method inserts a string as a separator between a list
    of other strings:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 可以轻松地从一组字符串中创建新的字符串，并使用 `join` 方法将它们连接成一个单独的字符串。这个方法将一个字符串作为分隔符插入到其他字符串列表之间：
- en: '[PRE51]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Changing the case of text is a common occurrence, whether it is making the
    case uniform for comparison or changing in preparation for user consumption. Python
    strings have several methods to make this an easy process:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 改变文本大小写是常见的操作，无论是为了进行比较而统一大小写，还是为了准备用户使用。Python 字符串有几种方法可以轻松完成这个过程：
- en: '[PRE52]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Python also provides methods to understand a string’s content. Whether it’s
    checking the case of the text, or seeing if it represents a number, there are
    quite a few built-in methods for interrogation. Here are just a few of the most
    commonly used methods:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Python 还提供了方法来了解字符串的内容。无论是检查文本的大小写，还是查看它是否表示一个数字，都有相当多的内置方法可供查询。以下是一些最常用的方法：
- en: '[PRE53]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You can insert content into a string and control its format at runtime. Your
    program can use the values of variables or other calculated content in strings.
    This approach is used in both creating user-consumed text and for writing software
    logs.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在运行时向字符串中插入内容并控制其格式。你的程序可以在字符串中使用变量的值或其他计算出的内容。这种方法既用于创建用户可用的文本，也用于编写软件日志。
- en: 'The older form of string formatting in Python comes from the C language `printf`
    function. You can use the modulus operator, `%`, to insert formatted values into
    a string. This technique applies to the form `string % values`, where values can
    be a single nontuple or a tuple of multiple values. The string itself must have
    a conversion specifier for each value. The conversion specifier, at a minimum,
    starts with a `%` and is followed by a character representing the type of value
    inserted:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的旧式字符串格式化形式来自C语言的`printf`函数。你可以使用模数运算符`%`将格式化值插入到字符串中。这种技术适用于形式`string
    % values`，其中values可以是单个非元组或多个值的元组。字符串本身必须为每个值都有一个转换说明符。转换说明符至少以`%`开头，后跟表示插入值类型的字符：
- en: '[PRE54]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Additional format arguments include the conversion specifier. For example,
    you can control the number of places a float, `%f`, prints:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 其他格式参数包括转换说明符。例如，你可以控制浮点数`%f`打印的位数：
- en: '[PRE55]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This mechanism for string formatting was the dominant one in Python for years,
    and you encounter it in legacy code. This approach offers some compelling features,
    such as sharing syntax with other languages. It also has some pitfalls. In particular,
    due to the use of a sequence to hold the arguments, errors related to displaying
    `tuple` and `dict` objects are common. We recommend adopting newer formatting
    options, such as the string `format` method, template strings, and f-strings,
    to both avoid these errors and increase the simplicity and readability of your
    code.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这种字符串格式化机制多年来一直是Python中的主流，你会在遗留代码中遇到它。这种方法具有一些引人注目的特性，例如与其他语言共享语法。但也存在一些缺陷。特别是由于使用序列来保存参数，与显示`tuple`和`dict`对象相关的错误很常见。我们建议采用更新的格式化选项，如字符串`format`方法、模板字符串和f-strings，既可以避免这些错误，又可以增加代码的简洁性和可读性。
- en: 'Python 3 introduced a new way of formatting strings using the string method
    `format`. This way of formatting has been backported to Python 2 as well. This
    specification uses curly brackets in the string to indicate replacement fields
    rather than the modulus-based conversion specifiers of the old-style formatting.
    The insert values become arguments to the string `format` method. The order of
    the arguments determines their placement order in the target string:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3引入了一种使用字符串方法`format`格式化字符串的新方法。这种格式化方式已经回溯到Python 2。此规范使用字符串中的花括号来表示替换字段，而不是旧式格式化的基于模数的转换说明符。插入值变为字符串`format`方法的参数。参数的顺序决定它们在目标字符串中的放置顺序：
- en: '[PRE56]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'You can specify index numbers in the brackets to insert values in an order
    different than that in the argument list. You can also repeat a value by specifying
    the same index number in multiple replacement fields:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在括号中指定索引号，以按不同于参数列表顺序插入值。你还可以通过在多个替换字段中指定相同的索引号来重复值：
- en: '[PRE57]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'An even more powerful feature is that the insert values can be specified by
    name:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 更强大的功能是可以按名称指定插入值：
- en: '[PRE58]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here a `dict` works to supply the key values for name-based replacement fields:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里一个`dict`用于提供基于名称的替换字段的键值：
- en: '[PRE59]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You can also specify format specification arguments. Here they add left and
    right padding using `>` and `<`. In the second example, we specify a character
    to use in the padding:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以指定格式规范参数。在这里它们使用`>`和`<`添加左右填充。在第二个示例中，我们指定了用于填充的字符：
- en: '[PRE60]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Format specifications are done using [the format specification mini-language](https://oreil.ly/ZOFJg).
    Our topic also uses another type of language called *f-strings*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[格式规范迷你语言](https://oreil.ly/ZOFJg)来进行格式规范。我们的主题还使用了另一种称为*f-strings*的语言类型。
- en: 'Python f-strings use the same formatting language as the `format` method, but
    offer a more straightforward and intuitive mechanism for using them. f-strings
    are prepended with either *f* or *F* before the first quotation mark. Like the
    `format` string previously described, f-strings use curly braces to demarcate
    replacement fields. In an f-string, however, the content of the replacement field
    is an expression. This approach means it can refer to variables defined in the
    current scope or involve calculations:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Python的f-strings使用与`format`方法相同的格式化语言，但提供了一个更简单直观的机制来使用它们。f-strings在第一个引号之前用*f*或*F*标记。与前述的`format`字符串类似，f-strings使用大括号来标识替换字段。然而，在f-string中，替换字段的内容是一个表达式。这种方法意味着它可以引用当前范围内定义的变量或涉及计算：
- en: '[PRE61]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'As in `format` strings, format specifications in f-strings happen within the
    curly brackets after the value expression and start with a `:`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 与`format`字符串一样，f-字符串中的格式规范位于值表达式后的大括号内，并以`:`开头：
- en: '[PRE62]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The value expression can contain nested expressions, referencing variables,
    and expressions in the construction of the parent expression:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 值表达式可以包含嵌套表达式，在父表达式的构造中引用变量和表达式：
- en: '[PRE63]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Tip
  id: totrans-185
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: We highly recommend using f-strings for the majority of your string formatting.
    They combine the power of the specification mini-language with a simple and intuitive
    syntax.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议您在大多数字符串格式化时使用f-字符串。它们结合了规范迷你语言的强大功能与简单直观的语法。
- en: Template strings are designed to offer a straightforward string substitution
    mechanism. These built-in methods work for tasks such as internationalization,
    where simple word substitutions are necessary. They use `$` as a substitution
    character, with optional curly braces surrounding them. The characters directly
    following the `$` identify the value to be inserted. When the `substitute` method
    of the string template executes, these names are used to assign values.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串旨在提供简单的字符串替换机制。这些内置方法适用于国际化等任务，其中需要简单的单词替换。它们使用`$`作为替换字符，并在其周围可选地使用大括号。紧跟在`$`后面的字符标识要插入的值。当字符串模板的`substitute`方法执行时，这些名称用于分配值。
- en: Note
  id: totrans-188
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Built-in types and functions are available whenever you run Python code, but
    to access the broader world of functionality available in the Python ecosystem,
    you need to use the `import` statement. This approach lets you add functionality
    from the Python Standard Library or third-party services into your environment.
    You can selectively import parts of a package by using the `from` keyword:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行Python代码时，内置类型和函数是可用的，但要访问Python生态系统中提供的更广泛的功能，您需要使用`import`语句。此方法允许您将Python标准库或第三方服务的功能添加到您的环境中。您可以使用`from`关键字选择性地从包中导入部分功能：
- en: '[PRE64]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Dicts
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典
- en: Aside from strings and lists, dicts may be the most used of the Python built-in
    classes. A *dict* is a mapping of keys to values. The lookup of any particular
    value using a key is highly efficient and fast. The keys can be strings, numbers,
    custom objects, or any other nonmutable type.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 除了字符串和列表外，字典可能是Python内置类中使用最多的。*Dict*是键到值的映射。使用键查找任何特定值的操作非常高效和快速。键可以是字符串、数字、自定义对象或任何其他不可变类型。
- en: Note
  id: totrans-193
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A *mutable* object is one whose contents can change in place. Lists are a primary
    example; the contents of the list can change without the list’s identity changing.
    Strings are not mutable. You create a new string each time you change the contents
    of an existing one.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 可变对象是指其内容可以就地更改的对象。列表是一个主要的例子；列表的内容可以更改而列表的身份不会改变。字符串是不可变的。每次更改现有字符串的内容时，都会创建一个新字符串。
- en: Dicts are represented as comma–separated key/value pairs surrounded by curly
    braces. The key/value pairs consist of a key, a colon (*:*), and then a value.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 字典被表示为由大括号包围的逗号分隔的键/值对。键/值对包括键、冒号（*:*）和值。
- en: 'You can create a dict object using the `dict()` constructor. With no arguments,
    it creates an empty dict. It takes a sequence of key/value pairs as an argument
    as well:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`dict()`构造函数创建一个字典对象。如果没有参数，则创建一个空字典。它还可以接受一系列键/值对作为参数：
- en: '[PRE65]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You can also create a *dict* directly using curly braces:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以直接使用大括号创建*dict*：
- en: '[PRE66]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'You can access the value associated with a key using square bracket syntax:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用方括号语法访问与键相关联的值：
- en: '[PRE67]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You can use the same syntax to set a value. If the key is not in the dict,
    it adds as a new entry. If it already exists, the value changes to the new value:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用相同的语法设置一个值。如果键不在字典中，则将其添加为新条目。如果已存在，则该值将更改为新值：
- en: '[PRE68]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If you try to access a key that has not been defined in a dict, a `KeyError`
    exception will be thrown:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试访问在字典中未定义的键，则会引发`KeyError`异常：
- en: '[PRE69]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'You can check to see if the key exists in a dict using the `in` syntax we saw
    with sequences. In the case of dicts, it checks for the existence of keys:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用我们在序列中看到的`in`语法检查字典中键是否存在。对于字典，它检查键的存在：
- en: '[PRE70]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'A more intuitive solution is to use the `get()` method. If you have not defined
    a key in a dict, it returns a supplied default value. If you have not supplied
    a default value, it returns `None`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 更直观的解决方案是使用`get()`方法。如果在字典中未定义键，则返回提供的默认值。如果未提供默认值，则返回`None`：
- en: '[PRE71]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Use `del` to remove a key-value pair from a dict:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`del`从字典中删除一个键值对：
- en: '[PRE72]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The `keys()` method returns a `dict_keys` object with the dict’s keys. The
    `values()` method returns an `dict_values` object, and the `items()` method returns
    key-value pairs. This last method is useful for iterating through the contents
    of a dict:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`keys()`方法返回一个带有字典键的`dict_keys`对象。`values()`方法返回一个带有字典值的`dict_values`对象，而`items()`方法返回键值对。这个最后的方法对于迭代字典内容非常有用：'
- en: '[PRE73]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Similar to list comprehensions, dict comprehensions are one-line statements
    returning a dict by iterating through a sequence:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表推导式类似，字典推导式是通过迭代一个序列返回一个字典的一行语句：
- en: '[PRE74]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Functions
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: You have seen some Python built-in functions already. Now move on to writing
    your own. Remember, a *function* is a mechanism for encapsulating a block of code.
    You can repeat the behavior of this block in multiple spots without having to
    duplicate the code. Your code will be better organized, more testable, maintainable,
    and easier to understand.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了一些Python内置函数。现在开始编写您自己的函数。记住，*函数*是一种封装代码块的机制。您可以在多个位置重复此代码块的行为，而无需重复代码。您的代码将更有组织性，更易于测试、维护和理解。
- en: Anatomy of a Function
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数的解剖
- en: 'The first line of a function definition starts with the keyword `def`, followed
    by the function name, function parameters enclosed in parentheses, and then `:`.
    The rest of the function is a code block and is indented:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义的第一行以关键字`def`开头，后面跟着函数名、括号括起来的函数参数，然后是`:`。函数的其余部分是一个缩进的代码块：
- en: '[PRE75]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'If a string using multiline syntax is provided first in the indented block,
    it acts as documentation. Use these to describe what your function does, how parameters
    work, and what it can be expected to return. You will find these docstrings are
    invaluable for communicating with future users of your code. Various programs
    and services also use them to create documentation. Providing docstrings is considered
    a best practice and is highly recommended:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在缩进块中首先提供使用多行语法的字符串，则它作为文档。使用这些描述函数的作用、参数如何工作以及可以预期返回什么。您会发现这些文档字符串对与代码的未来用户进行交流非常宝贵。各种程序和服务也使用它们来创建文档。提供文档字符串被认为是最佳实践，并强烈推荐使用：
- en: '[PRE76]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Function arguments occur in the parentheses following the function name. They
    can be either positional or keyword. Positional arguments use the order of the
    arguments to assign value:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数出现在函数名后面的括号中。它们可以是位置参数或关键字参数。位置参数使用参数的顺序来分配值：
- en: '[PRE77]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'With keyword arguments, assign each argument a default value:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用关键字参数，为每个参数分配一个默认值：
- en: '[PRE78]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The default values are used when no values are passed during function invocation.
    The keyword parameters can be called by name during function invocation, in which
    case the order will not matter:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当在函数调用时没有传递值时，将使用默认值。关键字参数在函数调用时可以通过名称调用，此时顺序将无关紧要：
- en: '[PRE79]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'When using keyword parameters, all parameters defined after a keyword parameter
    must be keyword parameters as well. All functions return a value. The `return`
    keyword is used to set this value. If not set from a function definition, the
    function returns `None`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用关键字参数时，所有在关键字参数之后定义的参数必须也是关键字参数。所有函数都返回一个值。使用`return`关键字来设置这个值。如果从函数定义中未设置，则函数返回`None`：
- en: '[PRE80]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Functions as Objects
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数作为对象
- en: 'Functions are objects. They can be passed around, or stored in data structures.
    You can define two functions, put them in a list, and then iterate through the
    list to invoke them:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是对象。它们可以被传递，或者存储在数据结构中。您可以定义两个函数，将它们放入列表中，然后遍历列表以调用它们：
- en: '[PRE81]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Anonymous Functions
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名函数
- en: 'When you need to create a very limited function, you can create an unnamed
    (anonymous) one using the `lambda` keyword. Generally, you should limit their
    use to situations where a function expects a small function as a argument. In
    this example, you take a list of lists and sort it. The default sorting mechanism
    compares based on the first item of each sublist:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要创建一个非常有限的函数时，可以使用`lambda`关键字创建一个未命名（匿名）函数。一般情况下，应将它们的使用限制在函数期望小函数作为参数的情况下。在这个例子中，您接受一个列表的列表并对其进行排序。默认的排序机制基于每个子列表的第一个项目进行比较：
- en: '[PRE82]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'To sort based on something other than the first entry, you can define a method
    which returns the item’s second entry and pass it into the sorting function’s
    `key` parameter:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 若要根据除第一个条目之外的其他内容进行排序，可以定义一个返回项目第二个条目的方法，并将其传递给排序函数的`key`参数：
- en: '[PRE83]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'With the `lambda` keyword, you can do the same thing without the full function
    definition. Lambdas work with the `lambda` keyword followed by a parameter name,
    a colon, and a return value:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`lambda`关键字，您可以在没有完整函数定义的情况下执行相同的操作。Lambda使用`lambda`关键字，后跟参数名称、冒号和返回值：
- en: '[PRE84]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Sort using lambdas, first using the second entry and then using the third:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用lambda进行排序，首先使用第二个条目，然后使用第三个：
- en: '[PRE85]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Be cautious of using lambdas more generally, as they can create code that is
    poorly documented and confusing to read if used in place of general functions.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在更一般地使用lambda时要谨慎，因为如果用作一般函数的替代品，它们可能会创建文档不足且难以阅读的代码。
- en: Using Regular Expressions
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式
- en: The need to match patterns in strings comes up again and again. You could be
    looking for an identifier in a log file or checking user input for keywords or
    a myriad of other cases. You have already seen simple pattern matching using the
    `in` operation for sequences, or the string `.endswith` and `.startswith` methods.
    To do more sophisticated matching, you need a more powerful tool. Regular expressions,
    often referred to as regex, are the answer. Regular expressions use a string of
    characters to define search patterns. The Python `re` package offers regular expression
    operations similar to those found in Perl. The `re` module uses backslashes (*\*)
    to delineate special characters used in matching. To avoid confusion with regular
    string escape sequences, raw strings are recommended when defining regular expression
    patterns. Raw strings are prepended with an *r* before the first quotation mark.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 反复出现需要在字符串中匹配模式的情况。您可能正在查找日志文件中的标识符，或者检查用户输入的关键字或其他许多情况。您已经看到了使用`in`操作符进行简单模式匹配，或者字符串`.endswith`和`.startswith`方法。要进行更复杂的匹配，您需要更强大的工具。正则表达式，通常称为regex，是答案。正则表达式使用一系列字符来定义搜索模式。Python的`re`包提供了类似于Perl中的正则表达式操作。`re`模块使用反斜杠（*\\*）来标示匹配中使用的特殊字符。为了避免与常规字符串转义序列混淆，在定义正则表达式模式时建议使用原始字符串。原始字符串在第一个引号前加上*r*。
- en: Note
  id: totrans-246
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Python strings have several escape sequences. Among the most common are line-feed
    `\n` and tab `\t`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Python字符串具有几个转义序列。其中最常见的是换行符`\n`和制表符`\t`。
- en: Searching
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索
- en: 'Let say you have a cc list from an email as a text and you want to understand
    more about who is in this list:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有来自电子邮件的抄送列表作为文本，并且您想进一步了解谁在此列表中：
- en: '[PRE86]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'If you want to know whether a name is in this text, you could use the `in`
    sequence membership syntax:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道这段文本中是否有一个名称，您可以使用`in`序列成员语法：
- en: '[PRE87]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'To get similar behavior, you can use the `re.search` function, which returns
    a `re.Match` object only if there is a match:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得类似的行为，您可以使用`re.search`函数，仅在有匹配时返回`re.Match`对象：
- en: '[PRE88]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'You can use this as a condition to test for membership:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此用作测试成员资格的条件：
- en: '[PRE89]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Character Sets
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符集
- en: So far `re` hasn’t given you anything you couldn’t get using the `in` operator.
    However, what if you are looking for a person in a text, but you can’t remember
    if the name is *Bobbi* or *Robby*?
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`re`还没有给您使用`in`运算符获得的任何内容。但是，如果您在文本中寻找一个人，但无法记住名字是*Bobbi*还是*Robby*，该怎么办？
- en: 'With regular expressions, you can use groups of characters, any one of which
    could appear in a spot. These are called character sets. The characters from which
    a match should be chosen are enclosed by square brackets in the regular expression
    definition. You can match on *B* or *R*, followed by *obb*, and either *i* or
    *y*:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正则表达式，您可以使用一组字符，其中任何一个都可以出现在某个位置。这些称为字符集。在正则表达式定义中，匹配应选择的字符由方括号括起来。您可以匹配*B*或*R*，接着是*obb*，然后是*i*或*y*：
- en: '[PRE90]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'You can put comma-separated individual characters in a character set or use
    ranges. The range *A–Z* includes all the capitalized letters; the range *0–9*
    includes the digits from zero to nine:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将逗号分隔的单个字符放入字符集中，也可以使用范围。范围`A–Z`包括所有大写字母；范围`0–9`包括从零到九的数字：
- en: '[PRE91]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The *+* after an item in a regular expression matches one or more of that item.
    A number in brackets matches an exact number of characters:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在正则表达式中，`+`匹配一个或多个项目。括号中的数字匹配精确数量的字符：
- en: '[PRE92]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We can construct a match using a combination of character sets and other characters
    to make a naive match of an email address. The *.* character has a special meaning.
    It is a wildcard and matches any character. To match against the actual *.* character,
    you must escape it using a backslash:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用字符集和其他字符的组合构建匹配以匹配电子邮件地址的原始匹配器。*.*字符具有特殊含义。它是一个通配符，匹配任何字符。要匹配实际的*.*字符，您必须使用反斜杠进行转义：
- en: '[PRE93]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This example is just a demonstration of character sets. It does not represent
    the full complexity of a production-ready regular expressions for emails.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例仅演示了字符集。它并不代表用于电子邮件的生产就绪正则表达式的全部复杂性。
- en: Character Classes
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符类
- en: 'In addition to character sets, Python’s `re` offers character classes. These
    are premade character sets. Some commonly used ones are `\w`, which is equivalent
    to `[a-zA-Z0-9_]` and `\d`, which is equivalent to `[0-9]`. You can use the *+*
    modifier to match for multiple characters:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 除了字符集外，Python的`re`还提供字符类。这些是预定义的字符集。一些常用的是`\w`，它等效于`[a-zA-Z0-9_]`，以及`\d`，它等效于`[0-9]`。您可以使用*+*修饰符匹配多个字符：
- en: '[PRE94]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'And you can replace our primative email matcher with `\w`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以用`\w`替换我们原始的电子邮件匹配器：
- en: '[PRE95]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Groups
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组
- en: 'You can use parentheses to define groups in a match. These groups can be accessed
    from the match object. They are numbered in the order they appear, with the zero
    group being the full match:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用括号在匹配中定义分组。可以从匹配对象访问这些组。它们按它们出现的顺序编号，零号组为完整匹配：
- en: '[PRE96]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Named Groups
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名分组
- en: 'You can also supply names for the groups by adding `?P<NAME>` in the group
    definition. Then you can access the groups by name instead of number:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过在组定义中添加`?P<NAME>`为组添加名称。然后可以按名称而不是编号访问组：
- en: '[PRE97]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Find All
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找全部
- en: 'Up until now, we have demonstrated returning just the first match found. We
    can also use `findall` to return all of the matches as a list of strings:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们演示了只返回找到的第一个匹配项。我们也可以使用`findall`将所有匹配项作为字符串列表返回：
- en: '[PRE98]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Find Iterator
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找迭代器
- en: 'When dealing with large texts, such as logs, it is useful to not process the
    text all at once. You can produce an *iterator* object using the `finditer` method.
    This object processes text until it finds a match and then stops. Passing it to
    the `next` function returns the current match and continues processing until finding
    the next match. In this way, you can deal with each match individually without
    devoting resources to process all of the input at once:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 处理大文本（如日志）时，最好不要一次性处理文本。您可以使用`finditer`方法生成一个*迭代器*对象。此对象处理文本直到找到匹配项然后停止。将其传递给`next`函数返回当前匹配并继续处理直到找到下一个匹配。通过这种方式，您可以单独处理每个匹配项，而无需一次性处理所有输入以节省资源：
- en: '[PRE99]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The iterator object, `matched`, can be used in a `for` loop as well:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器对象`matched`也可以在`for`循环中使用：
- en: '[PRE100]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Substitution
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换
- en: 'Besides searching and matching, regexes can be used to substitute part or all
    of a string:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 除了搜索和匹配外，正则表达式还可用于替换字符串的一部分或全部：
- en: '[PRE101]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Compiling
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译
- en: 'All of the examples so far have called methods on the `re` module directly.
    This is adequate for many cases, but if the same match is going to happen many
    times, performance gains can be had by compiling the regular expression into an
    object. This object can be reused for matches without recompiling:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有示例都直接在`re`模块上调用方法。这对许多情况是足够的，但如果同一匹配会发生多次，则通过将正则表达式编译成对象可以获得性能增益。这个对象可以重复用于匹配而不需要重新编译：
- en: '[PRE102]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Regular expressions offer many more features than we have dealt with here. Indeed
    many books have been written on their use, but you should now be prepared for
    most basic cases.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式提供的功能远远超出我们在这里讨论的范围。实际上，有许多书籍专门讨论它们的使用，但是现在您应该准备好处理大多数基本情况了。
- en: Lazy Evaluation
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 惰性评估
- en: '*Lazy evaluation* is the idea that, especially when dealing with large amounts
    of data, you do not want process all of the data before using the results. You
    have already seen this with the `range` type, where the memory footprint is the
    same, even for one representing a large group of numbers.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '*惰性评估*是一个概念，特别是在处理大量数据时，您不希望在使用结果之前处理所有数据。您已经在`range`类型中看到了这一点，在其中，即使表示大量数字的一个`range`对象的内存占用量也是相同的。'
- en: Generators
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器
- en: You can use generators in a similar way as `range` objects. They perform some
    operation on data in chunks as requested. They pause their state in between calls.
    This means that you can store variables that are needed to calculate output, and
    they are accessed every time the generator is called.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像使用`range`对象一样使用生成器。它们按需对数据执行一些操作，并在调用之间暂停其状态。这意味着您可以存储需要计算输出的变量，并且每次调用生成器时都会访问它们。
- en: 'To write a generator function, use the `yield` keyword rather than a return
    statement. Every time the generator is called, it returns the value specified
    by `yield` and then pauses its state until it is next called. Let’s write a generator
    that simply counts, returning each subsequent number:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写生成器函数，使用`yield`关键字而不是返回语句。每次调用生成器时，它都返回`yield`指定的值，然后暂停其状态，直到下次调用。让我们编写一个简单地计数的生成器：
- en: '[PRE103]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Note that the generator keeps track of its state, and hence the variable `n`
    in each call to the generator reflects the value previously set. Let’s implement
    a Fibonacci generator:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，生成器会跟踪其状态，因此每次调用生成器时，变量`n`都反映了先前设置的值。让我们实现一个 Fibonacci 生成器：
- en: '[PRE104]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'We can also iterate using the generator in a `for` loop:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在`for`循环中使用生成器进行迭代：
- en: '[PRE105]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Generator Comprehensions
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器推导式
- en: 'We can use generator comprehensions to create one-line generators. They are
    created using a syntax similar to list comprehensions, but parentheses are used
    rather than square brackets:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用生成器推导式创建单行生成器。它们使用类似于列表推导式的语法，但使用圆括号而不是方括号：
- en: '[PRE106]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Even with this small example, we can see the difference in memory used by using
    the `sys.getsizeof` method, which returns the size of an object, in bytes:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是这个小例子，我们也可以看到使用`sys.getsizeof`方法来查看对象的内存使用情况的差异，该方法以字节为单位返回对象的大小：
- en: '[PRE107]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: More IPython Features
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多 IPython 特性
- en: You saw some of IPython’s features at the beginning of the chapter. Now let’s
    look at some more advanced features, such as running shell commands from within
    the IPython interpreter and using magic functions.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 您在本章开头看到了一些 IPython 的特性。现在让我们看一些更高级的功能，例如从 IPython 解释器内部运行 shell 命令和使用魔术函数。
- en: Using IPython to Run Unix Shell Commands
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 IPython 运行 Unix Shell 命令
- en: 'You can use IPython to run shell commands. This is one of the most compelling
    reasons to perform DevOps actions in the IPython shell. Let’s take a look at a
    very simple example where the `!` character, which IPython uses to identify shell
    commands, is put in front of the command `ls`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 IPython 运行 shell 命令。这是在 IPython shell 中执行 DevOps 操作的最有说服力的原因之一。让我们看一个非常简单的例子，其中`!`字符用于标识
    IPython 中的 shell 命令，并放在`ls`命令的前面：
- en: '[PRE108]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The output of the command is assigned to a Python variable `var_ls`. The `type`
    of this variable is `IPython.utils.text.SList`. The `SList` type converts a regular
    shell command into an object that has three main methods: `fields`, `grep`, and
    `sort`. Here is an example in action using the Unix `df` command. The `sort` method
    can interpret the whitespace from this Unix command and then sort the third column
    by size:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出被分配给一个 Python 变量`var_ls`。此变量的`type`是`IPython.utils.text.SList`。`SList`类型将常规
    shell 命令转换为具有三个主要方法的对象：`fields`、`grep`和`sort`。以下是使用 Unix 的`df`命令进行排序的示例，`sort`方法可以解释此
    Unix 命令中的空格，并按大小对第三列进行排序：
- en: '[PRE109]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Let’s take a look at `SList` and `.grep` next. Here is an example that searches
    for what commands with `kill` as part of their names are installed in the */usr/bin*
    directory:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们来看看`SList`和`.grep`。以下是一个示例，搜索安装在*/usr/bin*目录中名称包含`kill`的命令：
- en: '[PRE110]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The key take away here is that IPython is a dream environment for hacking around
    with little shell scripts.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键是，IPython 是一个非常适合用来玩弄小型 shell 脚本的理想环境。
- en: Using IPython magic commands
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 IPython 的魔术命令
- en: 'If you get in the habit of using IPython, you should also get in the habit
    of using built-in magic commands. They are essentially shortcuts that pack a big
    punch. Magic commands are indicated by prepending them with `%%`. Here is an example
    of how to write inline Bash inside of IPython. Note, this is just a small command,
    but it could be an entire Bash script:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯使用 IPython，也应该养成使用内置魔术命令的习惯。它们本质上是一些强大的快捷方式。魔术命令通过在其前面加上`%%`来表示。这里有一个在
    IPython 中写内联 Bash 的例子。注意，这只是一个小命令，但它可以是一个完整的 Bash 脚本：
- en: '[PRE111]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The `%%writefile` is pretty tricky because you can write and test Python or
    Bash scripts on the fly, using IPython to execute them. That’s not a bad party
    trick at all:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`%%writefile` 很棘手，因为你可以即兴编写和测试 Python 或 Bash 脚本，使用 IPython 执行它们。这绝对不是一个坏点子：'
- en: '[PRE112]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Another very useful command, `%who`, will show you what is loaded into memory.
    It comes in quite handy when you have been working in a terminal that has been
    running for a long time:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的命令 `%who`，将显示加载到内存中的内容。当你在一个长时间运行的终端中工作时，它非常方便：
- en: '[PRE113]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Exercises
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Write a Python function that takes a name as an argument and prints that name.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个 Python 函数，接受一个名称作为参数并打印该名称。
- en: Write a Python function that takes a string as an argument and prints whether
    it is upper- or lowercase.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个 Python 函数，接受一个字符串作为参数并打印它是大写还是小写。
- en: Write a list comprehension that results in a list of every letter in the word
    *smogtether* capitalized.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个列表推导，将单词 *smogtether* 中的每个字母都大写。
- en: Write a generator that alternates between returning *Even* and *Odd*.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个生成器，交替返回 *Even* 和 *Odd*。
