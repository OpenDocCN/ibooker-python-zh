- en: Chapter 6\. Testing with pytest
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章\. 使用 pytest 进行测试
- en: 'If you think back to when you wrote your first programs, you may recall a common
    experience: You had an idea for how a program could help with a real-life task,
    and spent a sizable amount of time coding it from top to bottom, only to be confronted
    with screens full of disheartening error messages when you finally ran it. Or,
    worse, it gave you results that were subtly wrong.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回想起编写你的第一个程序时的经历，你可能会想起一个常见的情景：你有一个想法，认为程序可以帮助解决实际任务，然后花了大量时间从头到尾编写它，最后当你运行它时，却看到一屏幕都是令人沮丧的错误消息。或者更糟糕的是，它给出了微妙错误的结果。
- en: There are a few lessons we’ve all learned from experiences like this. One is
    to start simple and keep it simple as you iterate on the program. Another lesson
    is to test early and repeatedly. Initially, this may just mean to run the program
    manually and validate that it does what it should. Later on, if you break the
    program into smaller parts, you can test those parts in isolation and automatically.
    As a side effect, the program gets easier to read and work on, too.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这样的经历中学到了一些经验教训。其中之一是从简单开始，并在迭代过程中保持简单。另一个教训是早期和重复测试。最初，这可能只是手动运行程序并验证其是否按预期工作。后来，如果将程序分解为更小的部分，可以独立且自动地测试这些部分。作为副作用，程序也更容易阅读和处理。
- en: In this chapter, I’ll talk about how testing can help you produce value early
    and consistently. Good tests amount to an executable specification of the code
    you own. They set you free from institutional knowledge in a team or company,
    and they speed up your development by giving you immediate feedback on changes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将谈论如何测试可以帮助您及时和一致地产生价值。良好的测试相当于对您拥有的代码的可执行规范。它们使您摆脱了团队或公司的制度化知识，通过及时反馈您的变更加快了开发速度。
- en: 'The third-party testing framework [pytest](https://docs.pytest.org/) has become
    somewhat of a de-facto standard in the Python world. Tests written with pytest
    are simple and readable: you write most tests as if there was no framework, using
    basic language primitives like functions and assertions. Despite its simplicity,
    the framework is powerful and expressive, notably through its concepts of test
    fixtures and parameterized tests. Pytest is extensible and comes with a rich ecosystem
    of plugins.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方测试框架 [pytest](https://docs.pytest.org/) 已经成为 Python 世界的一种事实标准。使用 pytest 编写的测试简单易读：你编写的大多数测试都像没有框架一样，使用基本的语言原语如函数和断言。尽管框架简单，但通过测试固件和参数化测试等概念，它强大且富有表现力。Pytest
    是可扩展的，并且配备了丰富的插件生态系统。
- en: Note
  id: totrans-5
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Pytest originated in the PyPy project, a Python interpreter written in Python.
    Early on, the PyPy developers worked on a separate standard library called `std`,
    later renamed to `py`. Its testing module `py.test` became an independent project
    under the name `pytest`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest 起源于 PyPy 项目，这是一个用 Python 编写的 Python 解释器。早期，PyPy 的开发人员致力于一个名为 `std` 的单独标准库，后来更名为
    `py`。其测试模块 `py.test` 成为了一个名为 `pytest` 的独立项目。
- en: Writing a Test
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试
- en: '[Example 6-1](#example_testing_wikipedia) revisits the Wikipedia example from
    [Chapter 3](ch03.html#chapter_packages). The program is as simple as it gets—​yet
    it’s far from obvious how you’d write tests for it. The `main` function has no
    inputs and no outputs—​only side effects, such as writing to the standard output
    stream. How would you test a function like this?'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-1](#example_testing_wikipedia) 重新访问了来自[第 3 章](ch03.html#chapter_packages)的维基百科示例。该程序非常简单，但你可能不清楚如何为其编写测试。`main`
    函数没有输入和输出，只有副作用，比如向标准输出流写入内容。你会如何测试这样的函数？'
- en: Example 6-1\. The `main` function from `random-wikipedia-article`
  id: totrans-9
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-1\. 来自 `random-wikipedia-article` 的 `main` 函数
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s write an *end-to-end test* that runs the program in a subprocess and checks
    that it completes with non-empty output. End-to-end tests run the entire program
    the way an end user would ([Example 6-2](#example_testing_end_to_end)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个*端到端测试*，在子进程中运行程序并检查其是否完成且输出非空。端到端测试会像最终用户一样运行整个程序（[示例 6-2](#example_testing_end_to_end)）。
- en: Example 6-2\. A test for `random-wikipedia-article`
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-2\. 对 `random-wikipedia-article` 的测试
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Tests written using pytest are functions whose names start with `test`. Use
    the built-in `assert` statement to check for expected behavior. Pytest rewrites
    the language construct to provide rich error reporting in case of a test failure.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pytest 编写的测试是以 `test` 开头的函数。使用内置的 `assert` 语句来检查预期行为。Pytest 重写语言构造以提供丰富的错误报告，以防测试失败。
- en: Place the contents of [Example 6-2](#example_testing_end_to_end) in the file
    *test_main.py* in a *tests* directory. Include an empty *__init__.py* file to
    turn the test suite into an import package. This lets you mirror the layout of
    the package you’re testing,^([1](ch06.html#id290)) and it gives you the option
    to import modules with test utilities.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 将[示例 6-2](#example_testing_end_to_end)的内容放入一个名为*test_main.py*的文件中，放在一个名为*tests*的目录中。包含一个空的*__init__.py*文件将测试套件转换为一个可导入的包。这样可以使您模仿您正在测试的包的布局，^([1](ch06.html#id290))并且可以选择导入具有测试实用工具的模块。
- en: 'At this point, your project should be structured in the following way:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您的项目应该按以下方式结构化：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Managing Test Dependencies
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理测试依赖项
- en: 'Tests must be able to import your project and its dependencies, so you need
    to install pytest in your project environment. For example, add a `tests` extra
    to your project:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 测试必须能够导入您的项目及其依赖项，因此您需要在项目环境中安装 pytest。例如，将一个`tests`的额外项添加到您的项目中：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can now install pytest in the project environment:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以在项目环境中安装 pytest：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternatively, compile a requirements file and synchronize your environment:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，编译一个需求文件并同步您的环境：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you use Poetry, add pytest to your project using `poetry add` instead:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 Poetry，请使用`poetry add`将 pytest 添加到您的项目中：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Please refer to these steps when I ask you to add test dependencies later in
    this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请在本章后面我要求您添加测试依赖项时参考这些步骤。
- en: Finally, let’s run the test suite. If you’re on Windows, activate the environment
    before you run the following command.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们运行测试套件。如果您使用的是 Windows，在运行以下命令之前，请激活环境。
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Use `py -m pytest` even in Poetry projects. It’s both shorter and safer than
    `poetry run pytest`. If you forget to install pytest into the environment, Poetry
    falls back to your global environment. (The safe variant would be `poetry run
    python -m pytest`.)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在 Poetry 项目中，也要使用`py -m pytest`。这既更短，也更安全，比`poetry run pytest`更安全。如果忘记将 pytest
    安装到环境中，Poetry 将退回到您的全局环境中。（安全的变体将是`poetry run python -m pytest`。）
- en: Designing for Testability
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计可测试性
- en: Writing finer-grained tests for the program is much harder. The API endpoint
    returns a random article, so *which* title and summary should the tests expect?
    Every invocation sends an HTTP request to the real Wikipedia API. Those network
    roundtrips will make the test suite excruciatingly slow—​and you can only run
    tests when your machine is connected to the internet.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为程序编写更精细的测试要困难得多。API 终点返回一个随机文章，那么测试应该期望*哪个*标题和摘要？每次调用都会向真实的维基百科 API 发送一个 HTTP
    请求。这些网络往返将使测试套件变得极其缓慢——而且只有在您的计算机连接到互联网时才能运行测试。
- en: Python programmers have an arsenal of tools at their disposal for situations
    like this. Most of these involve some form of *monkey patching*, which replaces
    functions or objects at runtime to make the code easier to test. For example,
    you can capture program output by replacing `sys.stdout` with a file-like object
    that writes to an internal buffer for later inspection. You can replace `urlopen`
    with a function that returns canned HTTP responses of your liking. Libraries like
    `responses`, `respx`, or `vcr.py` provide high-level interfaces that monkey patch
    the HTTP machinery behind the scenes. More generic approaches use the standard
    `unittest.mock` module or pytest’s `monkeypatch` fixture.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Python 程序员在这种情况下有一系列工具可供使用。其中大部分涉及某种形式的*猴子补丁*，即在运行时替换函数或对象，以使代码更易于测试。例如，您可以通过将`sys.stdout`替换为一个写入内部缓冲区以供后续检查的文件样对象来捕获程序输出。您可以将`urlopen`替换为返回您喜欢的固定
    HTTP 响应的函数。像`responses`、`respx`或`vcr.py`这样的库提供了在幕后猴子补丁 HTTP 机制的高级接口。更通用的方法使用标准的`unittest.mock`模块或
    pytest 的`monkeypatch`装置。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The term *monkey patch* for replacing code at runtime originated at Zope Corporation.
    Initially, people at Zope called the technique “guerilla patching”, since it didn’t
    abide by the usual rules of patch submission. People heard that as “gorilla patch”—and
    soon the more carefully crafted ones came to be known as “monkey patches”.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*猴子补丁*一词是在 Zope 公司首创的用于在运行时替换代码的术语。最初，Zope 公司的人们将这项技术称为“游击补丁”，因为它不遵守常规的补丁提交规则。人们听到的是“大猩猩补丁”——很快，更精心制作的补丁就被称为“猴子补丁”。'
- en: 'While these tools serve their purpose, I’d encourage you to focus on the root
    of the problem: [Example 6-1](#example_testing_wikipedia) has no separation of
    concerns. A single function serves as the application entry point, communicates
    with an external API, and presents the results on the console. This makes it hard
    to test its features in isolation.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些工具能够完成它们的任务，但我建议你专注于问题的根源：[示例 6-1](#example_testing_wikipedia)没有关注点分离。一个函数既作为应用程序的入口点，又与外部API通信，并在控制台上呈现结果。这使得很难单独测试其功能。
- en: 'The program also lacks abstraction, in two ways. First, it doesn’t encapsulate
    implementation details when interfacing with other systems, like interacting with
    the Wikipedia API or writing to the terminal. Second, its central concept—​the
    Wikipedia article—​only appears as an amorphous JSON object: the program doesn’t
    abstract its domain model in any way, such as by defining an `Article` class.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序还缺乏抽象化，有两个方面。首先，在与其他系统交互时，如与维基百科API交互或写入终端时，它没有封装实现细节。其次，它的中心概念——维基百科文章——只是一个无定形的JSON对象：程序未以任何方式抽象其域模型，例如定义一个`Article`类。
- en: '[Example 6-3](#example_testing_refactored) shows a refactoring that makes the
    code more testable. While this version of the program is longer, it expresses
    its logic more clearly and is more amenable to change. Good tests don’t just catch
    bugs: they improve the design of your code.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-3](#example_testing_refactored)展示了一种使代码更易于测试的重构。虽然这个版本的程序更长，但它更清晰地表达了逻辑，并且更容易修改。好的测试不仅能捕获错误：它们还改善了代码的设计。'
- en: Example 6-3\. Refactoring for testability
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-3\. 可测试性重构
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_testing_with_pytest_CO1-1)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_testing_with_pytest_CO1-1)'
- en: For brevity, examples in this chapter only show imports on first use.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，本章节中的示例仅在第一次使用时显示导入。
- en: The refactoring extracts `fetch` and `show` functions from `main`. It also defines
    an `Article` class as the common denominator of these functions. Let’s see how
    these changes let you test the parts of the program in isolation and in a repeatable
    way.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 重构将`main`中的`fetch`和`show`函数提取出来。它还将`Article`类定义为这些函数的共同基础。让我们看看这些改变如何让你能够以隔离和可重复的方式测试程序的各个部分。
- en: The `show` function accepts any file-like object. While `main` passes `sys.stdout`,
    tests can pass an `io.StringIO` instance to store the output in memory. [Example 6-4](#example_testing_show)
    uses this technique to check that the output ends with a newline. The final newline
    ensures the output doesn’t run into the next shell prompt.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`show`函数接受任何类似文件的对象。虽然`main`传递了`sys.stdout`，测试可以传递一个`io.StringIO`实例以将输出存储在内存中。[示例 6-4](#example_testing_show)使用这种技术来检查输出是否以换行符结束。最后的换行符确保输出不会延伸到下一个shell提示符。'
- en: Example 6-4\. Testing the `show` function
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-4\. 测试`show`函数
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There’s another benefit to the refactoring: The functions hide the implementation
    behind an interface that only involves your problem domain—​URLs, articles, files.
    This means your tests are less likely to break when you swap out your implementation.
    Go ahead and change the `show` function to use Rich, as shown in [Example 6-5](#example_testing_rich).^([2](ch06.html#id291))
    You won’t need to adapt your tests!'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 重构还有另一个好处：函数将实现隐藏在只涉及你的问题域——URL、文章、文件的接口后面。这意味着当你替换实现时，你的测试不太可能会失败。继续更改`show`函数以使用Rich，就像[示例 6-5](#example_testing_rich)中所示那样。^([2](ch06.html#id291))
    你不需要调整你的测试！
- en: Example 6-5\. Swapping out the implementation of `show`
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-5\. 替换`show`的实现
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In fact, the whole point of tests is to give you confidence that your program
    still works after making changes like this. Mocks and monkey patches, on the other
    hand, are brittle: They tie your test suite to implementation details, making
    it increasingly hard to change your program down the road.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，测试的整个目的是在你进行此类更改后依然确保程序正常工作。另一方面，模拟和猴子补丁是脆弱的：它们将你的测试套件与实现细节捆绑在一起，使得今后更改程序变得越来越困难。
- en: Fixtures and Parameterization
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fixture 和参数化
- en: 'Here are some other properties of the `show` function that you might check
    for:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一些`show`函数的其他属性，你可能会检查：
- en: It should include all the words of the title and summary.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该包含标题和摘要的所有单词。
- en: There should be a blank line after the title.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题后应有一个空行。
- en: The summary should not exceed a line length of 72 characters.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摘要不应超过72个字符的行长。
- en: 'Every test for the `show` function starts by setting up an output buffer. You
    can use a fixture to remove this code duplication. *Fixtures* are functions declared
    with the `pytest.fixture` decorator:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `show` 函数的测试都以设置输出缓冲区开始。你可以使用 fixture 来消除此代码重复。*Fixture* 是使用 `pytest.fixture`
    装饰器声明的函数：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Tests (and fixtures) can use a fixture by including a function parameter with
    the same name. When pytest invokes the test function, it passes the return value
    of the fixture function. Let’s rewrite [Example 6-4](#example_testing_show) to
    use the fixture:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 测试（及 fixture）可以通过包含与相同名称的函数参数使用 fixture。当 pytest 调用测试函数时，它传递 fixture 函数的返回值。让我们重写
    [Example 6-4](#example_testing_show) 来使用该 fixture：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Warning
  id: totrans-62
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'If you forget to add the parameter `file` to the test function, you get a confusing
    error: `''function'' object has no attribute ''write''`. This happens because
    the name `file` now refers to the fixture function in the same module.^([3](ch06.html#id292))'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果忘记将参数 `file` 添加到测试函数中，会出现令人困惑的错误：`'function' object has no attribute 'write'`。这是因为现在名称
    `file` 指向同一模块中的 fixture 函数。^([3](ch06.html#id292))
- en: If every test used the same article, you’d likely miss some edge cases. For
    example, you don’t want your program to crash if an article comes with an empty
    title. [Example 6-6](#example_testing_parametrize) runs the test for a number
    of articles with the `@pytest.mark.parametrize` decorator.^([4](ch06.html#id293))
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个测试都使用相同的文章，你可能会遗漏一些边界情况。例如，如果一篇文章标题为空，你不希望程序崩溃。[Example 6-6](#example_testing_parametrize)
    对多篇文章使用 `@pytest.mark.parametrize` 装饰器运行测试。^([4](ch06.html#id293))
- en: Example 6-6\. Running tests against multiple articles
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 6-6\. 对多篇文章运行测试
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you parameterize many tests in the same way, you can create a *parameterized
    fixture*, a fixture with multiple values ([Example 6-7](#example_testing_parametrized_fixture)).
    As before, pytest runs the test once for each article in `articles`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以相同方式参数化许多测试，可以创建一个*参数化 fixture*，一个带有多个值的 fixture（参见 [Example 6-7](#example_testing_parametrized_fixture)）。与之前一样，pytest
    会对每篇文章在 `articles` 中运行测试一次。
- en: Example 6-7\. Parameterized fixture for running tests against multiple articles
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 6-7\. 参数化 fixture，用于对多篇文章运行测试
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'So what did you gain here? For one thing, you don’t need to decorate each test
    with `@pytest.mark.parametrize`. There’s another advantage if your tests aren’t
    all in the same module: You can place fixtures in a file named *conftest.py* and
    use them across your entire test suite without imports.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 那么你在这里得到了什么？首先，你不需要为每个测试都添加 `@pytest.mark.parametrize` 装饰器。如果你的测试不都在同一个模块中，还有另一个优势：你可以将
    fixture 放在名为 *conftest.py* 的文件中，在整个测试套件中使用而无需导入。
- en: 'The syntax for parameterized fixtures is somewhat arcane. To keep things simple,
    I like to define a small helper:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化 fixture 的语法有些晦涩。为了保持简单，我喜欢定义一个小助手：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Use the helper to simplify the fixture from [Example 6-7](#example_testing_parametrized_fixture).
    You can also inline the `articles` variable from [Example 6-6](#example_testing_parametrize):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 helper 简化 [Example 6-7](#example_testing_parametrized_fixture) 中的 fixture。还可以从
    [Example 6-6](#example_testing_parametrize) 中内联 `articles` 变量：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you have a test suite written with `unittest`, there’s no need to rewrite
    it to start using pytest—​pytest “speaks” `unittest`, too. Use pytest as a test
    runner right away and you can rewrite your test suite incrementally later.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个使用 `unittest` 编写的测试套件，没有必要重写它以开始使用 pytest——pytest 也“说” `unittest`。立即使用
    pytest 作为测试运行器，稍后逐步重写你的测试套件。
- en: Advanced Techniques for Fixtures
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fixture 的高级技术
- en: 'For the `fetch` function, tests can set up a local HTTP server and perform
    a *roundtrip* check. This is shown in [Example 6-8](#example_testing_fetch): You
    serve an `Article` instance via HTTP, fetch the article from the server, and check
    that the served and fetched instances are equal.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `fetch` 函数，测试可以设置一个本地 HTTP 服务器并执行*往返*检查。这在 [Example 6-8](#example_testing_fetch)
    中展示：你通过 HTTP 提供一个 `Article` 实例，从服务器获取文章，并检查提供和获取的实例是否相等。
- en: Example 6-8\. Testing the `fetch` function (version 1)
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 6-8\. 测试 `fetch` 函数（版本 1）
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `serve` helper function takes an article and returns a URL for fetching
    the article. More precisely, it wraps the URL in a *context manager*, an object
    for use in a `with` block. This allows `serve` to clean up after itself when you
    exit the `with` block—​by shutting down the server:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`serve` 辅助函数接受一篇文章并返回一个用于获取文章的 URL。更确切地说，它将 URL 包装在*上下文管理器*中，这是一个可以在 `with`
    块中使用的对象。这允许 `serve` 在退出 `with` 块时进行清理——通过关闭服务器：'
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can implement the `serve` function using the `http.server` module from the
    standard library ([Example 6-9](#example_testing_serve)). Don’t worry too much
    about the details, though. Later in this chapter, I’ll introduce the `pytest-httpserver`
    plugin, which will bear the brunt of the work.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用标准库中的`http.server`模块实现`serve`函数（[示例 6-9](#example_testing_serve)）。不过，不必太担心细节。本章稍后将介绍`pytest-httpserver`插件，它将承担大部分工作。
- en: Example 6-9\. The `serve` function
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-9\. `serve`函数
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](assets/1.png)](#co_testing_with_pytest_CO2-1)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_testing_with_pytest_CO2-1)'
- en: The request handler responds to every GET request with a UTF-8 encoded JSON
    representation of the article.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请求处理程序用UTF-8编码的JSON表示文章响应每个GET请求。
- en: '[![2](assets/2.png)](#co_testing_with_pytest_CO2-2)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_testing_with_pytest_CO2-2)'
- en: The server only accepts local connections. The operating system randomly assigns
    the port number.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器仅接受本地连接。操作系统会随机分配端口号。
- en: '[![3](assets/3.png)](#co_testing_with_pytest_CO2-3)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_testing_with_pytest_CO2-3)'
- en: The server runs in a background thread. This allows control to return to the
    tests.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器在后台线程中运行。这样可以使控制权返回到测试中。
- en: 'Firing up and shutting down a web server for every test is expensive. Would
    it help to turn the server into a fixture? At first glance, not much—​every test
    gets its own instance of a fixture. However, you can instruct pytest to create
    a fixture only once during the entire test session, using a *session-scoped fixture*:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 每次测试都启动和关闭Web服务器是昂贵的。将服务器转换为夹具是否有所帮助？乍一看，效果不大—​每个测试都获得其自己的夹具实例。但是，您可以指示pytest在整个测试会话期间仅创建一次夹具，使用*会话范围的夹具*：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That looks more promising, but how do you shut down the server when the tests
    are done with it? Up to now, your fixtures have only prepared a test object and
    returned it. You can’t run code after a `return` statement. However, you *can*
    run code after a `yield` statement—​so pytest allows you to define a fixture as
    a generator.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来更有希望，但是当测试完成时如何关闭服务器呢？到目前为止，您的夹具仅准备了一个测试对象并返回它。您不能在`return`语句之后运行代码。但是，在`yield`语句之后您可以运行代码—​因此pytest允许您将夹具定义为生成器。
- en: A *generator fixture* prepares a test object, yields it, and cleans up resources
    at the end—​similar to a context manager. You use it in the same way as an ordinary
    fixture that returns its test object. Pytest handles the setup and teardown phases
    behind the scenes and calls your test function with the yielded value.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*生成器夹具*准备一个测试对象，yield它，并在结束时清理资源—​类似于上下文管理器。您可以像普通夹具一样使用它，该夹具返回其测试对象。Pytest在幕后处理设置和拆卸阶段，并使用yield的值调用您的测试函数。'
- en: '[Example 6-10](#example_testing_httpserver_fixture) defines the `httpserver`
    fixture using the generator technique.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-10](#example_testing_httpserver_fixture)使用生成器技术定义了`httpserver`夹具。'
- en: Example 6-10\. The `httpserver` fixture
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-10\. `httpserver`夹具
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[![1](assets/1.png)](#co_testing_with_pytest_CO3-1)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_testing_with_pytest_CO3-1)'
- en: Unlike in [Example 6-9](#example_testing_serve), there’s no `article` in scope.
    Instead, the request handler accesses it from the `article` attribute on the server
    (see below).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 6-9](#example_testing_serve)中，范围内没有`article`。相反，请求处理程序从服务器的`article`属性中访问它（详见下文）。
- en: 'There’s still a missing piece: You need to define the `serve` function. The
    function now depends on the `httpserver` fixture to do its work, so you can’t
    just define it at the module level. Let’s move it into the test function for now
    ([Example 6-11](#example_testing_fetch_v2)).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个遗漏的部分：您需要定义`serve`函数。现在该函数依赖于`httpserver`夹具来完成其工作，因此您不能简单地将其定义为模块级别。让我们暂时将其移动到测试函数中（[示例 6-11](#example_testing_fetch_v2)）。
- en: Example 6-11\. Testing the `fetch` function (version 2)
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-11\. 测试`fetch`函数（版本2）
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[![1](assets/1.png)](#co_testing_with_pytest_CO4-1)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_testing_with_pytest_CO4-1)'
- en: Store the article in the server, so the request handler can access it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将文章存储在服务器中，以便请求处理程序可以访问它。
- en: The `serve` function no longer returns a context manager, just a plain URL—​the
    `httpserver` fixture handles all of the setting up and tearing down. But you can
    still do better. The nested function clutters the test—​and every other test for
    the `fetch` function. Instead, let’s define `serve` inside its own fixture—​after
    all, fixtures can return any object, including functions ([Example 6-12](#example_testing_serve_fixture)).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`serve` 函数不再返回上下文管理器，只是一个简单的 URL—​`httpserver` fixture 处理所有的设置和拆卸。但是你仍然可以做得更好。内部函数会使测试代码变得混乱—​还有
    `fetch` 函数的所有其他测试。相反，让我们在其自己的 fixture 中定义 `serve`—​毕竟，fixtures 可以返回任何对象，包括函数（[Example 6-12](#example_testing_serve_fixture)）。'
- en: Example 6-12\. The `serve` fixture
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 6-12\. `serve` fixture
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](assets/1.png)](#co_testing_with_pytest_CO5-1)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_testing_with_pytest_CO5-1)'
- en: The outer function defines a `serve` fixture, which depends on `httpserver`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 外部函数定义了一个 `serve` fixture，依赖于 `httpserver`。
- en: '[![2](assets/2.png)](#co_testing_with_pytest_CO5-2)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_testing_with_pytest_CO5-2)'
- en: The inner function is the `serve` function you call in your tests.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 内部函数就是你在测试中调用的 `serve` 函数。
- en: Thanks to the `serve` fixture, the test function becomes a one-liner ([Example 6-13](#example_testing_fetch_fixture)).
    It’s also much faster, because you only start and stop the server once per session.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了 `serve` fixture，测试函数变成了一个单行代码（[Example 6-13](#example_testing_fetch_fixture)）。它也更快，因为你每个会话只启动和停止一次服务器。
- en: Example 6-13\. Testing the `fetch` function (version 3)
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 6-13\. 测试 `fetch` 函数（版本 3）
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Your test isn’t tied to any particular HTTP client library. [Example 6-14](#example_testing_httpx)
    swaps out the implementation of the `fetch` function to use HTTPX.^([5](ch06.html#id294))
    This would have broken any test that used monkey patching—​but your test will
    still pass!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你的测试与任何特定的 HTTP 客户端库无关。[Example 6-14](#example_testing_httpx) 替换了 `fetch` 函数的实现以使用
    HTTPX。^([5](ch06.html#id294)) 这可能会破坏使用猴子补丁的任何测试—​但你的测试仍然会通过！
- en: Example 6-14\. Swapping out the implementation of `fetch`
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 6-14\. 替换 `fetch` 的实现
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Extending pytest with Plugins
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用插件扩展 pytest
- en: As you’ve seen in [“Entry Points”](ch03.html#section_packages_entrypoints),
    pytest’s extensible design lets anybody contribute pytest plugins and publish
    them to PyPI,^([6](ch06.html#id295)) so a rich ecosystem of plugins has evolved.
    You’ve already seen the `pytest-sugar` plugin, which enhances pytest’s output,
    including adding a progress bar. In this section, you’ll look at a few more.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[“入口点”](ch03.html#section_packages_entrypoints)中看到的，pytest 的可扩展设计允许任何人贡献
    pytest 插件并将其发布到 PyPI，^([6](ch06.html#id295)) 因此插件的丰富生态系统已经形成。你已经看到了 `pytest-sugar`
    插件，它增强了 pytest 的输出，包括添加了一个进度条。在本节中，你将看到更多插件。
- en: The pytest-httpserver Plugin
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: pytest-httpserver 插件
- en: The [`pytest-httpserver`](https://pytest-httpserver.readthedocs.io/) plugin
    provides an `httpserver` fixture that’s more versatile and battle-tested than
    [Example 6-10](#example_testing_httpserver_fixture). Let’s use this plugin.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[`pytest-httpserver`](https://pytest-httpserver.readthedocs.io/) 插件提供了一个更多功能且经过实战测试的
    `httpserver` fixture，比[Example 6-10](#example_testing_httpserver_fixture)更加灵活。让我们使用这个插件。'
- en: First, add `pytest-httpserver` to your test dependencies. Next, remove the existing
    `httpserver` fixture from your test module. Finally, update the `serve` fixture
    to use the plugin ([Example 6-15](#example_testing_serve_fixture_plugin)).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将 `pytest-httpserver` 添加到你的测试依赖中。接下来，从你的测试模块中移除现有的 `httpserver` fixture。最后，更新
    `serve` fixture 以使用该插件（[Example 6-15](#example_testing_serve_fixture_plugin)）。
- en: Example 6-15\. The `serve` fixture using `pytest-httpserver`
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 6-15\. 使用 `pytest-httpserver` 的 `serve` fixture
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[Example 6-15](#example_testing_serve_fixture_plugin) configures the server
    to respond to requests to `"/"` with the JSON representation of the article. The
    plugin offers much flexibility beyond this use case—​for example, you can add
    custom request handlers or communicate over HTTPS.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 6-15](#example_testing_serve_fixture_plugin) 配置服务器以响应对 `"/"` 的请求，并返回文章的
    JSON 表示。该插件提供了远比这个用例更灵活的功能，例如，你可以添加自定义请求处理程序或者通过 HTTPS 进行通信。'
- en: The pytest-xdist Plugin
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: pytest-xdist 插件
- en: 'As your test suite grows, you’ll be looking for ways to speed up test runs.
    Here’s an easy way: utilize all your CPU cores. The [`pytest-xdist`](https://pytest-xdist.readthedocs.io/)
    plugin spawns a worker process on each processor and distributes tests randomly
    across the workers. The randomization also helps detect hidden dependencies between
    your tests.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的测试套件的增长，你会寻找加快测试运行速度的方法。这里有一个简单的方法：利用所有的 CPU 核心。[`pytest-xdist`](https://pytest-xdist.readthedocs.io/)
    插件在每个处理器上生成一个工作进程，并随机分发测试。这种随机化也有助于检测测试之间的隐藏依赖关系。
- en: 'Add `pytest-xdist` to your test dependencies and update your environment. Use
    the option `--numprocesses` or `-n` to specify the number of worker processes.
    Specify `auto` to use all physical cores on your system:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将`pytest-xdist`添加到您的测试依赖项并更新您的环境。使用选项`--numprocesses`或`-n`指定工作进程数。指定`auto`以使用系统上的所有物理核心：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The factory-boy and faker Libraries
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: factory-boy和faker库
- en: In [“Fixtures and Parameterization”](#section_testing_fixtures), you hardcoded
    the articles your tests run against. Let’s avoid this boilerplate—​it makes your
    tests hard to maintain.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“夹具和参数化”](#section_testing_fixtures)中，您硬编码了测试运行的文章。让我们避免这种样板代码—​它使您的测试难以维护。
- en: Instead, the [`factory-boy`](https://factoryboy.readthedocs.io/) library lets
    you create factories for test objects. You can generate batches of objects with
    predictable attributes, such as by using a sequence number. Alternatively, you
    can populate attributes randomly using the [`faker`](https://faker.readthedocs.io/)
    library.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，[`factory-boy`](https://factoryboy.readthedocs.io/)库允许您为测试对象创建工厂。您可以使用序列号生成具有可预测属性的对象批次。或者，您可以使用[`faker`](https://faker.readthedocs.io/)库随机填充属性。
- en: Add `factory-boy` to your test dependencies and update your environment. [Example 6-16](#example_testing_factoryboy)
    defines a factory for randomized articles and creates a batch of ten articles
    for the `article` fixture. (If you want to see `pytest-xdist` in action, increase
    the number of articles and run pytest with `-n auto`.)
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 将`factory-boy`添加到您的测试依赖项并更新您的环境。[示例6-16](#example_testing_factoryboy)定义了一个用于随机文章的工厂，并为`article`夹具创建了十篇文章的批次。（如果您想看到`pytest-xdist`的效果，请增加文章数并使用`-n
    auto`运行pytest。）
- en: Example 6-16\. Creating a batch of articles with `factory-boy` and `faker`
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例6-16\. 使用`factory-boy`和`faker`创建一批文章
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[![1](assets/1.png)](#co_testing_with_pytest_CO6-1)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_testing_with_pytest_CO6-1)'
- en: Specify the class of the test objects with `Meta.model`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Meta.model`指定测试对象的类。
- en: '[![2](assets/2.png)](#co_testing_with_pytest_CO6-2)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_testing_with_pytest_CO6-2)'
- en: Use a random sentence for the title and a random paragraph for the summary.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 标题使用随机句子，摘要使用随机段落。
- en: '[![3](assets/3.png)](#co_testing_with_pytest_CO6-3)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_testing_with_pytest_CO6-3)'
- en: Generate a batch of articles using the `build_batch` method.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`build_batch`方法生成一批文章。
- en: This simplified factory doesn’t cover edge cases particularly well. For a real-world
    application, you should include empty and extremely large strings, as well as
    unusual characters such as control characters. Another great testing library that
    lets you explore the search space of possible inputs is [`hypothesis`](https://hypothesis.readthedocs.io/).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简化的工厂不能很好地处理边界情况。对于真实的应用程序，您应该包括空和非常大的字符串，以及控制字符等异常字符。另一个可以让您探索可能输入搜索空间的优秀测试库是[`hypothesis`](https://hypothesis.readthedocs.io/)。
- en: Other Plugins
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他插件
- en: Pytest plugins perform a variety of functions ([Table 6-1](#table_testing_pytest_plugins)).
    These include executing tests in parallel or in random order, presenting or reporting
    test results in custom ways, and integrating with frameworks and other tools.
    Many plugins provide useful fixtures—​such as for interacting with external systems
    or creating test doubles.^([7](ch06.html#id296))
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest插件执行各种功能（[表6-1](#table_testing_pytest_plugins)）。这些功能包括并行或随机顺序执行测试，以自定义方式呈现或报告测试结果，以及与框架和其他工具集成。许多插件提供有用的夹具，例如用于与外部系统交互或创建测试双。
- en: Table 6-1\. A selection of pytest plugins
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-1\. 一些pytest插件的选择
- en: '| Plugin | Category | Description | Option |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 插件 | 类别 | 描述 | 选项 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `pytest-xdist` | Execution | Distribute tests across multiple CPUs | `--numprocesses`
    |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `pytest-xdist` | 执行 | 将测试分布到多个CPU上 | `--numprocesses` |'
- en: '| `pytest-sugar` | Presentation | Enhance output with a progress bar |  |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `pytest-sugar` | 展示 | 用进度条增强输出 |  |'
- en: '| `pytest-icdiff` | Presentation | Show colorized diffs on test failures |  |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `pytest-icdiff` | 展示 | 在测试失败时显示着色差异 |  |'
- en: '| `anyio` | Frameworks | Use asynchronous tests with asyncio and trio |  |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `anyio` | 框架 | 使用异步测试与asyncio和trio |  |'
- en: '| `pytest-httpserver` | Fake servers | Spawn an HTTP server with canned responses
    |  |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `pytest-httpserver` | 伪服务器 | 启动带有预设响应的HTTP服务器 |  |'
- en: '| `pytest-factoryboy` | Fake data | Turn factories into fixtures |  |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `pytest-factoryboy` | 伪数据 | 将工厂转换为夹具 |  |'
- en: '| `pytest-datadir` | Storage | Access static data in your test suite |  |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `pytest-datadir` | 存储 | 在测试套件中访问静态数据 |  |'
- en: '| `pytest-cov` | Coverage | Produce coverage reports with Coverage.py | `--cov`
    |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `pytest-cov` | 覆盖率 | 使用 Coverage.py 生成覆盖率报告 | `--cov` |'
- en: '| `xdoctest` | Documentation | Run code examples from docstrings | `--xdoctest`
    |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `xdoctest` | 文档 | 运行来自文档字符串的代码示例 | `--xdoctest` |'
- en: '| `typeguard` | Type checking | Type-check your code at runtime | `--typeguard-packages`
    |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `typeguard` | 类型检查 | 在运行时对你的代码进行类型检查 | `--typeguard-packages` |'
- en: Tip
  id: totrans-159
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Find each project on PyPI at `https://pypi.org/project/<name>`. The project
    homepage is available under *Project links* in the navigation bar.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在PyPI上找到每个项目：`https://pypi.org/project/<name>`。项目主页在导航栏的*项目链接*下可用。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you’ve learned how to test your Python projects with pytest:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了如何使用 pytest 测试你的 Python 项目：
- en: Tests are functions that exercise your code and check for expected behavior
    using the `assert` built-in. Prefix their names—​and the names of the containing
    modules—​with `test_`, and pytest will discover them automatically.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试是运行你的代码并使用内置的`assert`来检查预期行为的函数。将它们的名称前缀—和包含模块的名称—与`test_`，pytest会自动发现它们。
- en: Fixtures are functions or generators that set up and tear down test objects;
    declare them with the `@pytest.fixture` decorator. You can use a fixture in a
    test by including a parameter named like the fixture.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 固定装置是设置和撤销测试对象的函数或生成器；使用`@pytest.fixture`装饰器声明它们。你可以通过包含与装置名称相同的参数在测试中使用装置。
- en: Plugins for pytest can provide useful fixtures, as well as modify test execution,
    enhance reporting, and much more.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pytest的插件可以提供有用的固定装置，以及修改测试执行，增强报告等等。
- en: 'One of the prime characteristics of good software is that it’s easy to change,
    since any piece of code used in the real world must adapt to evolving requirements
    and an ever-changing environment. Tests make change easier in several ways:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀软件的主要特征之一是易于变更，因为任何实际使用的代码都必须适应不断变化的需求和环境。测试以多种方式简化变更：
- en: 'They drive software design towards loosely coupled building blocks that you
    can test in isolation: fewer interdependencies mean fewer barriers to change.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们将软件设计引向松散耦合的构建模块，你可以单独测试：减少依赖意味着减少变更障碍。
- en: They document and enforce expected behavior. That gives you the freedom and
    confidence to continuously refactor your codebase—​keeping it maintainable as
    it grows and transforms.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们记录并强制执行预期行为。这使你有自由和信心不断重构你的代码库—随着它的增长和转变保持可维护性。
- en: They reduce the cost of change by detecting defects early. The earlier you catch
    an issue, the cheaper it is to work out the root cause and develop a fix.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们通过早期检测缺陷来降低变更成本。你越早发现问题，修复根本原因和开发修复方案的成本就越低。
- en: End-to-end tests give you high confidence that a feature works as designed—​but
    they’re slow, flaky, and bad at isolating the causes of failures. Let most of
    your tests be unit tests. Avoid monkey patching to break the dependencies of your
    code for testability. Instead, decouple the core of your application from I/O,
    external systems, and third-party frameworks. Good software design and a solid
    testing strategy will keep your test suite blazingly fast and resilient to change.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试能够高度确保功能按设计方式工作—但它们速度慢、不稳定，并且很难分离失败的原因。让大部分测试都是单元测试。避免猴子补丁以打破代码的依赖性以进行可测试性。而是，将你的应用程序核心与I/O、外部系统和第三方框架解耦。良好的软件设计和坚实的测试策略将使你的测试套件速度飞快且对变更具有弹性。
- en: 'This chapter focuses on the tooling side of things, but there’s so much more
    to good testing practices. Luckily, other people have written fantastic texts
    about this topic. Here are three of my all-time favorites:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本章侧重于工具方面的事情，但良好的测试实践远不止这些。幸运的是，其他人已经写了一些关于这个主题的精彩文章。以下是我一直喜爱的三本书：
- en: 'Kent Beck, *Test-Driven Development: By Example* (London: Pearson, 2002).'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kent Beck，《测试驱动开发：通过示例》（伦敦：Pearson，2002）。
- en: 'Michael Feathers, *Working Effectively with Legacy Code* (London: Pearson,
    2004).'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Michael Feathers，《与遗留代码高效工作》（伦敦：Pearson，2004）。
- en: 'Harry Percival and Bob Gregory, [*Architecture Patterns in Python*](https://learning.oreilly.com/library/view/architecture-patterns-with/9781492052197/)
    (Sebastopol: O’Reilly, 2020).'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Harry Percival 和 Bob Gregory，《Python 中的架构模式》（Sebastopol：O’Reilly，2020）。
- en: 'If you want to know all about how to test with pytest, read Brian’s book:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解如何使用 pytest 进行测试的所有内容，请阅读Brian的书：
- en: 'Brian Okken, *Python Testing with pytest: Simple, Rapid, Effective, and Scalable*,
    Second Edition (Raleigh: The Pragmatic Bookshelf, 2022).'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Brian Okken，《Python Testing with pytest: Simple, Rapid, Effective, and Scalable》，第二版（Raleigh:
    The Pragmatic Bookshelf，2022）。'
- en: ^([1](ch06.html#id290-marker)) Large packages can have modules with the same
    name—​say, `gizmo.foo.registry` and `gizmo.bar.registry`. Under pytest’s default
    [import mode](https://docs.pytest.org/en/7.1.x/explanation/pythonpath.html#import-modes),
    test modules must have unique fully-qualified names—​so you must place the `test_registry`
    modules in separate `tests.foo` and `tests.bar` packages.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch06.html#id290-marker)) 大型包可能有相同名称的模块——比如，`gizmo.foo.registry` 和 `gizmo.bar.registry`。在
    pytest 的默认[导入模式](https://docs.pytest.org/en/7.1.x/explanation/pythonpath.html#import-modes)下，测试模块必须具有唯一的完全限定名称——因此，你必须将
    `test_registry` 模块放置在单独的 `tests.foo` 和 `tests.bar` 包中。
- en: ^([2](ch06.html#id291-marker)) Remember to add Rich to your project as described
    in [“Specifying Dependencies for a Project”](ch04.html#section_dependencies_specifications).
    If you use Poetry, refer to [“Managing Dependencies”](ch05.html#section_poetry_dependencies).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch06.html#id291-marker)) 记得按照 [“为项目指定依赖项”](ch04.html#section_dependencies_specifications)
    中描述的方式将 Rich 添加到你的项目中。如果你使用 Poetry，请参考 [“管理依赖项”](ch05.html#section_poetry_dependencies)。
- en: ^([3](ch06.html#id292-marker)) My reviewer Hynek recommends a technique to avoid
    this pitfall and get an idiomatic `NameError` instead. The trick is to name the
    fixture explicitly with `@pytest.fixture(name="file")`. This lets you use a private
    name for the function, such as `_file`, that doesn’t collide with the parameter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch06.html#id292-marker)) 我的审阅员 Hynek 建议一种避免这种陷阱并获得习惯性的 `NameError` 的技巧。诀窍是使用
    `@pytest.fixture(name="file")` 明确地为 fixture 命名。这样你就可以使用一个私有名称来命名函数，比如 `_file`，它不会与参数发生冲突。
- en: ^([4](ch06.html#id293-marker)) Note the somewhat uncommon spelling variant *parametrize*
    instead of *parameterize*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch06.html#id293-marker)) 注意略有不同的拼写变体 *parametrize*，而不是 *parameterize*。
- en: ^([5](ch06.html#id294-marker)) Remember to add a dependency on `httpx[http2]`
    to your project.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch06.html#id294-marker)) 记得将 `httpx[http2]` 添加为你项目的依赖。
- en: ^([6](ch06.html#id295-marker)) The [cookiecutter-pytest-plugin](https://github.com/pytest-dev/cookiecutter-pytest-plugin)
    template gives you a solid project structure for writing your own plugin.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch06.html#id295-marker)) [cookiecutter-pytest-plugin](https://github.com/pytest-dev/cookiecutter-pytest-plugin)
    模板为你提供了一个稳固的项目结构，用于编写你自己的插件。
- en: ^([7](ch06.html#id296-marker)) *Test double* is the umbrella term for the various
    kinds of objects tests use in lieu of the real objects used in production code.
    A good overview is [“Mocks Aren’t Stubs”](https://martinfowler.com/articles/mocksArentStubs.html)
    by Martin Fowler, January 2, 2007.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch06.html#id296-marker)) *测试替身* 是测试中使用的各种对象的总称，用以代替生产代码中使用的真实对象。Martin
    Fowler 在2007年1月2日发表的文章 [“Mocks Aren’t Stubs”](https://martinfowler.com/articles/mocksArentStubs.html)
    提供了一个很好的概述。
