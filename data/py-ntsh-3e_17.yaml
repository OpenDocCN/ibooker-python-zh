- en: Chapter 17\. Testing, Debugging, and Optimizing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第17章。测试、调试和优化
- en: You’re not finished with a programming task when you’re done writing the code;
    you’re finished only when the code runs correctly and with acceptable performance.
    *Testing* means verifying that code runs correctly by automatically exercising
    the code under known conditions and checking that the results are as expected.
    *Debugging* means discovering causes of incorrect behavior and repairing them
    (repair is often easy, once you figure out the causes).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编程任务完成并不意味着你写完了代码；只有当代码正确运行并且性能可接受时，任务才算真正完成。*测试*意味着在已知条件下自动运行代码，并检查结果是否符合预期，以验证代码是否正确运行。*调试*则是发现不正确行为的原因并修复它们（一旦找到原因，修复通常很容易）。
- en: '*Optimizing* is often used as an umbrella term for activities meant to ensure
    acceptable performance. Optimizing breaks down into *benchmarking* (measuring
    performance for given tasks to check that it’s within acceptable bounds), *profiling*
    (*instrumenting* the program with extra code to identify performance bottlenecks),
    and actual optimizing (removing bottlenecks to improve program performance). Clearly,
    you can’t remove performance bottlenecks until you’ve found out where they are
    (via profiling), which in turn requires knowing that there *are* performance problems
    (via benchmarking).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*优化*通常作为确保性能可接受的活动的总称。优化包括*基准测试*（为给定任务测量性能，以确保其在可接受范围内）、*性能分析*（在程序中插入额外代码以识别性能瓶颈）和实际优化（消除瓶颈以提高程序性能）。显然，除非通过性能分析找到了性能瓶颈的位置，否则无法消除性能瓶颈，而要找到性能瓶颈，则需要知道是否存在性能问题（通过基准测试获知）。'
- en: 'This chapter covers these subjects in the natural order in which they occur
    in development: testing first and foremost, debugging next, and optimizing last.
    Most programmers’ enthusiasm focuses on optimization: testing and debugging are
    often (wrongly!) perceived as being chores, while optimization is seen as being
    fun. Were you to read only one section of the chapter, we might suggest that section
    be [“Developing a Fast-Enough Python Application”](#developing_a_fast_enough_python_applica),
    which summarizes the Pythonic approach to optimization—close to Jackson’s classic
    “[Rules of Optimization](https://oreil.ly/_dTA8): Rule 1\. Don’t do it. Rule 2
    (for experts only). Don’t do it *yet*.”'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章按照开发中的自然顺序进行讨论：首先是测试，其次是调试，最后是优化。大多数程序员通常将热情集中在优化上：测试和调试经常（错误地！）被视为苦差事，而优化则被认为是有趣的。如果你只打算读本章的一部分，我们建议你阅读[“开发足够快速的Python应用程序”](#developing_a_fast_enough_python_applica)，该节总结了Python优化的方法——与Jackson经典的“[优化法则](https://oreil.ly/_dTA8)：法则1\.
    不要优化。法则2（仅限专家）。暂时不要优化。”相近。
- en: All of these tasks are important; discussion of each could fill at least a book
    by itself. This chapter cannot even come close to exploring every related technique;
    rather, it focuses on Python-specific approaches and tools. Often, for best results,
    you should approach the issue from the higher-level viewpoint of *system analysis
    and design*, rather than focusing only on implementation (in Python and/or any
    other mix of programming languages). Start by studying a good general book on
    the subject, such as *Systems Analysis and Design* by Alan Dennis, Barbara Wixom,
    and Roberta Roth (Wiley).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些任务都很重要；每个任务的讨论都至少能填满一本书。本章甚至无法详尽探讨每个相关技术；它着重于Python特定的方法和工具。通常情况下，为了取得最佳效果，你应该从*系统分析和设计*的更高层视角来解决问题，而不仅仅专注于实现（无论是Python还是其他编程语言的混合）。首先，可以通过学习如Alan
    Dennis、Barbara Wixom和Roberta Roth合著的《Systems Analysis and Design》（Wiley出版）等优秀的通用书籍入手。
- en: Testing
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'In this chapter, we distinguish between two different kinds of testing: *unit
    testing* and *system testing*. Testing is a rich, important field: many more distinctions
    could be drawn, but we focus on the issues that most matter to most software developers.
    Many developers are reluctant to spend time on testing, seeing it as time stolen
    from “real” development, but this is shortsighted: problems in code are easier
    to fix the earlier you find out about them. An extra hour spent developing tests
    will amply pay for itself as you find defects early, saving you many hours of
    debugging that would otherwise have been needed in later phases of the software
    development cycle.^([1](ch17.xhtml#ch01fn125))'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们区分了两种不同类型的测试：*单元测试* 和 *系统测试*。测试是一个丰富而重要的领域：还可以做更多的区分，但我们专注于大多数软件开发者最关心的问题。许多开发者不愿意花时间进行测试，认为这是从“真正”的开发中偷走的时间，但这是短视的：在早期发现问题时更容易修复代码。花费额外的时间开发测试将充分回报自己，因为您早期发现缺陷，节省了后续软件开发周期中需要的大量调试时间。^([1](ch17.xhtml#ch01fn125))
- en: Unit Testing and System Testing
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试和系统测试
- en: '*Unit testing* means writing and running tests to exercise a single module,
    or an even smaller unit, such as a class or function. *System testing* (also known
    as *functional*, *integration*, or *end-to-end* testing) involves running an entire
    program with known inputs. Some classic books on testing also draw the distinction
    between *white-box testing*, done with knowledge of a program’s internals, and
    *black-box testing*, done without such knowledge. This classic viewpoint parallels,
    but does not exactly duplicate, the modern one of unit versus system testing.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*单元测试* 意味着编写和运行测试来执行单个模块，甚至更小的单元，例如类或函数。*系统测试*（也称为*功能*、*集成*或*端到端*测试）涉及使用已知输入运行整个程序。一些经典的测试书籍还在白盒测试（具有程序内部知识进行的测试）与黑盒测试（没有此类知识进行的测试）之间划分。这种经典观点与现代单元与系统测试的观点类似，但并非完全相同。'
- en: 'Unit and system testing serve different goals. Unit testing proceeds apace
    with development; you can and should test each unit as you’re developing it. One
    relatively modern approach (first proposed in 1971 in Gerald Weinberg’s immortal
    classic *The Psychology of Computer Programming* [Dorset House]) is known as *test-driven
    development* (TDD): for each feature that your program must have, you first write
    unit tests, and only then do you proceed to write code that implements the feature
    and makes the tests pass. TDD may seem upside down, but it has advantages; for
    example, it ensures that you won’t omit unit tests for some feature. This approach
    is helpful because it urges you to focus first on exactly *what tasks* a certain
    function, class, or method should accomplish, dealing only afterward with *how*
    to implement that function, class, or method. An innovation along the lines of
    TDD is [*behavior-driven development* (BDD)](http://behavior-driven.org).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试和系统测试有不同的目标。单元测试随着开发进程同时进行；您可以并且应该在开发每个单元时进行测试。一种比较现代的方法（首次在1971年由杰拉尔德·温伯格在他的经典著作
    *计算机编程心理学* [Dorset House] 中提出）被称为*测试驱动开发*（TDD）：对于程序必须具备的每个特性，您首先编写单元测试，然后再编写实现该特性并使测试通过的代码。TDD可能看起来颠倒了，但它有优势；例如，它确保您不会漏掉某些功能的单元测试。这种方法有助于您首先专注于某个函数、类或方法应该完成的确切*任务*，仅在此后处理如何实现该函数、类或方法。沿着TDD的思路的一项创新是[*行为驱动开发*（BDD）](http://behavior-driven.org)。
- en: To test a unit—which may depend on other units not yet fully developed—you often
    have to write *stubs*, also known as *mocks*:^([2](ch17.xhtml#ch01fn126)) fake
    implementations of various units’ interfaces giving known, correct responses in
    cases needed to test other units. The mock module (part of Python’s standard library,
    in the package [unittest](https://oreil.ly/iJJMn)) helps you implement such stubs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试一个单元——它可能依赖于尚未完全开发的其他单元——通常需要编写*存根*，也称为*模拟*：各种单元接口的虚假实现，在需要测试其他单元的情况下提供已知的正确响应。模拟模块（Python标准库的一部分，位于包
    [unittest](https://oreil.ly/iJJMn) 中）帮助您实现这些存根。
- en: 'System testing comes later, since it requires the system to exist, with at
    least some subset of system functionality believed (based on unit testing) to
    be working. System testing offers a soundness check: each module in the program
    works properly (passes unit tests), but does the *whole* program work? If each
    unit is OK but the system is not, there’s a problem in the integration between
    units—the way the units cooperate. For this reason, system testing is also known
    as integration testing.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试在后面进行，因为它需要系统的存在，且至少有一部分系统功能（基于单元测试）被认为是正常工作的。系统测试提供了一种健壮性检查：程序中的每个模块都正常工作（通过单元测试），但整个程序是否正常工作呢？如果每个单元都没问题，但系统不正常，那么问题就在于单元之间的集成——单元的协作方式。因此，系统测试也被称为集成测试。
- en: System testing is similar to running the system in production use, except that
    you fix inputs in advance so that any problems you may find are easy to reproduce.
    The cost of failures in system testing is lower than in production use, since
    outputs from system testing are not used to make decisions, serve customers, control
    external systems, and so on. Rather, outputs from system testing are systematically
    compared with the outputs that the system *should* produce given the known inputs.
    The purpose is to find, in cheap and reproducible ways, discrepancies between
    what the program *should* do and what the program actually *does*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试类似于在生产环境中运行系统，除了你提前固定输入，这样你可能发现的问题就容易重现了。系统测试中的故障成本低于生产环境中的故障，因为系统测试的输出不会用于决策、服务客户、控制外部系统等等。相反，系统测试的输出会系统地与系统*应该*生成的输出进行比较，前提是已知输入。其目的是以廉价且可重现的方式，找出程序*应该*做的事情和程序实际*做*的事情之间的差异。
- en: 'Failures discovered by system testing (just like system failures in production
    use) may reveal defects in unit tests, as well as defects in the code. Unit testing
    may have been insufficient: a module’s unit tests may have failed to exercise
    all the needed functionality of the module. In that case, the unit tests need
    to be beefed up. Do that *before* you change your code to fix the problem, then
    run the newly enhanced unit tests to confirm that they now show the problem. Then
    fix the problem, and run the unit tests again to confirm that they no longer show
    it. Finally, rerun the system tests to confirm that the problem has indeed gone
    away.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试发现的故障（就像生产环境中的系统故障一样）可能会暴露单元测试中的缺陷，以及代码中的缺陷。单元测试可能不足够：一个模块的单元测试可能未能测试模块的所有必需功能。在这种情况下，需要加强单元测试。*在*你更改代码以修复问题之前，先做这个，然后运行新的增强单元测试，确认它们现在显示了问题。然后修复问题，再次运行单元测试，以确认它们不再显示问题。最后，重新运行系统测试，以确认问题确实已经解决。
- en: Bug-Fixing Best Practice
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误修复最佳实践
- en: 'This best practice is a specific application of test-driven design that we
    recommend without reservation: never fix a bug before having added unit tests
    that would have revealed the bug. This provides an excellent, cheap insurance
    against [software regression bugs](https://oreil.ly/msmPd).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这一最佳实践是我们毫无保留推荐的测试驱动设计的一个具体应用：在添加能够揭示错误的单元测试之前，绝不要修复一个错误。这为防止[软件回归错误](https://oreil.ly/msmPd)提供了一个很好的、廉价的保险。
- en: Often, failures in system testing reveal communication problems within the development
    team:^([3](ch17.xhtml#ch01fn127)) a module correctly implements a certain functionality,
    but another module expects different functionality. This kind of problem (an integration
    problem in the strict sense) is hard to pinpoint in unit testing. In good development
    practice, unit tests must run often, so it is crucial that they run fast. It’s
    therefore essential, in the unit testing phase, that each unit can assume other
    units are working correctly and as expected.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，系统测试中的故障会揭示开发团队内部的通信问题：^([3](ch17.xhtml#ch01fn127))一个模块正确实现了某种功能，但另一个模块期望不同的功能。这种问题（严格意义上的集成问题）在单元测试中很难定位。在良好的开发实践中，单元测试必须经常运行，因此它们运行速度必须很快。因此，在单元测试阶段，至关重要的是每个单元都能假设其他单元是正常工作且按预期工作的。
- en: Unit tests run in reasonably late stages of development can reveal integration
    problems if the system architecture is hierarchical, a common and reasonable organization.
    In such an architecture, low-level modules depend on no others (except library
    modules, which you can typically assume to be correct), so the unit tests of such
    low-level modules, if complete, suffice to provide confidence of correctness.
    High-level modules depend on low-level ones, and thus also depend on correct understanding
    about what functionality each module expects and supplies. Running complete unit
    tests on high-level modules (using true low-level modules, not stubs) exercises
    interfaces between modules, as well as the high-level modules’ own code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发的相对后期运行单元测试时，如果系统架构是分层的（这是一种常见且合理的组织方式），可以揭示集成问题。在这样的架构中，低级模块不依赖于其他模块（除了库模块，通常可以假设是正确的），因此这些低级模块的单元测试如果完备的话，就足以提供正确性的信心。高级模块依赖于低级模块，因此也依赖于正确理解每个模块期望和提供的功能。对高级模块进行完整的单元测试（使用真正的低级模块，而不是存根）可以测试模块之间的接口，以及高级模块本身的代码。
- en: Unit tests for high-level modules are thus run in two ways. You run the tests
    with stubs for the low levels during the early stages of development, when the
    low-level modules are not yet ready or, later, when you only need to check the
    correctness of the high levels. During later stages of development, you also regularly
    run the high-level modules’ unit tests using the true low-level modules. In this
    way, you check the correctness of the whole subsystem, from the high levels downward.
    Even in this favorable case, you *still* need to run system tests to ensure that
    you have checked that all of the system’s functionality is exercised and you have
    neglected no interfaces between modules.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，高级模块的单元测试有两种运行方式。在开发的早期阶段，当低级模块尚未准备好或者后来仅需要检查高级模块的正确性时，使用低级模块的存根来运行测试。在开发的后期阶段，还会定期使用真正的低级模块运行高级模块的单元测试。通过这种方式，可以检查从高级到低级的整个子系统的正确性。即使在这种有利的情况下，你仍然需要运行系统测试，以确保检查系统的所有功能是否被使用，并且没有忽略模块之间的任何接口。
- en: System testing is similar to running the program in normal ways. You need special
    support only to ensure supply of known inputs and capture of resulting outputs
    for comparison with expected outputs. This is easy for programs that perform I/O
    on files, and hard for programs whose I/O relies on a GUI, network, or other communication
    with external entities. To simulate such external entities and make them predictable
    and entirely observable, you generally need platform-dependent infrastructure.
    Another useful piece of supporting infrastructure for system testing is a *testing
    framework* to automate the running of system tests, including logging of successes
    and failures. Such a framework can also help testers prepare sets of known inputs
    and corresponding expected outputs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试类似于以正常方式运行程序。你只需要特殊支持来确保提供已知输入并捕获预期输出以进行比较。对于在文件上执行 I/O 的程序，这很容易，但对于依赖 GUI、网络或其他与外部实体通信的程序来说则更为困难。要模拟这些外部实体并使它们可预测和完全可观察，通常需要依赖平台相关的基础设施。系统测试的另一个有用的支持基础设施是*测试框架*，用于自动运行系统测试，并记录成功和失败。这样的框架还可以帮助测试人员准备一系列已知输入及其对应的预期输出。
- en: 'Both free and commercial programs for these purposes exist, and usually do
    not depend on which programming languages are used in the system under test. System
    testing is a close relative of what was classically known as black-box testing:
    testing that is independent from the implementation of the system under test (and
    thus, in particular, independent from the programming languages used for implementation).
    Instead, testing frameworks usually depend on the operating system platform on
    which they run, since the tasks they perform are platform dependent. These include:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些目的都有免费和商业程序，并且通常不依赖于系统测试中使用的编程语言。系统测试与经典的黑盒测试密切相关：这种测试独立于被测试系统的实现（特别是独立于用于实现的编程语言）。而测试框架通常依赖于它们运行的操作系统平台，因为它们执行的任务是平台相关的。这些任务包括：
- en: Running programs with given inputs
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行带有指定输入的程序
- en: Capturing their outputs
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获它们的输出
- en: Simulating/capturing GUI, network, and other interprocess communication I/O
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟/捕获 GUI、网络和其他进程间通信的 I/O
- en: Since frameworks for system testing depend on the platform, not on programming
    languages, we do not cover them further in this book. For a thorough list of Python
    testing tools, see the Python [wiki](https://oreil.ly/5RiTF).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于系统测试的框架取决于平台，而不是编程语言，因此我们在本书中不再详细介绍它们。有关 Python 测试工具的全面列表，请参阅 Python [wiki](https://oreil.ly/5RiTF)。
- en: The doctest Module
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: doctest 模块
- en: The doctest module exists to let you create good examples in your code’s docstrings,
    checking that the examples do in fact produce the results that your docstrings
    show for them. doctest recognizes such examples by looking within the docstring
    for the interactive Python prompt >>>, followed on the same line by a Python statement,
    and the statement’s expected output on the next line(s).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest` 模块旨在让您在代码的文档字符串中创建良好的示例，检查这些示例确实生成了文档字符串所展示的结果。doctest 通过查找文档字符串中的交互式
    Python 提示符 `>>>` 来识别这些示例，后跟同一行上的 Python 语句，并且语句的预期输出在接下来的行中。'
- en: As you develop a module, keep the docstrings up-to-date and enrich them with
    examples. Each time a part of the module (e.g., a function) is ready, or partially
    ready, make it a habit to add examples to its docstring. Import the module into
    an interactive session, and use the parts you just developed to provide examples
    with a mix of typical cases, limit cases, and failing cases. For this specific
    purpose only, use **from** *module* **import** * so that your examples don’t prefix
    *module*. to each name the module supplies. Copy and paste the interactive session
    into the docstring in an editor, adjust any glitches, and you’re almost done.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 开发模块时，请保持文档字符串的更新，并用示例丰富它们。每当模块的一部分（例如函数）准备好或部分准备好时，请养成向其文档字符串添加示例的习惯。将模块导入交互式会话，并使用刚开发的部分提供示例，包括典型案例、极限案例和失败案例的混合。仅为此特定目的使用
    **from** *module* **import** *，以便您的示例不会为每个模块提供的名称加前缀 *module*。将交互式会话复制并粘贴到编辑器中的文档字符串中，调整任何错误，然后几乎完成。
- en: Your documentation is now enriched with examples, and readers will have an easier
    time following it (assuming you choose a good mix of examples, wisely seasoned
    with nonexample text). Make sure you have docstrings, with examples, for the module
    as a whole, and for each function, class, and method the module exports. You may
    choose to skip functions, classes, and methods whose names start with _, since
    (as their names indicate) they’re private implementation details; doctest by default
    ignores them, and so should readers of your module’s source code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的文档已经丰富了示例，读者将更容易地跟随它（假设您选择了一些良好的示例混合，明智地加入非示例文本）。确保您对整个模块以及导出的每个函数、类和方法都有文档字符串和示例。您可以选择跳过名称以
    _ 开头的函数、类和方法，因为（正如它们的名称所示）它们是私有实现细节；默认情况下，doctest 会忽略它们，您的模块源代码的读者也应该如此。
- en: Make Your Examples Match Reality
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使您的示例符合现实
- en: Examples that don’t match the way your code works are worse than useless. Documentation
    and comments are useful only if they match reality; docs and comments that “lie”
    can be seriously damaging.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与代码不匹配的示例比毫无用处更糟糕。文档和注释仅在与现实匹配时才有用；“撒谎”的文档和注释可能会造成严重损害。
- en: Docstrings and comments often get out of date as code changes, and thus become
    misinformation, hampering, rather than helping, any reader of the source. It’s
    better to have no comments and docstrings at all, poor as such a choice would
    be, than to have ones that lie. doctest can help you by running and checking the
    examples in your docstrings. A failing doctest run should prompt you to review
    the docstring that contains the failing example, thus reminding you to keep the
    whole docstring updated.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 随着代码的更改，文档字符串和注释通常会变得过时，从而成为误导信息，不利于源代码的读者。最好的选择是根本没有注释和文档字符串，尽管这样的选择会很差劲，而不是有虚假信息的注释和文档字符串。doctest
    可以通过运行和检查文档字符串中的示例来帮助您。如果 doctest 运行失败，应提示您审查包含失败示例的文档字符串，从而提醒您保持整个文档字符串的更新。
- en: 'At the end of your module’s source, insert the following snippet:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块源的末尾插入以下片段：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code calls the function testmod of the module doctest when you run your
    module as the main program. testmod examines docstrings (the module’s docstring,
    and the docstrings of all public functions, classes, and methods thereof). In
    each docstring, testmod finds all examples (by looking for occurrences of the
    interpreter prompt >>>, possibly preceded by whitespace) and runs each example.
    testmod checks that each example’s results match the output given in the docstring
    right after the example. In case of exceptions, testmod ignores the traceback,
    and just checks that the expected and observed error messages are equal.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将模块作为主程序运行时，此代码会调用 doctest 模块的 testmod 函数。testmod 会检查文档字符串（模块的文档字符串以及所有公共函数、类和方法的文档字符串）。在每个文档字符串中，testmod
    会找到所有示例（通过查找解释器提示符 >>> 的出现，可能会先于空格），并运行每个示例。testmod 检查每个示例的结果是否与示例之后的文档字符串中给出的输出相匹配。在出现异常时，testmod
    会忽略回溯，并只检查预期和观察到的错误消息是否相等。
- en: When everything goes right, testmod terminates silently. Otherwise, it outputs
    detailed messages about the examples that failed, showing expected and actual
    output. [Example 17-1](#example_onesix_onedot_using_doctest) shows a typical example
    of doctest at work on a module *mod.py*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切顺利时，testmod 会悄无声息地终止。否则，它会输出关于失败的示例的详细信息，显示预期和实际输出。[示例 17-1](#example_onesix_onedot_using_doctest)
    展示了 doctest 在 *mod.py* 模块上运行的典型示例。
- en: Example 17-1\. Using doctest
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-1\. 使用 doctest
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this module’s docstring, we snipped the tracebacks from the docstring and
    replaced them with ellipses (...): this is good practice, since doctest ignores
    tracebacks, which add nothing to the explanatory value of a failing case. Apart
    from this snipping, the docstring is the copy and paste of an interactive session,
    plus some explanatory text and empty lines for readability. Save this source as
    *mod.py*, and then run it with **python mod.py**. It produces no output, meaning
    that all the examples work right. Try **python mod.py -v** to get an account of
    all tests it tries, and a verbose summary at the end. Finally, alter the example
    results in the module docstring, making them incorrect, to see the messages doctest
    provides for errant examples.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模块的文档字符串中，我们从文档字符串中剪切了回溯，并用省略号 (...) 替换了它们：这是一个良好的做法，因为 doctest 会忽略回溯，回溯对于失败的情况没有任何解释价值。除了这个剪切之外，文档字符串是交互式会话的复制粘贴，加上一些解释性文本和空行以提高可读性。将此源保存为
    *mod.py*，然后用 **python mod.py** 运行它。它不会产生任何输出，这意味着所有示例都运行正确。尝试 **python mod.py
    -v** 以获取它尝试的所有测试情况，并在最后获取详细摘要。最后，修改模块文档字符串中的示例结果，使其不正确，以查看 doctest 为错误示例提供的消息。
- en: While doctest is not meant for general-purpose unit testing, it can be tempting
    to use it for that purpose. The recommended way to do unit testing in Python is
    with a test framework such as unittest, pytest, or nose2 (covered in the following
    sections). However, unit testing with doctest can be easier and faster to set
    up, since it requires little more than copying and pasting from an interactive
    session. If you need to maintain a module that lacks unit tests, retrofitting
    such tests into the module with doctest is a reasonable short-term compromise,
    as a first step. It’s better to have just doctest-based unit tests than not to
    have any unit tests at all, as might otherwise happen should you decide that setting
    up tests properly with unittest from the start would take you too long.^([4](ch17.xhtml#ch01fn128))
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 doctest 并非用于通用单元测试，但很容易诱人将其用于此目的。在 Python 中进行单元测试的推荐方法是使用测试框架，如 unittest、pytest
    或 nose2（在下面的章节中介绍）。但是，使用 doctest 进行单元测试可能更容易且更快速，因为它几乎只需要从交互式会话中复制粘贴。如果你需要维护一个缺乏单元测试的模块，通过
    doctest 将这些测试添加到模块中是一个合理的短期折衷方案，作为第一步。与其完全没有单元测试，不如只使用基于 doctest 的单元测试，否则你可能会决定从一开始就用
    unittest 正确地设置测试需要花费太长时间。^([4](ch17.xhtml#ch01fn128))
- en: If you do decide to use doctest for unit testing, don’t cram extra tests into
    your module’s docstrings. This would damage the docstrings by making them too
    long and hard to read. Keep in the docstrings the right amount and kind of examples,
    strictly for explanatory purposes, just as if unit testing were not in the picture.
    Instead, put the extra tests into a global variable of your module, a dictionary
    named __test__. The keys in __test__ are strings to use as arbitrary test names;
    corresponding values are strings that doctest picks up and uses just like it uses
    docstrings. The values in __test__ may also be function and class objects, in
    which case doctest examines their docstrings for tests to run. This latter feature
    is a convenient way to run doctest on objects with private names, which doctest
    skips by default.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定使用doctest进行单元测试，请不要将额外的测试内容塞入模块的文档字符串中。这样会破坏文档字符串，使其过长且难以阅读。保留文档字符串中正确数量和类型的示例，严格用于解释目的，就像单元测试不在考虑范围内一样。而是将额外的测试内容放入模块的全局变量中，一个名为__test__的字典。__test__中的键是用作任意测试名称的字符串；相应的值是doctest获取并像使用文档字符串一样使用的字符串。__test__中的值也可以是函数和类对象，在这种情况下，doctest会检查它们的文档字符串以运行测试。这种后一种功能是运行doctest的便捷方式，可用于具有私有名称的对象，这些对象默认情况下doctest会跳过。
- en: The doctest module also supplies two functions that return instances of the
    unittest.TestSuite class based on doctests, so that you can integrate such tests
    into testing frameworks based on unittest. Full documentation for this advanced
    functionality is available [online](https://oreil.ly/cbdu8).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: doctest模块还提供了两个函数，这些函数基于doctest返回unittest.TestSuite类的实例，因此您可以将这些测试集成到基于unittest的测试框架中。有关此高级功能的完整文档可在线查看[online](https://oreil.ly/cbdu8)。
- en: The unittest Module
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: unittest模块
- en: The unittest module is the Python version of a unit testing framework originally
    developed by Kent Beck for Smalltalk. Similar, widespread versions of the framework
    also exist for many other programming languages (e.g., the JUnit package for Java)
    and are often collectively referred to as xUnit.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: unittest模块是由Kent Beck为Smalltalk最初开发的单元测试框架的Python版本。类似的，广泛使用的框架版本也存在于许多其他编程语言中（例如，Java的JUnit包），通常被统称为xUnit。
- en: 'To use unittest, don’t put your testing code in the same source file as the
    tested module: rather, write a separate test module for each module to test. A
    popular convention is to name the test module like the module being tested, with
    a prefix such as ''test_'', and put it in a subdirectory of the source’s directory
    named *test*. For example, the test module for *mod.py* can be *test/test_mod.py*.
    A simple, consistent naming convention helps you write and maintain auxiliary
    scripts that find and run all unit tests for a package.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用unittest，请不要将测试代码放在与被测试模块相同的源文件中：而是为每个要测试的模块编写一个单独的测试模块。一个流行的约定是将测试模块命名为要测试的模块的名称，以'test_'为前缀，并将其放在名为*test*的源目录的子目录中。例如，*mod.py*的测试模块可以是*test/test_mod.py*。一个简单而一致的命名约定有助于编写和维护辅助脚本，以查找并运行包的所有单元测试。
- en: Separation between a module’s source code and its unit testing code lets you
    refactor the module more easily, including possibly recoding some functionality
    in C without perturbing the unit testing code. Knowing that *test_mod.py* stays
    intact, whatever changes you make to *mod.py*, enhances your confidence that passing
    the tests in *test_mod.py* indicates that *mod.py* still works correctly after
    the changes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块的源代码与其单元测试代码之间进行分离可以更轻松地重构模块，甚至可能在不干扰单元测试代码的情况下在C中重新编码一些功能。知道*test_mod.py*保持不变，无论您对*mod.py*做了哪些更改，都可以增强您对在更改后*test_mod.py*中通过测试指示*mod.py*仍然正确工作的信心。
- en: 'A unit testing module defines one or more subclasses of unittest’s TestCase class.
    Each such subclass specifies one or more test cases by defining *test case methods*:
    methods that are callable without arguments and whose names start with test.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试模块定义了unittest的TestCase类的一个或多个子类。每个这样的子类通过定义*测试用例方法*来指定一个或多个测试用例：这些方法可以无参数调用，并且其名称以test开头。
- en: The subclass usually overrides setUp, which the framework calls to prepare a
    new instance just before each test case, and often also tearDown, which the framework
    calls to clean things up right after each test case; the entire setup/teardown
    arrangement is known as a *test fixture*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，子类会重写setUp方法，这是框架在每个测试用例之前调用以准备新实例的方法，并且通常也会重写tearDown方法，这是框架在每个测试用例之后调用以清理事物的方法；整个设置/清理安排被称为*测试夹具*。
- en: Each test case calls, on self, methods of the class TestCase whose names start
    with assert to express the conditions that the test must meet. unittest runs the
    test case methods within a TestCase subclass in arbitrary order, each on a new
    instance of the subclass, running setUp just before each test case and tearDown
    just after each test case.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试用例都在`TestCase`类的实例上调用以`assert`开头的方法，以表达测试必须满足的条件。unittest在`TestCase`子类内以任意顺序运行测试用例方法，每个测试用例在子类的新实例上运行，在每个测试用例之前运行`setUp`，在每个测试用例之后运行`tearDown`。
- en: Have setUp Use addCleanup When Needed
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`setUp`时需要使用`addCleanup`
- en: When setUp propagates an exception, tearDown does not execute. So, when setUp
    prepares several things needing eventual cleanup, and some preparation steps might
    cause uncaught exceptions, it should not rely on tearDown for the cleanup work.
    Instead, right after each preparation step succeeds, call self.addCleanup(*f*,
    **a*, ***k*), passing a cleanup callable *f* (and optionally positional and named
    arguments for *f*). In this case, *f*(**a*, ***k*) does get called after the test
    case (after tearDown when setUp propagates no exception, but, unconditionally,
    even when setUp does propagate exceptions), so the necessary cleanup code always
    executes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当`setUp`传播异常时，`tearDown`不会执行。因此，当`setUp`准备了几个需要最终清理的事情，并且一些准备步骤可能导致未捕获的异常时，不应依赖`tearDown`进行清理工作。相反，在每个准备步骤成功之后立即调用`self.addCleanup(*f*,
    **a*, ***k*)`，传递一个清理可调用的`*f*`（以及可选的`*f*`的位置参数和命名参数）。在这种情况下，`*f*(**a*, ***k*)`会在测试用例之后被调用（当`setUp`不传播异常时在`tearDown`之后，但无条件地，即使`setUp`传播异常时也会调用），因此必要的清理代码始终会执行。
- en: unittest provides other facilities, such as grouping test cases into test suites,
    per-class and per-module fixtures, test discovery, and other, even more advanced
    functionality. You do not need such extras unless you’re building a custom unit
    testing framework on top of unittest, or, at the very least, structuring complex
    testing procedures for equally complex packages. In most cases, the concepts and
    details covered in this section are enough to perform effective and systematic
    unit testing. [Example 17-2](#example_onesix_twodot_using_unittest) shows how
    to use unittest to provide unit tests for the module *mod.py* of [Example 17-1](#example_onesix_onedot_using_doctest).
    This example, for purely demonstrative purposes, uses unittest to perform exactly
    the same tests that [Example 17-1](#example_onesix_onedot_using_doctest) uses
    as examples in docstrings using doctest.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: unittest提供其他功能，例如将测试用例分组到测试套件中，每个类和每个模块的固件，测试发现以及其他更高级的功能。除非您正在构建一个基于unittest的自定义单元测试框架，或者至少正在为同样复杂的软件包构建复杂的测试程序，否则您不需要这些额外功能。在大多数情况下，本节介绍的概念和细节足以执行有效和系统化的单元测试。[示例 17-2](#example_onesix_twodot_using_unittest)演示了如何使用unittest为[示例 17-1](#example_onesix_onedot_using_doctest)的模块*mod.py*提供单元测试。这个例子纯粹是为了演示目的，使用unittest执行与[示例 17-1](#example_onesix_onedot_using_doctest)中在文档字符串中使用doctest作为示例的完全相同的测试。
- en: Example 17-2\. Using unittest
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-2. 使用unittest
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Running this script with **python** **test/test_mod.py** (or, equivalently,
    **python** **-m test.test_mod**) is just a bit more verbose than using **python
    mod.py** to run doctest, as in [Example 17-1](#example_onesix_onedot_using_doctest).
    *test_mod.py* outputs a . (dot) for each test case it runs, then a separator line
    of dashes, and finally a summary line, such as “Ran 7 tests in 0.110s,” and a
    final line of “OK” if every test passed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**python** **test/test_mod.py**（或者等价地，**python** **-m test.test_mod**）运行此脚本比使用**python
    mod.py**运行doctest稍微复杂一点。*test_mod.py*对于它运行的每个测试用例输出一个`.`（点），然后是一行破折号分隔线，最后是一个摘要行，例如“在0.110s内运行了7个测试”，如果每个测试都通过，则最后一行是“OK”。
- en: Each test case method makes one or more calls to methods whose names start with
    assert. Here, no method has more than one such call; in more complicated cases,
    however, multiple calls to assert methods from a single test case method are common.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试用例方法都调用一个或多个以`assert`开头的方法。在这里，没有方法调用超过一个这样的调用；然而，在更复杂的情况下，从单个测试用例方法调用多个`assert`方法是常见的。
- en: Even in a case as simple as this, one minor aspect shows that, for unit testing,
    unittest is more powerful and flexible than doctest. In the method testArgumentMustBeString,
    we pass as the argument to assertRaises a pair of exception classes, meaning we
    accept either kind of exception. *test_mod.py* therefore accepts these as valid
    multiple implementations of *mod.py*. It accepts the implementation in [Example 17-1](#example_onesix_onedot_using_doctest),
    which tries calling the method split on its argument, and therefore raises AttributeError
    when called with an argument that is not a string. However, it also accepts a
    different hypothetical implementation, one that raises TypeError instead when
    called with an argument of the wrong type. It is possible to code such checks
    with doctest, but it would be awkward and nonobvious, while unittest makes it
    simple and natural.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这种简单的情况下，一个小方面也表明，对于单元测试，unittest 比 doctest 更强大、更灵活。 在 testArgumentMustBeString
    方法中，我们将一对异常类作为 assertRaises 的参数传递，这意味着我们接受任何一种异常。 *test_mod.py* 因此将这些视为 *mod.py*
    的有效多个实现。 它接受 [示例 17-1](#example_onesix_onedot_using_doctest) 中的实现，该示例尝试在其参数上调用
    split 方法，因此在用非字符串参数调用时引发 AttributeError。 但是，它也接受了一个不同的假设实现，当使用错误类型的参数调用时引发 TypeError。
    使用 doctest 可以编写此类检查，但这将是笨拙和不明显的，而 unittest 则使其变得简单和自然。
- en: 'This kind of flexibility is crucial for real-life unit tests, which to some
    extent are executable specifications for their modules. You could, pessimistically,
    view the need for test flexibility as meaning the interface of the code you’re
    testing is not well-defined. However, it’s best to view the interface as being
    defined with a useful amount of flexibility for the implementer: under circumstance
    *X* (argument of invalid type passed to function reverse_words, in this example),
    either of two things (raising AttributeError or TypeError) is allowed to happen.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性对于现实生活中的单元测试至关重要，某种程度上它们是其模块的可执行规范。 你可以悲观地认为，对于测试的灵活性的需要意味着你正在测试的代码的接口没有定义好。
    但是，最好将接口视为具有对于实现者来说有用的灵活性：在情况 *X*（在这个例子中传递给函数 reverse_words 的无效类型的参数）下，两种情况（引发
    AttributeError 或 TypeError）都是允许的。
- en: 'Thus, implementations with either of the two behaviors are correct: the implementer
    can choose between them on the basis of such considerations as performance and
    clarity. Viewed in this way—as executable specifications for their modules (the
    modern view, and the basis of test-driven development), rather than as white-box
    tests strictly constrained to a specific implementation (as in some traditional
    taxonomies of testing)—unit tests become an even more vital component of the software
    development process.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，具有这两种行为之一的实现都是正确的：实现者可以根据诸如性能和清晰度等考虑因素之间进行选择。 从这种方式来看——作为其模块的可执行规范（现代观点，以及测试驱动开发的基础），而不是作为严格限定在特定实现上的白盒测试（如某些传统测试分类中）——单元测试成为软件开发过程中更加重要的组成部分。
- en: The TestCase class
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TestCase 类
- en: With unittest, you write test cases by extending TestCase, adding methods, callable
    without arguments, whose names start with test. These test case methods, in turn,
    call methods that your class inherits from TestCase, whose names start with assert,
    to indicate conditions that must hold for the tests to succeed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 unittest，您可以通过扩展 TestCase 编写测试用例，添加不带参数的方法，其名称以 test 开头。 这些测试用例方法反过来调用从 TestCase
    继承的方法，其名称以 assert 开头，以指示必须满足的条件，以使测试成功。
- en: The TestCase class also defines two methods that your class can optionally override
    to group actions to perform right before and after each test case method runs.
    This doesn’t exhaust TestCase’s functionality, but you won’t need the rest unless
    you’re developing testing frameworks or performing other advanced tasks. [Table 17-1](#methods_of_an_instance_t_of_testcase)
    lists the frequently called methods of a TestCase instance *t*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: TestCase 类还定义了两个方法，您的类可以选择性地覆盖以分组执行每个测试用例方法之前和之后的操作。 这并没有耗尽 TestCase 的功能，但除非您正在开发测试框架或执行其他高级任务，否则您不需要其余部分。
    [表 17-1](#methods_of_an_instance_t_of_testcase) 列出了 TestCase 实例 *t* 的经常调用方法。
- en: Table 17-1\. Methods of an instance t of TestCase
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 表 17-1\. TestCase 实例 t 的方法
- en: '| a⁠s⁠s⁠e⁠r⁠t⁠A⁠l⁠m⁠o⁠s⁠t​E⁠q⁠u⁠a⁠l | assertAlmostEqual(*first*, *second*,
    places=7, msg=**None**) Fails and outputs msg when *first* != *second* to within
    places decimal digits; otherwise, does nothing. This method is better than assertEqual
    to compare floats, since they are approximations that may differ in less significant
    decimal digits. When producing diagnostic messages if the test fails, unittest
    will assume that *first* is the expected value and *second* is the observed value.
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| a⁠s⁠s⁠e⁠r⁠t⁠A⁠l⁠m⁠o⁠s⁠t​E⁠q⁠u⁠a⁠l | assertAlmostEqual(*first*, *second*,
    places=7, msg=**None**) 当*first* != *second*到小数点places位时失败并输出msg；否则，什么也不做。此方法比assertEqual更适合比较浮点数，因为它们是可能在不重要的小数位数上有所不同的近似值。在测试失败时生成诊断消息时，unittest会假定*first*是期望的值，*second*是观察到的值。
    |'
- en: '| assertEqual | assertEqual(*first*, *second*, msg=**None**) Fails and outputs
    msg when *first* != *second*; otherwise, does nothing. When producing diagnostic
    messages if the test fails, unittest will assume that *first* is the expected
    value and *second* is the observed value. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| assertEqual | assertEqual(*first*, *second*, msg=**None**) 当*first* != *second*时失败并输出msg；否则，什么也不做。在测试失败时生成诊断消息时，unittest会假定*first*是期望的值，*second*是观察到的值。
    |'
- en: '| assertFalse | assertFalse(*condition*, msg=None) Fails and outputs msg when
    *condition* is true; otherwise, does nothing. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| assertFalse | assertFalse(*condition*, msg=None) 当*condition*为真时失败并输出msg；否则，什么也不做。
    |'
- en: '| assertNotAlm⁠o⁠s⁠t​E⁠q⁠u⁠al | assertNotAlmostEqual(*first*, *second*, places=7,
    msg=**None**) Fails and outputs msg when *first* == *second* to within places
    decimal digits; otherwise, does nothing. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| assertNotAlm⁠o⁠s⁠t​E⁠q⁠u⁠al | assertNotAlmostEqual(*first*, *second*, places=7,
    msg=**None**) 当*first* == *second*到小数点places位时失败并输出msg；否则，什么也不做。 |'
- en: '| assertNotEqual | assertNotEqual(*first*, *second*, msg=**None**) Fails and
    outputs msg when *first* == *second*; otherwise, does nothing. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| assertNotEqual | assertNotEqual(*first*, *second*, msg=**None**) 当*first*
    == *second*时失败并输出msg；否则，什么也不做。 |'
- en: '| assertRaises | assertRaises(*exceptionSpec*, *callable*, **args*, ***kwargs*)
    Calls *callable*(**args*, ***kwargs*). Fails when the call doesn’t raise any exception.
    When the call raises an exception that does not meet *exceptionSpec*, assertRaises
    propagates the exception. When the call raises an exception that meets *exceptionSpec*,
    assertRaises does nothing. *exceptionSpec* can be an exception class or a tuple
    of classes, just like the first argument of the **except** clause in a **try**/**except**
    statement.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '| assertRaises | assertRaises(*exceptionSpec*, *callable*, **args*, ***kwargs*)
    调用*callable*(**args*, ***kwargs*)。调用未引发任何异常时失败。当调用引发不符合*exceptionSpec*的异常时，assertRaises传播异常。当调用引发符合*exceptionSpec*的异常时，assertRaises什么也不做。*exceptionSpec*可以是异常类或类元组，就像**try**/**except**语句中**except**子句的第一个参数一样。'
- en: 'The preferred way to use assertRaises is as a context manager—that is, in a
    **with** statement:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用assertRaises的首选方式是作为上下文管理器——也就是说，在`with`语句中：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, the block of code indented in the **with** statement executes, rather
    than just the *callable* being called with certain arguments. The expectation
    (which avoids the construct failing) is that the block of code raises an exception
    meeting the given exception specification (an exception class or a tuple of classes).
    This alternative approach is more general and readable than passing a callable.
    |
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，缩进在`with`语句中的代码块执行，而不仅仅是调用*callable*带有特定参数。期望（避免构造失败）是代码块引发符合给定异常规范（异常类或类元组）的异常。这种替代方法比传递可调用对象更通用和可读。
    |
- en: '| a⁠s⁠s⁠e⁠r⁠t⁠R⁠a⁠i⁠s⁠e⁠s​R⁠e⁠g⁠e⁠x | assertRaisesRegex(*exceptionSpec*, *expected_regex*,
    *callable*, **args*, ***kwargs*) Just like assertRaises, but also checks that
    the exception’s error message matches *regex*; *regex* can be a regular expression
    object or a string pattern to compile into one, and the test (when the expected
    exception has been raised) checks the error message by calling search on the RE
    object.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '| a⁠s⁠s⁠e⁠r⁠t⁠R⁠a⁠i⁠s⁠e⁠s​R⁠e⁠g⁠e⁠x | assertRaisesRegex(*exceptionSpec*, *expected_regex*,
    *callable*, **args*, ***kwargs*) 就像`assertRaises`，但还检查异常的错误消息是否与*regex*匹配；*regex*可以是正则表达式对象或要编译成一个的字符串模式，测试（当引发预期异常时）通过调用RE对象上的search检查错误消息。'
- en: 'Just like assertRaises, assertRaisesRegex is best used as a context manager—that
    is, in a **with** statement:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`assertRaises`一样，`assertRaisesRegex`最好作为上下文管理器使用——也就是说，在`with`语句中：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| enterContext | enterContext(ctx_manager) 3.11+ Use this call in a TestCase.setup()
    method. Returns the value from calling ctx_manager.__enter__, and adds ctx_manager.__exit__
    to the list of cleanup methods that the framework is to run during the TestCase’s
    cleanup phase. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| enterContext | enterContext(ctx_manager) 3.11+ 在 TestCase.setup() 方法中使用此调用。返回调用
    ctx_manager.__enter__ 的值，并将 ctx_manager.__exit__ 添加到清理方法列表中，框架在 TestCase 清理阶段运行这些方法。
    |'
- en: '| fail | fail(msg=**None**) Fails unconditionally and outputs msg. An example
    snippet might be:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '| fail | fail(msg=**None**) 无条件失败并输出 msg。例如代码段可能是：'
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '|'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| setUp | setUp() The framework calls *t*.setUp() just before calling each
    test case method. setUp in TestCase does nothing; it exists only to let your class
    override the method when your class needs to perform some preparation for each
    test. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| setUp | setUp() 框架在调用每个测试用例方法之前调用 *t*.setUp()。在 TestCase 中的 setUp 不执行任何操作；它存在只是为了让你的类在需要为每个测试准备一些东西时重写这个方法。
    |'
- en: '| subTest | subTest(msg*=***None**, ***k*) Returns a context manager that can
    define a portion of a test within a test method. Use subTest when a test method
    runs the same test multiple times with varying parameters. Enclosing these parameterized
    tests in subTest ensures that all the cases will be run, even if some of them
    fail or raise exceptions. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| subTest | subTest(msg*=***None**, ***k*) 返回一个上下文管理器，可以在测试方法内定义测试的部分。当一个测试方法使用不同的参数多次运行相同的测试时，使用
    subTest 可以确保所有情况都会运行，即使其中一些失败或引发异常。 |'
- en: '| tearDown | tearDown() The framework calls *t*.tearDown() just after each
    test case method. tearDown in the base TestCase class does nothing; it exists
    only to let your class override the method when your class needs to perform some
    cleanup after each test. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| tearDown | tearDown() 框架在每个测试用例方法后调用 *t*.tearDown()。TestCase 类中的 tearDown
    不执行任何操作；它存在只是为了让你的类在需要在每个测试后执行一些清理操作时重写这个方法。 |'
- en: In addition, a TestCase instance maintains a LIFO stack of *cleanup functions*.
    When code in one of your tests (or in setUp) does something that requires cleanup,
    call self.addCleanup, passing a cleanup callable *f* and optionally positional
    and named arguments for *f*. To perform the stacked cleanups, you may call doCleanups;
    however, the framework itself calls doCleanups after tearDown. [Table 17-2](#cleanup_methods_of_an_instance_t_of_tes)
    lists the signatures of the two cleanup methods of a TestCase instance *t*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一个 TestCase 实例维护一个 *清理函数* 的后进先出（LIFO）栈。当你的一个测试中的代码（或者在 setUp 中）执行需要清理的操作时，请调用
    self.addCleanup，传递一个清理可调用函数 *f*，以及可选的位置参数和命名参数 *f*。要执行堆叠的清理操作，你可以调用 doCleanups；然而，框架本身会在
    tearDown 后调用 doCleanups。[表 17-2](#cleanup_methods_of_an_instance_t_of_tes) 列出了一个
    TestCase 实例 *t* 的两个清理方法的签名。
- en: Table 17-2\. Cleanup methods of an instance t of TestCase
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 表 17-2\. TestCase 实例 t 的清理方法
- en: '| addCleanup | addCleanup(*func*, **a*, ***k*) Appends (*func*, *a*, *k*) at
    the end of the cleanups list. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| addCleanup | addCleanup(*func*, **a*, ***k*) 将 (*func*, *a*, *k*) 添加到清理列表的末尾。
    |'
- en: '| doCleanups | doCleanups() Performs all cleanups, if any are stacked. Substantially
    equivalent to:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '| doCleanups | doCleanups() 执行所有已堆叠的清理操作。实质上等同于：'
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: for a hypothetical stack self.list_of_cleanups, plus, of course, error checking
    and reporting. |
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于假设的栈 self.list_of_cleanups，当然还包括错误检查和报告。 |
- en: Unit tests dealing with large amounts of data
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试处理大量数据
- en: 'Unit tests must be fast, as you should run them often as you develop. So, when
    feasible, unit test each aspect of your modules on small amounts of data. This
    makes your unit tests faster, and lets you embed the data in the test’s source
    code. When you test a function that reads from or writes to a file object, use
    an instance of the class io.TextIO for a text file (or io.BytesIO for a binary
    file, as covered in [“In-Memory Files: io.StringIO and io.BytesIO”](ch11.xhtml#in_memory_files_iodotstringio_and_iodot))
    to get a file with the data in memory: this approach is faster than writing to
    disk, and it requires no cleanup (removing disk files after the tests).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试必须快速，因为开发过程中应经常运行它们。因此，在可能的情况下，对模块的每个方面进行小数据量的单元测试。这样可以使单元测试更快，并允许您将数据嵌入到测试的源代码中。当您测试从文件对象读取或写入的函数时，对于文本文件使用
    io.TextIO 类的实例（或对于二进制文件使用 io.BytesIO 类的实例，如 [“内存中的文件：io.StringIO 和 io.BytesIO”](ch11.xhtml#in_memory_files_iodotstringio_and_iodot)
    中所述），以获得包含数据的内存中文件：这种方法比写入磁盘快，并且不需要清理（在测试后删除磁盘文件）。
- en: In rare cases, it may be impossible to exercise a module’s functionality without
    supplying and/or comparing data in quantities larger than can be reasonably embedded
    in a test’s source code. In such cases, your unit test must rely on auxiliary,
    external data files to hold the data to supply to the module it tests, and/or
    the data it needs to compare to the output. Even then, you’re generally better
    off using instances of the abovementioned io classes, rather than directing the
    tested module to perform actual disk I/O. Even more importantly, we strongly suggest
    that you generally use stubs to unit test modules that interact with external
    entities, such as databases, GUIs, or other programs over a network. It’s easier
    to control all aspects of the test when using stubs rather than real external
    entities. Also, to reiterate, the speed at which you can run unit tests is important,
    and it’s faster to perform simulated operations with stubs than real operations.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在罕见的情况下，可能无法在不提供和/或比较大量数据的情况下执行模块的功能。在这种情况下，您的单元测试必须依赖于辅助的外部数据文件来保存供模块测试所需的数据以及需要比较的输出数据。即便如此，我们通常建议使用上述
    io 类的实例，而不是直接让被测试的模块执行真实的磁盘 I/O。更重要的是，我们强烈建议通常使用存根来单元测试与外部实体交互的模块，例如数据库、GUI 或通过网络与其他程序交互的模块。使用存根而不是真实的外部实体进行测试可以更容易地控制测试的各个方面。另外，再次强调，测试单元的运行速度非常重要，使用存根执行模拟操作比使用真实操作更快。
- en: Make Test Randomness Reproducible by Supplying a Seed
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过提供种子使测试的随机性可重现
- en: 'If your code uses pseudorandom numbers (e.g., as covered in [“The random Module”](ch16.xhtml#the_random_module)),
    you can make it easier to test by ensuring its “random” behavior is *reproducible*:
    specifically, ensure that it’s easy for your tests to call random.seed with a
    known argument, so that the ensuing pseudorandom numbers are fully predictable.
    This also applies when you use pseudorandom numbers to set up your tests by generating
    inputs: such generation should default to a known seed, to be used in most testing,
    keeping the flexibility of changing seeds only for specific techniques such as
    [fuzzing](https://oreil.ly/C17DL).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的代码使用伪随机数（例如在 [“random 模块”](ch16.xhtml#the_random_module) 中介绍的内容），您可以通过确保其“随机”行为是可重现的，使其更容易测试：具体来说，确保您的测试可以轻松调用
    random.seed 并使用已知的参数，以便生成的伪随机数是完全可预测的。当您使用伪随机数来设置测试的输入时，这一点同样适用：默认应使用已知的种子来生成大多数测试，仅在特定技术（如
    [fuzzing](https://oreil.ly/C17DL)）中才更改种子。
- en: Testing with nose2
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 nose2 进行测试
- en: nose2 is a pip-installable third-party test utility and framework that builds
    on top of unittest to provide additional plug-ins, classes, and decorators to
    aid in writing and running your test suite. nose2 will “sniff out” test cases
    in your project, building its test suite by looking for unittest test cases stored
    in files named *test*.py*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: nose2 是一个可通过 pip 安装的第三方测试实用工具和框架，它构建在 unittest 之上，提供额外的插件、类和装饰器，以帮助编写和运行测试套件。nose2
    会在项目中“嗅探”出测试用例，通过查找以 *test*.py* 命名的文件中存储的 unittest 测试用例来构建其测试套件。
- en: 'Here is an example of using nose2’s params decorator to pass data parameters
    to a test function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，展示了如何使用 nose2 的 params 装饰器将数据参数传递给测试函数：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: nose2 also includes additional decorators, the such context manager to define
    groups of test functions, and a plug-in framework to provide testing metafunctions
    such as logging, debugging, and coverage reporting. For more information, see
    the [online docs](https://oreil.ly/oFTIV).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: nose2 还包括额外的装饰器，如上下文管理器来定义测试函数组，并且一个插件框架来提供测试元函数，例如日志记录、调试和覆盖报告。更多信息请参阅 [在线文档](https://oreil.ly/oFTIV)。
- en: Testing with pytest
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 pytest 进行测试
- en: The pytest module is a pip-installable third-party unit testing framework that
    introspects a project’s modules to find test cases in *test_*.py* or **_test.py*
    files, with method names starting with test at the module level, or in classes
    with names starting with Test. Unlike the built-in unittest framework, pytest
    does not require that test cases extend any testing class hierarchy; it runs the
    discovered test methods, which use Python **assert** statements to determine the
    success or failure of each test.^([5](ch17.xhtml#ch01fn129)) If a test raises
    any exception other than AssertionError, that indicates that there is an error
    in the test, rather than a simple test failure.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: pytest 模块是一个可通过 pip 安装的第三方单元测试框架，它会检查项目的模块以查找 *test_*.py* 或 **_test.py* 文件中以
    test 开头的方法名称的测试用例。与内置的 unittest 框架不同，pytest 不要求测试用例扩展任何测试类层次结构；它运行发现的测试方法，这些方法使用
    Python 的 **assert** 语句来确定每个测试的成功或失败。^([5](ch17.xhtml#ch01fn129)) 如果测试引发除 AssertionError
    外的任何异常，则表示测试中存在错误，而不仅仅是简单的测试失败。
- en: In place of a hierarchy of test case classes, pytest provides a number of helper
    methods and decorators to simplify writing unit tests. The most common methods
    are listed in [Table 17-3](#commonly_used_pytest_methods); consult the [online
    docs](https://oreil.ly/a0WBi) for a more complete list of methods and optional
    arguments.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: pytest 提供了一些辅助方法和装饰器来简化编写单元测试，而不是使用测试用例类的层次结构。最常用的方法列在 [表 17-3](#commonly_used_pytest_methods)
    中；请参阅 [在线文档](https://oreil.ly/a0WBi) 获取更完整的方法列表和可选参数。
- en: Table 17-3\. Commonly used pytest methods
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 表 17-3\. 常用 pytest 方法
- en: '| approx | approx(*float_value*) Used to support asserts that must compare
    floating-point values. *float_value* can be a single value or a sequence of values:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '| approx | approx(*float_value*) 用于支持对浮点数值进行比较的断言。*float_value* 可以是单个值或值序列：'
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| fail | fail(*failure_reason*) Forces failure of the current test. More explicit
    than injecting an **assert False** statement, but otherwise equivalent. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| fail | fail(*failure_reason*) 强制当前测试失败。比注入 **assert False** 语句更明确，但在其他方面等效。
    |'
- en: '| raises | raises(*expected_exception*, match=regex_match) A context manager
    that fails unless its context raises an exception *exc* such that isinstance(*exc*,
    *expected_exception*) is true. When match is given, the test fails unless *exc*’s
    str representation also matches re.search(match, str(*exc*)). |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| raises | raises(*expected_exception*, match=regex_match) 上下文管理器，除非其上下文引发了一个
    *exc*，使得 isinstance(*exc*, *expected_exception*) 为真。当给定 match 时，除非 *exc* 的字符串表示也与
    re.search(match, str(*exc*)) 匹配，否则测试失败。 |'
- en: '| skip | skip(*skip_reason*) Forces skipping of the current test; use this,
    for example, when a test is dependent on a previous test that has already failed.
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| skip | skip(*skip_reason*) 强制跳过当前测试；例如，在先前的测试已经失败时使用。 |'
- en: '| warns | warns(*expected_warning*, match*=regex_match*) Similar to *raises*;
    used to wrap code that tests that an expected warning is raised. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| warns | warns(*expected_warning*, match*=regex_match*) 类似于 *raises*，用于包装测试预期警告是否被触发的代码。
    |'
- en: The pytest.mark subpackage includes decorators to “mark” test methods with additional
    test behavior, including the ones listed in [Table 17-4](#decorators_in_the_pytestdotmark_subpack).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: pytest.mark 子包含有装饰器，可以用来“标记”测试方法，赋予其额外的测试行为，包括在 [表 17-4](#decorators_in_the_pytestdotmark_subpack)
    中列出的方法。
- en: Table 17-4\. Decorators in the pytest.mark subpackage
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 表 17-4\. pytest.mark 子包中的装饰器
- en: '| parametrize | @parametrize(*args_string*, *arg_test_values*) Calls the decorated
    test method, setting the arguments named in the comma-separated list *args_string*
    to the values from each argument tuple in *arg_test_values*.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '| parametrize | @parametrize(*args_string*, *arg_test_values*) 调用装饰的测试方法，将逗号分隔列表
    *args_string* 中命名的参数设置为 *arg_test_values* 中每个参数元组的值。'
- en: The following code runs test_is_greater twice, once with x=1, y=0, and expected=**True**;
    and once with x=0, y=1, and expected=**False**.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码运行 test_is_greater 两次，一次为 x=1, y=0，expected=**True**；另一次为 x=0, y=1，expected=**False**。
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| skip, skipif | @skip(*skip_reason*), @skipif(*condition*, *skip_reason*)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '| skip, skipif | @skip(*skip_reason*), @skipif(*condition*, *skip_reason*)'
- en: Skip a test method, optionally based on some global condition. |
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地根据一些全局条件跳过测试方法。 |
- en: Debugging
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试
- en: Since Python’s development cycle is fast, the most effective way to debug is
    often to edit your code to output relevant information at key points. Python has
    many ways to let your code explore its own state to extract information that may
    be relevant for debugging. The inspect and traceback modules specifically support
    such exploration, which is also known as *reflection* or *introspection*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Python 的开发周期很快，通常调试的最有效方式是编辑代码，在关键点输出相关信息。Python 提供了许多方法，让您的代码探索自身状态，提取可能与调试相关的信息。具体支持此类探索的是
    inspect 和 traceback 模块，这也被称为*反射*或*内省*。
- en: Once you have debugging-relevant information, print is often the natural way
    to display it (pprint, covered in [“The pprint Module”](ch09.xhtml#the_pprint_module),
    is also often a good choice). However, it’s frequently even better to *log* debugging
    information to files. Logging is useful for programs that run unattended (e.g.,
    server programs). Displaying debugging information is just like displaying other
    information, as covered in [Chapter 11](ch11.xhtml#file_and_text_operations).
    Logging such information is like writing to files (covered in the same chapter);
    however, Python’s standard library supplies a logging module, covered in [“The
    logging module”](ch06.xhtml#the_logging_module), to help with this frequent task.
    As covered in [Table 8-3](ch08.xhtml#functions_and_attributes_of_the_sys_mod),
    rebinding excepthook in the module sys lets your program log error info just before
    terminating with a propagating exception.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有与调试相关的信息，打印通常是显示它的自然方式（pprint，详见[“pprint模块”](ch09.xhtml#the_pprint_module)，通常也是一个很好的选择）。然而，将调试信息记录到文件中通常更好。对于无人看管运行的程序（例如服务器程序），记录日志非常有用。显示调试信息就像显示其他信息一样，如[第
    11 章](ch11.xhtml#file_and_text_operations)所述。记录此类信息就像写入文件一样（在同一章节中讨论）；但是，Python
    的标准库提供了一个记录模块，详见[“logging模块”](ch06.xhtml#the_logging_module)，以帮助处理此频繁任务。如[表 8-3](ch08.xhtml#functions_and_attributes_of_the_sys_mod)中所述，通过在
    sys 模块中重新绑定 excepthook，您的程序可以在以传播异常终止之前记录错误信息。
- en: Python also offers hooks to enable interactive debugging. The pdb module supplies
    a simple text-mode interactive debugger. Other powerful interactive debuggers
    for Python are part of IDEs such as IDLE and various commercial offerings, as
    mentioned in [“Python Development Environments”](ch02.xhtml#python_development_environments);
    we do not cover these advanced debuggers further in this book.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Python 还提供了启用交互式调试的钩子。pdb 模块提供了一个简单的文本模式交互式调试器。其他强大的 Python 交互式调试器包含在诸如 IDLE
    和各种商业软件提供的 IDE 中，如[“Python开发环境”](ch02.xhtml#python_development_environments)所述；本书不进一步介绍这些高级调试器。
- en: Before You Debug
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在您开始调试之前
- en: 'Before you embark on lengthy debugging explorations, make sure you have thoroughly
    checked your Python sources with the tools mentioned in [Chapter 2](ch02.xhtml#the_python_interpreter).
    Such tools catch only a subset of the bugs in your code, but they’re much faster
    than interactive debugging: their use amply pays for itself.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始漫长的调试探索之前，请确保使用[第 2 章](ch02.xhtml#the_python_interpreter)中提到的工具彻底检查了您的 Python
    源代码。这些工具仅捕获代码中的一部分 bug，但比交互式调试快得多：它们的使用绝对物有所值。
- en: Moreover, again before starting a debugging session, make sure that all the
    code involved is well covered by unit tests, as described in [“The unittest Module”](#the_unittest_module).
    As mentioned earlier in the chapter, once you have found a bug, *before* you fix
    it, add to your suite of unit tests (or, if need be, to the suite of system tests)
    a test or two that would have found the bug had they been present from the start,
    and run the tests again to confirm that they now reveal and isolate the bug; only
    once that is done should you proceed to fix the bug. Regularly following this
    procedure will help you learn to write better, more thorough tests, ensuring that
    you end up with a more robust test suite and have greater confidence in the overall,
    *enduring* correctness of your code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 再次在开始调试会话之前，请确保所有涉及的代码都有充分的单元测试覆盖，如[“unittest模块”](#the_unittest_module)中所述。正如本章前面提到的，一旦找到
    bug，*在*修复之前，请为您的单元测试套件（或者如果必要，系统测试套件）添加一两个测试，这些测试如果从一开始就存在，本应能发现该 bug，并再次运行测试以确认它们现在能够揭示和隔离该
    bug；只有在完成这些步骤之后，才能继续修复该 bug。定期遵循此过程将帮助您学会编写更好、更彻底的测试，确保最终拥有更健壮的测试套件，并对代码的*持久*正确性更有信心。
- en: 'Remember, even with all the facilities offered by Python, its standard library,
    and whatever IDE you fancy, debugging is still *hard*. Take this into account
    even before you start designing and coding: write and run plenty of unit tests,
    and keep your design and code *simple*, to reduce to the minimum the amount of
    debugging you will need! Brian Kernighan offers this classic advice: “Debugging
    is twice as hard as writing the code in the first place. Therefore, if you write
    the code as cleverly as you can, you are, by definition, not smart enough to debug
    it.” This is part of why “clever” is not a positive word when used to describe
    Python code, or a coder.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，即使Python及其标准库以及你喜欢的任何IDE提供了所有的设施，调试仍然*很难*。在你开始设计和编码之前，请考虑写并运行大量的单元测试，并保持你的设计和代码*简单*，以尽量减少你需要进行的调试工作！Brian
    Kernighan提供了这个经典建议：“调试比一开始编写代码难两倍。因此，如果你把代码写得越聪明，你就越不能够调试它。”这也是为什么“聪明”一词在描述Python代码或程序员时并不是一个正面词语的部分。
- en: The inspect Module
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: inspect模块
- en: The inspect module supplies functions to get information about all kinds of
    objects, including the Python call stack (which records all function calls currently
    executing) and source files. The most frequently used functions of inspect are
    listed in [Table 17-5](#useful_functions_of_the_inspect_module).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: inspect模块提供了获取各种对象信息的函数，包括Python调用堆栈（记录当前正在执行的所有函数调用）和源文件。inspect的最常用函数列在[表17-5](#useful_functions_of_the_inspect_module)中。
- en: Table 17-5\. Useful functions of the inspect module
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 表17-5\. inspect模块的有用函数
- en: '| currentframe | currentframe() Returns the frame object for the current function
    (the caller of currentframe). formatargvalues(*getargvalues(currentframe())),
    for example, returns a string representing the arguments of the calling function.
    |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| currentframe | currentframe() 返回当前函数的帧对象（调用currentframe的函数的调用者）。formatargvalues(*getargvalues(currentframe()))，例如，返回表示调用函数参数的字符串。'
- en: '| getargspec, formatargspec | getargspec(*f*) -3.11 Deprecated in Python 3.5,
    removed in Python 3.11\. The forward-compatible way to introspect callables is
    to call inspect.signature(*f*) and use the resulting instance of class inspect.Signature,
    covered in the following subsection. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| getargspec, formatargspec | getargspec(*f*) -3.11 在Python 3.5中弃用，在Python
    3.11中移除。检查可调用对象的前向兼容方法是调用inspect.signature(*f*)并使用inspect.Signature类的实例（在以下小节中介绍）。'
- en: '| get⁠a⁠r⁠g​v⁠a⁠l⁠ues, formatargvalues | getargvalues(*f*) *f* is a frame object—for
    example, the result of a call to the function _getframe in the sys module (covered
    in [“The Frame Type”](ch14.xhtml#the_frame_type)) or the function currentframe
    in the inspect module. getargvalues returns a named tuple with four items: (*args*,
    *varargs*, *keywords*, *locals*). *args* is the sequence of names of *f*’s function’s
    parameters. *varargs* is the name of the special parameter of form **a*, or **None**
    when *f*’s function has no such parameter. *keywords* is the name of the special
    parameter of form ***k*, or **None** when *f*’s function has no such parameter.
    *locals* is the dictionary of local variables for *f*. Since arguments, in particular,
    are local variables, the value of each argument can be obtained from *locals*
    by indexing the *locals* dictionary with the argument’s corresponding parameter
    name.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '| get⁠a⁠r⁠g​v⁠a⁠l⁠ues, formatargvalues | getargvalues(*f*) *f*是一个帧对象，例如，是sys模块中_getframe函数调用（在[“帧类型”](ch14.xhtml#the_frame_type)中涵盖）的结果，或者是inspect模块中currentframe函数的调用结果。getargvalues返回一个具有四个条目的命名元组：(*args*,
    *varargs*, *keywords*, *locals*)。*args*是*f*函数参数名称的序列。*varargs*是形如**a*的特殊参数的名称，或者当*f*函数没有这样的参数时为**None**。*keywords*是形如***k*的特殊参数的名称，或者当*f*函数没有这样的参数时为**None**。*locals*是*f*的本地变量字典。由于参数特别是本地变量，因此可以通过将参数名称与*locals*字典索引结合来获取每个参数的值。'
- en: 'formatargvalues accepts one to four arguments that are the same as the items
    of the named tuple that getargvalues returns, and returns a string with this information.
    formatargvalues(*getargvalues(*f*)) returns a string with *f*’s arguments in parentheses,
    in named form, as used in the call statement that created *f*. For example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: formatargvalues接受一个到四个参数，与getargvalues返回的命名元组的项目相同，并返回带有此信息的字符串。formatargvalues(*getargvalues(*f*))返回带有*f*参数的字符串，用括号括起来，并以调用语句中使用的命名形式表示。例如：
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| getdoc | getdoc(*obj*) Returns the docstring for *obj*, a multiline string
    with tabs expanded to spaces and redundant whitespace stripped from each line.
    |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| getdoc | getdoc(*obj*) 返回*obj*的文档字符串，一个多行字符串，其中制表符扩展为空格，并且每行的冗余空格被剥离。'
- en: '| getfile, getsourcefile | getfile(*obj*), getsourcefile(*obj*)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '| getfile, getsourcefile | getfile(*obj*)，getsourcefile(*obj*)'
- en: getfile returns the name of the binary or source file that defined *obj*. Raises
    TypeError when unable to determine the file (for example, when *obj* is a built-in).
    getsourcefile returns the name of the source file that defined obj; it raises
    TypeError when all it can find is a binary file, not the corresponding source
    file. |
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: getfile 返回定义 *obj* 的二进制或源文件的名称。在无法确定文件时（例如，*obj* 是内置对象），会引发 TypeError。getsourcefile
    返回定义 *obj* 的源文件的名称；当只能找到二进制文件而非相应的源文件时，会引发 TypeError。 |
- en: '| getmembers | getmembers(*obj*, filter=**None**) Returns all attributes (members),
    both data and methods (including special methods) of *obj*, as a sorted list of
    (*name*, *value*) pairs. When filter is not **None**, returns only attributes
    for which callable filter returns a truthy result when called on the attribute’s
    *value*, equivalent to:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '| getmembers | getmembers(*obj*, filter=**None**) 返回 *obj* 的所有属性（成员），包括数据和方法（包括特殊方法），以
    (*name*, *value*) 对的排序列表形式返回。当 filter 不为 **None** 时，仅返回过滤器在属性的 *value* 上调用时返回真值的属性，相当于：'
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| getmodule | getmodule(*obj*) Returns the module that defined *obj*, or **None**
    when unable to determine it. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| getmodule | getmodule(*obj*) 返回定义 *obj* 的模块，或者在无法确定时返回 **None**。 |'
- en: '| getmro | getmro(*c*) Returns a tuple of bases and ancestors of class *c*
    in method resolution order (discussed in [“Inheritance”](ch04.xhtml#inheritance)).
    *c* is the first item in the tuple, and each class appears only once in the tuple.
    For example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '| getmro | getmro(*c*) 返回类 *c* 的基类和祖先类的方法解析顺序（详见 [“继承”](ch04.xhtml#inheritance)）。元组的第一项是
    *c*，每个类在元组中只出现一次。例如：'
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| getsource, getsourcelines | getsource(*obj*), getsourcelines(*obj*)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '| getsource, getsourcelines | getsource(*obj*)，getsourcelines(*obj*)'
- en: 'getsource returns a multiline string that is the source code for *obj*, and
    raises IOError if it is unable to determine or fetch it. getsourcelines returns
    a pair: the first item is the source code for *obj* (a list of lines), and the
    second item is the line number of the first line within its file. |'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: getsource 返回一个多行字符串，这是 *obj* 的源代码，并在无法确定或获取时引发 IOError。getsourcelines 返回一个对：第一项是
    *obj* 的源代码（行列表），第二项是其文件中第一行的行号。 |
- en: '| isbuiltin, isclass, iscode, isframe,'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '| isbuiltin, isclass, iscode, isframe,'
- en: isfunction,
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: isfunction,
- en: ismethod,
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ismethod,
- en: ismodule,
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ismodule,
- en: 'isroutine | isbuiltin(*obj*), etc. Each of these functions accepts a single
    argument *obj* and returns **True** when *obj* is of the kind indicated in the
    function name. Accepted objects are, respectively: built-in (C-coded) functions,
    class objects, code objects, frame objects, Python-coded functions (including
    **lambda** expressions), methods, modules, and—for isroutine—all methods or functions,
    either C-coded or Python-coded. These functions are often used as the filter argument
    to getmembers. |'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: isroutine | isbuiltin(*obj*) 等。这些函数每个接受一个参数 *obj* 并在 *obj* 是函数名中指示的类型时返回 **True**。接受的对象分别是：内置（C
    编码）函数、类对象、代码对象、帧对象、Python 编码函数（包括 **lambda** 表达式）、方法、模块，以及对于 isroutine，所有方法或函数，无论是
    C 编码还是 Python 编码。这些函数通常用作 getmembers 的过滤器参数。 |
- en: '| stack | stack(context=1) Returns a list of six-item tuples. The first tuple
    is about stack’s caller, the second about the caller’s caller, and so on. The
    items in each tuple are: frame object, filename, line number, function name, list
    of context source lines around the current line, index of current line within
    the list. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| stack | stack(context=1) 返回一个六项元组列表。第一个元组关于堆栈的调用者，第二个关于调用者的调用者，依此类推。每个元组中的项是：帧对象、文件名、行号、函数名、当前行周围上下文源代码行列表、当前行在列表中的索引。
    |'
- en: Introspecting callables
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检视可调用对象
- en: To introspect a callable’s signature, call inspect.signature(*f*), which returns
    an instance *s* of class inspect.Signature.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要检视可调用对象的签名，调用 inspect.signature(*f*)，它返回一个 inspect.Signature 类的实例 *s*。
- en: '*s*.parameters is a dict mapping parameter names to inspect.Parameter instances.
    Call *s*.bind(**a*, ***k*) to bind all parameters to the given positional and
    named arguments, or *s*.bind_partial(**a*, ***k*) to bind a subset of them: each
    returns an instance *b* of inspect.BoundArguments.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*s*.parameters 是一个字典，将参数名映射到 inspect.Parameter 实例。调用 *s*.bind(**a*, ***k*)
    将所有参数绑定到给定的位置参数和命名参数，或者调用 *s*.bind_partial(**a*, ***k*) 绑定它们的子集：每个调用都返回一个 inspect.BoundArguments
    实例 *b*。'
- en: For detailed information and examples of how to introspect callables’ signatures
    through these classes and their methods, see [PEP 362](https://oreil.ly/e2Sb_).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解如何通过这些类及其方法检视可调用对象的签名的详细信息和示例，请参阅 [PEP 362](https://oreil.ly/e2Sb_)。
- en: An example of using inspect
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `inspect` 的示例
- en: 'Suppose that somewhere in your program you execute a statement such as:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在程序的某个地方执行了如下语句：
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'and unexpectedly receive an AttributeError informing you that object x has
    no attribute named f. This means that object x is not as you expected, so you
    want to determine more about x as a preliminary to ascertaining why x is that
    way and what you should do about it. A simple first approach might be:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 并意外地接收到一个 `AttributeError`，通知您对象 `x` 没有名为 `f` 的属性。这意味着对象 `x` 不如您所预期，因此您希望在确定为什么
    `x` 是那样以及您应该对其采取什么行动之前更多地了解 `x`。一个简单的第一步方法可能是：
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will often provide sufficient information to go on; or you might change
    it to print(type(x), dir(x), x) to see what x’s methods and attributes are. But
    if this isn’t sufficient, change the statement to:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常会提供足够的信息以继续进行；或者您可以将其更改为 `print(type(x), dir(x), x)` 以查看 `x` 的方法和属性是什么。但如果这还不够，将语句更改为：
- en: '[PRE15]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This example properly uses sys.stderr (covered in [Table 8-3](ch08.xhtml#functions_and_attributes_of_the_sys_mod)),
    since it displays information related to an error, not program results. The function
    getmembers of the module inspect obtains the names of all the methods available
    on x in order to display them. If you often need this kind of diagnostic functionality,
    you can package it up into a separate function, such as:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例适当地使用 `sys.stderr`（在 [表 8-3](ch08.xhtml#functions_and_attributes_of_the_sys_mod)
    中有详细讲述），因为它显示与错误相关的信息，而不是程序结果。`inspect` 模块的 `getmembers` 函数获取模块 `x` 上所有可用方法的名称以显示它们。如果您经常需要此类诊断功能，可以将其打包成一个单独的函数，例如：
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And then the example becomes just:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后示例变成：
- en: '[PRE17]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Good program structure and organization are just as necessary in code intended
    for diagnostic and debugging purposes as they are in code that implements your
    program’s functionality. See also [“The assert Statement”](ch06.xhtml#the_assert_statement)
    for a good technique to use when defining diagnostic and debugging functions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在旨在用于诊断和调试目的的代码中，良好的程序结构和组织同样必不可少，正如在实现程序功能的代码中一样。另请参见 [“`assert` 语句”](ch06.xhtml#the_assert_statement)
    以获取定义诊断和调试函数时的良好技巧。
- en: The traceback Module
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`traceback` 模块'
- en: 'The traceback module lets you extract, format, and output information about
    tracebacks that uncaught exceptions normally produce. By default, this module
    reproduces the formatting Python uses for tracebacks. However, the traceback module
    also lets you exert fine-grained control. The module supplies many functions,
    but in typical use you need only one of them:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`traceback` 模块允许您提取、格式化和输出未捕获异常通常产生的回溯信息。默认情况下，此模块复制 Python 用于回溯的格式。然而，`traceback`
    模块还允许您精细控制。该模块提供许多函数，但在典型用法中，您只需要其中一个：'
- en: '| print_exc | print_exc(limit=**None**, file=sys.stderr) Call print_exc from
    an exception handler, or from a function called, directly or indirectly, by an
    exception handler. print_exc outputs to file-like object file the traceback that
    Python outputs to stderr for uncaught exceptions. When limit is an integer, print_exc
    outputs only limit traceback nesting levels. For example, when, in an exception
    handler, you want to cause a diagnostic message just as if the exception propagated,
    but stop the exception from propagating further (so that your program keeps running
    and no further handlers are involved), call traceback.print_exc(). |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `print_exc` | `print_exc(limit=**None**, file=sys.stderr)` 从异常处理程序中调用 `print_exc`，或从直接或间接被异常处理程序调用的函数中调用
    `print_exc`。`print_exc` 输出 Python 为未捕获异常输出到 stderr 的回溯。当 `limit` 是整数时，`print_exc`
    仅输出限定的回溯嵌套层级。例如，在异常处理程序中，如果您希望引发诊断消息，就像异常已传播一样，但停止异常进一步传播（以使程序继续运行且不涉及更多处理程序），则调用
    `traceback.print_exc()`。'
- en: The pdb Module
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`pdb` 模块'
- en: The pdb module uses the Python interpreter’s debugging and tracing hooks to
    implement a simple command-line interactive debugger. pdb lets you set breakpoints,
    single-step and jump to source code, examine stack frames, and so on.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`pdb` 模块利用 Python 解释器的调试和跟踪钩子来实现一个简单的命令行交互式调试器。`pdb` 允许您设置断点，逐步执行和跳转到源代码，检查堆栈帧等等。'
- en: To run code under pdb’s control, import pdb, then call pdb.run, passing as the
    single argument a string of code to execute. To use pdb for postmortem debugging
    (debugging of code that just terminated by propagating an exception at an interactive
    prompt), call pdb.pm() without arguments. To trigger pdb directly from your application
    code, use the built-in function breakpoint.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 pdb 控制下运行代码，请导入 pdb，然后调用 pdb.run，传递作为唯一参数的要执行的代码字符串。要使用 pdb 进行事后调试（在交互提示处通过传播异常终止的代码调试），调用
    pdb.pm() 而无需参数。要直接从应用程序代码中触发 pdb，请使用内置函数 breakpoint。
- en: When pdb starts, it first reads text files named *.pdbrc* in your home directory
    and in the current directory. Such files can contain any pdb commands, but most
    often you put alias commands in them to define useful synonyms and abbreviations
    for other commands that you use often.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当 pdb 启动时，它首先读取位于您的主目录和当前目录中名为 *.pdbrc* 的文本文件。这些文件可以包含任何 pdb 命令，但通常您会在其中放置别名命令，以定义其他经常使用的命令的有用同义词和缩写。
- en: 'When pdb is in control, it prompts with the string (Pdb), and you can enter
    pdb commands. The command help (which you can enter in the abbreviated form h)
    lists the available commands. Call help with an argument (separated by a space)
    to get help about any specific command. You can abbreviate most commands to the
    first one or two letters, but you must always enter commands in lowercase: pdb,
    like Python itself, is case-sensitive. Entering an empty line repeats the previous
    command. The most frequently used pdb commands are listed in [Table 17-6](#commonly_used_pdb_commands).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当 pdb 控制时，它会显示字符串 (Pdb)，您可以输入 pdb 命令。命令 help（您可以用 h 的缩写形式输入）会列出可用的命令。使用带有参数的
    help（参数之间用空格分隔）可以获取有关任何特定命令的帮助。大多数命令可以缩写为第一个或前两个字母，但是必须始终以小写输入命令：pdb 与 Python
    本身一样，区分大小写。输入空行会重复上一条命令。最常用的 pdb 命令列在 [表 17-6](#commonly_used_pdb_commands) 中。
- en: Table 17-6\. *Commonly used pdb commands*
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 表 17-6\. *常用的 pdb 命令*
- en: '| ! | ! *statement* Executes Python statement *statement* with the currently
    selected stack frame (see the d and u commands later in this table) as the local
    namespace. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| ! | ! *statement* 使用当前选择的堆栈帧（请参见本表后面的 d 和 u 命令）作为本地命名空间执行 Python 语句 *statement*。
    |'
- en: '| alias, unalias | alias [*name* [*command*]], unalias *name*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '| 别名, 取消别名 | 别名 [*name* [*command*]], unalias *name*'
- en: Defines a short form of a frequently used command. *command* is any pdb command,
    with arguments, and may contain %1, %2, and so on to refer to specific arguments
    passed to the new alias *name* being defined, or %* to refer to all such arguments.
    alias with no arguments lists currently defined aliases. alias *name* outputs
    the current definition of alias *name*. unalias *name* removes an alias. |
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 定义经常使用的命令的简短形式。*command* 是任何带有参数的 pdb 命令，并且可以包含 %1、%2 等以引用传递给正在定义的新别名 *name*
    的特定参数，或者使用 %* 引用所有这些参数。不带参数的 alias 列出当前定义的别名。alias *name* 输出别名 *name* 的当前定义。unalias
    *name* 删除别名。
- en: '| args, a | args Lists all arguments passed to the function you are currently
    debugging. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| args, a | args 列出当前正在调试的函数传递的所有参数。 |'
- en: '| break, b | break [*location*[, *condition*]] With no arguments, lists the
    currently defined breakpoints and the number of times each breakpoint has triggered.
    With an argument, break sets a breakpoint at the given *location**.* *location*
    can be a line number or a function name, optionally preceded by *filename*: to
    set a breakpoint in a file that is not the current one or at the start of a function
    whose name is ambiguous (i.e., a function that exists in more than one file).
    When *condition* is present, it is an expression to evaluate (in the debugged
    context) each time the given line or function is about to execute; execution breaks
    only when the expression returns a truthy value. When setting a new breakpoint,
    break returns a breakpoint number, which you can later use to refer to the new
    breakpoint in any other breakpoint-related pdb command. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 断点, b | 断点 [*location*[, *condition*]] 如果没有参数，列出当前定义的断点及每个断点触发的次数。带有参数时，break
    在给定的 *location* 处设置断点。*location* 可以是行号或函数名，可选择在函数名之前加上 *filename*: 以在不是当前文件或函数名模糊的情况下设置断点（即存在于多个文件中的函数）。当存在
    *condition* 时，它是一个表达式，每次执行给定行或函数时（在调试上下文中）都会进行评估；仅当表达式返回真值时才会中断执行。设置新断点时，break
    返回断点编号，稍后可以在任何其他与断点相关的 pdb 命令中使用该编号引用新断点。 |'
- en: '| clear, cl | clear [*breakpoint-numbers*] Clears (removes) one or more breakpoints.
    clear with no arguments removes all breakpoints after asking for confirmation.
    To deactivate a breakpoint temporarily, without removing it, see disable, covered
    below. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| clear, cl | clear [*断点编号*] 清除（删除）一个或多个断点。无参数清除所有断点，需确认后执行。要临时停用断点而不是删除它，请参见后面的
    disable。 |'
- en: '| condition | condition *breakpoint-number* [*expression*] condition *n expression*
    sets or changes the condition on breakpoint *n*. condition *n*, without *expression*,
    makes breakpoint *n* unconditional. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| condition | condition *断点编号* [*表达式*] condition *n expression* 设置或更改断点 *n*
    的条件。condition *n*，不带 *expression*，将断点 *n* 设置为无条件断点。 |'
- en: '| continue, c, cont | continue Continues execution of the code being debugged,
    up to a breakpoint, if any. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| continue, c, cont | continue 继续执行正在调试的代码，直到遇到断点为止。 |'
- en: '| disable | disable [*breakpoint-numbers*] Disables one or more breakpoints.
    disable without arguments disables all breakpoints (after asking for confirmation).
    This differs from clear in that the debugger remembers the breakpoint, and you
    can reactivate it via enable. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| disable | disable [*断点编号*] 禁用一个或多个断点。无参数禁用所有断点（需确认）。与 clear 不同的是，调试器会记住断点，并可以通过
    enable 重新激活。 |'
- en: '| down, d | down Moves down one frame in the stack (i.e., toward the most recent
    function call). Normally, the current position in the stack is at the bottom (at
    the function that was called most recently and is now being debugged), so down
    can’t go further down. However, down is useful if you have previously executed
    the command up, which moves the current position upward in the stack. |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| down, d | down 在堆栈中向下移动一帧（即向最近的函数调用移动）。通常情况下，堆栈中的当前位置位于最底部（即正在调试的最近调用的函数），所以
    down 不能再向下移动。然而，如果之前执行了 up 命令（该命令将当前位置向上移动到堆栈中的上一级），则 down 命令会很有用。 |'
- en: '| enable | enable [*breakpoint-numbers*] Enables one or more breakpoints. enable
    without arguments enables all breakpoints after asking for confirmation. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| enable | enable [*断点编号*] 启用一个或多个断点。无参数启用所有断点，需确认后执行。 |'
- en: '| ignore | ignore *breakpoint-number* [*count*] Sets the breakpoint’s ignore
    count (to 0 if *count* is omitted). Triggering a breakpoint whose ignore count
    is greater than 0 just decrements the count. Execution stops, presenting you with
    an interactive pdb prompt, only when you trigger a breakpoint whose ignore count
    is 0. For example, say that module *fob.py* contains the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '| ignore | ignore *断点编号* [*次数*] 设置断点的忽略计数（如果省略 *count*，则为 0）。触发忽略计数大于 0 的断点时，只会减少计数而不会停止执行，而是会显示交互式
    pdb 提示。只有当触发忽略计数为 0 的断点时，执行才会停止。例如，假设模块 *fob.py* 包含以下代码：'
- en: '[PRE18]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now consider the following interactive pdb session (minor formatting details
    may change depending on the Python version you’re running):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 'Now consider the following interactive pdb session (minor formatting details
    may change depending on the Python version you’re running):'
- en: '[PRE19]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The ignore command, as pdb says, tells pdb to ignore the next 500 hits on breakpoint
    1, which we set at fob.g in the previous break statement. Therefore, when execution
    finally stops, the function g has already been called 500 times, as we show by
    printing its argument i, which indeed is now 500. The ignore count of breakpoint
    1 is now 0; if we execute another continue and print i, i shows as 501. In other
    words, once the ignore count decrements to 0, execution stops every time the breakpoint
    is hit. If we want to skip some more hits, we must give pdb another ignore command,
    setting the ignore count of breakpoint 1 to some value greater than 0 yet again.
    |
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: The ignore command, as pdb says, tells pdb to ignore the next 500 hits on breakpoint
    1, which we set at fob.g in the previous break statement. Therefore, when execution
    finally stops, the function g has already been called 500 times, as we show by
    printing its argument i, which indeed is now 500. The ignore count of breakpoint
    1 is now 0; if we execute another continue and print i, i shows as 501. In other
    words, once the ignore count decrements to 0, execution stops every time the breakpoint
    is hit. If we want to skip some more hits, we must give pdb another ignore command,
    setting the ignore count of breakpoint 1 to some value greater than 0 yet again.
    |
- en: '| jump, j | jump *line_number* Sets the next line to execute to the given line
    number. You can use this to skip over some code by advancing to a line beyond
    it, or revisit some code that was already run by jumping to a previous line. (Note
    that a jump to a previous source line is not an undo command: any changes to program
    state made after that line are retained.)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '| jump, j | jump *行号* 设置下一个要执行的行号。可以用此命令跳过某些代码，也可以回到已执行过的代码。注意，跳到前面的源代码行不是撤销命令：在该行之后对程序状态的任何更改都会被保留。
    |'
- en: jump does come with some limitations—for example, you can only jump within the
    bottom frame, and you cannot jump into a loop or out of a **finally** block—but
    it can still be an extremely useful command. |
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: jump 确实有一些限制——例如，您只能在底部帧内跳转，不能跳入循环或跳出**finally**块——但它仍然可以是一个极其有用的命令。
- en: '| list, l | list [*first* [, *last*] ] Without arguments, lists 11 (eleven)
    lines centered on the current one, or the next 11 lines if the previous command
    was also a list. Arguments to the list command can optionally specify the first
    and last lines to list within the current file; use a dot (.) to indicate the
    current debug line. The list command lists physical lines, counting and including
    comments and empty lines, not logical lines. list’s output marks the current line
    with ->; if the current line was reached in the course of handling an exception,
    the line that raised the exception is marked with >>. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| list, l | list [*first* [, *last*] ] 如果没有参数，则列出当前行为中心的 11（十一）行，或者如果上一个命令也是列表，则列出接下来的
    11 行。列表命令的参数可选地指定要在当前文件中列出的第一行和最后一行；使用点（.）表示当前调试行。list 命令列出物理行，包括注释和空行在内，而不是逻辑行。list
    的输出标记当前行为 ->；如果当前行是在处理异常时到达的，则标记引发异常的行为 >>。 |'
- en: '| ll | ll Long version of list, showing all lines in the current function or
    frame. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| ll | ll list的长版本，在当前函数或帧中显示所有行。 |'
- en: '| next, n | next Executes the current line, without “stepping into” any function
    called from the current line. However, hitting breakpoints in functions called
    directly or indirectly from the current line does stop execution. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| next, n | next 执行当前行，而不“进入”从当前行直接或间接调用的任何函数中。但是，在从当前行直接或间接调用的函数中命中断点会停止执行。
    |'
- en: '| print, p | print(*expression*), p *expression*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '| print, p | print(*expression*), p *expression*'
- en: Evaluates *expression* in the current context and displays the result. |
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前上下文中评估*expression*并显示结果。 |
- en: '| quit, q | quit Immediately terminates both pdb and the program being debugged.
    |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| quit, q | quit 立即终止pdb和正在调试的程序。 |'
- en: '| return, r | return Executes the rest of the current function, stopping only
    at breakpoints, if any. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| return, r | return 执行当前函数的其余部分，仅在有断点时停止。 |'
- en: '| step, s | step Executes the current line, stepping into any function called
    from the current line. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| step, s | step 执行当前行，进入从当前行调用的任何函数中。 |'
- en: '| tbreak | tbreak [*location*[, *condition*]] Like break, but the breakpoint
    is temporary (i.e., pdb automatically removes the breakpoint as soon as the breakpoint
    is triggered). |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| tbreak | tbreak [*location*[, *condition*]] 类似于break，但断点是临时的（即pdb在触发断点后自动删除断点）。
    |'
- en: '| up, u | up Moves up one frame in the stack (i.e., away from the most recent
    function call and toward the calling function). |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| up, u | up 在堆栈中向上移动一帧（即远离最近的函数调用，并向调用函数靠近）。 |'
- en: '| where, w | where Shows the stack of frames and indicates the current one
    (i.e., in which frame’s context the command ! executes statements, the command
    args shows arguments, the command print evaluates expressions, etc.). |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| where, w | where 显示帧堆栈并指示当前帧（即在哪个帧的上下文中执行命令!、显示参数、评估表达式等）。 |'
- en: You can also enter a Python expression at the (Pdb) prompt, and pdb will evaluate
    it and display the result, just as if you were at the Python interpreter prompt.
    However, when you enter an expression whose first term coincides with a pdb command,
    the pdb command will execute. This is especially problematic when debugging code
    with single-letter variables like *p* and *q*. In these cases, you must begin
    the expression with ! or precede it with the print or p command.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在（Pdb）提示符处输入Python表达式，pdb 将对其进行评估并显示结果，就像在Python解释器提示符处一样。但是，当您输入的表达式的第一个术语与pdb命令重合时，pdb命令将执行。在调试带有单字母变量（如*p*和*q*）的代码时，这尤其棘手。在这些情况下，必须以!开头或以print或p命令开始表达式。
- en: Other Debugging Modules
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他调试模块
- en: While pdb is built into Python, there are third-party packages that provide
    enhanced features for debugging.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然pdb内置于Python中，但也有第三方包提供了增强的调试功能。
- en: ipdb
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ipdb
- en: Just as ipython extends the interactive interpreter provided by Python, [ipdb](https://oreil.ly/t8rV2)
    adds the same inspection, tab completion, command-line editing, and history features
    (and magic commands) to pdb. [Figure 17-1](#example_of_an_ipdb_session) shows
    an example interaction.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 就像ipython扩展了Python提供的交互式解释器一样，[ipdb](https://oreil.ly/t8rV2) 为pdb添加了相同的检查、制表完成、命令行编辑和历史记录功能（以及魔术命令）。[Figure 17-1](#example_of_an_ipdb_session)
    显示了一个示例交互过程。
- en: '*![Example of an ipdb session](assets/pns4_1701.png)*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*![一个 ipdb 会话示例](assets/pns4_1701.png)*'
- en: Figure 17-1\. *Example of an ipdb session*
  id: totrans-214
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 17-1\. *一个 ipdb 会话示例*
- en: ipdb also adds configuration and conditional expressions to its version of set_trace,
    giving more control over when your program is to break out into the debugging
    session. (In this example, the breakpoint is conditional on i being equal to 2.)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ipdb 还在其 set_trace 版本中添加了配置和条件表达式，以便更好地控制何时程序可以中断进入调试会话。（在此示例中，断点是在 i 等于 2 时条件触发的。）
- en: pudb
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pudb
- en: '[pudb](https://oreil.ly/a5PJB) is a lightweight “graphical-like” debugger that
    runs in a terminal console (see [Figure 17-2](#example_of_a_pudb_session)), utilizing
    the [urwid](http://excess.org/urwid) console UI library. It is especially useful
    when connecting to remote Python environments using terminal sessions such as
    ssh, where a windowed-GUI debugger is not easy to install or run.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[pudb](https://oreil.ly/a5PJB) 是一个轻量级的“类图形化”调试器，运行在终端控制台中（见[图 17-2](#example_of_a_pudb_session)），利用
    [urwid](http://excess.org/urwid) 控制台 UI 库。特别适用于使用 ssh 等终端会话连接远程 Python 环境，其中安装或运行窗口化
    GUI 调试器并不容易。'
- en: '*![Example of a pudb session](assets/pns4_1702.png)*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*![一个 pudb 会话示例](assets/pns4_1702.png)*'
- en: Figure 17-2\. *Example of a pudb session*
  id: totrans-219
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 17-2\. *一个 pudb 会话示例*
- en: pudb has its own set of debugging commands and interface, which take some practice
    to use; however, it makes a visual debugging environment handily available when
    working in tight computing spaces.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: pudb 拥有其自己的调试命令和界面，需要一些实践才能使用；然而，在紧凑的计算环境中工作时，它提供了一个便捷的可视化调试环境。
- en: The warnings Module
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 警告模块
- en: Warnings are messages about errors or anomalies that aren’t serious enough to
    disrupt the program’s control flow (as would happen by raising an exception).
    The warnings module affords fine-grained control over which warnings are output
    and what happens to them. You can conditionally output a warning by calling the
    function warn in the warnings module. Other functions in the module let you control
    how warnings are formatted, set their destinations, and conditionally suppress
    some warnings or transform some warnings into exceptions.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 警告是关于错误或异常情况的消息，这些情况不足以打断程序的控制流（如通过引发异常来打断）。警告模块提供了对输出哪些警告以及处理它们的细粒度控制。您可以通过调用警告模块中的
    warn 函数来有条件地输出警告。模块中的其他函数允许您控制警告的格式化方式、设置其目标以及有条件地抑制某些警告或将某些警告转换为异常。
- en: Classes
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: 'Exception classes that represent warnings are not supplied by warnings: rather,
    they are built-ins. The class Warning subclasses Exception and is the base class
    for all warnings. You may define your own warning classes, which must subclass
    Warning, either directly or via one of its other existing subclasses—these include:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '表示警告的异常类不由 warnings 提供：相反，它们是内置的。Warning 类是 Exception 的子类，是所有警告的基类。您可以定义自己的警告类，它们必须直接或通过现有子类（包括）继承
    Warning。:'
- en: DeprecationWarning
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: DeprecationWarning
- en: For use of deprecated features which are still supplied only for backward compatibility
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 用于使用已弃用的特性，这些特性仅供向后兼容使用
- en: RuntimeWarning
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: RuntimeWarning
- en: For use of features whose semantics are error prone
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 用于使用语义容易出错的特性
- en: SyntaxWarning
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: SyntaxWarning
- en: For use of features whose syntax is error prone
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 用于使用语法容易出错的特性
- en: UserWarning
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: UserWarning
- en: For other user-defined warnings that don’t fit any of the above cases
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 用于其他用户定义的不适合上述任何情况的警告
- en: Objects
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象
- en: 'Python supplies no concrete “warning objects.” Rather, a warning is made up
    of a *message* (a string), a *category* (a subclass of Warning), and two pieces
    of information to identify where the warning was raised: *module* (the name of
    the module that raised the warning) and *lineno* (the number of the line in the
    source code that raised the warning). Conceptually, you may think of these as
    attributes of a warning object *w*: we use attribute notation later, strictly
    for clarity, but no specific object *w* actually exists.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Python 没有具体的“警告对象”。而是，警告由一个*消息*（一个字符串）、一个*类别*（Warning 的子类）和两个用于标识引发警告位置的信息组成：*module*（引发警告的模块名）和*lineno*（源代码中引发警告的行号）。从概念上讲，您可以将这些看作是警告对象
    *w* 的属性：我们稍后使用属性表示法，严格来说，仅出于清晰度考虑，但实际上并不存在具体的对象 *w*。
- en: Filters
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤器
- en: At any time, the warnings module keeps a list of active filters for warnings.
    When you import warnings for the first time in a run, the module examines sys.warnoptions
    to determine the initial set of filters. You can run Python with the option **-W**
    to set sys.warnoptions for a given run. Do not rely on the initial set of filters
    being held specifically in sys.warnoptions, as this is an implementation detail
    that may change in future versions of Python.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 任何时候，警告模块都会保留警告的活动过滤器列表。当你在运行中首次导入警告模块时，该模块会检查 sys.warnoptions 来确定初始过滤器集。你可以使用
    Python 选项 **-W** 来设置 sys.warnoptions 以供给定运行使用。不要依赖于初始过滤器具体在 sys.warnoptions 中的保持，因为这是可能在未来的
    Python 版本中会更改的实现细节。
- en: 'As each warning *w* occurs, warnings tests *w* against each filter until a
    filter matches. The first matching filter determines what happens to *w*. Each
    filter is a tuple of five items. The first item, *action*, is a string that defines
    what happens on a match. The other four items, *message**,* *category**,* *module*,
    and *lineno*, control what it means for *w* to match the filter: for a match,
    all conditions must be satisfied. Here are the meanings of these items (using
    attribute notation to indicate conceptual attributes of *w*):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 每当发生一个警告 *w*，警告会对每个过滤器进行测试，直到找到一个匹配的过滤器。第一个匹配的过滤器确定 *w* 的处理方式。每个过滤器是一个包含五个项目的元组。第一项
    *action* 是一个字符串，定义了匹配时的处理方式。其他四项 *message**,* *category**,* *module*, 和 *lineno*
    控制了 *w* 与过滤器匹配的条件：要进行匹配，必须满足所有条件。以下是这些项目的含义（使用属性表示法指示 *w* 的概念属性）：
- en: '*message*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*message*'
- en: A regular expression pattern string; the match condition is re.match(*message*,
    *w*.message, re.I) (the match is case insensitive)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式模式字符串；匹配条件是 re.match(*message*, *w*.message, re.I)（匹配不区分大小写）
- en: '*category*'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '*category*'
- en: Warning or a subclass; the match condition is issubclass(*w*.category, *category*)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 警告或其子类；匹配条件是 issubclass(*w*.category, *category*)
- en: '*module*'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*module*'
- en: A regular expression pattern string; the match condition is re.match(*module*,
    *w*.module) (the match is case sensitive)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式模式字符串；匹配条件是 re.match(*module*, *w*.module)（匹配区分大小写）
- en: '*lineno*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*lineno*'
- en: 'An int; the match condition is *lineno* **in** (*0*, *w*.lineno): that is,
    either *lineno* is 0, meaning *w*.lineno does not matter, or *w*.lineno must exactly
    equal *lineno*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一个整数；匹配条件是 *lineno* **在** (*0*, *w*.lineno)：即，*lineno* 要么是 0，表示 *w*.lineno 无关紧要，要么
    *w*.lineno 必须精确等于 *lineno*。
- en: 'Upon a match, the first field of the filter, the *action*, determines what
    happens. It can have the following values:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配时，过滤器的第一个字段 *action* 决定了会发生什么。它可以具有以下值：
- en: '''always'''
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '''always'''
- en: '*w*.message is output whether or not *w* has already occurred.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*w*.message 无论 *w* 是否已经发生都输出。'
- en: '''default'''
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '''default'''
- en: '*w*.message is output if, and only if, this is the first time *w* has occurred
    from this specific location (i.e., this specific (*w*.module, *w*.location) pair).'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*w*.message 只有在这是第一次从此特定位置（即此特定 (*w*.module, *w*.location) 对）发生 *w* 时才输出。'
- en: '''error'''
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '''error'''
- en: '*w*.category(*w*.message) is raised as an exception.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*w*.category(*w*.message) 被作为异常抛出。'
- en: '''ignore'''
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '''ignore'''
- en: '*w* is ignored.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*w* 被忽略。'
- en: '''module'''
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '''module'''
- en: '*w*.message is output if, and only if, this is the first time *w* occurs from
    *w*.module.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*w*.message 只有在这是第一次从 *w*.module 处发生 *w* 时才输出。'
- en: '''once'''
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '''once'''
- en: '*w*.message is output if, and only if, this is the first time *w* occurs from
    any location.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*w*.message 只有在这是第一次从任何位置发生 *w* 时才输出。'
- en: 'When a module issues a warning, warnings adds to that module’s global variables
    a dict named __warningsgregistry__, if that dict is not already present. Each
    key in the dict is a pair (*message*, *category*), or a tuple with three items
    (*message*, *category*, *lineno*); the corresponding value is **True** when further
    occurrences of that message are to be suppressed. Thus, for example, you can reset
    the suppression state of all warnings from a module *m* by executing *m*.__warningsregistry__.clear():
    when you do that, all messages are allowed to get output again (once), even when,
    for example, they’ve previously triggered a filter with an *action* of ''module''.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个模块发出警告时，警告会向该模块的全局变量添加一个名为 __warningsgregistry__ 的字典，如果该字典尚不存在。字典中的每个键都是一个二元组
    (*message*, *category*)，或者是一个包含三个项目的元组 (*message*, *category*, *lineno*)；相应的值为
    **True**，表示进一步抑制该消息的发生。因此，例如，你可以通过执行 *m*.__warningsregistry__.clear() 来重置模块 *m*
    中所有警告的抑制状态：这样做后，所有消息都可以再次（一次）输出，即使例如它们以前触发过具有 'module' *action* 的过滤器。
- en: Functions
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: The warnings module supplies the functions listed in [Table 17-7](#functions_of_the_warnings_module).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 警告模块提供了 [表 17-7](#functions_of_the_warnings_module) 中列出的函数。
- en: Table 17-7\. *Functions of the warnings module*
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 表17-7\. *warnings模块的函数*
- en: '| fil⁠t⁠e⁠r​w⁠a⁠r⁠nings | filterwarnings(*action*, message=''.*'', category=Warning,
    module=''.*'', lineno=0, append=**False**)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '| fil⁠t⁠e⁠r​w⁠a⁠r⁠nings | filterwarnings(*action*, message=''.*'', category=Warning,
    module=''.*'', lineno=0, append=**False**)'
- en: Adds a filter to the list of active filters. When append is **True**, filterwarnings
    adds the filter after all other existing filters (i.e., appends the filter to
    the list of existing filters); otherwise, filterwarnings inserts the filter before
    any other existing filter. All components, save *action*, have default values
    that mean “match everything.” As detailed above, message and module are pattern
    strings for regular expressions, category is some subclass of Warning, lineno
    is an integer, and *action* is a string that determines what happens when a message
    matches this filter. |
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个过滤器到活动过滤器列表中。当`append`为**True**时，`filterwarnings`在所有现有过滤器之后添加过滤器（即将过滤器附加到现有过滤器列表之后）；否则，`filterwarnings`将过滤器插入到任何现有过滤器之前。除了*action*之外，所有组件都有默认值，意味着“匹配所有”。如上所述，`message`和`module`都是正则表达式的模式字符串，`category`是某个`Warning`的子类，`lineno`是一个整数，*action*是一个字符串，用于确定当消息匹配此过滤器时发生的情况。
- en: '| for⁠m⁠a⁠t​w⁠a⁠r⁠ning | formatwarning(*message*, *category*, *filename*, *lineno*)
    Returns a string that represents the given warning with standard formatting. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| for⁠m⁠a⁠t​w⁠a⁠r⁠ning | formatwarning(*message*, *category*, *filename*, *lineno*)
    返回一个字符串，表示带有标准格式的给定警告信息。'
- en: '| re⁠s⁠e⁠t​w⁠a⁠r⁠nings | resetwarnings() Removes all filters from the list
    of filters. resetwarnings also discards any filters originally added with the
    **-W** command-line option. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| re⁠s⁠e⁠t​w⁠a⁠r⁠nings | resetwarnings() 从过滤器列表中移除所有过滤器。`resetwarnings`还会丢弃使用**-W**命令行选项最初添加的任何过滤器。'
- en: '| showwarning | showwarning(*message*, *category*, *filename*, *lineno*, file=sys.stderr)
    Outputs the given warning to the given file object. Filter actions that output
    warnings call showwarning, letting the argument file default to sys.stderr. To
    change what happens when filter actions output warnings, code your own function
    with this signature and bind it to warnings.showwarning, thus overriding the default
    implementation. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| showwarning | showwarning(*message*, *category*, *filename*, *lineno*, file=sys.stderr)
    将给定的警告输出到给定的文件对象。输出警告的过滤器操作调用`showwarning`，让参数`file`默认为`sys.stderr`。要更改过滤器操作输出警告时的行为，请编写一个具有此签名的自定义函数，并将其绑定到`warnings.showwarning`，从而覆盖默认实现。'
- en: '| warn | warn(*message*, category=UserWarning, stacklevel=1) Sends a warning
    so that the filters examine and possibly output it. The location of the warning
    is the current function (caller of warn) if stacklevel is 1, or the caller of
    the current function if stacklevel is 2. Thus, passing 2 as the value of stacklevel
    lets you write functions that send warnings on their caller’s behalf, such as:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '| warn | warn(*message*, category=UserWarning, stacklevel=1) 发送一个警告，以便过滤器检查并可能输出它。警告的位置是当前函数（`warn`的调用者）如果`stacklevel`为1，或者当前函数的调用者如果`stacklevel`为2。因此，将2作为`stacklevel`的值使您能编写函数，以代表其调用者发送警告，例如：'
- en: '[PRE21]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Thanks to the parameter stacklevel=2, the warning appears to come from the caller
    of to_unicode, rather than from to_unicode itself. This is very important when
    the *action* of the filter that matches this warning is 'default' or 'module',
    since these actions output a warning only the first time the warning occurs from
    a given location or module. |
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于参数`stacklevel=2`，警告似乎来自于`to_unicode`的调用者，而不是`to_unicode`本身。当匹配此警告的过滤器的*action*是'default'或'module'时，这一点非常重要，因为这些操作仅在从给定位置或模块第一次发生警告时输出警告。
- en: Optimization
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化
- en: '“First make it work. Then make it right. Then make it fast.” This quotation,
    often with slight variations, is widely known as “the golden rule of programming.”
    As far as we’ve been able to ascertain, the source is Kent Beck, who credits his
    father with it. This principle is often quoted, but too rarely followed. A negative
    form, slightly exaggerated for emphasis, is a quotation by Don Knuth (who credits
    Sir Tony Hoare with it): “Premature optimization is the root of all evil in programming.”'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: “首先让它能运行。然后让它正确。最后让它快速。” 这句引文，通常略有变化，广为人知为“编程的黄金法则”。据我们所知，这句话的来源是Kent Beck，他归功于他的父亲。这个原则经常被引用，但很少被遵循。稍微夸张地说，唐纳德·克努斯（他归功于托尼·霍尔）的一句略微夸张的负面引用是：“过早优化是编程中一切邪恶之源。”
- en: 'Optimization is premature if your code is not working yet, or if you’re not
    sure what, precisely, your code should be doing (since then you cannot be sure
    if it’s working). First make it work: ensure that your code is correctly performing
    exactly the tasks it is *meant* to perform.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 优化过早进行，如果你的代码还没有工作，或者你不确定你的代码应该做什么（因为这样你不能确定它是否工作）。首先让它工作：确保你的代码正确执行它*应该*执行的任务。
- en: 'Optimization is also premature if your code is working but you are not satisfied
    with the overall architecture and design. Remedy structural flaws before worrying
    about optimization: first make it work, then make it right. These steps are not
    optional; working, well-architected code is *always* a must.^([6](ch17.xhtml#ch01fn130))'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码正在工作，但你对整体架构和设计不满意，优化也是过早的。在担心优化之前，解决结构性缺陷：先让它工作，然后再做正确的事情。这些步骤不是可选的；工作良好的架构代码*总是*必须的。^([6](ch17.xhtml#ch01fn130))
- en: Having a good test suite is key before attempting any optimization. After all,
    the purpose of optimization is to increase speed or reduce memory consumption—or
    both—without changing the code’s behavior.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试任何优化之前，拥有一个良好的测试套件是关键。毕竟，优化的目的是增加速度或减少内存消耗——或者两者兼而有之——而不改变代码的行为。
- en: 'In contrast, you don’t always need to make it fast. Benchmarks may show that
    your code’s performance is already acceptable after the first two steps. When
    performance is not acceptable, profiling often shows that all performance issues
    are in a small part of the code, with your program spending perhaps 80 or 90%
    of its time in 10 to 20% of the code.^([7](ch17.xhtml#ch01fn131)) Such performance-crucial
    regions of your code are known as *bottlenecks*, or *hot spots*. It’s a waste
    of effort to optimize large portions of code that account for, say, 10 percent
    of your program’s running time. Even if you made that part run 10 times as fast
    (a rare feat), your program’s overall runtime would only decrease by 9%,^([8](ch17.xhtml#ch01fn132))
    a speedup no user would likely even notice. If optimization is needed, focus your
    efforts where they matter: on bottlenecks. You can often optimize bottlenecks
    while keeping your code 100% pure Python, thus not preventing future porting to
    other Python implementations.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你并不总是需要让它变得快。基准测试可能显示，前两个步骤后，你的代码性能已经足够可接受。当性能不可接受时，分析常常显示所有性能问题都集中在代码的一个小部分，你的程序可能在10%到20%的代码中花费80%或90%的时间。^([7](ch17.xhtml#ch01fn131))
    这种性能关键的代码区域被称为*瓶颈*或*热点*。优化大部分代码（占程序运行时间的10%）是一种浪费。即使让这部分运行速度提升10倍（这是罕见的成就），你的程序整体运行时间只会减少9%。^([8](ch17.xhtml#ch01fn132))
    这种加速对用户来说可能根本察觉不到。如果需要优化，把注意力集中在真正重要的瓶颈上。你通常可以在保持代码100%纯Python的同时优化瓶颈，这样就不会阻止未来移植到其他Python实现。
- en: Developing a Fast-Enough Python Application
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发一个足够快的Python应用程序
- en: Start by designing, coding, and testing your application in Python, using available
    extension modules if they save you work. This takes much less time than it would
    with a classic compiled language. Then benchmark the application to find out if
    the resulting code is fast enough. Often it is, and you’re done—congratulations!
    Ship it!
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 首先在Python中设计、编码和测试你的应用程序，如果可用的扩展模块可以节省你的工作，可以使用它们。这比使用经典的编译语言要少很多时间。然后对应用程序进行基准测试，以确定生成的代码是否足够快。通常是这样的，你就完成了——恭喜！发布它！
- en: Since much of Python itself is coded in highly optimized C (as are many of its
    standard library and extension modules), your application may even turn out to
    already be faster than typical C code. However, if the application is too slow,
    you need, first and foremost, to rethink your algorithms and data structures.
    Check for bottlenecks due to application architecture, network traffic, database
    access, and operating system interactions. For many applications, each of these
    factors is more likely than language choice, or coding details, to cause slowdowns.
    Tinkering with large-scale architectural aspects can often dramatically speed
    up an application, and Python is an excellent medium for such experimentation.
    If you’re using a version control system (and you ought to be!), it should be
    easy to create experimental branches or clones where you can try out different
    techniques to see which—if any—deliver significant improvements, all without jeopardizing
    your working code. You can then merge back any improvements that pass your tests.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python本身的大部分代码都是用高度优化的C编写的（包括其许多标准库和扩展模块），你的应用程序甚至可能比典型的C代码更快。但是，如果应用程序速度太慢，首先需要重新思考算法和数据结构。检查由于应用程序架构、网络流量、数据库访问和操作系统交互而导致的瓶颈。对于许多应用程序而言，每个这些因素引起的减速概率比语言选择或编码细节更大。调整大规模架构方面的细节通常可以显著加速应用程序，并且Python是进行此类实验的优秀媒介。如果你正在使用版本控制系统（你应该使用！），创建实验分支或克隆以尝试不同的技术是很容易的，以查看哪些——如果有的话——能够显著改进性能，而不会危及你的工作代码。然后，你可以将通过测试的任何改进合并回来。
- en: 'If your program is still too slow, profile it: find out where the time is going!
    As we previously mentioned, applications often exhibit computational bottlenecks,
    with small areas of the source code accounting for the vast majority of the running
    time. Optimize the bottlenecks, applying the techniques suggested in the rest
    of this chapter.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序仍然太慢，请对其进行性能分析：找出时间花在哪里！如前所述，应用程序通常表现出计算瓶颈，源代码中的小部分区域占据了绝大多数的运行时间。优化这些瓶颈，应用本章其余部分建议的技术。
- en: If normal Python-level optimizations still leave some outstanding computational
    bottlenecks, you can recode those as Python extension modules, as covered in [Chapter
    25](https://oreil.ly/python-nutshell-25). In the end, your application will run
    at roughly the same speed as if you had coded it all in C, C++, or FORTRAN—or
    faster, when large-scale experimentation has let you find a better architecture.
    Your overall programming productivity with this process will not be much lower
    than if you had coded everything in Python. Future changes and maintenance are
    easy, since you use Python to express the overall structure of the program, and
    lower-level, harder-to-maintain languages for only a few specific computational
    bottlenecks.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果常规的Python级优化仍然存在一些显著的计算瓶颈，你可以将它们重写为Python扩展模块，详见[第25章](https://oreil.ly/python-nutshell-25)。最终，你的应用程序将以接近使用C、C++或FORTRAN编写的速度运行，甚至更快，尤其是在进行大规模实验后找到更好的架构时。使用这个过程的整体编程效率不会比你完全使用Python编码低多少。未来的变更和维护非常简单，因为你使用Python来表达程序的整体结构，而使用低级别、更难维护的语言仅用于少数特定的计算瓶颈。
- en: As you build applications in a given area following this process, you will accumulate
    a library of reusable Python extension modules. You will therefore become more
    and more productive at developing other fast-running Python applications in the
    same field.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当你按照这个过程在特定领域构建应用程序时，你将积累一套可重复使用的Python扩展模块库。因此，你在开发其他快速运行的Python应用程序时会变得越来越高效。
- en: Even if external constraints eventually force you to recode your whole application
    in a lower-level language, you’ll still be better off for having started in Python.
    Rapid prototyping has long been acknowledged as the best way to get software architecture
    right. A working prototype lets you check that you have identified the right problems
    and taken a good path to their solution. A prototype also affords the kind of
    large-scale architectural experimentation that can make a real difference in performance.
    You can migrate your code gradually to other languages by way of extension modules,
    if need be, and the application remains fully functional and testable at each
    stage. This ensures against the risk of compromising a design’s architectural
    integrity in the coding stage.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 即使外部约束最终迫使你将整个应用程序重新编写为低级语言，你也会因为最初选择Python而受益良多。快速原型设计长期以来被公认为正确软件架构的最佳方式。一个工作原型能让你检查是否正确地识别了问题，并采取了良好的解决路径。原型还能进行大规模的架构实验，这对性能可能产生真正的巨大影响。如果需要，你可以通过扩展模块逐步将代码迁移到其他语言，并且每个阶段应用仍然完全可用和可测试。这可以防止在编码阶段损害设计架构完整性的风险。
- en: Even if you are required to use a low-level language for the entire application,
    it can often be more productive to write it in Python first (especially if you
    are new to the application’s domain). Once you have a working Python version,
    you can experiment with the user or network interface or library API, and with
    the architecture. Also, it is much easier to find and fix bugs and to make changes
    in Python code than in lower-level languages. At the end, you’ll know the code
    so well that porting to a lower-level language should be very fast and straightforward,
    safe in the knowledge that most of the design mistakes were made and fixed in
    the Python implementation.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 即使要求整个应用程序使用低级语言，首先在Python中编写通常更高效（特别是如果您对应用程序的领域不熟悉）。一旦有了工作的Python版本，您可以试验用户界面、网络接口或库API以及架构。此外，相比于低级语言，Python代码更容易找到和修复错误，并进行更改。最后，您将非常熟悉代码，因此将其移植到低级语言应该会非常快速和简单，安全地知道大多数设计错误已在Python实现中发现和修复。
- en: The resulting software will be faster and more robust than if all of the coding
    had been lower-level from the start, and your productivity—while not quite as
    good as with a pure Python application—will still be higher than if you had been
    coding at a lower level throughout.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 使用高级语言编写的软件，比起一开始就采用低级编码，结果会更快、更健壮。尽管与纯Python应用相比，你的生产力可能稍逊色一些，但仍然比一直在低级语言编码要高。
- en: Benchmarking
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基准测试
- en: '*Benchmarking* (also known as *load testing*) is similar to system testing:
    both activities are much like running the program for production purposes. In
    both cases, you need to have at least some subset of the program’s intended functionality
    working, and you need to use known, reproducible inputs. For benchmarking, you
    don’t need to capture and check your program’s output: since you make it work
    and make it right before you make it fast, you’re already fully confident about
    your program’s correctness by the time you load test it. You do need inputs that
    are representative of typical system operation—ideally ones that are likely to
    pose the greatest challenges to your program’s performance. If your program performs
    several kinds of operations, make sure you run some benchmarks for each different
    kind of operation.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '*基准测试*（也称为*负载测试*）类似于系统测试：这两种活动都很像为了生产目的运行程序。在这两种情况下，您需要至少有程序预期功能的某些子集，并且需要使用已知的可重现输入。对于基准测试，您无需捕获和检查程序的输出：因为在使其工作和使其正确之前，您已经对程序的正确性充满信心。您需要输入，这些输入代表典型系统操作的代表性，最好是那些可能对程序性能构成最大挑战的输入。如果您的程序执行几种操作，请确保对每种不同操作运行一些基准测试。'
- en: Elapsed time as measured by your wristwatch is probably precise enough to benchmark
    most programs. A 5 or 10% difference in performance, except in programs with very
    peculiar constraints, makes no practical difference to a program’s real-life usability.
    (Programs with hard real-time constraints are another matter, since they have
    needs very different from those of normal programs in most respects. )
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 用手表测量的经过时间可能足够精确地为大多数程序进行基准测试。在实际使用中，除了在极端约束下的程序外，性能上的5%或10%的差异几乎没有实际意义。（在硬实时约束的程序中情况不同，因为它们在大多数方面与普通程序的需求非常不同。）
- en: 'When you benchmark “toy” programs or snippets in order to help you choose an
    algorithm or data structure, you may need more precision: the timeit module of
    Python’s standard library (covered in [“The timeit module”](#the_timeit_module))
    is quite suitable for such tasks. The benchmarking discussed in this section is
    of a different kind: it is an approximation of real-life program operation for
    the sole purpose of checking whether the program’s performance on each task is
    acceptable, before embarking on profiling and other optimization activities. For
    such “system” benchmarking, a situation that approximates the program’s normal
    operating conditions is best, and high accuracy in timing is not all that important.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当您为了帮助选择算法或数据结构而对“玩具”程序或片段进行基准测试时，您可能需要更高的精度：Python标准库的timeit模块（在[“timeit模块”](#the_timeit_module)中介绍）非常适合这些任务。本节讨论的基准测试是一种不同类型的基准测试：它是对程序在每个任务上的性能是否可接受进行检查的近似实际程序操作的情况，然后进行性能分析和其他优化活动。对于这样的“系统”基准测试，最好是近似程序正常操作条件的情况，而时间的高精度并不是非常重要的。
- en: Large-Scale Optimization
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大规模优化
- en: 'The aspects of your program that are most important for performance are large-scale
    ones: your choice of overall architecture, algorithms, and data structures.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 对于性能最重要的方面是大规模的选择：整体架构、算法和数据结构。
- en: The performance issues that you must often take into account are those connected
    with the traditional big-O notation of computer science. Informally, if you call
    *N* the input size of an algorithm, big-O notation expresses algorithm performance,
    for large values of *N*, as proportional to some function of *N*. (In precise
    computer science lingo, this should be called big-Theta notation, but in real
    life, programmers always call it big-O, perhaps because an uppercase Theta looks
    a bit like an O with a dot in the center!)
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 您经常必须考虑的性能问题与传统计算机科学的大O符号有关。非正式地，如果您将*N*称为算法的输入大小，则大O符号表达算法性能，对于较大的*N*值，与*N*的某个函数成比例。
- en: An O(1) algorithm (also known as “constant time”) is one that takes a certain
    amount of time not growing with *N*. An O(*N*) algorithm (also known as “linear
    time”) is one where, for large enough *N*, handling twice as much data takes about
    twice as much time, three times as much data takes three times as much time, and
    so on, proportionally to *N*. An O(*N*²) algorithm (also known as a “quadratic
    time” algorithm) is one where, for large enough *N*, handling twice as much data
    takes about four times as much time, three times as much data takes nine times
    as much time, and so on, growing proportionally to *N* squared. Identical concepts
    and notation are used to describe a program’s consumption of memory (“space”)
    rather than of time.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: O(1)算法（也称为“常数时间”）是一种不随*N*增长而需要一定时间的算法。 O(*N*)算法（也称为“线性时间”）是一种对于足够大的*N*，处理两倍数据需要大约两倍时间，三倍数据需要三倍时间，依此类推，与*N*成比例增长的算法。
    O(*N*²)算法（也称为“二次时间”算法）是一种对于足够大的*N*，处理两倍数据需要大约四倍时间，三倍数据需要九倍时间，依此类推，与*N*的平方成比例增长的算法。相同的概念和符号用于描述程序对内存消耗（“空间”）而非时间的情况。
- en: 'To find more information on big-O notation, and about algorithms and their
    complexity, any good book about algorithms and data structures can help; we recommend
    Magnus Lie Hetland’s excellent book *Python Algorithms: Mastering Basic Algorithms
    in the Python Language*, 2nd edition (Apress).'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于大O符号、算法及其复杂性的信息，任何一本好的算法和数据结构书都可以帮助；我们推荐Magnus Lie Hetland的优秀著作《Python算法：精通Python语言中的基本算法》，第二版（Apress）。
- en: 'To understand the practical importance of big-O considerations in your programs,
    consider two different ways to accept all items from an input iterable and accumulate
    them into a list in reverse order:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解在程序中大O符号考虑的实际重要性，考虑两种不同的方式来接受输入可迭代对象中的所有项目，并将它们以相反顺序累积到一个列表中。
- en: '[PRE22]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We could express each of these functions more concisely, but the key difference
    is best appreciated by presenting the functions in these elementary terms. The
    function slow builds the result list by inserting each input item *before* all
    previously received ones. The function fast appends each input item *after* all
    previously received ones, then reverses the result list at the end. Intuitively,
    one might think that the final reversing represents extra work, and therefore
    slow should be faster than fast. But that’s not the way things work out.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更简洁地表达这些函数，但关键差异最好通过这些基本术语来理解。函数`slow`通过在每次接收到的输入项之前插入来构建结果列表。函数`fast`将每个输入项添加到先前接收到的所有项之后，然后在最后反转结果列表。直觉上，人们可能认为最后的反转代表了额外的工作，因此`slow`应该比`fast`更快。但事实并非如此。
- en: Each call to result.append takes roughly the same amount of time, independent
    of how many items are already in the list result, since there is (nearly) always
    a free slot for an extra item at the end of the list (in pedantic terms, append
    is *amortized* O(1), but we don’t cover amortization in this book). The **for**
    loop in the function fast executes *N* times to receive *N* items. Since each
    iteration of the loop takes a constant time, overall loop time is O(*N*). result.reverse
    also takes time O(*N*), as it is directly proportional to the total number of
    items. Thus, the total running time of fast is O(*N*). (If you don’t understand
    why a sum of two quantities, each O(*N*), is also O(*N*), consider that the sum
    of any two linear functions of *N* is also a linear function of *N*—and “being
    O(*N*)” has exactly the same meaning as “consuming an amount of time that is a
    linear function of *N*.”)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`result.append`花费的时间大致相同，与列表`result`中已有的项数量无关，因为列表末尾几乎总是有一个空位可以放置额外的项（严格来说，`append`的时间复杂度是*摊销*
    O(1)，但本书不涵盖摊销）。函数`fast`中的**for**循环执行*N*次以接收*N*个项。由于循环的每次迭代都需要恒定的时间，因此整个循环的时间复杂度是O(*N*)。`result.reverse`同样需要O(*N*)的时间，因为它与项的总数成正比。因此，函数`fast`的总运行时间是O(*N*)。（如果你不理解为什么两个时间复杂度均为O(*N*)的量的和也是O(*N*)，可以考虑任何两个*N*的线性函数的和也是*N*的线性函数——“是O(*N*)”的含义与“消耗与*N*成线性关系的时间量”完全相同。）
- en: On the other hand, each call to result.insert makes space at slot 0 for the
    new item to insert, moving all items that are already in list result forward one
    slot. This takes time proportional to the number of items already in the list.
    The overall amount of time to receive *N* items is therefore proportional to 1+2+3+...*N*-1,
    a sum whose value is O(*N*²). Therefore, the total running time of slow is O(*N*²).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，每次调用`result.insert`都为要插入的新项在索引0处创建空间，将已在列表`result`中的所有项向前移动一个位置。这需要的时间与列表中已有的项数量成正比。因此，接收*N*个项的总时间与1+2+3+...*N*-1成正比，其值为O(*N*²)。因此，函数`slow`的总运行时间是O(*N*²)。
- en: 'It’s almost always worth replacing an O(*N*²) solution with an O(*N*) one,
    unless you can somehow assign rigorous small limits to input size *N*. If *N*
    can grow without very strict bounds, the O(*N*²) solution turns out to be disastrously
    slower than the O(*N*) one for large values of *N*, no matter what the proportionality
    constants in each case may be (and no matter what profiling tells you). Unless
    you have other O(*N*²) or even worse bottlenecks elsewhere that you can’t eliminate,
    a part of the program that is O(*N*²) turns into the program’s bottleneck, dominating
    runtime for large values of *N*. Do yourself a favor and watch out for the big-O:
    all other performance issues, in comparison, are usually almost insignificant.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎总是值得将O(*N*²)的解决方案替换为O(*N*)的解决方案，除非你可以以某种方式为输入大小*N*分配严格的小限制。如果*N*可以无严格边界地增长，那么对于大的*N*值，O(*N*²)的解决方案将比O(*N*)的解决方案慢得令人难以置信（无论各自情况中的比例常数是多少（以及无论分析器告诉你的是什么）。除非你无法消除其他地方的O(*N*²)或更差的瓶颈，否则程序中O(*N*²)部分将成为程序的瓶颈，在大的*N*值下支配运行时间。请自己做个好处，留意大O符号：与其他性能问题相比，通常几乎可以忽略不计。
- en: 'Incidentally, you can make the function fast even faster by expressing it in
    more idiomatic Python. Just replace the first two lines with the following single
    statement:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，你可以通过更具Python风格的表达方式使函数`fast`运行得更快。只需用以下单个语句替换前两行：
- en: '[PRE23]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This change does not affect fast’s big-O character (fast is still O(*N*) after
    the change), but does speed things up by a large constant factor.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这种改变不会影响`fast`的大O特性（改变后仍然是O(*N*)），但确实通过较大的常数因子加快了运行速度。
- en: Simple Is Better than Complex, and Usually Faster!
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单胜于复杂，通常也更快！
- en: More often than not, in Python, the simplest, clearest, most direct and idiomatic
    way to express something is also the fastest.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，表达某些内容的最简单、最清晰、最直接和最惯用的方式通常也是最快的。
- en: Choosing algorithms with good big-O performance is roughly the same task in
    Python as in any other language. You just need a few hints about the big-O performance
    of Python’s elementary building blocks, and we provide them in the following sections.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中选择具有良好大O性能的算法与在任何其他语言中大致相同。您只需了解Python的基本构建块的大O性能的一些提示，我们在以下各节中提供了这些提示。
- en: List operations
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表操作
- en: Python lists are internally implemented as *vectors* (also known as *dynamic
    arrays*), not as “*linked* lists.” This implementation choice determines the performance
    characteristics of Python lists, in big-O terms.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Python列表在内部实现为*vectors*（也称为*dynamic arrays*），而不是“*linked* lists”。这种实现选择在大O符号术语中决定了Python列表的性能特征。
- en: 'Chaining two lists *L1* and *L2*, of length *N1* and *N2* (i.e., *L1*+*L2*)
    is O(*N1*+*N2*). Multiplying a list *L* of length *N* by integer *M* (i.e., *L***M*)
    is O(*N***M*). Accessing or rebinding any list item is O(1). len() on a list is
    also O(1). Accessing any slice of length *M* is O(*M*). Rebinding a slice of length
    *M* with one of identical length is also O(*M*). Rebinding a slice of length *M1*
    with one of different length *M2* is O(*M1*+*M2*+*N1*), where *N1* is the number
    of items *after* the slice in the target list (so, length-changing slice rebindings
    are relatively cheap when they occur at the *end* of a list, but costlier when
    they occur at the *beginning* or around the middle of a long list). If you need
    first-in, first-out operations, a list is probably not the fastest data structure
    for the purpose: instead, try the type collections.deque, covered in [“deque”](ch08.xhtml#deque).'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个长度为*N1*和*N2*的列表*L1*和*L2*链接（即*L1*+*L2*）的复杂度是O(*N1*+*N2*)。将长度为*N*的列表*L*乘以整数*M*（即*L***M*）的复杂度是O(*N***M*)。访问或重新绑定任何列表项的复杂度是O(1)。对列表进行len()操作也是O(1)。访问长度为*M*的任何切片的复杂度是O(*M*)。将长度相同的切片重新绑定为另一个长度相同的切片的复杂度也是O(*M*)。将长度为*M1*的切片重新绑定为长度不同的*M2*的切片的复杂度是O(*M1*+*M2*+*N1*)，其中*N1*是目标列表中切片之后的项数（因此，在列表末尾进行长度更改的切片重新绑定相对较便宜，但在列表开始或长列表中间进行则更昂贵）。如果需要先进先出操作，列表可能不是用于此目的的最快数据结构：相反，请尝试类型collections.deque，详见[“deque”](ch08.xhtml#deque)。
- en: Most list methods, as shown in [Table 3-5](ch03.xhtml#list_object_methods),
    are equivalent to slice rebindings and have equivalent big-O performance. The
    methods count, index, remove, and reverse, and the operator **in**, are O(*N*).
    The method sort is generally O(*N* log *N*), but sort is highly optimized^([9](ch17.xhtml#ch01fn133))
    to be O(*N*) in some important special cases, such as when the list is already
    sorted or reverse-sorted except for a few items. range(a, b, c) is O(1), but looping
    on all items of the result is O((b - a) // c).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数列表方法，如[表 3-5](ch03.xhtml#list_object_methods)所示，等效于切片重新绑定，并具有相同的大O性能。方法count、index、remove和reverse，以及运算符**in**，都是O(*N*)。方法sort通常是O(*N*
    log *N*)，但在某些重要的特殊情况下，例如列表已经排序或反向排序除了少数项外，sort被高度优化^([9](ch17.xhtml#ch01fn133))为O(*N*)。range(a,
    b, c)是O(1)，但在结果的所有项上循环的复杂度是O((b - a) // c)。
- en: String operations
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串操作
- en: Most methods on a string of length *N* (be it bytes or Unicode) are O(*N*).
    len(*astring*) is O(1). The fastest way to produce a copy of a string with transliterations
    and/or removal of specified characters is the string’s method translate. The single
    most practically important big-O consideration involving strings is covered in
    [“Building up a string from pieces”](#building_up_a_string_from_pieces).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 对于长度为*N*的字符串（无论是字节还是Unicode），大多数方法的复杂度都是O(*N*)。len(*astring*)的复杂度是O(1)。产生具有字符转换和/或删除指定字符的副本的最快方法是字符串的方法translate。涉及字符串的单个最实用的大O考虑在[“Building
    up a string from pieces”](#building_up_a_string_from_pieces)中有所涵盖。
- en: Dictionary operations
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典操作
- en: Python dicts are implemented with hash tables. This implementation choice determines
    all the performance characteristics of Python dictionaries, in big-O terms.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Python的字典是用哈希表实现的。这种实现选择在大O符号术语中决定了Python字典的所有性能特征。
- en: Accessing, rebinding, adding, or removing a dictionary item is O(1), as are
    the methods get, setdefault, and popitem, and the operator **in**. *d1*.update(*d*2)
    is O(len(*d*2)). len(*adict*) is O(1). The methods keys, items, and values are
    O(1), but looping on all items of the iterators those methods return is O(*N*),
    as is looping directly on a dict.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 访问、重新绑定、添加或移除字典项的操作是O(1)，get、setdefault和popitem方法以及操作符**in**也是如此。*d1*.update(*d*2)是O(len(*d*2))。len(*adict*)是O(1)。方法keys、items和values是O(1)，但直接在字典上循环遍历所有项的开销为O(*N*)。
- en: When the keys in a dictionary are instances of classes that define __hash__
    and equality comparison methods, dictionary performance is of course affected
    by those methods. The performance indications presented in this section hold when
    hashing and equality comparison on keys are O(1).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当字典中的键是定义了__hash__和相等比较方法的类的实例时，字典的性能当然会受到这些方法的影响。本节中提供的性能指标在键的哈希和相等比较为O(1)时成立。
- en: Set operations
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合操作
- en: Python sets, like dicts, are implemented with hash tables. All performance characteristics
    of sets are, in big-O terms, the same as for dictionaries.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Python集合像字典一样是用哈希表实现的。集合的所有性能特征在大O术语中与字典相同。
- en: Adding or removing an item in a set is O(1), as is the operator **in**. len(*aset*)
    is O(1). Looping on a set is O(*N*). When the items in a set are instances of
    classes that define __hash__ and equality comparison methods, set performance
    is of course affected by those methods. The performance hints presented in this
    section hold when hashing and equality comparison on items are O(1).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在集合中添加或移除项目的操作是O(1)，同样的是操作符**in**。len(*aset*)是O(1)。在集合中的项目是定义了__hash__和相等比较方法的类的实例时，集合的性能当然会受到这些方法的影响。本节中提供的性能提示在项目的哈希和相等比较为O(1)时成立。
- en: Summary of big-O times for operations on Python built-in types
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python内置类型的操作的大O时间摘要
- en: 'Let *L* be any list, *T* any string (str or bytes), *D* any dict, *S* any set
    (with, say, numbers as items, just for the purpose of ensuring O(1) hashing and
    comparison), and *x* any number (ditto):'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让*L*是任何列表，*T*是任何字符串（str或bytes），*D*是任何字典，*S*是任何集合（例如，具有数字作为项，仅用于确保O(1)的哈希和比较），*x*是任何数字（同上）：
- en: O(1)
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: O(1)
- en: len(*L*), len(T), len(*D*), len(S), *L*[i], *T*[i], *D*[i], del D[i], **if**
    *x* **in** D, **if** *x* **in** *S*, *S*.add(*x*), *S*.remove(*x*), appends or
    removals to/from the very right end of *L*
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: len(*L*)，len(*T*)，len(*D*)，len(*S*)，*L*[i]，*T*[i]，*D*[i]，del D[i]，**if** *x*
    **in** D，**if** *x* **in** *S*，*S*.add(*x*)，*S*.remove(*x*)，对*L*最右端的附加或移除
- en: O(N)
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: O(N)
- en: Loops on *L*, *T*, *D*, *S*, general appends or removals to/from *L* (except
    at the very right end), all methods on *T*, **if** *x* **in** *L*, **if** *x*
    **in** *T*, most methods on *L*, all shallow copies
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在*L*、*T*、*D*、*S*上的循环，对*L*进行一般的附加或移除（除非在最右端），*T*的所有方法，**if** *x* **in** *L*，**if**
    *x* **in** *T*，*L*的大多数方法，所有浅复制
- en: O(N log N)
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: O(N log N)
- en: '*L*.sort(), mostly (but O(*N*) if *L* is already nearly sorted or reverse sorted)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '*L*.sort()，大多数情况下是O(*N*)（但如果*L*已经几乎排序或逆序排序，则为O(*N*)）'
- en: Profiling
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能分析
- en: 'As mentioned at the start of this section, most programs have *hot spots*:
    relatively small regions of source code that account for most of the time elapsed
    during a program run. Don’t try to guess where your program’s hot spots are: a
    programmer’s intuition is notoriously unreliable in this field. Instead, use the
    Python standard library module profile to collect profile data over one or more
    runs of your program, with known inputs. Then use the module pstats to collate,
    interpret, and display that profile data.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节开头所述，大多数程序有*热点*：源代码中相对较小的区域占据了程序运行时间的大部分。不要试图猜测程序的热点在哪里：程序员在这一领域的直觉经常不可靠。相反，使用Python标准库模块profile在一个或多个运行中收集已知输入的配置文件数据。然后使用模块pstats来整理、解释和显示该配置文件数据。
- en: To gain accuracy, you can calibrate the Python profiler for your machine (i.e.,
    determine what overhead profiling incurs on that machine). The profile module
    can then subtract this overhead from the times it measures, making profile data
    you collect closer to reality. The standard library module cProfile has similar
    functionality to profile; cProfile is preferable, since it’s faster, which means
    it imposes less overhead.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高准确性，您可以校准Python分析器以适合您的机器（即确定分析在该机器上产生的开销）。然后，profile模块可以从它测量的时间中减去这些开销，使您收集的配置文件数据更接近实际情况。标准库模块cProfile具有与profile类似的功能；cProfile更可取，因为它更快，这意味着它施加的开销更小。
- en: There are also many third-party profiling tools worth considering, such as [pyinstrument](https://oreil.ly/taMU6)
    and [Eliot](https://oreil.ly/CCbtt); an [excellent article](https://oreil.ly/UWs_3)
    by Itamar Turner-Trauring explains the basics and advantages of each of these
    tools.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多值得考虑的第三方分析工具，例如[pyinstrument](https://oreil.ly/taMU6)和[Eliot](https://oreil.ly/CCbtt)；Itamar
    Turner-Trauring 的一篇[优秀文章](https://oreil.ly/UWs_3)解释了这些工具的基础和优点。
- en: The profile module
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: profile 模块
- en: 'The profile module supplies one often-used function:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: profile 模块提供了一个经常使用的函数：
- en: '| run | run(*code*, filename=**None**) *code* is a string that is usable with
    exec, normally a call to the main function of the program you’re profiling. filename
    is the path of a file that run creates or rewrites with profile data. Usually,
    you call run a few times, specifying different filenames and different arguments
    to your program’s main function, in order to exercise various program parts in
    proportion to your expectations about their use “in real life.” Then, you use
    the pstats module to display collated results across the various runs.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '| run | run(*code*, filename=**None**) *code* 是一个字符串，可用于 exec，通常是对你要分析的程序的主函数的调用。filename
    是 run 创建或重写带有分析数据的文件的路径。通常情况下，您会多次调用 run，指定不同的文件名和程序主函数的不同参数，以便按照您对它们在实际使用中的预期使用比例来执行各种程序部分。然后，您使用
    pstats 模块来显示跨各种运行的汇总结果。'
- en: 'You may call run without a filename to get a summary report, similar to the
    one the pstats module provides, on standard output. However, this approach gives
    you no control over the output format, nor any way to consolidate several runs
    into one report. In practice, you should rarely use this feature: it’s best to
    collect profile data into files, then use pstats.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以调用 run 而不使用文件名来获取摘要报告，类似于 pstats 模块提供的报告，在标准输出上。但是，这种方法无法控制输出格式，也无法将几次运行合并到一个报告中。在实践中，您应该很少使用此功能：最好将分析数据收集到文件中，然后使用
    pstats。
- en: The profile module also supplies the class Profile (discussed briefly in the
    next section). By instantiating Profile directly, you can access advanced functionality,
    such as the ability to run a command in specified local and global dictionaries.
    We do not cover such advanced functionality of the class profile.Profile further
    in this book. |
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: profile 模块还提供了类 Profile（在下一节中简要讨论）。通过直接实例化 Profile，您可以访问高级功能，例如在指定的本地和全局字典中运行命令的能力。在本书中，我们不再深入讨论类
    profile.Profile 的这种高级功能。
- en: Calibration
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 校准
- en: 'To calibrate profile for your machine, use the class Profile, which profile
    supplies and internally uses in the function run. An instance *p* of Profile supplies
    one method you use for calibration:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 要为您的机器校准 profile，请使用 profile 提供并在函数 run 中内部使用的类 Profile。Profile 的一个实例 *p* 提供了一个用于校准的方法：
- en: '| calibrate | *p*.calibrate(*N*) Loops *N* times, then returns a number that
    is the profiling overhead per call on your machine. *N* must be large if your
    machine is fast. Call *p*.calibrate(10000) a few times and check that the various
    numbers it returns are close to each other, then pick the smallest one of them.
    If the numbers vary a lot, try again with a larger value of *N*.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '| calibrate | *p*.calibrate(*N*) 循环 *N* 次，然后返回一个数字，该数字是您机器上每次调用的分析开销。如果您的机器速度很快，则
    *N* 必须很大。多次调用 *p*.calibrate(10000)，并检查它返回的各种数字是否接近，然后选择其中最小的一个。如果数字变化很大，请尝试使用更大的
    *N* 再次尝试。'
- en: 'The calibration procedure can be time-consuming. However, you need to perform
    it only once, repeating it only when you make changes that could alter your machine’s
    characteristics, such as applying patches to your operating system, adding memory,
    or changing your Python version. Once you know your machine’s overhead, you can
    tell profile about it each time you import it, right before using profile.run.
    The simplest way to do this is as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 校准过程可能会耗时。但是，您只需要执行一次，只有在进行可能改变机器特性的更改时才需要重复执行，例如对操作系统应用补丁、添加内存或更改 Python 版本。一旦您了解了机器的开销，您就可以在每次导入它之前，就在使用
    profile.run 之前告诉 profile 关于它。做到这一点的最简单方法如下：
- en: '[PRE24]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The pstats module
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pstats 模块
- en: 'The pstats module supplies a single class, Stats, to analyze, consolidate,
    and report on the profile data contained in one or more files written by the function
    profile.run. Its constructor has the signature:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: pstats 模块提供了一个单一的类，Stats，用于分析、 consoliidate 和报告由函数 profile.run 写入的一个或多个文件中包含的分析数据。它的构造函数具有如下签名：
- en: '| Stats | **class** Stats(*filename*, **filenames*, stream*=sys.stdout*) Instantiates
    Stats with one or more filenames of files of profile data written by the function
    profile.run, with profiling output sent to stream. |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| Stats | **class** Stats(*filename*, **filenames*, stream*=sys.stdout*) 使用由函数
    profile.run 写入的一个或多个配置数据文件的文件名来实例化 Stats，并将分析输出发送到 stream。 |'
- en: An instance *s* of the class Stats provides methods to add profile data and
    sort and output results. Each method returns *s*, so you can chain many calls
    in the same expression. *s*’s main methods are listed in [Table 17-8](#methods_of_an_instance_s_of_class_stats).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 类 Stats 的实例 *s* 提供了添加配置数据、排序和输出结果的方法。每个方法返回 *s*，因此可以在同一表达式中链式调用多个方法。*s* 的主要方法列在
    [Table 17-8](#methods_of_an_instance_s_of_class_stats) 中。
- en: Table 17-8\. *Methods of an instance s of class Stats*
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: Table 17-8\. *类 Stats 实例 s 的方法*
- en: '| add | add(*filename*) Adds another file of profile data to the set that *s*
    is holding for analysis. |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| add | add(*filename*) 将另一个配置数据文件添加到 *s* 用于分析的集合中。 |'
- en: '| pr⁠i⁠n⁠t⁠_​c⁠a⁠l⁠lees, pri⁠n⁠t⁠_​c⁠a⁠l⁠lers | print_callees(**restrictions*),
    print_callers(**restrictions*)'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '| pr⁠i⁠n⁠t⁠_​c⁠a⁠l⁠lees, pri⁠n⁠t⁠_​c⁠a⁠l⁠lers | print_callees(**restrictions*),
    print_callers(**restrictions*)'
- en: 'Outputs the list of functions in *s*’s profile data, sorted according to the
    latest call to *s*.sort_stats and subject to given restrictions, if any. You can
    call each printing method with zero or more *restrictions*, to be applied one
    after the other, in order, to reduce the number of output lines. A restriction
    that is an int *n* limits the output to the first *n* lines. A restriction that
    is a float *f* between 0.0 and 1.0 limits the output to a fraction *f* of the
    lines. A restriction that is a string is compiled as a regular expression pattern
    (covered in [“Regular Expressions and the re Module”](ch10.xhtml#regular_expressions_and_the_re_module));
    only lines that satisfy a search method call on the regular expression are output.
    Restrictions are cumulative. For example, *s*.print_callees(10, 0.5) outputs the
    first 5 lines (half of 10). Restrictions apply only after the summary and header
    lines: the summary and header lines are output unconditionally.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 输出 *s* 配置数据中函数列表，根据最新调用 *s*.sort_stats 进行排序并受到给定限制的影响。您可以用零个或多个 *restrictions*
    调用每个打印方法，以依次应用它们，以减少输出行数。整数 *n* 限制输出为前 *n* 行。介于 0.0 和 1.0 之间的浮点数 *f* 限制输出为行数的
    *f* 分数。字符串限制被编译为正则表达式模式（详见 [“正则表达式和 re 模块”](ch10.xhtml#regular_expressions_and_the_re_module)）；只输出满足正则表达式搜索方法调用的行。限制是累积的。例如，*s*.print_callees(10,
    0.5) 输出前 5 行（10 的一半）。摘要和标头行只有在无条件情况下输出后才适用限制。
- en: Each function *f* in the output is accompanied by the list of *f*’s callers
    (functions that called *f*) or *f*’s callees (functions that *f* called), according
    to the name of the method. |
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中的每个函数 *f* 都附带 *f* 的调用者（调用 *f* 的函数）或 *f* 的被调用者（*f* 调用的函数），具体取决于方法的名称。 |
- en: '| print_stats | print_stats(**restrictions*) Outputs statistics about *s*’s
    profile data, sorted according to the latest call to *s*.sort_stats and subject
    to given restrictions, if any, as covered in print_callees and print_callers,
    above. After a few summary lines (date and time on which profile data was collected,
    number of function calls, and sort criteria used), the output—absent restrictions—is
    one line per function, with six fields per line, labeled in a header line. print_stats
    outputs the following fields for each function *f*:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '| print_stats | print_stats(**restrictions*) 输出关于 *s* 的配置数据统计，根据最新调用 *s*.sort_stats
    进行排序并受到给定限制的影响（如果有的话），详见 print_callees 和 print_callers。在几行摘要（收集配置数据的日期和时间、函数调用数以及使用的排序标准）之后，输出结果（无限制）为每个函数一行，每行有六个字段，由标头行标记。对于每个函数
    *f*，print_stats 输出以下字段：'
- en: Total number of calls to *f*
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 *f* 的总次数
- en: Total time spent in *f*, exclusive of other functions that *f* called
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*f* 的累计时间，不包括 *f* 调用的其他函数'
- en: Total time per call to *f* (i.e., field 2 divided by field 1)
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*f* 的每次调用所花费的总时间（即字段 2 除以字段 1）'
- en: Cumulative time spent in *f*, and all functions directly or indirectly called
    from *f*
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*f* 所花费的累计时间，以及直接或间接调用 *f* 的所有函数'
- en: Cumulative time per call to *f* (i.e., field 4 divided by field 1)
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次调用 *f* 的累计时间（即字段 4 除以字段 1）
- en: The name of function *f*
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数 *f* 的名称
- en: '|'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| sort_stats | sort_stats(**keys*) Gives one or more keys on which to sort
    future output. Each key is either a string or a member of the enum pstats.SortKey.
    The sort is descending for keys that indicate times or numbers, and alphabetical
    for key ''nfl''. The most frequently used keys when calling sort_stats are:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '| sort_stats | sort_stats(**keys*) 给出一个或多个用于将未来输出排序的键。每个键可以是一个字符串或者枚举 pstats.SortKey
    的成员。对于表示时间或数字的键，排序是降序的；对于键 ''nfl''，则按字母顺序排序。在调用 sort_stats 时最常用的键包括：'
- en: SortKey.CALLS or 'calls'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: SortKey.CALLS 或 'calls'
- en: Number of calls to the function (like field 1 in the print_stats output)
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用的次数（例如 print_stats 输出中的字段 1）
- en: SortKey.CUMULATIVE or 'cumulative'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: SortKey.CUMULATIVE 或 'cumulative'
- en: Cumulative time spent in the function and all functions it called (like field
    4 in the print_stats output)
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 函数及其调用的累计时间（例如 print_stats 输出中的字段 4）
- en: SortKey.NFL or 'nfl'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: SortKey.NFL 或 'nfl'
- en: Name of the function, its module, and the line number of the function in its
    file (like field 6 in the print_stats output)
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的名称、其模块以及函数在其文件中的行号（例如 print_stats 输出中的字段 6）
- en: SortKey.TIME or 'time'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: SortKey.TIME 或 'time'
- en: Total time spent in the function itself, exclusive of functions it called (like
    field 2 in the print_stats output)
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 函数本身消耗的总时间，不包括调用的函数（例如 print_stats 输出中的字段 2）
- en: '|'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| strip_dirs | strip_dirs() Alters *s* by stripping directory names from all
    module names to make future output more compact. *s* is unsorted after *s*.strip_dirs,
    and therefore you normally call *s*.sort_stats right after calling *s*.strip_dirs.
    |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| strip_dirs | strip_dirs() 通过剥离所有模块名称中的目录名来修改 *s*，以使未来输出更加紧凑。在 *s*.strip_dirs
    之后，*s* 是未排序的，因此通常在调用 *s*.strip_dirs 后立即调用 *s*.sort_stats。 |'
- en: Small-Scale Optimization
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小规模优化
- en: Fine-tuning of program operations is rarely important. It may make a small but
    meaningful difference in some particularly hot spot, but it is hardly ever a decisive
    factor. And yet, fine-tuning—in the pursuit of mostly irrelevant microefficiencies—is
    where a programmer’s instincts are likely to lead them. It is in good part because
    of this that most optimization is premature and best avoided. The most that can
    be said in favor of fine-tuning is that, if one idiom is *always* speedier than
    another when the difference is measurable, then it’s worth your while to get into
    the habit of always using the speedier way.^([10](ch17.xhtml#ch01fn134))
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 程序操作的微调很少重要。它可能在一些特别热点中带来小但有意义的差异，但几乎从未是决定性因素。然而，微调——在追求大多数无关紧要的微小效率时——是程序员本能的结果。这在很大程度上是因为大多数优化是过早的，并且最好避免。对微调的最有利论点是，如果一种习惯性的表达方式总是比另一种更快，当差异可测量时，那么你值得养成总是使用更快方法的习惯。^([10](ch17.xhtml#ch01fn134))
- en: 'In Python, if you do what comes naturally, choosing simplicity and elegance,
    you typically end up with code that has good performance and is clear and maintainable.
    In other words, *let Python do the work*: when Python provides a simple, direct
    way to perform a task, chances are that it’s also the fastest way. In a few cases,
    an approach that may not be intuitively preferable still offers performance advantages,
    as discussed in the rest of this section.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，如果你顺其自然，选择简单和优雅，你通常会得到性能良好、清晰易懂且可维护的代码。换句话说，*让 Python 来做工作*：当 Python
    提供一种简单直接的方法来执行任务时，很可能也是最快的方式。在少数情况下，即使可能不是直观上首选的方法，在性能上也有优势，正如本节其余部分所讨论的。
- en: 'The simplest optimization is to run your Python programs using **python -O**
    or **-OO**. **-OO** makes little difference to performance compared to **-O**
    but may save some memory, as it removes docstrings from the bytecode, and memory
    is sometimes (indirectly) a performance bottleneck. The optimizer is not powerful
    in current releases of Python, but it may gain you performance advantages on the
    order of 5-10% (and potentially larger if you make use of **assert** statements
    and **if** __debug__: guards, as suggested in [“The assert Statement”](ch06.xhtml#the_assert_statement)).
    The best aspect of **-O** is that it costs nothing—as long as your optimization
    isn’t premature, of course (don’t bother using **-O** on a program you’re still
    developing).'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '最简单的优化是使用 **python -O** 或 **-OO** 运行你的 Python 程序。**-OO** 与 **-O** 相比在性能上几乎没有区别，但可能会节省一些内存，因为它从字节码中删除了文档字符串，而内存有时（间接地）是性能瓶颈。在当前
    Python 版本中，优化器并不强大，但如果你使用 **assert** 语句和 **if** __debug__: 保护（如 [“assert 语句”](ch06.xhtml#the_assert_statement)
    中建议的那样），它可能为你带来 5-10% 的性能优势（在某些情况下可能更大）。**-O** 的最大优点是它几乎不花费任何代价——当然前提是你的优化不是过早的（当你仍在开发中的程序不要使用
    **-O**）。'
- en: The timeit module
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: timeit 模块
- en: 'The standard library module timeit is handy for measuring the precise performance
    of specific snippets of code. You can import timeit to use timeit’s functionality
    in your programs, but the simplest and most normal use is from the command line:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库模块 `timeit` 对于测量特定代码片段的精确性能非常方便。您可以导入 `timeit` 以在程序中使用其功能，但最简单和最常见的用法是从命令行：
- en: '[PRE25]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The “setup statement” is executed only once, to set things up; the “statements
    to be timed” are executed repeatedly, to accurately measure the average time they
    take.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: “设置语句”仅执行一次，用于设置事物；“要计时的语句”重复执行，以准确测量它们的平均时间。
- en: 'For example, say you’re wondering about the performance of x=x+1 versus x+=1,
    where x is an int. At a command prompt, you can easily try:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想知道 `x=x+1` 与 `x+=1` 的性能差异，其中 x 是一个整数。在命令提示符下，你可以轻松尝试：
- en: '[PRE26]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: and find out that performance is, for all intents and purposes, the same in
    both cases (a tiny difference, such as the 2.5% in this case, is best regarded
    as “noise”).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 并发现两种情况下的性能在所有实际情况下都几乎相同（在本例中为 2.5% 的微小差异最好视为“噪音”）。
- en: Memoizing
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记忆化
- en: '*Memoizing* is the technique of saving values returned from a function that
    is called repeatedly with the same argument values. When the function is called
    with arguments that have not been seen before, a memoizing function computes the
    result, and then saves the arguments used to call it and the corresponding result
    in a cache. When the function is called again later with the same arguments, the
    function just looks up the computed value in the cache instead of rerunning the
    function calculation logic. In this way, the calculation is performed just once
    for any particular argument or arguments.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '*记忆化* 是一种技术，用于保存重复使用相同参数值调用的函数返回值。当使用之前未见过的参数调用函数时，记忆化函数计算结果，然后在缓存中保存用于调用它的参数及其相应的结果。当以后再次使用相同参数调用函数时，函数只需在缓存中查找计算出的值，而不需要重新运行函数计算逻辑。通过这种方式，对于任何特定的参数或参数，计算仅执行一次。'
- en: 'Here is an example of a function for calculating the sine of a value given
    in degrees:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个计算给定角度值正弦值的函数示例：
- en: '[PRE30]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If we determined that sin_degrees was a bottleneck, and was being repeatedly
    called with the same values for x (such as the integer values from 0 to 360, as
    you might use when displaying an analog clock), we could add a memoizing cache:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确定 `sin_degrees` 是一个瓶颈，并且在调用时 `x` 的值重复出现（比如在显示模拟时钟时使用的 0 到 360 的整数值），我们可以添加一个记忆缓存：
- en: '[PRE31]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: For functions that take multiple arguments, the tuple of argument values would
    be used for the cache key.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接受多个参数的函数，参数值的元组将用作缓存键。
- en: 'We defined *_cached_values* outside the function, so that it is not reset each
    time we call the function. To explicitly associate the cache with the function,
    we can utilize Python’s object model, which allows us to treat functions as objects
    and assign attributes to them:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数外部定义了 `_cached_values`，这样每次调用函数时它不会被重置。为了明确地将缓存与函数关联起来，我们可以利用Python的对象模型，该模型允许我们将函数视为对象并为其分配属性：
- en: '[PRE32]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Caching is a classic approach to gain performance at the expense of using memory
    (the *time–memory trade-off*). The cache in this example is unbounded, so, as
    sin_degrees is called with many different values of x, the cache will continue
    to grow, consuming more and more program memory. Caches are often configured with
    an *eviction policy*, which determines when values can be removed from the cache.
    Removing the oldest cached value is a common eviction policy. Since Python keeps
    dict entries in insertion order, the “oldest” key will be the first one found
    if we iterate over the dict:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是通过使用内存来获得性能的经典方法（时间-内存折衷）。此示例中的缓存是无界限的，因此，当 `sin_degrees` 以许多不同的 `x` 值被调用时，缓存将继续增长，消耗越来越多的程序内存。缓存通常配置有“驱逐策略”，该策略确定何时可以从缓存中删除值。删除最旧的缓存值是一种常见的驱逐策略。由于Python将字典条目保持按插入顺序，如果我们迭代字典，那么“最旧”的键将是我们找到的第一个键：
- en: '[PRE33]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can see that this starts to complicate the code, with the original logic
    for computing the sine of a value given in degrees hidden inside all the caching
    logic. The Python stdlib module functools includes caching decorators lru_cache,
    3.9+ cache, and 3.8+ cached_property to perform memoization cleanly. For example:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，这开始使代码复杂化，原始计算给定角度值正弦值的逻辑隐藏在所有缓存逻辑内部。Python标准库模块 `functools` 包括缓存装饰器 `lru_cache`、3.9+
    `cache` 和 3.8+ `cached_property`，以清晰地执行记忆化。例如：
- en: '[PRE34]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The signatures for these decorators are described in detail in [“The functools
    Module”](ch08.xhtml#the_functools_module).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这些装饰器的签名在[“functools模块”](ch08.xhtml#the_functools_module)中有详细描述。
- en: Caching Floating-Point Values Can Give Undesirable Behavior
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存浮点数值可能会导致不良行为
- en: As was described in [“Floating-Point Values”](ch16.xhtml#floating_point_values),
    comparing float values for equality can return **False** when the values are actually
    within some expected tolerance for being considered equal. With an unbounded cache,
    a cache containing float keys may grow unexpectedly large by caching multiple
    values that differ only in the 18th decimal place. For a bounded cache, many float
    keys that are very nearly equal may cause the unwanted eviction of other values
    that are significantly different.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[“浮点数值”](ch16.xhtml#floating_point_values)中所描述的，当浮点值的比较相等时，实际上可能返回**False**，因为这些值在某些期望的公差范围内被认为是相等的。对于无界缓存，包含浮点键的缓存可能因缓存仅在第18位小数处不同的多个值而意外增长。对于有界缓存，许多几乎相等的浮点键可能导致意外地驱逐其他明显不同的值。
- en: All the cache techniques listed here use equality matching, so code for memoizing
    a function with one or more float arguments should take extra steps to cache rounded
    values, or use math.isclose for matching.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出的所有缓存技术都使用相等匹配，因此使用一个或多个浮点参数缓存函数的代码应采取额外的步骤来缓存四舍五入的值，或者使用math.isclose进行匹配。
- en: Precomputing a lookup table
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预计算查找表
- en: 'In some cases, you can predict all the values that your code will use when
    calling a particular function. This allows you to precompute the values and save
    them in a lookup table. For example, in our application that is going to compute
    the sin function for the integer degree values 0 to 360, we can perform this work
    just once at program startup and keep the results in a Python dict:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可以预测在调用特定函数时代码将使用的所有值。这使您可以预先计算这些值并将它们保存在查找表中。例如，在我们的应用程序中，将为整数度值0到360计算sin函数的工作可以在程序启动时仅执行一次，并将结果保存在Python字典中：
- en: '[PRE35]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Binding sin_degrees to the _sin_degrees_lookup dict’s get method means the rest
    of our program can still call sin_degrees as a function, but now the value retrieval
    occurs at the speed of a dict lookup, with no additional function overhead.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 将sin_degrees绑定到_sin_degrees_lookup字典的get方法意味着我们程序的其余部分仍然可以将sin_degrees作为函数调用，但现在值检索速度等于字典查找速度，没有额外的函数开销。
- en: Building up a string from pieces
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过片段构建字符串
- en: The single Python “anti-idiom” that is most likely to damage your program’s
    performance, to the point that you should *never* use it, is to build up a large
    string from pieces by looping on string concatenation statements such as big_string
    += piece. Python strings are immutable, so each such concatenation means that
    Python must free the *M* bytes previously allocated for big_string, and allocate
    and fill *M* + *K* bytes for the new version. Doing this repeatedly in a loop,
    you end up with roughly O(*N*²) performance, where *N* is the total number of
    characters. More often than not, getting O(*N*²) performance where O(*N*) is easily
    available is a disaster.^([11](ch17.xhtml#ch01fn135)) On some platforms, things
    may be even bleaker due to memory fragmentation effects caused by freeing many
    areas of progressively larger sizes.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 单个Python“反模式”，最有可能损害程序性能的是，通过循环在大字符串上逐片构建字符串，例如big_string += piece。Python字符串是不可变的，因此每次这样的连接意味着Python必须释放之前为big_string分配的*M*字节，并为新版本分配和填充*M*
    + *K*字节。在循环中重复执行此操作，最终会导致大约O(*N*²)的性能，其中*N*是总字符数。通常情况下，如果可以轻松获得O(*N*)的性能而获得O(*N*²)的性能，那么会是一场灾难。^([11](ch17.xhtml#ch01fn135))
    在某些平台上，由于释放许多逐渐变大的区域而导致的内存碎片效应，情况可能更为糟糕。
- en: 'To achieve O(*N*) performance, accumulate intermediate pieces in a list, rather
    than building up the string piece by piece. Lists, unlike strings, are mutable,
    so appending to a list is O(1) (amortized). Change each occurrence of big_string
    += piece into temp_list.append(piece). Then, when you’re done accumulating, use
    the following code to build your desired string result in O(*N*) time:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现O(*N*)性能，累积中间片段使用列表，而不是逐片构建字符串。列表与字符串不同，是可变的，因此向列表附加是O(1)（摊销）。将每个big_string
    += piece的出现更改为temp_list.append(piece)。然后，在累积完成时，使用以下代码在O(*N*)时间内构建所需的字符串结果：
- en: '[PRE36]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Using a list comprehension, generator expression, or other direct means (such
    as a call to map, or use of the standard library module itertools) to build temp_list
    may often offer further (substantial, but not big-O) optimization over repeated
    calls to temp_list.append. Other O(*N*) ways to build up big strings, which a
    few Python programmers find more readable, are to concatenate the pieces to an
    instance of array.array('u') with the array’s extend method, use a bytearray,
    or write the pieces to an instance of io.TextIO or io.BytesIO.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表推导、生成器表达式或其他直接方法（如调用 map，或使用标准库模块 itertools）来构建 temp_list，通常可以进一步（重要但不是大
    O）优化，而不是重复调用 temp_list.append。其他构建大字符串的 O(*N*) 方法，一些 Python 程序员认为更可读的方法是将这些片段连接到
    array.array('u') 的实例上，使用 array 的 extend 方法，使用 bytearray，或将片段写入 io.TextIO 或 io.BytesIO
    的实例。
- en: In the special case where you want to output the resulting string, you may gain
    a further small slice of performance by using writelines on temp_list (never building
    big_string in memory). When feasible (i.e., when you have the output file object
    open and available in the loop, and the file is buffered), it’s just as effective
    to perform a write call for each piece, without any accumulation.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在特殊情况下，如果你想要输出结果字符串，通过在 temp_list 上使用 writelines（而不是在内存中构建 big_string），可能会获得进一步的小幅性能提升。如果可行（即在循环中已打开并可用输出文件对象，并且文件已缓冲），每个片段执行一次写入调用同样有效，而不需要任何累积。
- en: 'Although not nearly as crucial as += on a big string in a loop, another case
    where removing string concatenation may give a slight performance improvement
    is when you’re concatenating several values in an expression:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不像在循环中对大字符串使用 += 那样关键，但另一种情况是，移除字符串串联可能会在表达式中连接多个值时带来轻微的性能提升：
- en: '[PRE37]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Formatting strings using the format method or f-strings (discussed in [Chapter 8](ch08.xhtml#core_built_ins_and_standard_library_mod))
    is often a good performance choice, as well as being more idiomatic and thereby
    clearer than concatenation approaches. On a sample run of the preceding example,
    the format approach is more than twice as fast as the (perhaps more intuitive)
    concatenation, and the f-string approach is more than twice as fast as format.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 使用格式化方法或 f-string 来格式化字符串（在 [第 8 章](ch08.xhtml#core_built_ins_and_standard_library_mod)
    讨论过）通常是一个很好的性能选择，而且比串联方法更符合惯用法，因此更清晰。在前面示例的样本运行中，格式化方法比串联方法快两倍以上（也许更直观的串联方法），而
    f-string 方法比格式化方法更快两倍以上。
- en: Searching and sorting
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索和排序
- en: The operator **in**, the most natural tool for searching, is O(1) when the righthand-side
    operand is a set or dict, but O(*N*) when the righthand-side operand is a string,
    list, or tuple. If you must perform many such checks on a container, you’re *much*
    better off using a set or dict, rather than a list or tuple, as the container.
    Python sets and dicts are highly optimized for searching and fetching items by
    key. Building the set or dict from other containers, however, is O(*N*), so for
    this crucial optimization to be worthwhile, you must be able to hold on to the
    set or dict over several searches, possibly altering it apace as the underlying
    sequence changes.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符 **in** 在搜索时是最自然的工具，当右操作数是集合或字典时是 O(1)，但当右操作数是字符串、列表或元组时是 O(*N*)。如果你必须在容器上执行许多此类检查，则最好使用集合或字典，而不是列表或元组，作为容器。Python
    的集合和字典对于搜索和按键提取项进行了高度优化。但是，从其他容器构建集合或字典是 O(*N*) 的，因此为了使这种关键的优化值得，你必须能够在多个搜索中保留集合或字典，并在底层序列变化时可能进行适当的更改。
- en: 'The sort method of Python lists is also a highly optimized and sophisticated
    tool. You can rely on sort’s performance. Most functions and methods in the standard
    library that perform comparisons accept a key argument to determine how, exactly,
    to compare items. You provide a key function, which computes a key value for each
    element in the list. The list elements are sorted by their key values. For instance,
    you might write a key function for sorting objects based on an attribute *attr*
    as **lambda** ob: ob.*attr*, or one for sorting dicts by dict key ''*attr*'' as
    **lambda** d: d[''*attr*'']. (The attrgetter and itemgetter methods of the operator
    module are useful alternatives to these simple key functions; they’re clearer
    and sharper than **lambda** and offer performance gains as well.)'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 'Python 列表的排序方法也是一个高度优化和复杂的工具。你可以依赖排序的性能。标准库中的大多数执行比较的函数和方法都接受键参数，以确定如何精确比较项目。你可以提供一个键函数，为列表中的每个元素计算一个键值。列表元素按其键值排序。例如，你可以编写一个按属性
    *attr* 排序对象的键函数，如 **lambda** ob: ob.*attr*，或者按字典键 ''*attr*'' 排序字典的键函数，如 **lambda**
    d: d[''*attr*'']。 （operator 模块的 attrgetter 和 itemgetter 方法是这些简单键函数的有用替代品；它们比 **lambda**
    更清晰和更精确，并且还提供了性能增益。）'
- en: Older versions of Python used a cmp function, which would take list elements
    in pairs (*A*, *B*) and return -1, 0, or 1 for each pair depending on which of
    *A* < *B*, *A* == *B*, or *A* > *B* is true. Sorting using a cmp function is very
    slow, as it may have to compare every element to every other element (potentially
    O(*N*²) performance). The sort function in current Python versions no longer accepts
    a cmp function argument. If you are migrating ancient code and only have a function
    suitable as a cmp argument, you can use functools.cmp_to_key to build from it
    a key function suitable to pass as the new key argument.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的旧版本使用了一个 cmp 函数，该函数会获取列表元素对（*A*, *B*）并根据 *A* < *B*、*A* == *B* 或 *A*
    > *B* 的情况返回 -1、0 或 1。使用 cmp 函数进行排序非常慢，因为它可能需要比较每个元素和其他每个元素（可能是 O(*N*²) 的性能）。在当前的
    Python 版本中，排序函数不再接受 cmp 函数参数。如果你正在迁移古老的代码，并且只有一个适合作为 cmp 参数的函数，你可以使用 `functools.cmp_to_key`
    来构建一个适合作为新 key 参数传递的键函数。
- en: However, several functions in the module heapq, covered in [“The heapq Module”](ch08.xhtml#the_heapq_module),
    do not accept a key argument. In such cases, you can use the DSU idiom, covered
    in [“The Decorate–Sort–Undecorate Idiom”](ch08.xhtml#the_decorateen_dashsorten_dashundecorat).
    (Heaps are well worth keeping in mind, since in some cases they can save you from
    having to perform sorting on all of your data.)
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在模块堆 `heapq` 中，涵盖了 [“堆模块”](ch08.xhtml#the_heapq_module) ，有几个函数不接受键参数。在这种情况下，可以使用
    DSU 惯用法，详见 [“装饰-排序-去装饰惯用法”](ch08.xhtml#the_decorateen_dashsorten_dashundecorat)
    。（在某些情况下，堆非常值得注意，因为它们可以帮助你避免对所有数据进行排序。）
- en: Avoid exec and from ... import *
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免使用 exec 和 from ... import *。
- en: 'Code in a function runs faster than code at the top level in a module, because
    access to a function’s local variables is faster than access to globals. If a
    function contains an exec without explicit dicts, however, the function slows
    down. The presence of such an exec forces the Python compiler to avoid the modest
    but important optimization it normally performs regarding access to local variables,
    since the exec might alter the function’s namespace. A **from** statement of the
    form:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中的代码比模块顶层的代码运行得更快，因为访问函数的局部变量比访问全局变量更快。然而，如果函数包含一个没有显式字典的 exec，那么函数会变慢。这样的
    exec 的存在迫使 Python 编译器避免它通常执行的关于访问局部变量的轻微但重要的优化，因为 exec 可能会改变函数的命名空间。形如：
- en: '[PRE38]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: wastes performance too, since it also can alter a function’s namespace unpredictably,
    and therefore inhibits Python’s local-variable optimization.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 还浪费性能，因为它也可能无法预测地改变函数的命名空间，并因此抑制 Python 的局部变量优化。
- en: exec itself is also quite slow, and even more so if you apply it to a string
    of source code rather than to a code object. By far the best approach—for performance,
    for correctness, and for clarity—is to avoid exec altogether. It’s most often
    possible to find better (faster, more robust, and clearer) solutions. If you *must*
    use exec, *always* use it with explicit dicts, although avoiding exec altogether
    is *far* better, if at all feasible. If you need to exec a dynamically obtained
    string more than once, compile the string just once and then repeatedly exec the
    resulting code object.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec` 本身也非常慢，如果应用于源代码字符串而不是代码对象，则更是如此。在性能、正确性和清晰度方面，避免使用 `exec` 是迄今为止最好的方法。通常可以找到更好的（更快、更健壮和更清晰）解决方案。如果必须使用
    `exec`，则始终使用显式字典，虽然完全避免使用 `exec` 是更好的选择。如果需要多次执行动态获取的字符串，则应该先编译该字符串，然后重复执行生成的代码对象。'
- en: eval works on expressions, not on statements; therefore, while still slow, it
    avoids some of the worst performance impacts of exec. With eval, too, you’re best
    advised to use explicit dicts. As with exec, if you need multiple evaluations
    of the same dynamically obtained string, compile the string once and then repeatedly
    eval the resulting code object. Avoiding eval altogether is even better.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval` 适用于表达式而非语句；因此，虽然它仍然很慢，但避免了 `exec` 的最糟糕的性能影响。对于 `eval`，最好使用显式字典。与 `exec`
    一样，如果需要多次评估同一动态获取的字符串，应该先编译该字符串，然后重复使用 `eval` 生成的代码对象。完全避免使用 `eval` 更好。'
- en: See [“Dynamic Execution and exec”](ch14.xhtml#dynamic_execution_and_exec) for
    more details and advice about exec, eval, and compile.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 `exec`、`eval` 和 `compile` 的细节和建议，请参见[“动态执行和 exec”](ch14.xhtml#dynamic_execution_and_exec)。
- en: Short-circuiting of Boolean expressions
  id: totrans-427
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔表达式的短路计算
- en: Python evaluates Boolean expressions from left to right according to the precedence
    of the operations **not**, **and**, and **or**. When, from evaluating just the
    leading terms, Python can determine that the overall expression must be **True**
    or **False**, it skips the rest of the expression. This feature is known as *short-circuiting*,
    so called because Python bypasses unneeded processing the same way an electrical
    short bypasses parts of an electrical circuit.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: Python 根据操作符 **not**、**and** 和 **or** 的优先级，从左到右逐一评估布尔表达式。当仅仅通过评估前导项就能确定整体表达式为
    **True** 或 **False** 时，Python 将跳过剩余部分。这个特性被称为 *短路计算*，因为 Python 跳过不必要的处理，就像电气短路绕过电路的部分一样。
- en: 'In this example, both conditions must be **True** to continue:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，两个条件都必须为 **True** 才能继续执行：
- en: '[PRE39]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When fast_function is going to return **False**, it’s faster to evaluate it
    first, potentially avoiding the call to slow_function altogether:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `fast_function` 准备返回 **False** 时，首先评估它可能会更快，从而避免完全调用 `slow_function`。
- en: '[PRE40]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This optimization also applies when the operator is **or**, when either case
    must be **True** to continue: when fast_function returns **True**, Python skips
    slow_function completely.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作符是 **or** 时，也适用这种优化，只要其中一个条件为 **True** 就继续执行：当 `fast_function` 返回 **True**
    时，Python 完全跳过 `slow_function`。
- en: You can optimize these expressions by considering the order of the expressions’
    operators and terms, and order them so that Python evaluates the faster subexpressions
    first.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过考虑表达式操作符和项的顺序来优化这些表达式，让 Python 首先评估更快的子表达式。
- en: Short-Circuiting May Bypass Needed Functions
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 短路计算可能绕过所需的函数
- en: In the preceding examples, when slow_function performs some important “side
    effect” behavior (such as logging to an audit file, or notifying an administrator
    of a system condition), short-circuiting may unexpectedly skip that behavior.
    Take care when including necessary behavior as part of a Boolean expression, and
    do not overoptimize and remove important functionality.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，当 `slow_function` 执行一些重要的“副作用”行为（比如记录到审计文件或者通知系统管理员某个条件），短路计算可能会意外地跳过这些行为。在将必要行为包含在布尔表达式中时要小心，不要过度优化或者移除重要的功能。
- en: Short-circuiting of iterators
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代器的短路计算
- en: 'Similarly to short-circuiting in Boolean expressions, you can short-circuit
    the evaluation of values in an iterator. Python’s built-in functions all, any,
    and next return after finding the first item in the iterator that meets the given
    condition, without generating further values:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于布尔表达式的短路计算，你也可以在迭代器中短路计算值的评估。Python 的内置函数 `all`、`any` 和 `next` 在找到满足给定条件的第一项后立即返回，而不会生成更多的值：
- en: '[PRE41]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Your code gains an added advantage when the iterator is specifically a generator,
    as shown in all three of these cases. When the sequence of items is expensive
    to produce (as might be the case with records fetched from a database, for example),
    retrieving those items with a generator and short-circuiting to retrieve only
    the minimum needed can provide significant performance benefits.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 当迭代器特别是生成器时，你的代码将获得额外的优势，如这三种情况所示。当项目序列生成成本高昂（例如从数据库提取的记录），使用生成器检索这些项目，并短路以仅检索所需的最小值，可以带来显著的性能优势。
- en: Optimizing loops
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化循环
- en: 'Most of your program’s bottlenecks will be in loops, particularly nested loops,
    because loop bodies execute repeatedly. Python does not implicitly perform any
    *code hoisting*: if you have any code inside a loop that you could execute just
    once by hoisting it out of the loop, and the loop is a bottleneck, hoist the code
    out yourself. Sometimes the presence of code to hoist may not be immediately obvious:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分程序的瓶颈将出现在循环中，特别是嵌套循环中，因为循环体重复执行。Python 不会自动执行任何 *代码提升*：如果你有任何代码在循环内部，通过提升它们出循环以减少执行次数，而循环是一个瓶颈，那么你应该自己提升代码。有时，代码提升的必要性可能不是显而易见的：
- en: '[PRE42]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In this case, the code that faster hoists out of the loop is the attribute
    lookup anobject.amethod. slower repeats the lookup every time, while faster performs
    it just once. The two functions are not 100% equivalent: it is (barely) conceivable
    that executing amethod might cause such changes on anobject that the next lookup
    for the same named attribute fetches a different method object. This is part of
    why Python doesn’t perform such optimizations itself. In practice, such subtle,
    obscure, and tricky cases happen very rarely; it’s almost invariably safe to perform
    such optimizations yourself, to squeeze the last drop of performance out of some
    bottleneck.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，更快地提升出循环的代码是属性查找 anobject.amethod。 slower 每次重复查找，而 faster 只执行一次。这两个函数并不完全相同：可以（勉强）想象执行
    amethod 可能会导致 anobject 上的更改，使得下一个查找同名属性的对象检索到不同的方法对象。这也是为什么 Python 自身不执行此类优化的部分原因。实际上，这类微妙、隐晦且棘手的情况很少发生；你几乎可以肯定地自己执行这些优化，以从某些瓶颈中挤出最后一丝性能。
- en: 'Python is faster with local variables than with global ones. If a loop repeatedly
    accesses a global whose value does not change between iterations, you can “cache”
    the value in a local variable, and access that instead. This also applies to built-ins:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: Python 使用局部变量比全局变量更快。如果一个循环反复访问一个在迭代之间不会改变值的全局变量，你可以在局部变量中“缓存”该值，并访问它。这也适用于内置函数：
- en: '[PRE43]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, the speedup is very modest.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，加速效果非常有限。
- en: 'Do not cache **None**, **True**, or **False**. Those constants are keywords:
    no further optimization is needed.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 不要缓存 **None**、**True** 或 **False**。这些常量是关键字：不需要进一步优化。
- en: List comprehensions and generator expressions can be faster than loops, and,
    sometimes, so can map and filter. For optimization purposes, try changing loops
    into list comprehensions, generator expressions, or perhaps map and filter calls,
    where feasible. The performance advantage of map and filter is nullified, and
    worse, if you have to use a **lambda** or an extra level of function call. Only
    when the argument to map or filter is a built-in function, or a function you’d
    have to call anyway even from an explicit loop, list comprehension, or generator
    expression, do you stand to gain some tiny speedup.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导式和生成器表达式可能比循环更快，有时 map 和 filter 也是如此。为了优化，请尝试将循环转换为列表推导式、生成器表达式或者可能的 map
    和 filter 调用。如果必须使用 **lambda** 或者额外的函数调用，那么 map 和 filter 的性能优势将被抵消，甚至更差。只有当 map
    或 filter 的参数是内置函数，或者是你必须从显式循环、列表推导式或生成器表达式中调用的函数时，才有可能获得一些微小的加速。
- en: 'The loops that you can replace most naturally with list comprehensions, or
    map and filter calls, are ones that build up a list by repeatedly calling append
    on the list. The following example shows this optimization in a microperformance
    benchmark script (the example includes a call to the the timeit convenience function
    repeat, which simply calls timeit.timeit the specified number of times):'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用列表推导式、map 和 filter 调用最自然地替换的循环是那些通过重复调用列表的 append 来构建列表的循环。以下示例展示了这种优化在一个微性能基准测试脚本中（该示例包括对
    timeit 便捷函数 repeat 的调用，该函数只是调用 timeit.timeit 指定次数）：
- en: '[PRE44]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As we reported in the previous edition of this book (using a different set
    of test parameters):'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书的上一版中报道的（使用不同的测试参数）：
- en: Running this example in v2 on an old laptop shows that fast takes about 0.36
    seconds, middling 0.43 seconds, and slow 0.77 seconds. In other words, on that
    machine, slow (the loop of append method calls) is about 80 percent slower than
    middling (the single map call), and middling, in turn, is about 20 percent slower
    than fast (the list comprehension).
  id: totrans-453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在旧笔记本电脑上运行此示例 v2 显示，快函数大约需要 0.36 秒，中等函数需要 0.43 秒，慢函数需要 0.77 秒。换句话说，在该设备上，慢函数（追加方法调用的循环）比中等函数（单个映射调用）慢约
    80%，而中等函数反过来比快函数（列表推导式）慢约 20%。
- en: ''
  id: totrans-454
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The list comprehension is the most direct way to express the task being microbenchmarked
    in this example, so, not surprisingly, it’s also fastest—about two times faster
    than the loop of append method calls.
  id: totrans-455
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列表推导式是在本例中微基准化任务的最直接方式，因此毫不奇怪，它也是最快的——大约比使用追加方法调用的循环快两倍。
- en: At that time, using Python 2.7, there was a clear advantage to using the middling
    function over slow, and a modest speed increase resulted from using the fast function
    over middling. For the versions covered in this edition, the improvement of fast
    over middling is much less, if any. Of greater interest is that the slow function
    is now starting to approach the performance of the optimized functions. Also,
    it is easy to see the progressive performance improvements in successive versions
    of Python, especially Python 3.11 (see [Figure 17-3](#performance_of_the_example_on_various_p)).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 当时，使用 Python 2.7 时，使用中等函数而不是慢函数具有明显优势，并且使用快函数而不是中等函数会带来适度的速度提升。对于本版本涵盖的情况，快函数相对于中等函数的改进要少得多，如果有的话。更有趣的是，慢函数现在开始接近优化函数的性能。此外，可以看到在连续版本的
    Python 中逐步的性能改进，特别是 Python 3.11（见[图 17-3](#performance_of_the_example_on_various_p)）。
- en: The clear lesson is that performance tuning and optimization measures should
    be revisited when upgrading to newer Python versions.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 明显的教训是，在升级到较新的 Python 版本时，应重新审视性能调优和优化措施。
- en: '*![Performance of the example on various Python versions](assets/pns4_1703.png)*'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '*![在各种 Python 版本上的示例性能](assets/pns4_1703.png)*'
- en: Figure 17-3\. *Performance of the example on various Python versions*
  id: totrans-459
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 17-3\. *在各种 Python 版本上的示例性能*
- en: Using multiprocessing for heavy CPU work
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于重型 CPU 工作的多处理
- en: If you have heavily CPU-bound processing that can be done in independent pieces,
    then one important way to optimize is to use multiprocessing, as described in
    [Chapter 15](ch15.xhtml#concurrency_threads_and_processes). You should also consider
    whether using one of the numeric packages described in [Chapter 16](ch16.xhtml#numeric_processing),
    capable of applying vector processing to large data sets, is applicable.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有大量可以在独立片段中完成的 CPU 密集型处理，则优化的一个重要方式是使用多处理，如[第 15 章](ch15.xhtml#concurrency_threads_and_processes)中所述。您还应考虑是否适用于应用于大数据集的数值处理的某个数值包，如[第
    16 章](ch16.xhtml#numeric_processing)中所述。
- en: Optimizing I/O
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化 I/O
- en: If your program does substantial amounts of I/O, it’s quite likely that performance
    bottlenecks are due to I/O, rather than to computation. Such programs are said
    to be I/O-bound, rather than CPU-bound. Your operating system tries to optimize
    I/O performance, but you can help it in a couple of ways.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的程序大量进行 I/O 操作，那么性能瓶颈很可能是由 I/O 而不是计算引起的。这类程序称为 I/O 限制而不是 CPU 限制。您的操作系统会尝试优化
    I/O 性能，但您可以通过几种方式来帮助它。
- en: 'From the point of view of a program’s convenience and simplicity, the ideal
    amount of data to read or write at a time is often small (one character or one
    line) or very large (an entire file at a time). That’s often fine: Python and
    your operating system work behind the scenes to let your program use convenient
    logical chunks for I/O, while arranging for physical I/O operations to use chunk
    sizes more attuned to performance. Reading and writing a whole file at a time
    is quite likely to be OK for performance as long as the file is not *very* large.
    Specifically, file-at-a-time I/O is fine as long as the file’s data fits very
    comfortably in physical RAM, leaving ample memory available for your program and
    operating system to perform whatever other tasks they’re doing at the same time.
    The hard problems of I/O-bound performance come with huge files.'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 从程序便利性和简单性的角度来看，一次读取或写入的理想数据量通常很小（一个字符或一行）或非常大（一次整个文件）。这通常没问题：Python 和您的操作系统在幕后工作，使您的程序可以使用方便的逻辑块进行I/O操作，同时安排物理I/O操作使用更适合性能的块大小。一次读取和写入整个文件在性能上通常是可以接受的，只要文件不是*非常*大。具体来说，每次整个文件的I/O操作都可以接受，只要文件的数据非常舒适地适合于物理RAM，留出充足的内存供您的程序和操作系统在执行其他任务时使用。I/O限制性能的难题通常出现在大文件时。
- en: 'If performance is an issue, *never* use a file’s readline method, which is
    limited in the amount of chunking and buffering it can perform. (Using writelines,
    on the other hand, causes no performance problems when that method is convenient
    for your program.) When reading a text file, loop directly on the file object
    to get one line at a time with best performance. If the file isn’t too huge, and
    so can conveniently fit in memory, time two versions of your program: one looping
    directly on the file object, the other reading the whole file into memory. Either
    may prove faster by a little.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 如果性能是一个问题，*绝对不要*使用文件的readline方法，因为它在执行分块和缓冲时有限制。相反，如果该方法对您的程序方便的话，使用writelines不会造成性能问题。当读取文本文件时，直接在文件对象上循环以获得最佳性能的一行数据。如果文件不太大，因此可以方便地放入内存中，请测试您的程序的两个版本的时间：一个直接在文件对象上循环，另一个将整个文件读入内存。任何一种方式都可能稍微快一些。
- en: For binary files, particularly large binary files whose contents you need just
    a part of on each given run of your program, the module mmap (covered in [“The
    mmap Module”](ch15.xhtml#the_mmap_module)) can sometimes help keep your program
    simple and boost performance.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 对于二进制文件，特别是那些每次运行程序时只需要其中一部分内容的大型二进制文件，模块mmap（在[“mmap模块”](ch15.xhtml#the_mmap_module)中介绍）有时可以帮助简化程序并提升性能。
- en: Making an I/O-bound program multithreaded sometimes affords substantial performance
    gains, if you can arrange your architecture accordingly. Start a few worker threads
    devoted to I/O, have the computational threads request I/O operations from the
    I/O threads via Queue instances, and post the request for each input operation
    as soon as you know you’ll eventually need that data. Performance increases only
    if there are other tasks your computational threads can perform while I/O threads
    are blocked waiting for data. You get better performance this way only if you
    can manage to overlap computation and waiting for data by having different threads
    do the computing and the waiting. (See [“Threads in Python”](ch15.xhtml#threads_in_python)
    for detailed coverage of Python threading and a suggested architecture.)
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 如果能够根据需要安排架构，使I/O限制的程序多线程化，有时会大幅提升性能。启动几个专注于I/O的工作线程，让计算线程通过队列实例请求I/O操作，并在确定最终需要数据时立即发布请求。仅当计算线程能够在I/O线程等待数据时执行其他任务时，性能才会提高。通过不同线程进行计算和等待数据，重叠计算和数据等待，才能以此方式获得更好的性能。（详见[“Python线程”](ch15.xhtml#threads_in_python)以及建议的架构的详细介绍。）
- en: On the other hand, a possibly even faster and more scalable approach is to eschew
    threads in favor of asynchronous (event-driven) architectures, as mentioned in
    [Chapter 15](ch15.xhtml#concurrency_threads_and_processes).
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，可能更快、更可扩展的方法是放弃线程，转而采用异步（事件驱动）架构，正如[第15章](ch15.xhtml#concurrency_threads_and_processes)中所提到的。
- en: ^([1](ch17.xhtml#ch01fn125-marker)) This issue is related to “technical debt”
    and other topics covered in the [“‘Good enough’ is good enough”](https://oreil.ly/LcncX)
    tech talk by one of this book’s authors (that author’s favorite tech talk out
    of the many he delivered!), excellently summarized and discussed by Martin Michlmayr
    on [LWN.net](https://oreil.ly/2REWD).
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch17.xhtml#ch01fn125-marker)) 这个问题与“技术债务”等主题有关，这些主题在本书的一位作者的[“好即是好”](https://oreil.ly/LcncX)技术演讲中有所涉及（该作者在众多演讲中最喜欢的一次！），由Martin
    Michlmayr在[LWN.net](https://oreil.ly/2REWD)上进行了精彩的总结和讨论。
- en: '^([2](ch17.xhtml#ch01fn126-marker)) The language used in this area is confused
    and confusing: terms like *dummies*, *fakes*, *spies*, *mocks*, *stubs*, and *test
    doubles* are utilized by different people to mean slightly different things. For
    an authoritative approach to terminology and concepts (though not the exact one
    we use), see the essay [“Mocks Aren’t Stubs”](https://oreil.ly/QaPs6) by Martin
    Fowler.'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch17.xhtml#ch01fn126-marker)) 在这个领域使用的语言是混乱而令人困惑的：像*dummies*, *fakes*,
    *spies*, *mocks*, *stubs*和*test doubles*这样的术语被不同的人用来表示略有不同的含义。对于术语和概念的权威性方法（虽然不是我们使用的确切方法），请参阅Martin
    Fowler的文章[“Mocks Aren't Stubs”](https://oreil.ly/QaPs6)。
- en: ^([3](ch17.xhtml#ch01fn127-marker)) That’s partly because the structure of the
    system tends to mirror the structure of the organization, per [Conway’s law](https://oreil.ly/7usV4).
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch17.xhtml#ch01fn127-marker)) 这部分原因是因为系统的结构往往反映了组织的结构，根据[康威定律](https://oreil.ly/7usV4)。
- en: '^([4](ch17.xhtml#ch01fn128-marker)) However, be sure you know exactly what
    you’re using doctest for in any given case: to quote Peter Norvig, writing precisely
    on this subject: “Know what you’re aiming for; if you aim at two targets at once
    you usually miss them both.”'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch17.xhtml#ch01fn128-marker)) 但是，请确保你确切地知道在任何给定情况下你正在使用doctest做什么：引用Peter
    Norvig，在这个主题上写得很精确：“知道你的目标是什么；如果你同时瞄准两个目标，你通常会两个都错过。”
- en: ^([5](ch17.xhtml#ch01fn129-marker)) When evaluating assert *a* == *b*, pytest
    interprets *a* as the observed value and *b* as the expected value (the reverse
    of unittest).
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch17.xhtml#ch01fn129-marker)) 在评估assert *a* == *b*时，pytest将*a*解释为观察到的值，将*b*解释为预期值（与unittest相反）。
- en: '^([6](ch17.xhtml#ch01fn130-marker)) “Oh, but I’ll only be running this code
    for a short time!” is *not* an excuse to get sloppy: the Russian proverb “nothing
    is more permanent than a temporary solution” is particularly applicable in software.
    All over the world, plenty of “temporary” code performing crucial tasks is over
    50 years old.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch17.xhtml#ch01fn130-marker)) “哦，但我只会运行这段代码很短的时间！”这不是草率行事的借口：俄罗斯谚语“没有比临时解决方案更持久的东西”在软件领域特别适用。全世界有很多“临时”的代码正在执行关键任务，但已经超过50年了。
- en: ^([7](ch17.xhtml#ch01fn131-marker)) A typical case of the [Pareto principle](https://oreil.ly/iJVCX)
    in action.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch17.xhtml#ch01fn131-marker)) 典型的[Pareto原则](https://oreil.ly/iJVCX)案例。
- en: ^([8](ch17.xhtml#ch01fn132-marker)) Per [Amdahl’s law](https://oreil.ly/e6PEg).
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch17.xhtml#ch01fn132-marker)) 根据[Amdahl定律](https://oreil.ly/e6PEg)。
- en: ^([9](ch17.xhtml#ch01fn133-marker)) Using the invented-for-Python [adaptive
    sorting](https://oreil.ly/BjZoM) algorithm [Timsort](https://oreil.ly/cFW7U).
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch17.xhtml#ch01fn133-marker)) 使用专为Python发明的[自适应排序](https://oreil.ly/BjZoM)算法[Timsort](https://oreil.ly/cFW7U)。
- en: ^([10](ch17.xhtml#ch01fn134-marker)) A once-slower idiom may be optimized in
    some future version of Python, so it’s worth redoing timeit measurements to check
    for this when you upgrade to newer versions of Python.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch17.xhtml#ch01fn134-marker)) 一种曾经较慢的习惯用法可能在未来的Python版本中被优化，因此在升级到较新版本的Python时重新进行timeit测量以检查这一点是值得的。
- en: ^([11](ch17.xhtml#ch01fn135-marker)) Even though current Python implementations
    bend over backward to help reduce the performance hit of this specific, terrible,
    but common anti-pattern, they can’t catch every occurrence, so don’t count on
    that!
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch17.xhtml#ch01fn135-marker)) 即使当前的Python实现竭尽全力帮助减少这种特定的、可怕的但常见的反模式的性能损失，它们也无法捕捉到每一种情况，所以不要指望它们！
