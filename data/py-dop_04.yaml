- en: Chapter 4\. Useful Linux Utilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章\. 有用的 Linux 实用工具
- en: 'The command line and its tooling were one of the main reasons Alfredo felt
    attached to Linux servers when he started his career. One of his first jobs as
    a system administrator in a medium-sized company involved taking care of everything
    that was Linux-related. The small IT department was focused on the Windows servers
    and desktops, and they thoroughly disliked using the command line. At one point,
    the IT manager told him that he understood graphical user interfaces (GUIs), installing
    utilities, and tooling in general to solve problems: *“I am not a coder, if it
    doesn’t exist as a GUI, I can’t use it,”* he said.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当他开始职业生涯时，命令行及其工具是 Alfredo 感到亲密的原因之一。在一家中型公司担任系统管理员时，他的第一份工作涉及管理一切与 Linux 相关的事务。小型
    IT 部门专注于 Windows 服务器和桌面系统，他们非常不喜欢使用命令行。有一次，IT 管理员告诉他，他了解图形用户界面（GUI）、安装实用工具以及一般工具来解决问题：*“我不是程序员，如果没有
    GUI，我就无法使用它。”*
- en: Alfredo was hired as a contractor to help out with the few Linux servers the
    company had. At the time, [Subversion (SVN) was all the rage for version control](https://subversion.apache.org),
    and the developers depended on this single SVN server to push their work. Instead
    of using the centralized identity server, provided by two *domain controllers*,
    it used a text-based authentication system that mapped a user to a hash representing
    the password. This meant that usernames didn’t necessarily map to those in the
    domain controller and that passwords could be anything. Often, a developer would
    ask to reset the password, and someone had to edit this text file with the hash.
    A project manager asked Alfredo to integrate the SVN authentication with the domain
    controller (Microsoft’s Active Directory). The first question he asked was why
    hadn’t the IT department done this already? *“They say it is not possible, but
    Alfredo, this is a lie, SVN can integrate with Active Directory.”*
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Alfredo 被聘为承包商，帮助公司管理几台 Linux 服务器。当时，[Subversion (SVN) 是版本控制的热门工具](https://subversion.apache.org)，开发人员依赖这一单一的
    SVN 服务器来推动他们的工作。与使用中心化身份服务器不同，由两个*域控制器*提供，它使用了一个基于文本的认证系统，将用户映射到代表密码的哈希值。这意味着用户名不一定映射到域控制器中的用户名，并且密码可以是任意的。通常情况下，开发人员会要求重置密码，然后有人必须编辑这个文本文件来更新哈希值。项目经理要求
    Alfredo 将 SVN 的认证整合到域控制器（微软的 Active Directory）中。他第一个问题是为什么 IT 部门之前没有做这件事？*“他们说这是不可能的，但是
    Alfredo，这是谎言，SVN 可以与 Active Directory 整合。”*
- en: 'He had never used an authentication service like Active Directory and barely
    understood SVN, but he was determined to make this work. Alfredo set out to read
    all about SVN and Active Directory, tinkered his way around a virtual machine
    with an SVN server running, and tried to get this authentication to work. It took
    about two weeks to read up on all the pieces involved and to get it to work. He
    succeeded in the end and was able to get this system into production. This felt
    incredibly powerful; he had acquired unique knowledge and was now ready to be
    fully in charge of this system. The IT manager, as well as the rest of the department,
    were ecstatic. Alfredo tried to share this newly acquired knowledge with others
    and was always met with an excuse: *“no time,”* *“too busy,”* *“other priorities,”*
    and *“perhaps some other time—maybe next week.”*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 他从未使用过像 Active Directory 这样的认证服务，对 SVN 的理解也很浅薄，但他决心要让这个工作成功。Alfredo 开始阅读关于 SVN
    和 Active Directory 的所有信息，利用一个运行 SVN 服务器的虚拟机进行尝试，并努力让这种认证机制工作起来。他花了大约两周时间研究所有相关的部分，并最终成功让它投入生产。这感觉非常强大；他掌握了独特的知识，现在完全可以负责这个系统。IT
    管理员以及整个部门都非常激动。Alfredo 尝试与他人分享这些新获得的知识，但总是遇到借口：*“没时间”，“太忙了”，“其他优先事项”，以及“也许下周吧。”*
- en: 'An apt description for technologists is: *knowledge workers*. Your curiosity
    and a never-ending pursuit of knowledge will continue to make you, and the environments
    you work on, much better. Don’t ever let a coworker (or a whole IT department,
    as in Alfredo’s case) be a deterrent for improving systems. If there is an opportunity
    to learn something new, jump on it! The worst that can happen is that you have
    acquired knowledge that perhaps won’t be used often, but on the other hand, might
    change your professional career.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 技术人员的一个恰当描述是：“知识工作者”。你的好奇心和对知识的不断追求将继续提升你以及你所工作的环境。永远不要让同事（或像阿尔弗雷多那样整个IT部门）成为改进系统的障碍。如果有学习新东西的机会，一定要抓住！最糟糕的情况是，你获得了也许不经常使用但却可能改变你职业生涯的知识。
- en: Linux does have desktop environments, but its real power comes from understanding
    and using the command line, and ultimately, by extending it. When there are no
    pre-made tools to solve a problem, seasoned DevOps people will craft their own.
    This notion of being able to come up with solutions by putting together the core
    pieces is incredibly powerful, and is what ultimately happened at that job where
    it felt productive to complete tasks without having to install off-the-shelf software
    to fix things.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Linux确实有桌面环境，但它真正的力量来自理解和使用命令行，最终，通过扩展它。当没有现成的工具解决问题时，经验丰富的DevOps人员将制定自己的解决方案。通过组合核心部件来提出解决方案的这种能力非常强大，最终在那个工作中感到有效率是可以完成任务而不必安装现成软件来修复问题。
- en: This chapter will go through some common patterns in the shell and will include
    some useful Python commands that should enhance the ability to interact with a
    machine. We find that creating aliases and *one-liners* is the most fun one can
    have at work, and sometimes they are so useful that they end up as plug-ins or
    standalone pieces of software.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍Shell中的一些常见模式，并包括一些有用的Python命令，这些命令应该增强与机器交互的能力。我们发现创建别名和“一行代码”是工作中最有趣的事情之一，有时它们非常有用，最终成为插件或独立的软件。
- en: Disk Utilities
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 磁盘工具
- en: There are several different utilities that you can use to get information about
    devices in a system. A lot of them have feature overlap, and some have an interactive
    session to deal with disk operations, such as `fdisk` and `parted`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中有几种不同的工具可用于获取设备信息。其中许多具有功能重叠，一些具有交互式会话以处理磁盘操作，如`fdisk`和`parted`。
- en: It is *crucial* to have a good grasp on disk utilities, not only to retrieve
    information and manipulate partitions, but also to accurately measure performance.
    Performance, in particular, is one of the tough things to accomplish correctly.
    The best answer to the question *How do I measure the performance of a device?*
    is *It depends*, because it is difficult to do for the specific metric one is
    looking for.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 精通磁盘工具非常重要，不仅可以检索信息和操作分区，还能准确地衡量性能。特别是性能衡量是一个难点。对于“如何衡量设备性能？”这个问题，最好的答案是“取决于”，因为很难为特定的度量标准做到这一点。
- en: Measuring Performance
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能测量
- en: If we had to work in an isolated environment with a server that doesn’t have
    access to the internet or that we don’t control and therefore can’t install packages,
    we would have to say that the `dd` tool (which should be readily available on
    all major Linux distributions) would help provide some answers. If at all possible,
    pair it with `iostat` to isolate the command that hammers the device versus the
    one that gets the report.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不得不在一个无法访问互联网或我们无法控制并因此无法安装软件包的服务器上工作，那么我们将不得不说`dd`工具（应该在所有主要的Linux发行版上都可以找到）将帮助提供一些答案。如果可能的话，可以与`iostat`配合使用，以区分是哪个命令在占用设备，哪个在获取报告。
- en: As a seasoned performance engineer once said, it depends on what is measured
    and how. For example `dd` is single threaded and has limitations, such as being
    unable to do multiple random reads and writes; it also measures throughput and
    not input/output operations per second (IOPS). What are you measuring? Throughput
    or IOPS?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如一位经验丰富的性能工程师所说，这取决于测量的对象和方式。例如，`dd`是单线程的并且有其限制，比如不能进行多个随机读写；它还测量吞吐量而不是每秒的输入/输出操作数（IOPS）。你在测量什么？吞吐量还是IOPS？
- en: Caution
  id: totrans-13
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A word of warning on these examples. They can destroy your system, don’t follow
    them blindly, and make sure to use devices that can get erased.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些示例，需要提个醒。它们可能会破坏你的系统，请不要盲目跟随，并确保使用可以被清除的设备。
- en: 'This simple one-liner will run `dd` to get some numbers of a brand-new device
    (*/dev/sdc* in this case):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的单行命令将运行 `dd` 来获取一个全新设备（在本例中为 */dev/sdc*）的一些数据：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It writes 10 records of 100 megabytes at a rate of 1 GB/s. This is throughput.
    An easy way to get IOPS with `dd` is to use `iostat`. In this example, `iostat`
    runs only on the device getting hammered with `dd`, with the `-d` flag only to
    give the device information, and with an interval of one second:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 它以1GB/s的速率写入100兆字节的10条记录。这是吞吐量。通过 `dd` 获得IOPS的简单方法是使用 `iostat`。在此示例中，`iostat`
    仅在受 `dd` 猛烈攻击的设备上运行，使用 `-d` 标志仅提供设备信息，并以一秒的间隔运行：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `iostat` output will repeat itself for every second until a `Ctrl-C` is
    issued to cancel the operation. The second column in the output is `tps`, which
    stands for transactions per second and is the same as IOPS. A nicer way to visualize
    the output, which avoids the clutter that a repeating command produces, is to
    clear the terminal on each run:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`iostat` 输出将每秒重复一次，直到发出 `Ctrl-C` 取消操作。输出中的第二列是 `tps`，代表每秒事务数，等同于IOPS。一个更好的可视化输出的方法是在每次运行时清除终端：'
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Accurate tests with fio
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用fio进行准确的测试
- en: If `dd` and `iostat` aren’t sufficient, the most commonly used tool for performance
    testing is `fio`. It can help clarify the performance behavior of a device in
    a read-heavy or write-heavy environment (and even adjust the percentages of reads
    versus writes).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `dd` 和 `iostat` 不足够，性能测试中最常用的工具是 `fio`。它可以帮助澄清设备在读取或写入密集环境中的性能行为（甚至可以调整读取与写入的百分比）。
- en: 'The output from `fio` is quite verbose. The example below trims it to emphasize
    the IOPS found on both read and write operations:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`fio` 的输出非常详细。下面的示例修剪了输出以突出显示读写操作的IOPS：'
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The flags used in the example name the *job* `sdc-performance`, point to the
    */dev/sdc* device directly (will require superuser permissions), use the native
    Linux asynchronous I/O library, set the `iodepth` to `1` (number of sequential
    I/O requests to be sent at a time), and define random read and write operations
    of 32 kilobytes for the buffer size using buffered I/O (can be set to 1 to use
    unbuffered I/O) on a 64-megabyte file. Quite the lengthy command here!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中使用的标志命名了*作业* `sdc-performance`，直接指向 */dev/sdc* 设备（将需要超级用户权限），使用本地Linux异步I/O库，将
    `iodepth` 设置为 `1`（一次发送的顺序I/O请求数），并定义了32千字节的缓冲区大小的随机读写操作，使用了带缓冲的I/O（可以设置为1以使用无缓冲I/O），作用于64兆字节文件。这是一个非常长的命令！
- en: The `fio` tool has a tremendous number of additional options that can help with
    most any case where accurate IOPS measurements are needed. For example, it can
    span the test across many devices at once, do some *I/O warm up*, and even set
    I/O thresholds for the test if a defined limit shouldn’t be surpassed. Finally,
    the many options in the command line can be configured with INI-style files so
    that the execution of jobs can be scripted nicely.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`fio` 工具有大量额外选项，可以帮助几乎所有需要准确IOPS测量的情况。例如，它可以跨多个设备进行测试，进行一些*I/O预热*，甚至为测试设置I/O阈值，以防超出定义的限制。最后，命令行中的许多选项可以使用INI风格的文件进行配置，从而可以很好地脚本化作业执行。'
- en: Partitions
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分区
- en: We tend to default to `fdisk` with its interactive session to create partitions,
    but in some cases, `fdisk` doesn’t work well, such as with large partitions (two
    terabytes or larger). In those cases, your fallback should be to use `parted`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们倾向于使用交互式会话的 `fdisk` 来创建分区，但在某些情况下，如大分区（两TB或更大），`fdisk` 可能不太适用。在这些情况下，您应该使用
    `parted` 作为备选方案。
- en: 'A quick interactive session shows how to create a primary partition with `fdisk`,
    with the default start value and four gibibytes of size. At the end the `w` key
    is sent to *write* the changes:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个快速的交互式会话展示如何使用 `fdisk` 创建一个带有默认起始值和四吉比字节大小的主分区。最后使用 `w` 键来*写入*更改：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`parted` accomplishes the same, but with a different interface:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`parted` 以不同的界面实现相同功能：'
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the end, you quit with the `q` key. For programmatic creation of partitions
    on the command line without any interactive prompts, you accomplish the same result
    with a couple of commands:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用几个命令实现在命令行上以编程方式创建分区，而无需任何交互提示：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Retrieving Specific Device Information
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索特定设备信息
- en: 'Sometimes when specific information for a device is needed, either `lsblk`
    or `blkid` are well suited. `fdisk` doesn’t like to work without superuser permissions.
    Here `fdisk` lists the information about the */dev/sda* device:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候需要设备的特定信息时，要么使用`lsblk`要么使用`blkid`更合适。`fdisk`在没有超级用户权限时无法正常工作。在这里，`fdisk`列出了有关*/dev/sda*设备的信息：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`blkid` is a bit similar in that it wants superuser permissions as well:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`blkid`类似，它也需要超级用户权限：'
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`lsblk` allows to get information without higher permissions, and provides
    the same informational output regardless:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`lsblk`允许获取信息而无需更高的权限，并提供相同的信息输出：'
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This command, which uses the `-p` flag for low-level device probing, is *very
    thorough* and should give you good enough information for a device:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令使用`-p`标志进行低级设备探测，*非常彻底*，应该会为设备提供足够好的信息：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`lsblk` has some default properties to look for:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`lsblk`有一些默认属性要查找：'
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'But it also allows you to set specific flags to request a particular property:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 但它还允许您设置特定的标志以请求特定的属性：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To access a property in this way makes it easy to script and even consume from
    the Python side of things.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式访问属性使得编写脚本和从Python端访问变得容易。
- en: Network Utilities
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络工具
- en: Network tooling keeps improving as more and more servers need to be interconnected.
    A lot of the utilities in this section cover useful one-liners like Secure Shell
    (SSH) tunneling, but some others go into the details of testing network performance,
    such as using the Apache Bench tool.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 随着越来越多的服务器需要互联，网络工具不断改进。本节中的许多实用程序涵盖了像安全外壳（SSH）隧道这样的有用单行命令，但有些则深入到测试网络性能的细节，例如使用Apache
    Bench工具。
- en: SSH Tunneling
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SSH隧道
- en: Have you ever tried to reach an HTTP service that runs on a remote server that
    is not accessible except via SSH? This situation occurs when the HTTP service
    is enabled but not needed publicly. The last time we saw this happen was when
    a production instance of [RabbitMQ](https://www.rabbitmq.com) had the management
    plug-in enabled, which starts an HTTP service on port 15672\. The service isn’t
    exposed and with good reason; there is no need to have it publicly available since
    it is rarely used, and besides, one can use SSH’s tunneling capabilities.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否尝试过访问在远程服务器上运行但除了通过SSH无法访问的HTTP服务？当HTTP服务已启用但不需要公开访问时会出现这种情况。我们上次看到这种情况发生是在生产实例的[RabbitMQ](https://www.rabbitmq.com)上启用了管理插件，它在端口15672上启动了HTTP服务。服务没有暴露出来是有道理的；没有必要公开它，因为它很少被使用，而且可以使用SSH的隧道功能。
- en: 'This works by creating an SSH connection with the remote server and then forwarding
    the remote port (15672, in my case) to a local port on the originating machine.
    The remote machine has a custom SSH port, which complicates the command slightly.
    This is is how it looks:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过创建与远程服务器的SSH连接，然后将远程端口（在我的情况下是15672）转发到源机器上的本地端口来工作。远程机器具有自定义的SSH端口，这略微复杂化了命令。命令如下所示：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There are three flags, three numbers, and two addresses. Let’s dissect the command
    to make what is going on here much clearer. The `-L` flag is the one that signals
    that we want forwarding enabled and a local port (9998) to bind to a remote port
    (RabbitMQ’s default of 15672). Next, the `-p` flag indicates that the custom SSH
    port of the remote server is 2223, and then the username and address are specified.
    Lastly, the `-N` means that it shouldn’t get us to a remote shell and do the forwarding.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有三个标志，三个数字和两个地址。让我们解析一下命令，以便更清楚地理解正在发生的事情。`-L`标志表明我们要启用转发并绑定到一个远程端口（RabbitMQ的默认端口15672）的本地端口（9998）。接下来的`-p`标志指示远程服务器的自定义SSH端口为2223，然后指定用户名和地址。最后，`-N`表示不应该进入远程shell并进行转发。
- en: 'When executed correctly, the command will appear to hang, but it allows you
    to go into [*http://localhost:9998/*](http://localhost:9998/) and see the login
    page for the remote RabbitMQ instance. A useful flag to know when tunneling is
    `-f`: it will send the process into the background, which is helpful if this connection
    isn’t temporary, leaving the terminal ready and clean to do more work.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确执行时，命令会似乎挂起，但允许您进入[*http://localhost:9998/*](http://localhost:9998/)并查看远程RabbitMQ实例的登录页面。在进行隧道时了解的一个有用标志是`-f`：它会将进程发送到后台，这对于这种非临时连接很有帮助，使终端准备好并保持干净，可以继续工作。
- en: Benchmarking HTTP with Apache Benchmark (ab)
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Apache Benchmark（ab）进行HTTP基准测试
- en: We *really* love to hammer servers we work with to ensure they handle load correctly,
    especially before they get promoted to production. Sometimes we even try to trigger
    some odd race condition that may happen under heavy load. The Apache Benchmark
    tool (`ab` in the command line) is one of those tiny tools that can get you going
    quickly with just a few flags.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实喜欢测试我们使用的服务器，以确保它们能够正确处理负载，特别是在它们被提升到生产环境之前。有时，甚至会尝试触发某些在重负载下可能发生的奇怪竞态条件。Apache
    Benchmark 工具（命令行中的 `ab`）是其中一个可以仅用几个标志迅速启动的小工具。
- en: 'This command will create 100 requests at a time, for a total of 10,000 requests,
    to a local instance where Nginx is running:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在运行 Nginx 的本地实例上一次创建 100 个请求，总共 10,000 个请求：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'That is pretty brutal to handle in a system, but this is a local server, and
    the requests are just an HTTP `GET`. The detailed output from `ab` is very comprehensive
    and looks like this (trimmed for brevity):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于系统来说是相当残酷的处理方式，但这是一个本地服务器，请求只是一个 HTTP `GET`。来自 `ab` 的详细输出非常全面，如下所示（已削减以保持简洁）：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This type of information and how it is presented is tremendous. At a glance,
    you can quickly tell if a production server drops connections (in the `Failed
    requests` field) and what the averages are. A `GET` request is used, but `ab`
    allows you to use other HTTP verbs, such as `POST`, and even do a `HEAD` request.
    You need to exercise caution with this type of tool because it can easily overload
    a server. Below are more realistic numbers from an HTTP service in production
    (trimmed for brevity):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这种信息及其呈现方式非常了不起。一眼就可以快速判断生产服务器是否断开连接（在 `Failed requests` 字段中），以及平均值是多少。使用 `GET`
    请求，但 `ab` 允许您使用其他 HTTP 动词，如 `POST`，甚至进行 `HEAD` 请求。您需要小心使用这种类型的工具，因为它很容易使服务器超载。以下是来自生产环境中
    HTTP 服务的更为真实的数据（已削减以保持简洁）：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now the numbers look different, it hits a service with SSL enabled, and `ab`
    lists what the protocols are. At 83 requests per second, we think it could do
    better, but this is an API server that produces JSON, and it typically doesn’t
    get much load at once, as was just generated.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数字看起来不同，它命中了一个启用了 SSL 的服务，并且 `ab` 列出了协议。每秒 83 次请求，我们认为它可以做得更好，但这是一个生成 JSON
    的 API 服务器，并且通常不会一次性承载太多负载，就像刚生成的那样。
- en: Load Testing with molotov
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 molotov 进行负载测试
- en: The [Molotov](https://molotov.readthedocs.io) project is an interesting project
    geared towards load testing. Some of its features are similar to those of Apache
    Benchmark, but being a Python project, it provides a way to write scenarios with
    Python and the `asyncio` module.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[Molotov](https://molotov.readthedocs.io) 项目是一个有趣的负载测试项目。它的一些特点类似于 Apache Benchmark，但作为一个
    Python 项目，它提供了一种使用 Python 和 `asyncio` 模块编写场景的方法。'
- en: 'This is how the simplest example for `molotov` looks:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `molotov` 最简单示例的样子：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Save the file as *load_test.py*, create a small Flask application that handles
    both `POST` and `GET` requests at its main URL, and save it as *small.py*:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件保存为 *load_test.py*，创建一个小型 Flask 应用程序，该应用程序在其主 URL 处处理 `POST` 和 `GET` 请求，并将其保存为
    *small.py*：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Start the Flask application with `FLASK_APP=small.py flask run`, and then run
    `molotov` with the *load_test.py* file created previously:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `FLASK_APP=small.py flask run` 启动 Flask 应用程序，然后使用先前创建的 *load_test.py* 文件运行
    `molotov`：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'One hundred requests on a single worker ran against the local Flask instance.
    The tool really shines when the load testing is extended to do more per request.
    It has concepts similar to unit testing, such as setup, teardown, and even code,
    that can react to certain events. Since the small Flask application can handle
    a `POST` that redirects to a Google search, add another scenario to the *load_test*.py_
    file. This time change the weight so that 100% of the requests do a `POST`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 单个工作程序上的一百个请求运行到本地 Flask 实例。当负载测试扩展到每个请求更多时，这个工具确实表现出色。它具有类似单元测试的概念，如设置、拆卸，甚至可以对某些事件做出反应的代码。由于小型
    Flask 应用程序可以处理重定向到 Google 搜索的 `POST`，因此在 *load_test.py* 文件中添加另一个场景到 *load_test*。这次更改权重，使得
    100% 的请求执行 `POST`：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Run this new scenario for a single request to show the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个新场景以展示以下内容：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A single request (with `-r 1`) was enough to make this fail. The assertion
    needs to be updated to check for a `302` instead of a `301`. Once that status
    is updated, change the weight of the `POST` scenario to `80` so that other requests
    (with a `GET`) are sent to the Flask application. This is how the file looks in
    the end:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一个请求（使用 `-r 1`）就足以导致失败。断言需要更新为检查 `302` 而不是 `301`。一旦状态更新，将 `POST` 场景的权重更改为 `80`，以便其他请求（使用
    `GET`）发送到 Flask 应用程序。最终文件如下：
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run *load_test.py* for 10 requests to distribute the requests, two for a `GET`
    and the rest with a `POST`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 *load_test.py* 进行 10 次请求以分发请求，其中两次为 `GET` 请求，其余为 `POST` 请求：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, `molotov` is easily extensible with pure Python and can be modified
    to suit other, more complex, needs. These examples scratch the surface of what
    the tool can do.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`molotov` 可以通过纯 Python 很容易地扩展，并且可以修改以适应其他更复杂的需求。这些例子只是展示了该工具可以做什么的冰山一角。
- en: CPU Utilities
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CPU 实用程序
- en: 'There are two important CPU utilities: `top` and `htop`. You can find `top`
    preinstalled in most Linux distributions today, but if you are able to install
    packages, `htop` is fantastic to work with and we prefer its customizable interface
    over `top`. There are a few other tools out there that provide CPU visualization
    and perhaps even monitoring, but none are as complete and as widely available
    as both `top` and `htop`. For example, it is entirely possible to get CPU utilization
    from the `ps` command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个重要的 CPU 实用程序：`top` 和 `htop`。你可以在今天的大多数 Linux 发行版中找到预安装的 `top`，但是如果你能够安装软件包，那么
    `htop` 是非常好用的，我们更喜欢它的可自定义界面而不是 `top`。还有一些其他工具可以提供 CPU 可视化，甚至可能是监控，但是没有一个像 `top`
    和 `htop` 那样完整且广泛可用。例如，完全可以从 `ps` 命令获取 CPU 利用率：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `ps` command takes some custom fields. The first one is `pcpu`, which gives
    the CPU usage, followed by the process ID, the user, and finally, the command.
    That *pipes* into a sorted reverse because by default it goes from less CPU usage
    to more, and you need to have the most CPU usage at the top. Finally, since the
    command displays this information for every single process, it filters the top
    10 results with the `head` command.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps` 命令需要一些自定义字段。第一个是 `pcpu`，它给出了 CPU 使用情况，然后是进程 ID、用户，最后是命令。这将通过排序的反向管道处理，因为默认情况下它从较少的
    CPU 使用情况到更多的 CPU 使用情况，并且你需要将最高的 CPU 使用情况显示在顶部。最后，由于该命令为每个进程显示此信息，因此使用 `head` 命令过滤前
    10 个结果。'
- en: But the command is quite a mouthful, is a challenge to remember, and is not
    updated on the fly. Even if aliased, you are better off with `top` or `htop`.
    As you will see, both have extensive features.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这个命令相当冗长，记忆起来很有挑战性，并且不能实时更新。即使使用别名，你最好还是使用 `top` 或 `htop`。正如你将看到的，两者都有丰富的功能。
- en: Viewing Processes with htop
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 htop 查看进程
- en: The `htop` tool is just like `top` (an interactive process viewer) but is fully
    cross-platform (works on OS X, FreeBSD, OpenBSD, and Linux), offers support for
    better visualizations (see [Figure 4-1](#Figure-4-1)), and is a pleasure to use.
    Visit [*https://hisham.hm/htop*](https://hisham.hm/htop) for a screenshot of `htop`
    running on a server. One of the main caveats of `htop` is that all the shortcuts
    you may know about `top` are not compatible, so you will have to rewire your brain
    to understand and use them for `htop`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`htop` 工具就像 `top`（一个交互式进程查看器），但完全跨平台（适用于 OS X、FreeBSD、OpenBSD 和 Linux），提供更好的可视化支持（参见[图 4-1](#Figure-4-1)），使用起来非常愉快。访问
    [*https://hisham.hm/htop*](https://hisham.hm/htop) 查看在服务器上运行 `htop` 的截图。`htop`
    的一个主要缺点是，你可能知道的所有 `top` 的快捷键都不兼容，因此你需要重新调整你的大脑来理解并使用它们来使用 `htop`。'
- en: '![pydo 0401](assets/pydo_0401.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![pydo 0401](assets/pydo_0401.png)'
- en: Figure 4-1\. htop running on a server
  id: totrans-91
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-1\. 在服务器上运行的 htop
- en: Right away, the look and feel of the information displayed in [Figure 4-1](#Figure-4-1)
    is different. The CPU, Memory, and Swap are nicely shown at the top left, and
    they move as the system changes. The arrow keys scroll up or down and even left
    to right, providing a view of the whole command of the process.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 立即看到在 [图 4-1](#Figure-4-1) 中显示的信息的外观和感觉是不同的。CPU、内存和交换空间在左上角清晰显示，并随着系统的变化而变化。箭头键可以向上或向下滚动，甚至可以左右滚动，提供对进程的整个命令的视图。
- en: Want to kill a process? Move to it with the arrow keys, or hit `/` to incrementally
    search (and filter) the process, and then press `k`. A new menu will show all
    the signals that can be sent to the process—for example, `SIGTERM` instead of
    `SIGKILL`. It is possible to *“tag”* more than one process to kill. Press the
    space bar to tag the selected process, highlighting it with a different color.
    Made a mistake and want to un-tag? Press the space bar again. This all feels very
    intuitive.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 想要终止一个进程吗？使用箭头键移动到该进程，或者按 `/` 逐步搜索（和过滤）该进程，然后按 `k`。一个新菜单将显示可以发送给进程的所有信号，例如 `SIGTERM`
    而不是 `SIGKILL`。可以*“标记”*多个要终止的进程。按空格键标记所选进程，用不同颜色突出显示。犯了一个错误想要取消标记吗？再次按空格键。这一切都感觉非常直观。
- en: One problem with `htop` is that it has lots of actions mapped to `F` keys, and
    you may not have any. For example, `F1` is for help. The alternative is to use
    the equivalent mappings when possible. To access the help menu, use the `h` key;
    to access the setup, use `Shift s` instead of F2.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`htop`的一个问题是它将许多操作映射到`F`键，而您可能没有。例如，`F1`是帮助。替代方法是在可能的情况下使用等效的映射。要访问帮助菜单，请使用`h`键；要访问设置，请使用`Shift
    s`，而不是F2。'
- en: 'The `t` (again, how intuitive!) enables (toggles) the process list as a tree.
    Probably the most used functionality is sorting. Press `>` and a menu appears
    to select what type of sorting you want: PID, user, memory, priority, and CPU
    percentage are just a few. There are also shortcuts to sort directly (skips the
    menu selection) by memory (`Shift i`), CPU (`Shift p`), and Time (`Shift t`).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`t`键（再次，多么直观！）将进程列表切换为树形式。可能最常用的功能是排序。按`>`键会弹出菜单，以选择您想要的排序类型：PID、用户、内存、优先级和CPU百分比仅为其中几个。还有直接排序的快捷方式（跳过菜单选择）：按内存（`Shift
    i`）、CPU（`Shift p`）和时间（`Shift t`）。'
- en: 'Finally, two incredible features: you can run `strace` or `lsof` directly in
    the selected process as long as these are installed and available to the user.
    If the processes require superuser permissions, `htop` will report that, and it
    will require `sudo` to run as a privileged user. To run `strace` on a selected
    process, use the `s` key; for `lsof`, use the `l` key.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，两个令人难以置信的功能：只要这些已安装并对用户可用，您可以直接在选择的进程中运行`strace`或`lsof`。如果进程需要超级用户权限，`htop`将报告，并且需要使用`sudo`以特权用户身份运行。要在所选进程上运行`strace`，请使用`s`键；对于`lsof`，请使用`l`键。
- en: If either `strace` or `lsof` is used, the search and filter options are available
    with the `/` character. What an incredibly useful tool! Hopefully, one day other
    non-`F` key mappings will be possible, even though most work can be done with
    the alternative mappings.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`strace`或`lsof`，可以使用`/`字符进行搜索和过滤选项。多么令人难以置信的实用工具！希望将来能实现其他非`F`键映射，尽管大多数工作可以通过替代映射完成。
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If `htop` is customized via its interactive session, the changes get persisted
    in a configuration file that is usually located at *~/.config/htop/htoprc*. If
    you define configurations there and later change them in the session, then the
    session will overwrite whatever was defined previously in the *htoprc* file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过其交互会话定制了`htop`，更改将保存在通常位于`~/.config/htop/htoprc`的配置文件中。如果在会话中定义了配置，然后在会话中后来更改了它们，则会话将覆盖先前在`htoprc`文件中定义的内容。
- en: Working with Bash and ZSH
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bash和ZSH
- en: It all starts with customization. Both Bash and ZSH will usually come with a
    *“dotfile,”* a file prefixed with a dot that holds configuration but by default
    is hidden when directory contents are listed, and lives in the home directory
    of the user. For Bash this is *.bashrc*, and for ZSH it is *.zshrc*. Both shells
    support several layers of places that will get loaded in a predefined order, which
    ends in the configuration file for the user.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都从定制开始。Bash和ZSH通常都会有一个*“点文件”*，即以点开头的文件，用于保存配置，默认情况下在目录内容列表时是隐藏的，存放在用户的主目录中。对于Bash来说，这是`.bashrc`，对于ZSH来说，是`.zshrc`。这两个shell都支持几层按预定义顺序加载的位置，最终会加载用户的配置文件。
- en: 'When ZSH is installed, a `.zshrc` is usually not created. This is how a minimal
    version of it looks in a CentOS distro (all comments removed for brevity):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当安装ZSH时，通常不会创建`.zshrc`文件。这是它在CentOS发行版中的最小版本（为简洁起见，所有注释已删除）：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Bash has a couple of additional items in it but nothing surprising. You will
    no doubt get to the point of being extremely annoyed at some behavior or thing
    you saw in some other server that you want to replicate. We can’t live without
    colors in the terminal, so whatever the shell, it has to have color enabled. Before
    you know it, you are deep into configurations and want to add a bunch of useful
    aliases and functions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Bash中有一些附加项，但没有什么令人意外的。毫无疑问，您会对某些行为或在其他服务器上看到的事物感到极度恼火，并希望复制它们。我们无法在终端中没有颜色，所以无论是哪个shell，都必须启用颜色。在您知晓之前，您已深入到配置中，并希望添加一堆有用的别名和函数。
- en: 'Soon after, the text editor configurations come in, and it all feels unmanageable
    on different machines or when new ones are added and all those useful aliases
    are not set up, and it is *unbelievable*, but no one has enabled color support
    anywhere. Everyone has a way to solve this problem in an entirely nontransferable,
    ad hoc way: Alfredo uses a *Makefile* at some point, and his coworkers use either
    nothing at all or a Bash script. A new project called [Dotdrop](https://deadc0de.re/dotdrop)
    has lots of features to get all those dotfiles in working order, with features
    such as copying, symlinking, and keeping separate *profiles* for development and
    other machines—pretty useful when you move from one machine to another.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此后，文本编辑器配置就出现了，在不同的机器上或者添加新机器时，这一切都显得难以管理，所有这些有用的别名都没有设置，这简直是*令人难以置信*，但是没有在任何地方启用颜色支持。每个人都有自己解决这个问题的方式，完全是一种无法转移的，特设的方式：阿尔弗雷多在某些时候使用*Makefile*，而他的同事们要么什么都不用，要么用一个Bash脚本。一个名为[Dotdrop](https://deadc0de.re/dotdrop)的新项目有很多功能，可以使所有这些点文件有条不紊地工作起来，包括复制、符号链接和为开发和其他机器保留独立的*配置文件*——当你从一台机器移动到另一台机器时非常有用。
- en: You can use Dotdrop for a Python project, and although you can install it via
    the regular `virtualenv` and `pip` tooling, it is recommended to include it as
    a submodule to your repository of dotfiles. If you haven’t done so already, it
    is very convenient to keep all your dotfiles in version control to keep track
    of changes. Alfredo’s [dotfiles](https://oreil.ly/LV1AH) are publicly available,
    and he tries to keep them as up-to-date as possible.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Python项目中使用Dotdrop，虽然您可以通过常规的`virtualenv`和`pip`工具安装它，但建议将其包含为点文件存储库的子模块。如果您还没有这样做，将所有点文件放入版本控制非常方便，以便跟踪更改。阿尔弗雷多的[dotfiles](https://oreil.ly/LV1AH)是公开可用的，并且他尽可能使其保持最新。
- en: Independent of what is used, keeping track of changes via version control, and
    making sure everything is always updated, is a good strategy.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 独立于所使用的内容，通过版本控制跟踪更改，并确保一切始终保持更新，是一个很好的策略。
- en: Customizing the Python Shell
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义Python Shell
- en: 'You can customize the Python shell with helpers and import useful modules in
    a Python file that then has to be exported as an environment variable. I keep
    my configuration files in a repository called *dotfiles*, so in my shell configuration
    file (*$HOME/.zshrc* for me) I define the following export:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将有用的模块导入Python文件并将其导出为环境变量来自定义Python shell。我将我的配置文件保存在一个名为*dotfiles*的仓库中，因此在我的shell配置文件（对我而言是*$HOME/.zshrc*）中定义如下导出：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To try this out, create a new Python file called *pythonstartup.py* (although
    it can be named anything) that looks like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 若要尝试此功能，请创建一个名为*pythonstartup.py*的新Python文件（虽然可以命名为任何名称），内容如下：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now open up a new Python shell and specify the newly created *pythonstartup.py*:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开一个新的Python shell，并指定新创建的*pythonstartup.py*：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `helpers` object is immediately available. Since we added the `uuid4` property,
    we can access it as `helpers.uuid4()`. As you may be able to tell, all the imports
    and definitions are going to be available in the Python shell. This is a convenient
    way to extend behavior that can be useful with the default shell.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`helpers`对象立即可用。由于我们添加了`uuid4`属性，我们可以将其作为`helpers.uuid4()`访问。正如您可能已经注意到的那样，所有导入和定义将在Python
    shell中可用。这是一种方便的扩展行为的方式，可以与默认shell一起使用。'
- en: Recursive Globbing
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归全局搜索
- en: 'Recursive globbing is enabled in ZSH by default, but Bash (versions 4 and higher)
    requires `shopt` to set it. Recursive globbing is a cool setting that allows you
    to traverse a path with the following syntax:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在ZSH中，默认启用递归全局搜索，但Bash（4及更高版本）需要使用`shopt`来设置。递归全局搜索是一种很酷的设置，允许您以以下语法遍历路径：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'That snippet would go through each file and directory recursively and list
    every single file that ends in `.py`. This is how to enable it in Bash 4:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 该片段将递归地遍历每个文件和目录，并列出以`.py`结尾的每个文件。这是如何在Bash 4中启用它的：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Searching and Replacing with Confirmation Prompts
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索和替换时，需要确认提示。
- en: Vim has a nice feature in its search and replace engine that prompts for confirmation
    to perform the replacement or skip it. This is particularly useful when you can’t
    nail the exact regular expression that matches what you need but want to ignore
    some other close matches. We know regular expressions, but we’ve tried to avoid
    being an expert at them because it would be very tempting to use them for everything.
    Most of the time, you will want to perform a simple search and replace and not
    bang your head against the wall to come up with the perfect regex.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Vim在其搜索和替换引擎中有一个很好的功能，提示是否执行替换或跳过。当你不能准确地匹配所需的正则表达式，但又想忽略一些其他接近的匹配时，这特别有用。我们了解正则表达式，但尽量避免成为专家，因为对于一切都使用它们是非常诱人的。大多数情况下，你会希望执行简单的搜索和替换，而不是为了找到完美的正则表达式而苦恼。
- en: 'The `c` flag needs to be appended at the end of the command to enable the confirmation
    prompt in Vim:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Vim命令的末尾添加`c`标志以启用确认提示：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The above translates to: search for *original term* in the whole file and replace
    it with *replacement term*, but at each instance, prompt so that one can decide
    to change it or skip it. If a match is found, Vim will display a message like
    this one:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容翻译为：在整个文件中搜索*原始术语*并用*替换术语*替换，但在每次匹配时提示，以便可以决定是否更改或跳过。如果找到匹配项，Vim将显示如下消息：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The whole confirmation workflow might seem silly but allows you to relax the
    constraints on the regular expression, or even not use one at all for a simpler
    match and replace. A quick example of this is a recent API change in a production
    tool that changed an object’s attribute for a callable. The code returned `True`
    or `False` to inform if superuser permissions were required or not. The actual
    replacement in a single file would look like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 整个确认工作流可能看起来很傻，但它允许你放松对正则表达式的约束，甚至在不使用正则表达式进行更简单的匹配和替换时也可以使用。一个快速的例子是生产工具中最近的API更改，更改了对象属性以进行调用。代码返回`True`或`False`以通知是否需要超级用户权限。在单个文件中的实际替换如下所示：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The added difficulty here is that `needs_root` was also splattered in comments
    and doc strings, so it wasn’t easy to come up with a regular expression that would
    allow skipping the replacement when inside a comment block or in part of a doc
    string. With the `c` flag, you can just hit `Y` or `N` and move on. No regular
    expression needed at all!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 增加的难度在于`needs_root`还散落在注释和文档字符串中，因此不容易想出一个允许在注释块内或文档字符串的一部分时跳过替换的正则表达式。使用`c`标志，你只需按下`Y`或`N`即可继续。根本不需要正则表达式！
- en: 'With recursive globbing enabled (`shopt -s globstar` in Bash 4), this powerful
    one-liner will go through all the matching files, perform the search, and replace
    the item according to the prompts if the pattern is found inside the files:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用启用了递归通配符(`shopt -s globstar`在Bash 4中)，这个强大的单行命令将遍历所有匹配的文件，执行搜索并根据需要的情况进行替换：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There is a lot to unpack here, but the above example will traverse recursively
    to find all the files ending in `.py`, load them into Vim, and perform the search
    and replace with confirmation only if there is a match. If there isn’t a match,
    it skips the file. The `set eventignore-=Syntax` is used because otherwise Vim
    will not load the syntax files when executing it this way; we like syntax highlighting
    and expect it to work when this type of replacement is used. The next part after
    the `|` character is the replacement with the confirmation flag and the `e` flag,
    which helps ignore any errors that would prevent a smooth workflow from being
    interrupted with errors.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多内容要处理，但上面的例子将递归遍历查找所有以`.py`结尾的文件，加载到Vim中，并仅在有匹配时执行带有确认的搜索和替换。如果没有匹配，则跳过该文件。使用`set
    eventignore-=Syntax`是因为否则在这种执行方式下Vim不会加载语法文件；我们喜欢语法高亮，并期望在使用这种替换时它能正常工作。`|`字符后的下一部分是带有确认标志和`e`标志的替换，后者有助于忽略可能会导致平稳工作流中断的任何错误。
- en: Tip
  id: totrans-133
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: There are numerous other flags and variations that you can use to enhance the
    replacement command. To learn more about the special flags with a search and replace
    in Vim, take a look at `:help substitute`, specifically at the `s_flags` section.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他标志和变体可用于增强替换命令。要了解有关Vim搜索和替换的特殊标志的更多信息，请查看`:help substitute`，特别是`s_flags`部分。
- en: 'Make the complicated one-liner easier to remember with a function that takes
    two parameters (search and replace terms) and the path:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个接受两个参数（搜索和替换术语）和路径的函数，使复杂的单行命令更容易记住。
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Name it `vsed`, as a mix of Vim and the `sed` tool, so that it is easier to
    remember. In the terminal, it looks straightforward and allows you to make changes
    to multiple files easily and with confidence, since you can accept or deny each
    replacement:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 将其命名为`vsed`，结合了Vim和`sed`工具，使其更容易记忆。在终端中看起来很简单，可以让你轻松自信地对多个文件进行更改，因为你可以接受或拒绝每次替换：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Removing Temporary Python Files
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除临时Python文件
- en: 'Python’s `pyc`, and more recently its `*pycache*` directories, can sometimes
    get in the way. This simple one-liner aliased to `pyclean` uses the `find` command
    to remove `pyc`, then goes on to find `*pycache*` directories and recursively
    deletes them with the tool’s built-in delete flag:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`pyc`，以及最近的`*pycache*`目录，有时可能会妨碍工作。这个简单的一行命令别名为`pyclean`，使用`find`命令删除`pyc`，然后继续查找`*pycache*`目录，并使用工具的内置删除标志递归删除它们：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Listing and Filtering Processes
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程清单和过滤
- en: Process listing to view what runs in a machine and then filtering to check on
    a specific application is one of the things that you’ll do several times a day
    at the very least. It is not at all surprising that everyone has a variation on
    either the flags or the order of the flags for the `ps` tool (we usually use `aux`).
    It is something you end up doing so many times a day that the order and the flags
    get ingrained in your brain and it is hard to do it any other way.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 进程列表用于查看机器上正在运行的内容，然后进行过滤以检查特定应用程序是你每天至少会做几次的事情之一。毫不奇怪，每个人都会对`ps`工具（我们通常使用`aux`）的标志或标志的顺序有所变化。你每天都会做这么多次，以至于这些标志和顺序会深深印在你的脑海中，很难用其他方式做。
- en: 'As a good starting point to list the processes and some information, such as
    process IDs, try this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 作为列出进程和一些信息的良好起点，比如进程ID，试试这个：
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This command lists all processes with the *BSD-style* flags (flags that aren’t
    prefixed with a dash `-`) regardless or whether they have a terminal (tty) or
    not, and includes the user that owns the process. Finally, it gives more space
    to the output (`w` flag).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令列出所有进程，使用*BSD风格*标志（不带破折号`-`的标志），无论它们是否具有终端（tty），并包括拥有进程的用户。最后，它为输出提供更多空间（`w`标志）。
- en: 'Most of the times, you are filtering with `grep` to get information about a
    specific process. For example, if you want to check if Nginx is running, you pipe
    the output into grep and pass `nginx` as an argument:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你会使用`grep`进行过滤，以获取关于特定进程的信息。例如，如果你想检查Nginx是否正在运行，你可以将输出通过管道传递到grep，并将`nginx`作为参数传递：
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'That is great, but it is annoying to have the `grep` command included. This
    is particularly maddening when there are no results except for the `grep`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒，但包含`grep`命令有些让人讨厌。特别是当除了`grep`之外没有结果时，这尤其让人恼火：
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'No `apache` process is found, but the visuals may mislead you to think it is,
    and double-checking that this is indeed just `grep` being included because of
    the argument can get tiring pretty quickly. A way to solve this is to add another
    pipe to `grep` to filter itself from the output:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 没有找到`apache`进程，但是视觉上可能会让你误以为有，双重检查确实只是因为参数而导致`grep`被包含在内，这可能会很快令人疲倦。解决方法是向`grep`添加另一个管道来从输出中过滤自身：
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To have to always remember to add that extra `grep` can be equally annoying,
    so an alias comes to the rescue:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 必须始终记住添加额外的`grep`同样令人恼火，因此别名来拯救：
- en: '[PRE42]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The new alias will filter the first `grep` line out and leave only the interesting
    output (if any):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 新的别名将过滤掉第一个`grep`行，仅留下有趣的输出（如果有的话）：
- en: '[PRE43]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Unix Timestamp
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unix时间戳
- en: 'To get the widely used Unix timestamp in Python is very easy:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Python中获取广泛使用的Unix时间戳非常容易：
- en: '[PRE44]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'But in the shell, it can be a bit more involved. This alias works in OS X,
    which has the BSD-flavored version of the `date` tool:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 但在shell中，可能会更复杂一些。这个别名适用于OS X，它具有BSD风格的`date`工具：
- en: '[PRE45]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'OS X can be awkward with its tooling, and it may be confusing to never remember
    why a given utility (like `date` in this case) behaves completely differently.
    In the Linux version of `date`, a far simpler approach works the same way:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: OS X 的工具可能有些古怪，导致你总是搞不清楚为什么特定实用程序（比如这种情况下的`date`）的行为完全不同。在 Linux 版本的`date`中，一个更简单的方法可以达到同样的效果：
- en: '[PRE46]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Mixing Python with Bash and ZSH
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Python与Bash和ZSH混合使用
- en: It never occurred to us to try and mix Python with a shell, like ZSH or Bash.
    It feels like going against common sense, but there are a few good cases here
    that you can use almost daily. In general, our rule of thumb is that 10 lines
    of shell script is the limit; anything beyond that is a bug waiting to make you
    waste time because the error reporting isn’t there to help you out.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从未想过尝试将 Python 与像 ZSH 或 Bash 这样的 shell 混合使用。这感觉违反常识，但这里有几个很好的例子，你几乎可以每天都使用。总的来说，我们的经验法则是
    shell 脚本的上限是 10 行；超过这个限制的任何内容都可能是一个 bug，会让你浪费时间，因为错误报告并不能帮助你解决问题。
- en: Random Password Generator
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机密码生成器
- en: 'The amount of accounts and passwords that you need on a week-to-week basis
    is only going to keep increasing, even for throwaway accounts that you can use
    Python for to generate robust passwords. Create a useful, randomized password
    generator that sends the contents to the clipboard to easily paste it:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 每周你需要的帐号和密码数量只会增加，即使是一次性帐号，你也可以使用 Python 生成强大的密码。创建一个有用的随机密码生成器，将内容发送到剪贴板以便轻松粘贴：
- en: '[PRE47]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Porting that to a shell function that can take an arbitrary length (useful
    when a site restricts length to a certain number) looks like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将其移植到一个可以接受任意长度的 shell 函数（在站点限制长度为某个特定数字时非常有用）看起来像这样：
- en: '[PRE48]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now the `mpass` function defaults to generate 12-character passwords by slicing
    the output, and then sends the contents of the generated string to `xclip` so
    that it gets copied to the clipboard for easy pasting.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `mpass` 函数默认生成 12 个字符的密码，然后将生成的字符串内容发送到 `xclip`，以便将其复制到剪贴板方便粘贴。
- en: Note
  id: totrans-172
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`xclip` is not installed by default in many distros, so you need to ensure
    that it is installed for the function to work properly. If `xclip` is not available,
    any other utility that can help manage the system clipboard will work fine.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多发行版中默认未安装 `xclip`，因此您需要确保它已安装以使函数正常工作。如果没有 `xclip`，任何其他可以帮助管理系统剪贴板的工具都可以正常工作。
- en: Does My Module Exist?
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块是否存在？
- en: 'Find out if a module exists, and if it does, get the path to that module. This
    is useful when reused for other functions that can take that output for processing:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 查找模块是否存在，如果存在则获取该模块的路径。这在被其他函数重用时非常有用，可以接受该输出进行处理：
- en: '[PRE49]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Changing Directories to a Module’s Path
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切换到模块路径
- en: '*“Where does this module live?”* is often asked when debugging libraries and
    dependencies, or even when poking around at the source of modules. Python’s way
    to install and distribute modules isn’t straightforward, and in different Linux
    distributions the paths are entirely different and have separate conventions.
    You can find out the path of a module if you import it and then use `print`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试库和依赖项或者探索模块源码时经常会被问到*“这个模块在哪？”*。Python 安装和分发模块的方式并不直观，在不同的 Linux 发行版中路径完全不同，并且有各自的约定。如果导入模块然后使用
    `print`，你可以找出模块的路径：
- en: '[PRE50]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'It isn’t convenient if all you want is the path so that you can change directories
    to it and look at the module. This function will try to import the module as an
    argument, print it out (this is shell, so `return` doesn’t do anything for us),
    and then change directory to it:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 获取路径以便于切换目录并查看模块并不方便。这个函数将尝试导入作为参数的模块，打印出来（这是 shell，所以 `return` 对我们没用），然后切换到它：
- en: '[PRE51]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let’s make it more robust, in case the package name has a dash and the module
    uses an underscore, by adding:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让它更加健壮，以防包名中有破折号并且模块使用下划线，添加：
- en: '[PRE52]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If the input has a dash, the little function can solve this on the fly and
    get us to where we need to be:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入有破折号，这个小函数可以实时解决并帮助我们到达目标位置：
- en: '[PRE53]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Converting a CSV File to JSON
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 CSV 文件转换为 JSON
- en: 'Python comes with a few built-ins that are surprising if you’ve never dealt
    with them. It can handle JSON natively, as well as CSV files. It only takes a
    couple of lines to load a CSV file and then *“dump”* its contents as JSON. Use
    the following CSV file (*addresses.csv*) to see the contents when JSON is dumped
    in the Python shell:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Python 自带一些内置功能，如果你从未接触过它们，可能会感到惊讶。它可以原生处理 JSON 和 CSV 文件。只需几行代码即可加载 CSV 文件，然后*“转储”*其内容为
    JSON。使用以下 CSV 文件（*addresses.csv*）在 Python shell 中查看转储的内容：
- en: '[PRE54]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Port the interactive session to a function that can do this on the command
    line:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 将交互式会话移植为可以在命令行上执行的函数：
- en: '[PRE56]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Use it in the shell, which is much simpler than remembering all the calls and
    modules:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在 shell 中使用它，这比记住所有调用和模块要简单得多：
- en: '[PRE57]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Python One-Liners
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 单行代码
- en: In general, writing a long, single line of Python is not considered good practice.
    The [PEP 8](https://oreil.ly/3P_qQ) guide even frowns on compounding statements
    with a semicolon (it is possible to use semicolons in Python!). But quick debug
    statements and calls to a debugger are fine. They are, after all, temporary.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，编写长的单行Python代码并不被视为良好的实践。[PEP 8](https://oreil.ly/3P_qQ)指南甚至不赞成使用分号来合并语句（在Python中可以使用分号！）。但是，快速调试语句和调试器的调用是可以的。它们毕竟是临时的。
- en: Debuggers
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试器
- en: 'A few programmers out there swear by the `print()` statement as the best strategy
    to debug running code. In some cases, that might work fine, but most of the time
    we use the Python debugger (with the `pdb` module) or `ipdb`, which uses IPython
    as a backend. By creating a break point, you can poke around at variables and
    go up and down the stack. These single-line statements are important enough that
    you should memorize them:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员发誓将`print()`语句作为调试运行代码的最佳策略。在某些情况下，这可能效果不错，但大多数时候我们使用Python调试器（使用`pdb`模块）或`ipdb`，它使用IPython作为后端。通过创建断点，您可以查看变量并在堆栈上下移动。这些单行语句非常重要，您应该记住它们：
- en: 'Set a break point and drop to the Python debugger (`pdb`):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个断点并进入Python调试器（`pdb`）：
- en: '[PRE58]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Set a break point and drop to a Python debugger based on IPython (`ipdb`):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个断点，并进入基于IPython（`ipdb`）的Python调试器：
- en: '[PRE59]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Although not technically a debugger (you can’t move forward or backward in
    the stack), this one-liner allows you to start an IPython session when the execution
    gets to it:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在技术上不是调试器（您无法在堆栈中前进或后退），但这个一行命令允许您在执行到它时启动一个IPython会话：
- en: '[PRE60]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note
  id: totrans-204
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Everyone seems to have a favorite debugger tool. We find `pdb` to be too rough
    (no auto-completion, no syntax highlighting), so we tend to like `ipdb` better.
    Don’t be surprised if someone comes along with a different debugger! In the end,
    it’s useful to know how `pdb` works, as it’s the base needed to be proficient
    regardless of the debugger. In systems you can’t control, use `pdb` directly because
    you can’t install dependencies; you may not like it, but you can still manage
    your way around.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人似乎都有自己喜欢的调试器工具。我们发现`pdb`太粗糙（没有自动完成，没有语法高亮），所以我们更喜欢`ipdb`。如果有人使用不同的调试器，不要感到惊讶！最后，了解`pdb`的工作原理是有用的，因为它是无论调试器如何都需要熟练掌握的基础。在无法控制的系统中，直接使用`pdb`，因为您无法安装依赖项；您可能不喜欢它，但您仍然可以处理。
- en: How Fast Is this Snippet?
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这段代码有多快？
- en: Python has a module to run a piece of code several times over and get some performance
    metrics from it. Lots of users like to ask if there are efficient ways to handle
    a loop or update a dictionary, and there are lots of knowledgeable people that
    love the `timeit` module to prove performance.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个模块可以多次运行一段代码，并从中获取一些性能指标。许多用户喜欢问是否有高效的方法来处理循环或更新字典，而有很多了解的人都喜欢`timeit`模块来证明性能。
- en: 'As you have probably seen, we are fans of [IPython](https://ipython.org), and
    its interactive shell comes with a *“magic”* special function for the `timeit`
    module. “Magic” functions are prefixed with the `%` character and perform a distinct
    operation within the shell. An all-time favorite regarding performance is whether
    list comprehension is faster than just appending to a list. The two examples below
    use the `timeit` module to find out:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经看到的，我们是[IPython](https://ipython.org)的粉丝，其交互式shell配备了`timeit`模块的“魔术”特殊功能。
    “魔术”函数以`%`字符为前缀，并在shell中执行不同的操作。关于性能的一项永久性喜爱是列表推导是否比仅附加到列表更快。以下两个示例使用`timeit`模块进行测试：
- en: '[PRE61]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In the standard Python shell (or interpreter), you import the module and access
    it directly. The invocation looks a bit different in this case:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准的Python shell（或解释器）中，你需要导入模块并直接访问它。在这种情况下，调用看起来有点不同：
- en: '[PRE62]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The output is a bit odd, but that’s because it’s meant to be processed by another
    module or library, and is not meant for human readability. The averages favor
    the list comprehension. This is how it looks in IPython:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 输出有点奇怪，但这是因为它是为另一个模块或库处理而设计的，而不是为了人类可读性。平均值倾向于列表推导。这是在IPython中的样子：
- en: '[PRE63]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Because IPython exposes `timeit` as a special command (notice the prefix with
    `%`), the output is human readable and more helpful to view, and it doesn’t require
    the weird import, as in the standard Python shell.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因为IPython将`timeit`公开为特殊命令（注意前缀为`%`），所以输出是人类可读的，并且更有助于查看，并且不需要像在标准的Python shell中那样奇怪的导入。
- en: strace
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: strace
- en: The ability to tell how a program is interacting with the operating system becomes
    crucial when applications aren’t logging the interesting parts or not logging
    at all. Output from `strace` can be rough, but with some understanding of the
    basics, it becomes easier to understand what is going on with a problematic application.
    One time, Alfredo was trying to understand why permission to access a file was
    being denied. This file was inside of a symlink that seemed to have all the right
    permissions. What was going on? It was difficult to tell by just looking at logs,
    since those weren’t particularly useful in displaying permissions as they tried
    to access files.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序没有记录感兴趣的部分或根本没有记录时，能够了解程序如何与操作系统交互变得至关重要。`strace` 的输出可能有些粗糙，但掌握一些基本知识后，理解问题应用程序的运行情况就会变得更容易。有一次，Alfredo
    尝试理解为什么拒绝访问文件的权限。这个文件位于一个符号链接中，这个链接似乎具有所有正确的权限。到底发生了什么？仅仅通过查看日志很难说清楚，因为这些日志在显示访问文件时的权限时并不特别有用。
- en: '`strace` included these two lines in the output:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`strace` 在输出中包含了这两行：'
- en: '[PRE64]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The program was setting ownership on the parent directory, which happened to
    be a link, and *block.db*, which in this case was also a link to a block device.
    The block device itself had the right permissions, so what was the problem? It
    turns out that the link in the directory had a *sticky bit* that prevented other
    links from changing the path—including the block device. The `chown` tool has
    a special flag (`-h` or `--no-dereference`) to indicate that the change in ownership
    should also affect the links.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 程序正在设置父目录的所有权，这个目录恰好是一个链接，以及 *block.db*，在这种情况下也是指向一个块设备的链接。块设备本身具有正确的权限，那么问题出在哪里呢？原来，目录中的链接有一个
    *粘性位*，阻止其他链接改变路径，包括块设备在内。`chown` 工具有一个特殊标志（`-h` 或 `--no-dereference`），表示所有权的更改也应影响这些链接。
- en: 'This type of debugging would be difficult (if not impossible) without something
    like `strace`. To try it out, create a file called *follow.py* with the following
    contents:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 没有像 `strace` 这样的工具，这种类型的调试将会很困难（甚至是不可能的）。要尝试它，请创建一个名为 *follow.py* 的文件，内容如下：
- en: '[PRE65]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'It imports the `subprocess` module to do a system call. It will output the
    contents of the system call to `ls`. Instead of a direct call with Python, prefix
    the command with `strace` to see what happens:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 它导入 `subprocess` 模块来执行系统调用。它将会将系统调用的内容输出到 `ls`。不要直接使用 Python 进行调用，而是使用 `strace`
    前缀来看看发生了什么：
- en: '[PRE66]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'A lot of output should’ve filled the terminal, and probably most of it will
    look very foreign. Force yourself to go through each line, regardless of whether
    you understand what is going on. Some lines will be easier to tell apart than
    others. There are a lot of `read` and `fstat` calls; you’ll see actual system
    calls and what the process is doing at each step. There are also `open` and `close`
    operations on some files, and there is a particular section that should show up
    with a few `stat` calls:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 终端应该已经填满了大量输出，其中大部分看起来可能非常陌生。不管你是否理解正在发生的事情，强迫自己逐行查看。有些行比其他行更容易区分。你会看到很多 `read`
    和 `fstat` 调用；你将看到实际的系统调用以及进程在每个步骤中的操作。还有一些文件上的 `open` 和 `close` 操作，特别是应该显示出几个
    `stat` 调用的特定部分：
- en: '[PRE67]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This system is pretty old, and `python` in the output means `python2.7`, so
    it pokes around the filesystem to try and find the right executable. It goes through
    a few until it reaches */usr/bin/python*, which is a link that points to */usr/bin/python2*,
    which in turn is another link that sends the process to */usr/bin/python2.7*.
    It then calls `stat` on */usr/bin/Modules/Setup*, which we’ve never heard of as
    Python developers, only to continue to the `os` module.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统相当老旧，输出中的 `python` 意味着 `python2.7`，因此它在文件系统中穿行以找到正确的可执行文件。它经过几个步骤直到达到 */usr/bin/python*，这是一个指向
    */usr/bin/python2* 的链接，进而又将进程发送到 */usr/bin/python2.7*。然后它在 */usr/bin/Modules/Setup*
    上调用 `stat`，对于我们作为 Python 开发者来说，这是一个闻所未闻的地方，仅仅是继续到 `os` 模块。
- en: It continues to *pybuilddir.txt* and *lib-dynload*. What a trip. Without `strace`
    we would’ve probably tried to read the code that executes this to try and figure
    out where it goes next. But `strace` makes this tremendously easier, including
    all the interesting steps along the way, with useful information for each call.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 它继续到 *pybuilddir.txt* 和 *lib-dynload*。真是一段旅程。没有 `strace`，我们可能会尝试阅读执行此操作的代码，以尝试弄清楚接下来会发生什么。但
    `strace` 让这变得极为容易，包括沿途的所有有趣步骤，每个调用都有有用的信息。
- en: The tool has many flags that are worth looking into; for example, it can *attach
    itself to a PID*. If you know the PID of a process, you can tell `strace` to produce
    output on what exactly is going on with it.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具有许多值得研究的标志；例如，它可以 *附加到一个 PID*。如果您知道进程的 PID，可以告诉 `strace` 生成关于它正在进行的操作的输出。
- en: One of those useful flags is `-f`; it will follow child processes as they are
    created by the initial program. In the example Python file, a call to `subprocess`
    is made, and it calls out to `ls`; if the command to `strace` is modified to use
    `-f`, the output becomes richer, with details about that call.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个有用的标志是 `-f`；它将随着初始程序创建的子进程而跟踪它们。在示例 Python 文件中，调用了 `subprocess`，它调用了 `ls`；如果修改
    `strace` 的命令以使用 `-f`，输出将更加丰富，包含有关该调用的详细信息。
- en: 'When *follow.py* runs in the home directory, there are a quite a few differences
    with the `-f` flag. You can see calls to `lstat` and `readlink` for the dotfiles
    (some of which are symlinked):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *follow.py* 在主目录中运行时，与 `-f` 标志有很多不同之处。您可以看到对点文件（其中一些是符号链接）的 `lstat` 和 `readlink`
    调用：
- en: '[PRE68]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Not only do the calls to these files show, but the PID is prefixed in the output,
    which helps identify which (child) process is doing what. A call to `strace` without
    the `-f` flag would not show a PID, for example.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅显示对这些文件的调用，而且 PID 在输出中有前缀，这有助于识别哪个（子）进程在做什么。例如，不带 `-f` 标志的 `strace` 调用不会显示
    PID。
- en: 'Finally, to analyze the output in detail, it can be helpful to save it to a
    file. This is possible with the `-o` flag:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要详细分析输出，将其保存到文件中会很有帮助。这可以通过 `-o` 标志实现：
- en: '[PRE69]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Exercises
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Define what IOPS is.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义 IOPS 是什么。
- en: Explain what the difference is between throughput and IOPS.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释吞吐量和 IOPS 之间的区别是什么。
- en: Name a limitation with `fdisk` for creating partitions that `parted` doesn’t
    have.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出 `fdisk` 创建分区的一个 `parted` 没有的限制。
- en: Name three tools that can provide disk information.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出可以提供磁盘信息的三个工具。
- en: What can an SSH tunnel do? When is it useful?
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSH 隧道可以做什么？何时有用？
- en: Case Study Question
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究问题
- en: Create a load test using the `molotov` tool that tests a `JSON` response from
    a server with an HTTP status of `200`.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `molotov` 工具创建一个负载测试，测试一个具有 `200` HTTP 状态的服务器的 `JSON` 响应。
