- en: Chapter 11\. File and Text Operations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章\. 文件和文本操作
- en: This chapter covers issues related to files and filesystems in Python. A *file*
    is a stream of text or bytes that a program can read and/or write; a *filesystem*
    is a hierarchical repository of files on a computer system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了Python中与文件和文件系统相关的问题。*文件*是程序可以读取和/或写入的文本或字节流；*文件系统*是计算机系统上文件的分层存储库。
- en: Other Chapters That Also Deal with Files
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他同样涉及文件处理的章节
- en: 'Files are a crucial concept in programming: so, although this chapter is one
    of the largest in the book, other chapters also have material relevant to handling
    specific kinds of files. In particular, [Chapter 12](ch12.xhtml#persistence_and_databases)
    deals with many kinds of files related to persistence and database functionality
    (CSV files in [Chapter 12](ch12.xhtml#persistence_and_databases), JSON files in
    [“The json Module”](ch12.xhtml#the_json_module), pickle files in [“The pickle
    Module”](ch12.xhtml#the_pickle_module), shelve files in [“The shelve Module”](ch12.xhtml#the_shelve_module),
    DBM and DBM-like files in [“The dbm Package”](ch12.xhtml#the_dbm_package), and
    SQLite database files in [“SQLite”](ch12.xhtml#sqlite)), [Chapter 22](ch22.xhtml#structured_text_html)
    deals with files in HTML format, and [Chapter 23](ch23.xhtml#structured_text_xml)
    deals with files in XML format.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 文件是编程中至关重要的概念：因此，尽管本章是本书中最大的章节之一，其他章节也包含处理特定类型文件相关的内容。特别是，[第12章](ch12.xhtml#persistence_and_databases)涉及与持久性和数据库功能相关的多种文件（CSV文件在[第12章](ch12.xhtml#persistence_and_databases)，JSON文件在[“json模块”](ch12.xhtml#the_json_module)，pickle文件在[“pickle模块”](ch12.xhtml#the_pickle_module)，shelve文件在[“shelve模块”](ch12.xhtml#the_shelve_module)，DBM和类似DBM的文件在[“dbm包”](ch12.xhtml#the_dbm_package)，以及SQLite数据库文件在[“SQLite”](ch12.xhtml#sqlite)），[第22章](ch22.xhtml#structured_text_html)处理HTML格式文件，[第23章](ch23.xhtml#structured_text_xml)处理XML格式文件。
- en: Files and streams come in many flavors. Their contents can be arbitrary bytes,
    or text. They may be suitable for reading, writing, or both, and they may be *buffered,*
    so that data is temporarily held in memory on the way to or from the file. Files
    may also allow *random access*, moving forward and back within the file, or jumping
    to read or write at a particular location in the file. This chapter covers each
    of these topics.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 文件和流具有多种变体。它们的内容可以是任意字节或文本。它们可能适合读取、写入或两者兼而有之，并且它们可能是*缓冲的*，因此数据在进出文件时在内存中暂时保留。文件还可以允许*随机访问*，在文件内前进和后退，或跳转到文件中的特定位置进行读取或写入。本章涵盖了这些每一个主题。
- en: 'In addition, this chapter also covers the polymorphic concept of file-like
    objects (objects that are not actually files but behave to some extent like files),
    modules that deal with temporary files and file-like objects, and modules that
    help you access the contents of text and binary files and support compressed files
    and other data archives. Python’s standard library supports several kinds of [lossless
    compression](https://oreil.ly/iwsUw), including (ordered by the typical ratio
    of compression on a text file, from highest to lowest):'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本章还涵盖了文件类对象的多态概念（实际上不是文件但在某种程度上像文件的对象）、处理临时文件和文件类对象的模块，以及帮助您访问文本和二进制文件内容并支持压缩文件和其他数据存档的模块。Python的标准库支持多种[无损压缩](https://oreil.ly/iwsUw)，包括（按文本文件的压缩比例从高到低排序）：
- en: '[LZMA](https://oreil.ly/DuCbU) (used, for example, by the [xz](https://tukaani.org/xz)
    program), see module [lzma](https://oreil.ly/Kw54K)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[LZMA](https://oreil.ly/DuCbU)（例如由[xz](https://tukaani.org/xz)程序使用），请参见模块[lzma](https://oreil.ly/Kw54K)'
- en: '[bzip2](https://oreil.ly/9rUEj) (used, for example, by the [bzip2](http://www.bzip.org)
    program), see module [bz2](https://oreil.ly/LXyg_)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[bzip2](https://oreil.ly/9rUEj)（例如由[bzip2](http://www.bzip.org)程序使用），请参见模块[bz2](https://oreil.ly/LXyg_)'
- en: '[deflate](https://oreil.ly/k_iKs) (used, for example, by the [gzip](https://oreil.ly/kCtWx)
    and [zip](https://oreil.ly/an46l) programs), see modules [zlib](https://oreil.ly/-lWQP),
    [gzip](https://oreil.ly/WyFJf), and [zipfile](https://oreil.ly/c7VxO)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[deflate](https://oreil.ly/k_iKs)（例如由[gzip](https://oreil.ly/kCtWx)和[zip](https://oreil.ly/an46l)程序使用），请参见模块[zlib](https://oreil.ly/-lWQP)，[gzip](https://oreil.ly/WyFJf)，和[zipfile](https://oreil.ly/c7VxO)'
- en: The [tarfile module](https://oreil.ly/ZJlzh) lets you read and write TAR files
    compressed with any one of these algorithms. The zipfile module lets you read
    and write ZIP files and also handles bzip2 and LZMA compressions. We cover both
    of these modules in this chapter. We don’t cover the details of compression in
    this book; for details, see the [online docs](https://oreil.ly/U0-Zx).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[tarfile 模块](https://oreil.ly/ZJlzh)可让您读取和写入使用任何这些算法压缩的 TAR 文件。zipfile 模块允许您读取和写入
    ZIP 文件，并处理 bzip2 和 LZMA 压缩。本章中我们涵盖了这两个模块。本书不涵盖压缩的详细内容；详见[在线文档](https://oreil.ly/U0-Zx)。'
- en: In the rest of this chapter, we will refer to all files and file-like objects
    as files.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将所有文件和类似文件的对象称为文件。
- en: In modern Python, input/output (I/O) is handled by the standard library’s io
    module. The os module supplies many of the functions that operate on the filesystem,
    so this chapter also introduces that module. It then covers operations on the
    filesystem (comparing, copying, and deleting directories and files; working with
    filepaths; and accessing low-level file descriptors) provided by the os module,
    the os.path module, and the new and preferable pathlib module, which provides
    an object-oriented approach to filesystem paths. For a cross-platform interprocess
    communication (IPC) mechanism known as *memory-mapped files*, see the module mmap,
    covered in [Chapter 15](ch15.xhtml#concurrency_threads_and_processes).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代 Python 中，输入/输出（I/O）由标准库的 io 模块处理。os 模块提供了许多操作文件系统的函数，因此本章还介绍了该模块。然后讨论了操作文件系统的内容（比较、复制和删除目录和文件；处理文件路径；以及访问低级文件描述符），这些功能由
    os 模块、os.path 模块以及新的更可取的 pathlib 模块提供，后者提供了一种面向对象的文件系统路径的方法。有关称为*内存映射文件*的跨平台进程间通信（IPC）机制，请参见第 15 章中介绍的
    mmap 模块。
- en: While most modern programs rely on a graphical user interface (GUI), often via
    a browser or a smartphone app, text-based, nongraphical “command-line” user interfaces
    are still very popular for their ease, speed of use, and scriptability. This chapter
    concludes with a discussion of non-GUI text input and output in Python in [“Text
    Input and Output”](#text_input_and_output), terminal text I/O in [“Richer-Text
    I/O”](#richer_text_isoliduso), and, finally, how to build software showing text
    understandable to different users, across languages and cultures, in [“Internationalization”](#internationalization).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数现代程序依赖于图形用户界面（GUI），通常通过浏览器或智能手机应用程序，但基于文本的非图形“命令行”用户界面因其易用性、使用速度和可脚本化而仍然非常受欢迎。本章最后讨论了
    Python 中的非 GUI 文本输入和输出，包括[“文本输入和输出”](#text_input_and_output)中的终端文本 I/O，[“更丰富的文本
    I/O”](#richer_text_isoliduso)，以及如何构建能够跨语言和文化理解的软件，在[“国际化”](#internationalization)中有所介绍。
- en: The io Module
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: io 模块
- en: As mentioned in this chapter’s introduction, io is the standard library module
    in Python that provides the most common ways for your Python programs to read
    or write files. In modern Python, the built-in function open is an alias for the
    function io.open. Use io.open (or its built-in alias open) to make a Python file
    object to read from, and/or write to, a file as seen by the underlying operating
    system. The parameters you pass to open determine what type of object is returned.
    This object can be an instance of io.TextIOWrapper if textual, or, if binary,
    one of io.BufferedReader, io.BufferedWriter, or io.BufferedRandom, depending on
    whether it’s read-only, write-only, or read/write. This section covers the various
    types of file objects, as well as the important issue of making and using *temporary*
    files (on disk, or even in memory).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章介绍的那样，io 是 Python 标准库中负责提供读取或写入文件的最常见方式的模块。在现代 Python 中，内置函数 open 是函数 io.open
    的别名。使用 io.open（或其内置别名 open）可以创建一个 Python 文件对象，用于从文件中读取和/或写入数据，这个文件对象在底层操作系统中是可见的。传递给
    open 的参数决定了返回的对象类型。如果是文本类型，返回的对象可以是 io.TextIOWrapper 的实例；如果是二进制类型，则可能是 io.BufferedReader、io.BufferedWriter
    或 io.BufferedRandom 中的一个，具体取决于它是只读、只写还是读写。本节涵盖了各种类型的文件对象，以及如何创建和使用*临时*文件（在磁盘上或甚至是在内存中）的重要问题。
- en: I/O Errors Raise OSError
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: I/O Errors Raise OSError
- en: Python reacts to any I/O error related to a file object by raising an instance
    of built-in exception class OSError (many useful subclasses exist, as covered
    in [“OSError subclasses”](ch06.xhtml#oserror_subclasses)). Errors causing this
    exception include a failing open call, calls to a method on a file to which the
    method doesn’t apply (e.g., write on a read-only file, or seek on a nonseekable
    file), and actual I/O errors diagnosed by a file object’s methods.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Python 对与文件对象相关的任何 I/O 错误作出响应，通过引发内置异常类 OSError 的实例来处理（有许多有用的子类存在，如[“OSError
    子类”](ch06.xhtml#oserror_subclasses)中所述）。导致此异常的错误包括打开调用失败、对文件对象调用不适用于该方法的方法（例如，在只读文件上进行写入或在不可寻址文件上进行寻址），以及由文件对象的方法诊断出的实际
    I/O 错误。
- en: The io module also provides the underlying classes, both abstract and concrete,
    that, by inheritance and by composition (also known as *wrapping*), make up the
    file objects that your program generally uses. We do not cover these advanced
    topics in this book. If you have access to unusual channels for data, or nonfilesystem
    data storage, and want to provide a file interface to those channels or storage,
    you can ease your task (through appropriate subclassing and wrapping) using other
    classes in the io module. For assistance with such advanced tasks, consult the
    [online docs](https://docs.python.org/3/library/io.xhtml).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: io 模块还提供了底层类（抽象和具体），通过继承和组合（也称为*包装*），构成了您的程序通常使用的文件对象。本书不涵盖这些高级主题。如果您可以访问数据的非常规通道或非文件系统数据存储，并希望为这些通道或存储提供文件接口，可以通过适当的子类化和包装使用
    io 模块中的其他类来简化任务。有关这些高级任务的帮助，请参阅[在线文档](https://docs.python.org/3/library/io.xhtml)。
- en: Creating a File Object with open
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 open 创建文件对象
- en: 'To create a Python file object, call open with the following syntax:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 Python 文件对象，请使用以下语法调用 open：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'file can be a string or an instance of pathlib.Path (any path to a file as
    seen by the underlying OS), or an int (an OS-level *file descriptor* as returned
    by os.open, or by whatever function you pass as the opener argument). When file
    is a path (a string or pathlib.Path instance), open opens the file thus named
    (possibly creating it, depending on the mode argument—despite its name, open is
    not just for opening existing files: it can also create new ones). When file is
    an integer, the underlying OS file must already be open (via os.open).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: file 可以是字符串或 pathlib.Path 实例（作为底层操作系统所见的任何文件路径），也可以是整数（由 os.open 返回的操作系统级*文件描述符*，或您传递为
    opener 参数的任何函数返回的值）。当 file 是路径（字符串或 pathlib.Path 实例）时，open 打开指定的文件（根据模式参数可能会创建文件——尽管其名称是
    open，它不仅仅用于打开现有文件：它也可以创建新文件）。当 file 是整数时，操作系统文件必须已通过 os.open 打开。
- en: Opening a File Pythonically
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以 Python 风格打开文件
- en: 'open is a context manager: use **with** open(...) **as** *f*:, *not* *f* =
    open(...), to ensure the file *f* gets closed as soon as the **with** statement’s
    body is done.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: open 是一个上下文管理器：请使用 **with** open(...) **as** *f*:，而不是 *f* = open(...)，以确保文件
    *f* 在 **with** 语句的主体完成后关闭。
- en: open creates and returns an instance *f* of the appropriate io module class,
    depending on the mode and buffering settings. We refer to all such instances as
    file objects; they are polymorphic with respect to each other.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: open 创建并返回适当的 io 模块类的实例 *f*，具体取决于模式和缓冲设置。我们将所有这些实例称为文件对象；它们在彼此之间是多态的。
- en: mode
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模式
- en: mode is an optional string indicating how the file is to be opened (or created).
    The possible values for mode are listed in [Table 11-1](#mode_settings).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: mode 是一个可选的字符串，指示如何打开（或创建）文件。模式的可能取值列在[表 11-1](#mode_settings)中。
- en: Table 11-1\. mode settings
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-1\. 模式设置
- en: '| Mode | Meaning |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 含义 |'
- en: '| --- | --- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| ''a'' | The file is opened in write-only mode. The file is kept intact if
    it already exists, and the data you write is appended to the existing contents.
    The file is created if it does not exist. Calling *f*.seek on the file changes
    the result of the method *f*.tell, but does not change the write position in the
    file opened in this mode: that write position always remains at the end of the
    file. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| ''a'' | 文件以只写方式打开。如果文件已经存在，则保持文件不变，并将写入的数据附加到现有内容。如果文件不存在，则创建文件。在此模式下打开的文件，调用*f*.seek方法会改变*f*.tell方法的结果，但不会改变写入位置：该写入位置始终保持在文件末尾。
    |'
- en: '| ''a+'' | The file is opened for both reading and writing, so all methods
    of *f* can be called. The file is kept intact if it already exists, and the data
    you write is appended to the existing contents. The file is created if it does
    not exist. Calling *f*.seek on the file, depending on the underlying operating
    system, may have no effect when the next I/O operation on *f* *writes* data, but
    does work normally when the next I/O operation on *f* *reads* data. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| ''a+'' | 文件同时用于读取和写入，因此可以调用所有*f*的方法。如果文件已经存在，则保持不变，并且您写入的数据将附加到现有内容中。如果文件不存在，则创建文件。在文件上调用*f*.seek，根据底层操作系统的不同，可能在下一个*f*
    *写*数据的I/O操作时没有效果，但在下一个*f* *读*数据的I/O操作时通常会正常工作。 |'
- en: '| ''r'' | The file must already exist, and it is opened in read-only mode (this
    is the default). |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| ''r'' | 文件必须已经存在，并且以只读模式打开（这是默认设置）。 |'
- en: '| ''r+'' | The file must exist and is opened for both reading and writing,
    so all methods of *f* can be called. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| ''r+'' | 文件必须存在，并且同时用于读取和写入，因此可以调用所有*f*的方法。 |'
- en: '| ''w'' | The file is opened in write-only mode. The file is truncated to zero
    length and overwritten if it already exists, or created if it does not exist.
    |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| ''w'' | 文件以只写模式打开。如果文件已经存在，则将其截断为零长度并覆盖，如果文件不存在，则创建文件。 |'
- en: '| ''w+'' | The file is opened for both reading and writing, so all methods
    of *f* can be called. The file is truncated to zero length and overwritten if
    it already exists, or created if it does not exist. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| ''w+'' | 文件同时用于读取和写入，因此可以调用所有*f*的方法。如果文件已经存在，则将其截断为零长度并覆盖，如果文件不存在，则创建文件。
    |'
- en: Binary and text modes
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二进制和文本模式
- en: The mode string may include any of the values in [Table 11-1](#mode_settings),
    followed by a b or t. b indicates that the file should be opened (or created)
    in binary mode, while t indicates text mode. When neither b nor t is included,
    the default is text (i.e., 'r' is like 'rt', 'w+' is like 'w+t', and so on), but
    per [The Zen of Python](https://oreil.ly/QO8-Y), “explicit is better than implicit.”
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 模式字符串可以包括[表 11-1](#mode_settings)中的任何值，后跟b或t。b表示文件应以二进制模式打开（或创建），而t表示文本模式。当没有包括b或t时，默认为文本（即'r'类似于'rt'，'w+'类似于'w+t'，依此类推），但根据[Python之禅](https://oreil.ly/QO8-Y)，“显式胜于隐式”。
- en: Binary files let you read and/or write strings of type bytes, and text files
    let you read and/or write Unicode text strings of type str. For text files, when
    the underlying channel or storage system deals in bytes (as most do), encoding
    (the name of an encoding known to Python) and errors (an error-handler name such
    as 'strict', 'replace', and so on, as covered under decode in [Table 9-1](ch09.xhtml#significant_str_and_bytes_methods))
    matter, as they specify how to translate between text and bytes, and what to do
    on encoding and decoding errors.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件允许您读取和/或写入字节类型的字符串，而文本文件允许您读取和/或写入Unicode文本字符串类型的str。对于文本文件，当底层通道或存储系统处理字节（大多数情况下是这样）时，编码（已知Python的编码名称）和错误（一个错误处理程序名称，如'strict'、'replace'等，在[表 9-1](ch09.xhtml#significant_str_and_bytes_methods)的decode下有所涵盖）很重要，因为它们指定了如何在文本和字节之间进行转换，以及在编码和解码错误时该如何处理。
- en: Buffering
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓冲
- en: buffering is an integer value that denotes the buffering policy you’re requesting
    for the file. When buffering is 0, the file (which must be binary mode) is unbuffered;
    the effect is as if the file’s buffer is flushed every time you write anything
    to the file. When buffering is 1, the file (which *must* be open in text mode)
    is line buffered, which means the file’s buffer is flushed every time you write
    \n to the file. When buffering is greater than 1, the file uses a buffer of about
    buffering bytes, often rounded up to some value convenient for the driver software.
    When buffering is <0, a default is used, depending on the type of file stream.
    Normally, this default is line buffering for files that correspond to interactive
    streams, and a buffer of io.DEFAULT_BUFFER_SIZE bytes for other files.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲是一个整数值，表示您请求的文件缓冲策略。当缓冲为0时，文件（必须为二进制模式）是无缓冲的；其效果就像每次写入文件时都刷新文件的缓冲区一样。当缓冲为1时，文件（必须在文本模式下打开）是行缓冲的，这意味着每次写入\n到文件时都会刷新文件的缓冲区。当缓冲大于1时，文件使用大约缓冲字节数的缓冲区，通常向上舍入为某个方便驱动程序软件的值。当缓冲小于0时，默认值由文件流类型决定。通常，这个默认值是与交互式流相对应的行缓冲，并且对于其他文件使用io.DEFAULT_BUFFER_SIZE字节的缓冲区。
- en: Sequential and nonsequential (“random”) access
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 顺序和非顺序（“随机”）访问
- en: A file object *f* is inherently sequential (a stream of bytes or text). When
    you read, you get bytes or text in the sequential order in which they are present.
    When you write, the bytes or text you write are added in the order in which you
    write them.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 文件对象*f*本质上是顺序的（一系列字节或文本）。读取时，按照它们出现的顺序获取字节或文本。写入时，按照写入的顺序添加字节或文本。
- en: For a file object *f* to support nonsequential access (also known as random
    access), it must keep track of its current position (the position in the storage
    where the next read or write operation starts transferring data), and the underlying
    storage for the file must support setting the current position. *f*.seekable returns
    **True** when *f* supports nonsequential access.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文件对象*f*支持非顺序访问（也称为随机访问），它必须跟踪其当前位置（存储中下一个读取或写入操作开始传输数据的位置），并且文件的底层存储必须支持设置当前位置。当*f*.seekable返回**True**时，表示*f*支持非顺序访问。
- en: When you open a file, the default initial read/write position is at the start
    of the file. Opening *f* with a mode of 'a' or 'a+' sets *f*’s read/write position
    to the end of the file before writing data to *f*. When you write or read *n*
    bytes to/from file object *f*, *f*’s position advances by *n*. You can query the
    current position by calling *f*.tell, and change the position by calling *f*.seek,
    both covered in the next section.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件时，默认的初始读/写位置是在文件的开头。使用模式'a'或'a+'打开*f*将*f*的读/写位置设置为在写入数据之前的文件末尾。当向文件对象*f*写入或读取*n*字节时，*f*的位置将前进*n*。您可以通过调用*f*.tell查询当前位置，并通过调用*f*.seek更改位置，这两者在下一节中有详细介绍。
- en: When calling *f*.seek on a text-mode *f*, the offset you pass must be 0 (to
    position *f* at the start or end, depending on *f*.seek’s second parameter), or
    the opaque result returned by an earlier call to *f*.tell,^([1](ch11.xhtml#ch01fn99))
    to position *f* back to a spot you had thus “bookmarked” before.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本模式的*f*上调用*f*.seek时，传递的偏移量必须为0（将*f*定位在开头或结尾，取决于*f*.seek的第二个参数），或者是先前调用*f*.tell返回的不透明结果^([1](ch11.xhtml#ch01fn99))，以将*f*定位回之前“书签”过的位置。
- en: Attributes and Methods of File Objects
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件对象的属性和方法
- en: A file object *f* supplies the attributes and methods documented in [Table 11-2](#attributes_and_methods_of_file_objects).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 文件对象*f*提供了[表 11-2](#attributes_and_methods_of_file_objects)中记录的属性和方法。
- en: Table 11-2\. Attributes and methods of file objects
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-2\. 文件对象的属性和方法
- en: '| close | close() Closes the file. You can call no other method on *f* after
    *f*.close. Multiple calls to *f*.close are allowed and innocuous. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| close | close() 关闭文件。在*f*.close之后不能再调用*f*的其他方法。允许多次调用*f*.close而无害。 |'
- en: '| closed | *f*.closed is a read-only attribute that is **True** when *f*.close()
    has been called; otherwise, it is **False**. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| closed | *f*.closed是一个只读属性。当*f*.close()已调用时，返回**True**；否则返回**False**。 |'
- en: '| encoding | *f*.encoding is a read-only attribute, a string naming the encoding
    (as covered in [“Unicode”](ch09.xhtml#unicode)). The attribute does not exist
    on binary files. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| encoding | *f*.encoding是一个只读属性，是指定的编码名称（如在[“Unicode”](ch09.xhtml#unicode)中介绍）。该属性在二进制文件上不存在。
    |'
- en: '| fileno | fileno() Returns the file descriptor of *f*’s file at operating
    system level (an integer). File descriptors are covered in [“File and directory
    functions of the os module”](#file_and_directory_functions_of_the_os). |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| fileno | fileno() 返回*f*的文件在操作系统级别的文件描述符（一个整数）。文件描述符在[“os模块的文件和目录函数”](#file_and_directory_functions_of_the_os)中有介绍。
    |'
- en: '| flush | flush() Requests that *f*’s buffer be written out to the operating
    system, so that the file as seen by the system has the exact contents that Python’s
    code has written. Depending on the platform and the nature of *f*’s underlying
    file, *f*.flush may not be able to ensure the desired effect. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| flush | flush() 请求将*f*的缓冲区写入操作系统，使得系统看到的文件与Python代码写入的内容完全一致。根据平台和*f*的底层文件性质，*f*.flush可能无法确保所需的效果。
    |'
- en: '| isatty | isatty() Returns **True** when *f*’s underlying file is an interactive
    stream, such as to or from a terminal; otherwise, returns **False**. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| isatty | isatty() 当*f*的底层文件是交互流（例如来自终端或到终端）时返回**True**；否则返回**False**。 |'
- en: '| mode | *f*.mode is a read-only attribute that is the value of the mode string
    used in the io.open call that created *f*. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| mode | *f*.mode是一个只读属性，其值是在创建*f*的io.open调用中使用的模式字符串。 |'
- en: '| name | *f*.name is a read-only attribute that is the value of the file (str
    or bytes) or int used in the io.open call that created *f*. When io.open was called
    with a pathlib.Path instance *p*, *f*.name is str(*p*). |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| name | *f*.name 是一个只读属性，其值是创建*f*的io.open调用中使用的文件（str或bytes）或int。当io.open使用pathlib.Path实例*p*调用时，*f*.name是str(*p*)。
    |'
- en: '| read | read(*size*=-1, /) When *f* is open in binary mode, reads up to *size*
    bytes from *f*’s file and returns them as a bytestring. read reads and returns
    less than *size* bytes if the file ends before *size* bytes are read. When *size*
    is less than 0, read reads and returns all bytes up to the end of the file. read
    returns an empty string when the file’s current position is at the end of the
    file or when *size* equals 0. When *f* is open in text mode, *size* is a number
    of characters, not bytes, and read returns a text string. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| read | read(*size*=-1, /) 当*f*以二进制模式打开时，从*f*的文件中读取最多*size*字节并将它们作为字节字符串返回。如果文件在读取*size*字节之前结束，则read读取并返回少于*size*字节。当*size*小于0时，read读取并返回直到文件末尾的所有字节。当文件的当前位置在文件末尾或*size*等于0时，read返回一个空字符串。当*f*以文本模式打开时，*size*表示字符数而不是字节数，read返回一个文本字符串。
    |'
- en: '| readline | readline(*size*=-1, /) Reads and returns one line from *f*’s file,
    up to the end of line (\n), included. When *size* is greater than or equal to
    0, reads no more than *size* bytes. In that case, the returned string might not
    end with \n. \n might also be absent when readline reads up to the end of the
    file without finding \n. readline returns an empty string when the file’s current
    position is at the end of the file or when *size* equals 0. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| readline | readline(*size*=-1, /) 从*f*的文件中读取并返回一行，直到行尾（\n）为止。当*size*大于或等于0时，最多读取*size*字节。在这种情况下，返回的字符串可能不以\n结尾。当文件的当前位置在文件末尾或*size*等于0时，readline返回一个空字符串。当readline读取到文件末尾且未找到\n时，\n可能也会不存在。
    |'
- en: '| readlines | readlines(*size*=-1, /) Reads and returns a list of all lines
    in *f*’s file, each a string ending in \n. If *size* > 0, readlines stops and
    returns the list after collecting data for a total of about *size* bytes rather
    than reading all the way to the end of the file; in that case, the last string
    in the list might not end in \n. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| readlines | readlines(*size*=-1, /) 读取并返回文件*f*中所有行的列表，每行都是以\n结尾的字符串。如果*size*
    > 0，则readlines在收集了约*size*字节的数据后停止并返回列表；在这种情况下，列表中的最后一个字符串可能不以\n结尾。 |'
- en: '| seek | seek(*pos*, *how*=io.SEEK_SET, /) Sets *f*’s current position to the
    integer byte offset *pos* away from a reference point. *how* indicates the reference
    point. The io module has attributes named SEEK_SET, SEEK_CUR, and SEEK_END, to
    specify that the reference point is, respectively, the file’s beginning, current
    position, or end.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '| seek | seek(*pos*, *how*=io.SEEK_SET, /) 将*f*的当前位置设置为离参考点*pos*字节偏移的整数。*how*指示参考点。io模块有名为SEEK_SET、SEEK_CUR和SEEK_END的属性，分别指定参考点为文件的开头、当前位置或结尾。
    |'
- en: When *f* is opened in text mode, *f*.seek must have a *pos* of 0, or, for io.SEEK_SET
    only, a *pos* that is the result of a previous call to *f*.tell.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当*f*以文本模式打开时，*f*.seek必须为0，或者对于io.SEEK_SET，*f*.seek的*pos*必须是上一次调用*f*.tell的结果。
- en: When *f* is opened in mode 'a' or 'a+', on some but not all platforms, data
    written to *f* is appended to the data that is already in *f*, regardless of calls
    to *f*.seek. |
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当*f*以模式'a'或'a+'打开时，在某些平台上，写入*f*的数据会追加到已经存在*f*中的数据，而不管对*f*.seek的调用。 |
- en: '| tell | tell() Returns *f*’s current position: for a binary file this is an
    integer offset in bytes from the start of the file, and for a text file it’s an
    opaque value usable in future calls to *f*.seek to position *f* back to the position
    that is now current. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| tell | tell() 返回*f*的当前位置：对于二进制文件，这是从文件开头的字节偏移量，对于文本文件，这是一个不透明的值，可在将来调用*f*.seek将*f*定位回当前位置使用。
    |'
- en: '| truncate | truncate(*size*=None, /) Truncates *f*’s file, which must be open
    for writing. When *size* is present, truncates the file to be at most *size* bytes.
    When *size* is absent, uses *f*.tell() as the file’s new size. *size* may be larger
    than the current file size; in this case, the resulting behavior is platform dependent.
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| truncate | truncate(*size*=None, /) 截断*f*的文件，*f*必须已经打开以进行写入。当*size*存在时，将文件截断为最多*size*字节。当*size*不存在时，使用*f*.tell()作为文件的新大小。*size*可能比当前文件大小大；在这种情况下，结果行为取决于平台。
    |'
- en: '| write | write(*s*, /) Writes the bytes of string *s* (binary or text, depending
    on *f*’s mode) to the file. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| write | write(*s*, /) 将字符串*s*的字节（根据*f*的模式是二进制还是文本）写入文件。 |'
- en: '| writelines | writelines(*lst*, /) Like:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '| writelines | writelines(*lst*, /) 类似于：'
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It does not matter whether the strings in iterable *lst* are lines: despite
    its name, the method writelines just writes each of the strings to the file, one
    after the other. In particular, writelines does not add line-ending markers: such
    markers, if required, must already be present in the items of *lst*. |'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*lst* 可迭代的字符串是否为行并不重要：尽管其名称如此，writelines 方法只是将每个字符串依次写入文件。特别地，writelines 不会添加行结束标记：如果需要的话，这些标记必须已经存在于
    *lst* 的项目中。'
- en: Iteration on File Objects
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件对象的迭代
- en: 'A file object *f*, open for reading, is also an iterator whose items are the
    file’s lines. Thus, the loop:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于读取的文件对象 *f* 也是一个迭代器，其项是文件的行。因此，下面的循环：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: iterates on each line of the file. Due to buffering issues, interrupting such
    a loop prematurely (e.g., with **break**), or calling next(*f*) instead of *f*.readline(),
    leaves the file’s position set to an arbitrary value. If you want to switch from
    using *f* as an iterator to calling other reading methods on *f*, be sure to set
    the file’s position to a known value by appropriately calling *f*.seek. On the
    plus side, a loop directly on *f* has very good performance, since these specifications
    allow the loop to use internal buffering to minimize I/O without taking up excessive
    amounts of memory even for huge files.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历文件的每一行。由于缓冲问题，如果在这样的循环中过早中断（例如使用 **break**），或者调用 next(*f*) 而不是 *f*.readline()，则文件的位置将设置为任意值。如果您希望从在
    *f* 上进行迭代切换到在 *f* 上调用其他读取方法，请确保通过适当地调用 *f*.seek 将文件的位置设置为已知值。好处是，直接在 *f* 上进行循环具有非常好的性能，因为这些规格允许循环使用内部缓冲以最小化I/O，即使对于大文件也不会占用过多的内存。
- en: File-Like Objects and Polymorphism
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件类对象与多态性
- en: 'An object *x* is file-like when it behaves *polymorphically* to a file object
    as returned by io.open, meaning that we can use *x* “as if” *x* were a file. Code
    using such an object (known as *client code* of the object) usually gets the object
    as an argument, or by calling a factory function that returns the object as the
    result. For example, if the only method that client code calls on *x* is *x*.read,
    without arguments, then all *x* needs to supply in order to be file-like enough
    for that code is a method read that is callable without arguments and returns
    a string. Other client code may need *x* to implement a larger subset of file
    methods. File-like objects and polymorphism are not absolute concepts: they are
    relative to demands placed on an object by some specific client code.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个对象 *x* 表现得像一个由 io.open 返回的文件对象时，它就是类似文件的。这意味着我们可以像使用文件一样使用 *x*。使用这样一个对象的代码（称为对象的
    *客户端代码*）通常通过参数获取对象，或者通过调用返回该对象的工厂函数获取对象。例如，如果客户端代码在 *x* 上唯一调用的方法是 *x*.read（无参数），那么为了这段代码，*x*
    需要提供的仅仅是一个可调用的、无参数的 read 方法，并且返回一个字符串。其他客户端代码可能需要 *x* 实现更大的文件方法子集。文件类对象和多态性并非绝对概念：它们是相对于某些特定客户端代码对对象提出的要求而言的。
- en: Polymorphism is a powerful aspect of object-oriented programming, and file-like
    objects are a good example of polymorphism. A client-code module that writes to
    or reads from files can automatically be reused for data residing elsewhere, as
    long as the module does not break polymorphism by type checking. When we discussed
    the built-ins type and isinstance in [Table 8-1](ch08.xhtml#pythonapostrophes_core_built_in_types),
    we mentioned that type checking is often best avoided, as it blocks Python’s normal
    polymorphism. Often, to support polymorphism in your client code, you just need
    to avoid type checking.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 多态是面向对象编程中强大的一个方面，文件类对象是多态的一个很好的例子。一个写入或读取文件的客户端模块可以自动地被重用于其他数据，只要该模块不通过类型检查来破坏多态性。当我们讨论内置类型和isinstance在[表 8-1](ch08.xhtml#pythonapostrophes_core_built_in_types)中时，我们提到类型检查通常最好避免，因为它会阻碍Python的正常多态性。通常，为了支持你的客户端代码的多态性，你只需要避免类型检查。
- en: You can implement a file-like object by coding your own class (as covered in
    [Chapter 4](ch04.xhtml#object_oriented_python)) and defining the specific methods
    needed by client code, such as read. A file-like object *fl* need not implement
    all the attributes and methods of a true file object *f*. If you can determine
    which methods the client code calls on *fl*, you can choose to implement only
    that subset. For example, when *fl* is only going to be written, *fl* doesn’t
    need “reading” methods, such as read, readline, and readlines.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过编写自己的类来实现类似文件的对象（如在[第4章](ch04.xhtml#object_oriented_python)中介绍的），并定义客户端代码所需的特定方法，比如read。文件样对象*fl*不必实现真实文件对象*f*的所有属性和方法。如果你可以确定客户端代码在*fl*上调用哪些方法，你可以选择只实现那些子集。例如，当*fl*只用于写入时，*fl*不需要“读取”方法，如read、readline和readlines。
- en: 'If the main reason you want a file-like object instead of a real file object
    is to keep the data in memory, rather than on disk, use the io module’s classes
    StringIO or BytesIO, covered in [“In-Memory Files: io.StringIO and io.BytesIO”](#in_memory_files_iodotstringio_and_iodot).
    These classes supply file objects that hold data in memory and largely behave
    polymorphically to other file objects. If you’re running multiple processes that
    you want to communicate via file-like objects, consider mmap, covered in [Chapter 15](ch15.xhtml#concurrency_threads_and_processes).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个类似文件的对象而不是真实文件对象的主要原因是将数据保存在内存中而不是磁盘上，可以使用io模块的StringIO或BytesIO类（详见[“内存中的文件：io.StringIO和io.BytesIO”](#in_memory_files_iodotstringio_and_iodot)）。这些类提供了在内存中保存数据并且在大多数情况下表现得与其他文件对象多态的文件对象。如果你正在运行多个进程，希望通过类似文件的对象进行通信，考虑使用mmap，详见[第15章](ch15.xhtml#concurrency_threads_and_processes)。
- en: The tempfile Module
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: tempfile模块
- en: The tempfile module lets you create temporary files and directories in the most
    secure manner afforded by your platform. Temporary files are often a good idea
    when you’re dealing with an amount of data that might not comfortably fit in memory,
    or when your program must write data that another process later uses.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: tempfile模块允许你以平台所允许的最安全方式创建临时文件和目录。当你处理的数据量可能不适合放入内存，或者你的程序必须写入稍后由另一个进程使用的数据时，临时文件通常是一个好主意。
- en: 'The order of the parameters for the functions in this module is a bit confusing:
    to make your code more readable, always call these functions with named-argument
    syntax. The tempfile module exposes the functions and classes outlined in [Table 11-3](#functions_and_classes_of_the_tempfile_m).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块中函数的参数顺序有点混乱：为了使你的代码更易读，请始终使用命名参数语法调用这些函数。tempfile模块公开了表格11-3中概述的函数和类。
- en: Table 11-3\. Functions and classes of the tempfile module
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 表格11-3\. tempfile模块的函数和类
- en: '| mkdtemp | mkdtemp(suffix=**None**, prefix=**None**, dir=None) Securely creates
    a new temporary directory that is readable, writable, and searchable only by the
    current user, and returns the absolute path to the temporary directory. You can
    optionally pass arguments to specify strings to use as the start (prefix) and
    end (suffix) of the temporary file’s filename, and the path to the directory in
    which the temporary file is created (dir). Ensuring that the temporary directory
    is removed when you’re done with it is your program’s responsibility. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| mkdtemp | mkdtemp(suffix=**None**, prefix=**None**, dir=None) 安全创建一个新的临时目录，只有当前用户可以读取、写入和搜索，然后返回临时目录的绝对路径。你可以选择传递参数来指定用作临时文件名开头（前缀）和结尾（后缀）的字符串，以及创建临时文件的目录路径（dir）。确保在使用完毕后删除临时目录是你程序的责任。
    |'
- en: '| mkdtemp *(cont.)* | Here is a typical usage example that creates a temporary
    directory, passes its path to another function, and finally ensures the directory
    (and all contents) are removed:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '| mkdtemp *(cont.)* | 这里是一个典型的使用示例，它创建一个临时目录，将其路径传递给另一个函数，最后确保目录（及其所有内容）被删除：'
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| mkstemp | mkstemp(suffix=**None**, prefix=**None**, dir=**None**, text=**False**)
    Securely creates a new temporary file that is readable and writable only by the
    current user, is not executable, and is not inherited by subprocesses; returns
    a pair (*fd*, *path*), where *fd* is the file descriptor of the temporary file
    (as returned by os.open, covered in [Table 11-18](#useful_os_module_functions_to_deal_with))
    and the string *path* is the absolute path to the temporary file. The optional
    arguments suffix, prefix, and dir are like for the function mkdtemp. If you want
    the temporary file to be a text file, explicitly pass the argument text=**True**.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '| mkstemp | mkstemp(suffix=**None**, prefix=**None**, dir=**None**, text=**False**)
    安全地创建一个新的临时文件，只有当前用户可读可写，不可执行，并且不被子进程继承；返回一对（*fd*，*path*），其中 *fd* 是临时文件的文件描述符（由
    os.open 返回，见 [Table 11-18](#useful_os_module_functions_to_deal_with)）, 字符串 *path*
    是临时文件的绝对路径。可选参数 suffix，prefix 和 dir 类似于函数 mkdtemp。如果你想让临时文件成为文本文件，请显式传递参数 text=**True**。'
- en: 'Ensuring that the temporary file is removed when you’re done using it is up
    to you. mkstemp is not a context manager, so you can’t use a **with** statement;
    it’s best to use **try**/**finally** instead. Here is a typical usage example
    that creates a temporary text file, closes it, passes its path to another function,
    and finally ensures the file is removed:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在使用完临时文件后将其删除由你来负责。mkstemp 不是一个上下文管理器，所以你不能使用 **with** 语句；最好使用 **try**/**finally**
    代替。以下是一个典型的使用示例，创建一个临时文本文件，关闭它，将其路径传递给另一个函数，最后确保文件被删除：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Nam⁠e⁠d​T⁠e⁠m⁠p⁠o⁠r⁠a⁠r⁠y​F⁠i⁠l⁠e | NamedTemporaryFile(mode=''w+b'', bufsize=-1,
    suffix=**None**, prefix=**None**, dir=**None**)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '| Nam⁠e⁠d​T⁠e⁠m⁠p⁠o⁠r⁠a⁠r⁠y​F⁠i⁠l⁠e | NamedTemporaryFile(mode=''w+b'', bufsize=-1,
    suffix=**None**, prefix=**None**, dir=**None**)'
- en: Like TemporaryFile (covered later in this table), except that the temporary
    file does have a name on the filesystem. Use the name attribute of the file object
    to access that name. Some platforms (mainly Windows) do not allow the file to
    be opened again; therefore, the usefulness of the name is limited if you want
    to ensure that your program works cross-platform. If you need to pass the temporary
    file’s name to another program that opens the file, you can use the function mkstemp
    instead of NamedTemporaryFile to guarantee correct cross-platform behavior. Of
    course, when you choose to use mkstemp, you do have to take care to ensure the
    file is removed when you’re done with it. The file object returned from NamedTemporaryFile
    is a context manager, so you can use a with statement. |
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与 TemporaryFile（稍后在此表中讨论）类似，不同之处在于临时文件确实在文件系统上有一个名称。使用文件对象的 name 属性来访问该名称。一些平台（主要是
    Windows）不允许再次打开文件；因此，如果要确保程序跨平台运行，名称的有用性是有限的。如果需要将临时文件的名称传递给另一个打开文件的程序，可以使用函数
    mkstemp 而不是 NamedTemporaryFile 来保证正确的跨平台行为。当然，当你选择使用 mkstemp 时，确保在完成后删除文件是需要注意的。从
    NamedTemporaryFile 返回的文件对象是一个上下文管理器，因此可以使用 with 语句。|
- en: '| Spoo⁠l⁠e⁠d​T⁠e⁠m⁠p⁠o⁠r⁠a⁠r⁠y​F⁠i⁠l⁠e | SpooledTemporaryFile(mode=''w+b'',
    bufsize=-1, suffix=**None**, prefix=**None**, dir=**None**) Like TemporaryFile
    (see below), except that the file object that SpooledTemporaryFile returns can
    stay in memory, if space permits, until you call its fileno method (or its rollover
    method, which ensures the file gets written to disk, whatever its size). As a
    result, performance can be better with SpooledTemporaryFile, as long as you have
    enough memory that’s not otherwise in use. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| Spoo⁠l⁠e⁠d​T⁠e⁠m⁠p⁠o⁠r⁠a⁠r⁠y​F⁠i⁠l⁠e | SpooledTemporaryFile(mode=''w+b'',
    bufsize=-1, suffix=**None**, prefix=**None**, dir=**None**) 类似于 TemporaryFile（见下文），不同之处在于
    SpooledTemporaryFile 返回的文件对象可以保留在内存中，如果空间允许，直到你调用其 fileno 方法（或其 rollover 方法，它确保文件被写入磁盘，无论其大小如何）。因此，只要有足够的内存未被其他方式使用，使用
    SpooledTemporaryFile 可能性能更好。|'
- en: '| TemporaryDirectory | TemporaryDirectory(suffix=None, prefix=**None**, dir=**None**,
    ignore_cleanup_errors=**False**) Creates a temporary directory, like mkdtemp (passing
    the optional arguments suffix, prefix, and dir). The returned directory object
    is a context manager, so you can use a **with** statement to ensure it’s removed
    as soon as you’re done with it. Alternatively, when you’re not using it as a context
    manager, use its built-in class method cleanup (*not* shutil.rmtree) to explicitly
    remove and clean up the directory. Set ignore_cleanup_errors to **True** to ignore
    unhandled exceptions during cleanup. The temporary directory and its contents
    are removed as soon as the directory object is closed (whether implicitly on garbage
    collection or explicitly by a cleanup call). |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| TemporaryDirectory | TemporaryDirectory(suffix=None, prefix=**None**, dir=**None**,
    ignore_cleanup_errors=**False**) 创建临时目录，类似于 mkdtemp（传递可选参数 suffix、prefix 和 dir）。返回的目录对象是一个上下文管理器，因此您可以使用**with**语句确保在完成后立即删除它。或者，当您不将其用作上下文管理器时，可以使用其内置类方法
    cleanup（*而不是* shutil.rmtree）显式删除和清理目录。将 ignore_cleanup_errors 设置为 **True** 可以忽略清理过程中的未处理异常。临时目录及其内容在目录对象关闭时（无论是隐式地由垃圾回收还是显式地通过
    cleanup 调用）立即删除。'
- en: '| TemporaryFile | TemporaryFile(mode=''w+b'', bufsize=-1, suffix=**None**,
    prefix=**None**, dir=**None**)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '| TemporaryFile | TemporaryFile(mode=''w+b'', bufsize=-1, suffix=**None**,
    prefix=**None**, dir=**None**)'
- en: Creates a temporary file with mkstemp (passing to mkstemp the optional arguments
    suffix, prefix, and dir), makes a file object from it with os.fdopen, covered
    in [Table 11-18](#useful_os_module_functions_to_deal_with) (passing to fdopen
    the optional arguments mode and bufsize), and returns the file object. The temporary
    file is removed as soon as the file object is closed (implicitly or explicitly).
    For greater security, the temporary file has no name on the filesystem, if your
    platform allows that (Unix-like platforms do; Windows doesn’t). The file object
    returned from TemporaryFile is a context manager, so you can use a **with** statement
    to ensure it’s removed as soon as you’re done with it. |
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 mkstemp 创建临时文件（传递给 mkstemp 可选参数 suffix、prefix 和 dir），使用 os.fdopen 将其转换为文件对象，见
    [Table 11-18](#useful_os_module_functions_to_deal_with)（传递给 fdopen 可选参数 mode 和
    bufsize），然后返回文件对象。临时文件在文件对象关闭时立即删除（隐式或显式）。为了提高安全性，如果您的平台允许（类 Unix 平台允许，Windows
    不允许），临时文件在文件系统上没有名称。从 TemporaryFile 返回的文件对象是一个上下文管理器，因此您可以使用**with**语句确保在完成后立即删除它。
- en: Auxiliary Modules for File I/O
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于文件 I/O 的辅助模块
- en: File objects supply the functionality needed for file I/O. Other Python library
    modules, however, offer convenient supplementary functionality, making I/O even
    easier and handier in several important cases. We’ll look at two of those modules
    here.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 文件对象提供了文件 I/O 所需的功能。然而，其他 Python 库模块提供了方便的附加功能，在几个重要情况下使 I/O 更加简单和方便。我们将在这里看到其中的两个模块。
- en: The fileinput Module
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: fileinput 模块
- en: The fileinput module lets you loop over all the lines in a list of text files.
    Performance is good—comparable to the performance of direct iteration on each
    file—since buffering is used to minimize I/O. You can therefore use this module
    for line-oriented file input whenever you find its rich functionality convenient,
    with no worry about performance. The key function of the module is input; fileinput
    also supplies a FileInput class whose methods support the same functionality.
    Both are described in [Table 11-4](#key_classes_and_functions_of_the_filein).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: fileinput 模块允许您循环遍历文本文件列表中的所有行。性能很好——与直接迭代每个文件的性能相当，因为使用缓冲区减少 I/O。因此，无论何时发现其丰富功能方便，都可以使用该模块进行基于行的文件输入，而不必担心性能问题。模块的关键函数是
    input；fileinput 还提供了支持相同功能的 FileInput 类。两者在 [Table 11-4](#key_classes_and_functions_of_the_filein)
    中描述。
- en: Table 11-4\. Key classes and functions of the fileinput module
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Table 11-4\. fileinput 模块的关键类和函数
- en: '| FileInput | **class** FileInput(files=**None**, inplace=**False**, backup='''',
    mode=''r'', openhook=**None**, encoding=**None**, errors=**None**) Creates and
    returns an instance *f* of class FileInput. The arguments are the same as for
    fileinput.input covered next, and methods of *f* have the same names, arguments,
    and semantics as the other functions of the fileinput module (see [Table 11-5](#additional_functions_of_the_fileinput_m)).
    *f* also supplies a readline method, which reads and returns the next line. Use
    the FileInput class to nest or mix loops that read lines from multiple sequences
    of files. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| FileInput | **类** FileInput(files=**None**, inplace=**False**, backup='''',
    mode=''r'', openhook=**None**, encoding=**None**, errors=**None**) 创建并返回FileInput类的实例*f*。参数与接下来介绍的fileinput.input相同，*f*的方法具有与文件输入模块的其他函数相同的名称、参数和语义（见[表 11-5](#additional_functions_of_the_fileinput_m)）。*f*还提供了一个readline方法，它读取并返回下一行。使用FileInput类来嵌套或混合从多个文件序列中读取行的循环。
    |'
- en: '| input | input(files=None, inplace=**False**, backup='''', mode=''r'', openhook=**None**,
    encoding=**None**, errors=**None**)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '| input | input(files=None, inplace=**False**, backup='''', mode=''r'', openhook=**None**,
    encoding=**None**, errors=**None**)'
- en: Returns an instance of FileInput, an iterable yielding lines in files; that
    instance is the global state, so all other functions of the fileinput module (see
    [Table 11-5](#additional_functions_of_the_fileinput_m)) operate on the same shared
    state. Each function of the fileinput module corresponds directly to a method
    of the class FileInput.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个FileInput的实例，它是一个在文件中生成行的可迭代对象；该实例是全局状态，因此文件输入模块的所有其他函数（见[表 11-5](#additional_functions_of_the_fileinput_m)）都操作相同的共享状态。文件输入模块的每个函数直接对应于类FileInput的一个方法。
- en: files is a sequence of filenames to open and read one after the other, in order.
    When files is a string, it’s a single filename to open and read. When files is
    **None**, input uses sys.argv[1:] as the list of filenames. The filename '-' means
    standard input (sys.stdin). When the sequence of filenames is empty, input reads
    sys.stdin instead.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: files是要依次打开和读取的文件名序列。当files是一个字符串时，它是要打开和读取的单个文件名。当files为**None**时，input使用sys.argv[1:]作为文件名列表。文件名'-'表示标准输入（sys.stdin）。当文件名序列为空时，input读取sys.stdin。
- en: When inplace is **False** (the default), input just reads the files. When inplace
    is **True**, input moves each file being read (except standard input) to a backup
    file and redirects standard output (sys.stdout) to write to a new file with the
    same path as the original one of the file being read. This way, you can simulate
    overwriting files in place. If backup is a string that starts with a dot, input
    uses backup as the extension of the backup files and does not remove the backup
    files. If backup is an empty string (the default), input uses *.bak* and deletes
    each backup file as the input files are closed. The keyword argument mode may
    be 'r', the default, or 'rb'.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当inplace为**False**（默认值）时，input只读取文件。当inplace为**True**时，input将正在读取的每个文件（除标准输入外）移动到备份文件，并重定向标准输出（sys.stdout）以写入具有与正在读取的原始文件相同路径的新文件。这样，您可以模拟就地覆盖文件。如果backup是以点开头的字符串，则input将backup用作备份文件的扩展名，并且不会删除备份文件。如果backup是一个空字符串（默认值），input将使用*.bak*并在关闭输入文件时删除每个备份文件。关键字参数mode可以是'r'，默认值，也可以是'rb'。
- en: You may optionally pass an openhook function to use as an alternative to io.open.
    For example, openhook=fileinput.hook_compressed decompresses any input file with
    extension *.gz* or *.bz2* (not compatible with inplace=**True**). You can write
    your own openhook function to decompress other file types, for example using LZMA
    decompression^([a](ch11.xhtml#ch01fn100)) for *.xz* files; use the [Python source
    for fileinput.hook_compressed](https://oreil.ly/qXxx1) as a template. 3.10+ You
    can also pass encoding and errors, which will be passed to the hook as keyword
    arguments . |
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择传递一个openhook函数来替代io.open。例如，openhook=fileinput.hook_compressed可以解压缩带有扩展名*.gz*或*.bz2*的任何输入文件（与inplace=**True**不兼容）。您可以编写自己的openhook函数来解压缩其他文件类型，例如使用LZMA解压缩*.xz*文件；使用[fileinput.hook_compressed的Python源代码](https://oreil.ly/qXxx1)作为模板。3.10+
    您还可以传递encoding和errors，它们将作为关键字参数传递给钩子。 |
- en: '| ^([a](ch11.xhtml#ch01fn100-marker)) LZMA support may require building Python
    with optional additional libraries. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch11.xhtml#ch01fn100-marker)) LZMA支持可能需要使用可选的附加库构建Python。 |'
- en: The functions of the fileinput module listed in [Table 11-5](#additional_functions_of_the_fileinput_m)
    work on the global state created by fileinput.input, if any; otherwise, they raise
    RuntimeError.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列在[表 11-5](#additional_functions_of_the_fileinput_m)中的文件输入模块的函数在由fileinput.input创建的全局状态上运行，如果有的话；否则，它们会引发RuntimeError。
- en: Table 11-5\. Additional functions of the fileinput module
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-5\. fileinput 模块的附加函数
- en: '| close | close() Closes the whole sequence so that iteration stops and no
    file remains open. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| close | close() 关闭整个序列，停止迭代并且没有文件保持打开状态。 |'
- en: '| filelineno | filelineno() Returns the number of lines read so far from the
    file now being read. For example, returns 1 if the first line has just been read
    from the current file. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| filelineno | filelineno() 返回目前为止从正在读取的文件中读取的行数。例如，如果刚刚从当前文件读取了第一行，则返回 1。'
- en: '| filename | filename() Returns the name of the file now being read, or **None**
    if no line has been read yet. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| filename | filename() 返回当前正在读取的文件的名称，如果尚未读取任何行则返回 **None**。 |'
- en: '| isfirstline | isfirstline() Returns **True** or **False**, just like filelineno()
    == 1. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| isfirstline | isfirstline() 返回 **True** 或 **False**，就像 filelineno() == 1
    一样。 |'
- en: '| isstdin | isstdin() Returns **True** when the current file being read is
    sys.stdin; otherwise, returns **False**. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| isstdin | isstdin() 当前正在读取的文件是 sys.stdin 时返回 **True**；否则返回 **False**。 |'
- en: '| lineno | lineno() Returns the total number of lines read since the call to
    input. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| lineno | lineno() 返回自调用输入函数以来读取的总行数。'
- en: '| nextfile | nextfile() Closes the file being read: the next line to read is
    the first one of the next file. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| nextfile | nextfile() 关闭当前正在读取的文件：下一行要读取的是下一个文件的第一行。 |'
- en: 'Here’s a typical example of using fileinput for a “multifile search and replace,”
    changing one string into another throughout the text files whose names were passed
    as command-line arguments to the script:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用 fileinput 进行“多文件搜索和替换”的典型示例，将一个字符串更改为另一个字符串，应用于通过命令行参数传递给脚本的文本文件：
- en: '[PRE5]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In such cases it’s important to include the end='' argument to print, since
    each line has its line-end character \n at the end, and you need to ensure that
    print doesn’t add another (or else each file would end up “double-spaced”).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，包括 end='' 参数来打印是很重要的，因为每行在末尾都有其换行符 \n，并且您需要确保 print 不会再添加另一个（否则每个文件最终会变成“双空格”）。
- en: 'You may also use the FileInput instance returned by fileinput.input as a context
    manager. Just as with io.open, this will close all files opened by the FileInput
    upon exiting the **with** statement, even if an exception occurs:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用由 fileinput.input 返回的 FileInput 实例作为上下文管理器。与 io.open 一样，这将在退出 **with**
    语句时关闭由 FileInput 打开的所有文件，即使发生异常也是如此：
- en: '[PRE6]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The struct Module
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构体 Module
- en: The struct module lets you pack binary data into a bytestring, and unpack the
    bytes of such a bytestring back into the Python data they represent. This is useful
    for many kinds of low-level programming. Often, you use struct to interpret data
    records from binary files that have some specified format, or to prepare records
    to write to such binary files. The module’s name comes from C’s keyword struct,
    which is usable for related purposes. On any error, functions of the module struct
    raise exceptions that are instances of the exception class struct.error.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体模块允许您将二进制数据打包成字节串，并将这样的字节串解包回它们所表示的 Python 数据。这对于许多类型的低级编程很有用。通常，您使用 struct
    来解释来自具有某些指定格式的二进制文件的数据记录，或者准备要写入此类二进制文件的记录。模块的名称来自于 C 语言中的关键字 struct，用于类似的目的。在任何错误情况下，结构模块的函数会引发异常，这些异常是
    struct.error 类的实例。
- en: The struct module relies on *struct format strings* following a specific syntax.
    The first character of a format string gives the [byte order](https://oreil.ly/rqogV),
    size, and alignment of the packed data; the options are listed in [Table 11-6](#possible_first_characters_in_a_struct_f).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体模块依赖于遵循特定语法的 *结构格式字符串*。格式字符串的第一个字符给出了打包数据的[字节顺序](https://oreil.ly/rqogV)、大小和对齐方式；选项列在[表 11-6](#possible_first_characters_in_a_struct_f)中。
- en: Table 11-6\. Possible first characters in a struct format string
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-6\. 结构格式字符串可能的第一个字符
- en: '| Character | Meaning |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| Character | Meaning |'
- en: '| --- | --- |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| @ | Native byte order, native data sizes, and native alignment for the current
    platform; this is the default if the first character is none of the characters
    listed here (note that the format P in [Table 11-7](#common_format_characters_for_struct)
    is available only for this kind of struct format string). Look at the string sys.byteorder
    when you need to check your system’s byte order; most CPUs today use ''little'',
    but ''big'' is the “network standard” for TCP/IP, the core protocols of the internet.
    |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| @ | 本地字节顺序、本地数据大小和本地对齐方式适用于当前平台；如果第一个字符不是列出的字符之一，则这是默认值（请注意，在 [表 11-7](#common_format_characters_for_struct)
    中，格式 P 仅适用于这种类型的结构格式字符串）。在需要检查系统字节顺序时，请查看字符串 sys.byteorder；大多数 CPU 今天使用 ''little''，但
    ''big'' 是互联网核心协议 TCP/IP 的“网络标准”。 |'
- en: '| = | Native byte order for the current platform, but standard size and alignment.
    |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| = | 当前平台的本机字节顺序，但标准大小和对齐方式。 |'
- en: '| < | Little-endian byte order; standard size and alignment. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| < | 小端字节顺序；标准大小和对齐方式。 |'
- en: '| >, ! | Big-endian/network standard byte order; standard size and alignment.
    |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| >, ! | 大端/网络标准字节顺序；标准大小和对齐方式。 |'
- en: Standard sizes are indicated in [Table 11-7](#common_format_characters_for_struct).
    Standard alignment means no forced alignment, with explicit padding bytes used
    as needed. Native sizes and alignment are whatever the platform’s C compiler uses.
    Native byte order can put the most significant byte at either the lowest (big-endian)
    or highest (little-endian) address, depending on the platform.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 标准大小在 [表 11-7](#common_format_characters_for_struct) 中指示。标准对齐方式表示没有强制对齐，根据需要使用显式填充字节。本机大小和对齐方式是平台的
    C 编译器使用的内容。本机字节顺序可以将最高有效字节放在最低地址（大端）或最高地址（小端），这取决于平台。
- en: 'After the optional first character, a format string is made up of one or more
    format characters, each optionally preceded by a count (an integer represented
    by decimal digits). Common format characters are listed in [Table 11-7](#common_format_characters_for_struct);
    see the [online docs](https://oreil.ly/yz7bI) for a complete list. For most format
    characters, the count means repetition (e.g., ''3h'' is exactly the same as ''hhh'').
    When the format character is s or p—that is, a bytestring—the count is not a repetition:
    it’s the total number of bytes in the string. You can freely use whitespace between
    formats, but not between a count and its format character. The format s means
    a fixed-length bytestring as long as its count (the Python string is truncated,
    or padded with copies of the null byte b''\0'', if needed). The format p means
    a “Pascal-like” bytestring: the first byte is the number of significant bytes
    that follow, and the actual contents start from the second byte. The count is
    the total number of bytes, including the length byte.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在可选的第一个字符之后，格式字符串由一个或多个格式字符组成，每个格式字符可选择地由一个计数（用十进制数字表示的整数）前置。常用格式字符列在 [表 11-7](#common_format_characters_for_struct)
    中；完整列表请参阅 [在线文档](https://oreil.ly/yz7bI)。对于大多数格式字符，计数表示重复（例如，'3h' 等同于 'hhh'）。当格式字符为
    s 或 p —— 即字节串时，计数不表示重复：它是字符串中的总字节数。您可以在格式之间自由使用空白字符，但计数和其格式字符之间不可有空格。格式 s 表示长度固定的字节串，与其计数相同（Python
    字符串会被截断或根据需要使用空字节 b'\0' 进行填充）。格式 p 表示“类似帕斯卡”的字节串：第一个字节是随后的有效字节数，实际内容从第二个字节开始。计数是总字节数，包括长度字节在内。
- en: Table 11-7\. Common format characters for struct
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-7\. struct 的常用格式字符
- en: '| Character | C type | Python type | Standard size |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | C 类型 | Python 类型 | 标准大小 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| B | unsigned char | int | 1 byte |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| B | 无符号字符 | int | 1 byte |'
- en: '| b | signed char | int | 1 byte |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| b | 有符号字符 | int | 1 byte |'
- en: '| c | char | bytes (length 1) | 1 byte |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| c | char | bytes (length 1) | 1 byte |'
- en: '| d | double | float | 8 bytes |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| d | 双精度浮点数 | float | 8 bytes |'
- en: '| f | float | float | 4 bytes |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| f | 浮点数 | float | 4 bytes |'
- en: '| H | unsigned short | int | 2 bytes |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| H | 无符号短整型 | int | 2 bytes |'
- en: '| h | signed short | int | 2 bytes |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| h | 有符号短整型 | int | 2 bytes |'
- en: '| I | unsigned int | long | 4 bytes |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| I | 无符号整型 | long | 4 bytes |'
- en: '| i | signed int | int | 4 bytes |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| i | 有符号整型 | int | 4 bytes |'
- en: '| L | unsigned long | long | 4 bytes |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| L | 无符号长整型 | long | 4 bytes |'
- en: '| l | signed long | int | 4 bytes |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| l | 有符号长整型 | int | 4 bytes |'
- en: '| P | void* | int | N/A |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| P | void* | int | N/A |'
- en: '| p | char[] | bytes | N/A |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| p | char[] | bytes | N/A |'
- en: '| s | char[] | bytes | N/A |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| s | char[] | bytes | N/A |'
- en: '| x | padding byte | No value | 1 byte |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| x | 填充字节 | 无值 | 1 byte |'
- en: The struct module supplies the functions covered in [Table 11-8](#functions_of_the_struct_module).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: struct 模块提供了 [表 11-8](#functions_of_the_struct_module) 中涵盖的函数。
- en: Table 11-8\. Functions of the struct module
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-8\. struct 模块的函数
- en: '| calcsize | calcsize(*fmt*, /) Returns the size, in bytes, corresponding to
    format string *fmt*. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| calcsize | calcsize(*fmt*, /) 返回格式字符串 *fmt* 对应的字节大小。 |'
- en: '| iter_unpack | iter_unpack(*fmt*, *buffer*, /) Unpacks iteratively from *buffer*
    per format string *fmt*. Returns an iterator that will read equally sized chunks
    from *buffer* until all its contents are consumed; each iteration yields a tuple
    as specified by *fmt*. *buffer*’s size must be a multiple of the size required
    by the format, as reflected in struct.calcsize(*fmt*). |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| iter_unpack | iter_unpack(*fmt*, *buffer*, /) 从 *buffer* 中按格式字符串 *fmt* 迭代解包。返回一个迭代器，该迭代器将从
    *buffer* 中读取大小相等的块，直到消耗完所有内容；每次迭代都会产生一个由 *fmt* 指定的元组。*buffer* 的大小必须是格式所需的大小的倍数，如
    struct.calcsize(*fmt*) 所反映的那样。 |'
- en: '| pack | pack(*fmt*, **values*, /) Packs the values per format string *fmt*,
    and returns the resulting bytestring. *values* must match in number and type the
    values required by *fmt*. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| pack | pack(*fmt*, **values*, /) 将值按格式字符串 *fmt* 打包，并返回生成的字节串。*values* 必须与
    *fmt* 所需的值的数量和类型匹配。'
- en: '| pack_into | pack_into(*fmt*, *buffer*, *offset*, **values*, /) Packs the
    values per format string *fmt* into writable buffer *buffer* (usually an instance
    of bytearray) starting at index *offset*. *values* must match in number and type
    the values required by *fmt*. len(buffer[offset:]) must be >=struct.calcsize(*fmt*).
    |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| pack_into | pack_into(*fmt*, *buffer*, *offset*, **values*, /) 将值按格式字符串 *fmt*
    打包到可写入的缓冲区 *buffer*（通常是 `bytearray` 的实例），从索引 *offset* 开始。*values* 必须与 *fmt* 所需的值的数量和类型匹配。`len(buffer[offset:])`
    必须 >= `struct.calcsize(*fmt*)`。'
- en: '| unpack | unpack(*fmt*, *s*, /) Unpacks bytestring *s* per format string *fmt*,
    and returns a tuple of values (if just one value, a one-item tuple). len(*s*)
    must equal struct.calcsize(*fmt*). |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| unpack | unpack(*fmt*, *s*, /) 根据格式字符串 *fmt* 解包字节串 *s*，并返回值的元组（如果只有一个值，则返回一个单项元组）。`len(*s*)`
    必须等于 `struct.calcsize(*fmt*)`。'
- en: '| unpack_from | unpack_from(*fmt*, /, buffer, offset=0*)* Unpacks bytestring
    (or other readable buffer) buffer, starting from offset offset, per format string
    *fmt*, returning a tuple of values (if just one value, a one-item tuple). len(buffer[offset:])
    must be >=struct.calcsize(*fmt*). |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| unpack_from | unpack_from(*fmt*, /, buffer, offset=0*) 从偏移量 *offset* 开始，根据格式字符串
    *fmt* 解包字节串（或其他可读取的缓冲区）*buffer*，返回一个值的元组（如果只有一个值，则返回一个单项元组）。`len(buffer[offset:])`
    必须 >= `struct.calcsize(*fmt*)`。'
- en: The struct module also offers a Struct class, which is instantiated with a format
    string as an argument. Instances of this class implement pack, pack_into, unpack,
    unpack_from, and iter_unpack methods corresponding to the functions described
    in the preceding table; they take the same arguments as the corresponding module
    functions, but omitting the *fmt* argument, which was provided on instantiation.
    This allows the class to compile the format string once and reuse it. Struct objects
    also have a format attribute that holds the format string for the object, and
    a size attribute that holds the calculated size of the structure.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct` 模块还提供了一个 `Struct` 类，它以格式字符串作为参数进行实例化。该类的实例实现了 `pack`、`pack_into`、`unpack`、`unpack_from`
    和 `iter_unpack` 方法，这些方法对应于前面表格中描述的函数；它们接受与相应模块函数相同的参数，但省略了在实例化时提供的 `fmt` 参数。这允许类只编译一次格式字符串并重复使用。`Struct`
    对象还有一个 `format` 属性，保存对象的格式字符串，并且有一个 `size` 属性，保存结构的计算大小。'
- en: 'In-Memory Files: io.StringIO and io.BytesIO'
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存中的文件：`io.StringIO` 和 `io.BytesIO`
- en: You can implement file-like objects by writing Python classes that supply the
    methods you need. If all you want is for data to reside in memory, rather than
    in a file as seen by the operating system, use the classes StringIO or BytesIO
    of the io module. The difference between them is that instances of StringIO are
    text-mode files, so reads and writes consume or produce text strings, while instances
    of BytesIO are binary files, so reads and writes consume or produce bytestrings.
    These classes are especially useful in tests and other applications where program
    output should be redirected for buffering or journaling; [“The print Function”](#the_print_function)
    includes a useful context manager example, redirect, that demonstrates this.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过编写 Python 类来实现类似文件的对象，这些类提供你需要的方法。如果你只想让数据驻留在内存中，而不是作为操作系统可见的文件，可以使用 `io`
    模块的 `StringIO` 或 `BytesIO` 类。它们之间的区别在于 `StringIO` 的实例是文本模式文件，因此读取和写入消耗或产生文本字符串，而
    `BytesIO` 的实例是二进制文件，因此读取和写入消耗或产生字节串。这些类在测试和其他需要将程序输出重定向用于缓冲或日志记录的应用程序中特别有用；["The
    print Function"](#the_print_function) 包括一个有用的上下文管理器示例 `redirect`，演示了这一点。
- en: 'When you instantiate either class you can optionally pass a string argument,
    respectively str or bytes, to use as the initial content of the file. Additionally,
    you can pass the argument newline=''\n'' to StringIO (but not BytesIO) to control
    how line endings are handled (like in [TextIoWrapper](https://oreil.ly/-cD05));
    if newline is None, newlines are written as \n on all platforms. In addition to
    the methods described in [Table 11-2](#attributes_and_methods_of_file_objects),
    an instance *f* of either class supplies one extra method:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当你实例化任何一个类时，可以选择传递一个字符串参数，分别是 `str` 或 `bytes`，作为文件的初始内容。此外，你可以向 `StringIO`（但不是
    `BytesIO`）传递参数 `newline='\n'` 来控制如何处理换行符（如在 [TextIoWrapper](https://oreil.ly/-cD05)
    中所述）；如果 `newline` 是 `None`，则在所有平台上都将换行符写为 `\n`。除了 [表 11-2](#attributes_and_methods_of_file_objects)
    中描述的方法之外，任何一个类的实例 `f` 还提供一个额外的方法：
- en: '| getvalue | getvalue() Returns the current data contents of *f* as a string
    (text or bytes). You cannot call *f*.getvalue after you call *f*.close: close
    frees the buffer that *f* internally keeps, and getvalue needs to return the buffer
    as its result. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| getvalue | getvalue() 返回 *f* 的当前数据内容作为字符串（文本或字节）。在调用 *f*.close 后不能再调用 *f*.getvalue：close
    释放 *f* 内部保留的缓冲区，而 getvalue 需要将缓冲区作为其结果返回。|'
- en: Archived and Compressed Files
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存档和压缩文件
- en: Storage space and transmission bandwidth are increasingly cheap and abundant,
    but in many cases you can save such resources, at the expense of some extra computational
    effort, by using compression. Computational power grows cheaper and more abundant
    even faster than some other resources, such as bandwidth, so compression’s popularity
    keeps growing. Python makes it easy for your programs to support compression.
    We don’t cover the details of compression in this book, but you can find details
    on the relevant standard library modules in the [online docs](https://oreil.ly/QJzCW).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 存储空间和传输带宽变得越来越便宜和充裕，但在许多情况下，通过使用压缩可以节省这些资源，尽管需要额外的计算工作。计算能力的成本比其他资源（如带宽）增长更快，因此压缩的流行度不断增长。Python
    使得您的程序能够轻松支持压缩。本书不涵盖压缩的详细信息，但您可以在[在线文档](https://oreil.ly/QJzCW)中找到有关相关标准库模块的详细信息。
- en: 'The rest of this section covers “archive” files (which collect in a single
    file a collection of files and optionally directories), which may or may not be
    compressed. Python’s stdlib offers two modules to handle two very popular archive
    formats: tarfile (which, by default, does not compress the files it bundles),
    and zipfile (which, by default, does compress the files it bundles).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的其余部分涵盖了“存档”文件（在单个文件中收集文件和可选目录的集合），这些文件可能会压缩也可能不会压缩。Python 的标准库提供了两个模块来处理两种非常流行的存档格式：tarfile（默认情况下不会压缩其捆绑的文件）和
    zipfile（默认情况下会压缩其捆绑的文件）。
- en: The tarfile Module
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: tarfile 模块
- en: 'The tarfile module lets you read and write[TAR files](https://oreil.ly/TvKqN)
    (archive files compatible with those handled by popular archiving programs such
    as tar), optionally with gzip, bzip2, or LZMA compression. TAR files are typically
    named with a *.tar* or *.tar.(compression type)* extension. 3.8+ The default format
    of new archives is POSIX.1-2001 (pax). **python -m tarfile** offers a useful command-line
    interface to the module’s functionality: run it without arguments to get a brief
    help message.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: tarfile 模块允许您读取和编写[TAR 文件](https://oreil.ly/TvKqN)（与流行的打包程序（如 tar）处理的文件兼容的存档文件），可选择使用
    gzip、bzip2 或 LZMA 压缩。TAR 文件通常以 *.tar* 或 *.tar.(压缩类型)* 扩展名命名。3.8+ 新建存档的默认格式为 POSIX.1-2001（pax）。
    **python -m tarfile** 提供了一个有用的命令行接口以访问模块的功能：运行它而不带参数可以获取简短的帮助消息。
- en: The tarfile module supplies the functions listed in [Table 11-9](#classes_and_functions_of_the_tarfile_mo).
    When handling invalid TAR files, functions of tarfile raise instances of tarfile.TarError.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: tarfile 模块提供了[T表 11-9](#classes_and_functions_of_the_tarfile_mo)中列出的函数。处理无效的
    TAR 文件时，tarfile 的函数会引发 tarfile.TarError 的实例。
- en: Table 11-9\. Classes and functions of the tarfile module
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-9\. tarfile 模块的类和函数
- en: '| is_tarfile | is_tarfile(*filename*) Returns **True** when the file named
    by *filename* (which may be a str, 3.9+ or a file or file-like object) appears
    to be a valid TAR file (possibly with compression), judging by the first few bytes;
    otherwise, returns **False**. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| is_tarfile | is_tarfile(*filename*) 当名为*filename*（可以是字符串，3.9+ 或文件或类文件对象）的文件在前几个字节上看起来像是一个有效的
    TAR 文件（可能带有压缩），则返回 **True**；否则返回 **False**。|'
- en: '| open | open(name=**None**, mode=''r'', fileobj=**None**, bufsize=10240, ***kwargs*)
    Creates and returns a TarFile instance *f* to read or create a TAR file through
    file-like object fileobj. When fileobj is **None**, name may be a string naming
    a file or a path-like object; open opens the file with the given mode (by default,
    ''r''), and *f* wraps the resulting file object. open may be used as a context
    manager (e.g., **with** tarfile.open(...) **as** *f*).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '| open | open(name=**None**, mode=''r'', fileobj=**None**, bufsize=10240, ***kwargs*)
    创建并返回一个 TarFile 实例 *f*，用于通过类文件对象 fileobj 读取或创建 TAR 文件。当 fileobj 为 **None** 时，name
    可以是指定文件的字符串名称或路径对象；open 使用给定的模式（默认为 ''r''）打开文件，并且 *f* 包装生成的文件对象。open 可以作为上下文管理器使用（例如，**with**
    tarfile.open(...) **as** *f*）。'
- en: f.close may not close fileobj
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: f.close 可能不会关闭 fileobj
- en: 'Calling *f*.close does *not* close fileobj when *f* was opened with a fileobj
    that is not **None**. This behavior of *f*.close is important when fileobj is
    an instance of io.BytesIO: you can call fileobj.getvalue after *f*.close to get
    the archived and possibly compressed data as a string. This behavior also means
    that you have to call fileobj.close explicitly after calling *f*.close.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用未为 **None** 的 fileobj 打开 *f* 时，调用 *f*.close 并不会关闭 fileobj。当 fileobj 是 io.BytesIO
    的实例时，此 *f*.close 的行为非常重要：您可以在 *f*.close 后调用 fileobj.getvalue 来获取归档的可能已压缩数据作为字符串。这种行为也意味着您必须在调用
    *f*.close 后显式调用 fileobj.close。
- en: mode can be 'r' to read an existing TAR file with whatever compression it has
    (if any); 'w' to write a new TAR file, or truncate and rewrite an existing one,
    without compression; or 'a' to append to an existing TAR file, without compression.
    Appending to compressed TAR files is not supported. To write a new TAR file with
    compression, mode can be 'w:gz' for gzip compression, 'w:bz2' for bzip2 compression,
    or 'w:xz' for LZMA compression. You can use mode strings 'r:' or 'w:' to read
    or write uncompressed, nonseekable TAR files using a buffer of bufsize bytes;
    for reading TAR files use plain 'r', since this will automatically uncompress
    as necessary.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: mode 可以是 'r' 以读取具有任何压缩（如果有的话）的现有 TAR 文件；'w' 以编写新的 TAR 文件，或截断并重写现有文件，而不使用压缩；或
    'a' 以追加到现有的 TAR 文件，而不使用压缩。不支持向已压缩的 TAR 文件追加。要使用压缩编写新的 TAR 文件，mode 可以是 'w:gz' 以进行
    gzip 压缩，'w:bz2' 以进行 bzip2 压缩，或 'w:xz' 以进行 LZMA 压缩。您可以使用 mode 字符串 'r:' 或 'w:' 以使用
    bufsize 字节缓冲区读取或写入未压缩的不可寻址 TAR 文件；对于读取 TAR 文件，请使用普通 'r'，因为这将根据需要自动解压缩。
- en: In the mode strings specifying compression, you can use a vertical bar (&#124;)
    instead of a colon (:) to force sequential processing and fixed-size blocks; this
    is useful in the (admittedly very unlikely) case that you ever find yourself handling
    a tape device! |
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定压缩方式的模式字符串中，你可以使用竖线（&#124;）而不是冒号（:），以强制顺序处理和固定大小的块；这在（尽管非常不太可能的）情况下很有用，你可能会发现自己处理磁带设备！
    |
- en: The TarFile class
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TarFile 类
- en: '[TarFile](https://oreil.ly/RwYNA) is the underlying class for most tarfile
    methods, but is not used directly. A TarFile instance *f*, created using tarfile.open,
    supplies the methods detailed in [Table 11-10](#methods_of_a_tarfile_instance_f).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[TarFile](https://oreil.ly/RwYNA) 是大多数 tarfile 方法的底层类，但不直接使用。通过使用 tarfile.open
    创建的 TarFile 实例 *f*，提供了 [Table 11-10](#methods_of_a_tarfile_instance_f) 中详细描述的方法。'
- en: Table 11-10\. Methods of a TarFile instance *f*
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-10\. TarFile 实例 *f* 的方法
- en: '| add | *f*.add(*name*, arcname=**None**, recursive=**True**, *, filter=**None**)
    Adds to archive *f* the file named by *name* (can be any type of file, a directory,
    or a symbolic link). When arcname is not **None**, it’s used as the archive member
    name in lieu of *name*. When *name* is a directory, and recursive is **True**,
    add recursively adds the whole filesystem subtree rooted in that directory in
    sorted order. The optional (named-only) argument filter is a function that is
    called on each object to be added. It takes a TarInfo object argument and returns
    either the (possibly modified) TarInfo object, or **None**. In the latter case
    the add method excludes this TarInfo object from the archive. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| add | *f*.add(*name*, arcname=**None**, recursive=**True**, *, filter=**None**)
    向归档 *f* 添加名为 *name* 的文件（可以是任何类型的文件、目录或符号链接）。当 arcname 不为 **None** 时，将其用作归档成员的名称，而不是使用
    *name*。当 *name* 是一个目录且 recursive 为 **True** 时，add 方法将以排序顺序递归地添加该目录中以该目录为根的整个文件系统子树。可选的（仅命名的）参数
    filter 是一个函数，用于调用每个要添加的对象。它接受一个 TarInfo 对象参数，并返回可能修改后的 TarInfo 对象或 **None**。在后一种情况下，add
    方法将从归档中排除此 TarInfo 对象。 |'
- en: '| addfile | *f*.addfile(*tarinfo*, fileobj=**None**) Adds to archive *f* a
    TarInfo object *tarinfo*. If fileobj is not **None**, the first *tarinfo*.size
    bytes of binary file-like object fileobj are added. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| addfile | *f*.addfile(*tarinfo*, fileobj=**None**) 向归档 *f* 添加一个 TarInfo 对象
    *tarinfo*。如果 fileobj 不为 **None**，则将二进制类文件对象 fileobj 的前 *tarinfo*.size 字节添加到归档中。
    |'
- en: '| close | *f*.close() Closes archive *f*. You must call close, or else an incomplete,
    unusable TAR file might be left on disk. Such mandatory finalization is best performed
    with a **try**/**finally**, as covered in [“try/finally”](ch06.xhtml#trysolidusfinally),
    or, even better, a **with** statement, covered in [“The with Statement and Context
    Managers”](ch06.xhtml#the_with_statement_and_context_managers). Calling *f*.close
    does *not* close fileobj if *f* was created with a non-**None** fileobj. This
    matters especially when fileobj is an instance of io.BytesIO: you can call fileobj.getvalue
    after *f*.close to get the compressed data string. So, you always have to call
    fileobj.close (explicitly, or implicitly by using a **with** statement) *after*
    *f*.close. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| close | *f*.close() 关闭存档 *f*。您必须调用 close，否则可能会在磁盘上留下一个不完整的、无法使用的 TAR 文件。最好使用
    **try**/**finally**（在 [“try/finally”](ch06.xhtml#trysolidusfinally)中讨论）进行此类必需的最终操作，或者更好地，使用
    [“with 语句和上下文管理器”](ch06.xhtml#the_with_statement_and_context_managers)中讨论的 **with**
    语句。调用 *f*.close 不会关闭 fileobj，如果 *f* 是使用非 **None** fileobj 创建的。这在 fileobj 是 io.BytesIO
    的实例时尤为重要：您可以在 *f*.close 后调用 fileobj.getvalue 来获取压缩的数据字符串。因此，您始终必须在 *f*.close **后**调用
    fileobj.close（显式地或通过使用 **with** 语句隐式地）。'
- en: '| extract | *f.*extract(*member*, path='''', set_attrs=**True**, numeric_owner=**False**)
    Extracts the archive member identified by *member* (a name or a TarInfo instance)
    into a corresponding file in the directory (or path-like object) named by path
    (the current directory by default). If set_attrs is **True**, the owner and timestamps
    will be set as they were saved in the TAR file; otherwise, the owner and timestamps
    for the extracted file will be set using the current user and time values. If
    numeric_owner is **True**, the UID and GID numbers from the TAR file are used
    to set the owner/group for the extracted files; otherwise, the named values from
    the TAR file are used. (The [online docs](https://oreil.ly/Ugj8v) recommend using
    extractall over calling extract directly, since extractall does additional error
    handling internally.) |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| extract | *f.*extract(*member*, path='''', set_attrs=**True**, numeric_owner=**False**)
    将由 *member*（名称或 TarInfo 实例）标识的存档成员提取到目录（或类似路径的对象）中由 path（默认为当前目录）命名的相应文件中。如果 set_attrs
    为 **True**，则所有者和时间戳将设置为它们在 TAR 文件中保存的值；否则，提取文件的所有者和时间戳将使用当前用户和时间值进行设置。如果 numeric_owner
    为 **True**，则从 TAR 文件中使用的 UID 和 GID 数字将用于设置提取文件的所有者/组；否则，将使用 TAR 文件中的命名值。（[在线文档](https://oreil.ly/Ugj8v)建议使用
    extractall 而不是直接调用 extract，因为 extractall 在内部执行了额外的错误处理。） |'
- en: '| extractall | *f*.extractall(path=''.'', members=**None**, numeric_owner=**False**)
    Similar to calling extract on each member of TAR file *f*, or just those listed
    in the members argument, with additional error checking for chown, chmod, and
    utime errors that occur while writing the extracted members.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '| extractall | *f*.extractall(path=''.'', members=**None**, numeric_owner=**False**)
    类似于对 TAR 文件 *f* 的每个成员调用 extract，或者只对在成员参数中列出的成员调用 extract，并且对在写入提取的成员时发生的 chown、chmod
    和 utime 错误进行额外的错误检查。'
- en: Don’t Use extractall on a Tarfile from an Untrusted Source
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要对来自不受信任来源的 Tarfile 使用 extractall
- en: extractall does not check the paths of extracted files, so there is a risk that
    an extracted file will have an absolute path (or include one or more .. components)
    and thus overwrite a potentially sensitive file.^([a](ch11.xhtml#ch01fn101)) It
    is best to read each member individually and only extract it if it has a safe
    path (i.e., no absolute paths or relative paths with any.. path component).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: extractall 不检查提取文件的路径，因此存在提取文件具有绝对路径（或包含一个或多个..组件）并因此覆盖潜在敏感文件的风险。^([a](ch11.xhtml#ch01fn101))
    最好逐个成员地读取并仅在其具有安全路径（即，没有绝对路径或相对路径带有任何..路径组件）时提取它。
- en: '|'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| extractfile | *f*.extractfile(*member*) Extracts the archive member identified
    by *member* (a name or a TarInfo instance) and returns an io.BufferedReader object
    with the methods read, readline, readlines, seek, and tell. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| extractfile | *f*.extractfile(*member*) 提取由 *member*（名称或 TarInfo 实例）标识的存档成员，并返回一个具有方法
    read、readline、readlines、seek 和 tell 的 io.BufferedReader 对象。 |'
- en: '| getmember | *f*.getmember(*name*) Returns a TarInfo instance with information
    about the archive member named by the string *name*. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| getmember | *f*.getmember(*name*) 返回一个 TarInfo 实例，其中包含有关字符串 *name* 命名的存档成员的信息。
    |'
- en: '| getmembers | *f*.getmembers() Returns a list of TarInfo instances, one for
    each member in archive *f*, in the same order as the entries in the archive itself.
    |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| getmembers | *f*.getmembers() 返回一个 TarInfo 实例列表，其中每个实例对应于存档 *f* 中的每个成员，顺序与存档中条目的顺序相同。
    |'
- en: '| getnames | *f*.getnames() Returns a list of strings, the names of each member
    in archive *f*, in the same order as the entries in the archive itself. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| getnames | *f*.getnames() 返回一个字符串列表，存档 *f* 中每个成员的名称，顺序与存档中条目的顺序相同。 |'
- en: '| gettarinfo | *f*.gettarinfo(name=**None**, arcname=**None**, fileobj=**None**)
    Returns a TarInfo instance with information about the open file object fileobj,
    when not **None**, or else the existing file whose path is the string name. name
    may be a path-like object. When arcname is not **None**, it’s used as the name
    attribute of the resulting TarInfo instance. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| gettarinfo | *f*.gettarinfo(name=**None**, arcname=**None**, fileobj=**None**)
    返回一个 TarInfo 实例，其中包含有关打开的文件对象 fileobj 的信息，当 fileobj 不是 **None** 时；否则，是路径字符串 name
    的现有文件。name 可能是类似路径的对象。当 arcname 不是 **None** 时，它被用作生成的 TarInfo 实例的 name 属性。 |'
- en: '| list | *f*.list(verbose=**True**, *, members=**None**) Outputs a directory
    of the archive *f* to sys.stdout. If the optional argument verbose is **False**,
    outputs only the names of the archive’s members. If the optional argument members
    is given, it must be a subset of the list returned by getmembers. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| list | *f*.list(verbose=**True**, *, members=**None**) 输出存档 *f* 的目录到 sys.stdout。如果可选参数
    verbose 是 **False**，则只输出存档成员的名称。如果给定可选参数 members，则必须是 getmembers 返回的列表的子集。 |'
- en: '| next | *f*.next() Returns the next available archive member as a TarInfo
    instance; if none are available, returns **None**. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| next | *f*.next() 返回下一个可用的存档成员作为 TarInfo 实例；如果没有可用的，则返回 **None**。 |'
- en: '| ^([a](ch11.xhtml#ch01fn101-marker)) Described further in [CVE-2007-4559](https://oreil.ly/7hJ89).
    |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch11.xhtml#ch01fn101-marker)) 进一步描述，请参阅 [CVE-2007-4559](https://oreil.ly/7hJ89)。
    |'
- en: The TarInfo class
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: The TarInfo class
- en: The methods getmember and getmembers of TarFile instances return instances of
    TarInfo, supplying information about members of the archive. You can also build
    a TarInfo instance with a TarFile instance’s method gettarinfo. The *name* argument
    may be a path-like object. The most useful attributes and methods supplied by
    a TarInfo instance *t* are listed in [Table 11-11](#useful_attributes_of_a_tarinfo_instance).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: The methods getmember and getmembers of TarFile instances return instances of
    TarInfo, supplying information about members of the archive. You can also build
    a TarInfo instance with a TarFile instance’s method gettarinfo. The *name* argument
    may be a path-like object. The most useful attributes and methods supplied by
    a TarInfo instance *t* are listed in [Table 11-11](#useful_attributes_of_a_tarinfo_instance).
- en: Table 11-11\. Useful attributes of a TarInfo instance *t*
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Table 11-11\. TarInfo 实例 *t* 的有用属性
- en: '| isdir() | Returns **True** if the file is a directory |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| isdir() | 如果文件是目录，则返回 **True** |'
- en: '| isfile() | Returns **True** if the file is a regular file |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| isfile() | 如果文件是常规文件，则返回 **True** |'
- en: '| issym() | Returns **True** if the file is a symbolic link |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| issym() | 如果文件是符号链接，则返回 **True** |'
- en: '| linkname | Target file’s name (a string), when *t*.type is LNKTYPE or SYMTYPE
    |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| linkname | 当 *t*.type 是 LNKTYPE 或 SYMTYPE 时，目标文件的名称（一个字符串） |'
- en: '| mode | Permission and other mode bits of the file identified by *t* |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| mode | *t* 标识的文件的权限和其他模式位 |'
- en: '| mtime | Time of last modification of the file identified by *t* |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| mtime | 最后修改时间，由 *t* 标识的文件 |'
- en: '| name | Name in the archive of the file identified by *t* |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| name | *t* 标识的存档中文件的名称 |'
- en: '| size | Size, in bytes (uncompressed), of the file identified by *t* |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| size | *t* 标识的文件的大小（未压缩，以字节为单位） |'
- en: '| type | File type—one of many constants that are attributes of the tarfile
    module (SYMTYPE for symbolic links, REGTYPE for regular files, DIRTYPE for directories,
    and so on; see the [online docs](https://oreil.ly/RwYNA) for a complete list)
    |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| type | 文件类型之一，是 tarfile 模块的属性常量之一（符号链接的 SYMTYPE，常规文件的 REGTYPE，目录的 DIRTYPE
    等等；请参阅 [在线文档](https://oreil.ly/RwYNA) 获取完整列表） |'
- en: The zipfile Module
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: The zipfile Module
- en: 'The zipfile module can read and write ZIP files (i.e., archive files compatible
    with those handled by popular compression programs such as zip and unzip, pkzip
    and pkunzip, WinZip, and so on, typically named with a *.zip* extension). **python
    -m zipfile** offers a useful command-line interface to the module’s functionality:
    run it without further arguments to get a brief help message.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: The zipfile module can read and write ZIP files (i.e., archive files compatible
    with those handled by popular compression programs such as zip and unzip, pkzip
    and pkunzip, WinZip, and so on, typically named with a *.zip* extension). **python
    -m zipfile** 提供了一个有用的命令行界面，用于访问模块的功能：运行它而不带其他参数，以获取简短的帮助消息。
- en: Detailed information about ZIP files is available on the [PKWARE](https://oreil.ly/fVfmV)
    and [Info-ZIP](https://oreil.ly/rMHiL) websites. You need to study that detailed
    information to perform advanced ZIP file handling with zipfile. If you do not
    specifically need to interoperate with other programs using the ZIP file standard,
    the modules lzma, gzip, and bz2 are usually better ways to deal with compression,
    as is tarfile to create (optionally compressed) archives.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有关ZIP文件的详细信息可以在[PKWARE](https://oreil.ly/fVfmV)和[Info-ZIP](https://oreil.ly/rMHiL)网站上找到。您需要研究这些详细信息以使用zipfile执行高级ZIP文件处理。如果您不需要与使用ZIP文件标准的其他程序进行互操作，则通常最好使用lzma、gzip和bz2模块来处理压缩，tarfile则是创建（可选压缩的）存档的更好方法。
- en: 'The zipfile module can’t handle multidisk ZIP files, and cannot create encrypted
    archives (it can decrypt them, albeit rather slowly). The module also cannot handle
    archive members using compression types besides the usual ones, known as *stored*
    (a file copied to the archive without compression) and *deflated* (a file compressed
    using the ZIP format’s default algorithm). zipfile also handles the bzip2 and
    LZMA compression types, but beware: not all tools can handle those, so if you
    use them you’re sacrificing some portability to get better compression.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: zipfile 模块不能处理多磁盘ZIP文件，也不能创建加密存档（它可以解密，尽管速度相对较慢）。该模块还不能处理使用除通常的*stored*（未压缩复制到存档的文件）和*deflated*（使用ZIP格式的默认算法压缩的文件）之外的压缩类型的存档成员。zipfile
    还处理bzip2和LZMA压缩类型，但请注意：并非所有工具都能处理这些类型，因此如果您使用它们，则牺牲了一些可移植性以获得更好的压缩。
- en: The zipfile module supplies function is_zipfile and class Path, as listed in
    [Table 11-12](#auxiliary_function_and_class_of_the_zip). In addition, it supplies
    classes ZipFile and ZipInfo, described later. For errors related to invalid ZIP
    files, functions of zipfile raise exceptions that are instances of the exception
    class zipfile.error.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: zipfile 模块提供is_zipfile函数和类Path，如[表11-12](#auxiliary_function_and_class_of_the_zip)中列出。此外，它还提供了稍后描述的类ZipFile和ZipInfo。与无效ZIP文件相关的错误，zipfile的函数会引发zipfile.error异常的实例。
- en: Table 11-12\. Auxiliary function and class of the zipfile module
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 表11-12\. zipfile 模块的辅助函数和类
- en: '| is_zipfile | is_zipfile(*file*) Returns **True** when the file named by string,
    path-like object, or file-like object *file* seems to be a valid ZIP file, judging
    by the first few and last bytes of the file; otherwise, returns **False**. |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| is_zipfile | is_zipfile(*file*) 当由字符串、路径样式对象或类似文件对象*file*命名的文件在文件的前几个和最后几个字节中看起来是有效的ZIP文件时返回**True**；否则返回**False**。
    |'
- en: '| Path | **class** Path(*root*, at='''') 3.8+A pathlib-compatible wrapper for
    ZIP files. Returns a pathlib.Path object *p* from *root*, a ZIP file (which may
    be a ZipFile instance or file suitable for passing to the ZipFile constructor).
    The string argument at is a path to specify the location of *p* in the ZIP file:
    the default is the root. *p* exposes several pathlib.Path methods: see the [online
    docs](https://oreil.ly/sMeC_) for details. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| Path | **class** Path(*root*, at='''') 3.8+ 用于ZIP文件的pathlib兼容包装器。从*root*，一个ZIP文件（可以是ZipFile实例或适合传递给ZipFile构造函数的文件）返回一个pathlib.Path对象*p*。字符串参数at是指定*p*在ZIP文件中位置的路径：默认是根。*p*公开了几个pathlib.Path方法：详细信息请参阅[在线文档](https://oreil.ly/sMeC_)。
    |'
- en: The ZipFile class
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ZipFile 类
- en: 'The main class supplied by zipfile is ZipFile. Its constructor has the following
    signature:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: zipfile 提供的主要类是ZipFile。其构造函数具有以下签名：
- en: '| ZipFile | **class** ZipFile(*file*, mode=''r'', compression=zipfile.ZIP_STORED,
    allowZip64=**True**, compresslevel=**None**, *, strict_timestamps=**True**) Opens
    a ZIP file named by *file* (a string, file-like object, or path-like object).
    mode can be ''r'' to read an existing ZIP file, ''w'', to write a new ZIP file
    or truncate and rewrite an existing one, or ''a'' to append to an existing file.
    It can also be ''x'', which is like ''w'' but raises an exception if the ZIP file
    already existed—here, ''x'' stands for “exclusive.”'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '| ZipFile | **class** ZipFile(*file*, mode=''r'', compression=zipfile.ZIP_STORED,
    allowZip64=**True**, compresslevel=**None**, *, strict_timestamps=**True**) 打开名为*file*（字符串、类似文件对象或路径样式对象）的ZIP文件。mode可以是''r''以读取现有的ZIP文件，''w''以写入新的ZIP文件或截断并重写现有文件，或者''a''以追加到现有文件。也可以是''x''，类似于''w''，但如果ZIP文件已存在则引发异常——这里的''x''表示“排他”。'
- en: When mode is 'a', *file* can name either an existing ZIP file (in which case
    new members are added to the existing archive) or an existing non-ZIP file. In
    the latter case, a new ZIP file-like archive is created and appended to the existing
    file. The main purpose of this latter case is to let you build an executable file
    that unpacks itself when run. The existing file must then be a pristine copy of
    a self-unpacking executable prefix, as supplied by *www.info-zip.org* and by other
    purveyors of ZIP file compression tools.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当模式为 'a' 时，*file* 可以命名为现有的 ZIP 文件（在这种情况下，新成员将添加到现有存档中）或现有的非-ZIP 文件。在后一种情况下，将创建一个新的类似
    ZIP 文件的存档，并将其附加到现有文件上。后一种情况的主要目的是让您构建一个在运行时自行解压缩的可执行文件。然后，现有文件必须是自解压缩可执行文件前缀的原始副本，由
    *www.info-zip.org* 和其他 ZIP 文件压缩工具供应商提供。
- en: 'compression is the ZIP compression method to use in writing the archive: ZIP_STORED
    (the default) requests that the archive use no compression, and ZIP_DEFLATED requests
    that the archive use the *deflation* mode of compression (the most usual and effective
    compression approach used in ZIP files). It can also be ZIP_BZIP2 or ZIP_LZMA
    (sacrificing portability for more compression; these require the bz2 or lzma module,
    respectively). Unrecognized values will raise NotImplementedError. |'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩是写入存档时要使用的 ZIP 压缩方法：ZIP_STORED（默认值）请求存档不使用压缩，ZIP_DEFLATED 请求存档使用压缩的 *deflation*
    模式（ZIP 文件中使用的最常见和有效的压缩方法）。它还可以是 ZIP_BZIP2 或 ZIP_LZMA（牺牲可移植性以获得更多压缩；这些需要分别使用 bz2
    或 lzma 模块）。未被识别的值将引发 NotImplementedError。|
- en: '| ZipFile *(cont.)* | When allowZip64 is **True** (the default), the ZipFile
    instance is allowed to use the ZIP64 extensions to produce an archive larger than
    4 GB; otherwise, any attempt to produce such a large archive raises a LargeZipFile
    exception. compresslevel is an integer (ignored when using ZIP_STORED or ZIP_LZMA)
    from 0 for ZIP_DEFLATED (1 for ZIP_BZIP2), which requests modest compression but
    fast operation, to 9 to request the best compression at the cost of more computation.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '| ZipFile *(cont.)* | 当 allowZip64 为 **True**（默认值）时，允许 ZipFile 实例使用 ZIP64 扩展来生成大于
    4 GB 的存档；否则，任何尝试生成这样一个大存档的尝试都会引发 LargeZipFile 异常。compresslevel 是一个整数（在使用 ZIP_STORED
    或 ZIP_LZMA 时被忽略），从 0 表示 ZIP_DEFLATED（1 表示 ZIP_BZIP2），它请求适度的压缩但操作速度较快，到 9 请求最佳压缩以换取更多计算。'
- en: 3.8+ Set strict_timestamps to **False** to store files older than 1980-01-01
    (sets the timestamp to 1980-01-01) or beyond 2107-12-31 (sets the timestamp to
    2107-12-31). |
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 将 strict_timestamps 设置为 **False** 可以存储早于 1980-01-01（将时间戳设置为 1980-01-01）或晚于 2107-12-31（将时间戳设置为
    2107-12-31）的文件。|
- en: 'ZipFile is a context manager; thus, you can use it in a **with** statement
    to ensure the underlying file gets closed when you’re done with it. For example:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ZipFile 是一个上下文管理器；因此，您可以在 **with** 语句中使用它，以确保在完成后关闭底层文件。例如：
- en: '[PRE7]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In addition to the arguments with which it was instantiated, a ZipFile instance
    *z* has the attributes fp and filename, which are the file-like object *z* works
    on and its filename (if known); comment, the possibly empty string that is the
    archive’s comment; and filelist, the list of ZipInfo instances in the archive.
    In addition, *z* has a writable attribute called debug, an int from 0 to 3 that
    you can assign to control how much debugging output to emit to sys.stdout:^([2](ch11.xhtml#ch01fn102))
    from nothing when *z*.debug is 0, to the maximum amount of information available
    when *z*.debug is 3.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 除了实例化时提供的参数之外，ZipFile 实例 *z* 还具有属性 fp 和 filename，它们是 *z* 工作的类似文件的对象和其文件名（如果已知）；comment，可能是空字符串的存档评论；和
    filelist，存档中的 ZipInfo 实例列表。此外，*z* 还有一个名为 debug 的可写属性，一个从 0 到 3 的 int，您可以分配它来控制在输出到
    sys.stdout 时要发出多少调试输出：^([2](ch11.xhtml#ch01fn102)) 从 *z*.debug 为 0 时什么都不输出，到 *z*.debug
    为 3 时发出的调试输出为可用的最大量。
- en: A ZipFile instance *z* supplies the methods listed in [Table 11-13](#methods_supplied_by_an_instance_z_of_zi).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ZipFile 实例 *z* 提供了 [Table 11-13](#methods_supplied_by_an_instance_z_of_zi) 中列出的方法。
- en: Table 11-13\. Methods supplied by an instance *z* of ZipFile
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-13\. ZipFile 实例 *z* 提供的方法
- en: '| close | close() Closes archive file *z*. Make sure to call *z*.close(), or
    an incomplete and unusable ZIP file might be left on disk. Such mandatory finalization
    is generally best performed with a **try**/**finally** statement, as covered in
    [“try/finally”](ch06.xhtml#trysolidusfinally), or—even better—a **with** statement,
    covered in [“The with Statement and Context Managers”](ch06.xhtml#the_with_statement_and_context_managers).
    |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| close | close() 关闭存档文件 *z*。确保调用 *z*.close()，否则可能会在磁盘上留下不完整且无法使用的 ZIP 文件。这种强制性的最终化通常最好使用
    [“try/finally”](ch06.xhtml#trysolidusfinally) 中介绍的 **try**/**finally** 语句执行，或者更好地使用
    [“The with Statement and Context Managers”](ch06.xhtml#the_with_statement_and_context_managers)
    中介绍的 **with** 语句执行。 |'
- en: '| extract | extract(*member*, path=**None**, pwd=**None**) Extracts an archive
    member to disk, to the directory or path-like object path or, by default, to the
    current working directory; *member* is the member’s full name, or an instance
    of ZipInfo identifying the member. extract normalizes path info within *member*,
    turning absolute paths into relative ones, removing any .. component, and, on
    Windows, turning characters that are illegal in filenames into underscores (_).
    pwd, if present, is the password to use to decrypt an encrypted member.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '| extract | extract(*member*, path=**None**, pwd=**None**) 将存档成员提取到磁盘，到目录或类似路径的对象路径，或者默认情况下提取到当前工作目录；*member*
    是成员的完整名称，或者标识成员的 ZipInfo 实例。extract 会在 *member* 中规范化路径信息，将绝对路径转换为相对路径，移除任何 ..
    组件，并且在 Windows 上，将文件名中非法的字符转换为下划线 (_)。pwd（如果存在）是用于解密加密成员的密码。 |'
- en: extract returns the path to the file it has created (or overwritten if it already
    existed), or to the directory it has created (or left alone if it already existed).
    Calling extract on a closed ZipFile raises ValueError. |
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: extract 返回它创建的文件（如果已存在则覆盖），或者返回它创建的目录（如果已存在则不变）。在已关闭的 ZipFile 上调用 extract 会引发
    ValueError。 |
- en: '| extractall | extractall(path=**None**, members=**None**, pwd=**None**) Extracts
    archive members to disk (by default, all of them), to directory or path- like
    object path or, by default, to the current working directory; members optionally
    limits which members to extract, and must be a subset of the list of strings returned
    by *z*.namelist. extractall normalizes path info within members it extracts, turning
    absolute paths into relative ones, removing any .. component, and, on Windows,
    turning characters that are illegal in filenames into underscores (_). pwd, if
    present, is the password to use to decrypt encrypted members, if any. |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| extractall | extractall(path=**None**, members=**None**, pwd=**None**) 将存档成员提取到磁盘（默认情况下为全部成员），到目录或类似路径的对象路径，或者默认情况下提取到当前工作目录；members
    可选地限制要提取的成员，并且必须是由 *z*.namelist 返回的字符串列表的子集。extractall 会在提取的成员中规范化路径信息，将绝对路径转换为相对路径，移除任何
    .. 组件，并且在 Windows 上，将文件名中非法的字符转换为下划线 (_)。pwd（如果存在）是用于解密加密成员（如果有）的密码。 |'
- en: '| getinfo | getinfo(*name*) Returns a ZipInfo instance that supplies information
    about the archive member named by the string *name*. |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| getinfo | getinfo(*name*) 返回一个 ZipInfo 实例，该实例提供有关由字符串 *name* 指定的存档成员的信息。
    |'
- en: '| infolist | infolist() Returns a list of ZipInfo instances, one for each member
    in archive *z*, in the same order as the entries in the archive. |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| infolist | infolist() 返回一个 ZipInfo 实例列表，其中包含存档 *z* 中的每个成员的信息，顺序与存档中的条目相同。
    |'
- en: '| namelist | namelist() Returns a list of strings, the name of each member
    in archive *z*, in the same order as the entries in the archive. |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| namelist | namelist() 返回一个字符串列表，其中包含存档 *z* 中每个成员的名称，顺序与存档中的条目相同。 |'
- en: '| open | open(*name*, mode=''r'', pwd=**None**, *, force_zip64=**False**) Extracts
    and returns the archive member identified by *name* (a member name string or ZipInfo
    instance) as a (maybe read-only) file-like object. *mode* may be ''r'' or ''w''.
    pwd, if present, is the password to use to decrypt an encrypted member. Pass force_zip64=**True**
    when an unknown file size may exceed 2 GiB, to ensure the header format is capable
    of supporting large files. When you know in advance the large file size, use a
    ZipInfo instance for *name*, with file_size set appropriately. |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| open | open(*name*, mode=''r'', pwd=**None**, *, force_zip64=**False**) 提取并返回由
    *name*（成员名称字符串或 ZipInfo 实例）标识的存档成员作为（可能是只读的）类文件对象。*mode* 可以是 ''r'' 或 ''w''。pwd（如果存在）是用于解密加密成员的密码。在可能的情况下，当未知文件大小可能超过
    2 GiB 时，请传递 force_zip64=**True**，以确保标题格式能够支持大文件。当您预先知道大文件大小时，请使用适当设置文件大小的 ZipInfo
    实例进行 *name* 的操作。 |'
- en: '| printdir | printdir() Outputs a textual directory of the archive *z* to sys.stdout.
    |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| printdir | printdir() 将存档 *z* 的文本目录输出到 sys.stdout。 |'
- en: '| read | read(*name*, *pwd*) Extracts the archive member identified by *name*
    (a member name string or ZipInfo instance) and returns the bytestring of its contents
    (raises ValueError if called on a closed ZipFile). *pwd*, if present, is the password
    to use to decrypt an encrypted member. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| read | read(*name*, *pwd*) 提取由 *name*（成员名称字符串或 ZipInfo 实例）标识的归档成员并返回其内容的字节串（如果在关闭的
    ZipFile 上调用则引发 ValueError）。*pwd*（如果存在）是用于解密加密成员的密码。 |'
- en: '| setpassword | setpassword(*pwd*) Sets string *pwd* as the default password
    to use to decrypt encrypted files. |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| setpassword | setpassword(*pwd*) 将字符串 *pwd* 设置为解密加密文件时使用的默认密码。 |'
- en: '| testzip | testzip() Reads and checks the files in archive *z*. Returns a
    string with the name of the first archive member that is damaged, or **None**
    if the archive is intact. |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| testzip | testzip() 读取并检查归档 *z* 中的文件。返回损坏的第一个归档成员的名称的字符串，如果归档完好则返回 **None**。
    |'
- en: '| write | write(*filename*, arcname=**None**, compress_type=**None**, compresslevel=**None**)
    Writes the file named by string *filename* to archive *z*, with archive member
    name arcname. When arcname is **None**, write uses *filename* as the archive member
    name. When compress_type or compresslevel is **None** (the default), write uses
    *z*’s compression type and level; otherwise, compress_type and/or compresslevel
    specify how to compress the file. *z* must be opened for modes ''w'', ''x'', or
    ''a''; otherwise ValueError is raised. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| write | write(*filename*, arcname=**None**, compress_type=**None**, compresslevel=**None**)
    将由字符串 *filename* 指定的文件写入归档 *z*，并使用 arcname 作为归档成员名称。当 arcname 为 **None** 时，write
    使用 *filename* 作为归档成员名称。当 compress_type 或 compresslevel 为 **None**（默认值）时，write
    使用 *z* 的压缩类型和级别；否则，compress_type 和/或 compresslevel 指定如何压缩文件。*z* 必须以 ''w''、''x''
    或 ''a'' 模式打开；否则将引发 ValueError。 |'
- en: '| writestr | writestr(*zinfo_arc*, *data,* compress_type=**None***,* compresslevel=**None**)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '| writestr | writestr(*zinfo_arc*, *data,* compress_type=**None***,* compresslevel=**None**)'
- en: Adds a member to archive *z* using the metadata specified by *zinfo_arc* and
    the data in *data*. *zinfo_arc* must be either a ZipInfo instance specifying at
    least *filename* and *date_time*, or a string to be used as the archive member
    name with the date and time are set to the current moment. *data* is an instance
    of bytes or str. When compress_type or compresslevel is **None** (the default),
    writestr uses *z*’s compression type and level; otherwise, compress_type and/or
    compresslevel specify how to compress the file. *z* must be opened for modes 'w',
    'x', or 'a'; otherwise ValueError is raised.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用指定的元数据 *zinfo_arc* 和 *data* 中的数据向归档 *z* 添加成员。*zinfo_arc* 必须是指定至少 *filename*
    和 *date_time* 的 ZipInfo 实例，或者是用作归档成员名称的字符串，日期和时间设置为当前时刻。*data* 是 bytes 或 str 的实例。当
    compress_type 或 compresslevel 为 **None**（默认值）时，writestr 使用 *z* 的压缩类型和级别；否则，compress_type
    和/或 compresslevel 指定如何压缩文件。*z* 必须以 'w'、'x' 或 'a' 模式打开；否则将引发 ValueError。
- en: 'When you have data in memory and need to write the data to the ZIP file archive
    *z*, it’s simpler and faster to use *z*.writestr than *z*.write. The latter would
    require you to write the data to disk first and later remove the useless disk
    file; with the former you can just code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有内存中的数据并需要将数据写入到 ZIP 文件归档 *z* 中时，使用 *z*.writestr 比 *z*.write 更简单更快。后者需要你首先将数据写入磁盘，然后再删除无用的磁盘文件；而前者可以直接编码：
- en: '[PRE8]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here’s how you can print a list of all files contained in the ZIP file archive
    created by the previous example, followed by each file’s name and contents:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何打印由上一个示例创建的 ZIP 文件归档中包含的所有文件的列表，以及每个文件的名称和内容：
- en: '[PRE9]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '|'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: The ZipInfo class
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ZipInfo 类
- en: The methods getinfo and infolist of ZipFile instances return instances of class
    ZipInfo to supply information about members of the archive. [Table 11-14](#useful_attributes_of_a_zipinfo_instance)
    lists the most useful attributes supplied by a ZipInfo instance *z*.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ZipFile 实例的 getinfo 和 infolist 方法返回 ZipInfo 类的实例，用于提供有关归档成员的信息。[Table 11-14](#useful_attributes_of_a_zipinfo_instance)
    列出了 ZipInfo 实例 *z* 提供的最有用的属性。
- en: Table 11-14\. Useful attributes of a ZipInfo instance z
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Table 11-14\. ZipInfo 实例 z 的有用属性
- en: '| comment | A string that is a comment on the archive member |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| comment | 归档成员的评论字符串'
- en: '| compress_size | The size, in bytes, of the compressed data for the archive
    member |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| compress_size | 归档成员压缩数据的字节大小 |'
- en: '| compress_type | An integer code recording the type of compression of the
    archive member |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| compress_type | 记录归档成员压缩类型的整数代码 |'
- en: '| date_time | A tuple of six integers representing the time of the last modification
    to the file: the items are year (>=1980), month, day (1+), hour, minute, second
    (0+) |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| date_time | 一个由六个整数组成的元组，表示文件的最后修改时间：年（>=1980）、月、日（1+）、小时、分钟、秒（0+） |'
- en: '| file_size | The size, in bytes, of the uncompressed data for the archive
    member |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| file_size | 存档成员的未压缩数据大小，以字节为单位 |'
- en: '| filename | The name of the file in the archive |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| filename | 存档中文件的名称 |'
- en: The os Module
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: os 模块
- en: os is an umbrella module presenting a nearly uniform cross-platform view of
    the capabilities of various operating systems. It supplies low-level ways to create
    and handle files and directories, and to create, manage, and destroy processes.
    This section covers filesystem-related functions of os; [“Running Other Programs
    with the os Module”](ch15.xhtml#running_other_programs_with_the_os_modu) covers
    process-related functions. Most of the time you can use other modules at higher
    levels of abstraction and gain productivity, but understanding what is “underneath”
    in the low-level os module can still be quite useful (hence our coverage).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: os 是一个综合模块，提供了对各种操作系统能力的几乎统一的跨平台视图。它提供了低级方法来创建和处理文件和目录，以及创建、管理和销毁进程。本节介绍了 os
    的与文件系统相关的函数；[“使用 os 模块运行其他程序”](ch15.xhtml#running_other_programs_with_the_os_modu)
    则涵盖了与进程相关的函数。大多数情况下，你可以使用更高级的抽象级别的其他模块来提高生产力，但理解底层 os 模块中的“底层”内容仍然非常有用（因此我们进行了覆盖）。
- en: 'The os module supplies a name attribute, a string that identifies the kind
    of platform on which Python is being run. Common values for name are ''posix''
    (all kinds of Unix-like platforms, including Linux and macOS) and ''nt'' (all
    kinds of Windows platforms); ''java'' is for the old but still-missed Jython.
    You can exploit some unique capabilities of a platform through functions supplied
    by os. However, this book focuses on cross-platform programming, not platform-specific
    functionality, so we cover neither parts of os that exist only on one platform,
    nor platform-specific modules: functionality covered in this book is available
    at least on ''posix'' and ''nt'' platforms. We do, though, cover some of the differences
    among the ways in which a given functionality is provided on various platforms.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: os 模块提供了一个 name 属性，这是一个字符串，用于标识 Python 运行的平台类型。name 的常见值包括 'posix'（各种 Unix 类平台，包括
    Linux 和 macOS）和 'nt'（各种 Windows 平台）；'java' 是老旧但仍然想念的 Jython。你可以通过 os 提供的函数利用某个平台的一些独特功能。然而，本书关注的是跨平台编程，而不是特定于平台的功能，因此我们不涵盖仅存在于一个平台上的
    os 部分，也不涵盖特定于平台的模块：本书涵盖的功能至少在 'posix' 和 'nt' 平台上可用。然而，我们确实涵盖了在各个平台上提供给定功能的方式之间的一些差异。
- en: Filesystem Operations
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件系统操作
- en: 'Using the os module, you can manipulate the filesystem in a variety of ways:
    creating, copying, and deleting files and directories; comparing files; and examining
    filesystem information about files and directories. This section documents the
    attributes and methods of the os module that you use for these purposes, and covers
    some related modules that operate on the filesystem.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 os 模块，你可以以多种方式操作文件系统：创建、复制和删除文件和目录；比较文件；以及检查关于文件和目录的文件系统信息。本节记录了你用于这些目的的
    os 模块的属性和方法，并涵盖了一些操作文件系统的相关模块。
- en: Path-string attributes of the os module
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: os 模块的路径字符串属性
- en: A file or directory is identified by a string, known as its *path*, whose syntax
    depends on the platform. On both Unix-like and Windows platforms, Python accepts
    Unix syntax for paths, with a slash (/) as the directory separator. On non-Unix-like
    platforms, Python also accepts platform-specific path syntax. On Windows, in particular,
    you may use a backslash (\) as the separator. However, you then need to double
    up each backslash as \\ in string literals, or use raw string literal syntax (as
    covered in [“Strings”](ch03.xhtml#string)); you also needlessly lose portability.
    Unix path syntax is handier and usable everywhere, so we strongly recommend that
    you *always* use it. In the rest of this chapter, we use Unix path syntax in both
    explanations and examples.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 文件或目录由一个字符串标识，称为其*路径*，其语法取决于平台。在类 Unix 和 Windows 平台上，Python 接受 Unix 路径的语法，斜线
    (/) 作为目录分隔符。在非 Unix 类平台上，Python 还接受特定于平台的路径语法。特别是在 Windows 上，你可以使用反斜杠 (\) 作为分隔符。然而，在字符串文字中，你需要将每个反斜杠双写为
    \\，或者使用原始字符串文字语法（如 [“字符串”](ch03.xhtml#string) 中所述）；但这会使程序失去可移植性。Unix 路径语法更加方便，可以在任何地方使用，因此我们强烈建议*始终*使用它。在本章的其余部分，我们在解释和示例中都使用
    Unix 路径语法。
- en: The os module supplies attributes that provide details about path strings on
    the current platform, detailed in [Table 11-15](#attributes_supplied_by_the_os_module).
    You should typically use the higher-level path manipulation operations covered
    in [“The os.path Module”](#the_osdotpath_module)^([3](ch11.xhtml#ch01fn103)) rather
    than lower-level string operations based on these attributes. However, these attributes
    may be useful at times.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`os` 模块提供了关于当前平台路径字符串的属性，详见 [Table 11-15](#attributes_supplied_by_the_os_module)。通常应使用高级别的路径操作（见
    [“The os.path Module”](#the_osdotpath_module)^([3](ch11.xhtml#ch01fn103))），而非基于这些属性的低级别字符串操作。然而，在某些情况下，这些属性可能会很有用。'
- en: Table 11-15\. Attributes supplied by the os module
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Table 11-15\. `os` 模块提供的属性
- en: '| curdir | The string that denotes the current directory (''.'' on Unix and
    Windows) |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| curdir | 表示当前目录的字符串（在 Unix 和 Windows 上为 ''.''） |'
- en: '| defpath | The default search path for programs, used if the environment lacks
    a PATH environment variable |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| defpath | 程序的默认搜索路径，如果环境缺少 PATH 环境变量则使用 |'
- en: '| extsep | The string that separates the extension part of a file’s name from
    the rest of the name (''.'' on Unix and Windows) |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| extsep | 文件名扩展部分与其余部分之间的分隔符（在 Unix 和 Windows 上为 ''.''） |'
- en: '| linesep | The string that terminates text lines (''\n'' on Unix; ''\r\n''
    on Windows) |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| linesep | 终止文本行的字符串（在 Unix 上为 ''\n''；在 Windows 上为 ''\r\n''） |'
- en: '| pardir | The string that denotes the parent directory (''..'' on Unix and
    Windows) |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| pardir | 表示父目录的字符串（在 Unix 和 Windows 上为 ''..''） |'
- en: '| pathsep | The separator between paths in lists of paths expressed as strings,
    such as those used for the environment variable PATH ('':'' on Unix; '';'' on
    Windows) |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| pathsep | 字符串列表中路径之间的分隔符，比如用于环境变量 PATH 的（在 Unix 上为 '':''；在 Windows 上为 '';''）
    |'
- en: '| sep | The separator of path components (''/'' on Unix; ''\\'' on Windows)
    |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| sep | 路径组件的分隔符（在 Unix 上为 ''/''；在 Windows 上为 ''\\''） |'
- en: Permissions
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 权限
- en: 'Unix-like platforms associate nine bits with each file or directory: three
    each for the file’s owner, its group, and everybody else (aka “others” or “the
    world”), indicating whether the file or directory can be read, written, and executed
    by the given subject. These nine bits are known as the file’s *permission bits*,
    and are part of the file’s *mode* (a bit string that includes other bits that
    describe the file). You often display these bits in octal notation, which groups
    three bits per digit. For example, mode 0o664 indicates a file that can be read
    and written by its owner and group, and that anybody else can read, but not write.
    When any process on a Unix-like system creates a file or directory, the operating
    system applies to the specified mode a bit mask known as the process’s *umask*,
    which can remove some of the permission bits.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 类 Unix 平台为每个文件或目录关联九个位：三个位为文件的所有者、其组和其他人（即“others”或“the world”），指示该文件或目录能否被给定主体读取、写入和执行。这九个位称为文件的
    *权限位*，是文件 *模式* 的一部分（一个包括描述文件的其他位的位字符串）。通常以八进制表示这些位，每个数字表示三个位。例如，模式 0o664 表示一个文件，其所有者和组可以读取和写入，任何其他人只能读取，不能写入。在
    Unix 类似系统上，当任何进程创建文件或目录时，操作系统将应用称为进程的 *umask* 的位掩码，可以移除一些权限位。
- en: Non-Unix-like platforms handle file and directory permissions in very different
    ways. However, the os functions that deal with file permissions accept a *mode*
    argument according to the Unix-like approach described in the previous paragraph.
    Each platform maps the nine permission bits in a way appropriate for it. For example,
    on Windows, which distinguishes only between read-only and read/write files and
    does not record file ownership, a file’s permission bits show up as either 0o666
    (read/write) or 0o444 (read-only). On such a platform, when creating a file, the
    implementation looks only at bit 0o200, making the file read/write when that bit
    is 1 and read-only when it is 0.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 非 Unix 类似平台以非常不同的方式处理文件和目录权限。然而，处理文件权限的 `os` 函数接受一个根据前述 Unix 类似方法的 *模式* 参数。每个平台将这九个权限位映射到适合其的方式。例如，在
    Windows 上，它只区分只读和读写文件，并且不记录文件所有权，文件的权限位显示为 0o666（读/写）或 0o444（只读）。在这样的平台上，创建文件时，实现只关注位
    0o200，当该位为 1 时文件为读/写，为 0 时为只读。
- en: File and directory functions of the os module
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`os` 模块的文件和目录函数'
- en: 'The os module supplies several functions (listed in [Table 11-16](#os_module_functions))
    to query and set file and directory status. In all versions and platforms, the
    argument *path* to any of these functions can be a string giving the path of the
    file or directory involved, or it can be a path-like object (in particular, an
    instance of pathlib.Path, covered later in this chapter). There are also some
    particularities on some Unix platforms:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: os 模块提供了几个函数（在 [Table 11-16](#os_module_functions) 中列出）来查询和设置文件和目录状态。在所有版本和平台上，这些函数的参数
    *path* 都可以是给定所涉及文件或目录路径的字符串，也可以是路径类对象（特别是 pathlib.Path 的实例，在本章后面介绍）。在一些 Unix 平台上还有一些特殊性：
- en: Some of the functions also support a *file descriptor* (*fd*)—an int denoting
    a file as returned, for example, by os.open—as the *path* argument. The module
    attribute os.supports_fd is the set of functions in the os module that support
    this behavior (the module attribute is missing on platforms lacking such support).
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些函数还支持 *文件描述符*（*fd*）——一个整数，表示例如由 os.open 返回的文件作为 *path* 参数。模块属性 os.supports_fd
    是支持此行为的 os 模块中的函数集合（在不支持此类功能的平台上，该模块属性将缺失）。
- en: Some functions support the optional keyword-only argument follow_symlinks, defaulting
    to **True**. When this argument is **True**, if *path* indicates a symbolic link,
    the function follows it to reach an actual file or directory; when it’s **False**,
    the function operates on the symbolic link itself. The module attribute os.supports_follow_symlinks,
    if present, is the set of functions in the os module that support this argument.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些函数支持可选的仅限关键字参数 follow_symlinks，默认为 **True**。当此参数为 **True** 时，如果 *path* 指示一个符号链接，则函数跟随它以达到实际的文件或目录；当此参数为
    **False** 时，函数在符号链接本身上操作。模块属性 os.supports_follow_symlinks（如果存在）是支持此参数的 os 模块中的函数集合。
- en: Some functions support the optional named-only argument dir_fd, defaulting to
    None. When dir_fd is present, *path* (if relative) is taken as being relative
    to the directory open at that file descriptor; when missing, *path* (if relative)
    is taken as relative to the current working directory. If *path* is absolute,
    dir_fd is ignored. The module attribute os.supports_dir_fd, if present, is the
    set of functions of the os module that support this argument.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些函数支持可选的仅限命名参数 dir_fd，默认为 None。当 dir_fd 存在时，*path*（如果是相对路径）被视为相对于在该文件描述符上打开的目录；当缺少
    dir_fd 时，*path*（如果是相对路径）被视为相对于当前工作目录。如果 *path* 是绝对路径，则忽略 dir_fd。模块属性 os.supports_dir_fd（如果存在）是支持该参数的
    os 模块函数集合。
- en: Additionally, on some platforms the named-only argument effective_ids, defaulting
    to **False**, lets you choose to use effective rather than real user and group
    identifiers. Check whether it is available on your platform with os.supports_effective_ids.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，某些平台上的命名参数 effective_ids，默认为 **False**，允许您选择使用有效的而不是真实的用户和组标识符。通过 os.supports_effective_ids
    检查它在您的平台上是否可用。
- en: Table 11-16\. os module functions
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Table 11-16\. os 模块函数
- en: '| access | access(*path*, *mode*, *, dir_fd=**None**, effective_ids=**False**,
    follow_symlinks=**True**)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '| access | access(*path*, *mode*, *, dir_fd=**None**, effective_ids=**False**,
    follow_symlinks=**True**)'
- en: Returns **True** when the file or path-like object *path* has all of the permissions
    encoded in integer *mode*; otherwise, returns **False**. *mode* can be os.F_OK
    to test for file existence, or one or more of os.R_OK, os.W_OK, and os.X_OK (joined
    with the bitwise OR operator &#124;, if more than one) to test permissions to
    read, write, and execute the file. If dir_fd is not **None**, access operates
    on *path* relative to the provided directory (if *path* is absolute, dir_fd is
    ignored). Pass the keyword-only argument effective_ids=**True** (the default is
    **False**) to use effective rather than real user and group identifiers (this
    may not work on all platforms). If you pass follow_symlinks=**False** and the
    last element of *path* is a symbolic link, access operates on the symbolic link
    itself, not on the file pointed to by the link.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件或类似路径对象 *path* 具有整数 *mode* 编码的所有权限时返回 **True**；否则返回 **False**。*mode* 可以是
    os.F_OK 以测试文件存在性，或者是 os.R_OK、os.W_OK 和 os.X_OK 中的一个或多个（如果有多个，则使用按位或运算符 &#124;
    连接）以测试读取、写入和执行文件的权限。如果 dir_fd 不是 **None**，则 access 在相对于提供的目录上操作 *path*（如果 *path*
    是绝对路径，则忽略 dir_fd）。传递关键字参数 effective_ids=**True**（默认为 **False**）以使用有效的而不是真实的用户和组标识符（这在所有平台上可能不起作用）。如果传递
    follow_symlinks=**False** 并且 *path* 的最后一个元素是符号链接，则 access 在符号链接本身上操作，而不是在链接指向的文件上操作。
- en: access does not use the standard interpretation for its *mode* argument, covered
    in the previous section. Rather, access tests only if this specific process’s
    real user and group identifiers have the requested permissions on the file. If
    you need to study a file’s permission bits in more detail, see the function stat,
    covered later in this table.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: access 不使用其 *mode* 参数的标准解释，详细内容请参阅前一节。相反，access 仅测试此特定进程的真实用户和组标识符对文件的请求权限。如果需要更详细地研究文件的权限位，请参阅后面在此表中介绍的
    stat 函数。
- en: Don’t use access to check if a user is authorized to open a file, before opening
    it; this might be a security hole. |
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用 access 来检查用户在打开文件之前是否被授权打开文件；这可能存在安全漏洞。 |
- en: '| chdir | chdir(*path*) Sets the current working directory of the process to
    *path*, which may be a file descriptor or path-like object. |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| chdir | chdir(*path*) 将进程的当前工作目录设置为 *path*，*path* 可以是文件描述符或类似路径的对象。 |'
- en: '| chmod, lchmod | chmod(*path*, *mode, *,* dir_fd=**None**, follow_symlinks=**True**)
    lchmod(*path*, *mode*)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '| chmod, lchmod | chmod(*path*, *mode, *,* dir_fd=**None**, follow_symlinks=**True**)
    lchmod(*path*, *mode*)'
- en: Changes the permissions of the file (or file descriptor or path-like object)
    *path*, as encoded in integer *mode*. *mode* can be zero or more of os.R_OK, os.W_OK,
    and os.X_OK (joined with the bitwise OR operator &#124;, if more than one) for
    read, write, and execute permissions. On Unix-like platforms, *mode* can be a
    richer bit pattern (as covered in the previous section) to specify different permissions
    for user, group, and other, as well as having other special, rarely used bits
    defined in the module stat and listed in the [online docs](https://oreil.ly/Ue-aa).
    Pass follow_symlinks=**False** (or use lchmod) to change permissions of a symbolic
    link, not the target of that link. |
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 更改文件（或文件描述符或类似路径的对象）*path* 的权限，权限由整数 *mode* 编码。 *mode* 可以是 os.R_OK、os.W_OK 和
    os.X_OK 的任意组合（如果有多个则用按位或运算符 &#124; 连接）来表示读、写和执行权限。在类 Unix 平台上，*mode* 可以是更复杂的位模式（如前一节所述），用于指定用户、组和其他对象的不同权限，还可以定义模块
    stat 中的其他特殊且不常用的位。具体详细信息请参阅 [在线文档](https://oreil.ly/Ue-aa)。传递 follow_symlinks=**False**（或使用
    lchmod）来更改符号链接的权限，而不是该链接的目标文件。 |
- en: '| DirEntry | An instance *d* of class DirEntry supplies attributes *name* and
    *path*, holding the item’s base name and full path, respectively, and several
    methods, of which the most frequently used are is_dir, is_file, and is_symlink.
    is_dir and is_file by default follow symbolic links: pass follow_symlinks=**False**
    to avoid this behavior. *d* avoids system calls as much as feasible, and when
    it needs one, it caches the results. If you need information that’s guaranteed
    to be up-to-date, you can call os.stat(*d*.path) and use the stat_result instance
    it returns; however, this sacrifices scandir’s potential performance improvements.
    For more complete information, see the [online docs](https://oreil.ly/4ZsbW).
    |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| DirEntry | 类 DirEntry 的实例 *d* 提供属性 *name* 和 *path*，分别保存条目的基本名称和完整路径，以及几种方法，其中最常用的是
    is_dir、is_file 和 is_symlink。is_dir 和 is_file 默认会跟随符号链接：传递 follow_symlinks=**False**
    可以避免此行为。*d* 在尽可能的情况下避免系统调用，并在需要时缓存结果。如果需要确保获取的信息是最新的，可以调用 os.stat(*d*.path) 并使用其返回的
    stat_result 实例；不过这可能会牺牲 scandir 的性能提升。有关更详细的信息，请参阅 [在线文档](https://oreil.ly/4ZsbW)。
    |'
- en: '| getcwd, getcwdb | getcwd(), getcwdb()'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '| getcwd, getcwdb | getcwd(), getcwdb()'
- en: getcwd returns a str, the path of the current working directory. getcwdb returns
    a bytes string (3.8+ with UTF-8 encoding on Windows). |
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: getcwd 返回一个 str，表示当前工作目录的路径。getcwdb 返回一个 bytes 字符串（在 Windows 上使用 UTF-8 编码，3.8+
    版本）。 |
- en: '| link | link(*src*, *dst*, ***, src_dir_fd=**None**, dst_dir_fd=**None**,
    follow_symlinks=**True**)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '| link | link(*src*, *dst*, ***, src_dir_fd=**None**, dst_dir_fd=**None**,
    follow_symlinks=**True**)'
- en: Creates a *hard* link named *dst*, pointing to *src*. Both may be path-like
    objects. Set src_dir_fd and/or dst_dir_fd for link to operate on relative paths,
    and pass follow_symlinks=**False** to only operate on a symbolic link, not the
    target of that link. To create a symbolic (“soft”) link, use the symlink function,
    covered later in this table. |
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 创建名为 *dst* 的硬链接，指向 *src*。 *src* 和 *dst* 都可以是类似路径的对象。设置 src_dir_fd 和/或 dst_dir_fd
    以便链接操作使用相对路径，并传递 follow_symlinks=**False** 只在符号链接上操作，而不是该链接的目标文件。要创建符号（“软”）链接，请使用稍后在此表中介绍的
    symlink 函数。 |
- en: '| listdir | listdir(path=''.'') Returns a list whose items are the names of
    all files and subdirectories in the directory, file descriptor (referring to a
    directory), or path-like object path. The list is in arbitrary order and does
    *not* include the special directory names ''.'' (current directory) and ''..''
    (parent directory). When path is of type bytes, the filenames returned are also
    of type bytes; otherwise, they are of type str. See also the alternative function
    scandir, covered later in this table, which can offer performance improvements
    in some cases. Don’t remove or add files to the directory during the call of this
    function: that may produce unexpected results. |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| listdir | listdir(path=''.'') 返回列表，其中的项是目录中所有文件和子目录的名称，文件描述符（指向目录）或类路径对象
    path。列表顺序任意，并且*不*包括特殊目录名称 ''.''（当前目录）和 ''..''（父目录）。当 path 类型为 bytes 时，返回的文件名也为
    bytes 类型；否则为 str 类型。请参阅表中稍后的替代函数 scandir，在某些情况下可提供性能改进。在调用此函数期间，请勿从目录中删除或添加文件：这可能会产生意外的结果。'
- en: '| mkdir, makedirs | mkdir(*path*, mode=0777, dir_fd=**None**), makedirs(*path*,
    mode=0777, exist_ok=**False**)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '| mkdir, makedirs | mkdir(*path*, mode=0777, dir_fd=**None**), makedirs(*path*,
    mode=0777, exist_ok=**False**)'
- en: mkdir creates only the rightmost directory of *path* and raises OSError if any
    of the previous directories in *path* do not exist. mkdir accepts dir_fd for paths
    relative to a file descriptor. makedirs creates all directories that are part
    of *path* and do not yet exist (pass exist_ok=**True** to avoid raising FileExistsError).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: mkdir 仅创建 *path* 中最右侧的目录，如果 *path* 中的前面任何目录不存在，则引发 OSError。mkdir 可接受 dir_fd
    以相对于文件描述符的方式访问路径。makedirs 创建 *path* 中尚不存在的所有目录（传递 exist_ok=**True** 可避免引发 FileExistsError）。
- en: Both functions use mode as permission bits of directories they create, but some
    platforms, and some newly created intermediate-level directories, may ignore mode;
    use chmod to explicitly set permissions. |
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 两个函数都使用 mode 作为它们创建的目录的权限位，但某些平台和某些新创建的中间级目录可能会忽略 mode；使用 chmod 明确设置权限。
- en: '| remove, unlink | remove(*path*, ***, dir_fd*=***None**), unlink(*path*, ***,
    dir_fd=**None**)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '| remove, unlink | remove(*path*, ***, dir_fd*=***None**), unlink(*path*, ***,
    dir_fd=**None**)'
- en: Removes the file or path-like object *path* , which may be relative to dir_fd.
    See rmdir later in this table to remove a directory, rather than a file. unlink
    is a synonym of remove. |
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 删除文件或类路径对象 *path*（相对于 dir_fd）。请参阅表中稍后的 rmdir 来删除目录而不是文件。unlink 是 remove 的同义词。
- en: '| removedirs | removedirs(*path*) Loops from right to left over the directories
    that are part of *path*, which may be a path-like object, removing each one. The
    loop ends when a removal attempt raises an exception, generally because a directory
    is not empty. removedirs does not propagate the exception, as long as it has removed
    at least one directory. |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| removedirs | removedirs(*path*) 从右到左遍历 *path* 的目录部分（可能是类路径对象），依次移除每个目录。循环在遇到异常（通常是因为目录不为空）时结束。只要
    removedirs 至少删除了一个目录，就不会传播异常。|'
- en: '| rename, renames | rename(src, dst, ***, src_dir_fd=**None**, dst_dir_fd=**None**),
    renames(*src*, *dst, /*)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '| rename, renames | rename(src, dst, ***, src_dir_fd=**None**, dst_dir_fd=**None**),
    renames(*src*, *dst, /*)'
- en: Renames (“moves”) the file, path-like object, or directory named src to dst.
    If dst already exists, rename may either replace dst or raise an exception; to
    guarantee replacement, instead call the function os.replace. To use relative paths,
    pass src_dir_fd and/or dst_dir_fd.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: renames（“移动”）文件、类路径对象或名为 src 的目录到 dst。如果 dst 已存在，rename 可能会替换 dst 或引发异常；要保证替换，请调用
    os.replace 函数。要使用相对路径，传递 src_dir_fd 和/或 dst_dir_fd。
- en: renames works like rename, except it creates all intermediate directories needed
    for *dst*. After renaming, renames removes empty directories from the path *src*
    using removedirs. It does not propagate any resulting exception; it’s not an error
    if the renaming does not empty the starting directory of *src*. renames cannot
    accept relative path arguments. |
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: renames 功能与 rename 类似，但它会为 *dst* 创建所有必要的中间目录。重命名后，renames 使用 removedirs 从路径
    *src* 中移除空目录。如果重命名未清空 *src* 的起始目录，不会传播任何导致的异常；这并不算是错误。renames 无法接受相对路径参数。
- en: '| rmdir | rmdir(*path*, ***, dir_fd=**None**) Removes the empty directory or
    path-like object named *path* (which may be relative to dir_fd). Raises OSError
    if the removal fails, and, in particular, if the directory is not empty. |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| rmdir | rmdir(*path*, ***, dir_fd=**None**) 会删除名为 *path*（可能相对于 dir_fd）的空目录或类路径对象。如果删除失败，特别是如果目录不为空，则会引发
    OSError。|'
- en: '| scandir | scandir(path=''.'') Returns an iterator yielding os.DirEntry instances
    for each item in path, which may be a string, a path-like object, or a file descriptor.
    Using scandir and calling each resulting item’s methods to determine its characteristics
    can provide performance improvements compared to using listdir and stat, depending
    on the underlying platform. scandir may be used as a context manager: e.g., **with**
    os.scandir(*path*) **as** *itr*: to ensure closure of the iterator (freeing up
    resources) when done. |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| scandir | scandir(path=''.'') 返回一个迭代器，针对路径中的每个项目产生一个 os.DirEntry 实例，该路径可以是字符串、类似路径的对象或文件描述符。
    使用 scandir 并调用每个结果项的方法以确定其特征可以提供性能改进，相比于使用 listdir 和 stat，这取决于底层平台。 scandir 可以用作上下文管理器：例如，**with**
    os.scandir(*path*) **as** *itr*: 在完成时确保关闭迭代器（释放资源）。'
- en: '| stat, lstat,'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '| stat, lstat,'
- en: fstat | stat(path, ***, dir_fd=**None**, follow_symlinks=**True**), lstat(path,
    ***, dir_fd*=***None**),
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: fstat | stat(path, ***, dir_fd=**None**, follow_symlinks=**True**), lstat(path,
    ***, dir_fd*=***None**),
- en: fstat(fd)
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: fstat(fd)
- en: stat returns a value *x* of type stat_result, which provides (at least) 10 items
    of information about path. path may be a file, file descriptor (in this case you
    can use stat(fd) or fstat, which only accepts file descriptors), path-like object,
    or subdirectory. *path* may be a relative path of dir_fd, or a symlink (if follow_symlinks=**False**,
    or if using lstat; on Windows, all [reparse points](https://oreil.ly/AvIiq) that
    the OS can resolve are followed unless follow_symlinks=**False***)*. The stat_result
    value is a tuple of values that also supports named access to each of its contained
    values (similar to a collections.namedtuple, though not implemented as such).
    Accessing the items of stat_result by their numeric indices is possible but not
    advisable, because the resulting code is not readable; use the corresponding attribute
    names instead. [Table 11-17](#items_left_parenthesisattributesright_p) lists the
    main 10 attributes of a stat_result instance and the meaning of the corresponding
    items.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: stat 返回类型为 stat_result 的值 *x*，它提供关于路径的（至少）10 个信息项。 path 可以是文件、文件描述符（在这种情况下，您可以使用
    stat(fd) 或 fstat，它仅接受文件描述符）、类似路径的对象或子目录。 *path* 可以是 dir_fd 的相对路径，也可以是符号链接（如果 follow_symlinks=**False**，或者使用
    lstat；在 Windows 上，除非 follow_symlinks=**False**，否则会遵循操作系统可以解析的所有[重解析点](https://oreil.ly/AvIiq)）。
    stat_result 值是一个包含值元组，也支持对其包含值的每个命名访问（类似于 collections.namedtuple，尽管未实现为此类）。 访问
    stat_result 的项目通过其数字索引是可能的，但不建议，因为结果代码不可读； 相反，请使用相应的属性名称。 [表 11-17](#items_left_parenthesisattributesright_p)
    列出了 stat_result 实例的主要 10 个属性以及相应项的含义。
- en: Table 11-17\. Items (attributes) of a stat_result instance
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-17\. stat_result 实例的项（属性）
- en: '&#124; Item index &#124; Attribute name &#124; Meaning &#124;'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 项目索引 &#124; 属性名称 &#124; 含义 &#124;'
- en: '&#124; --- &#124; --- &#124; --- &#124;'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; --- &#124; --- &#124; --- &#124;'
- en: '&#124; 0 &#124; st_mode &#124; Protection and other mode bits &#124;'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 0 &#124; st_mode &#124; 保护和其他模式位 &#124;'
- en: '&#124; 1 &#124; st_ino &#124; Inode number &#124;'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 1 &#124; st_ino &#124; inode 号码 &#124;'
- en: '&#124; 2 &#124; st_dev &#124; Device ID &#124;'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 2 &#124; st_dev &#124; 设备 ID &#124;'
- en: '&#124; 3 &#124; st_nlink &#124; Number of hard links &#124;'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 3 &#124; st_nlink &#124; 硬链接数量 &#124;'
- en: '&#124; 4 &#124; st_uid &#124; User ID of owner &#124;'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 4 &#124; st_uid &#124; 所有者的用户 ID &#124;'
- en: '&#124; 5 &#124; st_gid &#124; Group ID of owner &#124;'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 5 &#124; st_gid &#124; 所有者的组 ID &#124;'
- en: '&#124; 6 &#124; st_size &#124; Size, in bytes &#124;'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 6 &#124; st_size &#124; 大小（以字节为单位） &#124;'
- en: '&#124; 7 &#124; st_atime &#124; Time of last access &#124;'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 7 &#124; st_atime &#124; 最后访问时间 &#124;'
- en: '&#124; 8 &#124; st_mtime &#124; Time of last modification &#124;'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 8 &#124; st_mtime &#124; 最后修改时间 &#124;'
- en: '&#124; 9 &#124; st_ctime &#124; Time of last status change &#124;'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '&#124; 9 &#124; st_ctime &#124; 最后状态更改时间 &#124;'
- en: 'For example, to print the size, in bytes, of file *path*, you can use any of:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要打印文件 *path* 的大小（以字节为单位），您可以使用以下任何一种：
- en: '[PRE10]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Time values are in seconds since the epoch, as covered in [Chapter 13](ch13.xhtml#time_operations)
    (int, on most platforms). Platforms unable to give a meaningful value for an item
    use a dummy value. For other, platform-dependent attributes of stat_result instances,
    see the [online docs](https://oreil.ly/o7wOH). |
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 时间值以自纪元以来的秒数表示，如 [第 13 章](ch13.xhtml#time_operations) 中所述（在大多数平台上为整数）。 无法为项目提供有意义值的平台使用虚拟值。
    对于 stat_result 实例的其他、特定于平台的属性，请参阅 [在线文档](https://oreil.ly/o7wOH)。
- en: '| symlink | symlink(*target*, *symlink_path*, target_is_directory=**False**,
    *, dir_fd=**None**) Creates a symbolic link named *symlink_path* to the file,
    directory, or path-like object *target*, which may be relative to dir_fd. target_is_directory
    is used only on Windows systems, to specify whether the created symlink should
    represent a file or a directory; this argument is ignored on non-Windows systems.
    (Calling os.symlink typically requires elevated privileges when run on Windows.)
    |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| symlink | symlink(*target*, *symlink_path*, target_is_directory=**False**,
    *, dir_fd=**None**) 创建名为*symlink_path*的符号链接，指向文件、目录或路径对象*target*。*target*可以相对于dir_fd。target_is_directory仅在Windows系统上使用，用于指定创建的符号链接应表示文件还是目录；在非Windows系统上，此参数将被忽略。（在Windows上运行os.symlink通常需要提升的权限。）
    |'
- en: '| utime | utime(*path*, times=**None**, ***, [*ns*, ]dir_fd=**None**, follow_symlinks=**True**)
    Sets the accessed and modified times of file, directory, or path-like object *path*,
    which may be relative to dir_fd, and may be a symlink if follow_symlinks=**False**.
    If times is **None**, utime uses the current time. Otherwise, times must be a
    pair of numbers (in seconds since the epoch, as covered in [Chapter 13](ch13.xhtml#time_operations))
    in the order (*accessed*, *modified*). To specify nanoseconds instead, pass *ns*
    as (*acc_ns*, *mod_ns*), where each member is an int expressing nanoseconds since
    the epoch. Do *not* specify both times and *ns*. |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| utime | utime(*path*, times=**None**, ***, [*ns*, ]dir_fd=**None**, follow_symlinks=**True**)
    设置文件、目录或路径对象*path*的访问时间和修改时间。*path*可以相对于dir_fd，并且如果follow_symlinks=**False**，*path*可以是符号链接。如果times为**None**，utime使用当前时间。否则，times必须是一对数字（自纪元以来的秒数，详见[第13章](ch13.xhtml#time_operations)），顺序为（*accessed*，*modified*）。要指定纳秒，请将*ns*传递为（*acc_ns*，*mod_ns*），其中每个成员都是表示自纪元以来的纳秒数的整数。不要同时指定times和*ns*。
    |'
- en: '| walk, fwalk | walk(*top*, topdown=**True**, onerror=**None**, followlinks=**False**),
    fwalk(top=''.'', topdown=**True**, onerror=**None**, *, follow_symlinks=**False**,
    dir_fd=**None**)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '| walk, fwalk | walk(*top*, topdown=**True**, onerror=**None**, followlinks=**False**),
    fwalk(top=''.'', topdown=**True**, onerror=**None**, *, follow_symlinks=**False**,
    dir_fd=**None**)'
- en: walk is a generator yielding an item for each directory in the tree whose root
    is the directory or path-like object *top*. When topdown is **True**, the default,
    walk visits directories from the tree’s root downward; when topdown is **False**,
    walk visits directories from the tree’s leaves upward. By default, walk catches
    and ignores any OSError exception raised during the tree-walk; set onerror to
    a callable in order to catch any OSError exception raised during the tree-walk
    and pass it as the only argument in a call to onerror, which may process it, ignore
    it, or **raise** it to terminate the tree-walk and propagate the exception (the
    filename is available as the filename attribute of the exception object).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: walk是一个生成器，为树的每个目录生成一个条目，树的根是目录或路径对象*top*。当topdown为**True**（默认）时，walk从树的根向下访问目录；当topdown为**False**时，walk从树的叶子向上访问目录。默认情况下，walk捕获并忽略树遍历过程中引发的任何OSError异常；将onerror设置为可调用对象，以捕获树遍历过程中引发的任何OSError异常，并将其作为唯一参数传递给onerror，可对其进行处理、忽略或**引发**以终止树遍历并传播异常（文件名可作为异常对象的filename属性访问）。
- en: 'Each item walk yields is a tuple of three subitems: *dirpath*, a string that
    is the directory’s path; *dirnames*, a list of names of subdirectories that are
    immediate children of the directory (special directories ''.'' and ''..'' are
    *not* included); and *filenames*, a list of names of files that are directly in
    the directory. If topdown is **True**, you can alter list *dirnames* in place,
    removing some items and/or reordering others, to affect the tree-walk of the subtree
    rooted at *dirpath*; walk iterates only on subdirectories left in *dirnames*,
    in the order in which they’re left. Such alterations have no effect if topdown
    is **False** (in this case, walk has already visited all subdirectories by the
    time it visits the current directory and yields its item). |'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: walk每生成的条目是一个包含三个子项的元组：*dirpath*，是目录的路径字符串；*dirnames*，是该目录的直接子目录名称列表（特殊目录'.'和'..'
    *不* 包括在内）；*filenames*，是该目录中直接的文件名称列表。如果topdown为**True**，您可以直接修改*dirnames*列表，删除一些项目和/或重新排序其他项目，以影响从*dirpath*开始的子树遍历；walk仅迭代剩余在*dirnames*中的子目录，按照它们留下的顺序。如果topdown为**False**，这些修改将不会生效（在这种情况下，walk在访问当前目录和生成其条目时已经访问了所有子目录）。
    |
- en: '| walk, fwalk'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '| walk, fwalk'
- en: '*(cont.)* | By default, walk does not walk down symbolic links that resolve
    to directories. To get such extra walking, pass followlinks=**True**, but beware:
    this can cause infinite looping if a symbolic link resolves to a directory that
    is its ancestor. walk doesn’t take precautions against this anomaly.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '*(续)* | 默认情况下，walk 不会遍历解析为目录的符号链接。要获得这样的额外遍历，请传递 followlinks=**True**，但请注意：如果符号链接解析为其祖先的目录，这可能会导致无限循环。walk
    对此异常没有采取预防措施。'
- en: followlinks versus follow_symlinks
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: followlinks 与 follow_symlinks
- en: Note that, for os.walk *only*, the argument that is named follow_symlinks everywhere
    else is instead named followlinks.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在所有情况下，对于 os.walk **仅**，名为 follow_symlinks 的参数实际上被命名为 followlinks。
- en: 'fwalk (Unix only) works like walk, except that *top* may be a relative path
    of file descriptor dir_fd, and fwalk yields *four*-member tuples: the first three
    members (*dirpath*, *dirnames*, and *filenames*) are identical to walk’s yielded
    values, and the fourth member is *dirfd*, a file descriptor of *dirpath*. Note
    that both walk and fwalk default to *not* following symlinks. |'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: fwalk（仅Unix）类似于 walk，但 top 可能是文件描述符 dir_fd 的相对路径，并且 fwalk 产生四元组：前三个成员（dirpath、dirnames
    和 filenames）与 walk 的生成值相同，第四个成员是 dirfd，即 dirpath 的文件描述符。请注意，无论是 walk 还是 fwalk，默认情况下
    **不** 跟随符号链接。|
- en: File descriptor operations
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件描述符操作
- en: In addition to the many functions covered earlier, the os module supplies several
    that work specifically with file descriptors. A *file descriptor* is an integer
    that the operating system uses as an opaque handle to refer to an open file. While
    it is usually best to use Python file objects (covered in [“The io Module”](#the_io_module))
    for I/O tasks, sometimes working with file descriptors lets you perform some operations
    faster, or (at the possible expense of portability) in ways not directly available
    with io.open. File objects and file descriptors are not interchangeable.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面介绍的许多函数外，os 模块还提供了几个专门与文件描述符一起使用的函数。*文件描述符* 是操作系统用作不透明句柄以引用打开文件的整数。尽管通常最好使用
    Python 文件对象（在 [“The io Module”](#the_io_module) 中介绍），有时使用文件描述符可以让您执行某些操作更快，或者（可能牺牲可移植性）以不直接可用于
    io.open 的方式执行操作。文件对象和文件描述符不能互换。
- en: 'To get the file descriptor *n* of a Python file object *f*, call *n* = *f*.fileno().
    To create a new Python file object *f* using an existing open file descriptor
    *fd*, use *f* = os.fdopen(*fd*), or pass *fd* as the first argument of io.open.
    On Unix-like and Windows platforms, some file descriptors are preallocated when
    a process starts: 0 is the file descriptor for the process’s standard input, 1
    for the process’s standard output, and 2 for the process’s standard error. Calling
    os module methods such as dup or close on these preallocated file descriptors
    can be useful for redirecting or manipulating standard input and output streams.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 Python 文件对象 *f* 的文件描述符 *n*，请调用 *n* = *f*.fileno()。要使用现有打开的文件描述符 *fd* 创建新的
    Python 文件对象 *f*，请使用 *f* = os.fdopen(*fd*)，或者将 *fd* 作为 io.open 的第一个参数传递。在类 Unix
    和 Windows 平台上，某些文件描述符在进程启动时预分配：0 是进程的标准输入的文件描述符，1 是进程的标准输出的文件描述符，2 是进程的标准错误的文件描述符。调用诸如
    dup 或 close 等 os 模块方法来操作这些预分配的文件描述符，对于重定向或操作标准输入和输出流可能会很有用。
- en: The os module provides many functions for dealing with file descriptors; some
    of the most useful are listed in [Table 11-18](#useful_os_module_functions_to_deal_with).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: os 模块提供了许多处理文件描述符的函数；其中一些最有用的列在 [Table 11-18](#useful_os_module_functions_to_deal_with)
    中。
- en: Table 11-18\. Useful os module functions to deal with file descriptors
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-18\. 处理文件描述符的有用 os 模块函数
- en: '| close | close(*fd*) Closes file descriptor *fd*. |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| close | close(*fd*) 关闭文件描述符 *fd*。|'
- en: '| closerange | closerange(*fd_low*, *fd_high*) Closes all file descriptors
    from *fd_low*, included, to *fd_high*, excluded, ignoring any errors that may
    occur. |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| closerange | closerange(*fd_low*, *fd_high*) 关闭从 *fd_low*（包括 *fd_low*）到 *fd_high*（不包括
    *fd_high*）的所有文件描述符，忽略可能发生的任何错误。|'
- en: '| dup | dup(*fd*) Returns a file descriptor that duplicates file descriptor
    *fd*. |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| dup | dup(*fd*) 返回复制文件描述符 *fd* 的文件描述符。'
- en: '| dup2 | dup2(*fd*, *fd2*) Duplicates file descriptor *fd* to file descriptor
    *fd2*. When file descriptor *fd2* is already open, dup2 first closes *fd2*. |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| dup2 | dup2(*fd*, *fd2*) 复制文件描述符 *fd* 到文件描述符 *fd2*。当文件描述符 *fd2* 已经打开时，dup2
    首先关闭 *fd2*。|'
- en: '| fdopen | fdopen(*fd*, **a*, ***k*) Like io.open, except that *fd* *must*
    be an int that is an open file descriptor. |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| fdopen | fdopen(*fd*, **a*, ***k*) 类似于 io.open，不同之处在于 *fd* **必须** 是打开文件描述符的整数。|'
- en: '| fstat | fstat(*fd*) Returns a stat_result instance *x*, with information
    about the file open on file descriptor *fd*. [Table 11-17](#items_left_parenthesisattributesright_p)
    covers *x*’s contents. |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| fstat | fstat(*fd*) 返回一个 stat_result 实例 *x*，其中包含有关打开在文件描述符 *fd* 上的文件的信息。[表
    11-17](#items_left_parenthesisattributesright_p) 涵盖了 *x* 的内容。 |'
- en: '| lseek | lseek(*fd*, *pos*, *how*) Sets the current position of file descriptor
    *fd* to the signed integer byte offset *pos* and returns the resulting byte offset
    from the start of the file. *how* indicates the reference (point 0). When *how*
    is os.SEEK_SET, a *pos* of 0 means the start of the file; for os.SEEK_CUR it means
    the current position, and for os.SEEK_END it means the end of the file. For example,
    lseek(*fd*, 0, os.SEEK_CUR) returns the current position’s byte offset from the
    start of the file without affecting the current position. Normal disk files support
    seeking; calling lseek on a file that does not support seeking (e.g., a file open
    for output to a terminal) raises an exception. |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| lseek | lseek(*fd*, *pos*, *how*) 将文件描述符 *fd* 的当前位置设置为有符号整数字节偏移量 *pos*，并返回从文件开头的结果字节偏移量。*how*
    表示参考点（点 0）。当 *how* 是 os.SEEK_SET 时，*pos* 为 0 表示文件开头；对于 os.SEEK_CUR，它表示当前位置；对于
    os.SEEK_END，它表示文件末尾。例如，lseek(*fd*, 0, os.SEEK_CUR) 返回从文件开头到当前位置的当前位置的字节偏移量，而不影响当前位置。普通磁盘文件支持寻址；对不支持寻址的文件（例如，向终端输出的文件）调用
    lseek 会引发异常。 |'
- en: '| open | open(*file*, *flags*, mode=0o777) Returns a file descriptor, opening
    or creating a file named by string *file*. When open creates the file, it uses
    mode as the file’s permission bits. *flags* is an int, normally the bitwise OR
    (with operator &#124;) of one or more of the following attributes of os:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '| open | open(*file*, *flags*, mode=0o777) 返回一个文件描述符，打开或创建名为 *file* 的文件。当 open
    创建文件时，使用 mode 作为文件的权限位。*flags* 是一个整数，通常是 os 模块以下一个或多个属性的按位 OR 运算（使用操作符 &#124;
    ）：'
- en: O_APPEND
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: O_APPEND
- en: Appends any new data to *file*’s current contents
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 追加任何新数据到 *file* 当前的内容
- en: O_BINARY
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: O_BINARY
- en: Opens *file* in binary rather than text mode on Windows platforms (raises an
    exception on Unix-like platforms)
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 平台上以二进制而非文本模式打开 *file*（在类 Unix 平台上引发异常）
- en: O_CREAT
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: O_CREAT
- en: Creates *file* if *file* does not already exist
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *file* 不存在，则创建 *file*
- en: O_DSYNC, O_RSYNC, O_SYNC, O_NOCTTY
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: O_DSYNC, O_RSYNC, O_SYNC, O_NOCTTY
- en: Set the synchronization mode accordingly, if the platform supports this
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 根据平台支持的情况设置同步模式
- en: O_EXCL
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: O_EXCL
- en: Raises an exception if *file* already exists
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *file* 已经存在，则抛出异常
- en: O_NDELAY, O_NONBLOCK
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: O_NDELAY, O_NONBLOCK
- en: Opens *file* in nonblocking mode, if the platform supports this
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果平台支持，以非阻塞模式打开 *file*
- en: O_RDONLY, O_WRONLY, O_RDWR
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: O_RDONLY, O_WRONLY, O_RDWR
- en: 'Opens *file* for read-only, write-only, or read/write access, respectively
    (mutually exclusive: exactly one of these attributes *must* be in *flags*)'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 分别打开 *file* 以进行只读、只写或读/写访问（互斥：这些属性中必须有且仅有一个 *flags*）
- en: O_TRUNC
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: O_TRUNC
- en: Throws away previous contents of *file* (incompatible with O_RDONLY)
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 丢弃 *file* 的先前内容（与 O_RDONLY 不兼容）
- en: '|'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| pipe | pipe() Creates a pipe and returns a pair of file descriptors (*r_fd*,
    *w_fd*), respectively open for reading and writing. |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| pipe | pipe() 创建一个管道并返回一对文件描述符（*r_fd*、*w_fd*），分别用于读取和写入。 |'
- en: '| read | read(*fd, n*) Reads up to *n* bytes from file descriptor *fd* and
    returns them as a bytestring. Reads and returns *m < n* bytes when only *m* more
    bytes are currently available for reading from the file. In particular, returns
    the empty string when no more bytes are currently available from the file, typically
    because the file is finished. |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| read | read(*fd, n*) 从文件描述符 *fd* 读取最多 *n* 字节，并将它们作为字节串返回。当只有 *m* 个字节当前可供从文件读取时，读取并返回
    *m < n* 字节。特别地，在没有更多字节当前可用于读取时，通常因为文件已经结束，返回空字符串。 |'
- en: '| write | write(*fd*, *s*) Writes all bytes from bytestring *s* to file descriptor
    *fd* and returns the number of bytes written. |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| write | write(*fd*, *s*) 将字节串 *s* 中的所有字节写入文件描述符 *fd* 并返回写入的字节数。 |'
- en: The os.path Module
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: os.path 模块
- en: The os.path module supplies functions to analyze and transform path strings
    and path-like objects. The most commonly useful functions from the module are
    listed in [Table 11-19](#frequently_used_functions_of_the_osdotp).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: os.path 模块提供了用于分析和转换路径字符串和类似路径对象的函数。该模块中最常用的有用函数列在 [表 11-19](#frequently_used_functions_of_the_osdotp)
    中。
- en: Table 11-19\. Frequently used functions of the os.path module
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-19\. os.path 模块的常用函数
- en: '| abspath | abspath(*path*) Returns a normalized absolute path string equivalent
    to *path*, just like (in the case where *path* is the name of a file in the current
    directory):'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '| abspath | abspath(*path*) 返回与 *path* 等效的标准化绝对路径字符串，就像（在 *path* 是当前目录中文件名的情况下）：'
- en: os.path.normpath(os.path.join(os.getcwd(), *path*))
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: os.path.normpath(os.path.join(os.getcwd(), *path*))
- en: For example, os.path.abspath(os.curdir) is the same as os.getcwd(). |
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，os.path.abspath(os.curdir) 与 os.getcwd() 相同。
- en: '| basename | basename(*path*) Returns the base name part of *path*, just like
    os.path.split(*path*)[1]. For example, os.path.basename(''b/c/d.e'') returns ''d.e''.
    |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| basename | basename(*path*) 返回 *path* 的基本名称部分，就像 os.path.split(*path*)[1]。例如，os.path.basename(''b/c/d.e'')
    返回 ''d.e''。'
- en: '| commonpath | commonpath(*list*) Accepts a sequence of strings or path-like
    objects, and returns the longest common subpath. Unlike commonprefix, only returns
    a valid path; raises ValueError if *list* is empty, contains a mixture of absolute
    and relative paths, or contains paths on different drives. |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| commonpath | commonpath(*list*) 接受字符串或类似路径对象的序列，并返回最长公共子路径。与 commonprefix
    不同，只返回有效路径；如果 *list* 为空、包含绝对和相对路径的混合或包含不同驱动器上的路径，则引发 ValueError。'
- en: '| com⁠m⁠o⁠n​p⁠r⁠e⁠fix | commonprefix(*list*) Accepts a list of strings or pathlike
    objects and returns the longest string that is a prefix of all items in the list,
    or ''.'' if *list* is empty. For example, os.path.commonprefix([''foobar'', ''foolish''])
    returns ''foo''. May return an invalid path; see commonpath if you want to avoid
    this. |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| com⁠m⁠o⁠n​p⁠r⁠e⁠fix | commonprefix(*list*) 接受字符串或类似路径对象的列表，并返回列表中所有项目的最长公共前缀字符串，如果
    *list* 为空则返回 ''.''。例如，os.path.commonprefix([''foobar'', ''foolish'']) 返回 ''foo''。可能返回无效路径；如果要避免此问题，请参阅
    commonpath。'
- en: '| dirname | dirname(*path*) Returns the directory part of *path*, just like
    os.path.split(*path*)[0]. For example, os.path.dirname(''b/c/d.e'') returns ''b/c''.
    |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| dirname | dirname(*path*) 返回 *path* 的目录部分，就像 os.path.split(*path*)[0]。例如，os.path.dirname(''b/c/d.e'')
    返回 ''b/c''。'
- en: '| exists, lexists | exists(*path*), lexists(*path*) exists returns **True**
    when *path* names an existing file or directory (*path* may also be an open file
    descriptor or path-like object); otherwise, returns **False**. In other words,
    os.path.exists(*x*) is the same as os.access(*x*, os.F_OK). lexists is the same,
    but also returns **True** when *path* names an existing symbolic link that indicates
    a nonexistent file or directory (sometimes known as a *broken symlink*), while
    exists returns **False** in such cases. Both return **False** for paths containing
    characters or bytes that are not representable at the OS level. |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| exists, lexists | exists(*path*), lexists(*path*) 当 *path* 是现有文件或目录的名称时，exists
    返回 **True**（*path* 也可以是打开的文件描述符或类似路径对象）；否则返回 **False**。换句话说，os.path.exists(*x*)
    与 os.access(*x*, os.F_OK) 相同。lexists 也是如此，但在 *path* 是指示不存在的文件或目录的现有符号链接（有时称为*损坏的符号链接*）时，也返回
    **True**，而在这种情况下，exists 返回 **False**。对于包含操作系统级别不可表示的字符或字节的路径，两者均返回 **False**。'
- en: '| expandvars, expanduser | expandvars(*path*), expanduser(*path*) Returns a
    copy of string or path-like object *path*, where each substring of the form $*name*
    or ${*name*} (and *%name%* on Windows only) is replaced with the value of environment
    variable *name*. For example, if environment variable HOME is set to /u/alex,
    the following code:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '| expandvars, expanduser | expandvars(*path*), expanduser(*path*) 返回字符串或类似路径对象
    *path* 的副本，在其中形如 $*name* 或 ${*name*}（仅在 Windows 上为 *%name%*）的每个子字符串都替换为环境变量 *name*
    的值。例如，如果环境变量 HOME 设置为 /u/alex，则以下代码：'
- en: '[PRE11]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: emits /u/alex/foo/.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 发射 /u/alex/foo/.
- en: os.path.expanduser expands a leading ~ or ~user, if any, to the path of the
    home directory of the current user. |
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: os.path.expanduser 将前导的 ~ 或 ~user（如果有）扩展为当前用户的主目录路径。
- en: '| getatime, getctime,'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '| getatime, getctime,'
- en: getmtime,
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: getmtime,
- en: 'getsize | getatime(*path*), getctime(*path*), getmtime(*path*), getsize(*path*)
    Each of these functions calls os.stat(*path*) and returns an attribute from the
    result: respectively, st_atime, st_ctime, st_mtime, and st_size. See [Table 11-17](#items_left_parenthesisattributesright_p)
    for more details about these attributes. |'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: getsize | getatime(*path*), getctime(*path*), getmtime(*path*), getsize(*path*)
    每个函数调用 os.stat(*path*) 并从结果中返回一个属性：分别是 st_atime、st_ctime、st_mtime 和 st_size。有关这些属性的更多详细信息，请参阅
    [Table 11-17](#items_left_parenthesisattributesright_p)。
- en: '| isabs | isabs(*path*) Returns **True** when *path* is absolute. (A path is
    absolute when it starts with a (back)slash (/ or \), or, on some non-Unix-like
    platforms, such as Windows, with a drive designator followed by os.sep.) Otherwise,
    isabs returns **False**. |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| isabs | isabs(*path*) 当 *path* 是绝对路径时返回 **True**（路径以斜杠 (/ 或 \) 或在某些非类 Unix
    平台（如 Windows）上以驱动器指示符开头，后跟 os.sep）。否则，isabs 返回 **False**。'
- en: '| isdir | isdir(*path*) Returns **True** when *path* names an existing directory
    (isdir follows symlinks, so isdir and islink may both return **True** ); otherwise,
    returns **False**. |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| isdir | isdir(*path*) 当 *path* 指定的是现有目录时返回 **True**（isdir 跟随符号链接，因此 isdir
    和 islink 可能都返回 **True**）；否则返回 **False**。'
- en: '| isfile | isfile(*path*) Returns **True** when *path* names an existing regular
    file (isfile follows symlinks, so islink may also be **True**); otherwise, returns
    **False**. |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| isfile | isfile(*path*) 当 *path* 指定的是现有常规文件时返回 **True**（isfile 跟随符号链接，因此
    islink 也可能为 **True**）；否则返回 **False**。'
- en: '| islink | islink(*path*) Returns **True** when *path* names a symbolic link;
    otherwise, returns **False**. |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| islink | islink(*path*) 当 *path* 指定的是符号链接时返回 **True**；否则返回 **False**。'
- en: '| ismount | ismount(*path*) Returns **True** when *path* names a [mount point](https://oreil.ly/JYbY5);
    otherwise, returns **False**. |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| ismount | ismount(*path*) 当 *path* 指定的是 [挂载点](https://oreil.ly/JYbY5) 时返回
    **True**；否则返回 **False**。'
- en: '| join | join(*path*, **paths*) Returns a string that joins the arguments (strings
    or path-like objects) with the appropriate path separator for the current platform.
    For example, on Unix, exactly one slash character / separates adjacent path components.
    If any argument is an absolute path, join ignores previous arguments. For example:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '| join | join(*path*, **paths*) 返回一个字符串，它使用当前平台的适当路径分隔符连接参数（字符串或类路径对象）。例如，在Unix上，相邻路径组件之间使用一个斜杠字符
    / 分隔。如果任何参数是绝对路径，join 将忽略先前的参数。例如：'
- en: '[PRE12]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The second call to os.path.join ignores its first argument 'a/b', since its
    second argument '/c/d' is an absolute path. |
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次调用 os.path.join 忽略了其第一个参数 'a/b'，因为其第二个参数 '/c/d' 是绝对路径。 |
- en: '| normcase | normcase(*path*) Returns a copy of *path* with case normalized
    for the current platform. On case-sensitive filesystems (typical in Unix-like
    systems), *path* is returned unchanged. On case-insensitive filesystems (typical
    in Windows), it lowercases the string. On Windows, normcase also converts each
    / to a \\. |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| normcase | normcase(*path*) 返回 *path* 的大小写标准化副本，以适应当前平台。在区分大小写的文件系统（如Unix类系统）中，返回
    *path* 本身。在不区分大小写的文件系统（如Windows）中，将字符串转换为小写。在Windows上，normcase 还会将每个 / 转换为 \\\\。'
- en: '| normpath | normpath(*path*) Returns a normalized pathname equivalent to *path*,
    removing redundant separators and path-navigation aspects. For example, on Unix,
    normpath returns ''a/b'' when *path* is any of ''a//b'', ''a/./b'', or ''a/c/../b''.
    normpath makes path separators appropriate for the current platform. For example,
    on Windows, separators become \\. |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| normpath | normpath(*path*) 返回一个等效于 *path* 的标准化路径名，移除冗余的分隔符和路径导航部分。例如，在Unix上，当
    *path* 是 ''a//b''、''a/./b'' 或 ''a/c/../b'' 之一时，normpath 返回 ''a/b''。normpath 使路径分隔符适合当前平台。例如，在Windows上，分隔符变成
    \\\\。'
- en: '| realpath | realpath(*path*, ***, strict=**False**) Returns the actual path
    of the specified file or directory or path-like object, resolving symlinks along
    the way. 3.10+ Set strict=**True** to raise OSError when *path* doesn’t exist,
    or when there is a loop of symlinks. |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| realpath | realpath(*path*, ***, strict=**False**) 返回指定文件或目录或路径类对象的实际路径，同时解析符号链接。3.10+
    设置 strict=**True** 可以在 *path* 不存在或存在符号链接循环时引发 OSError。'
- en: '| relpath | relpath(*path*, start=os.curdir) Returns a path to the file or
    directory *path* (a str or path-like object) relative to directory start. |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| relpath | relpath(*path*, start=os.curdir) 返回到目录 start 的相对于文件或目录 *path*（一个字符串或路径类对象）的路径。'
- en: '| samefile | samefile(*path1*, *path2*) Returns **True** if both arguments
    (strings or path-like objects) refer to the same file or directory. |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| samefile | samefile(*path1*, *path2*) 如果两个参数（字符串或路径类对象）引用同一文件或目录，则返回 **True**。'
- en: '| sameopenfile | sameopenfile(*fd1*, *fd2*) Returns **True** if both arguments
    (file descriptors) refer to the same file or directory. |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| sameopenfile | sameopenfile(*fd1*, *fd2*) 如果两个参数（文件描述符）引用同一文件或目录，则返回 **True**。'
- en: '| samestat | samestat(*stat1*, *stat2*) Returns **True** if both arguments
    (instances of os.stat_result, typically results of os.stat calls) refer to the
    same file or directory. |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| samestat | samestat(*stat1*, *stat2*) 如果两个参数（通常是 os.stat 调用的结果 os.stat_result
    实例）引用同一文件或目录，则返回 **True**。'
- en: '| split | split(*path*) Returns a pair of strings (*dir*, *base*) such that
    join(*dir*, *base*) equals *path*. *base* is the last component and never contains
    a path separator. When *path* ends in a separator, *base* is ''''. *dir* is the
    leading part of *path*, up to the last separator excluded. For example, os.path.split(''a/b/c/d'')
    returns (''a/b/c'', ''d''). |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| split | split(*path*) 返回一对字符串(*dir*, *base*)，使得join(*dir*, *base*)等于*path*。*base*是最后的组成部分，永远不包含路径分隔符。当*path*以分隔符结尾时，*base*为空字符串。*dir*是*path*的前导部分，直到最后一个分隔符之前的部分。例如，os.path.split(''a/b/c/d'')
    返回 (''a/b/c'', ''d'')。 |'
- en: '| splitdrive | splitdrive(*path*) Returns a pair of strings (*drv*, *pth*)
    such that *drv*+*pth* equals *path*. *drv* is a drive specification, or '''';
    it is always '''' on platforms without drive specifications, e.g. Unix-like systems.
    On Windows, os.path.splitdrive(''c:d/e'') returns (''c:'', ''d/e''). |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| splitdrive | splitdrive(*path*) 返回一对字符串(*drv*, *pth*)，使得*drv*+*pth*等于*path*。*drv*是驱动器规范，或者是''''；在没有驱动器规范的平台（如类Unix系统）上，它始终为''''。在Windows上，os.path.splitdrive(''c:d/e'')
    返回 (''c:'', ''d/e'')。 |'
- en: '| splitext | splitext(*path*) Returns a pair (*root*, *ext*) such that *root*+*ext*
    equals *path*. *ext* is either '''' or starts with a ''.'' and has no other ''.''
    or path separator. For example, o⁠s⁠.⁠p⁠a⁠t⁠h⁠.⁠s⁠p⁠l⁠i⁠t​e⁠x⁠t⁠(⁠''⁠a⁠.⁠a⁠/⁠b⁠.⁠c⁠.⁠d⁠''⁠)
    returns the pair (''a.a/b.c'', ''.d''). |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| splitext | splitext(*path*) 返回一对(*root*, *ext*)，使得*root*+*ext*等于*path*。*ext*要么是空字符串，要么以''.''开头且没有其他''.''或路径分隔符。例如，os.path.splitext(''a.a/b.c.d'')
    返回一对 (''a.a/b.c'', ''.d'')。 |'
- en: OSError Exceptions
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OSError 异常
- en: When a request to the operating system fails, os raises an exception, an instance
    of OSError. os also exposes the built-in exception class OSError with the synonym
    os.error. Instances of OSError expose three useful attributes, detailed in [Table 11-20](#attributes_of_oserror_instances).
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作系统请求失败时，os会引发异常，即OSError的一个实例。os还使用os.error作为OSError的同义词。OSError的实例具有三个有用的属性，详见[Table 11-20](#attributes_of_oserror_instances)。
- en: Table 11-20\. Attributes of OSError instances
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-20\. OSError 实例的属性
- en: '| errno | The numeric error code of the operating system error |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| errno | 操作系统错误的数值错误代码 |'
- en: '| filename | The name of the file on which the operation failed (file-related
    functions only) |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| filename | 操作失败的文件名（仅限文件相关函数） |'
- en: '| strerror | A string that briefly describes the error |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| strerror | 简要描述错误的字符串 |'
- en: OSError has subclasses to specify what the problem was, as discussed in [“OSError
    subclasses”](ch06.xhtml#oserror_subclasses).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: OSError有多个子类用于指定问题所在，详见[“OSError子类”](ch06.xhtml#oserror_subclasses)。
- en: os functions can also raise other standard exceptions, such as TypeError or
    ValueError, when called with invalid argument types or values, so that they didn’t
    even attempt the underlying operating system functionality.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用无效的参数类型或值调用os函数时，它们还可以引发其他标准异常，如TypeError或ValueError，以便它们甚至不尝试基础操作系统功能。
- en: The errno Module
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: errno 模块
- en: 'The errno module supplies dozens of symbolic names for error code numbers.
    Use errno to handle possible system errors selectively, based on error codes;
    this will enhance your program’s portability and readability. However, a selective
    **except** with the appropriate OSError subclass often works better than errno.
    For example, to handle “file not found” errors, while propagating all other kinds
    of errors, you could use:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: errno 模块为操作系统错误代码数值提供了几十个符号名称。使用errno根据错误代码有选择地处理可能的系统错误，这将增强程序的可移植性和可读性。然而，使用适当的OSError子类进行选择性的异常处理通常比errno更好。例如，为了处理“文件未找到”错误，同时传播所有其他类型的错误，可以使用：
- en: '[PRE13]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'errno supplies a dictionary named errorcode: the keys are error code numbers,
    and the corresponding values are the error names, strings such as ''ENOENT''.
    Displaying errno.errorcode[err.errno] as part of the explanation behind some OSError
    instance’s err can often make the diagnosis clearer and more understandable to
    readers who specialize in the specific platform.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: errno 提供了一个名为errorcode的字典：键是错误代码数值，对应的值是错误名称字符串，如'ENOENT'。在一些OSError实例的错误背后解释中显示errno.errorcode[err.errno]通常可以使诊断对专门从事特定平台的读者更加清晰和易懂。
- en: The pathlib Module
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pathlib 模块
- en: The pathlib module provides an object-oriented approach to filesystem paths,
    pulling together a variety of methods for handling paths and files as objects,
    not as strings (unlike os.path). For most use cases, pathlib.Path will provide
    everything you’ll need. On rare occasions, you’ll want to instantiate a platform-specific
    path, or a “pure” path that doesn’t interact with the operating system; see the
    [online docs](https://oreil.ly/ZWExX) if you need such advanced functionality.
    The most commonly useful functions of pathlib.Path are listed in [Table 11-21](#commonly_used_functions_of_pathlibdotpa),
    with examples for a pathlib.Path object *p*. On Windows, pathlib.Path objects
    are returned as WindowsPath; on Unix, as PosixPath, as shown in the examples in
    [Table 11-21](#commonly_used_functions_of_pathlibdotpa). (For clarity, we are
    simply importing pathlib rather than using the more common and idiomatic **from**
    pathlib **import** Path.)
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: pathlib 模块提供了一种面向对象的文件系统路径处理方法，整合了多种处理路径和文件的方法，将它们作为对象而不是字符串处理（与 os.path 不同）。对于大多数用例，pathlib.Path
    将提供所需的一切。在少数情况下，您可能需要实例化一个特定于平台的路径，或者一个不与操作系统交互的“纯”路径；如果需要此类高级功能，请参阅 [在线文档](https://oreil.ly/ZWExX)。pathlib.Path
    最常用的函数列在 [Table 11-21](#commonly_used_functions_of_pathlibdotpa) 中，包括一个 pathlib.Path
    对象 *p* 的示例。在 Windows 上，pathlib.Path 对象返回为 WindowsPath；在 Unix 上，返回为 PosixPath，如
    [Table 11-21](#commonly_used_functions_of_pathlibdotpa) 中的示例所示。（为了清晰起见，我们只是导入
    pathlib 而不使用更常见和惯用的 **from** pathlib **import** Path。）
- en: pathlib Methods Return Path Objects, Not Strings
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pathlib 方法返回路径对象，而非字符串
- en: Keep in mind that pathlib methods typically return a path object, not a string,
    so results of similar methods in os and os.path do *not* test as being identical.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，pathlib 方法通常返回路径对象，而不是字符串，因此与 os 和 os.path 中类似的方法的结果 *不* 相同。
- en: Table 11-21\. Commonly used methods of pathlib.Path
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: Table 11-21\. pathlib.Path 的常用方法
- en: '| chmod, lchmod | *p*.chmod(*mode*, follow_symlinks=**True**), *p*.lchmod(*mode*)'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '| chmod, lchmod | *p*.chmod(*mode*, follow_symlinks=**True**), *p*.lchmod(*mode*)'
- en: chmod changes the file mode and permissions, like os.chmod (see [Table 11-16](#os_module_functions)).
    On Unix platforms, 3.10+ set follow_symlinks=**False** to change permissions on
    the symbolic link rather than its target, or use lchmod. See the [online docs](https://oreil.ly/23S7z)
    for more information on chmod settings.lchmod is like chmod but, when *p* points
    to a symbolic link, changes the symbolic link rather than its target. Equivalent
    to pathlib.Path.chmod(follow_symlinks=**False**). |
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: chmod 修改文件模式和权限，如 os.chmod（参见 [Table 11-16](#os_module_functions)）。在 Unix 平台上，3.10+
    将 follow_symlinks 设置为**False**，以修改符号链接的权限而不是其目标，或使用 lchmod。有关 chmod 设置的更多信息，请参见
    [在线文档](https://oreil.ly/23S7z)。lchmod 类似于 chmod，但当 *p* 指向一个符号链接时，会更改符号链接而不是其目标。相当于
    pathlib.Path.chmod(follow_symlinks=**False**)。 |
- en: '| cwd | pathlib.Path.cwd() Returns the current working directory as a path
    object. |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| cwd | pathlib.Path.cwd() 返回当前工作目录作为路径对象。 |'
- en: '| exists | *p*.exists() Returns **True** when *p* names an existing file or
    directory (or a symbolic link pointing to an existing file or directory); otherwise,
    returns **False**. |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| exists | *p*.exists() 当 *p* 指定的是现有文件或目录（或指向现有文件或目录的符号链接）时返回 **True**；否则返回
    **False**。 |'
- en: '| expanduser | *p*.expanduser() Returns a new path object with a leading ~
    expanded to the path of the home directory of the current user, or ~user expanded
    to the path of the home directory of the given user. See also home later in this
    table. |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| expanduser | *p*.expanduser() 返回一个新的路径对象，其中 leading ~ 扩展为当前用户的主目录路径，或者 ~user
    扩展为给定用户的主目录路径。另请参见本表中稍后的 home。 |'
- en: '| glob, rglob | *p*.glob(*pattern*), *p*.rglob(*pattern*)'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '| glob, rglob | *p*.glob(*pattern*), *p*.rglob(*pattern*)'
- en: 'Yield all matching files in directory *p* in arbitrary order. *pattern* may
    include ** to allow recursive globbing in *p* or any subdirectory; rglob always
    performs recursive globbing in *p* and all subdirectories, as if *pattern* started
    with ''**/''. For example:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *p* 目录中以任意顺序生成所有匹配的文件。*pattern* 可以包含 ** 以允许在 *p* 或任何子目录中进行递归匹配；rglob 总是在 *p*
    和所有子目录中执行递归匹配，就像 *pattern* 以 '**/' 开始一样。例如：
- en: '[PRE14]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| hardlink_to | *p*.hardlink_to(*target*) 3.10+ Makes *p* a hard link to the
    same file as *target*. Replaces the deprecated link_to 3.8+, -3.10 Note: the order
    of arguments for link_to was like os.link, described in [Table 11-16](#os_module_functions);
    for hardlink_to, like for symlink_to later in this table, it’s the reverse. |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| hardlink_to | *p*.hardlink_to(*target*) 3.10+ 将 *p* 设置为与 *target* 相同文件的硬链接。取代了已弃用的
    link_to 3.8+，-3.10 注意：link_to 的参数顺序类似于 os.link，在 [Table 11-16](#os_module_functions)
    中描述；而 hardlink_to 的顺序与此表后面的 symlink_to 相似，正好相反。 |'
- en: '| home | pathlib.Path.home() Returns the user’s home directory as a path object.
    |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| home | pathlib.Path.home() 返回用户的主目录作为一个路径对象。 |'
- en: '| is_dir | *p*.is_dir() Returns **True** when *p* names an existing directory
    (or a symbolic link to a directory); otherwise, returns **False**. |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| is_dir | *p*.is_dir() 当*p*表示现有目录（或指向目录的符号链接）时返回**True**；否则返回**False**。 |'
- en: '| is_file | *p*.is_file() Returns **True** when *p* names an existing file
    (or a symbolic link to a file); otherwise, returns **False**. |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| is_file | *p*.is_file() 当*p*表示现有文件（或指向文件的符号链接）时返回**True**；否则返回**False**。
    |'
- en: '| is_mount | *p.*is_mount() Returns **True** when *p* is a *mount point* (a
    point in a filesystem where a different filesystem has been mounted); otherwise,
    returns **False**. See the [online docs](https://oreil.ly/-g8r0) for details.
    Not implemented on Windows. |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| is_mount | *p*.is_mount() 当*p*是一个挂载点（文件系统中已经挂载了另一个文件系统的地方）时返回**True**；否则返回**False**。详细信息请参阅[在线文档](https://oreil.ly/-g8r0)。在Windows上未实现。
    |'
- en: '| is_symlink | *p*.is_symlink() Returns **True** when *p* names an existing
    symbolic link; otherwise, returns **False**. |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| is_symlink | *p*.is_symlink() 当*p*表示现有符号链接时返回**True**；否则返回**False**。 |'
- en: '| iterdir | *p*.iterdir() Yields path objects for the contents of directory
    *p* (''.'' and ''..'' not included) in arbitrary order. Raises NotADirectoryError
    when *p* is not a directory. May produce unexpected results if you remove a file
    from *p*, or add a file to *p*, after you create the iterator and before you’re
    done using it. |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| iterdir | *p*.iterdir() 以任意顺序生成目录*p*的内容的路径对象（不包括''.''和''..''）。当*p*不是目录时引发NotADirectoryError。如果在创建迭代器后并且在使用完成之前，从*p*中删除文件或向*p*中添加文件，则可能产生意外结果。
    |'
- en: '| mkdir | *p*.mkdir(mode=0o777, parents=**False**, exist_ok=**False**) Creates
    a new directory at the path. Use mode to set file mode and access flags. Pass
    parents=**True** to create any missing parents as needed. Pass exist_ok=**True**
    to ignore FileExistsError exceptions. For example:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '| mkdir | *p*.mkdir(mode=0o777, parents=**False**, exist_ok=**False**) 在路径处创建一个新目录。使用mode设置文件模式和访问标志。设置parents=**True**以根据需要创建任何缺少的父目录。设置exist_ok=**True**以忽略FileExistsError异常。例如：
    |'
- en: '[PRE22]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: See the [online docs](https://oreil.ly/yrvuL) for thorough coverage. |
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 查看详细内容请参阅[在线文档](https://oreil.ly/yrvuL)。 |
- en: '| open | *p*.open(mode=''r'', buffering=-1, encoding=**None**, errors=**None**,
    newline=**None**) Opens the file pointed to by the path, like the built-in open(*p*)
    (with other args the same). |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '| open | *p*.open(mode=''r'', buffering=-1, encoding=**None**, errors=**None**,
    newline=**None**) 打开路径指向的文件，类似于内置的open(*p*)（其他参数相同）。 |'
- en: '| read_bytes | *p*.read_bytes() Returns the binary contents of *p* as a bytes
    object. |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '| read_bytes | *p*.read_bytes() 返回*p*的二进制内容作为一个bytes对象。 |'
- en: '| read_text | *p*.read_text(encoding=**None**, errors=**None**) Returns the
    decoded contents of *p* as a string. |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '| read_text | *p*.read_text(encoding=**None**, errors=**None**) 返回以字符串形式解码后的*p*的内容。
    |'
- en: '| readlink | *p*.readlink() 3.9+ Returns the path to which a symbolic link
    points. |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '| readlink | *p*.readlink() 3.9+ 返回符号链接指向的路径。 |'
- en: '| rename | *p*.rename(*target*) Renames *p* to *target* and 3.8+ returns a
    new Path instance pointing to *target*. *target* may be a string, or an absolute
    or relative path; however, relative paths are interpreted relative to the *current*
    working directory, *not* the directory of *p*. On Unix, when *target* is an existing
    file or empty directory, rename replaces it silently when the user has permission;
    on Windows, rename raises FileExistsError. |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '| rename | *p*.rename(*target*) 将*p*重命名为*target*，并且3.8+返回一个指向*target*的新Path实例。*target*可以是字符串，绝对路径或相对路径；但是，相对路径将相对于*当前*工作目录而不是*p*的目录进行解释。在Unix上，当*target*为现有文件或空目录时，rename在用户有权限时静默替换它；在Windows上，rename会引发FileExistsError。
    |'
- en: '| replace | *p*.replace(*target*) Like *p*.rename(*target*), but, on any platform,
    when *target* is an existing file (or, except on Windows, an empty directory),
    replace replaces it silently when the user has permission. For example:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '| replace | *p*.replace(*target*) 类似*p*.rename(*target*)，但在任何平台上，当*target*为现有文件（或在Windows以外的平台上为空目录）时，replace会在用户有权限时静默替换它。例如：
    |'
- en: '[PRE24]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '|'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| resolve | *p*.resolve(strict=**False**) Returns a new absolute path object
    with symbolic links resolved; eliminates any ''..'' components. Set strict=**True**
    to raise exceptions: FileNotFoundError when the path does not exist, or RuntimeError
    when it encounters an infinite loop. For example, on the temporary directory created
    in the mkdir example earlier in this table:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '| resolve | *p*.resolve(strict=**False**) 返回一个新的绝对路径对象，解析了符号链接并消除了任何''..''组件。设置strict=**True**可引发异常：当路径不存在时引发FileNotFoundError，或在遇到无限循环时引发RuntimeError。例如，在此表格前面创建的临时目录中：
    |'
- en: '[PRE36]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '|'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| rmdir | *p*.rmdir() Removes directory *p*. Raises OSError if *p* is not empty.
    |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| rmdir | *p*.rmdir() 移除目录*p*。如果*p*不为空，则引发OSError。 |'
- en: '| samefile | *p*.samefile(*target*) Returns **True** when *p* and *target*
    indicate the same file; otherwise, returns **False**. *target* may be a string
    or a path object. |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| samefile | *p*.samefile(*target*) 当*p*和*target*指示相同的文件时返回**True**；否则返回**False**。*target*可以是字符串或路径对象。
    |'
- en: '| stat | p.stat(*, follow_symlinks=**True**) Returns information about the
    path object, including permissions and size; see os.stat in [Table 11-16](#os_module_functions)
    for return values. 3.10+ To stat a symbolic link itself, rather than its target,
    pass follow_symlinks=**False**. |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| stat | p.stat(*, follow_symlinks=**True**) 返回与路径对象有关的信息，包括权限和大小；参见[Table 11-16](#os_module_functions)中的os.stat以获取返回值。3.10+
    若要对符号链接本身进行stat操作，而不是其目标，请传递follow_symlinks=**False**。 |'
- en: '| symlink_to | *p*.symlink_to(*target*, target_is_directory=**False**) Makes
    *p* a symbolic link to *target*. On Windows, you must set target_is_directory=**True**
    if *target* is a directory. (POSIX ignores this argument.) (On Windows 10+, like
    os.symlink, requires Developer Mode permissions; see the [online docs](https://oreil.ly/_aI9U)
    for details.) Note: the order of arguments is the reverse of the order for os.link
    and os.symlink, described in [Table 11-16](#os_module_functions). |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| symlink_to | *p*.symlink_to(*target*, target_is_directory=**False**) 将*p*创建为指向*target*的符号链接。在Windows上，如果*target*是目录，则必须设置target_is_directory=**True**。（POSIX忽略此参数。）（在Windows
    10+上，与os.symlink类似，需要开发者模式权限；有关详细信息，请参见[在线文档](https://oreil.ly/_aI9U)。）注意：参数顺序与os.link和os.symlink的顺序相反，这在[Table 11-16](#os_module_functions)中有描述。
    |'
- en: '| touch | *p*.touch(mode=0o666, exist_ok=**True**) Like touch on Unix, creates
    an empty file at the given path. When the file already exists, updates the modification
    time to the current time if exist_ok=**True**; if exist_ok=**False**, raises FileExistsError.
    For example:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '| touch | *p*.touch(mode=0o666, exist_ok=**True**) 类似于Unix上的touch，会在给定路径处创建一个空文件。当文件已存在时，如果exist_ok=**True**，则更新修改时间为当前时间；如果exist_ok=**False**，则引发FileExistsError。例如：
    |'
- en: '[PRE38]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '|'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| unlink | *p*.unlink(missing_ok=**False**) Removes file or symbolic link *p*.
    (Use rmdir for directories, as described earlier in this table.) 3.8+ Pass missing_ok=**True**
    to ignore [FileExistsError](https://oreil.ly/wuPTp). |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '| unlink | *p*.unlink(missing_ok=**False**) 移除文件或符号链接*p*。（对于目录，请参见本表前面描述的rmdir。）3.8+
    传递missing_ok=**True**以忽略[FileExistsError](https://oreil.ly/wuPTp)。 |'
- en: '| write_bytes | *p*.write_bytes(*data*) Opens (or, if need be, creates) the
    file pointed to in bytes mode, writes *data* to it, then closes the file. Overwrites
    the file if it already exists. |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '| write_bytes | *p*.write_bytes(*data*) 以字节模式打开（或创建，如果需要的话）指向的文件，将*data*写入其中，然后关闭文件。如果文件已存在，则覆盖该文件。
    |'
- en: '| write_text | *p*.write_text(data, encoding=**None**, errors=**None**, newline=**None**)
    Opens (or, if need be, creates) the file pointed to in text mode, writes *data*
    to it, then closes the file. Overwrites the file if it already exists. 3.10+ When
    newline is **None** (the default), translates any ''\n'' to the system default
    line separator; when ''\r'' or ''\r\n'', translates ''\n'' to the given string;
    when '''' or ''\n'', no translation takes place. |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
  zh: '| write_text | *p*.write_text(data, encoding=**None**, errors=**None**, newline=**None**)
    以文本模式打开（或创建，如果需要的话）指向的文件，将*data*写入其中，然后关闭文件。如果文件已存在，则覆盖该文件。3.10+ 当newline为**None**（默认值）时，将任何''\n''转换为系统默认换行符；当为''\r''或''\r\n''时，将''\n''转换为给定的字符串；当为''''或''\n''时，不进行任何转换。
    |'
- en: pathlib.Path objects also support the attributes listed in [Table 11-22](#attributes_of_an_instance_p_of_pathlibd)
    to access the various component parts of the path string. Note that some attributes
    are strings, while others are Path objects. (For brevity, OS-specific types such
    as PosixPath or WindowsPath are shown simply using the abstract Path class.)
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: pathlib.Path对象还支持在[Table 11-22](#attributes_of_an_instance_p_of_pathlibd)中列出的属性，以访问路径字符串的各个组成部分。请注意，一些属性是字符串，而其他属性是Path对象。（为简洁起见，OS特定类型（如PosixPath或WindowsPath）仅使用抽象Path类显示。）
- en: Table 11-22\. Attributes of an instance p of pathlib.Path
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: Table 11-22\. pathlib.Path实例p的属性
- en: '| Attribute | Description | Value for Unix path Path(''/usr/bin/ python'')
    | Value for Windows path Path(r’c:\Python3\ python.exe'') |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
  zh: '| Attribute | 描述 | Unix路径Path(''/usr/bin/ python'')的值 | Windows路径Path(r’c:\Python3\
    python.exe'')的值 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| anchor | Combination of drive and root | ''/'' | ''c:\\'' |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '| anchor | 驱动器和根的组合 | ''/'' | ''c:\\'' |'
- en: '| drive | Drive letter of *p* | '''' | ''c:'' |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '| drive | *p*的驱动器字母 | '''' | ''c:'' |'
- en: '| name | End component of *p* | ''python'' | ''python.exe'' |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '| name | *p*的末尾组件 | ''python'' | ''python.exe'' |'
- en: '| parent | Parent directory of *p* | Path(''/usr/bin'') | Path(''c:\\Python3'')
    |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '| parent | *p*的父目录 | Path(''/usr/bin'') | Path(''c:\\Python3'') |'
- en: '| parents | Ancestor directories of *p* | (Path(''/usr/ bin''), Path(''/usr''),
    Path(''/'')) | (Path(''c:\\Python3''), Path(''c:\\'')) |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '| parents | *p* 的祖先目录 | (Path(''/usr/ bin''), Path(''/usr''), Path(''/''))
    | (Path(''c:\\Python3''), Path(''c:\\'')) |'
- en: '| parts | Tuple of all components of *p* | (''/'', ''usr'', ''bin'', ''python'')
    | (''c:\\'', ''Python3'', ''python.exe'') |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '| parts | *p* 的所有组成部分的元组 | (''/'', ''usr'', ''bin'', ''python'') | (''c:\\'',
    ''Python3'', ''python.exe'') |'
- en: '| root | Root directory of *p* | ''/'' | ''\\'' |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
  zh: '| root | *p* 的根目录 | ''/'' | ''\\'' |'
- en: '| stem | Name of *p*, minus suffix | ''python'' | ''python'' |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
  zh: '| stem | *p* 的名称，不包括后缀 | ''python'' | ''python'' |'
- en: '| suffix | Ending suffix of *p* | '''' | ''.exe'' |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '| suffix | *p* 的结束后缀 | '''' | ''.exe'' |'
- en: '| suffixes | List of all suffixes of *p*, as delimited by ''.'' characters
    | [] | [''.exe''] |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
  zh: '| suffixes | 由 ''.'' 字符分隔的 *p* 的所有后缀的列表 | [] | [''.exe''] |'
- en: The [online documentation](https://oreil.ly/uBDrd) includes more examples for
    paths with additional components, such as filesystem and UNC shares.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '[在线文档](https://oreil.ly/uBDrd) 包含了更多带有额外组件（如文件系统和 UNC 共享）的路径示例。'
- en: pathlib.Path objects also support the '/' operator, an excellent alternative
    to os.path.join or Path.joinpath from the Path module. See the example code in
    the description of Path.touch in [Table 11-21](#commonly_used_functions_of_pathlibdotpa).
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: pathlib.Path 对象还支持`/`操作符，是 os.path.join 或 Path 模块中 Path.joinpath 的一个很好的替代方案。请参见
    [Table 11-21](#commonly_used_functions_of_pathlibdotpa) 中 Path.touch 描述中的示例代码。
- en: The stat Module
  id: totrans-505
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: stat 模块
- en: The function os.stat (covered in [Table 11-16](#os_module_functions)) returns
    instances of stat_result, whose item indices, attribute names, and meaning are
    also covered there. The stat module supplies attributes with names like those
    of stat_result’s attributes in uppercase, and corresponding values that are the
    corresponding item indices.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 os.stat（在 [Table 11-16](#os_module_functions) 中介绍）返回 stat_result 的实例，其项索引、属性名称和含义也在那里介绍了。
    stat 模块提供了类似于 stat_result 属性的大写名称的属性，并且相应的值是相应的项索引。
- en: 'The more interesting contents of the stat module are functions to examine the
    st_mode attribute of a stat_result instance and determine the kind of file. os.path
    also supplies functions for such tasks, which operate directly on the file’s *path*.
    The functions supplied by stat, shown in [Table 11-23](#stat_module_functions_for_examining_st),
    are faster than os’s when you perform several tests on the same file: they require
    only one os.stat system call at the start of a series of tests to obtain the file’s
    st_mode, while the functions in os.path implicitly ask the operating system for
    the same information at each test. Each function returns **True** when *mode*
    denotes a file of the given kind; otherwise, it returns **False**.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: stat 模块的更有趣的内容是用于检查 stat_result 实例的 st_mode 属性并确定文件类型的函数。os.path 也提供了用于这种任务的函数，它们直接在文件的
    *path* 上操作。与 os 的函数相比，在对同一文件执行多个测试时，stat 提供的函数（在 [Table 11-23](#stat_module_functions_for_examining_st)
    中显示）更快：它们在一系列测试开始时只需要一个 os.stat 系统调用来获取文件的 st_mode，而 os.path 中的函数在每次测试时隐式地向操作系统请求相同的信息。每个函数在
    *mode* 表示给定类型的文件时返回 **True**；否则，返回 **False**。
- en: Table 11-23\. stat module functions for examining st_mode
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: Table 11-23\. stat 模块函数用于检查 st_mode
- en: '| S_ISBLK | S_ISBLK(*mode*) Indicates whether *mode* denotes a special-device
    file of the block kind |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '| S_ISBLK | S_ISBLK(*mode*) 表示 *mode* 是否表示一个块设备文件 |'
- en: '| S_ISCHR | S_ISCHR(*mode*) Indicates whether *mode* denotes a special-device
    file of the character kind |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
  zh: '| S_ISCHR | S_ISCHR(*mode*) 表示 *mode* 是否表示一个字符设备文件 |'
- en: '| S_ISDIR | S_ISDIR(*mode*) Indicates whether *mode* denotes a directory |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
  zh: '| S_ISDIR | S_ISDIR(*mode*) 表示 *mode* 是否表示一个目录 |'
- en: '| S_ISFIFO | S_ISFIFO(*mode*) Indicates whether *mode* denotes a FIFO (also
    known as a “named pipe”) |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '| S_ISFIFO | S_ISFIFO(*mode*) 表示 *mode* 是否表示一个 FIFO（也称为“命名管道”） |'
- en: '| S_ISLNK | S_ISLNK(*mode*) Indicates whether *mode* denotes a symbolic link
    |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '| S_ISLNK | S_ISLNK(*mode*) 表示 *mode* 是否表示一个符号链接 |'
- en: '| S_ISREG | S_ISREG(*mode*) Indicates whether *mode* denotes a normal file
    (not a directory, special device-file, etc.) |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '| S_ISREG | S_ISREG(*mode*) 表示 *mode* 是否表示一个普通文件（不是目录、特殊设备文件等） |'
- en: '| S_ISSOCK | S_ISSOCK(*mode*) Indicates whether *mode* denotes a Unix-domain
    socket |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '| S_ISSOCK | S_ISSOCK(*mode*) 表示 *mode* 是否表示一个 Unix 域套接字 |'
- en: Several of these functions are meaningful only on Unix-like systems, since other
    platforms do not keep special files such as devices and sockets in the same namespace
    as regular files; Unix-like systems do.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数中的几个仅在类 Unix 系统上有意义，因为其他平台不会将设备和套接字等特殊文件保留在与常规文件相同的命名空间中；类 Unix 系统会这样做。
- en: The stat module also supplies two functions that extract relevant parts of a
    file’s *mode* (*x*.st_mode, for some result *x* of function os.stat), listed in
    [Table 11-24](#stat_module_functions_for_extracting_bi).
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '`stat` 模块还提供了两个函数，从文件的 *mode* (*x*.st_mode，对于 `os.stat` 函数的某些结果 *x*) 提取相关部分，列在[表 11-24](#stat_module_functions_for_extracting_bi)。'
- en: Table 11-24\. stat module functions for extracting bits from mode
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-24\. `stat` 模块从模式中提取位的函数
- en: '| S_IFMT | S_IFMT(*mode*) Returns those bits of *mode* that describe the kind
    of file (i.e., the bits that are examined by the functions S_ISDIR, S_ISREG, etc.)
    |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '| S_IFMT | S_IFMT(*mode*) 返回描述文件类型的*mode* 中的位（即函数 `S_ISDIR`、`S_ISREG` 等检查的位）
    |'
- en: '| S_IMODE | S_IMODE(*mode*) Returns those bits of *mode* that can be set by
    the function os.chmod (i.e., the permission bits and, on Unix-like platforms,
    a few other special bits such as the set-user-id flag) |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
  zh: '| S_IMODE | S_IMODE(*mode*) 返回*mode* 中可以由函数 `os.chmod` 设置的位（即权限位，以及在类 Unix
    平台上，一些特殊位，如设置用户标识标志） |'
- en: The stat module supplies a utility function, stat.filemode(*mode*), that converts
    a file’s mode to a human readable string of the form '-rwxrwxrwx'.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '`stat` 模块提供了一个实用函数 `stat.filemode(*mode*)`，将文件的模式转换为形如 ''-rwxrwxrwx'' 的人类可读字符串。'
- en: The filecmp Module
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`filecmp` 模块'
- en: The filecmp module supplies a few functions that are useful for comparing files
    and directories, listed in [Table 11-25](#useful_functions_of_the_filecmp_module).
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '`filecmp` 模块提供了一些有用的用于比较文件和目录的函数，列在[表 11-25](#useful_functions_of_the_filecmp_module)。'
- en: Table 11-25\. Useful functions of the filecmp module
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-25\. `filecmp` 模块的有用函数
- en: '| clear_cache | clear_cache() Clears the filecmp cache, which may be useful
    in quick file comparisons. |'
  id: totrans-525
  prefs: []
  type: TYPE_TB
  zh: '| clear_cache | clear_cache() 清除 `filecmp` 缓存，这在快速文件比较中可能很有用。 |'
- en: '| cmp | cmp(*f1*, *f2*, shallow=**True**) Compares the files (or pathlib.Paths)
    identified by path strings *f1* and *f2*. If the files are deemed to be equal,
    cmp returns **True**; otherwise, it returns **False**. If shallow is **True**,
    files are deemed to be equal if their stat tuples are equal. When shallow is **False**,
    cmp reads and compares the contents of files whose stat tuples are equal. |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
  zh: '| cmp | cmp(*f1*, *f2*, shallow=**True**) 比较由路径字符串 *f1* 和 *f2* 标识的文件（或 `pathlib.Paths`）。如果文件被认为相等，则
    `cmp` 返回 **True**；否则返回 **False**。如果 `shallow` 为 **True**，则如果它们的 stat 元组相等，文件被视为相等。当
    `shallow` 为 **False** 时，`cmp` 读取并比较 stat 元组相等的文件的内容。 |'
- en: '| cmpfiles | cmpfiles(*dir1*, *dir2*, *common*, shallow=**True**) Loops on
    the sequence *common*. Each item of *common* is a string that names a file present
    in both directories *dir1* and *dir2*. cmpfiles returns a tuple whose items are
    three lists of strings: (*equal*, *diff*, and *errs*). *equal* is the list of
    names of files that are equal in both directories, *diff* is the list of names
    of files that differ between directories, and *errs* is the list of names of files
    that it could not compare (because they do not exist in both directories, or there
    is no permission to read one or both of them). The argument shallow is the same
    as for cmp. |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
  zh: '| cmpfiles | cmpfiles(*dir1*, *dir2*, *common*, shallow=**True**) 循环处理序列 *common*。*common*
    中的每个项都是同时存在于目录 *dir1* 和 *dir2* 中的文件名。`cmpfiles` 返回一个元组，其项为三个字符串列表：（*equal*，*diff*
    和 *errs*）。*equal* 是两个目录中相等文件的名称列表，*diff* 是不同目录之间不同文件的名称列表，*errs* 是无法比较的文件名称列表（因为它们不同时存在于两个目录中，或者没有权限读取它们的其中一个或两个）。参数
    `shallow` 与 `cmp` 相同。'
- en: 'The filecmp module also supplies the class dircmp. The constructor for this
    class has the signature:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '`filecmp` 模块还提供了 `dircmp` 类。该类的构造函数签名如下：'
- en: '| dircmp | **class** dircmp(*dir1*, *dir2*, ignore=**None**, hide=**None**)
    Creates a new directory-comparison instance object comparing directories *dir1*
    and *dir2*, ignoring names listed in ignore and hiding names listed in hide (defaulting
    to ''.'' and ''..'' when hide=**None**). The default value for ignore is supplied
    by the DEFAULT_IGNORE attribute of the filecmp module; at the time of this writing
    it is [''RCS'', ''CVS'', ''tags'', ''.git'', ''.hg'', ''.bzr'', ''_darcs'', ''__pycache__''].
    Files in the directories are compared like with filecmp.cmp with shallow=**True**.
    |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
  zh: '| dircmp | **class** dircmp(*dir1*, *dir2*, ignore=**None**, hide=**None**)
    创建一个新的目录比较实例对象，比较目录 *dir1* 和 *dir2*，忽略 `ignore` 中列出的名称，隐藏 `hide` 中列出的名称（默认为 ''.''
    和 ''..'' 当 `hide` 为 **None** 时）。`ignore` 的默认值由 `filecmp` 模块的 `DEFAULT_IGNORE`
    属性提供；在撰写本文时，默认值为 `[''RCS'', ''CVS'', ''tags'', ''.git'', ''.hg'', ''.bzr'', ''_darcs'',
    ''__pycache__'']`。目录中的文件与 `filecmp.cmp` 使用 `shallow=**True**` 进行比较。 |'
- en: A dircmp instance *d* supplies three methods, detailed in [Table 11-26](#methods_supplied_by_a_dircmp_instance_d).
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '`dircmp` 实例 *d* 提供三种方法，详见[表 11-26](#methods_supplied_by_a_dircmp_instance_d)。'
- en: Table 11-26\. Methods supplied by a dircmp instance d
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: Table 11-26\. dircmp 实例 d 提供的方法
- en: '| report | report_full_closure() Outputs to sys.stdout a comparison between
    *dir1* and *dir2* and all their common subdirectories, recursively |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '| report | report_full_closure() 输出 *dir1* 和 *dir2* 以及它们所有共同的子目录之间的比较结果到 sys.stdout，递归进行
    |'
- en: '| report_fu⁠l⁠l⁠_​c⁠l⁠o⁠sure | report_full_closure() Outputs to sys.stdout
    a comparison between *dir1* and *dir2* and all their common subdirectories, recursively
    |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
  zh: '| report_fu⁠l⁠l⁠_​c⁠l⁠o⁠sure | report_full_closure() 输出 *dir1* 和 *dir2* 以及它们所有共同的子目录之间的比较结果到
    sys.stdout，递归进行 |'
- en: '| report_parti⁠a⁠l⁠_​c⁠l⁠o⁠sure | report_partial_closure() Outputs to sys.stdout
    a comparison between *dir1* and *dir2* and their common immediate subdirectories
    |'
  id: totrans-534
  prefs: []
  type: TYPE_TB
  zh: '| report_parti⁠a⁠l⁠_​c⁠l⁠o⁠sure | report_partial_closure() 输出 *dir1* 和 *dir2*
    及它们共同的直接子目录之间的比较结果到 sys.stdout |'
- en: In addition, *d* supplies several attributes, covered in [Table 11-27](#attributes_supplied_by_a_dircmp_instanc).
    These attributes are computed “just in time” (i.e., only if and when needed, thanks
    to a __getattr__ special method) so that using a dircmp instance incurs no unnecessary
    overhead.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，*d* 提供了几个属性，详见 [Table 11-27](#attributes_supplied_by_a_dircmp_instanc)。这些属性是“按需计算”的（即，只在需要时才计算，多亏了
    __getattr__ 特殊方法），因此使用 dircmp 实例不会产生不必要的开销。
- en: Table 11-27\. Attributes supplied by a dircmp instance d
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: Table 11-27\. dircmp 实例 d 提供的属性
- en: '| common | Files and subdirectories that are in both *dir1* and *dir2* |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
  zh: '| common | *dir1* 和 *dir2* 中的文件和子目录 |'
- en: '| common_dirs | Subdirectories that are in both *dir1* and *dir2* |'
  id: totrans-538
  prefs: []
  type: TYPE_TB
  zh: '| common_dirs | *dir1* 和 *dir2* 中的子目录 |'
- en: '| common_files | Files that are in both *dir1* and *dir2* |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '| common_files | *dir1* 和 *dir2* 中的文件 |'
- en: '| common_funny | Names that are in both *dir1* and *dir2* for which os.stat
    reports an error or returns different kinds for the versions in the two directories
    |'
  id: totrans-540
  prefs: []
  type: TYPE_TB
  zh: '| common_funny | *dir1* 和 *dir2* 中的名称，其中 os.stat 报告错误或者两个目录中版本的类型不同 |'
- en: '| diff_files | Files that are in both *dir1* and *dir2* but with different
    contents |'
  id: totrans-541
  prefs: []
  type: TYPE_TB
  zh: '| diff_files | *dir1* 和 *dir2* 中内容不同的文件 |'
- en: '| funny_files | Files that are in both *dir1* and *dir2* but could not be compared
    |'
  id: totrans-542
  prefs: []
  type: TYPE_TB
  zh: '| funny_files | *dir1* 和 *dir2* 中的文件，但无法进行比较 |'
- en: '| left_list | Files and subdirectories that are in *dir1* |'
  id: totrans-543
  prefs: []
  type: TYPE_TB
  zh: '| left_list | *dir1* 中的文件和子目录 |'
- en: '| left_only | Files and subdirectories that are in *dir1* and not in *dir2*
    |'
  id: totrans-544
  prefs: []
  type: TYPE_TB
  zh: '| left_only | *dir1* 中的文件和子目录，但不在 *dir2* 中 |'
- en: '| right_list | Files and subdirectories that are in *dir2* |'
  id: totrans-545
  prefs: []
  type: TYPE_TB
  zh: '| right_list | *dir2* 中的文件和子目录 |'
- en: '| right_only | Files and subdirectories that are in *dir2* and not in *dir1*
    |'
  id: totrans-546
  prefs: []
  type: TYPE_TB
  zh: '| right_only | *dir2* 中的文件和子目录，但不在 *dir1* 中 |'
- en: '| same_files | Files that are in both *dir1* and *dir2* with the same contents
    |'
  id: totrans-547
  prefs: []
  type: TYPE_TB
  zh: '| same_files | *dir1* 和 *dir2* 中内容相同的文件 |'
- en: '| subdirs | A dictionary whose keys are the strings in common_dirs; the corresponding
    values are instances of dircmp (or 3.10+ of the same dircmp subclass as *d*) for
    each subdirectory |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
  zh: '| subdirs | 一个字典，其键是 common_dirs 中的字符串；相应的值是 dircmp 的实例（或者 3.10+ 中与 *d* 同一种类的
    dircmp 子类的实例），用于每个子目录 |'
- en: The fnmatch Module
  id: totrans-549
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fnmatch 模块
- en: The fnmatch module (an abbreviation for *filename match*) matches filename strings
    or paths with patterns that resemble the ones used by Unix shells, as listed in
    [Table 11-28](#fnmatch_pattern_matching_conventions).
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: fnmatch 模块（*filename match* 的缩写）用于匹配类 Unix shell 使用的模式的文件名字符串或路径，如 [Table 11-28](#fnmatch_pattern_matching_conventions)
    所示。
- en: Table 11-28\. fnmatch pattern matching conventions
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: Table 11-28\. fnmatch 模式匹配惯例
- en: '| Pattern | Matches |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 匹配项 |'
- en: '| --- | --- |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| * | Any sequence of characters |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
  zh: '| * | 任意字符序列 |'
- en: '| ? | Any single character |'
  id: totrans-555
  prefs: []
  type: TYPE_TB
  zh: '| ? | 任意单个字符 |'
- en: '| [*chars*] | Any one of the characters in *chars* |'
  id: totrans-556
  prefs: []
  type: TYPE_TB
  zh: '| [*chars*] | *chars* 中的任意一个字符 |'
- en: '| [!*chars*] | Any one character not among those in *chars* |'
  id: totrans-557
  prefs: []
  type: TYPE_TB
  zh: '| [!*chars*] | 不属于 *chars* 中任意一个字符 |'
- en: 'fnmatch does *not* follow other conventions of Unix shell pattern matching,
    such as treating a slash (/) or a leading dot (.) specially. It also does not
    allow escaping special characters: rather, to match a special character, enclose
    it in brackets. For example, to match a filename that’s a single close bracket,
    use ''[]]''.'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: fnmatch 不遵循类 Unix shell 模式匹配的其他惯例，比如特殊对待斜杠 (/) 或前导点 (.)。它也不允许转义特殊字符：而是要匹配特殊字符，将其括在方括号中。例如，要匹配一个文件名为单个右括号，使用
    '[]]'。
- en: The fnmatch module supplies the functions listed in [Table 11-29](#functions_of_the_fnmatch_module).
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: fnmatch 模块提供了 [Table 11-29](#fnmatch_module_functions) 中列出的函数。
- en: Table 11-29\. Functions of the fnmatch module
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: Table 11-29\. fnmatch 模块的函数
- en: '| filter | filter(*names*, *pattern*) Returns the list of items of *names*
    (a sequence of strings) that match *pattern*. |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '| filter | filter(*names*, *pattern*) 返回 *names*（一个字符串序列）中与 *pattern* 匹配的项目列表。'
- en: '| fnmatch | fnmatch(*filename*, *pattern*) Returns **True** when string *filename*
    matches *pattern*; otherwise, returns **False**. The match is case sensitive when
    the platform is (for example, typical Unix-like systems), and otherwise (for example,
    on Windows) case insensitive; beware of that, if you’re dealing with a filesystem
    whose case-sensitivity doesn’t match your platform (for example, macOS is Unix-like;
    however, its typical filesystems are case insensitive). |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '| fnmatch | fnmatch(*filename*, *pattern*) 当字符串 *filename* 与 *pattern* 匹配时返回
    **True**；否则返回 **False**。当平台为大小写敏感时（例如典型的类 Unix 系统），匹配区分大小写；否则（例如在 Windows 上），不区分大小写；请注意，如果处理的文件系统的大小写敏感性与您的平台不匹配（例如
    macOS 是类 Unix 的，但其典型文件系统不区分大小写）。'
- en: '| fnmatchcase | fnmatchcase(*filename*, *pattern*) Returns **True** when string
    *filename* matches *pattern*; otherwise, returns **False**. The match is always
    case-sensitive on any platform. |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '| fnmatchcase | fnmatchcase(*filename*, *pattern*) 当字符串 *filename* 与 *pattern*
    匹配时返回 **True**；否则返回 **False**。此匹配在任何平台上均区分大小写。'
- en: '| translate | translate(*pattern*) Returns the regular expression pattern (as
    covered in [“Pattern String Syntax”](ch10.xhtml#pattern_string_syntax)) equivalent
    to the fnmatch pattern *pattern*. |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '| translate | translate(*pattern*) 返回等同于 fnmatch 模式 *pattern* 的正则表达式模式（详见[“模式字符串语法”](ch10.xhtml#pattern_string_syntax)）。'
- en: The glob Module
  id: totrans-565
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: glob 模块
- en: The glob module lists (in arbitrary order) the pathnames of files that match
    a *path pattern*, using the same rules as fnmatch; in addition, it treats a leading
    dot (.), separator (/), and ** specially, like Unix shells do. [Table 11-30](#functions_of_the_glob_module)
    lists some useful functions provided by the glob module.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: glob 模块以任意顺序列出与 *路径模式* 匹配的文件路径名，使用与 fnmatch 相同的规则；此外，它特别处理前导点（.）、分隔符（/）和 **，就像
    Unix shell 一样。[Table 11-30](#functions_of_the_glob_module) 列出了 glob 模块提供的一些有用函数。
- en: Table 11-30\. Functions of the glob module
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: Table 11-30\. glob 模块的函数
- en: '| escape | escape(*pathname*) Escapes all special characters (''?'', ''*'',
    and ''[''), so you can match an arbitrary literal string that may contain special
    characters. |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '| escape | escape(*pathname*) 转义所有特殊字符（''?''、''*'' 和 ''[''），因此可以匹配可能包含特殊字符的任意字面字符串。'
- en: '| glob | glob(*pathname*, *, root_dir=**None**, dir_fd=**None**, recursive=**False**)
    Returns the list of pathnames of files that match the pattern *pathname*. root_dir
    (if not **None**) is a string or path-like object specifying the root directory
    for searching (this works like changing the current directory before calling glob).
    If *pathname* is relative, the paths returned are relative to root_dir. To search
    paths relative to directory descriptors, pass dir_fd instead. Optionally pass
    named argument recursive=**True** to have path component ** recursively match
    zero or more levels of subdirectories. |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
  zh: '| glob | glob(*pathname*, *, root_dir=**None**, dir_fd=**None**, recursive=**False**)
    返回与模式 *pathname* 匹配的文件的路径名列表。root_dir（如果不是 **None**）是指定搜索的根目录的字符串或类似路径的对象（这类似于在调用
    glob 之前更改当前目录）。如果 *pathname* 是相对路径，则返回的路径是相对于 root_dir 的。要搜索相对于目录描述符的路径，请传递 dir_fd。可选地传递命名参数
    recursive=**True** 以使路径组件递归地匹配零个或多个子目录级别。'
- en: '| iglob | iglob(*pathname, *,* root_dir=**None**, dir_fd=**None**, recursive=**False**)
    Like glob, but returns an iterator yielding one relevant pathname at a time. |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
  zh: '| iglob | iglob(*pathname, *,* root_dir=**None**, dir_fd=**None**, recursive=**False**)
    类似于 glob，但返回一个迭代器，每次生成一个相关的路径名。'
- en: The shutil Module
  id: totrans-571
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: shutil 模块
- en: The shutil module (an abbreviation for *shell utilities*) supplies functions
    to copy and move files, and to remove an entire directory tree. On some Unix platforms,
    most of the functions support the optional keyword-only argument follow_symlinks,
    defaulting to **True**. When follow_symlinks=**True**, if a path indicates a symbolic
    link, the function follows it to reach an actual file or directory; when **False**,
    the function operates on the symbolic link itself. [Table 11-31](#functions_of_the_shutil_module)
    lists the functions provided by the shutil module.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: shutil 模块（*shell utilities* 的缩写）提供了复制、移动文件以及删除整个目录树的函数。在某些 Unix 平台上，大多数函数支持可选的仅关键字参数
    follow_symlinks，默认为 **True**。当 follow_symlinks=**True** 时，如果路径指示为符号链接，则函数会跟随它以达到实际文件或目录；当
    **False** 时，函数操作的是符号链接本身。[Table 11-31](#functions_of_the_shutil_module) 列出了 shutil
    模块提供的函数。
- en: Table 11-31\. Functions of the shutil module
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: Table 11-31\. shutil 模块的函数
- en: '| copy | copy(*src*, *dst*) Copies the contents of the file named by *src*,
    which must exist, and creates or overwrites the file *dst* (*src* and *dst* are
    strings or instances of pathlib.Path). If *dst* is a directory, the target is
    a file with the same base name as *src*, but located in *dst*. copy also copies
    permission bits, but not last access and modification times. Returns the path
    to the destination file it has copied to. |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
  zh: '| copy | copy(*src*, *dst*) 复制由*src*指定的文件的内容（*src*必须存在），并创建或覆盖由*dst*指定的文件（*src*和*dst*可以是字符串或pathlib.Path实例）。如果*dst*是一个目录，则目标是与*src*同名的文件，但位于*dst*中。copy还复制权限位，但不复制最后访问和修改时间。返回已复制到的目标文件的路径。
    |'
- en: '| copy2 | copy2(*src*, *dst*) Like copy, but also copies last access time and
    modification time. |'
  id: totrans-575
  prefs: []
  type: TYPE_TB
  zh: '| copy2 | copy2(*src*, *dst*) 类似于copy，但也复制最后访问时间和修改时间。 |'
- en: '| copyfile | copyfile(*src*, *dst*) Copies just the contents (not permission
    bits, nor last access and modification times) of the file named by *src*, creating
    or overwriting the file named by *dst*. |'
  id: totrans-576
  prefs: []
  type: TYPE_TB
  zh: '| copyfile | copyfile(*src*, *dst*) 仅复制由*src*指定的文件的内容（不包括权限位、最后访问和修改时间），创建或覆盖由*dst*指定的文件。
    |'
- en: '| copyf⁠i⁠l⁠e​o⁠b⁠j | copyfileobj(*fsrc*, *fdst*, bufsize=16384) Copies all
    bytes from file object *fsrc*, which must be open for reading, to file object
    *fdst*, which must be open for writing. Copies up to bufsize bytes at a time if
    *bufsize* is greater than 0. File objects are covered in [“The io Module”](#the_io_module).
    |'
  id: totrans-577
  prefs: []
  type: TYPE_TB
  zh: '| copyfileobj | copyfileobj(*fsrc*, *fdst*, bufsize=16384) 从已打开用于读取的文件对象*fsrc*向已打开用于写入的文件对象*fdst*复制所有字节。如果*bufsize*大于0，则每次最多复制*bufsize*字节。文件对象的具体内容请参见[“The
    io Module”](#the_io_module)。 |'
- en: '| copymode | copymode(*src*, *dst*) Copies permission bits of the file or directory
    named by *src* to the file or directory named by *dst*. Both *src* and *dst* must
    exist. Does not change *dst*’s contents, nor its status as being a file or a directory.
    |'
  id: totrans-578
  prefs: []
  type: TYPE_TB
  zh: '| copymode | copymode(*src*, *dst*) 复制由*src*指定的文件或目录的权限位到由*dst*指定的文件或目录。*src*和*dst*都必须存在。不更改*dst*的内容，也不更改其作为文件或目录的状态。
    |'
- en: '| copystat | copystat(*src*, *dst*) Copies permission bits and times of last
    access and modification of the file or directory named by *src* to the file or
    directory named by *dst*. Both *src* and *dst* must exist. Does not change *dst*’s
    contents, nor its status as being a file or a directory. |'
  id: totrans-579
  prefs: []
  type: TYPE_TB
  zh: '| copystat | copystat(*src*, *dst*) 复制由*src*指定的文件或目录的权限位、最后访问时间和修改时间到由*dst*指定的文件或目录。*src*和*dst*都必须存在。不更改*dst*的内容，也不更改其作为文件或目录的状态。
    |'
- en: '| copytree | copytree(*src*, *dst*, symlinks=**False**, ignore=**None**, copy_function=copy2,
    ignore_dangling_symlinks=**False**, dirs_exist_ok=**False**) Copies the directory
    tree rooted at the directory named by *src* into the destination directory named
    by *dst**.* *dst* must not already exist: copytree creates it (as well as creating
    any missing parent directories). copytree copies each file using the function
    copy2, by default; you can optionally pass a different file-copy function as named
    argument copy_function. If any exceptions occur during the copy process, copytree
    will record them internally and continue, raising Error at the end containing
    the list of all the recorded exceptions.'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '| copytree | copytree(*src*, *dst*, symlinks=**False**, ignore=**None**, copy_function=copy2,
    ignore_dangling_symlinks=**False**, dirs_exist_ok=**False**) 复制以*src*命名的目录为根的目录树到以*dst*命名的目标目录中。*dst*不得已存在：copytree将创建它（以及创建任何缺失的父目录）。copytree默认使用copy2函数复制每个文件；您可以选择作为命名参数copy_function传递不同的文件复制函数。如果在复制过程中发生任何异常，copytree将在最后记录它们并继续执行，最终引发包含所有记录异常列表的错误。'
- en: When symlinks is **True**, copytree creates symbolic links in the new tree when
    it finds symbolic links in the source tree. When symlinks is **False**, copytree
    follows each symbolic link it finds and copies the linked-to file with the link’s
    name, recording an exception if the linked file does not exist (if ignore_dangling_symlinks=**True**,
    this exception is ignored). On platforms that do not have the concept of a symbolic
    link, copytree ignores the argument symlinks. |
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 当symlinks为**True**时，copytree在新树中创建符号链接，如果在源树中发现符号链接。当symlinks为**False**时，copytree跟随它找到的每个符号链接，并复制链接的文件，使用链接的名称记录异常（如果ignore_dangling_symlinks为**True**，则忽略此异常）。在不支持符号链接概念的平台上，copytree会忽略symlinks参数。
    |
- en: '| copytree *(cont.)* | When ignore is not **None**, it must be a callable accepting
    two arguments (a directory path and a list of the immediate children of the directory)
    and returning a list of the children to be ignored in the copy process. If present,
    ignore is often the result of a call to shutil.ignore_patterns. For example, this
    code:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '| copytree *(续)* | 当ignore不为**None**时，它必须是一个接受两个参数（目录路径和目录的直接子项列表）并返回要在复制过程中忽略的子项列表的可调用对象。如果存在，ignore通常是对shutil.ignore_patterns的调用结果。例如，以下代码：'
- en: '[PRE44]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: copies the tree rooted at directory src into a new tree rooted at directory
    dst, ignoring any file or subdirectory whose name starts with a dot and any file
    or subdirectory whose name ends with *.bak*.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 将源自目录src的树复制到新目录dst中的树，忽略任何以点开头的文件或子目录以及任何以*.bak*结尾的文件或子目录。
- en: By default, copytree will record a FileExistsError exception if a target directory
    already exists. 3.8+ You can set dirs_exist_ok to **True** to allow copytree to
    write into existing directories found in the copying process (and potentially
    overwrite their contents). |
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果目标目录已经存在，copytree会记录FileExistsError异常。从3.8版本开始，可以将dirs_exist_ok设置为**True**，允许copytree在复制过程中写入已存在的目录（可能会覆盖其内容）。
- en: '| igno⁠r⁠e⁠_​p⁠a⁠t⁠terns | ignore_patterns(**patterns*) Returns a callable
    picking out files and subdirectories matching *patterns*, like those used in the
    fnmatch module (see [“The fnmatch Module”](#the_fnmatch_module)). The result is
    suitable for passing as the ignore argument to the copytree function. |'
  id: totrans-586
  prefs: []
  type: TYPE_TB
  zh: '| ignore_patterns | ignore_patterns(**patterns*) 返回一个可调用对象，选出与*patterns*匹配的文件和子目录，类似于fnmatch模块中使用的模式（见[“fnmatch模块”](#the_fnmatch_module)）。结果适合作为copytree函数的ignore参数传递。'
- en: '| move | move(*src*, *dst*, copy_function=copy2) Moves the file or directory
    named by *src* to that named by *dst*. move first tries using os.rename. Then,
    if that fails (because *src* and *dst* are on separate filesystems, or because
    *dst* already exists), move copies *src* to *dst* (using copy2 for a file or copytree
    for a directory by default; you can optionally pass a file-copy function other
    than copy2 as the named argument copy_function), then removes *src* (using os.unlink
    for a file, rmtree for a directory). |'
  id: totrans-587
  prefs: []
  type: TYPE_TB
  zh: '| move | move(*src*, *dst*, copy_function=copy2) 将名为*src*的文件或目录移动到名为*dst*的位置。move首先尝试使用os.rename。然后，如果失败（因为*src*和*dst*位于不同的文件系统上，或者*dst*已经存在），move将*src*复制到*dst*（默认情况下使用copy2复制文件或copytree复制目录；您可以选择传递名为copy_function的文件复制函数作为命名参数），然后删除*src*（对于文件使用os.unlink，对于目录使用rmtree）。'
- en: '| rmtree | rmtree(*path*, ignore_errors=**False**, onerror=**None**) Removes
    the directory tree rooted at *path*. When ignore_errors is **True**, rmtree ignores
    errors. When ignore_errors is **False** and onerror is **None**, errors raise
    exceptions. When onerror is not **None**, it must be callable with three parameters:
    *func*, *path*, and *ex*. *func* is the function raising the exception (os.remove
    or os.rmdir), *path* is the path passed to *func*, and *ex* is the tuple of information
    sys.exc_info returns. When onerror raises an exception, rmtree terminates, and
    the exception propagates. |'
  id: totrans-588
  prefs: []
  type: TYPE_TB
  zh: '| rmtree | rmtree(*path*, ignore_errors=**False**, onerror=**None**) 删除以*path*为根的目录树。当ignore_errors为**True**时，rmtree忽略错误。当ignore_errors为**False**且onerror为**None**时，错误会引发异常。当onerror不为**None**时，必须是一个可调用的函数，接受三个参数：*func*是引发异常的函数（os.remove或os.rmdir），*path*是传递给*func*的路径，*ex*是sys.exc_info返回的信息元组。当onerror引发异常时，rmtree终止，并且异常传播。'
- en: Beyond offering functions that are directly useful, the source file *shutil.py*
    in the Python stdlib is an excellent example of how to use many of the os functions.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供直接有用的函数外，Python标准库中的源文件*shutil.py*是如何使用许多os函数的优秀示例。
- en: Text Input and Output
  id: totrans-590
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本输入和输出
- en: Python presents non-GUI text input and output streams to Python programs as
    file objects, so you can use the methods of file objects (covered in [“Attributes
    and Methods of File Objects”](#attributes_and_methods_of_file_object)) to operate
    on these streams.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: Python将非GUI文本输入和输出流呈现为Python程序的文件对象，因此可以使用文件对象的方法（在[“文件对象的属性和方法”](#attributes_and_methods_of_file_object)中介绍）来操作这些流。
- en: Standard Output and Standard Error
  id: totrans-592
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准输出和标准错误
- en: 'The sys module (covered in [“The sys Module”](ch08.xhtml#the_sys_module)) has
    the attributes stdout and stderr, which are writable file objects. Unless you
    are using shell redirection or pipes, these streams connect to the “terminal”
    running your script. Nowadays, actual terminals are very rare: a so-called terminal
    is generally a screen window that supports text I/O.'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: sys模块（在[“sys模块”](ch08.xhtml#the_sys_module)中讨论）具有stdout和stderr属性，它们都是可写的文件对象。除非你正在使用shell重定向或管道，否则这些流连接到运行你的脚本的“终端”。如今，实际的终端非常罕见：所谓的终端通常是支持文本I/O的屏幕窗口。
- en: The distinction between sys.stdout and sys.stderr is a matter of convention.
    sys.stdout, known as *standard output*, is where your program emits results. sys.stderr,
    known as *standard error*, is where output such as error, status, or progress
    messages should go. Separating program output from status and error messages helps
    you use shell redirection effectively. Python respects this convention, using
    sys.stderr for its own errors and warnings.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: sys.stdout和sys.stderr之间的区别是惯例的问题。sys.stdout，即*标准输出*，是程序输出结果的地方。sys.stderr，即*标准错误*，是错误、状态或进度消息等输出的地方。将程序输出与状态和错误消息分开有助于有效地使用shell重定向。Python遵循这一惯例，将sys.stderr用于自身的错误和警告消息。
- en: The print Function
  id: totrans-595
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: print函数
- en: Programs that output results to standard output often need to write to sys.stdout.
    Python’s print function (covered in [Table 8-2](ch08.xhtml#pythonapostrophes_core_built_in_functio))
    can be a rich, convenient alternative to sys.stdout.write. print is fine for the
    informal output used during development to help you debug your code, but for production
    output, you may need more control of formatting than print affords. For example,
    you may need to control spacing, field widths, the number of decimal places for
    floating-point values, and so on. If so, you can prepare the output as an f-string
    (covered in [“String Formatting”](ch09.xhtml#string_formatting)), then output
    the string, usually with the write method of the appropriate file object. (You
    can pass formatted strings to print, but print may add spaces and newlines; the
    write method adds nothing at all, so it’s easier for you to control what exactly
    gets output.)
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 将结果输出到标准输出的程序通常需要写入sys.stdout。Python的print函数（在[表 8-2](ch08.xhtml#pythonapostrophes_core_built_in_functio)中讨论）可以作为一个丰富而方便的替代方案，用于在开发过程中进行非正式输出，以帮助调试代码，但是对于生产输出，你可能需要比print提供的格式控制更多。例如，你可能需要控制间距、字段宽度、浮点值的小数位数等。如果是这样，你可以将输出准备为f-string（在[“字符串格式化”](ch09.xhtml#string_formatting)中讨论），然后将字符串输出，通常使用适当文件对象的write方法。（你可以将格式化的字符串传递给print，但print可能会添加空格和换行；write方法根本不会添加任何内容，因此更容易控制输出的确切内容。）
- en: 'If you need to direct output to a file *f* that is open for writing, just calling
    *f*.write is often best, while print(..., file=*f*) is sometimes a handy alternative.
    To repeatedly direct the output from print calls to a certain file, you can temporarily
    change the value of sys.stdout. The following example is a general-purpose redirection
    function usable for such a temporary change; in the presence of multitasking,
    make sure to also add a lock in order to avoid any contention (see also the contextlib.redirect_stdout
    decorator described in [Table 6-1](ch06.xhtml#commonly_used_classes_and_functions_in)):'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将输出直接定向到一个打开写入模式的文件*f*，直接调用*f*.write通常是最好的方法，而print(..., file=*f*)有时是一个方便的替代方法。要重复地将print调用的输出定向到某个文件，你可以临时改变sys.stdout的值。下面的示例是一个通用的重定向函数，可用于这种临时更改；在多任务存在的情况下，请确保还添加一个锁以避免任何争用（参见也在[表 6-1](ch06.xhtml#commonly_used_classes_and_functions_in)中描述的contextlib.redirect_stdout装饰器）：
- en: '[PRE45]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Standard Input
  id: totrans-599
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准输入
- en: In addition to stdout and stderr, the sys module provides the stdin attribute,
    which is a readable file object. When you need a line of text from the user, you
    can call the built-in function input (covered in [Table 8-2](ch08.xhtml#pythonapostrophes_core_built_in_functio)),
    optionally with a string argument to use as a prompt.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 除了stdout和stderr之外，sys模块还提供了stdin属性，它是一个可读的文件对象。当你需要从用户那里获取一行文本时，可以调用内置函数input（在[表 8-2](ch08.xhtml#pythonapostrophes_core_built_in_functio)中讨论），可选地使用一个字符串参数作为提示。
- en: 'When the input you need is not a string (for example, when you need a number),
    use input to obtain a string from the user, then other built-ins, such as int,
    float, or ast.literal_eval, to turn the string into the number you need. To evaluate
    an expression or string from an untrusted source, we recommend using the function
    literal_eval from the standard library module ast (as covered in the [online docs](https://oreil.ly/6kb6T)).
    ast.literal_eval(*astring*) returns a valid Python value (such as an int, a float,
    or a list) for the given literal *astring* when it can (3.10+ stripping any leading
    spaces and tabs from string inputs), or else raises a SyntaxError or ValueError
    exception; it never has any side effects. To ensure complete safety, *astring*
    cannot contain any operator or any nonkeyword identifier; however, + and - may
    be accepted as positive or negative signs on numbers, rather than as operators.
    For example:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要的输入不是字符串时（例如，当你需要一个数字时），使用 `input` 从用户那里获取一个字符串，然后使用其他内置函数如 `int`、`float`
    或 `ast.literal_eval` 将字符串转换为你需要的数字。要评估来自不受信任来源的表达式或字符串，建议使用标准库模块 `ast` 中的 `literal_eval`
    函数（如在[在线文档](https://oreil.ly/6kb6T)中描述）。`ast.literal_eval(*astring*)` 在可能时返回一个有效的
    Python 值（例如 int、float 或 list），对于给定的字面值 *astring*，否则会引发 SyntaxError 或 ValueError
    异常；它永远不会产生任何副作用。为了确保完全安全，*astring* 不能包含任何运算符或非关键字标识符；然而，+ 和 - 可以被接受作为数字的正负号，而不是运算符。例如：
- en: '[PRE46]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: eval Can Be Dangerous
  id: totrans-603
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`eval` 可能存在危险'
- en: 'Don’t use eval on arbitrary, unsanitized user inputs: a nasty (or well-meaning
    but careless) user can breach security or otherwise cause damage this way. There
    is no effective defense—just avoid using eval (and exec) on input from sources
    you do not fully trust.'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 不要对任意未经处理的用户输入使用 `eval`：一个恶意（或者无意中疏忽的）用户可以通过这种方式突破安全性或者造成其他损害。没有有效的防御措施——避免在来自不完全信任的来源的输入上使用
    `eval`（和 `exec`）。
- en: The getpass Module
  id: totrans-605
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`getpass` 模块'
- en: Very occasionally, you may want the user to input a line of text in such a way
    that somebody looking at the screen cannot see what the user is typing. This may
    occur when you’re asking the user for a password, for example. The getpass module
    provides a function for this, as well as one to get the current user’s username
    (see [Table 11-32](#functions_of_the_getpass_module)).
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，你可能希望用户以一种屏幕上看不到用户输入内容的方式输入一行文本。例如，当你要求用户输入密码时。`getpass` 模块提供了这种功能，以及获取当前用户用户名的函数（参见[Table 11-32](#functions_of_the_getpass_module)）。
- en: Table 11-32\. Functions of the getpass module
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: Table 11-32\. `getpass` 模块的功能
- en: '| getpass | getpass(prompt=''Password: '') Like input (covered in [Table 8-2](ch08.xhtml#pythonapostrophes_core_built_in_functio)),
    except that the text the user inputs is not echoed to the screen as the user is
    typing, and the default prompt is different from input’s. |'
  id: totrans-608
  prefs: []
  type: TYPE_TB
  zh: '| `getpass` | `getpass(prompt=''Password: '')` 与 `input` 类似（在[Table 8-2](ch08.xhtml#pythonapostrophes_core_built_in_functio)中介绍），不同之处在于用户输入的文本在用户输入时不会显示在屏幕上，并且默认提示与
    `input` 不同。 |'
- en: '| getuser | getuser() Returns the current user’s username. getuser tries to
    get the username as the value of one of the environment variables LOGNAME, USER,
    LNAME, or USERNAME, in that order. If none of these variables are in os.environ,
    getuser asks the operating system. |'
  id: totrans-609
  prefs: []
  type: TYPE_TB
  zh: '| `getuser` | `getuser()` 返回当前用户的用户名。`getuser` 尝试将用户名作为环境变量 `LOGNAME`、`USER`、`LNAME`
    或 `USERNAME` 的一个值来获取，依次尝试。如果 `os.environ` 中没有这些变量的值，`getuser` 会向操作系统询问。 |'
- en: Richer-Text I/O
  id: totrans-610
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 富文本 I/O
- en: The text I/O modules covered so far supply basic text I/O functionality on all
    platform terminals. Most platforms also offer enhanced text I/O features, such
    as responding to single keypresses (not just entire lines), printing text in any
    terminal row and column position, and enhancing the text with background and foreground
    colors and font effects like bold, italic, and underline. For this kind of functionality
    you’ll need to consider a third-party library. We focus here on the readline module,
    then take a quick look at a few console I/O options, including mscvrt, with a
    brief mention of curses, rich, and colorama, which we do not cover further.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所涵盖的文本 I/O 模块在所有平台终端上提供基本的文本 I/O 功能。大多数平台还提供增强的文本 I/O 功能，例如响应单个按键（而不仅仅是整行）、在任何终端行和列位置打印文本，以及使用背景和前景颜色以及加粗、斜体和下划线等字体效果增强文本。对于这种功能，你需要考虑使用第三方库。我们在这里关注
    `readline` 模块，然后快速查看一些控制台 I/O 选项，包括 `mscvrt`，并简要提及 `curses`、`rich` 和 `colorama`，我们不会进一步介绍它们。
- en: The readline Module
  id: totrans-612
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`readline` 模块'
- en: The readline module wraps the [GNU Readline Library](https://oreil.ly/Z0A5t),
    which lets the user edit text lines during interactive input and recall previous
    lines for editing and re-entry. Readline comes preinstalled on many Unix-like
    platforms, and it’s available online. On Windows, you can install and use the
    third-party module [pyreadline](https://oreil.ly/9XExm).
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: readline 模块封装了 [GNU Readline Library](https://oreil.ly/Z0A5t)，允许用户在交互输入期间编辑文本行并回溯先前的行以进行编辑和重新输入。Readline
    预安装在许多类 Unix 平台上，并且可在线获取。在 Windows 上，您可以安装和使用第三方模块 [pyreadline](https://oreil.ly/9XExm)。
- en: 'When readline is available, Python uses it for all line-oriented input, such
    as input. The interactive Python interpreter always tries to load readline to
    enable line editing and recall for interactive sessions. Some readline functions
    control advanced functionality: particularly *history*, for recalling lines entered
    in previous sessions; and *completion*, for context-sensitive completion of the
    word being entered. (See the [Python readline docs](https://oreil.ly/6SMkN) for
    complete details on configuration commands.) You can access the module’s functionality
    using the functions in [Table 11-33](#functions_of_the_readline_module).'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 当可用时，Python 使用 readline 处理所有基于行的输入，例如 input。交互式 Python 解释器始终尝试加载 readline 以启用交互会话的行编辑和回溯。某些
    readline 函数控制高级功能，特别是 *history* 用于回溯在先前会话中输入的行，以及 *completion* 用于正在输入的单词的上下文敏感完成（详见
    [Python readline 文档](https://oreil.ly/6SMkN) 关于配置命令的完整详细信息）。您可以使用 [Table 11-33](#functions_of_the_readline_module)
    中的函数访问模块的功能。
- en: Table 11-33\. Functions of the readline module
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: Table 11-33\. readline 模块的函数
- en: '| add_history | add_history(*s*, */*) Adds string *s* as a line at the end
    of the history buffer. To temporarily disable add_history, call set_auto_history(**False**),
    which will disable add_history for this session only (it won’t persist across
    sessions); set_auto_history is **True** by default. |'
  id: totrans-616
  prefs: []
  type: TYPE_TB
  zh: '| add_history | add_history(*s*, */*) 将字符串 *s* 作为一行添加到历史缓冲区的末尾。要临时禁用 add_history，请调用
    set_auto_history(**False**)，这将仅在本次会话中禁用 add_history（不会跨会话持久保存）；set_auto_history
    默认为 **True**。'
- en: '| app⁠e⁠n⁠d⁠_​h⁠i⁠s⁠tory_file | append_history_file(*n*, *filename*=''~/.history'',
    /) Appends the last *n* items to existing file *filename*. |'
  id: totrans-617
  prefs: []
  type: TYPE_TB
  zh: '| app⁠e⁠n⁠d⁠_​h⁠i⁠s⁠t⁠o⁠r⁠y_​f⁠i⁠l⁠e | append_history_file(*n*, *filename*=''~/.history'',
    /) 将最后 *n* 项追加到现有文件 *filename*。'
- en: '| clear_history | clear_history() Clears the history buffer. |'
  id: totrans-618
  prefs: []
  type: TYPE_TB
  zh: '| clear_history | clear_history() 清除历史缓冲区。'
- en: '| get_completer | get_completer() Returns the current completer function (as
    last set by set_completer), or **None** if no completer function is set. |'
  id: totrans-619
  prefs: []
  type: TYPE_TB
  zh: '| get_completer | get_completer() 返回当前的补全函数（由 set_completer 最后设置），如果没有设置补全函数，则返回
    **None**。'
- en: '| g⁠e⁠t⁠_​h⁠i⁠s⁠tory_length | get_history_length() Returns the number of lines
    of history to be saved to the history file. When the result is less than 0, all
    lines in the history are to be saved. |'
  id: totrans-620
  prefs: []
  type: TYPE_TB
  zh: '| g⁠e⁠t⁠_​h⁠i⁠s⁠tory_length | get_history_length() 返回要保存到历史文件中的行数。当结果小于0时，保存所有历史行。'
- en: '| parse_and_bind | parse_and_bind(*readline_cmd*, */*) Gives readline a configuration
    command. To let the user hit Tab to request completion, call parse_and_bind(''tab:
    complete''). See the [readline documentation](https://oreil.ly/Wv2dm) for other
    useful values of the string *readline_cmd*.'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '| parse_and_bind | parse_and_bind(*readline_cmd*, */*) 给 readline 提供配置命令。要让用户按
    Tab 键请求完成，请调用 parse_and_bind(''tab: complete'')。查看 [readline 文档](https://oreil.ly/Wv2dm)
    获取字符串 *readline_cmd* 的其他有用值。'
- en: 'A good completion function is in the standard library module rlcompleter. In
    the interactive interpreter (or in the startup file executed at the start of interactive
    sessions, covered in [“Environment Variables”](ch02.xhtml#environment_variables)),
    enter:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好的补全函数位于标准库模块 rlcompleter 中。在交互式解释器中（或在交互会话开始时执行的启动文件中，见 [“Environment Variables”](ch02.xhtml#environment_variables)），输入：
- en: '[PRE47]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: For the rest of this interactive session, you can hit the Tab key during line
    editing and get completion for global names and object attributes. |
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 在本次交互会话的其余部分，您可以在行编辑过程中按 Tab 键并获得全局名称和对象属性的完成。
- en: '| re⁠a⁠d⁠_​h⁠i⁠s⁠tory_file | read_history_file(*filename*=''~/.history'', /)
    Loads history lines from the text file at path *filename*. |'
  id: totrans-625
  prefs: []
  type: TYPE_TB
  zh: '| re⁠a⁠d⁠_​h⁠i⁠s⁠t⁠o⁠r⁠y_​f⁠i⁠l⁠e | read_history_file(*filename*=''~/.history'',
    /) 从路径 *filename* 的文本文件中加载历史行。'
- en: '| read_init_file | read_init_file(*filename*=**None, /**) Makes readline load
    a text file: each line is a configuration command. When *filename* is **None**,
    loads the same file as the last time. |'
  id: totrans-626
  prefs: []
  type: TYPE_TB
  zh: '| re⁠a⁠d⁠_​i⁠n⁠i⁠t_​f⁠i⁠l⁠e | read_init_file(*filename*=**None, /**) 使 readline
    加载文本文件：每行是一个配置命令。当 *filename* 为 **None** 时，加载与上次相同的文件。'
- en: '| set_completer | set_completer(*func, /*) Sets the completion function. When
    *func* is **None** or omitted, readline disables completion. Otherwise, when the
    user types a partial word *start*, then presses the Tab key, readline calls *func*(*start*,
    *i*), with *i* initially 0. *func* returns the *i*th possible word starting with
    *start*, or **None** when there are no more. readline loops, calling *func* with
    *i* set to 0, 1, 2, etc., until *func* returns **None**. |'
  id: totrans-627
  prefs: []
  type: TYPE_TB
  zh: '| set_completer | set_completer(*func, /*) 设置完成函数。当 *func* 为 **None** 或省略时，readline
    禁用完成。否则，当用户键入部分单词 *start*，然后按 Tab 键时，readline 调用 *func*(*start*, *i*)，其中 *i* 最初为
    0。*func* 返回以 *start* 开头的第 *i* 个可能的单词，或在没有更多单词时返回 **None**。readline 循环调用 *func*，*i*
    设置为 0、1、2 等，直到 *func* 返回 **None**。 |'
- en: '| s⁠e⁠t⁠_​h⁠i⁠s⁠tory_length | set_history_length(*x, /*) Sets the number of
    lines of history that are to be saved to the history file. When *x* is less than
    0, all lines in the history are to be saved. |'
  id: totrans-628
  prefs: []
  type: TYPE_TB
  zh: '| s⁠e⁠t⁠_​h⁠i⁠s⁠t⁠o⁠r⁠y⁠_​l⁠e⁠n⁠g⁠t⁠h | set_history_length(*x, /*) 设置要保存到历史文件中的历史行数。当
    *x* 小于 0 时，将保存历史中的所有行。 |'
- en: '| wri⁠t⁠e⁠_​h⁠i⁠s⁠tory_file | write_history_file(*filename*=''~/.history'')
    Saves history lines to the text file whose name or path is *filename*, overwriting
    any existing file. |'
  id: totrans-629
  prefs: []
  type: TYPE_TB
  zh: '| wri⁠t⁠e⁠_​h⁠i⁠s⁠t⁠o⁠r⁠y⁠_​f⁠i⁠l⁠e | write_history_file(*filename*=''~/.history'')
    将历史记录行保存到名为 *filename* 或路径为 *filename* 的文本文件中，覆盖任何现有文件。 |'
- en: Console I/O
  id: totrans-630
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制台 I/O
- en: As mentioned previously, “terminals” today are usually text windows on a graphical
    screen. You may also, in theory, use a true terminal, or (perhaps a tad less theoretically,
    but these days not by much) the console (main screen) of a personal computer in
    text mode. All such “terminals” in use today offer advanced text I/O functionality,
    accessed in platform-dependent ways. The low-level curses package works on Unix-like
    platforms. For a cross-platform (Windows, Unix, macOS) solution, you may use the
    third-party package [rich](https://oreil.ly/zuTRT); in addition to its excellent
    [online docs](https://oreil.ly/BHr83), there are online [tutorials](https://oreil.ly/GYAnd)
    to help you get started. To output colored text on the terminal, see colorama,
    available on [PyPI](https://oreil.ly/JVE1a). msvcrt, introduced next, provides
    some low-level (Windows only) functions.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，“终端”今天通常是图形屏幕上的文本窗口。理论上，您也可以使用真正的终端，或者（也许略微现实些，但这些天不太可能）个人计算机的控制台（主屏幕）以文本模式运行。今天使用的所有这些“终端”都提供平台相关的高级文本
    I/O 功能。低级 curses 包适用于类 Unix 平台。对于跨平台（Windows、Unix、macOS）解决方案，您可以使用第三方包 [rich](https://oreil.ly/zuTRT)；除了其出色的
    [在线文档](https://oreil.ly/BHr83) 外，还有在线 [教程](https://oreil.ly/GYAnd) 可帮助您入门。要在终端上输出彩色文本，请参阅
    PyPI 上的 colorama。接下来介绍的 **msvcrt** 提供了一些低级（仅限 Windows）函数。
- en: curses
  id: totrans-632
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: curses
- en: The classic Unix approach to enhanced terminal I/O is named curses, for obscure
    historical reasons.^([4](ch11.xhtml#ch01fn104)) The Python package curses lets
    you exert detailed control if required. We don’t cover curses in this book; for
    more information, see A.M. Kuchling’s and Eric Raymond’s online tutorial [“Curses
    Programming with Python”](https://oreil.ly/Pbpbh).
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 增强的终端 I/O 的经典 Unix 方法因历史原因被称为 curses。Python 包 curses 允许您在需要时进行详细控制。本书不涵盖 curses；更多信息请参阅
    A.M. Kuchling 和 Eric Raymond 的在线教程 [“Curses Programming with Python”](https://oreil.ly/Pbpbh)。
- en: The msvcrt module
  id: totrans-634
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**msvcrt** 模块'
- en: The Windows-only msvcrt module (which you may need to install with pip) supplies
    a few low-level functions that let Python programs access proprietary extras supplied
    by the Microsoft Visual C++ runtime library *msvcrt.dll*. For example, the functions
    listed in [Table 11-34](#some_useful_functions_of_the_msvcrt_mod) let you read
    user input character by character rather than reading a full line at a time.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '**msvcrt** 模块只能在 Windows 上使用（你可能需要使用 pip 安装），它提供了一些低级函数，使 Python 程序可以访问由 Microsoft
    Visual C++ 运行时库 *msvcrt.dll* 提供的专有附加功能。例如，[Table 11-34](#some_useful_functions_of_the_msvcrt_mod)
    中列出的函数允许你逐字符而不是逐行读取用户输入。'
- en: Table 11-34\. Some useful functions of the msvcrt module
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: Table 11-34\. **msvcrt** 模块的一些有用函数
- en: '| getch, getche | getch(), getche() Reads and returns a single-character bytes
    from keyboard input, and if necessary blocks until one is available (i.e., a key
    is pressed). getche echoes the character to screen (if printable), while getch
    does not. When the user presses a special key (arrows, function keys, etc.), it’s
    seen as two characters: first a chr(0) or chr(224), then a second character that,
    together with the first one, defines the special key the user pressed. This means
    that the program must call getch or getche twice to read these key presses. To
    find out what getch returns for any key, run the following small script on a Windows
    machine:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '| getch, getche | getch(), getche() 从键盘输入读取并返回单个字符的字节，并在必要时阻塞，直到有一个可用（即按下一个键）。getche
    将字符回显到屏幕上（如果可打印），而 getch 则不会。当用户按下特殊键（箭头键、功能键等）时，它被视为两个字符：首先是 chr(0) 或 chr(224)，然后是第二个字符，这两个字符共同定义用户按下的特殊键。这意味着程序必须调用两次
    getch 或 getche 才能读取这些按键。要了解 getch 对任何键返回什么，请在 Windows 机器上运行以下小脚本：'
- en: '[PRE48]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '|'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| kbhit | kbhit() Returns **True** when a character is available for reading
    (getch, when called, returns immediately); otherwise, returns **False** (getch,
    when called, waits). |'
  id: totrans-640
  prefs: []
  type: TYPE_TB
  zh: '| kbhit | kbhit() 当有字符可读时返回**True**（调用 getch 时立即返回）；否则返回**False**（调用 getch
    时等待）。 |'
- en: '| ungetch | ungetch(*c*) “Ungets” character *c*; the next call to getch or
    getche returns *c*. It’s an error to call ungetch twice without intervening calls
    to getch or getche. |'
  id: totrans-641
  prefs: []
  type: TYPE_TB
  zh: '| ungetch | ungetch(*c*) “取消”字符*c*；接下来的 getch 或 getche 调用会返回*c*。调用两次 ungetch
    而没有调用中间的 getch 或 getche 是错误的。 |'
- en: Internationalization
  id: totrans-642
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国际化
- en: Many programs present some information to users as text. Such text should be
    understandable and acceptable to users in different locales. For example, in some
    countries and cultures, the date “March 7” can be concisely expressed as “3/7.”
    Elsewhere, “3/7” indicates “July 3,” and the string that means “March 7” is “7/3.”
    In Python, such cultural conventions are handled with the help of the standard
    library module locale.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序将某些信息以文本形式呈现给用户。这样的文本应该能够被不同地区的用户理解和接受。例如，在某些国家和文化中，“March 7”这个日期可以简洁地表示为“3/7”。而在其他地方，“3/7”表示“7月3日”，而表示“March
    7”的字符串则是“7/3”。在 Python 中，这样的文化习惯是通过标准库模块 locale 处理的。
- en: Similarly, a greeting might be expressed in one natural language by the string
    “Benvenuti,” while in another language the string to use is “Welcome.” In Python,
    such translations are handled with the help of the stdlib module gettext.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，一个问候语可能用字符串“Benvenuti”在一种自然语言中表达，而在另一种语言中，则需要使用“Welcome”这个字符串。在 Python 中，这些翻译是通过标准库模块
    gettext 处理的。
- en: Both kinds of issues are commonly addressed under the umbrella term *internationalization*
    (often abbreviated *i18n*, as there are 18 letters between *i* and *n* in the
    full spelling in English)—a misnomer, since the same issues apply not just between
    nations, but also to different languages or cultures within a single nation.^([5](ch11.xhtml#ch01fn105))
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种问题通常在称为*国际化*的总称下处理（通常缩写为*i18n*，因为英文全拼中*i*和*n*之间有18个字母）——这个名称不准确，因为这些问题不仅适用于国家之间，还适用于同一国家内不同的语言或文化。^([5](ch11.xhtml#ch01fn105))
- en: The locale Module
  id: totrans-646
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块 locale
- en: Python’s support for cultural conventions imitates that of C, slightly simplified.
    A program operates in an environment of cultural conventions known as a *locale*.
    The locale setting permeates the program and is typically set at program startup.
    The locale is not thread-specific, and the locale module is not thread-safe. In
    a multithreaded program, set the program’s locale in the main thread; i.e., set
    it before starting secondary threads.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: Python 对文化习惯的支持模仿了 C 语言，稍作简化。程序在称为*locale*的文化习惯环境中运行。Locale 设置渗透到程序中，并通常在程序启动时设置。Locale
    不是线程特定的，而且 locale 模块不是线程安全的。在多线程程序中，应在主线程中设置程序的 locale；即在启动次要线程之前设置。
- en: Limitations of locale
  id: totrans-648
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: locale 的局限性
- en: locale is only useful for process-wide settings. If your application needs to
    handle multiple locales at the same time in a single process—whether in threads
    or asynchronously—locale is not the answer due to its process-wide nature. Consider,
    instead, alternatives such as [PyICU](https://pypi.org/project/PyICU), mentioned
    in [“More Internationalization Resources”](#more_internationalization_resources).
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: locale 只对进程范围的设置有效。如果您的应用程序需要在同一个进程中同时处理多种 locale——无论是在线程中还是异步地——由于其进程范围的特性，locale
    并不适合。考虑使用像[PyICU](https://pypi.org/project/PyICU)这样的替代方案，见[“更多国际化资源”](#more_internationalization_resources)。
- en: If a program does not call locale.setlocale, the *C locale* (so called due to
    Python’s C language roots) is used; it’s similar, but not identical, to the US
    English locale. Alternatively, a program can find out and accept the user’s default
    locale. In this case, the locale module interacts with the operating system (via
    the environment or in other system-dependent ways) to try to find the user’s preferred
    locale. Finally, a program can set a specific locale, presumably determining which
    locale to set on the basis of user interaction or via persistent configuration
    settings.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序没有调用 locale.setlocale，则使用 *C locale*（因为 Python 的 C 语言根源而得名）；它与美国英语区域类似但不完全相同。另外，程序可以查找并接受用户的默认区域设置。在这种情况下，区域模块通过与操作系统的交互（通过环境或其他系统相关方式）尝试找到用户首选的区域设置。最后，程序可以设置特定的区域设置，据此确定要设置的区域设置，可能基于用户交互或持久配置设置。
- en: Locale setting is normally performed across the board for all relevant categories
    of cultural conventions. This common wide-spectrum setting is denoted by the constant
    attribute LC_ALL of the locale module. However, the cultural conventions handled
    by locale are grouped into categories, and, in some rare cases, a program can
    choose to mix and match categories to build up a synthetic composite locale. The
    categories are identified by the attributes listed in [Table 11-35](#constant_attributes_of_the_locale_modul).
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 区域设置通常会跨文化习惯的相关类别进行全面设置。这种广泛的设置由区域模块的常量属性 LC_ALL 表示。然而，由区域处理的文化习惯被分成不同类别，在某些罕见的情况下，程序可以选择混合和匹配这些类别，以构建合成的复合区域。这些类别由
    [表 11-35](#constant_attributes_of_the_locale_modul) 中列出的属性标识。
- en: Table 11-35\. Constant attributes of the locale module
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-35\. 区域模块的常量属性
- en: '| LC_COLLATE | String sorting; affects functions strcoll and strxfrm in locale
    |'
  id: totrans-653
  prefs: []
  type: TYPE_TB
  zh: '| LC_COLLATE | 字符串排序；影响区域设置下的函数 strcoll 和 strxfrm |'
- en: '| LC_CTYPE | Character types; affects aspects of module string (and string
    methods) that have to do with lowercase and uppercase letters |'
  id: totrans-654
  prefs: []
  type: TYPE_TB
  zh: '| LC_CTYPE | 字符类型；影响与小写和大写字母相关的 string 模块（以及其方法）的某些方面 |'
- en: '| LC_MESSAGES | Messages; may affect messages displayed by the operating system
    (for example, messages displayed by function os.strerror and module gettext) |'
  id: totrans-655
  prefs: []
  type: TYPE_TB
  zh: '| LC_MESSAGES | 消息；可能影响操作系统显示的消息（例如函数 os.strerror 和模块 gettext 显示的消息） |'
- en: '| LC_MONETARY | Formatting of currency values; affects functions localeconv
    and currency in locale |'
  id: totrans-656
  prefs: []
  type: TYPE_TB
  zh: '| LC_MONETARY | 货币值格式化；影响区域设置下的函数 localeconv 和 currency |'
- en: '| LC_NUMERIC | Formatting of numbers; affects functions atoi, atof, format_string,
    localeconv, and str in locale, as well as the number separators used in format
    strings (e.g., f-strings and str.format) when format character ''n'' is used |'
  id: totrans-657
  prefs: []
  type: TYPE_TB
  zh: '| LC_NUMERIC | 数字格式化；影响区域设置下的函数 atoi、atof、format_string、localeconv 和 str，以及在格式字符串（如
    f-strings 和 str.format）中使用格式字符 ''n'' 时使用的数字分隔符 |'
- en: '| LC_TIME | Formatting of times and dates; affects the function time.strftime
    |'
  id: totrans-658
  prefs: []
  type: TYPE_TB
  zh: '| LC_TIME | 时间和日期格式化；影响函数 time.strftime |'
- en: The settings of some categories (denoted by LC_CTYPE, LC_MESSAGES, and LC_TIME)
    affect behavior in other modules (string, os, gettext, and time, as indicated).
    Other categories (denoted by LC_COLLATE, LC_MONETARY, and LC_NUMERIC) affect only
    some functions of locale itself (plus string formatting in the case of LC_NUMERIC).
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 某些类别的设置（由 LC_CTYPE、LC_MESSAGES 和 LC_TIME 表示）会影响其他模块中的行为（如 string、os、gettext
    和 time）。其他类别（由 LC_COLLATE、LC_MONETARY 和 LC_NUMERIC 表示）仅影响区域本身的某些函数（以及在 LC_NUMERIC
    情况下的字符串格式化）。
- en: The locale module supplies the functions listed in [Table 11-36](#useful_functions_of_the_locale_module)
    to query, change, and manipulate locales, as well as functions that implement
    the cultural conventions of locale categories LC_COLLATE, LC_MONETARY, and LC_NUMERIC.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 区域模块提供了 [表 11-36](#useful_functions_of_the_locale_module) 中列出的函数，用于查询、更改和操作区域设置，以及实施
    LC_COLLATE、LC_MONETARY 和 LC_NUMERIC 类别的文化习惯的函数。
- en: Table 11-36\. Useful functions of the locale module
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-36\. 区域模块的有用函数
- en: '| atof | atof(*s*) Parses the string *s* into a floating-point number using
    the current LC_NUMERIC setting. |'
  id: totrans-662
  prefs: []
  type: TYPE_TB
  zh: '| atof | atof(*s*) 使用当前 LC_NUMERIC 设置将字符串 *s* 解析为浮点数。 |'
- en: '| atoi | atoi(*s*) Parses the string *s* into an integer number using the current
    LC_NUMERIC setting. |'
  id: totrans-663
  prefs: []
  type: TYPE_TB
  zh: '| atoi | atoi(*s*) 使用当前 LC_NUMERIC 设置将字符串 *s* 解析为整数。 |'
- en: '| currency | currency(*data,* grouping=**False**, international=**False**)
    Returns the string or number *data* with a currency symbol, and, if grouping is
    **True**, uses the monetary thousands separator and grouping. When international
    is **True**, uses int_curr_symbol and int_frac_digits, described later in this
    table. |'
  id: totrans-664
  prefs: []
  type: TYPE_TB
  zh: '| currency | currency(*data,* grouping=**False**, international=**False**)
    返回带有货币符号的字符串或数字 *data*，如果 grouping 为 **True**，则使用货币千位分隔符和分组。当 international 为
    **True** 时，使用后面表中描述的 int_curr_symbol 和 int_frac_digits。'
- en: '| f⁠o⁠r⁠m⁠a⁠t⁠_​s⁠t⁠r⁠i⁠n⁠g | format_string(*fmt*, *num*, grouping=**False**,
    monetary=**False**) Returns the string obtained by formatting *num* according
    to the format string *fmt* and the LC_NUMERIC or LC_MONETARY settings. Except
    for cultural convention issues, the result is like old-style *fmt* % *num* string
    formatting, covered in [“Legacy String Formatting with %”](ch09.xhtml#legacy_string_formatting_with_percent).
    If *num* is an instance of a number type and *fmt* is *%d* or *%f*, set grouping
    to **True** to group digits in the result string according to the LC_NUMERIC setting.
    If monetary is **True**, the string is formatted with mon_decimal_point, and *grouping*
    uses mon_thousands_sep and mon_grouping instead of the ones supplied by LC_NUMERIC
    (see localeconv later in this table for more information on these). For example:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '| f⁠o⁠r⁠m⁠a⁠t⁠_​s⁠t⁠r⁠i⁠n⁠g | format_string(*fmt*, *num*, grouping=**False**,
    monetary=**False**) 返回通过根据格式字符串 *fmt* 和 LC_NUMERIC 或 LC_MONETARY 设置对 *num* 进行格式化而获得的字符串。除了文化习惯问题外，结果类似于旧式
    *fmt* % *num* 字符串格式化，详见 [“使用 % 进行传统字符串格式化”](ch09.xhtml#legacy_string_formatting_with_percent)。如果
    *num* 是数字类型的实例，并且 *fmt* 是 *%d* 或 *%f*，将 grouping 设置为 **True** 可以根据 LC_NUMERIC
    设置在结果字符串中对数字进行分组。如果 monetary 为 **True**，字符串将使用 mon_decimal_point 格式化，并且 *grouping*
    使用 mon_thousands_sep 和 mon_grouping 而不是 LC_NUMERIC 提供的设置（有关这些设置的更多信息，请参见表后的 localeconv）。例如：'
- en: '[PRE49]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In this example, since the numeric locale is set to US English, when the argument
    grouping is **True**, format_string groups digits by threes with commas and uses
    a dot (.) for the decimal point. However, the monetary locale is set to Italian,
    so when the argument monetary is **True**, format_string uses a comma (,) for
    the decimal point and grouping uses a dot (.) for the thousands separator. Usually,
    the syntaxes for monetary and nonmonetary numbers are equal within any given locale.
    |
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，由于数字区域设置为美国英语，在参数 grouping 为 **True** 时，format_string 会使用逗号将数字每三位分组，并使用点
    (.) 作为小数点。然而，货币区域设置为意大利时，当参数 monetary 为 **True** 时，format_string 使用逗号 (,) 作为小数点，分组使用点
    (.) 作为千位分隔符。通常，在任何给定的区域设置内，货币和非货币数字的语法是相同的。 |
- en: '| g⁠e⁠t​d⁠e⁠f⁠a⁠u⁠l⁠t​l⁠o⁠c⁠a⁠l⁠e | getdefaultlocale(envvars=(''LANGUAGE'',
    ''LC_ALL'', ''LC_TYPE'', ''LANG'')) Checks the environment variables whose names
    are specified by envvars, in order. The first one found in the environment determines
    the default locale. getdefaultlocale returns a pair of strings (*lang*, *encoding*)
    compliant with [RFC 1766](https://oreil.ly/BbYK1) (except for the ''C'' locale),
    such as (''en_US'', ''UTF-8''). Each item of the pair may be **None** if gedefaultlocale
    is unable to discover what value the item should have. |'
  id: totrans-681
  prefs: []
  type: TYPE_TB
  zh: '| g⁠e⁠t​d⁠e⁠f⁠a⁠u⁠l⁠t​l⁠o⁠c⁠a⁠l⁠e | getdefaultlocale(envvars=(''LANGUAGE'',
    ''LC_ALL'', ''LC_TYPE'', ''LANG'')) 检查按顺序指定的 envvars 环境变量。在环境中找到的第一个变量确定默认区域设置。getdefaultlocale
    返回一对符合 [RFC 1766](https://oreil.ly/BbYK1) 的字符串 (*lang*, *encoding*)（除了 ''C'' 区域设置），例如
    (''en_US'', ''UTF-8'')。如果 gedefaultlocale 无法确定某个项的值，则每对中的每一项可能为 **None**。 |'
- en: '| g⁠e⁠t​l⁠o⁠c⁠a⁠l⁠e | getlocale(category=LC_CTYPE) Returns a pair of strings
    (*lang, encoding*) with the current setting for the given category. The category
    cannot be LC_ALL. |'
  id: totrans-682
  prefs: []
  type: TYPE_TB
  zh: '| g⁠e⁠t​l⁠o⁠c⁠a⁠l⁠e | getlocale(category=LC_CTYPE) 返回给定类别的当前设置的一对字符串 (*lang,
    encoding*)。类别不能是 LC_ALL。 |'
- en: '| localeconv | localeconv() Returns a dict *d* with the cultural conventions
    specified by categories LC_NUMERIC and LC_MONETARY of the current locale. While
    LC_NUMERIC is best used indirectly, via other functions of locale, the details
    of LC_MONETARY are accessible only through *d*. Currency formatting is different
    for local and international use. For example, the ''$'' symbol is for *local*
    use only; it is ambiguous in *international* use, since the same symbol is used
    for many currencies called “dollars” (US, Canadian, Australian, Hong Kong, etc.).
    In international use, therefore, the symbol for US currency is the unambiguous
    string ''USD''. The function temporarily sets the LC_CTYPE locale to the LC_NUMERIC
    locale, or the LC_MONETARY locale if the locales are different and the numeric
    or monetary strings are non-ASCII. This temporary change affects all threads.
    The keys into *d* to use for currency formatting are the following strings:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '| localeconv | localeconv() 返回一个字典*d*，其中包含当前区域设置的LC_NUMERIC和LC_MONETARY类别指定的文化约定。虽然LC_NUMERIC最好间接使用，通过其他locale函数，但LC_MONETARY的细节只能通过*d*访问。本地和国际使用的货币格式不同。例如，''$''符号仅用于*本地*使用；在*国际*使用中是模糊的，因为相同的符号用于许多称为“dollars”的货币（美元、加拿大元、澳大利亚元、香港元等）。因此，在国际使用中，美元货币的符号是明确的字符串''USD''。该函数临时将LC_CTYPE区域设置为LC_NUMERIC区域设置，或者如果区域设置不同且数字或货币字符串为非ASCII，则为LC_MONETARY区域设置。此临时更改影响所有线程。用于货币格式的*d*中的键是以下字符串：'
- en: '''currency_symbol'''
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '''currency_symbol'''
- en: Currency symbol to use locally
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 用于本地使用的货币符号
- en: '''frac_digits'''
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '''frac_digits'''
- en: Number of fractional digits to use locally
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 本地使用的小数位数
- en: '''int_curr_symbol'''
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '''int_curr_symbol'''
- en: Currency symbol to use internationally
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 用于国际使用的货币符号
- en: '''int_frac_digits'''
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '''int_frac_digits'''
- en: Number of fractional digits to use internationally
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 用于国际使用的小数位数
- en: '''mon_decimal_point'''
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '''mon_decimal_point'''
- en: String to use as the “decimal point” (aka *radix point*) for monetary values
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 用作货币值的“小数点”（又称*基数点*）的字符串
- en: '''mon_grouping'''
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '''mon_grouping'''
- en: List of digit-grouping numbers for monetary values
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 货币值的数字分组数字列表
- en: '''mon_thousands_sep'''
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '''mon_thousands_sep'''
- en: String to use as digit-groups separator for monetary values
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 用于货币值的数字组分隔符的字符串
- en: '''negative_sign'', ''positive_sign'''
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '''negative_sign'', ''positive_sign'''
- en: Strings to use as the sign symbol for negative (positive) monetary values
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 用作负（正）货币值符号的字符串
- en: '''n_cs_precedes'', ''p_cs_precedes'''
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '''n_cs_precedes'', ''p_cs_precedes'''
- en: '**True** when the currency symbol comes before negative (positive) monetary
    values'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '**True** 当货币符号位于负（正）货币值之前时'
- en: '''n_sep_by_space'', ''p_sep_by_space'''
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '''n_sep_by_space'', ''p_sep_by_space'''
- en: '**True** when a space goes between the sign and negative (positive) monetary
    values'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '**True** 当符号和负（正）货币值之间有空格时'
- en: '''n_sign_posn'', ''p_sign_posn'''
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '''n_sign_posn'', ''p_sign_posn'''
- en: See [Table 11-37](#numeric_codes) for a list of numberic codes for formating
    negative (positive) monetary values.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[Table 11-37](#numeric_codes) 查看格式化负（正）货币值的数字代码列表。
- en: CHAR_MAX
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: CHAR_MAX
- en: Indicates that the current locale does not specify any convention for this formatting
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 表示当前区域设置不指定此格式的任何约定
- en: '|'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| localeconv *(cont.)* | *d*[''mon_grouping''] is a list of numbers of digits
    to group when formatting a monetary value (but take care: in some locales, *d*[''mon_grouping'']
    may be an empty list). When *d*[''mon_grouping''][-1] is 0, there is no further
    grouping beyond the indicated numbers of digits. When *d*[''mon_grouping''][-1]
    is locale.CHAR_MAX, grouping continues indefinitely, as if *d*[''mon_grouping''][-2]
    were endlessly repeated. locale.CHAR_MAX is a constant used as the value for all
    entries in *d* for which the current locale does not specify any convention. |'
  id: totrans-709
  prefs: []
  type: TYPE_TB
  zh: '| localeconv *(cont.)* | *d*[''mon_grouping''] 是一个数字列表，用于在格式化货币值时分组数字（但要注意：在某些区域设置中，*d*[''mon_grouping'']
    可能是一个空列表）。当*d*[''mon_grouping''][-1] 为0时，除了指定的数字之外，没有进一步的分组。当*d*[''mon_grouping''][-1]
    为locale.CHAR_MAX时，分组将无限继续，就像*d*[''mon_grouping''][-2] 无限重复一样。locale.CHAR_MAX 是用于当前区域设置不指定任何约定的所有*d*条目的值的常量。'
- en: '| localize | localize(*normstr*, grouping=**False**, monetary=**False**) Returns
    a formatted string following LC_NUMERIC (or LC_MONETARY, when monetary is **True**)
    settings from normalized numeric string *normstr*. |'
  id: totrans-710
  prefs: []
  type: TYPE_TB
  zh: '| localize | localize(*normstr*, grouping=**False**, monetary=**False**) 从规范化的数字字符串*normstr*
    返回一个按照LC_NUMERIC（或当monetary 为**True**时，LC_MONETARY）设置的格式化字符串。 |'
- en: '| normalize | normalize(*localename*) Returns a string, suitable as an argument
    to setlocale, that is the normalized form for *localename*. When normalize cannot
    normalize the string *localename*, it returns *localename* unchanged. |'
  id: totrans-711
  prefs: []
  type: TYPE_TB
  zh: '| normalize | normalize(*localename*) 返回一个字符串，适合作为 setlocale 的参数，即 *localename*
    的规范化形式。当 normalize 无法规范化字符串 *localename* 时，返回不变的 *localename*。 |'
- en: '| re⁠s⁠e⁠t​l⁠o⁠c⁠ale | resetlocale(category=LC_ALL) Sets the locale for category
    to the default given by getdefaultlocale. |'
  id: totrans-712
  prefs: []
  type: TYPE_TB
  zh: '| resetlocale | resetlocale(category=LC_ALL) 将类别 *category* 的区域设置为由 getdefaultlocale
    给出的默认值。 |'
- en: '| s⁠e⁠t​l⁠o⁠c⁠a⁠l⁠e | setlocale(*category*, locale=**None**) Sets the locale
    for *category* to locale, if not **None**, and returns the setting (the existing
    one when locale is **None**; otherwise, the new one). locale can be a string,
    or a pair (*lang*, *encoding*). *lang* is normally a language code based on [ISO
    639](https://oreil.ly/aT8Js) two-letter codes (''en'' is English, ''nl'' is Dutch,
    and so on). When locale is the empty string '''', setlocale sets the user’s default
    locale. To see valid locales, view the locale.locale_alias dictionary. |'
  id: totrans-713
  prefs: []
  type: TYPE_TB
  zh: '| setlocale | setlocale(*category*, locale=**None**) 将类别 *category* 的区域设置为
    locale，如果不是 **None**，则返回设置（当 locale 是 **None** 时返回现有设置；否则返回新设置）。 locale 可以是一个字符串，或者一个
    (*lang*, *encoding*) 对。 *lang* 通常是基于 [ISO 639](https://oreil.ly/aT8Js) 两字母代码的语言代码（''en''
    为英语，''nl'' 为荷兰语等）。当 locale 是空字符串 '''' 时，setlocale 设置用户的默认区域设置。要查看有效的区域设置，请查看 locale.locale_alias
    字典。 |'
- en: '| str | str(*num*) Like locale.format_string(''%f'', *num*). |'
  id: totrans-714
  prefs: []
  type: TYPE_TB
  zh: '| str | str(*num*) 类似于 locale.format_string(''%f'', *num*)。 |'
- en: '| strcoll | strcoll(*str1*, *str2*) Respecting the LC_COLLATE setting, returns
    -1 when *str1* comes before *str2* in collation, 1 when *str2* comes before *str1*,
    and 0 when the two strings are equivalent for collation purposes. |'
  id: totrans-715
  prefs: []
  type: TYPE_TB
  zh: '| strcoll | strcoll(*str1*, *str2*) 在 LC_COLLATE 设置下，当 *str1* 在排序中排在 *str2*
    之前时返回 -1，当 *str2* 在 *str1* 之前时返回 1，在排序目的上两个字符串相等时返回 0。 |'
- en: '| strxfrm | strxfrm(*s*) Returns a string *sx* such that Python’s built-in
    comparisons of two or more strings so transformed is like calling locale.strcoll
    on the originals. strxfrm lets you easily use the key argument for sorts and comparisons
    needing locale-conformant string comparisons. For example,'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '| strxfrm | strxfrm(*s*) 返回一个字符串 *sx*，使得 Python 对两个或多个经过此转换的字符串进行比较时类似于调用 locale.strcoll。
    strxfrm 让你可以轻松地在需要区域设置兼容的排序和比较中使用键参数。例如，'
- en: '[PRE63]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '|'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Table 11-37\. Numeric codes to format monetary values
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-37\. 格式化货币值的数值代码
- en: '| 0 | The value and the currency symbol are placed inside parentheses |'
  id: totrans-720
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 值和货币符号放在括号内 |'
- en: '| 1 | The sign is placed before the value and the currency symbol |'
  id: totrans-721
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 标记放在值和货币符号之前 |'
- en: '| 2 | The sign is placed after the value and the currency symbol |'
  id: totrans-722
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 标记放在值和货币符号之后 |'
- en: '| 3 | The sign is placed immediately before the value |'
  id: totrans-723
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 标记直接放在值之前 |'
- en: '| 4 | The sign is placed immediately after the value |'
  id: totrans-724
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 标记直接放在值之后 |'
- en: The gettext Module
  id: totrans-725
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: gettext 模块
- en: A key issue in internationalization is the ability to use text in different
    natural languages, a task known as *localization* (sometimes *l10n*). Python supports
    localization via the standard library module gettext, inspired by GNU gettext.
    The gettext module is optionally able to use the latter’s infrastructure and APIs,
    but also offers a simpler, higher-level approach, so you don’t need to install
    or study GNU gettext to use Python’s gettext effectively.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 国际化的一个关键问题是能够在不同的自然语言中使用文本，这被称为*本地化*（有时是*l10n*）。 Python 通过标准库模块 gettext 支持本地化，受到
    GNU gettext 的启发。 gettext 模块可以选择性地使用后者的基础设施和 API，但也提供了一种更简单、更高级的方法，因此你不需要安装或研究
    GNU gettext 就能有效地使用 Python 的 gettext。
- en: For full coverage of gettext from a different perspective, see the [online docs](https://oreil.ly/43fgn).
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 详细了解从不同角度覆盖 gettext，请参阅 [在线文档](https://oreil.ly/43fgn)。
- en: Using gettext for localization
  id: totrans-728
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 gettext 进行本地化
- en: 'gettext does not deal with automatic translation between natural languages.
    Rather, it helps you extract, organize, and access the text messages that your
    program uses. Pass each string literal subject to translation, also known as a
    *message*, to a function named _ (underscore) rather than using it directly. gettext
    normally installs a function named _ in the builtins module. To ensure that your
    program runs with or without gettext, conditionally define a do-nothing function,
    named _, that just returns its argument unchanged. Then you can safely use _(''*message*'')
    wherever you would normally use a literal ''*message*'' that should be translated,
    if feasible. The following example shows how to start a module for conditional
    use of gettext:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: gettext不涉及自然语言之间的自动翻译。 相反，它帮助您提取、组织和访问程序使用的文本消息。 将每个需要翻译的字符串文字（也称为*消息*）传递给一个名为_（下划线）的函数，而不是直接使用它。
    gettext通常在内置模块中安装一个名为_的函数。 为确保您的程序能够有或没有gettext运行，有条件地定义一个名为_的无操作函数，它只是返回其未更改的参数。
    然后，您可以安全地在需要翻译的文字使用_*message*_的地方使用它。 以下示例显示了如何启动用于有条件使用gettext的模块：
- en: '[PRE64]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If some other module has installed gettext before you run this example code,
    the function greet outputs a properly localized greeting. Otherwise, greet outputs
    the string 'Hello world' unchanged.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在您运行此示例代码之前某个其他模块已安装了gettext，则函数greet会输出一个适当本地化的问候语。 否则，greet输出未更改的字符串'Hello
    world'。
- en: Edit your source, decorating message literals with the function _. Then use
    any of various tools to extract messages into a text file (normally named *messages.pot*)
    and distribute the file to the people who translate messages into the various
    natural languages your application must support. Python supplies a script *pygettext.py*
    (in the directory *Tools/i18n* in the Python source distribution) to perform message
    extraction on your Python sources.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑您的源代码，使用函数_装饰消息文字。 然后使用各种工具之一将消息提取到一个文本文件中（通常命名为*messages.pot*），并将该文件分发给负责将消息翻译为各种自然语言的人员。
    Python提供了一个脚本*pygettext.py*（位于Python源分发中的*Tools/i18n*目录中）来执行对您的Python源文件的消息提取。
- en: Each translator edits *messages.pot* to produce a text file of translated messages,
    with extension *.po.* Compile the *.po* files into binary files with extension
    *.mo*, suitable for fast searching, using any of various tools. Python supplies
    a script *msgfmt.py* (also in *Tools/i18n*) for this purpose. Finally, install
    each *.mo* file with a suitable name in a suitable directory.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 每位翻译员编辑*messages.pot*以生成一个翻译消息的文本文件，扩展名为*.po.* 使用各种工具之一将*.po*文件编译成扩展名为*.mo*的二进制文件，适合快速搜索。
    Python提供了一个名为*msgfmt.py*（也在*Tools/i18n*中）的脚本用于此目的。 最后，在适当的目录中使用适当的名称安装每个*.mo*文件。
- en: Conventions about which directories and names are suitable differ among platforms
    and applications. gettext’s default is subdirectory *share/locale/<lang>/LC_MESSAGES/*
    of directory *sys.prefix*, where *<lang>* is the language’s code (two letters).
    Each file is named *<name>.mo*, where *<name>* is the name of your application
    or package.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 关于哪些目录和名称适合的约定在平台和应用程序之间有所不同。 gettext的默认目录是目录*sys.prefix*下的子目录*share/locale/<lang>/LC_MESSAGES/*，其中*<lang>*是语言代码（两个字母）。
    每个文件命名为*<name>.mo*，其中*<name>*是您的应用程序或软件包的名称。
- en: 'Once you have prepared and installed your *.mo* files, you normally execute,
    at the time your application starts up, some code such as the following:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您准备好并安装了您的*.mo*文件，通常在应用程序启动时，您会执行以下类似的代码：
- en: '[PRE65]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This ensures that calls such as _('message') return the appropriate translated
    strings. You can choose different ways to access gettext functionality in your
    program; for example, if you also need to localize C-coded extensions, or to switch
    between languages during a run. Another important consideration is whether you’re
    localizing a whole application, or just a package that is distributed separately.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保像_('message')这样的调用返回适当的翻译字符串。 您可以选择不同的方式在程序中访问gettext功能； 例如，如果您还需要本地化C编码的扩展，或者在运行期间切换语言。
    另一个重要考虑因素是您是本地化整个应用程序还是仅分开分发的软件包。
- en: Essential gettext functions
  id: totrans-738
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重要的gettext函数
- en: gettext supplies many functions. The most often used functions are listed in
    [Table 11-38](#useful_functions_of_the_gettext_module); see the [online docs](https://oreil.ly/Yk1yv)
    for a complete list.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: gettext提供了许多功能。最常用的功能列在[第11-38表](#useful_functions_of_the_gettext_module)中；请查看[在线文档](https://oreil.ly/Yk1yv)获取完整列表。
- en: Table 11-38\. Useful functions of the gettext module
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 表11-38\. gettext模块的有用函数
- en: '| install | install(*domain*, localedir=**None**, names=**None**) Installs
    in Python’s built-in namespace a function named _ to perform translations given
    in the file *<lang>/LC_MESSAGES/<domain>.mo* in the directory localedir, with
    language code *<lang>* as per getdefaultlocale. When localedir is **None**, install
    uses the directory os.path.join(sys.prefix, ''share'', ''locale''). When names
    is provided, it must be a sequence containing the names of functions you want
    to install in the builtins namespace in addition to _. Supported names are ''gettext'',
    ''lgettext'', ''lngettext'', ''ngettext'', 3.8+ ''npgettext'', and 3.8+ ''pgettext''.
    |'
  id: totrans-741
  prefs: []
  type: TYPE_TB
  zh: '| 安装 | 安装(*domain*, localedir=**None**, names=**None**) 在Python的内置命名空间中安装一个名为_的函数，以在目录localedir中给定的文件<lang>/LC_MESSAGES/<domain>.mo中执行翻译，使用语言代码<lang>按照getdefaultlocale。当localedir为**None**时，install使用目录os.path.join(sys.prefix，''share''，''locale'')。当提供names时，它必须是包含要在内置命名空间中安装的函数名称的序列，以外加_。支持的名称有''gettext''，''lgettext''，''lngettext''，''ngettext''，3.8+''npgettext''和3.8+''pgettext''。
    |'
- en: '| translation | translation(*domain*, localedir=**None**, languages=**None**,
    class_=**None**, fallback=**False**) Searches for a *.mo* file, like the install
    function; if it finds multiple files, translation uses later files as fallbacks
    for earlier ones. Set fallback to **True** to return a NullTranslations instance;
    otherwise, the function raises OSError when it doesn’t find any *.mo* file.'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '| 翻译 | 翻译(*domain*, localedir=**None**, languages=**None**, class_=**None**,
    fallback=**False**) 搜索*.mo*文件，就像install函数一样；如果找到多个文件，则翻译将较晚的文件用作较早的文件的回退。将fallback设置为**True**以返回一个NullTranslations实例；否则，当找不到任何*.mo*文件时，函数会引发OSError。'
- en: When languages is **None**, translation looks in the environment for the *<lang>*
    to use, like install. It examines, in order, the environment variables LANGUAGE,
    LC_ALL, LC_MESSAGES, and LANG, and splits the first nonempty one on ':' to give
    a list of language names (for example, it splits 'de:en' into ['de', 'en']). When
    not **None**, languages must be a list of one or more language names (for example,
    ['de', 'en']). translation uses the first language name in the list for which
    it finds a *.mo* file. |
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 当languages为**None**时，翻译会在环境中查找要使用的<lang>，就像install一样。它按顺序检查环境变量LANGUAGE、LC_ALL、LC_MESSAGES和LANG，并在第一个非空变量上用':'拆分以给出语言名称的列表（例如，它将'de:en'拆分为['de'，'en']）。当languages不为**None**时，languages必须是一个包含一个或多个语言名称的列表（例如，['de'，'en']）。翻译使用列表中找到的第一个语言名称，该名称对应于找到的*.mo*文件。
    |
- en: '| translation *(cont.)* | translation returns an instance object of a translation
    class (by default, GNUTranslations; if present, the class’s constructor must take
    a single file object argument) that supplies the methods gettext (to translate
    a str) and install (to install gettext under the name _ in Python’s builtins namespace).
    translation offers more detailed control than install, which is like translation(*domain*,
    *localedir*).install(*unicode*). With translation, you can localize a single package
    without affecting the built-in namespace, by binding the name _ on a per-module
    basis—for example, with:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: '| 翻译 *(cont.)* | 翻译返回一个翻译类的实例对象（默认为GNUTranslations；如果存在，则类的构造函数必须接受单个文件对象参数），该对象提供了gettext方法（用于翻译str）和install方法（将gettext安装在Python内置命名空间中的名称_下）。翻译提供了比install更详细的控制，其功能类似于translation(*domain*,
    *localedir*).install(*unicode*)。使用翻译，您可以在不影响内置命名空间的情况下，按模块绑定名称_，以本地化单个包，例如：'
- en: '[PRE66]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '|'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: More Internationalization Resources
  id: totrans-747
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多国际化资源
- en: Internationalization is a very large topic. For a general introduction, see
    [Wikipedia](https://oreil.ly/raRbx). One of the best packages of code and information
    for internationalization, which the authors happily recommend, is [ICU](https://icu.unicode.org),
    embedding also the Unicode Consortium’s Common Locale Data Repository (CLDR) database
    of locale conventions and code to access the CLDR. To use ICU in Python, install
    the third-party package [PyICU](https://oreil.ly/EkwTk).
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 国际化是一个非常庞大的主题。有关一般介绍，请参见[Wikipedia](https://oreil.ly/raRbx)。国际化的最佳代码和信息包之一，作者乐意推荐的是[ICU](https://icu.unicode.org)，其中还包括Unicode
    Consor国际化是一个非常庞大的主题。有关一般介绍，请参见[Wikipedia](https://oreil.ly/raRbx)。国际化的最佳代码和信息包之一，作者乐意推荐的是[ICU](https://icu.unicode.org)，其中还包括Unicode
    Consortium的通用区域设置数据存储库（CLDR）数据库的区域设置约定和访问CLDR的代码。要在Python中使用ICU，请安装第三方包[PyICU](https://oreil.ly/EkwTk)。
- en: ^([1](ch11.xhtml#ch01fn99-marker)) tell’s value is opaque for text files, since
    they contain variable-length characters. For binary files, it’s simply a straight
    byte count.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch11.xhtml#ch01fn99-marker)) 对于文本文件，tell 的值对于不定长字符是不透明的，因为它们包含可变长度的字符。对于二进制文件，它只是一个直接的字节计数。
- en: ^([2](ch11.xhtml#ch01fn102-marker)) Alas, yes—not sys.stderr, as common practice
    and logic would dictate!
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch11.xhtml#ch01fn102-marker)) 遗憾的是，是的——不是sys.stderr，如常见做法和逻辑所建议的那样！
- en: ^([3](ch11.xhtml#ch01fn103-marker)) Or, even better, the even-higher-level pathlib
    module, covered later in this chapter.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch11.xhtml#ch01fn103-marker)) 或者更好的是，更高级别的 pathlib 模块，在本章后面进行介绍。
- en: ^([4](ch11.xhtml#ch01fn104-marker)) “Curses” does describe well the typical
    utterances of programmers faced with this complicated, low-level approach.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch11.xhtml#ch01fn104-marker)) “诅咒” 很好地描述了程序员面对这种复杂的低级别方法时的典型呻吟。
- en: ^([5](ch11.xhtml#ch01fn105-marker)) I18n includes the process of “localization,”
    or adapting international software to local language and cultural conventions.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch11.xhtml#ch01fn105-marker)) I18n 包括了“本地化”的过程，即将国际软件适应本地语言和文化习惯。
