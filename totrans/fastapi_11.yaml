- en: Chapter 8\. Web Layer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 网页层
- en: Preview
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预览
- en: '[Chapter 3](ch03.html#ch03) was a quick look at how to define FastAPI web endpoints,
    pass simple string inputs to them, and get responses. This chapter goes further
    into the top layer of a FastAPI application—which could also be called an *Interface*
    or *Router* layer—and its integration with the Service and Data layers.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html#ch03)快速查看如何定义FastAPI的Web端点，将简单的字符串输入传递给它们，并获得响应。本章进一步探讨了FastAPI应用程序的顶层（也可以称为*接口*或*路由器*层）及其与服务和数据层的集成。'
- en: As before, I’ll start with small examples. Then I’ll introduce some structure,
    dividing layers into subsections to allow for cleaner development and growth.
    The less code we write, the less we’ll need to remember and fix later.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前一样，我将从小例子开始。然后，我会引入一些结构，将层次划分为子部分，以便进行更清晰的开发和扩展。我们写的代码越少，以后需要记住和修复的就越少。
- en: The basic sample data in this book concerns imaginary creatures, or *cryptids*,
    and their explorers. You may find parallels with other domains of information.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中基本的示例数据涉及想象中的生物，或称为*神秘动物*，以及它们的探险者。你可能会发现与其他信息领域的类似之处。
- en: 'What do we do with information, in general? Like most websites, ours will provide
    ways to do the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一般情况下，我们如何处理信息？与大多数网站一样，我们的网站将提供以下方式来做以下事情：
- en: Retrieve
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索
- en: Create
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建
- en: Modify
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改
- en: Replace
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换
- en: Delete
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除
- en: Starting from the top, we’ll create web endpoints that perform these functions
    on our data. At first, we’ll provide fake data to make the endpoints work with
    any web client. In the following chapters, we’ll move the fake data code down
    into the lower layers. At each step, we’ll ensure that the site still works and
    passes data through correctly. Finally, in [Chapter 10](ch10.html#ch10), we’ll
    drop the faking and store real data in real databases, for a full end-to-end (Web
    → Service → Data) website.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始，我们将创建Web端点来执行这些功能对我们的数据。起初，我们将提供虚假数据使端点能够与任何Web客户端一起工作。在接下来的章节中，我们将把虚假数据的代码移动到较低层次。在每个步骤中，我们将确保网站仍然能够正确地传递数据。最后，在[第10章](ch10.html#ch10)中，我们将放弃伪造，并在真实数据库中存储真实数据，以实现完整的端到端（Web
    → 服务 → 数据）网站。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Allowing any anonymous visitor to perform all these actions will be an object
    lesson in “why we can’t have nice things.” [Chapter 11](ch11.html#ch11) discusses
    the *auth* (authentication and authorization) needed to define roles and limit
    who can do what. For the rest of the current chapter, we’ll sidestep auth and
    just show how to handle the raw web functions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 允许任何匿名访问者执行所有这些操作将成为“为什么我们不能拥有好东西”的一个教训。[第11章](ch11.html#ch11)讨论了*auth*（身份验证和授权）需要定义角色和限制谁可以做什么。在本章的其余部分中，我们将避开认证，只展示如何处理原始的网页功能。
- en: 'Interlude: Top-Down, Bottom-Up, Middle-Out?'
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插曲：自上而下，自下而上，中间到外围？
- en: 'When designing a website, you could start from one of the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计网站时，你可以从以下之一开始：
- en: The Web layer and work down
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网页层及以下工作
- en: The Data layer and work up
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据层及以上
- en: The Service layer and work out in both directions
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务层及两端工作
- en: Do you already have a database, installed and loaded with data, and are just
    pining for a way to share it with the world? If so, you may want to tackle the
    Data layer’s code and tests first, then the Service layer, and write the Web layer
    last.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经有一个安装和加载数据的数据库，只是渴望找到一种与世界分享的方法吗？如果是这样，你可能想先处理数据层的代码和测试，然后是服务层，最后编写网页层。
- en: If you’re following [domain-driven design](https://oreil.ly/iJu9Q), you might
    start in the middle Service layer, defining your core entities and data models.
    Or you may want to evolve the web interface first, and fake calls to the lower
    layers until you know what you’ll expect of them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循[领域驱动设计](https://oreil.ly/iJu9Q)，你可能会从中间的服务层开始，定义你的核心实体和数据模型。或者你可能想先演化Web界面，并伪造调用低层，直到你知道它们的预期结果。
- en: 'You’ll find very good design discussions and recommendations in these books:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在这些书中找到非常好的设计讨论和建议：
- en: '[*Clean Architectures in Python*](https://oreil.ly/5KrL9) by Leonardo Giordani
    (Digital Cat Books)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*Python中的清晰架构*](https://oreil.ly/5KrL9) 作者：Leonardo Giordani（Digital Cat Books）'
- en: '[*Architecture Patterns with Python*](https://www.cosmicpython.com) by Harry
    J.W. Percival and Bob Gregory (O’Reilly)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*使用Python的架构模式*](https://www.cosmicpython.com) 作者：Harry J.W. Percival 和 Bob
    Gregory（O’Reilly）'
- en: '[*Microservice APIs*](https://oreil.ly/Gk0z2) by José Haro Peralta (Manning)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*微服务API*](https://oreil.ly/Gk0z2) 作者：José Haro Peralta（Manning）'
- en: In these and other sources, you’ll see terms like *hexagonal architecture*,
    *ports*, and *adapters*. Your choices on how to proceed largely depend on what
    data you have already and how you want to approach the work of building a site.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些和其他来源中，您将看到诸如 *六边形架构*、*端口* 和 *适配器* 等术语。您如何继续的选择主要取决于您已有的数据及您希望如何处理构建站点的工作。
- en: I’m guessing that many of you are mainly interested in trying out FastAPI and
    its related technologies, and don’t necessarily have a predefined mature data
    domain that you want to instrument right away.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我猜您中的许多人主要是想尝试 FastAPI 及其相关技术，并不一定有一个预定义的成熟数据域，想要立即开始设置。
- en: So, in this book I’m taking the web-first approach—step-by-step, starting with
    essential parts, and adding others as needed on the way down. Sometimes experiments
    work, sometimes not. I’ll avoid the urge to stuff everything into this Web layer
    at first.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本书中，我采用了 Web 优先方法——逐步，从基本部分开始，根据需要逐步添加其他部分。有时实验有效，有时不有效。我将避免一开始就把所有内容塞进这个
    Web 层。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This Web layer is just one way of passing data between a user and a service.
    Alternate ways exist, such as by a CLI or software development kit (SDK). In other
    frameworks, you might see this Web layer called a *view* or *presentation* layer.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此 Web 层只是将数据在用户和服务之间传递的一种方式。还存在其他方式，例如 CLI 或软件开发工具包（SDK）。在其他框架中，您可能会看到此 Web
    层称为 *视图* 或 *演示* 层。
- en: RESTful API Design
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful API 设计
- en: HTTP is a way to get commands and data between web clients and servers. But,
    just as you can combine ingredients from your refrigerator in ways from ghastly
    to gourmet, some recipes for HTTP work better than others.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 是在 Web 客户端和服务器之间传递命令和数据的一种方式。但是，就像您可以将冰箱中的食材以从可怕到美味的方式组合一样，HTTP 的一些用法比其他用法更有效。
- en: 'In [Chapter 1](ch01.html#ch01), I mentioned that *RESTful* became a useful,
    though sometimes fuzzy, model for HTTP development. RESTful designs have these
    core components:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 1 章](ch01.html#ch01) 中，我提到 *RESTful* 成为 HTTP 开发中有用的，尽管有时模糊的模型。RESTful 设计具有以下核心组件：
- en: Resources
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 资源
- en: The data elements your application manages
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序管理的数据元素
- en: IDs
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符
- en: Unique resource identifiers
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一资源标识符
- en: URLs
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: URL
- en: Structured resource and ID strings
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化资源和 ID 字符串
- en: Verbs or actions
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 动词或操作
- en: 'Terms that accompany URLs for different purposes:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随 URL 的用途术语：
- en: '`GET`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`'
- en: Retrieve a resource.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 检索资源。
- en: '`POST`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST`'
- en: Create a new resource.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新资源。
- en: '`PUT`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT`'
- en: Completely replace a resource.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 完全替换资源。
- en: '`PATCH`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`PATCH`'
- en: Partially replace a resource.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 部分替换资源。
- en: '`DELETE`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`DELETE`'
- en: Resource goes kaboom.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 资源爆炸。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll see disagreement about the relative merits of `PUT` versus `PATCH`. If
    you don’t need to distinguish between a partial modification and a full one (replacement),
    you may not need both.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `PUT` 和 `PATCH` 的相对优点，存在不同意见。如果您不需要区分部分修改和完全替换，可能不需要两者。
- en: 'General RESTful rules for combining verbs and URLs containing resources and
    IDs use these patterns of path parameters (content between the `/` in the URL):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 用于结合动词和包含资源和标识符的 URL 的一般 RESTful 规则使用路径参数的这些模式（URL 中 `/` 之间的内容）：
- en: verb /resource/
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 动词 /资源/
- en: Apply *verb* to all resources of type *resource*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *动词* 应用于所有 *资源* 类型的资源。
- en: verb /resource/id
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 动词 /资源/id
- en: Apply *verb* to the *resource* with ID *id*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *动词* 应用于带有 ID *id* 的 *资源*。
- en: Using the example data for this book, a `GET` request to the endpoint */thing*
    would return data on all explorers, but a `GET` request for */thing/abc* would
    give you data for only the `thing` resource with ID `abc`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本书示例数据，对端点 */thing* 的 `GET` 请求将返回所有探险者的数据，但对 */thing/abc* 的 `GET` 请求将仅返回 ID
    为 `abc` 的 `thing` 资源的数据。
- en: 'Finally, web requests often carry more information, indicating to do the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Web 请求通常包含更多信息，指示要执行以下操作：
- en: Sort results
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对结果进行排序
- en: Paginate results
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分页结果
- en: Perform another function
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行另一个功能
- en: Parameters for these can sometimes be expressed as *path* parameters (tacked
    onto the end, after another `/`) but are often included as *query* parameters
    (*var=val* stuff after the `?` in the URL). Because URLs have size limits, large
    requests are often conveyed in the HTTP body.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数有时可以表示为 *路径* 参数（附加到另一个 `/` 后面），但通常作为 *查询* 参数（URL 中 `?` 后面的 *var=val* 格式）。因为
    URL 有大小限制，所以大请求通常通过 HTTP 主体传递。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Most authors recommend using plurals when naming the resource, and related
    namespaces like API sections and database tables. I followed this advice for a
    long time but now feel that singular names are simpler for many reasons (including
    oddities of the English language):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数作者建议在命名资源和相关的命名空间（如API部分和数据库表）时使用复数。我长期以来遵循这个建议，但现在感觉使用单数名称在许多方面更简单（包括英语语言的怪异性）：
- en: 'Some words are their own plurals: `series`, `fish`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些词是它们自己的复数形式：`series`，`fish`
- en: 'Some words have irregular plurals: `children`, `people`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些词具有不规则的复数形式：`children`，`people`
- en: You need bespoke singular to/from plural conversion code in many places
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要在许多地方编写定制的单数到复数转换代码
- en: For these reasons, I’m using a singular naming scheme in many places in this
    book. This is against usual RESTful advice, so feel free to ignore this if you
    disagree.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，本书中许多地方我都使用了单数命名方案。这与通常的RESTful建议相悖，如果您不同意，可以自由忽略。
- en: File and Directory Site Layout
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件和目录站点布局
- en: Our data mainly concerns creatures and explorers. Initially, we could define
    all the URLs and their FastAPI path functions for accessing their data in a single
    Python file. Let’s resist that temptation, and start as though we were already
    a rising star in the cryptid web space. With a good foundation, cool new things
    are much easier to add.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据主要涉及生物和探险者。最初，我们可以在单个Python文件中定义所有URL及其FastAPI路径函数，以访问它们的数据。让我们抵制这种诱惑，开始就像我们已经是神秘动物网站空间的新星一样。有了良好的基础，添加新功能就容易多了。
- en: 'First, pick a directory on your machine. Name it *fastapi*, or anything that
    will help you remember where you’ll be messing with the code from this book. Within
    it, create the following subdirectories:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在您的计算机上选择一个目录。将其命名为*fastapi*，或任何有助于您记住您将从本书中的代码中混合的地方。在其中，创建以下子目录：
- en: src
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 源码
- en: Contains all the website code
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 包含所有网站代码
- en: web
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 网络
- en: The FastAPI web layer
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI Web层
- en: service
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 服务
- en: The business logic layer
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 业务逻辑层
- en: data
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 数据
- en: The storage interface layer
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 存储接口层
- en: model
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 模型
- en: Pydantic model definitions
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic模型定义
- en: fake
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 虚构的
- en: Early hardwired (*stub*) data
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 早期硬编码（*stub*）数据
- en: 'Each of these directories will soon gain three files:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些目录中的每一个很快都会增加三个文件：
- en: __init__.py
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: __init__.py
- en: Needed to treat this directory as a package
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 必须将此目录视为一个包
- en: creature.py
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: creature.py
- en: Creature code for this layer
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为这一层创建的代码
- en: explorer.py
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: explorer.py
- en: Explorer code for this layer
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为这一层的探险者代码
- en: '*Many* opinions exist on how to lay out sites for development. This design
    is intended to show the layer separation and leave room for future additions.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*许多*意见存在于如何布置开发站点的问题上。此设计旨在显示层次分离并为将来的增加留出空间。'
- en: Some explanations are needed right now. First, *__init__.py* files are empty.
    They’re sort of a Python hack, so their directory should be treated as a Python
    *package* that may be imported from. Second, the *fake* directory provides some
    stub data to higher layers as the lower ones are built.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在需要一些解释。首先，*__init__.py*文件是空的。它们是Python的一种黑客，因此应该将它们的目录视为Python *package*，可以从中导入。其次，*fake*目录为较高层提供了一些stub数据，因为较低层正在构建。
- en: In addition, Python’s *import* logic doesn’t work strictly with directory hierarchies.
    It relies on Python *packages* and *modules*. The *.py* files listed in the tree
    structure described previously are Python modules (source files). Their parent
    directories are packages *if* they contain an *__init__.py* file. (This is a convention
    to tell Python whether, if you have a directory called *sys* and you type `import
    sys`, you actually want the system one or your local one.)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Python的*import*逻辑并不严格遵循目录层次结构。它依赖于Python的*packages*和*modules*。之前描述的树状结构中列出的*.py*文件是Python模块（源文件）。如果它们包含一个*__init__.py*文件，则它们的父目录是包。（这是一个约定，告诉Python，如果你有一个叫*sys*的目录，你键入`import
    sys`，你实际上想要系统的还是你本地的一个。）
- en: 'Python programs can import packages and modules. The Python interpreter has
    a built-in `sys.path` variable, which includes the location of the standard Python
    code. The environment variable `PYTHONPATH` is an empty or colon-separated string
    of directory names that tells Python which parent directories to check before
    `sys.path` to find the imported modules or packages. So, if you change to your
    new *fastapi* directory, type this (on Linux or macOS) to ensure that the new
    code under it will be checked first when importing:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Python 程序可以导入包和模块。Python 解释器有一个内置的 `sys.path` 变量，其中包括标准 Python 代码的位置。环境变量 `PYTHONPATH`
    是一个空字符串或以冒号分隔的目录名称字符串，告诉 Python 在检查 `sys.path` 之前要检查哪些父目录以查找导入的模块或包。因此，如果切换到新的
    *fastapi* 目录，可以在 Linux 或 macOS 上输入以下内容，以确保在导入时首先检查其下的新代码：
- en: '[PRE0]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That `$PWD` means *print working directory*, and saves you from typing the full
    path to your *fastapi* directory, although you can if you want. And the `src`
    part means to look only in there for modules and packages to import.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 那个 `$PWD` 意味着 *打印当前工作目录*，可以避免您输入 *fastapi* 目录的完整路径，尽管如果愿意，您也可以输入。而 `src` 部分表示仅在其中查找要导入的模块和包。
- en: 'To set the `PWD` environment variable under Windows, see [“Excursus: Setting
    Environment Variables” at the Python Software Foundation site](https://oreil.ly/9NRBA).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Windows 下设置 `PWD` 环境变量，请参阅[“Python 软件基金会网站上的环境变量设置”](https://oreil.ly/9NRBA)。
- en: Whew.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 哇。
- en: The First Website Code
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个网站代码
- en: This section discusses how to use FastAPI to write requests and responses for
    a RESTful API site. Then, we’ll begin to apply these to our actual, increasingly
    gnarly, site.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论如何使用 FastAPI 为 RESTful API 站点编写请求和响应。然后，我们将开始将这些应用到我们实际的，变得越来越复杂的站点上。
- en: Let’s begin with [Example 8-1](#ex-8-1). Within *src*, make this new top-level
    *main.py* program that will start the Uvicorn program and FastAPI package.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 [Example 8-1](#ex-8-1) 开始。在 *src* 中，创建这个新的顶层 *main.py* 程序，它将启动 Uvicorn
    程序和 FastAPI 包。
- en: Example 8-1\. The main program, main.py
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 8-1\. 主程序，main.py
- en: '[PRE1]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That `app` is the FastAPI object that ties everything together. Uvicorn’s first
    argument is `"main:app"` because the file is called *main.py*, and the second
    is `app`, the name of the FastAPI object.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 那个 `app` 就是将一切连接在一起的 FastAPI 对象。Uvicorn 的第一个参数是 `"main:app"`，因为文件名为 *main.py*，第二个参数是
    `app`，FastAPI 对象的名称。
- en: Uvicorn will keep on running, and restart if any code changes in the same directory
    or any subdirectories. Without `reload=True`, each time you modify your code,
    you’d need to kill and restart Uvicorn manually. In many of the following examples,
    you’ll just keep changing the same *main.py* file and forcing a restart, instead
    of creating *main2.py*, *main3.py*, and so on.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Uvicorn 将继续运行，并在同一目录或任何子目录中进行代码更改后重新启动。如果没有 `reload=True`，每次修改代码后，您都需要手动杀死并重新启动
    Uvicorn。在接下来的许多示例中，您将仅仅保持对同一个 *main.py* 文件的更改并强制重新启动，而不是创建 *main2.py*、*main3.py*
    等等。
- en: Fire up *main.py* in [Example 8-2](#ex-8-2).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Example 8-2](#ex-8-2) 中启动 *main.py*。
- en: Example 8-2\. Run the main program
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 8-2\. 运行主程序
- en: '[PRE2]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That final `&` puts the program into the background, and you can run other programs
    in the same terminal window if you like. Or omit the `&` and run your other code
    in a different window or tab.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后那个 `&` 将程序放入后台，您可以在同一个终端窗口中运行其他程序（如果愿意的话）。或者省略 `&` 并在不同的窗口或标签页中运行其他代码。
- en: 'Now you can access the site `localhost:8000` with a browser or any of the test
    programs that you’ve seen so far. [Example 8-3](#ex-8-3) uses HTTPie:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用浏览器或到目前为止看到的任何测试程序访问站点 `localhost:8000`。[Example 8-3](#ex-8-3) 使用 HTTPie：
- en: Example 8-3\. Test the main program
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 8-3\. 测试主程序
- en: '[PRE3]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: From now on, as you make changes, the web server should restart automatically.
    If an error kills it, restart it with `python main.py` again.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，当您进行更改时，Web 服务器应该会自动重新启动。如果出错导致其停止，请再次使用 `python main.py` 来重新启动它。
- en: '[Example 8-4](#ex-8-4) adds another test endpoint, using a *path* parameter
    (part of the URL).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 8-4](#ex-8-4) 添加了另一个测试端点，使用了 *path* 参数（URL 的一部分）。'
- en: Example 8-4\. Add an endpoint
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 8-4\. 添加一个端点
- en: '[PRE4]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As soon as you save your changes to *main.py* in your editor, the window where
    your web server is running should print something like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在编辑器中保存对 *main.py* 的更改，运行您的 Web 服务器的窗口应该会打印类似这样的内容：
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[Example 8-5](#ex-8-5) shows whether the new endpoint was handled correctly
    (the `-b` prints only the response body).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 8-5](#ex-8-5) 显示了新端点是否被正确处理（`-b` 仅打印响应正文）。'
- en: Example 8-5\. Test new endpoint
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 8-5\. 测试新的端点
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the following sections, we’ll add more endpoints to *main.py*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将在 *main.py* 中添加更多的端点。
- en: Requests
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求
- en: An HTTP request consists of a text *header* followed by one or more *body* sections.
    You could write your own code to parse HTTP into Python data structures, but you
    wouldn’t be the first. In your web application, it’s more productive to have these
    details done for you by a framework.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 请求由文本 *header* 后跟一个或多个 *body* 部分组成。你可以编写自己的代码将 HTTP 解析为 Python 数据结构，但你不会是第一个这样做的人。在你的
    Web 应用程序中，让框架为你完成这些细节更具生产力。
- en: 'FastAPI’s dependency injection is particularly useful here. Data may come from
    different parts of the HTTP message, and you’ve already seen how you can specify
    one or more of these dependencies to say where the data is located:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 的依赖注入在这里特别有用。数据可以来自 HTTP 消息的不同部分，你已经看到可以指定其中一个或多个依赖项来说明数据的位置：
- en: '`Header`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`Header`'
- en: In the HTTP headers
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTP 头部中
- en: '`Path`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`'
- en: In the URL
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 URL 中
- en: '`Query`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`Query`'
- en: After the `?` in the URL
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 URL 中的 `?` 后面
- en: '`Body`'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Body`'
- en: In the HTTP body
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTP body 中
- en: 'Other, more indirect, sources include the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 其他更间接的来源包括以下内容：
- en: Environment variables
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量
- en: Configuration settings
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置设置
- en: '[Example 8-6](#ex-8-6) features an HTTP request, using our old friend HTTPie,
    and ignoring the returned HTML body data.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-6](#ex-8-6) 展示了一个 HTTP 请求，使用我们的老朋友 HTTPie，并忽略返回的 HTML body 数据。'
- en: Example 8-6\. HTTP request and response headers
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-6\. HTTP 请求和响应头部
- en: '[PRE7]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first line asks for the top page at *example.com* (a free website that anyone
    can use in, well, examples). It asks only for a URL, with no parameters anywhere
    else. The first block of lines is the HTTP request headers sent to the website,
    and the next block contains the HTTP response headers.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行要求在 *example.com* 上获取顶层页面（一个任何人都可以在示例中使用的免费网站）。它只请求一个 URL，没有任何其他参数。第一块行是发送到网站的
    HTTP 请求头部，下一块包含 HTTP 响应头部。
- en: Note
  id: totrans-142
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Most test examples from here on won’t need all those request and response headers,
    so you’ll see more use of `http -b`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始的大多数测试示例不需要所有这些请求和响应头部，因此你会看到更多的使用 `http -b`。
- en: Multiple Routers
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个路由器
- en: Most web services handle multiple kinds of resources. Although you could throw
    all your path-handling code in a single file and head off to a happy hour somewhere,
    it’s often handy to use multiple *subrouters* instead of the single `app` variable
    that most of the examples up to now have used.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Web 服务处理多种资源类型。虽然你可以将所有路径处理代码都放在一个文件中，然后去愉快的时光中度过，但通常使用多个 *子路由器* 比起大多数到目前为止使用的单个
    `app` 变量更方便。
- en: Under the *web* directory (in the same directory as the *main.py* file that
    you’ve been modifying so far), make a file called *explorer.py*, as in [Example 8-7](#ex-8-7).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *web* 目录下（与你迄今修改的 *main.py* 文件相同的目录中），创建一个名为 *explorer.py* 的文件，就像 [示例 8-7](#ex-8-7)
    中的那样。
- en: Example 8-7\. `APIRouter` use in web/explorer.py
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-7\. 在 web/explorer.py 中使用 `APIRouter`
- en: '[PRE8]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, [Example 8-8](#ex-8-8) gets the top-level application *main.py* to know
    that there’s a new subrouter in town, which will handle all URLs that start with
    */explorer*:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，[示例 8-8](#ex-8-8) 让顶级应用程序 *main.py* 知道有一个新的子路由器出现了，它将处理所有以 */explorer* 开头的
    URL：
- en: Example 8-8\. Connect the main application (main.py) to the subrouter
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-8\. 连接主应用程序（main.py）到子路由器
- en: '[PRE9]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This new file will be picked up by Uvicorn. As usual, test in [Example 8-9](#ex-8-9)
    instead of assuming it will work.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新文件将被 Uvicorn 捡起。像往常一样，在 [示例 8-9](#ex-8-9) 中进行测试，而不是假设它会起作用。
- en: Example 8-9\. Test new subrouter
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-9\. 测试新的子路由器
- en: '[PRE10]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Build the Web Layer
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 Web 层
- en: Now let’s start adding the actual core functions to the Web layer. Initially,
    fake all the data in the web functions themselves. In [Chapter 9](ch09.html#ch09),
    we will move the fake data stuff to corresponding service functions, and in [Chapter 10](ch10.html#ch10),
    to the data functions. Finally, an actual database will be added for the Data
    layer to access. At each development step, calls to the web endpoints should still
    work.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们开始向 Web 层添加实际的核心函数。最初，在 Web 函数本身中假装所有的数据都是假的。在 [第9章](ch09.html#ch09) 中，我们将把假数据移到相应的服务函数中，然后在
    [第10章](ch10.html#ch10) 中移到数据函数中。最后，将添加一个真实的数据库供数据层访问。在每个开发步骤中，对 Web 端点的调用仍然应该有效。
- en: Define Data Models
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义数据模型
- en: First, define the data that we’ll be passing among levels. Our *domain* contains
    explorers and creatures, so let’s define minimal initial Pydantic models for them.
    Other ideas might come up later, like expeditions, journals, or ecommerce sales
    of coffee mugs. But for now, just include the two breathing (usually, in the case
    of creatures) models in [Example 8-10](#ex-8-10).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义我们将在各个级别之间传递的数据。我们的*领域*包含探险家和生物，所以让我们为它们定义最小的初始 Pydantic 模型。稍后可能会出现其他想法，例如探险、日志或咖啡杯的电子商务销售。但现在，只包括
    [示例 8-10](#ex-8-10) 中的两个呼吸（通常是生物）模型。
- en: Example 8-10\. Model definition in model/explorer.py
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-10\. 在 model/explorer.py 中的模型定义
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Example 8-11](#ex-8-11) resurrects the `Creature` definition from earlier
    chapters.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-11](#ex-8-11) 从早期章节中复活了`Creature`的定义。'
- en: Example 8-11\. Model definition in model/creature.py
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-11\. 在 model/creature.py 中的模型定义
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These are very simple initial models. You’re not using any of Pydantic’s features,
    such as required versus optional, or constrained values. This simple code can
    be enhanced later without massive logic upheavals.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是非常简单的初始模型。你没有使用任何 Pydantic 的特性，比如必需与可选，或受限制的值。稍后可以通过不进行大规模逻辑变动来增强这段简单的代码。
- en: For `country` values, you’ll use the ISO two-character country codes; this saves
    a little typing, at the cost of looking up uncommon ones.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`country`值，你将使用 ISO 两位字符的国家代码；这样做可以节省一些输入，但代价是查找不常见的国家。
- en: Stub and Fake Data
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存根和假数据
- en: Also known as *mock data*, *stubs* are canned results that are returned without
    calling the normal “live” modules. They’re a quick way to test your routes and
    responses.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 也称为*mock数据*，*存根*是返回而不调用正常“实时”模块的预制结果。它们是测试路由和响应的快速方式。
- en: A *fake* is a stand-in for a real data source that performs at least some of
    the same functions. An example is an in-memory class that mimics a database. You’ll
    be making some fake data in this chapter and the next few, as you fill in the
    code that defines the layers and their communication. In [Chapter 10](ch10.html#ch10),
    you’ll define an actual live data store (a database) to replace these fakes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*假数据*是真实数据源的替代品，它执行至少一些相同的功能。一个例子是模拟数据库的内存中类。在这一章和接下来的几章中，你将制作一些假数据，填写定义层及其通信的代码。在[第十章](ch10.html#ch10)中，你将定义一个真实的生数据存储（数据库）来替换这些假数据。'
- en: Create Common Functions Through the Stack
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过堆栈创建通用函数
- en: 'Similar to the data examples, the approach to building this site is exploratory.
    Often it isn’t clear what will eventually be needed, so let’s start with some
    pieces that would be common to similar sites. Providing a frontend for data usually
    requires ways to do the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据示例类似，构建此站点的方法是探索性的。通常不清楚最终需要什么，所以让我们从一些对类似站点常见的部分开始。通常情况下，提供数据前端通常需要以下操作方式：
- en: '*Get* one, some, all'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*获取*一个、一些、全部'
- en: '*Create*'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建*'
- en: '*Replace* completely'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*完全替换*'
- en: '*Modify* partially'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部分*修改*
- en: '*Delete*'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*删除*'
- en: Essentially, these are the CRUD basics from databases, although I’ve split the
    U into partial (*modify*) and complete (*replace*) functions. Maybe this distinction
    will prove unnecessary! It depends on where the data leads.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，这些是来自数据库的CRUD基础知识，尽管我已经将U分成了部分(*modify*)和完整(*replace*)函数。也许这种区别是不必要的！这取决于数据的方向。
- en: Create Fake Data
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建假数据
- en: Working top-down, you’ll duplicate some functions in all three levels. To save
    typing, [Example 8-12](#ex-8-12) introduces the top-level directory called *fake*,
    with modules providing fake data on explorers and creatures.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 自上而下地工作，你将在所有三个级别中重复一些函数。为了节省输入，[示例 8-12](#ex-8-12) 引入了名为*fake*的顶级目录，其中的模块提供了关于探险家和生物的假数据。
- en: Example 8-12\. New module fake/explorer.py
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-12\. 新模块 fake/explorer.py
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The creature setup in [Example 8-13](#ex-8-13) is similar.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 8-13](#ex-8-13)中的生物设置是类似的。
- en: Example 8-13\. New module fake/creature.py
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-13\. 新模块 fake/creature.py
- en: '[PRE14]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-184
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Yes, the module functions are almost identical. They’ll change later, when a
    real database arrives and must handle the differing fields of the two models.
    Also, you’re using separate functions here, rather than defining a `Fake` class
    or abstract class. A module has its own namespace, so it’s an equivalent way of
    bundling data and functions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，模块函数几乎是相同的。当真正的数据库到来并且必须处理两个模型的不同字段时，它们将会改变。此外，你在这里使用的是单独的函数，而不是定义一个`Fake`类或抽象类。模块有自己的命名空间，因此它是捆绑数据和函数的等效方式。
- en: 'Now let’s modify the web functions from Examples [8-12](#ex-8-12) and [8-13](#ex-8-13).
    Preparing to build out the later layers (Service and Data), import the fake data
    provider that was just defined, but name it `service` here: `import fake.explorer
    as service` ([Example 8-14](#ex-8-14)). In [Chapter 9](ch09.html#ch09), you’ll
    do the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们修改示例 [8-12](#ex-8-12) 和 [8-13](#ex-8-13) 中的 Web 函数。在构建稍后的层（服务和数据）时，导入刚刚定义的虚假数据提供程序，但在这里将其命名为
    `service`：`import fake.explorer as service`（[示例 8-14](#ex-8-14)）。在 [第 9 章](ch09.html#ch09)
    中，你将执行以下操作：
- en: Make a new *service/explorer.py* file.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的 *service/explorer.py* 文件。
- en: Import the fake data there.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在那里导入虚假数据。
- en: Make *web/explorer.py* import the new service module instead of the fake module.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使 *web/explorer.py* 导入新的服务模块，而不是虚假模块。
- en: In [Chapter 10](ch10.html#ch10), you’ll do the same in the Data layer. All of
    this is just adding parts and wiring them together, with as little code rework
    as possible. You don’t turn on the electricity (i.e., a live database and persistent
    data) until later in [Chapter 10](ch10.html#ch10).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 10 章](ch10.html#ch10) 中，你将在数据层做同样的事情。所有这些只是添加部分并将它们连接在一起，尽可能少地重构代码。直到稍后的
    [第 10 章](ch10.html#ch10) 才打开电（即实时数据库和持久数据）。
- en: Example 8-14\. New endpoints for web/explorer.py
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-14\. *web/explorer.py* 的新端点
- en: '[PRE15]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And now, do the same for */creature* endpoints ([Example 8-15](#ex-8-15a)).
    Yes, this is similar cut-and-paste code for now, but doing this up front simplifies
    changes later on—and there will always be changes later.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为 */creature* 终点做同样的事情（[示例 8-15](#ex-8-15a)）。是的，目前这只是类似的剪切和粘贴代码，但事先这样做简化了以后的更改——而且以后总会有更改。
- en: Example 8-15\. New endpoints for web/creature.py
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-15\. *web/creature.py* 的新端点
- en: '[PRE16]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The last time we poked at *main.py*, it was to add the subrouter for */explorer*
    URLs. Now, let’s add another for */creature* in [Example 8-16](#ex-8-15).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 上次我们修改 *main.py* 是为了添加 */explorer* URL 的子路由器。现在，让我们为 */creature* 在 [示例 8-16](#ex-8-15)
    中再添加一个。
- en: Example 8-16\. Add creature subrouter to main.py
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-16\. 在 main.py 中添加 creature 子路由器
- en: '[PRE17]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Did all of that work? If you typed or pasted everything exactly, Uvicorn should
    have restarted the application. Let’s try some manual tests.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些工作都做好了吗？如果你精确地输入或粘贴了所有内容，Uvicorn 应该已经重新启动了应用程序。让我们试试手动测试。
- en: Test!
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试！
- en: '[Chapter 12](ch12.html#ch12) will show how to use pytest to automate testing
    at various levels. Examples [8-17](#ex08-17) to [8-21](#ex08-21) perform some
    manual Web-layer tests of the explorer endpoints with HTTPie.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 12 章](ch12.html#ch12) 将展示如何使用 pytest 在各个层级自动化测试。示例 [8-17](#ex08-17) 到 [8-21](#ex08-21)
    进行了一些手动的 Web 层测试，使用 HTTPie 测试了探险者终点。'
- en: Example 8-17\. Test the Get All endpoint
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-17\. 测试获取所有终点
- en: '[PRE18]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Example 8-18\. Test the Get One endpoint
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-18\. 测试获取单个终点
- en: '[PRE19]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Example 8-19\. Test the Replace endpoint
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-19\. 测试替换终点
- en: '[PRE20]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Example 8-20\. Test the Modify endpoint
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-20\. 测试修改终点
- en: '[PRE21]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Example 8-21\. Test the Delete endpoint
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-21\. 测试删除终点
- en: '[PRE22]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can do the same for the */creature* endpoints.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 */creature* 终点，你可以做同样的事情。
- en: Using the FastAPI Automated Test Forms
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 FastAPI 自动化测试表单
- en: Besides the manual tests that I’ve used in most examples, FastAPI provides very
    nice automated test forms at the endpoints */docs* and */redocs*. They’re two
    different styles for the same information, so I’ll just show a little from the
    */docs* pages in [Figure 8-1](#fig-08-1).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 除了大多数示例中使用的手动测试外，FastAPI 还提供了 */docs* 和 */redocs* 端点非常好的自动化测试表单。它们是同样信息的两种不同样式，所以我将在
    [图 8-1](#fig-08-1) 中只展示 */docs* 页面的一点内容。
- en: '![Top docs page](assets/fapi_0801.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![顶部文档页面](assets/fapi_0801.png)'
- en: Figure 8-1\. Generated documentation page
  id: totrans-216
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-1\. 生成的文档页面
- en: 'Try the first test:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试第一个测试：
- en: Click the down-arrow to the right under the top GET `/explorer/` section. That
    will open up a large light blue form.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上方 GET `/explorer/` 部分右侧的下箭头下点击。那将打开一个大的浅蓝色表单。
- en: Click the blue Execute button on the left. You’ll see the top section of the
    results in [Figure 8-2](#fig-08-2).
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧的蓝色执行按钮。你将在 [图 8-2](#fig-08-2) 中看到结果的顶部部分。
- en: '![GET /explorer results page](assets/fapi_0802.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![GET /explorer 结果页面](assets/fapi_0802.png)'
- en: Figure 8-2\. Generated results page for GET /explorer/
  id: totrans-221
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-2\. GET /explorer/ 生成的结果页面
- en: 'In the lower “Response body” section, you’ll see the JSON returned for the
    (fake) explorer data that you’ve defined so far:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的 “响应体” 部分，你将看到到目前为止你定义的（虚假的）探险者数据返回的 JSON：
- en: '[PRE23]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Try all the others. For some (like `GET /explorer/{name}`), you’ll need to provide
    an input value. You’ll get a response for each, even though a few still do nothing
    until the database code is added. You can repeat these tests near the end of Chapters
    [9](ch09.html#ch09) and [10](ch10.html#ch10) to ensure that no data pipelines
    were punctured during these code changes.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试所有其他事情。 对于一些（例如`GET /explorer/{name}`），您需要提供一个输入值。 您将为每个请求得到一个响应，尽管在添加数据库代码之前，有些仍然无效。
    您可以在第[9](ch09.html#ch09)章和第[10](ch10.html#ch10)章结束时重复这些测试，以确保在这些代码更改期间未损坏数据管道。
- en: Talking to the Service and Data Layers
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与服务层和数据层交流
- en: 'Whenever a function in the Web layer needs data that is managed by the Data
    layer, that function should ask the Service layer to be an intermediary. This
    requires more code and may seem unnecessary, but it’s a good idea:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 每当Web层中的函数需要由数据层管理的数据时，该函数应请求服务层作为中介。 这需要更多的代码，可能看起来是不必要的，但这是个好主意：
- en: As the label on the jar says, the Web layer deals with the web, and the Data
    layer deals with external data stores and services. It’s much safer to keep their
    respective details completely separate.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像罐子上的标签所说，Web层处理Web，数据层处理外部数据存储和服务。 完全将它们各自的详细信息保持分开，这样更安全。
- en: The layers can be tested independently. Separation of layer mechanisms allows
    this.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各层可以独立测试。 层次机制的分离允许此操作。
- en: Note
  id: totrans-229
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For a very small site, you could skip the Service layer if it doesn’t add any
    value. [Chapter 9](ch09.html#ch09) initially defines service functions that do
    little more than pass requests and responses between the Web and Data layers.
    At least keep the Web and Data layers separate, though.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非常小的站点，如果没有增加任何价值，可以跳过服务层。 [第9章](ch09.html#ch09) 最初定义了几乎只传递请求和响应的服务函数，位于Web和数据层之间。
    至少保持Web和数据层分离。
- en: 'What does that Service layer function do? You’ll see in the next chapter. Hint:
    it talks to the Data layer, but in a hushed voice so the Web layer doesn’t know
    exactly what it’s saying. But it also defines any specific business logic, such
    as interactions between resources. Mainly, the Web and Data layers should not
    care what’s going on in there. (The Service layer is a Secret Service.)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 服务层函数做什么？ 您将在下一章中看到。 提示：它与数据层通信，但声音很低，以便Web层不知道确切内容。 它还定义了任何特定的业务逻辑，例如资源之间的交互。
    主要是，Web和数据层不应关心其中发生的事情。（服务层是特工机构。）
- en: Pagination and Sorting
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分页和排序
- en: 'In web interfaces, when returning many or all things with URL patterns like
    `GET` *`/resource`*, you often want to request the lookup and return of the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web界面中，当使用像`GET` *`/resource`*这样的URL模式返回许多或所有内容时，通常希望请求查找并返回以下内容：
- en: Only one thing
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有一件事
- en: Possibly many things
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能很多事情
- en: All things
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有事物
- en: 'How do you get our well-meaning but extremely literal-minded computer to do
    these things? Well, for the first case, the RESTful pattern that I mentioned earlier
    is to include the resource’s ID in the URL path. When getting multiple resources,
    we may want to see the results in a particular order:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如何让我们那位心地善良但又极度直接的计算机做这些事情？ 对于第一种情况，我之前提到的RESTful模式是在URL路径中包含资源的ID。 当获取多个资源时，我们可能希望按特定顺序查看结果：
- en: Sort
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 排序
- en: Order all the results, even if you get only a set of them at a time.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 排列所有的结果，即使您一次只得到一组结果。
- en: Paginate
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 分页
- en: Return only some results at a time, respecting any sorting.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 仅返回部分结果，并遵守任何排序。
- en: 'In each case, a group of user-specified parameters indicates what you want.
    It’s common to provide these as query parameters. Here are some examples:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，一组用户指定的参数表示您想要的内容。 常见的做法是将这些参数提供为查询参数。 以下是一些示例：
- en: Sort
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 排序
- en: '`GET` `/explorer?sort=country`: Get all explorers, sorted by country code.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET` `/explorer?sort=country`：按国家代码排序获取所有探险者。'
- en: Paginate
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 分页
- en: '`GET` `/explorer?offset=10&size=10`: Return (in this case, unsorted) explorers
    in places 10 through 19 of the whole list.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET` `/explorer?offset=10&size=10`：返回（在这种情况下，未排序的）整个列表中第10到第19个位置的探险者。'
- en: Both
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 两者
- en: '`GET` `/explorer?sort=country&offset=10&size=10`'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET` `/explorer?sort=country&offset=10&size=10`'
- en: 'Although you could specify these as individual query parameters, FastAPI’s
    dependency injection can help:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您可以将这些指定为单独的查询参数，但FastAPI的依赖注入可以提供帮助：
- en: Define the sort and paginate parameters as a Pydantic model.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将排序和分页参数定义为Pydantic模型。
- en: Provide the parameters model to the `get_all()` path function with the `Depends`
    feature in the path function arguments.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将参数模型提供给带有路径函数参数中的`Depends`功能的`get_all()`路径函数。
- en: Where should the sorting and pagination occur? At first, it may seem simplest
    for the database queries to pass full results up to the Web layer, and use Python
    to carve up the data there. But that isn’t very efficient. These tasks usually
    fit best in the Data layer, because databases are good at those things. I’ll finally
    get around to some code for these in [Chapter 17](ch17.html#ch17), which has more
    database tidbits beyond those in [Chapter 10](ch10.html#ch10).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 排序和分页应该发生在哪里？ 起初，将完整结果传递到Web层，并在那里使用Python来划分数据似乎最简单。 但那不太高效。 这些任务通常最适合在数据层中进行，因为数据库擅长处理这些事情。
    我最终将在[第17章](ch17.html#ch17)中提供一些关于这些任务的代码，该章节除了[第10章](ch10.html#ch10)中介绍的内容之外，还有更多数据库方面的小提示。
- en: Review
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾
- en: This chapter filled out more details from [Chapter 3](ch03.html#ch03) and others.
    It began the process of making a full site for information on imaginary creatures
    and their explorers. Starting with the Web layer, you defined endpoints with FastAPI
    path decorators and path functions. The path functions gather request data from
    wherever they live in the HTTP request bytes. Model data is automatically checked
    and validated by Pydantic. Path functions generally pass arguments to corresponding
    service functions, which are coming in the next chapter.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 本章更详细地填补了[第三章](ch03.html#ch03)和其他章节的细节。 它开始了创建一个完整站点的过程，用于提供有关虚构生物及其探险者的信息。
    从Web层开始，您使用FastAPI路径装饰器和路径函数定义了端点。 路径函数从HTTP请求字节的任何位置收集请求数据。 模型数据由Pydantic自动检查和验证。
    路径函数通常将参数传递给相应的服务函数，这将在下一章中介绍。
