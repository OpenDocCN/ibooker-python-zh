- en: Chapter 4\. 20 Asyncio Libraries You Aren’t Using (But…Oh, Never Mind)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。20个你没有使用的Asyncio库（但...哦，没关系）
- en: In this chapter, we look at case studies using the new Python features for async
    programming. We’ll be making use of several third-party libraries, as you will
    in your own projects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到使用新的Python异步编程功能的案例研究。我们将利用几个第三方库，就像你在自己的项目中会做的那样。
- en: The title of this chapter is a play on the title of a previous book I wrote
    called [*20 Python Libraries You Aren’t Using (But Should)*](https://oreil.ly/HLsvb)
    (O’Reilly). Many of those libraries will also be useful in your `asyncio`-based
    applications, but this chapter focuses on libraries that have been designed specifically
    for the new async features in Python.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的标题是我之前写过的一本书的标题的变形，那本书叫[*20 Python Libraries You Aren’t Using (But Should)*](https://oreil.ly/HLsvb)（O’Reilly）。其中许多库在您的`asyncio`应用程序中也会很有用，但本章重点介绍专为Python新异步特性设计的库。
- en: It is difficult to present `asyncio`-based code in short snippets. As you have
    seen in all the previous code samples in the book, I’ve tried to make each example
    a complete, runnable program, because application lifetime management is a core
    consideration for using async programming correctly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在短代码片段中展示基于`asyncio`的代码是困难的。正如您在本书中所有先前的代码示例中看到的那样，我尝试使每个示例成为一个完整可运行的程序，因为应用程序生命周期管理是正确使用异步编程的核心考虑因素。
- en: For this reason, most of the case studies in this chapter will be somewhat larger,
    in terms of lines of code, than is usual for such a book. My goal in using this
    approach is to make the case studies more useful by giving you a “whole view”
    of an async program rather than leaving you to figure out how detached fragments
    might fit together.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章的大多数案例研究在代码行数上都比这类书籍通常的要大。我采用这种方法的目标是通过给出“整体视图”来使案例研究更有用，而不是让你去揣摩如何将独立的片段组合在一起。
- en: Note
  id: totrans-5
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Some of the code samples in this chapter compromise on style in order to save
    space. I like PEP8 as much as the next Pythonista, but practicality beats purity!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的一些代码示例在样式上可能会妥协以节省空间。我像其他Pythonista一样喜欢PEP8，但实用性胜过纯粹！
- en: Streams (Standard Library)
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流（标准库）
- en: Before looking at third-party libraries, let’s begin with the standard library.
    The [streams API](https://oreil.ly/mnMZD) is the high-level interface offered
    for async socket programming, and as the following case study will show, it’s
    pretty easy to use. However, application design remains complex simply because
    of the nature of the domain.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在看第三方库之前，让我们从标准库开始。[流API](https://oreil.ly/mnMZD)是用于异步套接字编程的高级接口，正如下面的案例研究所示，它非常容易使用。然而，由于领域的本质，应用设计仍然复杂。
- en: The following case study shows an implementation of a message broker, with an
    initial naive design followed by a more considered design. Neither should be considered
    production-ready; my goal is to help you think about the various aspects of concurrent
    network programming that need to be taken into account when designing such applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的案例研究展示了消息代理的实现，首先是初始的朴素设计，然后是更加深思熟虑的设计。无论哪种都不应被视为生产就绪；我的目标是帮助您考虑在设计此类应用程序时需要考虑的并发网络编程的各个方面。
- en: 'Case Study: A Message Queue'
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究：消息队列
- en: 'A *message queue service* is a backend application that receives connections
    from other applications and passes messages between those connected services,
    often referred to as *publishers* and *subscribers*. Subscribers typically listen
    to specific channels for messages, and usually it is possible to configure the
    message distribution in different channels in two ways: messages can be distributed
    to all subscribers on a channel (*pub-sub*), or a different message can go to
    each subscriber one at a time (*point-to-point*).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*消息队列服务*是一个后端应用程序，它接收来自其他应用程序的连接，并在这些连接的服务之间传递消息，通常称为*发布者*和*订阅者*。订阅者通常监听特定频道以获取消息，通常可以配置不同频道中消息的分发方式有两种：消息可以发送到频道上的所有订阅者（*发布-订阅*），或者每个订阅者一次发送一个不同的消息（*点对点*）。'
- en: 'Recently, I worked on a project that involved using [ActiveMQ](https://oreil.ly/yiaK0)
    as a message broker for microservices intercommunication. At a basic level, such
    a broker (server):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，我参与了一个项目，使用[ActiveMQ](https://oreil.ly/yiaK0)作为微服务间通信的消息代理。在基本层面上，这样的代理（服务器）：
- en: Maintains persistent socket connections to multiple clients
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护到多个客户端的持久套接字连接
- en: Receives messages from clients with a target *channel name*
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从客户端接收带有目标*频道名称*的消息
- en: Delivers those messages to all *other* clients subscribed to that same channel
    name
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这些消息发送给所有订阅了相同频道名称的*其他*客户端
- en: 'I recall wondering how hard it might be to create such an application. As an
    added touch, ActiveMQ can perform both models of message distribution, and the
    two models are generally differentiated by the channel name:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得曾经想过创建这样的应用有多难。作为一个额外的补充，ActiveMQ 可以执行消息分发的两种模式，并且这两种模式通常通过频道名称区分：
- en: Channel names with the prefix `/topic` (e.g., `/topic/customer/registration`)
    are managed with the [pub-sub](https://oreil.ly/y6cYr) pattern, where all channel
    subscribers get all messages.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有前缀 `/topic`（例如，`/topic/customer/registration`）的频道名称使用[发布-订阅](https://oreil.ly/y6cYr)模式管理，其中所有频道订阅者都会收到所有消息。
- en: 'Channel names with the prefix `/queue` are handled with the [point-to-point](http://bit.ly/2CeNbxr)
    model, in which messages on a channel are distributed between channel subscribers
    in a round-robin fashion: each subscriber gets a unique message.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有前缀 `/queue` 的频道名称采用[点对点](http://bit.ly/2CeNbxr)模式处理，在该模式中，频道上的消息以循环方式分配给频道订阅者：每个订阅者都收到一个唯一的消息。
- en: 'In our case study, we will build a toy message broker with these basic features.
    The first issue we must address is that TCP is not a message-based protocol: we
    just get streams of bytes on the wire. We need to create our own protocol for
    the structure of messages, and the simplest protocol is to prefix each message
    with a size header, followed by a message payload of that size. The utility library
    in [Example 4-1](#msgproto) provides *read* and *write* capabilities for such
    messages.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例研究中，我们将构建一个具有这些基本特征的玩具消息代理。我们必须首先解决的问题是 TCP 不是一种消息传递协议：我们只是在网络上传输字节流。我们需要为消息结构创建自己的协议，最简单的协议是为每个消息前缀加上一个大小标头，然后是该大小的消息有效载荷。示例
    [4-1](#msgproto) 中的实用程序库提供了这些消息的 *读* 和 *写* 功能。
- en: 'Example 4-1\. Message protocol: read and write'
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-1\. 消息协议：读和写
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO1-1)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO1-1)'
- en: Get the first 4 bytes. This is the size prefix.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 获取前 4 个字节。这是大小前缀。
- en: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO1-2)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO1-2)'
- en: Those 4 bytes must be converted into an integer.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 4 个字节必须转换为整数。
- en: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO1-3)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO1-3)'
- en: Now we know the payload size, so we read that off the stream.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了有效载荷的大小，所以我们从流中读取它。
- en: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO1-4)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO1-4)'
- en: '*Write* is the inverse of *read*: first we send the length of the data, encoded
    as 4 bytes, and thereafter the data.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*写* 是 *读* 的反义词：首先我们发送数据的长度，编码为 4 个字节，然后发送数据。'
- en: Now that we have a rudimentary message protocol, we can focus on the message
    broker application in [Example 4-2](#msgserver).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个基本的消息协议，我们可以专注于 [示例 4-2](#msgserver) 中的消息代理应用。
- en: Example 4-2\. A 40-line prototype server
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-2\. 一个 40 行的原型服务器
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO2-1)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO2-1)'
- en: Imports from our *msgproto.py* module.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的 *msgproto.py* 模块导入。
- en: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO2-2)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO2-2)'
- en: A global collection of currently active subscribers. Every time a client connects,
    they must first send a channel name they’re subscribing to. A deque will hold
    all the subscribers for a particular channel.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当前活动订阅者的全局集合。每次客户端连接时，他们必须首先发送一个他们订阅的频道名称。一个双端队列将保存特定频道的所有订阅者。
- en: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO2-3)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO2-3)'
- en: The `client()` coroutine function will produce a long-lived coroutine for each
    new connection. Think of it as a callback for the TCP server started in `main()`.
    On this line, I’ve shown how the host and port of the remote peer can be obtained,
    for example, for logging.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`client()` 协程函数将为每个新连接生成一个长期运行的协程。将其视为在 `main()` 中启动的 TCP 服务器的回调函数。在这一行中，我展示了如何获取远程对等体的主机和端口，例如，用于日志记录。'
- en: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO2-4)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO2-4)'
- en: 'Our protocol for clients is the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对客户端的协议如下：
- en: On first connect, a client *must* send a message containing the channel to subscribe
    to (here, `subscribe_chan`).
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在首次连接时，客户端*必须*发送包含要订阅的频道的消息（这里是`subscribe_chan`）。
- en: Thereafter, for the life of the connection, a client sends a message to a channel
    by first sending a message containing the destination channel name, followed by
    a message containing the data. Our broker will send such data messages to every
    client subscribed to that channel name.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，在连接的整个生命周期中，客户端通过首先发送包含目标频道名称的消息，然后是包含数据的消息，向频道发送消息。我们的代理将这些数据消息发送给订阅该频道名称的每个客户端。
- en: '[![5](assets/5.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO2-5)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO2-5)'
- en: Add the `StreamWriter` instance to the global collection of subscribers.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 将`StreamWriter`实例添加到全局订阅者集合中。
- en: '[![6](assets/6.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO2-6)'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO2-6)'
- en: An infinite loop, waiting for data from this client. The first message from
    a client must be the destination channel name.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个无限循环，等待来自该客户端的数据。客户端的第一条消息必须是目标频道名称。
- en: '[![7](assets/7.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO2-7)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO2-7)'
- en: Next comes the actual data to distribute to the channel.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是要分发到频道的实际数据。
- en: '[![8](assets/8.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO2-8)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO2-8)'
- en: Get the deque of subscribers on the target channel.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 获取目标频道的订阅者双端队列。
- en: '[![9](assets/9.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO2-9)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO2-9)'
- en: 'Some special handling if the channel name begins with the magic word `/queue`:
    in this case, we send the data to *only one* of the subscribers, not all of them.
    This can be used for sharing work between a bunch of workers, rather than the
    usual pub-sub notification scheme, where all subscribers on a channel get all
    the messages.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果频道名称以魔法词`/queue`开头，则会进行一些特殊处理：在这种情况下，我们只向*一个*订阅者发送数据，而不是所有订阅者。这可用于在一群工作者之间共享工作，而不是通常的发布-订阅通知方案，在该方案中频道上的所有订阅者都会收到所有消息。
- en: '[![10](assets/10.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO2-10)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](assets/10.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO2-10)'
- en: 'Here is why we use a deque and not a list: rotation of the deque is how we
    keep track of which client is next in line for `/queue` distribution. This seems
    expensive until you realize that a single deque rotation is an O(1) operation.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以使用双端队列而不是列表，是因为双端队列的旋转是我们用来跟踪哪个客户端下一个应接收`/queue`分发的方式。这看起来很昂贵，直到你意识到单个双端队列旋转是O(1)操作。
- en: '[![11](assets/11.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO2-11)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[![11](assets/11.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO2-11)'
- en: Target only whichever client is first; this changes after every rotation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 仅针对第一个客户端目标；这在每次旋转后会改变。
- en: '[![12](assets/12.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO2-12)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[![12](assets/12.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO2-12)'
- en: Create a list of coroutines for sending the message to each writer, and then
    unpack these into `gather()` so we can wait for all of the sending to complete.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个用于向每个写入者发送消息的协程列表，然后将它们解包到`gather()`中，以便等待所有发送完成。
- en: 'This line is a bad flaw in our program, but it may not be obvious why: though
    it may be true that all of the sending to each subscriber will happen concurrently,
    what happens if we have one very slow client? In this case, the `gather()` will
    finish only when the slowest subscriber has received its data. We can’t receive
    any more data from the sending client until all these `send_msg()` coroutines
    finish. This slows all message distribution to the speed of the slowest subscriber.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码是我们程序中的一个严重缺陷，但可能不明显原因是：尽管每个订阅者的发送可能会并发进行，但如果我们有一个非常慢的客户端会发生什么？在这种情况下，`gather()`只有在最慢的订阅者收到其数据后才会完成。在所有这些`send_msg()`协程完成之前，我们无法从发送客户端接收任何更多数据。这将导致所有消息分发速度都受制于最慢的订阅者速度。
- en: '[![13](assets/13.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO2-13)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[![13](assets/13.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO2-13)'
- en: When leaving the `client()` coroutine, we make sure to remove ourselves from
    the global `SUBSCRIBERS` collection. Unfortunately, this is an O(*n*) operation,
    which can be a little expensive for very large *n*. A different data structure
    would fix this, but for now we console ourselves with the knowledge that connections
    are intended to be long-lived—thus, there should be few disconnection events—and
    *n* is unlikely to be very large (say ~10,000 as a rough order-of-magnitude estimate),
    and this code is at least easy to understand.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在离开`client()`协程时，我们确保将自己从全局的`SUBSCRIBERS`集合中移除。不幸的是，这是一个O(*n*)操作，对于非常大的*n*来说可能有点昂贵。不同的数据结构可以解决这个问题，但目前我们只能安慰自己的是连接应该是长期存在的——因此，应该很少有断开连接的事件——并且*n*不太可能非常大（例如，粗略估计为~10,000），而且这段代码至少很容易理解。
- en: 'So that’s our server; now we need clients, and then we can show some output.
    For demonstration purposes, I’ll make two kinds of clients: a *sender* and a *listener*.
    The server doesn’t differentiate; all clients are the same. The distinction between
    sender and listener behavior is only for educational purposes. [Example 4-3](#listener)
    shows the code for the listener application.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这就是我们的服务器；现在我们需要客户端，然后我们可以展示一些输出。为了演示目的，我将制作两种类型的客户端：一个*发送者*和一个*监听者*。服务器不区分；所有客户端都是相同的。发送者和监听者行为之间的区别仅用于教育目的。[Example 4-3](#listener)显示了监听应用程序的代码。
- en: 'Example 4-3\. Listener: a toolkit for listening for messages on our message
    broker'
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 4-3\. 监听器：用于监听消息代理上的消息的工具包
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO3-1)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO3-1)'
- en: The `uuid` standard library module is a convenient way of creating an “identity”
    for this listener. If you start up multiple instances, each will have its own
    identity, and you’ll be able to track what is happening in the logs.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`uuid`标准库模块是创建此监听器的“身份”的方便方式。如果启动多个实例，则每个实例都将有自己的身份，并且您将能够跟踪日志中发生的情况。'
- en: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO3-2)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO3-2)'
- en: Open a connection to the server.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 打开到服务器的连接。
- en: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO3-3)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO3-3)'
- en: The channel to subscribe to is an input parameter, captured in `args.listen`.
    Encode it into bytes before sending.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅的频道是一个输入参数，存储在`args.listen`中。在发送之前将其编码为字节。
- en: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO3-4)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO3-4)'
- en: By our protocol rules (as discussed in the broker code analysis previously),
    the first thing to do after connecting is to send the channel name to subscribe
    to.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的协议规则（如前文所述的代理程序代码分析），连接后要做的第一件事是发送要订阅的频道名称。
- en: '[![5](assets/5.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO3-5)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO3-5)'
- en: This loop does nothing else but wait for data to appear on the socket.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环除了等待套接字上出现数据之外什么也不做。
- en: '[![6](assets/6.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO3-6)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO3-6)'
- en: The command-line arguments for this program make it easy to point to a host,
    a port, and a channel name to listen to.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的命令行参数使得指定主机、端口和要监听的频道名称变得很容易。
- en: The code for the other client, the sender program shown in [Example 4-4](#sender),
    is similar in structure to the listener module.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个客户端的代码，也就是在[Example 4-4](#sender)中展示的发送程序，结构类似于监听器模块。
- en: 'Example 4-4\. Sender: a toolkit for sending data to our message broker'
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 4-4\. 发送者：用于向消息代理发送数据的工具包
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO4-1)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO4-1)'
- en: As with the listener, claim an identity.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与监听器一样，要声明一个身份。
- en: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO4-2)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO4-2)'
- en: Reach out and make a connection.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 联系并建立连接。
- en: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO4-3)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO4-3)'
- en: According to our protocol rules, the first thing to do after connecting to the
    server is to give the name of the channel to subscribe to; however, since we are
    a sender, we don’t really care about subscribing to any channels. Nevertheless,
    the protocol requires it, so just provide a null channel to subscribe to (we won’t
    actually listen for anything).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的协议规则，连接到服务器后的第一件事是提供要订阅的频道的名称；然而，由于我们是发送者，我们并不真的关心订阅任何频道。尽管如此，协议要求这样做，所以只需提供一个空频道来订阅（我们实际上不会监听任何内容）。
- en: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO4-4)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO4-4)'
- en: Send the channel to subscribe to.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 发送要订阅的频道。
- en: '[![5](assets/5.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO4-5)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO4-5)'
- en: The command-line parameter `args.channel` provides the channel *to which* we
    want to send messages. It must be converted to bytes first before sending.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行参数`args.channel`提供我们想要发送消息的频道。在发送之前，它必须先转换为字节。
- en: '[![6](assets/6.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO4-6)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO4-6)'
- en: Using `itertools.count()` is like a `while True` loop, except that we get an
    iteration variable to use. We use this in the debugging messages since it makes
    it a bit easier to track which message got sent from where.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`itertools.count()`就像使用`while True`循环一样，只是我们得到一个迭代变量来使用。我们在调试消息中使用它，因为这样可以更容易地跟踪从哪里发送了哪个消息。
- en: '[![7](assets/7.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO4-7)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO4-7)'
- en: The delay between sent messages is an input parameter, `args.interval`. The
    next line generates the message payload. It’s either a bytestring of specified
    size (`args.size`) or a descriptive message. This flexibility is just for testing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 发送消息之间的延迟是一个输入参数，即`args.interval`。下一行生成消息负载。它可以是指定大小的字节串（`args.size`），也可以是描述性消息。这种灵活性只是为了测试。
- en: '[![8](assets/8.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO4-8)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO4-8)'
- en: 'Note that *two* messages are sent here: the first is the destination channel
    name, and the second is the payload.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意这里发送了*两条*消息：第一条是目标频道名称，第二条是负载。
- en: '[![9](assets/9.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO4-9)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO4-9)'
- en: 'As with the listener, there are a bunch of command-line options for tweaking
    the sender: `channel` determines the target channel to send to, while `interval`
    controls the delay between sends. The `size` parameter controls the size of each
    message payload.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与监听器一样，有一堆命令行选项可以调整发送者：`channel`确定要发送到的目标频道，而`interval`控制发送之间的延迟。`size`参数控制每个消息负载的大小。
- en: We now have a broker, a listener, and a sender; it’s time to see some output.
    To produce the following code snippets, I started up the server, then two listeners,
    and then a sender. Then, after a few messages had been sent, I stopped the server
    with Ctrl-C. The server output is shown in [Example 4-5](#brokeoutput), the sender
    output in [Example 4-6](#senderoutput), and the listener output in Examples [4-7](#listeneroutput)
    and [4-8](#listener2output).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个代理、一个监听器和一个发送者；是时候看到一些输出了。为了产生以下代码片段，我启动了服务器，然后启动了两个监听器，然后启动了一个发送者。然后，在发送了几条消息后，我用Ctrl-C停止了服务器。服务器输出显示在[示例 4-5](#brokeoutput)中，发送者输出显示在[示例 4-6](#senderoutput)中，监听器输出显示在示例[4-7](#listeneroutput)和[4-8](#listener2output)中。
- en: Example 4-5\. Message broker (server) output
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-5\. 消息代理（服务器）输出
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Example 4-6\. Sender (client) output
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-6\. 发送者（客户端）输出
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Example 4-7\. Listener 1 (client) output
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-7\. 监听器 1（客户端）输出
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Example 4-8\. Listener 2 (client) output
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-8\. 监听器 2（客户端）输出
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our toy message broker works. The code is also pretty easy to understand, given
    such a complex problem domain, but unfortunately, the design of the broker code
    itself is problematic.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的玩具消息代理可以工作了。考虑到如此复杂的问题域，代码也相当容易理解，但不幸的是，代理代码本身的设计存在问题。
- en: The problem is that, for a particular client, we send messages to subscribers
    in the same coroutine as where new messages are received. This means that if any
    subscriber is slow to consume what we’re sending, it might take a long time for
    that `await gather(...)` line in [Example 4-2](#msgserver) to complete, and we
    cannot receive and process more messages while we wait.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某个特定的客户端来说，我们在同一个协程中发送消息给订阅者，就像接收新消息的协程一样。这意味着如果有任何一个订阅者消费速度慢，那么在 [示例 4-2](#msgserver)
    中的`await gather(...)`行可能需要很长时间才能完成，而在等待期间我们无法接收和处理更多消息。
- en: Instead, we need to decouple the receiving of messages from the sending of messages.
    In the next case study, we refactor our code to do exactly that.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们需要将消息接收与消息发送解耦。在下一个案例研究中，我们将重构我们的代码以实现这一点。
- en: 'Case Study: Improving the Message Queue'
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究：改进消息队列
- en: In this case study, we improve the design of our toy message broker. The listener
    and sender programs remain as is. The specific improvement in the new broker design
    is to decouple sending and receiving messages; this will resolve the problem where
    a slow subscriber would also slow down receiving new messages, as discussed in
    the previous section. The new code, shown in [Example 4-9](#msgserverbetter),
    is a bit longer but not terribly so.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例研究中，我们改进了我们的玩具消息代理的设计。监听器和发送程序保持不变。在新代理设计中的具体改进是解耦发送和接收消息；这将解决慢订阅者导致新消息接收缓慢的问题，正如前一节所讨论的。新代码显示在
    [示例 4-9](#msgserverbetter) 中，代码长度略长但不是特别多。
- en: 'Example 4-9\. Message broker: improved design'
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-9\. 消息代理：改进的设计
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-1)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-1)'
- en: 'In the previous implementation, there were only `SUBSCRIBERS`; now there are
    `SEND_QUEUES` and `CHAN_QUEUES` as global collections. This is a consequence of
    completely decoupling the *receiving* and *sending* of data. `SEND_QUEUES` has
    one queue entry for each client connection: all data that must be sent to that
    client must be placed onto that queue. (If you peek ahead, the `send_client()`
    coroutine will pull data off `SEND_QUEUES` and send it.)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的实现中，只有`SUBSCRIBERS`；现在有`SEND_QUEUES`和`CHAN_QUEUES`作为全局集合。这是完全解耦*接收*和*发送*数据的结果。`SEND_QUEUES`为每个客户端连接保存一个队列条目：所有必须发送到该客户端的数据都必须放入该队列中。（如果您提前查看，`send_client()`协程将从`SEND_QUEUES`中拉取数据并发送。）
- en: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-2)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-2)'
- en: 'Up until this point in the `client()` coroutine function, the code is the same
    as in the simple server: the subscribed channel name is received, and we add the
    `StreamWriter` instance for the new client to the global `SUBSCRIBERS` collection.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `client()` 协程函数中直到此刻，代码与简单服务器中的代码相同：接收订阅的通道名称，并将新客户端的`StreamWriter`实例添加到全局的`SUBSCRIBERS`集合中。
- en: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-3)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-3)'
- en: 'This is new: we create a long-lived task that will do all the sending of data
    to this client. The task will run independently as a separate coroutine and will
    pull messages off the supplied queue, `SEND_QUEUES[writer]`, for sending.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新的内容：我们创建了一个长期任务，将所有数据发送给这个客户端。该任务将作为一个独立的协程独立运行，并从提供的队列`SEND_QUEUES[writer]`中拉取消息进行发送。
- en: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-4)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-4)'
- en: 'Now we’re inside the loop where we receive data. Remember that we always receive
    two messages: one for the destination channel name, and one for the data. We’re
    going to create a new, dedicated `Queue` for every destination channel, and that’s
    what `CHAN_QUEUES` is for: when any client wants to push data to a channel, we’re
    going to put that data onto the appropriate queue and then go immediately back
    to listening for more data. This approach decouples the distribution of messages
    from the receiving of messages from this client.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们进入接收数据的循环中。请记住我们总是接收两条消息：一条是目标通道名称，另一条是数据。我们将为每个目标通道创建一个新的专用`Queue`，这就是`CHAN_QUEUES`的作用：当任何客户端想要向通道推送数据时，我们将该数据放入适当的队列中，然后立即返回以继续监听更多数据。这种方法将消息的分发与从该客户端接收消息的过程解耦。
- en: '[![5](assets/5.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-5)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-5)'
- en: If there isn’t already a queue for the target channel, make one.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标频道还没有队列，就创建一个。
- en: '[![6](assets/6.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-6)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-6)'
- en: Create a dedicated and long-lived task for that channel. The coroutine `chan_sender()`
    will be responsible for taking data off the channel queue and distributing that
    data to subscribers.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为该频道创建一个专用且长期存在的任务。协程`chan_sender()` 将负责从频道队列中取出数据并将其分发给订阅者。
- en: '[![7](assets/7.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-7)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-7)'
- en: Place the newly received data onto the specific channel’s queue. If the queue
    fills up, we’ll wait here until there is space for the new data. Waiting here
    means we won’t be reading any new data off the socket, which means that the client
    will have to wait on sending new data into the socket on its side. This isn’t
    necessarily a bad thing, since it communicates so-called *back-pressure* to this
    client. (Alternatively, you could choose to drop messages here if the use case
    is OK with that.)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 把新接收的数据放到特定频道的队列中。如果队列已满，我们会在此等待，直到有空间来存放新数据。在此等待意味着我们不会从套接字读取任何新数据，这意味着客户端必须等待在其端口将新数据发送到套接字。这不一定是件坏事，因为它向客户端传达所谓的*反压*。（或者，如果使用场景可以接受的话，你也可以选择在此处丢弃消息。）
- en: '[![8](assets/8.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-8)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-8)'
- en: When the connection is closed, it’s time to clean up. The long-lived task we
    created for sending data to this client, `send_task`, can be shut down by placing
    `None` onto its queue, `SEND_QUEUES[writer]` (check the code for `send_client()`).
    It’s important to use a value on the queue, rather than outright cancellation,
    because there may already be data on that queue and we want that data to be sent
    out before `send_client()` is ended.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接关闭时，是时候进行清理了。我们为向此客户端发送数据创建的长期任务`send_task`可以通过将`None`放入其队列`SEND_QUEUES[writer]`（请检查`send_client()`的代码）来关闭。重要的是要在队列上使用一个值，而不是直接取消，因为可能已经有数据在该队列上，我们希望在结束`send_client()`之前发送出这些数据。
- en: '[![9](assets/9.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-9)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-9)'
- en: Wait for that sender task to finish…
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 等待该发送任务完成……
- en: '[![10](assets/10.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-10)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](assets/10.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-10)'
- en: …then remove the entry in the `SEND_QUEUES` collection (and in the next line,
    we also remove the `sock` from the `SUBSCRIBERS` collection as before).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后从`SEND_QUEUES`集合中移除条目（接着在下一行，我们也像之前那样从`SUBSCRIBERS`集合中移除`sock`）。
- en: '[![11](assets/11.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-11)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[![11](assets/11.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-11)'
- en: 'The `send_client()` coroutine function is very nearly a textbook example of
    pulling work off a queue. Note how the coroutine will exit only if `None` is placed
    onto the queue. Note also how we suppress `CancelledError` *inside* the loop:
    this is because we want this task to be closed only by receiving a `None` on the
    queue. This way, all pending data on the queue can be sent out before shutdown.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`send_client()` 协程函数几乎是从队列中获取工作的教科书式示例。请注意协程只有在将`None`放入队列时才会退出。还请注意我们在循环内部抑制了`CancelledError`：这是因为我们希望只有在队列上接收到`None`时才关闭此任务。这样，在关闭之前可以发送队列上的所有待处理数据。'
- en: '[![12](assets/12.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-12)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[![12](assets/12.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-12)'
- en: '`chan_sender()` is the distribution logic for a channel: it sends data from
    a dedicated channel `Queue` instance to all the subscribers on that channel. But
    what happens if there are no subscribers for this channel yet? We’ll just wait
    a bit and try again. (Note, though, that the queue for this channel, `CHAN_QUEUES[name]`,
    will keep filling up.)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`chan_sender()` 是频道的分发逻辑：它从专用频道的`Queue`实例向所有订阅者发送数据。但是如果该频道还没有订阅者会发生什么呢？我们会稍等一会儿然后再尝试。（请注意，该频道的队列`CHAN_QUEUES[name]`会持续填充。）'
- en: '[![13](assets/13.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-13)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[![13](assets/13.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-13)'
- en: 'As in our previous broker implementation, we do something special for channels
    whose name begins with `/queue`: we rotate the deque and send only to the first
    entry. This acts like a crude load-balancing system because each subscriber gets
    different messages off the same queue. For all other channels, all subscribers
    get all the messages.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们先前的代理实现类似，对于名称以`/queue`开头的通道，我们会旋转deque并仅发送到第一个条目。这就像一个简单的负载平衡系统，因为每个订阅者从同一个队列中获取不同的消息。对于所有其他通道，所有订阅者都会收到所有消息。
- en: '[![14](assets/14.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-14)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[![14](assets/14.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-14)'
- en: We’ll wait here for data on the queue, and exit if `None` is received. Currently,
    this isn’t triggered anywhere (so these `chan_sender()` coroutines live forever),
    but if logic were added to clean up these channel tasks after, say, some period
    of inactivity, that’s how it would be done.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在此等待队列的数据，并在接收到`None`时退出。目前没有任何地方触发这个行为（所以这些`chan_sender()`协程将永远存在），但如果在某段不活跃的时间后增加逻辑来清理这些通道任务，那就是如何完成的。
- en: '[![15](assets/15.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-15)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[![15](assets/15.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO5-15)'
- en: 'Data has been received, so it’s time to send to subscribers. We do not do the
    sending here: instead, we place the data onto each subscriber’s own send queue.
    This decoupling is necessary to make sure that a slow subscriber doesn’t slow
    down anyone else receiving data. And furthermore, if the subscriber is so slow
    that their send queue fills up, we don’t put that data on their queue; i.e., it
    is lost.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 数据已接收，所以现在是发送给订阅者的时候了。我们不在这里发送：相反，我们将数据放置在每个订阅者自己的发送队列上。这种解耦是必要的，以确保慢订阅者不会减慢其他接收数据的速度。而且，如果订阅者太慢以至于他们的发送队列填满了，我们不会将数据放入他们的队列中；即，它会丢失。
- en: The preceding design produces the same output as the earlier, simplistic implementation,
    but now we can be sure that a slow listener will not interfere with message distribution
    to other listeners.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 前述的设计产生了与之前简单实现相同的输出，但现在我们可以确保慢监听器不会干扰消息分发到其他监听器。
- en: These two case studies show a progression in thinking around the design of a
    message distribution system. A key aspect was the realization that sending and
    receiving data might be best handled in separate coroutines, depending on the
    use case. In such instances, queues can be very useful for moving data between
    those different coroutines and for providing buffering to decouple them.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个案例研究展示了在消息分发系统设计中思考的进展。一个关键方面是意识到根据用例，发送和接收数据可能最好由不同的协程处理。在这种情况下，队列非常有用，可以在这些不同的协程之间移动数据并提供缓冲以解耦它们。
- en: The more important goal of these case studies was to show how the streams API
    in `asyncio` makes it very easy to build socket-based applications.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这些案例研究的更重要目标是展示`asyncio`中的流API如何非常容易地构建基于套接字的应用程序。
- en: Twisted
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Twisted
- en: The [Twisted](https://oreil.ly/Y3dY2) project predates—dramatically—the `asyncio`
    standard library, and has been flying the flag of async programming in Python
    for around 14 years now. The project provides not only the basic building blocks,
    like an event loop, but also primitives like *deferreds* that are a bit like the
    futures in `asyncio`. The design of `asyncio` has been heavily influenced by Twisted
    and the extensive experience of its leaders and maintainers.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[Twisted](https://oreil.ly/Y3dY2) 项目比`asyncio`标准库要早很多，大约已经在Python中推广了14年。该项目不仅提供基本构建块，如事件循环，还提供像*deferreds*这样的原语，类似于`asyncio`中的futures。`asyncio`的设计深受Twisted及其领导者和维护者的影响。'
- en: 'Note that [`asyncio` does *not* replace Twisted](https://oreil.ly/J0ezC). Twisted
    includes high-quality implementations of a huge number of internet protocols,
    including not only the usual HTTP but also XMPP, NNTP, IMAP, SSH, IRC, and FTP
    (both servers and clients). And the list goes on: DNS? Check. SMTP? Check. POP3?
    Check. The availability of these excellent internet protocol implementations continues
    to make Twisted compelling.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，[`asyncio`并不取代Twisted](https://oreil.ly/J0ezC)。Twisted包含大量高质量的互联网协议实现，不仅包括通常的HTTP，还包括XMPP、NNTP、IMAP、SSH、IRC和FTP（服务器和客户端）。还有更多：DNS？有。SMTP？有。POP3？有。这些优秀的互联网协议实现的可用性使Twisted依然引人注目。
- en: At the code level, the main difference between Twisted and `asyncio`, apart
    from history and historical context, is that for a long time Python lacked language
    support for coroutines, and this meant that Twisted and projects like it had to
    figure out ways of dealing with asynchronicity that worked with standard Python
    syntax.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码层面上，除了历史和历史背景之外，Twisted 和 `asyncio` 之间的主要区别在于很长一段时间内，Python 缺乏对协程的语言支持，这意味着
    Twisted 和类似项目不得不找出适用于标准 Python 语法的处理异步性的方法。
- en: For most of Twisted’s history, *callbacks* were the means by which async programming
    was done, with all the nonlinear complexity that entails; however, when it became
    possible to use generators as makeshift coroutines, it suddenly became possible
    to lay out code in Twisted in a linear fashion using its `@defer.inlineCallbacks`
    decorator, as shown in [Example 4-10](#twistedinline).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Twisted 的大部分历史中，*回调函数* 是完成异步编程的手段，具有非线性复杂性；然而，当可以使用生成器作为临时协程时，就突然有可能使用 Twisted
    的 `@defer.inlineCallbacks` 装饰器以线性方式编写代码，如 [Example 4-10](#twistedinline) 所示。
- en: Example 4-10\. Even more Twisted with inlined callbacks
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 4-10\. 更多带内联回调的 Twisted
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO6-1)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO6-1)'
- en: Ordinarily, Twisted requires creating instances of `Deferred` and adding callbacks
    to those instances as the method of constructing async programs. A few years ago,
    the `@inlineCallbacks` decorator was added, which repurposes generators as coroutines.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，Twisted 需要创建 `Deferred` 实例并向这些实例添加回调函数来构建异步程序的方法。几年前，添加了 `@inlineCallbacks`
    装饰器，它将生成器重新用作协程。
- en: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO6-2)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO6-2)'
- en: While `@inlineCallbacks` *did* allow you to write code that was linear in appearance
    (unlike callbacks), some hacks were required, such as this call to `defer.returnValue()`,
    which is how you have to return values from `@inlineCallbacks` coroutines.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `@inlineCallbacks` *确实* 允许您编写外观上线性的代码（不像回调函数那样），但是需要一些技巧，例如调用 `defer.returnValue()`，这是您必须从
    `@inlineCallbacks` 协程中返回值的方式。
- en: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO6-3)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO6-3)'
- en: Here we can see the `yield` that makes this function a generator. For `@inlineCallbacks`
    to work, there must be at least one `yield` present in the function being decorated.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们可以看到 `yield` 使这个函数成为一个生成器。为了使 `@inlineCallbacks` 起作用，被装饰的函数中必须至少有一个 `yield`。
- en: Since native coroutines appeared in Python 3.5, the Twisted team (and [Amber
    Brown](https://atleastfornow.net) in particular) have been working to add support
    for running Twisted on the `asyncio` event loop.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 自从原生协程出现在 Python 3.5 中以来，Twisted 团队（特别是 [Amber Brown](https://atleastfornow.net)）一直在努力添加支持，使
    Twisted 可以在 `asyncio` 事件循环上运行。
- en: This is an ongoing effort, and my goal in this section is not to convince you
    to create all your applications as Twisted-`asyncio` hybrids, but rather to make
    you aware that work is currently being done to provide significant interoperability
    between the two.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个持续的努力，本节的目标不是说服你将所有应用程序都创建为 Twisted-`asyncio` 混合体，而是让你意识到当前正在进行工作，以在两者之间提供显著的互操作性。
- en: For those of you with experience using Twisted, [Example 4-11](#twistedasyncio)
    might be jarring.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些有 Twisted 使用经验的人来说，[Example 4-11](#twistedasyncio) 可能会感到突兀。
- en: Example 4-11\. Support for asyncio in Twisted
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 4-11\. Twisted 中对 asyncio 的支持
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO7-1)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO7-1)'
- en: This is how you tell Twisted to use the `asyncio` event loop as its main `reactor`.
    Note that this line *must* come before the `reactor` is imported from `twisted.internet`
    on the following line.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是告诉 Twisted 使用 `asyncio` 事件循环作为其主 `reactor` 的方式。请注意，这一行必须在以下行中从 `twisted.internet`
    导入 `reactor` 之前。
- en: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO7-2)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO7-2)'
- en: Anyone familiar with Twisted programming will recognize these imports. We don’t
    have space to cover them in depth here, but in a nutshell, the `reactor` is the
    `Twisted` version of the `asyncio` *loop*, and `defer` and `task` are namespaces
    for tools to work with scheduling coroutines.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 任何熟悉Twisted编程的人都会认出这些导入。我们在这里没有空间对它们进行深入介绍，但简而言之，`reactor`是`Twisted`版本的`asyncio`
    *loop*，而`defer`和`task`是用于处理调度协程的工具的命名空间。
- en: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO7-3)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO7-3)'
- en: 'Seeing `async def` here, in a Twisted program, looks odd, but this is indeed
    what the new support for `async/await` gives us: the ability to use native coroutines
    directly in Twisted programs.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在Twisted程序中看到`async def`看起来很奇怪，但这确实是新的对`async/await`的支持带给我们的：直接在Twisted程序中使用本机协程的能力。
- en: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO7-4)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO7-4)'
- en: In the older `@inlineCallbacks` world, you would have used `yield from` here,
    but now we can use `await`, the same as in `asyncio` code. The other part of this
    line, `deferLater()`, is an alternative way to do the same thing as `asyncio.sleep(1)`.
    We `await` a future where, after one second, a do-nothing callback will fire.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在较旧的`@inlineCallbacks`世界中，你会在这里使用`yield from`，但现在我们可以使用`await`，与`asyncio`代码中的一样。这行的另一部分，`deferLater()`，是一个执行与`asyncio.sleep(1)`相同操作的替代方法。我们等待一个未来，在一秒钟后，一个什么都不做的回调将触发。
- en: '[![5](assets/5.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO7-5)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO7-5)'
- en: '`ensureDeferred()` is a Twisted version of scheduling a coroutine. This would
    be analogous to `loop.create_task()` or `asyncio.ensure_future()`.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`ensureDeferred()`是Twisted版本的调度协程。这类似于`loop.create_task()`或`asyncio.ensure_future()`。'
- en: '[![6](assets/6.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO7-6)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO7-6)'
- en: Running the `reactor` is the same as `loop.run_forever()` in `asyncio`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`reactor`与在`asyncio`中运行`loop.run_forever()`是一样的。
- en: 'Running this script produces the following output:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本会产生以下输出：
- en: '[PRE11]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There’s much more to learn about Twisted. In particular, it’s well worth your
    time to go through the list of networking protocols it implements. There is still
    some work to be done, but the future looks very bright for interoperation between
    Twisted and `asyncio`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 还有很多关于Twisted的东西要学习。特别是，值得花时间去研究它实现的网络协议列表。还有一些工作要做，但是Twisted和`asyncio`之间的互操作的未来看起来非常光明。
- en: '`asyncio` has been designed in such a way that we can look forward to a future
    where it will be possible to incorporate code from many async frameworks, such
    as Twisted and Tornado, into a single application, with all code running on the
    same event loop.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio`已经被设计成这样一种方式，以便我们可以期待未来，未来将能够将来自许多异步框架（如Twisted和Tornado）的代码合并到单个应用程序中，在同一个事件循环上运行所有代码。'
- en: The Janus Queue
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Janus队列
- en: 'The Janus queue (installed with `pip install janus`) provides a solution for
    communication between threads and coroutines. In the Python standard library,
    there are two kinds of queues:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Janus队列（通过`pip install janus`安装）为线程和协程之间的通信提供了解决方案。在Python标准库中，有两种类型的队列：
- en: '`queue.Queue`'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue.Queue`'
- en: A *blocking* queue, commonly used for communication and buffering between threads
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*阻塞*队列，通常用于线程之间的通信和缓冲
- en: '`asyncio.Queue`'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio.Queue`'
- en: An `async`-compatible queue, commonly used for communication and buffering between
    coroutines
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`async`兼容的队列，通常用于协程之间的通信和缓冲
- en: 'Unfortunately, neither is useful for communication between threads and coroutines!
    This is where Janus comes in: it is a single queue that exposes both APIs, a blocking
    one *and* an async one. [Example 4-12](#janusex) generates data from inside a
    thread, places that data on a queue, and then consumes that data from a coroutine.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这两者都不适用于线程和协程之间的通信！这就是Janus发挥作用的地方：它是一个单一的队列，公开了两种API，一个是阻塞的*，另一个是异步的。[示例 4-12](#janusex)从线程内部生成数据，将该数据放入队列中，然后从协程中消耗该数据。
- en: Example 4-12\. Connecting coroutines and threads with a Janus queue
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-12\. 使用Janus队列连接协程和线程
- en: '[PRE12]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO8-1)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO8-1)'
- en: Create a Janus queue. Note that just like an `asyncio.Queue`, the Janus queue
    will be associated with a specific event loop. As usual, if you don’t provide
    the `loop` parameter, the standard `get_event_loop()` call will be used internally.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个Janus队列。请注意，就像`asyncio.Queue`一样，Janus队列将与特定的事件循环关联。通常情况下，如果不提供`loop`参数，内部将使用标准的`get_event_loop()`调用。
- en: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO8-2)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO8-2)'
- en: 'Our `main()` coroutine function simply waits for data on a queue. This line
    will suspend until there is data, exactly until there is data, exactly like calling
    `get()` on an `asyncio.Queue` instance. The queue object has two *faces*: this
    one is called `async_q` and provides the async-compatible queue API.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`main()`协程函数简单地等待队列中的数据。这一行将暂停，直到有数据，就像在`asyncio.Queue`实例上调用`get()`一样。队列对象有两个*面孔*：这个称为`async_q`，提供了异步兼容的队列API。
- en: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO8-3)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO8-3)'
- en: Print a message.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 打印一条消息。
- en: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO8-4)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO8-4)'
- en: Inside the `data_source()` function, a random `int` is generated, which is used
    both as a sleep duration and a data value. Note that the `time.sleep()` call is
    blocking, so this function must be executed in a thread.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在`data_source()`函数内部，生成一个随机的`int`，用作睡眠持续时间和数据值。注意，`time.sleep()`调用是阻塞的，因此这个函数必须在一个线程中执行。
- en: '[![5](assets/5.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO8-5)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO8-5)'
- en: 'Place the data onto the Janus queue. This shows the other *face* of the Janus
    queue: `sync_q`, which provides the standard, blocking `Queue` API.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据放入Janus队列。这展示了Janus队列的另一个*面孔*：`sync_q`，它提供了标准的阻塞`Queue` API。
- en: 'Here’s the output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE13]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you can, it’s better to aim for having short executor jobs, and in these
    cases, a queue (for communication) won’t be necessary. This isn’t always possible,
    though, and in such situations, the Janus queue can be the most convenient solution
    to buffer and distribute data between threads and coroutines.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以的话，最好目标是拥有短的执行任务，而在这些情况下，队列（用于通信）不是必需的。尽管如此，在这种情况下，Janus队列可以是在线程和协程之间缓冲和分发数据最方便的解决方案。
- en: aiohttp
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: aiohttp
- en: '`aiohttp` brings all things HTTP to `asyncio`, including support for HTTP clients
    and servers, as well as WebSocket support. Let’s jump straight into code examples,
    starting with simplicity itself: “Hello World.”'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`aiohttp`将所有HTTP相关的功能带入了`asyncio`，包括对HTTP客户端和服务器的支持，以及WebSocket支持。让我们直接看代码示例，从简单的“Hello
    World”开始。'
- en: 'Case Study: Hello World'
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究：Hello World
- en: '[Example 4-13](#aiohttpminimal) shows a minimal web server using `aiohttp`.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-13](#aiohttpminimal)展示了使用`aiohttp`的最简单的Web服务器。'
- en: Example 4-13\. Minimal aiohttp example
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-13\. aiohttp最小示例
- en: '[PRE14]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO9-1)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO9-1)'
- en: An `Application` instance is created.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`Application`实例。
- en: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO9-2)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO9-2)'
- en: A route is created, with the target coroutine `hello()` given as the handler.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个路由，目标协程`hello()`作为处理程序。
- en: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO9-3)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO9-3)'
- en: The web application is run.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Web应用程序。
- en: 'Observe that there is no mention of loops, tasks, or futures in this code:
    the developers of the `aiohttp` framework have hidden all that away from us, leaving
    a very clean API. This is going to be common in most frameworks that build on
    top of `asyncio`, which has been designed to allow framework designers to choose
    only the bits they need, and encapsulate them in their preferred API.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此代码中没有提到循环、任务或未来：`aiohttp`框架的开发者已经把所有这些都隐藏起来，留下了一个非常清洁的API。这在大多数构建在`asyncio`之上的框架中都很常见，这个框架设计旨在允许框架设计者仅选择他们需要的部分，并将其封装在他们喜欢的API中。
- en: 'Case Study: Scraping the News'
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究：抓取新闻
- en: '`aiohttp` can be used both as a server and a client library, like the very
    popular (but blocking!) [`requests`](https://oreil.ly/E2s9d) library. I wanted
    to showcase `aiohttp` by using an example that incorporates both features.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`aiohttp` 可以像非常流行的（但是阻塞的！）[`requests`](https://oreil.ly/E2s9d) 库一样，同时作为服务器和客户端库使用。我想通过一个同时包含这两个特性的示例来展示
    `aiohttp`。'
- en: 'In this case study, we’ll implement a website that does web scraping behind
    the scenes. The application will scrape two news websites and combine the headlines
    into one page of results. Here is the strategy:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例研究中，我们将实现一个在幕后进行网页抓取的网站。该应用程序将抓取两个新闻网站，并将标题组合成一个结果页面。这是我们的策略：
- en: A browser client makes a web request to *http://localhost:8080/news*.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器客户端向 *http://localhost:8080/news* 发送 Web 请求。
- en: Our web server receives the request, and then on the backend fetches HTML data
    from multiple news websites.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 Web 服务器接收请求，然后在后端从多个新闻网站获取 HTML 数据。
- en: Each page’s data is scraped for headlines.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个页面的数据都被用于抓取头条新闻。
- en: The headlines are sorted and formatted into the response HTML that we send back
    to the browser client.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标题被排序并格式化为我们发送回浏览器客户端的响应 HTML。
- en: '[Figure 4-1](#scraper-image) shows the output.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure 4-1](#scraper-image) 显示了输出结果。'
- en: '![uaip 0401](assets/uaip_0401.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![uaip 0401](assets/uaip_0401.png)'
- en: 'Figure 4-1\. The final product of our news scraper: headlines from CNN are
    shown in one color, and Al Jazeera in another'
  id: totrans-225
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-1\. 我们新闻抓取器的最终产品：CNN 的标题以一种颜色显示，Al Jazeera 的标题以另一种颜色显示。
- en: Web scraping has become quite difficult nowadays. For example, if you try `requests.get('http://edition.cnn.com')`,
    you’re going to find that the response contains very little usable data! It has
    become increasingly necessary to be able to execute JavaScript locally in order
    to obtain data, because many sites use JavaScript to load their actual content.
    The process of executing such JavaScript to produce the final, complete HTML output
    is called *rendering*.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，网页抓取变得非常困难。例如，如果您尝试 `requests.get('http://edition.cnn.com')`，您会发现响应包含的可用数据非常少！如今，执行
    JavaScript 以获取数据变得越来越必要，因为许多网站使用 JavaScript 加载其实际内容。执行这种 JavaScript 以生成最终完整的 HTML
    输出的过程称为*渲染*。
- en: To accomplish rendering, we use a neat project called [Splash](https://oreil.ly/1IAie),
    which describes itself as a “JavaScript rendering service.” It can run in a [Docker](https://www.docker.com)
    container and provides an API for rendering other sites. Internally, it uses a
    (JavaScript-capable) WebKit engine to fully load and render a website. This is
    what we’ll use to obtain website data. Our `aiohttp` server, shown in [Example 4-14](#exscraper),
    will call this Splash API to obtain the page data.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现渲染，我们使用一个名为 [Splash](https://oreil.ly/1IAie) 的不错的项目，它自称是一个“JavaScript 渲染服务”。它可以在
    [Docker](https://www.docker.com) 容器中运行，并提供用于渲染其他站点的 API。在内部，它使用一个（支持 JavaScript
    的）WebKit 引擎来完全加载和渲染网站。这是我们将用来获取网站数据的工具。我们的 `aiohttp` 服务器，在 [Example 4-14](#exscraper)
    中显示，将调用这个 Splash API 来获取页面数据。
- en: Tip
  id: totrans-228
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'To obtain and run the Splash container, run these commands in your shell:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取并运行 Splash 容器，请在您的 shell 中运行以下命令：
- en: '[PRE15]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our server backend will call the Splash API at *http://localhost:8050*.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器后端将调用 Splash API，网址为 *http://localhost:8050*。
- en: Example 4-14\. Code for the news scraper
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 4-14\. 新闻抓取器的代码
- en: '[PRE16]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO10-1)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO10-1)'
- en: The `news()` function is the handler for the */news* URL on our server. It returns
    the HTML page showing all the headlines.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`news()` 函数是我们服务器上 */news* URL 的处理程序。它返回显示所有标题的 HTML 页面。'
- en: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO10-2)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO10-2)'
- en: 'Here, we have only two news websites to be scraped: CNN and Al Jazeera. More
    could easily be added, but then additional postprocessors would also have to be
    added, just like the `cnn_articles()` and `aljazeera_articles()` functions that
    are customized to extract headline data.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只有两个要抓取的新闻网站：CNN 和 Al Jazeera。可以很容易地添加更多，但是必须添加额外的后处理器，就像定制的 `cnn_articles()`
    和 `aljazeera_articles()` 函数一样，用于提取标题数据。
- en: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO10-3)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO10-3)'
- en: For each news site, we create a task to fetch and process the HTML page data
    for its front page. Note that we unpack the tuple (`(*s)`) since the `news_fetch()`
    coroutine function takes both the URL and the postprocessing function as parameters.
    Each `news_fetch()` call will return a *list of tuples* as headline results, in
    the form *`<article URL>`*, *`<article title>`*.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个新闻站点，我们创建一个任务来获取并处理其首页的 HTML 页面数据。注意，我们解包元组（`(*s)`），因为`news_fetch()`协程函数接受
    URL 和后处理函数作为参数。每个`news_fetch()`调用将返回一个*元组列表*作为标题结果，格式为*`<article URL>`*, *`<article
    title>`*。
- en: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO10-4)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO10-4)'
- en: All the tasks are gathered together into a single `Future` (`gather()` returns
    a future representing the state of all the tasks being gathered), and then we
    immediately `await` the completion of that future. This line will suspend until
    the future completes.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 所有任务都聚集在一个单独的`Future`中（`gather()`返回表示所有任务状态的 future），然后我们立即`await`该 future 的完成。这行代码将暂停，直到
    future 完成。
- en: '[![5](assets/5.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO10-5)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO10-5)'
- en: Since all the `news_fetch()` tasks are now complete, we collect all of the results
    into a dictionary. Note how nested comprehensions are used to iterate over tasks,
    and then over the list of tuples returned by each task. We also use *f-strings*
    to substitute data directly, including even the kind of page, which will be used
    in CSS to color the `div` background.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有`news_fetch()`任务现在已完成，我们将所有结果收集到一个字典中。请注意如何使用嵌套推导来迭代任务，然后迭代每个任务返回的元组列表。我们还使用
    *f-strings* 直接替换数据，包括页面的类型，这将用于 CSS 来着色`div`的背景。
- en: '[![6](assets/6.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO10-6)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO10-6)'
- en: In this dictionary, the *key* is the headline title, and the *value* is an HTML
    string for a `div` that will be displayed in our result page.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字典中，*key* 是头条标题，*value* 是将显示在我们结果页面中的`div`的 HTML 字符串。
- en: '[![7](assets/7.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO10-7)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO10-7)'
- en: Our web server is going to return HTML. We’re loading HTML data from a local
    file called *index.html*. This file is presented in [Example B-1](app02.html#corobot)
    if you want to re-create the case study yourself.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Web 服务器将返回 HTML。我们正在从名为 *index.html* 的本地文件加载 HTML 数据。如果您想重新创建这个案例研究，请参考
    [Example B-1](app02.html#corobot) 中的文件。
- en: '[![8](assets/8.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO10-8)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO10-8)'
- en: We substitute the collected headline `div` into the template and return the
    page to the browser client. This generates the page shown in [Figure 4-1](#scraper-image).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将收集的头条`div`替换到模板中，并将页面返回给浏览器客户端。这生成了示例 [Figure 4-1](#scraper-image) 中展示的页面。
- en: '[![9](assets/9.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO10-9)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO10-9)'
- en: Here, inside the `news_fetch()` coroutine function, we have a tiny template
    for hitting the Splash API (which, for me, is running in a local Docker container
    on port 8050). This demonstrates how `aiohttp` can be used as an HTTP client.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在`news_fetch()`协程函数内部，我们有一个小模板，用于调用运行在本地 Docker 容器端口 8050 上的 Splash API。这演示了如何使用`aiohttp`作为
    HTTP 客户端。
- en: '[![10](assets/10.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO10-10)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](assets/10.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO10-10)'
- en: 'The standard way is to create a `ClientSession()` instance, and then use the
    `get()` method on the session instance to perform the REST call. In the next line,
    the response data is obtained. Note that because we’re always operating on coroutines,
    with `async with` and `await`, this coroutine will never block: we’ll be able
    to handle many thousands of these requests, even though this operation (`news_fetch()`)
    might be relatively slow since we’re doing web calls internally.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 标准方式是创建一个`ClientSession()`实例，然后在会话实例上使用`get()`方法执行 REST 调用。在下一行，获取响应数据。请注意，由于我们始终在协程上操作，使用`async
    with`和`await`，这个协程不会阻塞：我们可以处理成千上万的这些请求，即使这个操作（`news_fetch()`）可能相对较慢，因为我们在内部进行网络调用。
- en: '[![11](assets/11.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO10-11)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[![11](assets/11.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO10-11)'
- en: After the data is obtained, we call the postprocessing function. For CNN, it’ll
    be `cnn_articles()`, and for Al Jazeera it’ll be `aljazeera_articles()`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 获取数据后，我们调用后处理函数。对于 CNN，将是 `cnn_articles()`，对于 Al Jazeera，将是 `aljazeera_articles()`。
- en: '[![12](assets/12.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO10-12)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[![12](assets/12.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO10-12)'
- en: We have space only for a brief look at the postprocessing. After getting the
    page data, we use the Beautiful Soup 4 library for extracting headlines.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只有时间简要介绍后处理。获取页面数据后，我们使用 Beautiful Soup 4 库提取标题。
- en: '[![13](assets/13.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO10-13)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[![13](assets/13.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO10-13)'
- en: The `match()` function will return all matching tags (I’ve manually checked
    the HTML source of these news websites to figure out which combination of filters
    extracts the best tags), and then we return a list of tuples matching the format
    *`<article URL>`*, *`<article title>`*.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`match()` 函数将返回所有匹配的标签（我手动检查了这些新闻网站的 HTML 源代码，以找出哪种过滤器组合提取最佳标签），然后我们返回一个符合格式
    *`<文章 URL>`*、*`<文章标题>`* 的元组列表。'
- en: '[![14](assets/14.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO10-14)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[![14](assets/14.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO10-14)'
- en: This is the analogous postprocessor for Al Jazeera. The `match()` condition
    is slightly different, but it is otherwise the same as the CNN one.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Al Jazeera 的类似后处理器。`match()` 条件略有不同，但除此之外与 CNN 的相同。
- en: Generally, you’ll find that `aiohttp` has a simple API and “stays out of your
    way” while you develop your applications.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会发现 `aiohttp` 具有简单的 API 并且在你开发应用程序时“不会干扰你”。
- en: In the next section, we’ll look at using ZeroMQ with `asyncio`, which has the
    curious effect of making socket programming quite enjoyable.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看如何在 `asyncio` 中使用 ZeroMQ，这使得套接字编程变得非常有趣。
- en: ØMQ (ZeroMQ)
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ØMQ（ZeroMQ）
- en: 'Programming is a science dressed up as art, because most of us don’t understand
    the physics of software and it’s rarely, if ever, taught. The physics of software
    is not algorithms, data structures, languages, and abstractions. These are just
    tools we make, use, and throw away. The real physics of software is the physics
    of people. Specifically, it’s about our limitations when it comes to complexity
    and our desire to work together to solve large problems in pieces. This is the
    science of programming: make building blocks that people can understand and use
    easily, and people will work together to solve the very largest problems.'
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编程是一门打扮成艺术的科学，因为我们大多数人不了解软件的物理学，而且很少有人教过。软件的物理学不是算法、数据结构、语言和抽象。这些只是我们制作、使用和丢弃的工具。软件的真正物理学是人的物理学。具体而言，它是关于我们在复杂性方面的限制以及我们希望一起解决大问题的愿望的物理学。这就是编程的科学：制作人们能够轻松理解和使用的构建块，人们将共同努力解决最大的问题。
- en: ''
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Pieter Hintjens, *ZeroMQ: Messaging for Many Applications*'
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Pieter Hintjens，《ZeroMQ: Messaging for Many Applications》'
- en: 'ØMQ (or [ZeroMQ](http://zeromq.org)) is a popular language-agnostic library
    for networking applications: it provides “smart” sockets. When you create ØMQ
    sockets in code, they resemble regular sockets, with recognizable method names
    like `recv()` and `send()` and so on—but internally these sockets handle some
    of the more annoying and tedious tasks required for working with conventional
    sockets.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ØMQ（或[ZeroMQ](http://zeromq.org)）是一个流行的与语言无关的网络应用程序库：它提供“智能”套接字。当你在代码中创建 ØMQ
    套接字时，它们类似于常规套接字，具有可识别的方法名称，如 `recv()` 和 `send()` 等，但在内部，这些套接字处理了一些更烦人和乏味的任务，以便与传统套接字一起工作。
- en: One of the features it provides is management of message passing, so you don’t
    have to invent your own protocol and count bytes on the wire to figure out when
    all the bytes for a particular message have arrived—you simply send whatever you
    consider to be a “message,” and the whole thing arrives on the other end intact.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供的功能之一是管理消息传递，因此您不必发明自己的协议并计算字节，以确定何时到达特定消息的所有字节 - 您只需发送您认为是“消息”的内容，整个消息都会完整地到达另一端。
- en: 'Another great feature is automatic reconnection logic. If the server goes down
    and comes back up later, the client ØMQ socket will *automatically* reconnect.
    And even better, messages your code sends into the socket will be buffered during
    the disconnected period, so they will all still be sent out when the server returns.
    These are some of the reasons ØMQ is sometimes referred to as [*brokerless* messaging](https://oreil.ly/oQE4x):
    it provides some of the features of message broker software directly in the socket
    objects themselves.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很棒的特性是自动重新连接逻辑。如果服务器宕机后稍后恢复，客户端 ØMQ socket 将*自动*重新连接。更好的是，在断开连接期间，您的代码发送到
    socket 的消息将被缓存，因此服务器恢复时仍然可以发送它们出去。这些是 ØMQ 有时被称为[*无中介*消息传递](https://oreil.ly/oQE4x)的原因之一：它直接在
    socket 对象本身提供了一些消息代理软件的功能。
- en: ØMQ sockets are already implemented as asynchronous internally (so they can
    maintain many thousands of concurrent connections, even when used in threaded
    code), but this is hidden from us behind the ØMQ API. Nevertheless, support for
    Asyncio has been added to the [PyZMQ](https://oreil.ly/N8w7J) Python bindings
    for the ØMQ library, and in this section we’re going to look at several examples
    of how you might incorporate these smart sockets into your Python applications.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ØMQ sockets 已经在内部实现为异步的（因此它们可以在线程代码中维护许多千次连接），但这一点被 ØMQ API 隐藏了。尽管如此，对于 ØMQ
    库的 Python 绑定 [PyZMQ](https://oreil.ly/N8w7J) 添加了对 Asyncio 的支持，在本节中，我们将看几个例子，演示如何将这些智能
    sockets 整合到您的 Python 应用程序中。
- en: 'Case Study: Multiple Sockets'
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究：多个 sockets
- en: 'Here’s a head-scratcher: if ØMQ provides sockets that are already asynchronous,
    in a way that is usable with threading, what is the point of using ØMQ with `asyncio`?
    The answer is cleaner code.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个让人费解的问题：如果 ØMQ 提供的 sockets 已经是异步的，并且可以与线程一起使用，那么使用 `asyncio` 还有什么意义呢？答案是代码更清晰。
- en: To demonstrate, let’s look at a tiny case study in which you use multiple ØMQ
    sockets in the same application. First, [Example 4-15](#zmqtrad) shows the blocking
    version (this example is taken from the [zguide](https://oreil.ly/qXAj8), the
    official guide for ØMQ).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，让我们看一个小案例研究，在这个案例中，您可以在同一个应用程序中使用多个 ØMQ sockets。首先，[示例 4-15](#zmqtrad)
    展示了阻塞版本（此示例摘自 [zguide](https://oreil.ly/qXAj8)，ØMQ 的官方指南）。
- en: Example 4-15\. The traditional ØMQ approach
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-15\. 传统的 ØMQ 方法
- en: '[PRE17]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO11-1)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO11-1)'
- en: ØMQ sockets have *types*. This is a `PULL` socket. You can think of it as a
    *receive-only* kind of socket that will be fed by some other *send-only* socket,
    which will be a `PUSH` type.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ØMQ sockets 有*类型*。这是一个 `PULL` socket。您可以把它想象成一种*仅接收*的 socket，它将由另一个*仅发送*的 socket，即
    `PUSH` 类型的 socket 提供数据。
- en: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO11-2)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO11-2)'
- en: The `SUB` socket is another kind of receive-only socket, and it will be fed
    a `PUB` socket which is send-only.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`SUB` socket 是另一种接收-only socket，它将接收一个仅发送的 `PUB` socket 提供的数据。'
- en: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO11-3)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO11-3)'
- en: If you need to move data between multiple sockets in a threaded ØMQ application,
    you’re going to need a *poller*. This is because these sockets are not thread-safe,
    so you cannot `recv()` on different sockets in different threads.^([1](ch04.html#idm46363022865560))
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在多个线程的 ØMQ 应用程序中移动数据，您将需要一个*轮询器*。这是因为这些 sockets 不是线程安全的，所以您不能在不同的线程上的不同
    sockets 上执行 `recv()` 操作。^([1](ch04.html#idm46363022865560))
- en: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO11-4)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO11-4)'
- en: It works similarly to the `select()` system call. The poller will unblock when
    there is data ready to be received on one of the registered sockets, and then
    it’s up to you to pull the data off and do something with it. The big `if` block
    is how you detect the correct socket.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式类似于 `select()` 系统调用。当注册的 socket 中有数据可以接收时，轮询器将解除阻塞，然后您可以取出数据并对其进行处理。大的
    `if` 块是用来检测正确的 socket 的方法。
- en: Using a poller loop plus an explicit socket-selection block makes the code look
    a little clunky, but this approach avoids thread-safety problems by guaranteeing
    the same socket is not used from different threads.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 使用轮询器循环加上显式的套接字选择块使得代码看起来有些笨拙，但这种方法通过确保同一套接字不会从不同线程中使用来避免线程安全问题。
- en: '[Example 4-16](#zmqsrv) shows the server code.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-16](#zmqsrv) 显示了服务器代码。'
- en: Example 4-16\. Server code
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-16\. 服务器代码
- en: '[PRE18]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This code is not important for the discussion, but briefly: there’s a `PUSH`
    socket and a `PUB` socket, as I said earlier, and a loop inside that sends data
    to both sockets every second. Here’s sample output from *poller.py* (note: *both*
    programs must be running):'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 对于讨论来说，这段代码并不重要，但简要来说：有一个 `PUSH` 套接字和一个 `PUB` 套接字，正如我之前所说，内部循环每秒向这两个套接字发送数据。这里是
    *poller.py* 的样本输出（注意：*两个*程序都必须在运行）：
- en: '[PRE19]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The code works; however, our interest here is not whether the code runs, but
    rather whether `asyncio` has anything to offer for the structure of *poller.py*.
    The key thing to understand is that our `asyncio` code is going to run in a single
    thread, which means that it’s fine to handle different sockets in different *coroutines*—and
    indeed, this is exactly what we’ll do.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是可以运行的；然而，我们关心的不是代码是否运行，而是 `asyncio` 对 *poller.py* 结构是否有所贡献。要理解的关键是，我们的 `asyncio`
    代码将在单个线程中运行，这意味着可以在不同的 *协程* 中处理不同的套接字——事实上，这正是我们将要做的。
- en: Of course, [someone had to do the hard work](http://bit.ly/2sPCihI) to add support
    for coroutines into `pyzmq` (the Python client library for ØMQ) itself for this
    to work, so it wasn’t free. But we can take advantage of that hard work to improve
    on the “traditional” code structure, as shown in [Example 4-17](#cleansep).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，要使其工作，[有人必须努力工作](http://bit.ly/2sPCihI) 将协程支持添加到 `pyzmq`（ØMQ 的 Python 客户端库）本身中。因此这并非是免费的。但我们可以利用这些努力来改进“传统”的代码结构，正如
    [示例 4-17](#cleansep) 中所示。
- en: Example 4-17\. Clean separation with asyncio
  id: totrans-293
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-17\. 使用 asyncio 进行清晰分离
- en: '[PRE20]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO12-1)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO12-1)'
- en: This code sample does the same as [Example 4-15](#zmqtrad), except that now
    we’re taking advantage of coroutines to restructure everything. Now we can deal
    with each socket in isolation. I’ve created two coroutine functions, one for each
    socket; this one is for the `PULL` socket.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码示例与 [示例 4-15](#zmqtrad) 相同，只是现在我们利用协程重新结构化了一切。现在我们可以单独处理每个套接字。我创建了两个协程函数，一个用于每个套接字；这个是用于
    `PULL` 套接字的。
- en: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO12-2)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO12-2)'
- en: I’m using the `asyncio` support in `pyzmq`, which means that all `send()` and
    `recv()` calls must use the `await` keyword. The `Poller` no longer appears anywhere,
    because it’s been integrated into the `asyncio` event loop itself.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在使用 `pyzmq` 中的 `asyncio` 支持，这意味着所有的 `send()` 和 `recv()` 调用必须使用 `await` 关键字。`Poller`
    不再出现在任何地方，因为它已经集成到了 `asyncio` 事件循环中。
- en: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO12-3)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO12-3)'
- en: This is the handler for the `SUB` socket. The structure is very similar to the
    `PULL` socket’s handler, but that need not have been the case. If more complex
    logic had been required, I’d have been able to easily add it here, fully encapsulated
    within the `SUB`-handler code only.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `SUB` 套接字的处理程序。其结构与 `PULL` 套接字的处理程序非常相似，但这并非必然。如果需要更复杂的逻辑，我可以轻松地在这里添加，完全封装在
    `SUB` 处理程序代码内。
- en: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO12-4)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO12-4)'
- en: Again, the `asyncio`-compatible sockets require the `await` keyword to send
    and receive.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`asyncio` 兼容的套接字需要使用 `await` 关键字进行发送和接收。
- en: The output is the same as before, so I won’t show it.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与之前相同，因此我不会再次展示它。
- en: The use of coroutines has, in my opinion, a staggeringly positive effect on
    the code layout in these examples. In real production code with lots of ØMQ sockets,
    the coroutine handlers for each could even be in separate files, providing more
    opportunities for better code structure. And even for programs with a single read/write
    socket, it is very easy to use separate coroutines for reading and writing, if
    necessary.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，使用协程对这些示例中的代码布局有着惊人的积极影响。在具有许多 ØMQ 套接字的实际生产代码中，每个协程处理程序甚至可以在单独的文件中，提供更多改善代码结构的机会。即使对于只有一个读/写套接字的程序，如果需要，使用单独的协程进行读取和写入也非常容易。
- en: 'The improved code looks a lot like threaded code, and indeed, for the specific
    example shown here, the same refactor will work for threading: run blocking `do_receiver()`
    and `do_subscriber()` functions in separate threads. But do you really want to
    deal with even the *potential* for race conditions, especially as your application
    grows in features and complexity over time?'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 改进后的代码看起来非常像线程化的代码，实际上，对于这里展示的特定示例，相同的重构将适用于线程化：在单独的线程中运行阻塞的 `do_receiver()`
    和 `do_subscriber()` 函数。但是，您真的想要处理*潜在的*竞争条件吗，尤其是随着您的应用程序随着时间的推移而功能和复杂性增加？
- en: There is lots to explore here, and as I said before, these magic sockets are
    a lot of fun to play with. In the next case study, we’ll look at a more practical
    use of ØMQ.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多可以探索的地方，正如我之前所说的，这些神奇的套接字非常有趣。在下一个案例研究中，我们将看到 ØMQ 的更实际的用途。
- en: 'Case Study: Application Performance Monitoring'
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究：应用性能监控
- en: With the modern, containerized, microservice-based deployment practices of today,
    some things that used to be trivial, such as monitoring your apps’ CPU and memory
    usage, have become somewhat more complicated than just running `top`. Several
    commercial products have emerged over the last few years to deal with these problems,
    but their cost can be prohibitive for small startup teams and hobbyists.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 随着现代、容器化的、基于微服务的部署实践的发展，一些以前微不足道的事情，比如监视您的应用程序的 CPU 和内存使用情况，现在已经比运行 `top` 更加复杂。在过去几年中出现了一些商业产品来解决这些问题，但是它们的成本对于小型初创团队和业余爱好者来说可能是禁碍的。
- en: 'In this case study, I’ll exploit ØMQ and `asyncio` to build a toy prototype
    for distributed application monitoring. Our design has three parts:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例研究中，我将利用 ØMQ 和 `asyncio` 来构建一个用于分布式应用监控的玩具原型。我们的设计有三个部分：
- en: Application layer
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层
- en: This layer contains all our applications. Examples might be a “customers” microservice,
    a “bookings” microservice, an “emailer” microservice, and so on. I will add a
    ØMQ “transmitting” socket to each of our applications. This socket will send performance
    metrics to a central server.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层包含了我们所有的应用程序。例如可能是“客户”微服务，“预订”微服务，“电子邮件”微服务等。我将为我们的每个应用程序添加一个 ØMQ “传输”套接字。该套接字将向中央服务器发送性能指标。
- en: Collection layer
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 收集层
- en: The central server will expose a ØMQ socket to collect the data from all the
    running application instances. The server will also serve a web page to show performance
    graphs over time and will live-stream the data as it comes in.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 中央服务器将公开一个 ØMQ 套接字，以收集所有正在运行的应用程序实例的数据。服务器还将提供一个网页，显示随时间变化的性能图表，并实时传输数据。
- en: Visualization layer
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化层
- en: This is the web page being served. We’ll display the collected data in a set
    of charts, and the charts will live-update in real time. To simplify the code
    samples, I will use the convenient [Smoothie Charts](http://smoothiecharts.org)
    JavaScript library, which provides all the necessary client-side features.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正在提供的网页。我们将在一组图表中显示收集的数据，并且图表将实时更新。为了简化代码示例，我将使用方便的[Smoothie Charts](http://smoothiecharts.org)
    JavaScript库，它提供了所有必要的客户端特性。
- en: The backend app (application layer) that produces metrics is shown in [Example 4-18](#applayer).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 生成指标的后端应用（应用层）在 [示例 4-18](#applayer) 中显示。
- en: 'Example 4-18\. The application layer: producing metrics'
  id: totrans-317
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-18\. 应用层：生成指标
- en: '[PRE21]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO13-1)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO13-1)'
- en: This coroutine function will run as a long-lived coroutine, continually sending
    out data to the server process.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这个协程函数将作为一个长期运行的协程，不断地向服务器进程发送数据。
- en: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO13-2)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO13-2)'
- en: Create a ØMQ socket. As you know, there are different flavors of socket; this
    one is a `PUB` type, which allows one-way messages to be sent to another ØMQ socket.
    This socket has—as the ØMQ guide says—superpowers. It will automatically handle
    all reconnection and buffering logic for us.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 ØMQ 套接字。正如您所知，套接字有不同的类型；这个是 `PUB` 类型，允许将单向消息发送到另一个 ØMQ 套接字。正如 ØMQ 指南所说，这种套接字具有超级能力，将自动处理所有的重新连接和缓冲逻辑。
- en: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO13-3)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO13-3)'
- en: Connect to the server.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到服务器。
- en: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO13-4)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO13-4)'
- en: Our shutdown sequence is driven by `KeyboardInterrupt`, farther down. When that
    signal is received, all the tasks will be cancelled. Here I handle the raised
    `CancelledError` with the handy `suppress()` context manager from the `contextlib`
    standard library module.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的关闭序列由 `KeyboardInterrupt` 驱动，稍后处理。当接收到该信号时，所有任务将被取消。在这里，我使用了 `contextlib`
    标准库模块中方便的 `suppress()` 上下文管理器来处理引发的 `CancelledError`。
- en: '[![5](assets/5.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO13-5)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO13-5)'
- en: Iterate forever, sending out data to the server.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 永远迭代，向服务器发送数据。
- en: '[![6](assets/6.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO13-6)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO13-6)'
- en: 'Since ØMQ knows how to work with complete messages, and not just chunks off
    a bytestream, it opens the door to a bunch of useful wrappers around the usual
    `sock.send()` idiom: here, I use one of those helper methods, `send_json()`, which
    will automatically serialize the argument into JSON. This allows us to use a `dict()`
    directly.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 ØMQ 知道如何处理完整的消息，而不仅仅是字节流的块，这为通常的 `sock.send()` 惯用语提供了许多有用的包装器的可能性：在这里，我使用了其中一个帮助方法
    `send_json()`，它将自动将参数序列化为 JSON。这允许我们直接使用 `dict()`。
- en: '[![7](assets/7.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO13-7)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO13-7)'
- en: A reliable way to transmit datetime information is via the ISO 8601 format.
    This is especially true if you have to pass datetime data between software written
    in different languages, since the vast majority of language implementations will
    be able to work with this standard.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 ISO 8601 格式传输日期时间信息是一种可靠的方法。特别是如果需要在不同语言编写的软件之间传递日期时间数据，因为绝大多数语言实现都能处理这种标准。
- en: '[![8](assets/8.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO13-8)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO13-8)'
- en: To end up here, we must have received the `CancelledError` exception resulting
    from task cancellation. The ØMQ socket must be closed to allow program shutdown.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要结束到这里，我们必须收到由任务取消引起的 `CancelledError` 异常。必须关闭 ØMQ 套接字以允许程序关闭。
- en: '[![9](assets/9.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO13-9)'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO13-9)'
- en: The `main()` function symbolizes the actual microservice application. Fake work
    is produced with this sum over random numbers, just to give us some nonzero data
    to view in the visualization layer a bit later.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数象征着实际的微服务应用程序。通过对随机数求和来生成假工作，只是为了稍后在可视化层中查看一些非零数据。'
- en: '[![10](assets/10.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO13-10)'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](assets/10.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO13-10)'
- en: I’m going to create multiple instances of this application, so it will be convenient
    to be able to distinguish between them (later, in the graphs) with a `--color`
    parameter.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我将创建此应用的多个实例，因此最好能够使用 `--color` 参数在图表中区分它们（稍后）。
- en: '[![11](assets/11.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO13-11)'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '[![11](assets/11.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO13-11)'
- en: Finally, the ØMQ context can be terminated.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以终止 ØMQ 上下文。
- en: The primary point of interest is the `stats_reporter()` function. This is what
    streams out metrics data (collected by the useful `psutil` library). The rest
    of the code can be assumed to be a typical microservice application.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 主要关注点是 `stats_reporter()` 函数。这是用来流出度量数据的（由有用的 `psutil` 库收集）。代码的其余部分可以假定是典型的微服务应用程序。
- en: The server code in [Example 4-19](#metserver) collects all the data and serves
    it to a web client.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-19](#metserver)中的服务器代码收集所有数据并提供给Web客户端。'
- en: 'Example 4-19\. The collection layer: this server collects process stats'
  id: totrans-343
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-19\. 这个服务器是收集层：该服务器收集进程统计信息。
- en: '[PRE22]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-1)'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-1)'
- en: One half of this program will receive data from other applications, and the
    other half will provide data to browser clients via *server-sent events* (SSEs).
    I use a `WeakSet()` to keep track of all the currently connected web clients.
    Each connected client will have an associated `Queue()` instance, so this `connections`
    identifier is really a set of queues.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的一部分将从其他应用程序接收数据，另一部分将通过*服务器发送事件*（SSEs）向浏览器客户端提供数据。我使用`WeakSet()`来跟踪当前连接的所有Web客户端。每个连接的客户端将有一个关联的`Queue()`实例，因此这个`connections`标识符实际上是一组队列。
- en: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-2)'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-2)'
- en: Recall that in the application layer, I used a `zmq.PUB` socket; here in the
    collection layer, I use its partner, the `zmq.SUB` socket type. This ØMQ socket
    can only receive, not send.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在应用层中，我使用了`zmq.PUB`套接字；而在收集层中，我使用了它的配对项`zmq.SUB`套接字类型。这个 ØMQ 套接字只能接收数据，不能发送。
- en: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-3)'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-3)'
- en: For the `zmq.SUB` socket type, providing a subscription name is required, but
    for our purposes, we’ll just take everything that comes in—hence the empty topic
    name.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`zmq.SUB`套接字类型，需要提供订阅名称，但出于我们的目的，我们将接收所有传入的内容——因此订阅主题名称为空。
- en: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-4)'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-4)'
- en: 'I *bind* the `zmq.SUB` socket. Think about that for second. In pub-sub configurations,
    you usually have to make the *pub* end the server (`bind()`) and the *sub* end
    the client (`connect()`). ØMQ is different: either end can be the server. For
    our use case, this is important, because each of our application-layer instances
    will be connecting to the same collection server domain name, and not the other
    way around.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我*绑定*了`zmq.SUB`套接字。仔细想想这一点。在发布-订阅配置中，通常需要将*发布*端作为服务器(`bind()`)，而*订阅*端作为客户端(`connect()`)。
    ØMQ 不同：任一端点都可以是服务器。对于我们的用例，这一点很重要，因为我们的每个应用层实例将连接到相同的收集服务器域名，而不是相反的情况。
- en: '[![5](assets/5.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-5)'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-5)'
- en: The support for `asyncio` in `pyzmq` allows us to `await` data from our connected
    apps. And not only that, but the incoming data will be automatically deserialized
    from JSON (yes, this means `data` is a `dict()`).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`pyzmq`中对`asyncio`的支持使我们能够从连接的应用程序中`await`数据。不仅如此，传入的数据将自动从JSON反序列化（是的，这意味着`data`是一个`dict()`）。'
- en: '[![6](assets/6.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-6)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-6)'
- en: 'Recall that our `connections` set holds a queue for every connected web client.
    Now that data has been received, it’s time to send it to all the clients: the
    data is placed onto each queue.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们的`connections`集合为每个连接的Web客户端维护了一个队列。现在数据已经接收到，是时候将其发送给所有客户端了：数据被放入每个队列中。
- en: '[![7](assets/7.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-7)'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-7)'
- en: The `feed()` coroutine function will create coroutines for each connected web
    client. Internally, [server-sent events](https://mzl.la/2omEs3t) are used to push
    data to the web clients.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`feed()`协程函数将为每个连接的Web客户端创建协程。内部使用[服务器发送事件](https://mzl.la/2omEs3t)将数据推送到Web客户端。'
- en: '[![8](assets/8.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-8)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-8)'
- en: As described earlier, each web client will have its own `queue` instance, in
    order to receive data from the `collector()` coroutine. The `queue` instance is
    added to the `connections` set, but because `connections` is a *weak* set, the
    entry will automatically be removed from `connections` when the `queue` goes out
    of scope—i.e., when a web client disconnects. [Weakrefs](https://oreil.ly/fRmdu)
    are great for simplifying these kinds of bookkeeping tasks.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前描述的那样，每个 Web 客户端都会有自己的`queue`实例，以便从`collector()`协程接收数据。`queue`实例被添加到`connections`集合中，但因为`connections`是一个*弱*集合，当`queue`超出作用域时——即
    Web 客户端断开连接时——条目将自动从`connections`中删除。[Weakrefs](https://oreil.ly/fRmdu) 对于简化这类簿记任务非常有用。
- en: '[![9](assets/9.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-9)'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-9)'
- en: The `aiohttp_sse` package provides the `sse_response()` context manager. This
    gives us a scope inside which to push data to the web client.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`aiohttp_sse`包提供了`sse_response()`上下文管理器。这为我们提供了一个范围，用于向 Web 客户端推送数据。'
- en: '[![10](assets/10.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-10)'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](assets/10.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-10)'
- en: We remain connected to the web client, and wait for data on this specific client’s
    queue.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保持与 Web 客户端的连接，并等待该特定客户端队列中的数据。
- en: '[![11](assets/11.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-11)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '[![11](assets/11.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-11)'
- en: As soon as the data comes in (inside `collector()`), it will be sent to the
    connected web client. Note that I reserialize the `data` dict here. An optimization
    to this code would be to avoid deserializing JSON in `collector()`, and instead
    use `sock.recv_string()` to avoid the serialization round trip. Of course, in
    a real scenario, you might want to deserialize in the collector, and perform some
    validation on the data before sending it to the browser client. So many choices!
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据进来（在`collector()`内部），它将被发送到连接的 Web 客户端。请注意，我在这里重新序列化了`data`字典。优化此代码的一个方法是避免在`collector()`中反序列化
    JSON，而是使用`sock.recv_string()`来避免序列化往返。当然，在真实场景中，您可能希望在收集器中进行反序列化，并在将数据发送到浏览器客户端之前对数据进行一些验证。选择太多了！
- en: '[![12](assets/12.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-12)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '[![12](assets/12.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-12)'
- en: The `index()` endpoint is the primary page load, and here we serve a static
    file called *charts.html*.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`index()`端点是主要页面加载点，在这里我们提供一个名为*charts.html*的静态文件。'
- en: '[![13](assets/13.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-13)'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '[![13](assets/13.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-13)'
- en: The `aiohttp` library provides facilities for us to hook in additional long-lived
    coroutines we might need. With the `collector()` coroutine, we have exactly that
    situation, so I create a startup coroutine, `start_collector()`, and a shutdown
    coroutine. These will be called during specific phases of `aiohttp`’s startup
    and shutdown sequence. Note that I add the collector task to the `app` itself,
    which implements a mapping protocol so that you can use it like a dict.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`aiohttp`库为我们提供了便利设施，用于挂接我们可能需要的额外长期存在的协程。有了`collector()`协程，我们正好有了这种情况，所以我创建了一个启动协程`start_collector()`和一个关闭协程。这些将在`aiohttp`的启动和关闭序列的特定阶段调用。请注意，我将收集器任务添加到`app`本身，它实现了映射协议，以便您可以像使用字典一样使用它。'
- en: '[![14](assets/14.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-14)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '[![14](assets/14.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-14)'
- en: I obtain our `collector()` coroutine off the `app` identifier and call `cancel()`
    on that.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我从`app`标识符获取我们的`collector()`协程，并在其上调用`cancel()`。
- en: '[![15](assets/15.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-15)'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '[![15](assets/15.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO14-15)'
- en: 'Finally, you can see where the custom startup and shutdown coroutines are hooked
    in: the `app` instance provides hooks to which our custom coroutines may be appended.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以看到自定义启动和关闭协程的挂钩位置：`app`实例提供了可以附加我们自定义协程的挂钩。
- en: All that remains is the visualization layer, shown in [Example 4-20](#vislayer).
    I’m using the [Smoothie Charts library](http://smoothiecharts.org) to generate
    scrolling charts, and the complete HTML for our main (and only) web page, *charts.html*,
    is provided in the [Example B-1](app02.html#corobot). There is too much HTML,
    CSS, and JavaScript to present in this section, but I do want to highlight a few
    points about how the server-sent events are handled in JavaScript in the browser
    client.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一剩下的就是可视化层，显示在[示例 4-20](#vislayer)中。我正在使用[Smoothie Charts 库](http://smoothiecharts.org)生成滚动图表，并且我们的主要（也是唯一的）网页
    *charts.html* 的完整 HTML 提供在[示例 B-1](app02.html#corobot)中。这里有太多的 HTML、CSS 和 JavaScript
    要展示在本节中，但我确实想强调一下在浏览器客户端中如何处理服务器发送的事件。
- en: Example 4-20\. The visualization layer, which is a fancy way of saying “the
    browser”
  id: totrans-376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-20。可视化层，这是一种说法，即“浏览器”
- en: '[PRE23]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO15-1)'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO15-1)'
- en: Create a new `EventSource()` instance on the */feed* URL. The browser will connect
    to */feed* on our server, (*metric_server.py*). Note that the browser will automatically
    try to reconnect if the connection is lost. Server-sent events are often overlooked,
    but in many situations their simplicity makes them preferable to WebSockets.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在 */feed* URL 上创建一个新的 `EventSource()` 实例。浏览器将连接到我们服务器上的 */feed*（*metric_server.py*）。请注意，如果连接丢失，浏览器将自动尝试重新连接。服务器发送的事件经常被忽视，但在许多情况下，它们的简单性使它们比
    WebSockets 更可取。
- en: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO15-2)'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO15-2)'
- en: The `onmessage` event will fire every time the server sends data. Here the data
    is parsed as JSON.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 每当服务器发送数据时，`onmessage` 事件将触发。这里的数据被解析为 JSON。
- en: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO15-3)'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO15-3)'
- en: The `cpu` identifier is a mapping of a color to a `TimeSeries()` instance (for
    more on this, see [Example B-1](app02.html#corobot)). Here, we obtain that time
    series and append data to it. We also obtain the timestamp and parse it to get
    the correct format required by the chart.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`cpu` 标识符是颜色到 `TimeSeries()` 实例的映射（有关更多信息，请参见[示例 B-1](app02.html#corobot)）。在这里，我们获取了该时间序列并向其追加数据。我们还获取时间戳并解析它以获取图表所需的正确格式。'
- en: 'Now we can run the code. To get the whole show moving, a bunch of command-line
    instructions are required, the first of which is to start up the data collector
    process:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行代码了。要让整个流程启动起来，需要一堆命令行指令，其中第一个是启动数据收集器进程：
- en: '[PRE24]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The next step is to start up all the microservice instances. These will send
    their CPU and memory usage metrics to the collector. Each will be identified by
    a different color, which is specified on the command line. Note how two of the
    microservices are told to leak some memory:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是启动所有微服务实例。它们将向收集器发送它们的 CPU 和内存使用情况指标。每个微服务将由不同的颜色标识，这是在命令行上指定的。注意两个微服务如何被告知泄漏一些内存：
- en: '[PRE25]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[Figure 4-2](#appmonshot) shows our final product in a browser. You’ll have
    to take my word for it that the graphs really do animate. You’ll notice in the
    preceding command lines that I added some memory leakage to blue, and a lot to
    green. I even had to restart the green service a few times to prevent it from
    climbing over 100 MB.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-2](#appmonshot)在浏览器中显示了我们的最终产品。您只能相信图形确实是动画的。您会注意到在前面的命令行中，我向蓝色添加了一些内存泄漏，并且向绿色添加了很多内存泄漏。我甚至不得不几次重新启动绿色服务以防止其超过
    100 MB。'
- en: '![uaip 0402](assets/uaip_0402.png)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![uaip 0402](assets/uaip_0402.png)'
- en: Figure 4-2\. We’d better get an SRE on green ASAP!
  id: totrans-390
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-2。我们最好尽快找个 SRE 来处理绿色！
- en: 'What is especially interesting about this project is this: *any* of the running
    instances in any part of this stack can be restarted, and no reconnect-handling
    code is necessary. The ØMQ sockets, along with the `EventSource()` JavaScript
    instance in the browser, magically reconnect and pick up where they left off.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目特别有趣的地方在于：*这个堆栈中的任何部分中运行的任何实例*都可以重新启动，而且不需要重新连接处理代码。ØMQ sockets 以及浏览器中的
    `EventSource()` JavaScript 实例会自动重新连接并继续上次断开的地方。
- en: In the next section, we turn our attention to databases and to how `asyncio`
    might be used to design a system for cache invalidation.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将把注意力转向数据库，以及如何使用 `asyncio` 设计一个用于缓存失效的系统。
- en: asyncpg and Sanic
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: asyncpg 和 Sanic
- en: The [`asyncpg` library](https://oreil.ly/yGdNh) provides client access to the
    PostgreSQL database, but differentiates itself from other `asyncio`-compatible
    Postgres client libraries with its emphasis on speed. `asyncpg` is authored by
    [Yury Selivanov](https://twitter.com/1st1), one of the core `asyncio` Python developers,
    who is also the author of the uvloop project. It has no third-party dependencies,
    although [Cython](http://cython.org) is required if you’re installing from source.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '[`asyncpg` 库](https://oreil.ly/yGdNh) 提供了访问 PostgreSQL 数据库的客户端，但与其他 `asyncio`
    兼容的 Postgres 客户端库不同，它侧重于速度。`asyncpg` 的作者是 [Yury Selivanov](https://twitter.com/1st1)，他是核心
    `asyncio` Python 开发人员之一，也是 uvloop 项目的作者。它没有第三方依赖，但如果您从源代码安装，需要 [Cython](http://cython.org)。'
- en: '`asyncpg` achieves its speed by working directly against the PostgreSQL binary
    protocol, and other advantages to this low-level approach include support for
    [prepared statements](http://bit.ly/2sMNlIz) and [scrollable cursors](http://bit.ly/2Chr0H5).'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncpg` 通过直接使用 PostgreSQL 二进制协议来实现其速度优势，这种低级方法的其他优势包括支持 [预处理语句](http://bit.ly/2sMNlIz)
    和 [可滚动游标](http://bit.ly/2Chr0H5)。'
- en: 'We’ll be looking at a case study using `asyncpg` for cache invalidation, but
    before that it will be useful to get a basic understanding of the API `asyncpg`
    provides. For all of the code in this section, we’ll need a running instance of
    PostgreSQL. This is most easily done with Docker, using the following command:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用 `asyncpg` 进行缓存失效的案例研究，但在此之前，理解 `asyncpg` 提供的 API 基础知识将非常有用。在本节的所有代码中，我们需要一个正在运行的
    PostgreSQL 实例。可以通过 Docker 最轻松地实现这一点，使用以下命令：
- en: '[PRE26]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that I’ve exposed port 55432 rather than the default, 5432, just in case
    you already have a running instance of the database on the default port. [Example 4-21](#asyncpgdemo)
    briefly demonstrates how to use `asyncpg` to talk to PostgreSQL.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我暴露了端口 55432，而不是默认的 5432，以防万一您已经在默认端口上运行了数据库实例。[示例 4-21](#asyncpgdemo) 简要演示了如何使用
    `asyncpg` 与 PostgreSQL 进行通信。
- en: Example 4-21\. Basic demo of asyncpg
  id: totrans-399
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-21\. `asyncpg` 的基本演示
- en: '[PRE27]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO16-1)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO16-1)'
- en: I’ve hidden some boilerplate away in a tiny `util` module to simplify things
    and keep the core message.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将一些样板代码隐藏在一个小的 `util` 模块中，以简化事务并保持核心信息。
- en: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO16-2)'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO16-2)'
- en: The `Database` class gives us a context manager that will create a new database
    for us—in this, case named `test`—and will destroy that database when the context
    manager exits. This turns out to be very useful when experimenting with ideas
    in code. Because no state is carried over between experiments, you start from
    a clean database every time. Note that this is an `async with` context manager;
    we’ll talk more about that later, but for now, the focal area of this demo is
    what happens inside the `demo()` coroutine.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`Database` 类为我们提供了一个上下文管理器，该管理器将为我们创建一个新数据库，本例中命名为 `test`，并在退出上下文管理器时销毁该数据库。在代码中尝试不同想法时，这非常有用。由于在实验之间没有状态传递，每次都从一个干净的数据库开始。请注意，这是一个
    `async with` 上下文管理器；稍后我们会详细讨论这一点，但现在，这个演示的焦点区域是 `demo()` 协程内部发生的事情。'
- en: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO16-3)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO16-3)'
- en: The `Database` context manager has provided us with a `Connection` instance,
    which is immediately used to create a new table, `users`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`Database` 上下文管理器为我们提供了一个 `Connection` 实例，该实例立即用于创建一个新表 `users`。'
- en: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO16-4)'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO16-4)'
- en: I use `fetchval()` to insert a new record. While I could have used `execute()`
    to do the insertion, the benefit of using `fetchval()` is that I can obtain the
    `id` of the newly inserted record, which I store in the `pk` identifier.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 `fetchval()` 来插入新记录。虽然我可以使用 `execute()` 来执行插入操作，但使用 `fetchval()` 的好处在于我可以获取新插入记录的
    `id`，并将其存储在 `pk` 标识符中。
- en: Note that I use *parameters* (`$1` and `$2`) for passing data to the SQL query.
    *Never* use string interpolation or concatenation to build queries, as this is
    a security risk!
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我使用 *参数* (`$1` 和 `$2`) 将数据传递给 SQL 查询。永远不要使用字符串插值或串联来构建查询，因为这会造成安全风险！
- en: '[![5](assets/5.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO16-5)'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO16-5)'
- en: In the remainder of this demo, I’m going to be manipulating data in the `users`
    table, so here I make a new utility coroutine function that fetches a record in
    the table. This will be called several times.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在此演示的其余部分中，我将操作`users`表中的数据，所以在这里我创建一个新的实用协程函数，用于从表中获取记录。这将被多次调用。
- en: '[![6](assets/6.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO16-6)'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO16-6)'
- en: When *retrieving* data, it is far more useful to use the `fetch`-based methods,
    because these will return `Record` objects. `asyncpg` will automatically cast
    datatypes to the most appropriate types for Python.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '*检索*数据时，使用`fetch`系列方法要更有用，因为这些将返回`Record`对象。`asyncpg`将自动将数据类型转换为Python中最合适的类型。'
- en: '[![7](assets/7.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO16-7)'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO16-7)'
- en: I immediately use the `get_row()` helper to display the newly inserted record.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我立即使用`get_row()`辅助函数显示新插入的记录。
- en: '[![8](assets/8.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO16-8)'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO16-8)'
- en: 'I modify data by using the `UPDATE` command for SQL. It’s a tiny modification:
    the year value in the date of birth is changed by one year. As before, this is
    performed with the connection’s `execute()` method. The remainder of the code
    demo follows the same structure as seen so far, and a `DELETE`, followed by another
    `print()`, happens a few lines down.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用SQL的`UPDATE`命令修改数据。这是一个微小的修改：出生日期中的年份加了一年。与之前一样，这是通过连接的`execute()`方法执行的。代码演示的其余部分与迄今为止所见相同的结构，并在几行下面进行`DELETE`，然后又一个`print()`。
- en: 'Here’s the output of running this script:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本的输出如下：
- en: '[PRE28]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note how the date value retrieved in our `Record` object has been converted
    to a Python `date` object: `asyncpg` has automatically converted the datatype
    from the SQL type to its Python counterpart. A large table of [type conversions](http://bit.ly/2sQszaQ)
    in the `asyncpg` documentation describes all the type mappings that are built
    into the library.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们的`Record`对象中检索的日期值已转换为Python的`date`对象：`asyncpg`已自动将数据类型从SQL类型转换为其Python对应类型。在`asyncpg`文档中，一个[类型转换](http://bit.ly/2sQszaQ)的大表格描述了所有内置到库中的类型映射。
- en: The preceding code is very simple, perhaps even crudely so if you’re used to
    the convenience of object-relational mappers (ORMs) like SQLAlchemy or the Django
    web framework’s built-in ORM. At the end of this chapter, I mention several third-party
    libraries that provide access to ORMs or ORM-like features for `asyncpg`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码非常简单，如果您习惯于对象关系映射器（ORM）（如SQLAlchemy或Django web框架的内置ORM）的便利，甚至可能有点粗糙。在本章的最后，我提到了几个第三方库，它们提供了访问ORM或类似ORM功能的`asyncpg`的功能。
- en: '[Example 4-22](#dbobject) shows my boilerplate `Database` object in the `utils`
    module; you may find it useful to make something similar for your own experiments.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-22](#dbobject)显示了我在`utils`模块中的样板`Database`对象；您可能会发现制作类似的东西对您自己的实验很有用。'
- en: Example 4-22\. Useful tooling for your asyncpg experiments
  id: totrans-423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-22\. 用于您的 asyncpg 实验的有用工具
- en: '[PRE29]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO17-1)'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO17-1)'
- en: The `Database` class is just a fancy context manager for creating and deleting
    a database from a PostgreSQL instance. The database name is passed into the constructor.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`Database`类只是一个炫酷的上下文管理器，用于从PostgreSQL实例中创建和删除数据库。数据库名称传递到构造函数中。'
- en: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO17-6)'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO17-6)'
- en: '(Note: The sequence of callouts in the code is intentionally different from
    this list.) This is an *asynchronous* context manager. Instead of the usual `__enter__()`
    and `__exit__()` methods, I use their `__aenter__()` and `__aexit__()` counterparts.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: （注意：代码中的注释序列与此列表有意不同。）这是一个*异步*上下文管理器。我使用它们的`__aenter__()`和`__aexit__()`对应方法，而不是通常的`__enter__()`和`__exit__()`方法。
- en: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO17-2)'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO17-2)'
- en: Here, in the entering side, I’ll create the new database and return a connection
    to that new database. `server_command()` is another helper method defined a few
    lines down. I use it to run the command for creating our new database.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将在进入侧创建新的数据库，并返回一个连接到这个新数据库的对象。`server_command()` 是另一个帮助方法，在几行下面定义。我使用它来运行创建新数据库的命令。
- en: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO17-3)'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO17-3)'
- en: 'I then make a connection to the newly created database. Note that I’ve hardcoded
    several details about the connection: this is intentional, as I wanted to keep
    the code samples small. You could easily generalize this by making fields for
    the username, hostname, and port.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我连接到新创建的数据库。请注意，我已经硬编码了关于连接的一些细节：这是故意的，因为我想保持代码示例的简洁。你可以通过为用户名、主机名和端口创建字段来轻松地泛化这些细节。
- en: '[![5](assets/5.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO17-4)'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO17-4)'
- en: In the exiting side of the context manager, I close the connection and…
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在上下文管理器的退出侧，我关闭连接并且
- en: '[![6](assets/6.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO17-5)'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO17-5)'
- en: …destroy the database.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: …销毁数据库。
- en: '[![7](assets/7.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO17-7)'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO17-7)'
- en: For completeness, this is our utility method for running commands against the
    PostgreSQL server itself. It creates a connection for that purpose, runs the given
    command, and exits.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，这是我们用于在 PostgreSQL 服务器本身运行命令的实用方法。它创建一个连接，运行给定的命令，然后退出。
- en: '[![8](assets/8.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO17-8)'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO17-8)'
- en: This function creates a long-lived socket connection to the database that will
    listen for events. This mechanism will be featured in the upcoming case study.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数创建了一个长期存在的套接字连接到数据库，用于监听事件。这种机制将在即将到来的案例研究中展示。
- en: Caution
  id: totrans-441
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In point 8 for the preceding code, I created a dedicated connection for each
    channel I want to listen on. This is expensive since it means that a PostgreSQL
    worker will be completely tied up for every channel being listened to. A much
    better design would be to use one connection for multiple channels. Once you have
    worked through this example, try to modify the code to use a single connection
    for multiple channel listeners.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码的第 8 点中，我为每个我想监听的频道创建了一个专用连接。这是昂贵的，因为这意味着每个被监听的频道都将完全占用一个 PostgreSQL 工作进程。一个更好的设计是为多个频道使用一个连接。当你完成这个例子后，请尝试修改代码，以便使用单个连接来监听多个频道。
- en: 'Now that you have an understanding of the basic building blocks of `asyncpg`,
    we can explore it further with a really fun case study: using PostgreSQL’s built-in
    support for sending event notifications to perform cache invalidation!'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了`asyncpg`的基本构建块，我们可以通过一个非常有趣的案例研究来进一步探索它：使用 PostgreSQL 内置的支持发送事件通知以执行缓存失效！
- en: 'Case Study: Cache Invalidation'
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究：缓存失效
- en: 'There are two hard things in computer science: cache invalidation, naming things,
    and off-by-one errors.'
  id: totrans-445
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 计算机科学中有两件难事：缓存失效、命名事物和 off-by-one 错误。
- en: ''
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Phil Karlton
  id: totrans-447
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Phil Karlton
- en: It is common in web services and web applications that the persistence layer,
    i.e., the backing database (DB), becomes the performance bottleneck sooner than
    any other part of the stack. The application layer can usually be scaled horizontally
    by running more instances, whereas it’s trickier to do that with a database.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 服务和 Web 应用程序中，持久层即后端数据库（DB）通常比堆栈中的任何其他部分更快成为性能瓶颈。应用层通常可以通过运行更多实例来实现水平扩展，而对于数据库来说，这样做就比较棘手了。
- en: This is why it’s common practice to look at design options that can limit excessive
    interaction with the database. The most common option is to use *caching* to “remember”
    previously fetched database results and replay them when asked, thus avoiding
    subsequent calls to the DB for the same information.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么通常要考虑设计选项，以限制与数据库的过度交互。最常见的选项是使用*caching*来“记住”先前获取的数据库结果，并在需要时重播它们，从而避免再次调用
    DB 获取相同的信息。
- en: However, what happens if one of your app instances writes new data to the database
    while another app instance is still returning the old, stale data from its internal
    cache? This is a classic *cache invalidation* problem, and it can be very difficult
    to resolve in a robust way.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你的一个应用实例在另一个应用实例仍然从其内部缓存返回旧的陈旧数据时写入新数据到数据库会发生什么呢？这是一个经典的*缓存失效*问题，在稳健的解决方案中可能非常难以解决。
- en: 'Our attack strategy is as follows:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的攻击策略如下：
- en: Each app instance has an in-memory cache of DB queries.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个应用实例都有一个内存中的数据库查询缓存。
- en: When one writes new data to the database, the database alerts all of the connected
    app instances of the new data.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当某个应用实例向数据库写入新数据时，数据库会通知所有连接的应用实例新数据的情况。
- en: Each app instance then updates its internal cache accordingly.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，每个应用实例相应地更新其内部缓存。
- en: This case study will highlight how PostgreSQL, with its built-in support for
    event updates via the [`LISTEN`](http://bit.ly/2EP9yeJ) and [`NOTIFY`](http://bit.ly/2BN5lp1)
    commands, can simply *tell us* when its data has changed.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这个案例研究将重点介绍如何利用PostgreSQL的内置支持通过[`LISTEN`](http://bit.ly/2EP9yeJ)和[`NOTIFY`](http://bit.ly/2BN5lp1)命令进行事件更新，可以简单地*告诉我们*数据何时发生了变化。
- en: '`asyncpg` already has support for the `LISTEN`/`NOTIFY` API. This feature of
    PostgreSQL allows your app to subscribe to events on a named channel and to post
    events to named channels. PostgreSQL can almost become a lighter version of [RabbitMQ](https://oreil.ly/jvDgm)
    or [ActiveMQ](https://oreil.ly/yiaK0)!'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncpg`已经支持`LISTEN`/`NOTIFY` API。PostgreSQL的这一特性允许你的应用订阅命名通道上的事件，并在命名通道上发布事件。PostgreSQL几乎可以成为[RabbitMQ](https://oreil.ly/jvDgm)或[ActiveMQ](https://oreil.ly/yiaK0)的一个轻量级版本！'
- en: This case study has more moving parts than usual, and that makes it awkward
    to present in the usual linear format. Instead, we’ll begin by looking at the
    final product, and work backward toward the underlying implementation.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这个案例研究的部件比通常的要复杂得多，这使得以通常的线性格式呈现起来很尴尬。相反，我们将从最终产品开始查看，并向后工作到底层实现。
- en: 'Our app provides a JSON-based API server for managing the favorite dishes of
    patrons at our robotic restaurant. The backing database will have only one table,
    `patron`, with only two fields: `name` and `fav_dish`. Our API will allow the
    usual set of four operations: *create*, *read*, *update*, and *delete* (CRUD).'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用为管理我们机器人餐厅客户最喜爱菜肴提供基于JSON的API服务器。后台数据库只有一个名为`patron`的表，只有两个字段：`name`和`fav_dish`。我们的API将允许四种常见操作：*创建*、*读取*、*更新*和*删除*（CRUD）。
- en: 'The following is a sample interaction with our API using `curl`, illustrating
    how to create a new entry in our database (I haven’t yet shown how to start up
    the server running on *localhost:8000*; that will come later):'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`curl`与我们API的样例交互，展示如何在我们的数据库中创建新条目（我还没有展示如何在*localhost:8000*上启动运行的服务器；稍后会详细说明）：
- en: '[PRE30]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `-d` parameter is for data,^([2](ch04.html#idm46363020071448)) `-H` is for
    the HTTP headers, `-X` is for the HTTP request method (alternatives include `GET`,
    `DELETE`, `PUT`, and a few others), and the URL is for our API server. We’ll get
    to the code for that shortly.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '`-d`参数用于数据，^([2](ch04.html#idm46363020071448)) `-H`用于HTTP头部，`-X`用于HTTP请求方法（其他选择包括`GET`、`DELETE`、`PUT`和几个其他方法），URL用于我们的API服务器。我们稍后会详细介绍其代码。'
- en: In the output, we see that the creation was `ok`, and the `id` being returned
    is the primary key of the new record in the database.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们看到创建是`ok`，返回的`id`是数据库中新记录的主键。
- en: 'In the next few shell snippets, we’ll run through the other three operations:
    *read*, *update*, and *delete*. We can read the patron record we just created
    with this command:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个Shell代码段中，我们将运行另外三个操作：*读取*、*更新*和*删除*。我们可以使用以下命令读取我们刚刚创建的客户记录：
- en: '[PRE31]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Reading the data is pretty straightforward. Note that the `id` of the desired
    record must be supplied in the URL.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 读取数据非常简单。请注意，在URL中必须提供所需记录的`id`。
- en: 'Next, we’ll update the record and check the results:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更新记录并检查结果：
- en: '[PRE33]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Updating a resource is similar to creating one, with two key differences:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 更新资源类似于创建资源，但有两个关键区别：
- en: The HTTP request method (`-X`) is `PUT`, not `POST`.
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP请求方法（`-X`）是`PUT`，而不是`POST`。
- en: The URL now requires the `id` field to specify which resource to update.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，URL需要`id`字段来指定要更新的资源。
- en: 'Finally, we can delete the record and verify its deletion with the following
    commands:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以删除记录并使用以下命令验证其删除：
- en: '[PRE34]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, `null` is returned when you try to `GET` a record that doesn’t
    exist.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，尝试`GET`不存在的记录时会返回`null`。
- en: 'So far this all looks quite ordinary, but our objective is not only to make
    a CRUD API—we want to look at cache invalidation. So, let’s turn our attention
    toward the cache. Now that we have a basic understanding of our app’s API, we
    can look at the application logs to see timing data for each request: this will
    tell us which requests are cached, and which hit the DB.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切看起来很普通，但我们的目标不仅仅是创建一个 CRUD API — 我们想要研究缓存失效。因此，让我们将注意力转向缓存。现在我们对应用程序的
    API 有了基本的理解，我们可以查看应用程序日志，查看每个请求的时间数据：这将告诉我们哪些请求是缓存的，哪些是命中数据库的。
- en: 'When the server is first started up, the cache is empty; it’s a memory cache,
    after all. We’re going to start up our server, and then in a separate shell run
    two `GET` requests in quick succession:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器首次启动时，缓存是空的；毕竟它是一个内存缓存。我们将启动服务器，然后在另一个 shell 中快速连续运行两个`GET`请求：
- en: '[PRE35]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We expect that the first time we retrieve our record, there’s going to be a
    cache miss, and the second time, a hit. We can see evidence of this in the log
    for the API server itself (the first Sanic web server, running on *localhost:8000*):'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望第一次检索记录时，会发生缓存未命中，第二次则会命中。我们可以在 API 服务器本身的日志中看到这一点的证据（第一个运行在 *localhost:8000*
    上的 Sanic web 服务器）：
- en: '[PRE36]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO18-1)'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO18-1)'
- en: Everything up to this line is the default `sanic` startup log message.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一行为止，是默认的`sanic`启动日志消息。
- en: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO18-2)'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO18-2)'
- en: As described, the first `GET` results in a cache miss because the server has
    only just started.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 如描述的那样，第一次`GET`导致缓存未命中，因为服务器刚刚启动。
- en: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO18-3)'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO18-3)'
- en: This is from our first `curl -X GET`. I’ve added some timing functionality to
    the API endpoints. Here we can see that the handler for the `GET` request took
    ~4 ms.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次`curl -X GET`的结果。我已经为 API 端点添加了一些时间功能。在这里，我们可以看到处理`GET`请求的处理程序花费了约 4
    毫秒。
- en: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO18-4)'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO18-4)'
- en: The second `GET` returns data from the cache, and the much faster (100x faster!)
    timing data.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次`GET`从缓存返回数据，并且时间数据明显更快（快了100倍！）。
- en: So far, nothing unusual. Many web apps use caching in this way.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，还没有什么异常。许多 Web 应用程序都会以这种方式使用缓存。
- en: 'Now let’s start up a second app instance on port 8001 (the first instance was
    on port 8000):'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在端口8001上启动第二个应用实例（第一个实例在端口8000上）：
- en: '[PRE37]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Both instances, of course, connect to the same database. Now, with both API
    server instances running, let’s modify the data for patron *John*, who clearly
    lacks sufficient Spam in his diet. Here we perform an `UPDATE` against the first
    app instance at port 8000:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，两个实例都连接到同一个数据库。现在，两个 API 服务器实例正在运行，让我们修改“John”用户的数据，他显然缺乏足够的 Spam（垃圾邮件）在他的饮食中。在这里，我们对端口8000上的第一个应用实例执行`UPDATE`：
- en: '[PRE38]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Immediately after this update event on only one of the app instances, *both*
    API servers, 8000 and 8001, report the event in their respective logs:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在仅一个应用实例上的此更新事件之后，*两个* API 服务器，8000和8001，在各自的日志中都报告了这一事件：
- en: '[PRE39]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The database has reported the update event back to both app instances. We haven’t
    done any requests against app instance 8001 yet, though—does this mean that the
    new data is already cached there?
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库已经将更新事件返回到两个应用实例。尽管我们还没有对8001端口的应用实例做任何请求，这是否意味着新数据已经缓存在那里？
- en: 'To check, we can do a `GET` on the second server, at port 8001:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查，我们可以在第二个服务器，端口8001上执行`GET`：
- en: '[PRE40]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The timing info in the log output shows that we do indeed obtain the data directly
    from the cache, even though this is our first request:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志输出的时间信息显示，尽管这是我们的第一次请求，我们确实从缓存中直接获取了数据：
- en: '[PRE41]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The upshot is that when the database changes, *all connected app instances*
    get notified, allowing them to update their caches.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 结论是，当数据库发生更改时，*所有连接的应用实例* 都会收到通知，从而更新它们的缓存。
- en: 'With this explanation out of the way, we can now look at the `asyncpg` code
    implementation required to make our cache invalidation actually work. The basic
    design for the server code shown in [Example 4-23](#sanicdemo) is the following:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个解释之后，我们现在可以看一下实际上需要使我们的缓存失效的`asyncpg`代码实现。在 [示例 4-23](#sanicdemo) 中显示的服务器代码的基本设计如下：
- en: We have a simple web API using the new, `asyncio`-compatible [Sanic web framework](https://oreil.ly/q5eA4).
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用新的、与`asyncio`兼容的 [Sanic Web 框架](https://oreil.ly/q5eA4) 创建了一个简单的 Web API。
- en: The data will be stored in a backend PostgreSQL instance, but the API will be
    served via multiple instances of the web API app servers.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据将存储在后端的 PostgreSQL 实例中，但 API 将由多个 Web API 应用服务器实例提供。
- en: The app servers will cache data from the database.
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用服务器将缓存来自数据库的数据。
- en: The app servers will subscribe to events via `asyncpg` in specific tables on
    the DB, and will receive update notifications when the data in the DB table has
    been changed. This allows the app servers to update their individual in-memory
    caches.
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用服务器将通过`asyncpg`在特定表上订阅事件，并在数据库表中的数据更改时接收更新通知。这使得应用服务器能够更新其各自的内存缓存。
- en: Example 4-23\. API server with Sanic
  id: totrans-506
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-23\. Sanic API 服务器
- en: '[PRE42]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-1)'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-1)'
- en: The `Database` utility helper, as described earlier. This will provide the methods
    required to connect to the database.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前描述的，`Database`实用工具助手。这将提供连接到数据库所需的方法。
- en: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-2)'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-2)'
- en: Two more tools I’ve cobbled together to log the elapsed time of each API endpoint.
    I used this in the previous discussion to detect when a `GET` was being returned
    from the cache. The implementations for `aelapsed()` and `aprofiler()` are not
    important for this case study, but you can obtain them in [Example B-1](app02.html#corobot).
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 我又打造了两个工具，用来记录每个 API 端点的经过时间。在之前的讨论中，我用它来检测是否从缓存中返回了`GET`请求。`aelapsed()`和`aprofiler()`的实现对本案例不重要，但你可以在[示例 B-1](app02.html#corobot)中找到它们。
- en: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-3)'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-3)'
- en: We create the main Sanic app instance.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建主要的 Sanic 应用实例。
- en: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-4)'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-4)'
- en: 'This coroutine function is for creating new patron entries. In an `add_route()`
    call toward the bottom of the code, `new_patron()` is associated with the endpoint
    `/patron`, only for the `POST` HTTP method. The `@aelapsed` decorator is not part
    of the Sanic API: it’s my own invention, merely to log out timings for each call.'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 这个协程函数用于创建新的顾客条目。在代码底部的`add_route()`调用中，`new_patron()`与端点`/patron`相关联，仅限于`POST`
    HTTP方法。`@aelapsed`装饰器不是 Sanic API 的一部分：这是我自己的发明，仅用于记录每次调用的时间。
- en: '[![5](assets/5.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-5)'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-5)'
- en: Sanic provides immediate deserialization of received JSON data by using the
    `.json` attribute on the `request` object.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: Sanic 通过在`request`对象上使用`.json`属性，立即对接收到的 JSON 数据进行反序列化。
- en: '[![6](assets/6.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-6)'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-6)'
- en: The `model` module, which I imported, is the *model* for our `patron` table
    in the database. I’ll go through that in more detail in the next code listing;
    for now, just understand that all the database queries and SQL are in this `model`
    module. Here I’m passing the connection pool for the database, and the same pattern
    is used for all the interaction with the database model in this function and in
    the `PatronAPI` class further down.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 我导入的`model`模块是我们数据库中`patron`表的*模型*。我将在下一个代码列表中详细介绍它；现在只需了解所有数据库查询和 SQL 都在这个`model`模块中。这里我传递了数据库连接池，并且在这个函数和稍后的`PatronAPI`类中与数据库模型的所有交互都使用了相同的模式。
- en: '[![7](assets/7.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-7)'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-7)'
- en: A new primary key, `id`, will be created, and this is returned back to the caller
    as JSON.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 将创建一个新的主键`id`，并以 JSON 形式返回给调用者。
- en: '[![8](assets/8.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-8)'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-8)'
- en: While creation is handled in the `new_patron()` function, all other interactions
    are handled in this *class-based view*, which is a convenience provided by Sanic.
    All the methods in this class are associated with the same URL, `/patron/<id:int>`,
    which you can see in the `add_route()` function near the bottom. Note that the
    `id` URL parameter will be passed to each of the methods, and this parameter is
    required for all three endpoints.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然创建在 `new_patron()` 函数中处理，但所有其他交互都在这个 *基于类的视图* 中处理，这是 Sanic 提供的便利。此类中的所有方法都与同一个
    URL `/patron/<id:int>` 相关联，你可以在接近底部的 `add_route()` 函数中看到。请注意，`id` URL 参数将被传递给这些方法中的每一个，并且对于所有三个端点，此参数都是必需的。
- en: 'You can safely ignore the `metaclass` argument: all it does is wrap each method
    with the `@aelapsed` decorator so that timings will be printed in the logs. Again,
    this is not part of the Sanic API; it’s my own invention for logging timing data.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以安全地忽略 `metaclass` 参数：它的作用只是用 `@aelapsed` 装饰器包装每个方法，以便在日志中打印时间。同样，这不是 Sanic
    API 的一部分；这是我为了记录时间数据而发明的。
- en: '[![9](assets/9.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-9)'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-9)'
- en: As before, model interaction is performed inside the `model` module.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，模型交互是在 `model` 模块内执行的。
- en: '[![10](assets/10.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-10)'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](assets/10.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-10)'
- en: If the model reports failure for doing the update, I modify the response data.
    I’ve included this for readers who have not yet seen Python’s version of the *ternary
    operator*.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型报告更新操作失败，我会修改响应数据。我特意包含了这一点，以便还未见过 Python 版本的 *三元运算符* 的读者能够了解。
- en: '[![11](assets/11.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-11)'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '[![11](assets/11.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-11)'
- en: The `@app.listener` decorators are hooks provided by Sanic to give you a place
    to add extra actions during the startup and shutdown sequence. This one, `before_server_start`,
    is invoked before the API server is started up. This seems like a good place to
    initialize our database connection.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '`@app.listener` 装饰器是 Sanic 提供的钩子，用于在启动和关闭序列期间添加额外的操作。其中的 `before_server_start`
    钩子在 API 服务器启动前被调用。这似乎是初始化数据库连接的好地方。'
- en: '[![12](assets/12.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-12)'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '[![12](assets/12.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-12)'
- en: Use the `Database` helper to create a connection to our PostgreSQL instance.
    The DB we’re connecting to is `restaurant`.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Database` 辅助程序来连接到我们的 PostgreSQL 实例。我们连接的数据库是 `restaurant`。
- en: '[![13](assets/13.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-13)'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '[![13](assets/13.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-13)'
- en: Obtain a connection pool to our database.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 获取到连接池以连接到我们的数据库。
- en: '[![14](assets/14.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-14)'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '[![14](assets/14.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-14)'
- en: Use our model (for the `patron` table) to create the table if it’s missing.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的模型（用于 `patron` 表）来创建表格，如果表格不存在的话。
- en: '[![15](assets/15.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-15)'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '[![15](assets/15.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-15)'
- en: Use our model to create a dedicated_listener for database events, listening
    on the channel `chan_patron`. The callback function for these events is `model.db_event()`,
    which I’ll go through in the next listing. The callback will be called every time
    the database updates the channel.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的模型创建一个专用的监听器来监听数据库事件，监听的频道是 `chan_patron`。这些事件的回调函数是 `model.db_event()`，我将在下一个清单中详细介绍它。每当数据库更新通道时，都会调用此回调函数。
- en: '[![16](assets/16.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-16)'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '[![16](assets/16.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-16)'
- en: '`after_server_stop` is the hook for tasks that must happen during shutdown.
    Here we disconnect from the database.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '`after_server_stop` 是在关闭期间必须执行的任务的钩子。在这里我们断开与数据库的连接。'
- en: '[![17](assets/17.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-17)'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '[![17](assets/17.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-17)'
- en: This `add_route()` call sends `POST` requests for the `/patron` URL to the `new_patron()`
    coroutine function.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `add_route()` 调用将 `POST` 请求发送到 `/patron` URL，以执行 `new_patron()` 协程函数。
- en: '[![18](assets/18.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-18)'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '[![18](assets/18.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO19-18)'
- en: 'This `add_route()` call sends *all* requests for the `/patron/<id:int>` URL
    to the `PatronAPI` class-based view. The method names in that class determine
    which one is called: a `GET` HTTP request will call the `PatronAPI.get()` method,
    and so on.'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `add_route()` 调用将所有 `/patron/<id:int>` URL 的请求发送到基于类的视图 `PatronAPI`。该类中的方法名称决定调用哪个方法：`GET`
    HTTP 请求将调用 `PatronAPI.get()` 方法，依此类推。
- en: The preceding code contains all the HTTP handling for our server, as well as
    startup and shutdown tasks like setting up a connection pool to the database and,
    crucially, setting up a `db-event` listener on the `chan_patron` channel on the
    DB server.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码包含了服务器的所有 HTTP 处理，以及启动和关闭任务，比如设置到数据库的连接池，并且关键的是，在数据库服务器的 `chan_patron` 通道上设置了
    `db-event` 监听器。
- en: '[Example 4-24](#sanicdbmodel) presents the model for the `patron` table in
    the database.'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-24](#sanicdbmodel) 展示了数据库中 `patron` 表的模型。'
- en: Example 4-24\. DB model for the “patron” table
  id: totrans-547
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-24\. “patron” 表的数据库模型
- en: '[PRE43]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO20-1)'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO20-1)'
- en: You have to add triggers to the database in order to get notifications when
    data changes. I’ve created these handy helpers to create the trigger function
    itself (with `create_notify_trigger`) and to add the trigger to a specific table
    (with `add_table_triggers`). The SQL required to do this is somewhat out of scope
    for this book, but it’s still crucial to understanding how this case study works.
    I’ve included the annotated code for these triggers in [Appendix B](app02.html#corobot).
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中添加触发器以便在数据更改时获得通知是非常相似的。我已经创建了这些方便的助手函数来创建触发器函数本身（使用 `create_notify_trigger`）和将触发器添加到特定表中（使用
    `add_table_triggers`）。这本书不会详细讨论如何执行此操作，但是理解这个案例研究的关键性是非常重要的。我在附录 B 中包含了这些触发器的注释代码。
- en: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO20-2)'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO20-2)'
- en: The third-party `boltons` package provides a bunch of useful tools, not the
    least of which is the `LRU` cache, a more versatile option than the `@lru_cache`
    decorator in the `functools` standard library module.^([3](ch04.html#idm46363021245640))
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方 `boltons` 包提供了一堆有用的工具，其中包括 `LRU` 缓存，比 `functools` 标准库模块中的 `@lru_cache` 装饰器更加灵活的选择。^([3](ch04.html#idm46363021245640))
- en: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO20-3)'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO20-3)'
- en: 'This block of text holds all the SQL for the standard CRUD operations. Note
    that I’m using native PostgreSQL syntax for the parameters: `$1`, `$2`, and so
    on. There is nothing novel here, and it won’t be discussed further.'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 此文本块包含了标准 CRUD 操作的所有 SQL。请注意，我在参数中使用了原生的 PostgreSQL 语法：`$1`、`$2` 等等。这里没有什么新颖的东西，不会再进一步讨论。
- en: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO20-4)'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO20-4)'
- en: Create the cache for this app instance.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 为此应用程序实例创建缓存。
- en: '[![5](assets/5.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO20-5)'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO20-5)'
- en: I called this function from the Sanic module inside the `new_patron()` endpoint
    for adding new patrons. Inside the function, I use the `fetchval()` method to
    insert new data. Why `fetchval()` and not `execute()`? Because `fetchval()` returns
    the primary key of the new inserted record!^([4](ch04.html#idm46363020825512))
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加新的客户端的 `new_patron()` 端点内，我从 Sanic 模块调用了这个函数。在函数内部，我使用了 `fetchval()` 方法来插入新数据。为什么用
    `fetchval()`而不是 `execute()`？因为 `fetchval()` 返回新插入记录的主键！^([4](ch04.html#idm46363020825512))
- en: '[![6](assets/6.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO20-6)'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO20-6)'
- en: Update an existing record. When this succeeds, PostgreSQL will return `UPDATE
    1`, so I use that as a check to verify that the update succeeded.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 更新现有记录。当这成功时，PostgreSQL 将返回 `UPDATE 1`，所以我用它作为检查更新成功的标志。
- en: '[![7](assets/7.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO20-7)'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO20-7)'
- en: Deletion is very similar to updating.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 删除与更新非常相似。
- en: '[![8](assets/8.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO20-8)'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO20-8)'
- en: 'This is the read operation. This is the only part of our CRUD interface that
    cares about the cache. Think about that for a second: we don’t update the cache
    when doing an insert, update, or delete. This is because we rely on the async
    notification from the database (via the installed triggers) to update the cache
    if any data is changed.'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 这是读取操作。这是我们 CRUD 接口中唯一关心缓存的部分。想想这个：在插入、更新或删除时，我们不更新缓存。这是因为我们依赖来自数据库的异步通知（通过安装的触发器）来更新缓存，如果数据有任何更改的话。
- en: '[![9](assets/9.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO20-9)'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO20-9)'
- en: Of course, we do still want to use the cache after the first `GET`.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在第一次 `GET` 后我们仍然希望使用缓存。
- en: '[![10](assets/10.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO20-10)'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](assets/10.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO20-10)'
- en: The `db_event()` function is the callback that `asyncpg` will make when there
    are events on our DB notification channel, `chan_patron`. This specific parameter
    list is required by `asyncpg`. `conn` is the connection on which the event was
    sent, `pid` is the process ID of the PostgreSQL instance that sent the event,
    `channel` is the name of the channel (which in this case will be `chan_patron`),
    and the payload is the data being sent on the channel.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '`db_event()` 函数是 `asyncpg` 在我们的数据库通知通道 `chan_patron` 上发生事件时调用的回调函数。`asyncpg`
    要求的特定参数列表包括：`conn` 是发送事件的连接，`pid` 是发送事件的 PostgreSQL 实例的进程 ID，`channel` 是通道的名称（在本例中将是
    `chan_patron`），payload 是在通道上发送的数据。'
- en: '[![11](assets/11.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO20-11)'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '[![11](assets/11.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO20-11)'
- en: Deserialize the JSON data to a dict.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 将 JSON 数据反序列化为字典。
- en: '[![12](assets/12.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO20-12)'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '[![12](assets/12.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO20-12)'
- en: The cache population is generally quite straightforward, but note that update
    events contain both new and old data, so we need to make sure to cache the new
    data only.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存填充通常非常简单，但请注意更新事件包含新旧数据，因此我们需要确保仅缓存新数据。
- en: '[![13](assets/13.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO20-13)'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '[![13](assets/13.png)](#co_20_asyncio_libraries_you_aren__8217_t_using__but__8230_oh__never_mind__CO20-13)'
- en: This is a small utility function I’ve made to easily re-create a table if it’s
    missing. This is really useful if you need to do this frequently—such as when
    writing the code samples for this book!
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我做的一个小实用函数，可以轻松重新创建表格，如果它丢失了的话。如果你经常需要这样做，比如在为本书编写代码示例时，这将非常有用！
- en: This is also where the database notification triggers are created and added
    to our `patron` table. See [Example B-1](app02.html#corobot) for annotated listing
    of these functions.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是数据库通知触发器被创建并添加到我们的 `patron` 表的地方。有关这些函数的带注释的清单，请参见 [示例 B-1](app02.html#corobot)。
- en: That brings us to the end of this case study. We’ve seen how Sanic makes it
    very simple to create an API server, and we’ve seen how to use `asyncpg` for performing
    queries via a connection pool, and how to use PostgreSQL’s async notification
    features to receive callbacks over a dedicated, long-lived database connection.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本案例研究的结束。我们看到 Sanic 如何简单地创建 API 服务器，以及如何使用 `asyncpg` 通过连接池执行查询，以及如何利用 PostgreSQL
    的异步通知特性在长连接上接收回调。
- en: Many people prefer to use object-relational mappers to work with databases,
    and in this area, [SQLAlchemy](https://www.sqlalchemy.org) is the leader. There
    is growing support for using SQLAlchemy together with `asyncpg` in third-party
    libraries like [`asyncpgsa`](https://oreil.ly/TAKwC) and [GINO](https://oreil.ly/a4qOR).
    Another popular ORM, [Peewee](https://oreil.ly/pl0Gn), is given support for `asyncio`
    through the [`aiopeewee`](https://oreil.ly/76dzO) package.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 很多人喜欢使用对象关系映射器来操作数据库，在这方面，[SQLAlchemy](https://www.sqlalchemy.org) 是领导者。越来越多的第三方库支持使用
    SQLAlchemy 与 `asyncpg` 结合，比如 [`asyncpgsa`](https://oreil.ly/TAKwC) 和 [GINO](https://oreil.ly/a4qOR)。另一个流行的
    ORM，[Peewee](https://oreil.ly/pl0Gn)，通过 [`aiopeewee`](https://oreil.ly/76dzO)
    包也支持 `asyncio`。
- en: Other Libraries and Resources
  id: totrans-578
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他库和资源
- en: There are many other libraries for `asyncio` not covered in this book. To find
    out more, you can check out the [`aio-libs` project](https://oreil.ly/40Uf_),
    which manages nearly 40 libraries, and the [Awesome `asyncio` project](https://oreil.ly/SsC_0),
    which bookmarks many other projects compatible with the `asyncio` module.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多未在本书中涵盖的 `asyncio` 库。想要了解更多信息，你可以查看管理近 40 个库的 [`aio-libs` 项目](https://oreil.ly/40Uf_)，以及收藏了许多与
    `asyncio` 模块兼容的其他项目的 [Awesome `asyncio` 项目](https://oreil.ly/SsC_0)。
- en: One library that bears special mention is [`aiofiles`](https://oreil.ly/6ThkG).
    As you may recall from our earlier discussions, I said that to achieve high concurrency
    in Asyncio, it is vitally important that the loop never block. In this context,
    our focus on blocking operations has been exclusively network-based I/O, but it
    turns out that disk access is also a blocking operation that will impact your
    performance at very high concurrency levels. The solution to this is `aiofiles`,
    which provides a convenient wrapper for performing disk access in a thread. This
    works because Python releases the GIL during file operations so your main thread
    (running the `asyncio` loop) is unaffected.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 特别要提到的一个库是 [`aiofiles`](https://oreil.ly/6ThkG)。正如你可能还记得我们之前的讨论，为了在 Asyncio
    中实现高并发，循环永远不能被阻塞是非常重要的。在这个背景下，我们关注的阻塞操作一直是基于网络的 I/O，但事实证明，磁盘访问也是会阻塞的操作，在非常高的并发水平下会影响性能。解决这个问题的方法是使用
    `aiofiles`，它为在线程中执行磁盘访问提供了一个方便的包装器。这有效是因为 Python 在文件操作期间会释放 GIL，因此你的主线程（运行 `asyncio`
    循环的线程）不会受到影响。
- en: The most important domain for Asyncio is going to be network programming. For
    this reason, it’s not a bad idea to learn a little about socket programming, and
    even after all these years, Gordon McMillan’s [“Socket Programming HOWTO”](http://bit.ly/2sQt2d6),
    included with the standard Python documentation, is one of the best introductions
    you’ll find.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: Asyncio 最重要的领域将是网络编程。因此，学习一些套接字编程并不是一个坏主意，即使经过这么多年，Gordon McMillan 的 [“Socket
    Programming HOWTO”](http://bit.ly/2sQt2d6) 仍然是标准 Python 文档中最好的入门教程之一。
- en: 'I learned Asyncio from a wide variety of sources, many of which have already
    been mentioned in earlier sections. Everyone learns differently, so it’s worth
    exploring different types of learning materials. Here are a few others that I
    found useful:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 我从各种来源学习了 Asyncio，其中许多已在前面的部分提到。每个人的学习方式都不同，因此探索不同类型的学习材料是值得的。以下是我发现有用的几个：
- en: Robert Smallshire’s [“Get to Grips with Asyncio in Python 3” talk](https://oreil.ly/S5jRX),
    presented at NDC London in January 2017\. This is by far the best YouTube video
    on Asyncio I’ve come across. The talk may be somewhat advanced for a beginner,
    but it really does give a clear description of how Asyncio is designed.
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Robert Smallshire 在 2017 年 1 月的 NDC London 上的 [“Get to Grips with Asyncio in
    Python 3” talk](https://oreil.ly/S5jRX)。这绝对是我看过的关于 Asyncio 的最好的 YouTube 视频。这个讲座可能对初学者来说有些高级，但确实清晰地描述了
    Asyncio 的设计原理。
- en: Nikolay Novik’s [“Building Apps with Asyncio” slides](https://oreil.ly/ufpft),
    presented at PyCon UA 2016\. The information is dense, but a lot of practical
    experience is captured in these slides.
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nikolay Novik 在 PyCon UA 2016 年的 [“Building Apps with Asyncio” slides](https://oreil.ly/ufpft)。这些幻灯片信息丰富，捕捉到了大量实际经验。
- en: Endless sessions in the Python REPL, trying things out and “seeing what happens.”
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Python 的 REPL 中进行无休止的会话，尝试各种可能性并“看看会发生什么”。
- en: I encourage you to continue learning, and if a concept doesn’t stick, keep looking
    for new sources until you find an explanation that works for you.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励你继续学习，如果有概念记不住，继续寻找新的来源，直到找到适合你的解释。
- en: ^([1](ch04.html#idm46363022865560-marker)) Actually, you *can* as long as the
    sockets being used in different threads are created, used, and destroyed entirely
    in their own threads. It is possible but hard to do, and many people struggle
    to get this right. This is why the recommendation to use a single thread and a
    polling mechanism is so strong.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch04.html#idm46363022865560-marker)) 实际上，只要不同线程中使用的套接字完全在各自的线程中创建、使用和销毁，是可以的。这是可能的，但很难做到，很多人在这方面遇到困难。这也是为什么强烈建议使用单线程和轮询机制的原因。
- en: ^([2](ch04.html#idm46363020071448-marker)) The recipe for this dish, and recipes
    for other fine Spam-based fare, can be found [on the UKTV website](http://bit.ly/2CGymPL).
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch04.html#idm46363020071448-marker)) 可以在 UKTV 网站上找到这道菜的食谱，以及其他美味的基于 Spam
    的食谱。
- en: ^([3](ch04.html#idm46363021245640-marker)) Obtain `boltons` with `pip install
    boltons`.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch04.html#idm46363021245640-marker)) 使用 `pip install boltons` 安装 `boltons`。
- en: ^([4](ch04.html#idm46363020825512-marker)) You *also* need the `RETURNING id`
    part of the SQL, though!
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch04.html#idm46363020825512-marker)) *你也需要* SQL 中的 `RETURNING id` 部分哦！
