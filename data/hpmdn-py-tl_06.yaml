- en: Chapter 4\. Dependency Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章 依赖管理
- en: 'Python programmers benefit from a rich ecosystem of third-party libraries and
    tools. Standing on the shoulders of giants comes at a price: The packages you
    depend on for your projects generally depend on a number of packages themselves.
    All of these are moving targets—​as long as any project is alive, its maintainers
    will publish a stream of releases to fix bugs, add features, and adapt to the
    evolving ecosystem.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python 程序员受益于一个丰富的第三方库和工具生态系统。站在巨人的肩膀上是有代价的：你的项目所依赖的包通常也依赖于许多其他包。所有这些都是活动目标——只要任何项目存在，它的维护者就会发布一系列的版本来修复错误、添加功能，并适应不断发展的生态系统。
- en: Managing dependencies is a major challenge when you maintain software over time.
    You need to keep your project up-to-date, if only to close security vulnerabilities
    in a timely fashion. Often this requires updating your dependencies to the latest
    version—​few open source projects have the resources to distribute security updates
    for older releases. You’ll be updating dependencies all the time! Making the process
    as frictionless, automated, and reliable as possible comes with a huge payoff.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，当你维护软件时，管理依赖关系是一个重要的挑战。你需要保持项目的最新状态，即使只是及时关闭安全漏洞。通常，这需要将你的依赖项更新到最新版本——很少有开源项目有资源为旧版本发布安全更新。你会一直更新依赖项！让这个过程尽可能无摩擦、自动化和可靠，会带来巨大的回报。
- en: '*Dependencies* of a Python project are the third-party packages that must be
    installed in its environment.^([1](ch04.html#id273)) Most commonly, you incur
    a dependency on a package because it distributes a module you import. We also
    say that the project *requires* a package.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python 项目的*依赖项*是必须在其环境中安装的第三方包。^([1](ch04.html#id273))最常见的情况是，你因为它分发了一个你导入的模块而产生了对一个包的依赖。我们也说该项目*需要*一个包。
- en: 'Many projects also use third-party tools for developer tasks—​like running
    the test suite or building documentation. These packages are known as *development
    dependencies*: end users don’t need them to run your code. A related case is the
    build dependencies from [Chapter 3](ch03.html#chapter_packages), which let you
    create packages for your project.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 许多项目还使用第三方工具来进行开发者任务——比如运行测试套件或构建文档。这些包称为*开发依赖项*：最终用户不需要它们来运行你的代码。一个相关的情况是来自
    [第 3 章](ch03.html#chapter_packages) 的构建依赖项，它们允许你为你的项目创建包。
- en: Dependencies are like relatives. If you depend on a package, its dependencies
    are your dependencies, too—​no matter how much you like them. These packages are
    known as *indirect dependencies*; you can think of them as a tree with your project
    at its root.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项就像亲戚一样。如果你依赖于一个包，它的依赖项也是你的依赖项——不管你有多喜欢它们。这些包被称为*间接依赖项*；你可以把它们想象成一个以你的项目为根的树。
- en: This chapter explains how to manage dependencies effectively. In the next section,
    you’ll learn how to specify dependencies in *pyproject.toml*, as part of the project
    metadata. Afterwards, I’ll talk about development dependencies and requirements
    files. Finally, I’ll explain how you can *lock* dependencies to precise versions
    for reliable deployments and repeatable checks.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将解释如何有效地管理依赖项。在下一节中，您将学习如何在 *pyproject.toml* 中指定依赖项，作为项目元数据的一部分。之后，我将讨论开发依赖项和要求文件。最后，我会解释如何*锁定*依赖项以便于可靠的部署和可重复的检查。
- en: Adding Dependencies to the Example Application
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向示例应用程序添加依赖项
- en: As a working example, let’s enhance `random-wikipedia-article` from [Example 3-1](ch03.html#example_packages_wikipedia)
    with the [HTTPX](https://www.python-httpx.org/) library, a fully featured HTTP
    client that supports both synchronous and asynchronous requests, as well as the
    newer (and far more efficient) protocol version HTTP/2\. You’ll also improve the
    output of the program using [Rich](https://rich.readthedocs.io), a library for
    rich text and beautiful formatting in the terminal.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个工作示例，让我们使用 [HTTPX](https://www.python-httpx.org/) 库来增强 [示例 3-1](ch03.html#example_packages_wikipedia)
    中的 `random-wikipedia-article`，这是一个功能齐全的 HTTP 客户端，支持同步和异步请求，以及更新（和更高效）的协议版本 HTTP/2。你还将使用
    [Rich](https://rich.readthedocs.io) 改进程序的输出，这是一个用于丰富文本和美观格式的终端库。
- en: Consuming an API with HTTPX
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 HTTPX 消费 API
- en: Wikipedia asks developers to set a `User-Agent` header with contact details.
    That’s not so they can send out postcards to congratulate folks on their proficient
    use of the Wikipedia API. It gives them a way to reach out if a client inadvertently
    hammers their servers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Wikipedia要求开发者使用包含联系方式的`User-Agent`标头。这不是为了让他们可以寄明信片祝贺您熟练使用Wikipedia API。而是为了在客户端无意中打击他们的服务器时提供联系方式。
- en: '[Example 4-1](#example_dependencies_wikipedia_httpx) shows how you can use
    `httpx` to send a request to the Wikipedia API with the header. You could also
    use the standard library to send a `User-Agent` header with your requests. But
    `httpx` offers a more intuitive, explicit, and flexible interface, even when you’re
    not using any of its advanced features. Try it out:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-1](#example_dependencies_wikipedia_httpx)展示了如何使用`httpx`发送带有标头的请求到Wikipedia
    API。您也可以使用标准库发送带有`User-Agent`标头的请求。但是，即使您不使用其高级功能，`httpx`也提供了更直观、明确和灵活的接口。试试看：'
- en: Example 4-1\. Using `httpx` to consume the Wikipedia API
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-1\. 使用`httpx`消耗Wikipedia API
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_dependency_management_CO1-1)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dependency_management_CO1-1)'
- en: When creating a client instance, you can specify headers that it should send
    with every request—​like the `User-Agent` header. Using the client as a context
    manager ensures that the network connection is closed at the end of the `with`
    block.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建客户端实例时，可以指定应该随每个请求发送的标头，如`User-Agent`标头。将客户端作为上下文管理器使用确保在`with`块结束时关闭网络连接。
- en: '[![2](assets/2.png)](#co_dependency_management_CO1-2)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dependency_management_CO1-2)'
- en: This line performs two HTTP `GET` requests to the API. The first one goes to
    the *random* endpoint, which responds with a redirect to the actual article. The
    second one follows the redirect.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此行执行了两个HTTP `GET`请求到API。第一个请求发送到*random*端点，响应一个重定向到实际文章。第二个请求跟随重定向。
- en: '[![3](assets/3.png)](#co_dependency_management_CO1-3)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dependency_management_CO1-3)'
- en: The `raise_for_status` method raises an exception if the server response indicates
    an error via its status code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`raise_for_status`方法在服务器响应通过其状态代码指示错误时引发异常。'
- en: '[![4](assets/4.png)](#co_dependency_management_CO1-4)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_dependency_management_CO1-4)'
- en: The `json` method abstracts the details of parsing the response body as JSON.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`json`方法抽象了将响应体解析为JSON的细节。'
- en: Console Output with Rich
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Rich进行控制台输出
- en: While you’re at it, let’s improve the look and feel of the program. [Example 4-2](#example_dependencies_wikipedia_rich)
    uses Rich, a library for console output, to display the article title in bold.
    That hardly scrapes the surface of Rich’s formatting options. Modern terminals
    are surprisingly capable, and Rich lets you leverage their potential with ease.
    Take a look at its [official documentation](https://rich.readthedocs.io/) for
    details.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，让我们改进程序的外观和感觉。[示例 4-2](#example_dependencies_wikipedia_rich)使用Rich库在粗体中显示文章标题。这只是展示了Rich格式选项的冰山一角。现代终端功能强大，而Rich让您可以轻松利用它们的潜力。请查看其[官方文档](https://rich.readthedocs.io/)获取详细信息。
- en: Example 4-2\. Using Rich to enhance console output
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-2\. 使用Rich增强控制台输出
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_dependency_management_CO2-1)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dependency_management_CO2-1)'
- en: Console objects provide a featureful `print` method for console output. Setting
    the console width to 72 characters replaces our earlier call to `textwrap.fill`.
    You’ll also want to disable automatic syntax highlighting, since you’re formatting
    prose rather than data or code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台对象提供了一个功能丰富的`print`方法用于控制台输出。将控制台宽度设置为72个字符取代了我们早期对`textwrap.fill`的调用。您还会希望禁用自动语法高亮，因为您正在格式化散文而不是数据或代码。
- en: '[![2](assets/2.png)](#co_dependency_management_CO2-2)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dependency_management_CO2-2)'
- en: The `style` keyword allows you to set the title apart using a bold font.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`style`关键字允许您使用粗体字设置标题。'
- en: Specifying Dependencies for a Project
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为项目指定依赖关系
- en: 'If you haven’t done so yet, create and activate a virtual environment for the
    project, and perform an editable install from the current directory:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未这样做，请为项目创建并激活虚拟环境，并从当前目录执行可编辑安装：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You may be tempted to install `httpx` and `rich` manually into the environment.
    Instead, add them to the project dependencies in *pyproject.toml*. This ensures
    that whenever you install your project, the two packages are installed along with
    it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会尝试手动将`httpx`和`rich`安装到环境中。相反，请将它们添加到*pyproject.toml*中的项目依赖项中。这样可以确保每次安装项目时，这两个包都会与之一起安装。
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you reinstall the project, you’ll see that uv installs its dependencies
    as well:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重新安装项目，您会发现 uv 也会安装其依赖项：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Each entry in the `dependencies` field is a *dependency specification*. Besides
    the package name, it lets you supply additional information: version specifiers,
    extras, and environment markers. The following sections explain what these are.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`dependencies` 字段中的每个条目都是*依赖说明*。除了包名称外，它还允许您提供其他信息：版本说明符、额外功能和环境标记。以下各节将详细解释这些内容。'
- en: Version Specifiers
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本说明符
- en: '*Version specifiers* define the range of acceptable versions for a package.
    When you add a new dependency, it’s a good idea to include its current version
    as a lower bound—​unless your project needs to be compatible with older releases.
    Update the lower bound whenever you start relying on newer features of the package.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*版本说明符* 定义了包的可接受版本范围。当您添加新的依赖项时，包括其当前版本作为下限是个好主意——除非您的项目需要与旧版本兼容。每当开始依赖包的新特性时，更新下限。'
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Why declare lower bounds on your dependencies? Installers choose the latest
    version for a dependency by default. There are three reasons why you should care.
    First, libraries are typically installed alongside other packages, which may have
    additional version constraints. Second, even applications aren’t always installed
    in isolation—​for example, Linux distros may package your application for the
    system-wide environment. Third, lower bounds help you detect version conflicts
    in your own dependency tree—​such as when you require a recent release of a package,
    but another dependency only works with its older releases.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要声明依赖的下限？安装程序默认选择依赖的最新版本。有三个原因需要关注。首先，库通常与其他软件包一起安装，这些软件包可能有额外的版本约束。其次，即使应用程序不总是独立安装——例如，Linux
    发行版可能为系统范围的环境打包您的应用程序。第三，下限有助于检测您自己依赖树中的版本冲突——例如，当您需要一个包的最新版本时，但另一个依赖项仅适用于其旧版本时。
- en: Avoid speculative upper version bounds—​you shouldn’t guard against newer releases
    unless you know they’re incompatible with your project. See [“Upper Version Bounds
    in Python”](#sidebar_dependencies_upper_version_bounds) about issues with version
    capping.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 避免推测性的上限版本——除非您知道它们与您的项目不兼容，否则不应防范更新版本。关于版本上限的问题，请参见[“Python 中的上限版本边界”](#sidebar_dependencies_upper_version_bounds)。
- en: '*Lock files* are a much better solution to dependency-induced breakage than
    upper bounds—​they request “known good” versions of your dependencies when deploying
    a service or running automated checks (see [“Locking Dependencies”](#section_dependencies_locking)).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*锁文件* 是比上限更好的依赖性破坏解决方案——它们在部署服务或运行自动化检查时请求“已知良好”的依赖版本（参见[“锁定依赖”](#section_dependencies_locking)）。'
- en: 'If a botched release breaks your project, publish a bugfix release to exclude
    that specific broken version:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个失败的发布破坏了您的项目，请发布一个修复错误的版本以排除该特定的破损版本：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Use an upper bound as a last resort if a dependency breaks compatibility permanently.
    Lift the version cap once you’re able to adapt your code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果依赖项永久性地破坏了兼容性，请作为最后的手段使用上限版本。一旦能够适应您的代码，解除版本限制：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Warning
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Excluding versions after the fact has a pitfall that you need to be aware of.
    Dependency resolvers can decide to downgrade your project to a version without
    the exclusion and upgrade the dependency anyway. Lock files can help with this.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 排除后期版本存在一个需要注意的陷阱。依赖解析器可以决定将您的项目降级到没有排除的版本，并且仍然升级依赖项。锁文件可以帮助解决这个问题。
- en: 'Version specifiers support several operators, as shown in [Table 4-1](#table_dependencies_version_specifiers).
    In short, use the equality and comparison operators you know from Python: `==`,
    `!=`, `<=`, `>=`, `<`, and `>`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 版本说明符支持多个运算符，如[表 4-1](#table_dependencies_version_specifiers)所示。简而言之，请使用您从 Python
    中了解的相等和比较运算符：`==`, `!=`, `<=`, `>=`, `<`, 和 `>`。
- en: Table 4-1\. Version Specifiers
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-1\. 版本说明符
- en: '| Operator | Name | Description |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 名称 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `==` | Version matching | Versions must compare equal after normalization.
    Trailing zeros are stripped off. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `==` | 版本匹配 | 规范化后版本必须相等。尾随零将被去除。 |'
- en: '| `!=` | Version exclusion | The inverse of the `==` operator |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `!=` | 版本排除 | `==` 运算符的反义词 |'
- en: '| `<=`, `>=` | Inclusive ordered comparison | Performs lexicographical comparison.
    Prereleases precede final releases. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `<=`, `>=` | 包含的有序比较 | 执行词典顺序比较。预发布版本优先于最终版本。 |'
- en: '| `<`, `>` | Exclusive ordered comparison | Similar as above, but the versions
    must not compare equal |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `<`, `>` | 排他性有序比较 | 类似于上述，但版本不能相等 |'
- en: '| `~=` | Compatible release | Equivalent to `>=x.y,==x.*` to the specified
    precision |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `~=` | 兼容版本 | 等同于`>=x.y,==x.*`到指定的精度 |'
- en: '| `===` | Arbitrary equality | Simple string comparison for non-standard versions
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `===` | 任意相等性 | 用于非标准版本的简单字符串比较 |'
- en: 'Three operators merit additional discussion:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 三个运算符值得额外讨论：
- en: The `==` operator supports wildcards (`*`), albeit only at the end of the version
    string. In other words, you can require the version to match a particular prefix,
    such as `1.2.*`.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`==`运算符支持通配符（`*`），尽管只能在版本字符串的末尾使用。换句话说，您可以要求版本匹配特定的前缀，比如`1.2.*`。'
- en: The `===` operator lets you perform a simple character-by-character comparison.
    It’s best used as a last resort for non-standard versions.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`===`运算符允许您执行简单的逐字符比较。最好作为非标准版本的最后一招使用。'
- en: The `~=` operator for compatible releases specifies that the version should
    be greater than or equal to the given value, while still starting with the same
    prefix. For example, `~=1.2.3` is equivalent to `>=1.2.3,==1.2.*`, and `~=1.2`
    is equivalent to `>=1.2,==1.*`.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~=`运算符用于兼容版本的指定，指定版本应大于或等于给定值，同时以相同的前缀开头。例如，`~=1.2.3`等同于`>=1.2.3,==1.2.*`，而`~=1.2`等同于`>=1.2,==1.*`。'
- en: 'You don’t need to guard against prereleases—​version specifiers exclude them
    by default. Prereleases are valid candidates in three situations only: when they’re
    already installed, when no other releases satisfy the dependency specification,
    and when you request them explicitly, using a clause like `>=1.0.0rc1`.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要对预发布版本进行保护—版本指定符默认排除它们。只有三种情况下预发布版本才是有效的候选项：当它们已安装时、当没有其他版本满足依赖规范时、以及明确请求它们时，使用像`>=1.0.0rc1`这样的子句。
- en: Extras
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 额外
- en: 'Suppose you want to use the newer HTTP/2 protocol with `httpx`. This only requires
    a small change to the code that creates the HTTP client:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要使用更新的HTTP/2协议与`httpx`。这只需要对创建HTTP客户端的代码进行小修改：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Under the hood, `httpx` delegates the gory details of speaking HTTP/2 to another
    package, `h2`. That dependency is not pulled in by default, however. This way,
    users who don’t need the newer protocol get away with a smaller dependency tree.
    You do need it here, so activate the optional feature using the syntax `httpx[http2]`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`httpx`将HTTP/2的详细信息委托给另一个包`h2`。但是，默认情况下不会引入该依赖项。这样，不需要新协议的用户可以得到更小的依赖树。但是在这里你需要它，所以使用语法`httpx[http2]`来激活可选功能：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Optional features that require additional dependencies are known as *extras*,
    and you can have more than one. For example, you could specify `httpx[http2,brotli]`
    to allow decoding responses with *Brotli compression*, which is a compression
    algorithm developed at Google that’s common in web servers and content delivery
    networks.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 需要额外依赖的可选功能称为*额外*，您可以有多个。例如，您可以指定`httpx[http2,brotli]`以允许解码使用*Brotli压缩*的响应，这是Google开发的一种压缩算法，在Web服务器和内容传递网络中很常见。
- en: Optional dependencies
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选依赖项
- en: Let’s take a look at this situation from the point of view of `httpx`. The `h2`
    and `brotli` dependencies are optional, so `httpx` declares them under `optional-dependencies`
    instead of `dependencies` ([Example 4-3](#example_dependencies_httpx_extras)).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`httpx`的角度看一下这种情况。`h2`和`brotli`依赖项是可选的，因此`httpx`将它们声明在`optional-dependencies`而不是`dependencies`下（[示例 4-3](#example_dependencies_httpx_extras)）。
- en: Example 4-3\. Optional dependencies of `httpx` (simplified)
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-3。简化的`httpx`可选依赖项
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `optional-dependencies` field is a TOML table. It can hold multiple lists
    of dependencies, one for each extra provided by the package. Each entry is a dependency
    specification and uses the same rules as the `dependencies` field.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`optional-dependencies`字段是一个TOML表。它可以容纳多个依赖项列表，每个额外由包提供。每个条目都是一个依赖规范，并且使用与`dependencies`字段相同的规则。'
- en: 'If you add an optional dependency to your project, how do you use it in your
    code? Don’t check if your package was installed with the extra—​just import the
    optional package. You can catch the `ImportError` exception if the user didn’t
    request the extra:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您向项目添加一个可选依赖项，如何在代码中使用它？不要检查是否使用了额外的包—只需导入可选包。如果用户没有请求额外的内容，您可以捕获`ImportError`异常：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is a common pattern in Python—​so common it comes with a name and an acronym:
    “Easier to Ask Forgiveness than Permission” (EAFP). Its less Pythonic counterpart
    is dubbed “Look Before You Leap” (LBYL).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的一个常见模式——**EAFP**（Easier to Ask Forgiveness than Permission，宁愿请求原谅，而不是事先征得许可），已经如此常见，以至于它有一个名字和一个缩写。它不那么符合
    Python 风格的对应物被称为**LBYL**（Look Before You Leap，事先审慎而后行）。
- en: Environment Markers
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境标记
- en: The third piece of metadata you can specify for a dependency is environment
    markers. Before I explain what these markers are, let me show you an example of
    where they come in handy.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于依赖项的第三个元数据，你可以指定环境标记。在我解释这些标记有什么作用之前，让我向你展示一个它们何时非常有用的例子。
- en: If you looked at the `User-Agent` header in [Example 4-1](#example_dependencies_wikipedia_httpx)
    and thought, “I shouldn’t have to repeat the version number in the code,” you’re
    absolutely right. As you saw in [“Single-sourcing the project version”](ch03.html#section_packages_single_sourcing_the_version),
    you can read the version of your package from its metadata in the environment.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看了 [示例 4-1](#example_dependencies_wikipedia_httpx) 中的 `User-Agent` 头部，并想，“我不应该在代码中重复版本号”，你是完全正确的。正如你在
    [“单一来源项目版本”](ch03.html#section_packages_single_sourcing_the_version) 中看到的，你可以从环境中的元数据中读取包的版本。
- en: '[Example 4-4](#example_dependencies_wikipedia_importlib_metadata) shows how
    you can use the function `importlib.metadata.metadata` to construct the `User-Agent`
    header from the core metadata fields `Name`, `Version`, and `Author-email`. These
    fields correspond to `name`, `version`, and `authors` in the project metadata.^([3](ch04.html#id275))'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-4](#example_dependencies_wikipedia_importlib_metadata) 展示了如何使用函数 `importlib.metadata.metadata`
    从核心元数据字段 `Name`、`Version` 和 `Author-email` 构建 `User-Agent` 头部。这些字段对应于项目元数据中的 `name`、`version`
    和 `authors`。^([3](ch04.html#id275))'
- en: Example 4-4\. Using `importlib.metadata` to build a `User-Agent` header
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-4\. 使用`importlib.metadata`构建`User-Agent`头部
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_dependency_management_CO3-1)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dependency_management_CO3-1)'
- en: The `metadata` function retrieves the core metadata fields for the package.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`metadata`函数用于检索包的核心元数据字段。'
- en: '[![2](assets/2.png)](#co_dependency_management_CO3-2)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dependency_management_CO3-2)'
- en: The `str.format_map` function looks up each placeholder in the mapping.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`str.format_map` 函数查找映射中的每个占位符。'
- en: The `importlib.metadata` library was introduced in Python 3.8\. While it’s now
    available in all supported versions, that wasn’t always so. Were you out of luck
    if you had to support an older Python version?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`importlib.metadata`库是在 Python 3.8 中引入的。虽然现在它在所有支持的版本中都可用，但并非总是如此。如果你需要支持一个较旧的
    Python 版本，那就不那么幸运了。'
- en: Not quite. Fortunately, many additions to the standard library come with *backports*—third-party
    packages that provide the functionality for older interpreters. For `importlib.metadata`,
    you can fall back to the `importlib-metadata` backport from PyPI. The backport
    remains useful because the library changed several times after its introduction.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 不完全是。幸运的是，许多标准库的新增功能都有*后备*——提供老版本解释器功能的第三方包。对于 `importlib.metadata`，你可以从 PyPI
    上回退到 `importlib-metadata` 后备包。这个后备包依然有用，因为该库在引入后多次改变。
- en: 'You only need backports in environments that use specific Python versions.
    An environment marker lets you express this as a conditional dependency:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要在使用特定 Python 版本的环境中使用后备包。环境标记允许你将此表达为条件依赖项：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Installers will only install the package on interpreters older than Python 3.8.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 安装程序只会在 Python 3.8 之前的解释器上安装该包。
- en: More generally, an *environment marker* expresses a condition that an environment
    must satisfy for the dependency to apply. Installers evaluate the condition on
    the interpreter of the target environment.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地说，*环境标记* 表达了环境必须满足的条件，以便应用该依赖项。安装程序会在目标环境的解释器上评估该条件。
- en: Environment markers let you request dependencies for specific operating systems,
    processor architectures, Python implementations, or Python versions. [Table 4-2](#table_dependencies_environment_markers)
    lists all the environment markers at your disposal, as specified in PEP 508.^([4](ch04.html#id276))
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 环境标记允许你针对特定的操作系统、处理器架构、Python 实现或 Python 版本请求依赖项。[表 4-2](#table_dependencies_environment_markers)
    列出了所有可用的环境标记，如 PEP 508 中所指定的。^([4](ch04.html#id276))
- en: Table 4-2\. Environment Markers^([a](ch04.html#id277))
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-2\. 环境标记^([a](ch04.html#id277))
- en: '| Environment Marker | Standard Library | Description | Examples |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 环境标记 | 标准库 | 描述 | 示例 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `os_name` | `os.name()` | The operating system family | `posix`, `nt` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `os_name` | `os.name()` | 操作系统家族 | `posix`, `nt` |'
- en: '| `sys_platform` | `sys.platform()` | The platform identifier | `linux`, `darwin`,
    `win32` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `sys_platform` | `sys.platform()` | 平台标识符 | `linux`, `darwin`, `win32` |'
- en: '| `platform_system` | `platform.system()` | The system name | Linux, Darwin,
    Windows |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `platform_system` | `platform.system()` | 系统名称 | Linux, Darwin, Windows |'
- en: '| `platform_release` | `platform.release()` | The operating system release
    | `23.2.0` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `platform_release` | `platform.release()` | 操作系统版本 | `23.2.0` |'
- en: '| `platform_version` | `platform.version()` | The system release | `Darwin
    Kernel Version 23.2.0: ...` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `platform_version` | `platform.version()` | 系统版本 | `Darwin Kernel Version
    23.2.0: ...` |'
- en: '| `platform_machine` | `platform.machine()` | The processor architecture |
    `x86_64`, `arm64` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `platform_machine` | `platform.machine()` | 处理器架构 | `x86_64`, `arm64` |'
- en: '| `python_version` | `platform.python_version_tuple()` | The Python feature
    version in the format `x.y` | `3.12` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `python_version` | `platform.python_version_tuple()` | 格式为 `x.y` 的 Python
    特性版本 | `3.12` |'
- en: '| `python_full_version` | `platform.python_version()` | The full Python version
    | `3.12.0`, `3.13.0a4` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `python_full_version` | `platform.python_version()` | 完整的 Python 版本 | `3.12.0`,
    `3.13.0a4` |'
- en: '| `platform_python_implementation` | `platform.python_implementation()` | The
    Python implementation | `CPython`, `PyPy` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `platform_python_implementation` | `platform.python_implementation()` | Python
    实现 | `CPython`, `PyPy` |'
- en: '| `implementation_name` | `sys.implementation.name` | The Python implementation
    | `cpython`, `pypy` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `implementation_name` | `sys.implementation.name` | Python 实现 | `cpython`,
    `pypy` |'
- en: '| `implementation_version` | `sys.implementation.version` | The Python implementation
    version | `3.12.0`, `3.13.0a4` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `implementation_version` | `sys.implementation.version` | Python 实现版本 | `3.12.0`,
    `3.13.0a4` |'
- en: '| ^([a](ch04.html#id277-marker)) The `python_version` and `implementation_version`
    markers apply transformations. See PEP 508 for details. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch04.html#id277-marker)) `python_version` 和 `implementation_version`
    标记应用转换。详细信息请参阅 PEP 508。 |'
- en: 'Going back to [Example 4-4](#example_dependencies_wikipedia_importlib_metadata),
    here’s the full `dependencies` field with the `python_version` marker for `importlib-metadata`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 [Example 4-4](#example_dependencies_wikipedia_importlib_metadata)，这里是带有 `importlib-metadata`
    的 `dependencies` 字段的完整示例：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The import name for the backport is `importlib_metadata`, while the standard
    library module is named `importlib.metadata`. You can import the appropriate module
    in your code by checking the Python version in `sys.version_info`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 后备的导入名称为 `importlib_metadata`，而标准库模块名为 `importlib.metadata`。您可以通过检查 `sys.version_info`
    中的 Python 版本，在代码中导入适当的模块：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Did I just hear somebody shout “EAFP”? If your imports depend on the Python
    version, it’s better to avoid the technique from [“Optional dependencies”](#section_dependencies_optional)
    and “look before you leap.” An explicit version check communicates your intent
    to static analyzers, such as the mypy type checker (see [Chapter 10](ch10.html#chapter_typing)).
    EAFP may result in errors from these tools because they can’t detect when each
    module is available.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚才听见有人喊“EAFP”了吗？如果您的导入依赖于 Python 版本，最好避免使用 [“Optional dependencies”](#section_dependencies_optional)
    和 “look before you leap” 技术。显式版本检查能够向静态分析工具（例如 mypy 类型检查器，见 [第10章](ch10.html#chapter_typing)）传达您的意图。由于无法检测每个模块的可用性，EAFP
    可能会导致这些工具报错。
- en: Markers support the same equality and comparison operators as version specifiers
    ([Table 4-1](#table_dependencies_version_specifiers)). Additionally, you can use
    `in` and `not in` to match a substring against the marker. For example, the expression
    `'arm' in platform_version` checks if `platform.version()` contains the string
    `'arm'`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 标记支持与版本规范符号相同的相等和比较运算符（见 [Table 4-1](#table_dependencies_version_specifiers)）。此外，您可以使用
    `in` 和 `not in` 来匹配标记中的子字符串。例如，表达式 `'arm' in platform_version` 检查 `platform.version()`
    是否包含字符串 `'arm'`。
- en: 'You can also combine multiple markers using the boolean operators `and` and
    `or`. Here’s a rather contrived example combining all these features:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用布尔运算符 `and` 和 `or` 结合多个标记。以下是一个相当牵强的示例，结合了所有这些特性：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The example also relies on TOML’s support for multi-line strings, which uses
    triple quotes just like Python. Dependency specifications cannot span multiple
    lines, so you have to escape the newlines with a backslash.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例还依赖于 TOML 对多行字符串的支持，使用与 Python 相同的三重引号。依赖规范不能跨越多行，因此您必须使用反斜杠转义换行符。
- en: Development Dependencies
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发依赖
- en: Development dependencies are third-party packages that you require during development.
    As a developer, you might use the pytest testing framework to run the test suite
    for your project, the Sphinx documentation system to build its docs, or a number
    of other tools to help with project maintenance. Your users, on the other hand,
    don’t need to install any of these packages to run your code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 开发依赖是你在开发过程中需要的第三方软件包。作为开发者，你可能会使用pytest测试框架来运行项目的测试套件，Sphinx文档系统来构建其文档，或者其他一些工具来帮助项目维护。另一方面，你的用户不需要安装这些软件包来运行你的代码。
- en: 'An Example: Testing with pytest'
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个示例：使用pytest进行测试
- en: 'As a concrete example, let’s add a small test for the `build_user_agent` function
    from [Example 4-4](#example_dependencies_wikipedia_importlib_metadata). Create
    a directory *tests* with two files: an empty *__init__.py* and a module *test_random_wikipedia_article.py*
    with the code from [Example 4-5](#example_dependencies_test_build_user_agent).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个具体例子来说，让我们为[示例 4-4](#example_dependencies_wikipedia_importlib_metadata)中的`build_user_agent`函数添加一个小测试。创建一个包含两个文件的目录*tests*：一个空的*__init__.py*和一个模块*test_random_wikipedia_article.py*，其中包含来自[示例 4-5](#example_dependencies_test_build_user_agent)的代码。
- en: Example 4-5\. Testing the generated `User-Agent` header
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-5\. 测试生成的`User-Agent`标头
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[Example 4-5](#example_dependencies_test_build_user_agent) only uses built-in
    Python features, so you could just import and run the test manually. But even
    for this tiny test, pytest adds three useful features. First, it discovers modules
    and functions whose names start with `test`, so you can run your tests by invoking
    `pytest` without arguments. Second, pytest shows tests as it executes them, as
    well as a summary with the test results at the end. Third, pytest rewrites assertions
    in your tests to give you friendly, informative messages when they fail.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-5](#example_dependencies_test_build_user_agent)仅使用内置的Python功能，因此你可以只是导入并手动运行测试。但即使对于这个小测试，pytest也添加了三个有用的功能。首先，它发现名称以`test`开头的模块和函数，因此你可以通过调用`pytest`而不带参数来运行测试。其次，pytest在执行测试时显示测试，并在最后显示带有测试结果的摘要。第三，pytest重写测试中的断言，以便在失败时提供友好且信息丰富的消息。'
- en: 'Let’s run the test with pytest. I’m assuming you already have an active virtual
    environment with an editable install of your project. Enter the commands below
    to install and run pytest in that environment:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用pytest运行测试。我假设你已经有了一个带有可编辑安装的活动虚拟环境。在该环境中输入以下命令来安装和运行pytest：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For now, things look great. Tests help your project evolve without breaking
    things. The test for `build_user_agent` is a first step in that direction. Installing
    and running pytest is a small infrastructure cost compared to these long-term
    benefits.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 目前看起来一切都很好。测试有助于项目在不破坏功能的情况下发展。对于`build_user_agent`的测试是朝这个方向迈出的第一步。与这些长期利益相比，安装和运行pytest只是一个小的基础设施成本。
- en: 'Setting up a project environment becomes harder as you acquire more development
    dependencies—​documentation generators, linters, code formatters, type checkers,
    or other tools. Even your test suite may require more than pytest: plugins for
    pytest, tools for measuring code coverage, or just packages that help you exercise
    your code.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你获得更多的开发依赖项，设置项目环境变得更加困难——文档生成器、代码检查器、代码格式化程序、类型检查器或其他工具。即使你的测试套件可能需要比pytest更多的东西：pytest的插件、用于测量代码覆盖率的工具，或者只是帮助你练习代码的包。
- en: You also need compatible versions of these packages—​your test suite may require
    the latest version of pytest, while your documentation may not build on the new
    Sphinx release. Each of your projects may have slightly different requirements.
    Multiply this by the number of developers working on each project, and it becomes
    clear that you need a way to track your development dependencies.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要这些软件包的兼容版本——你的测试套件可能需要最新版本的pytest，而你的文档可能无法在新的Sphinx发布版上构建。每个项目可能有稍微不同的要求。将这些乘以每个项目上工作的开发人员数量，就会清楚地表明你需要一种跟踪开发依赖关系的方式。
- en: 'As of this writing, Python doesn’t have a standard way to declare the development
    dependencies of a project—​although many Python project managers support them
    in their `[tool]` table and a draft PEP exists.^([5](ch04.html#id278)) Besides
    project managers, people use two approaches to fill the gap: optional dependencies
    and requirements files.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前为止，Python没有声明项目开发依赖项的标准方法——尽管许多Python项目管理工具在它们的`[tool]`表中支持它们，并且有一个草案PEP存在。^([5](ch04.html#id278))
    除了项目管理工具外，人们使用两种方法来填补这一空白：可选依赖和要求文件。
- en: Optional Dependencies
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选依赖项
- en: As you’ve seen in [“Extras”](#section_dependencies_extras), the `optional-dependencies`
    table contains groups of optional dependencies named extras. It has three properties
    that make it suitable for tracking development dependencies. First, the packages
    aren’t installed by default, so end users don’t pollute their Python environment
    with them. Second, it lets you group the packages under meaningful names like
    `tests` or `docs`. And third, the field comes with the full expressivity of dependency
    specifications, including version constraints and environment markers.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[“额外内容”](#section_dependencies_extras)中看到的，`optional-dependencies` 表格包含了命名为额外内容的可选依赖项组。它具有使其适合跟踪开发依赖项的三个属性。首先，默认情况下不会安装这些包，因此最终用户不会在其
    Python 环境中污染它们。其次，它允许你将包分组到有意义的名称下，例如 `tests` 或 `docs`。第三，该字段具有完整的依赖关系规范的表达性，包括版本约束和环境标记。
- en: On the other hand, there’s an impedance mismatch between development dependencies
    and optional dependencies. Optional dependencies are exposed to users through
    the package metadata—​they let users opt into features that require additional
    packages. By contrast, users aren’t meant to install development dependencies—​these
    packages aren’t required for any user-facing features.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，开发依赖项和可选依赖项之间存在阻抗不匹配。可选依赖项通过包元数据向用户公开—它们让用户选择需要额外包的功能。相比之下，用户不应该安装开发依赖项—这些包不需要任何用户可见的功能。
- en: Furthermore, you can’t install extras without the project itself. By contrast,
    not all developer tools need your project installed. For example, linters analyze
    your source code for bugs and potential improvements. You can run them on a project
    without installing it into the environment. Besides wasting time and space, “fat”
    environments constrain dependency resolution unnecessarily. For example, many
    Python projects could no longer upgrade important dependencies when the Flake8
    linter put a version cap on `importlib-metadata`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你无法在没有项目本身的情况下安装额外的内容。相比之下，并不是所有的开发工具都需要安装你的项目。例如，代码检查器会分析你的源代码中的错误和潜在改进。你可以在不将项目安装到环境中的情况下运行它们。除了浪费时间和空间外，“臃肿”的环境还会不必要地限制依赖关系的解析。例如，当
    Flake8 代码检查器对 `importlib-metadata` 设置版本限制时，许多 Python 项目就无法再升级重要的依赖项。
- en: Keeping this in mind, extras are widely used for development dependencies and
    are the only method covered by a packaging standard. They’re a pragmatic choice,
    especially if you manage linters with pre-commit (see [Chapter 9](ch09.html#chapter_linting)).
    [Example 4-6](#example_dependencies_dev_extras_tests_and_docs) shows how you’d
    use extras to track packages required for testing and documentation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 特别要记住的是，额外内容被广泛用于开发依赖项，并且是包装标准涵盖的唯一方法。它们是一种实用的选择，特别是如果你使用 pre-commit 管理代码检查器（见[第九章](ch09.html#chapter_linting)）。[示例 4-6](#example_dependencies_dev_extras_tests_and_docs)
    展示了如何使用额外内容来跟踪测试和文档所需的包。
- en: Example 4-6\. Using extras to represent development dependencies
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-6：使用额外内容表示开发依赖项
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](assets/1.png)](#co_dependency_management_CO4-1)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![1](assets/1.png)：[共依赖管理](#co_dependency_management_CO4-1)'
- en: The `pytest-sugar` plugin enhances pytest’s output with a progress bar and shows
    failures immediately.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest-sugar` 插件可以增强 pytest 的输出，添加了进度条并立即显示失败情况。'
- en: '[![2](assets/2.png)](#co_dependency_management_CO4-2)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![2](assets/2.png)：[共依赖管理](#co_dependency_management_CO4-2)'
- en: Sphinx is a documentation generator used by the official Python documentation
    and many open source projects.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx 是官方 Python 文档和许多开源项目使用的文档生成器。
- en: 'You can now install the test dependencies using the `tests` extra:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用 `tests` 额外内容安装测试依赖项了：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can also define a `dev` extra with all the development dependencies. This
    lets you set up a development environment in one go, with your project and every
    tool it uses:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以定义一个包含所有开发依赖项的 `dev` 额外内容。这样，你可以一次性设置一个开发环境，包括你的项目和它使用的每个工具：
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There’s no need to repeat all the packages when you define `dev`. Instead, you
    can just reference the other extras, as shown in [Example 4-7](#example_dependencies_dev_extra).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义 `dev` 时，没有必要重复所有的包。相反，你可以只引用其他的额外内容，就像[示例 4-7](#example_dependencies_dev_extra)所示。
- en: Example 4-7\. Providing a `dev` extra with all development dependencies
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-7：提供了一个包含所有开发依赖项的 `dev` 额外内容
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This style of declaring an extra is also known as a *recursive optional dependency*,
    since the package with the `dev` extra depends on itself (with `tests` and `docs`
    extras).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 声明额外内容的这种风格也被称为*递归可选依赖*，因为具有 `dev` 额外内容的包依赖于自身（具有 `tests` 和 `docs` 额外内容）。
- en: Requirements Files
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需求文件
- en: '*Requirements files* are plain text files with dependency specifications on
    each line ([Example 4-8](#example_dependencies_requirements_txt)). Additionally,
    they can contain URLs and paths, optionally prefixed by `-e` for an editable install,
    as well as global options, such as `-r` to include another requirements file or
    `--index-url` to use a package index other than PyPI. The file format also supports
    Python-style comments (with a leading `#` character) and line continuations (with
    a trailing `\` character).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*Requirements文件*是带有每行依赖规范的纯文本文件（[Example 4-8](#example_dependencies_requirements_txt)）。此外，它们可以包含URL和路径，可选地以`-e`为前缀进行可编辑安装，以及全局选项，如`-r`用于包含另一个requirements文件或`--index-url`用于使用除PyPI以外的包索引。该文件格式还支持Python风格的注释（以`#`字符开头）和行继续（以`\`字符结尾）。'
- en: Example 4-8\. A simple requirements.txt file
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-8\. 一个简单的requirements.txt文件。
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can install the dependencies listed in a requirements file using pip or
    uv:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用pip或uv安装requirements文件中列出的依赖项。
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: By convention, a requirements file is named *requirements.txt*. However, variations
    are common. You might have a *dev-requirements.txt* for development dependencies
    or a *requirements* directory with one file per dependency group ([Example 4-9](#example_dependencies_dev_requirements)).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 根据惯例，一个需求文件通常命名为*requirements.txt*。但是，变种是很常见的。你可能有一个*dev-requirements.txt*用于开发依赖，或者一个*requirements*目录，每个依赖组有一个文件（[Example 4-9](#example_dependencies_dev_requirements)）。
- en: Example 4-9\. Using requirements files to specify development dependencies
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-9\. 使用requirements文件指定开发依赖。
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[![1](assets/1.png)](#co_dependency_management_CO5-1)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dependency_management_CO5-1)'
- en: The *tests.txt* file requires an editable install of the project because the
    test suite needs to import the application modules.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*tests.txt*文件需要项目的可编辑安装，因为测试套件需要导入应用程序模块。'
- en: '[![2](assets/2.png)](#co_dependency_management_CO5-2)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dependency_management_CO5-2)'
- en: The *docs.txt* file doesn’t require the project. (That’s assuming you build
    the documentation from static files only. If you use the `autodoc` Sphinx extension
    to generate API documentation from docstrings in your code, you’ll also need the
    project here.)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*docs.txt*文件不需要项目。（这是假设您仅从静态文件构建文档。如果您使用`autodoc` Sphinx扩展从代码中的文档字符串生成API文档，则还需要在此处添加项目。）'
- en: '[![3](assets/3.png)](#co_dependency_management_CO5-3)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dependency_management_CO5-3)'
- en: The *dev.txt* file includes the other requirements files.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*dev.txt*文件包含其他requirements文件。'
- en: Note
  id: totrans-167
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意。
- en: If you include other requirements files using `-r`, their paths are evaluated
    relative to the including file. By contrast, paths to dependencies are evaluated
    relative to your current directory, which is typically the project directory.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`-r`包含其他requirements文件，则它们的路径相对于包含文件进行评估。相比之下，依赖项的路径是相对于您当前的目录进行评估的，通常是项目目录。
- en: 'Create and activate a virtual environment, then run the following commands
    to install the development dependencies and run the test suite:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并激活虚拟环境，然后运行以下命令以安装开发依赖项并运行测试套件：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Requirements files aren’t part of the project metadata. You share them with
    other developers using the version control system, but they’re invisible to your
    users. For development dependencies, this is exactly what you want. What’s more,
    requirements files don’t implicitly include your project in the dependencies.
    That shaves off time from all tasks that don’t need the project installed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Requirements文件不是项目元数据的一部分。您可以通过版本控制系统与其他开发人员共享它们，但它们对于您的用户来说是不可见的。对于开发依赖项来说，这正是您想要的。此外，requirements文件不会隐式地将项目包含在依赖项中。这减少了不需要安装项目的所有任务所需的时间。
- en: Requirements files also have downsides. They aren’t a packaging standard, and
    unlikely to become one—​each line of a requirements file is essentially an argument
    to `pip install`. “Whatever pip does” may remain the unwritten law for many edge
    cases in Python packaging, but community standards replace it more and more. Another
    downside is the clutter these files cause in your project when compared to a table
    in *pyproject.toml*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Requirements文件也有缺点。它们不是一个打包的标准，也不太可能成为一个——requirements文件的每一行基本上是传递给`pip install`的一个参数。“pip会做什么”可能仍然是Python打包中许多边缘情况的潜规则，但社区标准越来越多地取代了它。另一个缺点是，与*pyproject.toml*中的表格相比，这些文件在项目中造成了混乱。
- en: As mentioned above, Python project managers let you declare dependency groups
    in *pyproject.toml*, outside of the project metadata—​Rye, Hatch, PDM, and Poetry
    all offer this feature. See [Chapter 5](ch05.html#chapter_poetry) for a description
    of Poetry’s dependency groups.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，Python项目管理器允许你在*pyproject.toml*中声明依赖组，超出了项目元数据—​Rye、Hatch、PDM和Poetry都提供了这一功能。查看[第五章](ch05.html#chapter_poetry)以了解Poetry的依赖组描述。
- en: Locking Dependencies
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁定依赖关系
- en: You’ve installed your dependencies in a local environment or in continuous integration
    (CI), and you’ve run your test suite and any other checks you have in place. Everything
    looks good, and you’re ready to deploy your code. But how do you install the same
    packages in production that you used when you ran your checks?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在本地环境或持续集成（CI）中安装了依赖项，并运行了测试套件和其他检查。一切看起来都很好，你准备部署你的代码了。但是，如何在生产环境中安装与你运行检查时使用的相同包？
- en: Using different packages in development and production has consequences. Production
    may end up with a package that’s incompatible with your code, has a bug or security
    vulnerability, or—​in the worst case—​has been hijacked by an attacker. If your
    service gets a lot of exposure, this scenario is worrying—​and it can involve
    any package in your dependency tree, not just those that you import directly.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发和生产中使用不同的包装载具有后果。生产可能最终会得到一个与你的代码不兼容的包，或者有缺陷或安全漏洞的包，甚至—​在最坏的情况下—​被攻击者劫持的包。如果你的服务曝光度很高，这种情况令人担忧—​而且它可能涉及依赖树中的任何包，而不仅仅是你直接导入的包。
- en: Warning
  id: totrans-177
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: '*Supply chain attacks* infiltrate a system by targeting its third-party dependencies.
    For example, in 2022, a threat actor dubbed “JuiceLedger” uploaded malicious packages
    to legitimate PyPI projects after compromising them with a phishing campaign.^([6](ch04.html#id279))'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*供应链攻击*通过针对其第三方依赖项来渗透系统。例如，2022年，“JuiceLedger”威胁行动者通过网络钓鱼活动篡改了合法的PyPI项目并上传了恶意包装载。^([6](ch04.html#id279))'
- en: 'There are many reasons why environments end up with different packages given
    the same dependency specifications. Most of them fall into two categories: upstream
    changes and environment mismatch. First, you can get different packages if the
    set of available packages changes upstream:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 环境在给定相同依赖规范的情况下最终以不同包装载的原因有很多。其中大部分原因可以归类为两类：上游更改和环境不匹配。首先，如果可用包的集合发生上游更改，你可能会得到不同的包：
- en: A new release comes in before you deploy.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你部署之前发布了新版本。
- en: A new artifact is uploaded for an existing release. For example, maintainers
    sometimes upload additional wheels when a new Python release comes out.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为现有版本上传了一个新的工件。例如，当新的Python版本发布时，维护者有时会上传额外的轮子。
- en: A maintainer deletes or yanks a release or artifact. *Yanking* is a soft delete
    that hides the file from dependency resolution unless you request it specifically.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护者删除或取消发布或工件。*取消发布*是一种软删除，它会隐藏文件以防止依赖解析，除非你明确请求它。
- en: 'Second, you can get different packages if your development environment doesn’t
    match the production environment:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果你的开发环境与生产环境不匹配，你可能会得到不同的包装载：
- en: Environment markers evaluate differently on the target interpreter (see [“Environment
    Markers”](#section_dependencies_environment_markers)). For example, the production
    environment might use an old Python version that requires a backport like `importlib-metadata`.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境标记在目标解释器上的评估有所不同（参见[“环境标记”](#section_dependencies_environment_markers)）。例如，生产环境可能使用一个旧的Python版本，需要像`importlib-metadata`这样的后移植。
- en: Wheel compatibility tags can cause the installer to select a different wheel
    for the same package (see [“Wheel Compatibility Tags”](ch03.html#sidebar_packages_wheel_compatibility_tags)).
    For example, this can happen if you develop on a Mac with Apple Silicon while
    production uses Linux on an x86-64 architecture.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轮子兼容性标签可能会导致安装程序为同一个包选择不同的轮子（参见[“轮子兼容性标签”](ch03.html#sidebar_packages_wheel_compatibility_tags)）。例如，如果你在配有苹果硅芯的Mac上开发，而生产环境使用x86-64架构的Linux，则可能会发生这种情况。
- en: If the release doesn’t include a wheel for the target environment, the installer
    builds it from the sdist on the fly. Wheels for extension modules often lag behind
    when a new Python version sees the light.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果发布不包括目标环境的轮子，安装程序会即时从源分布（sdist）构建它。当新的Python版本推出时，扩展模块的轮子通常会滞后。
- en: If the environments don’t use the same installer (or different versions of the
    same installer), each installer may resolve the dependencies differently. For
    example, uv uses the PubGrub algorithm for dependency resolution,^([7](ch04.html#id280))
    while pip uses a backtracking resolver for Python packages, `resolvelib`.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果环境不使用相同的安装程序（或者使用不同版本的相同安装程序），每个安装程序可能会以不同的方式解析依赖关系。例如，`uv` 使用 PubGrub 算法进行依赖关系解析，^([7](ch04.html#id280))
    而 `pip` 使用回溯解析器用于 Python 包，`resolvelib`。
- en: Tooling configuration or state can also cause different results—​for example,
    you might install from a different package index or from a local cache.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具配置或状态也可能导致不同的结果——例如，您可能从不同的软件包索引或本地缓存中安装。
- en: You need a way to define the exact set of packages required by your application,
    and you want its environment to be an exact image of this package inventory. This
    process is known as *locking*, or *pinning*, the project dependencies, which are
    listed in a *lock file*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一种定义应用程序所需确切包集合的方法，并且您希望其环境是该包清单的确切映像。这个过程称为*锁定*，或者*固定*，列在*锁定文件*中的项目依赖项。
- en: 'So far, I’ve talked about locking dependencies for reliable and reproducible
    deployments. Locking is also beneficial during development, for both applications
    and libraries. By sharing a lock file with your team and with contributors, you
    put everybody on the same page: every developer uses the same dependencies when
    running the test suite, building the documentation, or performing other tasks.
    Using the lock file for mandatory checks avoids surprises where checks fail in
    CI after passing locally. To reap these benefits, lock files must include development
    dependencies, too.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经谈论了为了可靠和可复制的部署而锁定依赖关系。锁定在开发过程中也很有益处，无论是应用程序还是库。通过与团队和贡献者共享锁定文件，您使每个开发人员在运行测试套件、构建文档或执行其他任务时使用相同的依赖项。在强制检查中使用锁定文件可避免出现在本地通过后，在
    CI 中检查失败的情况。为了获得这些好处，锁定文件还必须包含开发依赖项。
- en: As of this writing, Python lacks a packaging standard for lock files—​although
    the topic is under active consideration.^([8](ch04.html#id281)) Meanwhile, many
    Python project managers, such as Poetry, PDM, and pipenv, have implemented their
    own lock file formats; others, like Rye, use requirements files for locking dependencies.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 就目前而言，Python 缺乏用于锁定文件的打包标准——尽管这个话题正在积极考虑中。^([8](ch04.html#id281)) 与此同时，许多 Python
    项目管理器，如 Poetry、PDM 和 pipenv，已经实现了自己的锁定文件格式；而其他一些项目，如 Rye，则使用要求文件来锁定依赖项。
- en: 'In this section, I’ll introduce two methods for locking dependencies using
    requirements files: *freezing* and *compiling requirements*. In [Chapter 5](ch05.html#chapter_poetry),
    I’ll describe Poetry’s lock files.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将介绍使用要求文件锁定依赖项的两种方法：*冻结*和*编译要求*。在[第 5 章](ch05.html#chapter_poetry)中，我将描述
    Poetry 的锁定文件。
- en: Freezing Requirements with pip and uv
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 pip 和 uv 冻结要求
- en: 'Requirements files are a popular format for locking dependencies. They let
    you keep the dependency information separate from the project metadata. Pip and
    uv can generate these files from an existing environment:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要求文件是锁定依赖项的流行格式。它们允许您将依赖信息与项目元数据分开。Pip 和 uv 可以从现有环境生成这些文件：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Taking an inventory of the packages installed in an environment is known as
    *freezing*. Store the list in *requirements.txt* and commit the file to source
    control—​with one change: replace the file URL with a dot for the current directory.
    This lets you use the requirements file anywhere, as long as you’re inside the
    project directory.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对环境中安装的软件包进行清单的操作被称为*冻结*。将列表存储在*requirements.txt*中，并将文件提交到源代码控制——只有一个更改：将文件
    URL 替换为当前目录的点。这样，只要您在项目目录内，就可以在任何地方使用要求文件。
- en: 'When deploying your project to production, you can install the project and
    its dependencies like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当将项目部署到生产环境时，您可以像这样安装项目及其依赖项：
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Assuming your development environment uses a recent interpreter, the requirements
    file won’t list `importlib-metadata`—that library is only required before Python
    3.8\. If your production environment runs an ancient Python version, your deployment
    will break. There’s an important lesson here: lock your dependencies in an environment
    that matches the production environment.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的开发环境使用的是最新的解释器，那么要求文件中不会列出 `importlib-metadata`——该库仅在 Python 3.8 之前才需要。如果您的生产环境运行的是古老的
    Python 版本，您的部署将会失败。这里有一个重要的教训：在与生产环境匹配的环境中锁定您的依赖项。
- en: Tip
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: Lock your dependencies on the same Python version, Python implementation, operating
    system, and processor architecture as those used in production. If you deploy
    to multiple environments, generate a requirements file for each one.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 锁定依赖关系与用于生产的相同 Python 版本、Python 实现、操作系统和处理器架构。如果部署到多个环境，请为每个环境生成一个需求文件。
- en: Freezing requirements comes with a few limitations. First, you need to install
    your dependencies every time you refresh the requirements file. Second, it’s easy
    to pollute the requirements file inadvertently if you temporarily install a package
    and forget to create the environment from scratch afterward.^([9](ch04.html#id282))
    Third, freezing doesn’t allow you to record package hashes—​it merely takes an
    inventory of an environment, and environments don’t record hashes for the packages
    you install into them. (I’ll cover package hashes in the next section.)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 冻结需求有一些限制。首先，每次刷新需求文件时都需要安装依赖项。其次，如果临时安装一个软件包并忘记从头开始创建环境，则很容易意外污染需求文件。第三，冻结不允许记录软件包哈希
    —— 它仅仅是对环境进行清单的记录，而环境不记录安装在其中的软件包的哈希（我将在下一节介绍软件包哈希）。
- en: Compiling Requirements with pip-tools and uv
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 pip-tools 和 uv 编译需求
- en: The pip-tools project lets you lock dependencies without these limitations.
    You can compile requirements directly from *pyproject.toml*, without installing
    the packages. Under the hood, pip-tools leverages pip and its dependency resolver.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: pip-tools 项目使您能够在不受这些限制的情况下锁定依赖关系。您可以直接从 *pyproject.toml* 编译需求，而无需安装软件包。在底层，pip-tools
    利用 pip 及其依赖解析器。
- en: 'Pip-tools comes with two commands: `pip-compile`, to create a requirements
    file from dependency specifications, and `pip-sync`, to apply the requirements
    file to an existing environment. The uv tool provides drop-in replacements for
    both commands: `uv pip compile` and `uv pip sync`.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Pip-tools 提供两个命令：`pip-compile`，从依赖规范创建需求文件；`pip-sync`，将需求文件应用到现有环境。uv 工具提供了这两个命令的替代方案：`uv
    pip compile` 和 `uv pip sync`。
- en: 'Run `pip-compile` in an environment that matches the target environment for
    your project. If you use pipx, specify the target Python version:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在与项目目标环境匹配的环境中运行 `pip-compile`。如果使用 pipx，请指定目标 Python 版本：
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: By default, `pip-compile` reads from *pyproject.toml* and writes to *requirements.txt*.
    You can use the `--output-file` option to specify a different destination. The
    tool also prints the requirements to standard error, unless you specify `--quiet`
    to switch off terminal output.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`pip-compile` 从 *pyproject.toml* 读取，并写入 *requirements.txt*。您可以使用 `--output-file`
    选项指定不同的目标。该工具还将需求打印到标准错误，除非您指定 `--quiet` 关闭终端输出。
- en: 'Uv requires you to be explicit about the input and output files:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Uv 要求您明确指定输入和输出文件：
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Pip-tools and uv annotate the file to indicate the dependent package for each
    dependency, as well as the command used to generate the file. There’s one more
    difference to the output of `pip freeze`: the compiled requirements don’t include
    your own project. You’ll have to install it separately after applying the requirements
    file.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Pip-tools 和 uv 为每个依赖包注释文件，指示依赖关系以及用于生成文件的命令。与 `pip freeze` 的输出还有一个区别：编译后的需求文件不包括您自己的项目。您需要在应用需求文件后单独安装它。
- en: 'Requirements files allow you to specify package hashes for each dependency.
    These hashes add another layer of security to your deployments: they enable you
    to install only vetted packaging artifacts in production. The option `--generate-hashes`
    includes SHA256 hashes for each package listed in the requirements file. For example,
    here are hashes over the sdist and wheel files for an `httpx` release:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 需求文件允许您为每个依赖项指定软件包哈希。这些哈希为您的部署增加了另一层安全性：它们使您只能在生产中安装经过审查的包装成品。选项 `--generate-hashes`
    包含需求文件中每个软件包的 SHA256 哈希。例如，以下是 `httpx` 发布的 sdist 和 wheel 文件的哈希：
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Package hashes make installations more deterministic and reproducible. They’re
    also an important tool in organizations that require screening every artifact
    that goes into production. Validating the integrity of packages prevents *on-path
    attacks* where a threat actor (“man in the middle”) intercepts a package download
    to supply a compromised artifact.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包哈希使安装更加确定性和可重现。它们还是需要筛选每个进入生产的工件的组织中的重要工具。验证软件包的完整性可以防止“中间人”攻击，在此攻击中，威胁行为者拦截软件包下载以提供已篡改的工件。
- en: 'Hashes also have the side effect that pip refuses to install packages without
    them: either all packages have hashes, or none do. As a consequence, hashes protect
    you from installing files that aren’t listed in the requirements file.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希值还有一个副作用，即 pip 拒绝安装没有哈希值的软件包：要么所有软件包都有哈希值，要么没有。因此，哈希值保护您免受安装未列在需求文件中的文件的影响。
- en: 'Install the requirements file in the target environment using pip or uv, followed
    by the project itself. You can harden the installation using a couple of options:
    the option `--no-deps` ensures that you only install packages listed in the requirements
    file, and the option `--no-cache` prevents the installer from reusing downloaded
    or locally built artifacts.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在目标环境中使用 pip 或 uv 安装需求文件，然后再安装项目本身。您可以通过几个选项加固安装：选项 `--no-deps` 确保您只安装需求文件中列出的软件包，选项
    `--no-cache` 防止安装程序重复使用下载或本地构建的文件。
- en: '[PRE32]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Update your dependencies at regular intervals. Once per week may be acceptable
    for a mature application running in production. Daily may be more appropriate
    for a project under active development—​or even as soon as the releases come in.
    Tools like Dependabot and Renovate help with this chore: They open pull requests
    in your repositories with automated dependency upgrades.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 定期更新依赖项。对于生产环境中运行的成熟应用程序，每周更新一次可能是可以接受的。对于正在积极开发的项目，每天更新甚至在发布后立即更新可能更合适。Dependabot
    和 Renovate 等工具可帮助完成这些工作：它们在您的存储库中打开拉取请求，以自动升级依赖项。
- en: If you don’t upgrade dependencies regularly, you may be forced to apply a “big
    bang” upgrade under time pressure. A single security vulnerability can force you
    to port your project to major releases of multiple packages, as well as Python
    itself.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不定期升级依赖项，您可能会被迫在时间紧迫的情况下进行“大爆炸”升级。单个安全漏洞可能会迫使您将项目移植到多个软件包的主要版本以及 Python 本身的最新版本。
- en: You can upgrade your dependencies all at once, or one dependency at a time.
    Use the `--upgrade` option to upgrade all dependencies to their latest version,
    or pass a specific package with the `--upgrade-package` option (`-P`).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以一次性升级所有依赖项，也可以逐个依赖项升级。使用 `--upgrade` 选项将所有依赖项升级到它们的最新版本，或者使用 `--upgrade-package`
    选项（`-P`）传递特定软件包。
- en: 'For example, here’s how you’d upgrade Rich to the latest version:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是您如何升级 Rich 到最新版本的方式：
- en: '[PRE33]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'So far, you’ve created the target environment from scratch. You can also use
    `pip-sync` to synchronize the target environment with the updated requirements
    file. Don’t install pip-tools in the target environment for this: its dependencies
    may conflict with those of your project. Instead, use pipx, as you did with `pip-compile`.
    Point `pip-sync` to the target interpreter using its `--python-executable` option:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已从头开始创建了目标环境。您还可以使用 `pip-sync` 同步目标环境与更新后的需求文件。为此不要在目标环境中安装 pip-tools：其依赖可能与您项目的依赖发生冲突。而是像您在
    `pip-compile` 中使用 pipx 一样，使用 `--python-executable` 选项将 pip-sync 指向目标解释器：
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The command removes the project itself since it’s not listed in the requirements
    file. Re-install it after synchronizing:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会删除项目本身，因为它没有列在需求文件中。在同步后重新安装它：
- en: '[PRE35]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Uv uses the environment in *.venv* by default, so you can simplify these commands:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Uv 默认使用 *.venv* 中的环境，因此您可以简化这些命令：
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In [“Development Dependencies”](#section_dependencies_development), you saw
    two ways to declare development dependencies: extras and requirements files. Pip-tools
    and uv support both as inputs. If you track development dependencies in a `dev`
    extra, generate the *dev-requirements.txt* file like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“开发依赖项”](#section_dependencies_development) 中，您看到了声明开发依赖项的两种方式：extras 和需求文件。Pip-tools
    和 uv 都支持它们作为输入。如果您在 `dev` extra 中跟踪开发依赖项，请像这样生成 *dev-requirements.txt* 文件：
- en: '[PRE37]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If you have finer-grained extras, the process is the same. You may want to store
    the requirements files in a *requirements* directory to avoid clutter.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有更精细化的 extras，流程是相同的。您可能希望将需求文件存储在 *requirements* 目录中，以避免混乱。
- en: If you specify your development dependencies in requirements files instead of
    extras, compile each of these files in turn. By convention, input requirements
    use the *.in* extension, while output requirements use the *.txt* extension ([Example 4-10](#example_dependencies_dev_requirements_in)).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将开发依赖项指定为需求文件而不是 extras，在此顺序编译每个文件。按照惯例，输入需求使用 *.in* 扩展名，而输出需求使用 *.txt* 扩展名（[示例
    4-10](#example_dependencies_dev_requirements_in)）。
- en: Example 4-10\. Input requirements for development dependencies
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-10\. 开发依赖项的输入需求
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Unlike [Example 4-9](#example_dependencies_dev_requirements), the input requirements
    don’t list the project itself. If they did, the output requirements would include
    the path to the project—​and every developer would end up with a different path.
    Instead, pass *pyproject.toml* together with the input requirements to lock the
    entire set of dependencies together:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 与 [示例 4-9](#example_dependencies_dev_requirements) 不同，输入的需求列表不包括项目本身。如果包括，输出的需求会包含项目的路径—每位开发者的路径可能不同。相反，将
    *pyproject.toml* 与输入需求一起传递以锁定整套依赖项：
- en: '[PRE39]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Remember to install the project after you’ve installed the output requirements.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 安装输出需求后，请记得安装项目。
- en: Why bother compiling *dev.txt* at all? Can’t it just include *docs.txt* and
    *tests.txt*? If you install separately locked requirements on top of each other,
    they may well end up conflicting. Let the dependency resolver see the full picture.
    If you pass all the input requirements, it can give you a consistent dependency
    tree in return.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 到底为什么要编译 *dev.txt* 呢？它不能仅包括 *docs.txt* 和 *tests.txt* 吗？如果你分别安装已锁定的需求，它们可能会冲突。让依赖解析器看到完整的情况。如果你传递所有输入需求，它将给你一个一致的依赖树作为回报。
- en: '[Table 4-3](#table_dependencies_pipcompile_options) summarizes the command-line
    options for `pip-compile` you’ve seen in this chapter:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-3](#table_dependencies_pipcompile_options) 总结了本章中您看到的 `pip-compile` 的命令行选项：'
- en: Table 4-3\. Selected command-line options for `pip-compile`
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-3\. `pip-compile` 的选定命令行选项
- en: '| Option | Description |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `--generate-hashes` | Include SHA256 hashes for every packaging artifact
    |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `--generate-hashes` | 为每个打包工件包含 SHA256 哈希值 |'
- en: '| `--output-file` | Specify the destination file |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `--output-file` | 指定目标文件 |'
- en: '| `--quiet` | Do not print the requirements to standard error |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `--quiet` | 不要将需求打印到标准错误输出 |'
- en: '| `--upgrade` | Upgrade all dependencies to their latest version |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `--upgrade` | 将所有依赖项升级到它们的最新版本 |'
- en: '| `--upgrade-package=*<package>*` | Upgrade a specific package to its latest
    version |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `--upgrade-package=*<package>*` | 将特定包升级到其最新版本 |'
- en: '| `--extra=*<extra>*` | Include dependencies from the given extra in *pyproject.toml*
    |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `--extra=*<extra>*` | 在 *pyproject.toml* 中包含给定额外依赖项 |'
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you’ve learned how to declare project dependencies using *pyproject.toml*
    and how to declare development dependencies using either extras or requirements
    files. You’ve also learned how to lock dependencies for reliable deployments and
    reproducible checks using pip-tools. In the next chapter, you’ll see how the project
    manager Poetry helps with dependency management using dependency groups and lock
    files.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何使用 *pyproject.toml* 声明项目依赖关系，以及如何使用额外项或需求文件声明开发依赖关系。您还学习了如何使用 pip-tools
    锁定依赖项以实现可靠的部署和可重现的检查。在下一章中，您将看到项目管理器 Poetry 如何使用依赖组和锁文件来帮助依赖管理。
- en: ^([1](ch04.html#id273-marker)) In a wider sense, the dependencies of a project
    consist of all software packages that users require to run its code—​including
    the interpreter, the standard library, third-party packages, and system libraries.
    Conda and distro-level package managers like APT, DNF, and Homebrew support this
    generalized notion of dependencies.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch04.html#id273-marker)) 从更广泛的意义上讲，项目的依赖包括所有用户运行其代码所需的所有软件包—包括解释器、标准库、第三方包和系统库。Conda
    和像 APT、DNF 和 Homebrew 这样的发行级包管理器支持这种泛化的依赖概念。
- en: '^([2](ch04.html#id274-marker)) Henry Schreiner: [“Should You Use Upper Bound
    Version Constraints?,”](https://iscinumpy.dev/post/bound-version-constraints/)
    December 9, 2021.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '^([2](ch04.html#id274-marker)) Henry Schreiner: [“是否应使用上限版本约束？”，](https://iscinumpy.dev/post/bound-version-constraints/)
    2021年12月9日。'
- en: ^([3](ch04.html#id275-marker)) For simplicity, the code doesn’t handle multiple
    authors—​which one ends up in the header is undefined.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch04.html#id275-marker)) 为简单起见，代码不处理多个作者—头部最终显示的作者未定义。
- en: '^([4](ch04.html#id276-marker)) Robert Collins: [“PEP 508 – Dependency specification
    for Python Software Packages,”](https://peps.python.org/pep-0508/) November 11,
    2015.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '^([4](ch04.html#id276-marker)) Robert Collins: [“PEP 508 – Python软件包的依赖规范”，](https://peps.python.org/pep-0508/)
    2015年11月11日。'
- en: '^([5](ch04.html#id278-marker)) Stephen Rosen: [“PEP 735 – Dependency Groups
    in pyproject.toml,”](https://peps.python.org/pep-0735/) November 20, 2023.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '^([5](ch04.html#id278-marker)) Stephen Rosen: [“PEP 735 – pyproject.toml 中的依赖组”，](https://peps.python.org/pep-0735/)
    2023年11月20日。'
- en: '^([6](ch04.html#id279-marker)) Dan Goodin: [“Actors behind PyPI supply chain
    attack have been active since late 2021,”](https://arstechnica.com/information-technology/2022/09/actors-behind-pypi-supply-chain-attack-have-been-active-since-late-2021/)
    September 2, 2022.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '^([6](ch04.html#id279-marker)) Dan Goodin: [“PyPI供应链攻击背后的行动者自2021年末以来一直活跃,”](https://arstechnica.com/information-technology/2022/09/actors-behind-pypi-supply-chain-attack-have-been-active-since-late-2021/)
    2022年9月2日。'
- en: '^([7](ch04.html#id280-marker)) Natalie Weizenbaum: [“PubGrub: Next-Generation
    Version Solving,”](https://nex3.medium.com/pubgrub-2fb6470504f) April 2, 2018'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '^([7](ch04.html#id280-marker)) Natalie Weizenbaum: [“PubGrub: 下一代版本解决方案,”](https://nex3.medium.com/pubgrub-2fb6470504f)
    2018年4月2日'
- en: '^([8](ch04.html#id281-marker)) Brett Cannon: [“Lock files, again (but this
    time w/ sdists!),”](https://discuss.python.org/t/lock-files-again-but-this-time-w-sdists/46593)
    February 22, 2024.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '^([8](ch04.html#id281-marker)) Brett Cannon: [“再次谈论锁定文件（但这次包括sdists！）,”](https://discuss.python.org/t/lock-files-again-but-this-time-w-sdists/46593)
    2024年2月22日。'
- en: '^([9](ch04.html#id282-marker)) Uninstalling the package isn’t enough: the installation
    can have side effects on your dependency tree. For example, it may upgrade or
    downgrade other packages or pull in additional dependencies.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch04.html#id282-marker)) 卸载软件包并不足够：安装可能会对您的依赖树产生副作用。例如，它可能会升级或降级其他软件包，或者引入额外的依赖关系。
