- en: Chapter 4\. Constraining Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。类型约束
- en: 'Many developers learn the basic type annotations and call it a day. But we’re
    far from done. There is a wealth of advanced type annotations that are invaluable.
    These advanced type annotations allow you to constrain types, further restricting
    what they can represent. Your goal is to make illegal states unrepresentable.
    Developers should physically not be able to create types that are contradictory
    or otherwise invalid in your system. You can’t have errors in your code if it’s
    impossible to create the error in the first place. You can use type annotations
    to achieve this very goal, saving time and money. In this chapter I’ll teach you
    six different techniques:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发人员学习了基本类型注解就结束了。但我们远未结束。有许多宝贵的高级类型注解。这些高级类型注解允许您约束类型，进一步限制它们可以表示的内容。您的目标是使非法状态无法表示。如果根本不可能在系统中创建错误，那么您的代码中就不会出现错误。您可以使用类型注解来实现这个目标，节省时间和金钱。在本章中，我将教您六种不同的技术：
- en: '`Optional`'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional`'
- en: Use to replace `None` references in your codebase.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 用于在您的代码库中替换`None`引用。
- en: '`Union`'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`Union`'
- en: Use to present a selection of types.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 用于呈现一组类型的选择。
- en: '`Literal`'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`Literal`'
- en: Use to restrict developers to very specific values.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 用于限制开发人员使用非常特定的值。
- en: '`Annotated`'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`Annotated`'
- en: Use to provide additional description of your types.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 用于提供类型的附加描述。
- en: '`NewType`'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewType`'
- en: Use to restrict a type to a specific context.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 用于将类型限制在特定上下文中。
- en: '`Final`'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`Final`'
- en: Use to prevent variables from being rebound to a new value.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 用于防止变量被重新绑定到新值。
- en: Let’s start with handling `None` references with `Optional` types.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用`Optional`类型处理`None`引用开始。
- en: Optional Type
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可选类型
- en: 'Null references are often referred to as the “billion-dollar mistake,” coined
    by C.A.R. Hoare:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 空引用通常被称为“十亿美元的错误”，这个术语是由C.A.R. Hoare创造的：
- en: I call it my billion-dollar mistake. It was the invention of the null reference
    in 1965\. At that time, I was designing the first comprehensive type system for
    references in an object oriented language. My goal was to ensure that all use
    of references should be absolutely safe, with checking performed automatically
    by the compiler. But I couldn’t resist the temptation to put in a null reference,
    simply because it was so easy to implement. This has led to innumerable errors,
    vulnerabilities, and system crashes, which have probably caused a billion dollars
    of pain and damage in the last forty years.^([1](part0007_split_009.html#idm45644755819000))
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我称之为我的十亿美元的错误。这是在1965年发明的空引用。当时，我正在设计一种用于对象导向语言中引用的第一个全面类型系统。我的目标是确保所有引用的使用都绝对安全，并由编译器自动执行检查。但我无法抵挡诱惑，简单地实现了一个空引用。这导致了无数的错误、漏洞和系统崩溃，这些问题可能在过去四十年中造成了数十亿美元的损失和损害。^([1](part0007_split_009.html#idm45644755819000))
- en: While null references started in Algol, they would pervade countless other languages.
    C and C++ are often derided for null pointer dereference (which produces a segmentation
    fault or other program-halting crash). Java was well-known for requiring the user
    to catch `NullPointerException` throughout their code. It’s not a stretch to say
    that these sorts of bugs have a price tag measured in the billions. Think of the
    developer time, customer loss, and system failures due to accidental null pointers
    or references.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管空引用起源于Algol语言，但它们已经渗透到无数其他语言中。C和C++经常因空指针解引用而受到嘲笑（导致段错误或其他导致程序崩溃的问题）。Java因要求用户在整个代码中捕获`NullPointerException`而广为人知。可以毫不夸张地说，这些类型的错误具有以十亿计的代价。想想由于意外的空指针或引用而导致的开发人员时间、客户损失和系统故障。
- en: 'So, why does this matter in Python? Hoare’s quote is about object-oriented
    compiled languages back in the 60s; Python must be better by now, right? I regret
    to inform you that this billion-dollar mistake is in Python as well. It appears
    to us under a different name: `None`. I will show you a way to avoid the costly
    `None` mistake, but first, let’s talk about why `None` is so bad.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在Python中为什么这很重要呢？Hoare的引用是关于60年代的面向对象编译语言；Python现在一定会更好，对吧？我很遗憾地告诉您，这个十亿美元的错误也存在于Python中。它以不同的名字出现在我们面前：`None`。我将向您展示一种避免昂贵`None`错误的方法，但首先，让我们谈谈为什么`None`如此糟糕。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It is especially illuminating that Hoare admits that null references were born
    out of convenience. It goes to show you how taking the quicker path can lead to
    all sorts of pain later in your development life cycle. Think how your short-term
    decisions today will adversely affect your maintenance tomorrow.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其值得注意的是，霍尔承认，空引用是为了方便而产生的。这表明了选择更快捷的路径如何会在开发生命周期的后期导致各种痛苦。想想你今天的短期决策会如何不利于明天的维护。
- en: Let’s consider some code that runs an automated hot dog stand. I want my system
    to take a bun, put a frank in the bun, and then squirt ketchup and mustard through
    automated dispensers, as described in [Figure 4-1](part0007_split_001.html#figure_4_1).
    What could go wrong?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些运行自动热狗摊的代码。我希望我的系统能够拿起一个面包，把一根热狗放在面包里，然后通过自动发泡器挤出番茄酱和芥末，就像[图 4-1](part0007_split_001.html#figure_4_1)中描述的那样。会出什么问题呢？
- en: '![Worfklow for the automated hotdog stand](../images/00004.gif)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![自动热狗摊的工作流程](../images/00004.gif)'
- en: Figure 4-1\. Workflow for the automated hot dog stand
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-1\. 自动热狗摊的工作流程
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Pretty straightforward, no? Unfortunately, there’s no way to really tell. It’s
    easy to think through the happy path, or the control flow of the program when
    everything goes right, but when talking about robust code, you need to consider
    error conditions. If this were an automated stand with no manual intervention,
    what errors can you think of?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 相当直接，对吧？不幸的是，没有办法真正确定。想清楚正常路径，或者程序的控制流程当一切顺利时，是很容易的，但是当谈论到健壮的代码时，你需要考虑错误条件。如果这是一个没有人工干预的自动摊位，你能想到什么错误？
- en: 'Here’s a noncomprehensive list of errors I can think of:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我能想到的错误的非全面列表：
- en: Out of ingredients (buns, hot dogs, or ketchup/mustard).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材料不足（面包、热狗或番茄酱/芥末）。
- en: Order cancelled midprocess.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单在过程中取消。
- en: Condiments get jammed.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调料堵塞。
- en: Power is interrupted.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电力中断。
- en: Customer doesn’t want ketchup or mustard and tries to move the bun midprocess.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户不想要番茄酱或芥末，并试图在过程中移动面包。
- en: Rival vendor switches the ketchup out with catsup; chaos ensues.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 竞争对手用番茄酱替换了番茄酱；混乱随之而来。
- en: 'Now, your system is state of the art and will detect all of these conditions,
    but it does so by returning `None` when any one step fails. What does this mean
    for this code? You start seeing errors like the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的系统是最先进的，会检测所有这些情况，但是当任何一步失败时，它会返回`None`。这对这段代码意味着什么？你开始看到以下错误：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It would be catastrophic if these errors bubbled up to your customers; you
    pride yourself on a clean UI and don’t want ugly tracebacks defiling your interface.
    To address this, you start to code *defensively*, or coding in such a way that
    you try to foresee every possible error case and account for it. Defensive programming
    is a good thing, but it leads to code like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些错误泡沫冒到你的客户那里会很灾难性；你以清爽的用户界面为傲，不希望丑陋的回溯污染你的界面。为了解决这个问题，你开始进行*防御性编程*，或者以一种能够预见每种可能错误情况并加以考虑的方式进行编码。防御性编程是一件好事，但它导致了这样的代码：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This feels, well, tedious. Because any value can be `None` in Python, it seems
    like you need to engage in defensive programming and do an `is None` check before
    every dereference. This is overkill; most developers will trace through the call
    stack and ensure that no `None` values are returned to the caller. That leaves
    calls to external systems and maybe a scant few calls in your codebase that you
    always have to wrap with `None` checking. This is error prone; you cannot expect
    every developer who ever touches your codebase to know instinctively where to
    check for `None`. Furthermore, the original assumptions you’ve made when writing
    (e.g., this function will never return `None`) can be broken in the future, and
    now your code has a bug. And herein lies your problem: counting on manual intervention
    to catch error cases is unreliable.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这感觉，嗯，很烦人。因为在Python中任何值都可以是`None`，所以似乎你需要进行防御性编程，并在每次解除引用之前进行一个`is None`检查。这是多余的；大多数开发人员会跟踪调用堆栈，并确保不会将`None`值返回给调用者。这是错误的；你不能指望每个接触你的代码库的开发人员都能本能地知道在哪里检查`None`。此外，你编写代码时所做的原始假设（例如，此函数永远不会返回`None`）可能会在将来被打破，现在你的代码有了一个bug。问题就在这里：依靠手动干预来捕捉错误情况是不可靠的。
- en: The reason this is so tricky (and so costly) is that `None` is treated as a
    special case. It exists outside the normal type hierarchy. Every variable can
    be assigned to `None`. In order to combat this, you need to find a way of representing
    `None` inside your type hierarchy. You need `Optional` types.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如此棘手（也如此昂贵）的原因是，`None` 被视为一种特殊情况。它存在于正常类型层次结构之外。每个变量都可以被赋值为 `None`。为了应对这一点，你需要找到一种在你的类型层次结构中表示
    `None` 的方法。你需要使用 `Optional` 类型。
- en: '`Optional` types offer you two choices: either you have a value or you don’t.
    In other words, it is optional to set the variable to a value.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional` 类型为你提供两种选择：要么你有一个值，要么你没有。换句话说，将变量设置为一个值是可选的。'
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code indicates that the variable `maybe_a_string` may optionally contain
    a string. That code typechecks just fine, whether `maybe_a_string` contains `"abcdef"`
    or `None`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码指示变量 `maybe_a_string` 可能包含一个字符串。无论 `maybe_a_string` 包含 `"abcdef"` 还是 `None`，该代码都能成功通过类型检查。
- en: At first glance, it’s not apparent what this buys you. You still need to use
    `None` to represent the absence of a value. I have good news for you, though.
    There are three benefits I associate with `Optional` types.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，不明显它能为你带来什么。你仍然需要使用 `None` 来表示值的缺失。不过，我有个好消息告诉你。我将 `Optional` 类型与三个好处关联起来。
- en: First, you communicate your intent more clearly. If a developer sees an `Optional`
    type in a type signature, they view that as a big red flag that they should expect
    `None` as a possibility.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以更清晰地表达你的意图。如果开发者在类型签名中看到 `Optional` 类型，他们会把它看作一个大红旗，表明他们应该预期可能会出现 `None`。
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you notice a function returning an `Optional` value, take heed and check
    for `None` values.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到一个函数返回一个 `Optional` 值，请注意并检查 `None` 值。
- en: 'Second, you are able to further distinguish the absence of value from an empty
    value. Consider the innocuous list. What happens if you make a function call and
    receive an empty list? Was it just that no results were provided back to you?
    Or was it that an error occurred and you need to take explicit action? If you
    are receiving a raw list, you don’t know without trawling through source code.
    However, if you use an `Optional`, you are conveying one of three possibilities:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你能够进一步区分值的缺失和空值。考虑一个无害的列表。如果你进行一个函数调用并接收到一个空列表，会发生什么？是因为没有结果返回给你吗？还是发生了错误，你需要采取明确的行动？如果你收到一个原始列表，你不知道，除非你深入源代码。然而，如果你使用
    `Optional`，你传达了三种可能性中的一种：
- en: A list with elements
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有元素的列表
- en: Valid data to be operated on
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 可操作的有效数据
- en: A list with no elements
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个没有元素的列表
- en: No error occurred, but no data was available (provided that no data is not an
    error condition)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 没有发生错误，但没有可用数据（假设没有数据不是错误条件）
- en: '`None`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`None`'
- en: An error occurred that you need to handle
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了一个需要处理的错误
- en: Finally, typecheckers can detect `Optional` types and make sure that you aren’t
    letting `None` values slip through.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，类型检查器可以检测到 `Optional` 类型，并确保你没有让 `None` 值溜过去。
- en: 'Consider:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s add some error cases to this code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给这段代码添加一些错误情况：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When run with a typechecker, you get the following error:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用类型检查器运行时，你将得到以下错误：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Excellent! The typechecker will not allow you to return a `None` value by default.
    By changing the return type from `Bun` to `Optional[Bun]`, the code will typecheck
    successfully. This will give developers hints that they should not return `None`
    without encoding information in the return type. You can catch a common mistake
    and make this code more robust. But what about the calling code?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！类型检查器将不允许你默认返回 `None` 值。通过将返回类型从 `Bun` 更改为 `Optional[Bun]`，这段代码将成功地通过类型检查。这将为开发者提供提示，表明他们不应该在不在返回类型中编码信息的情况下返回
    `None`，可以捕捉一个常见的错误，并使这段代码更加健壮。但是调用代码呢？
- en: 'It turns out that the calling code benefits from this as well. Consider:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，调用代码也从中受益。考虑：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If `dispense_bun` returns an `Optional`, this code will not typecheck. It will
    complain with the following error:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `dispense_bun` 返回一个 `Optional`，这段代码将无法通过类型检查。它会报以下错误：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Warning
  id: totrans-66
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Depending on your typechecker, you may need to specifically enable an option
    to catch these sorts of errors. Always look through your typechecker’s documentation
    to learn what options are available. If there is an error you absolutely want
    to catch, you should test that your typechecker does indeed catch the error. I
    highly recommend testing out `Optional` behavior specifically. For the version
    of `mypy` I am running (0.800), I have to use `--strict-optional` as a command-line
    flag to catch this error.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的类型检查器，你可能需要专门启用一个选项来捕捉这些错误。始终查看你的类型检查器的文档，了解有哪些选项可用。如果有一个你绝对想要捕捉的错误，你应该测试一下你的类型检查器确实捕捉到了这个错误。我强烈建议专门测试`Optional`的行为。对于我正在运行的`mypy`版本（0.800），我必须使用`--strict-optional`作为命令行标志来捕捉这个错误。
- en: 'If you are interested in silencing the typechecker, you need to check for `None`
    explicitly and handle the `None` value, or assert that the value cannot be `None`.
    The following code typechecks successfully:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要消除类型检查器的警告，你需要显式检查`None`并处理`None`值，或者断言该值不能是`None`。以下代码可以成功进行类型检查：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`None` values truly are a billion-dollar mistake. If they slip through, programs
    can crash, users are frustrated, and money is lost. Use `Optional` types to tell
    other developers to beware of `None`, and benefit from the automated checking
    of your tools.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`None`值真的是一个十亿美元的错误。如果它们溜过去，程序可能会崩溃，用户会感到沮丧，钱会丢失。使用`Optional`类型告诉其他开发者注意`None`，并从你的工具的自动检查中受益。'
- en: Discussion Topic
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论主题
- en: How often do you deal with `None` in your codebase? How confident are you that
    every possible `None` value is handled correctly? Look through bugs and failing
    tests to see how many times you’ve been bitten by incorrect `None` handling. Discuss
    how `Optional` types will help your codebase.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码库中经常处理`None`吗？你对每个可能的`None`值是否处理正确有多自信？查看错误和失败的测试，看看你被错误的`None`处理咬了多少次。讨论一下`Optional`类型将如何帮助你的代码库。
- en: Union Types
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联合类型
- en: 'A `Union` type is a type that indicates that multiple disparate types may be
    used with the same variable. A `Union[int,str]` means that either an `int` *or*
    a `str` can be used for a variable. For instance, consider the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`Union`类型是指多个不同的类型可以与同一个变量一起使用的类型。`Union[int,str]`表示一个变量可以使用`int` *或*`str`。例如，考虑以下代码：'
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: I now want my hot dog stand to break into the lucrative pretzel business. Instead
    of trying to deal with weird class inheritance (we’ll cover more about inheritance
    in [Part II](part0011.html#part_2)) that doesn’t belong between hot dogs and pretzels,
    you simply can return a `Union` of the two.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在希望我的热狗摊能进入利润丰厚的椒盐脆饼业务。而不是试图处理不应存在于热狗和椒盐脆饼之间的奇怪的类继承（我们将在[第二部分](part0011.html#part_2)中更多地介绍继承），你只需返回这两者的`Union`。
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`Optional` is just a specialized version of a `Union`. `Optional[int]` is the
    same exact thing as `Union[int, None]`.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional`只是`Union`的一种特殊版本。`Optional[int]`与`Union[int, None]`完全相同。'
- en: Using a `Union` offers much the same benefit as an `Optional`. First, you reap
    the same communication advantages. A developer encountering a `Union` knows that
    they must be able to handle more than one type in their calling code. Furthermore,
    a typechecker is just as aware of `Union` as it is of `Optional`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Union`提供了与`Optional`几乎相同的好处。首先，你能得到同样的沟通优势。遇到`Union`的开发者知道他们必须能够处理调用代码中的多个类型。此外，类型检查器和`Optional`一样了解`Union`。
- en: 'You will find `Unions` useful in a variety of applications:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现`Union`在各种应用中都很有用：
- en: Handling disparate types returned based on user input (as above)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据用户输入处理返回的不同类型（如上所述）
- en: Handling error return types a la `Optional`s, but with more information, such
    as a string or error code
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理错误返回类型，比如`Optional`，但提供更多信息，比如字符串或错误代码
- en: Handling different user input (such as if a user is able to supply a list or
    a string)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理不同的用户输入（例如，如果用户能够提供一个列表或一个字符串）
- en: Returning different types, say for backward compatibility (returning an old
    version of an object or a new version of an object depending on requested operation)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回不同的类型，比如为了向后兼容性（根据请求的操作返回一个旧版本的对象或一个新版本的对象）
- en: And any other case where you may legitimately have more than one value represented
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以及其他任何你可能合理地有多个值表示的情况
- en: 'Suppose you had code that called the `dispense_snack` function but was only
    expecting a `HotDog` (or `None`) to be returned:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个调用`dispense_snack`函数的代码，但只期望返回一个`HotDog`（或`None`）：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As soon as `dispense_snack` starts returning `Pretzels`, this code fails to
    typecheck.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`dispense_snack`开始返回`Pretzels`，这段代码就无法通过类型检查。
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The fact that the typechecker errors out in this case is fantastic. If any function
    you depend on changes to return a new type, its return signature must be updated
    to `Union` a new type, which forces you to update your code to handle the new
    type. This means that your code will be flagged when your dependencies change
    in a way that contradicts your assumptions. With the decisions you make today,
    you can catch errors in the future. This is the mark of robust code; you are making
    it increasingly harder for developers to make mistakes, which reduces their error
    rates, which reduces the number of bugs users will experience.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，类型检查器出错的事实是非常好的。如果您依赖的任何函数更改为返回新类型，则其返回签名必须更新为`Union`新类型，这将强制您更新代码以处理新类型。这意味着，当您的依赖项以与您的假设相矛盾的方式发生变化时，您的代码将被标记。通过您今天做出的决策，您可以在未来捕捉错误。这是健壮代码的标志；您使开发人员犯错的难度越来越大，从而降低了他们的错误率，减少了用户可能遇到的错误数量。
- en: There is one more fundamental benefit of using a `Union`, but to explain it,
    I need to teach you a smidge of *type theory*, which is a branch of mathematics
    around type systems.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Union`还有一个更根本的好处，但是要解释清楚，我需要教你一点*类型理论*，这是关于类型系统的一种数学分支。
- en: Product and Sum Types
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 产品和总和类型
- en: '`Unions` are beneficial because they help constrain representable state space.
    *Representable state space* is the set of all possible combinations an object
    can take.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Union`很有用，因为它们有助于限制可表示的状态空间。 *可表示的状态空间* 是对象可以采用的所有可能组合的集合。'
- en: 'Take this `dataclass`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 取这个`dataclass`：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: I have a name, the condiments that can go on top, an error code in case something
    goes wrong, and if something does go wrong, a boolean to track whether I have
    disposed of the item correctly or not. How many different combinations of values
    can be put into this dictionary? A potentially infinite number, right? The `name`
    alone could be anything from valid values (“hotdog” or “pretzel”) to invalid values
    (“samosa”, “kimchi”, or “poutine”) to absurd (“12345”, “”, or “(╯°□°)╯︵ ┻━┻”).
    `condiments` has a similar problem. As it stands, there is no way to compute the
    possible options.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个名称，可以放在顶部的调味料，如果出了问题，还有一个错误代码，并且如果出了问题，有一个布尔值来跟踪我是否正确处理了该项。可以将多少种不同的值组合放入这个字典？可能是无限多个，对吧？`name`单独可以是任何有效值（“热狗”或“椒盐脆饼”）到无效值（“萨摩萨”、“泡菜”或“布丁”）甚至是荒谬的（“12345”、“”或“(╯°□°)╯︵
    ┻━┻”）。 `condiments`也存在类似的问题。目前，无法计算可能的选项。
- en: 'For the sake of simplicity, I will artificially constrain this type:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我将人为地限制这种类型：
- en: 'The name can be one of three values: hotdog, pretzel, or veggie burger'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称可以是三个值之一：热狗、椒盐脆饼或素食汉堡。
- en: The condiments can be empty, mustard, ketchup, or both.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调味料可以是空的、芥末、番茄酱或两者兼有。
- en: There are six error codes (0–5); 0 indicates success).
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有六个错误代码（0-5）；0表示成功。
- en: '`disposed_of` is only `True` or `False`.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disposed_of`只能是`True`或`False`。'
- en: 'Now how many different values can be represented in this combination of fields?
    The answer is 144, which is a grossly large number. I achieve this by the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这组字段可以表示多少种不同的值？答案是144，这是一个极其庞大的数字。我通过以下方式实现这一点：
- en: 3 possible types for name × 4 possible types for condiments × 6 error codes
    × 2 boolean values for if the entry has been disposed of = 3×4×6×2 = 144.
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 名称有三种可能类型 × 调味品有四种可能类型 × 六个错误代码 × 两个布尔值用于记录条目是否已处理 = 3×4×6×2 = 144。
- en: If you were to accept that any of these values could be `None`, the total balloons
    to 420\. While you should always think about `None` while coding (see earlier
    in this chapter about `Optional`), for this thought exercise, I’m going to ignore
    `None values`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你接受这些值中的任何一个可以是`None`，则总数扩展到420。虽然编码时应始终考虑`None`（请参阅本章前面关于`Optional`的内容），但对于这个思维实验，我将忽略`None`值。
- en: 'This sort of operation is known as a *product type*; the number of representable
    states is determined by the product of possible values. The problem is, not all
    of these states are valid. The variable `disposed_of` should only be set to `True`
    if an error code is set to nonzero. Developers will make this assumption, and
    trust that the illegal state never shows up. However, one innocent mistake can
    bring your whole system crashing to a halt. Consider the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种操作被称为*乘类型*；可表示状态的数量由可能值的乘积决定。问题在于，并非所有这些状态都是有效的。如果将变量`disposed_of`设置为非零错误码，则应该将其设置为`True`。开发人员会做出这种假设，并相信非法状态永远不会出现。然而，一个无辜的错误可能导致整个系统崩溃。考虑以下代码：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this case, a developer is checking `disposed_of` without checking for the
    nonzero error code first. This is a logic bomb waiting to happen. This code will
    work completely fine as long as `disposed_of` is `True` *and* the error code is
    nonzero. If a valid snack ever sets the `disposed_of` flag to `True` erroneously,
    this code will start producing invalid results. This can be hard to find, as there’s
    no reason for a developer who is creating the snack to check this code. As it
    stands, you have no way of catching this sort of error other than manually inspecting
    every use case, which is intractable for large code bases. By allowing an illegal
    state to be representable, you open the door to fragile code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，开发人员在检查非零错误码之前检查`disposed_of`。这是一个等待发生的逻辑炸弹。只要`disposed_of`为`True` *且*错误码为非零，这段代码就完全正常。如果一个有效的小吃错误地将`disposed_of`标志设置为`True`，这段代码将开始产生无效的结果。这很难找到，因为创建小吃的开发人员没有理由检查此代码。目前为止，除了手动检查每个用例之外，您没有办法捕获这种错误，对于大型代码库来说是不可行的。通过允许可表示非法状态，您打开了脆弱代码的大门。
- en: 'To remedy this, I need to make this illegal state unrepresentable. To do that,
    I’ll rework my example and use a `Union`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，我需要使这个非法状态不可表示。为了做到这一点，我将重新调整我的示例，并使用`Union`：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this case, `snack` can be either a `Snack` (which is just a `name` and `condiments`)
    or an `Error` (which is just a number and a boolean). With the use of a `Union`,
    how many representable states are there now?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`snack`可以是一个`Snack`（仅包含`name`和`condiments`）或一个`Error`（仅包含一个数字和一个布尔值）。通过使用`Union`，现在有多少个可表示的状态呢？
- en: For `Snack`, there are 3 names and 4 possible list values, which is a total
    of 12 representable states. For `ErrorCode`, I can remove the 0 error code (since
    that was only for success), which gives me 5 values for the error code and 2 values
    for the boolean for a total of 10 representable states. Since the `Union` is an
    either/or construct, I can either have 12 representable states in one case or
    10 in the other, for a total of 22\. This is an example of a *sum type*, since
    I’m adding the number of representable states together rather than multiplying.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Snack`，有3个名称和4个可能的列表值，总共有12个可表示的状态。对于`ErrorCode`，我可以移除0错误码（因为那只是成功的情况），这给了我5个错误码的值和2个布尔值的总计10个可表示的状态。由于`Union`是一个选择一个或另一个的结构，我可以在一种情况下有12个可表示的状态，或者在另一种情况下有10个，总共22个。这是一个*和类型*的示例，因为我是将可表示状态的数量相加而不是相乘。
- en: That’s 22 total representable states. Compare that with the 144 states when
    all the fields were lumped in a single entity. I’ve reduced my representable state
    space by almost 85%. I’ve made it impossible to mix and match fields that are
    incompatible with one another. It becomes much harder to make a mistake, and there
    are far fewer combinations to test. Anytime you use a sum type, such as a `Union`,
    you are dramatically decreasing the number of possible representable states.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是22个总可表示的状态。将其与将所有字段合并到单个实体时的144个状态进行比较。我将我的可表示状态空间减少了几乎85%。我使得不兼容的字段无法混合和匹配。这样做变得更难出错，并且需要测试的组合数量大大减少。任何时候您使用和类型，例如`Union`，都会大幅减少可能的可表示状态数量。
- en: Literal Types
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字面类型
- en: 'When calculating the number of representable states, I made some assumptions
    in the last section. I limited the number of values that were possible, but that’s
    a bit of a cheat, isn’t it? As I said before, there is almost an infinite number
    of values possible. Fortunately, there is a way to limit the values through Python:
    `Literals`. `Literal` types allow you to restrict the variable to a very specific
    set of values.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算可表示状态的数量时，我在上一节中做了一些假设。我限制了可能的值的数量，但这有点作弊，不是吗？正如我之前所说的，可能的值几乎是无限的。幸运的是，有一种方法可以通过Python限制这些值：`Literals`。`Literal`类型允许您将变量限制为非常特定的值集。
- en: 'I’ll change my earlier `Snack` class to employ `Literal` values:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'I’ll change my earlier `Snack` class to employ `Literal` values:'
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, if I try to instantiate these data classes with wrong values:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 'Now, if I try to instantiate these data classes with wrong values:'
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'I receive the following typechecker errors:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 'I receive the following typechecker errors:'
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`Literals` were introduced in Python 3.8, and they are an invaluable way of
    restricting possible values of a variable. They are a little more lightweight
    than Python enumerations (which I’ll cover in [Chapter 8](part0012_split_000.html#enum)).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Literals` were introduced in Python 3.8, and they are an invaluable way of
    restricting possible values of a variable. They are a little more lightweight
    than Python enumerations (which I’ll cover in [Chapter 8](part0012_split_000.html#enum)).'
- en: Annotated Types
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Annotated Types
- en: What if I wanted to get even deeper and specify more complex constraints? It
    would be tedious to write hundreds of literals, and some constraints aren’t able
    to be modeled by `Literal` types. There’s no way with a `Literal` to constrain
    a string to a certain size or to match a specific regular expression. This is
    where `Annotated` comes in. With `Annotated`, you can specify arbitrary metadata
    alongside your type annotation.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: What if I wanted to get even deeper and specify more complex constraints? It
    would be tedious to write hundreds of literals, and some constraints aren’t able
    to be modeled by `Literal` types. There’s no way with a `Literal` to constrain
    a string to a certain size or to match a specific regular expression. This is
    where `Annotated` comes in. With `Annotated`, you can specify arbitrary metadata
    alongside your type annotation.
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Unfortunately, the above code will not run, as `ValueRange` and `MatchesRegex`
    are not built-in types; they are arbitrary expressions. You will need to write
    your own metadata as part of an `Annotated` variable. Secondly, there are no tools
    that will typecheck this for you. The best you can do until such a tool exists
    is write dummy annotations or use strings to describe your constraints. At this
    point, `Annotated` is best served as a communication method.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Unfortunately, the above code will not run, as `ValueRange` and `MatchesRegex`
    are not built-in types; they are arbitrary expressions. You will need to write
    your own metadata as part of an `Annotated` variable. Secondly, there are no tools
    that will typecheck this for you. The best you can do until such a tool exists
    is write dummy annotations or use strings to describe your constraints. At this
    point, `Annotated` is best served as a communication method.
- en: NewType
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NewType
- en: 'While waiting for tooling to support `Annotated`, there is another way to represent
    more complicated constraints: `NewType`. `NewType` allows you to, well, create
    a new type.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 'While waiting for tooling to support `Annotated`, there is another way to represent
    more complicated constraints: `NewType`. `NewType` allows you to, well, create
    a new type.'
- en: 'Suppose I want to separate my hot dog stand code to handle two separate cases:
    a hot dog in its unservable form (no plate, no napkins) and a hot dog that is
    ready to serve (plated, with napkins). In my code, there exist some functions
    that should only be operating on the hot dog in one case or the other. For example,
    an unservable hot dog should never be dispensed to the customer.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 'Suppose I want to separate my hot dog stand code to handle two separate cases:
    a hot dog in its unservable form (no plate, no napkins) and a hot dog that is
    ready to serve (plated, with napkins). In my code, there exist some functions
    that should only be operating on the hot dog in one case or the other. For example,
    an unservable hot dog should never be dispensed to the customer.'
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: However, nothing prevents someone from passing in an unservable hot dog. If
    a developer makes a mistake and passes an unservable hot dog to this function,
    customers will be quite surprised to see just their order with no plate or napkins
    come out of the machine.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: However, nothing prevents someone from passing in an unservable hot dog. If
    a developer makes a mistake and passes an unservable hot dog to this function,
    customers will be quite surprised to see just their order with no plate or napkins
    come out of the machine.
- en: 'Rather than relying on developers to catch these errors whenever they happen,
    you need a way for your typechecker to catch this. To do that, you can use `NewType`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'Rather than relying on developers to catch these errors whenever they happen,
    you need a way for your typechecker to catch this. To do that, you can use `NewType`:'
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A `NewType` takes an existing type and creates a brand new type that has all
    the same fields and methods as the existing type. In this case, I am creating
    a type `ReadyToServeHotDog` that is distinct from `HotDog`; they are not interchangeable.
    What’s beautiful about this is that this type restricts implicit type conversions.
    You cannot use a `HotDog` anywhere you are expecting a `ReadyToServeHotDog` (you
    can use a `ReadyToServeHotDog` in place of `HotDog`, though). In the previous
    example, I am restricting `dispense_to_customer` to only take `ReadyToServeHotDog`
    values as an argument. This prevents developers from invalidating assumptions.
    If a developer were to pass a `HotDog` to this method, the typechecker will yell
    at them:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewType`接受现有类型并创建一个全新的类型，该类型具有与现有类型相同的所有字段和方法。在本例中，我正在创建一个名为`ReadyToServeHotDog`的类型，它与`HotDog`不同；它们不可互换。这种美妙之处在于，该类型限制了隐式类型转换。你不能在需要`ReadyToServeHotDog`的任何地方使用`HotDog`（尽管你可以用`ReadyToServeHotDog`替换`HotDog`）。在前面的例子中，我正在限制`dispense_to_customer`仅接受`ReadyToServeHotDog`值作为参数。这可以防止开发者无意间使假设失效。如果开发者试图向该方法传递一个`HotDog`，类型检查器会警告他们：'
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It is important to stress the one-way nature of this type conversion. As a developer,
    you can control when your old type becomes your new type.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 强调这种类型转换的单向性是很重要的。作为开发者，你可以控制旧类型何时成为新类型。
- en: 'For example, I’ll create a function that takes a unservable `HotDog` and makes
    it ready to serve:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我将创建一个函数，它接受一个无法服务的`HotDog`并使其准备好服务：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice how I’m explicitly returning a `ReadyToServeHotDog` instead of a normal
    `HotDog`. This acts as a “blessed” function; it is the only sanctioned way that
    I want developers to create a `ReadyToServeHotDog`. Any user trying to use a method
    that takes a `ReadyToServeHotDog` needs to create it using `prepare_for_serving`
    first.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我如何明确地返回一个`ReadyToServeHotDog`而不是普通的`HotDog`。这充当了一个“被认可”的函数；这是我希望开发者创建`ReadyToServeHotDog`的唯一合法方式。任何试图使用接受`ReadyToServeHotDog`的方法的用户都需要首先使用`prepare_for_serving`来创建它。
- en: It is important to notify users that the only way to create your new type is
    through a set of “blessed” functions. You don’t want users creating your new type
    in any circumstance other than a predetermined method, as that defeats the purpose.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要通知用户，创建你的新类型的唯一方法是通过一组“被认可”的函数。你不希望用户在任何情况下都创建你的新类型，因为那样会失去意义。
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Unfortunately, Python has no great way of telling users this, other than a comment.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Python 没有很好的方式来告诉用户这一点，除了通过注释。
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Still, `NewType` is applicable to many real-world scenarios. For example, these
    are all scenarios that I’ve run into that a `NewType` would solve:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 依然，`NewType`适用于许多现实世界的场景。例如，以下是我遇到过的`NewType`可以解决的所有场景：
- en: Separating a `str` from a `SanitizedString`, to catch bugs like SQL injection
    vulnerabilities. By making `SanitizedString` a `NewType`, I made sure that only
    properly sanitized strings were operated upon, eliminating the chance of SQL injection.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`str`与`SanitizedString`分离，以捕捉诸如 SQL 注入漏洞之类的错误。通过将`SanitizedString`设为`NewType`，我确保只有经过适当处理的字符串才能进行操作，消除了
    SQL 注入的可能性。
- en: Tracking a `User` object and `LoggedInUser` separately. By restricting `Users`
    with `NewType` from `LoggedInUser`, I wrote functions that were only applicable
    to users that were logged in.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分别跟踪`User`对象和`LoggedInUser`。通过将`Users`限制为`NewType`，我编写了仅适用于已登录用户的函数。
- en: Tracking an integer that should represent a valid User ID. By restricting the
    User ID to a `NewType`, I could make sure that some functions were only operating
    on IDs that were valid, without having to check `if` statements.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 追踪一个应该代表有效用户 ID 的整数。通过将用户 ID 限制为`NewType`，我可以确保某些函数只操作有效的 ID，而无需检查`if`语句。
- en: In [Chapter 10](part0014_split_000.html#classes), you’ll see how you can use
    classes and invariants to do something very similar, with a much stronger guarantee
    of avoiding illegal states. However, `NewType` is still a useful pattern to be
    aware of, and is much more lightweight than a full-blown class.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 10 章](part0014_split_000.html#classes)中，你将看到如何使用类和不变量做类似的事情，以更强的保证避免非法状态。然而，`NewType`仍然是一个值得关注的有用模式，比起完整的类要轻便得多。
- en: Final Types
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终类型
- en: Finally (pun intended), you may want to restrict a type from changing its value.
    That’s where `Final` comes in. `Final`, introduced in Python 3.8, indicates to
    a typechecker that a variable cannot be bound to another value. For instance,
    I want to start franchising out my hot dog stand, but I don’t want the name to
    be changed by accident.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后（意在说笑），你可能想要限制类型不要改变其值。这就是`Final`的用武之地。`Final`在Python 3.8中引入，指示类型检查器变量不能绑定到另一个值。例如，我想开始特许经营我的热狗摊，但我不希望名称因错误而改变。
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If a developer accidentally changed the name later on, they would see an error.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发者不小心之后改变了名称，他们会看到一个错误。
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In general, `Final` is best used when the variable’s scope spans a large amount
    of code, such as a module. It is difficult for developers to keep track of all
    the uses of a variable in such large scopes; letting the typechecker catch immutability
    guarantees is a boon in these cases.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，`Final` 最好在变量的范围跨度较大时使用，比如一个模块。在这些情况下，让类型检查器捕获不可变性保证是一个福音，因为开发者很难跟踪变量在这些大范围内的所有用途。
- en: Warning
  id: totrans-156
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: '`Final` will not error out when mutating an object through a function. It only
    prevents the variable from being rebound (set to a new value).'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`Final` 在通过函数改变对象时不会出错。它只是防止变量被重新绑定（设置为新值）。'
- en: Closing Thoughts
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结思考
- en: You’ve learned about many different ways to constrain your types in this chapter.
    All of them serve a specific purpose, from handling `None` with `Optional` to
    restricting to specific values with `Literal` to preventing a variable from being
    rebound with `Final`. By using these techniques, you’ll be able to encode assumptions
    and restrictions directly into your codebase, preventing future readers from needing
    to guess about your logic. Typecheckers will use these advanced type annotations
    to provide you with stricter guarantees about your code, which will give maintainers
    confidence when working in your codebase. With this confidence, they will make
    fewer mistakes, and your codebase will become more robust because of it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学到了许多约束类型的不同方法。它们每一个都有特定的目的，从使用`Optional`处理`None`到使用`Literal`限制特定值，再到使用`Final`防止变量重新绑定。通过使用这些技术，你可以直接将假设和限制编码到你的代码库中，避免未来的读者猜测你的逻辑。类型检查器将使用这些高级类型注释为你提供更严格的代码保证，这将使维护者在处理你的代码库时更加自信。有了这种信心，他们会犯更少的错误，你的代码库也因此变得更加健壮。
- en: In the next chapter, you’ll move on from type annotating single values, and
    learn how to properly annotate collection types. Collection types pervade most
    of Python; you must take care to express your intentions for them as well. You
    need to be well-versed in all the ways you can represent a collection, including
    in cases where you must create your own.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将继续从为单个值添加类型注释，学习如何正确为集合类型添加注释。集合类型在大多数Python中无处不在；你必须小心地表达你的意图。你需要精通所有可以表示集合的方式，包括必须自己创建的情况。
- en: '^([1](part0007_split_001.html#idm45644755819000-marker)) C.A.R. Hoare. “Null
    References: The Billion Dollar Mistake.” *Historically Bad Ideas*. Presented at
    Qcon London 2009, n.d.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](part0007_split_001.html#idm45644755819000-marker)) C.A.R. Hoare. “空引用：十亿美元的错误。”
    *历史上的糟糕想法*。2009年在Qcon London上展示，无日期。
