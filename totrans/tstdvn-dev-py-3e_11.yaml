- en: Chapter 7\. Working Incrementally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let’s address our real problem, which is that our design only allows for
    one global list. In this chapter I’ll demonstrate a critical TDD technique: how
    to adapt existing code using an incremental, step-by-step process which takes
    you from working state to working state. Testing Goat, not Refactoring Cat.'
  prefs: []
  type: TYPE_NORMAL
- en: Small Design When Necessary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s have a think about how we want support for multiple lists to work.
  prefs: []
  type: TYPE_NORMAL
- en: At the moment the only URL for our site is the homepage, and that’s why there’s
    only one global list. The most obvious way to support multiple lists is to say
    that each list gets its own URL, so that people can start multiple lists, or so
    that different people can have different lists. How might that work?
  prefs: []
  type: TYPE_NORMAL
- en: Not Big Design Up Front
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TDD is closely associated with the agile movement in software development, which
    includes a reaction against *Big Design Up Front*, the traditional software engineering
    practice whereby, after a lengthy requirements gathering exercise, there is an
    equally lengthy design stage where the software is planned out on paper. The agile
    philosophy is that you learn more from solving problems in practice than in theory,
    especially when you confront your application with real users as soon as possible.
    Instead of a long up-front design phase, we try to put a *minimum viable application*
    out there early, and let the design evolve gradually based on feedback from real-world
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'But that doesn’t mean that thinking about design is outright banned! In the
    last big chapter we saw how just blundering ahead without thinking can *eventually*
    get us to the right answer, but often a little thinking about design can help
    us get there faster. So, let’s think about our minimum viable lists app, and what
    kind of design we’ll need to deliver it:'
  prefs: []
  type: TYPE_NORMAL
- en: We want each user to be able to store their own list—​at least one, for now.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list is made up of several items, whose primary attribute is a bit of descriptive
    text.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to save lists from one visit to the next. For now, we can give each
    user a unique URL for their list. Later on we may want some way of automatically
    recognising users and showing them their lists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To deliver the “for now” items, it sounds like we’re going to store lists and
    their items in a database. Each list will have a unique URL, and each list item
    will be a bit of descriptive text, associated with a particular list.
  prefs: []
  type: TYPE_NORMAL
- en: YAGNI!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you start thinking about design, it can be hard to stop. All sorts of
    other thoughts are occurring to us—​we might want to give each list a name or
    title, we might want to recognise users using usernames and passwords, we might
    want to add a longer notes field as well as short descriptions to our list, we
    might want to store some kind of ordering, and so on. But we obey another tenet
    of the agile gospel: “YAGNI” (pronounced yag-knee), which stands for “You ain’t
    gonna need it!” As software developers, we have fun creating things, and sometimes
    it’s hard to resist the urge to build things just because an idea occurred to
    us and we *might* need it. The trouble is that more often than not, no matter
    how cool the idea was, you *won’t* end up using it. Instead you have a load of
    unused code, adding to the complexity of your application. YAGNI is the mantra
    we use to resist our overenthusiastic creative urges.'
  prefs: []
  type: TYPE_NORMAL
- en: REST (ish)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have an idea of the data structure we want—​the Model part of Model-View-Controller
    (MVC). What about the View and Controller parts? How should the user interact
    with `List`s and their `Item`s using a web browser?
  prefs: []
  type: TYPE_NORMAL
- en: Representational State Transfer (REST) is an approach to web design that’s usually
    used to guide the design of web-based APIs. When designing a user-facing site,
    it’s not possible to stick *strictly* to the REST rules, but they still provide
    some useful inspiration (skip ahead to [Link to Come] if you want to see a real
    REST API).
  prefs: []
  type: TYPE_NORMAL
- en: 'REST suggests that we have a URL structure that matches our data structure,
    in this case lists and list items. Each list can have its own URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That will fulfill the requirement we’ve specified in our FT. To view a list,
    we use a GET request (a normal browser visit to the page).
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a brand new list, we’ll have a special URL that accepts POST requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a new item to an existing list, we’ll have a separate URL, to which
    we can send POST requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: (Again, we’re not trying to perfectly follow the rules of REST, which would
    use a PUT request here—​we’re just using REST for inspiration. Apart from anything
    else, you can’t use PUT in a standard HTML form.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, our scratchpad for this chapter looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the New Design Incrementally Using TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do we use TDD to implement the new design? Let’s take another look at the
    flowchart for the TDD process in [Link to Come].
  prefs: []
  type: TYPE_NORMAL
- en: At the top level, we’re going to use a combination of adding new functionality
    (by adding a new FT and writing new application code), and refactoring our application—​that
    is, rewriting some of the existing implementation so that it delivers the same
    functionality to the user but using aspects of our new design. We’ll be able to
    use the existing functional test to verify we don’t break what already works,
    and the new functional test to drive the new features.
  prefs: []
  type: TYPE_NORMAL
- en: At the unit test level, we’ll be adding new tests or modifying existing ones
    to test for the changes we want, and we’ll be able to similarly use the unit tests
    we *don’t* touch to help make sure we don’t break anything in the process.
  prefs: []
  type: TYPE_NORMAL
- en: '![An inner red/green/refactor loop surrounded by an outer red/green of FTs](assets/double-loop-tdd-simpler.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. The TDD Process With Both Functional and Unit Tests
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Ensuring We Have a Regression Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s translate our scratchpad into a new functional test method, which introduces
    a second user and checks that their to-do list is separate from Edith’s.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start out very similarly to the first. Edith adds a first item to create
    a to-do list, but we introduce our first new assertion—Edith’s list should live
    at its own, unique URL:'
  prefs: []
  type: TYPE_NORMAL
- en: functional_tests/tests.py (ch07l005)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_working_incrementally_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`assertRegex` is a helper function from `unittest` that checks whether a string
    matches a regular expression. We use it to check that our new REST-ish design
    has been implemented. Find out more in the [`unittest` documentation](http://docs.python.org/3/library/unittest.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we imagine a new user coming along. We want to check that they don’t see
    any of Edith’s items when they visit the home page, and that they get their own
    unique URL for their list:'
  prefs: []
  type: TYPE_NORMAL
- en: functional_tests/tests.py (ch07l006)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_working_incrementally_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: I’m using the convention of double-hashes (`##`) to indicate “meta-comments”—comments
    about *how* the test is working and why—​so that we can distinguish them from
    regular comments in FTs which explain the User Story. They’re a message to our
    future selves, which might otherwise be wondering why we’re faffing about deleting
    cookies…​
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than that, the new test is fairly self-explanatory. Let’s see how we
    do when we run our FTs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Good, our first test still passes, and the second one fails where we might
    expect. Let’s do a commit, and then go and build some new models and views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Iterating Towards the New Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being all excited about our new design, I had an overwhelming urge to dive in
    at this point and start changing *models.py*, which would have broken half the
    unit tests, and then pile in and change almost every single line of code, all
    in one go. That’s a natural urge, and TDD, as a discipline, is a constant fight
    against it. Obey the Testing Goat, not Refactoring Cat! We don’t need to implement
    our new, shiny design in a single big bang. Let’s make small changes that take
    us from a working state to a working state, with our design guiding us gently
    at each stage.
  prefs: []
  type: TYPE_NORMAL
- en: There are four items on our to-do list. The FT, with its `Regex didn't match`
    error, is suggesting to us that the second item—​giving lists their own URL and
    identifier—​is the one we should work on next. Let’s have a go at fixing that,
    and only that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The URL comes from the redirect after POST. In *lists/tests.py*, let’s find
    `test_redirects_after_POST`, and change the expected redirect location:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/tests.py (ch07l007)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Does that seem slightly strange? Clearly, */lists/the-only-list-in-the-world*
    isn’t a URL that’s going to feature in the final design of our application. But
    we’re committed to changing one thing at a time. While our application only supports
    one list, this is the only URL that makes sense. We’re still moving forwards,
    in that we’ll have a different URL for our list and our home page, which is a
    step along the way to a more REST-ful design. Later, when we have multiple lists,
    it will be easy to change.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Another way of thinking about it is as a problem-solving technique: our new
    URL design is currently not implemented, so it works for 0 items. Ultimately,
    we want to solve for *n* items, but solving for 1 item is a good step along the
    way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the unit tests gives us an expected fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can go adjust our `home_page` view in *lists/views.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/views.py (ch07l008)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Django’s unit test runner picks up on the fact that this is not a real URL
    yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Taking a First, Self-Contained Step: One New URL'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our singleton list URL doesn’t exist yet. We fix that in *superlists/urls.py*.
  prefs: []
  type: TYPE_NORMAL
- en: superlists/urls.py (ch07l009)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_working_incrementally_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll just point our new URL at the existing home page view. This is the minimimal
    change.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Watch out for trailing slashes in URLs, both here in *urls.py* and in the tests.
    They’re a common source of bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'That gets our unit tests passing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: What do the FTs think?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Good, they get a little further along, we now confirm that we have a new URL,
    but the actual page content is still the same, it shows the old list.
  prefs: []
  type: TYPE_NORMAL
- en: Separating out our home page and list view functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now have two URLs, but they’re actually doing the exact same thing. Under
    the hood, they’re just pointing at the same function. Continuing to work incrementally,
    we can start to break apart the responsibilities for these two different URLs:
    * the home page only needs to display and react to creating a brand new list based
    on its first item. * the list view page needs to be able to display existing list
    items and add new items to the list'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s split out some tests for our new URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up *lists/tests.py*, and add a new test class called `ListViewTest`. Then
    move the method called `test_displays_all_list_items` across from `HomePageTest`
    into our new class, changing just the URL that is invoked by `self.client.get()`:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/tests.py (ch07l010)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try running this test now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It passes, because the URL is still pointing at the home_page view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make it point at a new view:'
  prefs: []
  type: TYPE_NORMAL
- en: superlists/urls.py (ch07l011)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'That predictably fails because there is no such view function yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: A New View Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Fair enough. Let’s create a dummy view function in *lists/views.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/views.py (ch07l012-0)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Not quite good enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking for the minimal code change, let’s just make the view return our existing
    *home.xhtml* template, but with nothing in it:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/views.py (ch07l012-1)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the tests guide us to making sure that our list view shows existing list
    items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'So let’s copy the last two lines from `home_page` more directly:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/views.py (ch07l012)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: That gets us to passing unit tests!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The FTs detect a regression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As always when we get to passing unit tests, we run the functional tests to
    check how things are doing “in real life”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Not only is our new test failing, but the old one is too. That tells us we’ve
    introduced a *regression*.
  prefs: []
  type: TYPE_NORMAL
- en: What are they trying to tell us?
  prefs: []
  type: TYPE_NORMAL
- en: 'Both tests are failing when we try to add the second item. We have to put our
    debugging hats on here. We know the home page is working, because the test has
    got all the way down to line 63 in the first FT, so we’ve at least added a first
    item. And our unit tests are all passing, so we’re pretty sure the URLs and views
    that we *do* have are doing what they should. Let’s have a quick look at those
    unit tests to see what they tell us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The home page displays the right template, and can handle POST requests, and
    the */only-list-in-the-world/* view knows how to display all items…​ but it doesn’t
    know how to handle POST requests. Ah, that gives us a clue.
  prefs: []
  type: TYPE_NORMAL
- en: A second clue is the rule of thumb that, when all the unit tests are passing
    but the functional tests aren’t, it’s often pointing at a problem that’s not covered
    by the unit tests, and in our case, that’s often a template problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is that our *home.xhtml* input form currently doesn’t specify an
    explicit URL to POST to:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/templates/home.xhtml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: By default the browser sends the POST data back to the same URL it’s currently
    on. When we’re on the home page that works fine, but when we’re on our */only-list-in-the-world/*
    page, it doesn’t.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Back to a Working State as Quickly as Possible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we could dive in and add POST request handling to our new view, but that
    would involve writing a bunch more tests and code, and at this point we’d like
    to get back to a working state as quickly as possible. Actually the *quickest*
    thing we can do to get things fixed is to just use the existing home page view,
    which already works, for all POST requests:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/templates/home.xhtml (ch07l013)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Try that, and we’ll see our FTs get back to a happier place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Our regression test passes once again, so we know we’re back to a working state.
    The new functionality may not be working yet, but at least the old stuff works
    as well as it used to.
  prefs: []
  type: TYPE_NORMAL
- en: Green? Refactor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Time for a little tidying up.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Red/Green/Refactor* dance, we’ve arrived at green, so we should see
    what needs a refactor. We now have two views, one for the home page, and one for
    an individual list. Both are currently using the same template, and passing it
    all the list items currently in the database. Post requests are only handled by
    the home page though.
  prefs: []
  type: TYPE_NORMAL
- en: It feels like the responsibilities of our two views are a little tangled up.
    Let’s try and disentangle them a little.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another Small Step: A Separate Template for Viewing Lists'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the home page and the list view are now quite distinct pages, they should
    be using different HTML templates; *home.xhtml* can have the single input box,
    whereas a new template, *list.xhtml*, can take care of showing the table of existing
    items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a new test to check that it’s using a different template:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/tests.py (ch07l014)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see what it says:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Looks about right, let’s change the view:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/views.py (ch07l015)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'But, obviously, that template doesn’t exist yet. If we run the unit tests,
    we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s create a new file at *lists/templates/list.xhtml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'A blank template, which gives us this error—​good to know the tests are there
    to make sure we fill it in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The template for an individual list will reuse quite a lot of the stuff we
    currently have in *home.xhtml*, so we can start by just copying that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: That gets the tests back to passing (green).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s do a little more tidying up (refactoring). We said the home page
    doesn’t need to list items, it only needs the new list input field, so we can
    remove some lines from *lists/templates/home.xhtml*, and maybe slightly tweak
    the `h1` to say “Start a new To-Do list”:'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll present the code change as a diff, which hopefully shows a bit more clearly
    what we need to modify:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/templates/home.xhtml (ch07l018)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We rerun the unit tests to check that hasn’t broken anything…​
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Good.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now there’s actually no need to pass all the items to the *home.xhtml* template
    in our `home_page` view, so we can simplify that and delete a couple of lines:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/views.py (ch07l019)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Rerun the unit tests once more; they still pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Time to run the functional tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Not bad! Our regression test (the first FT) is passing, and our new test is
    now getting slightly further forwards—​it’s telling us that Francis isn’t getting
    his own list page (because he still sees some of Edith’s list items).
  prefs: []
  type: TYPE_NORMAL
- en: 'It may feel like we haven’t made much headway since, functionally, the site
    still behaves almost exactly like it did when we started the chapter, but this
    really is progress. We’ve started on the road to our new design, and we’ve implemented
    a number of stepping stones *without making anything worse than it was before*.
    Let’s commit our progress so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'A Third Small Step: A New URL for Adding List Items'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Where are we with our own to-do list?
  prefs: []
  type: TYPE_NORMAL
- en: We’ve *sort of* made progress on the second item, even if there’s still only
    one list in the world. The first item is a bit scary. Can we do something about
    items 3 or 4?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a new URL for adding new list items at */lists/new*: If nothing
    else, it’ll simplify the home page view.'
  prefs: []
  type: TYPE_NORMAL
- en: A Test Class for New List Creation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open up *lists/tests.py*, and *move* the `test_can_save_a_POST_request` and
    `test_redirects_after_POST` methods into a new class, then change the URL they
    POST to:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/tests.py (ch07l020)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is another place to pay attention to trailing slashes, incidentally. It’s
    `/lists/new`, with no trailing slash. The convention I’m using is that URLs without
    a trailing slash are “action” URLs which modify the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try running that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The first failure tells us we’re not saving a new item to the database, and
    the second says that, instead of returning a 302 redirect, our view is returning
    a 404. That’s because we haven’t built a URL for */lists/new*, so the `client.post`
    is just getting a “not found” response.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Do you remember how we split this out into two tests earlier? If we only had
    one test that checked both the saving and the redirect, it would have failed on
    the `0 != 1` failure, which would have been much harder to debug. Ask me how I
    know this.
  prefs: []
  type: TYPE_NORMAL
- en: A URL and View for New List Creation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s build our new URL now:'
  prefs: []
  type: TYPE_NORMAL
- en: superlists/urls.py (ch07l021)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we get a `no attribute ''new_list''`, so let’s fix that, in *lists/views.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/views.py (ch07l022)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we get “The view lists.views.new_list didn’t return an HttpResponse object”.
    (This is getting rather familiar!) We could return a raw `HttpResponse`, but since
    we know we’ll need a redirect, let’s borrow a line from `home_page`:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/views.py (ch07l023)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'That gives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Seems reasonably straightforward. We borrow another line from `home_page`:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/views.py (ch07l024)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'And everything now passes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can run the FTs to check that we’re still in the same place: our regression
    test passes, and the new FT gets to the same point.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Removing Now-Redundant Code and Tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re looking good. Since our new views are now doing most of the work that
    `home_page` used to do, we should be able to massively simplify it. Can we remove
    the whole `if request.method == 'POST'` section, for example?
  prefs: []
  type: TYPE_NORMAL
- en: lists/views.py (ch07l025)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Yep!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: And while we’re at it, we can remove the now-redundant `test_only_saves_​items_when_necessary`
    test too!
  prefs: []
  type: TYPE_NORMAL
- en: Doesn’t that feel good? The view functions are looking much simpler. We rerun
    the tests to make sure…​
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: and the FTs?
  prefs: []
  type: TYPE_NORMAL
- en: A Regression! Pointing Our Forms at the New URL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Oops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Once again, the FTs pick up a tricky little bug, something that our unit tests
    alone would find it hard to catch.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s because our forms are still pointing to the old URL. In *both* *home.xhtml*
    and *lists.xhtml*, let’s change them to:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/templates/home.xhtml, lists/templates/list.xhtml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'And that should get us back to working again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: That’s another nicely self-contained commit, in that we’ve made a bunch of changes
    to our URLs, our *views.py* is looking much neater and tidier, and we’re sure
    the application is still working as well as it did before. We’re getting good
    at this working-state-to-working-state malarkey!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can cross out an item on the to-do list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Biting the Bullet: Adjusting Our Models'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enough housekeeping with our URLs. It’s time to bite the bullet and change
    our models. Let’s adjust the model unit test. Again, a diff is a good way to see
    the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/tests.py (ch07l029)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We create a new `List` object and then we assign each item to it by assigning
    it as its `.list` property. We check that the list is properly saved, and we check
    that the two items have also saved their relationship to the list. You’ll also
    notice that we can compare list objects with each other directly (`saved_list`
    and `mylist`)—behind the scenes, these will compare themselves by checking that
    their primary key (the `.id` attribute) is the same.
  prefs: []
  type: TYPE_NORMAL
- en: Time for another unit-test/code cycle.
  prefs: []
  type: TYPE_NORMAL
- en: For the first couple of iterations, rather than explicitly showing you what
    code to enter in between every test run, I’m only going to show you the expected
    error messages from running the tests. I’ll let you figure out what each minimal
    code change should be, on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Need a hint? Go back and take a look at the steps we took to introduce the `Item`
    model in [the chapter before last](ch05.xhtml#first-django-model).
  prefs: []
  type: TYPE_NORMAL
- en: 'Your first error should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Fix that, and then you should see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Next you should see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'So we run a `makemigrations`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'And then you should see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: A Foreign Key Relationship
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How do we give our `Item` a list attribute? Let’s just try naively making it
    like the `text` attribute (and here’s your chance to see whether your solution
    so far looks like mine by the way):'
  prefs: []
  type: TYPE_NORMAL
- en: lists/models.py (ch07l033)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, the tests tell us we need a migration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see what that gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re not quite there. Look closely at each side of the `!=`. Do you see the
    quotes `''`? Django has only saved the string representation of the `List` object.
    To save the relationship to the object itself, we tell Django about the relationship
    between the two classes using a `ForeignKey`:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/models.py (ch07l035)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'That’ll need a migration too. Since the last one was a red herring, let’s delete
    it and replace it with a new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Deleting migrations is dangerous. Now and again it’s nice to do it to keep things
    tidy, because we don’t always get our models code right on the first go! But if
    you delete a migration that’s already been applied to a database somewhere, Django
    will be confused about what state it’s in, and won’t be able to apply future migrations.
    You should only do it when you’re sure the migration hasn’t been used. A good
    rule of thumb is that you should never delete or modify a migration that’s already
    been committed to your VCS.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the Rest of the World to Our New Models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back in our tests, now what happens?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Oh dear!
  prefs: []
  type: TYPE_NORMAL
- en: There is some good news. Although it’s hard to see, our model tests are passing.
    But three of our view tests are failing nastily.
  prefs: []
  type: TYPE_NORMAL
- en: The cause is the new relationship we’ve introduced between `Item`s and `List`s,
    which requires each item to have a parent list, and which our old tests and code
    aren’t prepared for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still, this is exactly why we have tests! Let’s get them working again. The
    easiest is the `ListViewTest`; we just create a parent list for our two test items:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/tests.py (ch07l038)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'That gets us down to two failing tests, both on tests that try to POST to our
    `new_list` view. Decoding the tracebacks using our usual technique, working back
    from error to line of test code to, buried in there somewhere, the line of our
    own code that caused the failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s when we try to create an item without a parent list. So we make a similar
    change in the view:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/views.py (ch07l039)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'And that^([1](ch07.xhtml#id427)) gets our tests passing again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Are you cringing internally at this point? *Arg! This feels so wrong; we create
    a new list for every single new item submission, and we’re still just displaying
    all items as if they belong to the same list!* I know, I feel the same. The step-by-step
    approach, in which you go from working code to working code, is counterintuitive.
    I always feel like just diving in and trying to fix everything all in one go,
    instead of going from one weird half-finished state to another. But remember the
    Testing Goat! When you’re up a mountain, you want to think very carefully about
    where you put each foot, and take one step at a time, checking at each stage that
    the place you’ve put it hasn’t caused you to fall off a cliff.
  prefs: []
  type: TYPE_NORMAL
- en: 'So just to reassure ourselves that things have worked, we rerun the FT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Sure enough, it gets all the way through to where we were before. We haven’t
    broken anything, and we’ve made a big change to the database. That’s something
    to be pleased with! Let’s commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can cross out another item on the to-do list:'
  prefs: []
  type: TYPE_NORMAL
- en: Each List Should Have Its Own URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can get rid of the silly `the-only-list-in-the-world` url, but what shall
    we use as the unique identifier for our lists? Probably the simplest thing, for
    now, is just to use the auto-generated `id` field from the database. Let’s change
    `ListViewTest` so that the two tests point at new URLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll also change the old `test_displays_all_items` test and call it `test_displays_only_items_for_that_list`
    instead, making it check that only the items for a specific list are displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/tests.py (ch07l040)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Are you wondering about the line spacing in the test? I’m grouping together
    two lines at the beginning which set up the test, one line in the middle which
    actually calls the code under test, and the assertions at the end. This isn’t
    obligatory, but it does help see the structure of the test. Some people refer
    to this structure as *Arrange-Act-Assert*, or *Given-When-Then*: *Given* the database
    contains our list with two items, and another list, *When* I do a GET request
    for our list, *Then* I see the items in our list, but not the items in the other
    list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the unit tests gives an expected 404, and another related error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Capturing Parameters from URLs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s time to learn how we can pass parameters from URLs to views:'
  prefs: []
  type: TYPE_NORMAL
- en: superlists/urls.py (ch07l041-0)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: We adjust the regular expression for our URL to include a *capture group*, `<int:list_id>`,
    which will match any numerical characters, up to the following `/`, The captured
    id will get passed to the view as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, if we go to the URL */lists/1/*, `view_list` will get a second
    argument after the normal `request` argument, namely the integer `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But our view doesn’t expect an argument yet! Sure enough, this causes problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We can fix that easily with a dummy parameter in *views.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/views.py (ch07l041)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: That takes us down to our expected failure, plus an *only-list-in-the-world*
    that’s still hanging around somewhere, which I’m sure we can fix later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s make our list view discriminate over which items it sends to the template:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/views.py (ch07l042)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Adjusting new_list to the New World
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s address the *only-list-in-the-world* failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s have a little look and find the test that’s moaning:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/tests.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: It looks like it hasn’t been adjusted to the new world of `List`s and `Item`s.
    The test should be saying that this view redirects to the URL of the specific
    new list it just created.
  prefs: []
  type: TYPE_NORMAL
- en: lists/tests.py (ch07l043)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The test still fails, but we can now take a look at the view itself, and change
    it so it redirects to the right place:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/views.py (ch07l044)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'That gets us back to passing unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: What about the functional tests? We must be almost there?
  prefs: []
  type: TYPE_NORMAL
- en: The Functional Tests Detect Another Regression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Well, almost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Our *new* FT is actually passing: different users can get different lists.
    But the old test is warning us of a regression. It looks like you can’t add a
    second item to a list any more. It’s because of our quick-and-dirty hack where
    we create a new list for every single POST submission. This is exactly what we
    have functional tests for!'
  prefs: []
  type: TYPE_NORMAL
- en: 'And it correlates nicely with the last item on our to-do list:'
  prefs: []
  type: TYPE_NORMAL
- en: One More View to Handle Adding Items to an Existing List
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need a URL and view to handle adding a new item to an existing list (*/lists/<list_id>/add_item*).
    We’re getting pretty good at these now, so let’s knock one together quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/tests.py (ch07l045)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Are you wondering about `other_list`? A bit like in the tests for viewing a
    specific list, it’s important that we add items to a specific list. Adding this
    second object to the database prevents me from using a hack like `List.objects.first()`
    in the implementation. Yes, that would be a stupid thing to do, and you can go
    too far down the road of testing for all the stupid things you must not do (there
    are an infinite number of those, after all). It’s a judgement call, but this one
    feels worth it. There’s some more discussion of this in [Link to Come].
  prefs: []
  type: TYPE_NORMAL
- en: 'So that fails as expected, the list item is not saved, and the new URL currently
    returns a 404:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The Last New URL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we’ve got our expected 404, let’s add a new URL for adding new items to
    existing lists:'
  prefs: []
  type: TYPE_NORMAL
- en: superlists/urls.py (ch07l046)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Three very similar-looking URLs there. Let’s make a note on our to-do list;
    they look like good candidates for a refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to the tests, we get the usual missing module view objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The Last New View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s try:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/views.py (ch07l047)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Aha:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: lists/views.py (ch07l048)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'And then:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'We can copy the `redirect()` from `new_list` and the `List.objects.get()` from
    `view_list`:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/views.py (ch07l049)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'That takes us to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally we make it save our new list item:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/views.py (ch07l050)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: And we’re back to passing tests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Testing Template Context Directly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve got our new view and URL for adding items to existing lists; now we just
    need to actually use it in our *list.xhtml* template. So we open it up to adjust
    the form tag…​
  prefs: []
  type: TYPE_NORMAL
- en: lists/templates/list.xhtml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: …​oh. To get the URL for adding to the current list, the template needs to know
    what list it’s rendering, as well as what the items are.
  prefs: []
  type: TYPE_NORMAL
- en: 'We *want* to be able to do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/templates/list.xhtml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'For that to work, the view will have to pass the list to the template. Let’s
    create a new unit test in `ListViewTest`:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/tests.py (ch07l051)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_working_incrementally_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`response.context` represents the context we’re going to pass into the render
    function—​the Django Test Client puts it on the `response` object for us, to help
    with testing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'because we’re not passing `list` into the template. It actually gives us an
    opportunity to simplify a little:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/views.py (ch07l052)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'That, of course, introduces a bug, because the template needed `items`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'But we can fix it in *list.xhtml*, as well as adjusting the form’s POST action,
    which is what we were trying to do anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/templates/list.xhtml (ch07l053)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_working_incrementally_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: There’s our new form action.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_working_incrementally_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`.item_set` is called a [reverse lookup](https://docs.djangoproject.com/en/4.2/topics/db/queries/#following-relationships-backward).
    It’s one of Django’s incredibly useful bits of ORM that lets you look up an object’s
    related items from a different table…​'
  prefs: []
  type: TYPE_NORMAL
- en: 'So that gets the unit tests to pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: How about the FTs?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'HOORAY! Oh, and a quick check on our to-do list:'
  prefs: []
  type: TYPE_NORMAL
- en: Irritatingly, the Testing Goat is a stickler for tying up loose ends too, so
    we’ve got to do this one final thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, we’ll do a commit—​always make sure you’ve got a commit of
    a working state before embarking on a refactor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: A Final Refactor Using URL includes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*superlists/urls.py* is really meant for URLs that apply to your entire site.
    For URLs that only apply to the `lists` app, Django encourages us to use a separate
    *lists/urls.py*, to make the app more self-contained. The simplest way to make
    one is to use a copy of the existing *urls.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we replace the three list-specific lines in *superlists/urls.py* with
    an `include()`:'
  prefs: []
  type: TYPE_NORMAL
- en: superlists/urls.py (ch07l055)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_working_incrementally_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: While we’re at it, we use the `import x as y` syntax to alias `views` This is
    good practice in your top-level *urls.py*, because it will let us import views
    from multiple apps if we want—​and indeed we will need to later on in the book.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_working_incrementally_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the `include`. Notice that it can take a part of a URL as a prefix, which
    will be applied to all the included URLs (this is the bit where we reduce duplication,
    as well as giving our code a better structure).
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in *lists/urls.py* we can trim down to only include the latter part of
    our three URLs, and none of the other stuff from the parent *urls.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: lists/urls.py (ch07l056)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Rerun the unit tests to check that everything worked.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: When I saw that it, I couldn’t quite believe I did it correctly on the first
    go. It always pays to be skeptical of your own abilities, so I deliberately changed
    one of the URLs slightly, just to check if it broke a test. It did. We’re covered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feel free to try it yourself! Remember to change it back, check that the tests
    all pass again, and then do a final commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Phew. A marathon chapter. But we covered a number of important topics, starting
    with some thinking about design. We covered rules of thumb like “YAGNI” and “three
    strikes then refactor”. But, most importantly, we saw how to adapt an existing
    codebase step by step, going from working state to working state, in order to
    iterate towards a new design.
  prefs: []
  type: TYPE_NORMAL
- en: I’d say we’re pretty close to being able to ship this site, as the very first
    beta of the superlists website that’s going to take over the world. Maybe it needs
    a little prettification first…​let’s look at what we need to do to deploy it in
    the next couple of chapters.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch07.xhtml#id427-marker)) Are you wondering about the strange spelling
    of the “nulist” variable? Other options are “list”, which would shadow the built-in
    `list()` function, and `new_list`, which would shadow the name of the function
    that contains it. Or `list1` or `listey` or `mylist`, but none are particularly
    satisfactory.
  prefs: []
  type: TYPE_NORMAL
