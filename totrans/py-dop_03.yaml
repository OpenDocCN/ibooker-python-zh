- en: Chapter 3\. Working with the Command Line
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章\. 使用命令行
- en: The command line is where the rubber hits the road. Although there are many
    powerful tools with graphical interfaces, the command line is still home for DevOps
    work. Interacting with your shell environment from within Python and creating
    Python command-line tools are both necessary when using Python for DevOps.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行是实际操作的地方。尽管有许多强大的图形界面工具，但命令行仍然是 DevOps 工作的主场。从 Python 中与你的 shell 环境交互，并创建
    Python 命令行工具，在使用 Python 进行 DevOps 时都是必要的。
- en: Working with the Shell
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Shell
- en: Python offers tools for interacting with systems and shells. You should become
    familiar with the `sys`, `os`, and `subprocess` modules, as all are essential
    tools.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了与系统和 shell 交互的工具。你应该熟悉 `sys`、`os` 和 `subprocess` 模块，因为它们都是必不可少的工具。
- en: Talking to the Interpreter with the sys Module
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 sys 模块与解释器交互
- en: The `sys` module offers access to variables and methods closely tied to the
    Python interpreter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys` 模块提供了访问与 Python 解释器紧密相关的变量和方法。'
- en: Note
  id: totrans-6
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There are two dominant ways to interpret bytes during reading. The first, *little
    endian*, interprets each subsequent byte as having higher significance (representing
    a larger digit). The other, *big endian*, assumes the first byte has the greatest
    significance and moves down from there.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取时有两种主流的字节解释方式。第一种 *little endian*，将每个后续字节解释为具有更高重要性（表示更大数字）。另一种 *big endian*，假设第一个字节具有最大重要性，并从那里开始移动。
- en: 'You can use the `sys.byteorder` attribute to see the byte order of your current
    architecture:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `sys.byteorder` 属性来查看当前架构的字节顺序：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can use `sys.getsizeof` to see the size of Python objects. This is useful
    if you are dealing with limited memory:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `sys.getsizeof` 来查看 Python 对象的大小。如果你处理有限内存，这将非常有用：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you want to perform different behaviors, depending on the underlying operating
    system, you can use `sys.platform` to check:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要根据底层操作系统执行不同的行为，可以使用 `sys.platform` 进行检查：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A more common situation is that you want to use a language feature or module
    that is only available in specific versions of Python. You can use the `sys.version_info`
    to control behavior based on the running Python interpreter. Here we print different
    messages for Python 3.7, a Python version 3 that is below 3.7, and Python versions
    lower than 3:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的情况是你想要使用仅在特定版本的 Python 中可用的语言特性或模块。你可以使用 `sys.version_info` 来根据正在运行的 Python
    解释器控制行为。在这里，我们为 Python 3.7 打印不同的消息，低于 3.7 的 Python 版本，以及低于 3 的 Python 版本：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We cover more `sys` usage later in this chapter when we write command-line tools.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写命令行工具时，我们稍后会更多地涵盖 `sys` 的使用。
- en: Dealing with the Operating System Using the os Module
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 os 模块处理操作系统
- en: You have seen the `os` module used in [Chapter 2](ch02.html#automating_files_and_the_filesystem)
    for dealing with the filesystem. It also has a grab bag of various attributes
    and functions related to dealing with the operating system. In [Example 3-1](#Example-3-1)
    we demonstrate some of them.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 [第 2 章](ch02.html#automating_files_and_the_filesystem) 中看到了 `os` 模块用于处理文件系统。它还有一堆与操作系统相关的各种属性和函数。在
    [示例 3-1](#Example-3-1) 中，我们展示了其中一些。
- en: Example 3-1\. os module examples
  id: totrans-19
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-1\. os 模块示例
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_working_with_the_command_line_CO1-1)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_working_with_the_command_line_CO1-1)'
- en: Get the current working directory.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 获取当前工作目录。
- en: '[![2](assets/2.png)](#co_working_with_the_command_line_CO1-2)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_working_with_the_command_line_CO1-2)'
- en: Change the current working directory.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 更改当前工作目录。
- en: '[![3](assets/3.png)](#co_working_with_the_command_line_CO1-3)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_working_with_the_command_line_CO1-3)'
- en: The `os.environ` holds the environment variables that were set when the `os`
    module was loaded.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.environ` 保存了加载 `os` 模块时设置的环境变量。'
- en: '[![4](assets/4.png)](#co_working_with_the_command_line_CO1-4)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_working_with_the_command_line_CO1-4)'
- en: This is the setting and environment variable. This setting exists for subprocesses
    spawned from this code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是设置和环境变量。该设置适用于从此代码生成的子进程。
- en: '[![5](assets/5.png)](#co_working_with_the_command_line_CO1-5)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_working_with_the_command_line_CO1-5)'
- en: This is the login of the user in the terminal that spawned this process.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在终端中生成此进程的用户登录信息。
- en: The most common usage of the `os` module is to get settings from environment
    variables. These could be the level to set your logging, or secrets such as API
    keys.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`os` 模块的最常见用法是从环境变量中获取设置。这些设置可能是设置日志级别或诸如 API 密钥之类的秘密。'
- en: Spawn Processes with the subprocess Module
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 subprocess 模块生成进程
- en: 'There are many instances when you need to run applications outside of Python
    from within your Python code. This could be built-in shell commands, Bash scripts,
    or any other command-line application. To do this, you spawn a new *process* (instance
    of the application). The `subprocess` module is the right choice when you want
    to spawn a process and run commands within it. With `subprocess`, you can run
    your favorite shell command or other command-line software and collect its output
    from within Python. For the majority of use cases, you should use the `subprocess.run`
    function to spawn processes:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，你需要从你的 Python 代码中运行应用程序外部的应用程序。这可能是内置的 shell 命令、Bash 脚本或任何其他命令行应用程序。为此，你可以生成一个新的*进程*（应用程序的实例）。当你想在
    Python 中生成进程并在其中运行命令时，`subprocess` 模块是正确的选择。使用`subprocess`，你可以在 Python 中运行你喜欢的
    shell 命令或其他命令行软件，并从中收集其输出。对于大多数用例，你应该使用`subprocess.run`函数来生成进程：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `subprocess.run` function returns a `CompletedProcess` instance once the
    process completes. In this case, we run the shell command `ls` with the argument
    `-l` to see the contents of the current directory. We set it to capture `stdout`
    and `stderr` with the `capture_output` parameter. We then access the results using
    `cp.stdout`. If we run our `ls` command on a nonexistent directory, causing it
    to return an error, we can see the output in `cp.stderr`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`subprocess.run`函数在进程完成后返回`CompletedProcess`实例。在这种情况下，我们使用参数`-l`运行`ls` shell命令来查看当前目录的内容。我们设置它来捕获`stdout`和`stderr`的输出，然后使用`cp.stdout`访问结果。如果我们在不存在的目录上运行我们的`ls`命令，导致返回错误，我们可以在`cp.stderr`中看到输出：'
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can better integrate the handling of errors by using the `check` parameter.
    This raises an exception if the subprocess reports an error:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`check`参数，你可以更好地集成错误处理。如果子进程报告错误，这将引发异常：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this way, you don’t have to check `stderr` for failures. You can treat errors
    from your subprocess much as you would other Python exceptions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就不必检查`stderr`以查找失败。你可以像处理其他 Python 异常一样处理来自子进程的错误。
- en: Creating Command-Line Tools
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建命令行工具
- en: 'The simplest way to invoke a Python script on the command line is to invoke
    it using Python. When you construct a Python script, any statements at the top
    level (not nested in code blocks) run whenever the script is invoked or imported.
    If you have a function you want to run whenever your code is loaded, you can invoke
    it at the top level:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行上调用 Python 脚本的最简单方法是使用 Python 调用它。当你构建一个 Python 脚本时，顶级语句（不嵌套在代码块中）会在脚本被调用或导入时运行。如果你有一个希望在代码加载时运行的函数，你可以在顶级调用它：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This function runs whenever the script runs on the command line:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数在脚本在命令行上运行时运行：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Also, when the file is imported:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当文件被导入时：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This should only be done with the most straightforward scripts, however. A
    significant downside to this approach is that if you want to import your module
    into other Python modules, the code runs during import instead of waiting to be
    invoked by the calling module. Someone who is importing your module usually wants
    control over when its contents are invoked. You can add functionality that only
    happens when called from the command line by using the global `*name*` variable.
    You have seen that this variable reports the name of the module during import.
    If the module is called directly on the command line, this sets it to the string
    `**main**`. The convention for modules running on the command line is to end with
    a block testing for this and run command-line specific code from this block. To
    modify the script to run a function automatically only when invoked on the command
    line, but not during import, put the function invocation into the block after
    the test:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法只适用于最简单的脚本。然而，这种方法的一个显著缺点是，如果你想将你的模块导入到其他 Python 模块中，代码会在导入时运行，而不是等待调用模块。导入你的模块的人通常希望控制其内容在何时被调用。你可以通过使用全局变量`*name*`来添加仅在从命令行调用时发生的功能。你已经看到，这个变量在导入时报告模块的名称。如果模块直接在命令行上调用，它将被设置为字符串`**main**`。命令行上运行的模块的约定是在最后一个块中测试这一点，并从该块运行特定于命令行的代码。要修改脚本，仅在命令行调用时自动运行函数，而不在导入时运行，请将函数调用放入测试之后的块中：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When you import this function, this block does not run, as the `__name__` variable
    reflects the module path as imported. It runs when the module is run directly,
    however:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导入此函数时，此块不会运行，因为`__name__`变量反映了导入时的模块路径。然而，当直接运行模块时，它会运行：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first step in creating command-line tools is separating code that should
    only run when invoked on the command line. The next step is to accept command-line
    arguments. Unless your tool only does one thing, you need to accept commands to
    know what to do. Also, command-line tools that do more than the simplest tasks
    accept optional flags to configure their workings. Remember that these commands
    and flags are the *user interface* (UI) for anyone using your tools. You need
    to consider how easy they are to use and understand. Providing documentation is
    an essential part of making your code understandable.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 创建命令行工具的第一步是分离只有在命令行调用时才应运行的代码。下一步是接受命令行参数。除非您的工具只做一件事，否则需要接受命令以知道该做什么。此外，执行更复杂任务的命令行工具接受用于配置其工作方式的可选标志。请记住，这些命令和标志是任何使用您工具的人的*用户界面*（UI）。您需要考虑它们的易用性和可理解性。提供文档是使您的代码易于理解的重要部分。
- en: Using sys.argv
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 sys.argv
- en: 'The simplest and most basic way to process arguments from the command line
    is to use the `argv` attribute of the `sys` module. This attribute is a list of
    arguments passed to a Python script at runtime. If the script runs on the command
    line, the first argument is the name of the script. The rest of the items in the
    list are any remaining command-line arguments, represented as strings:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 处理命令行参数的最简单和最基本的方法是使用 `sys` 模块的 `argv` 属性。该属性是在运行时传递给 Python 脚本的参数列表。如果脚本在命令行上运行，第一个参数是脚本的名称。列表中的其余项目是剩余的命令行参数，表示为字符串：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run it on the command line and see the arguments:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行上运行并查看参数：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can use these arguments to write your own argument parser. To see what this
    might look like, check out [Example 3-2](#Example-3-2).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这些参数来编写自己的参数解析器。要查看这可能是什么样子，请查看 [示例 3-2](#Example-3-2)。
- en: Example 3-2\. Parsing with sys.argv
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-2\. 使用 sys.argv 进行解析
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](assets/1.png)](#co_working_with_the_command_line_CO2-1)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_working_with_the_command_line_CO2-1)'
- en: Here we test to see if we are running from the command line.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们测试是否从命令行运行。
- en: '[![2](assets/2.png)](#co_working_with_the_command_line_CO2-2)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_working_with_the_command_line_CO2-2)'
- en: Default values are set in these two lines.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值设置在以下两行。
- en: '[![3](assets/3.png)](#co_working_with_the_command_line_CO2-3)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_working_with_the_command_line_CO2-3)'
- en: Check if the string `--help` is in the list of arguments.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 检查字符串 `--help` 是否在参数列表中。
- en: '[![4](assets/4.png)](#co_working_with_the_command_line_CO2-4)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_working_with_the_command_line_CO2-4)'
- en: Exit the program after printing the help message.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印帮助消息后退出程序。
- en: '[![5](assets/5.png)](#co_working_with_the_command_line_CO2-5)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_working_with_the_command_line_CO2-5)'
- en: We need the position of the value after the flag, which should be the associated
    value.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要标志后面的值的位置，这应该是关联的值。
- en: '[![6](assets/6.png)](#co_working_with_the_command_line_CO2-6)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_working_with_the_command_line_CO2-6)'
- en: Test that the arguments list is long enough. It will not be if the flag was
    provided without a value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 测试参数列表的长度是否足够。如果提供了标志但没有值，则长度不够。
- en: '[![7](assets/7.png)](#co_working_with_the_command_line_CO2-7)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_working_with_the_command_line_CO2-7)'
- en: Call the function with the values as modified by the arguments.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数时，使用参数修改的值。
- en: '[Example 3-2](#Example-3-2) goes far enough to print out a simple help message
    and accept arguments to the function:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-2](#Example-3-2) 已经足够打印出一个简单的帮助消息并接受函数的参数：'
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This approach is fraught with complication and potential bugs. [Example 3-2](#Example-3-2)
    fails to handle many situations. If a user misspells or miscapitalizes a flag,
    the flag is ignored with no useful feedback. If they use commands that are not
    supported or try to use more than one value with a flag, once again the error
    is ignored. You should be aware of the `argv` parsing approach, but do not use
    it for any production code unless you specifically set out to write an argument
    parser. Luckily there are modules and packages designed for the creation of command-line
    tools. These packages provide frameworks to design the user interface for your
    module when running in a shell. Three popular solutions are *argparse*, *click*,
    and *python-fire*. All three include ways to design required arguments, optional
    flags, and means to display help documentation. The first, `argparse`, is part
    of the Python standard library, and the other two are third-party packages that
    need to be installed separately (using `pip`).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法充满了复杂性和潜在的错误。 [示例 3-2](#Example-3-2) 无法处理许多情况。 如果用户拼错或者大小写不正确的标志，标志将被忽略且没有有用的反馈。
    如果他们使用不受支持的命令或尝试使用多个值与标志，则再次忽略错误。 您应该了解`argv`解析方法，但除非您专门编写参数解析器，否则不要在任何生产代码中使用它。
    幸运的是，有为创建命令行工具设计用户界面的模块和包。 这些包提供了在shell中运行时设计模块用户界面的框架。 三种流行的解决方案是*argparse*，*click*和*python-fire*。
    这三者都包括设计必需参数，可选标志和显示帮助文档的方法。 第一个`argparse`是Python标准库的一部分，其他两个是需要单独安装的第三方包（使用`pip`安装）。
- en: Using argparse
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用argparse
- en: '`argparse` abstracts away many of the details of parsing arguments. With it,
    you design your command-line user interface in detail, defining commands and flags
    along with their help messages. It uses the idea of parser objects, to which you
    attach commands and flags. The parser then parses the arguments, and you use the
    results to call your code. You construct your interface using `ArgumentParser`
    objects that parse user input for you:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`argparse`抽象了解析参数的许多细节。 使用它，您可以详细设计命令行用户界面，定义命令和标志以及它们的帮助消息。 它使用解析器对象的概念，您可以将命令和标志附加到其中。
    然后解析器解析参数，您可以使用结果调用您的代码。 您使用`ArgumentParser`对象构建您的接口，这些对象为您解析用户输入：'
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You add position-based commands or optional flags to the parser using the `add_argument`
    method (see [Example 3-3](#Example-3-3)). The first argument to this method is
    the name of the new argument (command or flag). If the name begins with a dash,
    it is treated as an optional flag argument; otherwise it is treated as a position-dependent
    command. The parser creates a parsed-arguments object, with the arguments as attributes
    that you can then use to access input. [Example 3-3](#Example-3-3) is a simple
    program that echoes a users input and shows the basics of how `argparse` works.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`add_argument`方法向解析器添加基于位置的命令或可选标志（参见[示例 3-3](#Example-3-3)）。 此方法的第一个参数是新参数（命令或标志）的名称。
    如果名称以短横线开头，则将其视为可选标志参数； 否则将其视为位置依赖命令。 解析器创建一个解析后的参数对象，该对象具有您可以使用的属性来访问输入。 [示例 3-3](#Example-3-3)
    是一个简单的程序，用于回显用户输入并展示`argparse`的基本工作原理。
- en: Example 3-3\. simple_parse.py
  id: totrans-81
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-3\. simple_parse.py
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](assets/1.png)](#co_working_with_the_command_line_CO3-1)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_working_with_the_command_line_CO3-1)'
- en: Create the parser object, with its documentation message.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 创建解析器对象，并附上其文档消息。
- en: '[![2](assets/2.png)](#co_working_with_the_command_line_CO3-2)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_working_with_the_command_line_CO3-2)'
- en: Add a position-based command with its help message.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个基于位置的命令及其帮助消息。
- en: '[![3](assets/3.png)](#co_working_with_the_command_line_CO3-3)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_working_with_the_command_line_CO3-3)'
- en: Add an optional argument.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个可选参数。
- en: '[![4](assets/4.png)](#co_working_with_the_command_line_CO3-4)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_working_with_the_command_line_CO3-4)'
- en: Store the optional argument as a boolean value.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将可选参数存储为布尔值。
- en: '[![5](assets/5.png)](#co_working_with_the_command_line_CO3-5)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_working_with_the_command_line_CO3-5)'
- en: Use the parser to parse the arguments.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用解析器解析参数。
- en: '[![6](assets/6.png)](#co_working_with_the_command_line_CO3-6)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_working_with_the_command_line_CO3-6)'
- en: Access the argument values by name. The optional argument’s name has the *--*
    removed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 按名称访问参数值。 可选参数的名称已删除*--*。
- en: 'When you run it with the `--twice` flag, the input message prints twice:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`--twice`标志运行它时，输入消息会打印两次：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`argparse` automatically sets up help and usage messages based on the help
    and description text you supply:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`argparse`根据您提供的帮助和描述文本自动设置帮助和使用消息：'
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Many command-line tools use nested levels of commands to group command areas
    of control. Think of `git`. It has top-level commands, such as `git stash`, which
    have separate commands under them, such as `git stash pop`. With `argparse`, you
    create subcommands by creating subparsers under your main parser. You can create
    a hierarchy of commands using subparsers. In [Example 3-4](#Example-3-4), we implement
    a maritime application that has commands for ships and sailors. Two subparsers
    are added to the main parser; each subparser has its own commands.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 许多命令行工具使用嵌套的命令级别来分组控制命令区域。想想 `git`。它有顶层命令，比如 `git stash`，下面有单独的命令，比如 `git stash
    pop`。使用 `argparse`，你可以通过在主解析器下创建子解析器来创建子命令。你可以使用子解析器创建命令的层次结构。在 [示例 3-4](#Example-3-4)
    中，我们实现了一个海事应用程序，其中有用于船只和水手的命令。我们向主解析器添加了两个子解析器；每个子解析器都有自己的命令。
- en: Example 3-4\. argparse_example.py
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '[示例 3-4](assets/7.png)\\. argparse_example.py'
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[![1](assets/1.png)](#co_working_with_the_command_line_CO4-1)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_working_with_the_command_line_CO4-1)'
- en: Create the top-level parser.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 创建顶层解析器。
- en: '[![2](assets/2.png)](#co_working_with_the_command_line_CO4-2)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_working_with_the_command_line_CO4-2)'
- en: Add a top-level argument that can be used along with any command under this
    parser’s hierarchy.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个顶级参数，可以与这个解析器层次结构下的任何命令一起使用。
- en: '[![3](assets/3.png)](#co_working_with_the_command_line_CO4-3)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_working_with_the_command_line_CO4-3)'
- en: Create a subparser object to hold the subparsers. The `dest` is the name of
    the attribute used to choose a subparser.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个子解析器对象来保存子解析器。`dest` 是选择子解析器时使用的属性名称。
- en: '[![4](assets/4.png)](#co_working_with_the_command_line_CO4-4)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_working_with_the_command_line_CO4-4)'
- en: Add a subparser for *ships*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为 *ships* 添加一个子解析器。
- en: '[![5](assets/5.png)](#co_working_with_the_command_line_CO4-5)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_working_with_the_command_line_CO4-5)'
- en: Add a command to the *ships* subparser. The `choices` parameter gives a list
    of possible choices for the command.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为 *ships* 子解析器添加一个命令。`choices` 参数提供了命令的可能选择列表。
- en: '[![6](assets/6.png)](#co_working_with_the_command_line_CO4-6)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_working_with_the_command_line_CO4-6)'
- en: Add a subparser for *sailors*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为 *sailors* 添加一个子解析器。
- en: '[![7](assets/7.png)](#co_working_with_the_command_line_CO4-7)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_working_with_the_command_line_CO4-7)'
- en: Add a required positional argument to the *sailors* subparser.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为 *sailors* 子解析器添加一个必需的位置参数。
- en: '[![8](assets/8.png)](#co_working_with_the_command_line_CO4-8)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_working_with_the_command_line_CO4-8)'
- en: Check which subparser is used by checking the `func` value.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查 `func` 值来检查使用了哪个子解析器。
- en: '[Example 3-4](#Example-3-4) has one top-level optional argument (`twice`) and
    two subparsers. Each subparser has its own commands and flags. `argparse` automatically
    creates a hierarchy of help messages and displays them with the `--help` flag.
    The top-level help commands, including the subparsers and the top-level `twice`
    argument, are documented:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-4](#Example-3-4) 有一个顶级可选参数 (`twice`) 和两个子解析器。每个子解析器都有自己的命令和标志。`argparse`
    自动创建一个帮助消息的层次结构，并使用 `--help` 标志显示它们。顶级帮助命令包括子解析器和顶级 `twice` 参数都有文档记录：'
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can dig into the subcommands (subparsers) by using the `help` flag after
    the command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用命令后的 `help` 标志来深入探讨子命令（子解析器）。
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, `argparse` gives you a lot of control over your command-line
    interface. You can design a multilayered interface with built-in documentation
    with many options to fine-tune your design. Doing so takes a lot of work on your
    part, however, so let’s look at some easier options.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`argparse` 可以很好地控制你的命令行界面。你可以设计一个多层次的界面，并内置文档，有很多选项来微调你的设计。不过，这需要你付出很多工作，所以让我们看一些更简单的选项。
- en: Using click
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 click
- en: The `click` package was first developed to work with web framework `flask`.
    It uses Python *function decorators* to bind the command-line interface directly
    with your functions. Unlike `argparse`, `click` interweaves your interface decisions
    directly with the rest of your code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`click` 包最初是为与 web 框架 `flask` 配合而开发的。它使用 Python *函数装饰器* 将命令行接口直接与你的函数绑定在一起。与
    `argparse` 不同，`click` 直接将你的接口决策与代码的其余部分交织在一起。'
- en: 'This means that you tie your flags and options directly to the parameters of
    the functions that they expose. You can create a simple command-line tool from
    your functions using click’s `command` and `option` functions as decorators before
    your function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你将你的标志和选项直接与它们公开的函数的参数绑定在一起。你可以使用 click 的 `command` 和 `option` 函数作为你的函数之前的装饰器，从你的函数中创建一个简单的命令行工具：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`click.command` indicates that a function should be exposed to command-line
    access. `click.option` adds an argument to the command-line, automatically linking
    it to the function parameter of the same name (`--greeting` to `greet` and `--name`
    to `name`). `click` does some work behind the scenes so that we can call our `greet`
    method in our main block without parameters that are covered by the `options`
    decorators.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`click.command` 表示应将函数公开给命令行访问。`click.option` 将参数添加到命令行，自动将其链接到同名函数参数（`--greeting`
    对应 `greet` 和 `--name` 对应 `name`）。`click` 在后台做一些工作，使我们可以在主块中调用我们的 `greet` 方法，而不需要被
    `options` 装饰器所覆盖的参数。'
- en: 'These decorators handle parsing command-line arguments and automatically produce
    help messages:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这些装饰器处理解析命令行参数，并自动生成帮助消息：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can see that with `click` you can expose your functions for command-line
    use with much less code than `argparse`. You can concentrate on the business logic
    of your code rather than designing the interface.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，使用 `click` 可以以比 `argparse` 更少的代码将函数暴露为命令行使用。您可以集中精力于代码的业务逻辑，而不是设计界面。
- en: Now let’s look at a more complicated example with nested commands. Commands
    are nested by using `click.group` creating functions that represent the groups.
    In [Example 3-5](#Example-3-5) we nest commands with `argparse`, using an interface
    that is very similar to the one from [Example 3-4](#Example-3-4).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个更复杂的示例，其中包含嵌套命令。使用 `click.group` 创建表示组的函数来嵌套命令。在 [Example 3-5](#Example-3-5)
    中，我们使用 `argparse` 嵌套命令，其接口与 [Example 3-4](#Example-3-4) 中的接口非常相似。
- en: Example 3-5\. click_example.py
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-5\. click_example.py
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[![1](assets/1.png)](#co_working_with_the_command_line_CO5-1)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_working_with_the_command_line_CO5-1)'
- en: Create a top-level group under which other groups and commands will reside.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个顶级组，其他组和命令将驻留在其中。
- en: '[![2](assets/2.png)](#co_working_with_the_command_line_CO5-2)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_working_with_the_command_line_CO5-2)'
- en: Create a function to act as the top-level group. The `click.group` method transforms
    the function into a group.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个函数作为顶级组的操作。`click.group` 方法将该函数转换为一个组。
- en: '[![3](assets/3.png)](#co_working_with_the_command_line_CO5-3)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_working_with_the_command_line_CO5-3)'
- en: Create a group to hold the `ships` commands.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个用于容纳 `ships` 命令的组。
- en: '[![4](assets/4.png)](#co_working_with_the_command_line_CO5-4)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_working_with_the_command_line_CO5-4)'
- en: Add the `ships` group as a command to the top-level group. Note that the `cli`
    function is now a group with an `add_command` method.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `ships` 组作为顶级组的一个命令添加。请注意，`cli` 函数现在是一个具有 `add_command` 方法的组。
- en: '[![5](assets/5.png)](#co_working_with_the_command_line_CO5-5)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_working_with_the_command_line_CO5-5)'
- en: Add a command to the `ships` group. Notice that `ships.command` is used instead
    of `click.command`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `ships` 组添加一个命令。注意，使用了 `ships.command` 而不是 `click.command`。
- en: '[![6](assets/6.png)](#co_working_with_the_command_line_CO5-6)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_working_with_the_command_line_CO5-6)'
- en: Add a command to the `cli` group.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `cli` 组添加一个命令。
- en: '[![7](assets/7.png)](#co_working_with_the_command_line_CO5-7)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_working_with_the_command_line_CO5-7)'
- en: Call the top-level group.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 调用顶级组。
- en: 'The top-level help messages generated by `click` look like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`click` 生成的顶级帮助消息如下所示：'
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can dig into the help for a subgroup like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像这样查看子组的帮助：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you compare [Example 3-4](#Example-3-4) and [Example 3-5](#Example-3-5),
    you will see some of the differences between using `argparse` and `click`. The
    `click` approach certainly requires less code, almost half in these examples.
    The user interface (UI) code is interspersed throughout the whole program; it
    is especially important when creating functions that solely act as groups. If
    you have a complex program, with a complex interface, you should try as best as
    possible to isolate different functionality. By doing so, you make individual
    pieces easier to test and debug. In such a case, you might choose `argparse` to
    keep your interface code separate.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您比较 [Example 3-4](#Example-3-4) 和 [Example 3-5](#Example-3-5)，您会看到使用 `argparse`
    和 `click` 的一些区别。在这些示例中，`click` 方法确实需要的代码量少得多，几乎只有一半。用户界面（UI）代码穿插在整个程序中；这在创建纯粹作为组的函数时尤为重要。如果您有一个复杂的程序和复杂的界面，应尽可能将不同的功能隔离开来。通过这样做，您可以更轻松地测试和调试单独的组件。在这种情况下，您可能会选择使用
    `argparse` 来保持界面代码的独立性。
- en: fire
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: fire
- en: 'Now, let’s take a step farther down the road of making a command-line tool
    with minimal UI code. The `fire` package uses introspection of your code to create
    interfaces automatically. If you have a simple function you want to expose, you
    call `fire.Fire` with it as an argument:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更进一步，用尽量少的 UI 代码制作一个命令行工具。`fire`包使用你的代码的内省来自动创建接口。如果你有一个简单的函数想要暴露，可以将其作为参数调用`fire.Fire`：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`fire` then creates the UI based on the method’s name and arguments:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`fire`根据方法的名称和参数创建 UI：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In simple cases, you can expose multiple methods automatically by invoking
    `fire` with no arguments:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单情况下，通过不带参数调用`fire`可以自动暴露多个方法：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`fire` creates a command from each function and documents automatically:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`fire`从每个函数创建命令并自动记录文档：'
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is really convenient if you are trying to understand someone else’s code
    or debug your own. With one line of additional code, you can interact with all
    of a module’s functions from the command-line. That is powerful. Because `fire`
    uses the structure of your program itself to determine the interface, it is even
    more tied to your non-interface code than `argparse` or `click`. To mimic our
    nest command interface, you need to define classes with the structure of the interface
    you want to expose. To see an approach to this, check out [Example 3-6](#Example-3-6).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图理解别人的代码或调试自己的代码，这真的非常方便。通过额外的一行代码，你就可以与模块的所有函数进行命令行交互。这非常强大。因为`fire`使用程序本身的结构来确定接口，它甚至比`argparse`或`click`更与你的非接口代码紧密相关。要模仿我们的巢状命令接口，你需要定义具有要暴露的接口结构的类。要了解一种方法，请查看[示例 3-6](#Example-3-6)。
- en: Example 3-6\. fire_example.py
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-6\. fire_example.py
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[![1](assets/1.png)](#co_working_with_the_command_line_CO6-1)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_working_with_the_command_line_CO6-1)'
- en: Define a class for the ships commands.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为船只命令定义一个类。
- en: '[![2](assets/2.png)](#co_working_with_the_command_line_CO6-2)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_working_with_the_command_line_CO6-2)'
- en: '`sailors` has no subcommands, so it can be defined as a function.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`sailors`没有子命令，因此可以定义为一个函数。'
- en: '[![3](assets/3.png)](#co_working_with_the_command_line_CO6-3)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_working_with_the_command_line_CO6-3)'
- en: Define a class to act as the top group. Add the `sailors` function and the `Ships`
    as attributes of the class.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个充当顶级组的类。将`sailors`函数和`Ships`作为类的属性添加。
- en: '[![4](assets/4.png)](#co_working_with_the_command_line_CO6-4)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_working_with_the_command_line_CO6-4)'
- en: Call `fire.Fire` on the class acting as the top-level group.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在充当顶层组的类上调用`fire.Fire`：
- en: 'The automatically generated documentation at the top level represents the `Ships`
    class as a group, and the `sailors` command as a command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的顶层文档代表`Ships`类作为一个组，`sailors`命令作为一个命令：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The documentation for the `ships` group shows the commands representing the
    methods attached to the `Ships` class:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 展示代表附加到`Ships`类的方法的命令的`ships`组文档：
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The parameters for the `sailors` function are turned into positional arguments:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`sailors`函数的参数转换为位置参数：'
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can call the commands and subcommands as expected:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 按预期调用命令和子命令：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'An exciting feature of `fire` is the ability to enter an interactive mode easily.
    By using the `--interactive` flag, `fire` opens an IPython shell with the object
    and functions of your script available:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`fire`的一个令人兴奋的特性是能够轻松进入交互模式。通过使用`--interactive`标志，`fire`打开一个带有你脚本中对象和函数的 IPython
    shell：'
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here we run the maritime program’s `sailors` command in interactive mode. An
    IPython shell opens, and you have access to the `sailors` function. This interactive
    mode, in combination with the ease of exposing objects with `fire`, makes it the
    right tool both for debugging and introducing yourself to new code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在交互模式下运行海事程序的`sailors`命令。一个 IPython shell 打开，你可以访问`sailors`函数。这种交互模式与使用`fire`暴露对象的简便性结合使用，使其成为调试和介绍新代码的合适工具。
- en: You have now run the gamut in command-line tool building libraries, from the
    very hands-on `argparse`, to the less verbose `click`, and lastly to the minimal
    `fire`. So which one should you use? We recommend `click` for most use cases.
    It balances ease and control. In the case of complex interfaces where you want
    to separate the UI code from business logic, `argparse` is the way to go. Moreover,
    if you need to access code that does not have a command-line interface quickly,
    `fire` is right for you.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经使用命令行工具构建库的全套，从非常实用的`argparse`，到不那么冗长的`click`，最后到极简的`fire`。那么你应该使用哪个？对于大多数用例，我们推荐使用`click`。它平衡了简易性和控制性。在需要将
    UI 代码与业务逻辑分离的复杂界面情况下，`argparse`是不二之选。此外，如果需要快速访问没有命令行接口的代码，`fire`适合你。
- en: Implementing Plug-ins
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现插件
- en: Once you’ve implemented your application’s command-line user interface, you
    might want to consider a plug-in system. Plug-ins are pieces of code supplied
    by the user of your program to extend functionality. Plug-in systems are used
    in all sorts of applications, from large applications like Autodesk’s Maya to
    minimal web frameworks like Flask. You could write a tool that handles walking
    a filesystem and allows a user to provide plug-ins to operate on its contents.
    A key part of any plug-in system is plug-in discover. Your program needs to know
    what plug-ins are available to load and run. In [Example 3-7](#Example-3-7), we
    write a simple application that discovers and runs plug-ins. It uses a user-supplied
    prefix to search for, load, and run plug-ins.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实现了应用程序的命令行用户界面，你可能想考虑一个插件系统。插件是由程序用户提供的代码片段，用于扩展功能。插件系统被用于各种应用程序中，从像 Autodesk
    的 Maya 这样的大型应用到像 Flask 这样的最小的 Web 框架。你可以编写一个工具，处理文件系统的遍历，并允许用户提供插件来操作其内容。任何插件系统的关键部分都是插件发现。你的程序需要知道哪些插件是可用的，以加载和运行。
- en: Example 3-7\. simple_plugins.py
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-7\. simple_plugins.py
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[![1](assets/1.png)](#co_working_with_the_command_line_CO7-1)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_working_with_the_command_line_CO7-1)'
- en: '`pkgutil.iter_modules` returns all modules available in the current `sys.path`.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`pkgutil.iter_modules` 返回当前`sys.path`中所有可用的模块。'
- en: '[![2](assets/2.png)](#co_working_with_the_command_line_CO7-2)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_working_with_the_command_line_CO7-2)'
- en: Check if the module uses our plug-in prefix.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 检查模块是否使用了我们的插件前缀。
- en: '[![3](assets/3.png)](#co_working_with_the_command_line_CO7-3)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_working_with_the_command_line_CO7-3)'
- en: Use `importlib` to load the module, saving it in a `dict` for later use.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`importlib`加载模块，将其保存在后续使用的`dict`中。
- en: '[![4](assets/4.png)](#co_working_with_the_command_line_CO7-4)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_working_with_the_command_line_CO7-4)'
- en: Call the `run` method on the plug-in.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 调用插件上的`run`方法。
- en: 'Writing supplying plug-ins to [Example 3-7](#Example-3-7) is as simple as supplying
    modules whose names use a shared prefix and whose functionality is accessed using
    a method named `run`. If you write two files using the prefix `foo_plugin` with
    individual run methods:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 编写供应用于[示例 3-7](#Example-3-7)的插件就像提供模块一样简单，这些模块的名称使用共享前缀，并且功能通过名为`run`的方法访问。如果你编写两个文件，使用前缀`foo_plugin`并且具有各自的运行方法：
- en: '[PRE40]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can discover and run them with our plugin application:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过我们的插件应用程序发现并运行它们：
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You can easily extend this simple example to create plug-in systems for your
    applications.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松扩展这个简单的示例，为你的应用程序创建插件系统。
- en: 'Case Study: Turbocharging Python with Command-Line Tools'
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究：用命令行工具为 Python 添加涡轮增压
- en: It’s as good a time as ever to be writing code these days; a little bit of code
    goes a long way. Just a single function is capable of performing incredible things.
    Thanks to GPUs, machine learning, the cloud, and Python, it’s easy to create “turbocharged”
    command-line tools. Think of it as upgrading your code from using a basic internal
    combustion engine to a jet engine. What’s the basic recipe for the upgrade? One
    function, a sprinkle of powerful logic, and, finally, a decorator to route it
    to the command line.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是编写代码的绝佳时机；一点点代码可以做很多事情。单个函数就能实现令人难以置信的功能。由于 GPU、机器学习、云计算和 Python 的推广，创建“涡轮增压”命令行工具变得轻而易举。将其视为从基本内燃发动机升级到喷气发动机的代码升级基本配方。升级的基本配方是什么？一个函数，一些强大的逻辑，最后，一个装饰器将其路由到命令行。
- en: Writing and maintaining traditional GUI applications—web or desktop—is a Sisyphean
    task at best. It all starts with the best of intentions, but can quickly turn
    into a soul crushing, time-consuming ordeal where you end up asking yourself why
    you thought becoming a programmer was a good idea in the first place. Why did
    you run that web framework setup utility that essentially automated a 1970s technology—the
    relational database—into series of Python files? The old Ford Pinto with the exploding
    rear gas tank has newer technology than your web framework. There has got to be
    a better way to make a living.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 编写和维护传统的 GUI 应用程序 —— 无论是 Web 还是桌面 —— 都是一项枯燥无味的任务。一切都始于最好的意图，但很快可能变成一个压垮灵魂、耗时紧张的折磨过程，最后你会问自己，为什么最初会认为成为程序员是个好主意呢？为什么你要运行那个基本上将
    1970 年代技术 —— 关系数据库 —— 自动化为一系列 Python 文件的 Web 框架设置实用程序呢？老式的 Ford Pinto 汽车尾部爆炸的汽油箱比你的
    Web 框架还有新技术。一定有更好的方式来谋生。
- en: 'The answer is simple: stop writing web applications and start writing jet-powered
    command-line tools instead. The turbocharged command-line tools discussed in the
    following sections are focused on fast results vis-à-vis minimal lines of code.
    They can do things like learn from data (machine learning), make your code run
    two thousand times faster, and best of all, generate colored terminal output.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 答案很简单：停止编写 Web 应用程序，转而编写具有喷气动力的命令行工具。以下各节讨论的增压命令行工具专注于快速结果与最少代码行。它们可以做到像从数据中学习（机器学习）、使你的代码运行快两千倍，最重要的是，生成彩色的终端输出。
- en: 'Here are the raw ingredients that will be used to make several solutions:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是将用于制作几个解决方案的原始成分：
- en: Click framework
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Click 框架
- en: Python CUDA framework
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python CUDA 框架
- en: Numba framework
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Numba 框架
- en: Scikit-learn machine learning framework
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scikit-learn 机器学习框架
- en: Using the Numba Just-in-Time (JIT) Compiler
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Numba 即时编译器（JIT）
- en: Python has a reputation for slow performance because it’s fundamentally a scripting
    language. One way to get around this problem is to use the Numba Just-in-Time
    (JIT) compiler. Let’s take a look at what that code looks like.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Python 因其本质上是脚本语言而声名狼藉，因其性能慢而著称。解决这个问题的一种方法是使用 Numba 即时编译器（JIT）。让我们看看这段代码是什么样子的。
- en: 'First, use a timing decorator to get a grasp on the runtime of your functions:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用一个定时装饰器来掌握函数的运行时：
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Next, add a `numba.jit` decorator with the `nopython` keyword argument and set
    it to `True`. This will ensure that the code will be run by JIT instead of regular
    Python.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加一个 `numba.jit` 装饰器，使用 `nopython` 关键字参数并将其设置为 `True`。这将确保代码将由 JIT 而不是常规
    Python 运行。
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When you run it, you can see both a `jit` as well as a regular version being
    run via the command-line tool:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行它时，可以看到通过命令行工具同时运行了 `jit` 和常规版本：
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'How does that work? Just a few lines of code allow for this simple toggle:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的？只需几行代码就可以进行这个简单的切换：
- en: '[PRE46]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In some cases, a JIT version could make code run thousands of times faster,
    but benchmarking is key. Another item to point out is this line:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，JIT 版本可以使代码运行速度提高数千倍，但基准测试非常关键。另一个需要指出的是这一行：
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This script allows for colored terminal output, which can be very helpful when
    creating sophisticated tools.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本允许生成彩色的终端输出，当创建复杂工具时非常有用。
- en: Using the GPU with CUDA Python
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 CUDA Python 在 GPU 上运行
- en: 'Another way to turbocharge your code is to run it straight on a GPU. This example
    requires you run it on a machine with a CUDA enabled. Here’s what that code looks
    like:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种加速代码的方式是直接在 GPU 上运行它。这个示例需要在支持 CUDA 的机器上运行。这是代码的样子：
- en: '[PRE48]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'It’s useful to point out that if the Numpy array is first moved to the GPU,
    then a vectorized function does the work on the GPU. After that work is completed,
    the data is moved from the GPU. By using a GPU, there could be a monumental improvement
    to the code, depending on what it’s running. The output from the command-line
    tool is shown here:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 需要指出的是，如果先将 Numpy 数组移动到 GPU，然后在 GPU 上执行向量化函数，完成工作后再将数据从 GPU 移回。通过使用 GPU，代码可能会有显著的改进，这取决于它正在运行的内容。命令行工具的输出如下所示：
- en: '[PRE49]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Running True Multicore Multithreaded Python Using Numba
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Numba 运行真正的多核多线程 Python
- en: 'One common performance problem with Python is the lack of true, multithreaded
    performance. This also can be fixed with Numba. Here’s an example of some basic
    operations:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的一个常见性能问题是缺乏真正的多线程性能。这也可以通过 Numba 来解决。以下是一些基本操作的示例：
- en: '[PRE50]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note that the key difference between the parallel version is that it uses `@numba.jit(parallel=True)`
    and `numba.prange` to spawn threads for iteration. As you can see in [Figure 3-1](#Figure-3-1),
    all of the CPUs are maxed out on the machine, but when almost the exact same code
    is run without the parallelization, it only uses a core.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，并行版本的关键区别在于它使用 `@numba.jit(parallel=True)` 和 `numba.prange` 来为迭代生成线程。正如你在[图 3-1](#Figure-3-1)中所看到的，机器上的所有
    CPU 都被充分利用，但当几乎相同的代码运行时没有并行化，它只使用一个核心。
- en: '![pydo 0301](assets/pydo_0301.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![pydo 0301](assets/pydo_0301.png)'
- en: Figure 3-1\. Using all of the cores
  id: totrans-235
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-1。使用所有核心
- en: '[PRE51]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: KMeans Clustering
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: KMeans 聚类
- en: 'Another powerful thing that can be accomplished with a command-line tool is
    machine learning. In the example below, a KMeans clustering function is created
    with just a few lines of code. This clusters a Pandas DataFrame into a default
    of three clusters:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以通过命令行工具完成的强大功能是机器学习。在下面的示例中，仅使用几行代码就创建了一个 KMeans 聚类函数。这将一个 Pandas DataFrame
    聚类成默认的三个集群：
- en: '[PRE52]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The cluster number can be changed by passing in another number (as shown below)
    using `click`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传入另一个数字（如下所示），可以更改集群数量，使用 `click`：
- en: '[PRE53]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, the output of the Pandas DataFrame with the cluster assignment is
    shown next. Note that it now has cluster assignment as a column:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，下面显示了带有集群分配的 Pandas DataFrame 的输出。注意它现在有了一个列作为集群分配：
- en: '[PRE54]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Exercises
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Use `sys` to write a script that prints *command line* only when run from the
    command line.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `sys` 编写一个脚本，仅在从命令行运行时才打印*命令行*。
- en: Use `click` to create a command-line tool that takes a name as an argument and
    prints it if it does not begin with a *p*.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `click` 创建一个命令行工具，它接受一个名称作为参数，并在名称不以 *p* 开头时打印它。
- en: Use `fire` to access methods in an existing Python script from the command line.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `fire` 从命令行访问现有 Python 脚本中的方法。
