- en: Chapter 6\. Object References, Mutability, and Recycling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。对象引用、可变性和回收
- en: '“You are sad,” the Knight said in an anxious tone: “let me sing you a song
    to comfort you. […] The name of the song is called ‘HADDOCKS’ EYES’.”'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “你很伤心，”骑士焦急地说：“让我唱首歌来安慰你。[…] 这首歌的名字叫‘鳕鱼的眼睛’。”
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “Oh, that’s the name of the song, is it?” Alice said, trying to feel interested.
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “哦，那就是歌的名字吗？”爱丽丝试图表现出兴趣。
- en: ''
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “No, you don’t understand,” the Knight said, looking a little vexed. “That’s
    what the name is CALLED. The name really IS ‘THE AGED AGED MAN.’”
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “不，你没理解，”骑士说，看起来有点恼火。“那就是名字的称呼。名字真的就是‘老老老人’。”
- en: ''
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Adapted from Lewis Carroll, *Through the Looking-Glass, and What Alice Found
    There*
  id: totrans-7
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 改编自刘易斯·卡罗尔，《镜中世界》
- en: Alice and the Knight set the tone of what we will see in this chapter. The theme
    is the distinction between objects and their names. A name is not the object;
    a name is a separate thing.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 爱丽丝和骑士设定了我们在本章中将看到的基调。主题是对象和它们的名称之间的区别。一个名称不是对象；一个名称是一个独立的东西。
- en: 'We start the chapter by presenting a metaphor for variables in Python: variables
    are labels, not boxes. If reference variables are old news to you, the analogy
    may still be handy if you need to explain aliasing issues to others.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过提出一个关于Python中变量的比喻来开始本章：变量是标签，而不是盒子。如果引用变量对你来说是老生常谈，这个类比可能仍然有用，如果你需要向他人解释别名问题。
- en: 'We then discuss the concepts of object identity, value, and aliasing. A surprising
    trait of tuples is revealed: they are immutable but their values may change. This
    leads to a discussion of shallow and deep copies. References and function parameters
    are our next theme: the problem with mutable parameter defaults and the safe handling
    of mutable arguments passed by clients of our functions.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们讨论对象标识、值和别名的概念。元组的一个令人惊讶的特性被揭示出来：它们是不可变的，但它们的值可能会改变。这引发了对浅复制和深复制的讨论。引用和函数参数是我们接下来的主题：可变参数默认值的问题以及如何安全处理客户端传递的可变参数。
- en: The last sections of the chapter cover garbage collection, the `del` command,
    and a selection of tricks that Python plays with immutable objects.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后几节涵盖了垃圾回收、`del`命令以及Python对不可变对象玩弄的一些技巧。
- en: This is a rather dry chapter, but its topics lie at the heart of many subtle
    bugs in real Python programs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当枯燥的章节，但它的主题是许多真实Python程序中微妙错误的核心。
- en: What’s New in This Chapter
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章新内容
- en: The topics covered here are very fundamental and stable. There were no changes
    worth mentioning in this second edition.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这里涵盖的主题非常基础和稳定。在第二版中没有值得一提的变化。
- en: I added an example of using `is` to test for a sentinel object, and a warning
    about misuses of the `is` operator at the end of [“Choosing Between == and is”](#choosing_eq_v_is_sec).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加了一个使用`is`测试哨兵对象的示例，并在[“选择==还是is”](#choosing_eq_v_is_sec)的末尾警告了`is`运算符的误用。
- en: This chapter used to be in Part IV, but I decided to bring it up earlier because
    it works better as an ending to Part II, “Data Structures,” than an opening to
    “Object-Oriented Idioms.”
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章曾经在本书的第四部分，但我决定将其提前，因为它作为第二部分“数据结构”的结尾要比作为“面向对象习语”的开头更好。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The section on “Weak References” from the first edition of this book is now
    a [post at *fluentpython.com*](https://fpy.li/weakref).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书第一版中关于“弱引用”的部分现在是[*fluentpython.com*](https://fpy.li/weakref)上的一篇文章。
- en: Let’s start by unlearning that a variable is like a box where you store data.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从忘掉变量就像存储数据的盒子开始。
- en: Variables Are Not Boxes
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量不是盒子
- en: In 1997, I took a summer course on Java at MIT. The professor, Lynn Stein,^([1](ch06.html#idm46582451849440))
    made the point that the usual “variables as boxes” metaphor actually hinders the
    understanding of reference variables in object-oriented languages. Python variables
    are like reference variables in Java; a better metaphor is to think of variables
    as labels with names attached to objects. The next example and figure will help
    you understand why.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 1997年，我在麻省理工学院参加了一门关于Java的暑期课程。教授琳恩·斯坦^([1](ch06.html#idm46582451849440))指出，通常的“变量就像盒子”比喻实际上阻碍了理解面向对象语言中引用变量的理解。Python变量就像Java中的引用变量；一个更好的比喻是���变量视为附加到对象的名称的标签。下一个示例和图将帮助您理解为什么。
- en: '[Example 6-1](#ex_a_b_refs) is a simple interaction that the “variables as
    boxes” idea cannot explain. [Figure 6-1](#var-boxes-x-labels) illustrates why
    the box metaphor is wrong for Python, while sticky notes provide a helpful picture
    of how variables actually work.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-1](#ex_a_b_refs)是一个简单的互动，而“变量就像盒子”这个想法无法解释。[图 6-1](#var-boxes-x-labels)说明了为什么盒子的比喻对于Python是错误的，而便利贴提供了一个有助于理解变量实际工作方式的图像。'
- en: Example 6-1\. Variables `a` and `b` hold references to the same list, not copies
    of the list
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-1。变量`a`和`b`持有对同一列表的引用，而不是列表的副本
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO1-1)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO1-1)'
- en: Create a list `[1, 2, 3]` and bind the variable `a` to it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个列表`[1, 2, 3]`，并将变量`a`绑定到它。
- en: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO1-2)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO1-2)'
- en: Bind the variable `b` to the same value that `a` is referencing.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将变量`b`绑定到与`a`引用相同的值。
- en: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO1-3)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO1-3)'
- en: Modify the list referenced by `a`, by appending another item.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向`a`引用的列表追加另一个项目来修改列表。
- en: '[![4](assets/4.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO1-4)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO1-4)'
- en: You can see the effect via the `b` variable. If we think of `b` as a box that
    stored a copy of the `[1, 2, 3]` from the `a` box, this behavior makes no sense.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过变量`b`看到效果。如果我们把`b`看作是一个盒子，里面存放着从`a`盒子中复制的`[1, 2, 3]`，这种行为就毫无意义了。
- en: '![Boxes and labels diagram](assets/flpy_0601.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![盒子和标签图示](assets/flpy_0601.png)'
- en: Figure 6-1\. If you imagine variables are like boxes, you can’t make sense of
    assignment in Python; instead, think of variables as sticky notes, and [Example 6-1](#ex_a_b_refs)
    becomes easy to explain.
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-1。如果你把变量想象成箱子，就无法理解Python中的赋值；相反，把变量想象成便利贴，[示例6-1](#ex_a_b_refs)就变得容易解释了。
- en: Therefore, the `b = a` statement does not copy the contents of box `a` into
    box `b`. It attaches the label `b` to the object that already has the label `a`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`b = a`语句并不会复制箱子`a`的内容到箱子`b`中。它将标签`b`附加到已经有标签`a`的对象上。
- en: 'Prof. Stein also spoke about assignment in a very deliberate way. For example,
    when talking about a seesaw object in a simulation, she would say: “Variable *s*
    is assigned to the seesaw,” but never “The seesaw is assigned to variable *s*.”
    With reference variables, it makes much more sense to say that the variable is
    assigned to an object, and not the other way around. After all, the object is
    created before the assignment. [Example 6-2](#ex_var_assign_after) proves that
    the righthand side of an assignment happens first.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Stein教授也非常谨慎地谈到了赋值。例如，在谈论模拟中的一个跷跷板对象时，她会说：“变量*s*被赋给了跷跷板”，但从不说“跷跷板被赋给了变量*s*”。对于引用变量，更合理的说法是变量被赋给了对象，而不是反过来。毕竟，对象在赋值之前就已经创建了。[示例6-2](#ex_var_assign_after)证明了赋值的右侧先发生。
- en: 'Since the verb “to assign” is used in contradictory ways, a useful alternative
    is “to bind”: Python’s assignment statement `x = …` binds the `x` name to the
    object created or referenced on the righthand side. And the object must exist
    before a name can be bound to it, as [Example 6-2](#ex_var_assign_after) proves.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于动词“赋值”被以矛盾的方式使用，一个有用的替代方法是“绑定”：Python的赋值语句`x = …`将`x`名称绑定到右侧创建或引用的对象上。对象必须在名称绑定到它之前存在，正如[示例6-2](#ex_var_assign_after)所证明的那样。
- en: Example 6-2\. Variables are bound to objects only after the objects are created
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例6-2。只有在对象创建后，变量才会绑定到对象上。
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO2-1)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO2-1)'
- en: 'The output `Gizmo id: …` is a side effect of creating a `Gizmo` instance.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '输出`Gizmo id: …`是创建`Gizmo`实例的副作用。'
- en: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO2-2)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO2-2)'
- en: Multiplying a `Gizmo` instance will raise an exception.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 乘以`Gizmo`实例会引发异常。
- en: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO2-3)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO2-3)'
- en: Here is proof that a second `Gizmo` was actually instantiated before the multiplication
    was attempted.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有证据表明在尝试乘法之前实际上实例化了第二个`Gizmo`。
- en: '[![4](assets/4.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO2-4)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO2-4)'
- en: But variable `y` was never created, because the exception happened while the
    righthand side of the assignment was being evaluated.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 但变量`y`从未被创建，因为异常发生在赋值的右侧正在被评估时。
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'To understand an assignment in Python, read the righthand side first: that’s
    where the object is created or retrieved. After that, the variable on the left
    is bound to the object, like a label stuck to it. Just forget about the boxes.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解Python中的赋值，首先阅读右侧：那里是创建或检索对象的地方。之后，左侧的变量将绑定到对象上，就像贴在上面的标签一样。只需忘记箱子。
- en: Because variables are mere labels, nothing prevents an object from having several
    labels assigned to it. When that happens, you have *aliasing*, our next topic.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因为变量只是标签，所以一个对象可以有多个标签分配给它。当发生这种情况时，就会出现*别名*，这是我们下一个主题。
- en: Identity, Equality, and Aliases
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份、相等性和别名
- en: Lewis Carroll is the pen name of Prof. Charles Lutwidge Dodgson. Mr. Carroll
    is not only equal to Prof. Dodgson, they are one and the same. [Example 6-3](#ex_equal_and_same)
    expresses this idea in Python.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 路易斯·卡罗尔是查尔斯·卢特维奇·道奇森教授的笔名。卡罗尔先生不仅等同于道奇森教授，他们是一体的。[示例6-3](#ex_equal_and_same)用Python表达了这个想法。
- en: Example 6-3\. `charles` and `lewis` refer to the same object
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例6-3。`charles`和`lewis`指向同一个对象。
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO3-1)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO3-1)'
- en: '`lewis` is an alias for `charles`.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`lewis`是`charles`的别名。'
- en: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO3-2)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO3-2)'
- en: The `is` operator and the `id` function confirm it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`is`运算符和`id`函数证实了这一点。'
- en: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO3-3)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO3-3)'
- en: Adding an item to `lewis` is the same as adding an item to `charles`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 向`lewis`添加一个项目等同于向`charles`添加一个项目。
- en: However, suppose an impostor—let’s call him Dr. Alexander Pedachenko—claims
    he is Charles L. Dodgson, born in 1832\. His credentials may be the same, but
    Dr. Pedachenko is not Prof. Dodgson. [Figure 6-2](#alias_x_copy) illustrates this
    scenario.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，假设有一个冒名顶替者——我们称他为亚历山大·佩达琴科博士——声称自己是查尔斯·L·道奇森，出生于1832年。他的证件可能相同，但佩达琴科博士不是道奇森教授。[图6-2](#alias_x_copy)说明了这种情况。
- en: '![Alias x copy diagram](assets/flpy_0602.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![别名和复制示意图](assets/flpy_0602.png)'
- en: Figure 6-2\. `charles` and `lewis` are bound to the same object; `alex` is bound
    to a separate object of equal value.
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图6-2。`charles`和`lewis`绑定到同一个对象；`alex`绑定到一个相等值的单独对象。
- en: '[Example 6-4](#ex_equal_not_same) implements and tests the `alex` object depicted
    in [Figure 6-2](#alias_x_copy).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例6-4](#ex_equal_not_same)实现并测试了[图6-2](#alias_x_copy)中所示的`alex`对象。'
- en: Example 6-4\. `alex` and `charles` compare equal, but `alex` *is not* `charles`
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例6-4。`alex`和`charles`比较相等，但`alex`*不是*`charles`。
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO4-1)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO4-1)'
- en: '`alex` refers to an object that is a replica of the object assigned to `charles`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`alex`指的是一个与分配给`charles`的对象相同的对象的复制品。'
- en: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO4-2)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO4-2)'
- en: The objects compare equal because of the `__eq__` implementation in the `dict`
    class.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象之所以相等是因为`dict`类中的`__eq__`实现。
- en: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO4-3)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO4-3)'
- en: 'But they are distinct objects. This is the Pythonic way of writing the negative
    identity comparison: `a is not b`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但它们是不同的对象。这是写负身份比较的Pythonic方式：`a is not b`。
- en: '[Example 6-3](#ex_equal_and_same) is an example of *aliasing*. In that code,
    `lewis` and `charles` are aliases: two variables bound to the same object. On
    the other hand, `alex` is not an alias for `charles`: these variables are bound
    to distinct objects. The objects bound to `alex` and `charles` have the same *value*—that’s
    what `==` compares—but they have different identities.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-3](#ex_equal_and_same)是*别名*的一个例子。在那段代码中，`lewis`和`charles`是别名：两个变量绑定到同一个对象。另一方面，`alex`不是`charles`的别名：这些变量绑定到不同的对象。绑定到`alex`和`charles`的对象具有相同的*值*—这是`==`比较的内容—但它们具有不同的身份。'
- en: 'In *The Python Language Reference*, [“3.1\. Objects, values and types”](https://fpy.li/6-2)
    states:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Python语言参考*中，[“3.1\. 对象、值和类型”](https://fpy.li/6-2)中指出：
- en: An object’s identity never changes once it has been created; you may think of
    it as the object’s address in memory. The `is` operator compares the identity
    of two objects; the `id()` function returns an integer representing its identity.
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个对象的身份一旦创建就不会改变；您可以将其视为对象在内存中的地址。`is`运算符比较两个对象的身份；`id()`函数返回表示其身份的整数。
- en: The real meaning of an object’s ID is implementation dependent. In CPython,
    `id()` returns the memory address of the object, but it may be something else
    in another Python interpreter. The key point is that the ID is guaranteed to be
    a unique integer label, and it will never change during the life of the object.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的ID的真正含义取决于实现。在CPython中，`id()`返回对象的内存地址，但在另一个Python解释器中可能是其他内容。关键点是ID保证是唯一的整数标签，并且在对象的生命周期内永远不会更改。
- en: In practice, we rarely use the `id()` function while programming. Identity checks
    are most often done with the `is` operator, which compares the object IDs, so
    our code doesn’t need to call `id()` explicitly. Next, we’ll talk about `is` versus
    `==`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，我们编程时很少使用`id()`函数。通常使用`is`运算符进行身份检查，该运算符比较对象的ID，因此我们的代码不需要显式调用`id()`。接下来，我们将讨论`is`与`==`的区别。
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: For tech reviewer Leonardo Rochael, the most frequent use for `id()` is while
    debugging, when the `repr()` of two objects look alike, but you need to understand
    whether two references are aliases or point to separate objects. If the references
    are in different contexts—such as different stack frames—using the `is` operator
    may not be viable.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于技术审阅员Leonardo Rochael，最常见使用`id()`的情况是在调试时，当两个对象的`repr()`看起来相似，但您需要了解两个引用是别名还是指向不同的对象。如果引用在不同的上下文中—比如不同的堆栈帧—使用`is`运算符可能不可行。
- en: Choosing Between == and is
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择`==`和`is`之间
- en: The `==` operator compares the values of objects (the data they hold), while
    `is` compares their identities.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`==`运算符比较对象的值（它们持有的数据），而`is`比较它们的身份。'
- en: While programming, we often care more about values than object identities, so
    `==` appears more frequently than `is` in Python code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程时，我们通常更关心对象的值而不是对象的身份，因此在Python代码中，`==`比`is`出现得更频繁。
- en: 'However, if you are comparing a variable to a singleton, then it makes sense
    to use `is`. By far, the most common case is checking whether a variable is bound
    to `None`. This is the recommended way to do it:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您要将变量与单例进行比较，则使用`is`是有意义的。到目前为止，最常见的情况是检查变量是否绑定到`None`。这是建议的做法：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And the proper way to write its negation is:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 而其否定的正确方式是：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`None` is the most common singleton we test with `is`. Sentinel objects are
    another example of singletons we test with `is`. Here is one way to create and
    test a sentinel object:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`None`是我们用`is`测试的最常见的单例。哨兵对象是我们用`is`测试的另一个单例的例子。以下是创建和测试哨兵对象的一种方法：'
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `is` operator is faster than `==`, because it cannot be overloaded, so Python
    does not have to find and invoke special methods to evaluate it, and computing
    is as simple as comparing two integer IDs. In contrast, `a == b` is syntactic
    sugar for `a.__eq__(b)`. The `__eq__` method inherited from `object` compares
    object IDs, so it produces the same result as `is`. But most built-in types override
    `__eq__` with more meaningful implementations that actually take into account
    the values of the object attributes. Equality may involve a lot of processing—for
    example, when comparing large collections or deeply nested structures.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`is`运算符比`==`更快，因为它无法被重载，所以Python不必查找和调用特殊方法来评估它，计算就像比较两个整数ID一样简单。相反，`a == b`是`a.__eq__(b)`的语法糖。从`object`继承的`__eq__`方法比较对象ID，因此它产生与`is`相同的结果。但大多数内置类型使用更有意义的实现覆盖`__eq__`，实际上考虑对象属性的值。相等性可能涉及大量处理—例如，比较大型集合或深���嵌套结构时。'
- en: Warning
  id: totrans-90
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Usually we are more interested in object equality than identity. Checking for
    `None` is the *only* common use case for the `is` operator. Most other uses I
    see while reviewing code are wrong. If you are not sure, use `==`. It’s usually
    what you want, and also works with `None`—albeit not as fast.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们更关心对象的相等性而不是身份。检查`None`是`is`运算符的*唯一*常见用例。我在审查代码时看到的大多数其他用法都是错误的。如果不确定，请使用`==`。这通常是您想要的，并且也适用于`None`—尽管不如`is`快。
- en: To wrap up this discussion of identity versus equality, we’ll see that the famously
    immutable `tuple` is not as unchanging as you may expect.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下关于身份与相等性的讨论，我们会看到著名的不可变`tuple`并不像您期望的那样不变。
- en: The Relative Immutability of Tuples
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组的相对不可变性
- en: 'Tuples, like most Python collections—lists, dicts, sets, etc.—are containers:
    they hold references to objects.^([2](ch06.html#idm46582451310816)) If the referenced
    items are mutable, they may change even if the tuple itself does not. In other
    words, the immutability of tuples really refers to the physical contents of the
    `tuple` data structure (i.e., the references it holds), and does not extend to
    the referenced objects.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 元组，像大多数Python集合（列表、字典、集合等）一样，都是容器：它们保存对对象的引用。^([2](ch06.html#idm46582451310816))
    如果所引用的项是可变的，即使元组本身不变，它们也可能发生变化。换句话说，元组的不可变性实际上是指`tuple`数据结构的物理内容（即它保存的引用），而不是扩展到所引用的对象。
- en: '[Example 6-5](#ex_mutable_tuples) illustrates the situation in which the value
    of a tuple changes as a result of changes to a mutable object referenced in it.
    What can never change in a tuple is the identity of the items it contains.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-5](#ex_mutable_tuples)说明了元组的值因所引用的可变对象的更改而发生变化的情况。元组中永远不会改变的是它包含的项的标识。'
- en: Example 6-5\. `t1` and `t2` initially compare equal, but changing a mutable
    item inside tuple `t1` makes it different
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-5。`t1`和`t2`最初比较相等，但在元组`t1`内更改可变项后，它们变得不同
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO5-1)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO5-1)'
- en: '`t1` is immutable, but `t1[-1]` is mutable.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`t1`是不可变的，但`t1[-1]`是可变的。'
- en: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO5-2)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO5-2)'
- en: Build a tuple `t2` whose items are equal to those of `t1`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个元组`t2`，其项与`t1`的项相等。
- en: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO5-3)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO5-3)'
- en: Although distinct objects, `t1` and `t2` compare equal, as expected.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管是不同的对象，`t1`和`t2`比较相等，正如预期的那样。
- en: '[![4](assets/4.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO5-4)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO5-4)'
- en: Inspect the identity of the list at `t1[-1]`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`t1[-1]`列表的标识。
- en: '[![5](assets/5.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO5-5)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO5-5)'
- en: Modify the `t1[-1]` list in place.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在原地修改`t1[-1]`列表。
- en: '[![6](assets/6.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO5-6)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO5-6)'
- en: The identity of `t1[-1]` has not changed, only its value.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`t1[-1]`的标识没有改变，只是它的值改变了。'
- en: '[![7](assets/7.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO5-7)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO5-7)'
- en: '`t1` and `t2` are now different.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`t1`和`t2`现在是不同的。'
- en: This relative immutability of tuples is behind the riddle [“A += Assignment
    Puzzler”](ch02.html#tuple_puzzler). It’s also the reason why some tuples are unhashable,
    as we’ve seen in [“What Is Hashable”](ch03.html#what_is_hashable).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这种相对不可变性是谜题[“A += Assignment Puzzler”](ch02.html#tuple_puzzler)背后的原因。这也是为什么一些元组是不可哈希的，正如我们在[“什么是可哈希的”](ch03.html#what_is_hashable)中所看到的。
- en: The distinction between equality and identity has further implications when
    you need to copy an object. A copy is an equal object with a different ID. But
    if an object contains other objects, should the copy also duplicate the inner
    objects, or is it OK to share them? There’s no single answer. Read on for a discussion.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要复制对象时，相等性和标识之间的区别会产生进一步的影响。副本是一个具有不同ID的相等对象。但是，如果一个对象包含其他对象，副本是否也应该复制内部对象，还是可以共享它们？这并没有单一的答案。继续阅读以了解讨论。
- en: Copies Are Shallow by Default
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认情况下是浅拷贝
- en: 'The easiest way to copy a list (or most built-in mutable collections) is to
    use the built-in constructor for the type itself. For example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 复制列表（或大多数内置的可变集合）的最简单方法是使用类型本身的内置构造函数。例如：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO6-1)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO6-1)'
- en: '`list(l1)` creates a copy of `l1`.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`list(l1)`创建了`l1`的一个副本。'
- en: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO6-2)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO6-2)'
- en: The copies are equal…
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些拷贝是相等的…
- en: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO6-3)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO6-3)'
- en: …but refer to two different objects.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: …但是指向两个不同的对象。
- en: For lists and other mutable sequences, the shortcut `l2 = l1[:]` also makes
    a copy.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列表和其他可变序列，使用快捷方式`l2 = l1[:]`也会创建一个副本。
- en: However, using the constructor or `[:]` produces a *shallow copy* (i.e., the
    outermost container is duplicated, but the copy is filled with references to the
    same items held by the original container). This saves memory and causes no problems
    if all the items are immutable. But if there are mutable items, this may lead
    to unpleasant surprises.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用构造函数或`[:]`会产生一个*浅拷贝*（即，最外层容器被复制，但副本填充的是对原始容器持有的相同��的引用）。这节省内存，并且如果所有项都是不可变的，则不会出现问题。但是，如果有可变项，这可能会导致令人不快的惊喜。
- en: In [Example 6-6](#ex_shallow_copy), we create a shallow copy of a list containing
    another list and a tuple, and then make changes to see how they affect the referenced
    objects.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 6-6](#ex_shallow_copy)中，我们创建了一个包含另一个列表和一个元组的列表的浅拷贝，然后进行更改以查看它们对所引用对象的影响。
- en: Tip
  id: totrans-126
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you have a connected computer on hand, I highly recommend watching the interactive
    animation for [Example 6-6](#ex_shallow_copy) at the [Online Python Tutor](https://fpy.li/6-3).
    As I write this, direct linking to a prepared example at *pythontutor.com* is
    not working reliably, but the tool is awesome, so taking the time to copy and
    paste the code is worthwhile.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你手头有一台连接的电脑，我强烈推荐观看[示例 6-6](#ex_shallow_copy)的交互式动画，网址为[Online Python Tutor](https://fpy.li/6-3)。就我所知，直接链接到*pythontutor.com*上的准备好的示例并不总是可靠，但这个工具非常棒，所以抽出时间复制粘贴代码是值得的。
- en: Example 6-6\. Making a shallow copy of a list containing another list; copy
    and paste this code to see it animated at the Online Python Tutor
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-6\. 对包含另一个列表的列表进行浅复制；复制并粘贴此代码以在Online Python Tutor中查看动画
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO7-1)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO7-1)'
- en: '`l2` is a shallow copy of `l1`. This state is depicted in [Figure 6-3](#shallow_copy1).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`l2`是`l1`的浅复制。这个状态在[图 6-3](#shallow_copy1)中描述。'
- en: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO7-2)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO7-2)'
- en: Appending `100` to `l1` has no effect on `l2`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在`l1`后添加`100`对`l2`没有影响。
- en: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO7-3)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO7-3)'
- en: Here we remove `55` from the inner list `l1[1]`. This affects `l2` because `l2[1]`
    is bound to the same list as `l1[1]`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们从内部列表`l1[1]`中移除`55`。这会影响到`l2`，因为`l2[1]`与`l1[1]`绑定到同一个列表。
- en: '[![4](assets/4.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO7-4)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO7-4)'
- en: For a mutable object like the list referred by `l2[1]`, the operator `+=` changes
    the list in place. This change is visible at `l1[1]`, which is an alias for `l2[1]`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像`l2[1]`引用的列表这样的可变对象，运算符`+=`会就地修改列表。这种变化在`l1[1]`上可见，因为`l1[1]`是`l2[1]`的别名。
- en: '[![5](assets/5.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO7-5)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO7-5)'
- en: '`+=` on a tuple creates a new tuple and rebinds the variable `l2[2]` here.
    This is the same as doing `l2[2] = l2[2] + (10, 11)`. Now the tuples in the last
    position of `l1` and `l2` are no longer the same object. See [Figure 6-4](#shallow_copy2).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在元组上使用`+=`会创建一个新的元组并重新绑定变量`l2[2]`。这等同于执行`l2[2] = l2[2] + (10, 11)`。现在`l1`和`l2`中最后位置的元组不再是同一个对象。参见[图
    6-4](#shallow_copy2)。
- en: '![References diagram](assets/flpy_0603.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![引用图示](assets/flpy_0603.png)'
- en: Figure 6-3\. Program state immediately after the assignment `l2 = list(l1)`
    in [Example 6-6](#ex_shallow_copy). `l1` and `l2` refer to distinct lists, but
    the lists share references to the same inner list object `[66, 55, 44]` and tuple
    `(7, 8, 9)`. (Diagram generated by the Online Python Tutor.)
  id: totrans-141
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-3\. 在[示例 6-6](#ex_shallow_copy)中赋值`l2 = list(l1)`后的程序状态。`l1`和`l2`指向不同的列表，但这些列表共享对同一内部列表对象`[66,
    55, 44]`和元组`(7, 8, 9)`的引用。 (图示由Online Python Tutor生成。)
- en: The output of [Example 6-6](#ex_shallow_copy) is [Example 6-7](#ex_shallow_copy_out),
    and the final state of the objects is depicted in [Figure 6-4](#shallow_copy2).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-6](#ex_shallow_copy)的输出是[示例 6-7](#ex_shallow_copy_out)，对象的最终状态在[图 6-4](#shallow_copy2)中描述。'
- en: Example 6-7\. Output of [Example 6-6](#ex_shallow_copy)
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-7\. [示例 6-6](#ex_shallow_copy)的输出
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![References diagram](assets/flpy_0604.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![引用图示](assets/flpy_0604.png)'
- en: 'Figure 6-4\. Final state of `l1` and `l2`: they still share references to the
    same list object, now containing `[66, 44, 33, 22]`, but the operation `l2[2]
    += (10, 11)` created a new tuple with content `(7, 8, 9, 10, 11)`, unrelated to
    the tuple `(7, 8, 9)` referenced by `l1[2]`. (Diagram generated by the Online
    Python Tutor.)'
  id: totrans-146
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-4\. `l1`和`l2`的最终状态：它们仍然共享对同一列表对象的引用，现在包含`[66, 44, 33, 22]`，但操作`l2[2] +=
    (10, 11)`创建了一个新的元组，内容为`(7, 8, 9, 10, 11)`，与`l1[2]`引用的元组`(7, 8, 9)`无关。 (图示由Online
    Python Tutor生成。)
- en: It should be clear now that shallow copies are easy to make, but they may or
    may not be what you want. How to make deep copies is our next topic.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该清楚了，浅复制很容易实现，但可能并不是你想要的。如何进行深复制是我们下一个话题。
- en: Deep and Shallow Copies of Arbitrary Objects
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任意对象的深复制和浅复制
- en: Working with shallow copies is not always a problem, but sometimes you need
    to make deep copies (i.e., duplicates that do not share references of embedded
    objects). The `copy` module provides the `deepcopy` and `copy` functions that
    return deep and shallow copies of arbitrary objects.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浅复制并不总是问题，但有时你需要进行深复制（即不共享嵌入对象引用的副本）。`copy`模块提供了`deepcopy`和`copy`函数，用于返回任意对象的深复制和浅复制。
- en: To illustrate the use of `copy()` and `deepcopy()`, [Example 6-8](#ex_bus1)
    defines a simple class, `Bus`, representing a school bus that is loaded with passengers
    and then picks up or drops off passengers on its route.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明`copy()`和`deepcopy()`的用法，[示例 6-8](#ex_bus1)定义了一个简单的类`Bus`，代表一辆载有乘客的校车，然后在路线上接送乘客。
- en: Example 6-8\. Bus picks up and drops off passengers
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-8\. 公共汽车接送乘客
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, in the interactive [Example 6-9](#ex_bus1_console), we will create a `bus`
    object (`bus1`) and two clones—a shallow copy (`bus2`) and a deep copy (`bus3`)—to
    observe what happens as `bus1` drops off a student.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在交互式[示例 6-9](#ex_bus1_console)中，我们将创建一个`bus`对象（`bus1`）和两个克隆体—一个浅复制（`bus2`）和一个深复制（`bus3`）—来观察当`bus1`放下一个学生时会发生什么。
- en: Example 6-9\. Effects of using `copy` versus `deepcopy`
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-9\. 使用`copy`和`deepcopy`的效果
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO8-1)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO8-1)'
- en: Using `copy` and `deepcopy`, we create three distinct `Bus` instances.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`copy`和`deepcopy`，我们创建了三个不同的`Bus`实例。
- en: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO8-2)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO8-2)'
- en: After `bus1` drops `'Bill'`, he is also missing from `bus2`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在`bus1`删除`'Bill'`后，`bus2`也缺少了他。
- en: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO8-3)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO8-3)'
- en: Inspection of the `passengers` attributes shows that `bus1` and `bus2` share
    the same list object, because `bus2` is a shallow copy of `bus1`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`passengers`属性显示`bus1`和`bus2`共享相同的列表对象，因为`bus2`是`bus1`的浅拷贝。
- en: '[![4](assets/4.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO8-4)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO8-4)'
- en: '`bus3` is a deep copy of `bus1`, so its `passengers` attribute refers to another
    list.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`bus3`是`bus1`的深拷贝，因此其`passengers`属性引用另一个列表。'
- en: Note that making deep copies is not a simple matter in the general case. Objects
    may have cyclic references that would cause a naïve algorithm to enter an infinite
    loop. The `deepcopy` function remembers the objects already copied to handle cyclic
    references gracefully. This is demonstrated in [Example 6-10](#ex_cycle1).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在一般情况下，制作深拷贝并不是一件简单的事情。对象可能具有导致天真算法陷入无限循环的循环引用。`deepcopy`函数记住已复制的对象，以优雅地处理循环引用。这在[示例6-10](#ex_cycle1)中有演示。
- en: 'Example 6-10\. Cyclic references: `b` refers to `a`, and then is appended to
    `a`; `deepcopy` still manages to copy `a`'
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例6-10。循环引用：`b`引用`a`，然后附加到`a`；`deepcopy`仍然成功复制`a`
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Also, a deep copy may be too deep in some cases. For example, objects may refer
    to external resources or singletons that should not be copied. You can control
    the behavior of both `copy` and `deepcopy` by implementing the `__copy__()` and
    `__deepcopy__()` special methods, as described in the [`copy` module documentation](https://fpy.li/6-4).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在某些情况下，深拷贝可能太深。例如，对象可能引用不应复制的外部资源或单例。您可以通过实现`__copy__()`和`__deepcopy__()`特殊方法来控制`copy`和`deepcopy`的行为，如[`copy`模块文档](https://fpy.li/6-4)中所述。
- en: The sharing of objects through aliases also explains how parameter passing works
    in Python, and the problem of using mutable types as parameter defaults. These
    issues will be covered next.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过别名共享对象也解释了Python中参数传递的工作原理，以及在参数默认值中使用可变类型的问题。接下来将介绍这些问题。
- en: Function Parameters as References
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数参数作为引用
- en: The only mode of parameter passing in Python is *call by sharing*. That is the
    same mode used in most object-oriented languages, including JavaScript, Ruby,
    and Java (this applies to Java reference types; primitive types use call by value).
    Call by sharing means that each formal parameter of the function gets a copy of
    each reference in the arguments. In other words, the parameters inside the function
    become aliases of the actual arguments.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的唯一参数传递模式是*共享调用*。这是大多数面向对象语言使用的模式，包括JavaScript、Ruby和Java（这适用于Java引用类型；基本类型使用按值调用）。共享调用意味着函数的每个形式参数都会得到每个参数中引用的副本。换句话说，函数内部的参数成为实际参数的别名。
- en: The result of this scheme is that a function may change any mutable object passed
    as a parameter, but it cannot change the identity of those objects (i.e., it cannot
    altogether replace an object with another). [Example 6-11](#ex_param_pass) shows
    a simple function using `+=` on one of its parameters. As we pass numbers, lists,
    and tuples to the function, the actual arguments passed are affected in different
    ways.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方案的结果是函数可以更改作为参数传递的任何可变对象，但它不能更改这些对象的标识（即，它不能完全用另一个对象替换对象）。[示例6-11](#ex_param_pass)展示了一个简单函数在其中一个参数上使用`+=`的情况。当我们将数字、列表和元组传递给函数时，传递的实际参数会以不同的方式受到影响。
- en: Example 6-11\. A function may change any mutable object it receives
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例6-11。一个函数可以更改它接收到的任何可变对象
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO9-1)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO9-1)'
- en: The number `x` is unchanged.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 数字`x`保持不变。
- en: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO9-2)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO9-2)'
- en: The list `a` is changed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 列表`a`已更改。
- en: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO9-3)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO9-3)'
- en: The tuple `t` is unchanged.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 元组`t`保持不变。
- en: Another issue related to function parameters is the use of mutable values for
    defaults, as discussed next.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数参数相关的另一个问题是在默认情况下使用可变值，如下所述。
- en: 'Mutable Types as Parameter Defaults: Bad Idea'
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将可变类型用作参数默认值：不好的主意
- en: Optional parameters with default values are a great feature of Python function
    definitions, allowing our APIs to evolve while remaining backward compatible.
    However, you should avoid mutable objects as default values for parameters.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 具有默认值的可选参数是Python函数定义的一个很好的特性，允许我们的API在保持向后兼容的同时发展。但是，应避免将可变对象作为参数的默认值。
- en: To illustrate this point, in [Example 6-12](#ex_haunted_bus), we take the `Bus`
    class from [Example 6-8](#ex_bus1) and change its `__init__` method to create
    `HauntedBus`. Here we tried to be clever, and instead of having a default value
    of `passengers=None`, we have `passengers=[]`, thus avoiding the `if` in the previous
    `__init__`. This “cleverness” gets us into trouble.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，在[示例6-12](#ex_haunted_bus)中，我们从[示例6-8](#ex_bus1)中获取`Bus`类，并将其`__init__`方法更改为创建`HauntedBus`。在这里，我们试图聪明地避免在以前的`__init__`中使用`passengers=None`的默认值，而是使用`passengers=[]`，从而避免了`if`。这种“聪明”让我们陷入了麻烦。
- en: Example 6-12\. A simple class to illustrate the danger of a mutable default
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例6-12。一个简单的类来说明可变默认值的危险
- en: '[PRE15]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO10-1)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO10-1)'
- en: When the `passengers` argument is not passed, this parameter is bound to the
    default list object, which is initially empty.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当未传递`passengers`参数时，此参数绑定到默认的空列表对象。
- en: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO10-2)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO10-2)'
- en: This assignment makes `self.passengers` an alias for `passengers`, which is
    itself an alias for the default list, when no `passengers` argument is given.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个赋值使得`self.passengers`成为`passengers`的别名，而`passengers`本身是默认列表的别名，当没有传递`passengers`参数时。
- en: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO10-3)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO10-3)'
- en: When the methods `.remove()` and `.append()` are used with `self.passengers`,
    we are actually mutating the default list, which is an attribute of the function
    object.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`.remove()`和`.append()`方法与`self.passengers`一起使用时，实际上是在改变函数对象的属性的默认列表。
- en: '[Example 6-13](#demo_haunted_bus) shows the eerie behavior of the `HauntedBus`.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-13](#demo_haunted_bus)展示了`HauntedBus`的诡异行为。'
- en: Example 6-13\. Buses haunted by ghost passengers
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-13\. 被幽灵乘客缠身的公交车
- en: '[PRE16]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO11-1)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO11-1)'
- en: '`bus1` starts with a two-passenger list.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`bus1`从一个有两名乘客的列表开始。'
- en: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO11-2)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO11-2)'
- en: 'So far, so good: no surprises with `bus1`.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`bus1`没有什么意外。
- en: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO11-3)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO11-3)'
- en: '`bus2` starts empty, so the default empty list is assigned to `self.passengers`.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`bus2`从空开始，所以默认的空列表被分配给了`self.passengers`。'
- en: '[![4](assets/4.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO11-4)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO11-4)'
- en: '`bus3` also starts empty, again the default list is assigned.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`bus3`也是空的，再次分配了默认列表。'
- en: '[![5](assets/5.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO11-5)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO11-5)'
- en: The default is no longer empty!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值不再是空的！
- en: '[![6](assets/6.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO11-6)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO11-6)'
- en: Now `Dave`, picked by `bus3`, appears in `bus2`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在被`bus3`选中的`Dave`出现在了`bus2`中。
- en: '[![7](assets/7.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO11-7)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO11-7)'
- en: 'The problem: `bus2.passengers` and `bus3.passengers` refer to the same list.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`bus2.passengers`和`bus3.passengers`指向同一个列表。
- en: '[![8](assets/8.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO11-8)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO11-8)'
- en: But `bus1.passengers` is a distinct list.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 但`bus1.passengers`是一个独立的列表。
- en: The problem is that `HauntedBus` instances that don’t get an initial passenger
    list end up sharing the same passenger list among themselves.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于没有初始乘客列表的`HauntedBus`实例最终共享同一个乘客列表。
- en: Such bugs may be subtle. As [Example 6-13](#demo_haunted_bus) demonstrates,
    when a `HauntedBus` is instantiated with passengers, it works as expected. Strange
    things happen only when a `HauntedBus` starts empty, because then `self.passengers`
    becomes an alias for the default value of the `passengers` parameter. The problem
    is that each default value is evaluated when the function is defined—i.e., usually
    when the module is loaded—and the default values become attributes of the function
    object. So if a default value is a mutable object, and you change it, the change
    will affect every future call of the function.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这类bug可能很微妙。正如[示例 6-13](#demo_haunted_bus)所展示的，当使用乘客实例化`HauntedBus`时，它的表现如预期。只有当`HauntedBus`从空开始时才会发生奇怪的事情，因为这时`self.passengers`变成了`passengers`参数的默认值的别名。问题在于每个默认值在函数定义时被计算—即通常在模块加载时—并且默认值变成函数对象的属性。因此，如果默认值是一个可变对象，并且你对其进行更改，这种更改将影响到函数的每次未来调用。
- en: 'After running the lines in [Example 6-13](#demo_haunted_bus), you can inspect
    the `HauntedBus.__init__` object and see the ghost students haunting its `__defaults__`
    attribute:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行[示例 6-13](#demo_haunted_bus)中的代码后，你可以检查`HauntedBus.__init__`对象，并看到幽灵学生缠绕在其`__defaults__`属性中：
- en: '[PRE17]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we can verify that `bus2.passengers` is an alias bound to the first
    element of the `HauntedBus.__init__.__defaults__` attribute:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以验证`bus2.passengers`是绑定到`HauntedBus.__init__.__defaults__`属性的第一个元素的别名：
- en: '[PRE18]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The issue with mutable defaults explains why `None` is commonly used as the
    default value for parameters that may receive mutable values. In [Example 6-8](#ex_bus1),
    `__init__` checks whether the `passengers` argument is `None`. If it is, `self.passengers`
    is bound to a new empty list. If `passengers` is not `None`, the correct implementation
    binds a copy of that argument to `self.passengers`. The next section explains
    why copying the argument is a good practice.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 可变默认值的问题解释了为什么`None`通常被用作可能接收可变值的参数的默认值。在[示例 6-8](#ex_bus1)中，`__init__`检查`passengers`参数是否为`None`。如果是，`self.passengers`绑定到一个新的空列表。如果`passengers`不是`None`，正确的实现将该参数的副本绑定到`self.passengers`。下一节将解释为什么复制参数是一个好的实践。
- en: Defensive Programming with Mutable Parameters
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用可变参数进行防御性编程
- en: When you are coding a function that receives a mutable parameter, you should
    carefully consider whether the caller expects the argument passed to be changed.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写一个接收可变参数的函数时，你应该仔细考虑调用者是否希望传递的参数被更改。
- en: For example, if your function receives a `dict` and needs to modify it while
    processing it, should this side effect be visible outside of the function or not?
    Actually it depends on the context. It’s really a matter of aligning the expectation
    of the coder of the function and that of the caller.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的函数接收一个`dict`并在处理过程中需要修改它，那么这种副作用是否应该在函数外部可见？实际上这取决于上下文。这实际上是对函数编写者和调用者期望的一种调整。
- en: The last bus example in this chapter shows how a `TwilightBus` breaks expectations
    by sharing its passenger list with its clients. Before studying the implementation,
    see in [Example 6-14](#demo_twilight_bus) how the `TwilightBus` class works from
    the perspective of a client of the class.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中最后一个公交车示例展示了`TwilightBus`如何通过与其客户共享乘客列表来打破期望。在研究实现之前，看看[示例 6-14](#demo_twilight_bus)中`TwilightBus`类如何从类的客户的角度工作。
- en: Example 6-14\. Passengers disappear when dropped by a `TwilightBus`
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-14。当被`TwilightBus`放下时，乘客消失了
- en: '[PRE19]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO12-1)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO12-1)'
- en: '`basketball_team` holds five student names.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`basketball_team`拥有五个学生名字。'
- en: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO12-2)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO12-2)'
- en: A `TwilightBus` is loaded with the team.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`TwilightBus`装载着球队。
- en: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO12-3)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO12-3)'
- en: The `bus` drops one student, then another.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 公交车放下一个学生，然后又一个。
- en: '[![4](assets/4.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO12-4)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO12-4)'
- en: The dropped passengers vanished from the basketball team!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 被放下的乘客从篮球队中消失了！
- en: '`TwilightBus` violates the “Principle of least astonishment,” a best practice
    of interface design.^([3](ch06.html#idm46582449598144)) It surely is astonishing
    that when the bus drops a student, their name is removed from the basketball team
    roster.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`TwilightBus`违反了“最少惊讶原则”，这是接口设计的最佳实践。^([3](ch06.html#idm46582449598144)) 当公交车放下一个学生时，他们的名字从篮球队名单中被移除，这确实令人惊讶。'
- en: '[Example 6-15](#ex_twilight_bus) is the implementation `TwilightBus` and an
    explanation of the problem.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-15](#ex_twilight_bus)是`TwilightBus`的实现以及问题的解释。'
- en: Example 6-15\. A simple class to show the perils of mutating received arguments
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-15。一个简单的类，展示了修改接收参数的危险性
- en: '[PRE20]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO13-1)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO13-1)'
- en: Here we are careful to create a new empty list when `passengers` is `None`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当`passengers`为`None`时，我们小心地创建一个新的空列表。
- en: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO13-2)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO13-2)'
- en: However, this assignment makes `self.passengers` an alias for `passengers`,
    which is itself an alias for the actual argument passed to `__init__` (i.e., `basketball_team`
    in [Example 6-14](#demo_twilight_bus)).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个赋值使`self.passengers`成为`passengers`的别名，而`passengers`本身是传递给`__init__`的实际参数的别名（即[示例
    6-14](#demo_twilight_bus)中的`basketball_team`）。
- en: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO13-3)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO13-3)'
- en: When the methods `.remove()` and `.append()` are used with `self.passengers`,
    we are actually mutating the original list received as an argument to the constructor.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`.remove()`和`.append()`方法与`self.passengers`一起使用时，实际上是在修改作为构造函数参数传递的原始列表。
- en: 'The problem here is that the bus is aliasing the list that is passed to the
    constructor. Instead, it should keep its own passenger list. The fix is simple:
    in `__init__`, when the `passengers` parameter is provided, `self.passengers`
    should be initialized with a copy of it, as we did correctly in [Example 6-8](#ex_bus1):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是公交车别名化了传递给构造函数的列表。相反，它应该保留自己的乘客列表。修复方法很简单：在`__init__`中，当提供`passengers`参数时，应该用其副本初始化`self.passengers`，就像我们在[示例
    6-8](#ex_bus1)中正确做的那样：
- en: '[PRE21]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO14-1)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO14-1)'
- en: Make a copy of the `passengers` list, or convert it to a `list` if it’s not
    one.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 复制`passengers`列表，或者如果它不是列表，则将其转换为`list`。
- en: 'Now our internal handling of the passenger list will not affect the argument
    used to initialize the bus. As a bonus, this solution is more flexible: now the
    argument passed to the `passengers` parameter may be a `tuple` or any other iterable,
    like a `set` or even database results, because the `list` constructor accepts
    any iterable. As we create our own list to manage, we ensure that it supports
    the necessary `.remove()` and `.append()` operations we use in the `.pick()` and
    `.drop()` methods.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对乘客列表的内部处理不会影响用于初始化公��车的参数。作为一个额外的好处，这个解决方案更加灵活：现在传递给`passengers`参数的参数可以是一个`tuple`或任何其他可迭代对象，比如一个`set`甚至是数据库结果，因为`list`构造函数接受任何可迭代对象。当我们创建自己的列表来管理时，我们确保它支持我们在`.pick()`和`.drop()`方法中使用的必要的`.remove()`和`.append()`操作。
- en: Tip
  id: totrans-247
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'Unless a method is explicitly intended to mutate an object received as an argument,
    you should think twice before aliasing the argument object by simply assigning
    it to an instance variable in your class. If in doubt, make a copy. Your clients
    will be happier. Of course, making a copy is not free: there is a cost in CPU
    and memory. However, an API that causes subtle bugs is usually a bigger problem
    than one that is a little slower or uses more resources.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 除非一个方法明确意图修改作为参数接收的对象，否则在类中简单地将其分配给实例变量会导致别名化参数对象。如果有疑问，请复制。你的客户会更加满意。当然，复制并非免费：在CPU和内存方面会有成本。然而，导致微妙错误的API通常比稍慢或使用更多资源的API更大的问题。
- en: 'Now let’s talk about one of the most misunderstood of Python’s statements:
    `del`.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们谈谈 Python 语句中最被误解的之一：`del`。
- en: del and Garbage Collection
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: del 和 垃圾回收
- en: Objects are never explicitly destroyed; however, when they become unreachable
    they may be garbage-collected.
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对象永远不会被显式销毁；然而，当它们变得不可达时，它们可能被垃圾回收。
- en: ''
  id: totrans-252
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “Data Model” chapter of *The Python Language Reference*
  id: totrans-253
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*The Python Language Reference* 中 “Data Model” 章节'
- en: The first strange fact about `del` is that it’s not a function, it’s a statement.
    We write `del x` and not `del(x)`—although the latter also works, but only because
    the expressions `x` and `(x)` usually mean the same thing in Python.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`del` 的第一个奇怪之处在于它不是一个函数，而是一个语句。我们写 `del x` 而不是 `del(x)`—尽管后者也可以工作，但只是因为在 Python
    中表达式 `x` 和 `(x)` 通常表示相同的东西。'
- en: The second surprising fact is that `del` deletes references, not objects. Python’s
    garbage collector may discard an object from memory as an indirect result of `del`,
    if the deleted variable was the last reference to the object. Rebinding a variable
    may also cause the number of references to an object to reach zero, causing its
    destruction.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个令人惊讶的事实是 `del` 删除的是引用，而不是对象。Python 的垃圾收集器可能会间接地将对象从内存中丢弃，作为 `del` 的间接结果，如果被删除的变量是对象的最后一个引用。重新绑定一个变量也可能导致对象的引用数达到零，从而导致其销毁。
- en: '[PRE22]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO15-1)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO15-1)'
- en: Create object `[1, 2]` and bind `a` to it.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 创建对象 `[1, 2]` 并将 `a` 绑定到它。
- en: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO15-2)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO15-2)'
- en: Bind `b` to the same `[1, 2]` object.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `b` 绑定到相同的 `[1, 2]` 对象。
- en: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO15-3)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO15-3)'
- en: Delete reference `a`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 删除引用 `a`。
- en: '[![4](assets/4.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO15-4)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO15-4)'
- en: '`[1, 2]` was not affected, because `b` still points to it.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`[1, 2]` 没有受到影响，因为 `b` 仍然指向它。'
- en: '[![5](assets/5.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO15-5)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO15-5)'
- en: Rebinding `b` to a different object removes the last remaining reference to
    `[1, 2]`. Now the garbage collector can discard that object.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `b` 重新绑定到不同的对象会移除对 `[1, 2]` 的最后一个引用。现在垃圾收集器可以丢弃该对象。
- en: Warning
  id: totrans-267
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: There is a `__del__` special method, but it does not cause the disposal of the
    instance, and should not be called by your code. `__del__` is invoked by the Python
    interpreter when the instance is about to be destroyed to give it a chance to
    release external resources. You will seldom need to implement `__del__` in your
    own code, yet some Python programmers spend time coding it for no good reason.
    The proper use of `__del__` is rather tricky. See the [`__del__` special method
    documentation](https://fpy.li/6-6) in the “Data Model” chapter of *The Python
    Language Reference*.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个 `__del__` 特殊方法，但它不会导致实例的销毁，并且不应该被您的代码调用。`__del__` 在实例即将被销毁时由 Python 解释器调用，以便让它有机会释放外部资源。您很少需要在自己的代码中实现
    `__del__`，但一些 Python 程序员却花时间编写它却没有好的理由。正确使用 `__del__` 是相当棘手的。请参阅 *The Python Language
    Reference* 中 “Data Model” 章节的 [`__del__` 特殊方法文档](https://fpy.li/6-6)。
- en: 'In CPython, the primary algorithm for garbage collection is reference counting.
    Essentially, each object keeps count of how many references point to it. As soon
    as that *refcount* reaches zero, the object is immediately destroyed: CPython
    calls the `__del__` method on the object (if defined) and then frees the memory
    allocated to the object. In CPython 2.0, a generational garbage collection algorithm
    was added to detect groups of objects involved in reference cycles—which may be
    unreachable even with outstanding references to them, when all the mutual references
    are contained within the group. Other implementations of Python have more sophisticated
    garbage collectors that do not rely on reference counting, which means the `__del__`
    method may not be called immediately when there are no more references to the
    object. See [“PyPy, Garbage Collection, and a Deadlock”](https://fpy.li/6-7) by
    A. Jesse Jiryu Davis for discussion of improper and proper use of `__del__`.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CPython 中，垃圾回收的主要算法是引用计数。基本上，每个对象都会记录指向它的引用计数。一旦该 *refcount* 达到零，对象立即被销毁：CPython
    调用对象的 `__del__` 方法（如果定义了）然后释放为对象分配的内存。在 CPython 2.0 中，添加了一种分代垃圾回收算法，用于检测涉及引用循环的对象组—即使有指向它们的未解除引用，当所有相互引用都包含在组内时。Python
    的其他实现具有更复杂的垃圾收集器，不依赖于引用计数，这意味着当没有更多引用指向对象时，`__del__` 方法可能不会立即被调用。请参阅 A. Jesse
    Jiryu Davis 的 [“PyPy、垃圾回收和死锁”](https://fpy.li/6-7) 讨论 `__del__` 的不当和适当使用。
- en: To demonstrate the end of an object’s life, [Example 6-16](#ex_finalize) uses
    `weakref.finalize` to register a callback function to be called when an object
    is destroyed.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示对象生命周期的结束，[示例 6-16](#ex_finalize) 使用 `weakref.finalize` 注册一个回调函数，当对象被销毁时将被调用。
- en: Example 6-16\. Watching the end of an object when no more references point to
    it
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-16\. 当没有更多引用指向对象时观察对象结束
- en: '[PRE23]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO16-1)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO16-1)'
- en: '`s1` and `s2` are aliases referring to the same set, `{1, 2, 3}`.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`s1` 和 `s2` 是指向相同集合 `{1, 2, 3}` 的别名。'
- en: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO16-2)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO16-2)'
- en: This function must not be a bound method of the object about to be destroyed
    or otherwise hold a reference to it.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数不得是即将被销毁的对象的绑定方法或以其他方式保留对它的引用。
- en: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO16-3)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO16-3)'
- en: Register the `bye` callback on the object referred by `s1`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在`s1`引用的对象上注册`bye`回调。
- en: '[![4](assets/4.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO16-4)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO16-4)'
- en: The `.alive` attribute is `True` before the `finalize` object is called.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`finalize`对象之前，`.alive`属性为`True`。
- en: '[![5](assets/5.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO16-5)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO16-5)'
- en: As discussed, `del` did not delete the object, just the `s1` reference to it.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 正如讨论的那样，`del`并没有删除对象，只是删除了对它的`s1`引用。
- en: '[![6](assets/6.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO16-6)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO16-6)'
- en: Rebinding the last reference, `s2`, makes `{1, 2, 3}` unreachable. It is destroyed,
    the `bye` callback is invoked, and `ender.alive` becomes `False`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 重新绑定最后一个引用`s2`会使`{1, 2, 3}`变得不可访问。它被销毁，`bye`回调被调用，`ender.alive`变为`False`。
- en: The point of [Example 6-16](#ex_finalize) is to make explicit that `del` does
    not delete objects, but objects may be deleted as a consequence of being unreachable
    after `del` is used.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-16](#ex_finalize) 的重点在于明确`del`并不会删除对象，但对象可能在使用`del`后变得不可访问而被删除。'
- en: You may be wondering why the `{1, 2, 3}` object was destroyed in [Example 6-16](#ex_finalize).
    After all, the `s1` reference was passed to the `finalize` function, which must
    have held on to it in order to monitor the object and invoke the callback. This
    works because `finalize` holds a *weak reference* to `{1, 2, 3}`. Weak references
    to an object do not increase its reference count. Therefore, a weak reference
    does not prevent the target object from being garbage collected. Weak references
    are useful in caching applications because you don’t want the cached objects to
    be kept alive just because they are referenced by the cache.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么在[示例 6-16](#ex_finalize)中`{1, 2, 3}`对象被销毁。毕竟，`s1`引用被传递给`finalize`函数，该函数必须保持对它的引用以便监视对象并调用回调。这是因为`finalize`持有对`{1,
    2, 3}`的*弱引用*。对对象的弱引用不会增加其引用计数。因此，弱引用不会阻止目标对象被垃圾回收。弱引用在缓存应用中很有用，因为你不希望缓存的对象因为被缓存引用而保持活动状态。
- en: Note
  id: totrans-287
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Weak references is a very specialized topic. That’s why I chose to skip it in
    this second edition. Instead, I published [“Weak References” on *fluentpython.com*](https://fpy.li/weakref).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 弱引用是一个非常专业的主题。这就是为什么我选择在第二版中跳过它。相反，我在*fluentpython.com*上发布了[“弱引用”](https://fpy.li/weakref)。
- en: Tricks Python Plays with Immutables
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python对不可变对象的戏法
- en: Note
  id: totrans-290
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This optional section discusses some Python details that are not really important
    for *users* of Python, and that may not apply to other Python implementations
    or even future versions of CPython. Nevertheless, I’ve seen people stumble upon
    these corner cases and then start using the `is` operator incorrectly, so I felt
    they were worth mentioning.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这个可选部分讨论了一些对Python的*用户*来说并不重要的细节，可能不适用于其他Python实现甚至未来的CPython版本。尽管如此，我看到有人遇到这些边缘情况，然后开始错误地使用`is`运算符，所以我觉得值得一提。
- en: I was surprised to learn that, for a tuple `t`, `t[:]` does not make a copy,
    but returns a reference to the same object. You also get a reference to the same
    tuple if you write `tuple(t)`.^([4](ch06.html#idm46582449093056)) [Example 6-17](#ex_same_tuple)
    proves it.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，对于元组`t`，`t[:]`并不会创建一个副本，而是返回对同一对象的引用。如果写成`tuple(t)`也会得到对同一元组的引用。^([4](ch06.html#idm46582449093056))
    [示例 6-17](#ex_same_tuple) 证明了这一点。
- en: Example 6-17\. A tuple built from another is actually the same exact tuple
  id: totrans-293
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-17\. 从另一个元组构建的元组实际上是完全相同的元组
- en: '[PRE24]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO17-1)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO17-1)'
- en: '`t1` and `t2` are bound to the same object.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`t1`和`t2`绑定到同一个对象。'
- en: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO17-2)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO17-2)'
- en: And so is `t3`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`t3`也是如此。'
- en: 'The same behavior can be observed with instances of `str`, `bytes`, and `frozenset`.
    Note that a `frozenset` is not a sequence, so `fs[:]` does not work if `fs` is
    a `frozenset`. But `fs.copy()` has the same effect: it cheats and returns a reference
    to the same object, and not a copy at all, as [Example 6-18](#ex_same_string)
    shows.^([5](ch06.html#idm46582449005168))'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的行为也可以观察到`str`、`bytes`和`frozenset`的实例。请注意，`frozenset`不是一个序列，因此如果`fs`是一个`frozenset`，`fs[:]`不起作用。但`fs.copy()`具有相同的效果：它欺骗性地返回对同一对象的引用，根本不是副本，正如[示例 6-18](#ex_same_string)所示。^([5](ch06.html#idm46582449005168))
- en: Example 6-18\. String literals may create shared objects
  id: totrans-300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-18\. 字符串字面量可能创建共享对象
- en: '[PRE25]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO18-1)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO18-1)'
- en: Creating a new tuple from scratch.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始创建一个新元组。
- en: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO18-2)'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO18-2)'
- en: '`t1` and `t3` are equal, but not the same object.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`t1`和`t3`相等，但不是同一个对象。'
- en: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO18-3)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO18-3)'
- en: Creating a second `str` from scratch.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始创建第二个`str`。
- en: '[![4](assets/4.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO18-4)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_object_references__mutability___span_class__keep_together__and_recycling__span__CO18-4)'
- en: 'Surprise: `a` and `b` refer to the same `str`!'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶：`a`和`b`指向同一个`str`！
- en: The sharing of string literals is an optimization technique called *interning*.
    CPython uses a similar technique with small integers to avoid unnecessary duplication
    of numbers that appear frequently in programs like 0, 1, –1, etc. Note that CPython
    does not intern all strings or integers, and the criteria it uses to do so is
    an undocumented implementation detail.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 共享字符串字面量是一种名为*内部化*的优化技术。CPython使用类似的技术来避免程序中频繁出现的数字（如0、1、-1等）的不必要重复。请注意，CPython并不会对所有字符串或���数进行内部化，它用于执行此操作的标准是一个未记录的实现细节。
- en: Warning
  id: totrans-311
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Never depend on `str` or `int` interning! Always use `==` instead of `is` to
    compare strings or integers for equality. Interning is an optimization for internal
    use of the Python interpreter.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要依赖于`str`或`int`的内部化！始终使用`==`而不是`is`来比较字符串或整数的相等性。内部化是Python解释器内部使用的优化。
- en: The tricks discussed in this section, including the behavior of `frozenset.copy()`,
    are harmless “lies” that save memory and make the interpreter faster. Do not worry
    about them, they should not give you any trouble because they only apply to immutable
    types. Probably the best use of these bits of trivia is to win bets with fellow
    Pythonistas.^([6](ch06.html#idm46582448889664))
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论的技巧，包括`frozenset.copy()`的行为，是无害的“谎言”，可以节省内存并使解释器更快。不要担心它们，它们不应该给你带来任何麻烦，因为它们只适用于不可变类型。也许这些琐事最好的用途是与其他Python爱好者打赌。^([6](ch06.html#idm46582448889664))
- en: Chapter Summary
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节总结
- en: Every Python object has an identity, a type, and a value. Only the value of
    an object may change over time.^([7](ch06.html#idm46582448886416))
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Python对象都有一个标识、一个类型和一个值。对象的值随时间可能会改变，只有对象的值可能会随时间改变。^([7](ch06.html#idm46582448886416))
- en: 'If two variables refer to immutable objects that have equal values (`a == b`
    is `True`), in practice it rarely matters if they refer to copies or are aliases
    referring to the same object, because the value of an immutable object does not
    change, with one exception. The exception being immutable collections such as
    tuples: if an immutable collection holds references to mutable items, then its
    value may actually change when the value of a mutable item changes. In practice,
    this scenario is not so common. What never changes in an immutable collection
    are the identities of the objects within. The `frozenset` class does not suffer
    from this problem because it can only hold hashable elements, and the value of
    hashable objects cannot ever change, by definition.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个变量引用具有相等值的不可变对象（`a == b`为`True`），实际上很少关心它们是引用副本还是别名引用相同对象，因为不可变对象的值不会改变，只有一个例外。这个例外是不可变集合，例如元组：如果不可变集合保存对可变项的引用，那么当可变项的值发生变化时，其值实际上可能会改变。在实践中，这种情况并不常见。在不可变集合中永远不会改变的是其中对象的标识。`frozenset`类不会受到这个问题的影响，因为它只能保存可散列的元素，可散列对象的值根据定义永远不会改变。
- en: 'The fact that variables hold references has many practical consequences in
    Python programming:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 变量保存引用在Python编程中有许多实际后果：
- en: Simple assignment does not create copies.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单赋值不会创建副本。
- en: Augmented assignment with `+=` or `*=` creates new objects if the lefthand variable
    is bound to an immutable object, but may modify a mutable object in place.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`+=`或`*=`进行增强赋值会在左侧变量绑定到不可变对象时创建新对象，但可能会就地修改可变对象。
- en: 'Assigning a new value to an existing variable does not change the object previously
    bound to it. This is called a rebinding: the variable is now bound to a different
    object. If that variable was the last reference to the previous object, that object
    will be garbage collected.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新值分配给现有变量不会更改先前绑定到它的对象。这被称为重新绑定：变量现在绑定到不同的对象。如果该变量是先前对象的最后一个引用，那么该对象将被垃圾回收。
- en: Function parameters are passed as aliases, which means the function may change
    any mutable object received as an argument. There is no way to prevent this, except
    making local copies or using immutable objects (e.g., passing a tuple instead
    of a list).
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数参数作为别名传递，这意味着函数可能会改变作为参数接收的任何可变对象。除了制作本地副本或使用不可变对象（例如，传递元组而不是列表）外，没有其他方法可以阻止这种情况发生。
- en: Using mutable objects as default values for function parameters is dangerous
    because if the parameters are changed in place, then the default is changed, affecting
    every future call that relies on the default.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可变对象作为函数参数的默认值是危险的，因为如果参数在原地更改，则默认值也会更改，影响到依赖默认值的每个未来调用。
- en: In CPython, objects are discarded as soon as the number of references to them
    reaches zero. They may also be discarded if they form groups with cyclic references
    but not outside references.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在CPython中，对象一旦引用数达到零就会被丢弃。如果它们形成具有循环引用但没有外部引用的组，它们也可能被丢弃。
- en: In some situations, it may be useful to hold a reference to an object that will
    not—by itself—keep an object alive. One example is a class that wants to keep
    track of all its current instances. This can be done with weak references, a low-level
    mechanism underlying the more useful collections `WeakValueDictionary`, `WeakKeyDictionary`,
    `WeakSet`, and the `finalize` function from the `weakref` module. For more on
    this, please see [“Weak References” at *fluentpython.com*](https://fpy.li/weakref).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，保留对一个对象的引用可能是有用的，这个对象本身不会保持其他对象的存活。一个例子是一个类想要跟踪其所有当前实例。这可以通过弱引用来实现，这是更有用的集合`WeakValueDictionary`、`WeakKeyDictionary`、`WeakSet`以及`weakref`模块中的`finalize`函数的基础机制。有关更多信息，请参阅[*fluentpython.com*](https://fpy.li/weakref)上的[“弱引用”章节](https://fpy.li/weakref)。
- en: Further Reading
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The [“Data Model” chapter](https://fpy.li/dtmodel) of *The Python Language Reference*
    starts with a clear explanation of object identities and values.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python语言参考*的[“数据模型”章节](https://fpy.li/dtmodel)以清晰的方式解释了对象的标识和值。'
- en: Wesley Chun, author of the *Core Python* series of books, presented [Understanding
    Python’s Memory Model, Mutability, and Methods](https://fpy.li/6-8) at EuroPython
    2011, covering not only the theme of this chapter but also the use of special
    methods.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Wesley Chun，*Core Python* 系列书籍的作者，在2011年的EuroPython上做了题为[Understanding Python’s
    Memory Model, Mutability, and Methods](https://fpy.li/6-8)的演讲，不仅涵盖了本章的主题，还涉及了特殊方法的使用。
- en: Doug Hellmann wrote the posts [“copy – Duplicate Objects”](https://fpy.li/6-9)
    and [“weakref—Garbage-Collectable References to Objects”](https://fpy.li/6-10)
    covering some of the topics we just discussed.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Doug Hellmann撰写了关于“copy – Duplicate Objects”和“weakref—Garbage-Collectable References
    to Objects”的帖子，涵盖了我们刚讨论过的一些主题。
- en: 'More information on the CPython generational garbage collector can be found
    in the [gc module documentation](https://fpy.li/6-11), which starts with the sentence
    “This module provides an interface to the optional garbage collector.” The “optional”
    qualifier here may be surprising, but the [“Data Model” chapter](https://fpy.li/dtmodel)
    also states:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于CPython分代垃圾收集器的信息可以在[gc模块文档](https://fpy.li/6-11)中找到，其中以“此模块提供了一个可选垃圾收集器的接口。”开头。这里的“可选”修饰词可能令人惊讶，但[“数据模型”章节](https://fpy.li/dtmodel)也指出：
- en: An implementation is allowed to postpone garbage collection or omit it altogether—it
    is a matter of implementation quality how garbage collection is implemented, as
    long as no objects are collected that are still reachable.
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 实现可以延迟垃圾收集或完全省略它——垃圾收集的实现质量如何取决于实现，只要不收集仍然可达的对象。
- en: Pablo Galindo wrote more in-depth treatment of Python’s GC in [“Design of CPython’s
    Garbage Collector”](https://fpy.li/6-12) in the [*Python Developer’s Guide*](https://fpy.li/6-13),
    aimed at new and experienced contributors to the CPython implementation.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Pablo Galindo在[*Python开发者指南*](https://fpy.li/6-13)中深入探讨了Python的GC设计，针对CPython实现的新手和有经验的贡献者。
- en: The CPython 3.4 garbage collector improved handling of objects with a `__del__`
    method, as described in [PEP 442—Safe object finalization](https://fpy.li/6-14).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: CPython 3.4垃圾收集器改进了具有`__del__`方法的对象的处理，如[PEP 442—Safe object finalization](https://fpy.li/6-14)中所述。
- en: Wikipedia has an article about [string interning](https://fpy.li/6-15), mentioning
    the use of this technique in several languages, including Python.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科有一篇关于[string interning](https://fpy.li/6-15)的文章，提到了这种技术在几种语言中的使用，包括Python。
- en: 'Wikipedia also as an article on [“Haddocks’ Eyes”](https://fpy.li/6-16), the
    Lewis Carroll song I quoted at the top of this chapter. The Wikipedia editors
    wrote that the lyrics are used in works on logic and philosophy “to elaborate
    on the symbolic status of the concept of *name*: a name as identification marker
    may be assigned to anything, including another name, thus introducing different
    levels of symbolization.”'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科还有一篇关于[“Haddocks’ Eyes”](https://fpy.li/6-16)的文章，这是我在本章开头引用的Lewis Carroll的歌曲。维基百科编辑写道，这些歌词被用于逻辑和哲学作品中“阐述*名称*概念的符号地位：名称作为识别标记可以分配给任何东西，包括另一个名称，从而引入不同级别的符号化。”
- en: ^([1](ch06.html#idm46582451849440-marker)) Lynn Andrea Stein is an award-winning
    computer science educator who [currently teaches at Olin College of Engineering](https://fpy.li/6-1).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch06.html#idm46582451849440-marker)) Lynn Andrea Stein是一位屡获殊荣的计算机科学教育家，[目前在奥林工程学院任教](https://fpy.li/6-1)。
- en: ^([2](ch06.html#idm46582451310816-marker)) In contrast, flat sequences like
    `str`, `bytes`, and `array.array` don’t contain references but directly hold their
    contents—characters, bytes, and numbers—in contiguous memory.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch06.html#idm46582451310816-marker)) 相比之下，像`str`、`bytes`和`array.array`这样的扁平序列不包含引用，而是直接保存它们的内容——字符、字节和数字——在连续的内存中。
- en: ^([3](ch06.html#idm46582449598144-marker)) See [*Principle of least astonishment*](https://fpy.li/6-5)
    in the English Wikipedia.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch06.html#idm46582449598144-marker)) 在英文维基百科中查看[*最少惊讶原则*](https://fpy.li/6-5)。
- en: '^([4](ch06.html#idm46582449093056-marker)) This is clearly documented. Type
    `help(tuple)` in the Python console to read: “If the argument is a tuple, the
    return value is the same object.” I thought I knew everything about tuples before
    writing this book.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch06.html#idm46582449093056-marker)) 这是明确记录的。在Python控制台中键入`help(tuple)`以阅读：“如果参数是一个元组，则返回值是相同的对象。”在写这本书之前，我以为我对元组了解一切。
- en: '^([5](ch06.html#idm46582449005168-marker)) The harmless lie of having the `copy`
    method not copying anything is justified by interface compatibility: it makes
    `frozenset` more compatible with `set`. Anyway, it makes no difference to the
    end user whether two identical immutable objects are the same or are copies.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch06.html#idm46582449005168-marker)) 使`copy`方法不复制任何内容的无害谎言是为了接口兼容性：它使`frozenset`更兼容`set`。无论两个相同的不可变对象是相同的还是副本，对最终用户都没有影响。
- en: ^([6](ch06.html#idm46582448889664-marker)) A terrible use for this information
    would be to ask about it when interviewing candidates or authoring questions for
    “certification” exams. There are countless more important and useful facts to
    check for Python knowledge.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch06.html#idm46582448889664-marker)) 这些信息的可怕用途是在面试候选人或为“认证”考试编写问题时询问。有无数更重要和更有用的事实可用于检查Python知识。
- en: ^([7](ch06.html#idm46582448886416-marker)) Actually the type of an object may
    be changed by merely assigning a different class to its `__class__` attribute,
    but that is pure evil and I regret writing this footnote.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch06.html#idm46582448886416-marker)) 实际上，通过简单地将不同的类分配给其`__class__`属性，对象的类型可以更改，但这是纯粹的邪恶，我后悔写下这个脚注。
