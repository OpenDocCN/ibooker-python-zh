- en: Chapter 16\. Numeric Processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can perform some numeric computations with operators (covered in [“Numeric
    Operations”](ch03.xhtml#numeric_operations)) and built-in functions (covered in
    [“Built-in Functions”](ch08.xhtml#built_in_functions)). Python also provides modules
    that support additional numeric computations, covered in this chapter: math and
    cmath, statistics, operator, random and secrets, fractions, and decimal. Numeric
    processing often requires, more specifically, the processing of *arrays* of numbers;
    this topic is covered in [“Array Processing”](#array_processing), focusing on
    the standard library module array and popular third-party extension NumPy. Finally,
    [“Additional numeric packages”](#additional_numeric_packages) lists several additional
    numeric processing packages produced by the Python community. Most examples in
    this chapter assume you’ve imported the appropriate module; **import** statements
    are only included where the situation might be unclear.'
  prefs: []
  type: TYPE_NORMAL
- en: Floating-Point Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python represents real numeric values (that is, those that are not integers)
    using variables of type float. Unlike integers, computers can rarely represent
    floats exactly, due to their internal implementation as a fixed-size binary integer
    *significand* (often incorrectly called “mantissa”) and a fixed-size binary integer
    exponent. floats have several limitations (some of which can lead to unexpected
    results).
  prefs: []
  type: TYPE_NORMAL
- en: 'For most everyday applications, floats are sufficient for arithmetic, but they
    are limited in the number of decimal places they can represent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'They are also limited in the range of integer values they can accurately store
    (in the sense of being able to distinguish one from the next largest or smallest
    integer value):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Always keep in mind that floats are not entirely precise, due to their internal
    representation in the computer. The same consideration applies to complex numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t Use == Between Floating-Point or Complex Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given that floating-point numbers and operations only approximate the behavior
    of mathematical “real numbers,” it seldom makes sense to check two floats *x*
    and *y* for exact equality. Tiny variations in how each was computed can easily
    result in unexpected differences.
  prefs: []
  type: TYPE_NORMAL
- en: 'For testing floating-point or complex numbers for equality, use the function
    isclose exported by the built-in module math. The following code illustrates why:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For some values, you may have to set the tolerance value explicitly (this is
    *always* necessary when you’re comparing with 0):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You can also use isclose for safe looping.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t Use a float as a Loop Control Variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common error is to use a floating-point value as the control variable of a
    loop, assuming that it will eventually equal some ending value, such as 0. Instead,
    it most likely will end up looping forever.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following loop, expected to loop five times and then end, will in fact
    loop forever:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though f started as an int, it’s now a float. This code shows why:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Even using the inequality operator > results in incorrect behavior, looping
    six times instead of five (since the residual float value is still greater than
    0):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If instead you use math.isclose for comparing *f* with 0, the **for** loop
    repeats the correct number of times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In general, try to use an int for a loop’s control variable, rather than a float.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, mathematical operations that result in very large floats will often
    cause an OverflowError, or Python may return them as inf (infinity). The maximum
    float value usable on your computer is sys.float_info.max: on 64-bit computers,
    it’s 1.7976931348623157e+308. This may cause unexpected results when doing math
    using very large numbers. When you need to work with very large numbers, we recommend
    using the decimal module or third-party [gmpy](https://oreil.ly/JWoAx) instead.'
  prefs: []
  type: TYPE_NORMAL
- en: The math and cmath Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The math module supplies mathematical functions for working with floating-point
    numbers; the cmath module supplies equivalent functions for complex numbers. For
    example, math.sqrt(-1) raises an exception, but cmath.sqrt(-1) returns 1j.
  prefs: []
  type: TYPE_NORMAL
- en: Just like for any other module, the cleanest, most readable way to use these
    is to have, for example, **import** math at the top of your code, and explicitly
    call, say, math.sqrt afterward. However, if your code includes a large number
    of calls to the modules’ well-known mathematical functions, you might (though
    it may lose some clarity and readability) either use **from** math **import**
    *, or use **from** math **import** sqrt, and afterward just call sqrt.
  prefs: []
  type: TYPE_NORMAL
- en: Each module exposes three float attributes bound to the values of fundamental
    mathematical constants, e, pi, and [tau](https://oreil.ly/2Sbrf), and a variety
    of functions, including those shown in [Table 16-1](#methods_and_attributes_of_the_math_and).
    The math and cmath modules are not fully symmetric, so for each method the table
    indicates whether it is in math, cmath, or both. All examples assume you have
    imported the appropriate module.
  prefs: []
  type: TYPE_NORMAL
- en: Table 16-1\. Methods and attributes of the math and cmath modules
  prefs: []
  type: TYPE_NORMAL
- en: '|   |   | math | cmath |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| acos, asin, atan, cos, sin, tan | acos(*x*), etc. Return the trigonometric
    functions arccosine, arcsine, arctangent, cosine, sine, or tangent, respectively,
    of *x*, given in radians. | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| acosh, asinh, atanh, cosh, sinh, tanh | acosh(*x*), etc. Return the arc hyperbolic
    cosine, arc hyperbolic sine, arc hyperbolic tangent, hyperbolic cosine, hyperbolic
    sine, or hyperbolic tangent, respectively, of *x*, given in radians. | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| atan2 | atan2(*y, x*) Like atan(*y*/*x*), except that atan2 properly takes
    into account the signs of both arguments. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When *x* equals 0, atan2 returns π/2, while dividing by *x* would raise ZeroDivisionError.
    | ✓ |   |
  prefs: []
  type: TYPE_NORMAL
- en: '| cbrt | cbrt(x) 3.11+ Returns the cube root of *x*. | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| ceil | ceil(*x*) Returns float(*i*), where *i* is the smallest integer such
    that *i*>=*x*. | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| comb | comb(*n*, *k*) 3.8+ Returns the number of *combinations* of *n* items
    taken *k* items at a time, regardless of order. When counting the number of combinations
    taken from three items *A*, *B*, and *C*, two at a time, comb(3, 2) returns 3
    because, for example, *A*-*B* and *B*-*A* are considered the *same* combination
    (contrast this with perm, later in this table). Raises ValueError when *k* or
    *n* is negative; raises TypeError when *k* or *n* is not an int. When *k*>*n*,
    just returns 0, raising no exceptions. | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| copysign | copysign(*x*, *y*) Returns the absolute value of *x* with the
    sign of *y*. | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| degrees | degrees(*x*) Returns the degree measure of the angle *x* given
    in radians. | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| dist | dist(*pt0*, *pt1*) 3.8+ Returns the Euclidean distance between two
    *n*-dimensional points, where each point is represented as a sequence of values
    (coordinates). Raises ValueError if *pt0* and *pt1* are sequences of different
    lengths. | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| e | The mathematical constant *e* (2.718281828459045). | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| erf | erf(*x*) Returns the error function of *x* as used in statistical calculations.
    | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| erfc | erfc(*x*) Returns the complementary error function at *x*, defined
    as 1.0 - erf(*x*). | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| exp | exp(*x*) Returns eˣ. | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| exp2 | exp2(*x*) 3.11+ Returns 2ˣ. | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| expm1 | expm1(*x*) Returns eˣ - 1. Inverse of log1p. | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| fabs | fabs(*x*) Returns the absolute value of *x*. Always returns a float,
    even if *x* is an int (unlike the built-in abs function). | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| factorial | factorial(*x*) Returns the factorial of *x*. Raises ValueError
    when *x* is negative, and TypeError when *x* is not integral. | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| floor | floor(*x*) Returns float(*i*), where *i* is the greatest integer
    such that *i*<=*x*. | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| fmod | fmod(*x, y*) Returns the float *r*, with the same sign as *x*, such
    that *r*==*x*-*n***y* for some integer *n*, and abs(*r*)<abs(*y*). Like *x*%*y*,
    except that, when *x* and *y* differ in sign, *x%y* has the same sign as *y*,
    not the same sign as *x*. | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| frexp | frexp(*x*) Returns a pair (*m*, *e*) where *m* is a floating-point
    number and *e* is an integer such that *x*==*m**(2**e) and 0.5<=abs(*m*)<1,^([a](ch16.xhtml#ch01fn120))
    except that frexp(0) returns (0.0, 0). | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| fsum | fsum(*iterable*) Returns the floating-point sum of the values in *iterable*
    to greater precision than the sum built-in function. | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| gamma | gamma(*x*) Returns the Gamma function evaluated at *x*. | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| gcd | gcd(*x, y*) Returns the greatest common divisor of *x* and *y*. When
    *x* and *y* are both zero, returns 0. (3.9+ gcd can accept any number of values;
    gcd() without arguments returns 0.) | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| hypot | hypot(*x, y*) Returns sqrt(*x***x*+*y***y*). (3.8+ hypot can accept
    any number of values, to compute a hypotenuse length in *n* dimensions.) | ✓ |
      |'
  prefs: []
  type: TYPE_TB
- en: '| inf | A floating-point positive infinity, like float(''inf''). | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| infj | A complex imaginary infinity, equal to complex(0, float(''inf'')).
    |   | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| isclose | isclose(*x*, *y*, rel_tol=1e-09, abs_tol=0.0) Returns **True**
    when *x* and *y* are approximately equal, within relative tolerance rel_tol, with
    minimum absolute tolerance of abs_tol; otherwise, returns **False**. Default is
    rel_tol within nine decimal digits. rel_tol must be greater than 0. abs_tol is
    used for comparisons near zero: it must be at least 0.0. NaN is not considered
    close to any value (including NaN itself); each of -inf and inf is only considered
    close to itself. Except for behavior at +/– inf, isclose is like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '| ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| isfinite | isfinite(*x*) Returns **True** when *x* (in cmath, both the real
    and imaginary parts of *x*) is neither infinity nor NaN; otherwise, returns **False**.
    | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| isinf | isinf(*x*) Returns **True** when *x* (in cmath, either the real or
    imaginary part of *x*, or both) is positive or negative infinity; otherwise, returns
    **False**. | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| isnan | isnan(*x*) Returns **True** when *x* (in cmath, either the real or
    imaginary part of *x*, or both) is NaN; otherwise, returns **False**. | ✓ | ✓
    |'
  prefs: []
  type: TYPE_TB
- en: '| isqrt | isqrt(*x*) 3.8+ Returns int(sqrt(*x*)). | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| lcm | lcm(*x*, ...) 3.9+ Returns the least common multiple of the given ints.
    If not all values are ints, raises TypeError. | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| ldexp | ldexp(*x, i*) Returns *x**(*2****i*) (*i* must be an int; when *i*
    is a float, ldexp raises TypeError). Inverse of frexp. | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| lgamma | lgamma(*x*) Returns the natural logarithm of the absolute value
    of the Gamma function evaluated at *x*. | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| log | log(*x*) Returns the natural logarithm of *x*. | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| log10 | log10(*x*) Returns the base-10 logarithm of *x*. | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| log1p | log1p(*x*) Returns the natural logarithm of 1+*x*. Inverse of expm1.
    | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| log2 | log2(*x*) Returns the base-2 logarithm of *x*. | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| modf | modf(*x*) Returns a pair (*f*, *i*) with the fractional and integer
    parts of *x*, meaning two floats with the same sign as *x* such that *i*==int(*i*)
    and *x*==*f*+*i*. | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| nan | nan A floating-point “Not a Number” (NaN) value, like float(''nan'')
    or complex(''nan''). | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| nanj | A complex number with a 0.0 real part and floating-point “Not a Number”
    (NaN) imaginary part. |   | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| nextafter | nextafter(*a*, *b*) 3.9+ Returns the next higher or lower float
    value from *a* in the direction of *b*. | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| perm | perm(*n*, *k*) 3.8+ Returns the number of *permutations* of *n* items
    taken *k* items at a time, where selections of the same items but in differing
    order are counted separately. When counting the number of permutations of three
    items *A*, *B*, and *C*, taken two at a time, perm(3, 2) returns 6, because, for
    example, *A*-*B* and *B*-*A* are considered to be different permutations (contrast
    this with comb, earlier in this table). Raises ValueError when *k* or *n* is negative;
    raises TypeError when *k* or *n* is not an int. | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| pi | The mathematical constant *π*, 3.141592653589793. | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| phase | phase(*x*) Returns the *phase* of *x*, a float in the range (*–π*,
    *π*)*.* Like math.atan2(*x*.imag, *x*.real). See “Conversions to and from polar
    coordinates” in the [online docs](https://oreil.ly/gXdbT) for details. |   | ✓
    |'
  prefs: []
  type: TYPE_TB
- en: '| polar | polar(*x*) Returns the polar coordinate representation of *x*, as
    a pair (*r*, *phi*) where *r* is the modulus of *x* and *phi* is the phase of
    *x*. Like (abs(*x*), cmath.phase(*x*)). See “Conversions to and from polar coordinates”
    in the [online docs](https://oreil.ly/gXdbT) for details. |   | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| pow | pow(*x, y*) Returns float(*x*)**float(*y*). For large int values of
    *x* and *y*, to avoid OverflowError exceptions, use *x****y* or the pow built-in
    function instead (which does not convert to floats). | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| prod | prod(*seq*, start=1) 3.8+ Returns the product of all values in the
    sequence, beginning with the given start value, which defaults to 1. If *seq*
    is empty, returns the start value. | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| radians | radians(*x*) Returns the radian measure of the angle *x* given
    in degrees. | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| rect | rect(*r*, *phi*) Returns the complex value representing the polar
    coordinates (*r*, *phi*) converted to rectangular coordinates as (*x* + *yj*).
    |   | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| remainder | remainder(*x*, *y*) Returns the signed remainder from dividing
    *x*/*y* (the result may be negative if *x* or *y* is negative). | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| sqrt | sqrt(*x*) Returns the square root of *x*. | ✓ | ✓ |'
  prefs: []
  type: TYPE_TB
- en: '| tau | The mathematical constant *τ* = 2*π*, or 6.283185307179586. | ✓ | ✓
    |'
  prefs: []
  type: TYPE_TB
- en: '| trunc | trunc(*x*) Returns *x* truncated to an int. | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| ulp | ulp(*x*) 3.9+ Returns the least significant bit of floating-point value
    *x*. For positive values, equals math.nextafter(*x*, *x*+1) - x. For negative
    values, equals ulp(-*x*). If *x* is NaN or inf, returns *x*. ulp stands for [*unit
    of least precision*](https://oreil.ly/6cN99). | ✓ |   |'
  prefs: []
  type: TYPE_TB
- en: '| ^([a](ch16.xhtml#ch01fn120-marker)) Formally, *m* is the significand, and
    *e* is the exponent. Used to render a cross-platform portable representation of
    a floating-point value. |'
  prefs: []
  type: TYPE_TB
- en: The statistics Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The statistics module supplies the class NormalDist to perform distribution
    analytics, and the functions listed in [Table 16-2](#functions_of_the_statistics_module)
    to compute common statistics.
  prefs: []
  type: TYPE_NORMAL
- en: Table 16-2\. Functions of the statistics module (with functions added in versions
    3.8 and 3.10)
  prefs: []
  type: TYPE_NORMAL
- en: '|   | 3.8+ | 3.10+ |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| harmonic_mean mean'
  prefs: []
  type: TYPE_NORMAL
- en: median
  prefs: []
  type: TYPE_NORMAL
- en: median_grouped
  prefs: []
  type: TYPE_NORMAL
- en: median_high
  prefs: []
  type: TYPE_NORMAL
- en: median_low
  prefs: []
  type: TYPE_NORMAL
- en: mode
  prefs: []
  type: TYPE_NORMAL
- en: pstdev
  prefs: []
  type: TYPE_NORMAL
- en: pvariance
  prefs: []
  type: TYPE_NORMAL
- en: stdev
  prefs: []
  type: TYPE_NORMAL
- en: variance | fmean geometric_mean
  prefs: []
  type: TYPE_NORMAL
- en: multimode
  prefs: []
  type: TYPE_NORMAL
- en: quantiles
  prefs: []
  type: TYPE_NORMAL
- en: NormalDist | correlation covariance
  prefs: []
  type: TYPE_NORMAL
- en: linear_regression |
  prefs: []
  type: TYPE_NORMAL
- en: The [online docs](https://oreil.ly/CY8Pi) contain detailed information on the
    signatures and use of these functions.
  prefs: []
  type: TYPE_NORMAL
- en: The operator Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The operator module supplies functions that are equivalent to Python’s operators.
    These functions are handy in cases where callables must be stored, passed as arguments,
    or returned as function results. The functions in operator have the same names
    as the corresponding special methods (covered in [“Special Methods”](ch04.xhtml#special_methods)).
    Each function is available with two names, with and without “dunder” (leading
    and trailing double underscores): for example, both operator.add(*a*, *b*) and
    operator.__add__(*a*, *b*) return *a + b*.'
  prefs: []
  type: TYPE_NORMAL
- en: Matrix multiplication support has been added for the infix operator @, but you
    must implement it by defining your own __matmul__, __rmatmul__, and/or __imatmul__
    methods; NumPy currently supports @ (but, as of this writing, not yet @=) for
    matrix multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 16-3](#functions_supplied_by_the_operator_modu) lists some of the functions
    supplied by the operator module. For detailed information on these functions and
    their use, see the [online docs](https://oreil.ly/WrtUH).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 16-3\. Functions supplied by the operator module
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Signature | Behaves like |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| abs | abs(*a*) | abs(*a*) |'
  prefs: []
  type: TYPE_TB
- en: '| add | add(*a*, *b*) | *a* + *b* |'
  prefs: []
  type: TYPE_TB
- en: '| and_ | and_(*a*, *b*) | *a* & *b* |'
  prefs: []
  type: TYPE_TB
- en: '| concat | concat(*a*, *b*) | *a* + *b* |'
  prefs: []
  type: TYPE_TB
- en: '| contains | contains(*a*, *b*) | *b* **in** *a* |'
  prefs: []
  type: TYPE_TB
- en: '| countOf | countOf(*a*, *b*) | *a*.count(*b*) |'
  prefs: []
  type: TYPE_TB
- en: '| delitem | delitem(*a*, *b*) | **del** *a*[*b*] |'
  prefs: []
  type: TYPE_TB
- en: '| delslice | delslice(*a*, *b*, *c*) | **del** *a*[*b*:*c*] |'
  prefs: []
  type: TYPE_TB
- en: '| eq | eq(*a*, *b*) | *a* == *b* |'
  prefs: []
  type: TYPE_TB
- en: '| floordiv | floordiv(*a*, *b*) | *a* // *b* |'
  prefs: []
  type: TYPE_TB
- en: '| ge | ge(*a*, *b*) | *a* >= *b* |'
  prefs: []
  type: TYPE_TB
- en: '| getitem | getitem(*a*, *b*) | *a*[*b*] |'
  prefs: []
  type: TYPE_TB
- en: '| getslice | getslice(*a*, *b*, *c*) | *a*[*b*:*c*] |'
  prefs: []
  type: TYPE_TB
- en: '| gt | gt(*a*, *b*) | *a* > *b* |'
  prefs: []
  type: TYPE_TB
- en: '| index | index(*a*) | *a*.__index__() |'
  prefs: []
  type: TYPE_TB
- en: '| indexOf | indexOf(*a*, *b*) | *a*.index(*b*) |'
  prefs: []
  type: TYPE_TB
- en: '| invert, inv | invert(*a*)*,* inv(*a*) | ~*a* |'
  prefs: []
  type: TYPE_TB
- en: '| is_ | is_(*a*, *b*) | *a* **is** *b* |'
  prefs: []
  type: TYPE_TB
- en: '| is_not | is_not(*a*, *b*) | *a* **is not** *b* |'
  prefs: []
  type: TYPE_TB
- en: '| le | le(*a*, *b*) | *a* <= *b* |'
  prefs: []
  type: TYPE_TB
- en: '| lshift | lshift(*a*, *b*) | *a* << *b* |'
  prefs: []
  type: TYPE_TB
- en: '| lt | lt(*a*, *b*) | *a* < *b* |'
  prefs: []
  type: TYPE_TB
- en: '| matmul | matmul(*m1*, *m2*) | *m1* @ *m2* |'
  prefs: []
  type: TYPE_TB
- en: '| mod | mod(*a*, *b*) | *a* % *b* |'
  prefs: []
  type: TYPE_TB
- en: '| mul | mul(*a*, *b*) | *a* * *b* |'
  prefs: []
  type: TYPE_TB
- en: '| ne | ne(*a*, *b*) | *a* != *b* |'
  prefs: []
  type: TYPE_TB
- en: '| neg | neg(*a*) | *-a* |'
  prefs: []
  type: TYPE_TB
- en: '| not_ | not_(*a*) | **not** *a* |'
  prefs: []
  type: TYPE_TB
- en: '| or_ | or_(*a*, *b*) | *a* &#124; *b* |'
  prefs: []
  type: TYPE_TB
- en: '| pos | pos(*a*) | +*a* |'
  prefs: []
  type: TYPE_TB
- en: '| pow | pow(*a*, *b*) | a ** b |'
  prefs: []
  type: TYPE_TB
- en: '| repeat | repeat(*a*, *b*) | *a* * *b* |'
  prefs: []
  type: TYPE_TB
- en: '| rshift | rshift(*a*, *b*) | *a* >> *b* |'
  prefs: []
  type: TYPE_TB
- en: '| setitem | setitem(*a*, *b*, *c*) | *a*[*b*] = *c* |'
  prefs: []
  type: TYPE_TB
- en: '| setslice | setslice(*a*, *b*, *c*, *d*) | *a*[*b*:*c*] = *d* |'
  prefs: []
  type: TYPE_TB
- en: '| sub | sub(*a*, *b*) | *a* - *b* |'
  prefs: []
  type: TYPE_TB
- en: '| truediv | truediv(*a*, *b*) | *a/b* *# no truncation* |'
  prefs: []
  type: TYPE_TB
- en: '| truth | truth(*a*) | bool(*a*), **not not** a |'
  prefs: []
  type: TYPE_TB
- en: '| xor | xor(*a*, *b*) | *a* ^ *b* |'
  prefs: []
  type: TYPE_TB
- en: The operator module also supplies additional higher-order functions, listed
    in [Table 16-4](#higher_order_functions_supplied_by_the). Three of these functions,
    attrgetter, itemgetter, and methodcaller, return functions suitable for passing
    as named argument key to the sort method of lists, the sorted, min, and max built-in
    functions, and several functions in standard library modules, such as heapq and
    itertools (discussed in [Chapter 8](ch08.xhtml#core_built_ins_and_standard_library_mod)).
  prefs: []
  type: TYPE_NORMAL
- en: Table 16-4\. Higher-order functions supplied by the operator module
  prefs: []
  type: TYPE_NORMAL
- en: '| attrgetter | attrgetter(*attr*), attrgetter(**attrs*)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns a callable *f* such that *f*(*o*) is the same as getattr(*o*, *attr*).
    The string *attr* can include dots (.), in which case the callable result of attrgetter
    calls getattr repeatedly. For example, operator.attrgetter(''a.b'') is equivalent
    to **lambda** *o*: getattr(getattr(*o*, ''a''), ''b'').'
  prefs: []
  type: TYPE_NORMAL
- en: When you call attrgetter with multiple arguments, the resulting callable extracts
    each attribute thus named and returns the resulting tuple of values. |
  prefs: []
  type: TYPE_NORMAL
- en: '| itemgetter | itemgetter(*key*), itemgetter(**keys*)'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable *f* such that *f*(*o*) is the same as getitem(*o*, *key*).
  prefs: []
  type: TYPE_NORMAL
- en: When you call itemgetter with multiple arguments, the resulting callable extracts
    each item thus keyed and returns the resulting tuple of values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say that *L* is a list of lists, with each sublist at least three
    items long: you want to sort *L*, in place, based on the third item of each sublist,
    with sublists having equal third items sorted by their first items. The simplest
    way to do this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| length_hint | length_hint(*iterable*, default=0) Used to try to preallocate
    storage for items in *iterable*. Calls object *iterable*’s __len__ method to try
    to get an exact length. If __len__ is not implemented, then Python tries calling
    *iterable*’s __length_hint__ method. If this is also not implemented, length_hint
    returns the given default. Any mistake in using this “hint” helper may result
    in a performance issue, but not in silent, incorrect behavior. |'
  prefs: []
  type: TYPE_TB
- en: '| met⁠h⁠o⁠d​c⁠a⁠l⁠ler | methodcaller(*methodname*, args...) Returns a callable
    *f* such that *f*(*o*) is the same as o.*methodname*(args, ...). The optional
    args may be given as positional or named arguments. |'
  prefs: []
  type: TYPE_TB
- en: Random and Pseudorandom Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The random module of the standard library generates pseudorandom numbers with
    various distributions. The underlying uniform pseudorandom generator uses the
    powerful, popular [Mersenne Twister algorithm](https://oreil.ly/AcAgG), with a
    (huge!) period of length 2^(19937)-1.
  prefs: []
  type: TYPE_NORMAL
- en: The random Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All functions of the random module are methods of one hidden global instance
    of the class random.Random. You can instantiate Random explicitly to get multiple
    generators that do not share state. Explicit instantiation is advisable if you
    require random numbers in multiple threads (threads are covered in [Chapter 15](ch15.xhtml#concurrency_threads_and_processes)).
    Alternatively, instantiate SystemRandom if you require higher-quality random numbers
    (see the following section for details). [Table 16-5](#useful_functions_supplied_by_the_random)
    documents the most frequently used functions exposed by the random module.
  prefs: []
  type: TYPE_NORMAL
- en: Table 16-5\. Useful functions supplied by the random module
  prefs: []
  type: TYPE_NORMAL
- en: '| choice | choice(*seq*) Returns a random item from nonempty sequence *seq*.
    |'
  prefs: []
  type: TYPE_TB
- en: '| choices | choices(*seq*, *weights*=**None**, *, cum_weights=**None**, k=1)
    Returns k elements from nonempty sequence *seq*, with replacement. By default,
    elements are chosen with equal probability. If the optional *weights*, or the
    named argument cum_weights, is passed (as a list of floats or ints), then the
    respective choices are weighted by that amount during choosing. The cum_weights
    argument accepts a list of floats or ints as would be returned by itertools.accumulate(*weights*);
    e.g., if *weights* for a *seq* containing three items were [1, 2, 1], then the
    corresponding cum_weights would be [1, 3, 4]. (Only one of *weights* or cum_weights
    may be specified, and must be the same length as *seq*. If used, cum_weights and
    k must be given as named arguments.) |'
  prefs: []
  type: TYPE_TB
- en: '| getrandbits | getrandbits(*k*) Returns an int >= 0 with *k* random bits,
    like randrange(2 ** *k*) (but faster, and with no problems for large *k*). |'
  prefs: []
  type: TYPE_TB
- en: '| getstate | getstate() Returns a hashable and pickleable object *S* representing
    the current state of the generator. You can later pass *S* to the function setstate
    to restore the generator’s state. |'
  prefs: []
  type: TYPE_TB
- en: '| jumpahead | jumpahead(*n*) Advances the generator state as if *n* random
    numbers had been generated. This is faster than generating and ignoring *n* random
    numbers. |'
  prefs: []
  type: TYPE_TB
- en: '| randbytes | randbytes(*k*) 3.9+ Generates *k* random bytes. To generate bytes
    for secure or cryptographic applications, use secrets.randbits(*k* * 8), then
    unpack the int it returns into *k* bytes, using int.to_bytes(*k*, ''big''). |'
  prefs: []
  type: TYPE_TB
- en: '| randint | randint(*start*, *stop*) Returns a random int *i* from a uniform
    distribution such that *start* <= *i* <= *stop*. Both endpoints are included:
    this is quite unnatural in Python, so you would normally prefer randrange. |'
  prefs: []
  type: TYPE_TB
- en: '| random | random() Returns a random float *r* from a uniform distribution,
    0 <= *r* < 1. |'
  prefs: []
  type: TYPE_TB
- en: '| randrange | randrange([*start*,]*stop*[,*step*]) Like choice(range(*start*,
    *stop*, *step*)), but much faster. |'
  prefs: []
  type: TYPE_TB
- en: '| sample | sample(*seq*, *k*) Returns a new list whose *k* items are unique
    items randomly drawn from *seq*. The list is in random order, so that any slice
    of it is an equally valid random sample. *seq* may contain duplicate items. In
    this case, each occurrence of an item is a candidate for selection in the sample,
    and the sample may also contain such duplicates. |'
  prefs: []
  type: TYPE_TB
- en: '| seed | seed(*x*=**None**) Initializes the generator state. *x* can be any
    int, float, str, bytes, or bytearray. When *x* is **None**, and when the module
    random is first loaded, seed uses the current system time (or some platform-specific
    source of randomness, if any) to get a seed. *x* is normally an int up to 2^(256),
    a float, or a str, bytes, or bytearray up to 32 bytes in size.^([a](ch16.xhtml#ch01fn121))
    Larger *x* values are accepted, but may produce the same generator state as smaller
    ones. seed is useful in simulation or modeling for repeatable runs, or to write
    tests that require a reproducible sequence of random values. |'
  prefs: []
  type: TYPE_TB
- en: '| setstate | setstate(*S*) Restores the generator state. *S* must be the result
    of a previous call to getstate (such a call may have occurred in another program,
    or in a previous run of this program, as long as object *S* has correctly been
    transmitted, or saved and restored). |'
  prefs: []
  type: TYPE_TB
- en: '| shuffle | shuffle(*seq*) Shuffles, in place, mutable sequence *seq*. |'
  prefs: []
  type: TYPE_TB
- en: '| uniform | uniform(*a, b*) Returns a random floating-point number *r* from
    a uniform distribution such that *a* <= *r* < *b*. |'
  prefs: []
  type: TYPE_TB
- en: '| ^([a](ch16.xhtml#ch01fn121-marker)) As defined in the Python language specification.
    Specific Python implementations may support larger seed values for generating
    unique random number sequences. |'
  prefs: []
  type: TYPE_TB
- en: The random module also supplies several other functions that generate pseudorandom
    floating-point numbers from other probability distributions (Beta, Gamma, exponential,
    Gauss, Pareto, etc.) by internally calling random.random as their source of randomness.
    See the [online docs](https://oreil.ly/2n8wP) for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Crypto-Quality Random Numbers: The secrets Module'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pseudorandom numbers provided by the random module, while sufficient for simulation
    and modeling, are not of cryptographic quality. To get random numbers and sequences
    for use in security and cryptography applications, use the functions defined in
    the secrets module. These functions use the random.SystemRandom class, which in
    turn calls os.urandom. os.urandom returns random bytes, read from physical sources
    of random bits such as */dev/urandom* on older Linux releases, or the **getrandom()**
    syscall on Linux 3.17 and above. On Windows, os.urandom uses cryptographical-strength
    sources such as the CryptGenRandom API. If no suitable source exists on the current
    system, os.urandom raises NotImplementedError.
  prefs: []
  type: TYPE_NORMAL
- en: secrets Functions Cannot Be Run with a Known Seed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike the random module, which includes a seed function to support generation
    of repeatable sequences of random values, the secrets module has no such capability.
    To write tests dependent on specific sequences of random values generated by the
    secrets module functions, developers must emulate those functions with their own
    mock versions.
  prefs: []
  type: TYPE_NORMAL
- en: The secrets module supplies the functions listed in [Table 16-6](#functions_of_the_secrets_module).
  prefs: []
  type: TYPE_NORMAL
- en: Table 16-6\. Functions of the secrets module
  prefs: []
  type: TYPE_NORMAL
- en: '| choice | choice(*seq*) Returns a randomly selected item from nonempty sequence
    *seq*. |'
  prefs: []
  type: TYPE_TB
- en: '| randbelow | randbelow(*n*) Returns a random int *x* in the range 0 <= *x*
    < *n*. |'
  prefs: []
  type: TYPE_TB
- en: '| randbits | randbits(*k*) Returns an int with *k* random bits. |'
  prefs: []
  type: TYPE_TB
- en: '| token_bytes | token_bytes(*n*) Returns a bytes object of *n* random bytes.
    When you omit *n*, uses a default value, usually 32. |'
  prefs: []
  type: TYPE_TB
- en: '| token_hex | token_hex(*n*) Returns a string of hexadecimal characters from
    *n* random bytes, with two characters per byte. When you omit *n*, uses a default
    value, usually 32. |'
  prefs: []
  type: TYPE_TB
- en: '| token_urlsafe | token_urlsafe(*n*) Returns a string of Base64-encoded characters
    from *n* random bytes; the resulting string’s length is approximately 1.3 times
    *n*. When you omit *n*, uses a default value, usually 32. |'
  prefs: []
  type: TYPE_TB
- en: Additional recipes and best cryptographic practices are provided in Python’s
    [online documentation](https://oreil.ly/Yxh4k).
  prefs: []
  type: TYPE_NORMAL
- en: Alternative sources of physically random numbers are available online, e.g.
    from [Fourmilab](https://oreil.ly/uNAfT).
  prefs: []
  type: TYPE_NORMAL
- en: The fractions Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fractions module supplies a rational number class, Fraction, whose instances
    you can construct from a pair of integers, another rational number, or a str.
    Fraction class instances have read-only attributes numerator and denominator.
    You can pass a pair of (optionally signed) ints as the *numerator* and *denominator*.
    A denominator of 0 raises ZeroDivisionError. A string can be of the form '3.14',
    or can include an optionally signed numerator, a slash (/) , and a denominator,
    such as '-22/7'.
  prefs: []
  type: TYPE_NORMAL
- en: Fraction Reduces to Lowest Terms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fraction reduces the fraction to the lowest terms—for example, f = Fraction(226,
    452) builds an instance f equal to one built by Fraction(1, 2). The specific numerator
    and denominator originally passed to Fraction are not recoverable from the resulting
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Fraction also supports construction from decimal.Decimal instances, and from
    floats (the latter may not provide the results you expect, given floats’ bounded
    precision). Here are some examples of using Fraction with various inputs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The Fraction class supplies methods including limit_denominator, which allows
    you to create a rational approximation of a float—for example, Fraction(0.0999).limit_denominator(10)
    returns Fraction(1, 10). Fraction instances are immutable and can be keys in dicts
    or members of sets, as well as being usable in arithmetic operations with other
    numbers. See the [online docs](https://oreil.ly/xyS7U) for complete coverage.
  prefs: []
  type: TYPE_NORMAL
- en: The fractions module also supplies a function gcd that’s just like math.gcd,
    covered in [Table 16-1](#methods_and_attributes_of_the_math_and).
  prefs: []
  type: TYPE_NORMAL
- en: The decimal Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Python float is a binary floating-point number, normally according to the
    standard known as IEEE 754 implemented in hardware in modern computers. An excellent,
    concise, practical introduction to floating-point arithmetic and its issues can
    be found in David Goldberg’s paper [“What Every Computer Scientist Should Know
    About Floating-Point Arithmetic”](https://oreil.ly/kmCAq). A Python-focused essay
    on the same issues is part of the [tutorial](https://oreil.ly/0SQ-H) in the Python
    docs; another excellent summary (not focused on Python), Bruce Bush’s “The Perils
    of Floating Point,” is also available [online](https://oreil.ly/d8HJE).
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, particularly for money-related computations, you may prefer to use *decimal*
    floating-point numbers. Python supplies an implementation of the standard known
    as IEEE 854,^([1](ch16.xhtml#ch01fn122)) for base 10, in the standard library
    module decimal. The module has excellent [documentation](https://oreil.ly/3np33):
    there, you can find complete reference material, pointers to the applicable standards,
    a tutorial, and advocacy for decimal. Here, we cover only a small subset of decimal’s
    functionality, the most frequently used parts of the module.'
  prefs: []
  type: TYPE_NORMAL
- en: The decimal module supplies a Decimal class (whose immutable instances are decimal
    numbers), exception classes, and classes and functions to deal with the *arithmetic
    context*, which specifies such things as precision, rounding, and which computational
    anomalies (such as division by zero, overflow, underflow, and so on) raise exceptions
    when they occur. In the default context, precision is 28 decimal digits, rounding
    is “half-even” (round results to the closest representable decimal number; when
    a result is exactly halfway between two such numbers, round to the one whose last
    digit is even), and the anomalies that raise exceptions are invalid operation,
    division by zero, and overflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build a decimal number, call Decimal with one argument: an int, float, str,
    or tuple. If you start with a float, Python converts it losslessly to the exact
    decimal equivalent (which may require 53 digits or more of precision):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If this is not the behavior you want, you can pass the float as a str; for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You can easily write a factory function for ease of interactive experimentation
    with decimal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Now dfs(0.1) is just the same thing as Decimal(str(0.1)), or Decimal('0.1'),
    but more concise and handier to write.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you may use the quantize method of Decimal to construct a new
    decimal by rounding a float to the number of significant digits you specify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If you start with a tuple, you need to provide three arguments: the sign (0
    for positive, 1 for negative), a tuple of digits, and the integer exponent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have instances of Decimal, you can compare them, including comparison
    with floats (use math.isclose for this); pickle and unpickle them; and use them
    as keys in dictionaries and as members of sets. You may also perform arithmetic
    among them, and with integers, but not with floats (to avoid unexpected loss of
    precision in the results), as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The [online docs](https://oreil.ly/MygnC) include useful [recipes](https://oreil.ly/9KnLa)
    for monetary formatting, some trigonometric functions, and a list of FAQs.
  prefs: []
  type: TYPE_NORMAL
- en: Array Processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can represent what most languages call arrays, or vectors, with lists (covered
    in [“Lists”](ch03.xhtml#list)), as well as with the array standard library module
    (covered in the following subsection). You can manipulate arrays with loops, indexing
    and slicing, list comprehensions, iterators, generators, and genexps (all covered
    in [Chapter 3](ch03.xhtml#the_python_language)); built-ins such as map, reduce,
    and filter (all covered in [“Built-in Functions”](ch08.xhtml#built_in_functions));
    and standard library modules such as itertools (covered in [“The itertools Module”](ch08.xhtml#the_itertools_module)).
    If you only need a lightweight, one-dimensional array of instances of a simple
    type, stick with array. However, to process large arrays of numbers, such functions
    may be slower and less convenient than third-party extensions such as NumPy and
    SciPy (covered in [“Extensions for Numeric Array Computation”](#extensions_for_numeric_array_computatio)).
    When you’re doing data analysis and modeling, Pandas, which is built on top of
    NumPy (but not discussed in this book), might be most suitable.
  prefs: []
  type: TYPE_NORMAL
- en: The array Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The array module supplies a type, also called array, whose instances are mutable
    sequences, like lists. An array *a* is a one-dimensional sequence whose items
    can be only characters, or only numbers of one specific numeric type, fixed when
    you create *a*. The constructor for array is:'
  prefs: []
  type: TYPE_NORMAL
- en: '| array | **class** array(*typecode, init*='''', /) Creates and returns an
    array object *a* with the given *typecode**.* *init* can be a string (a bytestring,
    except for *typecode* ''u'') whose length is a multiple of itemsize: the string’s
    bytes, interpreted as machine values, directly initialize *a*’s items. Alternatively,
    *init* can be an iterable (of characters when *typecode* is ''u'', otherwise of
    numbers): each item of the iterable initializes one item of *a*. |'
  prefs: []
  type: TYPE_TB
- en: array.array’s advantage is that, compared to a list, it can save memory when
    you need to hold a sequence of objects all of the same (numeric or character)
    type. An array object *a* has a one-character, read-only attribute *a*.typecode,
    set on creation, which specifies the type of *a*’s items. [Table 16-7](#type_codes_for_the_array_module)
    shows the possible typecode values for array.
  prefs: []
  type: TYPE_NORMAL
- en: Table 16-7\. Type codes for the array module
  prefs: []
  type: TYPE_NORMAL
- en: '| typecode | C type | Python type | Minimum size |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ''b'' | char | int | 1 byte |'
  prefs: []
  type: TYPE_TB
- en: '| ''B'' | unsigned char | int | 1 byte |'
  prefs: []
  type: TYPE_TB
- en: '| ''u'' | unicode char | str (length 1) | See note |'
  prefs: []
  type: TYPE_TB
- en: '| ''h'' | short | int | 2 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| ''H'' | unsigned short | int | 2 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| ''i'' | int | int | 2 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| ''I'' | unsigned int | int | 2 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| ''l'' | long | int | 4 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| ''L'' | unsigned long | int | 4 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| ''q'' | long long | int | 8 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| ''Q'' | unsigned long long | int | 8 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| ''f'' | float | float | 4 bytes |'
  prefs: []
  type: TYPE_TB
- en: '| ''d'' | double | float | 8 bytes |'
  prefs: []
  type: TYPE_TB
- en: Minimum Size of typecode ‘u’
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '''u'' has an item size of 2 on a few platforms (notably, Windows) and 4 on
    just about every other platform. You can check the build type of a Python interpreter
    by using array.array(''u'').itemsize.'
  prefs: []
  type: TYPE_NORMAL
- en: The size, in bytes, of each item of an array *a* may be larger than the minimum,
    depending on the machine’s architecture, and is available as the read-only attribute
    *a*.itemsize.
  prefs: []
  type: TYPE_NORMAL
- en: Array objects expose all methods and operations of mutable sequences (as covered
    in [“Sequence Operations”](ch03.xhtml#sequence_operations)), except sort. Concatenation
    with + or +=, and slice assignment, require both operands to be arrays with the
    same typecode; in contrast, the argument to *a*.extend can be any iterable with
    items acceptable to *a*. In addition to the methods of mutable sequences (append,
    extend, insert, pop, etc.), an array object *a* exposes the methods and properties
    listed in [Table 16-8](#methods_and_properties_of_an_array_obje).
  prefs: []
  type: TYPE_NORMAL
- en: Table 16-8\. Methods and properties of an array object a
  prefs: []
  type: TYPE_NORMAL
- en: '| buffer_info | *a*.buffer_info() Returns a two-item tuple (*address*, *array_length*),
    where *array_length* is the number of items that you can store in *a*. The size
    of *a* in bytes is *a*.buffer_info()[1] * *a*.itemsize. |'
  prefs: []
  type: TYPE_TB
- en: '| byteswap | *a*.byteswap() Swaps the byte order of each item of *a*. |'
  prefs: []
  type: TYPE_TB
- en: '| frombytes | *a*.frombytes(*s*) Appends to *a* the bytes, interpreted as machine
    values, of bytes *s*. len(*s*) must be an exact multiple of *a*.itemsize. |'
  prefs: []
  type: TYPE_TB
- en: '| fromfile | *a*.fromfile(*f*, *n*) Reads *n* items, taken as machine values,
    from file object *f* and appends the items to *a*. *f* should be open for reading
    in binary mode—typically, mode ''rb'' (see [“Creating a File Object with open”](ch11.xhtml#creating_a_file_object_with_open)).
    When fewer than *n* items are available in *f*, fromfile raises EOFError after
    appending the items that are available (so, be sure to catch this in a **try**/**except**,
    if that’s OK in your app!). |'
  prefs: []
  type: TYPE_TB
- en: '| fromlist | *a*.fromlist(*L*) Appends to *a* all items of list *L*. |'
  prefs: []
  type: TYPE_TB
- en: '| fromunicode | *a*.fromunicode(*s*) Appends to *a* all characters from string
    *s*. *a* must have typecode ''u''; otherwise, Python raises ValueError. |'
  prefs: []
  type: TYPE_TB
- en: '| itemsize | *a*.itemsize Property that returns the size, in bytes, of each
    item in *a*. |'
  prefs: []
  type: TYPE_TB
- en: '| tobytes | *a*.tobytes() tobytes returns the bytes representation of the items
    in a. For any *a*, len(*a*.tobytes()) == len(*a*)**a*.itemsize. *f*.write(*a*.tobytes())
    is the same as *a*.tofile(*f*). |'
  prefs: []
  type: TYPE_TB
- en: '| tofile | *a*.tofile(*f*) Writes all items of *a*, taken as machine values,
    to file object *f*. Note that *f* should be open for writing in binary mode—for
    example, with mode ''wb''. |'
  prefs: []
  type: TYPE_TB
- en: '| tolist | *a*.tolist() Creates and returns a list object with the same items
    as *a*, like list(*a*). |'
  prefs: []
  type: TYPE_TB
- en: '| tounicode | *a*.tounicode() Creates and returns a string with the same items
    as *a*, like ''''.join(*a*). *a* must have typecode ''u''; otherwise, Python raises
    ValueError. |'
  prefs: []
  type: TYPE_TB
- en: '| typecode | *a*.typecode Property that returns the typecode used to create
    a*.* |'
  prefs: []
  type: TYPE_TB
- en: Extensions for Numeric Array Computation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you’ve seen, Python has great built-in support for numeric processing. The
    third-party library [SciPy](https://scipy.org), and many, *many* other packages,
    such as [NumPy](https://numpy.org), [Matplotlib](https://matplotlib.org), [SymPy](https://oreil.ly/oVs_S),
    [Numba](https://numba.pydata.org), [Pandas](https://pandas.pydata.org), [PyTorch](https://pytorch.org),
    [CuPy](https://cupy.dev), and [TensorFlow](https://www.tensorflow.org), provide
    even more tools. We introduce NumPy here, then provide a brief description of
    SciPy and some other packages, with pointers to their documentation.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need a lightweight, one-dimensional array of numbers, the standard library’s
    array module may suffice. If your work involves scientific computing, image processing,
    multidimensional arrays, linear algebra, or other applications involving large
    amounts of data, the popular third-party NumPy package meets your needs. Extensive
    documentation is available [online](https://docs.scipy.org/doc); a free PDF of
    Travis Oliphant’s [*Guide to NumPy*](https://oreil.ly/QA2xJ) is also available.^([2](ch16.xhtml#ch01fn123))
  prefs: []
  type: TYPE_NORMAL
- en: NumPy or numpy?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The docs variously refer to the package as NumPy or Numpy; however, in coding,
    the package is called numpy, and you usually import it with **import** numpy **as**
    np. This section follows those conventions.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy provides the class ndarray, which you can [subclass](https://oreil.ly/FK9qK)
    to add functionality for your particular needs. An ndarray object has *n* dimensions
    of homogeneous items (items can include containers of heterogeneous types). Each
    ndarray object *a* has a certain number of dimensions (aka *axes*), known as its
    *rank*. A *scalar* (i.e., a single number) has rank 0, a *vector* has rank 1,
    a *matrix* has rank 2, and so forth. An ndarray object also has a *shape*, which
    can be accessed as property shape. For example, for a matrix *m* with 2 columns
    and 3 rows, *m*.shape is (3,2).
  prefs: []
  type: TYPE_NORMAL
- en: NumPy supports a wider range of [numeric types](https://oreil.ly/HPxtV) (instances
    of dtype) than Python; the default numerical types are bool_ (1 byte), int_ (either
    int64 or int32, depending on your platform), float_ (short for float64), and complex_
    (short for complex128).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a NumPy array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several ways to create an array in NumPy. Among the most common are:'
  prefs: []
  type: TYPE_NORMAL
- en: With the factory function np.array, from a sequence (often a nested one), with
    *type inference* or by explicitly specifying *dtype*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With factory functions np.zeros, np.ones, or np.empty, which default to *dtype*
    float64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With factory function np.indices, which defaults to *dtype* int64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With factory functions np.random.uniform, np.random.normal, np.random.binomial,
    etc., which default to *dtype* float64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With factory function np.arange (with the usual *start*, *stop*, *stride*),
    or with factory function np.linspace (with *start*, *stop*, *quantity*) for better
    floating-point behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By reading data from files with other np functions (e.g., CSV with np.genfromtxt)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples of creating an array using the various techniques just
    described:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Shape, indexing, and slicing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each ndarray object *a* has an attribute *a*.shape, which is a tuple of ints.
    len(*a*.shape) is *a*’s *rank*; for example, a one-dimensional array of numbers
    (also known as a *vector*) has rank 1, and *a*.shape has just one item. More generally,
    each item of *a*.shape is the length of the corresponding dimension of *a*. *a*’s
    number of elements, known as its *size*, is the product of all items of *a*.shape
    (also available as property *a*.size). Each dimension of *a* is also known as
    an *axis*. Axis indices are from 0 and up, as usual in Python. Negative axis indices
    are allowed and count from the right, so -1 is the last (rightmost) axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each array *a* (except a scalar, meaning an array of rank 0) is a Python sequence.
    Each item *a*[*i*] of *a* is a subarray of *a*, meaning it is an array with a
    rank one less than *a*’s: *a*[*i*].shape == *a*.shape[1:]. For example, if *a*
    is a two-dimensional matrix (*a* is of rank 2), *a*[*i*], for any valid index
    *i*, is a one-dimensional subarray of *a* that corresponds to one row of the matrix.
    When *a*’s rank is 1 or 0, *a*’s items are *a*’s elements (just one element, for
    rank 0 arrays). Since *a* is a sequence, you can index *a* with normal indexing
    syntax to access or change *a*’s items. Note that *a*’s items are *a*’s subarrays;
    only for an array of rank 1 or 0 are the array’s *items* the same thing as the
    array’s *elements*.'
  prefs: []
  type: TYPE_NORMAL
- en: As with any other sequence, you can also *slice* *a*. After *b* = *a*[*i*:*j*],
    *b* has the same rank as *a*, and *b*.shape equals *a*.shape except that *b*.shape[0]
    is the length of the slice *a*[*i*:*j*], (i.e., when *a*.shape[0] > *j* >= *i*
    >= 0, the length of the slice is *j* - *i*, as described in [“Slicing a sequence”](ch03.xhtml#slicing_a_sequence)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have an array *a*, you can call *a*.reshape (or, equivalently, np.reshape
    with *a* as the first argument). The resulting shape must match *a*.size: when
    *a*.size is 12, you can call *a*.reshape(3, 4) or *a*.reshape(2, 6), but *a*.reshape(2,
    5) raises ValueError. Note that reshape does not work in place: you must explicitly
    bind or rebind the array, for example, *a* = *a*.reshape(*i*, *j*) or *b* = *a*.reshape(*i*,
    *j*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also loop on (nonscalar) *a* with **for**, just as you can with any
    other sequence. For example, this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'means the same thing as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: In these examples, each item *x* of *a* in the **for** loop is a subarray of
    *a*. For example, if *a* is a two-dimensional matrix, each *x* in either of these
    loops is a one-dimensional subarray of *a* that corresponds to a row of the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also index or slice *a* by a tuple. For example, when *a*’s rank is
    >= 2, you can write *a*[*i*][*j*] as *a*[*i*, *j*], for any valid *i* and *j*,
    for rebinding as well as for access; tuple indexing is faster and more convenient.
    *Do not put parentheses* inside the brackets to indicate that you are indexing
    *a* by a tuple: just write the indices one after the other, separated by commas.
    *a*[*i*, *j*] means exactly the same thing as *a*[(*i*, *j*)], but the form without
    parentheses is more readable.'
  prefs: []
  type: TYPE_NORMAL
- en: An indexing is a slicing in which one or more of the tuple’s items are slices,
    or (at most once per slicing) the special form ... (the Python built-in Ellipsis).
    ... expands into as many all-axis slices (:) as needed to “fill” the rank of the
    array you’re slicing. For example, *a*[1,...,2] is like *a*[1,:,:,2] when *a*’s
    rank is 4, but like *a*[1,:,:,:,:,2] when *a*’s rank is 6.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippets show looping, indexing, and slicing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Matrix operations in NumPy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As mentioned in [“The operator Module”](#the_operator_module), NumPy implements
    the operator @ for matrix multiplication of arrays. *a1* @ *a2* is like np.matmul(*a1*,
    *a2*). When both matrices are two-dimensional, they’re treated as conventional
    matrices. When one argument is a vector, you conceptually promote it to a two-dimensional
    array, as if by temporarily appending or prepending a 1, as needed, to its shape.
    Do not use @ with a scalar; use * instead. Matrices also allow addition (using
    +) with a scalar, as well as with vectors and other matrices of compatible shapes.
    Dot product is also available for matrices, using np.dot(*a1*, *a2*). A few simple
    examples of these operators follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: NumPy is rich and powerful enough to warrant whole books of its own; we have
    only touched on a few details. See the NumPy [documentation](https://oreil.ly/UceLt)
    for extensive coverage of its many, many features.
  prefs: []
  type: TYPE_NORMAL
- en: SciPy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whereas NumPy contains classes and functions for handling arrays, the SciPy
    library supports more advanced numeric computation. For example, while NumPy provides
    a few linear algebra methods, SciPy provides advanced decomposition methods and
    supports more advanced functions, such as allowing a second matrix argument for
    solving generalized eigenvalue problems. In general, when you are doing advanced
    numeric computation, it’s a good idea to install both SciPy and NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: '[SciPy.org](https://oreil.ly/WO3ON) also hosts [docs](https://oreil.ly/zf6-O)
    for a number of other packages, which are integrated with SciPy and NumPy, including
    [Matplotlib](https://matplotlib.org), which provides 2D plotting support; [SymPy](https://oreil.ly/fbfld),
    which supports symbolic mathematics; [Jupyter Notebook](http://jupyter.org), a
    powerful interactive console shell and web application kernel; and [Pandas](https://pandas.pydata.org),
    which supports data analysis and modeling. You may also want to take a look at
    [mpmath](https://mpmath.org), for arbitrary precision, and [sagemath](https://www.sagemath.org),
    for even richer functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: Additional numeric packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Python community has produced many more packages in the field of numeric
    processing. A few of them are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Anaconda](https://www.anaconda.com)'
  prefs: []
  type: TYPE_NORMAL
- en: A consolidated environment that simplifies the installation of Pandas, NumPy,
    and many related numerical processing, analytical, and visualization packages,
    and provides package management via its own conda package installer.
  prefs: []
  type: TYPE_NORMAL
- en: '[gmpy2](https://pypi.org/project/gmpy2)'
  prefs: []
  type: TYPE_NORMAL
- en: A module^([3](ch16.xhtml#ch01fn124)) that supports the GMP/MPIR, MPFR, and MPC
    libraries, to extend and accelerate Python’s abilities for multiple-precision
    arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: '[Numba](https://numba.pydata.org)'
  prefs: []
  type: TYPE_NORMAL
- en: A just-in-time compiler to convert Numba-decorated Python functions and NumPy
    code to LLVM. Numba-compiled numerical algorithms in Python can approach the speeds
    of C or FORTRAN.
  prefs: []
  type: TYPE_NORMAL
- en: '[PyTorch](https://pytorch.org)'
  prefs: []
  type: TYPE_NORMAL
- en: An open source machine learning framework.
  prefs: []
  type: TYPE_NORMAL
- en: '[TensorFlow](https://www.tensorflow.org/api_docs/python)'
  prefs: []
  type: TYPE_NORMAL
- en: A comprehensive machine learning platform that operates at large scale and in
    mixed environments, using dataflow graphs to represent computation, shared state,
    and state manipulation operations. TensorFlow supports processing across multiple
    machines in a cluster, and within-machine across multicore CPUs, GPUs, and custom-designed
    ASICs. TensorFlow’s main API uses Python.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch16.xhtml#ch01fn122-marker)) Superseded, technically, by the more recent,
    very similar standard [754-2008](https://oreil.ly/qL5nI), but practically still
    useful!
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch16.xhtml#ch01fn123-marker)) Python and the NumPy project have worked
    closely together for many years, with Python introducing language features specifically
    for NumPy (such as the @ operator and extended slicing) even though such novel
    language features are not (yet?) used anywhere in the Python standard library.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch16.xhtml#ch01fn124-marker)) Originally derived from the work of one
    of this book’s authors.
  prefs: []
  type: TYPE_NORMAL
