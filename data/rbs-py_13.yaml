- en: Chapter 11\. Defining Your Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。定义你的接口
- en: You have learned how to create your own user-defined types, but creating them
    is just half the battle. Now developers have to actually use your types. To do
    this, they use your type’s API. This is the set of types and related functions,
    along with any external functions, that a developer interacts with to use your
    code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学会如何创建自己的用户定义类型，但创建它们只是战斗的一半。现在开发者必须实际使用你的类型。为此，他们使用你类型的API。这是开发者与之交互以使用你的代码的类型和相关函数集合，以及任何外部函数。
- en: 'Once you get your types in front of users, those types will be used (and abused)
    in ways that you never thought of. And once the developers depend on your types,
    it will be hard to change their behavior. This gives rise to what I call the *Paradox
    of Code Interfaces*:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的类型展示给用户，它们将以你从未想到的方式被使用（和滥用）。一旦开发者依赖你的类型，改变它们的行为将变得困难。这导致了我所说的*代码接口悖论*的产生：
- en: You have one chance to get your interface right, but you won’t know it’s right
    until it’s used.
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你只有一次机会来正确设计你的接口，但是你不会知道它是否正确，直到它被使用。
- en: As soon as developers use the types you create, they come to depend on the behavior
    that those types encompass. If you try to make a backward-incompatible change,
    you potentially break all calling code. The riskiness in changing your interface
    is proportional to the amount of outside code depending on it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开发者使用你创建的类型，他们就会依赖这些类型所包含的行为。如果你尝试进行不向后兼容的更改，你可能会破坏所有调用代码。更改接口的风险与依赖它的外部代码量成正比。
- en: This paradox doesn’t apply if you control all the code that depends on your
    type; you can change it. But as soon as that type hits production, and people
    start using it, you’ll find it difficult to change. In a large codebase, where
    robustness and maintainability matter, coordinating the change and buy-in needed
    to make a sweeping change is costly. It becomes near impossible if your type is
    used by entities outside your organizational control, such as open source libraries
    or platform SDKs. This quickly leads to code that is difficult to work with, and
    code that is difficult to work with will slow developers down.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你控制所有依赖你类型的代码，这个悖论就不适用；你可以改变它。但是一旦这种类型投入生产，并且人们开始使用它，你会发现难以改变它。在一个庞大的代码库中，稳健性和可维护性很重要，协调变更和需要广泛支持的成本很高。如果你的类型被组织外的实体使用，比如开源库或平台SDK，这几乎是不可能的。这很快导致难以处理的代码，而难以处理的代码会减慢开发者的速度。
- en: What’s worse is that you won’t truly know if an interface is natural to use
    until enough people depend on it, giving rise to the paradox. How can you even
    begin to design an interface if you don’t know how it will be used? Sure, you
    know how *you* would use the interface, and that’s a great start, but you have
    an implicit bias when creating the interface. What feels natural to you won’t
    feel natural to everyone else. Your goal is for your users to do the right things
    (and avoid the wrong things) with minimal effort. Ideally, the users should not
    need to do anything extra to use your interface correctly.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，你不会真正知道一个接口是否自然易用，直到足够多的人依赖它，这就产生了这个悖论。如果你不知道接口将如何被使用，你又如何设计它呢？当然，你知道*你*会如何使用接口，这是一个很好的起点，但在创建接口时你有一种内在的偏见。对你来说自然的东西并不一定对其他人来说也自然。你的目标是让用户以最小的努力做正确的事情（并避免错误的事情）。理想情况下，用户使用你的接口不需要额外的操作。
- en: I don’t have a silver bullet for you; there is no foolproof way of writing an
    interface that meets everyone’s needs on the first try. Instead, I’ll talk about
    some principles you can apply to give you the best chance. For the cases where
    you need to make changes to an existing API, you’ll learn mitigation strategies.
    Your API is a first impression for other developers; make it count.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有一个对你来说完美无缺的方法；没有一种绝对可靠的方法来一次满足所有人的接口需求。相反，我会讨论一些原则，你可以应用它们来增加成功的机会。对于需要对现有API进行更改的情况，你将学习到减轻策略。你的API是其他开发者的第一印象；要珍惜它。
- en: Discussion Topic
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论话题
- en: What interfaces are hard to use in your codebase? Look for common errors that
    people make when using your types. Also look for parts of your interface that
    are rarely invoked, especially if you feel like they are useful. Why don’t users
    call these useful functions? Discuss what costs appear when developers encounter
    these hard-to-use interfaces.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码库中有哪些难以使用的接口？寻找使用你的类型时人们经常犯的常见错误。还要找出很少被调用的接口，特别是如果你觉得它们有用的话。为什么用户不调用这些有用的函数？讨论当开发者遇到这些难以使用的接口时会出现什么成本。
- en: Natural Interface Design
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自然的接口设计
- en: 'Your goal, tough as it may seem, is to make your interface appear natural to
    use. In other words, you want to reduce friction for the callers of your code.
    When code is hard to use, the following happens:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你的目标，尽管看起来很困难，是使你的接口看起来自然易用。换句话说，你希望减少调用者代码的摩擦力。当代码难以使用时，会发生以下情况：
- en: Duplicated functionality
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 重复的功能
- en: Some developers who find your types hard to use will write their own types,
    duplicating functionality. It may be healthy for different ideas to compete on
    a large scale (like competing open source projects), but it is not healthy for
    that divergence to be present in your codebase. Developers are presented with
    a multitude of types, not sure which one to use. With their attention split, their
    wires will get crossed and they will make mistakes, which creates bugs, which
    costs money. Also, if you want to add anything to one of these types, you need
    to add them in all the places the functionality has diverged, or you’ll create
    bugs, which costs money.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者发现你的类型难以使用，会编写他们自己的类型，重复功能。在大规模竞争（比如竞争的开源项目）中，不同的想法相互竞争可能是健康的，但在你的代码库中存在这种分歧并不健康。开发者面对大量类型，不确定应该使用哪一个。他们的注意力分散，思维混乱，会犯错，导致错误，这样会造成成本。另外，如果你想要向其中一个类型添加任何内容，你需要在所有功能分歧的地方添加，否则会产生错误，这样也会造成成本。
- en: Broken mental model
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 破碎的心智模型
- en: Developers build up a mental model of the code they work with. If certain types
    are difficult to reason about, that mental model breaks. Developers will misuse
    your types, causing subtle bugs. Perhaps they don’t call methods in the order
    that you require. Perhaps they miss calling a method that they should have. Perhaps
    they just misunderstand what the code is doing and pass the wrong information
    to it. Any of these will introduce fragility into your codebase.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者会建立起他们所使用的代码的心智模型。如果某些类型难以推理，那么心智模型就会破碎。开发者会误用你的类型，导致微妙的错误。也许他们没有按照你要求的顺序调用方法。也许他们忽略了应该调用的方法。也许他们只是误解了代码在做什么，并向其传递了错误的信息。任何这些都会给你的代码库引入脆弱性。
- en: Reduced testing
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 减少测试
- en: Code that is hard to use is hard to test. It doesn’t matter if it’s a complicated
    interface, a large chain of dependencies, or involved interactions; if you can’t
    easily test the code, fewer tests will be written. The fewer tests that are written,
    the fewer bugs you’ll catch when things change. It is very frustrating to deal
    with tests breaking in subtle ways every time a seemingly unrelated change is
    made.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 难以使用的代码很难测试。无论是复杂的接口，还是庞大的依赖链，或是复杂的交互；如果无法轻松测试代码，就会少写测试。写的测试越少，当事情变化时捕获的错误就越少。每次做一个看似无关的改变时，测试以微妙的方式断开都是非常令人沮丧的。
- en: 'Hard-to-use code will make your codebase unhealthy. You must take special care
    when designing your interfaces. Try to adhere to this rule of thumb from Scott
    Meyers:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用困难的代码会使你的代码库变得不健康。在设计接口时，你必须格外小心。试着遵循Scott Meyers的这个经验法则：
- en: Make interfaces easy to use correctly and hard to use incorrectly.^([1](part0015_split_009.html#idm45644739470600))
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使接口易于正确使用，难以错误使用。（参见[第1章](part0003_split_000.html#intro)中提到的最小惊奇法则的微妙陈述^([1](part0015_split_009.html#idm45644739470600))）
- en: You want developers to find your type easy to use, as if everything behaved
    as expected (this is a subtle restatement of the Law of Least Surprise, as mentioned
    in [Chapter 1](part0003_split_000.html#intro)). Furthermore, you also want to
    prevent users from using your types the wrong way. It is your job to think about
    all the behaviors that you should support and forbid in your interface. To do
    this, you need to get into the heads of your collaborators.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望开发者能够轻松使用你的类型，就好像一切都按照预期行为一样（这是最小惊奇法则的一个微妙的陈述）。此外，你还希望阻止用户错误地使用你的类型。你的工作是考虑在你的接口中应该支持和禁止的所有行为。为此，你需要深入了解你的合作者的思维。
- en: Thinking Like a User
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以用户为中心思考
- en: It’s tricky to think like a user, for you have been bestowed with the Curse
    of Knowledge. No arcane hex or mystical spell causes this; it is a by-product
    of your time with the codebase. As you build out ideas, you become so intimately
    familiar with them that it can blind you to how new users perceive your code.
    The first step to dealing with cognitive biases is to acknowledge them. From that
    point, you can take biases into account as you try to get into your users’ mindspace.
    Here are some useful strategies you can employ.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 想象成用户思考是棘手的，因为你已经被赋予了知识的诅咒。这不是什么奥秘的咒语或神秘的咒文引起的，而是你在代码库中度过的时间的副产品。当你构建想法时，你变得如此熟悉它们，以至于可能会蒙蔽你如何看待新用户对你的代码的感知。处理认知偏见的第一步是承认它们的存在。从那时起，你可以在试图理解用户思维空间时考虑这些偏见。以下是一些有用的策略，你可以采用。
- en: Test-driven development
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: '*Test-driven development* (TDD), formulated by Kent Beck in the early 2000s,
    is a popular framework for testing your code.^([2](part0015_split_009.html#idm45644739457384))
    TDD revolves around a simple loop:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*测试驱动开发*（TDD），由肯特·贝克在21世纪初制定，是一种流行的测试代码框架。^([2](part0015_split_009.html#idm45644739457384))
    TDD围绕着一个简单的循环：'
- en: Add a failing test.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个失败的测试。
- en: Write just enough code to pass that test.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只需写足够的代码来通过那个测试。
- en: Refactor.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构。
- en: There are entire books written about TDD, so I won’t go into too much detail
    about the mechanics.^([3](part0015_split_009.html#idm45644739452664)) However,
    the intent of TDD is *fabulous* for understanding how to use a type.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有关TDD的整本书，我就不详细介绍了。^([3](part0015_split_009.html#idm45644739452664)) 然而，TDD的目的是*了解如何使用一个类型*，这是非常棒的。
- en: Many developers think that test-*driven* development (writing tests first) has
    similar benefits to test-*after* development (writing tests second). In both cases,
    you have tested code, right? When simplified to this degree, TDD doesn’t seem
    worth the effort.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者认为测试*驱动*开发（先写测试）与测试*后*开发（后写测试）有类似的好处。无论哪种情况，你都有测试过的代码，对吧？当简化到这个程度时，TDD似乎不值得付出这么多的努力。
- en: However, this is an unfortunate oversimplification. The confusion stems from
    thinking of TDD as a testing methodology, when in fact, it is a *design methodology*.
    The tests are important, but they are merely a by-product of the methodology.
    The true value lies in how tests help design your interface.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是一个不幸的过度简化。混淆的根源在于把TDD看作是一种测试方法论，而实际上，它是一种*设计方法论*。测试很重要，但它们只是方法论的副产品。真正的价值在于测试如何帮助设计你的接口。
- en: With TDD, you are able to see how calling code looks before you write the implementation.
    Since you write the test first, you are given a chance to pause and ask yourself
    if how you interact with your types feels frictionless. If you find yourself making
    confusing function calls, building up long chains of dependencies, or having to
    write tests in a fixed order, you are experiencing red flags that should alert
    you that the type you’re building is too complicated. In these cases, reevaluate
    or refactor your interface. How great is it that you can simplify this code before
    you even write it?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通过TDD，你可以在编写实现之前看到调用代码的样子。因为你先写测试，所以你有机会停下来问自己，你与你的类型如何交互感觉是否无摩擦。如果你发现自己在做令人困惑的函数调用、构建长链依赖或者必须按固定顺序编写测试，那么这些都是应该警惕你正在构建的类型过于复杂的红旗。在这些情况下，重新评估或重构你的接口。你能在甚至写代码之前就简化它多么棒？
- en: As an additional benefit, your tests serve as a form of documentation. Other
    developers will want to know how to use your code, especially the parts that are
    not described in top-level documentation. A good set of comprehensive unit tests
    provides working documentation of exactly how to use your type; you want them
    to leave a good first impression. Just as your code is a single source of truth
    for the behavior in your system, your tests are the single source of truth for
    interacting with your code.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的好处，你的测试也可以作为文档的一种形式。其他开发者希望知道如何使用你的代码，尤其是那些没有在顶层文档中描述的部分。一套完整的单元测试提供了关于如何使用你的类型的工作文档；你希望它们给人留下良好的第一印象。正如你的代码是系统行为的唯一真实来源，你的测试是与你的代码交互的唯一真实来源。
- en: README-driven development
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于README的开发
- en: 'Similar to TDD, README-driven development (RDD), [coined by Tom Preston-Werner](https://oreil.ly/qd16A),
    is another design methodology aimed at catching hard-to-use code before it’s written.
    The goal with RDD is to distill your top-level ideas and most important interactions
    with your code into a single document that lives in your project: a README file.
    This is a great way to formulate how different parts of your code interact, and
    might provide higher level patterns for users to follow.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于TDD，README驱动开发（RDD），由[Tom Preston-Werner创造](https://oreil.ly/qd16A)，是另一种旨在在编写代码之前捕捉难以使用的代码的设计方法论。RDD的目标是将您的顶层思想和与代码的最重要交互精炼成一个单一文档，该文档位于您的项目中：README文件。这是制定代码不同部分如何交互的好方法，并可能为用户提供更高级别的模式。
- en: 'RDD boasts some of the following benefits:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: RDD拥有以下一些好处：
- en: No need to create every level of documentation up front, like you would in a
    Waterfall methodology.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需像瀑布模型中那样一次性创建每个层级的文档。
- en: A README is often the first thing a developer sees; RDD gives you a chance to
    craft the best first impression you can.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: README通常是开发者看到的第一件事情；RDD给了你一个机会来打造尽可能好的第一印象。
- en: It is easier to change the documentation based on team discussion than it is
    to change written code.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据团队讨论更改文档要比更改已写好的代码容易。
- en: You don’t need to use the README to explain poor code decisions; instead, the
    code needs to morph to support the ideal use cases.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不需要使用README来解释糟糕的代码决策；相反，代码需要变形以支持理想的用例。
- en: Remember, you are only successful in building maintainable software if future
    developers can actually maintain it. Give them every chance you can to succeed
    and craft them an experience starting at your documentation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，只有在未来的开发者能够真正维护软件时，你才能成功构建可维护的软件。给予他们尽可能多的成功机会，并为他们在文档开始时创造一种体验。
- en: Usability testing
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可用性测试
- en: 'Ultimately, you are trying to think about how your users think. There is a
    whole discipline dedicated to this very task: user experience (UX). UX is another
    area where there are countless books available, so I’ll just focus on one strategy
    that has done me wonders in simplifying code: usability testing.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，您正在尝试考虑用户如何思考。有一个完全致力于这项任务的学科：用户体验（UX）。UX是另一个有无数书籍可供选择的领域，所以我将专注于一个让我在简化代码方面取得显著成效的策略：可用性测试。
- en: Usability testing is the process of actively asking your users what they think
    of your product. It sounds so simple, doesn’t it? In order to think about how
    your users will behave, just ask them. The simplest thing you can do is talk to
    potential users (in this case, other developers), but it’s easy to overlook.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性测试是主动询问用户对您的产品的看法的过程。听起来很简单，对吧？为了考虑用户会如何行动，只需询问他们。您可以做的最简单的事情就是与潜在用户（在这种情况下，其他开发者）交谈，但很容易忽视。
- en: It’s incredibly easy to get started with usability testing through hallway testing.
    As you design your interface, just grab the first person to walk down your hallway
    and ask them to give feedback on your design. This is a great low-cost way of
    learning pain points. Don’t take this advice too literally though. Feel free to
    expand beyond whoever you see in a hallway and ask teammates, peers, or testers
    to evaluate your interface.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过走廊测试非常容易开始进行可用性测试。当您设计界面时，只需抓住第一个经过走廊的人，并请他们就设计给予反馈意见。这是学习痛点的一个很好的低成本方法。不过，不要太字面理解这个建议。请随时扩展到除了走廊上看到的人之外，并请队友、同事或测试人员评估您的界面。
- en: However, for interfaces that will be used by a much broader audience (such as
    the interface of a popular open source library), you may want something a tad
    more formal. In these cases, usability testing involves placing your prospective
    users in front of the interface that you’re writing. You give them a set of tasks
    to complete, and then observe. Your role is not to teach them or lead them through
    the exercises, but to see where they struggle and where they excel. Learn from
    their struggles; they are showing areas that are definitively hard to use.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于将由更广泛的受众使用的界面（例如流行的开源库的界面），您可能需要更正式一些。在这些情况下，可用性测试涉及将您的潜在用户放在您正在编写的界面前。您给他们一组任务来完成，然后观察。您的角色不是教导他们或引导他们完成练习，而是看到他们在哪里遇到困难，以及在哪些地方表现出色。从他们的困难中学习；他们展示了明显难以使用的区域。
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Usability testing is a great task for the more junior members on your team.
    Their curse of knowledge won’t be as strong as with the senior members, and they
    will be more likely to evaluate the design with a fresh set of eyes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性测试对于团队中的初级成员来说是一个很好的任务。他们的知识诅咒不像高级成员那样强烈，他们更有可能用一双新的眼睛评估设计。
- en: Natural Interactions
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自然交互
- en: Donald Norman describes a mapping as a relationship between “controls and their
    movements with results in the real world.” That mapping is natural if it “takes
    advantage of physical analogies and cultural standards, [leading] to immediate
    understanding.”^([4](part0015_split_009.html#idm45644739841848)) This is what
    you strive for when you write an interface. You want that immediate understanding
    to eliminate confusion.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 唐纳德·诺曼（Donald Norman）将映射描述为“控件及其运动与现实世界结果之间的关系”。如果这种映射“利用物理类比和文化标准，[会导致]立即理解。”^([4](part0015_split_009.html#idm45644739841848))
    这正是你在设计界面时所追求的。你希望那种即时理解消除混乱。
- en: The “controls and their movements” in this case are the functions and types
    that make up your interface. The “results in the real world” represent the behavior
    of the code. For this to feel natural, the operations have to agree with the mental
    model of the user. This is what Donald Norman means when talking about “physical
    analogies and cultural standards.” You must connect with the readers of your code
    in a way that they understand, drawing on their experiences and knowledge. The
    best way to do this is mapping your domain and other common knowledge into your
    code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，“控制及其运动”是构成你界面的功能和类型。在这里，“现实世界的结果”代表代码的行为。为了使这感觉自然，操作必须符合用户的心理模型。这就是唐纳德·诺曼在谈到“物理类比和文化标准”时的意思。你必须以一种他们理解的方式与代码的读者联系，利用他们的经验和知识。将你的领域和其他常见知识映射到你的代码中是做到这一点的最佳方式。
- en: When designing an interface, you need to think through the entire life cycle
    of a user’s interactions and ask yourself if the entirety of it maps to what a
    user unfamiliar with your code would understand. Model your interface such that
    it is easy to comprehend for someone who knows the domain well, even if they aren’t
    familiar with code. As you do this, your interface becomes intuitive, which lessens
    the chances of developers making mistakes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计界面时，你需要考虑用户交互的整个生命周期，并问自己是否整体上与不熟悉你代码的用户的理解相匹配。模拟你的界面，使得对于熟悉该领域但不熟悉代码的人易于理解。当你这样做时，你的界面变得直观，这减少了开发人员犯错误的可能性。
- en: Natural Interfaces in Action
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自然界面的实际应用
- en: For this chapter, you’re going to design an interface for part of an automated
    grocery pick-up service. A user scans their recipes using their smartphone, and
    the app will automatically figure out what ingredients are required. After the
    user confirms the order, the app queries local grocery stores for ingredient availability
    and schedules delivery. [Figure 11-1](part0015_split_005.html#figure_11_1) provides
    a representation of this workflow.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你将设计一个自动化杂货取货服务的部分界面。用户使用智能手机扫描其食谱，应用程序将自动确定所需的成分。用户确认订单后，应用程序查询本地杂货店的成分可用性并安排送货。[图 11-1](part0015_split_005.html#figure_11_1)提供了这个工作流程的表示。
- en: I’m going to focus on the specific interface for building up an order given
    a set of recipes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我将专注于特定界面，以构建给定一组食谱的订单。
- en: '![Workflow for automated grocery delivery app](../images/00015.gif)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![自动化杂货送货应用的工作流程](../images/00015.gif)'
- en: Figure 11-1\. Workflow for automated grocery delivery app
  id: totrans-56
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-1\. 自动化杂货送货应用的工作流程
- en: 'To represent a recipe, I’ll modify parts of the `Recipe` `dataclass` from [Chapter 9](part0013_split_000.html#dataclasses):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示一个食谱，我将修改来自[第9章](part0013_split_000.html#dataclasses)的`Recipe` `dataclass`的部分：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The codebase also has functions and types to retrieve local grocery store inventory:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 代码库还具有用于获取本地杂货店库存的功能和类型：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The other developers in the codebase have already set up the code to figure
    out the recipes from smartphone scans, but now they need to generate the ingredient
    list to order from each grocery store. That’s where you come in. Here’s what they
    have so far:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 代码库中的其他开发人员已经设置好代码，从智能手机扫描中找出食谱，但现在他们需要生成从每个杂货店订购的配料清单。这就是你的任务。以下是他们目前的情况：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Your goal is to fill in the blanks marked `HELP` or `????`. I want you to get
    in the habit of deliberately designing your interface before you start coding.
    How would you describe the purpose of the code to a nontechnical product manager
    or marketing agent? Take a few minutes before looking at the following code: how
    do you want a user to interact with your interface?'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你的目标是填写标记为`HELP`或`????`的空白。我希望你在开始编码之前刻意设计你的接口。你会如何向非技术产品经理或市场代理人描述代码的目的？在查看以下代码之前花几分钟：你希望用户如何与你的接口交互？
- en: 'Here’s what I came up with (there are plenty of ways to solve this; it’s OK
    if you have something vastly different):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我想出的解决方案（解决这个问题的方法有很多；如果你有完全不同的东西，也没关系）：
- en: For each recipe received, grab all the ingredients and aggregate them together.
    This becomes an `Order`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于收到的每个食谱，获取所有原料并将它们聚合在一起。这就成为一个`Order`。
- en: An `Order` is a list of ingredients, and the user can add/remove ingredients
    as needed. However, once confirmed, the `Order` should not be changeable.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个`Order`是一组原料，用户可以根据需要添加/删除原料。但是，一旦确认，`Order`就不应该再被修改。
- en: Once the order is confirmed, take all the ingredients and figure out what stores
    have the items available. This is a `Grocery List`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦订单确认，获取所有原料并找出哪些商店有这些物品可用。这是一个`Grocery List`。
- en: A `Grocery List` contains a list of stores and the items to pick up from each
    store. Each item is reserved at the store until the app places the order. Items
    may come from different stores; the app tries to find the cheapest item that matches.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Grocery List`包含一系列商店和要从每个商店提取的物品。每个项目都在商店预订，直到应用程序下订单。物品可能来自不同的商店；应用程序会尝试找到与之匹配的最便宜的物品。'
- en: Once the user confirms the `GroceryList`, place the order. Grocery items are
    unreserved and set for delivery.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦用户确认`GroceryList`，就下订单。杂货商品将被取消预订并设置为送货。
- en: The order is delivered to the user’s home.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订单送到用户家里。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Isn’t it amazing that you can come up with an implementation without having
    to know exactly how `get_recipe_from_scans` or `get_grocery_inventory` is implemented?
    This is the beauty of having types to describe domain concepts: if these were
    represented by tuples or dictionaries (or with no type annotations, which makes
    me shudder), you’d have to go digging through the codebase finding out what data
    you were dealing with.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否觉得很神奇，你可以在不必知道`get_recipe_from_scans`或`get_grocery_inventory`的具体实现方式的情况下想出一个实现？这就是使用类型描述领域概念的美妙之处：如果这些是由元组或字典表示的（或者没有类型注释，这让我感到恐惧），你将不得不在代码库中查找数据，找出你正在处理的数据是什么。
- en: That description of the interface contained no code concepts; it was all described
    in a way that is familiar to workers in the grocery domain. When designing an
    interface, you want to map as naturally to the domain as you can.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 描述接口的内容中没有代码概念；所有内容都以熟悉的方式描述给杂货行业的工作人员。设计接口时，你希望尽可能自然地映射到领域中。
- en: 'Let’s start with the order handling by creating a class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从订单处理开始创建一个类：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Not too bad of a start. If I look at the first step of my description above,
    it matches pretty closely to the code. I am getting the ingredients from each
    recipe and aggregating them together in a set. I’m having some trouble with how
    I want to represent adding ingredients to the set I’m already tracking, but I’ll
    come back to this in a bit, I promise.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 开始并不算太糟。如果我看一下上面描述的第一步，它与代码非常相似。我正在从每个食谱中获取原料，并将它们汇总到一起成为一个集合。我对如何表示向我已经跟踪的集合添加原料感到有些困扰，但我保证一会儿会回来解决这个问题。
- en: 'For now, I want to make sure that I am properly representing the invariant
    of an `Order`. If the order is confirmed, a user should not be able to modify
    anything inside it. I’ll change the `Order` class to do the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我想确保我正确地表示了`Order`的不变量。如果订单已确认，则用户不应该能够修改其中任何内容。我将更改`Order`类以执行以下操作：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now I have the first two items on my list represented in code, and the code
    mirrors the description pretty closely. By using a type to represent the `Order`,
    I have created an interface for the calling code to operate with. You can construct
    an order with `order = Order(recipes)` and then use that order to add ingredients,
    change the amount of existing ingredients, and handle confirmation logic.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经用代码表示了列表中的前两个项目，并且代码与描述非常相似。通过使用类型来表示`Order`，我已经为调用代码创建了一个接口。你可以用`order
    = Order(recipes)`构造一个订单，然后使用该订单添加原料，更改现有原料的数量，并处理确认逻辑。
- en: The only thing that is missing is that `????` when adding an ingredient that
    I’m already tracking (such as adding an extra 3 cups of flour). My first instinct
    was to just add the amounts together, but that won’t work if the units of measure
    are different, such as adding 1 cup of olive oil to 1 tablespoon. Neither 2 tablespoons
    nor 2 cups is the right answer.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一遗漏的是当添加一个我已经跟踪的成分时（例如额外添加3杯面粉），我需要`????`。我的第一反应是将数量加在一起，但如果计量单位不同就行不通，比如将1杯橄榄油加到1汤匙中。既不是2汤匙也不是2杯是正确答案。
- en: 'I could do type conversions right here in the code, but that doesn’t feel natural.
    What I really want to do is do something like `already_tracked_ingredient += new_ingredient`.
    But doing that gives me an exception:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以在代码中进行类型转换，但这并不自然。我真正想做的是像这样做一些事情：`already_tracked_ingredient += new_ingredient`。但这样做会导致异常：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: However, this is achievable; I just have to use a little Python magic to make
    it so.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，这是可以实现的；我只需使用一点Python魔术就可以搞定。
- en: Magic Methods
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 魔术方法
- en: '*Magic methods* allow you to define custom behavior when built-in operations
    are invoked in Python. A magic method is prefixed and suffixed by two underscores.
    Because of this, they are sometimes called *dunder* methods (or *double underscore*
    methods). You’ve already seen them in earlier chapters:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*魔术方法*允许您在Python中调用内置操作时定义自定义行为。魔术方法由两个下划线前缀和后缀。因此，它们有时被称为*dunder*方法（或*双下划线*方法）。您已经在早期章节中看到了它们：'
- en: In [Chapter 10](part0014_split_000.html#classes), I used the `__init__` method
    to construct a class. `__init__` gets called whenever a class is constructed.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第10章](part0014_split_000.html#classes)中，我使用`__init__`方法来构建一个类。每次构造类时都会调用`__init__`。
- en: In [Chapter 9](part0013_split_000.html#dataclasses), I used `__lt__`, `__gt__`,
    and others to define what happens when two objects were compared with < or >,
    respectively.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第9章](part0013_split_000.html#dataclasses)中，我使用了`__lt__`、`__gt__`等方法来定义当两个对象用<或>进行比较时的行为。
- en: In [Chapter 5](part0008_split_000.html#collections), I introduced `__getitem__`
    for intercepting calls to indexing with brackets such as `recipes['Stromboli']`.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第5章](part0008_split_000.html#collections)中，我介绍了`__getitem__`，用于拦截用括号进行索引的调用，例如`recipes['Stromboli']`。
- en: 'I can use the magic method `__add__` to control behavior for addition:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用魔术方法`__add__`来控制加法的行为：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now with the `__add__` method defined, I can add ingredients together with
    the `+` operator. The `add_ingredient` method can look like the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有了定义的`__add__`方法，我可以使用`+`运算符将成分相加。`add_ingredient`方法可以如下所示：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: I can now express the idea of adding ingredients naturally. It doesn’t stop
    here, either. I can define subtraction, or multiplication/division (for scaling
    serving numbers), or comparison. It is far easier for users to understand your
    codebase when such natural operations are available. Just about every operation
    in Python has a magic method backing it. There are so many that I can’t even begin
    to enumerate them all. However, some common methods are listed in [Table 11-1](part0015_split_006.html#table_11-2).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以自然地表达添加成分的想法了。这还不止于此。我还可以定义减法，或乘法/除法（用于扩展服务数量），或比较。当这些自然操作可用时，用户更容易理解您的代码库。Python中几乎每个操作都有一个支持它的魔术方法。有很多方法，我甚至无法一一列举。不过，一些常见方法列在[表11-1](part0015_split_006.html#table_11-2)中。
- en: Table 11-1\. Common magic methods in Python
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 表11-1\. Python中常见的魔术方法
- en: '| Magic method | Used for |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 魔术方法 | 用途 |'
- en: '| --- | --- |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `__add__`, `__sub__`, `__mul__`, `__div__` | Arithmetic operations (add,
    subtract, multiply, divide) |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `__add__`, `__sub__`, `__mul__`, `__div__` | 算术操作（加法、减法、乘法、除法） |'
- en: '| `__bool__` | Implicitly converting to Boolean for `if <expression>` checks
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `__bool__` | 隐式转换为布尔值用于`if <expression>`检查 |'
- en: '| `__and__`, `__or__` | Logical operations (`and` and `or`) |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `__and__`, `__or__` | 逻辑操作（`and`和`or`） |'
- en: '| `__getattr__`, `__setattr__`, `__delattr__` | Attribute access (such as `obj.name`
    or `del obj.name`) |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `__getattr__`, `__setattr__`, `__delattr__` | 属性访问（如`obj.name`或`del obj.name`）
    |'
- en: '| `__le__`, `__lt__`, `__eq__`, `__ne__`, `__gt__`, `__ge__` | Comparision
    (`<=`, `<`, `==`, `!=`, `>`, `>=`) |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `__le__`, `__lt__`, `__eq__`, `__ne__`, `__gt__`, `__ge__` | 比较（`<=`、`<`、`==`、`!=`、`>`、`>=`）
    |'
- en: '| `__str__`, `__repr__` | Converting to string (str()) or reproducible (repr())
    forms |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `__str__`, `__repr__` | 转换为字符串（str()）或可复制（repr()）形式 |'
- en: If you want to learn more, check out the Python documentation regarding the
    [data model](https://oreil.ly/jHBaZ).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多，请查阅有关[数据模型](https://oreil.ly/jHBaZ)的Python文档。
- en: Discussion Topic
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论主题
- en: What are some types in your codebase that could benefit from a more natural
    mapping? Discuss where magic methods might make sense, and where they might not.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码库中有哪些类型可以从更自然的映射中受益？讨论魔术方法何时有意义，何时没有。
- en: Context Managers
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文管理器
- en: 'Your code can now handle orders, but it’s time to fill in the other half: the
    grocery list handling. I want you to take a break from reading and think about
    filling in the blanks of the grocery list handling code. Take what you learned
    from the last section and create an interface that naturally maps to the written
    description of the problem.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在可以处理订单，但是现在是填写杂货清单处理的另一半的时候了。我希望你停下来阅读，考虑填写杂货清单处理代码中的空白。从上一节中学到的内容，并创建一个自然映射到问题描述的接口。
- en: 'Here’s a reminder of the grocery list handling:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是处理杂货清单的提醒：
- en: A `Grocery List` contains a list of stores and the items to pick up from each
    store. Each item is reserved at the store until the app places the order. Items
    may come from different stores; the app tries to find the cheapest item that matches.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Grocery List`包含一系列商店和从每个商店提取的项目。每个项目在商店中保留，直到应用程序下订单。商品可能来自不同的商店；应用程序尝试找到符合条件的最便宜的商品。'
- en: Once the user confirms the `GroceryList`, place the order. Grocery items are
    unreserved and set for delivery.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦用户确认了`GroceryList`，就下单了。杂货商品取消预订并设置为送货。
- en: 'From a calling code perspective, here’s what I have:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从调用代码的角度来看，这是我拥有的：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Given this grocery list interface, this is certainly easy to use (if I do say
    so myself). It’s clear what the code is doing, and if making the interface intuitive
    were the full story, I’d be golden. But I forgot the other half of Scott Meyers’s
    quote. I forgot to make the code *hard to use incorrectly*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这个杂货清单接口，这肯定很容易使用（如果我这么说的话）。清楚代码正在做什么，如果使接口直观成为完整故事的一部分，我会很成功。但我忘了Scott Meyers的引用的另一半。我忘了让代码*难以使用不正确*。
- en: Take a look again. What happens if the user doesn’t confirm their order? What
    if some exception were thrown while waiting? If this were to happen, I would never
    unreserve the items, leaving them reserved in perpetuity. Sure, I could hope that
    calling code would always try to catch an exception, but that’s easy to forget
    to do. In fact, it’d be quite easy to use incorrectly, wouldn’t you agree?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 再看看。如果用户不确认他们的订单会发生什么？如果在等待时抛出了某些异常怎么办？如果发生这种情况，我永远不会取消预订的商品，使其永久保留。当然，我可以希望调用代码总是尝试捕获异常，但这很容易忘记做。事实上，它可能非常容易使用不正确，你同意吗？
- en: Tip
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: You can’t only focus on the happy path, which is the execution of the code when
    everything goes as planned. Your interface must also handle all the possible ways
    problems can arise.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能只关注快乐路径，即一切按计划进行的代码执行。您的接口还必须处理可能出现问题的所有可能方式。
- en: Wanting to automatically invoke some sort of function when you are done with
    an operation is a common case in Python. File open/close, session authenticate/logout,
    database command batching/submission; these are all examples where you want to
    always make sure to invoke the second operation, regardless of what the previous
    code did. If you don’t, you often leak resources or otherwise tie up the system.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成操作后自动调用某种功能是Python中的常见情况。文件打开/关闭，会话身份验证/注销，数据库命令批处理/提交；这些都是您希望始终确保调用第二个操作的例子，无论以前的代码做了什么。如果不这样做，您经常会泄漏资源或以其他方式占用系统。
- en: 'Chances are, you’ve actually run across how to handle this: using a `with`
    block.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，您实际上已经了解如何处理此问题：使用`with`块。
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is something you learn early on in your Python journey as a best practice.
    As soon as the `with` block is finished (when the code returns to the original
    indent level of the `with` statement), Python closes the opened file. This is
    a convenient way of making sure that an operation occurs, even with no explicit
    user interaction. This is the key you need to making your grocery list interface
    hard to use incorrectly—what if you could make the grocery list unreserve items
    automatically, regardless of what path the code takes?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你在Python旅程的早期学习中作为最佳实践学到的东西。一旦`with`块完成（当代码返回到`with`语句的原始缩进级别时），Python关闭打开的文件。这是确保操作发生的便捷方式，即使没有明确的用户交互。这是使您的杂货清单接口难以不正确使用的关键—无论代码走哪条路径，都可以使杂货清单自动取消预订商品的方式。
- en: 'To do this, you need to employ a *context manager*, which is a Python construct
    that lets you take advantage of `with` blocks. Using a context manager, I can
    make our grocery list code much more fault-tolerant:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，您需要使用*上下文管理器*，这是Python的一种构造，允许您利用`with`块。使用上下文管理器，我可以使我们的杂货清单代码更加容错：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Any function decorated with `@contextmanager` will be usable alongside a `with`
    block. I construct a `_GroceryList` (notice how it’s private, so nobody should
    be creating a grocery list in ways other than `create_grocery_list`), then *yield*
    it. Yielding a value interrupts this function, returning the value yielded to
    the calling code. The user can then use it like so:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 任何用`@contextmanager`装饰的函数都可以与`with`块一起使用。我构造了一个`_GroceryList`（注意它是私有的，因此没有人应该以`create_grocery_list`之外的方式创建杂货清单），然后*yield*它。yield一个值会中断这个函数，将yield的值返回给调用代码。然后用户可以这样使用它：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The yielded value becomes `grocery_list` in the example above. When the `with`
    block exits, execution is returned to the context manager, right after the yield
    statement. It doesn’t matter if an exception is thrown, or if the `with` block
    finishes normally; because I wrapped our yield in a `try...finally block`, the
    grocery list will always clear any reserved items.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，yielded 的值变成了`grocery_list`。当`with`块退出时，执行会返回到上下文管理器，就在yield语句之后。无论是否抛出异常，或者`with`块是否正常结束；因为我将我们的yield包装在了一个`try...finally`块中，杂货清单总是会清除任何保留的项目。
- en: This is how you can effectively force a user to clean up after themselves. You
    are eliminating an entire class of errors that can happen when you use context
    managers—the errors of omission. Errors of omission are so easy to make; you literally
    have to do nothing. Instead, a context manager lets users do the right thing,
    even when they do nothing. It’s a sure sign of a robust codebase when a user can
    do the right thing without even knowing it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何有效地强制用户在自己之后进行清理的方法。通过使用上下文管理器，您消除了可能发生的整个错误类别——遗漏错误。遗漏错误非常容易发生；您只需什么都不做。相反，上下文管理器让用户在什么都不做时也能做正确的事情。当用户即使在不知情的情况下也能做正确的事情时，这表明代码库是稳健的。
- en: Warning
  id: totrans-127
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Context managers will not finish if the program is forcibly closed, such as
    a force kill from the operating system or a power loss. Context managers are just
    a tool to keep developers from forgetting to clean up after themselves; make sure
    your system can still handle things outside a developer’s control.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序被强制关闭，例如操作系统的强制终止或断电，上下文管理器将无法完成。上下文管理器只是一个工具，用来防止开发人员忘记在自己之后进行清理；确保您的系统仍然可以处理开发人员无法控制的情况。
- en: Closing Thoughts
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结思考
- en: You can create all the types in the world, but if other developers can’t use
    them without error, your codebase will suffer. Just like a house needs a strong
    foundation to stand upon, the types you create and vocabulary you surround them
    with need to be rock solid for your codebase to be healthy. When you have natural
    interfaces to your code, future developers will be able to reach for these types
    and build new features effortlessly. Have empathy for those future developers,
    and design your types with care.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建世界上所有类型，但如果其他开发人员在没有错误的情况下无法使用它们，您的代码库将受到影响。就像房子需要坚实的基础才能站立一样，您创建的类型和围绕它们的词汇需要为您的代码库提供坚实的支持。当您的代码有自然的接口时，未来的开发人员将能够轻松地获取这些类型并构建新功能。为那些未来的开发人员怀有同情心，并精心设计您的类型。
- en: You’ll need to think through the domain concepts your types represent, and how
    users interact with those types. By building a natural mapping, you tie real-world
    operations to your codebase. The interfaces you build should feel intuitive; remember,
    they should be easy to use correctly and hard to use incorrectly. Use every trick
    and tip at your disposal, from proper naming to magic methods to context managers.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要仔细考虑您的类型代表的领域概念，以及用户如何与这些类型交互。通过建立自然映射，将真实世界的操作与您的代码库联系起来。您构建的接口应该感觉直观；记住，它们应该易于正确使用并难以错误使用。利用您掌握的所有技巧和窍门，从正确的命名到魔术方法到上下文管理器。
- en: In the next chapter, I’m going to cover how types relate to one another when
    you create subtypes. Subtypes are a way of specializing a type’s interface; they
    allow for extension without modifying the original types. Any modification to
    existing code is a potential regression, so being able to create new types without
    changing old ones can significantly reduce erratic behavior.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将讲解当你创建子类型时，类型之间如何关联。子类型是专门化类型接口的一种方式；它们允许在不修改原始类型的情况下进行扩展。对现有代码的任何修改都可能引起回归，因此能够创建新类型而无需更改旧类型，可以显著减少异常行为。
- en: '^([1](part0015_split_002.html#idm45644739470600-marker)) Kevlin Henney and
    Scott Meyers. “Make Interfaces Easy to Use Correctly and Hard to Use Incorrectly.”
    Chap. 55 in *97 Things Every Programmer Should Know: Collective Wisdom from the
    Experts*. Sebastopol: O’Reilly Media, 2010.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '^([1](part0015_split_002.html#idm45644739470600-marker)) 凯夫林·亨尼（Kevlin Henney）和斯科特·迈耶斯（Scott
    Meyers）。《*97 件每个程序员都应该知道的事：专家集体智慧*》。Sebastopol: O’Reilly Media, 2010。'
- en: '^([2](part0015_split_003.html#idm45644739457384-marker)) Kent Beck. *Test Driven
    Development: By Example*. Upper Saddle River, NJ: Addison-Wesley Professional,
    2002.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '^([2](part0015_split_003.html#idm45644739457384-marker)) Kent Beck。《*测试驱动开发：实战与模式*》。Upper
    Saddle River, NJ: Addison-Wesley Professional, 2002。'
- en: ^([3](part0015_split_003.html#idm45644739452664-marker)) I recommend [*Test-Driven
    Development with Python*](https://oreil.ly/PJARR) by Harry Percival (O’Reilly,
    2017) if you’d like more information.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](part0015_split_003.html#idm45644739452664-marker)) 如果你想要更多信息，我推荐哈里·珀西瓦尔（Harry
    Percival）的《*Python 测试驱动开发*》（O’Reilly, 2017）。
- en: ^([4](part0015_split_004.html#idm45644739841848-marker)) This is from *Design
    of Everyday Things* by Donald Norman (Basic Books). This classic book is essential
    to anyone wanting to get into a UX mindset.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](part0015_split_004.html#idm45644739841848-marker)) 这段来自唐纳德·诺曼（Donald Norman）的《*设计心理学*》（Basic
    Books）。这本经典著作对于想要进入用户体验（UX）思维的人至关重要。
