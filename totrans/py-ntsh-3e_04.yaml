- en: Chapter 4\. Object-Oriented Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。面向对象的Python
- en: 'Python is an object-oriented (OO) programming language. Unlike some other object-oriented
    languages, however, Python doesn’t force you to use the object-oriented paradigm
    exclusively: it also supports procedural programming, with modules and functions,
    so that you can select the best paradigm for each part of your program. The object-oriented
    paradigm helps you group state (data) and behavior (code) together in handy packets
    of functionality. Moreover, it offers some useful specialized mechanisms covered
    in this chapter, like *inheritance* and *special methods*. The simpler procedural
    approach, based on modules and functions, may be more suitable when you don’t
    need the pluses^([1](ch04.xhtml#ch01fn48)) of object-oriented programming. With
    Python, you can mix and match paradigms.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种面向对象（OO）编程语言。然而，与一些其他面向对象语言不同，Python不强制您专门使用面向对象范式：它还支持过程式编程，具有模块和函数，因此您可以为程序的每个部分选择最佳范式。面向对象范式帮助您将状态（数据）和行为（代码）组合在方便的功能包中。此外，它提供了一些有用的专门机制，如*继承*和*特殊方法*。更简单的过程式方法，基于模块和函数，当您不需要面向对象编程的优点时可能更合适。使用Python，您可以混合和匹配范式。
- en: In addition to core OO concepts, this chapter covers *abstract base classes*,
    *decorators*, and *metaclasses*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除了核心面向对象概念外，本章还涵盖了*抽象基类*、*装饰器*和*元类*。
- en: Classes and Instances
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和实例
- en: 'If you’re familiar with object-oriented programming in other OO languages such
    as C++ or Java, you probably have a good grasp of classes and instances: a *class*
    is a user-defined type, which you *instantiate* to build *instances*, i.e., objects
    of that type. Python supports this through its class and instance objects.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉其他面向对象编程语言（如C++或Java）中的面向对象编程，你可能对类和实例有很好的理解：*类*是一种用户定义的类型，你可以*实例化*它以构建*实例*，即该类型的对象。Python通过其类和实例对象支持此功能。
- en: Python Classes
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python类
- en: 'A *class* is a Python object with the following characteristics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*类*是具有以下特征的Python对象：
- en: You can call a class object just like you’d call a function. The call, known
    as *instantiation*, returns an object known as an *instance* of the class; the
    class is also known as the instance’s *type*.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以像调用函数一样调用类对象。这种调用称为*实例化*，返回一个称为类的*实例*的对象；类也称为实例的*类型*。
- en: A class has arbitrarily named attributes that you can bind and reference.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类具有任意命名的属性，您可以绑定和引用。
- en: The values of class attributes can be *descriptors* (including functions), covered
    in [“Descriptors”](#descriptors), or ordinary data objects.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类属性的值可以是*描述符*（包括函数），在[“描述符”](#descriptors)中有介绍，也可以是普通数据对象。
- en: Class attributes bound to functions are also known as *methods* of the class.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定到函数的类属性也称为类的*方法*。
- en: A method can have any one of many Python-defined names with two leading and
    two trailing underscores (known as *dunder names*, short for “double-underscore
    names”—the name __init__, for example, is pronounced “dunder init”). Python implicitly
    calls such special methods, when a class supplies them, when various kinds of
    operations occur on that class or its instances.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个方法可以有许多Python定义的名称之一，其名称前后有两个下划线（称为*双下划线名称*，简称“双下划线名称”——例如，名称__init__，读作“dunder
    init”）。当类提供这些特殊方法时，Python隐式调用它们，当发生类或其实例的各种操作时。
- en: A class can *inherit* from one or more classes, meaning it delegates to other
    class objects the lookup of some attributes (including regular and dunder methods)
    that are not in the class itself.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类可以*继承*自一个或多个类，这意味着它将一些属性的查找委托给其他类对象（包括常规和双下划线方法），这些属性不在类本身中。
- en: An instance of a class is a Python object with arbitrarily named attributes
    that you can bind and reference. Every instance object delegates attribute lookup
    to its class for any attribute not found in the instance itself. The class, in
    turn, may delegate the lookup to classes from which it inherits, if any.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 类的一个实例是一个Python对象，具有任意命名的属性，您可以绑定和引用。对于实例本身没有找到的任何属性，每个实例对象都将属性查找委托给其类。类反过来可能会将查找委托给它继承的类（如果有的话）。
- en: In Python, classes are objects (values), handled just like other objects. You
    can pass a class as an argument in a call to a function, and a function can return
    a class as the result of a call. You can bind a class to a variable, an item in
    a container, or an attribute of an object. Classes can also be keys into a dictionary.
    Since classes are perfectly ordinary objects in Python, we often say that classes
    are *first-class* objects.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，类是对象（值），与其他对象一样处理。你可以将一个类作为参数传递给函数调用，并且函数可以将一个类作为调用的结果返回。你可以将一个类绑定到一个变量，一个容器中的项，或者一个对象的属性。类也可以作为字典的键。由于在
    Python 中类是完全普通的对象，我们经常说类是*一等*对象。
- en: The class Statement
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类语句
- en: 'The **class** statement is the most usual way you create a class object. **class**
    is a single-clause compound statement with the following syntax:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**class** 语句是创建类对象的最常见方式。**class** 是一个单子句复合语句，具有以下语法：'
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Classname* is an identifier: a variable that the class statement, when finished,
    binds (or rebinds) to the just-created class object. Python naming [conventions](https://oreil.ly/orJJ1)
    advise using title case for class names, such as Item, PrivilegedUser, MultiUseFacility,
    etc.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*Classname* 是一个标识符：当类语句完成时，它绑定（或重新绑定）到刚刚创建的类对象。Python 命名[约定](https://oreil.ly/orJJ1)
    建议对类名使用大写字母开头，例如 Item、PrivilegedUser、MultiUseFacility 等。'
- en: '*base-classes * is a comma-delimited series of expressions whose values are
    class objects. Various programming languages use different names for these class
    objects: you can call them the *bases, superclasses*, or *parents* of the class.
    You can say the class created *inherits* from, *derives* from, *extends*, or *subclasses*
    its base classes; in this book, we generally use *extend*. This class is a *direct
    subclass* or *descendant* of its base classes. ***kw* can include a named argument
    metaclass= to establish the class’s *metaclass*,^([2](ch04.xhtml#ch01fn49)) as
    covered in [“How Python Determines a Class’s Metaclass”](#how_python_determines_a_classapostrophe).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*base-classes* 是一个以逗号分隔的表达式序列，其值是类对象。各种编程语言对这些类对象使用不同的名称：你可以称它们为类的 *bases,
    superclasses*，或者 *parents*。你可以说创建的类从其基类 *继承*，*派生*，*扩展*，或者 *子类化*；在本书中，我们通常使用 *extend*。这个类是其基类的
    *直接子类* 或者 *后代*。***kw* 可以包括一个命名参数 `metaclass=` 来建立类的 *元类*，如 [“Python 如何确定类的元类”](#how_python_determines_a_classapostrophe)
    中所述。'
- en: 'Syntactically, including *base-classes* is optional: to indicate that you’re
    creating a class without bases, just omit *base-classes* (and, optionally, also
    omit the parentheses around it, placing the colon right after the class name).
    Every class inherits from object, whether you specify explicit bases or not.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从语法上讲，包括 *base-classes* 是可选的：要指示你正在创建一个没有基类的类，只需省略 *base-classes*（并且可选地也省略括号，将冒号直接放在类名后面）。每个类都继承自
    object，无论你是否指定了显式基类。
- en: 'The subclass relationship between classes is transitive: if *C1* extends *C2*,
    and *C2* extends *C3*, then *C1* extends *C3*. The built-in function issubclass(*C1*,
    *C2*) accepts two class objects: it returns **True** when *C1* extends *C2*, and
    otherwise it returns **False**. Any class is a subclass of itself; therefore,
    issubclass(*C*, *C*) returns **True** for any class *C*. We cover how base classes
    affect a class’s functionality in [“Inheritance”](#inheritance).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 类之间的子类关系是传递的：如果 *C1* 扩展了 *C2*，而 *C2* 扩展了 *C3*，那么 *C1* 扩展了 *C3*。内置函数 `issubclass(*C1*,
    *C2*)` 接受两个类对象：当 *C1* 扩展了 *C2* 时返回 **True**，否则返回 **False**。任何类都是其自身的子类；因此，对于任何类
    *C*，`issubclass(*C*, *C*)` 返回 **True**。我们在 [“继承”](#inheritance) 中讨论了基类如何影响类的功能。
- en: The nonempty sequence of indented statements that follows the **class** statement
    is the *class body*. A class body executes immediately as part of the **class**
    statement’s execution. Until the body finishes executing, the new class object
    does not yet exist, and the *Classname* identifier is not yet bound (or rebound).
    [“How a Metaclass Creates a Class”](#how_a_metaclass_creates_a_class) provides
    more details about what happens when a **class** statement executes. Note that
    the **class** statement does not immediately create any instance of the new class,
    but rather defines the set of attributes shared by all instances when you later
    create instances by calling the class.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随**class**语句的缩进语句的非空序列是*class body*。类主体作为**class**语句的一部分立即执行。直到主体执行完毕，新的类对象才存在，并且*Classname*标识符尚未绑定（或重新绑定）。[“元类如何创建类”](#how_a_metaclass_creates_a_class)提供了关于**class**语句执行时发生的详细信息。请注意，**class**语句不会立即创建任何新类的实例，而是定义了稍后通过调用该类创建实例时所有实例共享的属性集合。
- en: The Class Body
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类主体
- en: The body of a class is where you normally specify class attributes; these attributes
    can be descriptor objects (including functions) or ordinary data objects of any
    type. An attribute of a class can be another class—so, for example, you can have
    a **class** statement “nested” inside another **class** statement.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 类的主体通常是您指定类属性的地方；这些属性可以是描述符对象（包括函数）或任何类型的普通数据对象。类的一个属性可以是另一个类，所以，例如，您可以在另一个**class**语句内“嵌套”一个**class**语句。
- en: Attributes of class objects
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类对象的属性
- en: 'You usually specify an attribute of a class object by binding a value to an
    identifier within the class body. For example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您通常通过在类主体内将值绑定到标识符来指定类对象的属性。例如：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, the class object C1 has an attribute named x, bound to the value 23,
    and C1.x refers to that attribute. Such attributes may also be accessed via instances:
    c = C1(); print(c.x). However, this isn’t always reliable in practice. For example,
    when the class instance c has an x attribute, that’s what c.x accesses, not the
    class-level one. So, to access a class-level attribute from an instance, using,
    say, print(c.__class__.x) may be best.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，类对象C1有一个名为x的属性，绑定到值23，并且C1.x引用该属性。这样的属性也可以通过实例访问：c = C1(); print(c.x)。然而，在实践中，这并不总是可靠的。例如，当类实例c有一个x属性时，c.x访问的是该属性，而不是类级别的属性。因此，要从实例中访问类级别的属性，例如，使用print(c.__class__.x)可能是最好的选择。
- en: 'You can also bind or unbind class attributes outside the class body. For example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在类主体外绑定或解绑类属性。例如：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Your program is usually more readable if you bind class attributes only with
    statements inside the class body. However, rebinding them elsewhere may be necessary
    if you want to carry state information at a class, rather than instance, level;
    Python lets you do that, if you wish. There is no difference between a class attribute
    bound in the class body and one bound or rebound outside the body by assigning
    to an attribute.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只在类主体内部的语句中绑定类属性，您的程序通常会更易读。但是，如果您希望在类级别而不是实例级别传递状态信息，则可能需要在其他地方重新绑定它们；如果您愿意，Python允许您这样做。通过将属性赋值给属性，在类主体内部绑定的类属性与在类主体外部绑定或重新绑定的属性之间没有区别。
- en: As we’ll discuss shortly, all class instances share all of the class’s attributes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将很快讨论的那样，所有类实例共享类的所有属性。
- en: 'The **class** statement implicitly sets some class attributes. The attribute
    __name__ is the *Classname* identifier string used in the **class** statement.
    The attribute __bases__ is the tuple of class objects given (or implied) as the
    base classes in the **class** statement. For example, using the class C1 we just
    created:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**class**语句隐含地设置了一些类属性。属性__name__是在**class**语句中使用的*Classname*标识符字符串。属性__bases__是作为**class**语句中基类给定（或隐含）的类对象元组。例如，使用我们刚刚创建的C1类：'
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A class also has an attribute called __dict__, which is the read-only mapping
    that the class uses to hold other attributes (also known, informally, as the class’s
    *namespace*).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 类还有一个名为__dict__的属性，它是类使用的只读映射，用于保存其他属性（也可以非正式地称为类的*命名空间*）。
- en: 'In statements directly in a class’s body, references to class attributes must
    use a simple name, not a fully qualified name. For example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 直接在类主体中的语句中，对类属性的引用必须使用简单名称，而不是完全限定名称。例如：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, in statements within *methods* defined in a class body, references
    to class attributes must use a fully qualified name, not a simple name. For example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在类主体中定义的*方法*中的语句中，对类属性的引用必须使用完全限定名称，而不是简单名称。例如：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Attribute references (i.e., expressions like *C.x*) have semantics richer than
    attribute bindings. We cover such references in detail in [“Attribute Reference
    Basics”](#attribute_reference_basics).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 属性引用（即，表达式如*C.x*）的语义比属性绑定更丰富。我们在[“属性参考基础”](#attribute_reference_basics)中详细介绍这样的引用。
- en: Function definitions in a class body
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类主体中的函数定义
- en: Most class bodies include some **def** statements, since functions (known as
    *methods* in this context) are important attributes for most class instances.
    A **def** statement in a class body obeys the rules covered in [“Functions”](ch03.xhtml#function).
    In addition, a method defined in a class body has a mandatory first parameter,
    conventionally always named self, that refers to the instance on which you call
    the method. The self parameter plays a special role in method calls, as covered
    in [“Bound and Unbound Methods”](#bound_and_unbound_methods).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数类主体包括一些**def**语句，因为函数（在此上下文中称为*方法*）对于大多数类实例都是重要的属性。类主体中的**def**语句遵循[“函数”](ch03.xhtml#function)中涵盖的规则。此外，类主体中定义的方法有一个强制的第一个参数，通常总是命名为self，它引用调用方法的实例。self
    参数在方法调用中起着特殊的作用，如[“绑定和非绑定方法”](#bound_and_unbound_methods)中所述。
- en: 'Here’s an example of a class that includes a method definition:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个包含方法定义的类的示例：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A class can define a variety of special dunder methods relating to specific
    operations on its instances. We discuss these methods in detail in [“Special Methods”](#special_methods).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以定义各种与其实例上的特定操作相关的特殊双下划线方法。我们在[“特殊方法”](#special_methods)中详细讨论这些方法。
- en: Class-private variables
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类私有变量
- en: When a statement in a class body (or in a method in the body) uses an identifier
    starting (but not ending) with two underscores, such as *__ident*, Python implicitly
    changes the identifier to *_Classname__ident*, where *Classname* is the name of
    the class. This implicit change lets a class use “private” names for attributes,
    methods, global variables, and other purposes, reducing the risk of accidentally
    duplicating names used elsewhere (particularly in subclasses).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当类主体中的语句（或主体中的方法）使用以两个下划线开头（但不以两个下划线结尾）的标识符时，例如*__ident*，Python 隐式地将标识符更改为*_Classname__ident*，其中*Classname*是类的名称。这种隐式更改允许类使用“私有”名称来命名属性、方法、全局变量和其他用途，从而减少意外重复使用其他地方使用的名称（特别是在子类中）的风险。
- en: 'By convention, identifiers starting with a *single* underscore are private
    to the scope that binds them, whether that scope is or isn’t a class. The Python
    compiler does not enforce this privacy convention: it is up to programmers to
    respect it.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 根据约定，以*单个*下划线开头的标识符是私有的，无论绑定它们的作用域是或不是一个类。Python 编译器不强制执行此隐私约定：由程序员来尊重它。
- en: Class documentation strings
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类文档字符串
- en: If the first statement in the class body is a string literal, the compiler binds
    that string as the *documentation string* (or *docstring*) for the class. The
    docstring for the class is available in the __doc__ attribute; if the first statement
    in the class body is *not* a string literal, its value is **None**. See [“Docstrings”](ch03.xhtml#docstrings)
    for more information on documentation strings.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类主体中的第一个语句是一个字符串文字，则编译器将该字符串绑定为类的*文档字符串*（或*docstring*）；如果类主体中的第一个语句*不是*字符串文字，则其值为**None**。有关文档字符串的更多信息，请参见[“文档字符串”](ch03.xhtml#docstrings)。
- en: Descriptors
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述符
- en: 'A *descriptor* is an object whose class supplies one or more special methods
    named __get__, __set__, or __delete__. Descriptors that are class attributes control
    the semantics of accessing and setting attributes on instances of that class.
    Roughly speaking, when you access an instance attribute, Python gets the attribute’s
    value by calling __get__ on the corresponding descriptor, if any. For example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*描述符*是一个对象，其类提供一个或多个名为__get__、__set__或__delete__的特殊方法。作为类属性的描述符控制访问该类实例上的属性的语义。粗略地说，当您访问一个实例属性时，Python
    通过调用相应的描述符上的__get__来获取属性的值，如果有的话。例如：'
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For more details, see [“Attribute Reference Basics”](#attribute_reference_basics).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多详细信息，请参阅[“属性参考基础”](#attribute_reference_basics)。
- en: Overriding and nonoverriding descriptors
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖和非覆盖描述符
- en: When a descriptor’s class supplies a special method named __set__, the descriptor
    is known as an *overriding descriptor* (or, using the older, confusing terminology,
    a *data descriptor*); when the descriptor’s class supplies __get__ and not __set__,
    the descriptor is known as a *nonoverriding descriptor*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当描述符的类提供了名为 __set__ 的特殊方法时，该描述符称为 *覆盖描述符*（或者，使用较旧且令人困惑的术语，*数据描述符*）；当描述符的类提供了
    __get__ 而没有提供 __set__ 时，该描述符称为 *非覆盖描述符*。
- en: For example, the class of function objects supplies __get__, but not __set__;
    therefore, function objects are nonoverriding descriptors. Roughly speaking, when
    you assign a value to an instance attribute with a corresponding descriptor that
    is overriding, Python sets the attribute value by calling __set__ on the descriptor.
    For more details, see [“Attributes of instance objects”](#attributes_of_instance_objects).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，函数对象的类提供了 __get__，但没有提供 __set__；因此，函数对象是非覆盖描述符。粗略地说，当您使用具有对应覆盖描述符的值分配实例属性时，Python
    通过调用描述符的 __set__ 方法设置属性值。有关详细信息，请参见[“实例对象的属性”](#attributes_of_instance_objects)。
- en: 'The third dunder method of the descriptor protocol is __delete__, called when
    the **del** statement is used on the descriptor instance. If **del** is not supported,
    it is still a good idea to implement __delete__, raising a proper AttributeError
    exception; otherwise, the caller will get a mysterious AttributeError: __delete__
    exception.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '描述符协议的第三个双下划线方法是 __delete__，当使用 **del** 语句删除描述符实例时调用。如果不支持 **del**，实现 __delete__
    并引发适当的 AttributeError 异常是一个好主意；否则，调用者将得到一个神秘的 AttributeError: __delete__ 异常。'
- en: The [online docs](https://oreil.ly/0yGz3) include many more examples of descriptors
    and their related methods.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[在线文档](https://oreil.ly/0yGz3)包含许多描述符及其相关方法的示例。'
- en: Instances
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例
- en: 'To create an instance of a class, call the class object as if it were a function.
    Each call returns a new instance whose type is that class:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建类的实例，请将类对象视为函数进行调用。每次调用返回一个类型为该类的新实例：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The built-in function isinstance(*i*, *C*), with a class as argument *C*, returns
    **True** when *i* is an instance of class *C* or any subclass of *C*. Otherwise,
    isinstance returns **False**. If *C* is a tuple of types (3.10+ or multiple types
    joined using the | operator), isinstance returns **True** if *i* is an instance
    or subclass instance of any of the given types, and **False** otherwise.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 内置函数 isinstance(*i*, *C*)，其参数 *C* 是一个类，当 *i* 是类 *C* 或其任何子类的实例时返回 **True**。否则返回
    **False**。如果 *C* 是类型元组（3.10+ 或使用 | 运算符连接的多个类型），isinstance 在 *i* 是任何给定类型的实例或子类实例时返回
    **True**，否则返回 **False**。
- en: __init__
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: __init__
- en: 'When a class defines or inherits a method named __init__, calling the class
    object executes __init__ on the new instance to perform per instance initialization.
    Arguments passed in the call must correspond to __init__’s parameters, except
    for the parameter self. For example, consider the following class definition:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类定义或继承了名为 __init__ 的方法时，在调用类对象时会执行 __init__ 方法来对新实例进行每个实例的初始化。调用时传递的参数必须对应于
    __init__ 的参数，除了参数 self。例如，考虑以下类定义：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here’s how you can create an instance of the C6 class:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是创建 C6 类实例的方法：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As shown in the C6 class definition, the __init__ method typically contains
    statements that bind instance attributes. An __init__ method must not return a
    value other than **None**; if it does, Python raises a TypeError exception.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如 C6 类定义所示，__init__ 方法通常包含绑定实例属性的语句。__init__ 方法不能返回除 **None** 以外的值；如果返回其他值，Python
    将引发 TypeError 异常。
- en: The main purpose of __init__ is to bind, and thus create, the attributes of
    a newly created instance. You may also bind, rebind, or unbind instance attributes
    outside __init__. However, your code is more readable when you initially bind
    all class instance attributes in the __init__ method.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: __init__ 的主要目的是绑定并创建新创建实例的属性。您也可以在 __init__ 方法之外绑定、重新绑定或解绑实例属性。然而，当您最初在 __init__
    方法中绑定所有类实例属性时，您的代码更易读。
- en: When __init__ is absent (and not inherited from any base class), you must call
    the class without arguments, and the new instance has no instance-specific attributes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当 __init__ 方法不存在（且未从任何基类继承）时，必须以无参数调用类，并且新实例没有实例特定的属性。
- en: Attributes of instance objects
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实例对象的属性
- en: 'Once you have created an instance, you can access its attributes (data and
    methods) using the dot (.) operator. For example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 创建实例后，可以使用点（.）运算符访问其属性（数据和方法）。例如：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Attribute references such as these have fairly rich semantics in Python; we
    cover them in detail in [“Attribute Reference Basics”](#attribute_reference_basics).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Python中这样的属性引用具有相当丰富的语义；我们会在[“属性引用基础”](#attribute_reference_basics)中详细介绍它们。
- en: 'You can give an instance object an attribute by binding a value to an attribute
    reference. For example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将值绑定到属性引用来为实例对象添加属性。例如：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Instance object z now has an attribute named x, bound to the value 23, and z.x
    refers to that attribute. The __setattr__ special method, if present, intercepts
    every attempt to bind an attribute. (We cover __setattr__ in [Table 4-1](#general_purpose_special_methods).)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 实例对象*z*现在有一个名为x的属性，绑定到值23，*z.x* 引用该属性。如果存在__setattr__特殊方法，则会拦截每次绑定属性的尝试。（我们在[表 4-1](#general_purpose_special_methods)中介绍了__setattr__。）
- en: 'When you attempt to bind to an instance attribute whose name corresponds to
    an overriding descriptor in the class, the descriptor’s __set__ method intercepts
    the attempt: if C7.x were an overriding descriptor, z.x=23 would execute type(z).x.__set__(z,
    23).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试绑定到一个实例属性时，如果该属性名称对应于类中的重写描述符，描述符的__set__方法会拦截该尝试：如果C7.x是一个重写描述符，z.x=23会执行type(z).x.__set__(z,
    23)。
- en: 'Creating an instance sets two instance attributes. For any instance *z*, *z.*__class__
    is the class object to which *z* belongs, and *z.*__dict__ is the mapping *z*
    uses to hold its other attributes. For example, for the instance z we just created:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 创建实例会设置两个实例属性。对于任何实例*z*，*z.*__class__是*z*所属的类对象，*z.*__dict__是*z*用来保存其其他属性的映射。例如，对于我们刚创建的实例*z*：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You may rebind (but not unbind) either or both of these attributes, but this
    is rarely necessary.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以重新绑定（但不能解绑）这两个属性中的任何一个或两个，但这很少是必要的。
- en: 'For any instance *z*, any object *x*, and any identifier *S* (except __class__
    and __dict__), *z.S*=*x* is equivalent to *z*.__dict__[''*S*'']=*x* (unless a
    __setattr__ special method, or an overriding descriptor’s __set__ special method,
    intercepts the binding attempt). For example, again referring to the z we just
    created:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何实例*z*、任何对象*x*和任何标识符*S*（除了__class__和__dict__），*z.S*=*x* 等同于 *z*.__dict__['*S*']=*x*（除非__setattr__特殊方法或重写描述符的__set__特殊方法拦截绑定尝试）。例如，再次引用我们刚创建的*z*：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There is no difference between instance attributes created by assigning to attributes
    and those created by explicitly binding an entry in *z*.__dict__.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，通过给属性赋值或显式绑定*z*.__dict__中的条目创建的实例属性之间没有区别。
- en: The factory function idiom
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工厂函数习语
- en: 'It’s often necessary to create instances of different classes depending on
    some condition, or avoid creating a new instance if an existing one is available
    for reuse. A common misconception is that such needs might be met by having __init__
    return a particular object. However, this approach is infeasible: Python raises
    an exception if __init__ returns any value other than **None**. The best way to
    implement flexible object creation is to use a function rather than calling the
    class object directly. A function used this way is known as a *factory function*.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 经常需要根据某些条件创建不同类的实例，或者如果可重用的实例已存在则避免创建新实例。一个常见的误解是通过让__init__方法返回特定对象来满足这些需求。然而，这种方法行不通：如果__init__返回除了**None**之外的任何值，Python会引发异常。实现灵活对象创建的最佳方式是使用函数而不是直接调用类对象。以这种方式使用的函数称为*工厂函数*。
- en: 'Calling a factory function is a flexible approach: a function may return an
    existing reusable instance or create a new instance by calling whatever class
    is appropriate. Say you have two almost interchangeable classes, SpecialCase and
    NormalCase, and want to flexibly generate instances of either one of them, depending
    on an argument. The following appropriate_case factory function, as a “toy” example,
    allows you to do just that (we’ll talk more about the self parameter in [“Bound
    and Unbound Methods”](#bound_and_unbound_methods)):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 调用工厂函数是一种灵活的方法：一个函数可以返回一个现有可重用的实例或通过调用适当的类创建一个新实例。假设你有两个几乎可以互换的类，SpecialCase和NormalCase，并且想要根据参数灵活地生成其中任何一个类的实例。下面这个适当的工厂函数示例允许你做到这一点（我们将在[“绑定和未绑定方法”](#bound_and_unbound_methods)中更多地讨论self参数）：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: __new__
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: __new__
- en: 'Every class has (or inherits) a class method named __new__ (we cover class
    methods in [“Class methods”](#class_methods)). When you call *C*(**args*, ***kwds*)
    to create a new instance of class *C*, Python first calls *C.*__new__(*C*, **args*,
    ***kwds*), and uses __new__’s return value *x* as the newly created instance.
    Then Python calls *C.*__init__(*x*, **args*, ***kwds*), but only when *x* is indeed
    an instance of *C* or any of its subclasses (otherwise, *x*’s state remains as
    __new__ had left it). Thus, for example, the statement *x*=*C*(23) is equivalent
    to:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类都有（或继承）一个名为__new__的类方法（我们在[“类方法”](#class_methods)中讨论）。当您调用*C*(**args*, ***kwds*)来创建类*C*的新实例时，Python首先调用*C.*__new__(*C*,
    **args*, ***kwds*)，并使用__new__的返回值*x*作为新创建的实例。然后Python调用*C.*__init__(*x*, **args*,
    ***kwds*)，但仅当*x*确实是*C*或其任何子类的实例时（否则，*x*的状态将保持__new__留下的状态）。因此，例如，语句*x*=*C*(23)等同于：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'object.__new__ creates a new, uninitialized instance of the class it receives
    as its first argument. It ignores other arguments when that class has an __init__
    method, but it raises an exception when it receives other arguments beyond the
    first, and the class that’s the first argument does not have an __init__ method.
    When you override __new__ within a class body, you do not need to add __new__=classmethod(__new__),
    nor use an @classmethod decorator, as you normally would: Python recognizes the
    name __new__ and treats it as special in this context. In those sporadic cases
    in which you rebind *C*.__new__ later, outside the body of class *C*, you do need
    to use *C*.__new__=classmethod(*whatever*).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: object.__new__创建一个新的未初始化实例，该实例作为其第一个参数接收的类的实例。当该类具有__init__方法时，它会忽略其他参数，但当它接收到第一个参数之外的其他参数，并且第一个参数的类没有__init__方法时，它会引发异常。当您在类体内部重写__new__时，您无需添加__new__=classmethod(__new__)，也不需要使用@classmethod装饰器，因为Python在此上下文中识别名称__new__并将其视为特殊名称。在那些偶发情况下，您稍后在类*C*的体外重新绑定*C*.__new__时，您确实需要使用*C*.__new__=classmethod(*whatever*)。
- en: __new__ has most of the flexibility of a factory function, as covered in the
    previous section. __new__ may choose to return an existing instance or make a
    new one, as appropriate. When __new__ does create a new instance, it usually delegates
    creation to object.__new__ or the __new__ method of another superclass of *C*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: __new__具有工厂函数的大部分灵活性，如前一节所述。__new__可以选择返回现有实例或根据需要创建新实例。当__new__确实创建新实例时，它通常将创建委托给object.__new__或*C*的另一个超类的__new__方法。
- en: 'The following example shows how to override the class method __new__ in order
    to implement a version of the Singleton design pattern:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示如何重写类方法__new__以实现Singleton设计模式的版本：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: (We cover the built-in super in [“Cooperative superclass method calling”](#cooperative_superclass_method_calling).)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: （我们在[“协作超类方法调用”](#cooperative_superclass_method_calling)中介绍了内置的super。）
- en: Any subclass of Singleton (that does not further override __new__) has exactly
    one instance. When the subclass defines __init__, it must ensure __init__ is safe
    to call repeatedly (at each call of the subclass) on the subclass’s only instance.^([3](ch04.xhtml#ch01fn50))
    In this example, we insert the _initialized attribute, set to **False**, when
    __new__ actually creates a new instance. Subclasses’ __init__ methods can test
    if self._initialized is **False** and, if so, set it to **True** and continue
    with the rest of the __init__ method. When subsequent “creates” of the singleton
    instance call __init__ again, self._initialized will be **True**, indicating the
    instance is already initialized, and __init__ can typically just return, avoiding
    some repetitive work.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 任何Singleton的子类（不进一步重写__new__的子类）都有且仅有一个实例。当子类定义__init__时，它必须确保__init__可以安全地重复调用（在每次子类调用时）子类的唯一实例。^([3](ch04.xhtml#ch01fn50))
    在此示例中，我们插入_initialized属性，设置为**False**，当__new__实际上创建新实例时。子类的__init__方法可以测试self._initialized是否为**False**，如果是，则将其设置为**True**并继续执行__init__方法的其余部分。当后续创建单例实例再次调用__init__时，self._initialized将为**True**，表示实例已初始化，并且__init__通常可以直接返回，避免某些重复工作。
- en: Attribute Reference Basics
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性引用基础知识
- en: An *attribute reference* is an expression of the form *x.name*, where *x* is
    any expression and *name* is an identifier called the *attribute name*. Many Python
    objects have attributes, but an attribute reference has special, rich semantics
    when *x* refers to a class or instance. Methods are attributes, too, so everything
    we say about attributes in general also applies to callable attributes (i.e.,
    methods).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*属性引用*是形式为*x.name*的表达式，其中*x*是任何表达式，*name*是称为*属性名称*的标识符。许多Python对象都有属性，但是当*x*引用类或实例时，属性引用具有特殊而丰富的语义。方法也是属性，因此我们对一般属性的所有说法也适用于可调用属性（即方法）。'
- en: 'Say that *x* is an instance of class C, which inherits from base class B. Both
    classes and the instance have several attributes (data and methods), as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设*x*是类*C*的实例，该类继承自基类*B*。这些类和实例都有几个属性（数据和方法），如下所示：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A few attribute dunder names are special. *C*.__name__ is the string '*C*',
    the class’s name. *C*.__bases__ is the tuple (*B*,), the tuple of *C*’s base classes.
    *x*.__class__ is the class *C* to which *x* belongs. When you refer to an attribute
    with one of these special names, the attribute reference looks directly into a
    dedicated slot in the class or instance object and fetches the value it finds
    there. You cannot unbind these attributes. You may rebind them on the fly, changing
    the name or base classes of a class or the class of an instance, but this advanced
    technique is rarely necessary.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 几个属性dunder名称是特殊的。*C*.__name__是字符串'*C*'，类的名称。*C*.__bases__是元组(*B*,)，*C*的基类的元组。*x*.__class__是*x*所属的类*C*。当您使用这些特殊名称之一引用属性时，属性引用直接查找类或实例对象中的专用槽，并获取找到的值。您不能解绑这些属性。您可以即时重新绑定它们，更改类或实例的名称或基类，但这种高级技术很少必要。
- en: 'Class *C* and instance *x* each have one other special attribute: a mapping
    named __dict__ (typically mutable for *x*, but not for *C*). All other attributes
    of a class or instance,^([4](ch04.xhtml#ch01fn51)) except the few special ones,
    are held as items in the __dict__ attribute of the class or instance.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 类*C*和实例*x*各自还有一个特殊属性：名为__dict__的映射（对*x*通常是可变的，但对*C*不是）。类或实例的所有其他属性，^([4](ch04.xhtml#ch01fn51))除了少数特殊属性外，都保存为类或实例的__dict__属性中的项。
- en: Getting an attribute from a class
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从类获取属性
- en: 'When you use the syntax *C.name* to refer to an attribute on a class object
    *C*, lookup proceeds in two steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用语法*C.name*引用类对象*C*的属性时，查找进行两个步骤：
- en: When '*name*' is a key in *C.*__dict__, *C.name* fetches the value *v* from
    *C.*__dict__['*name*']. Then, when *v* is a descriptor (i.e., type(*v*) supplies
    a method named __get__), the value of *C.name* is the result of calling type(*v*).__get__(*v*,
    None, *C*). When *v* is not a descriptor, the value of *C.name* is *v*.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当'*name*'是*C*.__dict__中的键时，*C.name*从*C*.__dict__['*name*']中获取值*v*。然后，当*v*是描述符时（即，type(*v*)提供名为__get__的方法），*C.name*的值是调用type(*v*).__get__(*v*,
    None, *C*)的结果。当*v*不是描述符时，*C.name*的值是*v*。
- en: When '*name*' is *not* a key in *C*.__dict__, *C.name* delegates the lookup
    to *C*’s base classes, meaning it loops on *C*’s ancestor classes and tries the
    *name* lookup on each (in *method resolution order*, as covered in [“Inheritance”](#inheritance)).
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当'*name*'不是*C*.__dict__中的键时，*C.name*将查找委托给*C*的基类，这意味着它在*C*的祖先类上循环，并在每个类上尝试*name*查找（按照"继承"中详述的方法解析顺序）。
- en: Getting an attribute from an instance
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从实例获取属性
- en: 'When you use the syntax *x.name* to refer to an attribute of instance *x* of
    class *C*, lookup proceeds in three steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用语法*x.name*引用类*C*的实例*x*的属性时，查找进行三个步骤：
- en: When '*name*' is in *C* (or in one of *C*’s ancestor classes) as the name of
    an overriding descriptor *v* (i.e., type(*v*) supplies methods __get__ and __set__),
    the value of *x.name* is the result of type(*v*).__get__(*v, x, C*).
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当'*name*'出现在*C*（或*C*的祖先类之一）中作为覆盖描述符*v*的名称时（即，type(*v*)提供方法__get__和__set__），*x.name*的值是type(*v*).__get__(*v,
    x, C*)的结果。
- en: Otherwise, when '*name*' is a key in *x*.__dict__, *x.name* fetches and returns
    the value at *x*.__dict__['*name*'].
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，当'*name*'是*x*.__dict__中的键时，*x.name*获取并返回*x*.__dict__['*name*']中的值。
- en: 'Otherwise, *x.name* delegates the lookup to *x*’s class (according to the same
    two-step lookup process used for *C.name*, as just detailed):'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，*x.name*将查找委托给*x*的类（按照与*C.name*相同的两步查找过程）：
- en: When this finds a descriptor *v*, the overall result of the attribute lookup
    is, again, type(*v*).__get__(*v, x, C*).
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当这找到描述符*v*时，属性查找的整体结果再次是type(*v*).__get__(*v, x, C*)。
- en: When this finds a nondescriptor value *v*, the overall result of the attribute
    lookup is just *v*.
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当此查找到一个非描述符值*v*时，属性查找的整体结果就是*v*。
- en: When these lookup steps do not find an attribute, Python raises an AttributeError
    exception. However, for lookups of *x.name*, when *C* defines or inherits the
    special method __getattr__, Python calls *C*.__getattr__(*x,* '*name*') rather
    than raising the exception. It’s then up to __getattr__ to return a suitable value
    or raise the appropriate exception, normally AttributeError.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些查找步骤未找到属性时，Python会引发AttributeError异常。然而，对于*x.name*的查找，当*C*定义或继承特殊方法__getattr__时，Python会调用*C*.__getattr__(*x,
    '*name*')而不是引发异常。然后由__getattr__决定返回适当的值或引发适当的异常，通常是AttributeError。
- en: 'Consider the following attribute references, defined previously:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑前面定义的以下属性引用：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: x.e and x.d succeed in step 2 of the instance lookup process, since no descriptors
    are involved and 'e' and 'd' are both keys in x.__dict__. Therefore, the lookups
    go no further but rather return 88 and 77. The other three references must proceed
    to step 3 of the instance lookup process and look in x.__class__ (i.e., C). x.c
    and x.b succeed in step 1 of the class lookup process, since 'c' and 'b' are both
    keys in C.__dict__. Therefore, the lookups go no further but rather return 89
    and 67. x.a gets all the way to step 2 of the class lookup process, looking in
    C*.*__bases__[0] (i.e., B). 'a' is a key in B*.*__dict__; therefore, x.a finally
    succeeds and returns 23.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当在步骤2的实例查找过程中，x.e和x.d成功时，因为没有涉及描述符，并且'e'和'd'都是x.__dict__中的键。因此，查找不会继续，而是返回88和77。另外三个引用必须继续到步骤3的实例查找过程，并查找x.__class__（即C）。x.c和x.b在类查找过程的步骤1中成功，因为'c'和'b'都是C.__dict__中的键。因此，查找不会继续，而是返回89和67。x.a一直到类查找过程的步骤2，查找C.__bases__[0]（即B）。'a'是B.__dict__中的键；因此，x.a最终成功并返回23。
- en: Setting an attribute
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置一个属性
- en: Note that the attribute lookup steps happen as just described only when you
    *refer* to an attribute, not when you *bind* an attribute. When you bind to a
    class or instance attribute whose name is not special (unless a __setattr__ method,
    or the __set__ method of an overriding descriptor, intercepts the binding of an
    instance attribute), you affect only the __dict__ entry for the attribute (in
    the class or instance, respectively). In other words, for attribute binding, there
    is no lookup procedure involved, except for the check for overriding descriptors.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，属性查找步骤只有在*引用*属性时才会像刚才描述的那样发生，而在*绑定*属性时不会。当绑定到一个名称不是特殊的类或实例属性时（除非__setattr__方法或覆盖描述符的__set__方法拦截实例属性的绑定），你只影响该属性的__dict__条目（在类或实例中分别）。换句话说，对于属性绑定，除了检查覆盖描述符外，不涉及查找过程。
- en: Bound and Unbound Methods
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定方法和非绑定方法
- en: The method __get__ of a function object can return the function object itself,
    or a *bound method object* that wraps the function; a bound method is associated
    with the specific instance it’s obtained from.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对象的__get__方法可以返回函数对象本身，或者包装该函数的*绑定方法对象*；绑定方法与从特定实例获取它时关联。
- en: 'In the code in the previous section, the attributes f, g, and h are functions;
    therefore, an attribute reference to any one of them returns a method object that
    wraps the respective function. Consider the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节的代码中，属性f、g和h是函数；因此，对它们中的任何一个进行属性引用都会返回一个包装相应函数的方法对象。考虑以下内容：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This statement outputs three bound methods, represented by strings like:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此语句输出三个绑定方法，用如下字符串表示：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'and then three function objects, represented by strings like:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是三个函数对象，用字符串表示如下：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Bound Methods Versus Function Objects
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定方法与函数对象的比较
- en: We get bound methods when the attribute reference is on instance *x*, and function
    objects when the attribute reference is on class *C*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当属性引用在实例*x*上时，我们得到绑定方法，而当属性引用在类*C*上时，我们得到函数对象。
- en: 'Because a bound method is already associated with a specific instance, you
    can call the method as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因为绑定方法已经与特定实例关联，所以可以按以下方式调用方法：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The key thing to notice here is that you don’t pass the method’s first argument,
    self, by the usual argument-passing syntax. Rather, a bound method of instance
    *x* implicitly binds the self parameter to object *x*. Thus, the method’s body
    can access the instance’s attributes as attributes of self, even though we don’t
    pass an explicit argument to the method.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的关键点是，你不会通过通常的参数传递语法传递方法的第一个参数 self。相反，实例 *x* 的绑定方法会将 self 参数隐式绑定到对象 *x*。因此，方法体可以访问实例的属性，就像它们是
    self 的属性一样，即使我们没有显式地向方法传递参数。
- en: Let’s take a closer look at bound methods. When an attribute reference on an
    instance, in the course of the lookup, finds a function object that’s an attribute
    in the instance’s class, the lookup calls the function’s __get__ method to get
    the attribute’s value. The call, in this case, creates and returns a *bound method*
    that wraps the function.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看绑定方法。当实例上的属性引用在查找过程中找到一个在实例类中作为属性的函数对象时，查找会调用函数的 __get__ 方法来获取属性的值。在这种情况下，调用会创建并返回一个*绑定方法*，它包装了该函数。
- en: Note that when the attribute reference’s lookup finds a function object directly
    in *x*.__dict__, the attribute reference operation does *not* create a bound method.
    In such cases, Python does not treat the function as a descriptor and does not
    call the function’s __get__ method; rather, the function object itself is the
    attribute’s value. Similarly, Python creates no bound methods for callables that
    are not ordinary functions, such as built-in (as opposed to Python-coded) functions,
    since such callables are not descriptors.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当属性引用的查找直接在 *x*.__dict__ 中找到一个函数对象时，属性引用操作不会创建绑定方法。在这种情况下，Python 不会将函数视为描述符，也不会调用函数的
    __get__ 方法；相反，函数对象本身就是属性的值。同样地，对于不是普通函数的可调用对象，如内置函数（而不是 Python 编写的函数），Python 不会创建绑定方法。
- en: 'A bound method has three read-only attributes in addition to those of the function
    object it wraps: im_class is the class object that supplies the method, im_func
    is the wrapped function, and im_self refers to *x*, the instance from which you
    got the method.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 除了包装的函数对象的属性外，绑定方法还有三个只读属性：im_class 是提供方法的类对象，im_func 是被包装的函数，im_self 指的是来自你获取方法的实例
    *x*。
- en: You use a bound method just like its im_func function, but calls to a bound
    method do not explicitly supply an argument corresponding to the first parameter
    (conventionally named self). When you call a bound method, the bound method passes
    im_self as the first argument to im_func before other arguments (if any) given
    at the point of call.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像使用其 im_func 函数一样使用绑定方法，但是对绑定方法的调用不会显式提供一个对应于第一个参数（通常命名为 self）的参数。当你调用绑定方法时，在给定调用点的其他参数（如果有）之前，绑定方法会将
    im_self 作为第一个参数传递给 im_func。
- en: 'Let’s follow, in excruciatingly low-level detail, the conceptual steps involved
    in a method call with the normal syntax *x.name*(*arg*). In the following context:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细地跟随一下使用常规语法 *x.name*(*arg*) 进行方法调用所涉及的概念步骤。
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'x is an instance object of class C, name is an identifier that names a method
    of x’s (an attribute of C whose value is a function, in this case function f),
    and *arg* is any expression. Python first checks if ''name'' is the attribute
    name in C of an overriding descriptor, but it isn’t—functions are descriptors,
    because their type defines the method __get__, but *not* overriding ones, because
    their type does not define the method __set__. Python next checks if ''name''
    is a key in x._dict__, but it isn’t. So, Python finds name in C (everything would
    work just the same if name were found, by inheritance, in one of C’s __bases__).
    Python notices that the attribute’s value, function object f, is a descriptor.
    Therefore, Python calls f.__get__(x, C), which returns a bound method object with
    im_func set to f, im_class set to C, and im_self set to x. Then Python calls this
    bound method object, with *arg* as the only argument. The bound method inserts
    im_self (i.e., x) as the first argument, and *arg* becomes the second one in a
    call to the bound method’s im_func (i.e., function f). The overall effect is just
    like calling:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: x是类C的实例对象，name是x的方法名称（C的属性，其值是一个函数，在本例中是函数f的属性），*arg*是任何表达式。Python首先检查'name'是否是C中覆盖描述符的属性名称，但它不是——函数是描述符，因为它们的类型定义了方法__get__，但不是覆盖的描述符，因为它们的类型没有定义方法__set__。Python接下来检查'name'是否是x._dict__中的一个键，但它不是。所以，Python在C中找到了name（如果name通过继承在C的一个__bases__中找到，则一切都将同样工作）。Python注意到属性的值，函数对象f，是一个描述符。因此，Python调用f.__get__(x,
    C)，返回一个绑定方法对象，其im_func设置为f，im_class设置为C，im_self设置为x。然后Python调用这个绑定方法对象，*arg*作为唯一的参数。绑定方法将im_self（即x）插入为调用绑定方法的im_func（即函数f）的第一个参数，*arg*成为第二个参数。整体效果就像调用：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When a bound method’s function body executes, it has no special namespace relationship
    to either its self object or any class. Variables referenced are local or global,
    just like any other function, as covered in [“Namespaces”](ch03.xhtml#namespaces).
    Variables do not implicitly indicate attributes in self, nor do they indicate
    attributes in any class object. When the method needs to refer to, bind, or unbind
    an attribute of its self object, it does so by standard attribute reference syntax
    (e.g., self.*name*).^([5](ch04.xhtml#ch01fn52)) The lack of implicit scoping may
    take some getting used to (simply because Python differs in this respect from
    many, though far from all, other object-oriented languages), but it results in
    clarity, simplicity, and the removal of potential ambiguities.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当绑定方法的函数体执行时，它与其self对象或任何类之间没有特殊的命名空间关系。引用的变量是局部或全局的，就像任何其他函数一样，详见[“命名空间”](ch03.xhtml#namespaces)。变量不会隐式地指示self中的属性，也不会指示任何类对象中的属性。当方法需要引用、绑定或解绑其self对象的属性时，它通过标准的属性引用语法来完成（例如，self.*name*）。^([5](ch04.xhtml#ch01fn52))
    缺乏隐式作用域可能需要一些时间来适应（因为在这一点上，Python与许多面向对象的语言不同），但它确保了清晰性、简单性并消除了潜在的歧义。
- en: 'Bound method objects are first-class objects: you can use them wherever you
    can use a callable object. Since a bound method holds references to both the function
    it wraps and the self object on which it executes, it’s a powerful and flexible
    alternative to a closure (covered in [“Nested functions and nested scopes”](ch03.xhtml#nested_functions_and_nested_scopes)).
    An instance object whose class supplies the special method __call__ (covered in
    [Table 4-1](#general_purpose_special_methods)) offers another viable alternative.
    These constructs let you bundle some behavior (code) and some state (data) into
    a single callable object. Closures are simplest, but they are somewhat limited
    in their applicability. Here’s the closure from the section on nested functions
    and nested scopes:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定方法对象是一类一等公民对象：你可以在任何可调用对象的地方使用它们。由于绑定方法同时持有对其包装的函数和执行它的self对象的引用，它是闭包的一个强大而灵活的替代方案（详见[“嵌套函数和嵌套作用域”](ch03.xhtml#nested_functions_and_nested_scopes)）。如果一个实例对象的类提供了特殊方法__call__（详见[表4-1](#general_purpose_special_methods)），那么这是另一种可行的替代方案。这些构造允许你将一些行为（代码）和一些状态（数据）打包到一个可调用对象中。闭包最简单，但在适用性上有些限制。以下是来自嵌套函数和嵌套作用域部分的闭包示例：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Bound methods and callable instances are richer and more flexible than closures.
    Here’s how to implement the same functionality with a bound method:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定方法和可调用实例比闭包更丰富和灵活。以下是如何使用绑定方法实现相同功能的方式：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And here’s how to implement it with a callable instance (an instance whose
    class supplies the special method __call__):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何使用可调用实例（一个其类提供特殊方法__call__的实例）来实现它的方式：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: From the viewpoint of the code that calls the functions, all of these factory
    functions are interchangeable, since all of them return callable objects that
    are polymorphic (i.e., usable in the same ways). In terms of implementation, the
    closure is simplest; the object-oriented approaches—i.e., the bound method and
    the callable instance—use more flexible, general, and powerful mechanisms, but
    there is no need for that extra power in this simple example (since no other state
    is required beyond the augend, which is just as easily carried in the closure
    as in either of the object-oriented approaches).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从调用函数的代码视角来看，所有这些工厂函数都是可互换的，因为它们都返回多态的可调用对象。在实现方面，闭包是最简单的；面向对象的方法，即绑定方法和可调用实例，使用更灵活、通用和强大的机制，但在这个简单的例子中并不需要这种额外的功能（因为除了加数之外，不需要其他状态，闭包和面向对象方法都可以轻松处理）。
- en: Inheritance
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: When you use an attribute reference *C.name* on a class object *C*, and '*name*'
    is not a key in *C*.__dict__, the lookup implicitly proceeds on each class object
    that is in *C*.__bases__ in a specific order (which for historical reasons is
    known as the *method resolution order*, or MRO, but in fact applies to all attributes,
    not just methods). *C*’s base classes may in turn have their own bases. The lookup
    checks direct and indirect ancestors, one by one, in MRO, stopping when '*name*'
    is found.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在类对象*C*上使用属性引用*C.name*，并且'*name*'不是*C*.__dict__中的键时，查找将隐式地在*C*.__bases__中的每个类对象上进行，按特定顺序（由于历史原因称为方法解析顺序或MRO，但实际上适用于所有属性，而不仅仅是方法）。*C*的基类可能会有它们自己的基类。查找将逐个在MRO中的直接和间接祖先中进行，停止在找到'*name*'时。
- en: Method resolution order
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法解析顺序
- en: The lookup of an attribute name in a class essentially occurs by visiting ancestor
    classes in left-to-right, depth-first order. However, in the presence of multiple
    inheritance (which makes the inheritance graph a general *directed acyclic graph*,
    or DAG, rather than specifically a tree), this simple approach might lead to some
    ancestor classes being visited twice. In such cases, the resolution order leaves
    in the lookup sequence only the *rightmost* occurrence of any given class.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中查找属性名的查找基本上是通过按左到右、深度优先顺序访问祖先类来进行的。然而，在多重继承的情况下（使得继承图成为一般*有向无环图*（DAG），而不仅仅是特定的树），这种简单方法可能导致某些祖先类被访问两次。在这种情况下，解析顺序在查找序列中只保留任何给定类的*最右*出现。
- en: 'Each class and built-in type has a special read-only class attribute called
    __mro__, which is the tuple of types used for method resolution, in order. You
    can reference __mro__ only on classes, not on instances, and, since __mro__ is
    a read-only attribute, you cannot rebind or unbind it. For a detailed and highly
    technical explanation of all aspects of Python’s MRO, you may want to study Michele
    Simionato’s essay [“The Python 2.3 Method Resolution Order”](https://oreil.ly/pf6RF)^([6](ch04.xhtml#ch01fn53))
    and Guido van Rossum’s article on [“The History of Python”](https://oreil.ly/hetjd).
    In particular, note that it *is* quite possible that Python cannot determine *any*
    unambiguous MRO for a certain class: in this case, Python raises a TypeError exception
    when it executes that **class** statement.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类和内置类型都有一个特殊的只读类属性称为__mro__，它是用于方法解析的类型元组，按顺序排列。只能在类上引用__mro__，而不能在实例上引用，并且由于__mro__是只读属性，因此无法重新绑定或解绑。有关Python
    MRO的所有方面的详细且高度技术性的解释，请参阅Michele Simionato的文章[“Python 2.3 方法解析顺序”](https://oreil.ly/pf6RF)^([6](ch04.xhtml#ch01fn53))和Guido
    van Rossum关于[“Python历史”](https://oreil.ly/hetjd)的文章。特别要注意，Python可能无法确定某个类的任何明确的MRO：在这种情况下，当Python执行该**类**语句时会引发TypeError异常。
- en: Overriding attributes
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖属性
- en: 'As we’ve just seen, the search for an attribute proceeds along the MRO (typically,
    up the inheritance tree) and stops as soon as the attribute is found. Descendant
    classes are always examined before their ancestors, so that when a subclass defines
    an attribute with the same name as one in a superclass, the search finds the definition
    in the subclass and stops there. This is known as the subclass *overriding* the
    definition in the superclass. Consider the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚看到的，对属性的搜索沿着MRO（通常是沿着继承树向上）进行，并且一旦找到属性就会停止。子类始终在其祖先之前进行检查，因此当子类定义与超类中同名的属性时，搜索将找到子类中的定义并在此处停止。这被称为子类*覆盖*超类中的定义。考虑以下代码：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, class C overrides attributes b and g of its superclass B. Note that, unlike
    in some other languages, in Python you may override data attributes just as easily
    as callable attributes (methods).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，类 C 覆盖了其超类 B 的属性 b 和 g。请注意，与某些其他语言不同，Python中你可以像轻松覆盖可调用属性（方法）一样覆盖数据属性。
- en: Delegating to superclass methods
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 委托给超类方法
- en: 'When subclass *C* overrides a method *f* of its superclass *B*, the body of
    *C*.*f* often wants to delegate some part of its operation to the superclass’s
    implementation of the method. This can sometimes be done using a function object,
    as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当子类 *C* 覆盖其超类 *B* 的方法 *f* 时，*C* 的 *f* 方法体通常希望将其操作的某部分委托给超类方法的实现。这有时可以使用函数对象来完成，如下所示：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The delegation to the superclass, in the body of Sub.greet, uses a function
    object obtained by attribute reference Base.greet on the superclass, and therefore
    passes all arguments normally, including self. (If it seems a bit ugly explicitly
    using the base class, bear with us; you’ll see a better way to do this shortly,
    in this very section). Delegating to a superclass implementation is a frequent
    use of such function objects.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Sub 类的 greet 方法体中，委托到超类的方法使用了通过属性引用 Base.greet 获得的函数对象，因此通常会传递所有参数，包括 self。（如果显式使用基类看起来有点丑陋，请耐心等待；在本节中很快你会看到更好的方法）。委托到超类实现是这种函数对象的常见用法。
- en: 'One common use of delegation occurs with the special method __init__. When
    Python creates an instance, it does not automatically call the __init__ methods
    of any base classes, unlike some other object-oriented languages. It is up to
    a subclass to initialize its superclasses, using delegation as necessary. For
    example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 委托（Delegation）的一种常见用法出现在特殊方法 **__init__** 中。当Python创建一个实例时，不像一些其他面向对象的语言那样自动调用任何基类的
    **__init__** 方法。这由子类来初始化其超类，必要时使用委托。例如：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If the __init__ method of class Derived didn’t explicitly call that of class
    Base, instances of Derived would miss that portion of their initialization. Thus,
    such instances would violate the [Liskov substitution principle (LSP)](https://oreil.ly/0jxrp),
    since they’d lack the attribute anattribute. This issue does *not* arise if a
    subclass does not define __init__, since in that case it inherits it from the
    superclass. So, there is *never* any reason to code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Derived 类的 **__init__** 方法没有显式调用 Base 类的 **__init__** 方法，那么 Derived 的实例将缺少其初始化的部分。因此，这些实例将违反
    [里氏替换原则（LSP）](https://oreil.ly/0jxrp)，因为它们将缺少属性 anattribute。如果子类不定义 **__init__**，则不会出现此问题，因为在这种情况下，它会从超类继承
    **__init__**。因此，*绝对不*有理由编写以下代码：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Never Code a Method That Just Delegates to the Superclass
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绝对不要编写仅委托给超类的方法。
- en: You should never define a semantically empty __init__ (i.e., one that just delegates
    to the superclass). Instead, inherit __init__ from the superclass. This advice
    applies to *all* methods, special or not, but for some reason the bad habit of
    coding such semantically empty methods seems to show up most often for __init__.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要定义一个语义上空的 **__init__**（即仅委托给超类的方法）。相反，应该从超类继承 **__init__**。这条建议适用于*所有*方法，特殊的或不是，但出于某种原因，编码这种语义上空的方法似乎最常见于
    **__init__**。
- en: The preceding code illustrates the concept of delegation to an object’s superclass,
    but it is actually a poor practice, in today’s Python, to code these superclasses
    explicitly by name. If the base class is renamed, all the call sites to it must
    be updated. Or, worse, if refactoring the class hierarchy introduces a new layer
    between the Derived and Base class, the newly inserted class’s method will be
    silently skipped.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码说明了将委托概念应用于对象的超类，但在今天的Python中，通过名称显式编码这些超类实际上是一种不良实践。如果基类重命名，所有对它的调用点都必须更新。或者更糟的是，如果重构类层次结构在
    Derived 和 Base 类之间引入新层，则新插入类的方法将被静默跳过。
- en: 'The recommended approach is to call methods defined in a superclass using the
    super built-in type. To invoke methods up the inheritance chain, just call super(),
    without arguments:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐的方法是使用内置的 super 类型调用定义在超类中的方法。要调用继承链中的方法，只需调用 super()，不带参数：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Cooperative superclass method calling
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合作超类方法调用
- en: 'Explicitly calling the superclass’s version of a method using the superclass’s
    name is also quite problematic in cases of multiple inheritance with so-called
    “diamond-shaped” graphs. Consider the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在多重继承和所谓的“菱形图”情况下，使用超类名称显式调用超类版本的方法也会带来很多问题。考虑以下代码：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When we call D().met(), A.met ends up being called twice. How can we ensure
    that each ancestor’s implementation of the method is called once and only once?
    The solution is to use super:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 D().met() 时，A.met 实际上被调用了两次。如何确保每个祖先方法的实现仅被调用一次？解决方案是使用 super：
- en: '[PRE35]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, D().met() results in exactly one call to each class’s version of met. If
    you get into the good habit of always coding superclass calls with super, your
    classes will fit smoothly even in complicated inheritance structures—and there
    will be no ill effects if the inheritance structure instead turns out to be simple.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，D().met() 将确保每个类的 met 方法仅被调用一次。如果你养成了使用 super 来编码超类调用的好习惯，你的类将在复杂的继承结构中表现得很顺畅——即使继承结构实际上很简单也不会有任何负面影响。
- en: The only situation in which you may prefer to use the rougher approach of calling
    superclass methods through the explicit syntax is when various classes have different
    and incompatible signatures for the same method. This is an unpleasant situation
    in many respects; if you do have to deal with it, the explicit syntax may sometimes
    be the least of the evils. Proper use of multiple inheritance is seriously hampered;
    but then, even the most fundamental properties of OOP, such as polymorphism between
    base and subclass instances, are impaired when you give methods of the same name
    different signatures in a superclass and its subclass.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的情况可能更喜欢通过显式语法调用超类方法的粗糙方法是，当不同类具有相同方法的不同和不兼容签名时。在许多方面，这种情况令人不快；如果你确实必须处理它，显式语法有时可能是最不受欢迎的方法。正确使用多重继承受到严重阻碍；但是，即使在面向对象编程的最基本属性中，如基类和子类实例之间的多态性中，在超类和其子类中为相同名称的方法指定不同签名时，也会受到影响。
- en: Dynamic class definition using the type built-in function
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用内置函数 type 进行动态类定义
- en: 'In addition to the type(*obj*) use, you can also call type with three arguments
    to define a new class:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 type(*obj*) 的方式外，你还可以使用三个参数调用 type 来定义一个新的类：
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: where *name* is the name of the new class (which should match the target variable),
    *bases* is a tuple of immediate superclasses, *class_attributes* is a dict of
    class-level methods and attributes to define in the new class, and ***kwargs*
    are optional named arguments to pass to the metaclass of one of the base classes.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *name* 是新类的名称（应与目标变量匹配），*bases* 是直接超类的元组，*class_attributes* 是要在新类中定义的类级方法和属性的字典，***kwargs*
    是要传递给其中一个基类的元类的可选命名参数。
- en: 'For example, with a simple hierarchy of Vehicle classes (such as LandVehicle,
    WaterVehicle, AirVehicle, SpaceVehicle, etc.), you can dynamically create hybrid
    classes at runtime, such as:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用简单的 Vehicle 类层次结构（如 LandVehicle、WaterVehicle、AirVehicle、SpaceVehicle 等），你可以在运行时动态创建混合类，如：
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This would be equivalent to defining a multiply inherited class:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于定义一个多重继承的类：
- en: '[PRE38]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When you call type to create classes at runtime, you do not need to manually
    define the combinatorial expansion of all combinations of Vehicle subclasses,
    and adding new subclasses does not require massive extension of defined mixed
    classes.^([7](ch04.xhtml#ch01fn54)) For more notes and examples, see the [online
    documentation](https://oreil.ly/aNrSu).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 type 在运行时创建类时，你无需手动定义所有 Vehicle 子类的组合扩展，并且添加新的子类也不需要大量扩展已定义的混合类。^([7](ch04.xhtml#ch01fn54))
    欲了解更多注解和示例，请参阅[在线文档](https://oreil.ly/aNrSu)。
- en: “Deleting” class attributes
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “删除”类属性
- en: 'Inheritance and overriding provide a simple and effective way to add or modify
    (override) class attributes (such as methods) noninvasively—i.e., without modifying
    the base class defining the attributes—by adding or overriding the attributes
    in subclasses. However, inheritance does not offer a way to delete (hide) base
    classes’ attributes noninvasively. If the subclass simply fails to define (override)
    an attribute, Python finds the base class’s definition. If you need to perform
    such deletion, possibilities include the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 继承和重写提供了一种简单有效的方式来非侵入性地添加或修改（重写）类属性（如方法）——即在子类中添加或重写属性而无需修改定义属性的基类。然而，继承并未提供一种非侵入性地删除（隐藏）基类属性的方法。如果子类简单地未定义（重写）某个属性，则
    Python 会找到基类的定义。如果需要执行此类删除操作，则可能的选择包括以下几种：
- en: Override the method and raise an exception in the method’s body.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写方法并在方法体中引发异常。
- en: Eschew inheritance, hold the attributes elsewhere than in the subclass’s __dict__,
    and define __getattr__ for selective delegation.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免继承，将属性保存在子类的 __dict__ 之外，并为选择性委派定义 __getattr__ 方法。
- en: Override __getattribute__ to similar effect.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖 __getattribute__ 以类似的效果。
- en: The last of these techniques is demonstrated in [“__getattribute__”](#getattribute_).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术的最后一个在 [“__getattribute__”](#getattribute_) 中演示。
- en: Consider Using Aggregation Instead of Inheritance
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑使用聚合而不是继承
- en: 'An alternative to inheritance is to use *aggregation*: instead of inheriting
    from a base class, hold an instance of that base class as a private attribute.
    You then get complete control over the attribute’s life cycle and public interface
    by providing public methods in the containing class that delegate to the contained
    attribute (i.e., by calling equivalent methods on the attribute). This way, the
    containing class has more control over the creation and deletion of the attribute;
    also, for any unwanted methods that the attribute’s class provides, you simply
    don’t write delegating methods in the containing class.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的替代方法是使用 *聚合*：而不是从基类继承，而是将基类的实例作为私有属性。通过在包含类中提供公共方法（即调用属性上的等效方法）委托给包含的属性，您可以完全控制属性的生命周期和公共接口。这样，包含类对于属性的创建和删除有更多的控制权；此外，对于属性类提供的任何不需要的方法，您只需不在包含类中编写委派方法即可。
- en: The Built-in object Type
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置的 object 类型
- en: 'The built-in object type is the ancestor of all built-in types and classes.
    The object type defines some special methods (documented in [“Special Methods”](#special_methods))
    that implement the default semantics of objects:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 object 类型是所有内置类型和类的祖先。object 类型定义了一些特殊方法（在 [“特殊方法”](#special_methods) 中记录），实现了对象的默认语义：
- en: __new__, __init__
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: __new__, __init__
- en: You can create a direct instance of object by calling object() without any arguments.
    The call uses object.__new__ and object.__init__ to make and return an instance
    object without attributes (and without even a __dict__ in which to hold attributes).
    Such instance objects may be useful as “sentinels,” guaranteed to compare unequal
    to any other distinct object.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调用 object() 而不传递任何参数来创建对象的直接实例。该调用使用 object.__new__ 和 object.__init__ 来创建并返回一个没有属性（甚至没有用于保存属性的
    __dict__）的实例对象。这样的实例对象可能作为“哨兵”非常有用，确保与任何其他不同对象比较时不相等。
- en: __delattr__, __getattr__, __getattribute__, __setattr__
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: __delattr__, __getattr__, __getattribute__, __setattr__
- en: By default, any object handles attribute references (as covered in [“Attribute
    Reference Basics”](#attribute_reference_basics)) using these methods of object.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，任何对象都使用对象的这些方法处理属性引用（如 [“属性引用基础知识”](#attribute_reference_basics) 中所述）。
- en: __hash__, __repr__, __str__
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: __hash__, __repr__, __str__
- en: Passing an object to hash, repr, or str calls the object’s corresponding dunder
    method.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象传递给 hash、repr 或 str 调用对象的相应 dunder 方法。
- en: A subclass of object (i.e., any class) may—and often will!—override any of these
    methods and/or add others.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的子类（即任何类）可以——而且通常会！——覆盖这些方法中的任何一个，和/或添加其他方法。
- en: Class-Level Methods
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类级方法
- en: 'Python supplies two built-in nonoverriding descriptor types, which give a class
    two distinct kinds of “class-level methods”: *static methods* and *class methods*.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了两种内置的非覆盖描述符类型，这使得类具有两种不同类型的“类级方法”：*静态方法* 和 *类方法*。
- en: Static methods
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态方法
- en: A *static method* is a method that you can call on a class, or on any instance
    of the class, without the special behavior and constraints of ordinary methods
    regarding the first parameter. A static method may have any signature; it may
    have no parameters, and the first parameter, if any, plays no special role. You
    can think of a static method as an ordinary function that you’re able to call
    normally, despite the fact that it happens to be bound to a class attribute.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态方法* 是可以在类上调用，或者在类的任何实例上调用的方法，而不受普通方法关于第一个参数的特殊行为和约束的影响。静态方法可以具有任何签名；它可以没有参数，并且如果有的话，第一个参数也不起任何特殊作用。您可以将静态方法视为一种普通函数，您可以正常调用它，尽管它恰好绑定到类属性上。'
- en: While it is never *necessary* to define static methods (you can always choose
    to instead define a normal function, outside the class), some programmers consider
    them to be an elegant syntax alternative when a function’s purpose is tightly
    bound to some specific class.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然定义静态方法从未 *必需*（您可以选择定义一个普通函数，而不是在类外部定义），但某些程序员认为它们是一种优雅的语法替代品，当函数的目的与某个特定类紧密绑定时。
- en: 'To build a static method, call the built-in type staticmethod and bind its
    result to a class attribute. Like all binding of class attributes, this is normally
    done in the body of the class, but you may also choose to perform it elsewhere.
    The only argument to staticmethod is the function to call when Python calls the
    static method. The following example shows one way to define and call a static
    method:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个静态方法，调用内置的type staticmethod，并将其结果绑定到一个类属性。与所有绑定类属性的方式一样，通常应在类的主体中完成，但您也可以选择在其他地方执行。staticmethod的唯一参数是Python调用静态方法时要调用的函数。以下示例展示了定义和调用静态方法的一种方式：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This example uses the same name for the function passed to staticmethod and
    for the attribute bound to staticmethod’s result. This naming convention is not
    mandatory, but it’s a good idea, and we recommend you always use it. Python offers
    a special, simplified syntax to support this style, covered in [“Decorators”](#decorators).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将同一名称用于传递给staticmethod的函数和绑定到staticmethod结果的属性。这种命名惯例并非强制性，但是是个好主意，我们建议您始终使用它。Python提供了一种特殊的简化语法来支持这种风格，详见[“装饰器”](#decorators)。
- en: Class methods
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类方法
- en: A *class method* is a method you can call on a class or on any instance of the
    class. Python binds the method’s first parameter to the class on which you call
    the method, or the class of the instance on which you call the method; it does
    not bind it to the instance, as for normal bound methods. The first parameter
    of a class method is conventionally named cls.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*类方法*是您可以在类上或在类的任何实例上调用的方法。Python将方法的第一个参数绑定到调用该方法的类或调用该方法的实例的类；它不将其绑定到实例，如普通绑定方法。类方法的第一个参数通常被命名为cls。'
- en: As with static methods, while it is never *necessary* to define class methods
    (you can always choose to define a normal function, outside the class, that takes
    the class object as its first parameter), class methods are an elegant alternative
    to such functions (particularly since they can usefully be overridden in subclasses,
    when that is necessary).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 与静态方法一样，虽然定义类方法从不是*必需*的（您始终可以选择在类外定义一个普通函数，并将类对象作为其第一个参数），但类方法是这种函数的一种优雅替代方式（特别是在需要在子类中重写它们时）。
- en: 'To build a class method, call the built-in type classmethod and bind its result
    to a class attribute. Like all binding of class attributes, this is normally done
    in the body of the class, but you may choose to perform it elsewhere. The only
    argument to classmethod is the function to call when Python calls the class method.
    Here’s one way you can define and call a class method:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个类方法，调用内置的type classmethod，并将其结果绑定到一个类属性。与所有绑定类属性的方式一样，通常应在类的主体中完成，但您也可以选择在其他地方执行。classmethod的唯一参数是Python调用类方法时要调用的函数。以下是定义和调用类方法的一种方式：
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This example uses the same name for the function passed to classmethod and for
    the attribute bound to classmethod’s result. Again, this naming convention is
    not mandatory, but it’s a good idea, and we recommend that you always use it.
    Python’s simplified syntax to support this style is covered in [“Decorators”](#decorators).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将同一名称用于传递给classmethod的函数和绑定到classmethod结果的属性。同样，这种命名约定并非强制性，但是是个好主意，我们建议您始终使用它。Python提供了一种特殊的简化语法来支持这种风格，详见[“装饰器”](#decorators)。
- en: Properties
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: 'Python supplies a built-in overriding descriptor type, usable to give a class’s
    instances *properties*. A property is an instance attribute with special functionality.
    You reference, bind, or unbind the attribute with the normal syntax (e.g., print(*x.prop*),
    *x*.*prop*=23, **del** *x.prop*). However, rather than following the usual semantics
    for attribute reference, binding, and unbinding, these accesses call on instance
    *x* the methods that you specify as arguments to the built-in type property. Here’s
    one way to define a read-only property:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一种内置的重写描述符类型，可用于给类的实例提供*属性*。属性是具有特殊功能的实例属性。您可以使用普通语法（例如，print(*x.prop*)，*x*.*prop*=23，**del**
    *x.prop*）引用、绑定或解绑属性。但是，与通常的属性引用、绑定和解绑语义不同，这些访问会在实例*x*上调用您作为内置type property的参数指定的方法。以下是定义只读属性的一种方式：
- en: '[PRE41]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Each instance *r* of class Rectangle has a synthetic read-only attribute *r*.area,
    which the method *r*.area() computes on the fly by multiplying the sides. The
    docstring Rectangle.area.__doc__ is 'area of the rectangle'. The *r*.area attribute
    is read-only (attempts to rebind or unbind it fail) because we specify only a
    get method in the call to property, and no set or del methods.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 类Rectangle的每个实例*r*都有一个合成的只读属性*r*.area，方法*r*.area()通过动态计算乘以边的方法来生成。Rectangle.area.__doc__的文档字符串是'rectangle的面积'。*r*.area属性是只读的（尝试重新绑定或解绑它会失败），因为我们在property调用中仅指定了一个get方法，而没有set或del方法。
- en: 'Properties perform tasks similar to those of the special methods __getattr__,
    __setattr__, and __delattr__ (covered in [“General-Purpose Special Methods”](#general_purpose_special_method)),
    but properties are faster and simpler. To build a property, call the built-in
    type property and bind its result to a class attribute. Like all binding of class
    attributes, this is normally done in the body of the class, but you may choose
    to do it elsewhere. Within the body of a class *C*, you can use the following
    syntax:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 属性执行与特殊方法__getattr__、__setattr__和__delattr__（在[“通用特殊方法”](#general_purpose_special_method)中介绍）类似的任务，但属性更快更简单。要构建一个属性，请调用内置类型property并将其结果绑定到一个类属性。与类属性的所有绑定一样，通常在类的主体中完成，但您可以选择在其他地方完成。在类*C*的主体内部，您可以使用以下语法：
- en: '[PRE42]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When *x* is an instance of *C* and you reference *x*.*attrib*, Python calls
    on *x* the method you passed as argument fget to the property constructor, without
    arguments. When you assign *x*.*attrib* = *value*, Python calls the method you
    passed as argument fset, with *value* as the only argument. When you execute **del**
    *x*.*attrib*, Python calls the method you passed as argument fdel, without arguments.
    Python uses the argument you passed as doc as the docstring of the attribute.
    All parameters to property are optional. When an argument is missing, Python raises
    an exception when some code attempts that operation. For example, in the Rectangle
    example, we made the property area read-only because we passed an argument only
    for the parameter fget, and not for the parameters fset and fdel.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当*x*是类*C*的一个实例，并且您引用*x*.*attrib*时，Python会在*x*上调用作为fget参数传递给属性构造函数的方法，不带参数。当您赋值*x*.*attrib*
    = *value*时，Python会调用作为fset参数传递的方法，并将*value*作为唯一的参数传递给它。当您执行**del** *x*.*attrib*时，Python会调用作为fdel参数传递的方法，不带参数。Python使用作为doc参数传递的参数作为属性的文档字符串。属性的所有参数都是可选的。当缺少某个参数时，当某些代码尝试进行该操作时，Python会引发异常。例如，在矩形示例中，我们使属性area为只读，因为我们仅为参数fget传递了一个参数，而没有为参数fset和fdel传递参数。
- en: 'An elegant syntax to create properties in a class is to use property as a *decorator*
    (see [“Decorators”](#decorators)):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中创建属性的一种优雅语法是使用property作为*装饰器*（参见[“装饰器”](#decorators)）：
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To use this syntax, you *must* give the getter method the same name as you
    want the property to have; the method’s docstring becomes the docstring of the
    property. If you want to add a setter and/or a deleter as well, use decorators
    named (in this example) area.setter and area.deleter, and name the methods thus
    decorated the same as the property, too. For example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这种语法，您*必须*将getter方法命名为您希望属性具有的相同名称；该方法的文档字符串将成为属性的文档字符串。如果您还想添加设置器和/或删除器，请使用名为（在此示例中）area.setter和area.deleter的装饰器，并将如此装饰的方法命名为属性的相同名称。例如：
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Why properties are important
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么属性很重要
- en: 'The crucial importance of properties is that their existence makes it perfectly
    safe (and indeed advisable) for you to expose public data attributes as part of
    your class’s public interface. Should it ever become necessary, in future versions
    of your class or other classes that need to be polymorphic to it, to have some
    code execute when the attribute is referenced, rebound, or unbound, you will be
    able to change the plain attribute into a property and get the desired effect
    without any impact on any code that uses your class (aka “client code”). This
    lets you avoid goofy idioms, such as *accessor* and *mutator* methods, required
    by OO languages lacking properties. For example, client code can use natural idioms
    like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的关键重要性在于它们的存在使得将公共数据属性作为类公共接口的一部分完全安全（事实上也是建议性的）。如果在将来的类版本或者需要与之多态的其他类中，需要在引用、重新绑定或解绑属性时执行一些代码，您可以将普通属性更改为属性，并获得所需效果，而不会对使用您的类的任何代码（即“客户端代码”）产生任何影响。这让您可以避免面向对象语言中缺乏属性而需要使用的笨拙惯用法，如*访问器*和*修改器*方法。例如，客户端代码可以使用如下自然的惯用法：
- en: '[PRE45]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'rather than being forced into contorted nests of accessors and mutators like
    this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是被迫进入这样的复杂嵌套访问器和修改器：
- en: '[PRE46]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If you’re ever tempted to code methods whose natural names are something like
    get_*this* or set_*that*, wrap those methods into properties instead, for clarity.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有时候想要编写方法的自然名称像 get_*this* 或 set_*that*，最好将这些方法包装成属性，以增加代码的清晰度。
- en: Properties and inheritance
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性和继承
- en: 'Inheritance of properties works just like for any other attribute. However,
    there’s a little trap for the unwary: *the methods called upon to access a property
    are those defined in the class in which the property itself is defined*, without
    intrinsic use of further overriding that may happen in subclasses. Consider this
    example:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的继承与任何其他属性一样工作。然而，对于不留心的人来说，有一个小陷阱：*用于访问属性的方法是在定义属性的类中定义的方法*，而不是使用后续在子类中发生的进一步覆盖。考虑这个例子：
- en: '[PRE47]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Accessing the property c.g calls B.f, not C.f, as you might expect. The reason
    is quite simple: the property constructor receives (directly or via the decorator
    syntax) the *function object* f (and that happens at the time the **class** statement
    for B executes, so the function object in question is the one also known as B.f).
    The fact that the subclass C later redefines the name f is therefore irrelevant,
    since the property performs no lookup for that name, but rather uses the function
    object it received at creation time. If you need to work around this issue, you
    can do it by adding the extra level of lookup indirection yourself:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 访问属性 c.g 会调用 B.f，而不是你可能期望的 C.f。原因非常简单：属性构造函数（直接或通过装饰器语法）接收的是 *函数对象* f（这发生在执行
    B 的 **class** 语句时，因此问题中的函数对象也称为 B.f）。因此，稍后在子类 C 中重新定义名称 f 是无关紧要的，因为属性在创建时并不会查找该名称，而是使用它在创建时收到的函数对象。如果需要解决这个问题，可以通过手动添加额外的查找间接性来实现：
- en: '[PRE48]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, the function object held by the property is B._f_getter, which in turn
    does perform a lookup for the name f (since it calls self.f()); therefore, the
    overriding of f has the expected effect. As David Wheeler famously put it, “All
    problems in computer science can be solved by another level of indirection.”^([8](ch04.xhtml#ch01fn55))
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，属性所持有的函数对象是 B._f_getter，它反过来确实会查找名称 f（因为它调用 self.f()）；因此，对 f 的覆盖具有预期的效果。正如
    David Wheeler 所说，“计算机科学中的所有问题都可以通过另一级间接性来解决。”^([8](ch04.xhtml#ch01fn55))
- en: __slots__
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: __slots__
- en: 'Normally, each instance object *x* of any class *C* has a dictionary *x.*__dict__
    that Python uses to let you bind arbitrary attributes on *x*. To save a little
    memory (at the cost of letting *x* have only a predefined set of attribute names),
    you can define in class *C* a class attribute named __slots__, a sequence (normally
    a tuple) of strings (normally identifiers). When class *C* has __slots__, instance
    *x* of class *C* has no __dict__: trying to bind on *x* an attribute whose name
    is not in *C.*__slots__ raises an exception.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，任何类 *C* 的实例对象 *x* 都有一个字典 *x.*__dict__，Python 使用它让你在 *x* 上绑定任意属性。为了节省一点内存（以只允许
    *x* 有预定义的一组属性名称为代价），可以在类 *C* 中定义一个类属性名为 __slots__，一个序列（通常是元组）的字符串（通常是标识符）。当类 *C*
    有 __slots__ 时，类 *C* 的实例 *x* 就没有 __dict__：试图在 *x* 上绑定一个不在 *C.*__slots__ 中的属性名将会引发异常。
- en: 'Using __slots__ lets you reduce memory consumption for small instance objects
    that can do without the powerful and convenient ability to have arbitrarily named
    attributes. __slots__ is worth adding only to classes that can have so many instances
    that saving a few tens of bytes per instance is important—typically classes that
    could have millions, not mere thousands, of instances alive at the same time.
    Unlike most other class attributes, however, __slots__ works as we’ve just described
    only if an assignment in the class body binds it as a class attribute. Any later
    alteration, rebinding, or unbinding of __slots__ has no effect, nor does inheriting
    __slots__ from a base class. Here’s how to add __slots__ to the Rectangle class
    defined earlier to get smaller (though less flexible) instances:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 __slots__ 可以减少小实例对象的内存消耗，这些对象可以没有强大和便利的能力拥有任意命名的属性。只有在类可能同时有成百上千个实例的情况下，才值得为类添加
    __slots__，以便每个实例节省几十个字节的内存。然而，与大多数其他类属性不同，只有在类体中的赋值将其绑定为类属性时，__slots__ 才能像我们刚才描述的那样工作。以后对
    __slots__ 的任何更改、重绑定或取消绑定，以及从基类继承 __slots__ 都没有效果。以下是如何在前面定义的 Rectangle 类中添加 __slots__
    以获得更小（虽然不太灵活）的实例：
- en: '[PRE49]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'There’s no need to define a slot for the area property: __slots__ does not
    constrain properties, only ordinary instance attributes, which would reside in
    the instance’s __dict__ if __slots__ wasn’t defined.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要为area属性定义槽：__slots__不限制属性，只限制普通实例属性，如果没有定义__slots__，则这些属性将存储在实例的__dict__中。
- en: '3.8+ __slots__ attributes can also be defined using a dict with attribute names
    for the keys and docstrings for the values. OptimizedRectangle could be declared
    more fully as:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 3.8+ __slots__属性也可以使用以属性名称为键和以文档字符串为值的字典来定义。OptimizedRectangle可以更详细地声明为：
- en: '[PRE50]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: __getattribute__
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: __getattribute__
- en: 'All references to instance attributes go through the special method __getattribute__.
    This method comes from object, where it implements attribute reference semantics
    (as documented in [“Attribute Reference Basics”](#attribute_reference_basics)).
    You may override __getattribute__ for purposes such as hiding inherited class
    attributes for a subclass’s instances. For instance, the following example shows
    one way to implement a list without append:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 所有对实例属性的引用都通过特殊方法__getattribute__。这个方法来自object，在那里它实现了属性引用的语义（如[“属性引用基础”](#attribute_reference_basics)中所述）。你可以覆盖__getattribute__来隐藏子类实例的继承类属性等目的。例如，以下示例展示了一种实现无需append方法的列表的方法：
- en: '[PRE51]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: An instance *x* of class listNoAppend is almost indistinguishable from a built-in
    list object, except that its runtime performance is substantially worse, and any
    reference to *x*.append raises an exception.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 类listNoAppend的实例x几乎与内置的列表对象无法区分，唯一的区别是其运行时性能显著较差，并且任何对x.append的引用都会引发异常。
- en: Implementing __getattribute__ can be tricky; it is often easier to use the built-in
    functions getattr and setattr and the instance’s __dict__ (if any), or to reimplement
    __getattr__ and __setattr__. Of course, in some cases (such as the preceding example),
    there is no alternative.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 实现__getattribute__可能会比较棘手；使用内置函数getattr和setattr以及实例的__dict__（如果有的话）或重新实现__getattr__和__setattr__通常更容易。当然，在某些情况下（如前面的例子），没有其他选择。
- en: Per Instance Methods
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个实例方法
- en: 'An instance can have instance-specific bindings for all attributes, including
    callable attributes (methods). For a method, just like for any other attribute
    (except those bound to overriding descriptors), an instance-specific binding hides
    a class-level binding: attribute lookup does not consider the class when it finds
    a binding directly in the instance. An instance-specific binding for a callable
    attribute does not perform any of the transformations detailed in [“Bound and
    Unbound Methods”](#bound_and_unbound_methods): the attribute reference returns
    exactly the same callable object that was earlier bound directly to the instance
    attribute.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 实例可以具有所有属性的实例特定绑定，包括可调用属性（方法）。对于方法，与任何其他属性（除了绑定到覆盖描述符的属性之外），实例特定绑定会隐藏类级绑定：属性查找在找到直接在实例中绑定时不考虑类。对于可调用属性的实例特定绑定不执行[“绑定和非绑定方法”](#bound_and_unbound_methods)中详细描述的任何转换：属性引用返回完全相同的可调用对象，该对象之前直接绑定到实例属性。
- en: 'However, this does not work as you might expect for per instance bindings of
    the special methods that Python calls implicitly as a result of various operations,
    as covered in [“Special Methods”](#special_methods). Such implicit uses of special
    methods always rely on the *class-level* binding of the special method, if any.
    For example:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这对于Python隐式调用的各种操作的每个实例绑定的特殊方法可能不像你期望的那样工作，如[“特殊方法”](#special_methods)中所述。这些特殊方法的隐式使用总是依赖于特殊方法的*类级*绑定（如果有的话）。例如：
- en: '[PRE52]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Inheritance from Built-in Types
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从内置类型继承
- en: 'A class can inherit from a built-in type. However, a class may directly or
    indirectly extend multiple built-in types only if those types are specifically
    designed to allow this level of mutual compatibility. Python does not support
    unconstrained inheritance from multiple arbitrary built-in types. Normally, a
    new-style class only extends at most one substantial built-in type. For example,
    this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以从内置类型继承。但是，类只能直接或间接扩展多个内置类型，前提是这些类型专门设计为允许这种互操作兼容性。Python不支持从多个任意内置类型无约束地继承。通常，新式类最多只扩展一个实质性的内置类型。例如，这样：
- en: '[PRE53]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: raises a TypeError exception, with a detailed explanation of “multiple bases
    have instance lay-out conflict.” When you see such error messages, it means that
    you’re trying to inherit, directly or indirectly, from multiple built-in types
    that are not specifically designed to cooperate at such a deep level.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 引发 TypeError 异常，并详细说明“多个基类具有实例布局冲突。” 当你看到这样的错误消息时，意味着你试图直接或间接地从多个不特别设计以在如此深层次上合作的内置类型继承。
- en: Special Methods
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊方法
- en: A class may define or inherit special methods, often referred to as “dunder”
    methods because, as described earlier, their names have leading and trailing double
    underscores. Each special method relates to a specific operation. Python implicitly
    calls a special method whenever you perform the related operation on an instance
    object. In most cases, the method’s return value is the operation’s result, and
    attempting an operation when its related method is not present raises an exception.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以定义或继承特殊方法，通常被称为“dunder”方法，因为如前所述，它们的名称前后都有双下划线。每个特殊方法与特定操作相关联。Python 在你对实例对象执行相关操作时会隐式调用特殊方法。在大多数情况下，方法的返回值是操作的结果，当操作所关联的方法不存在时，尝试该操作会引发异常。
- en: Throughout this section, we point out the cases in which these general rules
    do not apply. In the following discussion, *x* is the instance of class *C* on
    which you perform the operation, and *y* is the other operand, if any. The parameter
    self of each method also refers to the instance object *x*. Whenever we mention
    calls to *x.*__*whatever*__(...), keep in mind that the exact call happening is
    rather, pedantically speaking, *x.*__class__.__*whatever*__(*x*, ...).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们指出一般规则不适用的情况。在以下讨论中，*x* 是执行操作的类 *C* 的实例，*y* 是另一个操作数（如果有的话）。每个方法的参数 self
    也指代实例对象 *x*。每当我们提到对 *x.*__*whatever*__(...) 的调用时，请记住，严格来说，正在发生的确切调用实际上是 *x.*__class__.__*whatever*__(*x*,
    ...)。
- en: General-Purpose Special Methods
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用特殊方法
- en: 'Some dunder methods relate to general-purpose operations. A class that defines
    or inherits these methods allows its instances to control such operations. These
    operations can be divided into categories:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 dunder 方法与通用操作相关。定义或继承这些方法的类允许其实例控制这些操作。这些操作可以分为几类：
- en: Initialization and finalization
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化和结束处理
- en: A class can control its instances’ initialization (a very common requirement)
    via special methods __new__ and __init__, and/or their finalization (a rare requirement)
    via __del__.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以通过特殊方法 __new__ 和 __init__ 控制其实例的初始化（这是一个非常常见的需求），并且/或者通过 __del__ 控制其终结处理（这是一个罕见的需求）。
- en: String representation
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串表示
- en: A class can control how Python renders its instances as strings via special
    methods __repr__, __str__, __format__, and __bytes__.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以通过特殊方法 __repr__, __str__, __format__ 和 __bytes__ 控制 Python 如何将其实例呈现为字符串。
- en: Comparison, hashing, and use in a Boolean context
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 比较、哈希和在布尔上下文中的使用
- en: A class can control how its instances compare with other objects (via special
    methods __lt__, __le__, __gt__, __ge__, __eq__, and __ne__), how dictionaries
    use them as keys and sets use them as members (via __hash__), and whether they
    evaluate as truthy or falsy in Boolean contexts ( via__bool__).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以控制其实例如何与其他对象比较（通过特殊方法 __lt__, __le__, __gt__, __ge__, __eq__ 和 __ne__），字典如何将其用作键以及集合如何将其用作成员（通过
    __hash__），以及它们在布尔上下文中是否评估为真值或假值（通过 __bool__）。
- en: Attribute reference, binding, and unbinding
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 属性引用、绑定和解绑
- en: A class can control access to its instances’ attributes (reference, binding,
    unbinding) via special methods __getattribute__, __getattr__, __setattr__, and
    __delattr__.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以通过特殊方法 __getattribute__, __getattr__, __setattr__ 和 __delattr__ 控制对其实例属性（引用、绑定、解绑）的访问。
- en: Callable instances
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 可调用实例
- en: A class can make its instances callable, just like function objects, via special
    method __call__.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以通过特殊方法 __call__ 使其实例可调用，就像函数对象一样。
- en: '[Table 4-1](#general_purpose_special_methods) documents the general-purpose
    special methods.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-1](#general_purpose_special_methods) 记录了通用的特殊方法。'
- en: Table 4-1\. General-purpose special methods
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-1\. 通用特殊方法
- en: '| __bool__ | __bool__(self) When evaluating *x* as true or false (see [“Boolean
    Values”](ch03.xhtml#boolean_values))—for example, on a call to bool(*x*)—Python
    calls *x*.__bool__(), which should return **True** or **False**. When __bool__
    is not present, Python calls __len__, and takes *x* as falsy when *x*.__len__()
    returns 0 (to check that a container is nonempty, avoid coding **if** len(*container*)>0:;
    use **if** *container*: instead). When neither __bool__ nor __len__ is present,
    Python considers *x* truthy. |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| __bool__ | __bool__(self) 当对*x*进行真假判断（参见[“布尔值”](ch03.xhtml#boolean_values)）时，例如在调用bool(*x*)时，Python会调用*x*.__bool__()，该方法应返回**True**或**False**。当不存在__bool__方法时，Python会调用__len__方法，并且当*x*.__len__()返回0时将*x*视为假（为了检查容器是否非空，避免编写**if**
    len(*container*)>0:；而是使用**if** *container*:）。当既不存在__bool__方法也不存在__len__方法时，Python将*x*视为真。'
- en: '| __bytes__ | __bytes__(self) Calling bytes(*x*) calls *x*.__bytes__(), if
    present. If a class supplies both special methods __bytes__ and __str__, they
    should return “equivalent” strings, respectively, of bytes and str type. |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| __bytes__ | __bytes__(self) 调用bytes(*x*)时会调用*x*.__bytes__()，如果存在的话。如果一个类同时提供了__bytes__和__str__特殊方法，它们分别应返回“等效”的bytes类型和str类型字符串。'
- en: '| __call__ | __call__(self[, *args*...]) When you call *x*([*args*...]), Python
    translates the operation into a call to *x*.__call__([*args*...]). The arguments
    for the call operation correspond to the parameters for the __call__ method, minus
    the first one. The first parameter, conventionally called self, refers to *x*:
    Python supplies it implicitly, just as in any other call to a bound method. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| __call__ | __call__(self[, *args*...]) 当调用*x*([*args*...])时，Python会将此操作转换为对*x*.__call__([*args*...])的调用。调用操作的参数对应于__call__方法的参数，去除第一个参数。第一个参数，通常称为self，引用*x*：Python会隐式提供它，就像对绑定方法的任何其他调用一样。'
- en: '| __del__ | __del__(self) Just before *x* disappears via garbage collection,
    Python calls *x*.__del__() to let *x* finalize itself. If __del__ is absent, Python
    does no special finalization on garbage-collecting *x* (this is the most common
    case: very few classes need to define __del__). Python ignores the return value
    of __del__ and doesn’t implicitly call __del__ methods of class *C*’s superclasses.
    *C*.__del__ must explicitly perform any needed finalization, including, if need
    be, by delegation. When class *C* has base classes to finalize, *C*.__del__ must
    call super().__del__().'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '| __del__ | __del__(self) 当*x*通过垃圾收集消失之前，Python会调用*x*.__del__()让*x*完成最后操作。如果没有__del__方法，Python在回收*x*时不会进行特殊处理（这是最常见的情况：很少有类需要定义__del__）。Python忽略__del__的返回值，并且不会隐式调用*C*类超类的__del__方法。*C*.__del__必须显式执行任何需要的最终操作，包括必要时通过委托来完成。当类*C*有需要终结的基类时，*C*.__del__必须调用super().__del__()。'
- en: The __del__ method has no specific connection with the **del** statement, covered
    in [“del Statements”](ch03.xhtml#del_statements).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: __del__方法与[“del语句”](ch03.xhtml#del_statements)中涵盖的**del**语句没有特定联系。
- en: '__del__ is generally not the best approach when you need timely and guaranteed
    finalization. For such needs, use the **try**/**finally** statement covered in
    [“try/finally”](ch06.xhtml#trysolidusfinally) (or, even better, the **with** statement,
    covered in [“The with Statement”](ch03.xhtml#the_with_statement)). Instances of
    classes defining __del__ don’t participate in cyclic garbage collection, covered
    in [“Garbage Collection”](ch14.xhtml#garbage_collection). Be careful to avoid
    reference loops involving such instances: define __del__ only when there is no
    feasible alternative. |'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 一般情况下，当您需要及时和确保的最终操作时，__del__并不是最佳选择。对于这种需求，应使用[“try/finally”](ch06.xhtml#trysolidusfinally)中涵盖的**try**/**finally**语句（或者更好的是[“The
    with Statement”](ch03.xhtml#the_with_statement)中涵盖的**with**语句）。定义有__del__方法的类的实例不参与循环垃圾收集，详见[“垃圾收集”](ch14.xhtml#garbage_collection)。注意避免涉及这些实例的引用循环：只有在没有可行的替代方案时才定义__del__。
- en: '| __delattr__ | __delattr__(self, *name*) At every request to unbind attribute
    *x.y* (typically, **del** *x.y*), Python calls *x*.__delattr__(''*y*''). All the
    considerations discussed later for __setattr__ also apply to __delattr__. Python
    ignores the return value of __delattr__. Absent __delattr__, Python turns **del**
    *x.y* into **del** *x*.__dict__[''*y*'']. |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| __delattr__ | __delattr__(self, *name*) 每次请求解绑属性*x.y*（通常是**del** *x.y*），Python会调用*x*.__delattr__(''*y*'')。所有后续讨论的__setattr__都适用于__delattr__。Python忽略__delattr__的返回值。如果不存在__delattr__，Python会将**del**
    *x.y*转换为**del** *x*.__dict__[''*y*'']。'
- en: '| __dir__ | __dir__(self) When you call dir(*x*), Python translates the operation
    into a call to *x*.__dir__(), which must return a sorted list of *x*’s attributes.
    When *x*’s class has no __dir__, dir(*x*) performs introspection to return a sorted
    list of *x*’s attributes, striving to produce relevant, rather than complete,
    information. |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| __dir__ | __dir__(self) 当调用dir(*x*)时，Python将操作转换为调用*x*.__dir__()，它必须返回*x*的属性的排序列表。当*x*的类没有__dir__时，dir(*x*)执行内省以返回*x*的属性的排序列表，努力产生相关而非完整的信息。
    |'
- en: '| __eq__, __ge__, __gt__, __le__,'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '| __eq__, __ge__, __gt__, __le__,'
- en: __lt__, __ne__ | __eq__(self, *other*), __ge__(self, *other*), __gt__(self,
    *other*), __le__(self, *other*),
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: __lt__, __ne__ | __eq__(self, *other*), __ge__(self, *other*), __gt__(self,
    *other*), __le__(self, *other*),
- en: __lt__(self, *other*), __ne__(self, *other*)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: __lt__(self, *other*), __ne__(self, *other*)
- en: The comparisons *x* == *y*, *x* >= *y*, *x* > *y*, *x* <= *y*, *x* < *y*, and
    *x* != *y*, respectively, call the special methods listed here, which should return
    **False** or **True**. Each method may return NotImplemented to tell Python to
    handle the comparison in alternative ways (e.g., Python may then try *y* > *x*
    in lieu of *x* < *y*).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 比较*x* == *y*, *x* >= *y*, *x* > *y*, *x* <= *y*, *x* < *y*, 和*x* != *y*，分别调用列出的特殊方法，应返回**False**或**True**。每个方法可以返回NotImplemented告知Python以替代方式处理比较（例如，Python可能尝试*y*
    > *x*来代替*x* < *y*）。
- en: Best practice is to define only one inequality comparison method (normally __lt__)
    plus __eq__, and decorate the class with functools.total_ordering (covered in
    [Table 8-7](ch08.xhtml#functions_and_attributes_of_the_functoo)), to avoid boilerplate
    and any risk of logical contradictions in your comparisons. |
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是仅定义一个不等比较方法（通常是__lt__）加上__eq__，并用functools.total_ordering修饰类（在[表 8-7](ch08.xhtml#functions_and_attributes_of_the_functoo)中有介绍），以避免模板和比较中的逻辑矛盾风险。
    |
- en: '| __format__ | __format__(self, format_string='''') Calling format(*x*) calls
    *x*.__format__(''''), and calling format(*x, format_string*) calls *x*.__format__(*format_string*).
    The class is responsible for interpreting the format string (each class may define
    its own small “language” of format specifications, inspired by those implemented
    by built-in types, as covered in [“String Formatting”](ch09.xhtml#string_formatting)).
    When __format__ is inherited from object, it delegates to __str__ and does not
    accept a nonempty format string. |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| __format__ | __format__(self, format_string='''') 调用format(*x*)会调用*x*.__format__('''')，调用format(*x,
    format_string*)会调用*x*.__format__(*format_string*)。类负责解释格式字符串（每个类可以定义自己的小型格式规范语言，受内置类型实现的启发，如在[“字符串格式化”](ch09.xhtml#string_formatting)中介绍）。当从object继承__format__时，它委托给__str__并且不接受非空格式字符串。
    |'
- en: '| __getattr__ | __getattr__(self, *name*) When *x.y* can’t be found by the
    usual steps (i.e., when an AttributeError would usually be raised), Python calls
    *x*.__getattr__(''*y*''). Python does not call __getattr__ for attributes found
    by normal means (as keys in *x*.__dict__, or via *x*.__class__). If you want Python
    to call __getattr__ for *every* attribute, keep the attributes elsewhere (e.g.,
    in another dict referenced by an attribute with a private name), or override __getattribute__
    instead. __getattr__ should raise AttributeError if it can’t find *y*. |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| __getattr__ | __getattr__(self, *name*) 当找不到*x.y*的常规步骤时（即通常会引发AttributeError时），Python会调用*x*.__getattr__(''*y*'')。Python不会对通过常规方式找到的属性调用__getattr__（如作为*x*.__dict__中的键或通过*x*.__class__访问）。如果希望Python对*每个*属性都调用__getattr__，可以将属性存放在其他位置（例如通过私有名称引用的另一个字典中），或者改写__getattribute__。如果__getattr__找不到*y*，应该引发AttributeError。
    |'
- en: '| __getattribute__ | __getattribute_(self, *name*) At every request to access
    attribute *x*.*y*, Python calls *x*.__getattribute__(''*y*''), which must get
    and return the attribute value or else raise AttributeError. The usual semantics
    of attribute access (*x*.__dict__, *C.*__slots__, *C*’s class attributes, *x*.__getattr__)
    are all due to object.__getattribute__.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '| __getattribute__ | __getattribute_(self, *name*) 每次访问属性*x*.*y*时，Python调用*x*.__getattribute__(''*y*'')，它必须获取并返回属性值，否则引发AttributeError。属性访问的通常语义（*x*.__dict__、*C.*__slots__、*C*的类属性、*x*.__getattr__）都归因于object.__getattribute__。'
- en: When class *C* overrides __getattribute__, it must implement all of the attribute
    semantics it wants to offer. The typical way to implement attribute access is
    by delegating (e.g., call object.__getattribute__(self, ...) as part of the operation
    of your override of __getattribute__).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当类*C*重写__getattribute__时，必须实现它想要提供的所有属性语义。实现属性访问的典型方式是委托（例如，在重写__getattribute__的操作中调用object.__getattribute__(self,
    ...)）。
- en: Overriding __getattribute__ Slows Attribute Access
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重写__getattribute__会减慢属性访问速度
- en: When a class overrides __getattribute__, all attribute accesses on instances
    of the class become slow, as the overriding code executes on every attribute access.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类覆盖了 __getattribute__，则该类实例上的所有属性访问变得缓慢，因为覆盖的代码会在每次属性访问时执行。
- en: '|'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| __hash__ | __hash__(self) Calling hash(*x*) calls *x*.__hash__() (and so
    do other contexts that need to know *x*’s hash value, namely using *x* as a dictionary
    key, such as *D*[*x*] where *D* is a dictionary, or using *x* as a set member).
    __hash__ must return an int such that *x*==*y* implies hash(*x*)==hash(*y*), and
    must always return the same value for a given object.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '| __hash__ | __hash__(self) 调用 hash(*x*) 会调用 *x*.__hash__()（以及其他需要知道 *x* 哈希值的上下文，如将
    *x* 作为字典键使用，如 *D*[*x*] 其中 *D* 是一个字典，或将 *x* 作为集合成员使用）。__hash__ 必须返回一个 int，以便当 *x*==*y*
    时意味着 hash(*x*)==hash(*y*)，并且对于给定的对象必须始终返回相同的值。'
- en: When __hash__ is absent, calling hash(*x*) calls id(*x*) instead, as long as
    __eq__ is also absent. Other contexts that need to know *x*’s hash value behave
    the same way.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当缺少 __hash__ 时，调用 hash(*x*) 会调用 id(*x*)，只要同时缺少 __eq__。其他需要知道 *x* 哈希值的上下文行为相同。
- en: Any *x* such that hash(*x*) returns a result, rather than raising an exception,
    is known as a *hashable object*. When __hash__ is absent, but __eq__ is present,
    calling hash(*x*) raises an exception (and so do other contexts that need to know
    *x*’s hash value). In this case, *x* is not hashable and therefore cannot be a
    dictionary key or set member.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 *x*，使得 hash(*x*) 返回一个结果而不是引发异常，被称为*可哈希对象*。当缺少 __hash__，但存在 __eq__ 时，调用 hash(*x*)
    会引发异常（以及其他需要知道 *x* 的哈希值的上下文）。在这种情况下，*x* 不可哈希，因此不能作为字典键或集合成员。
- en: 'You normally define __hash__ only for immutable objects that also define __eq__.
    Note that if there exists any *y* such that *x*==*y*, even if *y* is of a different
    type, and both *x* and *y* are hashable, you *must* ensure that hash(*x*)==hash(*y*).
    (There are few cases, among Python built-ins, where *x*==*y* can hold between
    objects of different types. The most important ones are equality between different
    number types: an int can equal a bool, a float, a fractions.Fraction instance,
    or a decimal.Decimal instance.) |'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 通常只为不可变对象定义 __hash__，而且还定义了 __eq__。请注意，如果存在任何 *y* 使得 *x*==*y*，即使 *y* 是不同类型的对象，并且
    *x* 和 *y* 都是可哈希的，*必须*确保 hash(*x*)==hash(*y*)。（在 Python 内置类型中，存在一些情况，其中对象的不同类型之间可以相等。最重要的是不同数字类型之间的相等性：int
    可以等于 bool、float、fractions.Fraction 实例或 decimal.Decimal 实例。）
- en: '| __init__ | __init__(self[, *args*...]) When a call *C*([*args...*]) creates
    instance *x* of class *C*, Python calls *x*.__init__([*args*...]) to let *x* initialize
    itself. If __init__ is absent (i.e., it’s inherited from object), you must call
    *C* without arguments, *C*(), and *x* has no instance-specific attributes on creation.
    Python performs no implicit call to __init__ methods of class *C*’s superclasses.
    *C*.__init__ must explicitly perform any initialization, including, if need be,
    by delegation. For example, when class *C* has a base class *B* to initialize
    without arguments, the code in *C*.__init__ must explicitly call super().__init__().
    __init__’s inheritance works just like for any other method or attribute: if *C*
    itself does not override __init__, it inherits it from the first superclass in
    its __mro__ to override __init__, like every other attribute.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '| __init__ | __init__(self[, *args*...]) 当调用 *C*([*args...*]) 创建类 *C* 的实例 *x*
    时，Python 调用 *x*.__init__([*args...*]) 让 *x* 初始化自己。如果缺少 __init__（即从 object 继承），必须无参数调用
    *C*，即 *C*()，并且在创建时 *x* 没有实例特定的属性。Python 不会对 *C* 类及其超类的 __init__ 方法进行隐式调用。*C*.__init__
    必须显式执行任何初始化操作，包括必要时委托。例如，当类 *C* 有一个需要无参数初始化的基类 *B* 时，*C*.__init__ 中的代码必须显式调用 super().__init__()。__init__
    的继承与任何其他方法或属性相同：如果 *C* 本身没有覆盖 __init__，它会从其 __mro__ 中的第一个超类继承它，就像其他属性一样。'
- en: __init__ must return None; otherwise, calling the class raises TypeError. |
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__` 必须返回 None；否则，调用该类会引发 TypeError。'
- en: '| __new__ | __new__(cls[, *args*...]) When you call *C*([*args*...]), Python
    gets the new instance *x* that you are creating by invoking *C.*__new__(*C*[,
    *args*...]). Every class has the class method __new__ (usually, it just inherits
    it from object), which can return any value *x*. In other words, __new__ need
    not return a new instance of *C*, although it’s expected to do so. If the value
    *x* that __new__ returns is an instance of *C* or of any subclass of *C* (whether
    a new or a previously existing one), Python then calls __init__ on *x* (with the
    same [*args*...] originally passed to __new__).'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '| `__new__` | `__new__(cls[, *args*...])` 当你调用 `*C*([*args*...])` 时，Python
    通过调用 `*C*.__new__(*C*[, *args*...])` 来获取你正在创建的新实例 *x*。每个类都有类方法 `__new__`（通常只是从
    object 继承而来），它可以返回任何值 *x*。换句话说，`__new__` 不需要返回 *C* 的新实例，尽管期望如此。如果 `__new__` 返回的值
    *x* 是 *C* 的实例或 *C* 的任何子类的实例（无论是新的还是之前存在的实例），Python 就会在 *x* 上调用 `__init__`（使用最初传递给
    `__new__` 的相同 [*args*...]）。'
- en: Initialize Immutables in __new__, All Others in __init__
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 `__new__` 中初始化不可变对象，其他对象在 `__init__` 中初始化。
- en: 'You can perform most kinds of initialization of new instances in either __init__
    or __new__, so you may wonder where it’s best to place them. Best practice is
    to put the initialization in __init__ only, unless you have a specific reason
    to put it in __new__. (When a type is immutable, __init__ cannot change its instances:
    in this case, __new__ has to perform all initialization.)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `__init__` 或 `__new__` 中执行大多数类型的新实例初始化，所以你可能想知道最好将它们放在哪里。最佳实践是只将初始化放在 `__init__`
    中，除非你有一个特定的理由将其放在 `__new__` 中。（当类型是不可变的时，`__init__` 不能改变其实例：在这种情况下，`__new__` 必须执行所有的初始化。）
- en: '|'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '| |'
- en: '| __repr__ | __repr__(self) Calling repr(*x*) (which happens implicitly in
    the interactive interpreter when *x* is the result of an expression statement)
    calls *x*.__repr__() to get and return a complete string representation of *x*.
    If __repr__ is absent, Python uses a default string representation. __repr__ should
    return a string with unambiguous information on *x*. When feasible, try to make
    eval(repr(*x*))==*x* (but, don’t go crazy to achieve this goal!). |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `__repr__` | `__repr__(self)` 调用 `repr(*x*)`（当 *x* 是表达式语句的结果时，在交互解释器中会隐式发生）会调用
    `*x*.__repr__()` 来获取并返回 *x* 的完整字符串表示。如果没有 `__repr__`，Python 就会使用默认的字符串表示。 `__repr__`
    应返回一个包含关于 *x* 的无歧义信息的字符串。在可行的情况下，尝试使 `eval(repr(*x*))==*x*`（但不要为了达到这个目标而过度努力！）。
    |'
- en: '| __setattr__ | __setattr__(self, *name*, *value*) At any request to bind attribute
    *x.y* (usually, an assignment statement *x.y=value*, but also, e.g., setattr(*x*,
    ''*y*'', *value*)), Python calls *x*.__setattr__(''*y*'', *value*). Python always
    calls __setattr__ for *any* attribute binding on *x*—a major difference from __getattr__
    (in this respect, __setattr__ is closer to __getattribute__). To avoid recursion,
    when *x*.__setattr__ binds *x*’s attributes, it must modify *x*.__dict__ directly
    (e.g., via *x*.__dict__[*name*]=*value*); or better, __setattr__ can delegate
    to the superclass (call super().__setattr__(''*y*'', *value*)). Python ignores
    the return value of __setattr__. If __setattr__ is absent (i.e., inherited from
    object), and *C.y* is not an overriding descriptor, Python usually translates
    *x.y=z* into *x*.__dict__[''*y*'']=*z* (however, __setattr__ also works fine with
    __slots__). |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `__setattr__` | `__setattr__(self, *name*, *value*)` 对于绑定属性 `*x.y*` 的任何请求（通常是赋值语句
    `*x.y=value*`，但也可以是 `setattr(*x*, ''*y*'', *value*)`），Python 调用 `*x*.__setattr__(''*y*'',
    *value*)`。Python 总是对 *x* 的 *任何* 属性绑定调用 `__setattr__` —— 这与 `__getattr__` 的主要区别（在这一点上，`__setattr__`
    更接近 `__getattribute__`）。为了避免递归，当 `*x*.__setattr__` 绑定 *x* 的属性时，它必须直接修改 `*x*.__dict__`（例如，通过
    `*x*.__dict__[*name*]=*value*`）；或者更好的是，`__setattr__` 可以委托给超类（调用 `super().__setattr__(''*y*'',
    *value*)`）。Python 忽略 `__setattr__` 的返回值。如果 `__setattr__` 不存在（即从 object 继承），并且
    *C.y* 不是覆盖描述符，Python 通常会将 `*x.y=z*` 翻译为 `*x*.__dict__[''*y*'']=*z*`（但 `__setattr__`
    也可以与 `__slots__` 一起很好地工作）。 |'
- en: '| __str__ | __str__(self) Like print(*x*), str(*x*) calls *x*.__str__() to
    get an informal, concise string representation of *x*. If __str__ is absent, Python
    calls *x*.__repr__. __str__ should return a convenient human-readable string,
    even when that entails some approximation. |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `__str__` | `__str__(self)` 类似于 `print(*x*)`，`str(*x*)` 调用 `*x*.__str__()`
    来获取 *x* 的非正式、简洁的字符串表示。如果没有 `__str__`，Python 就会调用 `*x*.__repr__`。 `__str__` 应返回一个方便阅读的字符串，即使这可能需要一些近似。
    |'
- en: Special Methods for Containers
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器的特殊方法
- en: An instance can be a *container* (a sequence, mapping, or set—mutually exclusive
    concepts^([9](ch04.xhtml#ch01fn56))). For maximum usefulness, containers should
    provide special methods __getitem__, __contains__, and __iter__ (and, if mutable,
    also __setitem__ and __delitem__), plus nonspecial methods discussed in the following
    sections. In many cases, you can obtain suitable implementations of the nonspecial
    methods by extending the appropriate abstract base class from the collections.abc
    module, such as Sequence, MutableSequence, and so on, as covered in [“Abstract
    Base Classes”](#abstract_base_classe).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 实例可以是一个 *container*（序列、映射或集合——相互排斥的概念^([9](ch04.xhtml#ch01fn56))）。为了最大限度地提高实用性，容器应提供特殊方法
    __getitem__、__contains__ 和 __iter__（如果可变，则还应提供 __setitem__ 和 __delitem__），以及后续章节讨论的常规方法。在许多情况下，您可以通过扩展
    collections.abc 模块中的适当抽象基类（例如 Sequence、MutableSequence 等）来获得合适的常规方法实现，如 [“Abstract
    Base Classes”](#abstract_base_classe) 中所述。
- en: Sequences
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 序列
- en: In each item-access special method, a sequence that has *L* items should accept
    any integer *key* such that *-L*<=*key*<*L*.^([10](ch04.xhtml#ch01fn57)) For compatibility
    with built-in sequences, a negative index *key*, 0>*key*>=-*L*, should be equivalent
    to *key*+*L*. When *key* has an invalid type, indexing should raise a TypeError
    exception. When *key* is a value of a valid type but out of range, indexing should
    raise an IndexError exception. For sequence classes that do not define __iter__,
    the **for** statement relies on these requirements, as do built-in functions that
    take iterable arguments. Every item-access special method of a sequence should
    also, if at all practical, accept as its index argument an instance of the built-in
    type slice whose start, step, and stop attributes are ints or None; the *slicing*
    syntax relies on this requirement, as covered in [“Container slicing”](#container_slicing).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个项目访问的特殊方法中，一个包含 *L* 个项目的序列应接受任何整数 *key*，使得 *-L*<=*key*<*L*。^([10](ch04.xhtml#ch01fn57))
    为了与内置序列兼容，负索引 *key*，0>*key*>=-*L*，应等同于 *key*+*L*。当 *key* 具有无效类型时，索引应引发 TypeError
    异常。当 *key* 是有效类型的值但超出范围时，索引应引发 IndexError 异常。对于不定义 __iter__ 的序列类，**for** 语句依赖于这些要求，以及接受可迭代参数的内置函数也依赖于这些要求。每个序列的项目访问特殊方法也应（如果有可能）接受作为其索引参数的内置类型切片的实例，其
    start、step 和 stop 属性为 int 或 None；*slicing* 语法依赖于此要求，如 [“Container slicing”](#container_slicing)
    中所述。
- en: A sequence should also allow concatenation (with another sequence of the same
    type) by +, and repetition by * (multiplication by an integer). A sequence should
    therefore have special methods __add__, __mul__, __radd__, and __rmul__, covered
    in [“Special Methods for Numeric Objects”](#special_methods_for_numeric_object);
    in addition, *mutable* sequences should have equivalent in-place methods __iadd__
    and __imul__. A sequence should be meaningfully comparable to another sequence
    of the same type, implementing [*lexicographic* comparison](https://oreil.ly/byfuT),
    like lists and tuples do. (Inheriting from the Sequence or MutableSequence abstract
    base class does not suffice to fulfill all of these requirements; inheriting from
    MutableSequence, at most, only supplies __iadd__.)
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 序列还应允许通过 + 进行连接（与同类型的另一个序列），并通过 *（乘以整数）进行重复。因此，序列应具有特殊方法 __add__、__mul__、__radd__
    和 __rmul__，如 [“Special Methods for Numeric Objects”](#special_methods_for_numeric_object)
    中所述；此外，*可变*序列应具有等效的就地方法 __iadd__ 和 __imul__。序列应与同类型的另一个序列有意义地进行比较，实现 [*字典序*比较](https://oreil.ly/byfuT)，就像列表和元组一样。（继承自
    Sequence 或 MutableSequence 抽象基类不能满足所有这些要求；最多只能从 MutableSequence 继承，只提供 __iadd__。）
- en: 'Every sequence should have the nonspecial methods covered in [“List methods”](ch03.xhtml#list_methods):
    count and index in any case, and, if mutable, then also append, insert, extend,
    pop, remove, reverse, and sort, with the same signatures and semantics as the
    corresponding methods of lists. (Inheriting from the Sequence or MutableSequence
    abstract base class does suffice to fulfill these requirements, except for sort.)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 每个序列都应包括 [“List methods”](ch03.xhtml#list_methods) 中介绍的常规方法：不区分大小写的 count 和
    index 方法，如果可变，则还应包括 append、insert、extend、pop、remove、reverse 和 sort 方法，其签名和语义与列表的相应方法相同。（继承自
    Sequence 或 MutableSequence 抽象基类足以满足这些要求，除了 sort 方法。）
- en: An immutable sequence should be hashable if, and only if, all of its items are.
    A sequence type may constrain its items in some ways (for example, accepting only
    string items), but that is not mandatory.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个不可变序列的所有项都是可散列的，那么它本身也应该是可散列的。序列类型可能以某些方式限制其项（例如，仅接受字符串项），但这不是强制性的。
- en: Mappings
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射
- en: 'A mapping’s item-access special methods should raise a KeyError exception,
    rather than IndexError, when they receive an invalid *key* argument value of a
    valid type. Any mapping should define the nonspecial methods covered in [“Dictionary
    Methods”](ch03.xhtml#dictionary_methods): copy, get, items, keys, and values.
    A mutable mapping should also define the methods clear, pop, popitem, setdefault,
    and update. (Inheriting from the Mapping or MutableMapping abstract base class
    fulfills these requirements, except for copy.)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 映射的元素访问特殊方法在接收到无效的 *key* 参数值（有效类型）时应引发 KeyError 异常，而不是 IndexError。任何映射都应定义在[“字典方法”](ch03.xhtml#dictionary_methods)中介绍的非特殊方法：copy、get、items、keys
    和 values。可变映射还应定义方法 clear、pop、popitem、setdefault 和 update。（从 Mapping 或 MutableMapping
    抽象基类继承可以满足这些要求，但不包括 copy。）
- en: An immutable mapping should be hashable if all of its items are. A mapping type
    may constrain its keys in some ways—for example, accepting only hashable keys,
    or (even more specifically) accepting, say, only string keys—but that is not mandatory.
    Any mapping should be meaningfully comparable to another mapping of the same type
    (at least for equality and inequality, although not necessarily for ordering comparisons).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其所有项都是可哈希的，则不可变映射类似类型应该是可哈希的。映射类似类型可以在某些方面对其键进行约束，例如仅接受可哈希键，或者（更具体地）例如仅接受字符串键，但这不是强制性的。任何映射应该与相同类型的另一个映射有意义地可比较（至少在等式和不等式方面，尽管不一定是有序比较）。
- en: Sets
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合
- en: 'Sets are a peculiar kind of container: they are neither sequences nor mappings
    and cannot be indexed, but they do have a length (number of elements) and are
    iterable. Sets also support many operators (&, |, ^, and -, as well as membership
    tests and comparisons) and equivalent nonspecial methods (intersection, union,
    and so on). If you implement a set-like container, it should be polymorphic to
    Python built-in sets, covered in [“Sets”](ch03.xhtml#sets). (Inheriting from the
    Set or MutableSet abstract base class fulfills these requirements.)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是一种特殊的容器：它们既不是序列也不是映射，不能被索引，但是有长度（元素个数）并且可迭代。集合还支持许多运算符（&、|、^ 和 -），以及成员测试和比较，还有等效的非特殊方法（交集、并集等）。如果你实现了类似集合的容器，它应该对
    Python 内置的集合具有多态性，详见[“集合”](ch03.xhtml#sets)。（从 Set 或 MutableSet 抽象基类继承可以满足这些要求。）
- en: An immutable set-like type should be hashable if all of its elements are. A
    set-like type may constrain its elements in some ways—for example, accepting only
    hashable elements, or (more specifically) accepting, say, only integer elements—but
    that is not mandatory.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其所有元素都是可哈希的，则不可变集合类似类型应该是可哈希的。集合类似类型可以在某些方面对其元素进行约束，例如仅接受可哈希元素，或（更具体地）例如仅接受整数元素，但这不是强制性的。
- en: Container slicing
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器切片
- en: 'When you reference, bind, or unbind a slicing such as *x*[*i*:*j*] or *x*[*i*:*j*:*k*]
    on a container *x* (in practice, this is only used with sequences), Python calls
    *x*’s applicable item-access special method, passing as *key* an object of a built-in
    type called a *slice object*. A slice object has the attributes start, stop, and
    step. Each attribute is **None** if you omit the corresponding value in the slice
    syntax. For example, **del** *x*[:3] calls *x*.__delitem__(*y*), where *y* is
    a slice object such that *y*.stop is 3, *y*.start is **None**, and *y*.step is
    **None**. It is up to container object *x* to appropriately interpret slice object
    arguments passed to *x*’s special methods. The method indices of slice objects
    can help: call it with your container’s length as its only argument, and it returns
    a tuple of three nonnegative indices suitable as start, stop, and step for a loop
    indexing each item in the slice. For example, a common idiom in a sequence class’s
    __getitem__ special method to fully support slicing is:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 当你引用、绑定或取消绑定容器 *x* 上的切片，例如 *x*[*i*:*j*] 或 *x*[*i*:*j*:*k*]（在实践中，这仅用于序列时），Python
    调用 *x* 的适用的元素访问特殊方法，将一个名为 *slice object* 的内置类型的对象作为 *key*。切片对象具有属性 start、stop
    和 step。如果在切片语法中省略了相应的值，则每个属性都是 **None**。例如，**del** *x*[:3] 调用 *x*.__delitem__(*y*)，其中
    *y* 是一个切片对象，使得 *y*.stop 为 3，*y*.start 为 **None**，*y*.step 为 **None**。容器对象 *x*
    应适当地解释传递给 *x* 的特殊方法的切片对象参数。切片对象的方法 indices 可以帮助：以你的容器长度作为其唯一参数调用它，它返回一个包含三个非负索引的元组，适合作为循环索引切片中每个项目的开始、停止和步长。例如，在序列类的
    __getitem__ 特殊方法中，完全支持切片的常见习惯用法是：
- en: '[PRE54]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This idiom uses generator expression (genexp) syntax and assumes that your class’s
    __init__ method can be called with an iterable argument to create a suitable new
    instance of the class.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这种习惯用法使用生成器表达式（genexp）语法，并假定你的类的__init__方法可以使用可迭代参数调用，以创建适当的新实例。
- en: Container methods
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器方法
- en: The special methods __getitem__, __setitem__, __delitem__, __iter__, __len__,
    and __contains__ expose container functionality (see [Table 4-2](#container_methods)).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊方法__getitem__、__setitem__、__delitem__、__iter__、__len__和__contains__公开容器功能（参见[表
    4-2](#container_methods)）。
- en: Table 4-2\. Container methods
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 4-2\. 容器方法
- en: '| __contains__ | __contains__(self, *item*) The Boolean test *y* **in** *x*
    calls *x*.__contains__(*y*). When *x* is a sequence, or set-like, __contains__
    should return **True** when *y* equals the value of an item in *x*. When *x* is
    a mapping, __contains__ should return **True** when *y* equals the value of a
    key in *x*. Otherwise, __contains__ should return **False**. When __contains__
    is absent and *x* is iterable, Python performs *y* **in** *x* as follows, taking
    time proportional to len(*x*):'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '| __contains__ | 布尔测试*y* **in** *x* 调用*x*.__contains__(*y*)。当*x*是一个序列或类似集合时，__contains__应该在*y*等于*x*中的一个项的值时返回**True**。当*x*是一个映射时，__contains__应该在*y*等于*x*中的一个键的值时返回**True**。否则，__contains__应该返回**False**。当__contains__不存在且*x*是可迭代的时候，Python执行*y*
    **in** *x*如下，时间与len(*x*)成正比：'
- en: '[PRE55]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '|'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| __delitem__ | __delitem__(self, *key*) For a request to unbind an item or
    slice of *x* (typically **del** *x*[*key*]), Python calls *x*.__delitem__(*key*).
    A container *x* should have __delitem__ if *x* is mutable and items (and possibly
    slices) can be removed. |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| __delitem__ | 当一个请求要解除*x*的一个项或片段的绑定（通常是 **del** *x*[*key*]），Python调用*x*.__delitem__(*key*)。如果*x*是可变的且可以删除项（及可能的片段），则容器*x*应该有__delitem__。
    |'
- en: '| __getitem__ | __getitem__(self, *key*) When you access *x*[*key*] (i.e.,
    when you index or slice container *x*), Python calls *x*.__getitem__(*key*). All
    (non-set-like) containers should have __getitem__. |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| __getitem__ | 当你访问*x*[*key*]（即当你索引或切片容器*x*时），Python调用*x*.__getitem__(*key*)。所有（非类似集合的）容器都应该有__getitem__。
    |'
- en: '| __iter__ | __iter__(self) For a request to loop on all items of *x* (typically
    **for** *item* **in** *x*), Python calls *x*.__iter__() to get an iterator on
    *x*. The built-in function iter(*x*) also calls *x*.__iter__(). When __iter__
    is absent, iter(*x*) synthesizes and returns an iterator object that wraps *x*
    and yields *x*[0], *x*[1], and so on, until one of these indexings raises an IndexError
    exception to indicate the end of the container. However, it is best to ensure
    that all of the container classes you code have __iter__. |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| __iter__ | 当一个请求要循环遍历*x*的所有项（通常是 **for** *item* **in** *x*），Python调用*x*.__iter__()来获取*x*上的迭代器。内置函数iter(*x*)也调用*x*.__iter__()。当__iter__不存在时，iter(*x*)会合成并返回一个迭代器对象，该对象包装*x*并产生*x*[0]、*x*[1]等，直到这些索引中的一个引发IndexError异常以指示容器的末尾。但是，最好确保你编写的所有容器类都有__iter__。
    |'
- en: '| __len__ | __len__(self) Calling len(*x*) calls *x*.__len__() (and so do other
    built-in functions that need to know how many items are in container *x*). __len__
    should return an int, the number of items in *x*. Python also calls *x*._len__()
    to evaluate *x* in a Boolean context, when __bool__ is absent; in this case, a
    container is falsy if and only if the container is empty (i.e., the container’s
    length is 0). All containers should have __len__, unless it’s just too expensive
    for the container to determine how many items it contains. |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| __len__ | 调用len(*x*)会调用*x*.__len__()（其他需要知道容器*x*中有多少项的内置函数也会这样）。__len__应该返回一个整数，即*x*中的项数。当__bool__不存在时，Python还会调用*x*._len__()来评估*x*在布尔上下文中的值；在这种情况下，当且仅当容器为空时（即容器的长度为0时），容器是虚假的。所有容器都应该有__len__，除非容器确定包含的项数太昂贵。
    |'
- en: '| __setitem__ | __setitem__(self, *key, value*) For a request to bind an item
    or slice of *x* (typically an assignment *x*[*key*]=*value*), Python calls *x*.__setitem__(*key,
    value*). A container *x* should have __setitem__ if *x* is mutable, so items,
    and maybe slices, can be added or rebound. |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| __setitem__ | 当一个请求要绑定*x*的一个项或片段（通常是一个赋值*x*[*key*]=*value*），Python调用*x*.__setitem__(*key,
    value*)。如果*x*是可变的，则容器*x*应该有__setitem__，因此可以添加或重新绑定项，也许还有片段。 |'
- en: Abstract Base Classes
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象基类
- en: 'Abstract base classes (ABCs) are an important pattern in object-oriented design:
    they’re classes that cannot be directly instantiated, but exist to be extended
    by concrete classes (the more usual kind of classes, ones that *can* be instantiated).'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象基类（ABCs）是面向对象设计中的重要模式：它们是不能直接实例化的类，而是存在于被具体类扩展的目的（通常的类，可以被实例化的那种）。
- en: One recommended approach to OO design (attributed to Arthur J. Riel) is to never
    extend a concrete class.^([11](ch04.xhtml#ch01fn58)) If two concrete classes have
    enough in common to tempt you to have one of them inherit from the other, proceed
    instead by making an *abstract* base class that subsumes all they have in common,
    and have each concrete class extend that ABC. This approach avoids many of the
    subtle traps and pitfalls of inheritance.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 一个推荐的面向对象设计方法（归功于 Arthur J. Riel）是永远不要扩展一个具体类。^([11](ch04.xhtml#ch01fn58)) 如果两个具体类有足够的共同点，使你想让其中一个继承另一个，那么可以通过创建一个
    *抽象* 基类来替代，该抽象基类涵盖它们所有的共同点，并让每个具体类扩展该 ABC。这种方法避免了继承中许多微妙的陷阱和问题。
- en: Python offers rich support for ABCs—enough to make them a first-class part of
    Python’s object model.^([12](ch04.xhtml#ch01fn59))
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: Python 对 ABCs 提供了丰富的支持，足以使它们成为 Python 对象模型的一部分。^([12](ch04.xhtml#ch01fn59))
- en: The abc module
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: abc 模块
- en: The standard library module abc supplies metaclass ABCMeta and class ABC (subclassing
    abc.ABC makes abc.ABCMeta the metaclass, and has no other effect).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库模块 abc 提供了元类 ABCMeta 和类 ABC（继承 abc.ABC 使得 abc.ABCMeta 成为元类，且没有其他效果）。
- en: 'When you use abc.ABCMeta as the metaclass for any class *C*, this makes *C*
    an ABC and supplies the class method *C*.register, callable with a single argument:
    that single argument can be any existing class (or built-in type) *X*.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将 abc.ABCMeta 作为任何类 *C* 的元类时，这使得 *C* 成为一个 ABC，并提供了类方法 *C*.register，可用一个参数调用：该参数可以是任何现有类（或内置类型）
    *X*。
- en: Calling *C*.register(*X*) makes *X* a *virtual* subclass of *C*, meaning that
    issubclass(*X,* *C*) returns **True**, but *C* does not appear in *X*.__mro__,
    nor does *X* inherit any of *C*’s methods or other attributes.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 *C*.register(*X*) 使 *X* 成为 *C* 的一个 *虚拟* 子类，这意味着 issubclass(*X,* *C*) 返回 **True**，但
    *C* 不出现在 *X*.__mro__ 中，*X* 也不继承 *C* 的任何方法或其他属性。
- en: Of course, it’s also possible to have a new class *Y* inherit from *C* in the
    normal way, in which case *C* does appear in *Y*.__mro__, and *Y* inherits all
    of *C*’s methods, as usual in subclassing.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也可以像通常的子类化方式一样，让一个新类 *Y* 继承自 *C*，在这种情况下 *C* 会出现在 *Y*.__mro__ 中，并且 *Y* 继承
    *C* 的所有方法，就像通常的子类化一样。
- en: An ABC *C* can also optionally override class method __subclasshook__, which
    issubclass(*X, C*) calls with the single argument *X* (*X* being any class or
    type). When *C*.__subclasshook__(*X*) returns **True**, then so does issubclass(*X,
    C*); when *C*.__subclasshook__(*X*) returns **False**, then so does issubclass(*X,
    C*). When *C*.__subclasshook__(*X*) returns NotImplemented, then issubclass(*X,
    C*) proceeds in the usual way.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 ABC *C* 还可以选择重写类方法 __subclasshook__，当 issubclass(*X, C*) 调用时会传入单一参数 *X*（*X*
    是任何类或类型）。当 *C*.__subclasshook__(*X*) 返回 **True** 时，issubclass(*X, C*) 也返回 **True**；当
    *C*.__subclasshook__(*X*) 返回 **False** 时，issubclass(*X, C*) 也返回 **False**。当 *C*.__subclasshook__(*X*)
    返回 NotImplemented 时，issubclass(*X, C*) 会按照通常的方式进行。
- en: The abc module also supplies the decorator abstractmethod to designate methods
    that must be implemented in inheriting classes. You can define a property as abstract
    by using both the property and abstractmethod decorators, in that order.^([13](ch04.xhtml#ch01fn60))
    Abstract methods and properties can have implementations (available to subclasses
    via the super built-in), but the point of making methods and properties abstract
    is that you can instantiate a nonvirtual subclass *X* of an ABC *C* only if *X*
    overrides every abstract property and method of *C*.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: abc 模块还提供了 decorator abstractmethod 来指定必须在继承类中实现的方法。你可以通过先使用 property 然后是 abstractmethod
    decorators 的顺序来将属性定义为抽象。^([13](ch04.xhtml#ch01fn60)) 抽象方法和属性可以有实现（通过 super 内建函数对子类可见），但将方法和属性设为抽象的目的是，只有当
    *X* 覆盖了 ABC *C* 的每个抽象属性和方法时，才能实例化 ABC *C* 的非虚拟子类 *X*。
- en: ABCs in the collections module
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: collections 模块中的 ABCs
- en: collections supplies many ABCs, in collections.abc.^([14](ch04.xhtml#ch01fn61))
    Some of these ABCs accept as a virtual subclass any class defining or inheriting
    a specific abstract method, as listed in [Table 4-3](#single_method_abcs).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: collections 提供了许多 ABCs，在 collections.abc.^([14](ch04.xhtml#ch01fn61)) 中列出了一些这样的
    ABCs，这些 ABCs 接受作为虚拟子类任何定义或继承特定抽象方法的类，如 [表 4-3](#single_method_abcs) 中所列。
- en: Table 4-3\. Single-method ABCs
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-3\. 单方法 ABCs
- en: '| ABC | Abstract methods |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| ABC | 抽象方法 |'
- en: '| --- | --- |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Callable | __call__ |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| Callable | __call__ |'
- en: '| Container | __contains__ |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| Container | __contains__ |'
- en: '| Hashable | __hash__ |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| Hashable | __hash__ |'
- en: '| Iterable | __iter__ |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| Iterable | __iter__ |'
- en: '| Sized | __len__ |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| Sized | __len__ |'
- en: The other ABCs in collections.abc extend one or more of these, adding more abstract
    methods and/or *mixin* methods implemented in terms of the abstract methods. (When
    you extend any ABC in a concrete class, you *must* override the abstract methods;
    you can also override some or all of the mixin methods, when that helps improve
    performance, but you don’t have to—you can just inherit them, when this results
    in performance that’s sufficient for your purposes.)
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: collections.abc 中的其他 ABCs 扩展了其中一个或多个，添加了更多基于抽象方法的抽象方法和/或 *mixin* 方法。（当你在具体类中扩展任何
    ABC 时，你 *必须* 覆盖抽象方法；你也可以覆盖一些或所有的 mixin 方法，以帮助提高性能，但这不是必须的——当这样做能够获得足够的性能以满足你的目的时，你可以直接继承它们。）
- en: '[Table 4-4](#abcs_with_additional_methods) details the ABCs in collections.abc
    that directly extend the preceding ones.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-4](#abcs_with_additional_methods) 详细说明了 collections.abc 中直接扩展了前述 ABCs
    的 ABCs。'
- en: Table 4-4\. ABCs with additional methods
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-4\. 具有附加方法的 ABCs
- en: '| ABC | Extends | Abstract methods | Mixin methods |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| ABC | 扩展 | 抽象方法 | Mixin 方法 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Iterator | Iterable | __next__ | __iter__ |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| Iterator | Iterable | __next__ | __iter__ |'
- en: '| Mapping | Container Iterable'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '| Mapping | Container Iterable'
- en: Sized | __getitem__ __iter__
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: Sized | __getitem__ __iter__
- en: __len__ | __contains__ __eq__
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: __len__ | __contains__ __eq__
- en: __ne__
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: __ne__
- en: getitems
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: getitems
- en: keys
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: keys
- en: values |
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: values |
- en: '| MappingView | Sized |   | __len__ |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| MappingView | Sized |   | __len__ |'
- en: '| Sequence | Container Iterable'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '| Sequence | Container Iterable'
- en: Sized | __getitem__ __len__ | __contains__ __iter__
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: Sized | __getitem__ __len__ | __contains__ __iter__
- en: __reversed__
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: __reversed__
- en: count
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: count
- en: index |
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: index |
- en: '| Set | Container Iterable'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '| Set | Container Iterable'
- en: Sized | __contains__ __iter
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: Sized | __contains__ __iter
- en: __len__ | __and__^([a](ch04.xhtml#ch01fn62)) __eq__
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: __len__ | __and__^([a](ch04.xhtml#ch01fn62)) __eq__
- en: __ge__^([b](ch04.xhtml#ch01fn63))
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: __ge__^([b](ch04.xhtml#ch01fn63))
- en: __gt__
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: __gt__
- en: __le__
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: __le__
- en: __lt__
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: __lt__
- en: __ne__
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: __ne__
- en: __or__
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: __or__
- en: __sub__
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: __sub__
- en: __xor__
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: __xor__
- en: isdisjoint |
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: isdisjoint |
- en: '| ^([a](ch04.xhtml#ch01fn62-marker)) For sets and mutable sets, many dunder
    methods are equivalent to nonspecial methods in the concrete class set; e.g.,
    __add__ is like intersection and __iadd__ is like intersection_update.^([b](ch04.xhtml#ch01fn63-marker))
    For sets, the ordering methods reflect the concept of *subset*: *s1* <= *s2* means
    “*s1* is a subset of or equal to *s2*.” |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch04.xhtml#ch01fn62-marker)) 对于集合和可变集合，许多 dunder 方法等效于具体类 set 中的非特殊方法；例如，__add__
    就像交集，而 __iadd__ 就像 intersection_update。^([b](ch04.xhtml#ch01fn63-marker)) 对于集合，排序方法反映了“子集”的概念：*s1*
    <= *s2* 意味着“*s1* 是 *s2* 的子集或等于 *s2*。” |'
- en: '[Table 4-5](#the_remaining_abcs_in_collectionsdotabc) details the ABCs in this
    module that further extend the previous ones.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-5](#the_remaining_abcs_in_collectionsdotabc) 详细说明了本模块中进一步扩展的 ABCs。'
- en: Table 4-5\. The remaining ABCs in collections.abc
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-5\. collections.abc 中剩余的 ABCs
- en: '| ABC | Extends | Abstract methods | Mixin methods |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| ABC | 扩展 | 抽象方法 | Mixin 方法 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| ItemsView | MappingView Set |   | __contains__ __iter__ |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| ItemsView | MappingView Set |   | __contains__ __iter__ |'
- en: '| KeysView | MappingView Set |   | __contains__ __iter__ |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| KeysView | MappingView Set |   | __contains__ __iter__ |'
- en: '| MutableMapping | Mapping | __delitem__ __getitem__'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '| MutableMapping | Mapping | __delitem__ __getitem__'
- en: __iter__
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: __iter__
- en: __len_
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: __len_
- en: '__setitem__ | Mapping’s methods, plus: clear'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '__setitem__ | Mapping’s methods, plus: clear'
- en: pop
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: pop
- en: popitem
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: popitem
- en: setdefault
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: setdefault
- en: update |
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: update |
- en: '| MutableSequence | Sequence | __delitem__ __getitem__'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '| MutableSequence | Sequence | __delitem__ __getitem__'
- en: __len__
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: __len__
- en: __setitem__
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: __setitem__
- en: 'insert | Sequence’s methods, plus: __iadd__'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 'insert | Sequence’s methods, plus: __iadd__'
- en: append
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: append
- en: extend
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: extend
- en: pop
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: pop
- en: remove
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: remove
- en: reverse |
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: reverse |
- en: '| MutableSet | Set | __contains__ __iter'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '| MutableSet | Set | __contains__ __iter'
- en: __len__
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: __len__
- en: add
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: add
- en: 'discard | Set’s methods, plus: __iand__'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 'discard | Set’s methods, plus: __iand__'
- en: __ior__
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: __ior__
- en: __isub__
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: __isub__
- en: __ixor__
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: __ixor__
- en: clear
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: clear
- en: pop
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: pop
- en: remove |
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: remove |
- en: '| ValuesView | MappingView |   | __contains__ __iter__ |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| ValuesView | MappingView |   | __contains__ __iter__ |'
- en: See the [online docs](https://oreil.ly/AVoUU) for further details and usage
    examples.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [在线文档](https://oreil.ly/AVoUU) 获取更多详细信息和使用示例。
- en: ABCs in the numbers module
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: numbers 模块中的 ABCs
- en: numbers supplies a hierarchy (also known as a *tower*) of ABCs representing
    various kinds of numbers. [Table 4-6](#abcs_supplied_by_the_numbers_module) lists
    the ABCs in the numbers module.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: numbers 提供了一个层次结构（也称为 *tower*）的 ABCs，表示各种类型的数字。 [表 4-6](#abcs_supplied_by_the_numbers_module)
    列出了 numbers 模块中的 ABCs。
- en: Table 4-6\. ABCs supplied by the numbers module
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-6\. numbers 模块提供的 ABCs
- en: '| ABC | Description |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| ABC | 描述 |'
- en: '| --- | --- |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Number | The root of the hierarchy. Includes numbers of *any* kind; need
    not support any given operation. |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| Number | 层次结构的根。包括任意类型的数值；不需要支持任何给定的操作。 |'
- en: '| Complex | Extends Number. Must support (via special methods) conversions
    to complex and bool, +, -, *, /, ==, !=, and abs, and, directly, the method conjugate
    and properties real and imag. |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| Complex | 扩展自 Number。必须支持（通过特殊方法）转换为 complex 和 bool，以及 +，-，*，/，==，!=，和 abs，以及直接的方法
    conjugate 和属性 real 和 imag。'
- en: '| Real | Extends Complex.^([a](ch04.xhtml#ch01fn64)) Additionally, must support
    (via special methods) conversion to float, math.trunc, round, math.floor, math.ceil,
    divmod, //, %, <, <=, >, and >=. |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| Real | 扩展自 Complex。此外，必须支持（通过特殊方法）转换为 float，math.trunc，round，math.floor，math.ceil，divmod，//，%，<，<=，>，和
    >=。'
- en: '| Rational | Extends Real. Additionally, must support the properties numerator
    and denominator. |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| Rational | 扩展自 Real。此外，必须支持 numerator 和 denominator 属性。 |'
- en: '| Integral | Extends Rational.^([b](ch04.xhtml#ch01fn65)) Additionally, must
    support (via special methods) conversion to int, **, and bitwise operations <<,
    >>, &, ^, &#124;, and ~. |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| Integral | 扩展自 Rational。此外，必须支持（通过特殊方法）转换为 int，**，和位运算 <<，>>，&，^，|，和 ~。'
- en: '| ^([a](ch04.xhtml#ch01fn64-marker)) So, every int or float has a property
    real equal to its value, and a property imag equal to 0.^([b](ch04.xhtml#ch01fn65-marker))
    So, every int has a property numerator equal to its value, and a property denominator
    equal to 1. |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch04.xhtml#ch01fn64-marker)) 因此，每个整数或浮点数都有一个 real 属性等于其值，以及一个 imag
    属性等于 0.^([b](ch04.xhtml#ch01fn65-marker)) 因此，每个整数都有一个 numerator 属性等于其值，以及一个 denominator
    属性等于 1. |'
- en: See the [online docs](https://oreil.ly/ViRw9) for notes on implementing your
    own numeric types.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [在线文档](https://oreil.ly/ViRw9) 获取关于实现自定义数值类型的说明。
- en: Special Methods for Numeric Objects
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数值对象的特殊方法
- en: An instance may support numeric operations by means of many special methods.
    Some classes that are not numbers also support some of the special methods in
    [Table 4-7](#special_methods_for_numeric_objects) in order to overload operators
    such as + and *. In particular, sequences should have special methods __add__,
    __mul__, __radd__, and __rmul__, as mentioned in [“Sequences”](ch03.xhtml#sequence).
    When one of the binary methods (such as __add__, __sub__, etc.) is called with
    an operand of an unsupported type for that method, the method should return the
    built-in singleton NotImplemented.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实例可以通过多个特殊方法支持数值操作。一些不是数字的类也支持 [Table 4-7](https://oreil.ly/ViRw9) 中的一些特殊方法，以重载如
    + 和 * 的运算符。特别是，序列应该有特殊方法 __add__, __mul__, __radd__, 和 __rmul__，如 [“Sequences”](ch03.xhtml#sequence)
    所述。当二进制方法之一（如 __add__, __sub__ 等）被调用时，如果操作数的类型不支持该方法，则该方法应返回内置的 NotImplemented
    单例。
- en: Table 4-7\. Special methods for numeric objects
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-7\. 数值对象的特殊方法
- en: '| __abs__, __invert__,'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '| __abs__, __invert__,'
- en: __neg__,
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: __neg__,
- en: __pos__ | __abs_(self), __invert__(self), __neg__(self), __pos__(self) The unary
    operators abs(*x*), ~*x*, -*x*, and +*x*, respectively, call these methods. |
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: __pos__ | __abs_(self), __invert__(self), __neg__(self), __pos__(self) 一元运算符
    abs(*x*), ~*x*, -*x*, 和 +*x*，分别调用这些方法。
- en: '| __add__, __mod__,'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '| __add__, __mod__,'
- en: __mul__,
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: __mul__,
- en: __sub__ | __add__ (self, *other*), __mod__(self, *other*),
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: __sub__ | __add__ (self, *other*), __mod__(self, *other*),
- en: __mul__(self, *other*),
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: __mul__(self, *other*),
- en: __sub__(self, *other*)
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: __sub__(self, *other*)
- en: The operators *x +* *y*, *x %* *y*, *x ** *y*, and *x -* *y*, respectively,
    call these methods, usually for arithmetic computations. |
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符 *x +* *y*, *x %* *y*, *x ** *y*, 和 *x -* *y* 分别调用这些方法，通常用于算术计算。
- en: '| __and__, __lshift__,'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '| __and__, __lshift__,'
- en: __or__,
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: __or__,
- en: __rshift__,
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: __rshift__,
- en: __xor__ | __and__(self, *other*), __lshift__(self, *other*), __or__(self, *other*),
    __rshift_(self, *other*),
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: __xor__ | __and__(self, *other*), __lshift__(self, *other*), __or__(self, *other*),
    __rshift_(self, *other*),
- en: __xor__(self, *other*)
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: __xor__(self, *other*)
- en: The operators *x &* *y*, *x <<* *y*, *x &#124;* *y*, *x >>* *y*, and *x ^* *y*,
    respectively, call these methods, usually for bitwise operations. |
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符 *x &* *y*, *x <<* *y*, *x \|* *y*, *x >>* *y*, 和 *x ^* *y* 分别调用这些方法，通常用于位运算。
- en: '| __complex__, __float__,'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '| __complex__, __float__,'
- en: __int__ | __complex__(self), __float__(self), __int__(self) The built-in types
    complex(*x*), float(*x*), and int(*x*), respectively, call these methods. |
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: __int__ | __complex__(self), __float__(self), __int__(self) 内置类型 complex(*x*),
    float(*x*), 和 int(*x*)，分别调用这些方法。
- en: '| __divmod__ | __divmod__(self, o*ther*) The built-in function divmod(*x, y*)
    calls *x*.__divmod__(*y*). __divmod__ should return a pair (*quotient, remainder*)
    equal to (*x* // *y, x* % *y*). |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| __divmod__ | __divmod__(self, o*ther*) 内置函数 divmod(*x, y*) 调用 *x*.__divmod__(*y*)。__divmod__
    应返回一对 (*quotient, remainder*) 等于 (*x* // *y, x* % *y*)。'
- en: '| __floordiv__, __truediv__ | __floordiv__(self, *other*), __truediv__(self,
    *other*)'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '| __floordiv__, __truediv__ | __floordiv__(self, *other*)，__truediv__(self,
    *other*)，'
- en: The operators *x* // *y* and *x* / *y*, respectively, call these methods, usually
    for arithmetic division. |
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符 *x* // *y* 和 *x* / *y*，通常用于算术除法。 |
- en: '| __iadd__, __ifloordiv__,'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '| __iadd__, __ifloordiv__,'
- en: __imod__,
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: __imod__，
- en: __imul__,
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: __imul__，
- en: __isub__,
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: __isub__，
- en: __itruediv__,
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: __itruediv__，
- en: __imatmul__ | __iadd__(self, *other*), __ifloordiv__(self, *other*),
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: __imatmul__ | __iadd__(self, *other*)，__ifloordiv__(self, *other*)，
- en: __imod__(self, *other*),
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: __imod__(self, *other*)，
- en: __imul__(self, *other*),
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: __imul__(self, *other*)，
- en: __isub__(self, *other*),
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: __isub__(self, *other*)，
- en: __itruediv__(self, *other*),
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: __itruediv__(self, *other*)，
- en: __imatmul__(self, *other*)
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: __imatmul__(self, *other*)，
- en: The augmented assignments *x* += *y*, *x* //= *y*, *x* %= *y*, *x* *= *y*, *x*
    -= *y*, *x* /= *y*, and *x* @= *y*, respectively, call these methods. Each method
    should modify *x* in place and return self. Define these methods when *x* is mutable
    (i.e., when *x* *can* change in place). |
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 增强赋值 *x* += *y*，*x* //= *y*，*x* %= *y*，*x* *= *y*，*x* -= *y*，*x* /= *y*，和 *x*
    @= *y*，分别调用这些方法。每个方法应该就地修改 *x* 并返回 self。当 *x* 是可变的时候定义这些方法（即，当 *x* *可以* 就地更改时）。
    |
- en: '| __iand__, __ilshift__,'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '| __iand__, __ilshift__,'
- en: __ior__,
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: __ior__，
- en: __irshift__,
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: __irshift__，
- en: __ixor__ | __iand_(self, *other*), __ilshift_(self, *other*),
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: __ixor__ | __iand_(self, *other*)，__ilshift_(self, *other*)，
- en: __ior__(self, *other*),
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: __ior__(self, *other*)，
- en: __irshift__(self, *other*),
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: __irshift__(self, *other*)，
- en: __ixor__(self, *other*)
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: __ixor__(self, *other*)，
- en: The augmented assignments *x* &= *y*, *x* <<= *y*, *x* \= *y*, *x* >>= *y*,
    and *x* ^= *y*, respectively, call these methods. Each method should modify *x*
    in place and return self. Define these methods when *x* is mutable (i.e., when
    *x* *can* change in place). |
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 增强赋值 *x* &= *y*，*x* <<= *y*，*x* \= *y*，*x* >>= *y*，和 *x* ^= *y*，分别调用这些方法。每个方法应该就地修改
    *x* 并返回 self。当 *x* 是可变的时候定义这些方法（即，当 *x* *可以* 就地更改时）。 |
- en: '| __index__ | __index__(self) Like __int__, but meant to be supplied only by
    types that are alternative implementations of integers (in other words, all of
    the type’s instances can be exactly mapped into integers). For example, out of
    all the built-in types, only int supplies __index__; float and str don’t, although
    they do supply __int__. Sequence indexing and slicing internally use __index__
    to get the needed integer indices. |'
  id: totrans-484
  prefs: []
  type: TYPE_TB
  zh: '| __index__ | __index__(self) 像__int__一样，但只应由整数的替代实现类型提供（换句话说，该类型的所有实例都可以精确映射到整数）。例如，所有内置类型中，只有int提供__index__；float和str不提供，尽管它们提供__int__。序列的索引和切片内部使用__index__来获取所需的整数索引。
    |'
- en: '| __ipow__ | __ipow__(self,*other*) The augmented assignment *x* **= *y* calls
    *x*.__ipow__(*y*). __ipow__ should modify *x* in place and return self. |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '| __ipow__ | __ipow__(self,*other*) 增强赋值 *x* **= *y* 调用 *x*.__ipow__(*y*)。__ipow__
    应该就地修改 *x* 并返回 self。 |'
- en: '| __matmul__ | __matmul__(self, *other*) The operator *x* @ *y* calls this
    method, usually for matrix multiplication. |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '| __matmul__ | __matmul__(self, *other*) 运算符 *x* @ *y* 调用这个方法，通常用于矩阵乘法。 |'
- en: '| __pow__ | __pow__(self,*other*[, *modulo*]) *x* ** *y* and pow(*x, y*) both
    call *x*.__pow__(*y*), while pow(*x, y, z*) calls *x*.__pow__(*y*, *z*). *x*.__pow__(*y,
    z*) should return a value equal to the expression *x*.__pow__(*y*) % *z*. |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '| __pow__ | __pow__(self,*other*[, *modulo*]) *x* ** *y* 和 pow(*x, y*) 都调用
    *x*.__pow__(*y*)，而 pow(*x, y, z*) 调用 *x*.__pow__(*y*, *z*)。 *x*.__pow__(*y, z*)
    应该返回等于表达式 *x*.__pow__(*y*) % *z* 的值。 |'
- en: '| __radd__, __rmod__,'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '| __radd__, __rmod__,'
- en: __rmul__,
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: __rmul__，
- en: __rsub__,
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: __rsub__，
- en: __rmatmul__ | __radd__(self, *other*), __rmod__(self, *other*),
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: __rmatmul__ | __radd__(self, *other*)，__rmod__(self, *other*)，
- en: __rmul__(self, *other*),
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: __rmul__(self, *other*)，
- en: __rsub__(self, *other*),
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: __rsub__(self, *other*)，
- en: __rmatmul__(self, *other*)
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: __rmatmul__(self, *other*)，
- en: The operators *y* + *x*, *y* / *x*, *y* % *x*, *y* * *x*, *y - x*, and *y* @
    *x*, respectively, call these methods on *x* when *y* doesn’t have the needed
    method __add__, __truediv__, and so on, or when that method returns NotImplemented.
    |
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符 *y* + *x*，*y* / *x*，*y* % *x*，*y* * *x*，*y - x*，和 *y* @ *x*，分别在 *y* 没有所需方法
    __add__，__truediv__ 等，或者当该方法返回 NotImplemented 时，在 *x* 上调用这些方法。 |
- en: '| __rand__, __rlshift__,'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '| __rand__, __rlshift__,'
- en: __ror__,
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: __ror__，
- en: __rrshift__,
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: __rrshift__，
- en: __rxor__ | __rand__(self, *other*), __rlshift__(self, *other*),
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: __rxor__ | __rand__(self, *other*)，__rlshift__(self, *other*)，
- en: __ror__(self, *other*),
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: __ror__(self, *other*)，
- en: __rrshift__(self, *other*),
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: __rrshift__(self, *other*)，
- en: __rxor__(self, *other*)
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: __rxor__(self, *other*)，
- en: The operators *y* & *x*, *y* << *x*, *y* &#124; *x*, *y* >> *x*, and *x* ^ *y*,
    respectively, call these methods on *x* when *y* doesn’t have the needed method
    __and__, __lshift__, and so on, or when that method returns NotImplemented. |
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符 *y* & *x*，*y* << *x*，*y* &#124; *x*，*y* >> *x*，以及 *x* ^ *y* 分别在 *y* 没有所需方法
    __and__，__lshift__，等等，或者当该方法返回 NotImplemented 时，在 *x* 上调用这些方法。|
- en: '| __rdivmod__ | __rdivmod_(self, *other*) The built-in function divmod(*y*,
    *x*) calls *x*.__rdivmod__(*y*) when *y* doesn’t have __divmod__, or when that
    method returns NotImplemented. __rdivmod__ should return a pair (*remainder*,
    *quotient*). |'
  id: totrans-504
  prefs: []
  type: TYPE_TB
  zh: '| __rdivmod__ | __rdivmod_(self, *other*) 内置函数 divmod(*y*, *x*) 调用 *x*.__rdivmod__(*y*)
    当 *y* 没有 __divmod__，或者当该方法返回 NotImplemented 时。__rdivmod__ 应返回一个对 (*remainder*,
    *quotient*)。'
- en: '| __rpow__ | __rpow__(self,*other*) *y* ** *x* and pow(*y*, *x*) call *x*.__rpow__(*y*)
    when *y* doesn’t have __pow__, or when that method returns NotImplemented. There
    is no three-argument form in this case. |'
  id: totrans-505
  prefs: []
  type: TYPE_TB
  zh: '| __rpow__ | __rpow__(self,*other*) *y* ** *x* 和 pow(*y*, *x*) 调用 *x*.__rpow__(*y*)
    当 *y* 没有 __pow__，或者当该方法返回 NotImplemented 时。在这种情况下，没有三个参数的形式。 |'
- en: Decorators
  id: totrans-506
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器
- en: 'In Python, you often use *higher-order functions*: callables that accept a
    function as an argument and return a function as their result. For example, descriptor
    types such as staticmethod and classmethod, covered in [“Class-Level Methods”](#class_level_methods),
    can be used, within class bodies, as follows:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，经常使用 *高阶函数*：接受函数作为参数并返回函数作为结果的可调用对象。例如，描述符类型，如 staticmethod 和 classmethod，在类体内可以使用，如
    [“类级方法”](#class_level_methods) 所述：
- en: '[PRE56]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'However, having the call to classmethod textually *after* the **def** statement
    hurts code readability: while reading *f*’s definition, the reader of the code
    is not yet aware that *f* is going to become a class method rather than an instance
    method. The code is more readable if the mention of classmethod comes *before*
    the def. For this purpose, use the syntax form known as *decoration*:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将 classmethod 的调用在 **def** 语句之后的文本上，对代码的可读性有所影响：当阅读 *f* 的定义时，代码的读者尚不知道 *f*
    将成为类方法而不是实例方法。如果在 **def** 前面提到 classmethod，则代码更易读。为此，使用称为 *装饰* 的语法形式：
- en: '[PRE57]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The decorator, here @classmethod, must be immediately followed by a **def**
    statement and means that *f* = *classmethod*(*f*) executes right after the **def**
    statement (for whatever name *f* the **def** defines). More generally, @*expression*
    evaluates the expression (which must be a name, possibly qualified, or a call)
    and binds the result to an internal temporary name (say, *__aux*); any decorator
    must be immediately followed by a **def** (or **class**) statement, and means
    that *f* = __*aux*(*f*) executes right after the **def** or **class** statement
    (for whatever name *f* the **def** or **class** defines). The object bound to
    __*aux* is known as a *decorator*, and it’s said to *decorate* function or class
    *f*.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器，这里的 @classmethod，必须紧随其后的 **def** 语句，并意味着 *f* = *classmethod*(*f*) 在 **def**
    语句之后立即执行（无论 *f* 是 **def** 定义的任何名称）。更一般地，@*expression* 评估表达式（必须是一个名称，可能是限定的，或者是一个调用），并将结果绑定到一个内部临时名称（比如，*__aux*）；任何装饰器必须紧跟在
    **def**（或 **class**）语句之后，并意味着 *f* = *__aux*(*f*) 在 **def** 或 **class** 语句之后立即执行（无论
    *f* 是 **def** 或 **class** 定义的任何名称）。绑定到 *__aux* 的对象称为 *装饰器*，它被称为 *装饰* 函数或类 *f*。
- en: 'Decorators are a handy shorthand for some higher-order functions. You can apply
    decorators to any **def** or **class** statement, not just in class bodies. You
    may code custom decorators, which are just higher-order functions accepting a
    function or class object as an argument and returning a function or class object
    as the result. For example, here is a simple example decorator that does not modify
    the function it decorates, but rather prints the function’s docstring to standard
    output at function definition time:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是一种便捷的高阶函数缩写。你可以将装饰器应用于任何 **def** 或 **class** 语句，不仅限于类体内。你可以编写自定义装饰器，它们只是接受函数或类对象作为参数，并返回函数或类对象作为结果的高阶函数。例如，这是一个简单的装饰器示例，它不修改其装饰的函数，而是在函数定义时将函数的文档字符串打印到标准输出：
- en: '[PRE58]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The standard library module functools offers a handy decorator, wraps, to enhance
    decorators built by the common “wrapping” idiom:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库模块 functools 提供了一个方便的装饰器 wraps，用于增强常见的“包装”习惯建立的装饰器：
- en: '[PRE59]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Decorating a function *f* with @announce causes a line announcing the call
    to be printed before each call to *f*. Thanks to the functools.wraps(*f*) decorator,
    the wrapper adopts the name and docstring of the wrappee: this is useful, for
    example, when calling the built-in help on such a decorated function.'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 @announce 装饰函数 *f* 导致在每次调用 *f* 之前打印一行公告。由于 functools.wraps(*f*) 装饰器，包装器采用被包装函数的名称和文档字符串：例如，在调用这样一个装饰过的函数时调用内置帮助是有用的。
- en: Metaclasses
  id: totrans-517
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元类
- en: 'Any object, even a class object, has a type. In Python, types and classes are
    also first-class objects. The type of a class object is also known as the class’s
    *metaclass*.^([15](ch04.xhtml#ch01fn66)) An object’s behavior is mostly determined
    by the type of the object. This also holds for classes: a class’s behavior is
    mostly determined by the class’s metaclass. Metaclasses are an advanced subject,
    and you may want to skip the rest of this section. However, fully grasping metaclasses
    can lead you to a deeper understanding of Python; very occasionally, it can be
    useful to define your own custom metaclasses.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 任何对象，甚至是类对象，都有一种类型。在 Python 中，类型和类也是一等对象。类对象的类型也称为类的 *元类*。^([15](ch04.xhtml#ch01fn66))
    对象的行为主要由对象的类型确定。对于类也是如此：类的行为主要由类的元类确定。元类是一个高级主题，您可能想跳过本节的其余部分。但是，完全掌握元类可以带您深入了解
    Python；偶尔定义自己的自定义元类可能会有用。
- en: Alternatives to Custom Metaclasses for Simple Class Customization
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单类定制的替代方法元类。
- en: While a custom metaclass lets you tweak classes’ behaviors in pretty much any
    way you want, it’s often possible to achieve some customizations more simply than
    by coding a custom metaclass.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然自定义元类允许您以几乎任何想要的方式调整类的行为，但通常可以通过编写自定义元类来更简单地实现一些自定义。
- en: 'When a class *C* has or inherits a class method __init_subclass__, Python calls
    that method whenever you subclass *C*, passing the newly built subclass as the
    only positional argument. __init_subclass__ can also have named parameters, in
    which case Python passes corresponding named arguments found in the class statement
    that performs the subclassing. As a purely illustrative example:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 当类 *C* 具有或继承类方法 __init_subclass__ 时，Python 在每次对 *C* 进行子类化时调用该方法，将新构建的子类作为唯一的位置参数传递。__init_subclass__
    也可以有命名参数，在这种情况下，Python 会传递在执行子类化的类语句中找到的相应命名参数。作为一个纯粹的说明性例子：
- en: '[PRE60]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The code in __init_subclass__ can alter cls in any applicable, post-class-creation
    way; essentially, it works like a class decorator that Python automatically applies
    to any subclass of C.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: __init_subclass__ 中的代码可以以适用的方式修改 cls，在类创建后工作方式上本质上像一个 Python 自动应用于 C 的任何子类的类装饰器。
- en: 'Another special method used for customization is __set_name__, which lets you
    ensure that instances of descriptors added as class attributes know what class
    you’re adding them to, and under which names. At the end of the **class** statement
    that adds *ca* to class *C* with name *n*, when the type of *ca* has the method
    __set_name__, Python calls *ca.*__set_name__(*C,* *n*). For example:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用于定制的特殊方法是 __set_name__，它允许您确保将描述符的实例添加为类属性时，它们知道您正在向其添加的类和名称。在将 *ca* 添加到名为
    *C* 的类并命名为 *n* 的类语句的末尾，当 *ca* 的类型具有方法 __set_name__ 时，Python 调用 *ca.*__set_name__(*C,*
    *n*)。例如：
- en: '[PRE64]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: How Python Determines a Class’s Metaclass
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何确定 Python 类的元类。
- en: The **class** statement accepts optional named arguments (after the bases, if
    any). The most important named argument is metaclass, which, if present, identifies
    the new class’s metaclass. Other named arguments are allowed only if a non-type
    metaclass is present, in which case they are passed on to the optional __prepare__
    method of the metaclass (it’s entirely up to the __prepare__ method to make use
    of such named arguments).^([16](ch04.xhtml#ch01fn67)) When the named argument
    metaclass is absent, Python determines the metaclass by inheritance; for classes
    with no explicitly specified bases, the metaclass defaults to type.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '**class** 语句接受可选的命名参数（在基类之后，如果有）。最重要的命名参数是 metaclass，如果存在，则标识新类的元类。如果存在非类型元类，则还允许其他命名参数，此时这些参数传递给元类的可选
    __prepare__ 方法（完全由 __prepare__ 方法决定如何使用此类命名参数）。^([16](ch04.xhtml#ch01fn67)) 当命名参数
    metaclass 不存在时，Python 通过继承来确定元类；对于没有明确指定基类的类，默认元类为 type。'
- en: 'Python calls the __prepare__ method, if present, as soon as it determines the
    metaclass, as follows:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: Python 调用 __prepare__ 方法（如果存在）来确定元类后立即调用元类，如下所示：
- en: '[PRE67]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Here, the call is equivalent to M.__prepare__('X', onebase, another, foo='bar').
    __prepare__, if present, must return a mapping (usually just a dictionary), which
    Python uses as the *d* mapping in which it executes the class body. If __prepare__
    is absent, Python uses a new, initially empty dict as *d*.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，调用等同于M.__prepare__('X', onebase, another, foo='bar')。如果存在__prepare__，则必须返回映射（通常只是字典），Python将其用作执行类体的*d*映射。如果不存在__prepare__，Python将使用一个新的、最初为空的字典作为*d*。
- en: How a Metaclass Creates a Class
  id: totrans-536
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元类如何创建类
- en: 'Having determined the metaclass *M*, Python calls *M* with three arguments:
    the class name (a str), the tuple of base classes *t*, and the dictionary (or
    other mapping resulting from __prepare__) *d* in which the class body just finished
    executing.^([17](ch04.xhtml#ch01fn68)) The call returns the class object *C*,
    which Python then binds to the class name, completing the execution of the **class**
    statement. Note that this is in fact an instantiation of type *M*, so the call
    to *M* executes *M.*__init__(*C*, *namestring*, *t*, *d*), where *C* is the return
    value of *M.*__new__(*M, namestring, t, d*), just as in any other instantiation.'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 确定了元类*M*后，Python使用三个参数调用*M*：类名（一个字符串）、基类元组*t*和字典（或其他由__prepare__生成的映射）*d*，其中类体刚刚执行完毕。^([17](ch04.xhtml#ch01fn68))
    这个调用返回类对象*C*，Python随后将其绑定到类名上，完成**class**语句的执行。注意，这实际上是类型*M*的实例化，因此对*M*的调用执行*M.*__init__(*C*,
    *namestring*, *t*, *d*)，其中*C*是*M.*__new__(*M, namestring, t, d*)的返回值，就像在任何其他实例化中一样。
- en: After Python creates the class object *C*, the relationship between class *C*
    and its type (type(*C*), normally *M*) is the same as that between any object
    and its type. For example, when you call the class object *C* (to create an instance
    of *C*), *M.*__call__ executes, with class object *C* as the first argument.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: Python创建类对象*C*之后，类*C*与其类型（通常为*M*的类型）之间的关系与任何对象与其类型之间的关系相同。例如，当你调用类对象*C*（创建*C*的实例）时，*M.*__call__执行，类对象*C*作为第一个参数。
- en: 'Note the benefit, in this context, of the approach described in [“Per Instance
    Methods”](#per_instance_methods), whereby special methods are looked up only on
    the class, not on the instance. Calling *C* to instantiate it must execute the
    metaclass’s *M.*__call__, whether or not *C* has a per instance attribute (method)
    __call__ (i.e., independently of whether *instances* of *C* are or aren’t callable).
    This way, the Python object model avoids having to make the relationship between
    a class and its metaclass an ad hoc special case. Avoiding ad hoc special cases
    is a key to Python’s power: Python has few, simple, general rules, and applies
    them consistently.'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，描述的方法（[“按实例方法”](#per_instance_methods)）的方法，仅在类上查找特殊方法，而不是在实例上。调用*C*实例化它必须执行元类的*M.*__call__，无论*C*是否具有每实例属性（方法）__call__（即，独立于*C*的实例是否可调用）。这种方式，Python对象模型避免了必须将类及其元类的关系作为专门情况的问题。避免专门情况是Python强大的关键：Python有少量、简单、通用的规则，并且一贯地应用这些规则。
- en: Defining and using your own metaclasses
  id: totrans-540
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义元类的定义和使用
- en: 'It’s easy to define custom metaclasses: inherit from type and override some
    of its methods. You can also perform most of the tasks for which you might consider
    creating a metaclass with __new__, __init__, __getattribute__, and so on, without
    involving metaclasses. However, a custom metaclass can be faster, since special
    processing is done only at class creation time, which is a rare operation. A custom
    metaclass lets you define a whole category of classes in a framework that magically
    acquire whatever interesting behavior you’ve coded, quite independently of what
    special methods the classes themselves may choose to define.'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 定义自定义元类很容易：继承自type并重写其部分方法。你还可以使用__new__、__init__、__getattribute__等方法执行大多数你可能考虑创建元类的任务，而不涉及元类。然而，自定义元类可能会更快，因为特殊处理仅在类创建时执行，这是一种罕见的操作。自定义元类允许你在框架中定义一整类具有你编码的任何有趣行为的类，这与类本身可能选择定义的特殊方法完全独立。
- en: To alter a specific class in an explicit way, a good alternative is often to
    use a class decorator, as mentioned in [“Decorators”](#decorators). However, decorators
    are not inherited, so the decorator must be explicitly applied to each class of
    interest.^([18](ch04.xhtml#ch01fn69)) Metaclasses, on the other hand, *are* inherited;
    in fact, when you define a custom metaclass *M*, it’s usual to also define an
    otherwise empty class *C* with metaclass *M*, so that other classes requiring
    *M* can just inherit from *C*.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 要以明确的方式修改特定的类，一个很好的替代方法通常是使用类装饰器，如 [“装饰器”](#decorators) 中所述。然而，装饰器不会被继承，因此必须显式地将装饰器应用于每个感兴趣的类。^([18](ch04.xhtml#ch01fn69))
    另一方面，元类是可以继承的；事实上，当你定义一个自定义元类 *M* 时，通常也会定义一个否则为空的类 *C*，其元类为 *M*，这样需要 *M* 的其他类可以直接继承自
    *C*。
- en: 'Some behavior of class objects can be customized only in metaclasses. The following
    example shows how to use a metaclass to change the string format of class objects:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 类对象的某些行为只能在元类中定制。下面的示例展示了如何使用元类来更改类对象的字符串格式：
- en: '[PRE68]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: A substantial custom metaclass example
  id: totrans-545
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个实质性的自定义元类示例
- en: 'Suppose that, programming in Python, we miss C’s struct type: an object that
    is just a bunch of data attributes, in order, with fixed names (data classes,
    covered in the following section, fully address this requirement, which makes
    this example a purely illustrative one). Python lets us easily define a generic
    Bunch class that is similar, apart from the fixed order and names:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在 Python 编程中，我们想念 C 语言的结构体类型：一个按顺序排列、具有固定名称的数据属性对象（数据类，在下一节中详细讨论，完全满足此需求，这使得此示例纯粹是说明性的）。Python
    允许我们轻松定义一个通用的 Bunch 类，它与固定顺序和名称除外是类似的：
- en: '[PRE69]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'A custom metaclass can exploit the fact that attribute names are fixed at class
    creation time. The code shown in [Example 4-1](#example_four_onedot_the_metabunch_metac)
    defines a metaclass, MetaBunch, and a class, Bunch, to let us write code like:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义元类可以利用属性名称在类创建时固定的事实。在 [示例 4-1](#example_four_onedot_the_metabunch_metac)
    中显示的代码定义了一个元类 MetaBunch 和一个类 Bunch，使我们能够编写如下代码：
- en: '[PRE70]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In this code, the print calls emit readable string representations of our Point
    instances. Point instances are quite memory lean, and their performance is basically
    the same as for instances of the simple class Bunch in the previous example (there
    is no extra overhead due to implicit calls to special methods). [Example 4-1](#example_four_onedot_the_metabunch_metac)
    is quite substantial, and following all its details requires a grasp of aspects
    of Python discussed later in this book, such as strings (covered in [Chapter 9](ch09.xhtml#strings_and_things))
    and module warnings (covered in [“The warnings Module”](ch17.xhtml#the_warnings_module)).
    The identifier mcl used in [Example 4-1](#example_four_onedot_the_metabunch_metac)
    stands for “metaclass,” clearer in this special advanced case than the habitual
    case of cls standing for “class.”
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，print 调用会生成我们的 Point 实例的可读字符串表示。Point 实例非常节省内存，并且它们的性能基本上与前面示例中简单类 Bunch
    的实例相同（由于对特殊方法的隐式调用没有额外开销）。[示例 4-1](#example_four_onedot_the_metabunch_metac) 非常实质性，要理解其所有细节需要掌握本书后面讨论的
    Python 方面，比如字符串（在 [第 9 章](ch09.xhtml#strings_and_things) 中讨论）和模块警告（在 [“warnings
    模块”](ch17.xhtml#the_warnings_module) 中讨论）。在 [示例 4-1](#example_four_onedot_the_metabunch_metac)
    中使用的标识符 mcl 表示“元类”，在这种特殊的高级情况下比 cls 表示“类”更清晰。
- en: Example 4-1\. The MetaBunch metaclass
  id: totrans-551
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-1\. MetaBunch 元类
- en: '[PRE71]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Data Classes
  id: totrans-553
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类
- en: As the previous Bunch class exemplified, a class whose instances are just a
    bunch of named data items is a great convenience. Python’s standard library covers
    that with the dataclasses module.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的 Bunch 类所示，一个其实例仅仅是一组命名数据项的类是非常方便的。Python 的标准库通过 dataclasses 模块涵盖了这一点。
- en: 'The main feature of the dataclasses module you’ll be using is the dataclass
    function: a decorator you apply to any class whose instances you want to be just
    such a bunch of named data items. As a typical example, consider the following
    code:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 dataclass 函数，它是 dataclasses 模块的主要特性：一种装饰器，你可以将其应用于希望成为一组命名数据项的任何类的实例。作为一个典型的例子，考虑以下代码：
- en: '[PRE72]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now you can call, say, pt = Point(0.5, 0.5) and get a variable with attributes
    pt.x and pt.y, each equal to 0.5. By default, the dataclass decorator has imbued
    the class Point with an __init__ method accepting initial floating-point values
    for attributes x and y, and a __repr__ method ready to appropriately display any
    instance of the class:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以调用例如 pt = Point(0.5, 0.5)，并获得一个具有 pt.x 和 pt.y 属性的变量，每个属性都等于 0.5。默认情况下，dataclass
    装饰器已经为 Point 类赋予了一个接受属性 x 和 y 的初始浮点值的 __init__ 方法，并准备好适当显示类的任何实例的 __repr__ 方法：
- en: '[PRE73]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The dataclass function takes many optional named parameters to let you tweak
    details of the class it decorates. The parameters you may be explicitly using
    most often are listed in [Table 4-8](#commonly_used_parameters_of_the_datacla).
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: dataclass 函数接受许多可选的命名参数，以便调整装饰的类的详细信息。您可能经常明确使用的参数列在 [Table 4-8](#commonly_used_parameters_of_the_datacla)
    中。
- en: Table 4-8\. Commonly used dataclass function parameters
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: Table 4-8\. dataclass 函数常用参数
- en: '| Parameter name | Default value and resulting behavior |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '| Parameter name | Default value and resulting behavior |'
- en: '| --- | --- |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| eq | **True** When **True**, generates an __eq__ method (unless the class
    defines one) |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '| eq | **True** 当为 **True** 时，生成一个 __eq__ 方法（除非类已定义了一个） |'
- en: '| frozen | **False** When **True**, makes each instance of the class read-only
    (not allowing rebinding or deletion of attributes) |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '| frozen | **False** 当为 **True** 时，使得类的每个实例为只读（不允许重新绑定或删除属性） |'
- en: '| init | **True** When **True**, generates an __init__ method (unless the class
    defines one) |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
  zh: '| init | **True** 当为 **True** 时，生成一个 __init__ 方法（除非类已定义了一个） |'
- en: '| kw_only | **False** 3.10+ When **True**, forces arguments to __init__ to
    be named, not positional |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
  zh: '| kw_only | **False** 3.10+ 当为 **True** 时，强制要求将参数传递给 __init__ 方法时使用命名方式，而非位置方式
    |'
- en: '| order | **False** When **True**, generates order-comparison special methods
    (__le__, __lt__, and so on) unless the class defines them |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '| order | **False** 当为 **True** 时，生成顺序比较的特殊方法（如 __le__、__lt__ 等），除非类已定义这些方法
    |'
- en: '| repr | **True** When **True**, generates a __repr__ method (unless the class
    defines one) |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
  zh: '| repr | **True** 当为 **True** 时，生成一个 __repr__ 方法（除非类已定义了一个） |'
- en: '| slots | **False** 3.10+ When **True**, adds the appropriate __slots__ attribute
    to the class (saving some amount of memory for each instance, but disallowing
    the addition of other, arbitrary attributes to class instances) |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
  zh: '| slots | **False** 3.10+ 当为 **True** 时，向类添加适当的 __slots__ 属性（为每个实例节省一些内存，但不允许向类实例添加其他任意属性）
    |'
- en: The decorator also adds to the class a __hash__ method (allowing instances to
    be keys in a dictionary and members of a set) when that is safe (typically, when
    you set frozen to **True**). You may force the addition of __hash__ even when
    that’s not necessarily safe, but we earnestly recommend that you don’t; if you
    insist, check the [online docs](https://oreil.ly/rOJTW) for details on how to
    do so.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置 frozen 为 **True** 时，装饰器还会为类添加一个 __hash__ 方法（允许实例作为字典的键和集合的成员），当这是安全的时候（通常是这样的情况）。即使在不安全的情况下，您也可以强制添加
    __hash__ 方法，但我们强烈建议您不要这样做；如果您坚持要这样做，请查阅 [online docs](https://oreil.ly/rOJTW)
    了解详细信息。
- en: If you need to tweak each instance of a dataclass after the automatically generated
    __init__ method has done the core work of assigning each instance attribute, define
    a method called __post_init__, and the decorator will ensure it is called right
    after __init__ is done.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在自动生成的 __init__ 方法完成为每个实例属性分配核心工作后调整数据类的每个实例，请定义一个名为 __post_init__ 的方法，装饰器将确保在
    __init__ 完成后立即调用它。
- en: 'Say you wish to add an attribute to Point to capture the time when the point
    was created. This could be added as an attribute assigned in __post_init__. Add
    the attribute create_time to the members defined for Point, as type float with
    a default value of 0, and then add an implementation for __post_init__:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您希望向 Point 添加一个属性，以捕获创建点的时间。可以将其添加为在 __post_init__ 中分配的属性，为 Point 的定义成员添加名为
    create_time 的属性，类型为 float，默认值为 0，并添加一个 __post_init__ 的实现：
- en: '[PRE75]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now if you create the variable pt = Point(0.5, 0.5), printing it out will display
    the creation timestamp, similar to the following:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您创建变量 pt = Point(0.5, 0.5)，打印它将显示创建时间戳，类似于以下内容：
- en: '[PRE76]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Like regular classes, dataclasses can also support additional methods and properties,
    such as this method that computes the distance between two Points and this property
    that returns the distance from a Point at the origin:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规类似，dataclass 还支持额外的方法和属性，例如计算两个点之间距离的方法以及返回到原点的点的距离的属性：
- en: '[PRE78]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'For example:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE79]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The dataclasses module also supplies asdict and astuple functions, each taking
    a dataclass instance as the first argument and returning, respectively, a dict
    and a tuple with the class’s fields. Furthermore, the module supplies a field
    function that you may use to customize the treatment of some of a dataclass’s
    fields (i.e., instance attributes), and several other specialized functions and
    classes needed only for very advanced, esoteric purposes; to learn all about them,
    check out the [online docs](https://oreil.ly/rOJTW).
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: dataclasses 模块还提供了 asdict 和 astuple 函数，每个函数的第一个参数都是 dataclass 实例，分别返回一个字典和一个元组，这些字典和元组包含类的字段。此外，该模块还提供了一个
    field 函数，用于自定义数据类字段（即实例属性）的处理方式，以及几个其他专门用于非常高级、神秘目的的函数和类；要了解有关它们的全部信息，请查阅[在线文档](https://oreil.ly/rOJTW)。
- en: Enumerated Types (Enums)
  id: totrans-586
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举类型（Enums）
- en: 'When programming, you’ll often want to create a set of related values that
    catalog or *enumerate* the possible values for a particular property or program
    setting,^([19](ch04.xhtml#ch01fn70)) whatever they might be: terminal colors,
    logging levels, process states, playing card suits, clothing sizes, or just about
    anything else you can think of. An *enumerated type* (*enum*) is a type that defines
    a group of such values, with symbolic names that you can use as typed global constants.
    Python provides the Enum class and related subclasses in the enum module for defining
    enums.'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程时，通常希望创建一组相关的值，用于列举特定属性或程序设置的可能值，^([19](ch04.xhtml#ch01fn70)) 无论它们是什么：终端颜色、日志级别、进程状态、扑克牌花色、服装尺寸，或者你能想到的任何其他东西。*枚举类型*（enum）是定义这种值组的一种类型，具有可作为类型化全局常量使用的符号名称。Python
    提供了 enum 模块中的 Enum 类及其相关子类用于定义枚举。
- en: 'Defining an enum gives your code a set of symbolic constants that represent
    the values in the enumeration. In the absence of enums, constants might be defined
    as ints, as in this code:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个枚举为你的代码提供了一组代表枚举中的值的符号常量。在没有枚举的情况下，常量可能会被定义为整数，如下所示：
- en: '[PRE83]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: However, in this design, there is no mechanism to warn against nonsense expressions
    like RED > XL or L * BLUE, since they are all just ints. There is also no logical
    grouping of the colors or sizes.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种设计中，没有机制可以警告类似 RED > XL 或 L * BLUE 这样的无意义表达式，因为它们都只是整数。也没有颜色或尺码的逻辑分组。
- en: 'Instead, you can use an Enum subclass to define these values:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可以使用 Enum 子类来定义这些值：
- en: '[PRE84]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Now, code like Color.RED > Size.S stands out visually as incorrect, and at runtime
    raises a Python TypeError. Using auto() automatically assigns incrementing int
    values beginning with 1 (in most cases, the actual values assigned to enum members
    are not meaningful).
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，像 Color.RED > Size.S 这样的代码在视觉上显得不正确，并且在运行时会引发 Python TypeError。使用 auto()
    自动分配从 1 开始递增的整数值（在大多数情况下，分配给枚举成员的实际值是无意义的）。
- en: Calling Enum Creates a Class, Not an Instance
  id: totrans-594
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用 Enum 创建一个类，而不是一个实例
- en: 'Surprisingly, when you call enum.Enum(), it doesn’t return a newly built *instance*,
    but rather a newly built *subclass*. So, the preceding snippet is equivalent to:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，当你调用 enum.Enum() 时，它不会返回一个新建的*实例*，而是一个新建的*子类*。因此，前面的片段等效于：
- en: '[PRE85]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: When you *call* Enum (rather than explicitly subclassing it in a class statement),
    the first argument is the name of the subclass you’re building; the second argument
    gives all the names of that subclass’s members, either as a sequence of strings
    or as a single whitespace-separated (or comma-separated) string.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 当你*调用* Enum（而不是在类语句中显式地对其进行子类化）时，第一个参数是你正在构建的子类的名称；第二个参数给出了该子类成员的所有名称，可以是字符串序列或单个以空格分隔（或逗号分隔）的字符串。
- en: We recommend that you define Enum subclasses using class inheritance syntax,
    instead of this abbreviated form. The **class** form is more visually explicit,
    so it is easier to see if a member is missing, misspelled, or added later.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您使用类继承语法定义 Enum 子类，而不是这种简写形式。**类**形式更加视觉明确，因此更容易看出是否缺少、拼写错误或以后添加的成员。
- en: 'The values within an enum are called its *members*. It is conventional to use
    all uppercase characters to name enum members, treating them much as though they
    were manifest constants. Typical uses of the members of an enum are assignment
    and identity checking:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举内部的值称为其*成员*。习惯上，使用全大写字符来命名枚举成员，将它们视为显式常量。枚举成员的典型用法包括赋值和身份检查：
- en: '[PRE86]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: You can obtain all members of an Enum by iterating over the Enum class itself,
    or from the class’s __members__ attribute. Enum members are all global singletons,
    so comparison with **is** and **is not** is preferred over == or !=.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 通过迭代枚举类本身或从类的 __members__ 属性获取，你可以获得枚举的所有成员。枚举成员都是全局单例，因此推荐使用 **is** 和 **is
    not** 进行比较，而不是 == 或 !=。
- en: The enum module contains several classes^([20](ch04.xhtml#ch01fn71)) to support
    different forms of enums, listed in [Table 4-9](#enum_classes).
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举模块包含几个类^([20](ch04.xhtml#ch01fn71))，支持不同形式的枚举，列在 [表 4-9](#enum_classes) 中。
- en: Table 4-9\. enum classes
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-9\. 枚举类
- en: '| Class | Description |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 描述 |'
- en: '| --- | --- |'
  id: totrans-605
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Enum | Basic enumeration class; member values can be any Python object, typically
    ints or strs, but do not support int or str methods. Useful for defining enumerated
    types whose members are an unordered group. |'
  id: totrans-606
  prefs: []
  type: TYPE_TB
  zh: '| 枚举 | 基本枚举类；成员值可以是任何Python对象，通常是整数或字符串，但不支持整数或字符串方法。适用于定义成员为无序组的枚举类型。 |'
- en: '| Flag | Used to define enums that you can combine with operators &#124;, &,
    ^, and ~; member values must be defined as ints to support these bitwise operations
    (Python, however, assumes no ordering among them). Flag members with a 0 value
    are falsy; other members are truthy. Useful when you create or check values with
    bitwise operations (e.g., file permissions). To support bitwise operations, you
    generally use powers of 2 (1, 2, 4, 8, etc.) as member values. |'
  id: totrans-607
  prefs: []
  type: TYPE_TB
  zh: '| Flag | 用于定义可以使用操作符 &#124;, &, ^ 和 ~ 进行组合的枚举；成员值必须定义为整数以支持这些位操作（Python 但是不假定它们之间的顺序）。值为
    0 的 Flag 成员为假；其他成员为真。在创建或检查使用位操作的值时非常有用（例如文件权限）。为了支持位操作，通常使用 2 的幂次方（1、2、4、8 等）作为成员值。'
- en: '| IntEnum | Equivalent to **class** IntEnum(*int*, *Enum*); member values are
    ints and support all int operations, including ordering. Useful when order among
    values is significant, such as when defining logging levels. |'
  id: totrans-608
  prefs: []
  type: TYPE_TB
  zh: '| IntEnum | 相当于 **class** IntEnum(*int*, *Enum*)；成员值为整数并支持所有整数操作，包括排序。在需要对值进行排序时非常有用，比如定义日志级别。
    |'
- en: '| IntFlag | Equivalent to **class** IntFlag(*int*, *Flag*); member values are
    ints (usually, powers of 2) supporting all int operations, including comparisons.
    |'
  id: totrans-609
  prefs: []
  type: TYPE_TB
  zh: '| IntFlag | 相当于 **class** IntFlag(*int*, *Flag*)；成员值为整数（通常是 2 的幂次方），支持所有整数操作，包括比较。
    |'
- en: '| StrEnum | 3.11+ Equivalent to **class** StrEnum(*str*, *Enum*); member values
    are strs and support all str operations. |'
  id: totrans-610
  prefs: []
  type: TYPE_TB
  zh: '| StrEnum | 3.11+ 相当于 **class** StrEnum(*str*, *Enum*)；成员值为字符串并支持所有字符串操作。 |'
- en: The enum module also defines some support functions, listed in [Table 4-10](#enum_support_functions).
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举模块还定义了一些支持函数，列在 [表 4-10](#enum_support_functions) 中。
- en: Table 4-10\. enum support functions
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-10\. 枚举支持函数
- en: '| Support function | Description |'
  id: totrans-613
  prefs: []
  type: TYPE_TB
  zh: '| 支持函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| auto | Autoincrements member values as you define them. Values typically
    start at 1 and increment by 1; for Flag, increments are in powers of 2. |'
  id: totrans-615
  prefs: []
  type: TYPE_TB
  zh: '| 自动 | 在定义成员时自动递增成员值。通常值从 1 开始，每次增加 1；对于 Flag，增量为 2 的幂次方。 |'
- en: '| unique | Class decorator to ensure that members’ values differ from each
    other. |'
  id: totrans-616
  prefs: []
  type: TYPE_TB
  zh: '| 唯一 | 类装饰器，确保成员值彼此不同。 |'
- en: 'The following example shows how to define a Flag subclass to work with the
    file permissions in the st_mode attribute returned from calling os.stat or Path.stat
    (for a description of the stat functions, see [Chapter 11](ch11.xhtml#file_and_text_operations)):'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例展示了如何定义一个 Flag 子类，以处理从调用 os.stat 或 Path.stat 返回的 st_mode 属性中的文件权限（有关 stat
    函数的描述，请参见 [第 11 章](ch11.xhtml#file_and_text_operations)）：
- en: '[PRE87]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Using enums in place of arbitrary ints or strs can add readability and type
    integrity to your code. You can find more details on the classes and methods of
    the enum module in the Python [docs](https://oreil.ly/d57vE).
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中使用枚举替代任意的整数或字符串可以提升可读性和类型完整性。你可以在 Python [文档](https://oreil.ly/d57vE) 中找到枚举模块的更多类和方法的详细信息。
- en: ^([1](ch04.xhtml#ch01fn48-marker)) Or “drawbacks,” according to one reviewer.
    One developer’s meat is another developer’s poison.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch04.xhtml#ch01fn48-marker)) 或者，根据一位评论者的观点，也可以说是“缺点”。有人的福祸相依。
- en: ^([2](ch04.xhtml#ch01fn49-marker)) When that’s the case, it’s also OK to have
    other named arguments after metaclass=. Such arguments, if any, are passed on
    to the metaclass.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch04.xhtml#ch01fn49-marker)) 当情况如此时，在 metaclass= 后也可以有其他命名参数。这些参数（如果有）将传递给元类。
- en: ^([3](ch04.xhtml#ch01fn50-marker)) That need arises because __init__, on any
    subclass of Singleton that defines this special method, repeatedly executes, each
    time you instantiate the subclass, on the only instance that exists for each subclass
    of Singleton.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch04.xhtml#ch01fn50-marker)) 这种需求是因为在 Singleton 的任何子类上定义了这个特殊方法的情况下，__init__
    会在每次你实例化子类时重复执行，在每个 Singleton 子类的唯一实例上执行。
- en: ^([4](ch04.xhtml#ch01fn51-marker)) Except for instances of a class defining
    __slots__, covered in [“__slots__”](#slots_).
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch04.xhtml#ch01fn51-marker)) 除了定义了 __slots__ 的类的实例外，涵盖在 [“__slots__”](#slots_)
    中。
- en: ^([5](ch04.xhtml#ch01fn52-marker)) Some other OO languages, like [Modula-3](https://en.wikipedia.org/wiki/Modula-3),
    similarly require explicit use of self.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch04.xhtml#ch01fn52-marker)) 其他一些面向对象语言，如[Modula-3](https://en.wikipedia.org/wiki/Modula-3)，同样需要显式地使用
    self。
- en: ^([6](ch04.xhtml#ch01fn53-marker)) Many Python releases later, Michele’s essay
    still applies!
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch04.xhtml#ch01fn53-marker)) 多个 Python 版本之后，Michele 的论文仍然适用！
- en: ^([7](ch04.xhtml#ch01fn54-marker)) One of the authors has used this technique
    to dynamically combine small mixin test classes to create complex test case classes
    to test multiple independent product features.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch04.xhtml#ch01fn54-marker)) 其中一位作者使用这种技术动态组合小的混合测试类，创建复杂的测试用例类来测试多个独立的产品特性。
- en: '^([8](ch04.xhtml#ch01fn55-marker)) To complete the usually truncated famous
    quote: “except of course for the problem of too many indirections.”'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch04.xhtml#ch01fn55-marker)) 为了完整引用常被截断的名言：“当然除了太多的间接问题。”
- en: ^([9](ch04.xhtml#ch01fn56-marker)) Third-party extensions can also define types
    of containers that are not sequences, not mappings, and not sets.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch04.xhtml#ch01fn56-marker)) 第三方扩展还可以定义不是序列、映射或集合的容器类型。
- en: ^([10](ch04.xhtml#ch01fn57-marker)) Lower bound included, upper bound excluded—as
    always, the norm for Python.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch04.xhtml#ch01fn57-marker)) 包含下限，排除上限——这一点对于 Python 来说一直是规范。
- en: ^([11](ch04.xhtml#ch01fn58-marker)) See, for example, [“Avoid Extending Classes”](https://oreil.ly/5B4nm)
    by Bill Harlan.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch04.xhtml#ch01fn58-marker)) 参见例如 [“避免扩展类”](https://oreil.ly/5B4nm)，作者是
    Bill Harlan。
- en: ^([12](ch04.xhtml#ch01fn59-marker)) For a related concept focused on type checking,
    see typing.Protocols, covered in [“Protocols”](ch05.xhtml#protocols).
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: ^([12](ch04.xhtml#ch01fn59-marker)) 关于类型检查的相关概念，请参阅 typing.Protocols，涵盖在 [“协议”](ch05.xhtml#protocols)
    中。
- en: ^([13](ch04.xhtml#ch01fn60-marker)) The abc module does include the abstractproperty
    decorator, which combines these two, but abstractproperty is deprecated, and new
    code should use the two decorators as described.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: ^([13](ch04.xhtml#ch01fn60-marker)) abc 模块确实包含 abstractproperty 装饰器，它结合了这两者，但
    abstractproperty 已经弃用，新代码应该按描述使用这两个装饰器。
- en: ^([14](ch04.xhtml#ch01fn61-marker)) For backward compatibility these ABCs were
    also accessible in the collections module until Python 3.9, but the compatibility
    imports were removed in Python 3.10\. New code should import these ABCs from collections.abc.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: ^([14](ch04.xhtml#ch01fn61-marker)) 为了向后兼容性，这些 ABCs 在 Python 3.9 之前也可以在 collections
    模块中访问，但在 Python 3.10 中移除了兼容性导入。新代码应该从 collections.abc 导入这些 ABCs。
- en: ^([15](ch04.xhtml#ch01fn66-marker)) Strictly speaking, the type of a class *C*
    could be said to be the metaclass only of *instances* of *C* rather than of *C*
    itself, but this subtle semantic distinction is rarely, if ever, observed in practice.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: ^([15](ch04.xhtml#ch01fn66-marker)) 严格来说，类 *C* 的类型可以说是 *C* 的实例的元类，而不是 *C* 本身，但这种微妙的语义区别在实践中很少被注意到。
- en: ^([16](ch04.xhtml#ch01fn67-marker)) Or when a base class has __init_subclass__,
    in which case the named arguments are passed to that method, as covered in [“Alternatives
    to Custom Metaclasses for Simple Class Customization”](#alternatives_to_custom_metaclasses_for).
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: ^([16](ch04.xhtml#ch01fn67-marker)) 或者当基类有 __init_subclass__ 的情况下，命名参数将传递给该方法，如
    [“简单类定制的替代方案”](#alternatives_to_custom_metaclasses_for) 中描述的那样。
- en: ^([17](ch04.xhtml#ch01fn68-marker)) This is similar to calling type with three
    arguments, as described in [“Dynamic class definition using the type built-in
    function”](#dynamic_class_definition_using_the_type).
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: ^([17](ch04.xhtml#ch01fn68-marker)) 这类似于调用 type 函数的三个参数版本，如 [“使用 type 内置函数动态定义类”](#dynamic_class_definition_using_the_type)
    中描述的那样。
- en: ^([18](ch04.xhtml#ch01fn69-marker)) __init_subclass__, covered in [“Alternatives
    to Custom Metaclasses for Simple Class Customization”](#alternatives_to_custom_metaclasses_for),
    works much like an “inherited decorator,” so it’s often an alternative to a custom
    metaclass.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: ^([18](ch04.xhtml#ch01fn69-marker)) __init_subclass__，在 [“简单类定制的替代方案”](#alternatives_to_custom_metaclasses_for)
    中讨论过，工作方式类似于“继承装饰器”，因此通常是自定义元类的替代选择。
- en: ^([19](ch04.xhtml#ch01fn70-marker)) Don’t confuse this concept with the unrelated
    enumerate built-in function, covered in [Chapter 8](ch08.xhtml#core_built_ins_and_standard_library_mod),
    which generates (*number*, *item*) pairs from an iterable.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: ^([19](ch04.xhtml#ch01fn70-marker)) 不要将这个概念与无关的内置函数 `enumerate` 混淆，该函数在 [第 8
    章](ch08.xhtml#core_built_ins_and_standard_library_mod) 中介绍，它从可迭代对象生成 (*序号*, *项*)
    对。
- en: ^([20](ch04.xhtml#ch01fn71-marker)) enum’s specialized metaclass behaves so
    differently from the usual type metaclass that it’s worth pointing out all the
    differences between enum.Enum and ordinary classes. You can read about this in
    the [“How are Enums different?” section](https://oreil.ly/xpp5N) of Python’s online
    documentation.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: ^([20](ch04.xhtml#ch01fn71-marker)) `enum` 的专用元类与通常的类型元类行为差异如此之大，以至于值得指出 `enum.Enum`
    和普通类之间的所有差异。你可以在 Python 在线文档的 [“枚举有何不同？”章节](https://oreil.ly/xpp5N) 中阅读有关内容。
