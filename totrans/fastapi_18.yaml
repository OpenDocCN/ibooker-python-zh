- en: Chapter 14\. Databases, Data Science, and a Little AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Preview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter discusses how to use FastAPI to store and retrieve data. It expands
    on the simple SQLite examples of [Chapter 10](ch10.html#ch10) with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Other open source databases (relational and not)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-level uses of SQLAlchemy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better error checking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data Storage Alternatives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The term *database* is unfortunately used to refer to three things:'
  prefs: []
  type: TYPE_NORMAL
- en: The server *type*, like PostgreSQL, SQLite, or MySQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A running instance of that *server*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *collection of tables* on that server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To avoid confusion—referring to an instance of the last bulleted item above
    as a “PostgreSQL database database database”—I’ll attach other terms to indicate
    which one I mean.
  prefs: []
  type: TYPE_NORMAL
- en: The usual backend for a website is a database. Websites and databases are like
    peanut butter and jelly, and although you could conceivably store your data in
    other ways (or pair peanut butter with pickles), for this book we’ll stick with
    databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Databases handle many problems that you would otherwise have to solve yourself
    with code, such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data consistency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The general choices for databases are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases, with the SQL query language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nonrelational databases, with various query languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational Databases and SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has a standard relational API definition called [DB-API](https://oreil.ly/StbE4),
    and it’s supported by Python driver packages for all the major databases. [Table 14-1](#table1401)
    lists some prominent relational databases and their main Python driver packages.
  prefs: []
  type: TYPE_NORMAL
- en: Table 14-1\. Relational databases and Python drivers
  prefs: []
  type: TYPE_NORMAL
- en: '| Database | Python drivers |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Open source |'
  prefs: []
  type: TYPE_TB
- en: '| [SQLite](https://www.sqlite.org) | [sqlite3](https://oreil.ly/TNNaA) |'
  prefs: []
  type: TYPE_TB
- en: '| [PostgreSQL](https://www.postgresql.org) | [psycopg2](https://oreil.ly/nLn5x)
    and [asyncpg](https://oreil.ly/90pvK) |'
  prefs: []
  type: TYPE_TB
- en: '| [MySQL](https://www.mysql.com) | [MySQLdb](https://oreil.ly/yn1fn) and [PyMySQL](https://oreil.ly/Cmup-)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Commercial |'
  prefs: []
  type: TYPE_TB
- en: '| [Oracle](https://www.oracle.com) | [python-oracledb](https://oreil.ly/gynvX)
    |'
  prefs: []
  type: TYPE_TB
- en: '| [SQL Server](https://www.microsoft.com/en-us/sql-server) | [pyodbc](https://oreil.ly/_UEYq)
    and [pymssql](https://oreil.ly/FkKUn) |'
  prefs: []
  type: TYPE_TB
- en: '| [IBM Db2](https://www.ibm.com/products/db2) | [ibm_db](https://oreil.ly/3uwpD)
    |'
  prefs: []
  type: TYPE_TB
- en: 'The main Python packages for relational databases and SQL are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[SQLAlchemy](https://www.sqlalchemy.org)'
  prefs: []
  type: TYPE_NORMAL
- en: A full-featured library that can be used at many levels
  prefs: []
  type: TYPE_NORMAL
- en: '[SQLModel](https://sqlmodel.tiangolo.com)'
  prefs: []
  type: TYPE_NORMAL
- en: A combination of SQLAlchemy and Pydantic, by the author of FastAPI
  prefs: []
  type: TYPE_NORMAL
- en: '[Records](https://github.com/kennethreitz/records)'
  prefs: []
  type: TYPE_NORMAL
- en: From the author of the Requests package, a simple query API
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most popular Python SQL package is SQLAlchemy. Although many explanations
    of SQLAlchemy discuss only its ORM, it has multiple layers, and I’ll discuss these
    bottom-up.
  prefs: []
  type: TYPE_NORMAL
- en: Core
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The base of SQLAlchemy, called *Core*, comprises the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An `Engine` object that implements the DB-API standard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URLs that express the SQL server type and driver, and the specific database
    collection on that server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client-server connection pools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transactions (`COMMIT` and `ROLLBACK`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL *dialect* differences among various database types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Direct SQL (text string) queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queries in the SQLAlchemy Expression Language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of these features, like the dialect handling, make SQLAlchemy the package
    of choice for working with various server types. You can use it to execute plain
    DB-API SQL statements or use the SQLAlchemy Expression Language.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve been using the raw DB-API SQLite driver so far and will continue. But for
    larger sites or those that might need to take advantage of a special server feature,
    SQLAlchemy (using basic DB-API, SQLAlchemy Expression Language, or the full ORM)
    is well worth using.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy Expression Language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SQLAlchemy Expression Language is *not* the ORM, but another way of expressing
    queries against relational tables. It maps the underlying storage structures to
    Python classes like `Table` and `Column`, and operations to Python methods like
    `select()` and `insert()`. These functions translate to plain SQL strings, and
    you can access them to see what happened. The language is independent of SQL server
    types. If you find SQL difficult, this may be worth trying.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s compare a few examples. [Example 14-1](#ex-14-1) shows the plain SQL version.
  prefs: []
  type: TYPE_NORMAL
- en: Example 14-1\. Straight SQL code for `get_one()` in data/explorer.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 14-2](#ex-14-2) shows a partial SQLAlchemy Expression Language equivalent
    to set up the database, build the table, and perform the insertion.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 14-2\. SQLAlchemy Expression Language for `get_one()`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For more examples, some alternative [documentation](https://oreil.ly/ZGCHv)
    is a bit more readable than the official pages.
  prefs: []
  type: TYPE_NORMAL
- en: ORM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An ORM expresses queries in terms of domain data models, not the relational
    tables and SQL logic at the base of the database machinery. The official [documentation](https://oreil.ly/x4DCi)
    goes into all the details. The ORM is much more complex than the SQL expression
    language. Developers who prefer fully *object-oriented* patterns usually prefer
    ORMs.
  prefs: []
  type: TYPE_NORMAL
- en: Many books and articles on FastAPI jump right into SQLAlchemy’s ORM when they
    come to the database section. I understand the appeal but also know that it requires
    you to learn another abstraction. SQLAlchemy is an excellent package, but if its
    abstractions don’t always hold, then you have two problems. The simplest solution
    may be to just use SQL, and move to the Expression Language or ORM if the SQL
    gets too hairy.
  prefs: []
  type: TYPE_NORMAL
- en: SQLModel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The author of FastAPI combined aspects of FastAPI, Pydantic, and SQLAlchemy
    to make [SQLModel](https://sqlmodel.tiangolo.com). It repurposes some development
    techniques from the web world to relational databases. SQLModel matches SQLAlchemy’s
    ORM with Pydantic’s data definition and validation.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I introduced SQLite in [Chapter 10](ch10.html#ch10), using it for the Data layer
    examples. It’s public domain—you can’t get more open sourcey than that. SQLite
    is used in every browser and every smartphone, making it one of the most widely
    deployed software packages in the world. It’s often overlooked when choosing a
    relational database, but it’s possible that multiple SQLite “servers” could support
    some large services as well as a beefy server like PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the early days of relational databases, IBM’s System R was the pioneer, and
    offshoots battled for the new market—mainly open source Ingres versus commercial
    Oracle. Ingres featured a query language named QUEL, and System R had SQL. Although
    QUEL was considered better than SQL by some, Oracle’s adoption of SQL as a standard,
    plus IBM’s influence, helped push Oracle and SQL to success.
  prefs: []
  type: TYPE_NORMAL
- en: Years later, Michael Stonebraker returned to migrate Ingres to [PostgreSQL](https://www.postgresql.org).
    Nowadays, open source developers tend to choose PostgreSQL, although MySQL was
    popular a few years ago and is still around.
  prefs: []
  type: TYPE_NORMAL
- en: EdgeDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Despite the success of SQL over the years, it does have some design flaws that
    make queries awkward. Unlike the mathematical theory that SQL is based on (*relational
    calculus* by E. F. Codd), the SQL language design itself is not *composable*.
    Mainly, this means that it’s hard to nest queries within larger ones, leading
    to more complex and verbose code.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, just for fun, I’m throwing in a new relational database here. [EdgeDB](https://www.edgedb.com)
    was written (in Python!) by the author of Python’s asyncio. It’s described as
    *Post-SQL* or *graph-relational*. Under the hood, it uses PostgreSQL to handle
    the tough system stuff. Edge’s contribution is [EdgeQL](https://oreil.ly/sdK4J):
    a new query language that aims to avoid those sharp SQL edges; it’s actually translated
    to SQL for PostgreSQL to execute. [“My Experience with EdgeDB” by Ivan Daniluk](https://oreil.ly/ciNfg)
    handily compares EdgeQL and SQL. The readable illustrated [official documentation](https://oreil.ly/ce6y3)
    parallels the book *Dracula*.'
  prefs: []
  type: TYPE_NORMAL
- en: Could EdgeQL spread beyond EdgeDB and become an alternative to SQL? Time will
    tell.
  prefs: []
  type: TYPE_NORMAL
- en: Nonrelational (NoSQL) Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Biggies in the open source NoSQL or NewSQL world are listed in [Table 14-2](#table1402).
  prefs: []
  type: TYPE_NORMAL
- en: Table 14-2\. NoSQL databases and Python drivers
  prefs: []
  type: TYPE_NORMAL
- en: '| Database | Python drivers |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [Redis](https://redis.io) | [redis-py](https://github.com/redis/redis-py)
    |'
  prefs: []
  type: TYPE_TB
- en: '| [MongoDB](https://www.mongodb.com) | [PyMongo](https://pymongo.readthedocs.io),
    [Motor](https://oreil.ly/Cmgtl) |'
  prefs: []
  type: TYPE_TB
- en: '| [Apache Cassandra](https://cassandra.apache.org) | [DataStax Driver for Apache
    Cassandra](https://github.com/datastax/python-driver) |'
  prefs: []
  type: TYPE_TB
- en: '| [Elasticsearch](https://www.elastic.co/elasticsearch) | [Python Elasticsearch
    Client](https://oreil.ly/e_bDI) |'
  prefs: []
  type: TYPE_TB
- en: Sometimes *NoSQL* means literally *no SQL*, but sometimes *not only SQL*. Relational
    databases enforce structures on data, often visualized as rectangular tables with
    column fields and data rows, similar to spreadsheets. To reduce redundancy and
    improve performance, relational databases are *normalized* with *normal forms*
    (rules for data and structures), such as allowing only a single value per cell
    (row/column intersection).
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL databases relax these rules, sometimes allowing varying column/field types
    across individual data rows. Often the *schemas* (database designs) can be ragged
    structures, as you could express in JSON or Python, rather than relational boxes.
  prefs: []
  type: TYPE_NORMAL
- en: Redis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Redis* is a data structure server that runs completely in memory, although
    it can save to and restore from disk. It closely matches Python’s own data structures
    and has become extremely popular.'
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*MongoDB* is sort of the PostgreSQL of NoSQL servers. A *collection* is the
    equivalent of a SQL table, and a *document* is the equivalent of a SQL table row.
    Another difference, and the main reason for a NoSQL database in the first place,
    is that you don’t need to define what a document looks like. In other words, there’s
    no fixed *schema*. A document is like a Python dictionary, with any string as
    a key.'
  prefs: []
  type: TYPE_NORMAL
- en: Cassandra
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cassandra is a large-scale database that can be distributed across hundreds
    of nodes. It’s written in Java.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative database called [ScyllaDB](https://www.scylladb.com) is written
    in C++ and claims to be compatible with Cassandra but more performant.
  prefs: []
  type: TYPE_NORMAL
- en: Elasticsearch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Elasticsearch](https://www.elastic.co/elasticsearch) is more like a database
    index than a database itself. It’s often used for full-text search.'
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL Features in SQL Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As noted previously, relational databases were traditionally normalized—constrained
    to follow different levels of rules called *normal forms*. One basic rule was
    that the value in each cell (row-column intersection) had to be a *scalar* (no
    arrays or other structures).
  prefs: []
  type: TYPE_NORMAL
- en: 'NoSQL (or *document*) databases supported JSON directly and were usually your
    only choice if you had “uneven” or “ragged” data structures. They were often *denormalized*:
    all the data needed for a document was included with that document. In SQL, you
    often needed to *join* across tables to build a full document.'
  prefs: []
  type: TYPE_NORMAL
- en: However, recent revisions of the SQL standard have allowed JSON data to be stored
    in relational databases also. Some relational databases now let you store complex
    (nonscalar) data in table cells, and even search and index within them. JSON functions
    are supported in various ways for [SQLite](https://oreil.ly/h_FNn), [PostgreSQL](https://oreil.ly/awYrc),
    [MySQL](https://oreil.ly/OA_sT), [Oracle](https://oreil.ly/osOYk), and others.
  prefs: []
  type: TYPE_NORMAL
- en: SQL with JSON can be the best of both worlds. SQL databases have been around
    much longer and have really useful features such as foreign keys and secondary
    indexes. Also, SQL is fairly standardized up to a point, and NoSQL query languages
    are all different.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, new data design and query languages are trying to combine SQL and NoSQL
    advantages, like EdgeQL that I mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you can’t fit your data into the rectangular relational box, look at
    a NoSQL database, a relational database with JSON support, or a “Post-SQL” database.
  prefs: []
  type: TYPE_NORMAL
- en: Database Load Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book is mainly about FastAPI, but websites are so frequently tied to databases.
  prefs: []
  type: TYPE_NORMAL
- en: The data examples in this book have been tiny. To really stress-test a database,
    millions of items would be great. Rather than think of things to add, it’s easier
    use a Python package like [Faker](https://faker.readthedocs.io). Faker can generate
    many kinds of data quickly—names, places, or special types that you define.
  prefs: []
  type: TYPE_NORMAL
- en: In [Example 14-3](#ex-14-3), Faker pumps out names and countries, which are
    then loaded by `load()` into SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: Example 14-3\. Load fake explorers in test_load.py
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You’re catching the `Duplicate` exception in `load()` and ignoring it, because
    Faker generates names from a limited list and is likely to repeat one now and
    then. So the result may be less than 100,000 explorers loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you’re calling `read_db()` twice, to remove any startup time as SQLite
    does the query. Then `read_api()` timing should be fair. [Example 14-4](#ex-14-4)
    fires it up.
  prefs: []
  type: TYPE_NORMAL
- en: Example 14-4\. Test database query performance
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The API read time for all explorers was much slower than the Data layer’s read
    time. Some of this is probably overhead from FastAPI’s conversion of the response
    to JSON. Also, the initial write time to the database wasn’t very zippy. It wrote
    one explorer at a time, because the Data layer API has a single `create()` function,
    but not a `create_many()`; on the read side, the API can return one (`get_one()`)
    or all (`get_all()`). So, if you ever want to do bulk loading, it might be good
    to add a new Data load function and a new Web endpoint (with restricted authorization).
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you expect any table in your database to grow to 100,000 rows, maybe
    you shouldn’t allow random users to get all of them in one API call. Pagination
    would be useful, or a way to download a single CSV file from the table.
  prefs: []
  type: TYPE_NORMAL
- en: Data Science and AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has become the most prominent language in data science in general, and
    machine learning in particular. So much data massaging is needed, and Python is
    good at that.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes developers have used [external tools](https://oreil.ly/WFHo9) like
    pandas to do the data manipulation that’s too tricky in SQL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PyTorch](https://pytorch.org) is one of the most popular ML tools, because
    it leverages Python’s strengths in data manipulation. The underlying computations
    may be in C or C++ for speed, but Python or Go are well-suited for the “higher”
    data-integration tasks. (The [Mojo](https://www.modular.com/mojo) language, a
    superset of Python, may handle both the high and low ends if it succeeds as planned.
    Although a general-purpose language, it specifically addresses some of the current
    complexity in AI development.)'
  prefs: []
  type: TYPE_NORMAL
- en: A new Python tool called [Chroma](https://www.trychroma.com) is a database,
    similar to SQLite, but tailored to machine learning, specifically large language
    models (LLMs). Read the [Getting Started page](https://oreil.ly/W59nn) to, you
    know, get started.
  prefs: []
  type: TYPE_NORMAL
- en: Although AI development is complex and moving fast, you can try out some AI
    with Python on your own machine without spending the megabucks that were behind
    GPT-4 and ChatGPT. Let’s build a small FastAPI web interface to a small AI model.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '*Model* has different meanings in AI and Pydantic/FastAPI. In Pydantic, a model
    is a Python class that bundles related data fields. AI models cover a broad range
    of techniques for determining patterns in data.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Hugging Face](https://huggingface.co) provides free AI models, datasets, and
    Python code to use them. First, install PyTorch and Hugging Face code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 14-5](#ex-14-5) shows a FastAPI application that uses Hugging Face’s
    transformers module to access a pretrained mid-sized open source machine language
    model and try to answer your prompts. (This was adapted from a command-line example
    on the YouTube channel CodeToTheMoon.)'
  prefs: []
  type: TYPE_NORMAL
- en: Example 14-5\. Top-level LLM test (ai.py)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this with `uvicorn ai:app` (as always, first make sure you don’t have another
    web server still running on `localhost`, port `8000`). Feed the */ai* endpoint
    questions and get answers, like this (note the double `==` for an HTTPie query
    parameter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a fairly small model, and as you can see, it doesn’t answer questions
    especially well. I tried other prompts (`line` arguments) and got equally noteworthy
    answers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Q: Are cats better than dogs?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A: No'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Q: What does bigfoot eat for breakfast?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A: A squid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Q: Who comes down the chimney?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A: A squealing pig'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Q: What group was John Cleese in?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A: The Beatles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Q: What has nasty pointy teeth?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A: A teddy bear'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These questions may get different answers at different times! Once the same
    endpoint said that Bigfoot eats sand for breakfast. In AI-speak, answers like
    this are called *hallucinations*. You can get better answers by using a larger
    model, like `google/flan-75-xl`, but it will take longer to download model data
    and respond on a personal computer. And of course, models like ChatGPT were trained
    on all the data they could find (using every CPU, GPU, TPU, and any other kind
    of PU), and will give excellent answers.
  prefs: []
  type: TYPE_NORMAL
- en: Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter expanded on the use of SQLite we went over in [Chapter 10](ch10.html#ch10)
    to other SQL databases, and even NoSQL ones. It also showed how some SQL databases
    can do NoSQL tricks with JSON support. Finally, it talked about the uses of database
    and special data tools that have become more important as machine learning continues
    its explosive growth.
  prefs: []
  type: TYPE_NORMAL
