- en: Chapter 3\. Dictionaries and Sets
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。字典和集合
- en: Python is basically dicts wrapped in loads of syntactic sugar.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Python基本上是用大量语法糖包装的字典。
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Lalo Martins, early digital nomad and Pythonista
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Lalo Martins，早期数字游牧民和Pythonista
- en: We use dictionaries in all our Python programs. If not directly in our code,
    then indirectly because the `dict` type is a fundamental part of Python’s implementation.
    Class and instance attributes, module namespaces, and function keyword arguments
    are some of the core Python constructs represented by dictionaries in memory.
    The `__builtins__.__dict__` stores all built-in types, objects, and functions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在所有的Python程序中都使用字典。即使不是直接在我们的代码中，也是间接的，因为`dict`类型是Python实现的基本部分。类和实例属性、模块命名空间和函数关键字参数是内存中由字典表示的核心Python构造。`__builtins__.__dict__`存储所有内置类型、对象和函数。
- en: Because of their crucial role, Python dicts are highly optimized—and continue
    to get improvements. *Hash tables* are the engines behind Python’s high-performance
    dicts.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其关键作用，Python 字典经过高度优化，并持续改进。*哈希表*是Python高性能字典背后的引擎。
- en: Other built-in types based on hash tables are `set` and `frozenset`. These offer
    richer APIs and operators than the sets you may have encountered in other popular
    languages. In particular, Python sets implement all the fundamental operations
    from set theory, like union, intersection, subset tests, etc. With them, we can
    express algorithms in a more declarative way, avoiding lots of nested loops and
    conditionals.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 其他基于哈希表的内置类型是`set`和`frozenset`。这些提供比您在其他流行语言中遇到的集合更丰富的API和运算符。特别是，Python集合实现了集合理论中的所有基本操作，如并集、交集、子集测试等。通过它们，我们可以以更声明性的方式表达算法，避免大量嵌套循环和条件语句。
- en: 'Here is a brief outline of this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章的简要概述：
- en: Modern syntax to build and handle `dicts` and mappings, including enhanced unpacking
    and pattern matching
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于构建和处理`dicts`和映射的现代语法，包括增强的解包和模式匹配
- en: Common methods of mapping types
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射类型的常见方法
- en: Special handling for missing keys
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丢失键的特殊处理
- en: Variations of `dict` in the standard library
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准库中`dict`的变体
- en: The `set` and `frozenset` types
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set`和`frozenset`类型'
- en: Implications of hash tables in the behavior of sets and dictionaries
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希表在集合和字典行为中的影响。
- en: What’s New in This Chapter
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章的新内容
- en: 'Most changes in this second edition cover new features related to mapping types:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这第二版中的大部分变化涵盖了与映射类型相关的新功能：
- en: '[“Modern dict Syntax”](#modern_dict_syntax_sec) covers enhanced unpacking syntax
    and different ways of merging mappings—including the `|` and `|=` operators supported
    by `dicts` since Python 3.9.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“现代字典语法”](#modern_dict_syntax_sec)介绍了增强的解包语法以及合并映射的不同方式，包括自Python 3.9起由`dicts`支持的`|`和`|=`运算符。'
- en: '[“Pattern Matching with Mappings”](#pattern_matching_mappings_sec) illustrates
    handling mappings with `match/case`, since Python 3.10.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“使用映射进行模式匹配”](#pattern_matching_mappings_sec)演示了自Python 3.10起使用`match/case`处理映射。'
- en: '[“collections.OrderedDict”](#ordereddict_sec) now focuses on the small but
    still relevant differences between `dict` and `OrderedDict`—considering that `dict`
    keeps the key insertion order since Python 3.6.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“collections.OrderedDict”](#ordereddict_sec)现在专注于`dict`和`OrderedDict`之间的细微但仍然相关的差异——考虑到自Python
    3.6起`dict`保留键插入顺序。'
- en: 'New sections on the view objects returned by `dict.keys`, `dict.items`, and
    `dict.values`: [“Dictionary Views”](#dictionary_views_sec) and [“Set Operations
    on dict Views”](#set_ops_dict_views_sec).'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由`dict.keys`、`dict.items`和`dict.values`返回的视图对象的新部分：[“字典视图”](#dictionary_views_sec)和[“字典视图上的集合操作”](#set_ops_dict_views_sec)。
- en: The underlying implementation of `dict` and `set` still relies on hash tables,
    but the `dict` code has two important optimizations that save memory and preserve
    the insertion order of the keys in `dict`. [“Practical Consequences of How dict
    Works”](#consequences_dict_internals) and [“Practical Consequences of How Sets
    Work”](#consequences_set_sec) summarize what you need to know to use them well.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`dict`和`set`的基础实现仍然依赖于哈希表，但`dict`代码有两个重要的优化，可以节省内存并保留键在`dict`中的插入顺序。[“dict工作原理的实际后果”](#consequences_dict_internals)和[“集合工作原理的实际后果”](#consequences_set_sec)总结了您需要了解的内容，以便很好地使用它们。'
- en: Note
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'After adding more than 200 pages in this second edition, I moved the optional
    section [“Internals of sets and dicts”](https://fpy.li/hashint) to the [*fluentpython.com*](http://fluentpython.com)
    companion website. The updated and expanded [18-page post](https://fpy.li/hashint)
    includes explanations and diagrams about:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这第二版中增加了200多页后，我将可选部分[“集合和字典的内部”](https://fpy.li/hashint)移至[*fluentpython.com*](http://fluentpython.com)伴随网站。更新和扩展的[18页文章](https://fpy.li/hashint)包括关于以下内容的解释和图表：
- en: The hash table algorithm and data structures, starting with its use in `set`,
    which is simpler to understand.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希表算法和数据结构，从在`set`中的使用开始，这更容易理解。
- en: The memory optimization that preserves key insertion order in `dict` instances
    (since Python 3.6).
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留`dict`实例中键插入顺序的内存优化（自Python 3.6起）。
- en: The key-sharing layout for dictionaries holding instance attributes—the `__dict__`
    of user-defined objects (optimization implemented in Python 3.3).
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于保存实例属性的字典的键共享布局——用户定义对象的`__dict__`（自Python 3.3起实现的优化）。
- en: Modern dict Syntax
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代字典语法
- en: The next sections describe advanced syntax features to build, unpack, and process
    mappings. Some of these features are not new in the language, but may be new to
    you. Others require Python 3.9 (like the `|` operator) or Python 3.10 (like `match/case`).
    Let’s start with one of the best and oldest of these features.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分描述了用于构建、解包和处理映射的高级语法特性。其中一些特性在语言中并不新鲜，但对您可能是新的。其他需要Python 3.9（如`|`运算符）或Python
    3.10（如`match/case`）的特性。让我们从其中一个最好且最古老的特性开始。
- en: dict Comprehensions
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典推导式
- en: Since Python 2.7, the syntax of listcomps and genexps was adapted to `dict`
    comprehensions (and `set` comprehensions as well, which we’ll soon visit). A *dictcomp*
    (dict comprehension) builds a `dict` instance by taking `key:value` pairs from
    any iterable. [Example 3-1](#example3-1) shows the use of `dict` comprehensions
    to build two dictionaries from the same list of tuples.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Python 2.7 起，列表推导和生成器表达式的语法已经适应了 `dict` 推导（以及我们即将讨论的 `set` 推导）。*dictcomp*（dict
    推导）通过从任何可迭代对象中获取 `key:value` 对来构建一个 `dict` 实例。[示例 3-1](#example3-1) 展示了使用 `dict`
    推导从相同的元组列表构建两个字典的用法。
- en: Example 3-1\. Examples of `dict` comprehensions
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-1\. `dict` 推导示例
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_dictionaries_and_sets_CO1-1)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dictionaries_and_sets_CO1-1)'
- en: An iterable of key-value pairs like `dial_codes` can be passed directly to the
    `dict` constructor, but…
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 可以直接将类似 `dial_codes` 的键值对可迭代对象传递给 `dict` 构造函数，但是…
- en: '[![2](assets/2.png)](#co_dictionaries_and_sets_CO1-2)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dictionaries_and_sets_CO1-2)'
- en: '…here we swap the pairs: `country` is the key, and `code` is the value.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: …在这里我们交换了键值对：`country` 是键，`code` 是值。
- en: '[![3](assets/3.png)](#co_dictionaries_and_sets_CO1-3)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dictionaries_and_sets_CO1-3)'
- en: Sorting `country_dial` by name, reversing the pairs again, uppercasing values,
    and filtering items with `code < 70`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 按名称对 `country_dial` 进行排序，再次反转键值对，将值大写，并使用 `code < 70` 过滤项。
- en: If you’re used to listcomps, dictcomps are a natural next step. If you aren’t,
    the spread of the comprehension syntax means it’s now more profitable than ever
    to become fluent in it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯于列表推导，那么字典推导是一个自然的下一步。如果你不熟悉，那么理解推导语法的传播意味着现在比以往任何时候都更有利可图。
- en: Unpacking Mappings
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解包映射
- en: '[PEP 448—Additional Unpacking Generalizations](https://fpy.li/pep448) enhanced
    the support of mapping unpackings in two ways, since Python 3.5.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[PEP 448—额外的解包泛化](https://fpy.li/pep448) 自 Python 3.5 以来增强了对映射解包的支持。'
- en: 'First, we can apply `**` to more than one argument in a function call. This
    works when keys are all strings and unique across all arguments (because duplicate
    keyword arguments are forbidden):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以在函数调用中对多个参数应用 `**`。当键都是字符串且在所有参数中唯一时，这将起作用（因为禁止重复关键字参数）：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Second, `**` can be used inside a `dict` literal—also multiple times:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，`**` 可以在 `dict` 字面量内使用——也可以多次使用：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, duplicate keys are allowed. Later occurrences overwrite previous
    ones—see the value mapped to `x` in the example.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，允许重复的键。后续出现的键会覆盖先前的键—请参见示例中映射到 `x` 的值。
- en: This syntax can also be used to merge mappings, but there are other ways. Please
    read on.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法也可以用于合并映射，但还有其他方法。请继续阅读。
- en: Merging Mappings with |
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 | 合并映射
- en: Python 3.9 supports using `|` and `|=` to merge mappings. This makes sense,
    since these are also the set union operators.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.9 支持使用 `|` 和 `|=` 来合并映射。这是有道理的，因为这些也是集合的并运算符。
- en: 'The `|` operator creates a new mapping:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`|` 运算符创建一个新的映射：'
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Usually the type of the new mapping will be the same as the type of the left
    operand—`d1` in the example—but it can be the type of the second operand if user-defined
    types are involved, according to the operator overloading rules we explore in
    [Chapter 16](ch16.html#operator_overloading).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，新映射的类型将与左操作数的类型相同—在示例中是 `d1`，但如果涉及用户定义的类型，则可以是第二个操作数的类型，根据我们在[第 16 章](ch16.html#operator_overloading)中探讨的运算符重载规则。
- en: 'To update an existing mapping in place, use `|=`. Continuing from the previous
    example, `d1` was not changed, but now it is:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要就地更新现有映射，请使用 `|=`。继续前面的例子，`d1` 没有改变，但现在它被改变了：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-54
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you need to maintain code to run on Python 3.8 or earlier, the [“Motivation”](https://fpy.li/3-1)
    section of [PEP 584—Add Union Operators To dict](https://fpy.li/pep584) provides
    a good summary of other ways to merge mappings.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要维护能在 Python 3.8 或更早版本上运行的代码，[PEP 584—为 dict 添加 Union 运算符](https://fpy.li/pep584)
    的 [“动机”](https://fpy.li/3-1) 部分提供了其他合并映射的方法的简要总结。
- en: Now let’s see how pattern matching applies to mappings.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看模式匹配如何应用于映射。
- en: Pattern Matching with Mappings
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用映射进行模式匹配
- en: The `match/case` statement supports subjects that are mapping objects. Patterns
    for mappings look like `dict` literals, but they can match instances of any actual
    or virtual subclass of `collections.abc.Mapping`.^([1](ch03.html#idm46582495507536))
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`match/case` 语句支持作为映射对象的主题。映射的模式看起来像 `dict` 字面量，但它们可以匹配 `collections.abc.Mapping`
    的任何实际或虚拟子类的实例。^([1](ch03.html#idm46582495507536))'
- en: In [Chapter 2](ch02.html#sequences) we focused on sequence patterns only, but
    different types of patterns can be combined and nested. Thanks to destructuring,
    pattern matching is a powerful tool to process records structured like nested
    mappings and sequences, which we often need to read from JSON APIs and databases
    with semi-structured schemas, like MongoDB, EdgeDB, or PostgreSQL. [Example 3-2](#dict_match_ex)
    demonstrates that. The simple type hints in `get_creators` make it clear that
    it takes a `dict` and returns a `list`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 2 章](ch02.html#sequences)中，我们只关注了序列模式，但不同类型的模式可以组合和嵌套。由于解构，模式匹配是处理结构化为嵌套映射和序列的记录的强大工具，我们经常需要从
    JSON API 和具有半结构化模式的数据库（如 MongoDB、EdgeDB 或 PostgreSQL）中读取这些记录。[示例 3-2](#dict_match_ex)演示了这一点。`get_creators`
    中的简单类型提示清楚地表明它接受一个 `dict` 并返回一个 `list`。
- en: 'Example 3-2\. creator.py: `get_creators()` extracts names of creators from
    media records'
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-2\. creator.py：`get_creators()` 从媒体记录中提取创作者的名称
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_dictionaries_and_sets_CO2-1)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dictionaries_and_sets_CO2-1)'
- en: 'Match any mapping with `''type'': ''book'', ''api'' :2`, and an `''authors''`
    key mapped to a sequence. Return the items in the sequence, as a new `list`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '匹配任何具有 `''type'': ''book'', ''api'' :2` 的映射，并且一个 `''authors''` 键映射到一个序列。将序列中的项作为新的
    `list` 返回。'
- en: '[![2](assets/2.png)](#co_dictionaries_and_sets_CO2-2)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dictionaries_and_sets_CO2-2)'
- en: 'Match any mapping with `''type'': ''book'', ''api'' :1`, and an `''author''`
    key mapped to any object. Return the object inside a `list`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '匹配任何具有 `''type'': ''book'', ''api'' :1` 的映射，并且一个 `''author''` 键映射到任何对象。将对象放入一个
    `list` 中返回。'
- en: '[![3](assets/3.png)](#co_dictionaries_and_sets_CO2-3)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dictionaries_and_sets_CO2-3)'
- en: 'Any other mapping with `''type'': ''book''` is invalid, raise `ValueError`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '具有`''type'': ''book''`的任何其他映射都是无效的，引发`ValueError`。'
- en: '[![4](assets/4.png)](#co_dictionaries_and_sets_CO2-4)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_dictionaries_and_sets_CO2-4)'
- en: 'Match any mapping with `''type'': ''movie''` and a `''director''` key mapped
    to a single object. Return the object inside a `list`.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '匹配任何具有`''type'': ''movie''`和将`''director''`键映射到单个对象的映射。返回`list`中的对象。'
- en: '[![5](assets/5.png)](#co_dictionaries_and_sets_CO2-5)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_dictionaries_and_sets_CO2-5)'
- en: Any other subject is invalid, raise `ValueError`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 任何其他主题都是无效的，引发`ValueError`。
- en: '[Example 3-2](#dict_match_ex) shows some useful practices for handling semi-structured
    data such as JSON records:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-2](#dict_match_ex)展示了处理半结构化数据（如JSON记录）的一些有用实践：'
- en: 'Include a field describing the kind of record (e.g., `''type'': ''movie''`)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '包括描述记录类型的字段（例如，`''type'': ''movie''`）'
- en: 'Include a field identifying the schema version (e.g., `''api'': 2''`) to allow
    for future evolution of public APIs'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '包括标识模式版本的字段（例如，`''api'': 2''）以允许公共API的未来演变'
- en: Have `case` clauses to handle invalid records of a specific type (e.g., `'book'`),
    as well as a catch-all
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有`case`子句来处理特定类型（例如，`'book'`）的无效记录，以及一个全捕捉
- en: 'Now let’s see how `get_creators` handles some concrete doctests:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`get_creators`如何处理一些具体的doctests：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that the order of the keys in the patterns is irrelevant, even if the subject
    is an `OrderedDict` as `b2`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，模式中键的顺序无关紧要，即使主题是`OrderedDict`，如`b2`。
- en: In contrast with sequence patterns, mapping patterns succeed on partial matches.
    In the doctests, the `b1` and `b2` subjects include a `'title'` key that does
    not appear in any `'book'` pattern, yet they match.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与序列模式相比，映射模式在部分匹配上成功。在doctests中，`b1`和`b2`主题包括一个在任何`'book'`模式中都不出现的`'title'`键，但它们匹配。
- en: 'There is no need to use `**extra` to match extra key-value pairs, but if you
    want to capture them as a `dict`, you can prefix one variable with `**`. It must
    be the last in the pattern, and `**_` is forbidden because it would be redundant.
    A simple example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要使用`**extra`来匹配额外的键值对，但如果要将它们捕获为`dict`，可以使用`**`前缀一个变量。它必须是模式中的最后一个，并且`**_`是被禁止的，因为它是多余的。一个简单的例子：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In [“Automatic Handling of Missing Keys”](#mappings_flexible_sec) we’ll study
    `defaultdict` and other mappings where key lookups via `__getitem__` (i.e., `d[key]`)
    succeed because missing items are created on the fly. In the context of pattern
    matching, a match succeeds only if the subject already has the required keys at
    the top of the `match` statement.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“缺失键的自动处理”](#mappings_flexible_sec)中，我们将研究`defaultdict`和其他映射，其中通过`__getitem__`（即，`d[key]`）进行键查找成功，因为缺失项会动态创建。在模式匹配的上下文中，只有在主题已经具有`match`语句顶部所需键时，匹配才成功。
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The automatic handling of missing keys is not triggered because pattern matching
    always uses the `d.get(key, sentinel)` method—where the default `sentinel` is
    a special marker value that cannot occur in user data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不会触发缺失键的自动处理，因为模式匹配总是使用`d.get(key, sentinel)`方法——其中默认的`sentinel`是一个特殊的标记值，不能出现在用户数据中。
- en: Moving on from syntax and structure, let’s study the API of mappings.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从语法和结构转向，让我们研究映射的API。
- en: Standard API of Mapping Types
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射类型的标准API
- en: The `collections.abc` module provides the `Mapping` and `MutableMapping` ABCs
    describing the interfaces of `dict` and similar types. See [Figure 3-1](#mapping_uml).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections.abc`模块提供了描述`dict`和类似类型接口的`Mapping`和`MutableMapping` ABCs。参见[图 3-1](#mapping_uml)。'
- en: 'The main value of the ABCs is documenting and formalizing the standard interfaces
    for mappings, and serving as criteria for `isinstance` tests in code that needs
    to support mappings in a broad sense:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ABCs的主要价值在于记录和规范映射的标准接口，并作为需要支持广义映射的代码中`isinstance`测试的标准：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-90
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Using `isinstance` with an ABC is often better than checking whether a function
    argument is of the concrete `dict` type, because then alternative mapping types
    can be used. We’ll discuss this in detail in [Chapter 13](ch13.html#ifaces_prot_abc).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ABC进行`isinstance`通常比检查函数参数是否为具体`dict`类型更好，因为这样可以使用替代映射类型。我们将在[第13章](ch13.html#ifaces_prot_abc)中详细讨论这个问题。
- en: '![UML class diagram for `Mapping` and `MutableMapping`](assets/flpy_0301.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![`Mapping`和`MutableMapping`的UML类图`](assets/flpy_0301.png)'
- en: Figure 3-1\. Simplified UML class diagram for the `MutableMapping` and its superclasses
    from `collections.abc` (inheritance arrows point from subclasses to superclasses;
    names in italic are abstract classes and abstract methods).
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-1。`collections.abc`中`MutableMapping`及其超类的简化UML类图（继承箭头从子类指向超类；斜体名称是抽象类和抽象方法）。
- en: To implement a custom mapping, it’s easier to extend `collections.UserDict`,
    or to wrap a `dict` by composition, instead of subclassing these ABCs. The `collections.UserDict`
    class and all concrete mapping classes in the standard library encapsulate the
    basic `dict` in their implementation, which in turn is built on a hash table.
    Therefore, they all share the limitation that the keys must be *hashable* (the
    values need not be hashable, only the keys). If you need a refresher, the next
    section explains.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现自定义映射，最好扩展`collections.UserDict`，或通过组合包装`dict`，而不是继承这些ABCs。`collections.UserDict`类和标准库中的所有具体映射类在其实现中封装了基本的`dict`，而`dict`又建立在哈希表上。因此，它们都共享一个限制，即键必须是*可哈希*的（值不需要是可哈希的，只有键需要是可哈希的）。如果需要复习，下一节会解释。
- en: What Is Hashable
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是可哈希的
- en: 'Here is part of the definition of hashable adapted from the [Python *Glossary*](https://fpy.li/3-3):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是从[Python *术语表*](https://fpy.li/3-3)中适应的可哈希定义的部分：
- en: An object is hashable if it has a hash code which never changes during its lifetime
    (it needs a `__hash__()` method), and can be compared to other objects (it needs
    an `__eq__()` method). Hashable objects which compare equal must have the same
    hash code.^([2](ch03.html#idm46582504518496))
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果对象具有永远不会在其生命周期内更改的哈希码（它需要一个`__hash__()`方法），并且可以与其他对象进行比较（它需要一个`__eq__()`方法），则该对象是可哈希的。比较相等的可哈希对象必须具有相同的哈希码。^([2](ch03.html#idm46582504518496))
- en: 'Numeric types and flat immutable types `str` and `bytes` are all hashable.
    Container types are hashable if they are immutable and all contained objects are
    also hashable. A `frozenset` is always hashable, because every element it contains
    must be hashable by definition. A `tuple` is hashable only if all its items are
    hashable. See tuples `tt`, `tl`, and `tf`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 数值类型和扁平不可变类型`str`和`bytes`都是可哈希的。如果容器类型是不可变的，并且所有包含的对象也是可哈希的，则它们是可哈希的。`frozenset`始终是可哈希的，因为它包含的每个元素必须根据定义是可哈希的。仅当元组的所有项都是可哈希的时，元组才是可哈希的。参见元组`tt`、`tl`和`tf`：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The hash code of an object may be different depending on the version of Python,
    the machine architecture, and because of a *salt* added to the hash computation
    for security reasons.^([3](ch03.html#idm46582504467472)) The hash code of a correctly
    implemented object is guaranteed to be constant only within one Python process.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的哈希码可能因Python版本、机器架构以及出于安全原因添加到哈希计算中的*盐*而有所不同。^([3](ch03.html#idm46582504467472))
    正确实现的对象的哈希码仅在一个Python进程中保证是恒定的。
- en: User-defined types are hashable by default because their hash code is their
    `id()`, and the `__eq__()` method inherited from the `object` class simply compares
    the object IDs. If an object implements a custom `__eq__()` that takes into account
    its internal state, it will be hashable only if its `__hash__()` always returns
    the same hash code. In practice, this requires that `__eq__()` and `__hash__()`
    only take into account instance attributes that never change during the life of
    the object.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，用户定义的类��是可哈希的，因为它们的哈希码是它们的`id()`，并且从`object`类继承的`__eq__()`方法只是简单地比较对象ID。如果一个对象实现了一个考虑其内部状态的自定义`__eq__()`，那么只有当其`__hash__()`始终返回相同的哈希码时，它才是可哈希的。实际上，这要求`__eq__()`和`__hash__()`只考虑在对象生命周期中永远不会改变的实例属性。
- en: 'Now let’s review the API of the most commonly used mapping types in Python:
    `dict`, `defaultdict`, and `OrderedDict`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回顾Python中最常用的映射类型`dict`、`defaultdict`和`OrderedDict`的API。
- en: Overview of Common Mapping Methods
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见映射方法概述
- en: 'The basic API for mappings is quite rich. [Table 3-1](#mapping_methods_tbl)
    shows the methods implemented by `dict` and two popular variations: `defaultdict`
    and `OrderedDict`, both defined in the `collections` module.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 映射的基本API非常丰富。[表 3-1](#mapping_methods_tbl) 显示了`dict`和两个流行变体：`defaultdict`和`OrderedDict`的方法，它们都定义在`collections`模块中。
- en: Table 3-1\. Methods of the mapping types `dict`, `collections.defaultdict`,
    and `collections.OrderedDict` (common object methods omitted for brevity); optional
    arguments are enclosed in `[…]`
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-1\. 映射类型`dict`、`collections.defaultdict`和`collections.OrderedDict`的方法（为简洁起见省略了常见对象方法）；可选参数用`[…]`括起来
- en: '|  | dict | defaultdict | OrderedDict |   |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '|  | dict | defaultdict | OrderedDict |   |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `d.clear()` | ● | ● | ● | Remove all items |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `d.clear()` | ● | ● | ● | 移除所有项 |'
- en: '| `d.__contains__(k)` | ● | ● | ● | `k in d` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `d.__contains__(k)` | ● | ● | ● | `k in d` |'
- en: '| `d.copy()` | ● | ● | ● | Shallow copy |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `d.copy()` | ● | ● | ● | 浅拷贝 |'
- en: '| `d.__copy__()` |  | ● |  | Support for `copy.copy(d)` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `d.__copy__()` |  | ● |  | 支持`copy.copy(d)` |'
- en: '| `d.default_factory` |  | ● |  | Callable invoked by `__missing__` to set
    missing values^([a](ch03.html#idm46582504368928)) |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `d.default_factory` |  | ● |  | `__missing__`调用的可调用对象，用于设置缺失值^([a](ch03.html#idm46582504368928))
    |'
- en: '| `d.__delitem__(k)` | ● | ● | ● | `del d[k]`—remove item with key `k` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `d.__delitem__(k)` | ● | ● | ● | `del d[k]`—删除键为`k`的项 |'
- en: '| `d.fromkeys(it, [initial])` | ● | ● | ● | New mapping from keys in iterable,
    with optional initial value (defaults to `None`) |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `d.fromkeys(it, [initial])` | ● | ● | ● | 从可迭代对象中的键创建新映射，可选初始值（默认为`None`）
    |'
- en: '| `d.get(k, [default])` | ● | ● | ● | Get item with key `k`, return `default`
    or `None` if missing |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `d.get(k, [default])` | ● | ● | ● | 获取键为`k`的项，如果不存在则返回`default`或`None` |'
- en: '| `d.__getitem__(k)` | ● | ● | ● | `d[k]`—get item with key `k` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `d.__getitem__(k)` | ● | ● | ● | `d[k]`—获取键为`k`的项 |'
- en: '| `d.items()` | ● | ● | ● | Get *view* over items—`(key, value)` pairs |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `d.items()` | ● | ● | ● | 获取项的*视图*—`(key, value)`对 |'
- en: '| `d.__iter__()` | ● | ● | ● | Get iterator over keys |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `d.__iter__()` | ● | ● | ● | 获取键的迭代器 |'
- en: '| `d.keys()` | ● | ● | ● | Get *view* over keys |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `d.keys()` | ● | ● | ● | 获取键的*视图* |'
- en: '| `d.__len__()` | ● | ● | ● | `len(d)`—number of items |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `d.__len__()` | ● | ● | ● | `len(d)`—项数 |'
- en: '| `d.__missing__(k)` |  | ● |  | Called when `__getitem__` cannot find the
    key |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `d.__missing__(k)` |  | ● |  | 当`__getitem__`找不到键时调用 |'
- en: '| `d.move_to_end(k, [last])` |  |  | ● | Move `k` first or last position (`last`
    is `True` by default) |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `d.move_to_end(k, [last])` |  |  | ● | 将`k`移动到第一个或最后一个位置（默认情况下`last`为`True`）
    |'
- en: '| `d.__or__(other)` | ● | ● | ● | Support for `d1 &#124; d2` to create new
    `dict` merging `d1` and `d2` (Python ≥ 3.9) |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `d.__or__(other)` | ● | ● | ● | 支持`d1 &#124; d2`创建新的`dict`合并`d1`和`d2`（Python
    ≥ 3.9） |'
- en: '| `d.__ior__(other)` | ● | ● | ● | Support for `d1 &#124;= d2` to update `d1`
    with `d2` (Python ≥ 3.9) |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `d.__ior__(other)` | ● | ● | ● | 支持`d1 &#124;= d2`更新`d1`与`d2`（Python ≥ 3.9）
    |'
- en: '| `d.pop(k, [default])` | ● | ● | ● | Remove and return value at `k`, or `default`
    or `None` if missing |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `d.pop(k, [default])` | ● | ● | ● | 移除并返回键为`k`的值，如果不存在则返回`default`或`None`
    |'
- en: '| `d.popitem()` | ● | ● | ● | Remove and return the last inserted item as `(key,
    value)` ^([b](ch03.html#idm46582504307360)) |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `d.popitem()` | ● | ● | ● | 移除并返回最后插入的项为`(key, value)` ^([b](ch03.html#idm46582504307360))
    |'
- en: '| `d.__reversed__()` | ● | ● | ● | Support for `reverse(d)`—returns iterator
    for keys from last to first inserted. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `d.__reversed__()` | ● | ● | ● | 支持`reverse(d)`—返回从最后插入到第一个插入的键的迭代器 |'
- en: '| `d.__ror__(other)` | ● | ● | ● | Support for `other &#124; dd`—reversed union
    operator (Python ≥ 3.9)^([c](ch03.html#idm46582504297152)) |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `d.__ror__(other)` | ● | ● | ● | 支持`other &#124; dd`—反向联合运算符（Python ≥ 3.9）^([c](ch03.html#idm46582504297152))
    |'
- en: '| `d.setdefault(k, [default])` | ● | ● | ● | If `k in d`, return `d[k]`; else
    set `d[k] = default` and return it |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `d.setdefault(k, [default])` | ● | ● | ● | 如果`k`在`d`中，则返回`d[k]`；否则设置`d[k]
    = default`并返回 |'
- en: '| `d.__setitem__(k, v)` | ● | ● | ● | `d[k] = v`—put `v` at `k` |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `d.__setitem__(k, v)` | ● | ● | ● | `d[k] = v`—在`k`处放置`v` |'
- en: '| `d.update(m, [**kwargs])` | ● | ● | ● | Update `d` with items from mapping
    or iterable of `(key, value)` pairs |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `d.update(m, [**kwargs])` | ● | ● | ● | 使用映射或`(key, value)`对的可迭代对象更新`d` |'
- en: '| `d.values()` | ● | ● | ● | Get *view* over values |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `d.values()` | ● | ● | ● | 获取*视图*的值 |'
- en: '| ^([a](ch03.html#idm46582504368928-marker)) `default_factory` is not a method,
    but a callable attribute set by the end user when a `defaultdict` is instantiated.^([b](ch03.html#idm46582504307360-marker))
    `OrderedDict.popitem(last=False)` removes the first item inserted (FIFO). The
    `last` keyword argument is not supported in `dict` or `defaultdict` as recently
    as Python 3.10b3.^([c](ch03.html#idm46582504297152-marker)) Reversed operators
    are explained in [Chapter 16](ch16.html#operator_overloading). |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| ^([a](ch03.html#idm46582504368928-marker)) `default_factory` 不是一个方法，而是在实例化`defaultdict`时由最终用户设置的可调用属性。^([b](ch03.html#idm46582504307360-marker))
    `OrderedDict.popitem(last=False)` 移除第一个插入的项目（FIFO）。`last`关键字参数在Python 3.10b3中不支持`dict`或`defaultdict`。^([c](ch03.html#idm46582504297152-marker))
    反向运算符在[第16章](ch16.html#operator_overloading)中有解释。 |'
- en: 'The way `d.update(m)` handles its first argument `m` is a prime example of
    *duck typing*: it first checks whether `m` has a `keys` method and, if it does,
    assumes it is a mapping. Otherwise, `update()` falls back to iterating over `m`,
    assuming its items are `(key, value)` pairs. The constructor for most Python mappings
    uses the logic of `update()` internally, which means they can be initialized from
    other mappings or from any iterable object producing `(key, value)` pairs.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`d.update(m)` 处理其第一个参数`m`的方式是*鸭子类型*的一个典型例子：它首先检查`m`是否有一个`keys`方法，如果有，就假定它是一个映射。否则，`update()`会回退到迭代`m`，假设其项是`(key,
    value)`对。大多数Python映射的构造函数在内部使用`update()`的逻辑，这意味着它们可以从其他映射或从产生`(key, value)`对的任何可迭代对象初始化。'
- en: A subtle mapping method is `setdefault()`. It avoids redundant key lookups when
    we need to update the value of an item in place. The next section shows how to
    use it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一种微妙的映射方法是`setdefault()`。当我们需要就地更新项目的值时，它避免了冗余的键查找。下一节将展示如何使用它。
- en: Inserting or Updating Mutable Values
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入或更新可变值
- en: In line with Python’s *fail-fast* philosophy, `dict` access with `d[k]` raises
    an error when `k` is not an existing key. Pythonistas know that `d.get(k, default)`
    is an alternative to `d[k]` whenever a default value is more convenient than handling
    `KeyError`. However, when you retrieve a mutable value and want to update it,
    there is a better way.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 符合Python的*失败快速*哲学，使用`d[k]`访问`dict`时，当`k`不是现有键时会引发错误。Python 程序员知道，当默认值比处理`KeyError`更方便时，`d.get(k,
    default)`是`d[k]`的替代方案。然而，当您检索可变值并希望更新它时，有一种更好的方法。
- en: Consider a script to index text, producing a mapping where each key is a word,
    and the value is a list of positions where that word occurs, as shown in [Example 3-3](#index0_output_ex).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑编写一个脚本来索引文本，生成一个映射，其中每个键是一个单词，值是该单词出现的位置列表，如[示例 3-3](#index0_output_ex)所示。
- en: 'Example 3-3\. Partial output from [Example 3-4](#index0_ex) processing the
    “Zen of Python”; each line shows a word and a list of occurrences coded as pairs:
    (`line_number`, `column_number`)'
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-3\. [示例 3-4](#index0_ex) 处理“Python 之禅”时的部分输出；每行显示一个单词和一对出现的编码为（`行号`，`列号`）的列表。
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Example 3-4](#index0_ex) is a suboptimal script written to show one case where
    `dict.get` is not the best way to handle a missing key. I adapted it from an example
    by Alex Martelli.^([4](ch03.html#idm46582504125024))'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-4](#index0_ex) 是一个次优脚本，用于展示`dict.get`不是处理缺失键的最佳方式的一个案例。我从亚历克斯·马特利的一个示例中进行了改编。^([4](ch03.html#idm46582504125024))'
- en: Example 3-4\. index0.py uses `dict.get` to fetch and update a list of word occurrences
    from the index (a better solution is in [Example 3-5](#index_ex))
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-4\. index0.py 使用`dict.get`从索引中获取并更新单词出现列表的脚本（更好的解决方案在[示例 3-5](#index_ex)中）
- en: '[PRE11]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_dictionaries_and_sets_CO3-1)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dictionaries_and_sets_CO3-1)'
- en: Get the list of occurrences for `word`, or `[]` if not found.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 获取`word`的出现列表，如果找不到则为`[]`。
- en: '[![2](assets/2.png)](#co_dictionaries_and_sets_CO3-2)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dictionaries_and_sets_CO3-2)'
- en: Append new location to `occurrences`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将新位置附加到`occurrences`。
- en: '[![3](assets/3.png)](#co_dictionaries_and_sets_CO3-3)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dictionaries_and_sets_CO3-3)'
- en: Put changed `occurrences` into `index` dict; this entails a second search through
    the `index`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将更改后的`occurrences`放入`index`字典中；这需要通过`index`进行第二次搜索。
- en: '[![4](assets/4.png)](#co_dictionaries_and_sets_CO3-4)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_dictionaries_and_sets_CO3-4)'
- en: In the `key=` argument of `sorted`, I am not calling `str.upper`, just passing
    a reference to that method so the `sorted` function can use it to normalize the
    words for sorting.^([5](ch03.html#idm46582493353744))
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sorted`的`key=`参数中，我没有调用`str.upper`，只是传递了对该方法的引用，以便`sorted`函数可以使用它来对单词进行规范化排序。^([5](ch03.html#idm46582493353744))
- en: The three lines dealing with `occurrences` in [Example 3-4](#index0_ex) can
    be replaced by a single line using `dict.setdefault`. [Example 3-5](#index_ex)
    is closer to Alex Martelli’s code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-4](#index0_ex) 中处理`occurrences`的三行可以用`dict.setdefault`替换为一行。[示例 3-5](#index_ex)
    更接近亚历克斯·马特利的代码。'
- en: Example 3-5\. index.py uses `dict.setdefault` to fetch and update a list of
    word occurrences from the index in a single line; contrast with [Example 3-4](#index0_ex)
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-5\. index.py 使用`dict.setdefault`从索引中获取并更新单词出现列表的脚本，一行搞定；与[示例 3-4](#index0_ex)进行对比
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_dictionaries_and_sets_CO4-1)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dictionaries_and_sets_CO4-1)'
- en: Get the list of occurrences for `word`, or set it to `[]` if not found; `setdefault`
    returns the value, so it can be updated without requiring a second search.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 获取`word`的出现列表，如果找不到则将其设置为`[]`；`setdefault`返回值，因此可以在不需要第二次搜索的情况下进行更新。
- en: In other words, the end result of this line…
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这行的最终结果是…
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: …is the same as running…
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: …等同于运行…
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: …except that the latter code performs at least two searches for `key`—three
    if it’s not found—while `setdefault` does it all with a single lookup.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: …除了后者的代码至少执行两次对`key`的搜索—如果找不到，则执行三次—而`setdefault`只需一次查找就可以完成所有操作。
- en: A related issue, handling missing keys on any lookup (and not only when inserting),
    is the subject of the next section.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相关问题是，在任何查找中处理缺失键（而不仅仅是在插入时）是下一节的主题。
- en: Automatic Handling of Missing Keys
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺失键的自动处理
- en: 'Sometimes it is convenient to have mappings that return some made-up value
    when a missing key is searched. There are two main approaches to this: one is
    to use a `defaultdict` instead of a plain `dict`. The other is to subclass `dict`
    or any other mapping type and add a `__missing__` method. Both solutions are covered
    next.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当搜索缺失的键时返回一些虚构的值是很方便的。有两种主要方法：一种是使用`defaultdict`而不是普通的`dict`。另一种是子类化`dict`或任何其他映射类型，并添加一个`__missing__`方法。接下来将介绍这两种解决方案。
- en: 'defaultdict: Another Take on Missing Keys'
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: defaultdict：另一种处理缺失键的方法
- en: A `collections.defaultdict` instance creates items with a default value on demand
    whenever a missing key is searched using `d[k]` syntax. [Example 3-6](#index_default_ex)
    uses `defaultdict` to provide another elegant solution to the word index task
    from [Example 3-5](#index_ex).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`collections.defaultdict`实例在使用`d[k]`语法搜索缺失键时按需创建具有默认值的项目。[示例 3-6](#index_default_ex)使用`defaultdict`提供了另一个优雅的解决方案来完成来自[示例 3-5](#index_ex)的单词索引任务。
- en: 'Here is how it works: when instantiating a `defaultdict`, you provide a callable
    to produce a default value whenever `__getitem__` is passed a nonexistent key
    argument.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作原理是：在实例化`defaultdict`时，你提供一个可调用对象，每当`__getitem__`传递一个不存在的键参数时产生一个默认值。
- en: 'For example, given a `defaultdict` created as `dd = defaultdict(list)`, if
    `''new-key''` is not in `dd`, the expression `dd[''new-key'']` does the following
    steps:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定一个创建为`dd = defaultdict(list)`的`defaultdict`，如果`'new-key'`不在`dd`中，表达式`dd['new-key']`会执行以下步骤：
- en: Calls `list()` to create a new list.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`list()`来创建一个新列表。
- en: Inserts the list into `dd` using `'new-key'` as key.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`'new-key'`作为键将列表插入`dd`。
- en: Returns a reference to that list.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回对该列表的引用。
- en: The callable that produces the default values is held in an instance attribute
    named `default_factory`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 产生默认值的可调用对象保存在名为`default_factory`的实例属性中。
- en: 'Example 3-6\. index_default.py: using `defaultdict` instead of the `setdefault`
    method'
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-6。index_default.py：使用`defaultdict`而不是`setdefault`方法
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](assets/1.png)](#co_dictionaries_and_sets_CO5-1)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dictionaries_and_sets_CO5-1)'
- en: Create a `defaultdict` with the `list` constructor as `default_factory`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`list`构造函数创建一个`defaultdict`作为`default_factory`。
- en: '[![2](assets/2.png)](#co_dictionaries_and_sets_CO5-2)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dictionaries_and_sets_CO5-2)'
- en: If `word` is not initially in the `index`, the `default_factory` is called to
    produce the missing value, which in this case is an empty `list` that is then
    assigned to `index[word]` and returned, so the `.append(location)` operation always
    succeeds.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`word`最初不在`index`中，则调用`default_factory`来生成缺失值，这种情况下是一个空的`list`，然后将其分配给`index[word]`并返回，因此`.append(location)`操作总是成功的。
- en: If no `default_factory` is provided, the usual `KeyError` is raised for missing
    keys.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供`default_factory`，则对于缺失的键会引发通常的`KeyError`。
- en: Warning
  id: totrans-180
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The `default_factory` of a `defaultdict` is only invoked to provide default
    values for `__getitem__` calls, and not for the other methods. For example, if
    `dd` is a `defaultdict`, and `k` is a missing key, `dd[k]` will call the `default_factory`
    to create a default value, but `dd.get(k)` still returns `None`, and `k in dd`
    is `False`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict`的`default_factory`仅在为`__getitem__`调用提供默认值时才会被调用，而不会为其他方法调用。例如，如果`dd`是一个`defaultdict`，`k`是一个缺失的键，`dd[k]`将调用`default_factory`来创建一个默认值，但`dd.get(k)`仍然返回`None`，`k
    in dd`为`False`。'
- en: The mechanism that makes `defaultdict` work by calling `default_factory` is
    the `__missing__` special method, a feature that we discuss next.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使`defaultdict`工作的机制是调用`default_factory`的`__missing__`特殊方法，这是我们接下来要讨论的一个特性。
- en: The __missing__ Method
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`__missing__`方法'
- en: 'Underlying the way mappings deal with missing keys is the aptly named `__missing__`
    method. This method is not defined in the base `dict` class, but `dict` is aware
    of it: if you subclass `dict` and provide a `__missing__` method, the standard
    `dict.__getitem__` will call it whenever a key is not found, instead of raising
    `KeyError`.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 映射处理缺失键的基础是名为`__missing__`的方法。这个方法在基本的`dict`类中没有定义，但`dict`知道它：如果你子类化`dict`并提供一个`__missing__`方法，标准的`dict.__getitem__`将在找不到键时调用它，而不是引发`KeyError`。
- en: Suppose you’d like a mapping where keys are converted to `str` when looked up.
    A concrete use case is a device library for IoT,^([6](ch03.html#idm46582492823616))
    where a programmable board with general-purpose I/O pins (e.g., a Raspberry Pi
    or an Arduino) is represented by a `Board` class with a `my_board.pins` attribute,
    which is a mapping of physical pin identifiers to pin software objects. The physical
    pin identifier may be just a number or a string like `"A0"` or `"P9_12"`. For
    consistency, it is desirable that all keys in `board.pins` are strings, but it
    is also convenient looking up a pin by number, as in `my_arduino.pin[13]`, so
    that beginners are not tripped when they want to blink the LED on pin 13 of their
    Arduinos. [Example 3-7](#ex_strkeydict0_tests) shows how such a mapping would
    work.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要一个映射，其中键在查找时被转换为`str`。一个具体的用例是物联网设备库，其中一个具有通用I/O引脚（例如树莓派或Arduino）的可编程板被表示为一个`Board`类，具有一个`my_board.pins`属性，它是物理引脚标识符到引脚软件对象的映射。物理引脚标识符可能只是一个数字或一个字符串，如`"A0"`或`"P9_12"`。为了一致性，希望`board.pins`中的所有键都是字符串，但也方便通过数字查找引脚，例如`my_arduino.pin[13]`，这样初学者在想要闪烁他们的Arduino上的13号引脚时不会出错。[示例 3-7](#ex_strkeydict0_tests)展示了这样一个映射如何工作。
- en: Example 3-7\. When searching for a nonstring key, `StrKeyDict0` converts it
    to `str` when it is not found
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-7。当搜索非字符串键时，`StrKeyDict0`在未找到时将其转换为`str`
- en: '[PRE16]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[Example 3-8](#ex_strkeydict0) implements a class `StrKeyDict0` that passes
    the preceding doctests.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-8](#ex_strkeydict0)实现了一个通过前面的doctests的`StrKeyDict0`类。'
- en: Tip
  id: totrans-189
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: A better way to create a user-defined mapping type is to subclass `collections.UserDict`
    instead of `dict` (as we will do in [Example 3-9](#ex_strkeydict)). Here we subclass
    `dict` just to show that `__missing__` is supported by the built-in `dict.__getitem__`
    method.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用户定义的映射类型的更好方法是子类化`collections.UserDict`而不是`dict`（正如我们将在[示例 3-9](#ex_strkeydict)中所做的那样）。这里我们子类化`dict`只是为了展示内置的`dict.__getitem__`方法支持`__missing__`。
- en: Example 3-8\. `StrKeyDict0` converts nonstring keys to `str` on lookup (see
    tests in [Example 3-7](#ex_strkeydict0_tests))
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-8。`StrKeyDict0`在查找时将非字符串键转换为`str`（请参见[示例 3-7](#ex_strkeydict0_tests)中的测试）
- en: '[PRE17]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](assets/1.png)](#co_dictionaries_and_sets_CO6-1)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dictionaries_and_sets_CO6-1)'
- en: '`StrKeyDict0` inherits from `dict`.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`StrKeyDict0`继承自`dict`。'
- en: '[![2](assets/2.png)](#co_dictionaries_and_sets_CO6-2)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dictionaries_and_sets_CO6-2)'
- en: Check whether `key` is already a `str`. If it is, and it’s missing, raise `KeyError`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`key`是否已经是`str`。如果是，并且它丢失了，那么引发`KeyError`。
- en: '[![3](assets/3.png)](#co_dictionaries_and_sets_CO6-3)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dictionaries_and_sets_CO6-3)'
- en: Build `str` from `key` and look it up.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 从`key`构建`str`并查找它。
- en: '[![4](assets/4.png)](#co_dictionaries_and_sets_CO6-4)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_dictionaries_and_sets_CO6-4)'
- en: The `get` method delegates to `__getitem__` by using the `self[key]` notation;
    that gives the opportunity for our `__missing__` to act.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`方法通过使用`self[key]`符号委托给`__getitem__`；这给了我们的`__missing__`发挥作用的机会。'
- en: '[![5](assets/5.png)](#co_dictionaries_and_sets_CO6-5)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_dictionaries_and_sets_CO6-5)'
- en: If a `KeyError` was raised, `__missing__` already failed, so we return the `default`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果引发`KeyError`，则`__missing__`已经失败，因此我们返回`default`。
- en: '[![6](assets/6.png)](#co_dictionaries_and_sets_CO6-6)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_dictionaries_and_sets_CO6-6)'
- en: Search for unmodified key (the instance may contain non-`str` keys), then for
    a `str` built from the key.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索未修改的键（实例可能包含非`str`键），然后搜索从键构建的`str`。
- en: Take a moment to consider why the test `isinstance(key, str)` is necessary in
    the `__missing__` implementation.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间考虑一下为什么在`__missing__`实现中需要测试`isinstance(key, str)`。
- en: Without that test, our `__missing__` method would work OK for any key `k`—`str`
    or not `str`—whenever `str(k)` produced an existing key. But if `str(k)` is not
    an existing key, we’d have an infinite recursion. In the last line of `__missing__`,
    `self[str(key)]` would call `__getitem__`, passing that `str` key, which in turn
    would call `__missing__` again.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这个测试，我们的`__missing__`方法对于任何键`k`——`str`或非`str`——都能正常工作，只要`str(k)`产生一个现有的键。但是如果`str(k)`不是一个现有的键，我们将会有一个无限递归。在`__missing__`的最后一行，`self[str(key)]`会调用`__getitem__`，传递那个`str`键，然后会再次调用`__missing__`。
- en: 'The `__contains__` method is also needed for consistent behavior in this example,
    because the operation `k in d` calls it, but the method inherited from `dict`
    does not fall back to invoking `__missing__`. There is a subtle detail in our
    implementation of `__contains__`: we do not check for the key in the usual Pythonic
    way—`k` in `my_dict`—because `str(key) in self` would recursively call `__contains__`.
    We avoid this by explicitly looking up the key in `self.keys()`.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`__contains__`方法也是必需的，因为操作`k in d`会调用它，但从`dict`继承的方法不会回退到调用`__missing__`。在我们的`__contains__`实现中有一个微妙的细节：我们不是用通常的Python方式检查键——`k`
    in `my_dict`——因为`str(key) in self`会递归调用`__contains__`。我们通过在`self.keys()`中明确查找键来避免这种情况。
- en: A search like `k in my_dict.keys()` is efficient in Python 3 even for very large
    mappings because `dict.keys()` returns a view, which is similar to a set, as we’ll
    see in [“Set Operations on dict Views”](#set_ops_dict_views_sec). However, remember
    that `k in my_dict` does the same job, and is faster because it avoids the attribute
    lookup to find the `.keys` method.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3中，像`k in my_dict.keys()`这样的搜索对于非常大的映射也是高效的，因为`dict.keys()`返回一个视图，类似于集合，正如我们将在[“dict
    视图上的集合操作”](#set_ops_dict_views_sec)中看到的。然而，请记住，`k in my_dict`也能完成同样的工作，并且更快，因为它避免了查找属性以找到`.keys`方法。
- en: I had a specific reason to use `self.keys()` in the `__contains__` method in
    [Example 3-8](#ex_strkeydict0). The check for the unmodified key—`key in self.keys()`—is
    necessary for correctness because `StrKeyDict0` does not enforce that all keys
    in the dictionary must be of type `str`. Our only goal with this simple example
    is to make searching “friendlier” and not enforce types.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[示例 3-8](#ex_strkeydict0)中的`__contains__`方法中有一个特定的原因使用`self.keys()`。检查未修改的键——`key
    in self.keys()`——对于正确性是必要的，因为`StrKeyDict0`不强制字典中的所有键都必须是`str`类型。我们这个简单示例的唯一目标是使搜索“更友好”，而不是强制类型。
- en: Warning
  id: totrans-210
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: User-defined classes derived from standard library mappings may or may not use
    `__missing__` as a fallback in their implementations of `__getitem__`, `get`,
    or `__contains__`, as explained in the next section.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 派生自标准库映射的用户定义类可能会或可能不会在它们的`__getitem__`、`get`或`__contains__`实现中使用`__missing__`作为回退，如下一节所述。
- en: Inconsistent Usage of __missing__ in the Standard Library
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准库中对`__missing__`的不一致使用
- en: 'Consider the following scenarios, and how the missing key lookups are affected:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下情况，以及缺失键查找是如何受影响的：
- en: '`dict` subclass'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`dict`子类'
- en: A subclass of `dict` implementing only `__missing__` and no other method. In
    this case, `__missing__` may be called only on `d[k]`, which will use the `__getitem__`
    inherited from `dict`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一个只实现`__missing__`而没有其他方法的`dict`子类。在这种情况下，`__missing__`只能在`d[k]`上调用，这将使用从`dict`继承的`__getitem__`。
- en: '`collections.UserDict` subclass'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections.UserDict`子类'
- en: Likewise, a subclass of `UserDict` implementing only `__missing__` and no other
    method. The `get` method inherited from `UserDict` calls `__getitem__`. This means
    `__missing__` may be called to handle lookups with `d[k]` and `d.get(k)`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，一个只实现`__missing__`而没有其他方法的`UserDict`子类。从`UserDict`继承的`get`方法调用`__getitem__`。这意味着`__missing__`可能被调用来处理`d[k]`和`d.get(k)`的查找。
- en: '`abc.Mapping` subclass with the simplest possible `__getitem__`'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 具有最简单可能的`__getitem__`的`abc.Mapping`子类
- en: A minimal subclass of `abc.Mapping` implementing `__missing__` and the required
    abstract methods, including an implementation of `__getitem__` that does not call
    `__missing__`. The `__missing__` method is never triggered in this class.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实现了`__missing__`和所需抽象方法的最小的`abc.Mapping`子类，包括一个不调用`__missing__`的`__getitem__`实现。在这个类中，`__missing__`方法永远不会被触发。
- en: '`abc.Mapping` subclass with `__getitem__` calling `__missing__`'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 具有调用`__missing__`的`__getitem__`的`abc.Mapping`子类
- en: A minimal subclass of `abc.Mapping` implementing `__missing__` and the required
    abstract methods, including an implementation of `__getitem__` that calls `__missing__`.
    The `__missing__` method is triggered in this class for missing key lookups made
    with `d[k]`, `d.get(k)`, and `k in d`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一个最小的`abc.Mapping`子类实现了`__missing__`和所需的抽象方法，包括调用`__missing__`的`__getitem__`的实现。在这个类中，对使用`d[k]`、`d.get(k)`和`k
    in d`进行的缺失键查找会触发`__missing__`方法。
- en: See [*missing.py*](https://fpy.li/3-7) in the example code repository for demonstrations
    of the scenarios described here.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例代码库中查看[*missing.py*](https://fpy.li/3-7)以演示这里描述的场景。
- en: The four scenarios just described assume minimal implementations. If your subclass
    implements `__getitem__`, `get`, and `__contains__`, then you can make those methods
    use `__missing__` or not, depending on your needs. The point of this section is
    to show that you must be careful when subclassing standard library mappings to
    use `__missing__`, because the base classes support different behaviors by default.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才描述的四种情况假设最小实现。如果你的子类实现了`__getitem__`、`get`和`__contains__`，那么你可以根据需要让这些方法使用`__missing__`或不使用。本节的重点是要表明，在子类化标准库映射时要小心使用`__missing__`，因为基类默认支持不同的行为。
- en: Don’t forget that the behavior of `setdefault` and `update` is also affected
    by key lookup. And finally, depending on the logic of your `__missing__`, you
    may need to implement special logic in `__setitem__`, to avoid inconsistent or
    surprising behavior. We’ll see an example of this in [“Subclassing UserDict Instead
    of dict”](#sublcassing_userdict_sec).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，`setdefault`和`update`的行为也受键查找影响。最后，根据你的`__missing__`的逻辑，你可能需要在`__setitem__`中实现特殊逻辑，以避免不一致或令人惊讶的行为。我们将在[“Subclassing
    UserDict Instead of dict”](#sublcassing_userdict_sec)中看到一个例子。
- en: So far we have covered the `dict` and `defaultdict` mapping types, but the standard
    library comes with other mapping implementations, which we discuss next.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了`dict`和`defaultdict`这两种映射类型，但标准库中还有其他映射实现，接下来我们将讨论它们。
- en: Variations of dict
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: dict的变体
- en: 'In this section is an overview of mapping types included in the standard library,
    besides `defaultdict`, already covered in [“defaultdict: Another Take on Missing
    Keys”](#defaultdict_sec).'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '本节概述了标准库中包含的映射类型，除了已在[“defaultdict: Another Take on Missing Keys”](#defaultdict_sec)中介绍的`defaultdict`。'
- en: collections.OrderedDict
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: collections.OrderedDict
- en: 'Now that the built-in `dict` also keeps the keys ordered since Python 3.6,
    the most common reason to use `OrderedDict` is writing code that is backward compatible
    with earlier Python versions. Having said that, Python’s documentation lists some
    remaining differences between `dict` and `OrderedDict`, which I quote here—only
    reordering the items for relevance in daily use:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Python 3.6开始，内置的`dict`也保持了键的有序性，使用`OrderedDict`的最常见原因是编写与早期Python版本向后兼容的代码。话虽如此，Python的文档列出了`dict`和`OrderedDict`之间的一些剩余差异，我在这里引用一下——只重新排列项目以便日常使用：
- en: The equality operation for `OrderedDict` checks for matching order.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderedDict`的相等操作检查匹配的顺序。'
- en: The `popitem()` method of `OrderedDict` has a different signature. It accepts
    an optional argument to specify which item is popped.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderedDict`的`popitem()`方法具有不同的签名。它接受一个可选参数来指定要弹出的项目。'
- en: '`OrderedDict` has a `move_to_end()` method to efficiently reposition an element
    to an endpoint.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderedDict`有一个`move_to_end()`方法，可以高效地将一个元素重新定位到末尾。'
- en: The regular `dict` was designed to be very good at mapping operations. Tracking
    insertion order was secondary.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常规的`dict`被设计为在映射操作方面非常出色。跟踪插入顺序是次要的。
- en: '`OrderedDict` was designed to be good at reordering operations. Space efficiency,
    iteration speed, and the performance of update operations were secondary.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderedDict`被设计为在重新排序操作方面表现良好。空间效率、迭代速度和更新操作的性能是次要的。'
- en: Algorithmically, `OrderedDict` can handle frequent reordering operations better
    than `dict`. This makes it suitable for tracking recent accesses (for example,
    in an LRU cache).
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从算法上讲，`OrderedDict`比`dict`更擅长处理频繁的重新排序操作。这使得它适用于跟踪最近的访问（例如，在LRU缓存中）。
- en: collections.ChainMap
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: collections.ChainMap
- en: 'A `ChainMap` instance holds a list of mappings that can be searched as one.
    The lookup is performed on each input mapping in the order it appears in the constructor
    call, and succeeds as soon as the key is found in one of those mappings. For example:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChainMap`实例保存了一个可以作为一个整体搜索的映射列表。查找是按照构造函数调用中出现的顺序在每个输入映射上执行的，并且一旦在这些映射中的一个中找到键，查找就成功了。例如：'
- en: '[PRE18]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `ChainMap` instance does not copy the input mappings, but holds references
    to them. Updates or insertions to a `ChainMap` only affect the first input mapping.
    Continuing from the previous example:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChainMap`实例不会复制输入映射，而是保留对它们的引用。对`ChainMap`的更新或插入只会影响第一个输入映射。继续上一个例子：'
- en: '[PRE19]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`ChainMap` is useful to implement interpreters for languages with nested scopes,
    where each mapping represents a scope context, from the innermost enclosing scope
    to the outermost scope. [The “ChainMap objects” section of the `collections` docs](https://fpy.li/3-8)
    has several examples of `ChainMap` usage, including this snippet inspired by the
    basic rules of variable lookup in Python:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChainMap`对于实现具有嵌套作用域的语言的解释器非常有用，其中每个映射表示一个作用域上下文，从最内部的封闭作用域到最外部作用域。[`collections`文档中的“ChainMap
    objects”部分](https://fpy.li/3-8)有几个`ChainMap`使用示例，包括这个受Python变量查找基本规则启发��代码片段：'
- en: '[PRE20]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[Example 18-14](ch18.html#environment_class_ex) shows a `ChainMap` subclass
    used to implement an interpreter for a subset of the Scheme programming language.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 18-14](ch18.html#environment_class_ex)展示了一个用于实现Scheme编程语言子集解释器的`ChainMap`子类。'
- en: collections.Counter
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: collections.Counter
- en: 'A mapping that holds an integer count for each key. Updating an existing key
    adds to its count. This can be used to count instances of hashable objects or
    as a multiset (discussed later in this section). `Counter` implements the `+`
    and `-` operators to combine tallies, and other useful methods such as `most_common([n])`,
    which returns an ordered list of tuples with the *n* most common items and their
    counts; see the [documentation](https://fpy.li/3-9). Here is `Counter` used to
    count letters in words:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一个为每个键保存整数计数的映射。更新现有键会增加其计数。这可用于计算可散列对象的实例数量或作为多重集（稍后在本节讨论）。`Counter` 实现了 `+`
    和 `-` 运算符来组合计数，并提供其他有用的方法，如 `most_common([n])`，它返回一个按顺序排列的元组列表，其中包含 *n* 个最常见的项目及其计数；请参阅[文档](https://fpy.li/3-9)。这里是
    `Counter` 用于计算单词中的字母：
- en: '[PRE21]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that the `'b'` and `'r'` keys are tied in third place, but `ct.most_common(3)`
    shows only three counts.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`'b'` 和 `'r'` 键并列第三，但 `ct.most_common(3)` 只显示了三个计数。
- en: To use `collections.Counter` as a multiset, pretend each key is an element in
    the set, and the count is the number of occurrences of that element in the set.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `collections.Counter` 用作多重集，假装每个键是集合中的一个元素，计数是该元素在集合中出现的次数。
- en: shelve.Shelf
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: shelve.Shelf
- en: The `shelve` module in the standard library provides persistent storage for
    a mapping of string keys to Python objects serialized in the `pickle` binary format.
    The curious name of `shelve` makes sense when you realize that pickle jars are
    stored on shelves.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的 `shelve` 模块为字符串键到以 `pickle` 二进制格式序列化的 Python 对象的映射提供了持久存储。当你意识到 pickle
    罐子存放在架子上时，`shelve` 这个奇怪的名字就有了意义。
- en: 'The `shelve.open` module-level function returns a `shelve.Shelf` instance—a
    simple key-value DBM database backed by the `dbm` module, with these characteristics:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`shelve.open` 模块级函数返回一个 `shelve.Shelf` 实例——一个简单的键-值 DBM 数据库，由 `dbm` 模块支持，具有以下特点：'
- en: '`shelve.Shelf` subclasses `abc.MutableMapping`, so it provides the essential
    methods we expect of a mapping type.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shelve.Shelf` 是 `abc.MutableMapping` 的子类，因此它提供了我们期望的映射类型的基本方法。'
- en: In addition, `shelve.Shelf` provides a few other I/O management methods, like
    `sync` and `close`.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，`shelve.Shelf` 提供了一些其他的 I/O 管理方法，如 `sync` 和 `close`。
- en: A `Shelf` instance is a context manager, so you can use a `with` block to make
    sure it is closed after use.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Shelf` 实例是一个上下文管理器，因此您可以使用 `with` 块来确保在使用后关闭它。'
- en: Keys and values are saved whenever a new value is assigned to a key.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当将新值分配给键时，键和值都会被保存。
- en: The keys must be strings.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键必须是字符串。
- en: The values must be objects that the `pickle` module can serialize.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值必须是 `pickle` 模块可以序列化的对象。
- en: The documentation for the [shelve](https://fpy.li/3-10), [dbm](https://fpy.li/3-11),
    and [pickle](https://fpy.li/3-12) modules provides more details and some caveats.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[shelve](https://fpy.li/3-10)、[dbm](https://fpy.li/3-11) 和 [pickle](https://fpy.li/3-12)
    模块的文档提供了更多细节和一些注意事项。'
- en: Warning
  id: totrans-259
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Python’s `pickle` is easy to use in the simplest cases, but has several drawbacks.
    Read Ned Batchelder’s [“Pickle’s nine flaws”](https://fpy.li/3-13) before adopting
    any solution involving `pickle`. In his post, Ned mentions other serialization
    formats to consider.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `pickle` 在最简单的情况下很容易使用，但也有一些缺点。在采用涉及 `pickle` 的任何解决方案之前，请阅读 Ned Batchelder
    的[“Pickle 的九个缺陷”](https://fpy.li/3-13)。在他的帖子中，Ned 提到了其他要考虑的序列化格式。
- en: '`OrderedDict`, `ChainMap`, `Counter`, and `Shelf` are ready to use but can
    also be customized by subclassing. In contrast, `UserDict` is intended only as
    a base class to be extended.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderedDict`、`ChainMap`、`Counter` 和 `Shelf` 都可以直接使用，但也可以通过子类化进行自定义。相比之下，`UserDict`
    只是作为一个可扩展的基类。'
- en: Subclassing UserDict Instead of dict
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过继承 `UserDict` 而不是 `dict` 来创建新的映射类型
- en: It’s better to create a new mapping type by extending `collections.UserDict`
    rather than `dict`. We realize that when we try to extend our `StrKeyDict0` from
    [Example 3-8](#ex_strkeydict0) to make sure that any keys added to the mapping
    are stored as `str`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最好通过扩展 `collections.UserDict` 来创建新的映射类型，而不是 `dict`。当我们尝试扩展我们的 `StrKeyDict0`（来自[示例
    3-8](#ex_strkeydict0)）以确保将任何添加到映射中的键存储为 `str` 时，我们意识到这一点。
- en: The main reason why it’s better to subclass `UserDict` rather than `dict` is
    that the built-in has some implementation shortcuts that end up forcing us to
    override methods that we can just inherit from `UserDict` with no problems.^([7](ch03.html#idm46582498801968))
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 更好地通过子类化 `UserDict` 而不是 `dict` 的主要原因是，内置类型有一些实现快捷方式，最终迫使我们覆盖我们可以从 `UserDict`
    继承而不会出现问题的方法。^([7](ch03.html#idm46582498801968))
- en: 'Note that `UserDict` does not inherit from `dict`, but uses composition: it
    has an internal `dict` instance, called `data`, which holds the actual items.
    This avoids undesired recursion when coding special methods like `__setitem__`,
    and simplifies the coding of `__contains__`, compared to [Example 3-8](#ex_strkeydict0).'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`UserDict` 不继承自 `dict`，而是使用组合：它有一个内部的 `dict` 实例，称为 `data`，用于保存实际的项目。这避免了在编写特殊方法如
    `__setitem__` 时出现不必要的递归，并简化了 `__contains__` 的编写，与[示例 3-8](#ex_strkeydict0)相比更加简单。
- en: 'Thanks to `UserDict`, `StrKeyDict` ([Example 3-9](#ex_strkeydict)) is more
    concise than `StrKeyDict0` ([Example 3-8](#ex_strkeydict0)), but it does more:
    it stores all keys as `str`, avoiding unpleasant surprises if the instance is
    built or updated with data containing nonstring keys.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `UserDict` 的存在，`StrKeyDict`（[示例 3-9](#ex_strkeydict)）比 `StrKeyDict0`（[示例
    3-8](#ex_strkeydict0)）更简洁，但它做得更多：它将所有键都存储为 `str`，避免了如果实例被构建或更新时包含非字符串键时可能出现的令人不快的情况。
- en: Example 3-9\. `StrKeyDict` always converts nonstring keys to `str` on insertion,
    update, and lookup
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-9\. `StrKeyDict` 在插入、更新和查找时总是将非字符串键转换为 `str`。
- en: '[PRE22]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[![1](assets/1.png)](#co_dictionaries_and_sets_CO7-1)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dictionaries_and_sets_CO7-1)'
- en: '`StrKeyDict` extends `UserDict`.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`StrKeyDict` 扩展了 `UserDict`。'
- en: '[![2](assets/2.png)](#co_dictionaries_and_sets_CO7-2)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dictionaries_and_sets_CO7-2)'
- en: '`__missing__` is exactly as in [Example 3-8](#ex_strkeydict0).'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`__missing__` 与[示例 3-8](#ex_strkeydict0)中的一样。'
- en: '[![3](assets/3.png)](#co_dictionaries_and_sets_CO7-3)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dictionaries_and_sets_CO7-3)'
- en: '`__contains__` is simpler: we can assume all stored keys are `str`, and we
    can check on `self.data` instead of invoking `self.keys()` as we did in `StrKeyDict0`.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`__contains__` 更简单：我们可以假定所有存储的键都是 `str`，并且可以在 `self.data` 上进行检查，而不是像在 `StrKeyDict0`
    中那样调用 `self.keys()`。'
- en: '[![4](assets/4.png)](#co_dictionaries_and_sets_CO7-4)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_dictionaries_and_sets_CO7-4)'
- en: '`__setitem__` converts any `key` to a `str`. This method is easier to overwrite
    when we can delegate to the `self.data` attribute.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`__setitem__` 将任何 `key` 转换为 `str`。当我们可以委托给 `self.data` 属性时，这种方法更容易被覆盖。'
- en: 'Because `UserDict` extends `abc.MutableMapping`, the remaining methods that
    make `StrKeyDict` a full-fledged mapping are inherited from `UserDict`, `MutableMapping`,
    or `Mapping`. The latter have several useful concrete methods, in spite of being
    abstract base classes (ABCs). The following methods are worth noting:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `UserDict` 扩展了 `abc.MutableMapping`，使得使 `StrKeyDict` 成为一个完整的映射的剩余方法都是从 `UserDict`、`MutableMapping`
    或 `Mapping` 继承的。尽管后者是抽象基类（ABC），但它们有几个有用的具体方法。以下方法值得注意：
- en: '`MutableMapping.update`'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`MutableMapping.update`'
- en: This powerful method can be called directly but is also used by `__init__` to
    load the instance from other mappings, from iterables of `(key, value)` pairs,
    and keyword arguments. Because it uses `self[key] = value` to add items, it ends
    up calling our implementation of `__setitem__`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这种强大的方法可以直接调用，但也被 `__init__` 用于从其他映射、从 `(key, value)` 对的可迭代对象和关键字参数加载实例。因为它使用
    `self[key] = value` 来添加项目，所以最终会调用我们的 `__setitem__` 实现。
- en: '`Mapping.get`'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mapping.get`'
- en: In `StrKeyDict0` ([Example 3-8](#ex_strkeydict0)), we had to code our own `get`
    to return the same results as `__getitem__`, but in [Example 3-9](#ex_strkeydict)
    we inherited `Mapping.get`, which is implemented exactly like `StrKeyDict0.get`
    (see the [Python source code](https://fpy.li/3-14)).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `StrKeyDict0`（[示例 3-8](#ex_strkeydict0)）中，我们不得不编写自己的 `get` 来返回与 `__getitem__`
    相同的结果，但在 [示例 3-9](#ex_strkeydict) 中，我们继承了 `Mapping.get`，它的实现与 `StrKeyDict0.get`
    完全相同（请参阅 [Python 源代码](https://fpy.li/3-14)）。
- en: Tip
  id: totrans-282
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Antoine Pitrou authored [PEP 455—Adding a key-transforming dictionary to collections](https://fpy.li/pep455)
    and a patch to enhance the `collections` module with a `TransformDict`, that is
    more general than `StrKeyDict` and preserves the keys as they are provided, before
    the transformation is applied. PEP 455 was rejected in May 2015—see Raymond Hettinger’s
    [rejection message](https://fpy.li/3-15). To experiment with `TransformDict`,
    I extracted Pitrou’s patch from [issue18986](https://fpy.li/3-16) into a standalone
    module ([*03-dict-set/transformdict.py*](https://fpy.li/3-17) in the [*Fluent
    Python* second edition code repository](https://fpy.li/code)).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 安托万·皮特鲁（Antoine Pitrou）撰写了 [PEP 455—向 collections 添加一个键转换字典](https://fpy.li/pep455)
    和一个增强 `collections` 模块的补丁，其中包括一个 `TransformDict`，比 `StrKeyDict` 更通用，并保留提供的键，然后应用转换。PEP
    455 在 2015 年 5 月被拒绝—请参阅雷蒙德·赫廷格的 [拒绝消息](https://fpy.li/3-15)。为了尝试 `TransformDict`，我从
    [issue18986](https://fpy.li/3-16) 中提取了皮特鲁的补丁，制作成了一个独立的模块（[*03-dict-set/transformdict.py*](https://fpy.li/3-17)
    在 [*Fluent Python* 第二版代码库](https://fpy.li/code) 中）。
- en: We know there are immutable sequence types, but how about an immutable mapping?
    Well, there isn’t a real one in the standard library, but a stand-in is available.
    That’s next.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道有不可变的序列类型，但不可变的映射呢？在标准库中确实没有真正的不可变映射，但有一个替代品可用。接下来是。
- en: Immutable Mappings
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变映射
- en: 'The mapping types provided by the standard library are all mutable, but you
    may need to prevent users from changing a mapping by accident. A concrete use
    case can be found, again, in a hardware programming library like *Pingo*, mentioned
    in [“The __missing__ Method”](#missing_method): the `board.pins` mapping represents
    the physical GPIO pins on the device. As such, it’s useful to prevent inadvertent
    updates to `board.pins` because the hardware can’t be changed via software, so
    any change in the mapping would make it inconsistent with the physical reality
    of the device.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供的映射类型都是可变的，但您可能需要防止用户意外更改映射。再次在硬件编程库中找到一个具体的用例，比如 *Pingo*，在 [“缺失方法”](#missing_method)
    中提到：`board.pins` 映射表示设备上的物理 GPIO 引脚。因此，防止意外更新 `board.pins` 是有用的，因为硬件不能通过软件更改，所以映射的任何更改都会使其与设备的物理现实不一致。
- en: The `types` module provides a wrapper class called `MappingProxyType`, which,
    given a mapping, returns a `mappingproxy` instance that is a read-only but dynamic
    proxy for the original mapping. This means that updates to the original mapping
    can be seen in the `mappingproxy`, but changes cannot be made through it. See
    [Example 3-10](#ex_MappingProxyType) for a brief demonstration.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`types` 模块提供了一个名为 `MappingProxyType` 的包装类，给定一个映射，它返回一个 `mappingproxy` 实例，这是原始映射的只读但动态代理。这意味着可以在
    `mappingproxy` 中看到对原始映射的更新，但不能通过它进行更改。参见 [示例 3-10](#ex_MappingProxyType) 进行简要演示。'
- en: Example 3-10\. `MappingProxyType` builds a read-only `mappingproxy` instance
    from a `dict`
  id: totrans-288
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-10\. `MappingProxyType` 从 `dict` 构建一个只读的 `mappingproxy` 实例。
- en: '[PRE23]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](assets/1.png)](#co_dictionaries_and_sets_CO8-1)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dictionaries_and_sets_CO8-1)'
- en: Items in `d` can be seen through `d_proxy`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`d` 中的项目可以通过 `d_proxy` 看到。'
- en: '[![2](assets/2.png)](#co_dictionaries_and_sets_CO8-2)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dictionaries_and_sets_CO8-2)'
- en: Changes cannot be made through `d_proxy`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 不能通过 `d_proxy` 进行更改。
- en: '[![3](assets/3.png)](#co_dictionaries_and_sets_CO8-3)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dictionaries_and_sets_CO8-3)'
- en: '`d_proxy` is dynamic: any change in `d` is reflected.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`d_proxy` 是动态的：`d` 中的任何更改都会反映出来。'
- en: 'Here is how this could be used in practice in the hardware programming scenario:
    the constructor in a concrete `Board` subclass would fill a private mapping with
    the pin objects, and expose it to clients of the API via a public `.pins` attribute
    implemented as a `mappingproxy`. That way the clients would not be able to add,
    remove, or change pins by accident.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在硬件编程场景中，这个方法在实践中可以这样使用：具体的 `Board` 子类中的构造函数会用 pin 对象填充一个私有映射，并通过一个实现为 `mappingproxy`
    的公共 `.pins` 属性将其暴露给 API 的客户端。这样，客户端就无法意外地添加、删除或更改 pin。
- en: Next, we’ll cover views—which allow high-performance operations on a `dict`,
    without unnecessary copying of data.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍视图—它允许在 `dict` 上进行高性能操作，而无需不必要地复制数据。
- en: Dictionary Views
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典视图
- en: The `dict` instance methods `.keys()`, `.values()`, and `.items()` return instances
    of classes called `dict_keys`, `dict_values`, and `dict_items`, respectively.
    These dictionary views are read-only projections of the internal data structures
    used in the `dict` implementation. They avoid the memory overhead of the equivalent
    Python 2 methods that returned lists duplicating data already in the target `dict`,
    and they also replace the old methods that returned iterators.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`dict`实例方法`.keys()`、`.values()`和`.items()`返回类`dict_keys`、`dict_values`和`dict_items`的实例，分别。这些字典视图是`dict`实现中使用的内部数据结构的只读投影。它们避免了等效Python
    2方法的内存开销，这些方法返回了重复数据的列表，这些数据已经在目标`dict`中，它们还替换了返回迭代器的旧方法。'
- en: '[Example 3-11](#ex_dict_values) shows some basic operations supported by all
    dictionary views.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例3-11](#ex_dict_values)展示了所有字典视图支持的一些基本操作。'
- en: Example 3-11\. The `.values()` method returns a view of the values in a `dict`
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例3-11。`.values()`方法返回字典中值的视图
- en: '[PRE24]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[![1](assets/1.png)](#co_dictionaries_and_sets_CO9-1)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dictionaries_and_sets_CO9-1)'
- en: The `repr` of a view object shows its content.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 视图对象的`repr`显示其内容。
- en: '[![2](assets/2.png)](#co_dictionaries_and_sets_CO9-2)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dictionaries_and_sets_CO9-2)'
- en: We can query the `len` of a view.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查询视图的`len`。
- en: '[![3](assets/3.png)](#co_dictionaries_and_sets_CO9-3)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_dictionaries_and_sets_CO9-3)'
- en: Views are iterable, so it’s easy to create lists from them.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 视图是可迭代的，因此很容易从中创建列表。
- en: '[![4](assets/4.png)](#co_dictionaries_and_sets_CO9-4)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_dictionaries_and_sets_CO9-4)'
- en: Views implement `__reversed__`, returning a custom iterator.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 视图实现了`__reversed__`，返回一个自定义迭代器。
- en: '[![5](assets/5.png)](#co_dictionaries_and_sets_CO9-5)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_dictionaries_and_sets_CO9-5)'
- en: We can’t use `[]` to get individual items from a view.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用`[]`从视图中获取单个项目。
- en: 'A view object is a dynamic proxy. If the source `dict` is updated, you can
    immediately see the changes through an existing view. Continuing from [Example 3-11](#ex_dict_values):'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 视图对象是动态代理。如果源`dict`被更新，您可以立即通过现有视图看到更改。继续自[示例3-11](#ex_dict_values)：
- en: '[PRE25]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The classes `dict_keys`, `dict_values`, and `dict_items` are internal: they
    are not available via `__builtins__` or any standard library module, and even
    if you get a reference to one of them, you can’t use it to create a view from
    scratch in Python code:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 类`dict_keys`、`dict_values`和`dict_items`是内部的：它们不通过`__builtins__`或任何标准库模块可用，即使你获得了其中一个的引用，也不能在Python代码中从头开始创建视图：
- en: '[PRE26]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `dict_values` class is the simplest dictionary view—it implements only the
    `__len__`, `__iter__`, and `__reversed__` special methods. In addition to these
    methods, `dict_keys` and `dict_items` implement several set methods, almost as
    many as the `frozenset` class. After we cover sets, we’ll have more to say about
    `dict_keys` and `dict_items` in [“Set Operations on dict Views”](#set_ops_dict_views_sec).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`dict_values`类是最简单的字典视图——它只实现了`__len__`、`__iter__`和`__reversed__`特殊方法。除了这些方法，`dict_keys`和`dict_items`实现了几个集合方法，几乎和`frozenset`类一样多。在我们讨论集合之后，我们将在[“字典视图上的集合操作”](#set_ops_dict_views_sec)中更多地谈到`dict_keys`和`dict_items`。'
- en: Now let’s see some rules and tips informed by the way `dict` is implemented
    under the hood.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一些由`dict`在幕后实现的规则和提示。
- en: Practical Consequences of How dict Works
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`dict`工作方式的实际后果'
- en: 'The hash table implementation of Python’s `dict` is very efficient, but it’s
    important to understand the practical effects of this design:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`dict`的哈希表实现非常高效，但重要的是要了解这种设计的实际影响：
- en: Keys must be hashable objects. They must implement proper `__hash__` and `__eq__`
    methods as described in [“What Is Hashable”](#what_is_hashable).
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键必须是可散列的对象。它们必须实现适当的`__hash__`和`__eq__`方法，如[“什么是可散列”](#what_is_hashable)中所述。
- en: Item access by key is very fast. A `dict` may have millions of keys, but Python
    can locate a key directly by computing the hash code of the key and deriving an
    index offset into the hash table, with the possible overhead of a small number
    of tries to find a matching entry.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过键访问项目非常快速。一个`dict`可能有数百万个键，但Python可以通过计算键的哈希码并推导出哈希表中的索引偏移量直接定位一个键，可能会有少量尝试来找到匹配的条目的开销。
- en: Key ordering is preserved as a side effect of a more compact memory layout for
    `dict` in CPython 3.6, which became an official language feature in 3.7.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键的顺序保留是CPython 3.6中`dict`更紧凑的内存布局的副作用，在3.7中成为官方语言特性。
- en: Despite its new compact layout, dicts inevitably have a significant memory overhead.
    The most compact internal data structure for a container would be an array of
    pointers to the items.^([8](ch03.html#idm46582498236432)) Compared to that, a
    hash table needs to store more data per entry, and Python needs to keep at least
    one-third of the hash table rows empty to remain efficient.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管其新的紧凑布局，字典不可避免地具有显着的内存开销。对于容器来说，最紧凑的内部数据结构将是一个指向项目的指针数组。^([8](ch03.html#idm46582498236432))
    相比之下，哈希表需要存储更多的数据，而Python需要保持至少三分之一的哈希表行为空以保持高效。
- en: To save memory, avoid creating instance attributes outside of the `__init__`
    method.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了节省内存，避免在`__init__`方法之外创建实例属性。
- en: That last tip about instance attributes comes from the fact that Python’s default
    behavior is to store instance attributes in a special `__dict__` attribute, which
    is a `dict` attached to each instance.^([9](ch03.html#idm46582498232544)) Since
    [PEP 412—Key-Sharing Dictionary](https://fpy.li/pep412) was implemented in Python
    3.3, instances of a class can share a common hash table, stored with the class.
    That common hash table is shared by the `__dict__` of each new instance that has
    the same attributes names as the first instance of that class when `__init__`
    returns. Each instance `__dict__` can then hold only its own attribute values
    as a simple array of pointers. Adding an instance attribute after `__init__` forces
    Python to create a new hash table just for the `__dict__` of that one instance
    (which was the default behavior for all instances before Python 3.3). According
    to PEP 412, this optimization reduces memory use by 10% to 20% for object-oriented
    programs.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条关于实例属性的提示来自于Python的默认行为是将实例属性存储在一个特殊的`__dict__`属性中，这是一个附加到每个实例的`dict`。自从Python
    3.3实现了[PEP 412—Key-Sharing Dictionary](https://fpy.li/pep412)以来，一个类的实例可以共享一个与类一起存储的公共哈希表。当`__init__`返回时，具有相同属性名称的每个新实例的`__dict__`都共享该公共哈希表。然后，每个实例的`__dict__`只能保存自己的属性值作为指针的简单数组。在`__init__`之后添加一个实例属性会强制Python为`__dict__`创建一个新的哈希表，用于该实例的`__dict__`（这是Python
    3.3之前所有实例的默认行为）。根据PEP 412，这种优化可以减少面向对象程序的内存使用量10%至20%。
- en: The details of the compact layout and key-sharing optimizations are rather complex.
    For more, please read [“Internals of sets and dicts”](https://fpy.li/hashint)
    at [*fluentpython.com*](http://fluentpython.com).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 紧凑布局和键共享优化的细节相当复杂。更多信息，请阅读[*fluentpython.com*](http://fluentpython.com)上的[“集合和字典的内部”](https://fpy.li/hashint)。
- en: Now let’s dive into sets.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入研究集合。
- en: Set Theory
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合理论
- en: Sets are not new in Python, but are still somewhat underused. The `set` type
    and its immutable sibling `frozenset` first appeared as modules in the Python
    2.3 standard library, and were promoted to built-ins in Python 2.6.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，集合并不新鲜，但仍然有些被低估。`set`类型及其不可变的姊妹`frozenset`首次出现在Python 2.3标准库中作为模块，并在Python
    2.6中被提升为内置类型。
- en: Note
  id: totrans-331
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'In this book, I use the word “set” to refer both to `set` and `frozenset`.
    When talking specifically about the `set` class, I use constant width font: `set`.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我使用“集合”一词来指代`set`和`frozenset`。当专门讨论`set`类��，我使用等宽字体：`set`。
- en: 'A set is a collection of unique objects. A basic use case is removing duplication:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是一组唯一对象。一个基本用例是去除重复项：
- en: '[PRE27]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Tip
  id: totrans-335
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you want to remove duplicates but also preserve the order of the first occurrence
    of each item, you can now use a plain `dict` to do it, like this:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想去除重复项但又保留每个项目的第一次出现的顺序，你现在可以使用一个普通的`dict`来实现，就像这样：
- en: '[PRE28]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Set elements must be hashable. The `set` type is not hashable, so you can’t
    build a `set` with nested `set` instances. But `frozenset` is hashable, so you
    can have `frozenset` elements inside a `set`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 集合元素必须是可散列的。`set`类型不可散列，因此你不能用嵌套的`set`实例构建一个`set`。但是`frozenset`是可散列的，所以你可以在`set`中包含`frozenset`元素。
- en: In addition to enforcing uniqueness, the set types implement many set operations
    as infix operators, so, given two sets `a` and `b`, `a | b` returns their union,
    `a & b` computes the intersection, `a - b` the difference, and `a ^ b` the symmetric
    difference. Smart use of set operations can reduce both the line count and the
    execution time of Python programs, at the same time making code easier to read
    and reason about—by removing loops and conditional logic.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 除了强制唯一性外，集合类型还实现了许多集合操作作为中缀运算符，因此，给定两个集合`a`和`b`，`a | b`返回它们的并集，`a & b`计算交集，`a
    - b`表示差集，`a ^ b`表示对称差。巧妙地使用集合操作可以减少Python程序的行数和执行时间，同时使代码更易于阅读和理解——通过消除循环和条件逻辑。
- en: For example, imagine you have a large set of email addresses (the `haystack`)
    and a smaller set of addresses (the `needles`) and you need to count how many
    `needles` occur in the `haystack`. Thanks to `set` intersection (the `&` operator)
    you can code that in a simple line (see [Example 3-12](#ex_set_ops_ex)).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下你有一个大型的电子邮件地址集合（`haystack`）和一个较小的地址集合（`needles`），你需要计算`needles`在`haystack`中出现的次数。由于集合交集（`&`运算符），你可以用一行代码实现这个功能（参见[示例
    3-12](#ex_set_ops_ex)）。
- en: Example 3-12\. Count occurrences of needles in a haystack, both of type set
  id: totrans-341
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-12. 计算在一个集合中针的出现次数，两者都是集合类型
- en: '[PRE29]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Without the intersection operator, you’d have to write [Example 3-13](#ex_set_loop_ex)
    to accomplish the same task as [Example 3-12](#ex_set_ops_ex).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 没有交集运算符，你将不得不编写[示例 3-13](#ex_set_loop_ex)来完成与[示例 3-12](#ex_set_ops_ex)相同的任务。
- en: Example 3-13\. Count occurrences of needles in a haystack (same end result as
    [Example 3-12](#ex_set_ops_ex))
  id: totrans-344
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-13. 计算在一个集合中针的出现次数（与[示例 3-12](#ex_set_ops_ex)的结果相同）
- en: '[PRE30]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[Example 3-12](#ex_set_ops_ex) runs slightly faster than [Example 3-13](#ex_set_loop_ex).
    On the other hand, [Example 3-13](#ex_set_loop_ex) works for any iterable objects
    `needles` and `haystack`, while [Example 3-12](#ex_set_ops_ex) requires that both
    be sets. But, if you don’t have sets on hand, you can always build them on the
    fly, as shown in [Example 3-14](#ex_set_ops_ex2).'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-12](#ex_set_ops_ex)比[示例 3-13](#ex_set_loop_ex)运行速度稍快。另一方面，[示例 3-13](#ex_set_loop_ex)适用于任何可迭代对象`needles`和`haystack`，而[示例
    3-12](#ex_set_ops_ex)要求两者都是集合。但是，如果你手头没有集合，你可以随时动态构建它们，就像[示例 3-14](#ex_set_ops_ex2)中所示。'
- en: Example 3-14\. Count occurrences of needles in a haystack; these lines work
    for any iterable types
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-14. 计算在一个集合中针的出现次数；这些行适用于任何可迭代类型
- en: '[PRE31]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Of course, there is an extra cost involved in building the sets in [Example 3-14](#ex_set_ops_ex2),
    but if either the `needles` or the `haystack` is already a set, the alternatives
    in [Example 3-14](#ex_set_ops_ex2) may be cheaper than [Example 3-13](#ex_set_loop_ex).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在构建[示例 3-14](#ex_set_ops_ex2)中的集合时会有额外的成本，但如果`needles`或`haystack`中的一个已经是一个集合，那么[示例
    3-14](#ex_set_ops_ex2)中的替代方案可能比[示例 3-13](#ex_set_loop_ex)更便宜。
- en: Any one of the preceding examples are capable of searching 1,000 elements in
    a `haystack` of 10,000,000 items in about 0.3 milliseconds—that’s close to 0.3
    microseconds per element.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 任何前述示例中的一个都能在`haystack`中搜索 1,000 个元素，其中包含 10,000,000 个项目，大约需要 0.3 毫秒，即每个元素接近
    0.3 微秒。
- en: Besides the extremely fast membership test (thanks to the underlying hash table),
    the `set` and `frozenset` built-in types provide a rich API to create new sets
    or, in the case of `set`, to change existing ones. We will discuss the operations
    shortly, but first a note about syntax.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 除了极快的成员测试（由底层哈希表支持），`set` 和 `frozenset` 内置类型提供了丰富的 API 来创建新集合或在`set`的情况下更改现有集合。我们将很快讨论这些操作，但首先让我们谈谈语法。
- en: Set Literals
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合字面量
- en: 'The syntax of `set` literals—`{1}`, `{1, 2}`, etc.—looks exactly like the math
    notation, with one important exception: there’s no literal notation for the empty
    `set`, so we must remember to write `set()`.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`字面量的语法—`{1}`，`{1, 2}`等—看起来与数学符号一样，但有一个重要的例外：没有空`set`的字面表示，因此我们必须记得写`set()`。'
- en: Syntax Quirk
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法怪癖
- en: 'Don’t forget that to create an empty `set`, you should use the constructor
    without an argument: `set()`. If you write `{}`, you’re creating an empty `dict`—this
    hasn’t changed in Python 3.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，要创建一个空的`set`，应该使用没有参数的构造函数：`set()`。如果写`{}`，你将创建一个空的`dict`—在 Python 3 中这一点没有改变。
- en: 'In Python 3, the standard string representation of sets always uses the `{…}`
    notation, except for the empty set:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 3 中，集合的标准字符串表示总是使用`{…}`符号，除了空集：
- en: '[PRE32]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Literal `set` syntax like `{1, 2, 3}` is both faster and more readable than
    calling the constructor (e.g., `set([1, 2, 3])`). The latter form is slower because,
    to evaluate it, Python has to look up the `set` name to fetch the constructor,
    then build a list, and finally pass it to the constructor. In contrast, to process
    a literal like `{1, 2, 3}`, Python runs a specialized `BUILD_SET` bytecode.^([10](ch03.html#idm46582497899520))
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 字面`set`语法如`{1, 2, 3}`比调用构造函数（例如，`set([1, 2, 3])`）更快且更易读。后一种形式较慢，因为要评估它，Python
    必须查找`set`名称以获取构造函数，然后构建一个列表，最后将其传递给构造函数。相比之下，要处理像`{1, 2, 3}`这样的字面量，Python 运行一个专门的`BUILD_SET`字节码。^([10](ch03.html#idm46582497899520))
- en: 'There is no special syntax to represent `frozenset` literals—they must be created
    by calling the constructor. The standard string representation in Python 3 looks
    like a `frozenset` constructor call. Note the output in the console session:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 没有特殊的语法来表示`frozenset`字面量—它们必须通过调用构造函数创建。在 Python 3 中的标准字符串表示看起来像一个`frozenset`构造函数调用。请注意控制台会话中的输出：
- en: '[PRE33]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Speaking of syntax, the idea of listcomps was adapted to build sets as well.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到语法，列表推导的想法也被用来构建集合。
- en: Set Comprehensions
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合推导式
- en: Set comprehensions (*setcomps*) were added way back in Python 2.7, together
    with the dictcomps that we saw in [“dict Comprehensions”](#dictcomp_sec). [Example 3-15](#ex_setcomp)
    shows how.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 集合推导式（*setcomps*）在 Python 2.7 中添加，与我们在[“dict推导式”](#dictcomp_sec)中看到的 dictcomps
    一起。[示例 3-15](#ex_setcomp)展示了如何。
- en: Example 3-15\. Build a set of Latin-1 characters that have the word “SIGN” in
    their Unicode names
  id: totrans-364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-15\. 构建一个拉丁-1字符集，其中 Unicode 名称中包含“SIGN”一词
- en: '[PRE34]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[![1](assets/1.png)](#co_dictionaries_and_sets_CO10-1)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_dictionaries_and_sets_CO10-1)'
- en: Import `name` function from `unicodedata` to obtain character names.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 从`unicodedata`导入`name`函数以获取字符名称。
- en: '[![2](assets/2.png)](#co_dictionaries_and_sets_CO10-2)'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_dictionaries_and_sets_CO10-2)'
- en: Build set of characters with codes from 32 to 255 that have the word `'SIGN'`
    in their names.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 构建字符集，其中字符代码从 32 到 255，名称中包含 `'SIGN'` 一词。
- en: The order of the output changes for each Python process, because of the salted
    hash mentioned in [“What Is Hashable”](#what_is_hashable).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的顺序会因为[“什么是可哈希的”](#what_is_hashable)中提到的盐哈希而对每个 Python 进程进行更改。
- en: Syntax matters aside, let’s now consider the behavior of sets.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 语法问题在一边，现在让我们考虑集合的行为。
- en: Practical Consequences of How Sets Work
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合工作方式的实际后果
- en: 'The `set` and `frozenset` types are both implemented with a hash table. This
    has these effects:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`set` 和 `frozenset` 类型都是使用哈希表实现的。这会产生以下影响：'
- en: Set elements must be hashable objects. They must implement proper `__hash__`
    and `__eq__` methods as described in [“What Is Hashable”](#what_is_hashable).
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合元素必须是可哈希对象。它们必须实现适当的`__hash__`和`__eq__`方法，如[“什么是可哈希的”](#what_is_hashable)中所述。
- en: Membership testing is very efficient. A set may have millions of elements, but
    an element can be located directly by computing its hash code and deriving an
    index offset, with the possible overhead of a small number of tries to find a
    matching element or exhaust the search.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员测试非常高效。一个集合可能有数百万个元素，但可以通过计算其哈希码并推导出索引偏移量来直接定位一个元素，可能需要少量尝试来找到匹配的元素或耗尽搜索。
- en: Sets have a significant memory overhead, compared to a low-level array pointers
    to its elements—which would be more compact but also much slower to search beyond
    a handful of elements.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与低级数组指针相比，集合具有显着的内存开销—后者更紧凑但搜索超过少量元素时也更慢。
- en: Element ordering depends on insertion order, but not in a useful or reliable
    way. If two elements are different but have the same hash code, their position
    depends on which element is added first.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素顺序取决于插入顺序，但并不是以有用或可靠的方式。如果两个元素不同但具有相同的哈希码，则它们的位置取决于哪个元素先添加。
- en: Adding elements to a set may change the order of existing elements. That’s because
    the algorithm becomes less efficient if the hash table is more than two-thirds
    full, so Python may need to move and resize the table as it grows. When this happens,
    elements are reinserted and their relative ordering may change.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向集合添加元素可能会改变现有元素的顺序。这是因为如果哈希表超过三分之二满，算法会变得不那么高效，因此 Python 可能需要在增长时移动和调整表格。当发生这种情况时，元素将被重新插入，它们的相对顺序可能会改变。
- en: See [“Internals of sets and dicts”](https://fpy.li/hashint) at [*fluentpython.com*](http://fluentpython.com)
    for details.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 详细信息请参见[“集合和字典的内部”](https://fpy.li/hashint)在[*fluentpython.com*](http://fluentpython.com)。
- en: Let’s now review the rich assortment of operations provided by sets.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看集合提供的丰富操作。
- en: Set Operations
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合操作
- en: '[Figure 3-2](#set_uml) gives an overview of the methods you can use on mutable
    and immutable sets. Many of them are special methods that overload operators,
    such as `&` and `>=`. [Table 3-2](#set_operators_tbl) shows the math set operators
    that have corresponding operators or methods in Python. Note that some operators
    and methods perform in-place changes on the target set (e.g., `&=`, `difference_update`,
    etc.). Such operations make no sense in the ideal world of mathematical sets,
    and are not implemented in `frozenset`.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '|  |  | `s.difference(it, …)` | `s` 和从可迭代对象 `it` 构建的所有集合的差集 |'
- en: Tip
  id: totrans-383
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '| S ⊆ Z | `s <= z` | `s.__le__(z)` | `s` 是 `z` 集合的子集 |'
- en: The infix operators in [Table 3-2](#set_operators_tbl) require that both operands
    be sets, but all other methods take one or more iterable arguments. For example,
    to produce the union of four collections, `a`, `b`, `c`, and `d`, you can call
    `a.union(b, c, d)`, where `a` must be a `set`, but `b`, `c`, and `d` can be iterables
    of any type that produce hashable items. If you need to create a new set with
    the union of four iterables, instead of updating an existing set, you can write
    `{*a, *b, *c, *d}` since Python 3.5 thanks to [PEP 448—Additional Unpacking Generalizations](https://fpy.li/pep448).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '[费曼学习法](https://wiki.example.org/feynmans_learning_method)的灵感源于**理查德·费曼**，这位物理学诺贝尔奖得主。'
- en: '![UML class diagram for `Set` and `MutableSet`](assets/flpy_0302.png)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![`Set` 和 `MutableSet` 的 UML 类图](assets/flpy_0302.png)'
- en: Figure 3-2\. Simplified UML class diagram for `MutableSet` and its superclasses
    from `collections.abc` (names in italic are abstract classes and abstract methods;
    reverse operator methods omitted for brevity).
  id: totrans-386
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '|  |  |  |  |'
- en: 'Table 3-2\. Mathematical set operations: these methods either produce a new
    set or update the target set in place, if it’s mutable'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '| 数学符号 | Python 运算符 | 方法 | 描述 |'
- en: '| Math symbol | Python operator | Method | Description |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `s.intersection(it, …)` | `s` 和从可迭代对象 `it` 构建的所有集合的交集 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '|  | `s -= z` | `s.__isub__(z)` | `s` 更新为 `s` 和 `z` 的差集 |'
- en: '| S ∩ Z | `s & z` | `s.__and__(z)` | Intersection of `s` and `z` |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| S \ Z | `s - z` | `s.__sub__(z)` | `s` 和 `z` 的相对补集或差集 |'
- en: '|  | `z & s` | `s.__rand__(z)` | Reversed `&` operator |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '|  | `z ^ s` | `s.__rxor__(z)` | 反转 `^` 运算符 |'
- en: '|  |  | `s.intersection(it, …)` | Intersection of `s` and all sets built from
    iterables `it`, etc. |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `s.difference_update(it, …)` | `s` 更新为 `s` 和从可迭代对象 `it` 构建的所有集合的差集
    |'
- en: '|  | `s &= z` | `s.__iand__(z)` | `s` updated with intersection of `s` and
    `z` |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '|  | `s &= z` | `s.__iand__(z)` | `s` 更新为 `s` 和 `z` 的交集 |'
- en: '|  |  | `s.intersection_update(it, …)` | `s` updated with intersection of `s`
    and all sets built from iterables `it`, etc. |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `s.union(it, …)` | `s` 和从可迭代对象 `it` 构建的所有集合的并集 |'
- en: '|  |  |  |  |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '[图 3-2](#set_uml) 概述了可变和不可变集合上可用的方法。其中许多是重载运算符的特殊方法，如 `&` 和 `>=`。[表 3-2](#set_operators_tbl)
    显示了在 Python 中具有对应运算符或方法的数学集合运算符。请注意，一些运算符和方法会对目标集合进行就地更改（例如 `&=`，`difference_update`
    等）。这样的操作在数学集合的理想世界中毫无意义，并且在 `frozenset` 中未实现。'
- en: '| S ∪ Z | `s &#124; z` | `s.__or__(z)` | Union of `s` and `z` |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `s.update(it, …)` | `s` 更新为 `s` 和从可迭代对象 `it` 构建的所有集合的并集 |'
- en: '|  | `z &#124; s` | `s.__ror__(z)` | Reversed `&#124;` |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '|  | `z & s` | `s.__rand__(z)` | 反转 `&` 运算符 |'
- en: '|  |  | `s.union(it, …)` | Union of `s` and all sets built from iterables `it`,
    etc. |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  |'
- en: '|  | `s &#124;= z` | `s.__ior__(z)` | `s` updated with union of `s` and `z`
    |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| S ∆ Z | `s ^ z` | `s.__xor__(z)` | 对称差集（`s & z` 的补集） |'
- en: '|  |  | `s.update(it, …)` | `s` updated with union of `s` and all sets built
    from iterables `it`, etc. |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: 表 3-2\. 数学集合操作：这些方法要么生成新集合，要么在原地更新目标集合（如果可变）
- en: '|  |  |  |  |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  |'
- en: '| S \ Z | `s - z` | `s.__sub__(z)` | Relative complement or difference between
    `s` and `z` |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| S ∩ Z = ∅ |  | `s.isdisjoint(z)` | `s` 和 `z` 互不相交（没有共同元素） |'
- en: '|  | `z - s` | `s.__rsub__(z)` | Reversed `-` operator |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `s.symmetric_difference(it)` | `s & set(it)` 的补集 |'
- en: '|  |  | `s.difference(it, …)` | Difference between `s` and all sets built from
    iterables `it`, etc. |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| S ∩ Z | `s & z` | `s.__and__(z)` | `s` 和 `z` 的交集 |'
- en: '|  | `s -= z` | `s.__isub__(z)` | `s` updated with difference between `s` and
    `z` |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: 使用费曼的技巧，你可以在短短`20 min`内深入理解知识点，而且记忆深刻，*难以遗忘*。
- en: '|  |  | `s.difference_update(it, …)` | `s` updated with difference between
    `s` and all sets built from iterables `it`, etc. |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '|  | `s ^= z` | `s.__ixor__(z)` | `s` 更新为 `s` 和 `z` 的对称差集 |'
- en: '|  |  |  |  |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| S ∪ Z | `s &#124; z` | `s.__or__(z)` | `s` 和 `z` 的并集 |'
- en: '| S ∆ Z | `s ^ z` | `s.__xor__(z)` | Symmetric difference (the complement of
    the intersection `s & z`) |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| e ∈ S | `e in s` | `s.__contains__(e)` | 元素 `e` 是 `s` 的成员 |'
- en: '|  | `z ^ s` | `s.__rxor__(z)` | Reversed `^` operator |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `s.intersection_update(it, …)` | `s` 更新为 `s` 和从可迭代对象 `it` 构建的所有集合的交集
    |'
- en: '|  |  | `s.symmetric_difference(it)` | Complement of `s & set(it)` |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| 数学符号 | Python 运算符 | 方法 | 描述 |'
- en: '|  | `s ^= z` | `s.__ixor__(z)` | `s` updated with symmetric difference of
    `s` and `z` |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: 表 3-3\. 返回布尔值的集合比较运算符和方法
- en: '|  |  | `s.symmetric_difference_update(it, …)` | `s` updated with symmetric
    difference of `s` and all sets built from iterables `it`, etc. |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `s.symmetric_difference_update(it, …)` | `s` 更新为 `s` 和从可迭代对象 `it` 构建的所有集合的对称差
    |'
- en: '[Table 3-3](#set_comparison_tbl) lists set predicates: operators and methods
    that return `True` or `False`.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Table 3-3\. Set comparison operators and methods that return a bool
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '|  |  |  |  |'
- en: '| Math symbol | Python operator | Method | Description |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '[表 3-3](#set_comparison_tbl) 列出了集合谓词：返回 `True` 或 `False` 的运算符和方法。'
- en: '| --- | --- | --- | --- |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| S ∩ Z = ∅ |  | `s.isdisjoint(z)` | `s` and `z` are disjoint (no elements
    in common) |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '|  |  |  |  |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: 图 3-2\. `MutableSet` 及其来自 `collections.abc` 的超类的简化 UML 类图（斜体名称为抽象类和抽象方法；为简洁起见省略了反转运算符方法）
- en: '| e ∈ S | `e in s` | `s.__contains__(e)` | Element `e` is a member of `s` |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '|  | `z &#124; s` | `s.__ror__(z)` | 反转 `&#124;` 运算符 |'
- en: '|  |  |  |  |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '|  | `z - s` | `s.__rsub__(z)` | 反转 `-` 运算符 |'
- en: '| S ⊆ Z | `s <= z` | `s.__le__(z)` | `s` is a subset of the `z` set |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '|  | `s &#124;= z` | `s.__ior__(z)` | `s` 更新为 `s` 和 `z` 的并集 |'
- en: '|  |  | `s.issubset(it)` | `s` is a subset of the set built from the iterable
    `it` |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `s.issubset(it)` | `s` 是从可迭代对象 `it` 构建的集合的子集 |'
- en: '|  |  |  |  |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  |'
- en: '| S ⊂ Z | `s < z` | `s.__lt__(z)` | `s` is a proper subset of the `z` set |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| S ⊂ Z | `s < z` | `s.__lt__(z)` | `s` 是 `z` 集合的真子集 |'
- en: '|  |  |  |  |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  |'
- en: '| S ⊇ Z | `s >= z` | `s.__ge__(z)` | `s` is a superset of the `z` set |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| S ⊇ Z | `s >= z` | `s.__ge__(z)` | `s` 是 `z` 集合的超集 |'
- en: '|  |  | `s.issuperset(it)` | `s` is a superset of the set built from the iterable
    `it` |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '|  |  | `s.issuperset(it)` | `s` 是从可迭代对象 `it` 构建的集合的超集 |'
- en: '|  |  |  |  |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  |'
- en: '| S ⊃ Z | `s > z` | `s.__gt__(z)` | `s` is a proper superset of the `z` set
    |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| S ⊃ Z | `s > z` | `s.__gt__(z)` | `s` 是 `z` 集合的真超集 |'
- en: '|  |  |  |  |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  |'
- en: In addition to the operators and methods derived from math set theory, the set
    types implement other methods of practical use, summarized in [Table 3-4](#set_methods_tbl).
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从数学集合理论中派生的运算符和方法外，集合类型还实现了其他实用的方法，总结在[表 3-4](#set_methods_tbl)中。
- en: Table 3-4\. Additional set methods
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-4\. 额外的集合方法
- en: '|  | set | frozenset |   |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '|  | 集合 | 冻结集合 |   |'
- en: '| --- | --- | --- | --- |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `s.add(e)` | ● |  | Add element `e` to `s` |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| `s.add(e)` | ��� |  | 向 `s` 添加元素 `e` |'
- en: '| `s.clear()` | ● |  | Remove all elements of `s` |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| `s.clear()` | ● |  | 移除 `s` 的所有元素 |'
- en: '| `s.copy()` | ● | ● | Shallow copy of `s` |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| `s.copy()` | ● | ● | `s` 的浅复制 |'
- en: '| `s.discard(e)` | ● |  | Remove element `e` from `s` if it is present |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| `s.discard(e)` | ● |  | 如果存在则从 `s` 中移除元素 `e` |'
- en: '| `s.__iter__()` | ● | ● | Get iterator over `s` |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| `s.__iter__()` | ● | ● | 获取 `s` 的迭代器 |'
- en: '| `s.__len__()` | ● | ● | `len(s)` |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| `s.__len__()` | ● | ● | `len(s)` |'
- en: '| `s.pop()` | ● |  | Remove and return an element from `s`, raising `KeyError`
    if `s` is empty |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| `s.pop()` | ● |  | 从 `s` 中移除并返回一个元素，如果 `s` 为空则引发 `KeyError` |'
- en: '| `s.remove(e)` | ● |  | Remove element `e` from `s`, raising `KeyError` if
    `e not in s` |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| `s.remove(e)` | ● |  | 从 `s` 中移除元素 `e`，如果 `e` 不在 `s` 中则引发 `KeyError` |'
- en: This completes our overview of the features of sets. As promised in [“Dictionary
    Views”](#dictionary_views_sec), we’ll now see how two of the dictionary view types
    behave very much like a `frozenset`.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对集合特性的概述。如[“字典视图”](#dictionary_views_sec)中承诺的，我们现在将看到两种字典视图类型的行为非常类似于
    `frozenset`。
- en: Set Operations on dict Views
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典视图上的集合操作
- en: '[Table 3-5](#view_methods_tbl) shows that the view objects returned by the
    `dict` methods `.keys()` and `.items()` are remarkably similar to `frozenset`.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-5](#view_methods_tbl) 显示了由 `dict` 方法 `.keys()` 和 `.items()` 返回的视图对象与 `frozenset`
    非常相似。'
- en: Table 3-5\. Methods implemented by `frozenset`, `dict_keys`, and `dict_items`
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-5\. `frozenset`、`dict_keys` 和 `dict_items` 实现的方法
- en: '|  | frozenset | dict_keys | dict_items | Description |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '|  | 冻结集合 | dict_keys | dict_items | 描述 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `s.__and__(z)` | ● | ● | ● | `s & z` (intersection of `s` and `z`) |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '| `s.__and__(z)` | ● | ● | ● | `s & z`（`s` 和 `z` 的交集） |'
- en: '| `s.__rand__(z)` | ● | ● | ● | Reversed `&` operator |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '| `s.__rand__(z)` | ● | ● | ● | 反转 `&` 运算符 |'
- en: '| `s.__contains__()` | ● | ● | ● | `e in s` |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '| `s.__contains__()` | ● | ● | ● | `e in s` |'
- en: '| `s.copy()` | ● |  |  | Shallow copy of `s` |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '| `s.copy()` | ● |  |  | `s` 的浅复制 |'
- en: '| `s.difference(it, …)` | ● |  |  | Difference between `s` and iterables `it`,
    etc. |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '| `s.difference(it, …)` | ● |  |  | `s` 和可迭代对象 `it` 等的差集 |'
- en: '| `s.intersection(it, …)` | ● |  |  | Intersection of `s` and iterables `it`,
    etc. |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '| `s.intersection(it, …)` | ● |  |  | `s` 和可迭代对象 `it` 等的交集 |'
- en: '| `s.isdisjoint(z)` | ● | ● | ● | `s` and `z` are disjoint (no elements in
    common) |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '| `s.isdisjoint(z)` | ● | ● | ● | `s` 和 `z` 不相交（没有共同元素） |'
- en: '| `s.issubset(it)` | ● |  |  | `s` is a subset of iterable `it` |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '| `s.issubset(it)` | ● |  |  | `s` 是可迭代对象 `it` 的子集 |'
- en: '| `s.issuperset(it)` | ● |  |  | `s` is a superset of iterable `it` |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '| `s.issuperset(it)` | ● |  |  | `s` 是可迭代对象 `it` 的超集 |'
- en: '| `s.__iter__()` | ● | ● | ● | Get iterator over `s` |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| `s.__iter__()` | ● | ● | ● | 获取 `s` 的迭代器 |'
- en: '| `s.__len__()` | ● | ● | ● | `len(s)` |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| `s.__len__()` | ● | ● | ● | `len(s)` |'
- en: '| `s.__or__(z)` | ● | ● | ● | `s &#124; z` (union of `s` and `z`) |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| `s.__or__(z)` | ● | ● | ● | `s &#124; z`（`s` 和 `z` 的并集） |'
- en: '| `s.__ror__()` | ● | ● | ● | Reversed `&#124;` operator |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| `s.__ror__()` | ● | ● | ● | 反转 `&#124;` 运算符 |'
- en: '| `s.__reversed__()` |  | ● | ● | Get iterator over `s` in reverse order |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| `s.__reversed__()` |  | ● | ● | 获取 `s` 的反向迭代器 |'
- en: '| `s.__rsub__(z)` | ● | ● | ● | Reversed `-` operator |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| `s.__rsub__(z)` | ● | ● | ● | 反转 `-` 运算符 |'
- en: '| `s.__sub__(z)` | ● | ● | ● | `s - z` (difference between `s` and `z`) |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| `s.__sub__(z)` | ● | ● | ● | `s - z`（`s` 和 `z` 之间的差集） |'
- en: '| `s.symmetric_difference(it)` | ● |  |  | Complement of `s & set(it)` |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| `s.symmetric_difference(it)` | ● |  |  | `s & set(it)` 的补集 |'
- en: '| `s.union(it, …)` | ● |  |  | Union of `s` and iterables `it`, etc. |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| `s.union(it, …)` | ● |  |  | `s` 和可迭代对象 `it` 等的并集 |'
- en: '| `s.__xor__()` | ● | ● | ● | `s ^ z` (symmetric difference of `s` and `z`)
    |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| `s.__xor__()` | ● | ● | ● | `s ^ z`（`s` 和 `z` 的对称差集） |'
- en: '| `s.__rxor__()` | ● | ● | ● | Reversed `^` operator |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| `s.__rxor__()` | ● | ● | ● | 反转 `^` 运算符 |'
- en: In particular, `dict_keys` and `dict_items` implement the special methods to
    support the powerful set operators `&` (intersection), `|` (union), `-` (difference),
    and `^` (symmetric difference).
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，`dict_keys` 和 `dict_items` 实现了支持强大的集合运算符 `&`（交集）、`|`（并集）、`-`（差集）和 `^`（对称差集）的特殊方法。
- en: 'For example, using `&` is easy to get the keys that appear in two dictionaries:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用 `&` 很容易获得出现在两个字典中的键：
- en: '[PRE35]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Note that the return value of `&` is a `set`. Even better: the set operators
    in dictionary views are compatible with `set` instances. Check this out:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 `&` 的返回值是一个 `set`。更好的是：字典视图中的集合运算符与 `set` 实例兼容。看看这个：
- en: '[PRE36]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Warning
  id: totrans-474
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'A `dict_items` view only works as a set if all values in the `dict` are hashable.
    Attempting set operations on a `dict_items` view with an unhashable value raises
    `TypeError: unhashable type ''T''`, with `T` as the type of the offending value.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '一个 `dict_items` 视图仅在字典中的所有值都是可哈希的情况下才能作为集合使用。尝试在具有不可哈希值的 `dict_items` 视图上进行集合操作会引发
    `TypeError: unhashable type ''T''`，其中 `T` 是有问题值的类型。'
- en: On the other hand, a `dict_keys` view can always be used as a set, because every
    key is hashable—by definition.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`dict_keys` 视图始终可以用作集合，因为每个键都是可哈希的—按定义。
- en: Using set operators with views will save a lot of loops and ifs when inspecting
    the contents of dictionaries in your code. Let Python’s efficient implementation
    in C work for you!
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 使用视图和集合运算符将节省大量循环和条件语句，当检查代码中字典内容时，让 Python 在 C 中高效实现为您工作！
- en: With this, we can wrap up this chapter.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们可以结束这一章了。
- en: Chapter Summary
  id: totrans-479
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节总结
- en: 'Dictionaries are a keystone of Python. Over the years, the familiar `{k1: v1,
    k2: v2}` literal syntax was enhanced to support unpacking with `**`, pattern matching,
    as well as `dict` comprehensions.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '字典是 Python 的基石。多年来，熟悉的 `{k1: v1, k2: v2}` 文字语法得到了增强，支持使用 `**`、模式匹配以及 `dict`
    推导式。'
- en: Beyond the basic `dict`, the standard library offers handy, ready-to-use specialized
    mappings like `defaultdict`, `ChainMap`, and `Counter`, all defined in the `collections`
    module. With the new `dict` implementation, `OrderedDict` is not as useful as
    before, but should remain in the standard library for backward compatibility—and
    has specific characteristics that `dict` doesn’t have, such as taking into account
    key ordering in `==` comparisons. Also in the `collections` module is the `UserDict`,
    an easy to use base class to create custom mappings.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本的 `dict`，标准库还提供了方便、即用即用的专用映射，如 `defaultdict`、`ChainMap` 和 `Counter`，都定义在
    `collections` 模块中。随着新的 `dict` 实现，`OrderedDict` 不再像以前那样有用，但应该保留在标准库中以保持向后兼容性，并具有
    `dict` 没有的特定特性，例如在 `==` 比较中考虑键的顺序。`collections` 模块中还有 `UserDict`，一个易于使用的基类，用于创建自定义映射。
- en: Two powerful methods available in most mappings are `setdefault` and `update`.
    The `setdefault` method can update items holding mutable values—for example, in
    a `dict` of `list` values—avoiding a second search for the same key. The `update`
    method allows bulk insertion or overwriting of items from any other mapping, from
    iterables providing `(key, value)` pairs, and from keyword arguments. Mapping
    constructors also use `update` internally, allowing instances to be initialized
    from mappings, iterables, or keyword arguments. Since Python 3.9, we can also
    use the `|=` operator to update a mapping, and the `|` operator to create a new
    one from the union of two mappings.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数映射中可用的两个强大方法是 `setdefault` 和 `update`。`setdefault` 方法可以更新持有可变值的项目，例如在 `list`
    值的 `dict` 中，避免为相同键进行第二次搜索。`update` 方法允许从任何其他映射、提供 `(key, value)` 对的可迭代对象以及关键字参数进行批量插入或覆盖项目。映射构造函数也在内部使用
    `update`，允许实例从映射、可迭代对象或关键字参数初始化。自 Python 3.9 起，我们还可以使用 `|=` 运算符更新映射，使用 `|` 运算符从两个映射的并集创建一个新映射。
- en: A clever hook in the mapping API is the `__missing__` method, which lets you
    customize what happens when a key is not found when using the `d[k]` syntax that
    invokes `__getitem__`.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 映射 API 中一个巧妙的钩子是 `__missing__` 方法，它允许你自定义当使用 `d[k]` 语法（调用 `__getitem__`）时找不到键时发生的情况。
- en: The `collections.abc` module provides the `Mapping` and `MutableMapping` abstract
    base classes as standard interfaces, useful for runtime type checking. The `MappingProxyType`
    from the `types` module creates an immutable façade for a mapping you want to
    protect from accidental change. There are also ABCs for `Set` and `MutableSet`.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections.abc` 模块提供了 `Mapping` 和 `MutableMapping` 抽象基类作为标准接口，对于运行时类型检查非常有用。`types`
    模块中的 `MappingProxyType` 创建了一个不可变的外观，用于保护不希望意外更改的映射。还有用于 `Set` 和 `MutableSet` 的抽象基类。'
- en: Dictionary views were a great addition in Python 3, eliminating the memory overhead
    of the Python 2 `.keys()`, `.values()`, and `.items()` methods that built lists
    duplicating data in the target `dict` instance. In addition, the `dict_keys` and
    `dict_items` classes support the most useful operators and methods of `frozenset`.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 字典视图是 Python 3 中的一个重要补充，消除了 Python 2 中 `.keys()`、`.values()` 和 `.items()` 方法造成的内存开销，这些方法构建了重复数据的列表，复制了目标
    `dict` 实例中的数据。此外，`dict_keys` 和 `dict_items` 类支持 `frozenset` 的最有用的运算符和方法。
- en: Further Reading
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: In The Python Standard Library documentation, [“collections—Container datatypes”](https://fpy.li/collec),
    includes examples and practical recipes with several mapping types. The Python
    source code for the module *Lib/collections/__init__.py* is a great reference
    for anyone who wants to create a new mapping type or grok the logic of the existing
    ones. Chapter 1 of the [*Python Cookbook*, 3rd ed.](https://fpy.li/pycook3) (O’Reilly)
    by David Beazley and Brian K. Jones has 20 handy and insightful recipes with data
    structures—the majority using `dict` in clever ways.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 标准库文档中，[“collections—Container datatypes”](https://fpy.li/collec) 包括了几种映射类型的示例和实用配方。模块
    *Lib/collections/__init__.py* 的 Python 源代码是任何想要创建新映射类型或理解现有映射逻辑的人的绝佳参考。David Beazley
    和 Brian K. Jones 的 [*Python Cookbook*, 3rd ed.](https://fpy.li/pycook3)（O’Reilly）第一章有
    20 个方便而富有见地的数据结构配方，其中大部分使用 `dict` 以巧妙的方式。
- en: 'Greg Gandenberger advocates for the continued use of `collections.OrderedDict`,
    on the grounds that “explicit is better than implicit,” backward compatibility,
    and the fact that some tools and libraries assume the ordering of `dict` keys
    is irrelevant—his post: [“Python Dictionaries Are Now Ordered. Keep Using OrderedDict”](https://fpy.li/3-18).'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: Greg Gandenberger 主张继续使用 `collections.OrderedDict`，理由是“显式胜于隐式”，向后兼容性，以及一些工具和库假定
    `dict` 键的顺序是无关紧要的���他的帖子：[“Python Dictionaries Are Now Ordered. Keep Using OrderedDict”](https://fpy.li/3-18)。
- en: '[PEP 3106—Revamping dict.keys(), .values() and .items()](https://fpy.li/pep3106)
    is where Guido van Rossum presented the dictionary views feature for Python 3\.
    In the abstract, he wrote that the idea came from the Java Collections Framework.'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '[PEP 3106—Revamping dict.keys(), .values() and .items()](https://fpy.li/pep3106)
    是 Guido van Rossum 为 Python 3 提出字典视图功能的地方。在摘要中，他写道这个想法来自于 Java 集合框架。'
- en: '[PyPy](https://fpy.li/3-19) was the first Python interpreter to implement Raymond
    Hettinger’s proposal of compact dicts, and they blogged about it in [“Faster,
    more memory efficient and more ordered dictionaries on PyPy”](https://fpy.li/3-20),
    acknowledging that a similar layout was adopted in PHP 7, described in [PHP’s
    new hashtable implementation](https://fpy.li/3-21). It’s always great when creators
    cite prior art.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '[PyPy](https://fpy.li/3-19)是第一个实现Raymond Hettinger提出的紧凑字典建议的Python解释器，他们在[“PyPy上更快、更节省内存和更有序的字典”](https://fpy.li/3-20)中发表了博客，承认PHP
    7中采用了类似的布局，描述在[PHP的新哈希表实现](https://fpy.li/3-21)中。当创作者引用先前的作品时，总是很棒。'
- en: At PyCon 2017, Brandon Rhodes presented [“The Dictionary Even Mightier”](https://fpy.li/3-22),
    a sequel to his classic animated presentation [“The Mighty Dictionary”](https://fpy.li/3-23)—including
    animated hash collisions! Another up-to-date, but more in-depth video on the internals
    of Python’s `dict` is [“Modern Dictionaries”](https://fpy.li/3-24) by Raymond
    Hettinger, where he tells that after initially failing to sell compact dicts to
    the CPython core devs, he lobbied the PyPy team, they adopted it, the idea gained
    traction, and was finally [contributed](https://fpy.li/3-25) to CPython 3.6 by
    INADA Naoki. For all details, check out the extensive comments in the CPython
    code for [*Objects/dictobject.c*](https://fpy.li/3-26) and the design document
    [*Objects/dictnotes.txt*](https://fpy.li/3-27).
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在PyCon 2017上，Brandon Rhodes介绍了[“字典更强大”](https://fpy.li/3-22)，这是他经典动画演示[“强大的字典”](https://fpy.li/3-23)的续集——包括动画哈希冲突！另一部更加深入的关于Python
    `dict`内部的视频是由Raymond Hettinger制作的[“现代字典”](https://fpy.li/3-24)，他讲述了最初未能向CPython核心开发人员推销紧凑字典的经历，他游说了PyPy团队，他们采纳了这个想法，这个想法得到了推广，并最终由INADA
    Naoki贡献给了CPython 3.6，详情请查看[*Objects/dictobject.c*](https://fpy.li/3-26)中的CPython代码的详细注释和设计文档[*Objects/dictnotes.txt*](https://fpy.li/3-27)。
- en: 'The rationale for adding sets to Python is documented in [PEP 218—Adding a
    Built-In Set Object Type](https://fpy.li/pep218). When PEP 218 was approved, no
    special literal syntax was adopted for sets. The `set` literals were created for
    Python 3 and backported to Python 2.7, along with `dict` and `set` comprehensions.
    At PyCon 2019, I presented [“Set Practice: learning from Python’s set types”](https://fpy.li/3-29)
    describing use cases of sets in real programs, covering their API design, and
    the implementation of [`uintset`](https://fpy.li/3-30), a set class for integer
    elements using a bit vector instead of a hash table, inspired by an example in
    Chapter 6 of the excellent [*The Go Programming Language*](http://gopl.io), by
    Alan Donovan and Brian Kernighan (Addison-Wesley).'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向Python添加集合的原因在[PEP 218—添加内置集合对象类型](https://fpy.li/pep218)中有记录。当PEP 218被批准时，没有采用特殊的文字语法来表示集合。`set`文字是为Python
    3创建的，并与`dict`和`set`推导一起回溯到Python 2.7。在PyCon 2019上，我介绍了[“集合实践：从Python的集合类型中学习”](https://fpy.li/3-29)，描述了实际程序中集合的用例，涵盖了它们的API设计以及使用位向量而不是哈希表的整数元素的集合类[`uintset`](https://fpy.li/3-30)的实现，灵感来自于Alan
    Donovan和Brian Kernighan的优秀著作[*The Go Programming Language*](http://gopl.io)第6章中的一个示例（Addison-Wesley）。
- en: IEEE’s *Spectrum* magazine has a story about Hans Peter Luhn, a prolific inventor
    who patented a punched card deck to select cocktail recipes depending on ingredients
    available, among other diverse inventions including…hash tables! See [“Hans Peter
    Luhn and the Birth of the Hashing Algorithm”](https://fpy.li/3-31).
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: IEEE的*Spectrum*杂志有一篇关于汉斯·彼得·卢恩的故事，他是一位多产的发明家，���申请了一项关于根据可用成分选择鸡尾酒配方的穿孔卡片盒的专利，以及其他包括…哈希表在内的多样化发明！请参阅[“汉斯·彼得·卢恩和哈希算法的诞生”](https://fpy.li/3-31)。
- en: ^([1](ch03.html#idm46582495507536-marker)) A virtual subclass is any class registered
    by calling the `.register()` method of an ABC, as explained in [“A Virtual Subclass
    of an ABC”](ch13.html#virtual_subclass_sec). A type implemented via Python/C API
    is also eligible if a specific marker bit is set. See [`Py_TPFLAGS_MAPPING`](https://fpy.li/3-2).
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.html#idm46582495507536-marker)) 通过调用ABC的`.register()`方法注册的任何类都是虚拟子类，如[“ABC的虚拟子类”](ch13.html#virtual_subclass_sec)中所解释的。如果设置了特定的标记位，通过Python/C
    API实现的类型也是合格的。请参阅[`Py_TPFLAGS_MAPPING`](https://fpy.li/3-2)。
- en: ^([2](ch03.html#idm46582504518496-marker)) The [Python *Glossary*](https://fpy.li/3-3)
    entry for “hashable” uses the term “hash value” instead of *hash code*. I prefer
    *hash code* because that is a concept often discussed in the context of mappings,
    where items are made of keys and values, so it may be confusing to mention the
    hash code as a value. In this book, I only use *hash code*.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch03.html#idm46582504518496-marker)) [Python *术语表*](https://fpy.li/3-3)中关于“可散列”的条目使用“哈希值”一词，而不是*哈希码*。我更喜欢*哈希码*，因为在映射的上下文中经常讨论这个概念，其中项由键和值组成，因此提到哈希码作为值可能会令人困惑。在本书中，我只使用*哈希码*。
- en: ^([3](ch03.html#idm46582504467472-marker)) See [PEP 456—Secure and interchangeable
    hash algorithm](https://fpy.li/pep456) to learn about the security implications
    and solutions adopted.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch03.html#idm46582504467472-marker)) 请参阅[PEP 456—安全和可互换的哈希算法](https://fpy.li/pep456)以了解安全性问题和采用的解决方案。
- en: ^([4](ch03.html#idm46582504125024-marker)) The original script appears in slide
    41 of Martelli’s [“Re-learning Python” presentation](https://fpy.li/3-5). His
    script is actually a demonstration of `dict.setdefault`, as shown in our [Example 3-5](#index_ex).
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch03.html#idm46582504125024-marker)) 原始脚本出现在Martelli的[“重新学习Python”演示](https://fpy.li/3-5)的第41页中。他的脚本实际上是`dict.setdefault`的演示，如我们的[示例3-5](#index_ex)所示。
- en: ^([5](ch03.html#idm46582493353744-marker)) This is an example of using a method
    as a first-class function, the subject of [Chapter 7](ch07.html#functions_as_objects).
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch03.html#idm46582493353744-marker)) 这是将方法作为一等函数使用的示例，是[第7章](ch07.html#functions_as_objects)的主题。
- en: ^([6](ch03.html#idm46582492823616-marker)) One such library is [*Pingo.io*](https://fpy.li/3-6),
    no longer under active development.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch03.html#idm46582492823616-marker)) 其中一个库是[*Pingo.io*](https://fpy.li/3-6)，目前已不再进行活跃开发。
- en: ^([7](ch03.html#idm46582498801968-marker)) The exact problem with subclassing
    `dict` and other built-ins is covered in [“Subclassing Built-In Types Is Tricky”](ch14.html#subclass_builtin_woes).
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch03.html#idm46582498801968-marker)) 关于子类化`dict`和其他内置类型的确切问题在[“子类化内置类型是棘手的”](ch14.html#subclass_builtin_woes)中有所涵盖。
- en: ^([8](ch03.html#idm46582498236432-marker)) That’s how tuples are stored.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch03.html#idm46582498236432-marker)) 这就是元组的存储方式。
- en: ^([9](ch03.html#idm46582498232544-marker)) Unless the class has a `__slots__`
    attribute, as explained in [“Saving Memory with __slots__”](ch11.html#slots_section).
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch03.html#idm46582498232544-marker)) 除非类有一个`__slots__`属性，如[“使用__slots__节省内存”](ch11.html#slots_section)中所解释的那样。
- en: ^([10](ch03.html#idm46582497899520-marker)) This may be interesting, but is
    not super important. The speed up will happen only when a set literal is evaluated,
    and that happens at most once per Python process—when a module is initially compiled.
    If you’re curious, import the `dis` function from the `dis` module and use it
    to disassemble the bytecodes for a `set` literal—e.g., `dis('{1}')`—and a `set`
    call—`dis('set([1])')`
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch03.html#idm46582497899520-marker)) 这可能很有趣，但并不是非常重要。加速只会在评估集合字面值时发生，而这最多只会发生一次Python进程—当模块最初编译时。如果你好奇，可以从`dis`模块中导入`dis`函数，并使用它来反汇编`set`字面值的字节码—例如，`dis('{1}')`—和`set`调用—`dis('set([1])')`。
